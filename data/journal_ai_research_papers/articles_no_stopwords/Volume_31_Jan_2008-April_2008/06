journal artificial intelligence

submitted published

exploiting subgraph structure
multi robot path
malcolm r k ryan

malcolmr cse unsw edu au

arc centre excellence autonomous systems
university south wales australia

abstract
multi robot path difficult due combinatorial explosion search
space every robot added complete search combined state space soon
becomes intractable present novel form abstraction allows
us plan much efficiently key abstraction partitioning
map subgraphs known structure entry exit restrictions
represent compactly becomes search much smaller space subgraph
configurations abstract plan found quickly resolved correct
possibly sub optimal concrete plan without need search prove
technique sound complete demonstrate practical effectiveness
real map
contending solution prioritised evaluated shown similar
performance albeit cost completeness two approaches necessarily
conflicting demonstrate combined single outperforms alone

introduction
many scenarios require large groups robots navigate around shared
environment examples include delivery robots office hada takase
warehouse everett gage gilbreth laird smurlo shipping yard alami fleury
herrb ingrand robert mine alarie gamache even virtual
armies computer wargame buro furtak case many robots
independent goals must traverse shared environment without colliding
one another path single robot usually consider
rest world static world represented graph called
road map path amounts finding path road map
reasonably efficient exist however multi robot scenario world
static must avoid collisions obstacles robots
centralised methods barraquand latombe treat robots single composite entity scale poorly number robots increases decoupled methods
lavalle hutchinson erdmann lozano perez first plan
robot independently resolve conflicts afterwards prove much faster incomplete many require robots deliberately detour optimal
path order let another robot pass even priority ordering used van den berg
overmars requiring low priority robots plan avoid high priority robots
found cannot solved priority ordering

c

ai access foundation rights reserved

firyan

realistic maps common structures roads corridors open spaces
produce particular topological features map constrain possible interactions robots long narrow corridor instance may impossible one robot
overtake another robots must enter exit first first order
hand large open space may permit many robots pass simultaneously
without collision
characterise features particular kinds subgraphs occurring
road map decompose map collection simple subgraphs
build plans hierarchically first movements one subgraph another
special purpose planners build paths within subgraph
propose abstraction limit considering
homogeneous group robots navigating shared road map identify particular
kinds subgraphs road map place known constraints ordering robots
pass use constraints make efficient
traversing kind subgraph combine local planners hierarchical
planner solving arbitrary
abstraction used implement centralised prioritised planners
demonstrate unlike heuristic abstractions method
sound complete used centralised search guaranteed
correct plan one exists guarantee cannot made prioritised search
used however two stage process means prioritised planner
abstraction often plans would available otherwise experimental
investigation shows effective maps sparsely connected
graph representations

formulation
assume work provided road map form graph
g v e representing connectivity free space single robot moving around
world e g vertical cell decomposition visibility graph lavalle
set robots r r rk shall consider homogeneous single map
suffices shall assume starting locations goals lie road map
shall assume map constructed collisions occur
one robot entering vertex v time another robot occupying entering
leaving vertex robots occupying vertices map affect movement
appropriate levels underlying control assumptions satisfied
real world
simple centralised computing plan proceeds follows first initialise
every robot starting position select robot move neighbouring vertex
checking first robot currently occupying vertex continue fashion selecting moving one robots step goal pseudocode
process shown code presented non deterministic choice points indicated choose operator backtracking required
fail command encountered practice search depth first
breadth first search necessary evaluate alternative paths presents



fiexploiting subgraph structure multi robot path

simple centralised
function plan g b

b

return hi

end

choose r r

select vf vf r

choose vt v vf v g

vt

fail

else

vf

vt r

return r vf vt plan g b

end
end function

build plan b graph g
nothing
choose robot
location
choose edge
destination occupied backtrack
move robot vf vt
recurse

complete search composite space gk g g g
k r robots eliminating vertices represent collisions robots
size composite graph given




fiv gk n pk


n
n k




k
fie g k e g n p k
k e g

n
n k

n v g k r running time depend
search used expected long moderately large values
n k

subgraph abstraction
consider shown figure road map contains vertices edges
robots plan according formulae composite
graph vertices edges small map
expanded large search human mind obvious lot
arrangements equivalent important exact positions robots
ordering
consider subgraph labeled x recognise subgraph stack robots
move subgraph last first lifo order robots inside
stack cannot change order without exiting entering stack
goal reverse order robots x know immediately cannot done
without moving robots stack enter opposite
order robots right order rearranging right positions


firyan



x

x


x

x

x













z

z

z

z

z

z

x

c

b

x

z

figure illustrating use subgraphs
trivial thus make distinction arrangement robots
specify exactly vertex robot occupies configuration stack
interested order
x vertices robots stack pm
possible arrangements total number arrangements


p p p p


terms deciding whether robot leave stack however need know
order need represent different configurations
stack
subgraphs z stacks applying analysis three
represent abstract state space different states possible
transitions states moving top robot one stack onto another
dramatically smaller composite map space
stack simple kind subgraph need larger collection canonical
subgraphs represent realistic key features looking follows
computing transitions subgraph require knowledge exact arrangement robots within subgraph abstract configuration
case order
two arrangements robots share configuration transforming one
done easily without search
therefore need done configuration space significantly
smaller
later introduce three subgraph types cliques halls rings
share properties readily found realistic first
need formalise ideas subgraph



fiexploiting subgraph structure multi robot path

definitions
section outline concepts use later complete formal
definition terms provided appendix along proof soundness
completeness subgraph process
given map represented graph g partition set disjoint subgraphs
sm subgraphs induced e edge exists two vertices
subgraph exists g
arrangement robots g partial function v g r
represents locations robots within g robot r vertex v write v r
speak arrangement robots within subgraph denote
arrangements lowercase roman letters b
configuration subgraph set equivalent arrangements robots within
two arrangements equivalent exists plan move robots one
without robots leaving subgraph denote configuration subgraph sx
cx configuration whole map represented tuple subgraph
configurations c cm
two operators operate configurations representing robot
entering leaving subgraph respectively robot r moves two subgraphs sx sy configurations change depending identity edge u v
robot traveled write
c x cx r u
c cy r v
complex subgraphs possible transition several possible configurations operators return sets possible transition
impossible particular configuration case operation returns empty
set
abstract plan defined sequence transitions intermediate
configurations every abstract plan two arrangements exists least one
corresponding concrete plan vice versa subgraph transitions concrete
plan must exist abstract plan equivalence arrangements configuration
guarantees existence intermediate steps see appendix complete
proof

subgraph
construct searches space abstract plans procedure much first compute configuration
tuple initial arrangement extend plan one step time step
consists selecting robot r moving subgraph currently occupies sx
neighbouring subgraph sy reduced graph x along connecting edge u v
transition possible plan step u v applicable may
number different configurations subgraph entered need choose
one create configuration tuple next step applicability test
selection subsequent configurations performed lines abstractplan


firyan

abstract plan extended step step fashion reaches configuration
tuple matches goal arrangement resulting abstract plan resolved
concrete plan transition abstract plan build two short concrete plans
one move robot outgoing vertex transition one make sure
incoming vertex clear subgraph appropriately arranged create subsequent
configuration since two plans separate subgraphs combined
parallel final step rearrange robots goal arrangement
done parallel subgraphs
abstractplan written non deterministic program including choicepoints search breadth first depth first search needed examine
possible set choices ordered fashion search complete
abstract plan guaranteed found one exists theorem
sound complete note resolution phase
planner entirely deterministic search needed abstract plan
found
subgraph methods
efficiency relies able compute several functions without
lot search
exit compute c r u testing possible robot exit subgraph
determining resulting configuration
enter compute c r v testing possible robot enter subgraph
determining resulting configuration
terminate compute b c testing possible robots subgraph
move terminating positions
resolveexit build plan rearranging robots subgraph allow one exit
resolveenter build plan rearranging robots subgraph allow one
enter
resolveterminate build plan rearranging robots subgraph
terminating positions
key efficient subgraph carefully constrain allowed structure
subgraphs partition functions simple implement
require expensive search advantage functions
computed arrangement robots within particular
subgraph relying positions robots elsewhere

subgraph structures
key process therefore selection subgraph types abstractions
need chosen


fiexploiting subgraph structure multi robot path

v

v

v

v

vk

v

stack

v

vk

b hall

v

v

v

v

v

v

v

v

c clique

ring

figure examples four different subgraph structures

commonly occurring real road maps
easy detect extract road map
abstract large portion search space
computing legality transitions fast sound complete
resolving abstract plan concrete sequence movements efficient
present four subgraph types stacks halls cliques rings satisfy
requirements following analysis let n number vertices
subgraph k number robots occupying subgraph action takes
place
stacks
stack figure represents narrow dead end corridor road map
one exit narrow robots pass one another robots must enter leave
last first order one simplest subgraphs occur often
real maps serves easy illustration subgraph methods formally
consists chain vertices linked predecessor successor
vertex one end chain called head connected subgraphs
entrances exits happen
configuration stack corresponds ordering robots reside
head robots stack cannot pass ordering cannot
changed without robots exiting entering stack



firyan

enter
robot enter stack long stack full one configuration created adding robot front ordering computation
done time
exit
robot exit stack top robot ordering one
configuration created removing robot ordering computation
done time
terminate
determine whether termination possible need check order robots
current configuration terminating arrangement operation
takes k time
resolveenter
rearranging robots inside stack simple since know ordering constant
vacate top stack possible entrance point move robots deeper
stack necessary guaranteed room since entering full stack
permitted worst takes k time
resolveexit
robot exits stack abstract planner already determined
first robot stack others head vertex simply move
stack head robots need moved worst
takes n time
resolveterminate
finally moving robots terminating positions done top bottom order
robot terminating position move upwards without interference
robot terminating position robots may need moved lower
order clear path sound since terminating positions
robots must stack else ordering would different process
nk total worst case running time
halls
hall generalisation stack figure b stack narrow corridor
permit passing hall may multiple entrances exits along
length formally consists single chain vertices one joined predecessor
successor must edges vertices hall may
edges connecting subgraphs node hall halls much
commonly occurring structures still maintain property stacks robots



fiexploiting subgraph structure multi robot path

j
v

v

v

v

v


v
b

c


j
v

v

v

v

v
b



v
c


j
v


v

v

v

b

v

v

c



figure example entering hall subgraph k n robot
enter three possible sequence positions j j

cannot reordered without exiting entering thus stacks configuration
hall corresponds order robots occupying one end hall

enter
robot enter hall long full configurations generated
entrance depend three factors size hall n number robots
already hall k index vertex enters ranging
n
figure shows entering hall several different configurations
matter robots already hall arranged left right
entrance entering robot moves enough space hall
side entrance vertex robot inserted point ordering
space limited example may possible move robots
one side another limiting possible insertion points
given three variables k n compute maximum minimum
insertion points
j min k
j max k n



firyan

creating configuration matter inserting robot
ordering appropriate point since list robots needs copied order
takes k time configuration
exit
whether robot exit hall via given edge depends several factors
size hall n number robots hall k index vertex
exits k index j robot ordering k exit
possible
j n k j
exit possible one resulting configuration previous ordering robot
removed takes k time compute
terminate
checking termination halls stacks test order
robots final arrangement matches current configuration done
k time k robots hall
resolveenter
resolve entrance hall need know subsequent configurations
aiming generate know proper insertion point entering robot
robots insertion point shuffled one direction one side
entry vertex rest side worst take nk time
resolveexit
resolving exit involves moving robot hall exit vertex shuffling
robots way worst case robots shuffle
one end hall takes nk time
resolveterminate
resolveterminate hall identical stack described
cliques
clique figure c represents large open area map many exit points
vertices around perimeter robots cross directly vertex another
long clique full robots inside shuffled way allow
happen
formally clique totally connected subgraph cliques quite different properties
halls stacks long least one empty vertex clique possible
rearrange arbitrarily configuration clique circumstance
set robots contains



fiexploiting subgraph structure multi robot path

however special set configurations clique locked
occurs number robots clique equals number vertices
impossible clique rearranged configuration locked clique
explicitly record position robot
enter
clique entered long full clique one
vacant vertex single configuration entering robot added
set occupants clique one space remaining entering robot locks
clique theory point necessary make configuration every
possible arrangement occupying robots entering robot vertex
enters
practice efficient create single locked configuration
records locking robot vertex leaves positions unspecified
permutation robots possible exact details configuration need
pinned next action exit terminate requires
form least commitment significantly reduce branching factor
search
performing test creating configuration takes k time k robots
clique
exit
clique unlocked robot exit vertex configuration
created simply removing robot set occupants
clique locked robot exit specific vertex occupies resulting configuration unlocked exact locations robots
discarded
least commitment version locking robot constrained exit vertex
every robot exit vertex except one occupied locking
robot
performing test creating configuration takes k time k robots
clique
terminate
unlocked configuration checking termination simply consists making sure
required occupants clique locked configuration
robots must terminating positions possibility rearranging
least commitment version locking robot must terminating vertex assume robots places thus
committing choice configuration delayed earlier
performing test takes k time k robots clique



firyan

resolveenter
entrance vertex occupied robot wishes enter simply move
occupant directly another vacant vertex clique since every vertex connected
every
least commitment entering robot locks clique need
look ahead plan see next action involving clique exit transition
need move exiting robot exit vertex clique locked
subsequent exit meaning robots terminating clique
need rearrange terminating positions point
amortise cost rearrangements subsequent call resolveexit
resolveterminate treat operation taking time
resolveexit
clique full time exit assume exiting robot already
exit vertex nothing needs done hand clique full
may robot exit vertex must moved exit vertex
already occupied another robot moved another unoccupied vertex
movements done directly clique totally connected operation
takes time
resolveterminate
clique locked assume robots already appropriately
arranged terminal positions work needs done otherwise
robots may need rearranged simple way proceed follows
robot place first vacate terminating position moving occupant
another unoccupied vertex move terminating robot vertex robot
moved way move process correct
may produce longer plans necessary upside takes n time
rings
ring figure resembles hall ends connected formally subgraph
vertices v v vn induced edges e satisfying
vi vj e iff j mod n
hall ordering important ring robots ring cannot pass one another
cannot order however rotate ordering provided
ring full thus ring size sequence hr r r equivalent
hr r r hr r r equivalent sequences represent configuration
cliques rings locked full locked ring cannot rotated
ring size three sequences hr r r hr r r equivalent
represent two locked configurations different properties



fiexploiting subgraph structure multi robot path

enter
robot may enter ring provided full k robots already
occupying ring k possible configurations one k
zero one possible insertion point
entering robot locks ring must record specific positions
robot ring still produce k different configurations
robots cannot arbitrarily rearranged unlike cliques
possible produce least commitment versions enter rings
cliques significantly reduce branching factor search
details involved wish enter
operation takes k time configuration generated
exit
ring locked robot exit recorded position otherwise
exit vertex robot removed sequence produce resultant
configuration configuration unlocked position information
discarded done k time k robots ring
terminate
check termination possible need see order robots around ring
terminal arrangement matches current configuration configuration
locked rotations allowed otherwise match must exact test
done k time k robots ring
resolveenter
robot enter ring need first rearrange entry
vertex empty nearest robots side vertex provide correct
insertion point subsequent configuration selected enter may
require shuffling robots one way another much fashion stack
hall worst case take nk operations k robots ring n vertices
resolveexit
ring locked robot exiting must already exit position nothing needs
done otherwise unlocked ring robots may need shuffled around
ring order move robot exit worst case take nk operations
k robots ring n vertices
resolveterminate
ring locked robots must already terminating positions
guaranteed abstract planner otherwise need rotated correct
positions one robot moved correct vertex rest ring
treated stack resolveterminate method described used
nk worst case running time k robots ring n vertices


firyan

summary
four subgraphs halls rings powerful subgraphs
common structured maps man made environments found often
purely random graphs consider shortest path unweighted graph hall
halls rings cliques significant size found many realistic
importantly structures well constrained enough six procedures
outlined implemented efficiently deterministically without
need search cases clique ring resolution methods
describe sometimes sacrifice path optimality speed could improved
smarter resolution planners since resolution stage done probably
would major effect overall running time planner

prioritised
common solution rapid growth search spaces multi robot prioritised
erdmann lozano perez van den berg overmars
give robots fixed priority ordering begin performed
priority ordering first plan built robot highest priority plan
second highest interfere first third
plan must constructed interfere plans
example implementation shown usually backtracking
plan made signified cut operator line
plan
cut search longer complete solutions
prioritised planner cannot figure example robots b wish
change positions plan robot easy plan contains one
step plan robots together requires move way
right hand side map pass prioritised planner
committed one step plan b cannot construct plan
robot interfere
incompleteness mistake however core makes prioritised efficient search space pruned significantly eliminating

x

x


x

x

b


figure simple cannot solved naive prioritised
goal swap positions robots b



fiexploiting subgraph structure multi robot path

certain plans consideration still viable solution within pruned space
often found much quickly hopefully cases
fails resort complete planner backup
prioritised subgraph
prioritised strictly competitor subgraph fact prioritised
search subgraph representation orthogonal ideas quite possible use
together plan constructed robot consecutively
rather building entire concrete plan abstract version produced
fashion earlier compatible abstract plans produced
every robot resolved concrete plan
well adding advantage abstraction prioritised subgraph
representation allows planner cover space possible plans
delaying resolution end avoid commitment concrete choices high
priority robot hamper later robots
illustrate lets return example figure partition
subgraph vertices x x x x hall x prioritised subgraph planner
solve abstract plan highest priority robot empty
nothing already goal subgraph given plan second highest
priority robot plan move x back plan produce
goal configuration required resolving plan move highest priority robot
x back needed plan built resolve methods halls
search
course thing free lunch example works choose
right partition instead treat x x stack x x separate hall
prioritised subgraph planner help us furthermore exist
one figure solved standard prioritised planners
fail introduce wrong subgraph abstraction difficult generate realistic

x

x

x



x
b



figure simple solved naive prioritised
subgraph abstraction goal swap positions robots
b priority ordering b subgraph planner choose robot
remain inside hall robot b trapped blocks
exit note edges x x directed



firyan

cases small numbers robots see section
occur number robots large

search complexity
let us consider carefully advantages subgraph decomposition lie subgraph transitions act macro operators one abstract state set
configurations another long history planners macros one kind
another advantages disadvantages well known see section
widely recognised macros advantageous reduce depth search
become disadvantage many macros created branching factor
search becomes large guidelines apply use subgraphs
typical search proceeds follows select plan frontier incomplete plans create expansions add expansions frontier recurse
complete plan found time taken complete search determined
number nodes search tree turn determined three factors
depth goal state
b average branching factor tree e number nodes generated per
node expanded
efficiency search
perfect search heads directly goal nevertheless contain bd
nodes alternative nodes must still generated even never followed
uninformed breadth first search hand generate bd nodes
regarded sensible upper bound efficiency search although possible
worse
macro operators tend decrease expense increasing b well
uninformed search dominates less advantage good heuristic exists
b equally important becomes important consider keep
increases branching factor minimum case subgraph
two main reasons b increases
reduced graph may larger average degree original since
subgraph contains many vertices tends going edges single
vertex edges connect different subgraphs branching factor
significantly larger sparse subgraphs halls worse regard
dense subgraphs cliques subgraph decomposition needs chosen
carefully avoid
single subgraph transition may create large number possible configurations
robot enters large hall already occupied several robots
cases may strictly matter configuration generated
possible use least commitment avoid creating unnecessary alternatives
possibility different configurations different outcomes



fiexploiting subgraph structure multi robot path

track need considered halls particular

see experiments follow careful choice subgraph decomposition important avoid pitfalls appropriate partition abstraction
significantly improve informed uninformed search

experiments
empirically test advantages subgraph ran several experiments
real randomly generated first experiment demonstrates
scale changes size terms number vertices
edges robots standard breadth first search second experiment shows
affected heuristic guide search experiments
use randomly generated graphs final experiment demonstrates
realistic
first two experiments maps generated randomly automatically partitioned subgraphs random generation done follows first spanning tree
generated adding vertices one one connecting randomly selected vertex
graph edges required generated randomly selecting two
non adjacent vertices creating edge edges undirected
automated partitioning worked follows
initially mark vertices unused
select pair adjacent unused vertices
use pair basis growing hall ring clique
hall randomly add unused vertices adjacent end hall provided
violate hall property continue growth possible
ring randomly add unused vertices adjacent end ring loop
created discard vertices involved loop
clique randomly add unused vertices adjacent every vertex clique continue growth possible
keep biggest three generated subgraphs mark vertices used
go back step adjacent unused pairs found
remaining unused vertices singletons
intended ideal far optimal fast
effective experience suggests partition generated contain
twice many subgraphs one crafted hand makes effort minimise
degree reduced graph even randomly generated partitions
advantages subgraph abstraction apparent
noted generate uniform distribution connected graphs
given size difficult generate sparse connected graphs uniform distribution
bias deemed significant



firyan


original
reduced





degree

subgraphs



































vertices



















vertices

figure automatic partitioning program experiment left
graph shows average number subgraphs generated right graph
shows average degree reduced graph

experiment scaling size
scaling v
first experiment investigate effect scaling number vertices
graph search time random graphs generated number vertices
ranging edges added average degree e v
equal value seems typical realistic maps one hundred graphs
generated size one partitioned method described
figure shows performance auto partitioning see number
subgraphs increased roughly linearly size graph average subgraph
size small graphs fewer vertices reduced graph partitioning
sparser original size increases average degree reduced graph
gets larger presented informative purposes make claims
quality partitioning indeed reducing
size graph small factor
graph three robots given randomly selected initial final locations
plan generated figure shows average run times four approaches shows clear performance hierarchy complete planners significantly
slower priority planners cases subgraph abstraction shows significant improvement naive alternative nevertheless every case combinatorial
growth runtime apparent note graph plotted log scale linear
relationship number vertices number subgraphs prevents subgraph
noted times overall rather slow acknowledge attribute
implementation java heavily optimised avoid garbage collection
currently working implementation optimised search engine believe
still provide valuable comparison methods



fiexploiting subgraph structure multi robot path





time ms






naive complete
naive priority
subgraph complete
subgraph priority
























vertices
run times

naive complete
naive priority
subgraph complete
subgraph priority



naive complete
naive priority
subgraph complete
subgraph priority





path length

branching factor





































vertices



















vertices

b branching factor

c goal depth

figure experiment graph boxes first third
quartile whiskers complete range experiment failed
complete due time memory limits incompleteness search run
time treated infinite value plotted cases
experiments failed graph c goal depth naive complete
subgraph priority approaches identical graphs vertices
lines overlap naive complete planner could solve
vertices



firyan

table number failures recorded two prioritised approaches experiment
failures
vertices naive subgraph













approaches better better partitioning ameliorate

analyse causes variation run times need consider search
process carefully measure search depth average branching factor b
experiment plotted figure b c expected
subgraph abstraction used goal depth decreased grows slowly
branching factor increased since uninformed search dominates
overall improvement time
incompleteness prioritised shows table three occasions
naive prioritised search failed available solutions however
prioritised subgraph search
scaling e
next examine effect graph density fixing number vertices
generated random graphs average degree ranging value
graphs randomly generated automatically partitioned
move three robots selected initial goal locations
experiment shown figure appear much
overall change run times approaches small improvement
naive prioritised planner graph gets denser figures b c
expected increasing density graph increases branching factor
decreases depth appears affect four approaches similarly
interesting difference however shown table records percentage
experiments prioritised planners unable solution
sparse graphs naive planner failed many improved
quickly density increased subgraph abstraction added planner able
solve two case solved
naive planner subgraph planner
scaling r
last scaling experiments investigate performs
varying numbers robots random graphs generated partitioned
vertices average degree one partitioned


fiexploiting subgraph structure multi robot path



time ms






naive complete
naive priority
subgraph complete
subgraph priority























degree
run times






naive complete
naive priority
subgraph complete
subgraph priority


path length

branching factor



naive complete
naive priority
subgraph complete
subgraph priority











































degree





degree

b branching factor

c goal depth

figure experiment b











firyan



time ms







naive complete
naive priority
subgraph complete
subgraph priority
























robots
run times
naive complete
naive priority
subgraph complete
subgraph priority



naive complete
naive priority
subgraph complete
subgraph priority






path length

branching factor










































robots




robots

b branching factor

c goal depth

figure experiment c











fiexploiting subgraph structure multi robot path

table number failures recorded two prioritised approaches experiment b
failures
degree naive subgraph

























table number failures recorded two prioritised approaches experiment c
failures
robots naive subgraph

























automatic partitioning ten set graph
number robots varying case initial goal locations selected
randomly
running times four approaches plotted figure major
performance difference prioritised non prioritised planners prioritised planners able handle twice many robots two complete search
approaches subgraph abstraction unnecessary overhead small
shows significant advantage number robots increases
less obvious advantage subgraph abstraction case prioritised
look failure rates shown table number robots
increases incompleteness naive prioritised begins become apparent
robots see could solved planner
advantage subgraph abstraction apparent total
could solved tried



firyan

figures b c plot average branching factor goal depth
previous experiments subgraph abstraction seen increase branching
factor decrease depth complete search approaches branching factor
grows rapidly number robots node search path contains choice
robot move prioritised reverses trend
ever done one robot time later robots much heavily constrained
options available providing fewer alternatives search tree
discussion
summarise experiments advantages subgraph abstraction twofold firstly decreases necessary search depth compressing
many robot movements single abstract step macro abstractions
expense increasing branching factor gains seem outweigh
losses practice course dependent degree use uninformed
search shall address
advantage specific prioritised planner tightly constrained sparse maps many robots incompleteness naive prioritised
search becomes significant issue addition subgraph abstraction
number failures dramatically reduced without additional search
experiment heuristic search
experiments far involved uninformed breadth first search without use
heuristic runtime strongly affected changes
search depth branching factor explained uninformed search
bd expected running time however perfect heuristic reduce bd
making branching factor much significant aspect perfect heuristic course
unavailable possible efficiently compute reasonably good search heuristic
task relaxing disregarding collisions simply compute sum
shortest path lengths robots location goal underestimate
actual path length accurate loosely constrained robots
dense graphs
experiment used best first search guided heuristic
every node search tree selected plan minimised value case
subgraph planner actual locations robots time point specified
subgraph occupy heuristic calculated maximum distances
vertex robots subgraph goal pre computed shortest path
distances every pair nodes running planner time
computation counted runtime
utility heuristic depends largely constrained
graph dense relatively robots heuristic direct planner
quickly goal however graph sparser interactions robots
become important heuristic less useful reason
used desire minimise length solution
solution quickly possible



fiexploiting subgraph structure multi robot path

concentrate attention experiment varying density graph affects
performance different approaches
random maps vertices generated average degree ranging
one hundred graphs generated size partitioned
described earlier figure shows original graph gets denser
number subgraphs decreases mostly possible create longer halls
good fewer subgraphs mean shorter paths consequential increase degree
adversely affect branching factor
ten robots placed randomly graph assigned random goal locations
four approaches applied resulting run times
plotted figure first thing apparent graph
distinction different approaches greatly reduced size graph
number robots much larger previous experiments
corresponding effect goal depth branching factor figure b c
run times much smaller clearly heuristic effective guiding search
average ratio search nodes expanded goal depth close
experiments slight increase constrained cases conclude
heuristic close perfect
compare four approaches see three distinct stages constrained case edges see subgraph approaches outperforming naive
small benefit prioritised search complete search edges
pattern changed two prioritised methods significantly better two
complete approaches number edges increases naive methods continue
improve prioritised subgraph search holds steady complete subgraph search
gets significantly worse due rapid increase branching factor edges
naive approaches significantly better subgraph approaches


singletons
halls
cliques
rings





original
reduced





degree

subgraphs











































edges



















edges

subgraphs

b degree

figure auto partitioner graphs experiment





firyan



time ms




naive complete
naive priority
subgraph complete
subgraph priority























edges
run times


naive complete
naive priority
subgraph complete
subgraph priority



naive complete
naive priority
subgraph complete
subgraph priority




path length

branching factor






























edges


edges

b branching factor

c goal depth

figure experiment







fiexploiting subgraph structure multi robot path

table number failures recorded two prioritised approaches experiment
failures
edges naive subgraph



















cause clearly seen figures b c branching factors subgraph
approaches increase significantly faster naive approaches corresponding
improvement goal depth sufficient outweigh cost
benefits subgraph abstraction highly constrained cases shown
failure cases table edges naive prioritised search unable solve
prioritised search subgraphs could solve number
failures fell quickly density graph increased
discussion
graph becomes moderately dense interactions robots become
total single robot paths measure becomes near perfect heuristic makes
branching factor much critical factor uninformed search
auto partitioning use poor job limiting factor
subgraph approaches perform poorly
better could achieved better decomposition clear whether
could found random graph without excessive computation certainly partitioning graphs hand easy task realistic graphs hand generally
shaped natural constraints e g rooms doors corridors make decomposition
much simpler see following experiment
experiment indoor map
figure shows map final two experiments floor plan level
k building university south wales road map vertices
edges drawn hand connecting offices open plan desk locations
imagined might used map delivery task involving team
medium sized robots
road map partitioned subgraphs cliques halls ring
plus remaining singleton nodes subgraphs containing one vertex average



firyan

figure map experiment vertices coloured subgraph



fiexploiting subgraph structure multi robot path


naive complete
naive priority
subgraph complete
subgraph priority

time ms














































robots

figure comparing run times experiment
degree reduced graph compared original partitioning done
hand aid interactive gui performed simple graph analysis
offered recommendations indicating nodes could added hall clique
user creating road map clearly laid partitioning mind
deciding partitioning whole difficult large open spaces generally
became cliques corridors became halls rings foyer area around vertex
caused particular trouble finding ideal partitioning due slightly unusual
topology
series experiments run world varying number robots
experiment runs performed robot placed
random office desk required make delivery another random office
desk chosen without replacement two robots goal plans built
complete prioritised planners without subgraph abstraction
four approaches utilised total single robot shortest path heuristic previous
experiment running times shown figure
see small numbers robots naive approaches significantly better subgraph approaches overhead subgraph search
outweighs disadvantages simple number robots increases
subgraph methods take around robots subgraph methods
significant better naive robots combination complete
search subgraphs begins perform less well two prioritised approaches
best performers considerable advantage subgraph
comparison auto partitioner yielded partition fewer subgraphs avg higher
degree avg
curious empty rooms centre map near vertex bathrooms
consider robots would need make deliveries



firyan

naive complete
naive priority
subgraph complete
subgraph priority




expanded path

























robots

figure assessing quality heuristic experiment value plotted
ratio number expanded nodes search tree goal depth
perfect heuristic yields value

considering search complexity let us first examine performance heuristic
figure plots ratio average number expanded nodes search tree
goal depth perfect heuristic value experiment
robots robots heuristic begins become inaccurate
inaccuracy seems affect complete planners badly prioritised ones
cases subgraph seriously affected naive
explain difference note heuristic contains significantly less
information subgraph search naive search know exactly
robot within subgraph assume worst possible position
means value configuration tuple solely allocation robots
subgraphs particular configurations subgraphs hall subgraphs
particular may several different configurations set robots
assigned heuristic value despite significantly different real distances
goal creates plateau heuristic function broadens search large
numbers robots permutations become significant factor search improve
heuristic need way distinguish value different configurations
subgraph probably require extra method specific subgraph structure
graphs branching factor goal depth figure come
expect branching factor larger complete search prioritised search
subgraph abstraction makes worse significantly branching factor prioritised


fiexploiting subgraph structure multi robot path

naive complete
naive priority
subgraph complete
subgraph priority



naive complete
naive priority
subgraph complete
subgraph priority



path length

branching factor


































robots
















robots

branching factor

b goal depth

figure branching factor goal depth experiment
table number failures recorded two prioritised approaches experiment
failures
edges naive subgraph










search increase robots added step plan
one robot moved goal depth shows opposite pattern complete searches
shorter prioritised searches subgraph abstraction approximately halves
search depth cases
failure rates recorded table story different previous
experiments naive prioritised planner able solve every depth
adding subgraph abstraction caused small number failures complex
clear caused reversal cases involved complex
elude analysis warrants investigation
discussion
experiment shown realistic appropriately chosen set
subgraphs subgraph abstraction effective way reduce search even
good heuristic available subgraph abstraction work well
example compared random graphs experiment answer seems found
degree reduced graph automatically partitioning random graph significantly
increases degree saw figure b turn increases branching factor
thus search time



firyan

contrast partition realistic map decreased degree graph
hand automatically branching factor subgraph
methods still larger one transition still create multiple configurations
effect reduced enough overcome decrease goal depth indication
realistic map structure exploited abstraction
investigation warranted characterise features many possible

conclusion
demonstrated kind abstract representation multi robot path
allows much faster without sacrificing completeness decomposing
road map subgraphs simple intuitive way providing background knowledge
planner efficiently exploited key subgraph structures
allow us treat many arrangements robots equivalent configurations compute
transitions configurations quickly deterministically described
four structures stacks halls cliques rings structures
simple enough compute configurations easily common enough found
many realistic maps
shown abstract plans subgraphs resolved deterministically
concrete plans without need search planner sound complete
although plans produced necessarily optimal future work could prove
worth spending time resolution phase trim unnecessarily wasteful plans
example simulated annealing sanchez ramos frausto may
time saved abstract leaves us space clever resolution
conventional solution search space explosion multi robot prioritisation shown subgraph competitive
prioritised combination two methods powerful still
cases partly alleviates incompleteness prioritised
related work
abstraction hierarchical decomposition standard techniques
related search use macro operators dates back far sacerdotis early
work abstrips system sacerdoti introduced abstraction
hierarchies whereby could first solved high level abstraction
ignoring lower level details idea expressed many different ways
history far many review detail present work particularly
inspired generic types long fox similarly detected
substructures task solved structure specific planners
hierarchical applied path abstractions
approximate cell decomposition barbehenn hutchinson conte zulli
generalised voronoi graphs choset burdick choset general ad hoc
hierarchical maps bakker zivkovic krose zivkovic bakker krose
structures identified examples carry well multi robot
scenario



fiexploiting subgraph structure multi robot path

faster solutions multi robot available assume
existence garage locations robot lavalle hutchinson kinds
temporary free space sharma aloimonos fitch butler rus
method present makes assumption thus general application
appear previous work provides complete abstraction
planner general multi robot
work bears similarity explicitly robot path
solving sokoban puzzle botea muller schaeffer junghanns schaeffer domain significantly constrained map necessarily
orthogonal grid stones move pushed man
method employ similar dividing map rooms tunnels use
strongly connected component identify equivalent arrangements boulders subpart equivalent arrangements treated single abstract state
corresponding configuration formulation used state global
search particular structures represent different general ideas partitioning independent local subproblems identifying abstract states strongly
connected components employed work
future plans
next stage project plan examine symmetries provided subgraph
representation recent work symbolic task porteous long fox
shown recognising exploiting symmetries almost symmetries
eliminate large amounts search subgraph configurations provide natural
ground similar work domain expect similar improvements
possible
plan investigate automatic subgraph partitioning
maps identified importance trading path depth branching
factor plan make partitioning chooses subgraphs optimise
relationship automatically finding optimal partition could hard creating
powerful interactive partitioning tool human operator would seem viable
compromise one would adapt auto partitioner describe
seed vertices selected user allowed choose
number possible subgraphs selection
subgraph structures identified currently working
formalising properties tree structured subgraphs another possibility would
generalise cliques rings ring chords structure although characterising
structure may prove difficult
many advances search technology may applicable
multi robot currently process expressing
entire constraint satisfaction csp gecode constraint engine
gecode team believe csp formulation powerful way take
advantage structural knowledge subgraph decomposition represents

acknowledgments


firyan

id thank jonathan paxman brad tonkes maurice pagnucco help
developing ideas proofreading drafts

appendix proof soundness completeness
appendix set necessary formal definitions prove soundness
completeness abstract process main theorem showing
abstract plan exists given concrete plan exists
graphs subgraphs
induced subgraph g graph v e
v v g

e u v u v v u v e g

intuitively describes subgraph consisting subset vertices connecting edges parent graph thus induced subgraph specified solely
terms vertices shall henceforth assume subgraphs refer induced
partition p g set sm subgraphs g satisfying

v g
v si

v si v sj j j


given graph g partition p construct reduced graph x g
contracting subgraph single vertex
v x p
e x si sj x si sj x g
robots arrangements
let us assume set robots r arrangement robots graph g
partial function v g r arrangement represents locations robots
within g v r robot r vertex v shall use notation v
indicate undefined v e vertex v unoccupied arrangement may
necessarily include every robot r two arrangements b said disjoint
range range b let ag represent set arrangements r g
subgraph g arrangement r g define
induced arrangement r
v v v v
disjoint subgraphs g disjoint arrangements
define combined arrangement arrangement
satisfying

v v
v
v v



fiexploiting subgraph structure multi robot path

lemma arrangement g partition p sm
set induced arrangements ai si combined arrangement

given identity uniquely identify arrangement g combination
induced arrangements partition p
concrete plans
need define means move robots around graph first define
two operators respectively add remove robots given arrangement
formally ag r v g ag mapping satisfies
g

r v b
g




r
b u
u

u v
otherwise

similarly ag r ag mapping satisfies
g

r b
g





b u
u

u r
otherwise

omit subscript g clear context
define plan step r e g g robot edge pair r u v
representing movement r along edge u v u v plan step
applicable arrangement ag iff u r v case apply
produce arrangement b
r r v
concrete plan plan g ag b ag sequence plan steps
hs sl exist arrangements al ag si applicable ai


al b
ai si ai l
lemma subgraph g p plan p plan g
lemma p plan g b q plan g b c
concatenation p q written p q plan g c


firyan

lemma let p kq denote set interleavings sequences p q let
disjoint subgraphs g p plan b p plan
b disjoint arbitrary interleaving p p kp plan
g b b
configurations
defined machinery concrete plans introduce abstraction key
idea configuration abstraction arrangements robots
subgraph rearranged one arrangement another without robots
leave subgraph rearrangement two arrangements
treated equivalent configurations represent sets equivalent arrangements
subgraph example stack subgraph configuration set arrangements
ordering robots arrangement entire partitioned graph
abstracted list configurations produces subgraphs
formally define configuration relation graph g equivalence relation
g

ag b iff exists plans pab pba g b b
g

respectively
configuration c g equivalence class write c represent
g

g

equivalence class containing arrangement let cg set configurations
g
lemma b range range b
g

given identity unambiguously define range configuration c
range c range c
extend definitions configurations c cg
configuration g r r v v g


c r v r v c v
g
g
g


c r v r c v r
g

g

g

note map configurations sets configurations
given partition p sm g corresponding set configuration
relations define configuration tuple r g tuple c cm


sm

ci csi


range ci r



range ci range cj j j
astute readers notice c r v never contains one element although may
g

empty



fiexploiting subgraph structure multi robot path

configuration tuple represents abstract state robots entire graph
terms configurations individual subgraphs partition given arrangement g construct corresponding configuration tuple c cm
ci si conversely si ci ci write
si

lemma b arrangements graph g partition sm
configuration tuple g b exists plan b g
proof
let ai si bi b si ai ci bi ci
ai bi therefore definition exists plan pi ai bi si
si

let p p k kpm since pi plans disjoint subgraphs p plan
b bm b required

abstract plans
configuration tuples abstract state representation define abstract
plans sequences subgraph transitions plan steps move robot one
subgraph another prove main section abstract
plan exists corresponding concrete plan exists allow
us later prove soundness completeness subgraph
rest section shall assume graph g partition p
sm corresponding configuration relations


sm

subgraph transition transition plan step r u v u sx
v sy sx sy transition r u v applicable configuration tuple
c cm g
cx r u u sx
sx

cy r v v sy
sy

robots sx rearranged robot r leave via u robots
sy rearranged v empty r enter
transition r u v applicable c cm u sx v sy
apply compute set configuration tuples
c c

c x cx r u
sx



c

cy r v

c z

cz otherwise

sy

lemma arrangement g partition sm transition
r u v applicable applicable



firyan

proof let sx sy disjoint subgraphs partition u sx v sy let
ax sx ay sy let c cm
ax cx
ax u r
cx r u
similarly
ay cy
ay v
cy r v
therefore applicable
let b b c c
c x b sx
sx

ax r
sx

cx r u

c b sy
sy

ay r v
sy

cy r v

c z cz
therefore b required



lemma r u v u v sx e transition arrangement g applicable
proof
let b let ai si bi b si let
c cm b c c
plan px hsi plan ax bx sx ax bx implying cx c x
z x az bz cz c z therefore b required




fiexploiting subgraph structure multi robot path

define abstract plan arrangement g tuple
sequence configuration tuples h l sequence plan steps
hs sl

l
si applicable

theorem abstract plan g exists exists corresponding concrete plan p g
proof case p
let abstract plan g h l
hs sl let ci cim
shall construct concrete plan
p p hs p pl hsl pl
pi concrete plan ai bi satisfying

bl
ai bi
si applicable bi
ai si bi l
proposition ai bi exist satisfying conditions l
proof induction
therefore exists
assume ai exists
let si r u v u sx v sy definition abstract plan
si applicable si therefore
ci
cix r u
x
n


ci



r
u

u

r


c
x
x
cix u r
set bix equal
ci
bix r u
x
bix r u ci
x



firyan


ci
ciy r v

n


ci



r
v

v




c


ciy v
set biy equal
ci
biy r v

biy r v ci

set biz ai sz z
x
bij defined every subgraph sj partition g therefore bi bi bim
exists arrangement g
ai exists bi exists l
si applicable bi since
bi u bix u r
bi v biy v
ai si bi exists
ai sx bix r ci
x
ai sy biy r v ci

ai sz biz z
x ciz
ci
z

ai
induction ai exists l bi exists l
furthermore bl l bi exists l required

proposition concrete plan pi ai bi exists l
proof

since ai bi plan pi must exist ai bi lemma



proposition p concrete plan g
proof
pi plan ai bi l furthermore ai si bi
hsi plan bi ai therefore concatenation plans
p p hs hsl pl
plan g bl required




fiexploiting subgraph structure multi robot path

case p
let p hs sl concrete plan g wish construct
abstract plan g
let ht tl increasing sequence integers ti iff st
subgraph transition note capital l designate length concrete
plan p lowercase l designate number transitions plan
length corresponding abstract plan
construct sequence arrangements h l

si l
split subsequences al



ai ti ti
define ti l h l hst stl
proposition ai
proof induction
definition
ti ti
assume ti j j ai need prove
let st r u v since
must u v sx lemma
st


therefore induction
ai
required



proposition valid abstract plan
proof
first check initial final configuration tuples contain
respectively


al
l
l



firyan

l let bi ti e final element ai let
bi sz z
let sti r u v u sx v sy applicable bi
definition p therefore lemma applicable

biz

ai
bi
bi required

therefore valid abstract plan



theorem significant tells us need
perform search concrete plans instead need search abstract plan
convert concrete form search succeed concrete
plan exists

references
alami r fleury herrb ingrand f robert f multi robot cooperation
martha project robotics automation magazine ieee
alarie gamache overview solution strategies used truck dispatching systems open pit mines international journal surface mining reclamation environment
bakker b zivkovic z krose b hierarchical dynamic programming robot
path proceedings ieee rsj international conference intelligent
robots systems
barbehenn hutchinson efficient search hierarchical motion
dynamically maintaining single source shortest paths trees ieee transactions
robotics automation
barraquand j latombe j c robot motion distributed representation international journal robotics
botea muller schaeffer j abstraction sokoban
computers games lecture notes computer science vol pp
springer
buro furtak rts games real time ai proceedings
behavior representation modeling simulation conference brims arlington
va
choset h sensor motion hierarchical generalized voronoi
graph ph thesis california institute technology pasadena california
choset h burdick j sensor generalized voronoi graph
proceedings international conference robotics utomation



fiexploiting subgraph structure multi robot path

conte g zulli r hierarchical path multi robot environment
simple navigation function ieee transactions systems man cybernetics

erdmann lozano perez multiple moving objects tech rep
ai laboratory
everett h gage gilbreth g laird r smurlo r real world issues
warehouse navigation proceedings spie conference mobile robots ix

fitch r butler z rus reconfiguration heterogeneous selfreconfiguring robots proceedings ieee rsj international conference intelligent robots systems
gecode team gecode generic constraint development environment available
http www gecode org
hada takase k multiple mobile robot navigation indoor global
positioning system igps proceedings ieee rsj international conference
intelligent robots systems
junghanns schaeffer j sokoban enhancing general single agent search
methods domain knowledge artificial intelligence
lavalle cambridge university press
lavalle hutchinson optimal motion multiple robots
independent goals ieee transactions robotics automation
vol
long fox generic types chap pp morgan
kaufmann
porteous j long fox identification exploitation almost
symmetry brown k ed proceedings rd uk
scheduling sig
sacerdoti e hierarchy abstraction spaces artificial intelligence

sanchez g ramos f frausto j locally optimal path
probabilistic road maps simulatead annealing proceedings iasted international conference robotics applications
sharma r aloimonos coordinated motion warehousemans
constraints free space ieee transactions systems man
cybernetics
van den berg j overmars prioritized motion multiple robots
proceedings ieee rsj international conference intelligent robots systems pp
zivkovic z bakker b krose b hierarchical map building visual landmarks geometric constraints proceedings ieee rsj international conference
intelligent robots systems


firyan

zivkovic z bakker b krose b hierarchical map building
graph partitioning ieee international conference robotics automation



fiexploiting subgraph structure multi robot path

subgraph abstraction
function plan g p r b



b

abstractplan g p r

p resolve g p b

return p
end function

build plan b g partition p
get initial configuration
get final configuration
build abstract plan
resolve concrete plan

function abstractplan g p r build abstract plan g p



return hi hi
done

end

c cm

choose r r
choose robot

select x r range cx
subgraph occupies

choose sy p sx sy x
choose neighbouring subgraph

choose u v e g u sx v sy
choose connecting edge
choose resulting configurations sx sy

choose c x cx r u

choose c cy r v

c c x c cm
construct configuration tuple

abstractplan g p r
recurse



r u v

return
end function
function resolve g p b
resolve abstract plan concrete plan



h l

hs sl

p hi



l

r u v si
next transition

c c
target configurations

sx u sx

sy v sy

aiz ai sz z

pxi bix sx resolveexit aix r u c x
rearrange sx let robot r exit
rearrange sy let robot r enter

pyi biy sy resolveenter aiy r v c

p p pxi pyi

bi ai bix biy aim

ai si bi

p p hsi
add transition

end

z

tz sz resolveterminate al sz b sz
rearrange sz final arrangement

end

p p tm

return p
end function



firyan

simple prioritised
function plan g b

v v g
initial arrangement robots


b v v g
b final arrangement robots

k

v ri v v ri

b v ri v b v ri

p pi planone g ri hp pi h b
build plan

cut
backtrack plan

end

return p
end function

r ri
r ri

r ri
found

function planone g ri hp pi ht ti b

b

return hi hi
done

end

choose rj r j
choose robot move

j

select vf vf ri

choose vt v vf v g
choose action ri

else

r vf vt pj tj
select old action rj pj

tj tj

end

vt

fail
backtrack destination occupied

end

vf
move robot

vt r

p pi planone g ri hp pi ht ti b
recurse

p rj vf vt p
add step global plan

j

pi ri vf vt pri
add step ri plan

end

return p pi
end function




