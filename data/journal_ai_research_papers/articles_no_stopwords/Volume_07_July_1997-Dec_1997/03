journal artificial intelligence

submitted published

identifying hierarchical structure sequences
linear time
craig g nevill manning
ian h witten
department computer science
university waikato hamilton zealand

cgn cs waikato ac nz
ihw cs waikato ac nz

abstract
equitur infers hierarchical structure sequence discrete symbols
replacing repeated phrases grammatical rule generates phrase continuing
process recursively hierarchical representation original sequence
offers insights lexical structure driven two constraints reduce
size grammar produce structure product equitur breaks ground
operating incrementally moreover methods simple structure permits proof operates
space time linear size input implementation process
symbols per second applied extensive range real world sequences

introduction
many sequences discrete symbols exhibit natural hierarchical structure text made
paragraphs sentences phrases words music composed major sections motifs bars
notes records user interface behavior encode hierarchical structure tasks users
perform computer programs constitute modules procedures statements discovering
natural structure underlies sequences challenging interesting wide
range applications phrase discovery music analysis programming
demonstration code optimization
search structure sequences occurs many different fields adaptive text
compression seeks sequences used predict upcoming symbols
encoded efficiently bell et al however text compression
extremely opaque illuminate hierarchical structure sequence grammatical
inference techniques induce grammars set example sentences possibly along set
negative examples gold angluin berwick pilato however
crucial operation input continuous stream segmented sentences
effect independent examples structure sought brief review
pertinent systems appears section techniques markov modeling hidden markov
modeling make attempt abstract information hierarchical form rabiner juang
laird saul sequence learning occurs areas automaton modeling
gaines adaptive systems andreae programming demonstration cypher
human performance studies cohen et al generally plays peripheral
role
describe sequitur infers hierarchical structure
sequence discrete symbols basic insight phrases appear
replaced grammatical rule generates phrase process
continued recursively producing hierarchical representation original sequence
ai access foundation morgan kaufmann publishers rights reserved

finevill manning witten

strictly grammar rules generalized generate one string
provide good basis inferring grammar beyond scope
scheme resembles one developed arose work language acquisition wolff
operated time quadratic respect length
input sequence whereas describe takes linear time let us investigate
sequences containing several million tokensin previous work examples much smaller
largest mentioned thousand tokens another difference crucial
importance practical applications works incrementally
return wolffs scheme compare sequitur section
ability deal easily long sequences greatly extended range sequiturs
application applied artificially generated fractal sequences produced lsystems along unification rule generalizer used recover original lsystem method inferred relatively compact deterministic context free grammars
million symbol sequences representing biological objects obtained stochastic contextsensitive l systems turn greatly speeded graphical rendering objects
applied sequitur mbyte segments digital library generate hierarchical
phrase indexes text provides novel method browsing nevill manning et al
compresses multi megabyte dna sequences effectively
general purpose compression finally post processing elicited
structure two million word extract genealogical database successfully identifying
structure database compressing much efficiently best known
touch applications section nevill manning
describes
describes sequitur evaluates behavior next section
gives concise description terms constraints form output
grammar section gives taste kind hierarchies sequitur capable inferring
realistic sequences section describes implementation detail particular
emphasis achieves efficiency section shows run time storage
requirements linear number input symbols section discusses
behavior extreme input strings end quantitative analysis sequiturs
performance several example sequences review related

sequitur
sequitur forms grammar sequence repeated phrases sequence
repetition gives rise rule grammar repeated subsequence replaced nonterminal symbol producing concise representation overall sequence
pursuit brevity drives form maintain grammar byproduct provide hierarchical structure sequence
left figure sequence contains repeating string bc note
sequence already grammara trivial one single rule compress sequitur forms
rule bc replaces occurrences bc grammar appears right
figure
sequence figure b shows rules reused longer rules longer
sequence consists two copies sequence figure since represents exact



fii nferring sequential structure sequences

repetition compression achieved forming rule abcdbc replace halves
sequence gains made forming rule b bc compress rule
demonstrates advantage treating sequence rule part grammarrules may
formed rule analogous way rules formed rule rules within rules
constitute grammars hierarchical structure
grammars figures b share two properties
p pair adjacent symbols appears grammar
p every rule used
property p requires every digram grammar unique referred
digram uniqueness property p ensures rule useful called rule utility
two constraints exactly characterize grammars sequitur generates
figure c shows happens properties violated first grammar contains
two occurrences bc p hold introduces redundancy bc appears twice
second grammar rule b used p hold removed
grammar would become concise grammars figures b ones
properties hold sequence however unique grammar
properties example sequence figure represented
grammars right obey p p deem grammar acceptable
repetitions cannot overlap string aaa give rise rule despite containing two
digrams aa
sequiturs operation consists ensuring properties hold describing
properties act constraints operates enforcing constraints
grammar digram uniqueness constraint violated rule formed
rule utility constraint violated useless rule deleted next two subsections describe
occurs
digram uniqueness
sequitur observes symbol appends rule last two symbols rule
symbol predecessorform digram digram occurs elsewhere
grammar first constraint violated restore rule formed digram
right hand side headed non terminal symbol two original digrams
replaced non terminal symbol
sequence

grammar



abcdbc

aada
bc

c

abcdbcabcdbc

aa
abcdbc

sequence

grammar

b

abcdbcabcdbc

aa
abdb
b bc



aabaaab

aaa
aab

cc
bc
b aa
c bda

abaab
aa

figure example sequences grammars reproduce
sequence one repetition b sequence nested repetition c
two grammars violate two constraints two different grammars
sequence obey constraints



finevill manning witten

table shows grammars successive symbols sequence
abcdbcabcd processed second column shows sequence observed far third
column gives grammar created sequence fourth column notes constraints
violated actions taken resolve violations
sequitur adds final c symbol digram bc appears twice sequitur creates
rule bc right hand side replaces two occurrences bc
illustrates basic procedure dealing duplicate digrams
appearance duplicate digram rule digram
appears right hand side existing rule rule need created nonterminal symbol heads existing rule replaces digram symbol table
third bc appears existing non terminal symbol replaces third occurrence bc
pair repeating digrams aa shown next line table sequitur
accordingly forms rule b replaces two occurrences aa sequitur creates
maintains hierarchy iterative process substitution bc
digram aa replaced b larger sequences changes ripple
grammar forming matching longer rules higher hierarchy
symbol
number

string
far

resulting
grammar

remarks





sa



ab

ab



abc

abc



abcd

abcd



abcdb

abcdb



abcdbc

abcdbc

bc appears twice

aada
bc

enforce digram uniqueness



abcdbca

aadaa
bc



abcdbcab

aadaab
bc



abcdbcabc

aadaabc
bc

bc appears twice

aadaaa
bc

enforce digram uniqueness
aa appears twice

bdab
bc
b aa

enforce digram uniqueness

bdabd
bc
b aa

bd appears twice

cac
bc
b aa
c bd

enforce digram uniqueness
b used

cac
bc
c aad

enforce rule utility



abcdbcabcd

table operation two grammar constraints
digram uniqueness rule utility



fii nferring sequential structure sequences

rule utility
right hand sides rules grammar two symbols long longer
rules formed effect rule utility constraint ensures every rule used
table symbol demonstrates idea appended rule
digram bd causes rule c formed however forming rule leaves one
appearance rule b violating second constraint reason b removed
grammar right hand side substituted one place occurs removing b
means rule c contains three symbols mechanism forming long rules
form short rule temporarily subsequent symbols continue match allow rule
supersede shorter one delete latter although creation deletion rules
appears inefficient first glance performed efficiently appropriate data
structures importantly keeps track long matches within grammar obviating
need external data structures simplifies considerably permitting concise
proof linear time complexity see section

structures inferred realistic sequences
described mechanism sequitur builds grammar embarking
efficiency issues instructive consider structures simple technique infer
realistic sequences case applied sequitur large sample excerpted
part structure illustrative purposes
figures b c parts three hierarchies inferred text bible
english french german hierarchies formed without knowledge preferred
structure words phrases nevertheless capture many meaningful regularities
figure word beginning split begin ninga root word suffix many words
word groups appear distinct parts hierarchy spaces made visible
replacing bullets produces french version figure b
commencement split analogous way beginninginto root commence
suffix ment words au dieu cieux distinct units hierarchy
german version figure c correctly identifies words sentence well phrase
die himmel und die fact hierarchy heaven figure bears
similarity german equivalent
london oslo bergen corpus johansson et al contains million words tagged
word classes example sentence labour sentiment would still favour
abolition house lords tagged classes determiner noun noun auxiliary adverb
verb article noun preposition article noun preposition noun hierarchy sequitur infers
word classes corresponds possible parse sentence corpus
tree expressed terms parts speech figure shows part inferred hierarchy
tags replaced actual words text sequitur identifies middle
part sentence sentiment would still favour abolition large block part could
stand grammatical sentence adjectival phrase house lords
appears distinct unit labour adjectival phrase precedes subject
figure e shows two bach chorales sequitur detected internal
repetitionsthe light gray boxes two halves first chorale almost
identicaland repetitions chorales denoted gray box second half



finevill manning witten



n h e b e g n n n g g c r e e h e h e v e n n h e e r h

b

u c e n c e e n e u c r l e c e u x e l e r r e

c

xx

n f n g c h u f g e h e l u n e e r e



labour sentiment would still favour abolition house lords

e

imperfect

perfect

figure hierarchies sequences genesis english b french c german
grammatical parse inferred sequence word classes e repetitions within
two chorales harmonized j bach
second chorale section white box occurs four halves detecting repeated
motifs many chorales sequitur identifies imperfect perfect cadences end
first second halves respectively general sequitur capable making plausible
inferences lexical structure sequences hierarchies produces aid comprehension
sequence

implementation issues
sequitur operates enforcing digram uniqueness rule utility constraints
essential violation constraints detected efficiently section
describe mechanisms fulfill requirement
choice appropriate data structure depends kind operations need
performed modify grammar sequitur
appending symbol rule
existing rule
creating rule
deleting rule
appending symbol involves lengthening rule existing rule involves substituting
non terminal symbol two symbols thereby shortening rules containing digrams
creating rule involves creating non terminal symbol left hand side


fii nferring sequential structure sequences



b

c

b



b


cd
digram
bc
index
ab

figure data structures rules digram index
inserting two symbols right hand side creating rule substitutions made
existing rule replacing two digrams non terminal symbol deleting
rule involves moving contents replace non terminal symbol lengthens rule
containing non terminal symbol left hand side rule must deleted
ensure rules lengthened shortened efficiently sequitur represents rule
doubly linked list whose start end connected single guard node shown
two rules b figure guard node serves attachment point left hand
side rule remains constant even rule contents change nonterminal symbol points rule heads shown figure pointer nonterminal symbol b rule head rule b pointers arrays necessary
accessing rules symbols operations affect adjacent symbols rules headed
non terminal
rule utility constraint demands rule deleted referred
rule associated reference count incremented non terminal symbol
references rule created decremented non terminal symbol deleted
reference count falls one rule deleted
digram uniqueness constraint difficult enforce digram appears
sequitur must search grammar occurrence one simple solution would
scan entire grammar time looking match inefficient leads
quadratic time better solution requires index efficient search
data structure storing digram index must permit fast access efficient addition
deletion entries hash table provides constant time access adding deleting
entries requires little extra work digram appears table need
contain pointer first symbol single matching digram grammar data structure
shown figure hash table consists simple array pointers collisions
handled open addressing avoid allocation memory chaining requires knuth

every time digram appears grammar sequitur adds index
digram appears two pointer assignments linking two symbols together doublylinked list one forward pointer one back pointer thus updating index
incorporated low level pointer assignments digram disappears grammar
pointer assignment madethe pointer value overwritten assignment
represents digram longer exists
demonstrate mechanism updating hash table rule created table
shows example figure addition contents digram index
second c appended rule digram table shows bc already exists grammar
rule bc created creating link b c right hand side rule
updates entry index bc point locationthe hash table contains
pointer symbol b start rule next first bc removed breaks link
b digram preceding symbol ab removed index


finevill manning witten

action

grammar

observe symbol c

abcdbc

change digrams

digram index

make rule

abcdbc
bc

bc updated

ab bc cd db

substitute bc

aadbc
bc

ab cd removed
aa ad added

bc db aa ad

substitute bc

aada
bc

db removed
da added

bc da aa ad

ab bc cd db

table updating digram index links made broken
breaks link c following cd removed index next replaces
bc creating links well adding digrams index
process continues resulting correct index digram pointers costing one
indexing operation per two pointer operations
next sequitur requires efficient strategy checking digram index rechecking
entire grammar whenever symbol added infeasible inefficient large portions
grammar unchanged since last check fact parts need checking
links made broken actions affect
maintenance digram table performed newly created digrams checked
index course every time link created digram entered index
time check duplicate entry found already present attempting
add digram index duplicate digram detected appropriate
actions performed therefore one hash table lookup required accessing
updating digram index

computational complexity
section sequitur linear space time complexity
proof amortized oneit put bound time required process one symbol
rather bounds time taken whole sequence processing time one symbol
fact large n n number input symbols far however
pathological sequence produces worst case requires preceding n symbols
involve formation matching rules
basic idea proof two constraints effect reducing
action


input symbol observed append rule












time link made two symbols
digram repeated elsewhere repetitions overlap
occurrence complete rule
replace digram non terminal symbol heads rule
otherwise
form rule replace digrams non terminal symbol
otherwise
insert digram index







time digram replaced non terminal symbol
symbol non terminal symbol occurs elsewhere
remove rule substituting contents place non terminal symbol

table sequitur








fii nferring sequential structure sequences

number symbols grammar work done satisfying constraints bounded
compression achieved sequence savings cannot exceed original size input
sequence linear number input symbols
table gives pseudo code sequitur line deals observations
sequence lines enforce digram utility constraint lines
enforce rule utility line appendix contains implementation sequitur java
requires lines
numbers right table identify main sections proof
demonstrate bounds number times executes action appends
symbols rules performed exactly n times every symbol input link
creation triggers action action uses existing rule action forms rule action
removes rule
table shows examples actions associated savings grammar size
savings calculated counting number symbols grammar
action non terminal symbols head rules counted
recreated order rules occur actions actions
reduce number symbols actions increase size grammar
difference size input size grammar must equal number
times actions taken
set stage proceed proof formally let
n size input string
size final grammar
r number rules final grammar
number times symbol seen action
number times digram seen action
number times existing rule used action
number times rule formed action
number times rule removed action
according reasoning reduction size grammar number times
actions executed

n
next number times rule created action must bounded two actions
affect number rules creates rules deletes number
rules final grammar must difference frequencies actions
r
equation r known bounded equation unknown noting
number times symbol seen equal n total work
action





saving

matching existing rule



ab
ab


ab



creating rule



ab ab


ab



deleting rule




ab

ab



table reduction grammar size three grammar operations



finevill manning witten

n n r
bound expression note number rules must less number symbols
final grammar rule contains least two symbols
r
expression
n n
consequently
n r n
final operation bound action checks duplicate digrams searching
grammar done hash table lookup assuming occupancy less say gives
average lookup time bounded constant knuth occupancy assured
size sequence known advance enlarging table recreating entries
whenever occupancy exceeds number entries table number
digrams grammar number symbols grammar minus number
rules grammar symbols end rule form left hand side
digram thus size hash table less size grammar bounded
size input means memory requirements linear
practice linear growth memory poses one strategy currently
investigating break input small segments form grammars
merge resulting grammar
number times action carried digram checked
link created links created actions already shown
bounded n time required action n
thus shown linear space time however claim must
qualified register model computation rather bitwise one
assumed average lookup time hash table digrams bounded constant
however length input increases number rules increases without bound
unstructured e g random input digram table grow without bound thus time
required execute hash function perform addressing constant
increase logarithmically input size proof ignores effect assumes hash
function operations register therefore constant time practice bit
architecture linearity proof remains valid sequences around symbols
bit architecture symbols

exploring extremes
described sequitur algorithmically characterize behavior variety
domains section explores large small grammar given sequence length
well determining minimum maximum amount work carry
amount work required process one symbol figure summarizes extreme
cases giving part example sequence grammar bounds given
terms n number symbols input
deepest hierarchy formed depth n example sequence
creates hierarchy shown figure order hierarchy deepen every
rule rule must contain non terminal symbol furthermore rule need longer two



fii nferring sequential structure sequences

symbols therefore produce deep hierarchy short string rule one
terminal symbol longer one builds order create rules string
represented must appear two different contexts otherwise rule incorporated
longer rule one context deepest hierarchy must participate context
hierarchy reduce size input string appear rule
note every rule figure appears hierarchy rule repetition
sequence one terminal symbol appended producing level hierarchy
point including repetition length one mth repetition length
repetition gives rise mth rule counting rule total length sequence
hierarchy depth therefore
n
deepest hierarchy depth n
end spectrum grammar shallowest hierarchy shown
figure b rules apart rule grammar largest possible one
sequence given length precisely rules formed sequence
gives rise one digram ever recurs course sequence alphabet
size different digrams bounds length sequence
kind sequence produces worst case compression repetitions
therefore sequitur detects structure
bound

example sequence

example grammar



deepest hierarchy

n

ababcabcdabcdeabcdef

abcddf
ab
b ac
c bd
ce

b

largest grammar
shallowest hierarchy

n

aabacadae bbcbdbe

aabacadae

c

smallest grammar

log n

aaaaaaaaaaaaaa

dd
aa
b aa
c bb
cc



largest number rules

n

aaaaababacacadad

aabbccdd
aa
b ab
c ac
ad

e

maximum processing
one symbol

n

yzxyzwxyzvwxy

abwbvwxy
yz
b xa

f

greatest number rule
creations deletions

n rules
n deleted rules

abcdeabcdeabcde

aaa
abcde

figure extreme cases



finevill manning witten

turning largest grammar smallest figure c depicts grammar formed
ordered sequence possibleone consisting entirely symbol four
contiguous symbols appear aaaa rule b aa formed another four appear
rule contains bbbb forming rule c bb every time number symbols doubles
rule created hierarchy thus log n deep grammar log n size
represents greatest data compression possible although necessary sequence
one symbol achieve logarithmic lower boundany recursive structure
produce grammar greatest number rules rule include
terminal symbols building hierarchy reduce number rules required cover
sequence given size furthermore rule longer two symbols occur
twice therefore rule requires four symbols creation maximum
number rules sequence length n n shown figure
discussed size grammars consider effort involved
maintaining shown upper bound processing sequence linear
length sequence however still useful characterize amount processing
involved symbol figure e shows sequence repetition built yz
xyz wxyz forth second occurrence wxyz appears matches
possible w x z appears yz matches rule xa matches rule b
finally sequitur forms rule wb cascading effect arbitrarily large
repetitions continue build right left fashion amount processing required
deal last z proportional depth deepest hierarchy matching cascades
hierarchy maximum time process one symbol therefore n fact w
x fail match means require little time process preserving overall linear
time bound
although bound linear sequences certainly differ proportion work sequence
length sequence figure b repetitions exist grammar formed
minimizes ratio sequence figure f consists multiple repetitions multisymbol sequence maximizes time repetition appears several rule deletions
creations match lengthens fact every symbol except incurs rule creation
subsequent deletion n creations deletions length repetition
proportion symbols incur work tends toward zero
repetition length approaches infinity

behavior practice
give idea sequitur behaves realistic sequences turn artificial cases
sequence english text figure plots number rules grammar number
input symbols character english novel shows increase
approximately linear figure b shows approximately linear growth total number
symbols grammar growth number unique words text shown
figure c high start drops toward end zobel et al observed
much larger samples english text thatsurprisinglynew words continue appear fairly
constant rate corresponding neologisms names acronyms typographical
errors example number rules grows linearly words
recognized multi word phrases constructed number phrases unbounded



fii nferring sequential structure sequences

nearly linear growth number symbols grammar seems disappointing
fact inevitable consequence information content english since symbols end
text convey similar amount information symbols beginning lower
bound achievable compression rate english text corresponds entropy
english
equitur operates quicklyas shown figure character novel
processed seconds rate symbols per second mb per minute figure
illustrates sequiturs linear time behavior practice sequence figure b
repetitions exist rules formed fast process indeed processed
rate symbols per secondthree times faster novel sequence figure f
consists multiple repetitions multi symbol sequence slows performance
symbols per seconda ten fold decrease fastest sequence sequence figure c
consists many repetitions single character forms concise grammar comes
symbols per second novel measurements performed
silicon graphics indigo
equitur effective data compression scheme outperforms schemes
achieve compression factoring repetition approaches performance schemes


b



symbols grammar

rules grammar


















c




input symbols












input symbols








input symbols





time seconds

vocabulary size

















input symbols



figure growth rates english text rules grammar b symbols
grammar c vocabulary size input time



finevill manning witten

compress probabilistic predictions sequiturs implementation evaluation
compression scheme described nevill manning witten

related work
mentioned introduction resembles work wolff
described sequitur possible contrast wolffs system mk processes
sequence left right forms chunk equivalent sequitur rule whenever
digram seen times happens occurrences digram replaced
non terminal symbol system carries sequence restarts
beginning case digram frequencies discarded process starts worst
case corresponds sequence figure f long exact
repetitions symbol repeated segment gives rise chunk process starts
figure f length repetition linear length sequence
number restarts length repetition quadratic length
sequence makes processing million symbol sequences impractical
number systems langley stolcke omohundro cook et al
form grammar rules repeated sequences merge rules generalize
grammars however operate different domainas input expect set sentences
drawn language rather single long sequence allows make inferences
directly comparing corresponding parts different sequences furthermore small
size training data means efficiency lesser concern performance
measured ability accept test sentences language reject
sentences target languages sequiturs case one
sequence available metric apply
vanlehn ball infer grammars sets sentences
enforces three constraints grammars purpose making version space finite
rule empty right side rule one symbol right side
symbol terminal every non terminal appears derivation string
constraints reminiscent sequitursfor example third constraint weaker form
sequiturs rule utilitybut serve different purpose sequitur operational
drive formation grammar vanlehn balls work make version space
tractable providing sensible restrictions form grammar
search space

conclusion
presented equitur identifying hierarchical structure
sequences idea abstracting subsequences occur rules
continuing operation recursively works maintaining two constraints
every digram grammar must unique every rule must used
equitur operates incrementally subject caveat register model
computation used linear space time efficiency permitted application long
sequencesup mbytein many different domains
evaluated prediction accuracy equitur evaluating
prediction accuracy fairly complex business adequate simply give count


fii nferring sequential structure sequences

correct versus incorrect predictions begs question likelihood
different ones occurring prediction schemes assign probabilities predictions
might offer judged discrepancy probabilistic predictions
true upcoming symbols whole question accurate probabilistic prediction sequences
tantamount compression sequences substantial field right bell et al
fact evaluated sequiturs performance compression found vies
best compression particularly large amount text available
nevill manning witten point present different one
sequitur represents sequence way exposes underlying structure fair say
compression produces representation way perspicuous
perhaps greatest drawback sequitur memory usage
linear size grammar linear memory complexity ordinarily considered intractable
although practice equitur works well sequences rather impressive size
clearly room approximate versions partition input merge
grammars formed could perhaps applied recursively create
logarithmic memory requirements conjecture however approximations
doubt turn useful practice inevitably sacrifice property
digram uniqueness appealing feature original

acknowledgments
grateful many detailed suggestions pat langley anonymous referees

references
andreae j h thinking teachable machine london academic press
angluin inference reversible languages journal association computing
machinery
bell c cleary j g witten h text compression englewood cliffs nj
prentice hall
berwick r c pilato learning syntax automata induction machine learning

cohen ivry r keele w attention structure sequence learning
journal experimental psychology
cook c rosenfeld aronson grammatical inference hill climbing
informational sciences
cypher editor watch programming demonstration cambridge
massachusetts mit press
gaines b r behaviour structure transformations uncertainty international journal
man machine studies
gold language identification limit information control
johansson leech g goodluck h manual information accompany
lancaster oslo bergen corpus british english use digital computers
oslo department english university oslo



finevill manning witten

knuth e art computer programming fundamental addisonwesley
laird p saul r discrete sequence prediction applications machine learning

langley p simplicity representation change grammar induction unpublished
manuscript robotics laboratory computer science department stanford university
stanford ca
nevill manning c g witten h compression explanation hierarchical grammars
computer journal press
nevill manning c g inferring sequential structure ph thesis department
computer science university waikato zealand
nevill manning c g witten h paynter g w browsing digital libraries
phrase proc second acm international conference digital
libraries philadelphia pa
rabiner l r juang b h introduction hidden markov ieee assp
magazine
stolcke omohundro inducing probabilistic grammars bayesian model
merging proc second international conference grammatical inference
applications alicante spain springer verlag
vanlehn k ball w version space learning context free grammars
machine learning
wharton r grammar enumeration inference information control

wolff j g segmentation artificial language analogue british
journal psychology
wolff j g discovery segments natural language british journal psychology

wolff j g language acquisition discovery phrase structure language
speech
wolff j g language acquisition data compression generalization language
communication




