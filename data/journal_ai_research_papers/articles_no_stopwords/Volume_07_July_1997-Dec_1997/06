journal artificial intelligence

submitted published

storing indexing plan derivations
explanation analysis retrieval failures
laurie h ihrig
subbarao kambhampati

department computer science engineering
arizona state university
tempe az

ihrig asu edu
rao asu edu

abstract

case cbp provides way scaling domain independent
solve large complex domains replaces detailed lengthy search
solution retrieval adaptation previous experiences general cbp demonstrated improve performance generative scratch
however performance improvements provides dependent adequate
judgements similarity particular although cbp may substantially reduce effort overall subject mis retrieval success cbp
depends retrieval errors relatively rare describes design
implementation replay framework case planner dersnlp ebl dersnlp ebl extends current cbp methodology incorporating explanation learning
techniques allow explain learn retrieval failures encounters
techniques used refine judgements case similarity response feedback
wrong decision made failure analysis used building case
library addition repairing cases large split stored
single goal subproblems multi goal stored smaller cases fail
merged full solution empirical evaluation demonstrates
advantage learning experienced retrieval failure

introduction
case improves eciency plan generation taking advantage previous solving experiences shown effective method scaling
domain independent solve large complex domains kambhampati hendler veloso cbp involves storing information particular
episodes successfully solved information may include
goals achieved world state conditions found relevant
achievement final plan decisions taken arriving
plan whenever encountered judgment made similarity
previous experiences similar cases reused extended search
solution example previous plan may transformed
skeletal plan refined solution friedland iwasaki
kambhampati hendler hanks weld multiple cases corresponding
small subproblem may combined extended solving single larger
redmond ram francis alternatively plan derivations may replayed
c ai access foundation morgan kaufmann publishers rights reserved

fiihrig kambhampati

provide guidance search process veloso ihrig kambhampati
cbp improves solving solved less time comparison
generative
one challenging tasks cbp determining cases store
match cases solving context complex domain unlikely
seen moreover every solved
stored library large cost associated retrieval may overshadow
gains provides koehler francis ram ultimately would
retain library minimum number cases
solved ecient retrieval adaptation cases stored smyth
keane however complex domains planner theory similarity
incomplete barletta mark information relevant
features situation determine stored case applicable sometimes
contain extra goals changed initial state conditions
changes may mean solution cannot found consistent earlier
decisions made stored episode planner cannot predict ahead time
previous choices wrong current situation experience retrieval
error
introduce dersnlp ebl derivational systematic nonlinear planner
explanation learning cbp system priar kambhampati hendler
spa hanks weld sound complete domain independent
planner dersnlp ebl deals mis retrieval allowing planner
learn failures may anticipate future errors failure explanations
automatically generated search process used extending case
solving situation used building case library
addition repairing cases
although earlier systems chef hammond exploited ebl techniques use restricted reasoning correctness plans generated
case planner contrast dersnlp ebl starts sound complete plan
synthesis strategy emphasis improving performance base level
planner guidance retrieved cases guidance considered succeed
leads planner search path leading solution
retrieval error occurs planner directed wrong path search
solution path lead solution dersnlp ebl extends current
cbp methodology ebl techniques employed automatic generation reasons retrieval failure analytical failures occur leaf nodes
search tree explained terms subsets con icting plan constraints leaf
node failure explanations regressed failing search paths form reason
retrieval failure
dersnlp ebl builds indexes case library failure analysis
failure reason used construction repairing case example retrieved
case fails due presence extra interacting goal covered retrieved
episodes explanation failure formed identifies subset input
goals negatively interacting failure reason used construct case
solves goals alone failure analysis employed refining


fistoring indexing plan derivations

retriever

library

cases




storer

plan derivation
case failure reason

case planner
replay extension recovery


solution

domain operators

figure schematic diagram illustrating dersnlp ebl
indexing case library censor retrieval failing case whenever
interacting goals present direct retriever repairing case
avoids failure
dersnlp ebl failure storage strategy limits size case library library
size reduced splitting single goal subproblems storing separately large solved retrieval adaptation multiple
instances smaller cases multi goal stored retrieved
cases fail merged extended full solution describe empirical studies
demonstrate substantial improvements performance novel
multi case adaptation
remainder organized follows section describes dersnlp ebl learns case failure improve case retrieval reports
preliminary experiments testing learning component section provides ecient techniques used store retrieve adapt multiple cases describes experiments test
dersnlp ebl method plan merging section describes evaluation full dersnlp ebl system solving large drawn complex domain section
relates work previous case planners including chef prodigy analogy
section provides summary

learning case failure
stated earlier dersnlp ebl complete correct domain independent
strategy priar kambhampati hendler spa hanks weld
implemented partial order planner aspect differs statespace systems prodigy analogy veloso carbonell veloso
paris bergmann wilke prodigy analogy employs case adaptation
strategy derivational replay stores experience form successful plan
derivations previous decisions made earlier episodes become instructions
guide search process solving derivational replay includes
following elements illustrated figure veloso veloso carbonell
facility within underlying planner generate trace derivation plan


fiihrig kambhampati

null
plan

skeletal
plan
e

final
plan

x
e x e x
depth limit
x

figure multiple derivation traces sequence decisions shown figure
rectangles used guide search process figure solution
could reached backtracking skeletal plan lies
outside plan derivation shown filled circles
indexing storage derivation trace library previous cases retrieval
multiple cases preparation solving finally replay mechanism
planner employs retrieved plan derivations sequence instructions
guide search process
dersnlp ebl methodology depends aspects common molgen
friedland iwasaki priar kambhampati hendler requires
eager case adaptation strategy skeletal plan constructed contains
constraints added advice retrieved cases constraints
separate failure resulting previous guidance subsequent
effort eager case adaptation decisions encapsulated
retrieved cases greedily adopted decisions extended solve
extra goals covered multiple retrieved plan derivations replayed sequence
produce skeletal plan contains recommended plan constraints
planner returns scratch previous decisions
retrieved cases visited skeletal plan refined achieve
goals left open previous work demonstrated effectiveness
plan space replay well advantage state space replay ihrig kambhampati
b
eager case adaptation described extension first skeletal plan
first extended search solution extension fails plan
backtracked discarding plan constraints added advice previous
episodes general case adaptation therefore involves three distinct phases
case replay case extension extension fails recovery search process
employed extending skeletal plan planner constructs explanation
plan failure becomes reason case retrieval failure explanations formed
analytical failures occur leaf nodes directly skeletal plan see
figure analytical failure explained set inconsistent plan constraints
failure explanations immediately regressed search paths encountered
regressed explanations collected root tree form reason


fistoring indexing plan derivations

l

l

ob

ld

ld

lp

lp

l

ob

l

b extra
goal

previous plan

figure plan accomplish transport single package ob destination
airport ld b contains extra goal involves additional
transport ld second package ob
retrieval error dersnlp ebl detects retrieval error occurred ways
refining skeletal plan tried planner forced backtrack
plan point failure reason fully constructed performing skeletal plan
extension separate process prior recovery allows planner identify retrieval
error terms failure skeletal plan construct reason failure
reason communicated storer used augmenting library
repairing case
consider simple example illustrated figure taken logistics
transportation domain shown figure goal package ob located
destination location ld package initially location l plane located
lp used transport package figure illustrates previous plan
contains steps determine plane route destination airport well steps
accomplish loading package right place along route eagerly
replaying earlier step addition decisions extra
package transport produces skeletal plan may readily extended include
loading unloading extra package long package lies along
route however package old route planner may able
solve extra goal without backtracking previous step addition decisions
see figure b
case failure reason shown figure gives conditions future
replay case failure conditions refer presence
set c negatively interacting goals well initial state
conditions contained e summary information content failure reason
extra package transport destination location package
destination location inside plane located plane
route


fiihrig kambhampati

action
precond
add
delete

load truck l
ob l
tr l
inside tr
ob l

action
precond
add
delete

load plane p l
ob l
pl p l
inside pl p
ob l

action
precond
add
delete

unload truck l
inside tr
tr l
ob l
inside tr

action
precond
add
delete

unload plane p li
inside pl
pl p li
ob li
inside pl

action
precond
add
delete
equals

drive truck li lg
tr li
city li lg
tr lg
tr li
li lg

action
precond
add
delete
equals

fly plane p li lg
airport lg
pl p li
pl p lg
pl p li
li lg

figure specification logistics transportation domain adapted experiments
subsequent backtracking skeletal plan planner continues search
go solution full one exists solution achieves
negatively interacting goals identified failure reason moreover since
goals represent subset goals derivation may used construct
case covering goals alone dersnlp ebl stores case directly beneath
failing case censor retrieval ensure whenever failure reason
holds example whenever extra package plane route
retriever directed away failing case toward case repairs failure
position describe detail dersnlp ebl eager derivation
replay strategy well learns reasons underlying case failure

eager derivation replay

derivation trace contains sequence instructions representing choices lie
along derivation path leading root search tree final plan leaf
node trace fitted context search process validating choice
context replaying decision valid order understand validation
process must first describe decision steps planner takes arriving
solution tuple hi g ai
complete description initial state g description goal state
set operators strips representation fikes nilsson ground operator
sequence said solution executed initial
state resulting state world satisfies goal
dersnlp ebl refinement planner solves navigating
space potential solutions represented partly constructed plan syntactically
formal development refinement search semantics partial plans refer reader
work kambhampati knoblock yang



fistoring indexing plan derivations

case failure explanation
c f h ob ob ld tg h ob ob ld tg g
e f hti ob ob ld hti inside pl ob pl
hti ob ob l hti ob ob lp g

figure example case failure reason
plan space p seen set constraints see semantically partial
plan shorthand notation set ground operator sequences consistent
constraints latter called candidate set partial plan denoted
hhpii particular partial plan represented tuple hs b l e ci
set actions step names plan mapped onto
operator domain theory contains two dummy steps ti whose effects
initial state conditions tg whose preconditions input goals g
b set codesignation binding non codesignation prohibited binding constraints variables appearing preconditions post conditions
operators represented plan steps
partial ordering relation representing ordering constraints
steps
l set causal links form hs p
e contains step effects represented hs ei
c set open conditions partial plan tuple hp si
p precondition step link supporting p l
consists starting null plan denoted p whose candidate set
corresponds possible ground operator sequences successively refining plan
adding constraints solution reached decision represents choice
resolve existing aw plan open condition unachieved
goal threat causal link understand choices validated
replay process useful think decision operator acting
partly constructed plan possible choices available dersnlp ebl shown
figure
decisions preconditions existence aw
current active plan effects alter constraints eliminate
aw example precondition establishment choice specified terms
existence unachieved subgoal effect addition causal link achieves
open condition precondition resolution decision threat one step
clobbering existing causal link threat resolved adding step ordering
promotes demotes clobberer relative causal link


fiihrig kambhampati

type establishment
kind step
preconditions

hp c
effects

fsg
fs g
b b unify p p
l l fhs p ig
e e effects

c c fhp ig
preconditions

type establishment
kind link
preconditions

hp c
effects

fs g
b b unify p p
l l fhs p
ig
c c fhp ig

type resolution
kind promotion
preconditions




hs p l
ht p e
ft sg fs tg
effects
ft sg






type resolution
kind demotion
preconditions




hs p l
ht p e
ft sg fs tg
effects
fs tg








figure decisions active plan hs b l e ci effects alter constraints produce current active plan
hs b l e c
decision replayed first compared current active plan determine whether precondition holds context invalid decisions whose
preconditions match skipped establishment decisions ignored goals
achieve present open conditions current active plan threat resolutions skipped threat present previous choices justified
current situation used guidance direct search process replaying valid
decision involves selecting match decision children current active
plan making child next plan refinement
dersnlp ebl eager derivation replay strategy replays applicable decisions
trace sequence replay strategy contrasted
prodigy analogy veloso replay alternated scratch
extra goals covered case eager derivation replay previous decision
eagerly adopted justified current context since invalid instructions
skipped skeletal plan end replay comparable product
fitting phase plan reuse kambhampati hendler hanks weld
contrast plan reuse derivation replay alter underlying strategy
replay merely provides search control directing search node visit next
means dersnlp ebl inherits properties snlp including soundness
completeness systematicity
sample trace snlp decision process shown figure trace corresponds
simple logistics transportation domain veloso adapted
snlp figure contains goal getting single package ob
designated airport ld derivation trace contains choices made along
path root search tree final plan leaf node instructions contain
description decision taken basis justification context

eager case extension recovery
decisions trace skipped replay known
priori unjustified guarantee skeletal plan left


fistoring indexing plan derivations

goal ob ob ld
initial airport ld airport li
airport lp pl pl lp
ob ob li
name g
name g
type start node
type establishment
name g
kind link
type establishment
link airport ld
kind step
open cond airport ld
step unload pl ob p ld
name g
link ob ob ld goal
type establishment
open cond ob ob ld goal
kind step
name g
step load pl ob pl
type establishment
link inside pl ob pl
kind step
open cond inside pl ob pl
step fly pl p ld
name g
link pl p ld
type establishment
open cond pl p ld
kind link
name g
link pl pl li
type establishment
open cond pl pl
kind step
name g
step fly pl p
type resolution
link pl p
kind promotion
open cond pl p
unsafe link pl pl li
name g
effect pl pl li
type establishment
name g
kind link
type establishment
link pl pl lp
kind link
open cond pl p
link ob ob li
name g
open cond ob ob li
type establishment
key abbreviations
kind link
pl plane
link airport li
ob object
open cond airport
final plan fly pl pl lp li created
load pl ob pl li created
fly pl pl li ld created
unload pl ob pl ld created
ordering steps

figure example solution trace dersnlp ebl



fiihrig kambhampati

dms
affi precond fii pff g add fgig delete fij jj ig
afii precond fii pfi g add fgig delete fij jj ig
aff precond fg add fgff g delete fpfi g fgij ig

figure specification barrett weld transformed dm domain
ultimately refined solution current without actually completing
search way predicting whether constraints left skeletal
plan consistent complete solution whenever skeletal plan complete
whenever extra goals unsatisfied initial state conditions planner must
undergo effort extend plan possibility effort
may fail necessitating recovery phase
dersnlp ebl skeletal plan extended first prior recovery plan
backtracked search process fails refine full solution
strategy requires depth limit placed search tree otherwise
skeletal plan extension may continue indefinitely becomes incomplete eager extension strategy however linked particular search method
example may used best first depth first iterative deepening search
different search methods used exploration subtree skeletal plan
prior backtracking plan skeletal plan found fail recovery
phase initiated merely involves exploring siblings replayed path
extension recovery linked particular search strategy

analyzing failure case extension

order skeletal plan successfully extended achieve conditions left open
sequence decisions adopted guidance previous trace must
concatenated choices arrive solution occur replayed
path must decision sequencable respect defined
follows

definition decision sequencable search path search path contains sequence decisions decision sequencable respect hi g ai
exist two decision sequences e e e e
decision sequencing operator produce plan correct hi g ai
one primary reasons replayed path may decision sequencable goal
interactions occur input goals particular extra
goals achieved case may interact covered making retrieved
case inapplicable long recognized relative diculty solving
linked level interaction input goals korf
joslin roach barrett weld veloso blythe kambhampati
practice limit actually bound placed number steps contained plan



fistoring indexing plan derivations

ihrig srivastava goal interaction formalized korf terms
search space barrett weld extend korf analysis plan
space plan space planner order goals achieved crucial
goals laboriously serializable state space planner exist goal
orderings goals may solved sequence may trivially serializable
plan space planner meaning goals solved order
however goals trivially serializable plan space planner veloso
blythe example consider dm domain barrett weld shown
figure notice gff one set goals true initially
goal gi present set must achieved operator affi
afii means time case replayed previously solved goal gi
action afii gff extra goal covered case replay fail
cbp however much concerned general properties
domain properties particular search paths stored
case library required input goals every trivially serializable
cbp beneficial performance would
domains cbp effective trivial serializability requirement since
necessary every plan every subset input goals consistent
solution full particular plans retrieved
library concerned
even goals trivially serializable replay may decision
sequencable depending cases actually retrieved library
dm domain single goal cases retrieved solve gi action afii
decision sequencable multi goal contains
goal gff however stored cases solved affi replay cases
sequencable fact aim dersnlp ebl learning component achieve
indexing within case library encountered
planner may solved sequenced replay cases retrieved library
next section describes dersnlp ebl able work towards objective
learning component learns replay failures

constructing reasons retrieval failure
dersnlp ebl constructs explanations retrieval failures use explanationbased learning techniques allow planner explain failures individual plans
planner search space leaf node plan represents analytical failure
contains set inconsistent constraints prevent plan refined
solution analytical failure explained terms constraints kambhampati katukam qu b leaf node failure explanations identify minimal set
constraints plan together inconsistent dersnlp ebl forms explanations
analytical failures occur subtree directly skeletal plan
regressed failing search paths collected root tree
form reason retrieval failure see figure regressed explanation terms
specification contains subset interacting goals well initial
state conditions relevant goals



fiihrig kambhampati

null
plan

e

ob ob ld tg
ti ob ob ld

e f
df
e f
df
e

null
plan

ob ob ld tg
ti ob ob ld

skeletal
plan

df
df

skeletal
plan

x

x
e

x

e

x

ti ob ob ld tg
ti ob ob ld

regression process

b detailed example

figure path failure explanation root tree computed e
f e
since plan failure explained subset constraints failure explanations
represented manner plan recall dersnlp ebl represents
plans tuple hs b l e ci see section explanation failure
occurring leaf node contains constraints contribute inconsistency
inconsistencies appear constraints added con ict existing
constraints discussed section dersnlp ebl makes two types decisions establishment resolution type decision may plan failure establishment
decision represents choice method achieving open condition
existing step adding causal link initial state attempt
made achieve condition linking initial state effect condition
satisfied initial state plan contains contradiction explanation
failure constructed identifies two con icting constraints

h fhti p sig fhti pig

precondition resolution decision threat causal link dersnlp ebl
uses two methods resolving threat promotion demotion adds step
ordering plan decision adds ordering con icts existing
ordering explanation failure identifies con ict

h fs sg

con icting constraints failure explanation regressed final
decision sorted according type form regressed explanation
process illustrated graphically figure b example link
initial state failure explanation e
h fhti ob ob ld tg ig fhti ob ob ld ig


fistoring indexing plan derivations

e regressed final decision df obtain explanation initial
state effect regresses however since link explanation added
decision df link regresses open condition precondition adding
link explanation ef therefore

h fhti ob ob ld ig fh ob ob ld tg igi

regression process continues failing path reaches root search
tree paths subtree underneath skeletal plan failed
failure reason root tree provides reason failure retrieved
cases represents combined explanation path failures case failure
reason contains aspects responsible failure
may contain subset goals initial state effects
present leaf node explanation present reason case failure

empirical evaluation utility case failure analysis

preliminary study conducted aim demonstrating advantage storing
retrieving cases basis experienced retrieval failure domains chosen
randomly generated contained negatively interacting goals
performance tested dersnlp ebl solving multi goal scratch
replay single cases covering smaller subset goals replay performance
tested without case failure information
domains

experiments run drawn two domains first artificial
domain dms originally described barrett weld shown figure
testing done randomly generated domain
restriction contain goal gff logistics transportation domain
veloso adopted second set experiments eight packages one
airplane randomly distributed four cities goals represented task
getting one packages single destination airport fly operator augmented delete condition prevented planes visiting airport
meant replay failed extra package transported
previous route taken plane
retrieval strategy

cases initially retrieved basis static similarity metric takes
account goals covered case well relevant initial state
conditions kambhampati veloso prior studies reasonably
dersnlp ebl ebl component explains analytical failures depth limit failures ignored
means failure explanations formed sound case depth limit failure
retriever may reject case applicable rejecting applicable case may lead
storage duplicate cases larger library size however empirical work shown
practical importance reasons outlined section
comprehensive evaluation unbiased set see section



fiihrig kambhampati

effective metric learning mode cases retrieved basis however
mode failure reasons attached case used censor retrieval
time case retrieved learning mode failure conditions
tested failure reason satisfied specification retrieval
mechanism returned case replay hand failure reason found
true context case repaired failure retrieved
following retrieval solved replay retrieved case well
scratch
experimental setup

experiment consisted three phases phase corresponding increase
size goals randomly selected case
logistics domain initial state randomly varied initial
training session took place start phase n n goal solved
scratch derivation trace stored library following training
testing session consisted generating manner additional
goal time n goal tried attempt made retrieve
similar n goal library testing session case
similar found previously failed
solved learning static scratch modes became part
set method able evaluate improvements provided failurebased retrieval retrieval static metric alone ineffective failure
conditions available
experimental

experiments shown tables table entry represents
cumulative obtained sequence corresponding one phase
experiment first row table shows percentage correctly solved
within time limit seconds average solution length shown parentheses
logistics domain solution length omitted dms since
generated within phase solution length second third rows
table contain respectively total number search nodes visited test
total cpu time including case retrieval time
summarized figure dersnlp ebl learning mode
able solve many multi goal two modes
substantially less time case retrieval case failure resulted performance
improvements increased size comparable improvements
found retrieval static similarity metric alone
surprising since cases retrieved experienced least one earlier failure
meant testing done cases likelihood failing retrieval
static metric
table records three different measures ect effectiveness replay first
percentage sequenced replay recall replay trace considered
sequenced skeletal plan refined reach solution


fistoring indexing plan derivations

dms

static

scratch

learning

logistics
static

scratch

























solved
nodes
time sec

























solved
nodes
time sec

























phase

learning

solved
nodes
time sec

two goal

three goal

four goal

table performance statistics dms logistics transportation domain average
solution length shown parentheses next solved logistics domain


dm

b logistics

figure replay performance dms logistics transportation domain


fiihrig kambhampati

dms

logistics
learning
static

phase

learning

static

seq
der
rep

















seq
der
rep

















seq
der
rep

















two goal

three goal

four goal

table measures effectiveness replay
point greater eciency replay learning mode dm domain
replay entirely sequenced mode transportation domain retrieval
failure sequenced replay often static
mode
greater effectiveness replay learning mode indicated two
measures contained subsequent two rows table respectively percentage plan refinements final derivation path formed guidance
replay der percentage total number plans created replay remain final derivation path rep case planner learning
mode showed much greater improvements according measures demonstrating relative effectiveness guiding retrieval learning component
replay failures indicate dersnlp ebl integration cbp ebl
promising extra interacting goals hinder success replay
section report thorough evaluation dersnlp ebl learning component conducted purpose investigating learning case failure
benefit planner solving random complex domain evaluation implemented full case system along novel case storage
adaptation strategies next section describe storage strategy
developed evaluation

improving case storage adaptation
aim case eciently solve large complex domains
complex domain means great variety encountered size
measured terms number goals n large unlikely n goal
seen therefore advantage able store cases
covering smaller subsets goals retrieve adapt multiple cases solving single
large


fistoring indexing plan derivations

implementing strategy decisions made goal combinations store previous work within state space veloso developed
reducing size library first transforming totally ordered plan
partially ordered graph separating connected components graph storing
subplans individually goals interact respective plans must
interleaved order form complete solution stored together single case
replay plan space planner snlp component subplan may
subdivided since planner ability first piece plans together later add step
orderings interleave subplans kambhampati chen ihrig kambhampati
replay smaller cases sequenced long individual subplans
may interleaved addition step orderings form full solution plan space
planner therefore greater capability reducing size stored
library consequence number cases stored
dersnlp ebl storage strategy makes use plan space planners ability piece
small plans together add step orderings interleave plans earlier approaches priar kambhampati hendler prodigy analogy veloso
caplan munoz avilla weberskirch cases stored cover
smaller subsets original set input goals achieved successful solving
episode dersnlp ebl differs earlier approaches division goal
subsets structure final plan alone sequence events
making solving episode repairing case stored cases
retrieved library solving fail extended
solution storer constructs case failure explanation obtained extension phase well successful plan derivation obtained
recovery
failure explanation identifies set negatively interacting goals responsible
failure goals form subset input goals achieved
solution repairing case stored plan derivation stripped
decisions irrelevant achievement interacting goals case
covers negatively interacting goals
note define negative interaction failure skeletal plan
interaction occurs set input goals cannot solved refining skeletal plan
causing planner backtrack plan moreover cannot determine
whether two goals negatively interacting merely analyzing final solution
include information failures encountered generating
solution particular final solution tell us whether additional goal
achieved extending replayed path backtracking path approaches
case storage determine goal interaction final plan alone veloso
munoz avilla weberskirch therefore ignore retrieval failures
encountered episode
retrieval failures provide important guidance library may improved
avoid similar failures dersnlp ebl used dynamically improve storage
library addition goal combinations multi goal
stored retrieved cases corresponding single goal subproblems fail merged


fiihrig kambhampati

case failure explanation

c fhgff tg hg tg ig
e fhti hti pfi ig
figure example case failure reason
extended solution repairing cases constructed achieve negatively
interacting goals responsible identified failure explanation

example negative interaction
figure provides example explanation failure encountered solving
barrett weld dm domain shown figure contains
three goals gff g g attempted replay case solves
two goals gff g second case achieves g latter
goal achieved action afi represents incorrect operator choice
input goals include goal gff
failure explanation shown figure identifies subset interacting goals made
g gff note interaction evident final plan shown figure
plan three input goals achieved connected
component base storage solely plan graph represented successful plan
three input goals stored single case moreover
representing novel combination goals stored library causing library
size increase exponentially size example suppose domain includes
goals fgi j ng gff number size three
number goal subsets n goals dersnlp ebl strategy storing cases
explanations retrieval failure maximum n cases stored
goal fgi j ng appears two cases one representing single goal
one representing two goal achieves gff
storing negatively interacting goals multi goal may therefore
substantial reduction size case library represents tradeoff
replayed cases must extended scratch solve con icts
individual plans recommended separate cases moreover complex domains
may goals interact positively may solved common
steps ihrig kambhampati munoz avilla weberskirch goals
stored separate cases replay may unnecessary redundancy plan
dersnlp ebl positive interactions handled replay process
merges subplans provided multiple cases section describe
merging accomplished next section provides detail case storage
strategy implemented empirical study


fistoring indexing plan derivations

ti







tg

figure solution example

building case library
following deliberative strategy adopted building case library
contains n goals first goal attempted solved case covering
goal alone stored library solving continues increasing size
one goal time example attempted contained goal set
g hg g gi solved decision sequence di second decision
sequence di stored whenever di cannot replayed extended achieve next
goal gi whenever replayed derivation path fails recovery phase successful
producing solution explanation case retrieval failure used identify
subset negatively interacting input goals n hgj gj responsible
failure replayed path fails extended backtracked reach solution
successful derivation passed storer along
failure explanation explanation used delete derivation decisions
relevant set negatively interacting goals n reduced derivation
stored library repairing case alternatively whenever next goal
set solved simple extension previous decision sequence case
stored includes goal
storage strategy entails two important properties case corresponds
single goal multi goal containing negatively interacting
goals plan derivations arising single solving episode
different decision sequence stored library prefix another stored case
case added library solved extending
retrieved case cases stored previous decisions need
backtracked search solution
dersnlp ebl strategy restricting multi goal cases goals
negatively interacting serves ameliorate mis retrieval experience
planner solving interactions discovered
less likely planner backtrack replayed paths aim
eventually library minimal number cases
encountered may achieved successfully merging multiple instances stored cases
therefore retain cases competence well performance
smyth keane
example dersnlp ebl storage strategy

example multi goal stored consider contained
figure three packages ob ob ob transported
destination location ld initially goal set contains goal transporting ob alone
represented ob ob ld successful derivation stored case
second goal added set since attempted achieves first


fiihrig kambhampati

ob



ob

b
b

ld

b
lp

ob

l

figure logistics transportation example illustrating multi case storage figure
shows two plans produced two stored derivations case achieves goal
single packages ob transported destination airport ld case
b achieves goal ob ob located airport
goal decision sequence backtracked order solve
additional goal second derivation case b stored derivation solves
mutually interacting goals ob ob ld ob ob ld solving
continues addition third goal goal solved simple extension
previous decision sequence case stored includes goal means
two cases stored library case corresponding single goal
case b corresponding multi goal containing two negatively interacting goals
multi goal stored goals mutually interacting
individual derivations cannot sequenced extended solve
full
dersnlp ebl storage strategy size library limited amount
interaction domain example negative interaction single
goal cases stored logistics transportation domain potential
goals interact negatively however since significant percentage
non interacting goals strategy reduces size library comparison one
multi goal successfully solved stored storage
strategy represents tradeoff since effort must expended merging retrieved
cases full solution see section
indexing basis replay failure

multi goal cases stored library censor retrieval corresponding
single goal subproblems library organization differs earlier work stores
cases common fashion single level first indexing case goals
success conditions relevant goals veloso munoz avilla
weberskirch contrast dersnlp ebl indexes cases discrimination
net similar one depicted figure figure shows one fragment case
library includes cases solve single input goal individual
episodes achieve goal represented one level lower net labeled


fistoring indexing plan derivations

g
input goals

initial conditions

ob ob ld
pl pl lp

ob ob l

g

g

derivation
r

failure reasons

pl pl lq

derivation
r

g

g

derivation

derivation

figure library fragment indexing stored cases solve single input goal ob
ob ld
relevant initial state conditions otherwise known footprinted initial state veloso
together goal initial state conditions make static success conditions
cases first retrieved one cases retrieved replay replay
fails derivation corresponding extra interacting goals added library
indexed directly failing case future retrievals case failure
conditions checked see whether extra goals responsible failure present
conditions retrieval process returns repairing case
achieves con icting goals case failure reason thus used direct retrieval away
case repeat known failure towards case avoids
one might question hierarchical organization instances failures due
interacting goals alone store cases single level first indexing
case goals conditions relevant goals answer
lies need censor cases failure conditions satisfied type error
found retrieving multiple cases example consider
contains three goals g g g suppose goal g negatively interacts
g g case retrieved library achieves g g
one goal g left open however case retrieved solves g alone
fail presence g type retrieval error handled prioritizing
cases repairing case stored subclass case failed failing cases
annotated failure reason directs retriever case avoids
failure
prioritizing cases basis negatively interacting goals alone sucient
capture retrieval failures may encountered cases retrieved
basis partial match relevant initial state conditions retrieval errors may
occur unmatched conditions veloso example failure might
occur logistics transportation example extra package plane
route similar failure occur package moved plane route strategy
adopted deal types failure information annotate case


fiihrig kambhampati

ob

ob



l
ld

b b
b

b

b
lp

ob

b

l

figure logistics transportation example illustrating multi case retrieval
failure reason whether extra goal unmatched initial state condition
use failure reasons prioritize cases ebl techniques employed
construction failure explanations may used types failures
dersnlp ebl method storing multi goal cases goals negatively interacting limits size case library aspects dersnlp ebl storage strategy
serve lower library size planner uses current library solving
derivations stored applicable case
retrieved cases fail strategy avoids storage duplicate cases may
entirely effective since soundness failure explanations guaranteed failure
explanations sound pointers repairing cases may eventually lead duplicate
case causing library continue grow indefinitely however easily checked
putting depth limit number repairing cases discrimination net
failures due interacting goals unchecked growth library
since number interacting goals limited maximum size
detailed example case retrieval

example case retrieval illustrated figure figure contains three subplans
corresponding two separate cases stored library case achieves goal
single package ob located destination ld case b achieves goal
ob ob located ld
assume attempted replay contains three
goals ob ob ld ob ob ld ob ob ld second goal negatively
interacts goals retriever first attempt case
solves first goal alone case solves goal however case annotated
failure reason satisfied situation therefore censored
favor repairing case case b retriever returns case b
one open goal covered ob ob ld seek case solves
goal alone case however failure reason satisfied
state rejected favor second copy b
call case b solves transporting ob ob
two instances case b retrieved solve three goal
case b case b together cover goals dersnlp ebl replays


fistoring indexing plan derivations

figure linking opportunities indicated increase number siblings
step addition decision
copies b sequence obtain solution full thereby merging
respective subplans notice however union plans contain redundant
steps example plans plane location l section describes
dersnlp ebl deals positive goal interactions

multi case merging

say two plans mergeable respect hi g ai exists
solution contains combined constraints

definition mergeability plan p achieving goal g mergeable plan p
goal g respect hi g ai plan p correct
hi g ai hhp ii hhp ii hhp ii thus syntactically p contains constraints
p p

multi case replay accomplishes plan merging may lower quality plans
care taken avoid redundant step additions ihrig kambhampati munozavilla weberskirch occur goals covered separate cases positively
interact may solved common steps replaying case sequence
unneeded steps plan
multi case replay open condition justification adding step
steps may added already exist plan due earlier replay another
case first retrieved derivation replayed none replayed step additions
redundancy however subsequent goals solved replay
additional cases step additions may unnecessary opportunities
linking open conditions achieve earlier established steps planner
way determining priori steps may represented single step
plan
dersnlp ebl replay framework handles redundant step additions skipping
step addition establishments whenever open condition may achieved link
thus strengthens increases justification replaying step addition decisions
open condition longer basis validating decision justification replay strengthened add condition linking opportunities
analogous decrease plan quality occurs state space plan reuse sequencing macro operators
state loops minton
consider example domain plane may transport two packages one trip
depending capacity



fiihrig kambhampati

dersnlp ebl

dersnlp ebl ij









replay
solved
time sec

scratch

replay

scratch

table percentage solved total cpu time seconds
logistics transportation domain average solution length
shown parentheses next solved
present may detected increase number siblings prescribed
step addition choice see figure siblings stored step addition decision
recorded annotations derivation trace links available
contained within siblings step addition decision skipped replay
alternative links explored normal course plan refinement
means step may eventually added links fail
increasing justification step addition decisions improves quality plans
terms number steps contain example case b b would normally
produce subplans shown figure cases replayed sequence
solving single plans merged plane moves city
plan merging increasing justification replay accomplishes
retracting redundant action sequences may cause failure thus
deals action merging interactions defined yang nau hendler
next section describe empirical study testing effectiveness merging
strategy
empirical test dersnlp ebl plan merging strategy

preliminary study conducted test effectiveness dersnlp ebl method
plan merging replay experiment compared dersnlp ebl
without increasing justification replay experimental setup consisted training
dersnlp ebl set randomly generated goal training testing
different set goal test initial state contained
locations post oces airports transport devices planes trucks
training phase planner solved stored successful plan derivations
case library testing phase planner retrieved multiple stored plan
derivations used guidance solving test dersnlp ebl
tested replay scratch modes replay
dersnlp ebl without dersnlp ebl ij increased justification
shown table
although overall performance poorer quality plans terms number
steps improved dersnlp ebl strategy increasing justification step addition suggests dersnlp ebl method plan merging serves reduce


fistoring indexing plan derivations

redundancy plans produced multi case replay recently munoz avilla
weberskirch tested non redundant merging strategy process domain found similar improvements plan size next section describes
evaluation full dersnlp ebl system

experimental evaluation complete system

experiments reported section tested full dersnlp ebl system
dynamic multi case storage retrieval strategy described section aim
evaluate replay system complex domain hypothesis performance
would improve solving experience negative interactions discovered
stored addition predicted dersnlp ebl method storage would
low library size low retrieval costs
logistics transportation domain veloso become somewhat benchmark cbp literature scaled version therefore chosen purpose
tested large multi goal drawn domain shown figure scaled
first cities size domain unusual current literature

experimental setup

experiment run phases phase corresponding increase
size thirty test size randomly generated since possible
obtain truly random distribution within nonartificial domain following strategy
adopted generation first initial state constructed fixing
number objects type contained domain description example first
experiment six cities locations within cities six planes six trucks
initial state constructed first including filter conditions nonachievable conditions defined layout cities example condition
airport ap identified ap airport condition city ap po indicated
ap po located city second achievable non filter conditions present add clauses domain operators varied
choosing object constants randomly available restriction
two initial state conditions inconsistent example plane package
assigned single randomly chosen location goals chosen among
achievable conditions manner although attempt made create interacting goals goal interaction common multi goal
limit imposed number steps plan meant multi goal often could solved concatenating subplans individual subgoals
instances planner could take advantage linking opportunities achieve multiple
goals common steps meant often planner backtrack
derivation one goal order solve additional goal
first experiment used city domain run phases size
test ranged goals increased phase prior
phase n experiment case library emptied planner retrained
randomly generated size n training solved attempting
single goal subproblems scratch storing trace derivation solution


fiihrig kambhampati

phase





solved
time sec




solved
time sec

logistics best first

cpu limit sec














































solved
time sec













solved
time sec






















solved
time sec



















solved
time sec



















one goal

two goal

three goal

four goal

five goal

six goal






table performance statistics logistics transportation domain average solution
length shown parentheses next solved case retrieval time shown
parentheses next cpu time
one already present library successively adding extra
goal multi goal stored retrieved cases used solving
failed whenever could solved sequenced replay previous cases
negatively interacting goals contained failure reason identified
case achieving goals alone stored library phase experiment
planner tested randomly generated test varying
amounts training solved scratch mode replay
multiple cases retrieved library constructed training
second experiment tested planner complex city domain employed stable case library formed dersnlp ebl trained city goal
logistics transportation library smaller used
planner tested larger city ranging goals

experimental

first experiment city domain dersnlp ebl showed substantial improvements multi case replay evident table moreover replay
performance improved solving experience plans produced
showed slight increase number steps solutions obtained
scratch mode plotted figure graphs cumulative
cpu time test six experiments figure illustrates cpu
time decreased number training solved insert shows total cpu


fistoring indexing plan derivations

figure replay performance logistics transportation domain increasing
amounts training thirty tested size
goals amount time needed solve test size
including case retrieval time shown solved scratch
level replay increasing levels training solving
randomly generated insert shows amount time taken
solve test increasing amounts training time limit
seconds placed solving



fiihrig kambhampati

figure replay performance logistics transportation domain scaled
cities case library formed training cities goals
solved library used solving test sets containing larger
cities goals none solved within
time limit sec scratch mode replay mode average solution
length shown parentheses next size

figure replay performance logistics transportation percentage test solved within time limit sec plotted number training
solved percentage solved shown increasing size
goals



fistoring indexing plan derivations

figure figure shows size case library increased number training
solved library size increases training size
goals shows number single goal subproblems contained goal
training
time including case retrieval time test six experiments
evident insert performance improves increased experience random
however relatively little experience solved enough
significant performance improvements
replay raised solving horizon illustrated figure effective
larger size scratch tends exceed time limit imposed
solving figure shows increase size library increasing
amounts training figure indicates library size determined
amount interaction domain opposed number training solved
rate case library grows tapers higher planner trained
larger
second experiment library formed course training goal
used solve larger goals complex domain cities see
figure none larger solved scratch mode within time
limit sec planner continued maximum time indicated
figure linear increase cpu time performance substantially better
replay however since library size relatively small improvements
performance offset cost retrieving adapting previous cases finding
suggests replay strategy employed experiments represents effective
method improving performance complex domains
opportunity interaction larger example goal could
contain goals mutually interact whereas goal maximum interacting goals
dersnlp ebl scratch mode used best first strategy replay best first strategy biased
subtree replayed path explored first siblings path



fiihrig kambhampati

action put x z
precond x z
clear x
clear
add
x
clear z
delete x z
clear

action tower x z
precond x z
clear x
add
delete

x table
clear z
x z

figure specification blocks world domain adapted experiments

empirical comparison dersnlp ebl rule ebl
case explanation learning offer two differing approaches improving performance planner prior kambhampati analyzed
tradeoffs hybrid learning dersnlp ebl designed alleviate
drawbacks associated pure case rule ebl prior
work ebl used construct generalized search control rules may
applied solving situation rules matched choice
point search process dejong mooney minton b mostow bhatnagar
kambhampati et al b known exhibit utility since
rule base grows rapidly increasing solving experience even small
number rules may high total match cost minton b tambe newell
rosenbloom kambhampati francis ram contrast empirical
discussed see table indicate dersnlp ebl low case retrieval
match cost
demonstrate dersnlp ebl reduces match cost conducted empirical study
compared performance ucpop ebl rule search control learning
framework kambhampati et al b framework constructs reasons
failures manner similar dersnlp ebl however similar
minton b employs explanations construction search control
rules matched node search tree planners tested
set ranging goals randomly generated blocks
domain shown figure testing performed set thirty
increasing amounts training
illustrated figure dersnlp ebl improved performance training solved ucpop ebl failed improve significantly reason evident
ucpop ebl match time ucpop match graphed figure ucpop ebl
time spent matching rules increases training wiping improvements
may gained use rules rules matched
choice point search tree small number rules sucient substantially increase
total match cost


fistoring indexing plan derivations

figure total cpu time blocks world increased amounts training
possible improve performance rule ebl reducing number
rules use utility monitoring strategies gratch dejong
sophisticated match doorenbos example doorenbos
employs improved rule matcher rete dersnlp ebl
hand aims alleviating utility reducing number times rules
matched similar rule ebl learning component employed generate
rules however rules generated govern retrieval cases stored
library compiled indexing structure dersnlp ebl exhibits low
match cost applying retrieval rules one point search process specifically
retrieves cases start solving case represents sequence
choices derivation path thus providing global control opposed local
shown table indicate cost retrieving cases significantly lower comparison
time spent solving

related work discussion
dersnlp ebl storage strategy relies capability case planner replay
multiple cases covering small subset goals add step orderings interleave respective plans strategy differs earlier approaches priar
kambhampati hendler prodigy analogy veloso paris bergmann
wilke caplan munoz avilla weberskirch division
goal subsets structure final plan alone sequence
events making solving episode retrieval failures treated opportunity planner stores repairing case aspect similar
hammond chef hammond learns improve retrieval strategy
failures despite surface similarity important differences



fiihrig kambhampati

transformational
priar
spa
mpa
plan space

state space
dersnlp

prodigy analogy
paris

derivational

figure different approaches case case adaptation accomplished underlying generative planner
dersnlp ebl learns case extension failures whereas chef concentrates
learning execution failures specifically chef assumes incomplete domain model
consisting stored cases domain specific modification theory patches given
chef retrieves previous case modifies retrieved plan domain
specific modification rules generate candidate solution current
correctness solution tested respect external causal simulator
domain solution found incorrect explanation incorrectness supplied
simulator used modify case library censor retrieval case
similar situations future effect improves correctness chef domain
theory contrast dersnlp ebl assumes complete knowledge domain form
domain operators access sound complete plan synthesis strategy
aim case reasoning dersnlp ebl improve performance
base level planner end dersnlp ebl analyzes case extension failures predict
case cannot extended solve
fox leake taken similar chef use introspective reasoning explain failures repairing cases similar chef introspective
reasoning used revise indexing case library fox leake ram cox
approaches employ domain specific techniques improve storage retrieval case library munoz avilla weberskirch smyth keane
dersnlp ebl differs automatically generates indices well defined
domain independent methodology kambhampati et al b incorporated
underlying strategy
since ebl employed explaining case failure well success dersnlp ebl complements extends earlier approaches case retrieval barletta mark kambhampati hendler hendler stoffel mulvehill veloso bergmann
wilke munoz avilla weberskirch ram francis although


fistoring indexing plan derivations

exhibits low retrieval match cost cbp system eciency may degrade larger domain size dersnlp ebl compatible others aimed
improving match cost doorenbos ram francis hendler et al
example mpa ram francis built around retrieval engine performs
asynchronous memory retrieval caper hendler et al uses structure matching
parallelizes process plan success conditions represented
retrieval probe matched large knowledge base world facts process
expands binary predicates match success conditions larger structure containing implicitly specified relations knowledge base structure acts filter
eliminating matches fail line probe
dersnlp ebl similar case systems employ complete correct
domain independent planner generate cases stored hanks weld kambhampati hendler koehler veloso ram francis surveying
literature possible distinguish approaches two orthogonal scales
shown figure horizontal direction cbp frameworks ranked
underlying strategy falls continuum whose end extremes represent
state space vs plan space dichotomy towards state space end spectrum
prodigy analogy employs means ends analysis mea planner nolimit
extend previous case nolimit classed state space planner since applies
actions plan current world state thereby advances world state
priar framework kambhampati hendler kambhampati
within nonlin tate nonlin creates plans hierarchical task reduction
partial order plan space planner constructs plans protecting underlying causal structure dersnlp ebl extends case normal course
plan refinement defined underlying plan space strategy however dersnlp ebl
implemented within partial order causal link planner snlp mcallester rosenblitt
barrett weld aspect similar spa system developed
hanks weld
different cbp systems may distinguished according case adaptation strategy roughly categorized transformational derivational
carbonell veloso carbonell b according whether transform previous plan replay previous plan derivation transformational strategies priar
spa final plan product episode stored case
library case retrieved plan fitted adapt solving situation retracting irrelevant redundant subparts early cbp systems carbonell
hammond employ transformational techniques adapt previous solution causal link planners snlp ready made plan reuse since causal
structure employed plan adaptation part plan priar spa
use plan causal structure fitting plan context
extending fitted plan solve priar differs spa
employs extension first strategy skeletal plan first refined addition
plan constraints undertaking retraction constraints spa
hand alternates retraction plan constraints addition
constraints mpa ram francis extends spa transformational strategy
accomplish multi case retrieval adaptation


fiihrig kambhampati

mentioned earlier derivational analogy case technique
introduced carbonell veloso carbonell b model developed
veloso prodigy analogy veloso employed case fitting strategy called
derivational replay case fitting replay similar fitting plan reuse
plan underlying causal structure justification
decision stored derivation trace ects causal dependencies plan
steps justified choices replayed solving replay thus serves
purpose retraction plan reuse replay may advantage multi case
reuse since allows planner readily merge small subplans solve large
dersnlp contrasted prodigy analogy employs case fitting
methodology called eager derivation replay ihrig kambhampati
replay strategy applicable cases replayed sequence returning fromscratch eager replay simplifies replay process avoiding decision
alternate replay multiple cases effectiveness dependent
underlying plan space strategy ihrig kambhampati dersnlp
eager case adaptation strategy allows case failure defined terms failure
single node search tree particular case failure defined failure
skeletal plan contains constraints adopted advice
previous cases eager case adaptation means explanations case failure may
constructed use ebl techniques developed explain
analytical failures occurring planner search space

summary conclusion
described design implementation case planner
dersnlp ebl dersnlp ebl framework represents integration eager case adaptation failure ebl ebl techniques employed building case library
basis experienced retrieval failures improves earlier treatments case retrieval barletta mark kambhampati hendler ihrig
kambhampati veloso carbonell partial order case planner
dersnlp ability solve large retrieving multiple instances smaller
subproblems merging cases sequenced replay ihrig kambhampati
dersnlp ebl framework extends use ebl
techniques employed construction case library techniques
used explain plan merging failure identify set negatively interacting goals
library augmented repairing case covering interacting goals
dersnlp ebl method storing multi goal cases goals negatively interacting small library size low retrieval costs however multi case adaptation
involves tradeoff since effort expended merging multiple instances stored cases
dersnlp ebl accomplishes merging increasing justification replay step addition decisions strategy avoids addition redundant steps goals positively
interact dersnlp ebl therefore aimed domains logistics transportation
domain significant amount positive interaction aimed domains
negative interaction course futile spend effort explaining case
failure none encountered


fistoring indexing plan derivations

section describes evaluation overall eciency storage retrieval
strategy solving large complex domain dersnlp ebl shows improvement performance offsets added cost entailed
retrieving failure conditions amount improvement provided replay shown
experiments seen lower bound since random distribution
may mean less similarity found real world
conclusion described novel integrating explanationbased learning techniques case aimed issues
associated pure case rule ebl particular
addresses mis retrieval cbp well utility
demonstrate eager case adaptation combined dersnlp ebl dynamic case
retrieval effective method improving performance

acknowledgements
authors wish thank amol mali eric lambrecht eric parker anonymous
reviewers helpful comments earlier versions thanks due
terry zimmerman providing insight ucpop ebl supported
part nsf initiation award iri nsf young investigator award
iri arpa initiative grants f c phase ii
f c phase iii

references

barletta r mark w explanation indexing cases proceedings
aaai
barrett weld partial order evaluating possible eciency gains
artificial intelligence
bergmann r wilke w building refining abstract cases change
representation language journal artificial intelligence
carbonell j learning analogy formulating generalizing plans past
experience michalski r carbonell j mitchell eds machine learning
artificial intelligence vol palo alto ca tioga press
dejong g mooney r explanation learning alternative view machine learning
doorenbos r production matching large learning systems ph thesis
computer science department carnegie mellon university
fikes r nilsson n application theorem proving
solving artificial intelligence
fox leake introspective reasoning refine indexing proceedings
ijcai


fiihrig kambhampati

francis ram comparative utility analysis case reasoning
control rule learning systems proceedings th european conference
machine learning ecml
friedland p iwasaki concept implementation skeletal plans
journal automated reasoning
gratch j dejong g composer probabilistic solution utility
speed learning proceedings aaai
hammond k explaining repairing plans fail artificial intelligence

hanks weld domain independent plan adaptation journal
artificial intelligence
hendler j stoffel k mulvehill high performance support case
applications technological achievements arpa rome laboratory
initiative advanced technology aaai press
ihrig l kambhampati derivation replay partial order
proceedings aaai
ihrig l kambhampati b plan space vs state space reuse
replay tech rep department computer science engineering arizona
state university available http rakaposhi eas asu edu yochan html
ihrig l kambhampati design implementation replay framework
partial order planner proceedings aaai
joslin roach j theoretical analysis conjunctive goal artificial
intelligence
kambhampati utility tradeoffs incremental modification reuse plans
proceedings aaai spring symposium computational considerations supporting
incremental modification reuse
kambhampati exploiting causal structure control retrieval refitting
plan reuse computational intelligence
kambhampati chen j relative utility ebg plan reuse partial ordering vs total ordering proceedings aaai pp washington
c
kambhampati hendler j validation structure theory plan
modification reuse artificial intelligence
kambhampati ihrig l srivastava b candidate set analysis
subgoal interactions conjunctive goal proceedings rd intl conf
ai systems


fistoring indexing plan derivations

kambhampati katukam qu b failure driven dynamic search control
partial order planners explanation artificial intelligence

kambhampati knoblock c yang q refinement search
unified framework evaluating design tradeoffs partial order artificial
intelligence
koehler j avoiding pitfalls case proceedings nd intl
conf ai systems
korf r search qualitative artificial intelligence

mcallester rosenblitt systematic nonlinear proceedings
aaai
minton issues design operator composition systems proceedings
international conference machine learning
minton b quantitative concerning utility explanation learning artificial intelligence
mostow j bhatnagar n failsafe oor planner uses ebg learn
failures proceedings ijcai
munoz avilla h weberskirch f manufacturing workpieces
storing indexing replaying decisions proceedings rd intl
conf ai systems aaai press
munoz avilla h weberskirch f case study mergeability cases
partial order planner proceedings th european conf
ram cox introspecive reasoning meta explanations multistrategy learning michalski r tecuci g eds machine learning multistrategy
vol iv morgan kaufmann
ram francis multi plan retrieval adaptation experience
agent leake b ed case reasoning experiences lessons future
directions aaai press mit press
redmond distributed cases case reasoning facilitating use multiple
cases proceedings aaai
smyth b keane remembering forget competence preserving deletion
policy cbr proceedings ijcai
tambe n newell rosenbloom p expensive chunks
solution restricting expressiveness machine learning
tate generating project networks proceedings ijcai


fiihrig kambhampati

veloso learning analogical reasoning springer verlag number
lecture notes artificial intelligence
veloso blythe j linkability examining causal link commitments partialorder proceedings nd intl conf ai systems
veloso carbonell j derivational analogy prodigy automating case
acquisition storage utilization machine learning
veloso carbonell j b toward scaling machine learning case study
derivational analogy prodigy minton ed machine learning methods
morgan kaufmann
yang q nau hendler j merging separately generated plans restricted
interactions computational intelligence




