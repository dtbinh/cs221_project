Journal Artificial Intelligence Research 7 (1997) 6782

Submitted 5/97, published 9/97

Identifying Hierarchical Structure Sequences:
linear-time algorithm
Craig G. Nevill-Manning
Ian H. Witten
Department Computer Science
University Waikato, Hamilton, New Zealand.

CGN@CS.WAIKATO.AC .NZ
IHW@CS.WAIKATO.AC .NZ

Abstract
EQUITUR algorithm infers hierarchical structure sequence discrete symbols
replacing repeated phrases grammatical rule generates phrase, continuing
process recursively. result hierarchical representation original sequence,
offers insights lexical structure. algorithm driven two constraints reduce
size grammar, produce structure by-product. EQUITUR breaks new ground
operating incrementally. Moreover, methods simple structure permits proof operates
space time linear size input. implementation process 50,000
symbols per second applied extensive range real world sequences.

1. Introduction
Many sequences discrete symbols exhibit natural hierarchical structure. Text made
paragraphs, sentences, phrases, words. Music composed major sections, motifs, bars,
notes. Records user interface behavior encode hierarchical structure tasks users
perform. Computer programs constitute modules, procedures, statements. Discovering
natural structure underlies sequences challenging interesting problem wide
range applications, phrase discovery music analysis, programming
demonstration code optimization.
search structure sequences occurs many different fields. Adaptive text
compression seeks models sequences used predict upcoming symbols
encoded efficiently (Bell et al., 1990). However, text compression models
extremely opaque, illuminate hierarchical structure sequence. Grammatical
inference techniques induce grammars set example sentences, possibly along set
negative examples (Gold, 1967; Angluin, 1982; Berwick Pilato, 1987). However,
crucial operation input continuous stream segmented sentences,
are, effect, independent examples structure sought. brief review
pertinent systems appears Section 8. Techniques Markov modeling hidden Markov
modeling make attempt abstract information hierarchical form (Rabiner Juang, 1986,
Laird Saul, 1994). Sequence learning occurs areas automaton modeling
(Gaines, 1976), adaptive systems (Andreae, 1977), programming demonstration (Cypher,
1993), human performance studies (Cohen et al., 1990), generally plays peripheral
role.
paper describe SEQUITUR, algorithm infers hierarchical structure
sequence discrete symbols. basic insight phrases appear
replaced grammatical rule generates phrase, process
continued recursively, producing hierarchical representation original sequence. result
1997 AI Access Foundation Morgan Kaufmann Publishers. rights reserved

fiNEVILL-MANNING & WITTEN

strictly grammar, rules generalized generate one string. (It
provide good basis inferring grammar, beyond scope paper.)
scheme resembles one developed arose work language acquisition (Wolff,
1975, 1977, 1980, 1982), operated time quadratic respect length
input sequence, whereas algorithm describe takes linear time. let us investigate
sequences containing several million tokensin previous work examples much smaller,
largest mentioned thousand tokens. Another difference, crucial
importance practical applications, new algorithm works incrementally.
return Wolffs scheme, compare SEQUITUR, Section 8.
ability deal easily long sequences greatly extended range SEQUITURs
application. applied artificially-generated fractal-like sequences produced Lsystems, and, along unification-based rule generalizer, used recover original Lsystem. method inferred relatively compact deterministic, context-free grammars
million-symbol sequences representing biological objects obtained stochastic, contextsensitive, L-systems, turn greatly speeded graphical rendering objects.
applied SEQUITUR 40 Mbyte segments digital library generate hierarchical
phrase indexes text, provides novel method browsing (Nevill-Manning et al.,
1997). algorithm compresses multi-megabyte DNA sequences effectively
general-purpose compression algorithms. Finally, post-processing, elicited
structure two million word extract genealogical database, successfully identifying
structure database compressing much efficiently best known
algorithms. touch applications Section 3 below; Nevill-Manning (1996)
describes all.
paper describes SEQUITUR algorithm evaluates behavior. next section
gives concise description algorithm terms constraints form output
grammar. Section 3 gives taste kind hierarchies SEQUITUR capable inferring
realistic sequences. Section 4 describes implementation detail, particular
emphasis achieves efficiency. Section 5 shows run time storage
requirements linear number input symbols, Section 6 discusses algorithms
behavior extreme input strings. end quantitative analysis SEQUITURs
performance several example sequences, review related research.

2. SEQUITUR Algorithm
SEQUITUR forms grammar sequence based repeated phrases sequence.
repetition gives rise rule grammar, repeated subsequence replaced nonterminal symbol, producing concise representation overall sequence.
pursuit brevity drives algorithm form maintain grammar, and, byproduct, provide hierarchical structure sequence.
left Figure 1a sequence contains repeating string bc. Note
sequence already grammara trivial one single rule. compress it, SEQUITUR forms
new rule bc, replaces occurrences bc. new grammar appears right
Figure 1a.
sequence Figure 1b shows rules reused longer rules. longer
sequence consists two copies sequence Figure 1a. Since represents exact

68

fiI NFERRING SEQUENTIAL STRUCTURE SEQUENCES

repetition, compression achieved forming rule abcdbc replace halves
sequence. gains made forming rule B bc compress rule A.
demonstrates advantage treating sequence, rule S, part grammarrules may
formed rule analogous way rules formed rule S. rules within rules
constitute grammars hierarchical structure.
grammars Figures 1a 1b share two properties:
p 1 : pair adjacent symbols appears grammar;
p 2 : every rule used once.
Property p 1 requires every digram grammar unique, referred
digram uniqueness. Property p2 ensures rule useful, called rule utility.
two constraints exactly characterize grammars SEQUITUR generates.
Figure 1c shows happens properties violated. first grammar contains
two occurrences bc, p1 hold. introduces redundancy bc appears twice.
second grammar, rule B used once, p 2 hold. removed,
grammar would become concise. grammars Figures 1a 1b ones
properties hold sequence. However, always unique grammar
properties. example, sequence Figure 1d represented
grammars right, obey p 1 p2 . deem either grammar acceptable.
Repetitions cannot overlap, string aaa give rise rule, despite containing two
digrams aa.
SEQUITURs operation consists ensuring properties hold. describing
algorithm, properties act constraints. algorithm operates enforcing constraints
grammar: digram uniqueness constraint violated, new rule formed,
rule utility constraint violated, useless rule deleted. next two subsections describe
occurs.
2.1 Digram Uniqueness
SEQUITUR observes new symbol, appends rule S. last two symbols rule
new symbol predecessorform new digram. digram occurs elsewhere
grammar, first constraint violated. restore it, new rule formed digram
right-hand side, headed new non-terminal symbol. two original digrams
replaced non-terminal symbol.
Sequence

Grammar



abcdbc

aAdA
bc

c

abcdbcabcdbc

AA
abcdbc

Sequence

Grammar

b

abcdbcabcdbc

AA
aBdB
B bc



aabaaab

AaA
aab

CC
bc
B aA
C BdA

AbAab
aa

Figure 1 Example sequences grammars reproduce them: (a)
sequence one repetition; (b) sequence nested repetition; (c)
two grammars violate two constraints; (d) two different grammars
sequence obey constraints.

69

fiNEVILL-MANNING & WITTEN

Table 1 shows grammars result successive symbols sequence
abcdbcabcd processed. second column shows sequence observed far, third
column gives grammar created sequence, fourth column notes constraints
violated, actions taken resolve violations.
SEQUITUR adds final c symbol 6, digram bc appears twice. SEQUITUR creates
new rule A, bc right-hand side, replaces two occurrences bc A.
illustrates basic procedure dealing duplicate digrams.
appearance duplicate digram always result new rule. new digram
appears right-hand side existing rule, new rule need created: nonterminal symbol heads existing rule replaces digram. symbol 9 Table 1,
third bc appears, existing non-terminal symbol replaces third occurrence bc.
results new pair repeating digrams, aA, shown next line Table 1. SEQUITUR
accordingly forms new rule B, replaces two occurrences aA. SEQUITUR creates
maintains hierarchy iterative process: substitution bc results new
digram aA, replaced B. larger sequences, changes ripple
grammar, forming matching longer rules higher hierarchy.
symbol
number

string
far

resulting
grammar

remarks

1



Sa

2

ab

ab

3

abc

abc

4

abcd

abcd

5

abcdb

abcdb

6

abcdbc

abcdbc

bc appears twice

aAdA
bc

enforce digram uniqueness

7

abcdbca

aAdAa
bc

8

abcdbcab

aAdAab
bc

9

abcdbcabc

aAdAabc
bc

bc appears twice

aAdAaA
bc

enforce digram uniqueness.
aA appears twice

BdAB
bc
B aA

enforce digram uniqueness

BdABd
bc
B aA

Bd appears twice

CAC
bc
B aA
C Bd

enforce digram uniqueness.
B used

CAC
bc
C aAd

enforce rule utility

10

abcdbcabcd

Table 1 Operation two grammar constraints,
digram uniqueness rule utility

70

fiI NFERRING SEQUENTIAL STRUCTURE SEQUENCES

2.2 Rule Utility
now, right-hand sides rules grammar two symbols long. Longer
rules formed effect rule utility constraint, ensures every rule used
once. Table 1, symbol 10 demonstrates idea. appended rule S,
new digram Bd causes new rule, C, formed. However, forming rule leaves one
appearance rule B, violating second constraint. reason, B removed
grammar, right-hand side substituted one place occurs. Removing B
means rule C contains three symbols. mechanism forming long rules:
form short rule temporarily, subsequent symbols continue match, allow new rule
supersede shorter one delete latter. Although creation deletion rules
appears inefficient first glance, performed efficiently appropriate data
structures. importantly, keeps track long matches within grammar, obviating
need external data structures. simplifies algorithm considerably, permitting concise
proof linear time complexity (see Section 5).

3. Structures Inferred Realistic Sequences
described mechanism SEQUITUR builds grammar, embarking
efficiency issues, instructive consider structures simple technique infer
realistic sequences. case applied SEQUITUR large sample excerpted
part structure illustrative purposes.
Figures 2a, 2b 2c show parts three hierarchies inferred text Bible
English, French, German. hierarchies formed without knowledge preferred
structure words phrases, nevertheless capture many meaningful regularities.
Figure 2a, word beginning split begin ninga root word suffix. Many words
word groups appear distinct parts hierarchy (spaces made visible
replacing bullets). algorithm produces French version Figure 2b,
commencement split analogous way beginninginto root commence
suffix ment. Again, words Au, Dieu cieux distinct units hierarchy.
German version Figure 2c correctly identifies words sentence, well phrase
die Himmel und die. fact, hierarchy heaven Figure 2a bears
similarity German equivalent.
London/Oslo-Bergen corpus (Johansson et al., 1978) contains 1.2 million words tagged
word classes. example, sentence Labour sentiment would still favour
abolition House Lords tagged classes determiner noun noun auxiliary adverb
verb article noun preposition article noun preposition noun. hierarchy SEQUITUR infers
word classes corresponds possible parse sentence corpus,
tree expressed terms parts speech. Figure 2d shows part inferred hierarchy,
tags replaced actual words text. SEQUITUR identifies middle
part sentence, sentiment would still favour abolition large block, part could
stand grammatical sentence. adjectival phrase House Lords
appears distinct unit, Labour, adjectival phrase precedes subject.
Figure 2e shows two Bach chorales SEQUITUR detected internal
repetitionsthe light gray boxes show two halves first chorale almost
identicaland repetitions chorales, denoted gray box second half

71

fiNEVILL-MANNING & WITTEN



n h e b e g n n n g G c r e e h e h e v e n n h e e r h

b

u c e n c e e n , e u c r l e c e u x e l e r r e

c

xx

n f n g c h u f G e H e l u n e E r e



Labour sentiment would still favour abolition House Lords

e

imperfect

perfect

Figure 2 Hierarchies various sequences: Genesis 1:1 (a) English, (b) French, (c) German;
(d) grammatical parse inferred sequence word classes; (e) repetitions within
two chorales harmonized J.S. Bach.
second chorale. section white box occurs four halves. Also, detecting repeated
motifs many chorales, SEQUITUR identifies imperfect perfect cadences end
first second halves, respectively. general, SEQUITUR capable making plausible
inferences lexical structure sequences, hierarchies produces aid comprehension
sequence.

4. Implementation Issues
SEQUITUR algorithm operates enforcing digram uniqueness rule utility constraints.
essential violation constraints detected efficiently, section
describe mechanisms fulfill requirement.
choice appropriate data structure depends kind operations need
performed modify grammar. SEQUITUR are:
appending symbol rule S;
using existing rule;
creating new rule;
deleting rule.
Appending symbol involves lengthening rule S. Using existing rule involves substituting
non-terminal symbol two symbols, thereby shortening rules containing digrams.
Creating new rule involves creating new non-terminal symbol left-hand side,
72

fiI NFERRING SEQUENTIAL STRUCTURE SEQUENCES



B

c

B



b


cd
digram
Bc
index
ab

Figure 3 Data structures rules digram index
inserting two new symbols right-hand side. creating rule, substitutions made
existing rule replacing two digrams new non-terminal symbol. Deleting
rule involves moving contents replace non-terminal symbol, lengthens rule
containing non-terminal symbol; left-hand side rule must deleted.
ensure rules lengthened shortened efficiently, SEQUITUR represents rule
using doubly-linked list whose start end connected single guard node, shown
two rules B Figure 3. guard node serves attachment point left-hand
side rule, remains constant even rule contents change. nonterminal symbol points rule heads, shown Figure 3 pointer nonterminal symbol B rule head rule B. pointers, arrays necessary
accessing rules symbols, operations affect adjacent symbols rules headed
non-terminal.
rule utility constraint demands rule deleted referred once.
rule associated reference count, incremented non-terminal symbol
references rule created, decremented non-terminal symbol deleted.
reference count falls one, rule deleted.
digram uniqueness constraint difficult enforce. new digram appears,
SEQUITUR must search grammar occurrence it. One simple solution would
scan entire grammar time looking match, inefficient leads
quadratic-time algorithm. better solution requires index efficient search.
data structure storing digram index must permit fast access efficient addition
deletion entries. hash table provides constant-time access, adding deleting
entries requires little extra work. digram appears once, table need
contain pointer first symbol single matching digram grammar data structure,
shown Figure 3. hash table consists simple array pointers, collisions
handled open addressing avoid allocation memory chaining requires (Knuth,
1968).
Every time new digram appears grammar, SEQUITUR adds index. new
digram appears result two pointer assignments linking two symbols together doublylinked list (one forward pointer one back pointer). Thus updating index
incorporated low-level pointer assignments. digram disappears grammar
pointer assignment madethe pointer value overwritten assignment
represents digram longer exists.
demonstrate mechanism updating hash table new rule created, Table
2 shows example Figure 1a, addition contents digram index.
second c appended rule S, digram table shows bc already exists grammar,
rule bc created. Creating link b c right-hand side rule
updates entry index bc point new locationthe hash table contains
pointer symbol b start rule A. Next, first bc removed. breaks link
b digram preceding symbol a, ab removed index.
73

fiNEVILL-MANNING & WITTEN

Action

grammar

observe symbol c

abcdbc

change digrams

digram index

make new rule

abcdbc
bc

bc updated

{ab, bc, cd, db}

substitute bc

aAdbc
bc

ab, cd removed,
aA, Ad added

{bc, db, aA, Ad}

substitute bc

aAdA
bc

db removed,
dA added

{bc, dA, aA, Ad}

{ab, bc, cd, db}

Table 2 Updating digram index links made broken
breaks link c following d, cd removed index. Next, replaces
bc, creating links A, well d, adding digrams index.
process continues, resulting correct index digram pointers, costing one
indexing operation per two pointer operations.
Next, SEQUITUR requires efficient strategy checking digram index. Rechecking
entire grammar whenever symbol added infeasible, inefficient large portions
grammar unchanged since last check. fact, parts need checking
links made broken. is, actions affect
maintenance digram table performed, newly created digrams checked
index. course, every time link created, digram entered index,
time check duplicate. entry found already present attempting
add new digram index, duplicate digram detected appropriate
actions performed. Therefore, one hash table lookup required accessing
updating digram index.

5. Computational Complexity
section, show SEQUITUR algorithm linear space time. complexity
proof amortized oneit put bound time required process one symbol,
rather bounds time taken whole sequence. processing time one symbol
fact large O( n ), n number input symbols far. However,
pathological sequence produces worst case requires preceding O( n ) symbols
involve formation matching rules.
basic idea proof two constraints effect reducing
action
1

new input symbol observed, append rule S.

1

2
3
4
5
6
7
8
9

time link made two symbols
new digram repeated elsewhere repetitions overlap,
occurrence complete rule,
replace new digram non-terminal symbol heads rule,
otherwise,
form new rule replace digrams new non-terminal symbol
otherwise,
insert digram index

2

10
11
12

time digram replaced non-terminal symbol
either symbol non-terminal symbol occurs elsewhere,
remove rule, substituting contents place non-terminal symbol

Table 3 SEQUITUR algorithm

74

3
4

5

fiI NFERRING SEQUENTIAL STRUCTURE SEQUENCES

number symbols grammar, work done satisfying constraints bounded
compression achieved sequence. savings cannot exceed original size input
sequence, algorithm linear number input symbols.
Table 3 gives pseudo-code SEQUITUR algorithm. Line 1 deals new observations
sequence, lines 2 9 enforce digram utility constraint, lines 10 12
enforce rule utility. on-line appendix contains implementation SEQUITUR Java,
requires 400 lines algorithm.
numbers right Table 3 identify main sections algorithm, proof
demonstrate bounds number times executes. Action 1 appends
symbols rules performed exactly n times, every symbol input. Link
creation triggers action 2. Action 3 uses existing rule, action 4 forms new rule, action 5
removes rule.
Table 4 shows examples actions 3, 4, 5, associated savings grammar size.
savings calculated counting number symbols grammar
action. non-terminal symbols head rules counted,
recreated based order rules occur. Actions 3 5 actions
reduce number symbols. actions increase size grammar,
difference size input size grammar must equal number
times actions taken.
set stage, proceed proof. formally, let
n size input string,
size final grammar,
r number rules final grammar,
1 number times new symbol seen (action 1),
2 number times new digram seen (action 2),
3 number times existing rule used (action 3),
4 number times new rule formed (action 4),
5 number times rule removed (action 5).
According reasoning above, reduction size grammar number times
actions 3 5 executed. is,
(1)
n = a3 + a5.
Next, number times new rule created (action 4) must bounded. two actions
affect number rules 4, creates rules, 5, deletes them. number
rules final grammar must difference frequencies actions:
r = a4 a5.
equation, r known a5 bounded equation (1), 4 unknown. Noting a1 ,
number times new symbol seen, equal n, total work
action





saving

Matching existing rule

3

...ab...
ab

...A...
ab

1

Creating new rule

4

...ab...ab...

...A...A...
ab

0

Deleting rule

5

...A...
ab

...ab...

1

Table 4 Reduction grammar size three grammar operations

75

fiNEVILL-MANNING & WITTEN

1 + 2 + 3 + 4 + 5 = n + 2 + (n o) + (r + 5 ) .
bound expression, note number rules must less number symbols
final grammar, rule contains least two symbols,
r < o.
Also, expression (1) above,
a5 = n a3 < n.
Consequently,
1 + 2 + 3 + 4 + 5 = 2n + (r o) + a5 + 2 < 3n +a 2 .
final operation bound action 2, checks duplicate digrams. Searching
grammar done hash table lookup. Assuming occupancy less than, say, 80% gives
average lookup time bounded constant (Knuth, 1967). occupancy assured
size sequence known advance, enlarging table recreating entries
whenever occupancy exceeds 80%. number entries table number
digrams grammar, number symbols grammar minus number
rules grammar, symbols end rule form left hand side
digram. Thus size hash table less size grammar, bounded
size input. means memory requirements algorithm linear.
practice, linear growth memory poses problem. One strategy currently
investigating break input small segments, form grammars them,
merge resulting grammar.
number times action 2 carried out, digram checked new
link created. Links created actions 1, 3, 4 5, already shown
bounded 3n, time required action 2 O(n).
Thus shown algorithm linear space time. However, claim must
qualified: based register model computation rather bitwise one.
assumed average lookup time hash table digrams bounded constant.
However, length input increases, number rules increases without bound,
unstructured (e.g., random) input, digram table grow without bound. Thus time
required execute hash function perform addressing constant,
increase logarithmically input size. proof ignores effect: assumes hash
function operations register-based therefore constant time. practice, 32-bit
architecture, linearity proof remains valid sequences around 109 symbols,
64-bit architecture 1019 symbols.

6. Exploring Extremes
described SEQUITUR algorithmically, characterize behavior variety
domains. section explores large small grammar given sequence length,
well determining minimum maximum amount work algorithm carry
amount work required process one symbol. Figure 4 summarizes extreme
cases, giving part example sequence grammar results. Bounds given
terms n, number symbols input.
deepest hierarchy formed depth O( n ), example sequence
creates hierarchy shown Figure 4a. order hierarchy deepen every
rule, rule must contain non-terminal symbol. Furthermore, rule need longer two

76

fiI NFERRING SEQUENTIAL STRUCTURE SEQUENCES

symbols. Therefore, produce deep hierarchy short string, rule one
terminal symbol longer one builds. order create rules, string
represented must appear two different contexts; otherwise rule incorporated
longer rule. One context deepest hierarchy, must participate. context
hierarchy, reduce size input string, appear rule S.
Note every rule Figure 4a appears hierarchy rule S. repetition
sequence, one terminal symbol appended, producing new level hierarchy.
point including repetition length one, mth repetition length + 1.
repetition gives rise mth rule (counting rule S). total length sequence
hierarchy depth therefore
n = 2 + 3 + 4 + ... + (m + 1) = O(m2)
deepest hierarchy depth = O( n ).
end spectrum, grammar shallowest hierarchy, shown
Figure 4b, rules apart rule S. grammar largest possible one
sequence given length, precisely rules formed it. sequence
gives rise one digram ever recurs. course, sequence alphabet
size ||, O(||2) different digrams, bounds length sequence.
kind sequence produces worst case compression: repetitions,
therefore SEQUITUR detects structure.
bound

example sequence

example grammar



deepest hierarchy

O(n)

ababcabcdabcdeabcdef

ABCDDf
ab
B Ac
C Bd
Ce

b

largest grammar;
shallowest hierarchy

n

aabacadae...bbcbdbe...

aabacadae...

c

smallest grammar

O(log n)

aaaaaaaaaaaaaa...

DD
aa
B AA
C BB
CC



largest number rules

n/4

aaaaababacacadad...

AABBCCDD
aa
B ab
C ac
ad

e

maximum processing
one symbol

O(n)

yzxyzwxyzvwxy

ABwBvwxy
yz
B xA

f

greatest number rule
creations deletions

n new rules
n deleted rules

abcdeabcdeabcde...

AAA...
abcde

Figure 4 extreme cases algorithm

77

fiNEVILL-MANNING & WITTEN

Turning largest grammar smallest, Figure 4c depicts grammar formed
ordered sequence possibleone consisting entirely symbol. four
contiguous symbols appear, aaaa, rule B aa formed. another four appear,
rule contains BBBB, forming new rule C BB. Every time number symbols doubles,
new rule created. hierarchy thus O(log n) deep, grammar O(log n) size.
represents greatest data compression possible, although necessary sequence
one symbol achieve logarithmic lower boundany recursive structure do.
produce grammar greatest number rules, rule include
terminal symbols, building hierarchy reduce number rules required cover
sequence given size. Furthermore, rule longer two symbols occur
twice. Therefore rule requires four symbols creation, maximum
number rules sequence length n n/4, shown Figure 4d.
discussed size grammars, consider effort involved
maintaining them. shown upper bound processing sequence linear
length sequence. However, still useful characterize amount processing
involved new symbol. Figure 4e shows sequence repetition built yz,
xyz, wxyz, forth. second occurrence wxyz appears, matches
possible w, x, y. z appears, yz matches rule A, xA matches rule B.
Finally, SEQUITUR forms new rule wB. cascading effect arbitrarily large
repetitions continue build right-to-left fashion. amount processing required
deal last z proportional depth deepest hierarchy, matching cascades
hierarchy. maximum time process one symbol therefore O( n ). fact w,
x, fail match means require little time process, preserving overall linear
time bound.
Although bound linear, sequences certainly differ proportion work sequence
length. sequence Figure 4b, repetitions exist grammar formed,
minimizes ratio. sequence Figure 4f, consists multiple repetitions multisymbol sequence, maximizes it. time repetition appears several rule deletions
creations match lengthens. fact, every symbol except incurs rule creation
subsequent deletion, O(n) creations deletions. length repetition,
proportion symbols incur work 1/m, tends toward zero
repetition length approaches infinity.

7. Behavior Practice
give idea SEQUITUR behaves realistic sequences, turn artificial cases
sequence English text. Figure 5a plots number rules grammar number
input symbols 760,000 character English novel, shows increase
approximately linear. Figure 5b shows approximately linear growth total number
symbols grammar. growth number unique words text, shown
Figure 5c, high start drops toward end. Zobel, et al. (1995) observed
much larger samples English text thatsurprisinglynew words continue appear fairly
constant rate, corresponding neologisms names, acronyms, typographical
errors. example, number rules grows linearly because, words
recognized, multi-word phrases constructed, number phrases unbounded.

78

fiI NFERRING SEQUENTIAL STRUCTURE SEQUENCES

nearly linear growth number symbols grammar seems disappointing,
fact inevitable consequence information content English. Since symbols end
text convey similar amount information symbols beginning, lower
bound achievable compression rate. English text, corresponds entropy
English.
EQUITUR operates quicklyas shown Figure 5d, 760,000 character novel
processed 16 seconds: rate 50,000 symbols per second, 3 Mb per minute. figure
illustrates SEQUITURs linear-time behavior practice. sequence Figure 4b,
repetitions exist rules formed, fast process, indeed processed
rate 150,000 symbols per secondthree times faster novel. sequence Figure 4f,
consists multiple repetitions multi-symbol sequence, slows performance 14,000
symbols per seconda ten-fold decrease fastest sequence. sequence Figure 4c,
consists many repetitions single character forms concise grammar, comes
50,000 symbols per second; novel. measurements performed
Silicon Graphics Indigo 2.
EQUITUR effective data compression scheme outperforms schemes
achieve compression factoring repetition, approaches performance schemes


b

200000

symbols grammar

rules grammar

30000

20000

10000

150000

100000

50000

0

0
0

c

200000

400000 600000
input symbols

800000



10000

5000

200000

400000 600000
input symbols

800000

0

200000

400000 600000
input symbols

800000

15

time (seconds)

vocabulary size

15000

0

10

5

0

0
0

200000

400000 600000
input symbols

800000

Figure 5 Growth rates English text: (a) rules grammar; (b) symbols
grammar; (c) vocabulary size input; (d) time

79

fiNEVILL-MANNING & WITTEN

compress based probabilistic predictions. SEQUITURs implementation evaluation
compression scheme described Nevill-Manning Witten (1997).

8. Related Work
mentioned introduction, research resembles work Wolff (1975).
described SEQUITUR, possible contrast Wolffs system, MK10, processes
sequence left right, forms chunk (equivalent SEQUITUR rule) whenever
digram seen 10 times. happens, occurrences digram replaced
non-terminal symbol, system either carries sequence, restarts
beginning. either case, digram frequencies discarded process starts over. worst
case algorithm corresponds sequence Figure 4f, long exact
repetitions. symbol repeated segment gives rise chunk, process starts
over. Figure 4f, length repetition linear length sequence,
number restarts length repetition, algorithm quadratic length
sequence. makes processing million-symbol sequences impractical.
number systems, Langley (1994), Stolcke Omohundro (1994), Cook et al.
(1976), form new grammar rules repeated sequences, merge rules generalize
grammars. However, operate different domainas input, expect set sentences
drawn language, rather single long sequence. allows make inferences
based directly comparing corresponding parts different sequences. Furthermore, small
size training data means efficiency lesser concern. performance
algorithms measured ability accept test sentences language, reject
new sentences target languages. SEQUITURs case, one
sequence available, metric apply.
VanLehn Ball (1987) infer grammars sets sentences. algorithm
enforces three constraints grammars purpose making version space finite.
are: (1) rule empty right side, (2) rule one symbol right side,
symbol terminal, (3) every non-terminal appears derivation string.
constraints reminiscent SEQUITURsfor example, third constraint weaker form
SEQUITURs rule utilitybut serve different purpose. SEQUITUR, operational;
drive formation grammar. VanLehn Balls work, make version space
tractable providing sensible restrictions form grammar, algorithm
search space.

9. Conclusion
paper presented EQUITUR , algorithm identifying hierarchical structure
sequences. Based idea abstracting subsequences occur rules
continuing operation recursively, algorithm works maintaining two constraints:
every digram grammar must unique, every rule must used once.
EQUITUR operates incrementally and, subject caveat register model
computation used, linear space time. efficiency permitted application long
sequencesup 40 Mbytein many different domains.
evaluated prediction accuracy EQUITUR paper. Evaluating
prediction accuracy fairly complex business. adequate simply give count
80

fiI NFERRING SEQUENTIAL STRUCTURE SEQUENCES

correct versus incorrect predictions, begs question likelihood
different ones occurring. Prediction schemes assign probabilities predictions
might offer, judged discrepancy probabilistic predictions
true upcoming symbols. whole question accurate probabilistic prediction sequences
tantamount compression sequences, substantial field right (Bell et al.,
1990). fact evaluated SEQUITURs performance compression found vies
best compression algorithms, particularly large amount text available
(Nevill-Manning Witten, 1997). point present paper different one:
SEQUITUR re-represents sequence way exposes underlying structure. fair say
compression algorithm produces representation way perspicuous.
Perhaps greatest drawback SEQUITUR algorithm memory usage,
linear size grammar. Linear memory complexity ordinarily considered intractable,
although practice EQUITUR works well sequences rather impressive size.
clearly room approximate versions algorithm partition input re-merge
grammars formed them, could perhaps applied recursively create algorithm
logarithmic memory requirements. conjecture, however, approximations
doubt turn useful practice, inevitably sacrifice property
digram uniqueness appealing feature original algorithm.

Acknowledgments
grateful many detailed suggestions Pat Langley anonymous referees.

References
Andreae, J.H. (1977) Thinking teachable machine. London: Academic Press.
Angluin, D. (1982) Inference reversible languages, Journal Association Computing
Machinery, 29, 741765.
Bell, T.C., Cleary, J.G., Witten, I.H. (1990) Text compression. Englewood Cliffs, NJ:
Prentice-Hall.
Berwick, R.C., Pilato, S. (1987) Learning syntax automata induction, Machine Learning,
2, 938.
Cohen, A., Ivry, R.I., Keele, S.W. (1990) Attention structure sequence learning,
Journal Experimental Psychology, 16(1), 1730.
Cook, C.M., Rosenfeld, A., & Aronson, A. (1976). Grammatical inference hill climbing,
Informational Sciences, 10, 59-80.
Cypher, A., editor (1993) Watch do: programming demonstration, Cambridge,
Massachusetts: MIT Press.
Gaines, B.R. (1976) Behaviour/structure transformations uncertainty, International Journal
Man-Machine Studies, 8, 337365.
Gold, M. (1967) Language identification limit, Information Control, 10, 447474.
Johansson, S., Leech, G., Goodluck, H. (1978) Manual Information Accompany
Lancaster-Oslo/Bergen Corpus British English, Use Digital Computers,
Oslo: Department English, University Oslo.

81

fiNEVILL-MANNING & WITTEN

Knuth, D.E. (1968) art computer programming 1: fundamental algorithms. AddisonWesley.
Laird, P. & Saul, R. (1994) Discrete sequence prediction applications, Machine Learning
15, 4368.
Langley, P. (1994). Simplicity representation change grammar induction. Unpublished
manuscript, Robotics Laboratory, Computer Science Department, Stanford University,
Stanford, CA.
Nevill-Manning, C.G. & Witten, I.H. Compression explanation using hierarchical grammars,
Computer Journal, press.
Nevill-Manning, C.G. (1996) Inferring sequential structure, Ph.D. thesis, Department
Computer Science, University Waikato, New Zealand.
Nevill-Manning, C.G., Witten, I.H. & Paynter, G.W. (1997) Browsing digital libraries:
phrase-based approach, Proc. Second ACM International Conference Digital
Libraries, 230236, Philadelphia, PA.
Rabiner, L.R. Juang, B.H. (1986) introduction hidden Markov models, IEEE ASSP
Magazine, 3(1), 416.
Stolcke, A., & Omohundro, S. (1994). Inducing probabilistic grammars Bayesian model
merging. Proc. Second International Conference Grammatical Inference
Applications, 106118, Alicante, Spain: Springer-Verlag.
VanLehn, K., & Ball, W. (1987). version space approach learning context-free grammars.
Machine Learning, 2, 3974.
Wharton, R. M. (1977). Grammar enumeration inference. Information Control, 33, 253272.

Wolff, J.G. (1975) algorithm segmentation artificial language analogue, British
Journal Psychology, 66, 7990.
Wolff, J.G. (1977) discovery segments natural language, British Journal Psychology,
68, 97106.
Wolff, J.G. (1980) Language acquisition discovery phrase structure, Language
Speech, 23(3), 255269.
Wolff, J.G. (1982) Language acquisition, data compression generalization, Language
Communication, 2(1), 5789.

82


