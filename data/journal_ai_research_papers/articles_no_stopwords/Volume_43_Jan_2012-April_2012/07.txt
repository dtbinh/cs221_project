Journal Artificial Intelligence Research 43 (2012) 419476

Submitted 08/11; published 03/12

Completeness Guarantees Incomplete Ontology
Reasoners: Theory Practice
Bernardo Cuenca Grau
Boris Motik
Giorgos Stoilos
Ian Horrocks

bernardo.cuenca.grau@cs.ox.ac.uk
boris.motik@cs.ox.ac.uk
giorgos.stoilos@cs.ox.ac.uk
ian.horrocks@cs.ox.ac.uk

Department Computer Science, University Oxford
Wolfson Building, Parks Road, OX1 3QD, Oxford

Abstract
achieve scalability query answering, developers Semantic Web applications
often forced use incomplete OWL 2 reasoners, fail derive answers
least one query, ontology, data set. lack completeness guarantees, however,
may unacceptable applications areas health care defence,
missing answers adversely aect applications functionality. Furthermore, even
application tolerate level incompleteness, often advantageous
estimate many kind answers lost.
paper, present novel logic-based framework allows one check whether
reasoner complete given query Q ontology is, whether reasoner
guaranteed compute answers Q w.r.t. arbitrary data set A. Since
ontologies typical queries often fixed application design time, approach allows
application developers check whether reasoner known incomplete general
actually complete kinds input relevant application.
present technique that, given query Q, ontology , reasoners
R1 R2 satisfy certain assumptions, used determine whether,
data set A, reasoner R1 computes answers Q w.r.t. reasoner R2 .
allows application developers select reasoner provides highest degree
completeness Q compatible applications scalability requirements.
results thus provide theoretical practical foundation design future
ontology-based information systems maximise scalability minimising even
eliminating incompleteness query answers.

1. Introduction
Ecient management querying large amounts data core problem growing
range applications fields diverse biology (Sidhu, Dillon, Chang, & Sidhu, 2005),
medicine (Golbreich, Zhang, & Bodenreider, 2006), geography (Goodwin, 2005), astronomy
(Derriere, Richard, & Preite-Martinez, 2006), agriculture (Soergel, Lauser, Liang, Fisseha,
Keizer, & Katz, 2004), defence (Lacy, Aviles, Fraser, Gerber, Mulvehill, & Gaskill,
2005). order facilitate interoperability, applications often use standard data
models query languages. particular, RDF (Hayes, 2004) provides standard model
semistructured data, SPARQL (Prudhommeaux & Seaborne, 2008) standard query
language RDF, ontology languages OWL (Horrocks, Patel-Schneider, &
van Harmelen, 2003) OWL 2 (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider,
c
2012
AI Access Foundation. rights reserved.

fiCuenca Grau, Motik, Stoilos & Horrocks

& Sattler, 2008b) used describe background knowledge application
domain. Thus, answering SPARQL queries RDF data sets structured using OWL
ontology key service ontology-based information systems.
important question design systems selection appropriate
reasoner. Systems Pellet (Sirin, Parsia, Cuenca Grau, Kalyanpur, & Katz, 2007),
HermiT (Motik, Shearer, & Horrocks, 2009b), RACER (Haarslev & Moller, 2001)
based (hyper)tableau algorithms provably completethat is, guaranteed compute answers query, ontology, data set. Completeness, however,
comes cost scalability, answering queries OWL 2 ontologies high computational complexity (Glimm, Horrocks, Lutz, & Sattler, 2007; Ortiz, Calvanese, & Eiter,
2008; Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007; Lutz, Toman, & Wolter,
2009). Thus, complete systems often fail meet scalability demands applications
manage data sets consisting hundreds millions even billions assertions.
Scalability query answering ensured restricting expressive power
ontology language level makes provably complete reasoning tractable.
led development three profiles OWL 2 (Motik, Cuenca Grau, Horrocks, Wu,
Fokoue, & Lutz, 2009a): OWL 2 EL, OWL 2 RL, OWL 2 QL. Query answering
three profiles implemented polynomial time w.r.t. size data (and even
logarithmic space case OWL 2 QL). appealing theoretical properties
spurred development specialised reasoners QuONTO (Acciarri, Calvanese,
De Giacomo, Lembo, Lenzerini, Palmieri, & Rosati, 2005) target specific profiles
typically reject ontologies fall outside target profile.
dierent solution scalability problem adopted reasoners Oracles Semantic Data Store (Wu, Eadon, Das, Chong, Kolovski, Annamalai, & Srinivasan,
2008), Sesame (Broekstra, Kampman, & van Harmelen, 2002), Jena (McBride, Brian, 2001),
OWLim (Kiryakov, Ognyanov, & Manov, 2005), Minerva (Ma, Yang, Qiu, Xie, Pan, & Liu,
2006), DLE-Jena (Meditskos & Bassiliades, 2008), Virtuoso (Erling & Mikhailov, 2009).
reasoners accept OWL 2 ontologies inputthat is, never reject inputs.
Furthermore, best knowledge, systems intended sound,
means results query indeed correct answers. Finally, reasoners
typically use scalable reasoning techniques, various (deductive) database algorithms.
consequence, reasoners incomplete: reasoner, least one query, ontology, data set exist reasoner return answers query.
reasoners actually designed complete particular profile
OWL 2 (typically OWL 2 RL due close connection datalog),
often additionally handle certain kinds axiom fall outside target profile.
Since incomplete reasoners handle large data sets, often provide best practical choice developers ontology-based applications. example, OWLim used
reasoning backend BBCs 2010 World Cup website, Oracles reasoner
used University Texas Health Science Center improve large-scale public
health surveillance. order verify selected reasoner meets applications
requirements, developers typically resort empirical testing, check reasoners answers w.r.t. application ontology queries representative data sets.
Although primarily intended testing performance, benchmark suites Lehigh
420

fiCompleteness Guarantees Incomplete Ontology Reasoners

University Benchmark (LUBM) (Guo, Pan, & Heflin, 2005) University Ontology
Benchmark (UOBM) (Ma et al., 2006) used completeness testing.
Empirical completeness testing, however, several important limitations. First, tests
generic, data sets used testing typically fixed and/or repetitive structure, skew test results. Second, test data exhaustive, completeness
tested w.r.t. limited number data sets. Finally, query answers may verifiable: since complete reasoners fail handle large data sets, often cannot compute
control answers needed check answers produced incomplete reasoner.
consequence, empirical completeness tests provide limited assurance reasoners
ability meet requirements given application.
paper, present radically dierent approach solving problems.
observed that, given query Q ontology , even reasoner complete
language , reasoner may able correctly answer Q w.r.t. arbitrary data
set A; case, say reasoner (Q, )-complete. Given ontology-based
applications often use limited set queries fixed ontology (or least queries
ontology evolve relatively slowly), scalable reasoner generally incomplete,
(Q, )-complete relevant combinations Q , may provide solid foundation
ontology-based applications, allowing enjoy best worlds: regardless
data set encountered, applications enjoy completeness guarantees normally
available computationally-intensive complete reasoners, time
exhibiting scalability levels normally available sacrificing completeness. develop
approach testing (Q, )-completeness given reasoner, proceed follows.
Section 3 develop logic-based framework allows us establish formally
provable (Q, )-completeness guarantees. following two notions central
framework. First, order abstract away implementation details concrete
reasoners, introduce notion abstract reasoner idealised reasoner captures intended behaviour salient features (such soundness monotonicity)
class concrete reasoners. Second, introduce notion test suitea finite set
data sets queries. Intuitively, given Q , goal construct test suite
that, reasoner correctly answers queries data sets test suite,
reasoner guaranteed (Q, )-complete.
Unfortunately, show Section 3.4, certain Q , impossible
construct finite test suite provide aforementioned completeness guarantees.
Therefore, investigate assumptions Q, , reasoner testing (Q, )completeness becomes practically feasible.
Section 3.5 consider case Q rewritten union
conjunctive queries Rthat is, answering Q w.r.t data set equivalent
evaluating R A. expressed OWL 2 QL, rewriting R computed
using algorithm Calvanese et al. (2007); additionally, algorithm Perez-Urbina,
Motik, Horrocks (2010) sometimes compute R even syntactically outside
fragment. show R converted test suite ER used
testing (Q, )-completeness reasoner satisfies basic assumptions;
roughly speaking, reasoners answers depend names individuals
occurring data set, answers must increase monotonically new data added.
size test ER polynomial size longest conjunctive query R,
421

fiCuenca Grau, Motik, Stoilos & Horrocks

feasible compute correct answers tests using complete reasoner.
number tests ER , however, exponential size R, may lead
problems practice. remedy, Section 3.6 strengthen assumptions require
reasoner drop answers merging individualsthat is, reasoner returns
given inputs Q, , A, (possibly noninjective) mapping reasoner
returns (a) given inputs Q, , (A)and show (Q, )-completeness
reasoners checked using test suite IR obtained R linear transformation.
Q rewritable union conjunctive queries eectively prevents stating recursive axioms. overcome restriction, Section 3.7 consider first-order reproducible reasonersthat is, reasoners whose behaviour Q, ,
seen computing certain answers Q w.r.t. (possibly unknown) first-order
theory FT A. Since FT datalog program, reasoners based deductive
databases first-order reproducible. addition, require Q rewritable
datalog, extension datalog allows existential quantifiers disjunction rule heads. many cases, transformed datalog, program
using equivalence-preserving transformations; furthermore, algorithm Perez-Urbina
et al. (2010) many cases produce plain datalog rewriting. show
transform datalog, rewriting Q test suite used test
(Q, )-completeness first-order reproducible reasoners.
Section 4 turn attention comparing incomplete reasoners. Roughly speaking, given Q , reasoner R1 complete reasoner R2 if, data set A,
reasoner R1 computes answers Q w.r.t. computed R2 .
show comparing incomplete reasoners infeasible general. Therefore, introduce
notion compact reasonersthat is, reasoners whose behaviour Q, ,
seen first selecting subset using complete reasoner evaluate
Q w.r.t. A. Thus, class compact reasoners captures reasoners reduce
input ontology set axioms match certain parameters, fitting
language fragments. Q rewritten union conjunctive queries
R, show test suite IR used compare compact reasoners.
implemented approaches computing test suites, tested completeness several well-known reasoners (see Section 5). show test suites
eciently computed realistic ontologies. Furthermore, able guarantee
(Q, )-completeness evaluated reasoners many queries ontologies. Finally,
(Q, )-completeness guarantee could provided, able compute
counter-examplea small data set reasoner hand incomplete.

2. Preliminaries
section briefly introduce Description Logics (DLs) (Baader, McGuinness, Nardi, &
Patel-Schneider, 2002)a family knowledge representation formalisms underpin
OWL OWL 2 ontology languages. describe description logics wider
framework first-order logic since many results hold arbitrary first-order theories.
introduce datalog, datalog languages, define syntax
semantics unions conjunctive queries (UCQs). Finally, introduce notions
UCQ, datalog, datalog, rewritings, underpin many techniques.
422

fiCompleteness Guarantees Incomplete Ontology Reasoners

2.1 Description Logics First-Order Logic
results paper hold arbitrary first-order theories, rather description logics. work, however, motivated description logics ontologies, use
DL terminology throughout paper; example, often talk TBoxes
ABoxes instead first-order theories sets facts.
definitions paper implicitly parameterised signature = P , ,
consists countably infinite disjoint sets predicates P individuals (commonly
called constants first-order logic) . predicate associated nonnegative
arity; predicates zero arity commonly called propositional symbols. notions
variables, terms, atoms, first-order formulae, sentences defined usual (Fitting,
1996); consider function symbols article assume formulae
function-free. atom false (true) interpretations written ().
atom fact contain variables. use standard first-order notions
satisfiability, unsatisfiability, entailment (written |=) sets first-order sentences.
assume P contains special equality inequality predicates ,
respectively; atoms form (t1 , t2 ) (t1 , t2 ) commonly written t1 t2
t1 t2 , respectively. make technical assumption distinct predicates
rather than, common first-order logic, t1 t2 abbreviation (t1 t2 );
furthermore, assume theory uses axiomatises semantics
follows, (5) instantiated predicate P arity n 1 n.
x, y.[x x ]

(1)

x, y.[x x]

(3)

x1 , . . . , xi , . . . , xn , yi .[P (x1 , . . . , xi , . . . , xn ) xi yi P (x1 , . . . , yi , . . . , xn )]

(5)

x.[x x]

(2)

x, y, z.[x z x z]

(4)

Note that, according assumption, set facts satisfiable. example,
set atoms {a b, b} satisfiable since b b positive variable-free
atoms semantically independent other; moreover, axiom (1) required
obtain expected contradiction.
individual renaming (often renaming) partial function :
maps individuals individuals. domain range written dom()
rng(); unless otherwise noted, assume dom() finite. object containing
individuals (such formula, set formulae, tuple individuals), ind()
set individuals occurring , () obtained simultaneously replacing
individual ind() dom() (a).
use notion substitutions first-order logic; is, substitution
mapping variables terms. term, atom, formula, result applying
substitution written ().
TBox finite set first-order sentences contains axioms (1)(5) whenever
and/or used. ABox finite set facts. Note definition allows
atoms form b b ABoxes; furthermore, since ABoxes contain
positive atoms, ABox (when considered without TBox) satisfiable.
423

fiCuenca Grau, Motik, Stoilos & Horrocks

DL Name
EL
FL
ALC
+(H)
+(R)
+(S)
+(I)
+(Q)
+(O)

Roles
R
R
R

Concepts
, A, C1 C2 , R.C
, A, C1 C2 , R.C
, , A, C, C1 C2 , C1 C2 , R.C, R.C
R.Self

TBox Axioms
C1 C2
C1 C2
C1 C2
R1 R2
RS
Trans(R)

R
nS.C, nS.C
{a}

Table 1: Syntax standard description logics. Typical extensions EL, ALC, FL
named appending calligraphic letters (H, R, S, I, Q, and/or O).
description logic DL (usually infinite) recursive set TBoxes satisfying
following conditions:
DL renaming , (T ) DL,
DL , DL.

DL, say DL-TBox. Finally, FOL largest description logic
contains finite sets first-order sentences signature question.
next present overview DLs commonly considered literature. Typically, predicates DL signatures required unary binary; former
commonly called atomic concepts latter commonly called atomic roles. DLs
typically use specialised syntax, summarised Table 1, provides set constructors
constructing complex concepts roles simpler ones, well dierent kinds
axioms. Using translation Table 2, concepts translated first-order
formulae one free variable, roles translated first-order formulae two
free variables, axioms translated first-order sentences. Note translation uses counting quantifiers n n , expressed using ordinary
quantifiers equality well-known transformations.
rest paper, commonly write TBoxes ABoxes DL syntax; however,
simplify presentation, identify written DL syntax (T ) (A).
2.2 Datalog,
next introduce fragment first-order logic called datalog, extension
datalog Cal, Gottlob, Lukasiewicz, Marnette, Pieris (2010). datalog, rule
(or commonly rule) r formula form (6), Bj atom dierent
whose free variables contained x,
= 1 1 (x, y1 ) = ,

1 and, 1 m, formula (x, yi ) conjunction atoms dierent
whose free variables contained x yi .
424

fiCompleteness Guarantees Incomplete Ontology Reasoners

Mapping DL roles first-order logic
(R, x, y) = R(x, y)
(R , x, y) = R(y, x)
Mapping DL concepts first-order logic
(, x, y) =
(, x, y) =
(A, x, y) = A(x)
({a}, x, y) = x
(C, x, y) = (C, x, y)
(C D, x, y) = (C, x, y) (D, x, y)
(C D, x, y) = (C, x, y) (D, x, y)
(R.C, x, y) = y.[(R, x, y) (C, y, x)]
(R.Self, x, y) = R(x, x)
(R.C, x, y) = y.[(R, x, y) (C, y, x)]
( nS.C, x, y) = n y.[(S, x, y) (C, y, x)]
( nS.C, x, y) = n y.[(S, x, y) (C, y, x)]
Mapping TBox axioms first-order logic
(C D) = x.[(C, x, y) (D, x, y)]
(R S) = x, y.[(R, x, y) (S, x, y)]
(Trans(R)) = x, y, z.[(R, x, y) (R, y, z) (R, x, z)]
(R ) = x, y, z.[(R, x, y) (S, y, z) (T, x, z)]
Mapping ABox axioms first-order logic
(C(a)) = (C, a, y)
(R(a, b)) = R(a, b)
(a b) = b
(a b) = b
Table 2: Translation DL syntax first-order logic

x.[B1 . . . Bn




i=1

yi .i (x, yi )]

(6)

rule safe variable x occurs Bj ; unless otherwise noted, rules
assumed safe. brevity, outer quantifier x commonly left implicit.
body r
set atoms body(r) = {B1 , . . . , Bn }, head r formula
head(r) =
yi .i (x, yi ). datalog, program finite set safe datalog, rules.
i=1
Note that, since treated ordinary predicates, occur rules, provided
semantics appropriately axiomatised; furthermore, note latter
achieved using datalog, rules.
Let r datalog, rule. Then, r datalog rule head(r) contains existential
quantifier. Also, r datalog rule = 1. Finally, r datalog rule = 1
head r single atom without existential quantifiers (Ceri, Gottlob, & Tanca, 1989).
several places paper, check whether set first-order sentences entails
datalog, rule, accomplished using following simple result.
425

fiCuenca Grau, Motik, Stoilos & Horrocks

Proposition 2.1. Let F set first-order sentences, let r datalog, rule
form (6). Then, substitution mapping free variables r distinct
individuals occurring F r, F |= r
F {(B1 ), . . . , (Bn )} |=




i=1

yi .i ((x), yi )

Proof. Let x tuple free variables r let arbitrary substitution
mapping variables x distinct individuals occurring F r. claim
proposition follows following equivalences:
F |= x.[B1 . . . Bn




yi .i (x, yi )]

i=1



F {[x.B1 . . . Bn
F {x.[B1 . . . Bn

F {(B1 ) . . . (Bn )
F {(B1 ), . . . , (Bn ),






yi .i (x, yi )]} unsatisfiable

(skolem. x)




i=1

yi .i ((x), yi )} unsatisfiable

yi .i ((x), yi )} unsatisfiable

i=1



F {(B1 ), . . . , (Bn )} |=

yi .i (x, yi )]} unsatisfiable

i=1



i=1

i=1






yi .i ((x), yi ).

2.3 Queries
order achieve high degree generality, define query Q finite set firstorder sentences containing distinct query predicate Q. Intuitively, query predicate Q
determines answers Q. order simplify notation, typically assume
association Q query predicate implicit (e.g., may require query
contain precisely one predicate), assume query predicate occurs
TBox ABox.
tuple constants certain answer query Q query predicate Q
respect TBox ABox arity agrees arity Q
Q |= Q(a). set certain answers Q w.r.t. denoted
cert(Q, , A). query predicate Q propositional (i.e., query Boolean),
cert(Q, , A) either empty contains tuple zero length; cases,
commonly write cert(Q, , A) = f cert(Q, , A) = t, respectively.
use special Boolean query checks first-order theory unsatisfiability.
Thus, cert(, , A) = unsatisfiable.
query Q query predicate Q union conjunctive queries (UCQ)
datalog program rule contains Q head body. UCQ Q
conjunctive query (CQ) contains exactly one rule.
426

fiCompleteness Guarantees Incomplete Ontology Reasoners

union conjunctive queries Q ground if, rule r Q, variable occurring body r occurs head r. Roughly speaking, computing
cert(Q, , A) ground Q, variables Q matched individuals
A, unnamed objects whose existence guaranteed existential quantifiers.
Many state art reasoners used practice support ground UCQs. Note
Q = {A(x) Q(x), R(x, y) Q(x, y)} ground UCQ; fact, Q even valid
first-order theory since predicate Q unique arity. obtain UCQ, one
pad head first rulethat is, one introduce special fresh individual null
rewrite rules Q = {A(x) Q(x, null ), R(x, y) Q(x, y)}.
properties first-order logic entailment, cert satisfies following properties
query Q, TBoxes , ABoxes .
1. Monotonicity: imply
cert(, , A) = implies cert(, , ) = t,
cert(Q, , A) cert(Q, , ).

2. Invariance renamings: renaming tuple individuals a,
cert(, , A) = implies cert(, (T ), (A)) = t,

cert(Q, , A) implies (a) cert((Q), (T ), (A)).
2.4 Rewritings
Intuitively, rewriting query Q w.r.t. TBox another query captures
information relevant answering Q arbitrary ABox (Calvanese
et al., 2007; Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009; Perez-Urbina et al.,
2010). practice, UCQs (Calvanese et al., 2007) datalog (Perez-Urbina et al., 2010)
widely used target languages query rewriting. sake generality,
however, paper use notion datalog, rewriting.
Definition 2.2. Let Q query let TBox. datalog, rewriting (or simply
rewriting) Q w.r.t. triple R = RD , R , RQ
RD datalog, program containing Q |= RD ,
R datalog program head(r) = r R ,
RQ UCQ whose query predicate Q,
following properties hold ABox A:
cert(, , A) = cert(, RD R , A),
cert(, , A) = f, cert(Q, , A) = cert(RQ , RD R , A).
Rewriting R datalog rewriting RD datalog program. Furthermore, rewriting R
UCQ rewriting RD = ; R usually written R = R , RQ .
427

fiCuenca Grau, Motik, Stoilos & Horrocks

Note Definition 2.2 requires |= RD hold, precludes rewritings consisting
axioms unsound w.r.t. . example, let Q = {A(x) Q(x)} = ;
then, RD = {B(x) A(x)} satisfy definition rewriting since formula
B(x) A(x) logical consequence .
wide range Q, datalog, rewriting Q w.r.t. computed using
straightforward equivalence-preserving transformations ; optimised
eliminating axioms irrelevant answering Q. Furthermore, several
algorithms computing UCQ datalog rewritings proposed literature.
example, Calvanese et al. (2007) showed compute UCQ rewriting cases
expressed logic DL-Lite family, approach extended
OWL 2 QL profile OWL 2 (Motik et al., 2009a). Similarly, Perez-Urbina et al. (2010)
proposed algorithm computing simplest possible datalog rewriting
expressed description logic ELHIO.
Rewritings produced known algorithms often contain predicates occur
Q; predicates sometimes called fresh. example, many rewriting
algorithms normalise TBoxes replacing complex concepts fresh atomic concepts.
rewriting R = RD , R , RQ obtained way unlikely satisfy requirement
|= RD . However, predicates occurring R often eliminated
via unfolding. example, let Q = {A(x) Q(x)} = {R.S.B A}, assume
rewriting algorithm produces
RD = {S(x, y) B(x) C(x), R(x, y) C(y) A(x)}.
satisfy Definition 2.2, predicate C unfolded RD replaced
RD = {R(x, y) S(y, z) B(z) A(x)},
|= RD holds. Unfolding, however, may always possible (e.g., might
case fresh predicates occur recursive axioms), may limit applicability results presented paper.

3. Completeness Guarantees Incomplete Reasoners
section, introduce formal framework allow us establish completeness guarantees incomplete reasoners. results restricted particular
description logic, applicable TBoxes satisfy following criterion.
Definition 3.1. TBox admissible description logic DL exists
DL-TBox, checking TBox satisfiability answering Boolean UCQs w.r.t.
arbitrary ABox decidable DL.
3.1 Concrete Abstract Reasoners
Concrete reasoners complex software systems dier greatly functionality
supported interfaces, use range dierent implementation techniques.
make results general independent specific implementation techniques,
introduce notion abstract reasoner. abstract reasoner thought
428

fiCompleteness Guarantees Incomplete Ontology Reasoners

idealised reasoner captures intended behaviour salient features class
concrete reasoners. concrete reasoner belonging class may use arbitrary algorithms,
long observable behaviour mirrors abstract reasoner.
Definition 3.2. abstract reasoner ans description logic DL computable function takes input arbitrary DL-TBox , arbitrary ABox A, either
special unsatisfiability query arbitrary UCQ Q. return value ans defined
follows:
ans(, , A) either f;
ans(, , A) = t, ans(Q, , A) interest arbitrary;
ans(, , A) = f, ans(Q, , A) finite set tuples individuals,
arity tuple equal arity query predicate Q.
abstract reasoner ans DL said applicable TBox DL-TBox.
Intuitively, ans(, , A) asks abstract reasoner check whether unsatisfiable, ans(Q, , A) asks abstract reasoner evaluate Q w.r.t. A.
unsatisfiable, tuple constants arity query predicate Q
answer Q A; therefore, result ans(Q, , A) interest
ans(, , A) = fthat is, ans identifies satisfiable.
Example 3.3. Consider abstract reasoners rdf, rdfs, rl, classify which, given
input UCQ Q, TBox , ABox A, compute answer Q w.r.t.
described next.
Abstract reasoner rdf ignores evaluates Q w.r.t. A; precisely, rdf(, , A) = f
rdf(Q, , A) = cert(Q, , A). Thus, rdf captures behaviour RDF reasoners.
Abstract reasoner rdfs evaluates Q w.r.t. datalog program Prdfs constructed translating RDFS axiom equivalent datalog rule;
precisely, rdfs(, , A) = f rdfs(Q, , A) = cert(Q, Prdfs , A). Thus, rdfs captures
behaviour RDFS reasoners Sesame.
Abstract reasoner rl evaluates Q w.r.t. datalog program Prl constructed
translating OWL 2 RL axiom equivalent datalog rule; precisely,
rl(, , A) = cert(, Prl , A) rl(Q, , A) = cert(Q, Prl , A). Thus, rl captures behaviour
OWL 2 RL reasoners Jena Oracles Semantic Data Store.
Abstract reasoner classify first classifies using complete OWL 2 DL reasoner; is,
computes TBox containing subclass axiom B |= B,
B atomic concepts occurring . abstract reasoner proceeds rl,
considers instead ; precisely, classify(, , A) = rl(, , )
classify(Q, , A) = rl(Q, , A). way, classify captures behaviour OWL 2
RL reasoners Minerva DLE-Jena try complete materialising
certain consequences .


ideal abstract reasoner one that, arbitrary UCQ Q, TBox ,
ABox A, ans(, , A) = cert(, , A), ans(Q, , A) = cert(Q, , A) whenever
ans(, , A) = f. next introduce discuss several properties abstract reasoners
429

fiCuenca Grau, Motik, Stoilos & Horrocks

likely aect close come ideal may relevant
applicability results.
following notion soundness describes abstract reasoners return answers
logically follow Q, , A.
Definition 3.4. abstract reasoner ans DL sound following conditions hold
UCQ Q, DL-TBox , ABox A:
ans(, , A) = implies cert(, , A) = t;
ans(, , A) = f implies ans(Q, , A) cert(Q, , A).
following notion monotonicity describes abstract reasoners extending
input TBox ABox never leads dropping answers. consider weaker
notion (Q, )-monotonicity, input query Q TBox fixed.
Definition 3.5. abstract reasoner ans DL monotonic following conditions
hold UCQ Q, DL-TBoxes , ABoxes
:
ans(, , A) = implies ans(, , ) = t;
ans(, , A) = f ans(, , ) = f imply ans(Q, , A) ans(Q, , ).
Given UCQ Q DL-TBox , ans (Q, )-monotonic following conditions
hold ABoxes :
ans(, , A) = implies ans(, , ) = t;
ans(, , A) = f ans(, , ) = f imply ans(Q, , A) ans(Q, , ).
discussed Section 2.3, logical consequences first-order theory invariant
renaming merging individuals. define analogous properties abstract
reasoners, first introduce notions -stable (Q, )-stable renamingsthat is,
renamings leave individuals occurring (respectively, Q ) unchanged.
Definition 3.6. Let Q query, let TBox, let renaming. Then, stable (a) = individual dom() ind(T ); furthermore, (Q, )-stable
(a) = individual dom() ind(Q ).
following notion weak faithfulness describes abstract reasoners whose answers
invariant replacement individuals fresh individuals. Furthermore, weak
(Q, )-faithfulness relaxes property case Q fixed.
Definition 3.7. abstract reasoner ans DL weakly faithful following conditions hold UCQ Q, DL-TBox , ABox A, injective renaming , tuple a:
ans(, , A) = ind(T A) dom() imply ans(, (T ), (A)) = t;
ans(, , A) = f, ind(Q A) dom(), ans(Q, , A) imply
ans(, (T ), (A)) = f (a) ans((Q), (T ), (A)).
430

fiCompleteness Guarantees Incomplete Ontology Reasoners

Given UCQ Q DL-TBox , ans weakly (Q, )-faithful following conditions
hold ABox A, injective renaming , tuple a:
ans(, , A) = t, ind(T A) dom(), -stable imply ans(, , (A)) = t;

ans(, , A) = f, ind(Q A) dom(), (Q, )-stable, ans(Q, , A)
imply ans(, , (A)) = f (a) ans(Q, , (A)).
following notion strong faithfulness describes abstract reasoners whose answers
invariant merging individuals. Furthermore, strong (Q, )-faithfulness relaxes
property case Q fixed.
Definition 3.8. abstract reasoner ans DL strongly faithful following conditions hold UCQ Q, DL-TBox , ABox A, renaming , tuple a:
ans(, , A) = implies ans(, (T ), (A)) = t;
ans(, , A) = f, ans(Q, , A), ans(, (T ), (A)) = f imply
(a) ans((Q), (T ), (A)).
Given UCQ Q DL-TBox , ans strongly (Q, )-faithful following conditions hold ABox A, renaming , tuple a:
ans(, , A) = -stable imply ans(, , (A)) = t;
ans(, , A) = f, (Q, )-stable, ans(Q, , A), ans(, , (A)) = f imply
(a) ans(Q, , (A)).
results present rest paper applicable abstract
reasoners satisfy various combinations properties; minimum, require
(Q, )-monotonicity weak (Q, )-faithfulness. abstract reasoners described Example 3.3 satisfy properties. Testing case concrete reasoners may,
however, infeasible practice; indeed, aware technique would allow one check whether concrete reasoner satisfies required properties. believe,
however, concrete reasoners commonly used practice intended sound,
monotonic, least weakly faithful, strong faithfulness reasonable assumption cases. concrete reasoner fails satisfy properties
certain inputs, likely due implementation bugs; thus, consequent failure
completeness seen bug, detecting situations viewed
part general problem testing software systems.
next present several examples abstract reasoners satisfy
mentioned properties.
Example 3.9. Consider abstract reasoner behaves rdf whenever number
assertions input ABox smaller certain threshold, returns
empty set answers larger ABoxes. Intuitively, abstract reasoner characterises
concrete RDF reasoner processes inputs certain size. reasoner
(Q, )-monotonic arbitrary Q .

431

fiCuenca Grau, Motik, Stoilos & Horrocks

Example 3.10. Consider abstract reasoner behaves rdf, that, trust
reasons, removes input ABox assertions whose individuals blacklisted
(e.g., come untrusted source). abstract reasoner weakly (Q, )faithful arbitrary Q .

Example 3.10 suggests that, abstract reasoner weakly faithful,
make decisions depend specific names individuals.
Example 3.11. Consider abstract reasoner rl= that, given input UCQ Q, TBox
, ABox A, proceeds follows. First, rl= computes ABox obtained
evaluating datalog program Prl Example 3.3 A. Second, rl= computes
query Q= obtained Q adding body rule r Q inequality x
pairs distinct variables x occurring r. Third, rl= evaluates Q=
considering databasethat is, finite first-order interpretation
individual mapped (and thus dierent individuals distinct). Thus, rl= characterises concrete reasoners evaluate queries matching dierent variables dierent
individuals. Abstract reasoner rl= sound, monotonic, weakly faithful,
strongly faithful. example, given query Q = {R(x, y) Q(x)}, ABox = {R(a, b)},
renaming = {a c, b c}, rl= (Q, , A) = {a}, rl= (Q, , (A)) = .
Example 3.11 suggests that, abstract reasoner strongly faithful,
allow distinct variables queries axioms mapped individuals.
next identify classes abstract reasoners use throughout paper. Note
soundness required, contributes generality results.
Definition 3.12. Given UCQ Q TBox , CwQ,T (CsQ,T ) class (Q, )monotonic weakly (strongly) (Q, )-faithful abstract reasoners applicable .
Finally, note abstract reasoners introduced Example 3.3 sound, monotonic, strongly (and therefore weakly) faithful. Consequently, concrete reasoners
based reasoning techniques outlined Example 3.3 considered sound, monotonic,
strongly faithful, modulo implementation bugs.
3.2 Completeness Abstract Reasoners
next define central notion abstract reasoner completeness given query Q
TBox . Intuitively, (Q, )-complete abstract reasoner indistinguishable
complete abstract reasoner applied Q, , arbitrary ABox A.
Definition 3.13. Let DL description logic, let ans abstract reasoner DL.
Then, ans (Q, )-complete UCQ Q DL-TBox following conditions
hold ABox A:
cert(, , A) = t, ans(, , A) = t;
cert(, , A) = f ans(, , A) = f, cert(Q, , A) ans(Q, , A).
Finally, ans complete (Q, )-complete UCQ Q DL-TBox .
432

fiCompleteness Guarantees Incomplete Ontology Reasoners

Example 3.14. Consider EL-TBox consisting following axioms; translation
axioms first-order logic shown symbol.
takesCo.MathCo St



MathSt takesCo.MathCo



CalcCo MathCo



St Prof



x, y.[takesCo(x, y) MathCo(y) St(x)]
x.[CalcCo(x) MathCo(x)]

(7)
(8)

x.[MathSt(x) y.[takesCo(x, y) MathCo(y)]] (9)
x.[St(x) Prof(x) ]

(10)

Axiom (7) states everyone taking maths course student; axiom (8) states
calculus course maths course; axiom (9) states maths student takes
maths course; axiom (10) states person student
professor. Axiom (8) RDFS axiom, axioms apart (9) OWL
2 RL axioms. Consider query (11) retrieves students taking maths course.
Q = {St(x) takesCo(x, y) MathCo(y) Q(x)}

(11)

None abstract reasoners rdf, rdfs, rl, classify Example 3.3 complete
general answering UCQs EL-TBoxes. Furthermore, Q previous
paragraph, abstract reasoners rdf, rdfs, rl (Q, )-complete, return
empty set answers ABox = {MathSt(c)}. contrast, following sections
show abstract reasoner classify (Q, )-completethat is, returns
certain answers Q, , arbitrary ABox A.

3.3 Test Suites
Checking (Q, )-completeness concrete reasoner applying reasoner possible
ABoxes comparing reasoners answers complete reasoner clearly
infeasible practice since infinitely many candidate input ABoxes. obtain
practical approach, need finite number tests. formalise idea using
following definition.
Definition 3.15. Let TBox. -test suite pair = , SQ
finite set ABoxes cert(, , A) = ,
SQ finite set pairs A, ABox cert(, , A) = f
UCQ.
abstract reasoner ans applicable passes -test suite ans satisfies
following two conditions:
, ans(, , A) = t,
A, SQ , ans(, , A) = f, cert(Y, , A) ans(Y, , A).
Let Q UCQ, let C class abstract reasoners applicable . Then,
exhaustive C Q ans C passes (Q, )-complete.
-test suite Q-simple Q query occurring SQ ; then, SQ commonly written set ABoxes, A, Q SQ commonly abbreviated SQ .
433

fiCuenca Grau, Motik, Stoilos & Horrocks

Intuitively, -test suite = , SQ determines tests abstract reasoner
subjected to. reasoner pass S, must correctly identify ABox
unsatisfiable, ABoxquery pair A, SQ reasoner must
correctly answer w.r.t. A.
Given Q , goal identify -test suite exhaustive Qthat
is, test suite abstract reasoner passes guaranteed (Q, )complete. Depending properties abstract reasoners, however, dierent test suites
may may achieve goal. Therefore, notion exhaustiveness relative
class abstract reasoners C: exhaustive class abstract reasoners C,
used test arbitrary abstract reasoner C. Note depends
target class abstract reasoners, actual abstract reasoner tested;
order words, construction depends properties one assume hold
target abstract reasoner. Furthermore, abstract reasoner contained C
passes S, general imply (Q, )-completeness guarantee.
Example 3.16. Let Q specified Example 3.14, let A1 A6
following ABoxes.
A1 = {takesCo(c, d), MathCo(d)}
A3 = {takesCo(c, d), CalcCo(d)}
A5 = {MathSt(c)}

A2 = {takesCo(c, c), MathCo(c)}
A4 = {takesCo(c, c), CalcCo(c)}
A6 = {St(c), Prof(c)}

following sections, show Q-simple -test suite = , SQ defined
= {A6 } SQ = {A1 , . . . , A5 } exhaustive class CwQ,T Q; consequently,
used test abstract reasoners Example 3.3.
particular, note abstract reasoners rdf rdfs fail tests SQ ,
abstract reasoner rl fails test A5 SQ ; furthermore, failed tests provide counterexample (Q, )-completeness. contrast, abstract reasoner classify Example
3.14 passes tests S, implies abstract reasoner indeed (Q, )-complete.
Finally, consider variant abstract reasoner classify that, similarly abstract
reasoner described Example 3.9, returns empty set answers input ABox
contains than, say, ten assertions. abstract reasoner (Q, )-monotonic
hence belong CwQ,T . abstract reasoner clearly passes S; however, since
belong CwQ,T , passing (correctly) imply abstract reasoner
(Q, )-complete.

next state following property, proof trivial.

Proposition 3.17. Let Q UCQ, let TBox, let C1 C2 classes
abstract reasoners applicable C1 C2 .
1. -test suite exhaustive C2 Q, exhaustive C1 Q.
2. -test suite exists exhaustive C1 Q, -test suite exists
exhaustive C2 Q.
Therefore, proving existence -test suite exhaustive Q, general
result one applies largest possible class abstract reasoners. Furthermore,
434

fiCompleteness Guarantees Incomplete Ontology Reasoners

following section identify cases -test suite exhaustive Q
found; Proposition 3.17 suces provide nonexistence results smallest
possible class abstract reasoners.
finish section pointing important practically relevant property
Q-simple -test suites, illustrated Example 3.16.
Proposition 3.18. Let = , SQ Q-simple -test suite let ans abstract
reasoner applicable . ans pass S, ans (Q, )-complete.
Proof. ABox SQ ans satisfy conditions Definition
3.15 counterexample (Q, )-completeness ans.
Thus, Q-simple -test suite exhaustive C Q provides sucient necessary test (Q, )-completeness abstract reasoners C. contrast,
Q-simple, show Section 3.7 provides sucient,
necessary test (Q, )-completeness abstract reasoners C.
3.4 Negative Results
Sections 3.5 (resp. Section 3.6) identify restrictions UCQ Q TBox
guarantee existence -test suites exhaustive CwQ,T (resp. CsQ,T ) Q.
presenting positive results, first outline limits (Q, )-completeness testing
thus justify restrictions use following sections.
3.4.1 Monotonicity Weak Faithfulness
approaches testing (Q, )-completeness abstract reasoners applicable
reasoners (Q, )-monotonic weakly (Q, )-faithful. section, provide
formal justification requirements form following two theorems.
Theorem 3.19 shows exhaustive test suites exist consider class
abstract reasoners satisfying properties Section 3.1 apart (Q, )monotonicity; includes soundness, strong faithfulness (which implies weak faithfulness), monotonicity w.r.t. TBox only.
Theorem 3.20 shows exhaustive test suites exist consider class
abstract reasoners satisfying properties defined Section 3.1 exception
(Q, )-weak faithfulness; properties include soundness monotonicity.
negative results Theorems 3.19 3.20 strong: hold smallest
classes abstract reasoners define based notions introduced Section 3.1 (by
Proposition 3.17, smaller class abstract reasoners, general negative
result); hold regardless Q considered (modulo minor technicality:
unlike Theorem 3.19, Theorem 3.20 requires satisfiable).
proof Theorem 3.19 intuitively understood follows. first assume
-test suite exhaustive Q class abstract reasoners
theorem applies. Then, specify abstract reasoner ans right thing (i.e.,
returns correct answer) given input query Q, TBox ,
435

fiCuenca Grau, Motik, Stoilos & Horrocks

arbitrary ABox containing many assertions largest test ABox S;
otherwise, ans returns sound, incomplete answer. finally show following
three properties ans.
Abstract reasoner ans belongs relevant class abstract reasoners.
Abstract reasoner ans passes S.
Abstract reasoner ans incomplete least one input ABox.
three properties show exhaustive Q relevant class
abstract reasoners. Intuitively, means class abstract reasoners large,
allowing abstract reasoners treat input erratic way.
Theorem 3.19. Let Q arbitrary UCQ, let arbitrary admissible TBox.
Then, -test suite exists exhaustive Q class sound strongly
faithful abstract reasoners applicable satisfying following conditions TBox
ABox A:
ans(, , A) = implies ans(, , A) = t;
ans(, , A) = f ans(, , A) = f imply ans(Q, , A) ans(Q, , A).
Proof. Consider arbitrary -test suite = , SQ . Let n maximum number
assertions ABox S. Furthermore, let ans abstract reasoner takes
input UCQ Qin , FOL-TBox Tin , ABox . result ans(, Tin , )
determined follows.
1. Try find renaming dom() = ind(T ) (T ) Tin ;
exists, return f.
2. contains n assertions, check satisfiability (T ) using
sound complete reasoner; return (T ) unsatisfiable.
3. Return f.
Furthermore, result ans(Qin , Tin , ) determined follows.
4. Try find renaming dom() = ind(Q ), (T ) Tin , (Q) = Qin ;
exists, return .
5. contains n assertions, compute cert((Q), (T ), ) using sound
complete reasoner return result.
6. Return .
Since admissible, checks steps 2 5 performed finite time; furthermore, step 1 realised enumerating mappings ind(T ) ind(Tin ), step
4 realised analogously; consequently, ans implemented terminates
inputs. see ans sound monotonic w.r.t. TBox, consider arbitrary
input Qin , Tin , Tin , Tin Tin .
436

fiCompleteness Guarantees Incomplete Ontology Reasoners

Assume ans(, Tin , ) = t. Then, Qin , Tin , abstract reasoner
returns step 2 (T ) unsatisfiable; then, since (T ) Tin ,
Tin unsatisfiable well, required soundness. Furthermore,
since (T ) Tin Tin , Qin , Tin , abstract reasoner returns step 2
well, ans(, Tin , ) = t, required monotonicity w.r.t. TBox.
Assume ans(Qin , Tin , ). Then, Qin , Tin , abstract reasoner
returns step 5, therefore cert((Q), (T ), ); then, since
(Q) = Qin (T ) Tin , cert(Qin , Tin , ), required soundness. Furthermore, since (T ) Tin Tin , Qin , Tin , abstract reasoner
returns step 5 well, ans(Qin , Tin , ), required monotonicity w.r.t.
TBox.
see ans strongly faithful, consider arbitrary renaming . renaming
exists (Q) = Qin (T ) Tin , clearly renaming exists
(Q) = (Qin ) (T ) (Tin ). Consequently, ans(, Tin , ) returns step 2,
ans(, (Tin ), (Ain )) returns step 2 well; similarly, ans(Qin , Tin , ) returns step
5, ans((Qin ), (Tin ), (Ain )) returns step 5 well; clearly, ans strongly faithful.
Finally, straightforward see ans passes S.
let ABox containing least n + 1 assertions cert(Q, , A) = ;
clearly exists. unsatisfiable, ans(, , A) = f; furthermore,
satisfiable, ans(Q, , A) = ; consequently, ans (Q, )-complete. Thus,
exhaustive Q class abstract reasoners considered theorem.
next prove Theorem 3.20. proof similar proof Theorem 3.19,
main dierence abstract reasoner ans construct. particular, given test
suite S, take ans return correct answer query Q, TBox ,
ABox contains individuals occurring S; otherwise, abstract reasoner
returns sound, incomplete answer. Again, class abstract reasoners
large, allowing ans treat inputs erratic way.
Unlike Theorem 3.19, following theorem requires satisfiable; understand
why, consider arbitrary unsatisfiable TBox UCQ Q. Let = , SQ
-test suite defined = {} (i.e., contains single empty ABox) SQ = (i.e.,
SQ contains ABoxes), consider arbitrary monotonic abstract reasoner ans
passes . Since ans passes S, ans(, , ) = t; then, since ans monotonic,
arbitrary ABox ans(, , A) = well, turn implies ans
(Q, )-complete. Failure satisfy weak faithfulness thus irrelevant unsatisfiable.
Theorem 3.20. Let arbitrary admissible satisfiable TBox let Q
arbitrary UCQ. Then, -test suite exists exhaustive Q class
sound monotonic abstract reasoners applicable .
Proof. Consider arbitrary -test suite = , SQ . Let set individuals
occurring S, Q, . Furthermore, let ans abstract reasoner takes
input UCQ Qin , FOL-TBox Tin , ABox . result ans(, Tin , )
determined follows.
1. Tin , return f.
437

fiCuenca Grau, Motik, Stoilos & Horrocks

2. Let Ain,I set assertions mention individuals I.
3. Check satisfiability Ain,I using sound complete reasoner; return
Ain,I unsatisfiable, return f otherwise.
Furthermore, given UCQ Qin , result ans(Qin , Tin , ) determined follows:
4. Tin Q =
Qin , return .
5. Let Ain,I set assertions mention individuals I.
6. Compute cert(Q, , Ain,I ) using sound complete reasoner return result.
ans implemented terminates inputs shown
proof Theorem 3.19. Furthermore, soundness ans follows following
two observations.
Assume ans(, Tin , ) = t. Then, abstract reasoner returns step 3 since
Ain,I unsatisfiable; then, since Tin Ain,I ,
Tin unsatisfiable well, required.
Assume ans(Qin , Tin , ). Then, abstract reasoner returns step 6,
therefore cert(Q, , Ain,I ); then, since Q = Qin , Tin ,
Ain,I , cert(Qin , Tin , ), required.
monotonicity, consider arbitrary Tin Tin Tin ;
clearly, Tin Ain,I Ain,I ; then, monotonicity first-order logic,
ans(, Tin , ) = implies ans(, Tin , ) = t, ans(Q, Tin , ) ans(Q, Tin , ). Finally, straightforward see ans passes S.
consider arbitrary ABox ind(A) = cert(Q, , A) = ;
clearly exists. unsatisfiable, since ABox constructed step 2 empty
satisfiable, ans(, , A) = f; furthermore, satisfiable, since
ABox constructed step 5 empty, ans(Q, , A) cannot contain individuals occurring
I; consequently, ans (Q, )-complete. Thus, exhaustive Q
class abstract reasoners considered theorem.
3.4.2 Monotonicity Weak Faithfulness Suffice
Next, show (Q, )-monotonicity (Q, )-faithfulness general guarantee
existence -test suite exhaustive Q. particular, Theorem 3.21 shows that,
contains single recursive axiom, test suite exists exhaustive class
sound, monotonic, strongly faithful abstract reasoners (and Proposition 3.17
CsQ,T CwQ,T well, UCQ Q). Although result applicable
particular Q , straightforward adapt proof TBox recursive
axiom relevant given query. Example 3.22, however, shows concept
relevance rather dicult formalise: even entails recursive axiom, axiom
necessarily relevant answering query. order complicate matters
further, state following result fixed Q , hope proof clearly
illustrates limitations incurred recursive axioms.
438

fiCompleteness Guarantees Incomplete Ontology Reasoners

Theorem 3.21. Q = {A(x) Q(x)} = {R.A A}, -test suite exists
exhaustive Q class sound, monotonic, strongly faithful abstract
reasoners applicable .

Proof. Consider arbitrary -test suite = , SQ . Since -test suite,
contains ABoxes unsatisfiable; clearly, ABox exists
stated theorem, = . Let SQ arbitrary, finite, set pairs A,
ABox UCQ, let n maximum number assertions ABox
SQ . Furthermore, consider following ABox, ai = aj 1 < j n + 1:
An+1 = {R(a0 , a1 ), . . . , R(an , an+1 ), A(an+1 )}
next construct abstract reasoner pEvaln following properties:
(P1) A, SQ , cert(Y, , A) pEvaln (Y, , A);
(P2) a0 pEvaln (Q, , An+1 );
(P3) pEvaln sound, monotonic, strongly faithful.
Note a0 cert(Q, , An+1 ), three properties imply exhaustive
Q class abstract reasoners considered theorem.
Abstract reasoner pEvaln accepts input FOL-TBox Tin ABox .
result pEvaln (, Tin , ) determined follows.
1. Return f.

Furthermore, given UCQ Qin , result pEvaln (Qin , Tin , ) determined follows.
2. Tin Q =
Qin , return .
3. Asat :=
4. Repeat following computation n times:
Asat := Asat {(A(x)) | substitution s.t. {(R(x, y)), (A(y))} Asat }
5. Return cert(Q, , Asat ).

Abstract reasoner pEvaln clearly satisfies Property (P2) deriving assertion A(a0 )
requires n+1 iterations loop step 4. Furthermore, pEvaln satisfies (P1)
every ABox occurring SQ contains n individuals seen
rule R(x, y) A(y) A(x), pEvaln applies n times input ABox .
finally show (P3). Abstract reasoner pEvaln clearly sound. Furthermore,
renaming (T ) = (Q) = Q, pEvaln clearly strongly faithful.
show pEvaln monotonic, consider arbitrary Tin , Tin , ,
Tin Tin ; since pEvaln (, Tin , ) = f input, following
relevant cases.
pEvaln returns step 2 input Qin , Tin , , case either Tin
Q = Qin . Since Tin Tin , clearly pEvaln returns step 2 input Qin , Tin ,
, monotonicity holds.
439

fiCuenca Grau, Motik, Stoilos & Horrocks

pEvaln returns step 5 input Qin , Tin , . Then, pEvaln return either
step 2 step 5 input Qin , Tin ; former case, monotonicity holds
trivially, latter case, pEvaln (Qin , Tin , ) pEvaln (Qin , Tin , ) follows
directly fact .
following example shows presence recursive axioms preclude existence -test suite exhaustive Q.
Example 3.22. Consider Q defined follows:
Q = {A(x) B(x) Q(x)}
= {R.A A, B R.A}
Note contains axiom mentioned Theorem 3.21; however, note
|= B A,
R = , {B(x) Q(x)}

UCQ rewriting Q w.r.t. . Section 3.5 show existence UCQ rewriting Q w.r.t. guarantees existence Q-simple -test suite exhaustive CwQ,T
(and hence CsQ,T ) Q; example, = , { {B(a)} } one -test suite.
Intuitively, |= B consequence relevant answering Q; hence,
= {B A} Q = {A(x) Q(x)}, cert(Q, , A) = cert(Q , , A)
arbitrary ABox A. Hence, recursive axiom irrelevant answering Q,
therefore presence preclude existence -test suite exhaustive
CwQ,T Q.

3.5 Testing (Q, )-Monotonic Weakly (Q, )-Faithful Abstract Reasoners

section, identify sucient condition guarantees existence Q-simple
-test suite exhaustive CwQ,T Q; Proposition 3.17, result applies CsQ,T
well. Roughly speaking, always computed instantiating rules
UCQ rewriting Q w.r.t. suitable way. requirement Q UCQrewritable w.r.t. invalidates negative result Theorem 3.21 since UCQ rewriting
Q = {A(x) Q(x)} w.r.t. = {R.A A} exists.
result allows one compute Q-simple -test suites exhaustive Q numerous
practically relevant cases. particular, UCQ rewriting guaranteed exist
expressed DLs underpinning QL profile OWL 2 (Motik et al., 2009a; Calvanese
et al., 2007); furthermore, illustrated Example 3.22, UCQ rewriting may exist even
expressed fragments OWL 2 OWL 2 EL (Motik et al., 2009a;
Baader, Brandt, & Lutz, 2005). practice, rewritings computed using systems
QuOnto (Acciarri et al., 2005) REQUIEM (Perez-Urbina et al., 2010).
establish desired result two steps. First, Section 3.5.1 present general
characterisation Q-simple -test suites exhaustive CwQ,T Q. Then, Section
3.5.2 use characterisation establish desired connection rewritings
Q-simple -test suites exhaustive Q.
440

fiCompleteness Guarantees Incomplete Ontology Reasoners

3.5.1 Characterisation Simple Exhaustive Test Suites
next prove Q-simple -test suite = , SQ exhaustive CwQ,T Q
contains isomorphic copy data pattern (i.e., subset ABox)
produce certain answer Q w.r.t. , preserves identity
individuals occurring Q. show sucient,
necessary condition existence exhaustive -test suite, observe that,
contain one copy data pattern, always find abstract reasoner
CwQ,T passes misses certain answers obtained via missing data pattern
therefore (Q, )-complete.
Theorem 3.23. Let Q UCQ, let admissible TBox, let = , SQ
Q-simple -test suite. Then, exhaustive CwQ,T Q following
properties satisfied ABox A.
1. unsatisfiable, exist ABox injective -stable
renaming dom() = ind(T ) (A ) A.
2. satisfiable, tuple cert(Q, , A) exist ABox
SQ , tuple b cert(Q, , ), injective (Q, )-stable renaming
(b) = a, dom() = ind(Q ), (A ) A.
Proof. () Let arbitrary Q-simple -test suite satisfies Properties 1 2;
next show exhaustive CwQ,T Q. Consider arbitrary abstract reasoner
ans CwQ,T passes Sthat is, ans satisfies following two properties:
(a) ans(, , ) = ,
(b) ans(, , ) = f implies cert(Q, , ) ans(Q, , ) SQ .
next show ans (Q, )-completethat is, ans satisfies two conditions
Definition 3.13 arbitrary ABox A. arbitrary A, following
two possibilities, depending satisfiability A.
Assume unsatisfiable. Since satisfies Property 1, exist ABox
injective -stable renaming s.t. dom() = ind(T ) (A ) A.
Condition (a) ans(, , ) = t. Since ans weakly (Q, )-faithful, injective
-stable, dom() = ind(T ), ans(, , (A )) = t; finally, since ans
(Q, )-monotonic (A ) A, ans(, , A) = t, required Definition 3.13.
Assume satisfiable ans(, , A) = f. Furthermore, consider arbitrary tuple cert(Q, , A). Since satisfies Property 2, exist ABox SQ ,
tuple b cert(Q, , ), injective (Q, )-stable renaming (b) = a,
dom() = ind(Q ), (A ) A. Since (A ) A, ans(, , A) = f, ans
(Q, )-monotonic, ans(, , (A )) = f; furthermore, ind(T ) dom(),
injective (Q, )-stable, ans weakly (Q, )-faithful, ans(, , (A )) = f implies ans(, , ) = f. then, Condition (b) cert(Q, , ) ans(Q, , ),
b ans(Q, , ). Since ans weakly (Q, )-faithful, injective (Q, )-stable,
dom() = ind(Q ), (b) ans(Q, , (A )); since (b) = a,
441

fiCuenca Grau, Motik, Stoilos & Horrocks

ans(Q, , (A )); finally, since ans (Q, )-monotonic (A ) A,
ans(Q, , A), required Definition 3.13.

() Assume exhaustive CwQ,T Q; next show Properties 1 2
satisfied arbitrary ABox A. end, consider particular abstract reasoner
ans prove ans CwQ,T ans passes S; abstract reasoner
help us identify ABox, tuple, renaming required prove Properties 1 2.
Let ans abstract reasoner takes input UCQ Qin , FOL-TBox Tin ,
ABox . result ans(, Tin , ) determined follows.
1. =
Tin , return f.

2. ABox , following.
(a) Check satisfiability using sound, complete, terminating
reasoner.
(b) unsatisfiable, injective -stable renaming exists
dom() = ind(T ) (A ) , return t.
3. Return f.
Furthermore, result ans(Qin , Tin , ) determined follows.
4. =
Tin Q =
Qin , return .
5. := .
6. tuple constants occurring arity equal arity query
predicate Q, SQ following.
(a) Compute C := cert(Q, , ) using sound, complete terminating reasoner.
(b) tuple b C injective (Q, )-stable renaming exist
(b) = a, dom() = ind(Q ), (A ) , add Out.
7. Return Out.
next show ans belongs CwQ,T ; end, prove ans terminates
inputs, (Q, )-monotonic weakly (Q, )-faithful.
Termination. Since admissible, checking satisfiability computation
cert(Q, , ) decidable, relevant sound, complete terminating reasoners
exist. Furthermore, checking whether -stable (resp. (Q, )-stable) injective renaming
exists done enumerating renamings ind(T ) (resp. ind(Q ))
ind(T ) (resp. ind(Q )). Therefore, ans implemented
terminates input.
(Q, )-Monotonicity. Consider arbitrary input Qin , Tin , , .
Assume ans(, Tin , ) = t, Tin abstract reasoner terminates
step 2(b) . then, since (A ) , Tin
abstract reasoner terminates step 2(b), ans(, Tin , ) = t,
required.
442

fiCompleteness Guarantees Incomplete Ontology Reasoners

Assume ans(, Tin , ) = f ans(, Tin , ) = f, consider arbitrary
tuple ans(Qin , Tin , ). added step 7(b) SQ
. then, since (A ) , Qin , Tin , abstract reasoner
adds step 7(b), ans(Qin , Tin , ), required.
Weak (Q, )-Faithfulness. Consider arbitrary input Qin , Tin , , arbitrary
injective renaming .
Assume ans(, Tin , ) = t, dom() ind(T A), -stable. Thus,
Tin abstract reasoner terminates step 2(b) . Let
renaming (c) = ((c)) c ind(T ). Clearly,
dom( ) = ind(T ), renaming -stable injective, (A ) (Ain ).
Thus, Tin (Ain ) abstract reasoner terminates step 2(b), therefore
ans(, Tin , (Ain )) = t, required.
Assume ans(, Tin , ) = f, dom() ind(Q A), (Q, )-stable,
consider arbitrary truple ans(Qin , Tin , ). added step
7(b) SQ , , b. Let renaming defined s.t. (c) = ((c))
individual c ind(Q ). Clearly, dom( ) = ind(Q ),
renaming (Q, )-stable injective, (A ) (Ain ), (b) = (a). Thus,
Qin , Tin , (Ain ) abstract reasoner terminates step 7(b) clearly
(a) ans(Qin , Tin , (Ain )), required.
concludes proof ans CwQ,T . Furthermore, ans clearly passes S; then,
since exhaustive CwQ,T Q, abstract reasoner ans (Q, )-complete. next
prove main claim theorem. end, consider arbitrary ABox A;
following possibilities, depending satisfiability A.
Assume unsatisfiable. ans(, , A) = t, abstract reasoner
returns step 2(b) ABox -stable renaming
(A ) dom() = ind(T ). Thus, Property 1 holds required.
Assume satisfiable, consider arbitrary tuple cert(Q, , A).
ans(, , A) = f ans(Q, , A), added step 7(b)
ABox SQ , tuple b cert(Q, , ), injective (Q, )-stable renaming
(b) = a, dom() = ind(Q ), (A ) A. Thus, Property 2
holds required.
following example illustrates Theorem 3.23.
Example 3.24. Let Q specified Example 3.14, let = , SQ
specified Example 3.16. show Section 3.5.2, exhaustive CwQ,T Q.
Consider ABox = {St(a), MathSt(b), takesCo(a, b1 )}. Clearly, satisfiable cert(Q, , A) = {b}. Theorem 3.23, certain answer obtained
evaluating Q w.r.t. ABox SQ . Indeed, note ABox A5 SQ isomorphic
subset = {MathSt(b)} via renaming = {b c}, applying Q
A5 produces c, isomorphic b via .
443

fiCuenca Grau, Motik, Stoilos & Horrocks

Note that, remove A5 S, longer -test suite
exhaustive Q. example, abstract reasoner rl Example 3.16 would pass
test suite, would return required certain answers applied A5 (and,
consequently, applied either).

3.5.2 Computing Test Suites Exhaustive CwQ,T

Based Theorem 3.23, section show -test suite exhaustive CwQ,T
Q obtained instantiating UCQ rewriting R Q w.r.t. is, replacing
variables R individuals possible ways. Please note instantiation
must full, sense possible replacements must considered.
class CwQ,T contain abstract reasoners rl= Example 3.11
strongly faithful may incorrectly handle case distinct variables bound
individuals.
Definition 3.25. Let set individuals, let r datalog rule, let
substitution. Then, instantiation substitution r w.r.t. (x)
variable x occurring r. latter holds, instantiation r w.r.t. ABox
Ar := {(B) | B body(r)}.
Let Q UCQ, let TBox, let R = R , RQ UCQ rewriting Q w.r.t.
, let maximum number distinct variables occurring rule R, let
set containing individuals occurring R, Q, , well fresh individuals.
R,I
R,I
full instantiation R w.r.t. pair ER,I = ER,I
ER,I
Q
, EQ E
smallest sets ABoxes
Ar ER,I
r R instantiation substitution r w.r.t. I,
Ar ER,I
Q r RQ instantiation substitution r w.r.t.
cert(, R , Ar ) = f.
ER,I clearly unique renaming fresh individuals I, typically left
R
implicit, one talks full instantiation ER = ER
, EQ R.
Example 3.26. Let Q specified Example 3.14, let R = R , RQ
R = {St(x) Prof(x) } RQ consists following datalog rules:
takesCo(x, y) MathCo(y) Q(x)
takesCo(x, y) CalcCo(y) Q(x)
MathSt(x) Q(x)

Then, R UCQ rewriting Q w.r.t. , one see Q-simple -test suite
= , SQ Example 3.16 full instantiation R.


following theorem shows full instantiation UCQ rewriting Q w.r.t.
Q-simple -test suite exhaustive CwQ,T Q. According theorem,
-test suite Example 3.26 exhaustive CwQ,T Q.
444

fiCompleteness Guarantees Incomplete Ontology Reasoners

Theorem 3.27. Let Q UCQ, let admissible TBox, let R = R , RQ
R
UCQ rewriting Q w.r.t. , let ER = ER
, EQ full instantiation R. Then,
ER Q-simple -test suite exhaustive CwQ,T Q.

Proof. Let set individuals ER obtained from. first show ER
Q-simple -test suitethat is, satisfies two properties Definition 3.15.
Consider arbitrary ABox ER
. Then, rule r R instantiation
substitution r exist = Ar ; clearly cert(, {r}, A) = t; since R
UCQ rewriting, unsatisfiable, required.
Consider arbitrary ABox ER
Q . Then, cert(, R , A) = f Definition 3.25;
since R UCQ rewriting, satisfiable, required.
next show ER satisfies Properties 1 2 Theorem 3.23 arbitrary
ABox A.
(Property 1) Assume unsatisfiable. Since R UCQ rewriting,
Definition 2.2 cert(, R , A) = t; then, rule r R substitution
exist Ar cert(, {r}, Ar ) = t. Let injective renaming
individual c occurring R (c) = c, individual
occurring Ar R (d) fresh individual I;
exists since number variables r smaller equal number fresh individuals
I. Let instantiation substitution r (x) = ((x)) variable
R
x occurring r; Ar ER
holds since E full instantiation R w.r.t. I. Let
injective renaming coincides inverse individual occurring
Ar , R, ; exists since injective range contains individual
occurring Ar , R, . Clearly (Ar ) = Ar holds, (Ar ) A. Furthermore,
clearly -stable. Thus, Property (1) satisfied Ar ER
.
(Property 2) Assume satisfiable, consider arbitrarily chosen tuple
cert(Q, , A). Since R UCQ rewriting, Definition 2.2 cert(, R , A) = f
cert(RQ , R , A); then, clearly cert(RQ , , A) well. Then, rule r RQ
substitution exist Ar cert({r}, , Ar ). Let injective
renaming individual c occurring R, Q, (c) = c,
individual occurring Ar R, Q, (d) fresh
individual I; clearly exists since number variables r smaller equal
number fresh individuals I. Let instantiation substitution r
R
(x) = ((x)) variable x occurring r; Ar ER
Q holds since E
full instantiation R w.r.t. I. Let injective renaming coincides
inverse individual occurring Ar , R, Q, ; exists since
injective range contains individual occurring Ar , R, Q, .
Furthermore, clearly tuple b cert({r}, , Ar ) exists (head(r)) = Q(b); since
R UCQ rewriting Ar satisfiable, b cert(Q, , Ar ); furthermore,
since injective, (b) = clearly holds. then, Property (2) satisfied Ar ER
Q,

, b.
445

fiCuenca Grau, Motik, Stoilos & Horrocks

3.5.3 Minimising Exhaustive Test Suites
practice, clearly beneficial compute test suites small possible.
goal achieved applying known techniques minimising UCQ rewritings
(Calvanese et al., 2007; Perez-Urbina, Horrocks, & Motik, 2009). Theorem 3.27,
smallest rewriting instantiated obtain exhaustive test suite.
State art query rewriting systems employ subsumption condensation techniques order reduce size rewriting. datalog rule r subsumes datalog rule
r substitution exists (r) r ; intuitively, r general r .
rewriting contains rules r r , r safely removed rewriting.
Furthermore, rule r contains distinct unifiable body atoms Bi Bj , condensation
r rule (r) general unifier Bi Bj . rewriting contains
rule r (r) subsumes r, rule safely replaced (r). following
example illustrates techniques used obtain small test suites.
Example 3.28. Let Q specified Example 3.14, let R rewriting
Q w.r.t. Example 3.26. R = R , RQ RQ consists following
rules UCQ rewriting Q w.r.t. .
takesCo(x, y) takesCo(x, z) MathCo(y) Q(x)

(12)

takesCo(x, y) CalcCo(y) Q(x)

(14)

MathSt(x) Q(x)

(16)

takesCo(x, x) CalcCo(x) MathCo(x) Q(x)

(13)

St(x) MathSt(x) Q(x)

(15)

Theorem 3.27, full instantiation R -test suite exhaustive CwQ,T
Q. rewriting R , however, contains redundancy hence resulting test suite
unnecessarily large. particular, applying condensation query (12), subsumption
queries (13) (14), subsumption queries (15) (16), obtain
simpler rewriting R.

Finally, note test suites obtained via full instantiation contain isomorphic
ABoxes. Clearly, isomorphic copies ABox safely eliminated test
suite without losing exhaustiveness CwQ,T Q.
3.6 Testing (Q, )-Monotonic Strongly (Q, )-Faithful Abstract Reasoners

Due full instantiation, test suites obtained Definition 3.25 exponentially larger
rewriting generated from. result, even rewritings moderate size
yield test suites containing thousands ABoxes. Intuitively, full instantiation required
obtain test suite exhaustive class CwQ,T class contains abstract
reasoners rl= Example 3.11, correctly handle case
distinct variables query matched individual.
section, show test suites exhaustive class CsQ,T obtained
injective instantiation rewritingthat is, replacing variable distinct
fresh individual. Test suites obtained way linear size rewriting,
thus substantially smaller test suites obtained full instantiation.
446

fiCompleteness Guarantees Incomplete Ontology Reasoners

Example 3.29. Let Q specified Example 3.14, let = , SQ
Q-simple -test suite Example 3.16. Furthermore, consider abstract reasoner rl=
Example 3.11 weakly, strongly (Q, )-faithful. easy check
rl= returns complete answers A1 A3 , A2 A4 . Therefore, Theorem
3.27, exhaustive CwQ,T Q, must include SQ ABoxes A2 A4 ,
respectively obtained ABoxes A1 A3 merging individual c.
Strongly (Q, )-faithful abstract reasoners, however, correctly handle inputs obtained
merging individuals. Based observation, section show Q-simple
-test suite = , SQ SQ = {A1 , A3 , A5 }, obtained injectively instantiating
rewriting R Example 3.26, exhaustive CsQ,T Q.



Section 3.5, first develop characterisation Q-simple -test suites
exhaustive CsQ,T Q; result analogous Theorem 3.23.

Theorem 3.30. Let Q UCQ, let admissible TBox, let = , SQ
Q-simple -test suite. Then, exhaustive CsQ,T Q following
properties satisfied ABox A.
1. unsatisfiable, exist ABox -stable renaming
dom() = ind(T ) (A ) A.
2. satisfiable, tuple cert(Q, , A) exist ABox
SQ , tuple b cert(Q, , ), (Q, )-stable renaming (b) = a,
dom() = ind(Q ), (A ) A.
Proof. () Let arbitrary Q-simple -test suite satisfies Properties 1 2;
next show exhaustive CsQ,T Q. Consider arbitrary abstract reasoner
ans CsQ,T passes Sthat is, ans satisfies following two properties:
(a) ans(, , ) = ,
(b) ans(, , ) = f implies cert(Q, , ) ans(Q, , ) SQ .
next show ans (Q, )-completethat is, ans satisfies two conditions
Definition 3.13 arbitrary ABox A. arbitrary A, following
two possibilities, depending satisfiability A.
Assume unsatisfiable. Since satisfies Property 1, exist ABox
-stable renaming dom() = ind(T ) (A ) A.
Condition (a) ans(, , ) = t. Since ans strongly (Q, )-faithful stable, ans(, , (A )) = t; finally, since ans (Q, )-monotonic (A ) A,
ans(, , A) = t, required Definition 3.13.
Assume satisfiable ans(, , A) = f. Furthermore, consider arbitrary tuple cert(Q, , A). Since satisfies Property 2, exist ABox SQ ,
tuple b cert(Q, , ), (Q, )-stable renaming (b) = a, (A ) A,
dom() = ind(Q ). Since (A ) A, ans(, , A) = f, ans (Q, )-monotonic,
ans(, , (A )) = f; furthermore, (Q, )-stable ans strongly faithful, ans(, , (A )) = f implies ans(, , ) = f. then, Condition (b)
cert(Q, , ) ans(Q, , ), b ans(Q, , ). ans strongly (Q, )-faithful
447

fiCuenca Grau, Motik, Stoilos & Horrocks

(Q, )-stable, (b) ans(Q, , (A )); since (b) = a, ans(Q, , (A ));
finally, since ans (Q, )-monotonic (A ) A, ans(Q, , A), required
Definition 3.13.
() Assume exhaustive CsQ,T Q; next show Properties 1 2
satisfied arbitrary ABox A. end, consider particular abstract reasoner
ans prove ans CsQ,T ans passes S; abstract reasoner
help us identify ABox, tuple, renaming required prove Properties 1 2.
Let ans abstract reasoner takes input UCQ Qin , FOL-TBox Tin ,
ABox . result ans(, Tin , ) determined follows.
1. =
Tin , return f.
2. ABox , following.
(a) Check satisfiability using sound, complete, terminating
reasoner.
(b) unsatisfiable, -stable renaming exists
dom() = ind(T ) (A ) , return t.
3. Return f.
Furthermore, result ans(Qin , Tin , ) determined follows.
4. =
Tin Q =
Qin , return .
5. := .
6. tuple constants occurring arity equal arity query
predicate Q, SQ following.
(a) Compute C := cert(Q, , ) using sound, complete terminating reasoner.
(b) tuple b C (Q, )-stable renaming exist (b) = a,
dom() = ind(Q ), (A ) , add Out.

7. Return Out.
next show ans belongs CsQ,T . proofs ans terminates
(Q, )-monotonic analogous proofs Theorem 3.23. show strong (Q, )faithfulness, consider arbitrary Qin , Tin , , arbitrary renaming .
Assume ans(, Tin , ) = -stable. Thus, Tin abstract
reasoner terminates step 2(b) . Let renaming
(c) = ((c)) c ind(T ). Clearly, dom( ) = ind(T ),
renaming -stable, (A ) (Ain ). Thus, Tin (Ain ) abstract
reasoner terminates step 2(b), ans(, Tin , (Ain )) = t, required.
Assume ans(, Tin , ) = f (Q, )-stable, consider arbitrary
tuple ans(Qin , Tin , ). added step 7(b) SQ ,
448

fiCompleteness Guarantees Incomplete Ontology Reasoners

, b. Let renaming defined (c) = ((c)) individual c ind(Q ). Clearly, dom( ) = ind(Q ), mapping
(Q, )-stable, (A ) (Ain ), (b) = (a). Thus, Qin , Tin , (Ain )
abstract reasoner terminates step 7(b), (a) ans(Qin , Tin , (Ain )), required.
concludes proof ans CsQ,T . Furthermore, ans clearly passes S; then,
since exhaustive CsQ,T Q, abstract reasoner ans (Q, )-complete. main
claim theorem shown Theorem 3.23.
next use Theorem 3.30 show Q-simple -test suite exhaustive
Q obtained injective instantiation UCQ rewriting Q w.r.t. .

CsQ,T

Definition 3.31. Let Q UCQ, let TBox, let R = R , RQ UCQ rewriting
Q w.r.t. , let substitution mapping variable occurring R distinct
R,
fresh individual. injective instantiation R w.r.t. pair IR, = IR,
, IQ
IR,
IR,
smallest sets ABoxes
Q

Ar IR,
r R ,

Ar IR,
r RQ cert(, R , Ar ) = f.
Q
IR, clearly unique renaming fresh individuals , typically left
R
implicit, one talks injective instantiation IR = IR
, IQ R.
Theorem 3.32. Let Q UCQ, let admissible TBox, let R = R , RQ
R
UCQ rewriting Q w.r.t. , let IR = IR
, IQ injective instantiation R.
Then, IR Q-simple -test suite exhaustive CsQ,T Q.

Proof. Let substitution IR obtained from. first show IR
Q-simple -test suitethat is, satisfies two properties Definition 3.15.
r
Consider arbitrary IR
. Then, rule r R exist = ; clearly
cert(, {r}, A) = t; since R UCQ rewriting, unsatisfiable, required.

Consider arbitrary IR
Q . Then, cert(, R , A) = f Definition 3.31; since R
UCQ rewriting, satisfiable, required.
next show IR satisfies Properties 1 2 Theorem 3.30 arbitrary
ABox A.
(Property 1) Assume unsatisfiable. Since R UCQ rewriting,
Definition 2.2 cert(, R , A) = t; then, rule r R substitution
exist Ar cert(, {r}, Ar ) = t. Let renaming
individual c occurring R (c) = c, variable x r
((x)) = (x). Clearly, (Ar ) = Ar , (Ar ) A. Furthermore, clear
-stable. Thus, Property (1) holds Ar IR
.
(Property 2) Assume satisfiable, consider arbitrarily chosen tuple
cert(Q, , A). Since R UCQ rewriting, Definition 2.2 cert(, R , A) = f
cert(RQ , R , A); then, clearly cert(RQ , , A) well. Then, rule r RQ
449

fiCuenca Grau, Motik, Stoilos & Horrocks

substitution exist Ar cert({r}, , Ar ). Let renaming
individual c occurring R, Q, (c) = c,
variable x r ((x)) = (x). Clearly, (Ar ) = Ar , (Ar ) A. Furthermore,
clear (Q, )-stable. Finally, clearly tuple b cert({r}, , Ar ) exists
(head(r)) = Q(b); since R UCQ rewriting Ar satisfiable,
b cert(Q, , Ar ); furthermore, (b) = clearly holds. then, Property (2) satisfied

Ar IR
,
,
b.
Q
3.7 Dealing Recursive Axioms
negative result Theorem 3.21 (which applies CwQ,T CsQ,T ) depends
presence recursive axiom TBox; thus, positive results Sections 3.5
3.6 require input UCQ rewritable w.r.t. input TBox, eectively
prohibits recursion TBox axioms. Instead disallowing recursive axioms, section
overcome limitation Theorem 3.21 placing additional requirements
abstract reasoners requiring first-order reproducible. Intuitively, latter
means reasoners behaviour seen complete reasoning unknown
first-order theory. abstract reasoners allowed partially evaluate recursive
axioms, invalidates approach used prove Theorem 3.21.
show -test suite exhaustive Q class first-order reproducible
abstract reasoners obtained instantiating datalog, rewriting Q w.r.t. .
rewritings exist wide range TBoxes queries, turn allows
results applicable range practically interesting cases. contrast test
suites computed UCQ rewriting, however, test suites obtained datalog,
rewriting may Q-simple. fact, show Section 3.7.2 that, certain Q
, -test suite exhaustive Q class first-order reproducible abstract
reasoners exists, test suite Q-simple. important practicallyrelevant consequence: -test suite Q-simple, first-order reproducible abstract
reasoner passes guaranteed (Q, )-complete; however, abstract reasoner
pass S, general cannot conclude reasoner (Q, )-complete.
3.7.1 First-Order Reproducible Abstract Reasoners
State art concrete reasoners Oracles reasoner, Jena, OWLim, Minerva, Virtuoso, DLE-Jena implemented RDF triple stores extended deductive
database features. Given input, reasoners first precompute assertions
follow preprocessing step. practice, step commonly implemented (a technique seen as) evaluating datalog program A.
preprocessing, reasoners answer arbitrary UCQ Q simply evaluating
Q precomputed set assertions.
Motivated observation, next introduce new class first-order reproducible
abstract reasonersthat is, abstract reasoners whose behaviour conceived complete reasoning unknown first-order theory. Note theory required
datalog program; example, contain existential quantifiers, used
capture behaviour concrete reasoners Jena OWLim (Bishop, Kiryakov,
450

fiCompleteness Guarantees Incomplete Ontology Reasoners

Ognyano, Peikov, Tashev, & Velkov, 2011) handle existential quantifiers input
introducing fresh individuals.
Definition 3.33. abstract reasoner ans description logic DL first-order reproducible if, DL-TBox , set first-order sentences FT exists that,
ABox A,
ans(, , A) = cert(, FT , A),

ans(, , A) = f, UCQ Q, ans(Q, , A) = cert(Q, FT , A).

FT contains predicates and/or individuals occurring , assumed
internal ans accessible queries, TBoxes, ABoxes, test suites, on.
Given TBox , CfT class first-order reproducible abstract reasoners applicable
.
Example 3.34. Abstract reasoners rdf, rdfs, rl classify Example 3.3 firstorder reproducible. Indeed, theory FT empty case rdf, precisely Prdfs
Prl cases rdfs rl, respectively. Finally, abstract reasoner classify, theory
FT union Prl program containing axiom x.[A(x) B(x)]
atomic subsumption B entailed input TBox.


Please note first-order reproducible abstract reasoner ans need actually construct FT : matters (possibly unknown) theory FT exists
characterises reasoners behaviour specified Definition 3.33.
Since QFT |= QFT whenever , first-order reproducible abstract
reasoner (Q, )-monotonic arbitrary Q . Furthermore, straightforward
see first-order reproducible abstract reasoner strongly (Q, )-faithful.
Consequently, CfT CsQ,T UCQ Q TBox .
next show negative result Theorem 3.21 directly apply
class CfT . particular, show abstract reasoner pEvaln used prove
Theorem 3.21 first-order reproducible. Intuitively, pEvaln understood
partial evaluation datalog programthat is, rules program applied
facts fixed number times rather fixpoint reached.
Proposition 3.35. positive integer n, abstract reasoner pEvaln defined
proof Theorem 3.21 first-order reproducible.
Proof. Let = {R.A A}, let Q = {A(x) Q(x)}, consider arbitrary nonnegative integer n. Furthermore, assume pEvaln CfT ; then, finite set first-order
sentences FT exists pEvaln (Q, , A) = cert(Q, FT , A) ABox A.
Let k positive integer; furthermore, let rk datalog rule let Ak
ABox defined follows, a0 , . . . , ak arbitrary distinct fixed individuals occurring
Q FT :
rk = R(x0 , x1 ) . . . R(xk1 , xk ) A(xk ) A(x0 )
Ak = {R(a0 , a1 ), . . . , R(ak1 , ak ), A(ak )}
following condition holds Proposition 2.1:
FT |= rk

FT Ak |= A(a0 )
451

(17)

fiCuenca Grau, Motik, Stoilos & Horrocks

definition pEvaln ,
a0 pEvaln (Q, , Ak ) 1 k n,
a0 pEvaln (Q, , Ak ) k > n.
Since pEvaln (Q, , A) = cert(Q, FT , A),
a0 cert(Q, FT , Ak ) 1 k n,
a0 cert(Q, FT , Ak ) k > n.
Since Q contains atom A(x) body,
FT Ak |= A(a0 ) 1 k n,
FT Ak |= A(a0 ) k > n.
condition (17),
FT |= rk 1 k n
FT |= rk k > n.
This, however, contradicts obvious observation r1 |= rk k 1.
Note proof Proposition 3.35 relies fact theory FT depends
input TBox, input query. shown next, defined first-order
reproducible abstract reasoners allowing FT depend input query,
negative result Theorem 3.21 would applied.
Definition 3.36. abstract reasoner ans DL first-order q-reproducible if,
UCQ Q DL-TBox , finite set first-order sentences FQ,T exists that,
ABox A,
ans(, , A) = cert(, FQ,T , A),
ans(, , A) = f, ans(Q, , A) = cert(Q, FQ,T , A).
Theorem 3.37. Q = {A(x) Q(x)} = {R.A A}, -test suite exists
exhaustive Q class sound, monotonic, strongly faithful, qreproducible abstract reasoners applicable .
Proof. prove claim, suces show that, nonnegative integer n,
abstract reasoner pEvaln defined proof Theorem 3.21 first-order q-reproducible.
Consider arbitrary nonnegative integer n, arbitrary DL-TBox , arbitrary
UCQ Q . define FQ ,T that, Q = Q, FQ ,T = ; otherwise,
FQ ,T consists following n rules:
A(x0 ) Q(x0 )

R(x0 , x1 ) A(x1 ) Q(x0 )
...

R(x0 , x1 ) R(x1 , x2 ) . . . R(xn1 , xn ) A(xn ) Q(x0 )
452

fiCompleteness Guarantees Incomplete Ontology Reasoners

Clearly, pEvaln (, , ) = cert(, FQ ,T , ) = f UCQ Q , DL-TBox
ABox , required. Furthermore, Q either Q = Q
ABox , pEvaln (Q , , ) = cert(Q , FQ ,T , ) = . Finally,
Q = Q, , ABox , clearly pEvaln (Q , , ) =
cert(Q , FQ ,T , ), required.
3.7.2 Simple vs. Non-Simple Test Suites
Proposition 3.18 Section 3.3 shows Q-simple -test suite exhaustive
Q class abstract reasoners provides sucient necessary test (Q, )completeness. next show analogous result hold contains recursive
axioms, even consider first-order reproducible abstract reasoners. Theorem 3.21, prove claim fixed Q since concept relevant recursive
axioms might dicult formalise; however, proof easily adapted
UCQs TBoxes. result essentially states -test suite exists provides
necessary sucient condition (Q, )-completeness abstract reasoner
CfT ; consequently, Proposition 3.18 -test suite exhaustive CfT Q
Q-simple. Furthermore, Section 3.7.3 show compute -test suite exhaustive
CfT Q, following claim hold vacuously.
Theorem 3.38. Let Q = {A(x) B(x) Q(x)}, let = {R.A A}, let C
class sound, monotonic, strongly faithful, first-order reproducible abstract reasoners applicable . Then, -test suite exists satisfies following two properties:
1. exhaustive C Q;
2. abstract reasoner ans C, ans (Q, )-complete ans passes S.
Proof. Assume -test suite = , SQ exists satisfies properties 1 2
theorem. Let n maximal number assertions occurring ABox S.
next define two abstract reasoners ans1 ans2 ; straightforward check
sound, monotonic, strongly faithful, first-order reproducible.
Given arbitrary FOL-TBox Tin , abstract reasoner ans1 uses datalog program
FT1in defined follows:
Tin , FT1in = .
Tin , FT1in contains following n rules:
r0 =
r1 =
r2 =

B(x0 ) A(x0 ) A(x0 )
B(x0 ) R(x0 , x1 ) A(x1 ) A(x0 )
B(x0 ) R(x0 , x1 ) R(x1 , x2 ) A(x3 ) A(x0 )
...
rn = B(x0 ) R(x0 , x1 ) . . . R(xn1 , xn ) A(xn ) A(x0 )
Given arbitrary FOL-TBox Tin , abstract reasoner ans2 uses datalog program
defined follows, predicate Z private FT2in (and hence aect
soundness abstract reasoner):
FT2in

453

fiCuenca Grau, Motik, Stoilos & Horrocks

Tin , FT2in = .
Tin , FT2in contains FT1in well following rules:
rZ1 = R(x0 , x1 ) . . . R(xn , xn+1 ) A(xn+1 ) Z(x0 )
rZ2 =
R(x0 , x1 ) Z(x1 ) Z(x0 )
rZ3 =
Z(x) B(x) A(x)
let arbitrary ABox containing n assertions. next show
that, assertion containing predicate Z, FT1in |=
FT2in |= . () direction trivial since FT1in FT2in , consider ()
direction. Furthermore, since rZ3 rule FT2in \ FT1in contain
Z head, claim nontrivial form A(a0 ) individual a0 occurring A. Since antecedent rZ3 satisfied a0 , B(a0 )
FT2in |= Z(a0 ). then, latter implied rZ1 rZ2 , individuals
a0 , a1 , . . . , ak 0 k exist R(ai , ai+1 ) 1 < k, A(ak ) A.
Since contains n assertions, w.l.o.g. assume k n. then, since
FT1in contains rule rk , FT1in |= A(a0 ) well, proves claim. consequence claim fact ABoxes contain n assertions,
cert(, FT1in , A) = cert(, FT2in , A) , cert(Y, FT1in , A) = cert(Y, FT2in , A)
A, SQ .
Let = {B(a0 ), R(a0 , a1 ), . . . , R(an , an+1 ), A(an+1 )}. cert(Q, , A) = {a0 }
cert(Q, FT1in , A) = , ans1 (Q, )-complete. Since exhaustive C Q,
abstract reasoner ans1 pass S; claim previous paragraph, abstract
reasoner ans2 pass either. next show ans2 (Q, )-complete,
contradicts assumption satisfies property 2 thus proves claim
theorem.
Consider arbitrary ABox containing assertions. Clearly, a0 cert(Q, , A)
individuals a0 , a1 , . . . , ak 0 k exist B(a0 ) A, R(ai , ai+1 )
1 < k, A(ak ) A. assume k n; since rk FT2in ,
FT2in |= A(a0 ) thus a0 cert(Q, FT2in , A). contrast, assume k > n; since
rZ1 FT2in , FT2in |= Z(akn1 ); since rZ2 FT2in , FT2in |= Z(ai )
0 k n 1; finally, since rZ3 FT2in , FT2in |= A(a0 ); then,
a0 cert(Q, FT2in , A), required.
corollary Theorem 3.38, next show testing abstract reasoners CfT
cannot done general using Q-simple test suites.
Corollary 3.39. Q = {A(x) B(x) Q(x)} = {R.A A}, Q-simple test suite exists exhaustive Q class sound, monotonic, strongly
faithful, first-order reproducible abstract reasoners applicable .
Proof. Q-simple -test suite exhaustive Q class mentioned
Theorem, Proposition 3.18 abstract reasoner ans class
pass (Q, )-complete, contradicts Theorem 3.38.
454

fiCompleteness Guarantees Incomplete Ontology Reasoners

Theorem 3.38 eectively says that, abstract reasoner ans CfT pass test suite S, cannot conclude ans (Q, )-complete. Please note holds
ans fails test form A, Q =
Y: Q = Y, counterexample
(Q, )-completeness ans. Thus, may show ans (Q, )-complete,
guaranteed so. illustrated following example.
Example 3.40. Let Q = {A(x) B(x) Q(x)} let = {R.A A, R.C C}. Furthermore, let = , SQ general test suite defined follows:
SQ = {

{ A(c) },
{ A(x) B(x) Q(x) } ,
{ R(c, d), A(d) }, { A(c) Q } ,
{ R(c, d), C(d) }, { C(c) Q }
}

Let R = RD , , Q RD = {R(x, y) A(y) A(x), R(x, y) C(y) C(x)}; clearly,
R rewriting Q w.r.t. . Section 3.7.3 show compute R using
variant injective instantiation way guarantees exhaustiveness CfT Q.
let ans1 CfT abstract reasoner defined FT1 = {R(x, y) A(y) A(x)}.
reasoner pass since cert({C(c) Q }, FT1 , {R(c, d), C(d)}) = f. Note, however, reasoner (Q, )-complete. Thus, test suite Q-simple, passing
sucient, necessary condition (Q, )-completeness. fact, note
contains TBox Theorem 3.38, theorem cannot reduce
correctly identifies reasoners CfT (Q, )-complete.
practice, however, one try mitigate fundamental theoretical limitation
eliminating irrelevant axioms rewriting R thus increasing likelihood
obtaining -test suite (Q, )-complete abstract reasoner pass. example,
using techniques Cuenca Grau, Horrocks, Kazakov, Sattler (2008a)
extract module R relevant query. example previous paragraph,
would remove rule R(x, y) C(y) C(x) R, injective instantiation
produce test suite = , SQ SQ defined follows:
SQ = {

{ A(c) },
{ A(x) B(x) Q(x) } ,
{ R(c, d), A(d) }, { A(c) Q }
}

Abstract reasoner ans1 previous paragraph passes thus guaranteed
(Q, )-complete.
let ans2 abstract reasoner defined FT2 = {B(x) R(x, y) A(y) A(x)}.
Clearly, abstract reasoner ans2 (Q, )-complete, ans2 pass SQ .
latter, however, cannot immediately conclude (Q, )-complete: test
fails involve original query Q. possible remedy, try unfold
R certain level injectively instantiate result hope obtaining -test
suite identify ans2 (Q, )-complete. particular, first unfolding
R produces following query:
B(x) R(x, y) A(y) Q(x)

Instantiating rewriting produces following test suite, prove
ans2 (Q, )-complete.
SQ = {

{ B(c), R(c, d), A(d) }, { A(x) B(x) Q(x) } }
455

fiCuenca Grau, Motik, Stoilos & Horrocks

Another round unfolding, however, produces following query:
B(x) R(x, y) R(y, z) A(z) Q(x)
Instantiating query produces following test suite:

Q ={

{ B(c), R(c, d), R(d, e), A(e) }, { A(x) B(x) Q(x) } }

ans2 pass
Q , conclude ans2 (Q, )-complete.



better understand Example 3.40, consider first-order reproducible abstract reasoner
ans, arbitrary UCQ Q, TBox R = RD , , RQ datalog rewriting
Q w.r.t. . Datalog program RD RQ equivalent (possibly infinite) UCQ RuQ
obtained RD RQ via exhaustive unfolding. following possibilities.
First, assume ans (Q, )-complete. Since RD RQ equivalent RuQ ,
certain answer Q w.r.t. arbitrary ABox produced r RuQ .
then, injective instantiation Ar r provide us counterexample
(Q, )-completeness ans. Thus, prove ans (Q, )-complete
generating elements RuQ fair manner (i.e., without indefinitely delaying
generation element RuQ ) checking whether cert(Q, , Ar ) ans(Q, , Ar );
guaranteed eventually encounter r RuQ invalidates condition
thus proves ans (Q, )-complete.
Second, assume ans (Q, )-complete. Using approach, determine cert(Q, , Ar ) ans(Q, , Ar ) holds r RuQ . RuQ finite (i.e.,
unfolding RD RQ terminates), RuQ UCQ rewriting Q w.r.t. ,
results Section 3.6 conclude ans indeed (Q, )-complete. If, however, RuQ infinite, never obtain sucient assurance (Q, )-complete
ans. following section show possible remedy problem.
3.7.3 Testing First-Order Reproducible Abstract Reasoners
section, show compute -test suite = , SQ exhaustive CfT
Q datalog, rewriting R = RD , R , RQ Q w.r.t. . Since first-order
reproducible abstract reasoners strongly faithful, need consider injective
instantiations R. Thus, rules R RQ instantiated Section 3.6.
rule r RD , however, instantiated pair A, SQ ABox obtained
instantiating body r Boolean UCQ obtained instantiating head
r. Intuitively, tests allow us check whether (unknown) first-order theory FT
captures behaviour abstract reasoner entails r.
Definition 3.41. Let Q UCQ query predicate Q, let admissible TBox,
let R = RD , R , RQ datalog, rewriting Q w.r.t. , let substitution
mapping variable occurring R distinct fresh individual. injective instanR,
R,
tiation R w.r.t. pair IR, = IR,
smallest set ABoxes
, IQ
IR,
smallest set pairs ABox UCQ
Q
Ar IR,
r R ,

456

fiCompleteness Guarantees Incomplete Ontology Reasoners

Ar , Q IR,
r RQ cert(, RD R , Ar ) = f,
Q
Ar , IR,
r RD form (6) cert(, RD R , Ar ) = f,
Q
UCQ = {i ((x), yi ) Q | 1 m} propositional query
predicate Q .
IR, clearly unique renaming fresh individuals , typically left
R
implicit, one talks injective instantiation IR = IR
, IQ R.
Example 3.42. Consider query Q = {A(x) Q(x)} EL-TBox consisting
following axioms, whose translation first-order logic shown symbol.
R.A B



BC



AD



R.C



C R.D



x, y.[R(x, y) A(y) B(x)]
x, y.[R(x, y) C(y) A(x)]
x.[B(x) C(x)]

x.[C(x) y.[R(x, y) D(y)]]
x.[A(x) D(x) ]

Then, R = RD , R , RQ defined next datalog rewriting Q w.r.t. .
RD = { R(x, y) A(y) B(x), R(x, y) C(y) A(x), B(x) C(x) }
R = { A(x) D(x) }

RQ = { A(x) Q(x) }

R
injective instantiation IR = IR
, IQ R shown below.

IR
= { { A(c), D(c) } }

IR
{ A(x) Q(x) } ,
Q = { { A(c) },
{ R(c, d), A(d) }, { B(c) Q } ,
{ R(c, d), C(d) }, { A(c) Q } ,
{ B(c) },
{ C(c) Q }
}



show injective instantiation datalog, rewriting Q w.r.t.
-test suite exhaustive CfT Q.
Theorem 3.43. Let Q UCQ, let TBox, let R = RD , R , RQ datalog,
R
R
rewriting Q w.r.t. , let IR = IR
, IQ injective instantiation R. Then,
-test suite exhaustive CfT Q.
Proof. Let substitution IR obtained from. first show IR -test
suite.
r
Consider arbitrary IR
. Then, rule r R exist = ; clearly
cert(, {r}, A) = t, cert(, RD R , A) = well; since R datalog, rewriting Q w.r.t. , unsatisfiable, required.

457

fiCuenca Grau, Motik, Stoilos & Horrocks

Consider arbitrary IR
Q . Then, cert(, RD R , A) = f Definition 3.41;
,
since R datalog
rewriting Q w.r.t. , satisfiable,
required.
show IR exhaustive CfT Q, consider arbitrary abstract reasoner
ans CfT passes IR is, ans satisfies following two properties:
(a) ans(, , ) = IR
,
(b) ans(, , ) = f implies cert(Y, , ) ans(Y, , ) Y, IR
Q.
Since ans first-order reproducible, set first-order sentences FT exists that,
ABox A,
ans(, , A) = cert(, FT , A),
ans(, , A) = f, ans(Q, , A) = cert(Q, FT , A).
assumption FT Definition 3.33 fact maps variables fresh
individuals, rng() ind(FT ) = .
Let R1D R2D smallest sets rules satisfying following conditions
rule r RD :
cert(, FT , Ar ) = implies r R1D , r obtained r replacing head
,
cert(, FT , Ar ) = f implies r R2D .
Furthermore, let R1Q R2Q sets rules obtained RQ analogous way.
Since R1D R2D obtained RD replacing head formulae , clearly
R1D R2D |= RD ; analogously, R1Q R2Q |= RQ .

next show FT |= R ; latter holds FT |= r rule r R .
Consider arbitrary rule r R ; note head(r) = . Then, Definition 3.41
r
r
Ar IR
; (a) ans(, , ) = t; Definition 3.33 cert(, FT , ) =
hence FT Ar |= ; finally, since rng() ind(FT ) = , Proposition 2.1
FT |= r, required.
next show FT |= R1D ; latter holds FT |= r rule r R1D .
Consider arbitrary rule r R1D ; note head(r) = . Then, definition R1D
cert(, FT , Ar ) = hence FT Ar |= ; finally, since rng() ind(FT ) = ,
Proposition 2.1 FT |= r, required.
completely analogous way previous paragraph, possible show
FT |= R1Q .
next show FT |= R2D ; latter holds FT |= r rule
r R2D . Consider arbitrary rule r R2D form (6); definition R2D
cert(, FT , Ar ) = f, Definition 3.33 ans(, , Ar ) = f. Then, Definition
3.41 Ar , IR
x), yi ) Q | 1 m}. Note
Q UCQ = {i ((
|= r Definition 2.2, Proposition 2.1 Ar |=
x), yi );
i=1 ((
definition fact Q occur , Ar |= Q ;
458

fiCompleteness Guarantees Incomplete Ontology Reasoners

then, cert(Y, , Ar ) = t. latter observation, ans(, , Ar ) = f, (b) imply
ans(Y, , Ar ) = t, Definition 3.33 cert(Y, FT , Ar ) = t. Since Q occurs

(note predicate occurring
FT private FT , Q cannot
r
occur FT ), FT |= i=1 ((x), yi ). Finally, since rng() ind(FT ) = ,
Proposition 2.1 FT |= r, required.
next show Q FT |= R2Q ; latter holds Q FT |= r
rule r R2Q . Consider arbitrary rule r R2Q ; note head(r) atom predicate
Q, definition R2Q cert(, FT , Ar ) = f, Definition 3.33
ans(, , Ar ) = f. Furthermore, Definition 3.41, cert(, RD R , Ar ) = f.
Let tuple arguments (head(r)). Then, Definition 3.41
Ar , Q IR
cert({r}, , Ar ), cert(RQ , RD R , Ar )
Q ; clearly,
monotonicity first-order logic. Since R rewriting Q w.r.t. , Definition 2.2 cert(Q, , Ar ). latter observation, ans(, , Ar ) = f, (b)
imply ans(Q, , Ar ). Definition 3.33 cert(Q, FT , Ar ); hence,
FT Ar |= Q(a). Finally, since rng() ind(FT ) = , Proposition 2.1
FT |= r, required.
following table summarises entailment relationships various first-order
theories obtained thus far:
FT |= R
Q FT |= R2Q

FT |= R1D
R1Q R2Q |= RQ

FT |= R2D
R1D R2D |= RD

FT |= R1Q

Clearly, implies following entailments:
FT |= RD R

Q FT |= RD R RQ

complete proof theorem show ans (Q, )-complete.
end, consider arbitrary ABox A; following possibilities, depending
satisfiability A.
Assume unsatisfiable. cert(, RD R , A) = Definition
2.2; mentioned entailments, cert(, FT , A) = t; consequently,
ans(, , A) = Definition 3.33, required.
Assume satisfiable ans(, , A) = f, consider arbitrary tuple
cert(Q, , A). Then, cert(, RD R , A) = f cert(RQ , RD R , A)
Definition 2.2. mentioned entailments, cert(Q, FT , A);
hence, ans(Q, , A) Definition 3.33, required.
Note size test suite obtained Theorem 3.43 linear size
rewriting, which, believe, makes approach suitable use practice.
3.7.4 Testing Ground Queries
shown Section 3.7.2, abstract reasoner ans CfT pass -test suite
Q-simple, cannot always conclude ans (Q, )-complete.
practical point view, would highly beneficial identify situations passing
would show ans indeed incomplete Q . Furthermore, applications
459

fiCuenca Grau, Motik, Stoilos & Horrocks

prototypical queries known design time, would design completeness
tests query-independentthat is, test abstract reasoner completeness
w.r.t. regardless input data query. section, show
achieve two goals focusing ground queries. restriction unreasonable
practice, since SPARQL query equivalently expressed ground UCQ.
first define query-independent notion exhaustiveness test suite.
Definition 3.44. Let TBox, let -test suite, let C class abstract
reasoners applicable . Then, exhaustive C ground UCQs ans C
passes (Q, )-complete ground UCQ Q.
Then, define notion ground rewriting rewriting captures
query answers w.r.t. , regardless input ground query ABoxand show
instantiate ground rewritings.

Definition 3.45. ground rewriting TBox pair R = RD , R that,
ground UCQ Q, triple RD , R , Q datalog rewriting w.r.t. Q.

injective instantiation IR R defined IR = IR R = RD , R , .
Note Definition 3.45 implies variable occurring head rule
R occurs rule body. Tools REQUIEM KAON2 easily
adapted compute ground rewriting TBox practice. next show
injective instantiation ground rewriting yields -test suite provides us
sucient necessary check completeness w.r.t. ground UCQs.

Theorem 3.46. Let TBox, let R = RD , R ground rewriting .
Then, following two claims hold.
1. IR exhaustive CfT ground UCQs.
2. abstract reasoner ans CfT pass IR (Q, )-complete
ground UCQ Q.

Proof. (Property 1) Consider arbitrary abstract reasoner ans CfT passes IR . Let
FT first-order theory characterises behaviour ans; proof
Theorem 3.43, fact ans passes IR implies FT |= RD R . Furthermore, consider
arbitrary ground UCQ Q arbitrary ABox A. ans (Q, )-complete
shown proof Theorem 3.43, minor dierence cert(Q, , A)
implies cert(Q, RD R , A) Definition 3.45.
(Property 2) Note that, since R ground rewriting , Definition 3.41 UCQs
IR ground. Thus, abstract reasoner ans CfT pass IR , clearly
shows ans (Q, )-complete ground UCQ Q.

4. Comparing Incomplete Abstract Reasoners
section, investigate techniques that, given query Q TBox , allow us
determine whether abstract reasoner ans2 complete abstract reasoner
ans1 is, whether ABoxes A, abstract reasoner ans2 computes answers
Q abstract reasoner ans1 . idea formalised following definition.
460

fiCompleteness Guarantees Incomplete Ontology Reasoners

Definition 4.1. Let Q UCQ, let TBox, let ans1 ans2 abstract
reasoners applicable . Then, ans1 Q,T ans2 following conditions hold
ABox A:
1. cert(, , A) = ans1 (, , A) = imply ans2 (, , A) = t;
2. cert(, , A) = f, ans1 (, , A) = f, ans2 (, , A) = f imply
ans1 (Q, , A) cert(Q, , A) ans2 (Q, , A) cert(Q, , A).
Furthermore, ans1 <Q,T ans2 ans1 Q,T ans2 ABox exists least one
following two conditions holds:
3. cert(, , A) = t, ans1 (, , A) = f, ans2 (, , A) = t;
4. cert(, , A) = f, ans1 (, , A) = f, ans2 (, , A) = f,
ans1 (Q, , A) cert(Q, , A) ans2 (Q, , A) cert(Q, , A).
Example 4.2. Consider abstract reasoners rdf, rdfs, rl, classify introduced Example 3.3 query Q TBox Example 3.14. clearly following:
rdf Q,T rdfs Q,T rl Q,T classify
Furthermore, two abstract reasoners, ABox exists distinguishes
abstracts reasoners w.r.t. Q ; example, ABox = {takesCo(c, d), MathsCo(d)},
rdfs(Q, , ) = rl(Q, , ) = {c}. result, following:
rdf <Q,T rdfs <Q,T rl <Q,T classify



would check whether ans1 Q,T ans2 ans1 <Q,T ans2 given pair
abstract reasoners subjecting reasoners finite set tests. Towards goal,
R
next define relations R
Q,T <Q,T compare abstract reasoners w.r.t. given
finite set R ABoxes. Ideally, given Q , would compute finite R
R
R
Q,T <Q,T coincide Q,T <Q,T abstract reasoners class C
interest. ideas captured following definitions.
Definition 4.3. Let Q UCQ, let TBox, let R finite set ABoxes, let
ans1 ans2 abstract reasoners applicable .
Then, ans1 R
Q,T ans2 Conditions 1 2 Definition 4.1 hold ABox
R
R. Furthermore, ans1 <R
Q,T ans2 ans1 Q,T ans2 either Condition 3 Condition
4 Definition 4.1 holds ABox R.
Definition 4.4. Let Q UCQ, let TBox, let C class abstract reasoners
applicable . finite set R ABoxes (Q, )-representative C following
conditions hold ans1 , ans2 C:
1. ans1 R
Q,T ans2 ans1 Q,T ans2 ;
461

fiCuenca Grau, Motik, Stoilos & Horrocks

2. ans1 <R
Q,T ans2 ans1 <Q,T ans2 .
show next, prove R (Q, )-representative, suces show
implication Condition 1 implication Condition 2 Definition 4.4.
Proposition 4.5. Let Q UCQ, let TBox, let C class abstract reasoners
applicable , let R finite set ABoxes
1. ans1 R
Q,T ans2 implies ans1 Q,T ans2 ,
2. ans1 <Q,T ans2 implies ans1 <R
Q,T ans2 .
Then, R (Q, )-representative C.
Proof. Note ans1 Q,T ans2 trivially implies ans1 R
Q,T ans2 ; thus, Condition 1
proposition clearly implies Condition 1 Definition 4.4. Furthermore, ABox R
satisfies Condition 3 4 Definition 4.1, Condition 1 2 Definition 4.1 holds well;
consequently, Conditions 1 2 proposition imply Condition 2 Definition 4.4.
obvious question whether Q-simple -test suite exhaustive class
C Q (Q, )-representative C. following example shows
necessarily case.
Example 4.6. Let Q specified Example 3.14, let R = {A1 , . . . , A6 }
ABoxes specified Example 3.16. shown Section 3, Q-simple -test suite
= , SQ = {A6 } SQ = {A1 , . . . , A5 } exhaustive CwQ,T Q.
Let trivial abstract reasoner returns empty set input, consider RDF-based abstract reasoner rdf Example 3.3, ignores TBox
evaluates query directly ABox. Clearly, trivial Q,T rdf; furthermore,
trivial <Q,T rdf since = {St(c), takesCo(c, d), MathCo(d)} rdf(Q, , A) = {c}
whereas trivial(Q, , A) = . abstract reasoners, however, return empty set
answers ABoxes R thus rdf R
Q,T trivial. Hence, using R cannot
dierentiate two abstract reasoners.

4.1 Negative Result
following strong result shows that, numerous TBoxes , finite set ABoxes
exists dierentiate two arbitrary abstract reasoners class sound,
first-order reproducible, monotonic, strongly faithful reasoners. Note result
stronger negative result Theorem 3.21, applies smaller class abstract
reasoners TBoxes imply least one concept subsumption.
Theorem 4.7. Let arbitrary TBox mentioning atomic role R atomic
concepts B |= B, let Q = {B(x) Q(x)}. Then, finite set
ABoxes exists (Q, )-representative class sound, monotonic, strongly
faithful, first-order reproducible abstract reasoners applicable .
462

fiCompleteness Guarantees Incomplete Ontology Reasoners

Proof. Assume finite set ABoxes R exists (Q, )-representative class
sound, monotonic, strongly faithful, first-order reproducible abstract reasoners
applicable . Let n maximum number assertions ABox R.
arbitrary integer k 1, let ansk first-order reproducible abstract reasoner
that, given FOL-TBox Tin , uses following datalog program FTkin :
FTkin

=




Tin | = B
A(x0 ) R(x0 , x1 ) . . . R(xk1 , xk ) B(x0 ) Tin |= B

Clearly, ansk sound, monotonic, strongly faithful; furthermore, ansk (, , A) = f
ABox A. next show ansn+1 (Q, , A) ansn+2 (Q, , A) ABox
R. Consider arbitrary a0 ansn+1 (Q, , A); then, individuals a0 , a1 , . . . , an+1 exist
R(a1 , ) 1 n + 1. Since contains n assertions
rule FTn+1 contains n + 1 body atoms, ai = aj = jthat is,
contains R-cycle. then, rule FTn+2 matched mapping x0
a0 , a0 ansn+2 (Q, , A). Therefore, ansn+1 R
Q,T ansn+2 .
= {A(a0 ), R(a0 , a1 ), . . . , R(an , an+1 )}, however, a0 ansn+1 (Q, , A)
ansn+2 (Q, , A) = ; thus, ansn+1 Q,T ansn+2 hold, contradicts assumption R exhaustive class abstract reasoners theorem.
4.2 Compact Abstract Reasoners
Theorem 4.7 suggests need make additional assumptions abstract reasoners wish compare using finite set ABoxes. section, show
representative sets ABoxes computed practice restrict
abstract reasoners call (Q, )-compact. Intuitively, abstract reasoner
processes Q, , computing certain answers Q, A, subset
, subset depends Q. words, behaviour compact
abstract reasoners simulated following process: select subset axioms
input TBox processed, compute certain answers w.r.t.
selected fragment TBox. class (Q, )-compact abstract reasoners thus captures properties concrete reasoners Jena Oracles Semantic Data Store
discard axioms input TBox fall outside certain fragment (e.g., existential
restrictions right-hand implications) encode remaining axioms
suitable set rules.
Definition 4.8. Let Q UCQ, let TBox. abstract reasoner ans applicable
(Q, )-compact TBox exists following properties hold
ABox A:
1. cert(, , A) = implies ans(, , A) = t;
2. cert(, , A) = f implies ans(, , A) = f ans(Q, , A) = cert(Q, , A).
Abstract reasoner ans compact (Q, )-compact UCQ Q TBox
ans applicable. Finally, CcQ,T class (Q, )-compact strongly
(Q, )-faithful abstract reasoners applicable .
463

fiCuenca Grau, Motik, Stoilos & Horrocks

Example 4.9. abstract reasoners defined Example 3.3 (Q, )-compact
query Q EL-TBox Example 3.14. Indeed, abstract reasoner rdf subset
given = ; abstract reasoner rdfs = {(8)}; abstract reasoner
rl = {(8), (9), (10)}; abstract reasoner classify = .

abstract reasoners ansk defined proof Theorem 4.7 (Q, )compact query TBoxes Theorem 4.7 applies.

Proposition 4.10. Let Q = {B(x) Q(x)} let = {A B, C R.}. Then,
k 1, abstract reasoner ansk proof Theorem 4.7 (Q, )-compact.
Proof. Let Q stated theorem consider arbitrary k 1. Let A1
A2 ABoxes defined follows:
A1 = {A(a0 )}

A2 = {A(a0 ), R(a0 , a1 ), . . . , R(ak1 , ak )}

Clearly, following:
ansk (Q, , A1 ) =

ansk (Q, , A2 ) = {a0 }

One straightforwardly check, however, following holds :
cert(Q, , A1 ) = cert(Q, , A2 )
Thus, ansk (Q, )-compact.
Thus, negative result Theorem 4.7 immediately apply class
containing compact abstract reasoners.
4.3 Comparing Compact Abstract Reasoners
section, show set ABoxes (Q, )-representative CcQ,T
obtained computing, subset , Q-simple -test suite exhaustive

CsQ,T . minor complication arises due fact contain fewer individuals

. deal cases correctly, ABoxes ST allowed contain

individuals occurring , ABoxes STQ allowed contain
individuals occurring Q . assumption without loss generality:

given (Q, )-test suite ST , one replace individuals Q

fresh individuals; result replacement (Q, )-test suite exhaustive CsQ,T .
Theorem 4.11. Let Q UCQ, let TBox. Furthermore, , let




ST = ST , STQ Q-simple -test suite exhaustive CsQ,T Q


ABox ST contains individual ind(T ) \ ind(T ) ABox STQ contains
individual ind(T ) \ ind(Q ). Then, set R ABoxes defined



R=
ST STQ


(Q, )-representative CcQ,T .
464

fiCompleteness Guarantees Incomplete Ontology Reasoners

Proof. Assume R satisfies conditions theorem, let ans1 ans2
arbitrary abstract reasoners CcQ,T . next show ans1 ans2 satisfy two
properties Proposition 4.5.
Property 1 Proposition 4.5:

ans1 R
Q,T ans2 implies ans1 Q,T ans2

Property 2 Proposition 4.5:

ans1 <Q,T ans2 implies ans1 <R
Q,T ans2

Since ans1 (Q, )-compact, TBox exists satisfies conditions
Definition 4.8. Assume ans1 R
Q,T ans2 ; next show Conditions 1 2
Definition 4.1 satisfied arbitrary ABox A.
(Condition 1) Assume cert(, , A) = ans1 (, , A) = t. contrapositive property 2 Definition 4.8, cert(, , A) = t. Since R contains ABoxes

Q-simple -test suite exhaustive CsQ,T Q, Theorem 3.30
exist ABox R -stable renaming dom() = ind(T )
(A ) A; since contain individuals ind(T ) \ ind(T ), renaming
-stable. definition -test suite, cert(, , ) = t; furthermore, property 1

Definition 4.8 ans1 (, , ) = t. Since ans1 R
Q,T ans2 ans2 (, , ) = t.

Since ans2 strongly (Q, )-faithful -stable, ans2 (, , (A )) = t. Finally, since (A ) ans2 (Q, )-monotonic, ans2 (, , A) = t, required.
(Condition 2) Assume cert(, , A) = f, ans1 (, , A) = f, ans2 (, , A) = f,
consider arbitrary tuple ans(Q, , A) cert(Q, , A). contrapositive
property 1 Definition 4.8, cert(, , A) = f; then, property 2 Definition 4.8, cert(Q, , A). Since R contains ABoxes Q
simple -test suite exhaustive CsQ,T Q, Theorem 3.30 exist
ABox R, tuple b cert(Q, , ), (Q, )-stable renaming
dom() = ind(Q ), (A ) A, (b) = a; since contain individuals ind(T ) \ ind(Q ), renaming (Q, )-stable. definition
(Q, )-test suite, cert(, , ) = f; furthermore, property 2 Definition 4.8
b ans1 (Q, , ). Since ans1 R ans2 b ans2 (Q, , ). Since ans2 strongly
Q,T
(Q, )-faithful (Q, )-stable, ans2 (Q, , (A )). Finally, since
(A ) ans2 (Q, )-monotonic, ans2 (Q, , A), required.
Assume ans1 <Q,T ans2 . Definition 4.1, ans1 Q,T ans2 ABox
exists satisfying Conditions 3 4 Definition 4.1. Clearly, ans1 R
Q,T ans2 ; hence,
remains shown R contains ABox satisfies Conditions 3 4
Definition 4.1. Since ans1 (Q, )-compact, TBox exists satisfies
conditions Definition 4.8.
(Condition 3) Assume cert(, , A) = t, assume ans1 (, , A) =
ans2 (, , A) = f. proof Condition 1, identify ABox R
-stable renaming ans1 (, , ) = (A ) A. Since ans2 (Q, )monotonic ans2 (, , A) = f, ans2 (, , (A )) = f; furthermore, since ans2
strongly (Q, )-faithful -stable, ans2 (, , ) = f. then,
Condition 3 Definition 4.1 satisfied R.
(Condition 4) Assume cert(, , A) = f ans1 (, , A) = ans2 (, , A) = f,
consider arbitrary tuple [ans1 (Q, , A) cert(Q, , A)] \ ans2 (Q, , A).
proof Condition 2, identify ABox R, (Q, )-stable renaming ,
465

fiCuenca Grau, Motik, Stoilos & Horrocks

tuple b cert(Q, , ) (A ) A, (b) = a, b ans1 (Q, , ). Since ans2
(Q, )-monotonic ans2 (Q, , A), ans2 (Q, , (A )); furthermore, since
ans2 strongly (Q, )-faithful (Q, )-stable, b ans2 (Q, , ).
then, Condition 4 Definition 4.1 satisfied R.
Theorems 3.32 4.11 immediately suggest approach computing set ABoxes
(Q, )-representative CcQ,T . First, compute UCQ rewriting Q w.r.t.
subset ; then, instantiate rule rewriting using injective
instantiation mapping; finally, compute R union ABoxes test suites.
nave procedure, however, practical since requires computing exponential
number UCQ rewritings. next present practical approach computing
set ABoxes (Q, )-representative CcQ,T . Intuitively, instead computing
exponentially many rewritings, one compute single UCQ rewriting Q w.r.t.
subset-closed is, contains rewriting subset .
Definition 4.12. UCQ rewriting R = R , RQ Q w.r.t. subset-closed
tuple R = R , RQ exists R R , RQ RQ R
UCQ rewriting Q w.r.t. .
following corollary immediate consequence Theorems 3.27, 3.32, 4.11.

Corollary 4.13. Let Q UCQ, let TBox, let R subset-closed UCQ rewriting
R
Q w.r.t. , let IR = IR
, IQ injective instantiation R. Then, set
Q,T
R
ABoxes R = IR
.
IQ (Q, )-representative Cc

Practical query rewriting systems REQUIEM optimised produce small
UCQ rewriting possible, output typically subset-closed. Therefore,
technique requires modification UCQ rewriting algorithms implemented existing systems. illustrated following example, required modification typically
involves disabling (at least partially) subsumption-based optimisations.
Example 4.14. Let Q specified Example 3.14, let = , SQ
-test suite Example 3.16. system REQUIEM compute R
given Q . Note, however, R subset-closed; example, UCQ
rewriting Q w.r.t. = Q, subset RQ . rewriting made
subset-closed extending RQ following rules:
St(x) takesCo(x, y) MathCo(x, y) Q(x)
St(x) takesCo(x, y) CalcCo(x, y) Q(x)
MathSt(x) St(x) Q(x)

Systems REQUIEM, however, typically discard rules applying subsumption
optimisations described Section 3.5.3.

following example shows, subset-closed UCQ rewriting Q w.r.t. can,
worst case, exponentially larger minimal UCQ rewritings Q w.r.t. .
Example 4.15. Let Q = {C(x) Q(x)}, let following TBox:
= {B Ai | 1 n} {A1 . . . C}
466

fiCompleteness Guarantees Incomplete Ontology Reasoners

Furthermore, let R = R , RQ R = RQ contains following rules:
C(x) Q(x)

B(x) Q(x)

A1 (x) . . . (x) Q(x)
Clearly, R UCQ rewriting Q w.r.t. ; however, number rules subset-closed
UCQ rewriting Q w.r.t. exponential n.


5. Evaluation
implemented techniques computing exhaustive test suites comparing incomplete concrete reasoners prototype tool called SyGENiA.1 tool uses REQUIEM
computing UCQ datalog rewritings.2
considered two evaluation scenarios. first one uses well-known Lehigh
University Benchmark (LUBM) (Guo et al., 2005), consists relatively small
TBox academic domain, 14 test queries, data generator. second one
uses small version GALEN (Rector & Rogers, 2006)a complex ontology commonly
used medical applications.
evaluated following concrete reasoners: Sesame v2.3-prl,3 DLE-Jena v2.0,4
OWLim v2.9.1,5 Minerva v1.5,6 Jena v2.6.37 three variants (Micro, Mini,
Max).
5.1 Computing Exhaustive Test Suites
Given UCQ Q TBox , tool uses REQUIEM compute datalog rewriting
R Q . R UCQ rewriting, tool computes simple test suite
either full injective instantiation (see Sections 3.5 3.6, respectively); otherwise,
tool computes non-simple test suite instantiating R described Section 3.7.3.
5.1.1 Simple Test Suites
case LUBM benchmark, 14 test queries leads UCQ rewriting w.r.t. TBox.8 Therefore, computed UCQ rewriting query Q
benchmark using REQUIEM instantiated it, fully injectively, thus obtaining
Q-simple -test suites exhaustive Q CwQ,T CsQ,T , respectively.
times needed compute test suites size test suite shown Table
3, denotes total number ABoxes corresponding test suites.
1.
2.
3.
4.
5.
6.
7.
8.

http://code.google.com/p/sygenia/
http://www.cs.ox.ac.uk/projects/requiem/home.html
http://www.openrdf.org/
http://lpis.csd.auth.gr/systems/DLE-Jena/
http://www.ontotext.com/owlim/
http://www.alphaworks.ibm.com/tech/semanticstk
http://jena.sourceforge.net/
Since REQUIEM currently support individuals queries, replaced individuals
queries distinguished variables.

467

fiCuenca Grau, Motik, Stoilos & Horrocks

Q,T
Cw

CsQ,T

Q1
Time 1.2

2
Time 1.2

1

Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14
0.7 0.2 6.7 0.2 2.1 0.7
7
2.4 7.4 0.07 0.2 0.2 0.05
20 2 2 352 8 1207 345 3 092 5 3 919 7
25 10
1
0.6 0.2 0.6 0.2 1.2 0.4 1.5 2.5 0.6 0.05 0.1 0.1 0.08
4
1
22
4 169 37
36
1 169
2
3
5
1

Table 3: Computation simple test suites LUBM. Times given seconds.

Q,T
Cw

CsQ,T

Time

Time


Q1
14
6 049
2.2
79

Q2
34
12 085
6
151

Q3
67
12 085
40
151

Q4
4.6
79
1.7
25

Table 4: Computation simple test suites GALEN. Times given seconds.
shown table, simple test suites could computed times ranging 0.05
7 seconds, CwQ,T CsQ,T . optimisations implemented REQUIEM ensure
UCQ rewritings relatively small, resulting test suites consist
relatively small number ABoxes. Notice, however, significant dierence
numbers ABoxes test suites obtained via injective instantiation (which range 1
169 average 32), obtained via full instantiation (which range
1 3, 919 average 702). Furthermore, rule rewriting contains
6 atoms, therefore ABox test suite contains 6 assertions.
case GALEN, used following sample queries, REQUIEM
compute UCQ rewriting:
Q1
Q2
Q3
Q4

:
:
:
:

HaemoglobinConcentrationProcedure(x) Q(x)
PlateletCountProcedure(x) Q(x)
LymphocyteCountProcedure(x) Q(x)
HollowStructure(x) Q(x)

instantiated UCQ rewriting fully injectively. times needed compute test suites size test suite shown Table 4.
shown table, simple test suites GALEN computed times ranging
1.7 67 seconds average 33 seconds. Thus, computing test suites
GALEN time consuming LUBM. unsurprising since TBox
GALEN significantly complex LUBM. number ABoxes
test suites ranged 25 151 case injective instantiations 79
12, 000 case full instantiations; again, note significant dierence
sizes two kinds test suites. cases, however, individual ABox
small, largest one containing 11 assertions.
5.1.2 Non-Simple Test Suites
computed non-simple test suites cases UCQ rewriting exists.
already mentioned, LUBM queries UCQ-rewritable. Therefore, manually added
following query, REQUIEM computes recursive datalog rewriting.
468

fiCompleteness Guarantees Incomplete Ontology Reasoners

Time (s)


CfT

LUBM
Q15
1.4
22

Q5
5.2
41

GALEN
Q6 Q7
1.3 2.7
23
31

Q8
1.6
12

Table 5: General test suites computed datalog rewritings LUBM GALEN.
System
Completeness Guarantee Completeness w.r.t. LUBM data set
JenaMax/DLE-Jena
Q1 Q14
Q1 Q14
OWLim
Q1 Q5 , Q7 , Q9 , Q11 Q14
Q1 Q14
Jena Mini/Micro
Q1 Q5 , Q7 , Q9 , Q11 Q14
Q1 Q14
Minerva
Q1 Q4 , Q9 , Q14
Q1 Q14
Sesame
Q1 , Q3 , Q11 , Q14
Q1 Q5 , Q11 , Q14

Table 6: Completeness guarantees UCQ-rewritable queries LUBM
Q15 :

Organization(x) Q(x)

Due complex structure GALEN TBox, test queries UCQ rewritable
easily identified. evaluated following four.
Q5
Q6
Q7
Q8

:
:
:
:

WestergrenESRProcedure(x) Q(x)
ArthroscopicProcedure(x) Q(x)
TrueCavity(x) Q(x)
BacterialCellWall(x) Q(x)

Times needed compute test suites size test suite shown Table 5.
5.2 Completeness Guarantees
already discussed, existing concrete reasoners captured strongly (Q, )-faithful
abstract reasoners. Hence, order establish completeness guarantees concrete
reasoners, restricted tests test suites computed using injective instantiations.
5.2.1 Results Simple Test Suites
results original queries LUBM benchmark shown Table 6.
concrete reasoner, first column table shows queries
able prove completeness using techniques (i.e., queries complete
arbitrary data set), second column table shows queries
concrete reasoner computes answers canonical LUBM data set one university.
results clearly show completeness w.r.t. data set LUBM benchmark
guarantee completeness arbitrary data sets; example, OWLim, Minerva,
Jena Mini/Micro complete queries w.r.t. LUBM data set (and
systems even complete expressive UOBM benchmark); however, certain
queries, systems found incomplete data set test suites.
Jena Max DLE-Jena systems guaranteed complete
14 LUBM queries regardless data setthat is, systems behave exactly
complete OWL reasoner LUBM queries LUBM TBox. According Jenas
469

fiCuenca Grau, Motik, Stoilos & Horrocks

documentation, Jena Max supports types axioms used LUBM TBox, hence
expected complete LUBM TBox queries. Interestingly, tested
LUBM data sets, Jena Max could compute answers many
queries, used smaller LUBM data sets instead. demonstrates additional
advantage approach: require reasoning w.r.t. large data sets, since
ABoxes test suites typically contain small number assertions. Regarding DLEJena, according technical description (Meditskos & Bassiliades, 2008), system
uses complete DL reasoner materialise certain subsumptions preprocessing step
uses Jena saturate ABox, much abstract reasoner classify
Example 3.3. Hence, DLE-Jena least complete Jena Mini and, addition,
able draw inferences Jena Mini missing (see below).
OWLim complete LUBM queries involve reasoning existential
quantifiers consequent implications. well known latter supported
system. Jena Mini Micro exhibited exactly behaviour OWLim,
despite fact Jena Mini handle larger fragment OWL OWLim. Clearly,
LUBM TBox queries suciently complex reveal dierences
OWLim, Jena Mini/Micro.
Minerva guaranteed complete six queries. DLE-Jena, uses
DL reasoner materialise entailed subsumptions atomic concepts, uses
custom method saturating ABox. investigating several ABoxes test
suites concluded Minerva cannot correctly handle (at-least) inverse role axioms;
example, cannot find entailment { R R , R(a, b) } |= R(b, a).
Finally, Sesame complete four queries. unsurprising since Sesame
RDFS reasoner thus complete small fragment OWL 2 DL.
next discuss results tests based GALEN ontology test queries
Q1 Q4 . could run Jena Max since GALEN heavily uses existential restrictions,
(according Jenas documentation) might cause problems. Minerva
system provided completeness guarantee least one query (Q4 );
Minerva precomputes subsumption relationships atomic concepts depend
existential restrictions right hand side TBox axioms, systems
handle. Also, unlike LUBM, version GALEN used contain
inverse roles, Minerva performed much better ontology. systems
identified incomplete test queries.
5.2.2 Results Non-Simple Test Suites
Results test queries UCQ-rewritable summarised Table 7. Symbol
indicates concrete reasoner found complete given query. Furthermore, whenever concrete reasoner failed test suite, tried prove reasoner
incomplete discussed examples Section 3.7.2; cases successful,
symbol indicates concrete reasoner identified incomplete
given query. Finally, symbol indicates concrete reasoner ran memory.
case LUBM, able establish completeness guarantees w.r.t. query
Q15 OWLim, Jena Micro, DLE-Jena, Jena Max. Note systems
handle recursive TBox statements, completeness Q15 surprising. RDFS,
470

fiCompleteness Guarantees Incomplete Ontology Reasoners

OWLim
Jena Max
Jena Micro
DLE-Jena
Minerva
Sesame

LUBM
Q15







Q5






GALEN
Q6 Q7











Q8






Table 7: Completeness guarantees datalog-rewritable queries

CsQ,T

Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14
Time 1.4 1.1 0.2 1.8 0.8 1.2 9.5 7.8 - 0.9 0.05 0.5 0.6 0.04
R
1 24 17 130 136 219 925 777 - 219 2
74 185 1

Table 8: Representative sets ABoxes LUBM. Times given seconds.
however, cannot express recursive TBox statements involving roles, Sesamean RDFS
reasonerfails compute certain answers tests.
case GALEN, completeness guaranteed query Q8 OWLim, Jena Micro,
DLE-Jena, Minerva, additionally query Q6 Minerva. already mentioned,
answers queries GALEN depend positive occurrences existential restrictions
axioms, systems cannot handle. could run Jena Max GALEN.
5.3 Comparing Incomplete Concrete Reasoners
implemented techniques comparing reasoners Section 4.3. end,
modified REQUIEM compute subset-closed rewritings, injectively
instantiated obtain (Q, )-representative sets ABoxes R.
5.3.1 Tests LUBM
shown Table 8, representative sets ABoxes could computed seconds
LUBM queries. exception Q9 , REQUIEM terminate
disabling rule subsumption optimisations. size representative sets ranged
1 777 ABoxes. expected, representative sets contain ABoxes
exhaustive test suites query TBox (see Table 3).
combinations system query tests Section 5.2 identified
system incomplete shown Table 9. table shows proportion certain
answers system returned applied LUBM data set, ABoxes R,
ABoxes test suite used Section 5.2 check systems completeness.
shown table, OWLim Jena Micro exhibited behaviour
almost complete. contrast, Sesame least complete queries. Furthermore,
please note dierence values obtained R S; particular,
Sesame compute certain answer Q5 S, whereas system able
compute certain answers Q5 ABoxes (e.g., LUBM data set).
ABoxes cannot distinguish Sesame trivial reasoner always
returns empty set answers; however, set R make distinction.
471

fiCuenca Grau, Motik, Stoilos & Horrocks

LUBM

R

Q5
1
0.25
0.8

Q6
1
0.86
0.86

LUBM

R

Q2
1
0.75
0.75

Q4
1
0.68
0.06

Minerva
Q8
Q10
Q12
1
1
1
0.98 0.86 0.25
0.81 0.84 0.92
Sesame
Q5
Q6
Q7
Q8
1
0.83 0.87 0.83
0
0.003 0.04 0.04
0.36 0.033 0.01 0.004
Q7
1
0.86
0.86

Q13
1
0.2
0.23

OWLim & JMicro
Q6
Q8
Q10
1
1
1
0.99
0.98
0.99
0.96
0.98
0.97

Q9
0.64
0
-

Q10
0.83
0.001
0.028

Q12
0
0.25
0.017

Q13
0
0.2
0.23

Table 9: Reasoner comparison LUBM

CsQ,T

Time
R

Q1
15
140

Q2
46
266

Q3
70
266

Q4
2
127

Table 10: Representative sets ABoxes GALEN
5.3.2 Tests GALEN
shown Table 10, representative sets ABoxes GALEN could computed
times ranging 2 70 seconds, set contains small number ABoxes.
system query, Table 11 shows proportion certain answers returned
system R test suite Section 5.2. Minerva complete
system. Jena Micro better DLE-Jena (apart query Q4 ), DLE-Jena
OWLim behaved almost way (again apart query Q4 ). expected,
Sesame least complete system.
discrepancies OWLim, Jena Micro, DLE-Jena Minerva rather
surprising. OWLim Jena theoretically support features OWL; furthermore,
DLE-Jena extension Jena (Meditskos & Bassiliades, 2008) DLE-Jena
least complete Jena, case LUBM. order explain discrepancies,
analysed test suites queries Q1 Q4 . precisely, selected ABoxes
OWLim fails return certain answers Jena Micro complete,
identified minimal set TBox axioms entail certain answers. analysis
revealed that, query Q4 , OWLim fails find entailment
{Device(a), HollowTopology(b), hasTopology(a, b)} |= HollowStructure(a),

follows following GALEN axioms:

HollowTopology Topology hasState.Hollow
Device SolidStructure

HollowStructure SolidStructure hasTopology.(Topology hasState.Hollow)

Although existential restrictions appear several axioms, observe reasoning
existential variables actually required, first third axioms imply (by simple
structural transformation) following axiom:
SolidStructure hasTopology.HollowTopology HollowStructure
472

fiCompleteness Guarantees Incomplete Ontology Reasoners

Sesame
OWLim
DLE-Jena
JMicro
Minerva

Q1

R
0.01 0.18
0.54 0.65
0.54 0.65
0.69 0.82
0.84 0.91

Q2

R
0 0.16
0.52 0.63
0.52 0.63
0.68 0.81
0.84 0.90

Q3

R
0 0.16
0.52 0.63
0.52 0.63
0.68 0.81
0.84 0.90

Q4

R
0.04 0.10
0.52 0.48
0.76 0.9
0.76 0.67
1
1

Table 11: Reasoner comparison GALEN
axiom entails required answer, systems deal axioms form;
however, unlike Jena Micro, OWLim appears incapable dealing cases.
Regarding DLE-Jena, according technical description (Meditskos & Bassiliades,
2008), system replaced several inference rules Jena queries DL reasoner, strictly extend Jena. investigation exhaustive test suite
query Q4 revealed DLE-Jena returns many answers based existential
restrictions right hand side TBox axioms Jena misses; however, investigation revealed DLE-Jena misses several inferences Jenas TBox reasoner
capture, probably due replacement Jenas inference rules.
explains DLE-Jena performs worse Minerva GALEN.
results clearly show behaviour systems greatly depends given
application scenario. example, DLE-Jena complete LUBM queries,
perform equally well GALEN. contrast, Minerva perform well
LUBM, complete system GALEN. results thus allow application
developers conduct thorough comparison reasoning systems given application.

6. Conclusion
paper proposed theoretical framework practical techniques establishing formally provable algorithmically verifiable completeness guarantees incomplete ontology reasoners. approach radically departs ad hoc evaluation based
well-known benchmarks, provides solid foundation striking balance
scalability completeness practical applications.
approach opens numerous exciting possibilities future research.
example, work opens door design ontology-based information systems
optimised class ontologies, queries, data relevant particular application. information systems could maximise scalability reasoning still ensuring
completeness query answers, even rich ontologies sophisticated queries.

Acknowledgments
extended version paper Incomplete Semantic Web Reasoner?
Giorgos Stoilos, Bernardo Cuenca Grau, Ian Horrocks published AAAI 2010
paper Completeness Guarantees Incomplete Reasoners authors
published ISWC 2010.
473

fiCuenca Grau, Motik, Stoilos & Horrocks

research supported EU project SEALS (FP7-ICT-238975),
EPSRC projects ExODA (EP/H051511/1) HermiT (EP/F065841/1). B. Cuenca
Grau supported Royal Society University Research Fellowship.

References
Acciarri, A., Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., Palmieri, M., &
Rosati, R. (2005). Quonto: Querying ontologies. Proceedings 20th National
Conference Artificial Intelligence (AAAI-05)., pp. 16701671. AAAI Press /
MIT Press.
Artale, A., Calvanese, D., Kontchakov, R., & Zakharyaschev, M. (2009). DL-Lite family
relations. J. Artificial Intelligence Research (JAIR), 36, 169.
Baader, F., McGuinness, D., Nardi, D., & Patel-Schneider, P. (2002). Description Logic
Handbook: Theory, implementation applications. Cambridge University Press.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing EL envelope. Proceedings
19th International Joint Conference AI (IJCAI-05), pp. 364369. MorganKaufmann Publishers.
Bishop, B., Kiryakov, A., Ognyano, D., Peikov, I., Tashev, Z., & Velkov, R. (2011).
OWLIM: family scalable semantic repositories. Semantic Web, 2 (1), 3342.
Broekstra, J., Kampman, A., & van Harmelen, F. (2002). Sesame: generic architecture
storing querying RDF RDF Schema. Proceedings 1st International
Semantic Web Conference (ISWC 2002), pp. 5468.
Cal, A., Gottlob, G., Lukasiewicz, T., Marnette, B., & Pieris, A. (2010). Datalog+/-:
family logical knowledge representation query languages new applications.
Proc. 25th Annual IEEE Symposium Logic Computer Science (LICS),
pp. 228242.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable
reasoning ecient query answering description logics: DL-Lite family.
Journal Automated Reasoning, 39 (3), 385429.
Ceri, S., Gottlob, G., & Tanca, L. (1989). always wanted know datalog
(and never dared ask). IEEE Trans. Knowledge Data Engineering, 1 (1), 146166.
Cuenca Grau, B., Horrocks, I., Kazakov, Y., & Sattler, U. (2008a). Modular Reuse
Ontologies: Theory Practice. Journal Artificial Intelligence Research, 31, 273
318.
Cuenca Grau, B., Horrocks, I., Motik, B., Parsia, B., Patel-Schneider, P., & Sattler, U.
(2008b). OWL 2: next step OWL. Journal Web Semantics (JWS), 6 (4),
309322.
Derriere, S., Richard, A., & Preite-Martinez, A. (2006). Ontology Astronomical
Object Types Virtual Observatory. Proc. 26th meeting IAU:
Virtual Observatory Action: New Science, New Technology, Next Generation
Facilities, pp. 1718, Prague, Czech Republic.
474

fiCompleteness Guarantees Incomplete Ontology Reasoners

Erling, O., & Mikhailov, I. (2009). RDF support virtuoso DBMS. Pellegrini, T.,
Auer, S., Tochtermann, K., & Schaert, S. (Eds.), Networked Knowledge - Networked
Media, pp. 724. Springer Berlin / Heidelberg.
Fitting, M. (1996). First-Order Logic Automated Theorem Proving, 2nd Edition. Texts
Computer Science. Springer.
Glimm, B., Horrocks, I., Lutz, C., & Sattler, U. (2007). Conjunctive query answering
description logic SHIQ. Proceedings International Joint Conference
AI (IJCAI), pp. 399404.
Golbreich, C., Zhang, S., & Bodenreider, O. (2006). Foundational Model Anatomy
OWL: Experience Perspectives. Journal Web Semantics, 4 (3), 181195.
Goodwin, J. (2005). Experiences using OWL Ordnance Survey. Proc.
OWL: Experiences Directions Workshop (OWLED 2005), Galway, Ireland.
Guo, Y., Pan, Z., & Heflin, J. (2005). LUBM: Benchmark OWL Knowledge Base
Systems. Journal Web Semantics, 3 (2), 158182.
Haarslev, V., & Moller, R. (2001). RACER System Description. Gore, R., Leitsch, A., &
Nipkow, T. (Eds.), Proc. 1st Int. Joint Conf. Automated Reasoning (IJCAR
2001), Vol. 2083 LNAI, pp. 701706, Siena, Italy. Springer.
Hayes, P. (2004). RDF Semantics. World Wide Web Consortium (W3C) Recommendation.
Horrocks, I., Patel-Schneider, P. F., & van Harmelen, F. (2003). SHIQ RDF
OWL: making web ontology language. Journal Web Semantics, 1 (1), 726.
Kiryakov, A., Ognyanov, D., & Manov, D. (2005). Owlim-a pragmatic semantic repository
owl.. Dean, M., Guo, Y., Jun, W., Kaschek, R., Krishnaswamy, S., Pan, Z., &
Sheng, Q. Z. (Eds.), WISE Workshops, pp. 182192.
Lacy, L., Aviles, G., Fraser, K., Gerber, W., Mulvehill, A., & Gaskill, R. (2005). Experiences
Using OWL Military Applications. Proc. OWL: Experiences Directions
Workshop (OWLED 2005), Galway, Ireland.
Lutz, C., Toman, D., & Wolter, F. (2009). Conjunctive query answering description
logic EL using relational database system. Proceedings 21st International
Joint Conference AI (IJCAI), pp. 20702075.
Ma, L., Yang, Y., Qiu, Z., Xie, G. T., Pan, Y., & Liu, S. (2006). Towards complete OWL
ontology benchmark. Proceedings 3rd European Semantic Web Conference
(ESWC 2006), pp. 125139.
McBride, Brian (2001). Jena: Implementing RDF Model Syntax Specification.
International Workshop Semantic Web 2001.
Meditskos, G., & Bassiliades, N. (2008). Combining DL reasoner rule engine
improving entailment-based OWL reasoning. Proceedings 7th International
Semantic Web Conference (ISWC 2008), pp. 277292.
Motik, B., Cuenca Grau, B., Horrocks, I., Wu, Z., Fokoue, A., & Lutz, C. (2009a). OWL 2
Web Ontology Language Profiles. W3C Recommendation.
475

fiCuenca Grau, Motik, Stoilos & Horrocks

Motik, B., Shearer, R., & Horrocks, I. (2009b). Hypertableau Reasoning Description
Logics. J. Artificial Intelligence Research (JAIR), 173 (14), 12751309.
Ortiz, M., Calvanese, D., & Eiter, T. (2008). Data complexity query answering expressive description logics via tableaux. Journal Automated Reasoning, 41 (1), 6198.
Perez-Urbina, H., Horrocks, I., & Motik, B. (2009). Ecient Query Answering OWL 2.
Proceedings 8th International Semantic Web Conference (ISWC 2009), Vol.
5823 LNCS, pp. 489504. Springer.
Perez-Urbina, H., Motik, B., & Horrocks, I. (2010). Tractable query answering rewriting
description logic constraints. Journal Applied Logic, 8 (2), 186209.
Prudhommeaux, E., & Seaborne, A. (2008). SPARQL query language RDF. World
Wide Web Consortium (W3C). W3C Recommendation.
Rector, A. L., & Rogers, J. (2006). Ontological practical issues using description
logic represent medical concept systems: Experience galen. Barahona,
P., Bry, F., Franconi, E., Henze, N., & Sattler, U. (Eds.), Reasoning Web, Second
International Summer School 2006, pp. 197231.
Sidhu, A., Dillon, T., Chang, E., & Sidhu, B. S. (2005). Protein Ontology Development
using OWL. Proc. OWL: Experiences Directions Workshop (OWLED
2005), Galway, Ireland.
Sirin, E., Parsia, B., Cuenca Grau, B., Kalyanpur, A., & Katz, Y. (2007). Pellet: practical
OWL-DL reasoner. Journal Web Semantics, 5 (2), 5153.
Soergel, D., Lauser, B., Liang, A., Fisseha, F., Keizer, J., & Katz, S. (2004). Reengineering
Thesauri New Applications: AGROVOC Example. J. Digital Information,
4 (4).
Wu, Z., Eadon, G., Das, S., Chong, E. I., Kolovski, V., Annamalai, M., & Srinivasan, J.
(2008). Implementing inference engine rdfs/owl constructs user-defined
rules oracle. Proceedings 2008 IEEE 24th International Conference
Data Engineering (ICDE 08), pp. 12391248. IEEE Computer Society.

476


