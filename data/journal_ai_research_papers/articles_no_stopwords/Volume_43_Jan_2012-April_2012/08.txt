Journal Artificial Intelligence Research 43 (2012) 329-351

Submitted 11/11; published 03/12

Local Consistency SAT-Solvers
Peter Jeavons
Justyna Petke

Peter.Jeavons@cs.ox.ac.uk
Justyna.Petke@cs.ox.ac.uk

Department Computer Science, University Oxford
Wolfson Building, Parks Road, Oxford, OX1 3QD, UK

Abstract
Local consistency techniques k-consistency key component specialised
solvers constraint satisfaction problems. paper show power
using k-consistency techniques constraint satisfaction problem precisely captured
using particular inference rule, call negative-hyper-resolution, standard
direct encoding problem Boolean clauses. show current clauselearning SAT-solvers discover expected polynomial time inconsistency
deduced given set clauses using negative-hyper-resolvents fixed size.
combine two results show that, without explicitly designed so, current
clause-learning SAT-solvers efficiently simulate k-consistency techniques, fixed values
k. give experimental results show feature allows clause-learning
SAT-solvers efficiently solve certain families constraint problems challenging
conventional constraint-programming solvers.

1. Introduction
One oldest central ideas constraint programming, going right back
Montanaris original paper 1974, idea using local consistency techniques prune
search space (Bessiere, 2006). idea arc-consistency introduced Mackworth
(1977), generalised k-consistency Freuder (1978). Modern constraint solvers
generally employ specialised propagators prune domains variables achieve
form generalised arc-consistency, typically attempt enforce higher levels
consistency, path-consistency.
contrast, software tools developed solve propositional satisfiability problems,
known SAT-solvers, generally use logical inference techniques, unit propagation
clause-learning, prune search space.
One surprising empirical findings last years remarkably good performance general SAT-solvers solving constraint satisfaction problems.
apply tools constraint satisfaction problem one first translate instance set clauses using form Boolean encoding (Tamura, Taga, Kitagawa,
& Banbara, 2009; Walsh, 2000). encoding techniques tend obscure structure original problem, may introduce large number Boolean variables
clauses encode quite easily-stated constraints. Nevertheless, quite cases,
approaches out-performed traditional constraint-solving tools (van Dongen,
Lecoutre, & Roussel, 2008, 2009; Petke & Jeavons, 2009).
c
2012
AI Access Foundation. rights reserved.

fiJeavons & Petke

paper draw number recent analytical approaches try account
good performance general SAT-solvers many forms constraint problems.
Building results Atserias, Bulatov, Dalmau (2007), Atserias Dalmau
(2008), Hwang Mitchell (2005), show power using k-consistency
techniques constraint problem precisely captured using single inference rule
standard Boolean encoding problem. refer inference rule negativehyper-resolution, show conclusions deduced enforcing k-consistency
deduced sequence negative-hyper-resolution inferences involving Boolean clauses
original instance negative-hyper-resolvents k literals. Furthermore,
using approach Atserias, Fichte, Thurley (2011), Pipatsrisawat
Darwiche (2009), show current clause-learning SAT-solvers mimic effect
deductions polynomial expected time, even random branching strategy. Hence
show that, although explicitly designed so, running clause-learning
SAT-solver straightforward encoding constraint problem efficiently simulates
effects enforcing k-consistency values k.

2. Preliminaries
section give background definitions used throughout
rest paper.
2.1 Constraint Satisfaction Problems k-Consistency
Definition 1 instance Constraint Satisfaction Problem (CSP) specified
triple (V, D, C),
V finite set variables;
= {Dv | v V } set Dv set possible values variable v,
called domain v;
C finite set constraints. constraint C pair (Ri , Si )
Si ordered list mi variables, called constraint scope;
Ri relation arity mi , called constraint relation.
Given CSP instance (V, D, C), partial assignment mapping f

subset W V Dv f (v) Dv v W . partial assignment satisfies
constraints instance if, (R, (v1 , v2 , . . . , vm )) C vj W
j = 1, 2, . . . , m, (f (v1 ), f (v2 ) . . . , f (vm )) R. partial assignment satisfies
constraints instance called partial solution1 instance. set
variables partial assignment f defined called domain f , denoted
Dom(f ). partial solution g extends partial solution f Dom(g) Dom(f )
g(v) = f (v) v Dom(f ). partial solution domain V called solution.
One way derive new information CSP instance, may help determine
whether solution, use form constraint propagation enforce
1. Note partial solutions extend solutions.

330

fiLocal Consistency SAT-Solvers

level local consistency (Bessiere, 2006). example, possible use notion
k-consistency, defined below. note several different equivalent ways
define enforce k-consistency described literature (Bessiere, 2006; Cooper, 1989;
Freuder, 1978). presentation follows Atserias et al. (2007), inspired
notion existential k-pebble games introduced Kolaitis Vardi (2000).
Definition 2 (Atserias et al., 2007) CSP instance P , k-consistency closure
P set H partial assignments obtained following algorithm:
1. Let H collection partial solutions f P |Dom(f )| k + 1;
2. every f H |Dom(f )| k every variable v P , g H
g extends f v Dom(g), remove f extensions H;
3. Repeat step 2 H unchanged.
Note computing k-consistency closure according definition corresponds
precisely enforcing strong (k+1)-consistency according definitions given Bessiere
(2006), Cooper (1989), Freuder (1978).
Throughout paper, shall assume domain possible values
variable CSP instance finite. straightforward show fixed k,
fixed maximum domain size, k-consistency closure instance P
computed polynomial time (Atserias et al., 2007; Cooper, 1989).
Note solution P must extend element k-consistency closure
P . Hence, k-consistency closure P empty, k, P solutions.
converse true general, holds certain special cases, class
instances whose structure tree-width bounded k (Atserias et al., 2007), class
instances whose constraint relations 0/1/all relations, defined Cooper, Cohen,
Jeavons (1994), connected row-convex relations, defined Deville, Barette,
Hentenryck (1997). special kinds instances possible determine
polynomial time whether solution exists simply computing k-consistency
closure, appropriate choice k. Moreover, solution exists,
constructed polynomial time selecting variable turn, assigning possible
value, re-computing k-consistency closure, retaining assignment gives
non-empty result.
following result gives useful condition determining whether k-consistency
closure CSP instance empty.
Lemma 1 (Kolaitis & Vardi, 2000) k-consistency closure CSP instance P
non-empty exists non-empty family H partial solutions P
that:
1. f H, |Dom(f )| k + 1;
2. f H f extends g, g H;
3. f H, |Dom(f )| k, v
/ Dom(f ) variable P ,
g H g extends f v Dom(g).
set partial solutions H satisfying conditions described Lemma 1 sometimes
called strategy instance P (Barto & Kozik, 2009; Kolaitis & Vardi, 2000).
331

fiJeavons & Petke

2.2 Encoding CSP Instance Propositional Formula
One possible approach solving CSP instance encode propositional formula
suitable set Boolean variables, use program decide satisfiability
formula. Many programs, known SAT-solvers, available
often efficiently handle problems thousands, sometimes even millions, Boolean
variables (Zhang & Malik, 2002).
Several different ways encoding CSP instance propositional formula
proposed (Prestwich, 2009; Tamura et al., 2009; Walsh, 2000).
consider one common family encodings, known sparse encodings (this term
introduced Hoos, 1999). CSP instance P = (V, D, C), sparse encoding
introduces set Boolean variables form xvi v V Dv .
Boolean variable xvi assigned True original variable v assigned
value i. say partial assignment f falsifies clause C C consists entirely
literals form xvf (v) , variables v Dom(f ). Otherwise, say partial
assignment f satisfies clause C.
Example 1 Let P CSP instance V = {u, v, w}, Du = Dv = {0, 1}, Dw =
{0, 1, 2} C contains single ternary constraint scope (u, v, w) specifying
u v < w. sparse encoding P introduce seven Boolean variables:
xu0 , xu1 , xv0 , xv1 , xw0 , xw1 , xw2 .
Sparse encodings usually contain certain clauses known at-least-one at-most-one
clauses, ensure variable v assigned value, say i, value,
W
j 6= i, assigned v. at-least-one clauses form iDv xvi variable
v. at-most-one clauses represented set binary clauses xvi xvj
i, j Dv 6= j.
Example 2 case CSP instance Example 1 at-least-one clauses are:
xu0 xu1 , xv0 xv1 , xw0 xw1 xw2
at-most-one clauses are:
xu0 xu1 , xv0 xv1 , xw0 xw1 , xw0 xw2 , xw1 xw2
various different sparse encodings differ way encode constraints
CSP instance. Two methods commonly used. first one encodes disallowed
variable assignments - so-called conflicts no-goods. direct encoding (Prestwich,
W
2009), instance, generates clause vS xvf (v) partial assignment f
satisfy constraint (R, S) C. Using direct encoding, ternary constraint
Example 1 would encoded following clauses:
xu0 xv0 xw0 ,
xu0 xv1 xw0 ,
xu0 xv1 xw1 ,
xu1 xv0 xw0 ,
332

fiLocal Consistency SAT-Solvers

xu1 xv0 xw1 ,
xu1 xv0 xw2 ,
xu1 xv1 xw0 ,
xu1 xv1 xw1 .
Another way translating constraints clauses encode allowed variable
assignments - so-called supports. used basis encoding
binary CSP instances, known support encoding (Gent, 2002), defined follows.
pair variables v, w scope constraint, value Dv ,
W
support encoding contain clause xvi jA xwj , Dw set
values variable w compatible assignment v = i, according
constraint.
Note support encoding defined binary CSP instances only. However,
non-binary constraints decomposed binary ones without introducing new
variables. instance, ternary constraint Example 1 decomposed two
binary constraints specifying u v v < w. Using support encoding,
binary constraints would represented following clauses:
xu0 xv0 xv1 , xu1 xv1 , xv0 xu0 , xv1 xu0 xu1 ,
xv0 xw1 xw2 , xv1 xw2 , xw0 , xw1 xv0 , xw2 xv0 xv1 .
2.3 Inference Rules
Given set clauses often deduce clauses applying certain inference
rules. example, two clauses form C1 x C2 x, (possibly
empty) clauses C1 , C2 , variable x, deduce clause C1 C2 .
form inference known propositional resolution; resultant clause called
resolvent (Robinson, 1965).
next section, shall establish close connection k-consistency
algorithm form inference called negative-hyper-resolution (Buning & Lettmann,
1999), define follows:
Definition 3 collection clauses form Ci xi , = 1, 2, . . . , r,
clause C0 x1 x2 xr , xi Boolean variable, C0
Ci (possibly empty) disjunction negative literals, deduce clause
C0 C1 Cr .
call form inference negative-hyper-resolution resultant clause
C0 C1 Cr negative-hyper-resolvent.
case C0 empty, negative-hyper-resolution rule equivalent
nogood resolution rule described Hwang Mitchell (2005) well H5-k rule
introduced de Kleer (1989) nogood recording scheme described Schiex
Verfaillie (1993).
Note inference obtained negative-hyper-resolution obtained
sequence standard resolution steps. However, reason introducing negative-hyperresolution allows us deduce clauses need single step without needing
introduce intermediate clauses (which may contain r 1 literals
333

fiJeavons & Petke

negative-hyper-resolvent). restricting size clauses use way
able obtain better performance bounds SAT-solvers results below.
Example 3 Assume collection clauses form Ci xi , = 1, 2, . . . , r,
clause C0 x1 x2 xr , specified Definition 3, Ci = C0 .
negative-hyper-resolvent set clauses C0 .
clause C0 obtained sequence standard resolution steps, follows.
First resolve C0 x1 x2 xr C0 xr obtain C0 x1 x2 xr1 .
resolve next clause, C0 xr1 , clauses, finally
obtain C0 . However, case intermediate clause C0 x1 x2 xr1 contains
r 1 literals negative-hyper-resolvent.
Example 4 Note no-good clauses direct encoding binary CSP instance
obtained single negative-hyper-resolution step appropriate support
clause support encoding together appropriate collection at-most-one clauses.
Let Dw set values variable w compatible assignment
W
v = i, support encoding contain clause C = xvi jA xwj .
values k Dw incompatible assignment v = i, form
negative-hyper-resolvent C at-most-one clauses xwk xwj j A,
obtain corresponding no-good clause, xvi xwk .
negative-hyper-resolution derivation clause C set initial clauses
sequence clauses C1 , C2 , . . . , Cm , Cm = C Ci follows negativehyper-resolution rule collection clauses, either contained
else occurs earlier sequence. width derivation defined
maximum size clauses Ci . Cm empty clause, say
derivation negative-hyper-resolution refutation .

3. k-Consistency Negative-Hyper-Resolution
pointed many authors enforcing local consistency form
inference relations analogous use resolution rule clauses (Bacchus, 2007;
Bessiere, 2006; Hwang & Mitchell, 2005; Rish & Dechter, 2000). precise strength
standard resolution inference rule direct encoding CSP instance considered
work Walsh (2000), shown unit resolution (where one
clauses resolved consists single literal), corresponds enforcing weak form
local consistency known forward checking. Hwang Mitchell (2005) pointed
standard resolution rule restriction clause length able simulate
inferences made k-consistency algorithm. Atserias Dalmau (2008) showed
standard resolution rule restricted clauses k literals, known kresolution rule, characterised terms Boolean existential (k +1)-pebble game.
follows CSP instances Boolean domains form inference corresponds
enforcing k-consistency. alternative proof k-resolution achieves k-consistency
instances Boolean domains given book Hooker (2006, Thm. 3.22).
extend results little, show CSP instances arbitrary
finite domains, applying negative-hyper-resolution rule direct encoding obtain
334

fiLocal Consistency SAT-Solvers

clauses k literals corresponds precisely enforcing k-consistency. similar
relationship stated work de Kleer (1989), complete proof given.
Note bound, k, impose size negative-hyper-resolvents,
independent domain size. words, using inference rule need
consider inferred clauses size k, even though make use clauses
encoding whose size equal domain size, may arbitrarily large.
Theorem 1 k-consistency closure CSP instance P empty direct
encoding set clauses negative-hyper-resolution refutation width k.
proof broken two lemmas inspired Lemmas 2 3 work
Atserias Dalmau (2008).
Lemma 2 Let P CSP instance, let direct encoding set clauses.
negative-hyper-resolution refutation width k less, k-consistency
closure P non-empty.
Proof. Let V set variables P , v V domain Dv , let
X = {xvi | v V, Dv } corresponding set Boolean variables . Let
set clauses negative-hyper-resolution derivation width k.
definition negative-hyper-resolution, every non-empty clause consists entirely
negative literals.
let H set partial assignments P domain size k + 1
falsify clause direct encoding.
Consider element f H. definition H, f falsify clause
, definition direct encoding, every element H partial solution
P . Furthermore, f extends g, g element H, g makes fewer
assignments f hence cannot falsify additional clauses f .
negative-hyper-resolution refutation width k,
contain empty clause, H contains (at least) partial solution empty domain,
hence H empty.
let f element H |Dom(f )| k let v variable P
Dom(f ). partial assignment g extends f Dom(g) =
Dom(f ) {v} either g H else exists clause
falsified g. Since g partial assignment, clause C falsified g,
must consist entirely negative literals. Hence literals C must either form
xwf (w) w Dom(f ), else xvg(v) . Moreover, clause must contain
literal xvg(v) , else would already falsified f .
Assume, contradiction, H contain assignment g extends f
Dom(g) = Dom(f ) {v}. case, that, Dv , contains
clause Ci consisting negative literals form xwf (w) w Dom(f ), together
literal xvi . consider clause, C, negative-hyper-resolvent
W
clauses Ci at-least-one clause iDv xvi . clause C consists entirely
negative literals form xwf (w) w Dom(f ), width
|Dom(f )| k, hence element . However C falsified f , contradicts
choice f . Hence shown f H |Dom(f )| k,
335

fiJeavons & Petke

variables v v 6 Dom(f ), g H g extends f
v Dom(g).
shown H satisfies conditions required Lemma 1, conclude
k-consistency closure P non-empty.
2

Lemma 3 Let P CSP instance, let direct encoding set clauses.
k-consistency closure P non-empty, negative-hyper-resolution
refutation width k less.
Proof. Let V set variables P , v V domain Dv , let
X = {xvi | v V, Dv } corresponding set Boolean variables .
Lemma 1, k-consistency closure P non-empty, exists nonempty set H partial solutions P satisfies three properties described
Lemma 1.
consider negative-hyper-resolution derivation width k.
show induction length derivation elements H falsify
clause derivation. First note elements H partial solutions,
satisfy constraints P , hence falsify clause . establishes
base case. Assume, induction, clauses derivation earlier
clause C falsified element H.
Note that, apart at-least-one clauses, clauses consist entirely
negative literals. Hence may assume, without loss generality, C negativehyper-resolvent set clauses = {Ci xvi | Dv } at-least-one clause
W
iDv xvi , fixed variable v.
f H falsifies C, literals C must form xwf (w) ,
w Dom(f ). Since width derivation k, C contains k literals,
hence may assume |Dom(f )| k. then, choice H, must
exist extension g f H v Dom(g). g falsify
clause , contradicts inductive hypothesis. Hence f H falsifies C, and,
particular, C cannot empty.
follows negative-hyper-resolution derivation width k contain
empty clause.
2
Note proof Theorem 1 applies sparse encoding contains
at-least-one clauses variable, clauses purely negative.
call encoding negative sparse encoding. well direct encoding,
negative sparse encodings exist. example, may use negative clauses involve
subset variables scope constraints (to forbid tuples possible
extensions complete scope disallowed constraint). Another example
negative sparse encoding well-known variant direct encoding
at-most-one clauses omitted.
Corollary 1 k-consistency closure CSP instance P empty
negative sparse encoding P negative-hyper-resolution refutation width k.
336

fiLocal Consistency SAT-Solvers

4. Negative-Hyper-Resolution SAT-Solvers
section adapt machinery Atserias et al. (2011), Pipatsrisawat
Darwiche (2009) show fixed k, existence negative-hyper-resolution
refutation width k likely discovered SAT-solver polynomial-time using
standard clause learning restart techniques, even totally random branching
strategy.
Note previous results power clause-learning SAT-solvers generally
assumed optimal branching strategy (Beame, Kautz, & Sabharwal, 2004; Pipatsrisawat
& Darwiche, 2009) - shown solvers potentially capable doing, rather
likely achieve practice. important exception paper
Atserias et al. (2011), gives analysis likely behaviour, relies
existence standard resolution proof bounded width. show results
Atserias et al. extended hyper-resolution proofs, shorter
narrower associated standard resolution proofs.
make use following terminology Atserias et al. (2011). clause
C, Boolean variable x, truth value {0, 1}, restriction C assignment
x = a, denoted C|x=a , defined constant 1, assignment satisfies clause,
else clause obtained deleting C literals involving variable x.
sequence assignments form (x1 = a1 , x2 = a2 , . . . , xr = ar ) write C|S
denote result computing restriction C assignment turn. C|S
empty, say assignments falsify clause C. set clauses ,
write |S denote set {C|S | C } \ {1}.
current SAT-solvers operate following way (Atserias et al., 2011; Pipatsrisawat & Darwiche, 2009). maintain database clauses current state
S, partial assignment truth values Boolean variables clauses
. high-level description algorithms used update clause database
state, derived description given Atserias et al., shown Algorithm 1 (a similar framework, using slightly different terminology, given Pipatsrisawat & Darwiche,
2009).
consider run algorithm shown Algorithm 1, started initial
database , empty state S0 , either halts discovers conflict (i.e., |S ).
run called complete round started , represent sequence
states S0 , . . . , Sm , algorithm maintains. Note state Si extends
state Si1 single assignment Boolean variable, may either decision
assignment implied assignment.
generally, round initial segment S0 , S1 , . . . , Sr complete round started
, state Sr either |Sr contains empty clause, |Sr
contain unit clause. clause C, say round S0 , S1 , . . . , Sr satisfies C
C|Sr = 1, say round falsifies C C|Sr empty.
S0 , S1 , . . . , Sr round started , |Sr contains empty clause,
algorithm either reports unsatisfiability learns new clause: round called
conclusive. round conclusive call inconclusive 2 . Note S0 , S1 , . . . , Sr
inconclusive round started , |Sr contain empty clause,
2. Note complete round assigns variables reports satisfiability called inconclusive.

337

fiJeavons & Petke

contain unit clauses. Hence, clause C , Sr falsifies
literals C except one, must satisfy remaining literal, hence satisfy C.
property clauses captured following definition.
Definition 4 (Atserias et al., 2011) Let set clauses, C non-empty clause,
l literal C. say absorbs C l every inconclusive round started
falsifies C \ {l} satisfies C.
absorbs C literal l C, simply say absorbs C.
Note closely related notion introduced Pipatsrisawat Darwiche (2009)
clauses absorbed set clauses ; referred 1-empowering
respect . (The exact relationship 1-empowering absorption discussed
Atserias et al., 2011.)
explore relationship absorption negative-hyper-resolution.
Example 5 Let direct encoding CSP instance P = (V, D, C), V =
{u, v, w}, Du = Dv = Dw = {1, 2} C contains two binary constraints: one forbids
assignment value 1 u v simultaneously, forbids simultaneous
assignment value 2 u 1 w. Let C contain ternary constraint
forbids assignment value 2 three variables simultaneously.
= { xu1 xu2 , xv1 xv2 , xw1 xw2 ,
xu1 xu2 , xv1 xv2 , xw1 xw2 ,
xu1 xv1 , xu2 xw1 , xu2 xv2 xw2 }.
clause xv1 xw1 contained , obtained negative-hyperresolution clauses xu1 xu2 , xu1 xv1 , xu2 xw1 .
clause absorbed , since every inconclusive round sets xv1 = true must
set xw1 = f alse unit propagation, every inconclusive round sets xw1 = true
must set xv1 = f alse unit propagation.
Example 5 indicates clauses obtained negative hyper-resolution
set clauses sometimes absorbed . next result clarifies situation
holds.
Lemma 4 negative-hyper-resolvent set disjoint clauses absorbed set
clauses.
Proof. Let C negative-hyper-resolvent set clauses = {Ci xi | =
1, 2, . . . , r} clause C 0 = C0 x1 x2 xr , Ci (possibly empty)
disjunction negative literals, 0 r. C = C0 C1 Cr Definition 3.
Definition 4, must show C 0 absorbs C literals. Assume
one literals C falsified. Since set clauses C 0 assumed
disjoint, remaining literal l must belong exactly one clauses set.
two cases consider.
1. l belongs clause C 0 , clauses one literals falsified,
remaining literal xi clauses set true, unit propagation.
Hence literals C 0 falsified, except l, l set true, unit propagation.
338

fiLocal Consistency SAT-Solvers

2. l belongs one clauses Ci xi , remaining clauses
one literals falsified, corresponding literals xj set true, unit
propagation. Hence literals C 0 falsified, except xi , xi set true,
unit propagation. literals Ci xi falsified, except l, l set
true unit propagation.
2
next example shows negative-hyper-resolvent set clauses
disjoint necessarily absorbed clauses.
Example 6 Recall set clauses given Example 5, direct encoding
CSP instance three variables {u, v, w}, domain {1, 2}.
clause xu2 xv2 contained , obtained negative-hyperresolution clauses xw1 xw2 , xu2 xv2 xw2 , xu2 xw1 .
clause absorbed , since inconclusive round sets xv2 = true
necessarily ensure xu2 = f alse unit propagation.
basic approach shall use establish main results show
clauses obtained bounded width negative-hyper-resolution given set
clauses, immediately absorbed (such one Example 6) likely
become absorbed quite quickly additional clauses added
process clause learning. Hence clause-learning SAT-solver likely fairly rapidly
absorb clauses derived original database clauses negativehyper-resolution. particular, empty clause derived negative-hyperresolution, solver fairly rapidly absorb literal complement,
hence report unsatisfiability (see proof Theorem 2 details).
following key properties absorption established Atserias et al. (2011).
Lemma 5 (Atserias et al., 2011) Let 0 sets clauses, let C C 0
non-empty clauses.
1. C belongs , absorbs C;
2. C C 0 absorbs C, absorbs C 0 ;
3. 0 absorbs C, 0 absorbs C.
allow analysis, need make assumptions learning scheme,
restart policy branching strategy used SAT-solver.
learning scheme rule creates adds new clause database
whenever conflict. clause called conflict clause, literals
falsified assignment current state. literal falsified i-th decision
assignment, later implied assignment (i + 1)-th decision assignment,
said falsified level i. conflict clause contains exactly one literal falsified
maximum possible level, called asserting clause (Pipatsrisawat & Darwiche,
2009; Zhang, Madigan, Moskewicz, & Malik, 2001).
Assumption 1 learning scheme chooses asserting clause.
339

fiJeavons & Petke

Algorithm 1 Framework typical clause-learning SAT-solver
Input: : set clauses;
: partial assignment truth values variables.
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.

|S 6=
|S
Conflict
contains decision assignments
print UNSATISFIABLE halt
else
apply learning scheme add new clause
restart policy says restart
set =
else
select recent conflict-causing unreversed decision assignment
reverse decision, remove later assignments
end
end
else {l} |S literal l
Unit Propagation
add implied assignment x = satisfies l
else
Decision
apply branching strategy choose decision assignment x =
add decision assignment
end
end
print SATISFIABLE output

learning schemes current use satisfy assumption (Pipatsrisawat & Darwiche, 2009; Zhang et al., 2001), including learning schemes called 1UIP Decision (Zhang et al., 2001).
make particular assumption restart policy. However, main result
phrased terms bound expected number restarts. algorithm restarts
r conflicts, bound expected number restarts simply multiplied
r get bound expected number conflicts. means results
strongest algorithm restarts immediately conflict. case,
r = 1 bound bound expected number conflicts. Existing SATsolvers typically employ aggressive restart policy, note remark
work Pipatsrisawat Darwiche (2009, p.666) clear trend
towards frequent restarts modern SAT solvers.
branching strategy determines decision assignment chosen inconclusive round complete. current SAT solvers strategy based
heuristic measure variable activity, related occurrence variable
conflict clauses (Moskewicz, Madigan, Zhao, Zhang, & Malik, 2001). However, simplify
probabilistic analysis, make following assumption.

340

fiLocal Consistency SAT-Solvers

Assumption 2 branching strategy chooses variable uniformly random amongst
unassigned variables, assigns value TRUE.
noted Atserias et al. (2011), analysis give applied
branching strategy randomly chooses making heuristic-based
decision randomly-based decision. precisely, allow, say, c > 1 rounds nonrandom decisions random ones, number required restarts conflicts
would appear multiplied factor c.
algorithm behaves according description Algorithm 1, satisfies
assumptions above, called standard randomised SAT-solver.
Theorem 2 set non-empty clauses n Boolean variables negativehyper-resolution refutation width k length m, expected number restarts
requiredby standard randomised SAT-solver discover unsatisfiable less
mnk 2 nk .
Proof. Let C1 , C2 , . . . , Cm negative-hyper-resolution refutation width k ,
Cm first occurrence empty clause. Since clause non-empty,
Cm must derived negative-hyper-resolution collection negative literals
x1 , x2 , . . . xd purely positive clause x1 x2 xd .
consider standard randomised SAT-solver started database .
unit clauses xi absorbed current database, then, Definition 4,
inconclusive round algorithm must assign variables xi false, hence falsify
clause x1 x2 xd . Since happens even decision assignments made,
SAT-solver report unsatisfiability.
remains bound expected number restarts required clause
Ci absorbed, 1 < m. Let Ci negative-hyper-resolvent clauses
0 x , together clause C = C x x x
Ci1 , Ci2 , . . . , Cir , form Cij
j
i0
0
1
2
r
, C0 (possibly empty) disjunction negative literals. Assume
clause Cij absorbed j = 0, 1, . . . , r.
absorbs Ci , learning restarts needed, assume
absorb Ci . Definition 4, means exists literal l
inconclusive round R started falsifies Ci \ {l} satisfy Ci . Note
R must leave literal l unassigned, one assignment would satisfy Ci
0 , hence force literals x used
would falsify C0 Cij
j
negative-hyper-resolution step satisfied, Cij absorbed , Ci0
would falsified, contradicting fact R inconclusive.
Hence, branching strategy chooses falsify literals Ci \ {l} whenever
choice, construct inconclusive round R0 l unassigned (since
decision assignments R0 assigned values R, implied assignments
R0 must assigned values3 R, shown R leaves l
unassigned). branching strategy chooses falsify remaining literal l Ci ,
algorithm would construct conclusive round R00 Ci0 falsified,
3. See Lemmas 5, 8 10 work Atserias et al. (2011) formal statement proof
assertion.

341

fiJeavons & Petke

decision assignments falsify literals Ci . Hence, Assumption 1, algorithm would
learn asserting clause C 0 add obtain new set 0 .
Since C 0 asserting clause, contains exactly one literal, l0 , falsified
highest level R00 . Hence, inconclusive round R started 0 falsifies Ci \ {l}
falsify one literal C 0 , hence force remaining literal l0 satisfied,
unit propagation. new implied assignment l0 propagates force l true,
R satisfies Ci , hence 0 absorbs Ci l. not, branching strategy
choose falsify remaining literal l Ci , cause new asserting
clause learned added . Since new asserting clause forces new literal
satisfied falsifying Ci \ {l} process repeated fewer n times
certain 0 absorbs Ci l.
consider sequence k random branching choices. first k 1
falsify literal Ci \ {l}, final choice falsifies l, shown
associated round reach conflict, add asserting clause . random
branching strategy, described Assumption 2, probability happens
least probability first k 1 random choices consist fixed set variables
(in order), final choice variable associated l. number
random choices fall fixed set follows hypergeometric distribution, overall
1
probability n1 (nk+1)
= 1/(k nk ).
(k1)
obtain upper bound expected number restarts, consider worst case
require n asserting clauses added absorb clause Ci k
literals l. Since require upper bound,
treat round independent
n
trial success probability p = 1/(k k ), consider worst case
achieve (m 1)nk successes ensure Ci 1 < absorbed. case
total number restarts follow negative binomial distribution, expected value
(m 1)nk/p. Hence cases expected number restarts less mnk 2 nk . 2
tighter bound number restarts obtained focus Decision
learning scheme (Atserias et al., 2011; Zhang et al., 2001), next result indicates.
Theorem 3 set non-empty clauses n Boolean variables negative-hyperresolution refutation width k length m, expected number restarts required
standard randomised SAT-solver
using Decision learning scheme discover

unsatisfiable less nk .
Proof. proof similar proof Theorem 2, except Decision learning scheme additional feature literals chosen conflict clause falsify
subset current decision assignments. Hence situation consider,
decision assignments falsify literals clause Ci , learning scheme learn
subset Ci , hence immediately absorb Ci , Lemma 5 (1,2). Hence maximum
number learnt clausesrequired
reduced (m 1)nk (m 1), probability

increased 1/(k nk ) 1/ nk , giving tighter bound.
2
Note similar argument shows standard deviation number restarts
less standard deviation negative binomial distribution parameters
342

fiLocal Consistency SAT-Solvers




1/ nk , less nk . Hence, Chebyshevs inequality (one-tailed version),
probability standard randomised SAT-solver using decision learning scheme

discover unsatisfiable (m + m) nk restarts greater 1/2.

5. k-Consistency SAT-Solvers
combining Theorem 1 Theorem 3 obtain following result linking k-consistency
SAT-solvers.
Theorem 4 k-consistency closure CSP instance P empty, expected
number restarts required standard randomised SAT-solver using Decision learning scheme discover direct encoding P unsatisfiable O(n2k d2k ), n
number variables P maximum domain size.
Proof. length negative-hyper-resolution refutation width k bounded
Pk
n
number possible no-goods length
k

P
,


i=1 . Hence,



Theorem 1 Theorem 3 obtain bound


n
i=1

Pk

nd
k ,

O(n2k d2k ). 2

Hence standard randomised SAT-solver suitable learning strategy decide
satisfiability CSP instance tree-width k O(n2k d2k ) expected restarts,
even set restart immediately conflict. particular, satisfiability
tree-structured binary CSP instance (i.e., tree-width 1) decided
solver O(n2 d2 ) expected conflicts, comparable growth rate
optimal arc-consistency algorithm binary constraints. Note result cannot
obtained directly work Atserias et al. (2011), direct encoding
instance tree-width k set clauses whose tree-width may high dk.
Moreover, standard randomised SAT-solver decide satisfiability CSP
instance, structure, within polynomial bounds, constraint relations
satisfy certain algebraic properties ensure bounded width (Barto & Kozik, 2009).
Examples constraint types include 0/1/all relations, defined Cooper et al.
(1994), connected row-convex relations, defined Deville et al. (1997),
decided 2-consistency.
shown Gent (2002) support encoding binary CSP instance
made arc-consistent (that is, 1-consistent) applying unit propagation alone. Hence,
standard SAT-solver mimic effect enforcing arc-consistency encoding
making decisions restarts. combining Theorem 4 observation
Example 4 direct encoding obtained support encoding negativehyper-resolution, obtain following corollary concerning support encoding
higher levels consistency.
Corollary 2 k 2, k-consistency closure binary CSP instance P
empty, expected number restarts required standard randomised SATsolver using Decision learning scheme discover support encoding P
unsatisfiable O(n2k d2k ), n number variables P maximum
domain size.
343

fiJeavons & Petke

CSP literature describes many variations notion consistency.
paper considered k-consistency only. note results generalised
types consistency singleton arc-consistency (Bessiere, 2006).
extension singleton arc-consistency follows recent discovery family
CSP instances solvable enforcing singleton arc-consistency, instances
bounded width (Chen, Dalmau, & Gruien, 2011). words, instances
solved enforcing k-consistency, fixed k. Hence, Theorem 4,
solved polynomial expected time standard randomised SAT-solver.

6. Experimental Results
polynomial upper bounds obtain paper asymptotic, apply
values n, k. However, conservative, likely met
easily practice.
investigate existing SAT-solver actually performs, measured runtime
MiniSAT solver (Een & Sorensson, 2003), version 2.2.0, family CSP instances
decided fixed level consistency. comparison, ran experiments two state-of-the-art constraint solvers: used Minion (Gent, Jefferson, &
Miguel, 2006), version 0.12, G12 finite domain solver (Nethercote et al., 2007),
version 1.4.
match simplified assumptions analysis closely, ran
set experiments core version MiniSAT order get solver uses
unit propagation conflict-directed learning restarts. modified solver
follow random branching strategy described above. solver delete learnt
clauses uses extreme restart policy makes restart whenever encounters
conflict. uses learning scheme MiniSAT. refer modified solver
simple-MiniSAT.
characteristic feature instances tested relatively low tree-width,
used Toulbar2 solver (Sanchez et al., 2008). solver implements BTD
(Backtracking Tree-Decomposition) technique shown efficient
practice, contrast earlier methods proposed attempt exploit
tree-decompositions input problem (Jegou & Terrioux, 2003). problem
finding tree-decomposition minimal width (i.e., tree-width) NP-hard, BTD
technique uses approximations (described Jegou & Terrioux, 2003). note
Toulbar2 designed solving optimization problems, namely weighted CSPs,
WCSPs. WCSP instance, certain partial assignments associated cost. However,
Toulbar2 solver used solve standard CSPs simply setting costs 0.
results, times given elapsed times Lenovo 3000 N200 laptop
Intel Core 2 Duo processor running 1.66GHz 2GB RAM. generated
instance run five times mean times mean number restarts shown4 .
Example 7 consider family instances specified two parameters, w d.
((d1)w+2)w variables arranged groups size w, domain {0, ..., d1}.
4. MiniSAT simple-MiniSAT run different seeds five runs instance.
Instances marked * run only. runtime simple-MiniSAT instances
exceeded 6 hours. Moreover, Toulbar2 run parameter B = 1 enables BTD.

344

fiLocal Consistency SAT-Solvers

impose constraint arity 2w pair successive groups, requiring
sum values assigned first two groups strictly smaller
sum values assigned second. ensures instances generated
unsatisfiable. instance w = 2 = 2 shown diagrammatically defined
using specification language MiniZinc (Nethercote et al., 2007) Figure 1 (a) (b)
respectively5 . similar format used Toulbar2 6 instance encoded
format shown Figure 1 (c) (note hard constraint cost 0).

(a) Graphical representation.

chain
x1 0 1
x2 0 1
x3 0 1
x4 0 1
x5 0 1
x6 0 1
x7 0 1
x8 0 1
hard( x1 + x2 < x3 + x4 )
hard( x3 + x4 < x5 + x6 )
hard( x5 + x6 < x7 + x8 )

array[1..4] var 0..1 : X1;
array[1..4] var 0..1 : X2;
constraint
forall(i 1..3)(
X1[i] + X2[i] < X1[i + 1] + X2[i + 1]);
solve satisfy;
(b) Specification MiniZinc.

(c) Specification cp format.

Figure 1: example CSP instance w = 2, = 2 tree-width = 3.

structure instances described Example 7 simple tree-decomposition
path nodes, node corresponding constraint scope. Hence tree-width
instances 2w 1 shown unsatisfiable enforcing (2w 1)consistency (Atserias et al., 2007). However, instances cannot solved efficiently
using standard propagation algorithms prune individual domain values.
structure direct encoding instances tree-decomposition
node corresponding constraint scope original CSP instance. However,
direct encoding introduces Boolean variables represent variable
5. order run instance CP solver one must usually use translator convert original
model. MiniZinc distribution provides mzn2fzn translator Minion one use Tailor
(available http://www.cs.st-andrews.ac.uk/andrea/tailor/).
6. cp2wcsp translator description cp wcsp formats available
http://carlit.toulouse.inra.fr/cgi-bin/awki.cgi/SoftCSP.

345

fiJeavons & Petke

original instance, tree-width encoded SAT instances larger approximately
factor d; fact 2wd 1 (see Figure 2).

(a) Tree-decomposition original instance.

(b) Tree-decomposition direct
encoding.

Figure 2: Tree-decompositions CSP instance Figure 1.
Table 1 shows runtimes simple-MiniSAT original MiniSAT solver
family instances, along times two state-of-the-art CP solvers
WCSP solver Toulbar2. far best solver set instances Toulbar2,
explicitly designed exploit low tree-width constructing tree-decomposition.
class instances considering, widths tree-decompositions found
Toulbar2 matched tree-widths instances tested (i.e., 2w 1).
However, note MiniSAT remarkably effective solving chains
inequalities, compared Minion G12, even though use MiniSAT requires
encoding instance large number clauses much larger tree-width
original. Although simplified version MiniSAT solver takes little longer
current highly optimised version, still performs well instances
comparison conventional CP solvers. Moreover, number restarts (and hence
number conflicts) appears grow polynomially size instance
(see Figure 3). cases actual number restarts much lower polynomial
upper bound expected number restarts given Theorem 4.
best theoretical upper bounds expected run-time obtained
Decision learning scheme (Theorem 4), standard version MiniSAT uses
1UIP learning scheme conflict clause minimization. allow direct comparison
theoretical upper bounds, implemented Decision scheme simpleMiniSAT. 1UIP learning scheme generally found efficient
practice (Zhang et al., 2001), switched conflict clause minimization simpleMiniSAT order compare two standard learning schemes ran set
experiments. counted number restarts two modified solvers instances
form described Example 7 - see Table 2.
346

fiLocal Consistency SAT-Solvers

group
size
(w)
2
2
2
2
2
2
2
2
2
3
3
3
3
3
4
4
4

domain
size
(d)
2
3
4
5
6
7
8
9
10
2
3
4
5
6
2
3
4

CSP
variables
(n)
8
12
16
20
24
28
32
36
40
15
24
33
42
51
24
40
56

Minion

G12

(sec)
0.055
0.053
0.057
0.084
1.048
47.295
> 20 min
> 20 min
> 20 min
0.055
0.412
> 20 min
> 20 min
> 20 min
0.060
> 20 min
> 20 min

(sec)
0.010
0.011
0.013
0.047
0.959
122.468
> 20 min
> 20 min
> 20 min
0.010
0.034
7.147
> 20 min
> 20 min
0.015
11.523
> 20 min

Toulbar2

MiniSAT

(sec)
0.021
0.023
0.040
0.091
0.199
0.549
1.214
2.523
4.930
0.024
0.103
0.860
5.646
28.663
0.046
1.246
20.700

(sec)
0.003
0.005
0.015
0.043
0.126
0.362
0.895
2.407
5.656
0.004
0.066
1.334
20.984
383.564
0.012
4.631
1,160.873

simpleMiniSAT
(sec)
0.002
0.007
0.034
0.188
0.789
2.884
9.878
34.352
111.912
0.008
0.503
20.054
817.779
> 20 min
0.118
260.656
> 20 min

simpleMiniSAT
restarts
19
157
820
3 039
7 797
17 599
36 108
65 318
114 827
167
5 039
41 478
210 298
731 860
1 617
108 113
1 322 784*

Table 1: Average performance solvers instances Example 7.
group
size
(w)

domain
size
(d)

CSP
variables
(n)

no. clauses
direct
encoding

2
2
2
2
2
2
2
2
2
3
3
3
3
3
4
4

2
3
4
5
6
7
8
9
10
2
3
4
5
6
2
3

8
12
16
20
24
28
32
36
40
15
24
33
42
51
24
40

49
298
1 162
3 415
8 315
17 724
34 228
61 257
103 205
198
3 141
23 611
113 406
408 720
863
34 666

simpleMiniSAT
1UIP
(sec)
0.002
0.008
0.048
0.272
1.399
5.780
24.417
95.278
309.980
0.009
0.643
53.067
2,266.627
> 6 hours
0.141
603.241

simpleMiniSAT
1UIP
restarts
21
203
1 026
4 068
12 029
27 356
56 193
109 862
199 399
192
5 952
63 952
375 849
1 584 012*
1 937
155 842

simpleMiniSAT
Decision
(sec)
0.002
0.010
0.057
0.323
1.526
6.035
20.436
69.144
207.342
0.012
0.750
71.778
2,036.456
> 6 hours
0.192
938.836

simpleMiniSAT
Decision
restarts
23
267
1 424
5 283
14 104
33 621
64 262
113 460
190 063
287
7 308
91 283
391,664
1 365 481*
2 592
253 153

Table 2: Average performance simple-MiniSAT 1UIP Decision learning schemes instances Example 7.

347

fiJeavons & Petke

Figure 3: Log-log plot number restarts/conflicts used simple-MiniSAT

instances Example 7. solid lines show growth function d2w2 nd/w
,
3
n number CSP variables. empirically derived polynomial
function appears fit experimental data well, much lower
upper bound expected number restarts calculated Theorem 4
O(d4w2 n4w2 ).

348

fiLocal Consistency SAT-Solvers

Although performance simple-MiniSAT Decision learning scheme
1UIP scheme significantly worse performance original simpleMiniSAT solver, twice many restarts required instance. Hence,
theoretical upper bounds still easily met standard learning schemes.

7. Conclusions
shown notion k-consistency precisely captured single
inference rule direct encoding CSP instance, restricted deriving clauses
k literals. used show clause-learning SAT-solver purely
random branching strategy simulate effect enforcing k-consistency expected
polynomial time, fixed k. sufficient ensure solvers able
solve certain problem families much efficiently conventional CP solvers relying
GAC-propagation.
principle clause-learning SAT-solvers much more. known that,
appropriate branching strategy restart policy, able p-simulate general
resolution (Beame et al., 2004; Pipatsrisawat & Darwiche, 2009), general resolution
proofs exponentially shorter negative-hyper-resolution proofs considered (Hwang & Mitchell, 2005). practice, seems current clause-learning
SAT-solvers highly-tuned learning schemes, branching strategies restart policies
often able exploit structure Boolean encoding CSP instance even
effectively local consistency techniques. Hence considerable work remains done
understanding relevant features instances able exploit, order
predict effectiveness solving different kinds CSP instances.

Acknowledgments
would thank Albert Atserias Marc Thurley comments conference
version paper, well anonymous referees. provision EPSRC
Doctoral Training Award Justyna Petke gratefully acknowledged.
preliminary version paper appeared Proceedings 16th International
Conference Principles Practice Constraint Programming - CP2010.

References
Atserias, A., Bulatov, A. A., & Dalmau, V. (2007). power k-consistency.
International Colloquium Automata, Languages Programming - ICALP07,
pp. 279290.
Atserias, A., & Dalmau, V. (2008). combinatorial characterization resolution width.
Journal Computer System Sciences, 74 (3), 323334.
Atserias, A., Fichte, J. K., & Thurley, M. (2011). Clause-learning algorithms many
restarts bounded-width resolution. Journal Artificial Intelligence Research
(JAIR), 40, 353373.
Bacchus, F. (2007). GAC via unit propagation. Principles Practice Constraint
Programming - CP07, pp. 133147.
349

fiJeavons & Petke

Barto, L., & Kozik, M. (2009). Constraint satisfaction problems bounded width.
Symposium Foundations Computer Science - FOCS09, pp. 595603.
Beame, P., Kautz, H. A., & Sabharwal, A. (2004). Towards understanding harnessing
potential clause learning. Journal Artificial Intelligence Research (JAIR),
22, 319351.
Bessiere, C. (2006). Constraint propagation. Rossi, F., van Beek, P., & Walsh, T. (Eds.),
Handbook Constraint Programming, chap. 3. Elsevier.
Buning, H., & Lettmann, T. (1999). Propositional logic: deduction algorithms. Cambridge tracts theoretical computer science. Cambridge University Press.
Chen, H., Dalmau, V., & Gruien, B. (2011). Arc consistency friends. Computing
Research Repository - CoRR, abs/1104.4993.
Cooper, M. C. (1989). optimal k-consistency algorithm. Artificial Intelligence, 41 (1),
8995.
Cooper, M. C., Cohen, D. A., & Jeavons, P. (1994). Characterising tractable constraints.
Artificial Intelligence, 65 (2), 347361.
de Kleer, J. (1989). comparison ATMS CSP techniques. International Joint
Conference Artificial Intelligence - IJCAI89, pp. 290296.
Deville, Y., Barette, O., & Hentenryck, P. V. (1997). Constraint satisfaction connected
row convex constraints. International Joint Conference Artificial Intelligence IJCAI97 (1), pp. 405411.
Een, N., & Sorensson, N. (2003). extensible SAT-solver. Theory Applications
Satisfiability Testing - SAT03, pp. 502518.
Freuder, E. C. (1978). Synthesizing constraint expressions. Communications ACM,
21 (11), 958966.
Gent, I. P. (2002). Arc consistency SAT. European Conference Artificial Intelligence
- ECAI02, pp. 121125.
Gent, I. P., Jefferson, C., & Miguel, I. (2006). Minion: fast scalable constraint solver.
European Conference Artificial Intelligence - ECAI06, pp. 98102.
Hooker, J. N. (2006). Integrated Methods Optimization (International Series Operations Research & Management Science). Springer-Verlag New York, Inc., Secaucus,
NJ, USA.
Hoos, H. H. (1999). SAT-encodings, search space structure, local search performance.
International Joint Conference Artificial Intelligence - IJCAI99, pp. 296303.
Hwang, J., & Mitchell, D. G. (2005). 2-way vs. d-way branching CSP. Principles
Practice Constraint Programming - CP05, pp. 343357.
Jegou, P., & Terrioux, C. (2003). Hybrid backtracking bounded tree-decomposition
constraint networks. Artificial Intelligence, 146 (1), 4375.
Kolaitis, P. G., & Vardi, M. Y. (2000). game-theoretic approach constraint satisfaction. Conference Artificial Intelligence - AAAI00 / Innovative Applications
Artificial Intelligence Conference - IAAI00, pp. 175181.
350

fiLocal Consistency SAT-Solvers

Mackworth, A. K. (1977). Consistency networks relations. Artificial Intelligence, 8 (1),
99118.
Montanari, U. (1974). Networks constraints: Fundamental properties applications
picture processing. Information Sciences, 7, 95132.
Moskewicz, M. W., Madigan, C. F., Zhao, Y., Zhang, L., & Malik, S. (2001). Chaff: Engineering efficient SAT solver. Design Automation Conference - DAC01, pp.
530535.
Nethercote, N., Stuckey, P. J., Becket, R., Brand, S., Duck, G. J., & Tack, G. (2007).
MiniZinc: Towards standard CP modelling language. Principles Practice
Constraint Programming - CP07, pp. 529543.
Petke, J., & Jeavons, P. (2009). Tractable benchmarks constraint programming. Technical Report RR-09-07, Department Computer Science, University Oxford.
Pipatsrisawat, K., & Darwiche, A. (2009). power clause-learning SAT solvers
restarts. Principles Practice Constraint Programming - CP09, pp. 654668.
Prestwich, S. D. (2009). CNF encodings. Biere, A., Heule, M., van Maaren, H., & Walsh,
T. (Eds.), Handbook Satisfiability, pp. 7597. IOS Press.
Rish, I., & Dechter, R. (2000). Resolution versus search: Two strategies SAT. Journal
Automated Reasoning, 24 (1/2), 225275.
Robinson, J. A. (1965). machine-oriented logic based resolution principle. Journal
ACM, 12 (1), 2341.
Sanchez, M., Bouveret, S., de Givry, S., Heras, F., Jegou, P., Larrosa, J., Ndiaye, S., Rollon,
E., Schiex, T., Terrioux, C., Verfaillie, G., & Zytnicki, M. (2008). Max-CSP competition 2008: Toulbar2 solver description. Proceedings Third International
CSP Solver Competition.
Schiex, T., & Verfaillie, G. (1993). Nogood recording static dynamic constraint
satisfaction problems. International Conference Tools Artificial Intelligence
- ICTAI93, pp. 4855.
Tamura, N., Taga, A., Kitagawa, S., & Banbara, M. (2009). Compiling finite linear CSP
SAT. Constraints, 14 (2), 254272.
van Dongen, M., Lecoutre, C., & Roussel, O. (2008). 3rd international CSP solver competition. Instances results available http://www.cril.univ-artois.fr/CPAI08/.
van Dongen, M., Lecoutre, C., & Roussel, O. (2009). 4th international CSP solver competition. Instances results available http://www.cril.univ-artois.fr/CPAI09/.
Walsh, T. (2000). SAT v CSP. Principles Practice Constraint Programming CP00, pp. 441456.
Zhang, L., Madigan, C. F., Moskewicz, M. W., & Malik, S. (2001). Efficient conflict driven
learning Boolean satisfiability solver. International Conference ComputerAided Design - ICCAD01, pp. 279285.
Zhang, L., & Malik, S. (2002). quest efficient Boolean satisfiability solvers.
Computer Aided Verification - CAV02, pp. 1736.

351


