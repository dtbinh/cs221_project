Journal Artificial Intelligence Research 43 (2012) 571-620

Submitted 09/11; published 04/12

Reformulating Situation Calculus Event
Calculus General Theory Stable Models
Answer Set Programming

Joohyung Lee
Ravi Palla

joolee@asu.edu
Ravi.Palla@asu.edu

School Computing, Informatics,
Decision Systems Engineering
Arizona State University
Tempe, AZ 85287, USA

Abstract
Circumscription logic programs stable model semantics two wellknown nonmonotonic formalisms. former served basis classical logic based
action formalisms, situation calculus, event calculus temporal action
logics; latter served basis family action languages, language
several descendants. Based discovery circumscription stable
model semantics coincide class canonical formulas, reformulate situation
calculus event calculus general theory stable models. present
translation turns reformulations answer set programs, efficient
answer set solvers applied compute situation calculus event calculus.

1. Introduction
Circumscription (McCarthy, 1980, 1986) logic programs stable model semantics (Gelfond & Lifschitz, 1988) two well-known nonmonotonic formalisms. one
oldest nonmonotonic formalisms, circumscription found many applications commonsense reasoning model-based diagnoses (e.g., McCarthy, 1986; Shanahan, 1995; Besnard
& Cordier, 1994). stable model semantics mathematical basis Answer Set Programming (ASP) (Marek & Truszczynski, 1999; Niemela, 1999; Lifschitz, 2008),
widely applied thanks availability several efficient implementations, known
answer set solvers.
two nonmonotonic formalisms applied overlapping classes
problems, minimal model reasoning ensured circumscription coincide stable
model reasoning. Moreover, formalisms different roots. circumscription
defined terms translation classical (second-order) logic, stable models proposed
Gelfond Lifschitz (1988) defined terms grounding fixpoints
style Reiters default logic (Reiter, 1980). differences part account fact
two formalisms formed rather disparate traditions knowledge representation
research. particular, area temporal reasoning, former served basis
classical logic based action calculi, situation calculus (McCarthy & Hayes, 1969;
Reiter, 2001), event calculus (Shanahan, 1995) temporal action logics (Doherty,
c
2012
AI Access Foundation. rights reserved.

fiLee & Palla

Gustafsson, Karlsson, & Kvarnstrom, 1998), whereas latter served basis
family action languages, language (Gelfond & Lifschitz, 1998) several
descendants translated logic programs stable model semantics.
However, recent generalization stable model semantics shed new light
relationship circumscription stable models. first-order stable model semantics defined Ferraris, Lee Lifschitz (2007, 2011) characterizes stable models
first-order sentence models (in sense first-order logic) sentence
satisfy stability condition, expressed second-order formula similar
one used define circumscription. Since logic programs viewed special
class first-order sentences stable model semantics, definition extends
stable model semantics Gelfond Lifschitz (1988) full first-order level without
limiting attention Herbrand models. Essentially characterization independently given Lin Zhou (2011), via logic knowledge justified assumption (Lin
& Shoham, 1992). definitions equivalent definition Quantified Equilibrium Logic given Pearce Valverde (2005), defined terms logic
Here-and-There (Heyting, 1930).
new definition stable model motivates us investigate relationship
stable model reasoning minimal model reasoning. particular, focus
relationship area temporal reasoning. show situation calculus
event calculus reformulated first-order stable model semantics,
ASP. theoretically interesting, practically useful allows us
leverage efficient answer set solvers computing circumscriptive action theories.
this, develop two technical results. First, show circumscription
first-order stable model semantics coincide class canonical formulas.
largest syntactic class identified far two semantics coincide, general
enough cover several circumscriptive action formalisms, situation calculus,
event calculus, temporal action logics. result allows us reformulate
action formalisms first-order stable model semantics. minimal model reasoning
sometimes leads unintuitive results, circumscriptive action formalisms carefully
designed avoid cases, result implies minimal model reasoning
action formalisms viewed stable model reasoning.
Second, identify class almost universal formulas, turned
syntax logic program preserving stable models. turns reformulations situation calculus event calculus first-order stable model
semantics fall class formulas. introduce system f2lp turns formulas
class logic programs, and, conjunction result canonical formulas, use
combination f2lp answer set solvers compute situation calculus
event calculus.
work makes explicit relationship classical logic logic program traditions temporal reasoning. Interestingly, development event calculus
spanned traditions. original version event calculus (Kowalski & Sergot, 1986) formulated logic programs, stable model semantics (that
time invention stable model semantics). extensive developments later carried classical logic foundation via circumscription (e.g.,
Shanahan, 1995, 1997, 1999; Miller & Shanahan, 1999; Mueller, 2004), relation
572

fiReformulating Situation Calculus Event Calculus

logic program formulation remained implicit. Based reduction circumscription completion, SAT-based event calculus systems implemented, one Shanahan
Witkowski (2004) another Mueller (2004). latter system called dec
reasoner,1 outperforms former thanks efficient general compilation
method propositional logic. system handles large fragment event
calculus, still cannot handle recursive disjunctive axioms since completion cannot
applied axioms. ASP-based approach hand handle
full version event calculus assumption domain given finite.
Thanks efficiency ASP solvers, experiments indicate ASP-based event
calculus reasoner significantly faster dec reasoner (Appendix B).
Similar logic programming tradition event calculus, situation calculus (McCarthy & Hayes, 1969; Reiter, 2001) implemented Prolog, based
fact Clarks completion semantics accounts definitional axioms. unlike
event calculus, best knowledge, efficient propositional solvers
applied directly compute models situation calculus theories. paper,
reformulate Lins causal action theories (1995) Reiters basic action theories (2001)
first-order stable model semantics ASP. basic action theories, provide
ASP-based encoding method obtains Reiters successor state axioms effect
axioms generic inertia axioms adopted ASP, idea close Reiters
frame default (1980).
paper organized follows. next section reviews definitions circumscription first-order stable model semantics, presents definition
canonical formula. Based this, Sections 3 4 reformulate event calculus
situation calculus first-order stable model semantics. Section 5 shows translation
turns almost universal formulas logic programs accepted ASP
solvers. Sections 6 7 use result turn reformulations event calculus
situation calculus given Sections 3 4 input language ASP solvers.
Complete proofs given Appendix C.

2. Circumscription First-Order Stable Model Semantics
assume following set primitive propositional connectives quantifiers:
(falsity), , , , , .
understand F abbreviation F ; symbol > stands , F G
stands (F G) (G F ).
2.1 Review: Circumscription
Let p list distinct predicate constants p1 , . . . , pn , let u list distinct
predicate variables u1 , . . . , un . u p denote conjunction formulas
x(ui (x) pi (x)) = 1, . . . n, x list distinct object variables whose
length arity pi . Expression u < p stands (u p) (p u).
1. http://decreasoner.sourceforge.net

573

fiLee & Palla

instance, p q unary predicate constants (u, v) < (p, q)


x(u(x) p(x)) x(v(x) q(x)) x(p(x) u(x)) x(q(x) v(x)) .
Circumscription defined terms CIRC operator minimized predicates.
first-order formula F , expression CIRC[F ; p] stands second-order formula
F u((u < p) F (u)),
F (u) formula obtained F substituting ui pi . F sentence
(i.e., formula free variables), intuitively, models CIRC[F ; p] models
F minimal p.
definition straightforwardly extended case F many-sorted firstorder formula (Lifschitz, 1994, Section 2.4), language event calculus
situation calculus based on.
2.2 Review: First-Order Stable Model Semantics
review follows definition Ferraris et al. (2011). There, stable models
defined terms SM operator, whose definition similar CIRC operator
previous section. first-order formula F finite list predicate constants
p = (p1 , . . . , pn ), formula SM[F ; p] defined
F u((u < p) F (u)),
u defined CIRC[F ; p], F (u) defined recursively follows:
pi (t) = ui (t) list terms;
F = F atomic formula F (including equality) contain
members p;
(F G) = F G ;
(F G) = F G ;
(F G) = (F G ) (F G);
(xF ) = xF ;
(xF ) = xF .
predicates p called intensional: predicates intend
characterize F terms non-intensional predicates.2 F sentence, models
second-order sentence SM[F ; p] called p-stable models F :
models F stable p. often simply write SM[F ] place SM[F ; p]
p list predicate constants occurring F . According Lee, Lifschitz,
2. Intensional predicates analogous output predicates Datalog, non-intensional predicates
analogous input predicates Datalog (Lifschitz, 2011).

574

fiReformulating Situation Calculus Event Calculus

Palla (2008), answer sets defined special class stable models follows. (F )
denote signature consisting object, function predicate constants occurring
F . F contains least one object constant, Herbrand interpretation (F )
satisfies SM[F ] called answer set F . answer sets logic program defined
answer sets FOL-representation (i.e., conjunction universal
closures implications corresponding rules). example, FOL-representation
program
p(a)
q(b)
r(x) p(x), q(x)

p(a) q(b) x(p(x) q(x) r(x))

(1)

SM[F ]
p(a) q(b) x(p(x) q(x) r(x))
uvw(((u, v, w) < (p, q, r)) u(a) v(b)
x((u(x) (v(x) q(x)) w(x)) (p(x) q(x) r(x)))),
equivalent first-order sentence
x(p(x) x = a) x(q(x) x = b) x(r(x) (p(x) q(x)))

(2)

(Ferraris et al., 2007, Example 3). stable models F first-order models (2).
answer set F Herbrand model {p(a), q(b), r(a)}.
According Ferraris et al. (2011), definition answer set, applied
syntax logic programs, equivalent traditional definition answer set
based grounding fixpoints (Gelfond & Lifschitz, 1988).
Note definition stable model general definition
answer set following ways: stable models restricted Herbrand models,
underlying signature arbitrary, intensional predicates fixed
list predicate constants occurring formula. last fact essential view
following proposition. pr (F ) denote list predicate constants occurring
F ; Choice(p) denote conjunction choice formulas x(p(x) p(x))
predicate constants p p, x list distinct object variables; False(p)
denote conjunction xp(x) predicate constants p p. sometimes identify
list corresponding set confusion.
Proposition 1 Formula
SM[F ; p] SM[F Choice(pr (F )\p) False(p\pr (F ))]

(3)

logically valid.
Notice (implicit) intensional predicates right-hand side (3)
(pr (F ) p). Choice formula makes predicates (pr (F ) \ p) exempt
stability checking. hand, False formula makes predicates
(p \ pr (F )) stabilized (i.e., empty extents), though occur F .
575

fiLee & Palla

Ferraris et al. (2011) incorporate strong negation stable model semantics
distinguishing intensional predicates two kinds, positive negative.
negative intensional predicate form p, p positive intensional predicate
symbol strong negation. Syntactically logical connective,
appear part predicate constant. interpretation underlying
signature coherent satisfies formula
x(p(x) p(x)),

(4)

x list distinct object variables, negative predicate p. usually
consider coherent interpretations only. Intuitively, p(t) represents p(t) false.
different p(t) represents known p(t) true. Similarly,
p(t) represents known p(t) false, p(t) represents
known p(t) known true. Note that, unlike first-order logic, p(t)
different p(t). instance, formula p(a) one answer set {p(a)} p(a)
answer sets.
extension circumscription many-sorted first-order sentences, definition
stable model straightforwardly extended many-sorted first-order sentences.
2.3 Equivalence Stable Model Semantics Circumscription
Canonical Formulas
Neither stable model semantics circumscription stronger other.
example,
CIRC[x(p(x) p(x)); p]
(5)
equivalent xp(x),
SM[x(p(x) p(x)); p]

(6)

equivalent >, (5) stronger (6). hand,
CIRC[x(p(x) q(x)); p, q]

(7)

equivalent x(p(x) q(x)),
SM[x(p(x) q(x)); p, q]

(8)

equivalent x(p(x) q(x)), (8) stronger (7).
section, show two semantics coincide class formulas called
canonical formulas, define below. first review notions positive, negative,
strictly positive occurrences.
Definition 1 say occurrence predicate constant, subexpression, formula F positive number implications containing occurrence
antecedent even, negative otherwise. (Recall treat G shorthand
G .) say occurrence strictly positive number implications F
containing occurrence antecedent 0.
576

fiReformulating Situation Calculus Event Calculus

example, (1), occurrences q positive, first one strictly
positive.
Definition 2 say formula F canonical relative list p predicate constants

occurrence predicate constant p antecedents one
implication F ,
every occurrence predicate constant p scope strictly positive
occurrence F strictly positive F .
Example 1 formula
x(p(x) q(x))

(9)

shown canonical relative {p, q} since satisfy first clause
definition (p occurs antecedents two implications p(x) shorthand
p(x) ). hand, formula canonical relative {q}. formula
x(p(x) p(x))

(10)

canonical relative {p} since satisfy second clause (the second occurrence p scope strictly positive occurrence , strictly positive
(10)); formula
p(a) (x p(x) x q(x))
(11)
canonical relative {p, q},
p(a, a) x(p(x, a) p(b, x))

(12)

canonical relative {p, q} since satisfy second clause (the second
occurrence p scope strictly positive occurrence , strictly
positive formula (12)).
following theorem states that, canonical formula, circumscription coincides
stable model semantics.
Theorem 1 canonical formula F relative p,
CIRC[F ; p] SM[F ; p]

(13)

logically valid.
instance, formula (11), canonical relative {p, q}, formulas CIRC[(11); p, q]
SM[(11); p, q] equivalent other. Also, sentence F clearly canonical
relative , CIRC[F ; ] equivalent SM[F ; ], turn equivalent F .
hand, equivalence may necessarily hold non-canonical formulas.
instance, observed that, formula (10) canonical relative {p}, formulas (5) (6) equivalent other. formula (9) canonical
577

fiLee & Palla

relative {p, q}, formulas (7) (8) equivalent other. observe
formula (12) canonical relative {p, q}, CIRC[(12); p, q] equivalent
SM[(12); p, q]: Herbrand interpretation {p(a, a), p(b, a)} satisfies SM[(12); p, q],
satisfy CIRC[(12); p, q].
Note non-canonical formulas often equivalently rewritten canonical formulas. Since equivalent transformation preserves models circumscription, Theorem 1 applied non-canonical formulas, first rewriting canonical
formulas. example, formula (9) equivalent
x(p(x) q(x)),

(14)

canonical relative {p, q}, CIRC[(9); p, q] equivalent SM[(14); p, q].
another example, formula (10) equivalent
x(p(x) p(x)),

(15)

canonical relative {p}, CIRC[(10); p] equivalent SM[(15); p].
clear treatment applied quantifier-free formula (including
propositional formula) quantifier-free formula equivalently rewritten
canonical formula first rewriting clausal normal form turning
clause form C D, C conjunction atoms disjunction
atoms.3
Sections 3 4 use Theorem 1 reformulate event calculus situation
calculus first-order stable model semantics.

3. Reformulating Event Calculus General Theory Stable
Models
section, review syntax circumscriptive event calculus described Chapter 2
book Mueller (2006). Based observation syntax conforms
condition canonicality, present reformulations event calculus general
theory stable models.
3.1 Review: Circumscriptive Event Calculus
assume many-sorted first-order language, contains event sort, fluent sort,
timepoint sort. fluent term term whose sort fluent; event term
timepoint term defined similarly.
Definition 3 condition defined recursively follows:
1 2 terms, comparisons 1 < 2 , 1 2 , 1 2 , 1 > 2 , 1 = 2 ,
1 6= 2 conditions;
3. appears unlikely knowledge encoded non-canonical formula (12)
cannot easily turned equivalent canonical formula. c.f. Guide Axiomatizing Domains
First-Order Logic (http://cs.nyu.edu/faculty/davise/guide.html). surprise
circumscriptive action theories mentioned paper satisfy canonicality assumption.

578

fiReformulating Situation Calculus Event Calculus

f fluent term timepoint term, HoldsAt(f, t) HoldsAt(f, t)
conditions;
1 2 conditions, 1 2 1 2 conditions;
v variable condition, v condition.
use e ei denote event terms, f denote fluent terms, ti
denote timepoint terms, denote conditions.
event calculus, circumscribe Initiates, Terminates, Releases minimize
unexpected effects events, circumscribe Happens minimize unexpected events,
circumscribe Ab (abnormality predicates) minimize abnormalities. Formally, event
calculus description circumscriptive theory defined
CIRC[ ; Initiates, Terminates, Releases] CIRC[ ; Happens]
CIRC[ ; Ab 1 , . . . , Ab n ] ,

(16)


conjunction universal closures axioms form
Initiates(e, f, t)
Terminates(e, f, t)
Releases(e, f, t)
1 (e, f1 , t) 2 (e, f2 , t)
(effect constraint)
[]Happens(e1 , t) []Happens(en , t) Initiates(e, f, t)
[]Happens(e1 , t) []Happens(en , t) Terminates(e, f, t),
1 2 either Initiates Terminates ([] means
optional);
conjunction universal closures temporal ordering formulas (comparisons
timepoint terms) axioms form
Happens(e, t)
(f, t) 1 (f1 , t) n (fn , t) Happens(e, t)
(causal constraints)
Happens(e, t) Happens(e1 , t) Happens(en , t) (disjunctive event axiom),
Started Stopped j (1 j n) either Initiated
Terminated ;
conjunction universal closures cancellation axioms form
Abi (..., t) ;
conjunction first-order sentences (outside scope CIRC) including unique
name axioms, state constraints, event occurrence constraints, set domainindependent axioms event calculus, EC (for continuous event calculus) DEC (for discrete event calculus) (Mueller, 2006, Chapter 2).
579

fiLee & Palla

includes following definitions predicates used causal constraints :
def

Started (f, t) (HoldsAt(f, t) e(Happens(e, t) Initiates(e, f, t)))

(CC1 )

def

Stopped (f, t) (HoldsAt(f, t) e(Happens(e, t) Terminates(e, f, t)))
def

Initiated (f, t) (Started (f, t) e(Happens(e, t) Terminates(e, f, t)))
def

Terminated (f, t) (Stopped (f, t) e(Happens(e, t) Initiates(e, f, t)))

(CC2 )
(CC3 )
(CC4 ).

Remark 1 following facts easy check:
canonical relative {Initiates, Terminates, Releases};
canonical relative {Happens};
canonical relative {Ab 1 , . . . , Ab n }.
facts used next section reformulate event calculus general
theory stable models.
3.2 Reformulating Event Calculus General Theory Stable Models
Following Ferraris, Lee, Lifschitz, Palla (2009), formula F say
negative list p predicate constants members p strictly positive
occurrences F .4 example, formula (9) negative {p}, negative {p, q}.
formula form F (shorthand F ) negative list predicates.
assume already equivalently rewritten negative {Initiates,
Terminates, Releases, Happens, Ab 1 , . . . , Ab n }. easily done prepending
strictly positive occurrences predicates. following theorem shows
equivalent reformulations circumscriptive event calculus general theory stable
models.
Theorem 2 event calculus description (16), following theories equivalent
other:5
(a) CIRC[; I, T, R] CIRC[; H] CIRC[; Ab 1 , . . . , Ab n ] ;
(b) SM[; I, T, R] SM[; H] SM[; Ab 1 , . . . , Ab n ] ;
(c) SM[ ; I, T, R, H, Ab 1 , . . . , Ab n ] ;
(d) SM[ Choice(pr ( ) \ {I, T, R, H, Ab 1 , . . . , Ab n })] .
equivalence (a) (b) immediate Theorem 1. equivalence
(b) (c) shown using splitting theorem Ferraris et al. (2009).
assumption negative intensional predicates essential showing
4. Note distinguish formula negative (on p) occurrence negative
(Section 2.3).
5. brevity, abbreviate names circumscribed predicates.

580

fiReformulating Situation Calculus Event Calculus

equivalence (For details, see proof Appendix C.4.). equivalence
(c) (d) follows Proposition 1 since
{I, T, R, H, Ab 1 , . . . , Ab n } \ pr ( )
empty set.6

4. Reformulating Situation Calculus General Theory Stable
Models
section, review reformulate two versions situation calculusLins
causal action theories (1995) Reiters basic action theories (2001).
4.1 Review: Lins Causal Action Theories
assume many-sorted first-order language contains situation sort, action
sort, fluent sort, truth value sort object sort. understand expression P (x, s),
P fluent name, shorthand Holds(P (x), s). consider functional
fluents simplicity.
According Lin (1995), formula (s) called simple state formula (s)
mention Poss, Caused situation term possibly variable s.
assume causal action theory consists finite number following
sets axioms. often identify conjunction universal closures
axioms D. following, F , fluent names, action name, V , Vi truth
values, s, s0 situation variables, (s) simple state formula s, symbols a, a0
action variables, f variable sort fluent, v variable sort truth value, x,
xi , y, yi lists variables.
Dcaused conjunction axioms form
Poss(A(x), s) ((s) Caused (F (y), V, do(A(x), s))
(direct effect axioms),
(s) Caused (F1 (x1 ), V1 , s) Caused (Fn (xn ), Vn , s) Caused (F (x), V, s)
(indirect effect axioms).
Dposs conjunction precondition axioms form
Poss(A(x), s) (s).

(17)

Drest conjunction following axioms:
basic axioms:
Caused (f, true, s) Holds(f, s),
Caused (f, false, s) Holds(f, s),
true 6= false v(v = true v = false).
6. I, , R, H occur domain independent axioms part .

581

(18)

fiLee & Palla

unique name assumptions fluent names:
(x) 6= Fj (y), (i 6= j)
(x) = (y) x = y.

(19)

Similarly action names.
foundational axioms discrete situation calculus:

7

6= do(a, s),
0

0

0

0

do(a, s) = do(a , ) (a = = ),



p p(S0 ) a, p(s) p(do(a, s)) p(s) .

(20)
(21)
(22)

frame axiom:
Poss(a, s) (vCaused (f, v, do(a, s))
(Holds(f, do(a, s)) Holds(f, s))).
Axioms domain knowledge: (s).
causal action theory defined
CIRC[Dcaused ; Caused ] Dposs Drest .

(23)

Remark 2 easy check Dcaused canonical relative Caused .
fact used next section reformulate causal action theories general
theory stable models.
4.2 Reformulating Causal Action Theories General Theory Stable
Models
Let Dposs conjunction axioms (s) Poss(A(x), s) axiom (17) Dposs .
Instead second-order axiom (22), consider following first-order formula Dsit ,
introduces new intensional predicate constant Sit whose argument sort situation.8
Sit(S0 ) a, s(Sit(s) Sit(do(a, s))) sSit(s).

(24)


following, Drest
theory obtained Drest dropping (22).

Theorem 3 Given causal action theory (23), following theories equivalent
disregard auxiliary predicate Sit:
(a) CIRC[Dcaused ; Caused ] Dposs Drest ;

(b) SM[Dcaused ; Caused ] Dposs Drest
SM[Dsit ; Sit] ;

(c) SM[Dcaused ; Caused ] SM[Dposs ; Poss] Drest
SM[Dsit ; Sit] ;

(d) SM[Dcaused Dposs Drest
Dsit ; Caused , Poss, Sit] .

7. simplicity omit two axioms regarding partial-order among situations.
8. Suggested Vladimir Lifschitz (personal communication).

582

fiReformulating Situation Calculus Event Calculus

4.3 Review: Reiters Basic Action Theories
causal action theories, understand P (x, s), P fluent name, shorthand
Holds(P (x), s), consider functional fluents.
basic action theory (BAT) form
Dss Dap Duna DS0 ,

(25)


conjunction foundational axioms (Section 4.1);
Dss conjunction successor state axioms form
F (x, do(a, s)) F (x, a, s),
F (x, a, s) formula uniform
among x, a, s;

9

whose free variables

Dap conjunction action precondition axioms form
Poss(A(x), s) (x, s),
(x, s) formula uniform whose free variables among x, s;
Duna conjunction unique name axioms fluents actions;
DS0 conjunction first-order formulas uniform S0 .
4.4 Reformulating Basic Action Theories General Theory Stable
Models
Note BAT theory first-order logic.10 view fact first-order
logic sentence F equivalent SM[F ; ], trivial view BAT first-order theory
stable model semantics list intensional predicates empty.
rest section, consider alternative encoding BAT ASP,
need provide explicit successor state axioms Dss . Instead, successor state
axioms entailed effect axioms generic inertia axioms adopted ASP
making intensional positive predicate Holds negative predicate Holds
(Recall definitions positive negative predicates Section 2.2). following
assume underlying signature contains predicates.
ASP-style BAT form
Deffect Dprecond Dinertia Dexogenous0 Duna DS0 ,

, Duna DS0 defined before;
9. refer reader book Reiter (2001) definition uniform formula.
10. simplicity disregard second-order axiom (22).

583

(26)

fiLee & Palla

Deffect conjunction axioms form
+
R
(x, a, s) Holds(R(x), do(a, s))

(27)


R
(x, a, s) Holds(R(x), do(a, s)),

(28)


+
R
(x, a, s)


R
(x, a, s)



variables among x, s;

formulas uniform whose free

Dprecond conjunction axioms form
(x, s) Poss(A(x), s),

(29)

(x, s) formula uniform whose free variables among x, s;
Dinertia conjunction axioms
Holds(R(x), s) Holds(R(x), do(a, s)) Holds(R(x), do(a, s)),
Holds(R(x), s) Holds(R(x), do(a, s)) Holds(R(x), do(a, s))
fluent names R;
Dexogenous0 conjunction
Holds(R(x), S0 ) Holds(R(x), S0 )
fluent names R.
Note axioms Dinertia typically used answer set programming represent
common sense law inertia (Lifschitz & Turner, 1999). Similarly, Dexogenous0 used
represent initial value fluent arbitrary.11
show ASP-style BAT related Reiters BAT. First, since use
strong negation, convenient define following notions. Given signature
BAT, Holds signature obtained adding Holds . say
interpretation Holds complete Holds satisfies
y(Holds(y) Holds(y)),
list distinct variables. Given interpretation Holds , expression I|
denotes projection .
Let Dss conjunction successor state axioms

Holds(R(x), do(a, s)) +
R (x, a, s) (Holds(R(x), s) R (x, a, s)),
+

+
R (x, a, s) disjunction R (x, a, s) axioms (27) Deffect , R (x, a, s)

disjunction R (x, a, s) axioms (28) Deffect . Dap denote conjunction axioms Poss(A(x), s) (x, s), (x, s) disjunction (x, s)
axioms (29) Dprecond .

11. axioms Dinertia Dexogenous0 closely related translation C+ nonmonotonic
causal logic (Giunchiglia, Lee, Lifschitz, McCain, & Turner, 2004).

584

fiReformulating Situation Calculus Event Calculus

Theorem 4 Let theory (26) signature Holds , coherent interpretation
Holds complete Holds. satisfies

x s(+
R (x, a, s) R (x, a, s))

every fluent name R, satisfies
SM[T ; Poss, Holds, Holds]
iff I| satisfies BAT
Dss Dap Duna DS0 .

5. Translating Almost Universal Sentences Logic Programs
Theorems 24 present reformulations situation calculus event calculus
general theory stable models, may contain nested quantifiers connectives.
hand, input languages ASP solvers limited simple rule forms,
analogous clausal normal form classical logic. Although first-order formula
rewritten clausal normal form preserving satisfiability, transformations
necessarily preserve stable models. due fact notion equivalence
stronger stable model semantics (Lifschitz, Pearce, & Valverde, 2001).
Definition 4 (Ferraris et al., 2011) formula F strongly equivalent formula G if,
formula H containing F subformula (and possibly containing object, function
predicate constants occur F , G), list p distinct predicate
constants, SM[H; p] equivalent SM[H 0 ; p], H 0 obtained H replacing
occurrence F G.
words, replacing subformula another strongly equivalent subformula
change stable models whole formula. strongly equivalent theories
classically equivalent (i.e., equivalent classical logic), converse hold.
Consequently, classically equivalent transformations necessarily preserve stable models. instance, consider p p. p intensional, former stable models
latter not.
known every propositional formula rewritten logic program (Cabalar
& Ferraris, 2007; Cabalar, Pearce, & Valverde, 2005; Lee & Palla, 2007), translations extended quantifier-free formulas straightforward way (Section 5.1).
However, method work presence arbitrary quantifiers,
target formalism (logic programs), variables implicitly universally quantified.
section, present translation turns certain class sentences called
almost universal sentences logic programs preserving stable models. turns
reformulations situation calculus event calculus Sections 3
4 belong class almost universal sentences, use ASP solvers
computing them.
585

fiLee & Palla

5.1 Translating Quantifier-Free Formulas Logic Programs
Cabalar et al. (2005) define following transformation turns propositional formula stable model semantics logic program.
Left side rules:
>F G

7

{F G}

(L1)

F G

7



(L2)

F G H

7

(L3)

(F G) H K

7

(F G) H K

7

{G F H}


F H K
GH K



F H K
GH K


H F G K

F G

7

{F G}

(R1)

F >G

7



(R2)

F G H

7

(R3)

F (G H) K

7

F (G H) K

7

{G F H}


F GK
F H K


GF H K
H F G K

(L4)

(L5)

Right side rules:

(R4)
(R5)

applying transformation formula lefthand side, assume
formula already written negation normal form, negation applied
literals only, using following transformation:
Negation normal form conversion:
>

F
(F G)
(F G)
(F G)

7
7

7

7

7

7



>
F
F G
F G
F G

According Cabalar et al. (2005), successive application rewriting rules
turn propositional formula disjunctive logic program. result simply
extended turn quantifier-free formula logic program.
noted Cabalar et al. (2005), translation may involve exponential blowup
size, Theorem 1 paper shows indeed vocabulary-preserving
polynomial time algorithm convert general propositional theories stable model
semantics disjunctive logic programs. Alternatively, one use another translation
paper, linear size involves auxiliary atoms
complex.
586

fiReformulating Situation Calculus Event Calculus

5.2 Quantifier Elimination
introduce quantifier elimination method distinguishes two kinds occurrences quantifiers: singular non-singular. non-singular occurrence
quantifier easy eliminate, singular occurrence eliminated certain
syntactic condition.
Definition 5 say occurrence QxG F singular
Q , occurrence QxG positive F ,
Q , occurrence QxG negative F .
example, occurrence x q(x) singular (11), occurrence x p(x)
not.
Non-singular occurrences quantifiers eliminated view fact every
first-order sentence rewritten prenex form. prenex form conversion rules given
Section 6.3.1 Pearce Valverde (2005) preserve strong equivalence, leads
following theorem.12
Theorem 5 (Lee & Palla, 2007, Proposition 5) Every first-order formula strongly
equivalent formula prenex form.
prenex form conversion turns non-singular occurrence quantifier
outermost preserving strong equivalence. Consequently, sentence contains
singular occurrence quantifier, results used turn sentence
universal sentence set ASP rules. However, presence
singular occurrence quantifier, prenex form conversion turns occurrence
outermost , allowed logic programs. consider handle
occurrences.
Obviously, Herbrand universe finite, interested Herbrand stable
models (i.e., answer sets) only, quantified formulas rewritten multiple disjunctions
conjunctions. even need consider turning formula prenex form.
example, formula
r x(p(x) q(x))

(30)

occurring theory whose signature contains {1, . . . , n} object constants (and
function constants), replace x(p(x) q(x)) multiple disjunctions
turn resulting program nested expressions usual disjunctive program
(Lifschitz, Tang, & Turner, 1999), 2n rules generated. instance, n = 3,
12. Pearce Valverde (2005) show sentence QNc5 , monotonic basis Quantified Equilibrium
Logic, turned prenex form, result follows.

587

fiLee & Palla

resulting logic program
r,
r,
r,
r,
r,
r,
r,
r,

p(1),
p(1),
p(1),
p(1),
q(1),
q(1),
q(1),
q(1),

p(2),
p(2),
q(2),
q(2),
p(2),
p(2),
q(2),
q(2),

p(3)
q(3)
p(3)
q(3)
p(3)
q(3)
p(3)
q(3).

Also, translation modular depends underlying domain; multiple
disjunctions conjunctions need updated domain changes. importantly, method applicable theory contains function constants positive
arity, Herbrand universe infinite.
One may consider introducing Skolem constants first-order logic, presuming
that, sentence F Skolem form F 0 , SM[F ; p] satisfiable iff SM[F 0 ; p]
satisfiable. However, idea work.13
Example 2 formula
F = (x p(x) q) x(q p(x)),
SM[F ; q] equivalent first-order sentence
(q x p(x)) x(q p(x)),
unsatisfiable (the equivalence established using Theorems 3 11 Ferraris et al., 2011). Formula F strongly equivalent prenex form

xy (p(x) q) (q p(y)) ,

(31)

However, introduce new object constants b replace existentially quantified
variables
F 0 = (p(a) q) (q p(b)),
formula SM[F 0 ; q] equivalent
(q p(a)) (q p(b)),
satisfiable.
present method eliminating singular occurrences quantifiers introducing auxiliary predicates. idea generalization practice logic programming
13. Pearce Valverde (2005) show Skolemization works QNc5 , monotonic basis Quantified Equilibrium Logic, example shows, imply Skolemization works
Quantified Equilibrium Logic.

588

fiReformulating Situation Calculus Event Calculus

simulates negated existential quantification body rule introducing auxiliary predicates. instance, order eliminate (30), introduce new
predicate constant p0 , turn (30)
(r p0 s) x(p(x) q(x) p0 ),

(32)

corresponds logic program
r, p0
p0 p(x), q(x).

(33)

models SM[(30); p, q, r, s] stable models (33) disregard
p0 . method involve grounding, translation depend
domain restricted Herbrand models. method formally justified
following proposition.
Recall formula H negative p members p strictly positive
occurrences H. Given formula F , say occurrence subformula G
p-negated F contained subformula H F negative p.
Proposition 2 Let F sentence, let p finite list distinct predicate constants,
let q new predicate constant occur F . Consider non-strictly
positive, p-negated occurrence yG(y, x) F , x list free variables
yG(y, x). Let F 0 formula obtained F replacing occurrence yG(y, x)
q(x).
SM[F ; p] x(q(x) yG(y, x))
equivalent
SM[F 0 xy(G(y, x) q(x)); p, q].
Proposition 2 tells us SM[F ; p] SM[F 0 xy(G(y, x) q(x); p, q]
models disregard new predicate constant q. Notice F 0 retain
occurrence y.
Example 3 formula (30), x(p(x) q(x)) contained negative formula (relative
set intensional predicates). accordance Proposition 2, SM[(30); p, q, r, s]
models SM[(32); p, q, r, s, p0 ] disregard p0 .
singular, p-negated occurrence subformula yG(y, x) eliminated
using Proposition 2 first rewriting yG(y, x) yG(y, x). Note yG(y, x)
strongly equivalent yG(y, x), general classically equivalent transformation may necessarily preserve stable models. However, Theorem Double
Negations (Ferraris et al., 2009, reviewed Appendix C) tells us transformation ensured preserve p-stable models replaced occurrence p-negated
given formula.
ready present quantifier elimination method, applies
class almost universal formulas.
589

fiLee & Palla

Definition 6 say formula F almost universal relative p every singular
occurrence QxG F p-negated F .
example, formula (30) almost universal relative set predicates
singular occurrence x(p(x) q(x)) (30) contained x(p(x) q(x)),
negative list predicates. Formula F Example 2 almost universal relative
{q} singular occurrence x p(x) contained formula itself,
negative {q}, singular occurrence x(q p(x)) contained x(q p(x)),
negative {q}.
following procedure used eliminate (possibly nested) quantifiers
almost universal sentence.
Definition 7 (Translation elim-quantifiers) Given formula F , first prepend
every maximal strictly positive occurrence formula form yH(y, x),14
repeat following process occurrences quantifiers remaining: Select
maximal occurrence formula form QyG(y, x) F , Q , x
list free variables QyG(y, x).
(a) occurrence QyG(y, x) F non-singular F , set F formula
obtained F replacing occurrence QyG(y, x) G(z, x), z
new variable.
(b) Otherwise, Q occurrence QyG(y, x) F positive, set F

F 0 (G(y, x) pG (x)),
pG new predicate constant F 0 formula obtained F replacing occurrence QyG(y, x) pG (x).
(c) Otherwise, Q occurrence QyG(y, x) F negative, set F
formula obtained F replacing occurrence QyG(y, x)
yG(y, x).
assume new predicate constants introduced translation belong
signature input formula F . clear process terminates, yields
formula quantifier-free. Since number times step (b) applied
number quantifiers input formula, new formulas added
size polynomial input formula, follows size resulting quantifier-free
formula polynomial size input formula.
following theorem tells us almost universal sentence F turned
form xG, G quantifier-free formula. (second-order) sentences F
G signature subset signature, say F -equivalent
G, denoted F G, class models F restricted identical class
models G restricted .
14. maximality understood terms subformula relation. is, select strictly positive
occurrence subformula F form yH(y, x) contained subformula
F form.

590

fiReformulating Situation Calculus Event Calculus

Theorem 6 Let F sentence signature , let F 0 universal closure
formula obtained F applying translation elim-quantifiers, let q list
new predicate constants introduced translation. F almost universal relative
p, SM[F ; p] -equivalent SM[F 0 ; p, q].
statement theorem becomes incorrect require F almost
universal relative p. instance, elim-quantifiers applied x p(x), results
q (p(x) q). However, SM[x p(x); p] {p}-equivalent
SM[x(q (p(x) q)); p, q]. former equivalent saying p singleton.
latter equivalent q xp(x) (q xp(x)), inconsistent.
5.3 f2lp: Computing Answer Sets First-Order Formulas
Using translation elim-quantifiers defined previous section, introduce translation f2lp turns almost universal formula logic program. assume
underlying signature contains finitely many predicate constants.
Definition 8 (Translation f2lp)
1. Given formula F list intensional predicates p, apply translation elim-quantifiers (Definition 7) F ;
2. Add choice formulas (q(x) q(x)) non-intensional predicates q.
3. Turn resulting quantifier-free formula logic program applying translation Section 3 paper Cabalar et al. (2005), reviewed
Section 5.1.
explained Section 5.1, due third step, transformation may involve
exponential blowup size. One obtain polynomial translation replacing Step 3
alternative translation given Section 4 paper Cabalar et al.
following theorem asserts correctness translation.
Theorem 7 Let F sentence signature , let p list intensional predicates,
let F 0 FOL representation program obtained F applying translation
f2lp p intensional predicates. F almost universal relative p, SM[F ; p]
-equivalent
SM[F 0 False(p \ pr (F 0 ))].
Example 4 Consider one domain independent axioms discrete event calculus
(DEC5 axiom):
HoldsAt(f, t) ReleasedAt(f, t+1)
e(Happens(e, t) Terminates(e, f, t)) HoldsAt(f, t+1).
Step 1 translation f2lp introduces formula
Happens(e, t) Terminates(e, f, t) q(f, t),
replaces (34)
HoldsAt(f, t) ReleasedAt(f, t+1) q(f, t) HoldsAt(f, t+1).
591

(34)

fiLee & Palla

Step 3 turns formulas rules
q(f, t) Happens(e, t), Terminates(e, f, t)
HoldsAt(f, t+1) HoldsAt(f, t), ReleasedAt(f, t+1), q(f, t).
Turning program obtained applying translation f2lp input languages
lparse 15 gringo 16 requires minor rewriting, moving equality negated
atoms head body 17 adding domain predicates body variables
occurring rule order reduce many-sorted signature non-sorted one.18
System f2lp implementation translation f2lp, turns first-order formula
languages lparse gringo. system downloaded home
page
http://reasoning.eas.asu.edu/f2lp .
First-order formulas encoded f2lp using extended rule form F G,
F G first-order formulas contain . ASCII representation
quantifiers connectives shown following table.
Symbol
ASCII





-


&


|


<-


false

>
true

xyz
![X,Y,Z]:

xyz
?[X,Y,Z]:

example, formula (34) encoded input language f2lp
holdsAt(F,T+1) <- holdsAt(F,T) & releasedAt(F,T+1) &
?[E]:(happens(E,T) & terminates(E,F,T)).

usual lparse gringo rules (which rule arrow :-) allowed
f2lp. rules simply copied output. program returned f2lp
passed ASP grounders solvers accept lparse gringo languages.

6. Computing Event Calculus Using ASP Solvers
Using translation f2lp, turn event calculus reformulation Section 3.2
answer set programs. following procedure describes process.
Definition 9 (Translation ec2asp)
1. Given event calculus description (16), rewrite
definitional axioms form
def

x(p(x) G)

(35)

x(G p(x)), G obtained G prepending
occurrences intensional predicates Initiates, Terminates, Releases, Happens,
Ab 1 , . . . , Ab n . prepend strictly positive occurrences intensional
predicates remaining axioms . Let 0 resulting formula obtained
.
15.
16.
17.
18.

http://www.tcs.hut.fi/Software/smodels
http://potassco.sourceforge.net
instance, (X=Y) | -q(X,Y) :- p(X,Y) turned :- X!=Y, {not q(X,Y)}0, p(X,Y).
Alternatively done declaring variables using #domain directive lparse gringo
languages.

592

fiReformulating Situation Calculus Event Calculus

2. Apply translation f2lp 0 intensional predicates
{Initiates, Terminates, Releases, Happens, Ab 1 , . . . , Ab n } p,
p set predicate constants p (35) considered Step 1.
following theorem states correctness translation.
Theorem 8 Let event calculus description (16) signature contains finitely
many predicate constants, let F FOL representation program obtained
applying translation ec2asp. -equivalent SM[F ].
view theorem, system f2lp used compute event calculus descriptions
simple rewriting stated translation ec2asp.19 system used place
dec reasoner many existing applications event calculus, robotics,
security, video games, web service composition, listed
http://decreasoner.sourceforge.net/csr/decapps.html .
computational mechanism dec reasoner similar method
based reduction event calculus reasoning propositional satisfiability uses
efficient SAT solvers computation. However, method advantages.
First, significantly faster due efficient grounding mechanisms implemented
ASP systems. evidenced experiments reported Appendix B.
Second, f2lp allows us compute full version event calculus, assuming
domain given finite. hand, reduction implemented dec
reasoner based completion, weaker circumscription. makes
system unable handle recursive axioms disjunctive axioms, effect constraints
disjunctive event axioms (Section 3.1). example, dec reasoner allow
following effect constraints describe indirect effects agents walking
objects holding:
HoldsAt(Holding(a, o), t) Initiates(e, InRoom(a, r), t)
Initiates(e, InRoom(o, r), t)
HoldsAt(Holding(a, o), t) Terminates(e, InRoom(a, r), t)
Terminates(e, InRoom(o, r), t).

(36)

Third, enhance event calculus reasoning combining ASP rules
event calculus description. words, event calculus viewed high
level action formalism top ASP. illustrate using example work
Dogandag, Ferraris, Lifschitz (2004). 9 rooms 12 doors shown
Figure 1. Initially robot Robby middle room doors closed.
goal robot make rooms accessible other. Figure 2 (File robby)
shows encoding problem language f2lp. Atom door(x, y) denotes
door rooms x y; open(x, y) denotes event Robby opening door
19. Kim, Lee, Palla (2009) presented prototype f2lp called ecasp tailored event
calculus computation.

593

fiLee & Palla

Figure 1: Robbys apartment 3 3 grid
rooms x y; goto(x) denotes event Robby going room x; opened(x, y)
denotes door x opened; inRoom(x) denotes Robby
room x; accessible(x, y) denotes accessible x. Note rules
defining relation accessible part event calculus axioms (Section 3.1).
example illustrates advantage allowing ASP rules event calculus descriptions.
minimal number steps solve given problem 11. find
plan using combination f2lp, gringo (grounder) claspD (solver disjunctive
programs) following way. 20
$ f2lp dec robby | gringo -c maxstep=11 | claspD
File dec f2lp encoding domain independent axioms Discrete Event
Calculus (The file listed Appendix A).21 following one plans found:
happens(open(5,8),0) happens(open(5,2),1) happens(open(5,4),2)
happens(goto(4),3) happens(open(4,1),4) happens(open(4,7),5)
happens(goto(5),6) happens(open(5,6),7) happens(goto(6),8)
happens(open(6,9),9) happens(open(6,3),10)

7. Computing Situation Calculus Using ASP Solvers
Using translation f2lp, turn situation calculus reformulations Sections 4.2
4.4 answer set programs.
7.1 Representing Causal Action Theories Answer Set Programs
following theorem shows turn causal action theories answer set programs.
Theorem 9 Let finite causal action theory (23) signature contains finitely
many predicate constants, let F FOL representation program obtained
applying translation f2lp

Dcaused Dposs Drest
Dsit

(37)

intensional predicates {Caused , Poss, Sit}. -equivalent SM[F ].
20. One use clingo instead gringo claspD output f2lp nondisjunctive program.
21. file available http://reasoning.eas.asu.edu/f2lp, along f2lp encodings
domain independent axioms versions event calculus.

594

fiReformulating Situation Calculus Event Calculus

% File robby
% objects
step(0..maxstep).
astep(0..maxstep-1) :- maxstep > 0.
room(1..9).
% variables
#domain step(T).
#domain room(R).
#domain room(R1).
#domain room(R2).
% position
door(R1,R2) <- R1
door(R1,R2) <- R1
door(R1,R2) <- R1
door(R1,R2) <- R2

doors
>= 1 &
>= 4 &
>= 7 &
< 10 &

R2
R2
R2
R2

>=1 & R1 < 4 & R2 < 4 & R2 = R1+1.
>= 4 & R1 < 7 & R2 < 7 & R2 = R1+1.
>= 7 & R1 < 10 & R2 < 10 & R2 = R1+1.
= R1+3.

door(R1,R2) <- door(R2,R1).
% fluents
fluent(opened(R,R1)) <- door(R1,R2).
fluent(inRoom(R)).
% F ranges fluents
#domain fluent(F).
% events
event(open(R,R1)) <- door(R,R1).
event(goto(R)).
% E E1 range events
#domain event(E).
#domain event(E1).
% effect axioms
initiates(open(R,R1),opened(R,R1),T).
initiates(open(R,R1),opened(R1,R),T).
initiates(goto(R2),inRoom(R2),T)
<- holdsAt(opened(R1,R2),T) & holdsAt(inRoom(R1),T).
terminates(E,inRoom(R1),T)
<- holdsAt(inRoom(R1),T) & initiates(E,inRoom(R2),T).
% action precondition axioms
holdsAt(inRoom(R1),T) <- happens(open(R1,R2),T).

595

fiLee & Palla

% event occurrence constraint
happens(E1,T) <- happens(E,T) & E != E1.
% state constraint
holdsAt(inRoom(R2),T) <- holdsAt(inRoom(R1),T) & R1 != R2.
% accessibility
accessible(R,R1,T) <- holdsAt(opened(R,R1),T).
accessible(R,R2,T) <- accessible(R,R1,T) & accessible(R1,R2,T).
% initial state
holdsAt(opened(R1,R2),0).
holdsAt(inRoom(5),0).
% goal state
accessible(R,R1,maxstep).
% happens exempt minimization order find plan.
{happens(E,T)} <- < maxstep.
% fluents inertial
releasedAt(F,0).

Figure 2: Robby f2lp

Similar computation event calculus Section 6, Herbrand stable
models (37) computed using f2lp answer set solvers. input f2lp
simplified limit attention Herbrand models. drop axioms (18)(21)
ensured Herbrand models. Also, order ensure finite grounding, instead
Dsit , include following set rules situation input f2lp.
nesting(0,s0).
nesting(L+1,do(A,S)) <- nesting(L,S) & action(A) & L < maxdepth.
situation(S) <- nesting(L,S).
final(S) <- nesting(maxdepth,S).

situation used generate finitely many situation terms whose depth maxdepth,
value given option invoking gringo. Using splitting theorem
(Section C.1), difficult check program containing rules
occurrence predicate nesting rules occurrence predicate situation head rules, every answer set contains
atoms situation(do(am , do(am1 , do(. . . , do(a1 , s0))))) possible sequences actions
a1 , . . . , = 0, . . . , maxdepth. Though program satisfy syntactic conditions, -restricted (Gebser, Schaub, & Thiele, 2007), -restricted (Syrjanen, 2004),
finite domain programs (Calimeri, Cozza, Ianni, & Leone, 2008), answer set solvers
usually impose order ensure finite grounding, rules still finitely grounded
596

fiReformulating Situation Calculus Event Calculus

% File: suitcase
value(t).
value(f).

lock(l1).

lock(l2).

#domain value(V).
#domain lock(X).
fluent(up(X)).
fluent(open).
#domain fluent(F).
action(flip(X)).
#domain action(A).
depth(0..maxdepth).
#domain depth(L).
% defining situation domain
nesting(0,s0).
nesting(L+1,do(A,S)) <- nesting(L,S) & L < maxdepth.
situation(S) <- nesting(L,S).
final(S) <- nesting(maxdepth,S).
% basic axioms
h(F,S) <- situation(S) & caused(F,t,S).
h(F,S) <- situation(S) & caused(F,f,S).
% D_caused
caused(up(X),f,do(flip(X),S)) <situation(S) & final(S) & poss(flip(X),S) & h(up(X),S).
caused(up(X),t,do(flip(X),S)) <situation(S) & final(S) & poss(flip(X),S) & h(up(X),S).
caused(open,t,S) <- situation(S) & h(up(l1),S) & h(up(l2),S).
% D_poss
poss(flip(X),S) <- situation(S).
% frame axioms
h(F,do(A,S)) <h(F,S) & situation(S) & final(S) & poss(A,S)
& ?[V]:caused(F,V,do(A,S)).
h(F,do(A,S)) <not h(F,S) & situation(S) & final(S) & poss(A,S)
& ?[V]:caused(F,V,do(A,S)).
% h non-intensional.
{h(F,S)} <- situation(S).

Figure 3: Lins Suitcase language f2lp
597

fiLee & Palla

gringo Version 3.x, check syntactic conditions.22 difficult
see program leads finite grounding since provide explicit upper
limit nesting depth function do.
addition situation , use following program executable order represent
set executable situations (Reiter, 2001):
executable(s0).
executable(do(A,S)) <- executable(S) & poss(A,S) & final(S)
& situation(S) & action(A).

Figure 3 shows encoding Lins suitcase example (1995) language f2lp
(h used represent Holds), describes suitcase two locks spring
loaded mechanism open suitcase locks up. example
illustrates ramification problem handled causal action theories. Since fix
domain situations finite, require actions effective final
situations. done introducing atom final(S).
Consider simple temporal projection problem Lin (1995). Initially first lock
second lock up. happen first lock flipped? Intuitively,
expect locks suitcase open. automate reasoning
using combination f2lp, gringo claspD. First, add executable
following rules theory Figure 3. order check theory entails flipping
first lock executable, suitcase open action, encode
negation facts last rule.
% initial situation
<- h(up(l1),s0).
h(up(l2),s0).
% query
<- executable(do(flip(l1),s0)) & h(open,do(flip(l1),s0)).

check answer temporal projection problem running command:
$ f2lp suitcase | gringo -c maxdepth=1 | claspD

claspD returns answer set expected.
Now, consider simple planning problem opening suitcase locks
initially down. add executable following rules theory Figure 3.
last rule encodes goal.
% initial situation
<- h(up(l1),s0).
<- h(up(l2),s0).
<- h(open,s0).
% goal
<- ?[S]: (executable(S) & h(open,S)).

maxdepth 1, combined use f2lp, gringo claspD results
answer sets, maxdepth 2, finds unique answer set contains
22. Similarly, system dlv-complex allows us turn finite domain checking (option -nofdcheck).
system used conference paper (Lee & Palla, 2010) article based on.

598

fiReformulating Situation Calculus Event Calculus

h(open, do(flip(l2), do(flip(l1), s0))) h(open, do(flip(l1), do(flip(l2), s0))),
encodes plan. words, single answer set encodes multiple plans
different branches situation tree, allows us combine information
different branches one model. instance hypothetical reasoning
elegantly handled situation calculus due branching time structure. Belleghem,
Denecker, Schreye (1997) note linear time structure event calculus
limited handle hypothetical reasoning allowed situation calculus.
7.2 Representing Basic Action Theories Answer Set Programs
Since BAT (not including second-order axiom (22)) viewed first-order
theory stable model semantics list intensional predicates empty,
follows f2lp used turn logic program. before, focus
ASP-style BAT.
Theorem 10 Let ASP-style BAT (26) signature contains finitely many
predicate constants, let F FOL representation program obtained applying translation f2lp intensional predicates {Holds, Holds, Poss}.
SM[T ; Holds, Holds, Poss] -equivalent SM[F ; (F ) {Poss}].
Figure 4 shows encoding broken object example discussed Reiter (1991).
Consider simple projection problem determining object o, next
bomb b, broken bomb explodes. add executable following rules
theory Figure 4.
% initial situation
h(broken(o),s0) & h(fragile(o),s0) & h(nexto(b,o),s0).
h(holding(p,o),s0) & h(exploded(b),s0).
% query
<- executable(do(explode(b),s0)) & h(broken(o),do(explode(b),s0)).

command
$ f2lp broken | gringo -c maxdepth=1 | claspD

returns answer set expected.

8. Related Work
Identifying syntactic class theories different semantics coincide important
understanding relationship them. known that, tight logic programs
tight first-order formulas, stable model semantics coincides completion
semantics (Fages, 1994; Erdem & Lifschitz, 2003; Ferraris et al., 2011). fact helps us
understand relationship two semantics, led design answer
set solver cmodels-1 23 computes answer sets using completion. Likewise class
canonical formulas introduced helps us understand relationship
stable model semantics circumscription. class canonical formulas largest
23. http://www.cs.utexas.edu/users/tag/cmodels

599

fiLee & Palla

% File: broken
% domains situations
person(p).
object(o).
bomb(b).
#domain person(R).
#domain object(Y).
#domain bomb(B).
fluent(holding(R,Y)).
fluent(broken(Y)).

fluent(nexto(B,Y)).
fluent(exploded(B)).

fluent(fragile(Y)).

action(drop(R,Y)).

action(explode(B)).

action(repair(R,Y)).

#domain fluent(F).
#domain action(A).
depth(0..maxdepth).
#domain depth(L).
% defining situation domain
nesting(0,s0).
nesting(L+1,do(A,S)) <- nesting(L,S) & L < maxdepth.
situation(S) <- nesting(L,S).
final(S) <- nesting(maxdepth,S).
% Effect Axioms
h(broken(Y),do(drop(R,Y),S)) <- situation(S) & h(fragile(Y),S) & final(S).
h(broken(Y),do(explode(B),S)) <- situation(S) & h(nexto(B,Y),S) & final(S).
h(exploded(B),do(explode(B),S)) <- situation(S) & final(S).
-h(broken(Y),do(repair(R,Y),S)) <- situation(S) & final(S).
-h(holding(R,Y),do(drop(R,Y),S)) <- situation(S) & final(S).
% Action precondition axioms
poss(drop(R,Y),S) <- h(holding(R,Y),S) & situation(S).
poss(explode(B),S) <- situation(S) & h(exploded(B),S).
poss(repair(R,Y),S) <- situation(S) & h(broken(Y),S).
% inertial axioms
h(F,do(A,S)) <- h(F,S) & -h(F,do(A,S)) & situation(S) & final(S).
-h(F,do(A,S)) <- -h(F,S) & h(F,do(A,S)) & situation(S) & final(S).
% D_exogeneous_0
h(F,s0) | -h(F,s0).
% Consider interpretations complete Holds
<- h(F,S) & -h(F,S) & situation(S).

Figure 4: Broken object example language f2lp

600

fiReformulating Situation Calculus Event Calculus

syntactic class first-order formulas identified far stable models coincide
models circumscription. words, minimal model reasoning stable
model reasoning indistinguishable canonical formulas.
Proposition 8 work Lee Lin (2006) shows embedding propositional circumscription logic programs stable model semantics. theorem
canonical formulas generalization result first-order case. Janhunen
Oikarinen (2004) showed another embedding propositional circumscription logic
programs, implemented system circ2dlp,24 translation appears quite
different one Lee Lin.
Zhang, Zhang, Ying, Zhou (2011) show embedding first-order circumscription
first-order stable model semantics. Theorem 3 paper reproduced follows.25
Theorem 11 (Zhang et al., 2011, Thm. 3) Let F formula negation normal form
let p finite list predicate constants. Let F formula obtained F
replacing every p(t) p(t), let F c formula obtained F replacing
every p(t) p(t) Choice(p), p p list terms. CIRC[F ; p]
equivalent SM[F F c ; p].
comparison Theorem 1, theorem applied characterize circumscription arbitrary formulas terms stable models first rewriting formulas
negation normal form. Theorem 1 applicable canonical formulas only,
require transformation, characterization bidirectional sense
viewed characterization stable models terms circumscription.
Zhang et al. (2011) introduce translation turns arbitrary first-order formulas
logic programs, work limited finite structures only. hand,
translation f2lp (Definition 8) works almost universal formulas only,
limited finite structures.
situation calculus event calculus widely studied action formalisms,
several papers compare relate (e.g., Belleghem, Denecker, &
Schreye, 1995; Provetti, 1996; Belleghem et al., 1997; Kowalski & Sadri, 1997).
Prolog provides natural implementation basic action theories since definitional
axioms represented Prolog rules according Clarks theorem (Reiter, 2001,
Chapter 5). Lloyd-Topor transformation used turn formulas Prolog rules
similar translation f2lp, difference former preserves completion
semantics latter preserves stable model semantics.
Lin Wang (1999) describe language used represent syntactically
restricted form Lins causal situation calculus, called clausal causal theories,
allow quantifiers. show translate language answer set programs
strong negation, answer sets used obtain fully instantiated
successor state axioms action precondition axioms. quite different
approach, computes propositional models full situation calculus theories
directly.
Kautz Selman (1992) introduce linear encodings similar propositionalized version situation calculus (McCarthy & Hayes, 1969). Lin (2003) introduces
24. http://www.tcs.hut.fi/Software/circ2dlp
25. bit simpler original statement redundancy dropped.

601

fiLee & Palla

action description language describes procedure compile action domain
language complete set successor state axioms, STRIPS-like
description extracted. soundness procedure shown respect
translation action domain descriptions Lins causal action theories. However,
procedure based completion cannot handle recursive axioms unlike
approach.
Denecker Ternovska (2007) present inductive variant situation calculus
represented ID-logic (Denecker & Ternovska, 2008)classical logic extended inductive definitions. ID-logic first-order stable model semantics appear closely
related, precise relationship yet shown.

9. Conclusion
first-order stable model semantics defined similar circumscription. paper
takes advantage definition identify class formulas minimal model
reasoning stable model reasoning coincide, uses idea reformulate situation calculus event calculus first-order stable model semantics. Together
translation turns almost universal sentence logic program, show
reasoning situation calculus event calculus reduced computing
answer sets. implemented system f2lp, front-end ASP solvers allows us
compute circumscriptive action theories. mathematical tool sets system presented paper may useful relating circumscriptive theories
logic programs. Also, advances ASP solvers may improve computation
circumscriptive theories.

Acknowledgments
grateful Yuliya Lierler, Vladimir Lifschitz, Erik Mueller, Heng Zhang, Yan Zhang,
anonymous referees useful comments discussions. authors
partially supported National Science Foundation Grant IIS-0916116.

Appendix A. File dec Language f2lp
File dec encodes domain independent axioms discrete event calculus. file
used together event calculus domain descriptions shown Section 6.
% File dec
#domain
#domain
#domain
#domain
#domain
#domain
#domain

fluent(F).
fluent(F1).
fluent(F2).
event(E).
time(T).
time(T1).
time(T2).

time(0..maxstep).
602

fiReformulating Situation Calculus Event Calculus

% DEC 1
stoppedIn(T1,F,T2) <- happens(E,T) & T1<T & T<T2 & terminates(E,F,T).
% DEC 2
startedIn(T1,F,T2) <- happens(E,T) & T1<T & T<T2 & initiates(E,F,T).
% DEC 3
holdsAt(F2,T1+T2) <- happens(E,T1) & initiates(E,F1,T1) & T2>0 &
trajectory(F1,T1,F2,T2) & stoppedIn(T1,F1,T1+T2) & T1+T2<=maxstep.
% DEC 4
holdsAt(F2,T1+T2) <- happens(E,T1) & terminates(E,F1,T1) & 0<T2 &
antiTrajectory(F1,T1,F2,T2) & startedIn(T1,F1,T1+T2) &
T1+T2<=maxstep.
% DEC 5
holdsAt(F,T+1) <- holdsAt(F,T) & releasedAt(F,T+1) &
?[E]:(happens(E,T) & terminates(E,F,T)) & T<maxstep.
% DEC 6
holdsAt(F,T+1) <- holdsAt(F,T) & releasedAt(F,T+1) &
?[E]:(happens(E,T) & initiates(E,F,T)) & T<maxstep.
% DEC 7
releasedAt(F,T+1) <releasedAt(F,T) & ?[E]:(happens(E,T) &
(initiates(E,F,T) | terminates(E,F,T))) & T<maxstep.
% DEC 8
releasedAt(F,T+1) <- releasedAt(F,T) &
?[E]: (happens(E,T) & releases(E,F,T)) & T<maxstep.
% DEC 9
holdsAt(F,T+1) <- happens(E,T) & initiates(E,F,T) & T<maxstep.
% DEC 10
holdsAt(F,T+1) <- happens(E,T) & terminates(E,F,T) & T<maxstep.
% DEC 11
releasedAt(F,T+1) <- happens(E,T) & releases(E,F,T) & T<maxstep.
% DEC 12
releasedAt(F,T+1) <- happens(E,T) &
(initiates(E,F,T) | terminates(E,F,T)) & T<maxstep.
{holdsAt(F,T)}.
{releasedAt(F,T)}.

603

fiLee & Palla

Problem
(max. step)

dec
reasoner

dec
reasoner (minisat)

f2lp
lparse + cmodels

f2lp
gringo + cmodels

f2lp
gringo + clasp(D)

f2lp
clingo

BusRide
(15)











0.2s
(0.07s + 0.13s)
A:13174/R:24687

0.14s

Kitchen
Sink (25)

39.0s
(38.9s + 0.1s)
A:1014/C:12109

38.9s
(38.9s + 0.00s)
A:1014/C:12109

0.24s
(0.18s + 0.06s)
A:11970/R:61932

0.20s

Thielscher
Circuit (40)

6.5s
(6.3s + 0.2s)
A:1394/C:42454

6.3s
(6.3s + 0.0s)
A:1394/C:42454

0.12s
(0.09s + 0.03s)
A:4899/R:35545

0.1s

Walking
Turkey (15)





0.00s
(0.00s + 0.00s)
A:316/R:456

0.00s

Falling w/
AntiTraj (15)

141.8s
(141.4s + 0.4s)
A:416/C:3056

141.7s
(141.7s + 0.00s)
A:416/C:3056

0.03s
(0.03s + 0.00s)
A:3702/R:7414

0.03s

Falling w/
Events (25)

59.5s
(59.5s + 0.0s)
A:1092/C:12351

59.4s
(59.4s + 0.0s)
A:1092/C:12351

0.28s
(0.20s + 0.08s)
A:13829/R:71266

0.22s

HotAir
Baloon (15)

32.2s
(32.2s + 0.0s)
A:288/C:1163

32.3s
(32.3s + 0.0s)
A:288/C:1163

0.0s
(0.0s + 0.0s)
A:1063/R:1835

0.01s

Telephone1
(40)

9.3s
(9.2s + 0.1s)
A:5419/C:41590

9.1s
(9.1s + 0.0s)
A:5419/C:41590

0.00s
(0.00s + 0.00s)
A:355/R:555
C:0
0.15s
(0.07s + 0.08s)
A:5269/R:24687
C:5308
0.44s
(0.19s + 0.25s)
A:11970/R:61932
C:0
0.19s
(0.09s + 0.1s)
A:4899/R:35545
C:0
0.00s
(0.00s + 0.00s)
A:316/R:456
C:0
0.04s
(0.02s + 0.02s)
A:3702/R:7414
C:0
0.46s
(0.20s + 0.26s)
A:1219/R:71266
C:1415
0.0s
(0.0s + 0.0s)
A:492/R:1835
C:681
0.11s
(0.08s + 0.03s)
A:9455/R:13140
C:0

0.01s
(0.00s + 0.01s)
A:448/R:647

Commuter
(15)

0.04s
(0.03s + 0.01s)
A:902/R:7779
C:0
77.29s
(45.74s + 31.55s)
A:32861/R:8734019
C:0
6.19s
(2.99s + 3.20s)
A:121621/R:480187
C:0
0.42s
(0.27s + 0.15s)
A:9292/R:53719
C:0
0.00s
(0.00s + 0.00s)
A:370/R:518
C:0
0.08s
(0.05s + 0.03s)
A:4994/R:9717
C:0
4.95s
(2.57s + 2.38s)
A:1240/R:388282
C:1436
0.01s
(0.01s + 0.00s)
A:494/R:2451
C:689
0.22s
(0.13s + 0.09s)
A:21414/R:27277
C:0

0.07s
(0.06s + 0.01s)
A:9455/R:13140

0.07s

A: number atoms, C: number clauses, R: number ground rules
Figure 5: Comparing dec reasoner f2lp answer set solvers

Appendix B. Comparing dec Reasoner ASP-based Event
Calculus Reasoner
compared performance dec reasoner (v 1.0) running relsat (v 2.2)
minisat (v 2.2) following:
f2lp (v 1.11) lparse (v 1.0.17)+cmodels (v 3.79) running minisat (v 2.0
beta),
f2lp (v 1.11) gringo (v 3.0.3)+cmodels (v 3.79) running minisat (v 2.0 beta),
f2lp (v 1.11) gringo (v 3.0.3) +clasp (v 2.0.2) (claspD (v 1.1.2) used instead
disjunctive programs),
f2lp (v 1.11) clingo (v 3.0.3 (clasp v 1.3.5)).
f2lp turns input theory languages lparse gringo, lparse
gringo turn result ground ASP program. cmodels turns ground program
set clauses invokes SAT solver compute answer sets, clasp
computes answer sets using techniques similar used SAT solvers. clingo
system combines gringo clasp monolithic way.
first five examples Figure 5 part benchmark problems work
Shanahan (1997, 1999). next four Mueller (2006). (We increased timepoints
604

fiReformulating Situation Calculus Event Calculus

Problem
(max. step)
ZooTest1
(16)

f2lp
gringo + cmodels
50.48s
(6.66s + 43.82s)
A:930483/R:2272288
C:3615955
ZooTest2
> 2h
159.51s
(22)
(12.36s + 147.15s)
A:2241512/R:4153670
C:8864228
ZooTest3
> 2h
142.68s
(23)
(13.55s + 129.13s)
A:2505940/R:4556928
C:9914568
A: number atoms, C: number clauses, R: number
dec
reasoner (minisat)
> 2h

f2lp
gringo + clasp
29.01s
(6.66s + 22.35s)
A:153432/R:2271175
210.55s
(12.36s + 198.19s)
A:219220/R:4152137
196.63s
(13.55s + 183.08s)
A:230731/R:4555325
ground rules

Figure 6: Zoo World dec reasoner ASP

see notable differences.) examples found f2lp homepage.
experiments done Pentium machine 3.06 GHz CPU 4GB RAM running
64 bit Linux. reported run times seconds obtained using Linux
time command (user time + sys time), except dec reasoner recorded
times reported system. fair comparisons order avoid including
time spent dec reasoner producing output neat format, sometimes
takes non-negligible time. dec reasoner, times parentheses (SAT encoding time + SAT solving time). others, times spent
grounder solver. cmodels time includes time spent converting ground
program generated lparse/gringo set clauses, calling SAT solver.
time spent f2lp translating event calculus description answer set
program (retaining variables) negligible problems. denotes system
cannot solve example due limited expressivity. instance, BusRide includes
disjunctive event axioms, results disjunctive program cannot handled
clingo. Similarly, dec reasoner cannot handle BusRide (disjunctive event axioms),
Commuter (compound events) Walking Turkey (effect constraints). evident
experiments, main reason efficiency ASP-based approach efficient grounding mechanisms implemented ASP grounders. Though dec reasoner
cmodels call SAT solver minisat, number atoms processed dec
reasoner general much smaller. dec reasoner adopts optimized
encoding method (that based predicate completion) avoids large number
ground instances atoms Initiates(e, f, t), Terminates(e, f, t), Releases(e, f, t)
(Mueller, 2004, Section 4.4). hand, several examples, number clauses
generated cmodels 0, means answer sets found without calling
SAT solver. examples unique answer set coincides
well-founded model, efficiently computed cmodels preprocessing step
calling SAT solvers. 14 benchmark examples Shanahan (1997, 1999),
10 belong case lparse used grounding.
605

fiLee & Palla

experiments Figure 5, solving times negligible problems. experimented computationally hard problems, solving takes
time grounding. Figure 6 shows runs medium-size action domain, Zoo
World (Akman, Erdogan, Lee, Lifschitz, & Turner, 2004). tests shown table
planning problems max. step length minimal plan. cut-off time
2 hours dec reasoner terminate within time problems. fact, entire time spent SAT encoding SAT solver never
called. hand, ASP grounder gringo took seconds ground
domain and, unlike Figure 5, solvers took much time grounder.
see, cmodels minisat performed better clasp two problems.
check time taken minisat encoding generated dec reasoner,
ran ZooTest1 completion. dec reasoner terminated 116578.1 seconds (32.38
hours).

Appendix C. Proofs
C.1 Review Useful Theorems
review theorems Ferraris et al. (2011) Ferraris et al. (2009)
used prove main results. fact, provide version splitting theorem
slightly general one given Ferraris et al. (2009), order
facilitate proof efforts.
Lemma 1 Formula
u p ((F ) (u) F )
logically valid.
Theorem 12 (Ferraris et al., 2011, Thm. 2) first-order formula F
disjoint lists p, q distinct predicate constants,
SM[F ; p] SM[F Choice(q); p q]
logically valid.
Let F first-order formula. rule F implication occurs strictly positively
F . predicate dependency graph F (relative p) directed graph
members p vertices,
edge p q if, rule G H F ,
p strictly positive occurrence H,
q positive occurrence G belong subformula G
negative p.
Theorem 13 (Ferraris et al., 2009, Splitting Thm.) Let F , G first-order sentences,
let p, q finite disjoint lists distinct predicate constants.
606

fiReformulating Situation Calculus Event Calculus

(a) strongly connected component predicate dependency graph F G relative
p, q either subset p subset q,
(b) F negative q,
(c) G negative p

SM[F G; p q] SM[F ; p] SM[G; q]
logically valid.
theorem slightly general one Ferraris et al. (2009)
notion dependency graph yields less edges one given Ferraris et al.
Instead
q positive occurrence G belong subformula G
negative p,
Ferraris et al.s definition
q positive occurrence G belong subformula
form K.
instance, according Ferraris et al., dependency graph
((p q) r) p

(38)

relative p two edges (from p r, p p), dependency graph
according definition edges.
hand, generalization essential view following theorem.
Theorem 14 (Ferraris et al., 2009, Thm. Double Negations) Let H sentence, F
subformula H, H sentence obtained H inserting front F .
occurrence F p-negated H, SM[H; p] equivalent SM[H ; p].
instance, SM[(38); p] equivalent SM[((p q) r) p; p]. dependency
graph ((p q) r) p relative p according definition Ferraris et al.
identical dependency graph (38) relative p according definition.
Next, say formula F Clark normal form (relative list p intensional
predicates) conjunction sentences form
x(G p(x)),

(39)

one intensional predicate p, x list distinct object variables, G
free variables x. completion (relative p) formula F
Clark normal form obtained replacing conjunctive term (39)
x(p(x) G).
following theorem relates SM completion. say F tight p
predicate dependency graph F relative p acyclic.
Theorem 15 (Ferraris et al., 2011) formula F Clark normal form tight
p, formula SM[F ; p] equivalent completion F relative p.
607

fiLee & Palla

C.2 Proof Proposition 1
Using Theorem 12 Theorem 13,
SM[F ; p] SM[F ; p pr (F )] SM[>; p\pr (F )]
SM[F ; p pr (F )] False(p\pr (F ))
SM[F Choice(pr (F )\p)] False(p\pr (F ))
SM[F Choice(pr (F )\p) False(p\pr (F ))].

C.3 Proof Theorem 1
following, F formula, p list distinct predicate constants p1 , . . . , pn , u
list distinct predicate variables u1 , . . . , un length p.
Lemma 2 (Ferraris et al., 2011, Lemma 5) Formula
u p (F (u) F )
logically valid.
Lemma 3 every occurrence every predicate constant p strictly positive F ,
(u p) (F (u) F (u))
logically valid.
Proof. induction. show case F G H. cases
straightforward. Consider
F (u) = (G (u) H (u)) (G H).
Since every occurrence predicate constants p F strictly positive, G contains
predicate constants p, G (u) equivalent G(u),
G. Also, I.H., H (u) H(u) logically valid. Therefore sufficient prove
assumption u p,
(G H(u)) (G H) (G H(u))
logically valid. left right clear. Assume (u p), G H(u), G. get
H(u), equivalent H (u) I.H. Lemma 2, conclude H.

proof Theorem 1 immediate following lemma, proved
induction.
Lemma 4 F canonical relative p, formula
(u p) F (F (u) F (u))
logically valid.
608

fiReformulating Situation Calculus Event Calculus

Proof.
F atomic formula. Trivial.
F = G H. Follows I.H.
F = G H. Assume (u p) (G H). Since G H canonical relative p,
every occurrence every predicate constant p strictly positive G H,
that, Lemma 3, G (u) equivalent G(u), H (u) equivalent H(u).
F = G H. Assume (u p) (G H). sufficient show
(G (u) H (u)) (G(u) H(u)).

(40)

Since G H canonical relative p, every occurrence every predicate constant
p G strictly positive G, that, Lemma 3, G (u) equivalent
G(u).
Case 1: G. Lemma 2, G (u). claim follows since G (u) equivalent
G(u).
Case 2: H. I.H. H (u) equivalent H(u). claim follows since G (u)
equivalent G(u).
F = xG. Follows I.H.
F = xG. Since every occurrence every predicate constant p G strictly
positive G, claim follows Lemma 3.

C.4 Proof Theorem 2
Proof. (a) (b):
(b) (c):

Follows immediately Theorem 1.

Note first equivalent SM[; ]. Since

every strongly connected component dependency graph relative
{I, T, R, H} either belongs {I, T, R} {H},
negative {H},
negative {I, T, R},
follows Theorem 13 (b) equivalent
SM[ ; I, T, R, H] SM[; Ab1 , . . . , Abn ] SM[; ]
Similarly, applying Theorem 13 repeatedly, show formula
equivalent (c).
(c) (d):

Proposition 1.



609

fiLee & Palla

C.5 Proof Theorem 3
Since Dcaused canonical relative Caused , Theorem 1, (a)

(a) (b):
equivalent


SM[Dcaused ; Caused ] Dposs Drest
(22).

(41)

Consequently, sufficient prove claim that, assumption Sit(s),
formula (22) equivalent SM[Dsit ; Sit].
First note assumption, (22) equivalently rewritten

p p(S0 ) a, s(p(s) p(do(a, s))) p = Sit .
(42)
hand, Sit(s), SM[Dsit ; Sit] equivalent
Sit(S0 ) a, s(Sit(s) Sit(do(a, s)))

p p < Sit (p(S0 ) a, s(p(s) p(do(a, s))) a, s(Sit(s) Sit(do(a, s)))) ,
which, assumption Sit(s), equivalent
p p(S0 ) a, s(p(s) p(do(a, s))) (p < Sit)



furthermore (42).
(b) (c): Since (s) contain Poss, equivalence follows
equivalence completion stable model semantics.
(c) (d): Since Dcaused contains strictly positive occurrence Poss
Dposs contains occurrence Caused , every strongly connected component
predicate dependency graph Dcaused Dposs relative {Caused , Poss} either belongs
{Caused } belongs {Poss}. Theorem 13, follows (b) equivalent

SM[Dcaused Dposs ; Caused , Poss] Drest
SM[Dsit ; Sit].

Similarly, applying Theorem 13 two times, get formula equivalent
(c).

C.6 Proof Theorem 4
Theory
Deffect Dprecond DS0 Duna Dinertia Dexogenous0 ,
corresponding BAT
Dss Dap DS0 Duna .
Without loss generality, assume already equivalently rewritten
exactly one positive effect axiom exactly one negative effect axiom fluent R,
exactly one action precondition axiom action A.
610

fiReformulating Situation Calculus Event Calculus

Consider
SM[ Deffect Dprecond DS0 Duna Dinertia Dexogenous0 ; Poss, Holds, Holds].
Since Duna negative intensional predicates, formula equivalent
SM[Deffect Dprecond DS0 Dinertia Dexogenous0 ; P oss, Holds, Holds] Duna .
(43)
Since P oss occur
Deffect DS0 Dinertia Dexogenous0 ,
since Dprecond negative {Holds, Holds}, Theorem 13, (43) equivalent
SM[Deffect DS0 Dinertia Dexogenous0 ; Holds, Holds]
SM[Dprecond ; P oss] Duna ,

(44)

equivalent
SM[Deffect DS0 Dinertia Dexogenous0 ; Holds, Holds]
Dap Duna .
Therefore statement theorem proven showing following:

|= x s(+
R (x, a, s) R (x, a, s))

(45)

|=

(46)

SM[DS0 Dexogenous0 Deffect Dinertia ; Holds, Holds]

(47)

every fluent R,
satisfies

iff I| satisfies
DS0 Dss .
Dexogenous0 , follows (47) equivalent
SM[DS
Dexogenous0 Deffect Dinertia ; Holds, Holds],
0

(48)

DS
formula obtained DS0 prepending occurrences Holds.
0
assumption (46),
DS
Dexogenous0 Deffect Dinertia
0
{Holds}-atomic-tight w.r.t. I, 26 relationship completion SM
stated Corollary 11 (Lee & Meng, 2011), |= (48) iff satisfies
DS0 , and, fluent R,
26. See Section 7 work Lee Meng (2011) definition.

611

fiLee & Palla

Holds(R(x), do(a, s)) +
R (x, a, s) (Holds(R(x, s) Holds(R(x), do(a, s)))

(49)


Holds(R(x), do(a, s))
R (x, a, s) (Holds(R(x), s) Holds(R(x), do(a, s))), (50)
x, a, (lists of) object names corresponding sorts.
remains show that, assumption (45), satisfies (49) (50) iff I| satisfies

Holds(R(x), do(a, s)) +
R (x, a, s) (Holds(R(x), s) R (x, a, s)).

(51)

following use following facts.
|=Holds(R(x), s) iff I| 6|= Holds(R(x), s).
F ground formula contain , |= F iff I| |= F .
Left Right: Assume |= (49) (50).
Case 1: I| |= Holds(R(x), do(a, s)). Clearly, |= Holds(R(x), do(a, s)), that,
(49), two subcases consider.
Subcase 1: |= +
R (x, a, s). Clearly, I| satisfies LHS RHS (51).
Subcase 2: |= Holds(R(x), s). (50), follows 6|=
R (x, a, s),
(x,
a,
s).
Clearly,
I|
satisfies

LHS

RHS (51).
consequently, I| 6|=

R
Case 2: I| 6|= Holds(R(x), do(a, s)). follows (49) 6|= +
R (x, a, s),
(x,
a,
s).

since

|=Holds(R(x),
do(a, s)),
equivalent saying I| 6|= +
R
(50), two subcases consider.
Subcase 1: |=
R (x, a, s). Clearly, I| satisfies neither LHS RHS (51).
Subcase 2: |= Holds(R(x), s). equivalent saying I| 6|=
Holds(R(x), s). Clearly, I| satisfies neither LHS RHS (51).
Right Left: Assume I| |= (51).
Case 1: |= Holds(R(x), do(a, s)). follows (51) I| satisfies RHS (51),
two subcases consider.
Subcase 1: I| |= +
R (x, a, s). Clearly, satisfies LHS RHS (49).
(45), follows 6|=
R (x, a, s). Consequently, satisfies neither
LHS RHS (50).
Subcase 2: I| |= Holds(R(x), s)
R (x, a, s). Clearly, satisfies LHS
RHS (49). Since 6|=
(x,
a,
s),

satisfies neither LHS RHS (50).
R
Case 2: |=Holds(R(x), do(a, s)). follows (51) I| 6|= +
R (x, a, s),
I| 6|= (Holds(R(x), s)
(x,
a,
s)).


latter,
consider

two
subcases.
R
612

fiReformulating Situation Calculus Event Calculus

Subcase 1: I| 6|= Holds(R(x), s). Clearly, satisfies neither LHS RHS
(49), satisfies LHS RHS (50).
Subcase 2: I| 6|=
R (x, a, s). Clearly, satisfies neither LHS RHS (49),
satisfies LHS RHS (50).

C.7 Proof Proposition 2
Lemma 5 Let F formula, let p list distinct predicate constants, let G
subformula F let G0 formula classically equivalent G. Let F 0
formula obtained F substituting G0 G. occurrence G subformula
F negative p occurrence G0 subformula F 0 negative
p,
SM[F ; p] SM[F 0 ; p]
logically valid.
Proof. Let F formula obtained F prepending G, let (F 0 )
formula obtained F 0 prepending G0 . Theorem Double
Negations (Theorem 14), following formulas logically valid.
SM[F ; p] SM[F ; p],
SM[F 0 ; p] SM[(F 0 ) ; p].
Lemma 1, follows
(u p (G G0 )) ((F ) (u) ((F 0 ) ) (u))
logically valid, u list predicate variables corresponding p. Consequently,
SM[F ; p] SM[(F 0 ) ; p]
logically valid.



Proof Proposition 2. formula
SM[F 0 xy(G(y, x) q(x)); p, q],

(52)

clearly, F 0 negative q xy(G(y, x) q(x)) negative p. Let H
subformula F negative p contains occurrence yG(y, x). Consider
two cases.
Case 1: occurrence yG(y, x) H strictly positive. Thus dependency
graph F 0 xy(G(y, x) q(x)) relative {p, q} incoming edges q.
Case 2: occurrence yG(y, x) H strictly positive. Since H negative p, yG(y, x) negative p well, dependency graph
F 0 xy(G(y, x) q(x)) relative {p, q} outgoing edges q.
613

fiLee & Palla

Therefore, every strongly connected component dependency graph belongs either
p {q}. Consequently, Theorem 13, (52) equivalent
SM[F 0 ; p] SM[xy(G(y, x) q(x)); q]

(53)

Since yG(y, x) negative q, formula xy(G(y, x) q(x)) tight {q}. Theorem 15, (53) equivalent
SM[F 0 ; p] x(yG(y, x) q(x)).

(54)

Lemma 5, follows (54) equivalent
SM[F ; p] x(yG(y, x) q(x)).
Consequently, claim follows.



C.8 Proof Theorem 6
clear algorithm terminates yields quantifier-free formula K.
prove SM[F ; p] SM[xK; p q], x list (free) variables K.
Let F formula obtained initial formula F prepending double
negations front every maximal strictly positive occurrence formulas form
yG(x, y). Since F almost universal relative p, occurrence subformula
F negative p. Thus Theorem Double Negations (Theorem 14),
SM[F ; p] equivalent SM[F ; p]. Note F contains strictly positive occurrence
formulas form yG(x, y).
iteration, let us assume formula iteration
H0 Hn ,
H0 transformed F previous iterations, Hi (i > 0)
formula form G(x, y) pG (x) introduced Step (b). Initially H0 F
n = 0. Let r0 p, let ri pG Hi (i > 0). induction prove

(i) every positive occurrence formulas form yG(x, y) Hi strictly positive, subformula Hi negative ri ;
(ii) every negative occurrence formulas form yG(x, y) Hi subformula
Hi negative ri .
prove Step (a) Step (c) applied turn Hk Hk0 ,
SM[x0 H0 ; r0 ] SM[xn Hn ; rn ]

(55)

SM[x00 H00 ; r0 ] SM[x0n Hn0 ; rn ],

(56)

equivalent
Hj0 = Hj j different k, xi (i 0) list free variables
Hi , x0i (i 0) list free variables Hi0 .
614

fiReformulating Situation Calculus Event Calculus

Indeed, Step (a) part prenex form conversion, preserves strong equivalence
(Theorem 5). clear (55) equivalent (56).
Step (c) applied turn (55) (56), since yH(x, y) subformula
Hk negative rk , equivalence (55) (56) follows Lemma 5.
Step (b) applied turn Hk Hk0 introduces new conjunctive term
0
Hn+1 , formula (55) (, r1 , . . . , rn )-equivalent
0
SM[x00 H00 ; r0 ] SM[x0n Hn0 ; rn ] SM[x0n+1 Hn+1
; rn+1 ]

(57)

Proposition 2 due condition (i).
Let
00
H000 Hm

(58)

final quantifier-free formula, H000 transformed F . induction,
follows SM[F ; p] -equivalent
00
SM[x000 H000 ; r0 ] SM[x00m Hm
; rm ],

(59)

x00i (0 m) list free variables Hi00 .
Since every non-strictly positive occurrence new predicate ri (i > 0) Hj00 (0
j m) positive, incoming edge ri dependency graph (58) relative
r0 , r1 , . . . , rm . Consequently, every strongly connected component dependency
graph belongs one ri (i 0). Moreover, clear Hi00 (i 0) negative
every rj j 6= i. (In case H000 , recall occurrence rj j > 0
strictly positive since F , H000 obtained, contains strictly positive
occurrence formulas form yG(x, y).) Thus splitting theorem (Theorem 13),
formula (59) equivalent
00
SM[x000 H000 x00m Hm
; r0 rm ].

(60)


C.9 Proof Theorem 7
use notations introduced proof Theorem 6. Theorem 6, SM[F ; p]
-equivalent (60) and, Theorem 12, (60) equivalent
00
SM[x000 H000 x00m Hm
Choice( pred \ p); pred r1 rm ]

(61)

(r0 p), pred set predicate constants signature . follows
Proposition 3 (Cabalar et al., 2005) (61) equivalent
000
SM[x000 H0000 x00m Hm
Choice( pred \ p); pred r1 rm ],

(62)

Hi000 obtained Hi00 applying translation (Cabalar et al., 2005,
Section 3) turns quantifier-free formula set rules. easy see F 0
formula
000
x000 H0000 x00m Hm
Choice( pred \ p)

615

fiLee & Palla

pred r1 rm p pr (F 0 ), (62) written
SM[F 0 ; p pr (F 0 )],
equivalent
SM[F 0 False(p \ pr (F 0 ))].
Proposition 1.



C.10 Proof Theorem 8
Assume
CIRC[; Initiates, Terminates, Releases] CIRC[; Happens]
CIRC[; Ab 1 , . . . , Ab n ] ,
equivalent
SM[; Initiates, Terminates, Releases] SM[; Happens]
SM[; Ab 1 , . . . , Ab n ]

(63)

Theorem 2.
Let def set definitions (35) , let 0 formula obtained
applying Step 1. Theorem 15, follows formula (35) def equivalent

SM[x(G0 p(x)); p],
G0 described Step 1. Consequently, (63) equivalent
SM[; Initiates, Terminates,
V Releases] SM[; Happens]
SM[; Ab 1 , . . . , Ab n ] (35)def SM[x(G0 p(x)); p] 00 ,

(64)

00 conjunction axioms 0 ones obtained
definitional axioms (35).
Applying Theorem 13 repeatedly, follows (64) equivalent
V
SM[ 00 (35)def x(G0 p(x));
Initiates, Terminates, Releases, Happens, Ab 1 , . . . , Ab n , p] .

(65)

According syntax event calculus reviewed Section 3.1,
every positive occurrence formula form yG(y) (65) contained
subformula negative
{Initiates, Terminates, Releases, Happens, Ab 1 , . . . , Ab n , p},
negative occurrences formula form yG(y) (65).
Consequently, statement theorem follows Theorem 7.

616



fiReformulating Situation Calculus Event Calculus

C.11 Proof Theorem 9
Since (37) almost universal relative {Caused , Poss, Sit}, result follows Theorems 7 3.

C.12 Proof Theorem 10
Dexogenous0 , follows SM[T ; Holds, Holds, Poss] equivalent
SM[T ; Holds, Holds, Poss], obtained prepending
occurrences Holds DS0 . definition uniform formula (Reiter, 2001),
follows almost universal relative {Holds, Holds, Poss}. result follows
Theorem 7.


References
Akman, V., Erdogan, S., Lee, J., Lifschitz, V., & Turner, H. (2004). Representing Zoo
World Traffic World language Causal Calculator. Artificial
Intelligence, 153(12), 105140.
Belleghem, K. V., Denecker, M., & Schreye, D. D. (1995). Combining situation calculus
event calculus. Proceedings International Conference Logic Programming
(ICLP), pp. 8397.
Belleghem, K. V., Denecker, M., & Schreye, D. D. (1997). relation situation
calculus event calculus. Journal Logic Programming, 31 (1-3), 337.
Besnard, P., & Cordier, M.-O. (1994). Explanatory diagnoses characterization
circumscription. Annals Mathematics Artificial Intelligence, 11 (1-4), 7596.
Cabalar, P., & Ferraris, P. (2007). Propositional theories strongly equivalent logic
programs. Theory Practice Logic Programming, 7 (6), 745759.
Cabalar, P., Pearce, D., & Valverde, A. (2005). Reducing propositional theories equilibrium logic logic programs. Proceedings Portuguese Conference Artificial
Intelligence (EPIA), pp. 417.
Calimeri, F., Cozza, S., Ianni, G., & Leone, N. (2008). Computable functions ASP: theory
implementation. Proceedings International Conference Logic Programming (ICLP), pp. 407424.
Denecker, M., & Ternovska, E. (2007). Inductive situation calculus. Artificial Intelligence,
171 (5-6), 332360.
Denecker, M., & Ternovska, E. (2008). logic nonmonotone inductive definitions. ACM
Transactions Computational Logic, 9 (2).
Doherty, P., Gustafsson, J., Karlsson, L., & Kvarnstrom, J. (1998). TAL: Temporal action
logics language specification tutorial. Linkoping Electronic Articles Computer
Information Science ISSN 1401-9841, 3 (015). http://www.ep.liu.se/ea/cis/
1998/015/.
617

fiLee & Palla

Dogandag, S., Ferraris, P., & Lifschitz, V. (2004). Almost definite causal theories..
Proceedings International Conference Logic Programming Nonmonotonic
Reasoning (LPNMR), pp. 7486.
Erdem, E., & Lifschitz, V. (2003). Tight logic programs. Theory Practice Logic
Programming, 3, 499518.
Fages, F. (1994). Consistency Clarks completion existence stable models. Journal
Methods Logic Computer Science, 1, 5160.
Ferraris, P., Lee, J., & Lifschitz, V. (2007). new perspective stable models. Proceedings International Joint Conference Artificial Intelligence (IJCAI), pp. 372379.
Ferraris, P., Lee, J., & Lifschitz, V. (2011). Stable models circumscription. Artificial
Intelligence, 175, 236263.
Ferraris, P., Lee, J., Lifschitz, V., & Palla, R. (2009). Symmetric splitting general
theory stable models. Proceedings International Joint Conference Artificial
Intelligence (IJCAI), pp. 797803.
Gebser, M., Schaub, T., & Thiele, S. (2007). Gringo : new grounder answer set
programming. Proceedings International Conference Logic Programming
Nonmonotonic Reasoning (LPNMR), pp. 266271.
Gelfond, M., & Lifschitz, V. (1988). stable model semantics logic programming.
Kowalski, R., & Bowen, K. (Eds.), Proceedings International Logic Programming
Conference Symposium, pp. 10701080. MIT Press.
Gelfond, M., & Lifschitz, V. (1998). Action languages. Electronic Transactions Artificial
Intelligence, 3, 195210. http://www.ep.liu.se/ea/cis/1998/016/.
Giunchiglia, E., Lee, J., Lifschitz, V., McCain, N., & Turner, H. (2004). Nonmonotonic
causal theories. Artificial Intelligence, 153(12), 49104.
Heyting, A. (1930). Die formalen Regeln der intuitionistischen Logik. Sitzungsberichte
der Preussischen Akademie von Wissenschaften. Physikalisch-mathematische Klasse,
4256.
Janhunen, T., & Oikarinen, E. (2004). Capturing parallel circumscription disjunctive
logic programs. Proc. 9th European Conference Logics Artificial Intelligence
(JELIA-04), pp. 134146.
Kautz, H., & Selman, B. (1992). Planning satisfiability. Proceedings European
Conference Artificial Intelligence (ECAI), pp. 359363.
Kim, T.-W., Lee, J., & Palla, R. (2009). Circumscriptive event calculus answer set programming. Proceedings International Joint Conference Artificial Intelligence
(IJCAI), pp. 823829.
Kowalski, R., & Sergot, M. (1986). logic-based calculus events. New Generation
Computing, 4, 6795.
Kowalski, R. A., & Sadri, F. (1997). Reconciling event calculus situation
calculus. Journal Logic Programming, 31 (1-3), 3958.
618

fiReformulating Situation Calculus Event Calculus

Lee, J., Lifschitz, V., & Palla, R. (2008). reductive semantics counting choice
answer set programming. Proceedings AAAI Conference Artificial
Intelligence (AAAI), pp. 472479.
Lee, J., & Lin, F. (2006). Loop formulas circumscription. Artificial Intelligence, 170 (2),
160185.
Lee, J., & Meng, Y. (2011). First-order stable model semantics first-order loop formulas.
Journal Artificial Inteligence Research (JAIR), 42, 125180.
Lee, J., & Palla, R. (2007). Yet another proof strong equivalence propositional
theories logic programs. Working Notes Workshop Correspondence
Equivalence Nonmonotonic Theories.
Lee, J., & Palla, R. (2010). Situation calculus answer set programming. Proceedings
AAAI Conference Artificial Intelligence (AAAI), pp. 309314.
Lifschitz, V. (1994). Circumscription. Gabbay, D., Hogger, C., & Robinson, J. (Eds.),
Handbook Logic AI Logic Programming, Vol. 3, pp. 298352. Oxford University Press.
Lifschitz, V. (2008). answer set programming?. Proceedings AAAI Conference Artificial Intelligence, pp. 15941597. MIT Press.
Lifschitz, V. (2011). Datalog programs stable models. de Moor, O., Gottlob,
G., Furche, T., & Sellers, A. (Eds.), Datalog Reloaded: First International Workshop,
Datalog 2010, Oxford, UK, March 16-19, 2010. Revised Selected Papers. Springer.
Lifschitz, V., Pearce, D., & Valverde, A. (2001). Strongly equivalent logic programs. ACM
Transactions Computational Logic, 2, 526541.
Lifschitz, V., Tang, L. R., & Turner, H. (1999). Nested expressions logic programs. Annals
Mathematics Artificial Intelligence, 25, 369389.
Lifschitz, V., & Turner, H. (1999). Representing transition systems logic programs.
Proceedings International Conference Logic Programming Nonmonotonic
Reasoning (LPNMR), pp. 92106.
Lin, F. (1995). Embracing causality specifying indirect effects actions. Proceedings International Joint Conference Artificial Intelligence (IJCAI), pp. 1985
1991.
Lin, F. (2003). Compiling causal theories successor state axioms STRIPS-like systems. Journal Artificial Intelligence Research, 19, 279314.
Lin, F., & Shoham, Y. (1992). logic knowledge justified assumptions. Artificial
Intelligence, 57, 271289.
Lin, F., & Wang, K. (1999). causal theories logic programs (sometimes).
Proceedings International Conference Logic Programming Nonmonotonic
Reasoning (LPNMR), pp. 117131.
Lin, F., & Zhou, Y. (2011). answer set logic programming circumscription via logic
GK. Artificial Intelligence, 175, 264277.
619

fiLee & Palla

Marek, V., & Truszczynski, M. (1999). Stable models alternative logic programming
paradigm. Logic Programming Paradigm: 25-Year Perspective, pp. 375398.
Springer Verlag.
McCarthy, J. (1980). Circumscriptiona form non-monotonic reasoning. Artificial Intelligence, 13, 2739,171172.
McCarthy, J. (1986). Applications circumscription formalizing common sense knowledge. Artificial Intelligence, 26 (3), 89116.
McCarthy, J., & Hayes, P. (1969). philosophical problems standpoint
artificial intelligence. Meltzer, B., & Michie, D. (Eds.), Machine Intelligence, Vol. 4,
pp. 463502. Edinburgh University Press, Edinburgh.
Miller, R., & Shanahan, M. (1999). event calculus classical logic - alternative axiomatisations. Electronic Transactions Artificial Intelligence, 3 (A), 77105.
Mueller, E. (2006). Commonsense reasoning. Morgan Kaufmann.
Mueller, E. T. (2004). Event calculus reasoning satisfiability. Journal Logic
Computation, 14 (5), 703730.
Niemela, I. (1999). Logic programs stable model semantics constraint programming
paradigm. Annals Mathematics Artificial Intelligence, 25, 241273.
Pearce, D., & Valverde, A. (2005). first order nonmonotonic extension constructive
logic. Studia Logica, 80, 323348.
Provetti, A. (1996). Hypothetical reasoning actions: situation calculus event
calculus. Computational Intelligence, 12, 478498.
Reiter, R. (1980). logic default reasoning. Artificial Intelligence, 13, 81132.
Reiter, R. (1991). frame problem situation calculus: simple solution (sometimes) completeness result goal regression. Lifschitz, V. (Ed.), Artificial
Intelligence Mathematical Theory Computation: Papers Honor John McCarthy, pp. 359380. Academic Press.
Reiter, R. (2001). Knowledge Action: Logical Foundations Specifying Implementing Dynamical Systems. MIT Press.
Shanahan, M. (1995). circumscriptive calculus events. Artif. Intell., 77 (2), 249284.
Shanahan, M. (1997). Solving Frame Problem: Mathematical Investigation
Common Sense Law Inertia. MIT Press.
Shanahan, M. (1999). event calculus explained. Artificial Intelligence Today, LNCS
1600, pp. 409430. Springer.
Shanahan, M., & Witkowski, M. (2004). Event calculus planning satisfiability.
Journal Logic Computation, 14 (5), 731745.
Syrjanen, T. (2004). Cardinality constraint programs.. Proceedings European Conference Logics Artificial Intelligence (JELIA), pp. 187199.
Zhang, H., Zhang, Y., Ying, M., & Zhou, Y. (2011). Translating first-order theories logic
programs. Proceedings International Joint Conference Artificial Intelligence
(IJCAI), pp. 11261131.

620


