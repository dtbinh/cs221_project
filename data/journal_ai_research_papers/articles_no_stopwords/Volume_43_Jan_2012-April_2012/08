journal artificial intelligence

submitted published

local consistency sat solvers
peter jeavons
justyna petke

peter jeavons cs ox ac uk
justyna petke cs ox ac uk

department computer science university oxford
wolfson building parks road oxford ox qd uk

abstract
local consistency techniques k consistency key component specialised
solvers constraint satisfaction power
k consistency techniques constraint satisfaction precisely captured
particular inference rule call negative hyper resolution standard
direct encoding boolean clauses current clauselearning sat solvers discover expected polynomial time inconsistency
deduced given set clauses negative hyper resolvents fixed size
combine two without explicitly designed current
clause learning sat solvers efficiently simulate k consistency techniques fixed values
k give experimental feature allows clause learning
sat solvers efficiently solve certain families constraint challenging
conventional constraint programming solvers

introduction
one oldest central ideas constraint programming going right back
montanaris original idea local consistency techniques prune
search space bessiere idea arc consistency introduced mackworth
generalised k consistency freuder modern constraint solvers
generally employ specialised propagators prune domains variables achieve
form generalised arc consistency typically attempt enforce higher levels
consistency path consistency
contrast software tools developed solve propositional satisfiability
known sat solvers generally use logical inference techniques unit propagation
clause learning prune search space
one surprising empirical findings last years remarkably good performance general sat solvers solving constraint satisfaction
apply tools constraint satisfaction one first translate instance set clauses form boolean encoding tamura taga kitagawa
banbara walsh encoding techniques tend obscure structure original may introduce large number boolean variables
clauses encode quite easily stated constraints nevertheless quite cases
approaches performed traditional constraint solving tools van dongen
lecoutre roussel petke jeavons
c

ai access foundation rights reserved

fijeavons petke

draw number recent analytical approaches try account
good performance general sat solvers many forms constraint
building atserias bulatov dalmau atserias dalmau
hwang mitchell power k consistency
techniques constraint precisely captured single inference rule
standard boolean encoding refer inference rule negativehyper resolution conclusions deduced enforcing k consistency
deduced sequence negative hyper resolution inferences involving boolean clauses
original instance negative hyper resolvents k literals furthermore
atserias fichte thurley pipatsrisawat
darwiche current clause learning sat solvers mimic effect
deductions polynomial expected time even random branching strategy hence
although explicitly designed running clause learning
sat solver straightforward encoding constraint efficiently simulates
effects enforcing k consistency values k

preliminaries
section give background definitions used throughout
rest
constraint satisfaction k consistency
definition instance constraint satisfaction csp specified
triple v c
v finite set variables
dv v v set dv set possible values variable v
called domain v
c finite set constraints constraint c pair ri si
si ordered list mi variables called constraint scope
ri relation arity mi called constraint relation
given csp instance v c partial assignment mapping f

subset w v dv f v dv v w partial assignment satisfies
constraints instance r v v vm c vj w
j f v f v f vm r partial assignment satisfies
constraints instance called partial solution instance set
variables partial assignment f defined called domain f denoted
dom f partial solution g extends partial solution f dom g dom f
g v f v v dom f partial solution domain v called solution
one way derive information csp instance may help determine
whether solution use form constraint propagation enforce
note partial solutions extend solutions



filocal consistency sat solvers

level local consistency bessiere example possible use notion
k consistency defined note several different equivalent ways
define enforce k consistency described literature bessiere cooper
freuder presentation follows atserias et al inspired
notion existential k pebble games introduced kolaitis vardi
definition atserias et al csp instance p k consistency closure
p set h partial assignments obtained following
let h collection partial solutions f p dom f k
every f h dom f k every variable v p g h
g extends f v dom g remove f extensions h
repeat step h unchanged
note computing k consistency closure according definition corresponds
precisely enforcing strong k consistency according definitions given bessiere
cooper freuder
throughout shall assume domain possible values
variable csp instance finite straightforward fixed k
fixed maximum domain size k consistency closure instance p
computed polynomial time atserias et al cooper
note solution p must extend element k consistency closure
p hence k consistency closure p empty k p solutions
converse true general holds certain special cases class
instances whose structure tree width bounded k atserias et al class
instances whose constraint relations relations defined cooper cohen
jeavons connected row convex relations defined deville barette
hentenryck special kinds instances possible determine
polynomial time whether solution exists simply computing k consistency
closure appropriate choice k moreover solution exists
constructed polynomial time selecting variable turn assigning possible
value computing k consistency closure retaining assignment gives
non empty
following gives useful condition determining whether k consistency
closure csp instance empty
lemma kolaitis vardi k consistency closure csp instance p
non empty exists non empty family h partial solutions p

f h dom f k
f h f extends g g h
f h dom f k v
dom f variable p
g h g extends f v dom g
set partial solutions h satisfying conditions described lemma sometimes
called strategy instance p barto kozik kolaitis vardi


fijeavons petke

encoding csp instance propositional formula
one possible solving csp instance encode propositional formula
suitable set boolean variables use program decide satisfiability
formula many programs known sat solvers available
often efficiently handle thousands sometimes even millions boolean
variables zhang malik
several different ways encoding csp instance propositional formula
proposed prestwich tamura et al walsh
consider one common family encodings known sparse encodings term
introduced hoos csp instance p v c sparse encoding
introduces set boolean variables form xvi v v dv
boolean variable xvi assigned true original variable v assigned
value say partial assignment f falsifies clause c c consists entirely
literals form xvf v variables v dom f otherwise say partial
assignment f satisfies clause c
example let p csp instance v u v w du dv dw
c contains single ternary constraint scope u v w specifying
u v w sparse encoding p introduce seven boolean variables
xu xu xv xv xw xw xw
sparse encodings usually contain certain clauses known least one one
clauses ensure variable v assigned value say value
w
j assigned v least one clauses form idv xvi variable
v one clauses represented set binary clauses xvi xvj
j dv j
example case csp instance example least one clauses
xu xu xv xv xw xw xw
one clauses
xu xu xv xv xw xw xw xw xw xw
different sparse encodings differ way encode constraints
csp instance two methods commonly used first one encodes disallowed
variable assignments called conflicts goods direct encoding prestwich
w
instance generates clause vs xvf v partial assignment f
satisfy constraint r c direct encoding ternary constraint
example would encoded following clauses
xu xv xw
xu xv xw
xu xv xw
xu xv xw


filocal consistency sat solvers

xu xv xw
xu xv xw
xu xv xw
xu xv xw
another way translating constraints clauses encode allowed variable
assignments called supports used basis encoding
binary csp instances known support encoding gent defined follows
pair variables v w scope constraint value dv
w
support encoding contain clause xvi ja xwj dw set
values variable w compatible assignment v according
constraint
note support encoding defined binary csp instances however
non binary constraints decomposed binary ones without introducing
variables instance ternary constraint example decomposed two
binary constraints specifying u v v w support encoding
binary constraints would represented following clauses
xu xv xv xu xv xv xu xv xu xu
xv xw xw xv xw xw xw xv xw xv xv
inference rules
given set clauses often deduce clauses applying certain inference
rules example two clauses form c x c x possibly
empty clauses c c variable x deduce clause c c
form inference known propositional resolution resultant clause called
resolvent robinson
next section shall establish close connection k consistency
form inference called negative hyper resolution buning lettmann
define follows
definition collection clauses form ci xi r
clause c x x xr xi boolean variable c
ci possibly empty disjunction negative literals deduce clause
c c cr
call form inference negative hyper resolution resultant clause
c c cr negative hyper resolvent
case c empty negative hyper resolution rule equivalent
nogood resolution rule described hwang mitchell well h k rule
introduced de kleer nogood recording scheme described schiex
verfaillie
note inference obtained negative hyper resolution obtained
sequence standard resolution steps however reason introducing negative hyperresolution allows us deduce clauses need single step without needing
introduce intermediate clauses may contain r literals


fijeavons petke

negative hyper resolvent restricting size clauses use way
able obtain better performance bounds sat solvers
example assume collection clauses form ci xi r
clause c x x xr specified definition ci c
negative hyper resolvent set clauses c
clause c obtained sequence standard resolution steps follows
first resolve c x x xr c xr obtain c x x xr
resolve next clause c xr clauses finally
obtain c however case intermediate clause c x x xr contains
r literals negative hyper resolvent
example note good clauses direct encoding binary csp instance
obtained single negative hyper resolution step appropriate support
clause support encoding together appropriate collection one clauses
let dw set values variable w compatible assignment
w
v support encoding contain clause c xvi ja xwj
values k dw incompatible assignment v form
negative hyper resolvent c one clauses xwk xwj j
obtain corresponding good clause xvi xwk
negative hyper resolution derivation clause c set initial clauses
sequence clauses c c cm cm c ci follows negativehyper resolution rule collection clauses contained
else occurs earlier sequence width derivation defined
maximum size clauses ci cm empty clause say
derivation negative hyper resolution refutation

k consistency negative hyper resolution
pointed many authors enforcing local consistency form
inference relations analogous use resolution rule clauses bacchus
bessiere hwang mitchell rish dechter precise strength
standard resolution inference rule direct encoding csp instance considered
work walsh shown unit resolution one
clauses resolved consists single literal corresponds enforcing weak form
local consistency known forward checking hwang mitchell pointed
standard resolution rule restriction clause length able simulate
inferences made k consistency atserias dalmau showed
standard resolution rule restricted clauses k literals known kresolution rule characterised terms boolean existential k pebble game
follows csp instances boolean domains form inference corresponds
enforcing k consistency alternative proof k resolution achieves k consistency
instances boolean domains given book hooker thm
extend little csp instances arbitrary
finite domains applying negative hyper resolution rule direct encoding obtain


filocal consistency sat solvers

clauses k literals corresponds precisely enforcing k consistency similar
relationship stated work de kleer complete proof given
note bound k impose size negative hyper resolvents
independent domain size words inference rule need
consider inferred clauses size k even though make use clauses
encoding whose size equal domain size may arbitrarily large
theorem k consistency closure csp instance p empty direct
encoding set clauses negative hyper resolution refutation width k
proof broken two lemmas inspired lemmas work
atserias dalmau
lemma let p csp instance let direct encoding set clauses
negative hyper resolution refutation width k less k consistency
closure p non empty
proof let v set variables p v v domain dv let
x xvi v v dv corresponding set boolean variables let
set clauses negative hyper resolution derivation width k
definition negative hyper resolution every non empty clause consists entirely
negative literals
let h set partial assignments p domain size k
falsify clause direct encoding
consider element f h definition h f falsify clause
definition direct encoding every element h partial solution
p furthermore f extends g g element h g makes fewer
assignments f hence cannot falsify additional clauses f
negative hyper resolution refutation width k
contain empty clause h contains least partial solution empty domain
hence h empty
let f element h dom f k let v variable p
dom f partial assignment g extends f dom g
dom f v g h else exists clause
falsified g since g partial assignment clause c falsified g
must consist entirely negative literals hence literals c must form
xwf w w dom f else xvg v moreover clause must contain
literal xvg v else would already falsified f
assume contradiction h contain assignment g extends f
dom g dom f v case dv contains
clause ci consisting negative literals form xwf w w dom f together
literal xvi consider clause c negative hyper resolvent
w
clauses ci least one clause idv xvi clause c consists entirely
negative literals form xwf w w dom f width
dom f k hence element however c falsified f contradicts
choice f hence shown f h dom f k


fijeavons petke

variables v v dom f g h g extends f
v dom g
shown h satisfies conditions required lemma conclude
k consistency closure p non empty


lemma let p csp instance let direct encoding set clauses
k consistency closure p non empty negative hyper resolution
refutation width k less
proof let v set variables p v v domain dv let
x xvi v v dv corresponding set boolean variables
lemma k consistency closure p non empty exists nonempty set h partial solutions p satisfies three properties described
lemma
consider negative hyper resolution derivation width k
induction length derivation elements h falsify
clause derivation first note elements h partial solutions
satisfy constraints p hence falsify clause establishes
base case assume induction clauses derivation earlier
clause c falsified element h
note apart least one clauses clauses consist entirely
negative literals hence may assume without loss generality c negativehyper resolvent set clauses ci xvi dv least one clause
w
idv xvi fixed variable v
f h falsifies c literals c must form xwf w
w dom f since width derivation k c contains k literals
hence may assume dom f k choice h must
exist extension g f h v dom g g falsify
clause contradicts inductive hypothesis hence f h falsifies c
particular c cannot empty
follows negative hyper resolution derivation width k contain
empty clause

note proof theorem applies sparse encoding contains
least one clauses variable clauses purely negative
call encoding negative sparse encoding well direct encoding
negative sparse encodings exist example may use negative clauses involve
subset variables scope constraints forbid tuples possible
extensions complete scope disallowed constraint another example
negative sparse encoding well known variant direct encoding
one clauses omitted
corollary k consistency closure csp instance p empty
negative sparse encoding p negative hyper resolution refutation width k


filocal consistency sat solvers

negative hyper resolution sat solvers
section adapt machinery atserias et al pipatsrisawat
darwiche fixed k existence negative hyper resolution
refutation width k likely discovered sat solver polynomial time
standard clause learning restart techniques even totally random branching
strategy
note previous power clause learning sat solvers generally
assumed optimal branching strategy beame kautz sabharwal pipatsrisawat
darwiche shown solvers potentially capable rather
likely achieve practice important exception
atserias et al gives analysis likely behaviour relies
existence standard resolution proof bounded width
atserias et al extended hyper resolution proofs shorter
narrower associated standard resolution proofs
make use following terminology atserias et al clause
c boolean variable x truth value restriction c assignment
x denoted c x defined constant assignment satisfies clause
else clause obtained deleting c literals involving variable x
sequence assignments form x x xr ar write c
denote computing restriction c assignment turn c
empty say assignments falsify clause c set clauses
write denote set c c
current sat solvers operate following way atserias et al pipatsrisawat darwiche maintain database clauses current state
partial assignment truth values boolean variables clauses
high level description used update clause database
state derived description given atserias et al shown similar framework slightly different terminology given pipatsrisawat darwiche

consider run shown started initial
database empty state halts discovers conflict e
run called complete round started represent sequence
states sm maintains note state si extends
state si single assignment boolean variable may decision
assignment implied assignment
generally round initial segment sr complete round started
state sr sr contains empty clause sr
contain unit clause clause c say round sr satisfies c
c sr say round falsifies c c sr empty
sr round started sr contains empty clause
reports unsatisfiability learns clause round called
conclusive round conclusive call inconclusive note sr
inconclusive round started sr contain empty clause
note complete round assigns variables reports satisfiability called inconclusive



fijeavons petke

contain unit clauses hence clause c sr falsifies
literals c except one must satisfy remaining literal hence satisfy c
property clauses captured following definition
definition atserias et al let set clauses c non empty clause
l literal c say absorbs c l every inconclusive round started
falsifies c l satisfies c
absorbs c literal l c simply say absorbs c
note closely related notion introduced pipatsrisawat darwiche
clauses absorbed set clauses referred empowering
respect exact relationship empowering absorption discussed
atserias et al
explore relationship absorption negative hyper resolution
example let direct encoding csp instance p v c v
u v w du dv dw c contains two binary constraints one forbids
assignment value u v simultaneously forbids simultaneous
assignment value u w let c contain ternary constraint
forbids assignment value three variables simultaneously
xu xu xv xv xw xw
xu xu xv xv xw xw
xu xv xu xw xu xv xw
clause xv xw contained obtained negative hyperresolution clauses xu xu xu xv xu xw
clause absorbed since every inconclusive round sets xv true must
set xw f alse unit propagation every inconclusive round sets xw true
must set xv f alse unit propagation
example indicates clauses obtained negative hyper resolution
set clauses sometimes absorbed next clarifies situation
holds
lemma negative hyper resolvent set disjoint clauses absorbed set
clauses
proof let c negative hyper resolvent set clauses ci xi
r clause c c x x xr ci possibly empty
disjunction negative literals r c c c cr definition
definition must c absorbs c literals assume
one literals c falsified since set clauses c assumed
disjoint remaining literal l must belong exactly one clauses set
two cases consider
l belongs clause c clauses one literals falsified
remaining literal xi clauses set true unit propagation
hence literals c falsified except l l set true unit propagation


filocal consistency sat solvers

l belongs one clauses ci xi remaining clauses
one literals falsified corresponding literals xj set true unit
propagation hence literals c falsified except xi xi set true
unit propagation literals ci xi falsified except l l set
true unit propagation

next example shows negative hyper resolvent set clauses
disjoint necessarily absorbed clauses
example recall set clauses given example direct encoding
csp instance three variables u v w domain
clause xu xv contained obtained negative hyperresolution clauses xw xw xu xv xw xu xw
clause absorbed since inconclusive round sets xv true
necessarily ensure xu f alse unit propagation
basic shall use establish main
clauses obtained bounded width negative hyper resolution given set
clauses immediately absorbed one example likely
become absorbed quite quickly additional clauses added
process clause learning hence clause learning sat solver likely fairly rapidly
absorb clauses derived original database clauses negativehyper resolution particular empty clause derived negative hyperresolution solver fairly rapidly absorb literal complement
hence report unsatisfiability see proof theorem details
following key properties absorption established atserias et al
lemma atserias et al let sets clauses let c c
non empty clauses
c belongs absorbs c
c c absorbs c absorbs c
absorbs c absorbs c
allow analysis need make assumptions learning scheme
restart policy branching strategy used sat solver
learning scheme rule creates adds clause database
whenever conflict clause called conflict clause literals
falsified assignment current state literal falsified th decision
assignment later implied assignment th decision assignment
said falsified level conflict clause contains exactly one literal falsified
maximum possible level called asserting clause pipatsrisawat darwiche
zhang madigan moskewicz malik
assumption learning scheme chooses asserting clause


fijeavons petke

framework typical clause learning sat solver
input set clauses
partial assignment truth values variables
























conflict
contains decision assignments
print unsatisfiable halt
else
apply learning scheme add clause
restart policy says restart
set
else
select recent conflict causing unreversed decision assignment
reverse decision remove later assignments
end
end
else l literal l
unit propagation
add implied assignment x satisfies l
else
decision
apply branching strategy choose decision assignment x
add decision assignment
end
end
print satisfiable output

learning schemes current use satisfy assumption pipatsrisawat darwiche zhang et al including learning schemes called uip decision zhang et al
make particular assumption restart policy however main
phrased terms bound expected number restarts restarts
r conflicts bound expected number restarts simply multiplied
r get bound expected number conflicts means
strongest restarts immediately conflict case
r bound bound expected number conflicts existing satsolvers typically employ aggressive restart policy note remark
work pipatsrisawat darwiche p clear trend
towards frequent restarts modern sat solvers
branching strategy determines decision assignment chosen inconclusive round complete current sat solvers strategy
heuristic measure variable activity related occurrence variable
conflict clauses moskewicz madigan zhao zhang malik however simplify
probabilistic analysis make following assumption



filocal consistency sat solvers

assumption branching strategy chooses variable uniformly random amongst
unassigned variables assigns value true
noted atserias et al analysis give applied
branching strategy randomly chooses making heuristic
decision randomly decision precisely allow say c rounds nonrandom decisions random ones number required restarts conflicts
would appear multiplied factor c
behaves according description satisfies
assumptions called standard randomised sat solver
theorem set non empty clauses n boolean variables negativehyper resolution refutation width k length expected number restarts
requiredby standard randomised sat solver discover unsatisfiable less
mnk nk
proof let c c cm negative hyper resolution refutation width k
cm first occurrence empty clause since clause non empty
cm must derived negative hyper resolution collection negative literals
x x xd purely positive clause x x xd
consider standard randomised sat solver started database
unit clauses xi absorbed current database definition
inconclusive round must assign variables xi false hence falsify
clause x x xd since happens even decision assignments made
sat solver report unsatisfiability
remains bound expected number restarts required clause
ci absorbed let ci negative hyper resolvent clauses
x together clause c c x x x
ci ci cir form cij
j




r
c possibly empty disjunction negative literals assume
clause cij absorbed j r
absorbs ci learning restarts needed assume
absorb ci definition means exists literal l
inconclusive round r started falsifies ci l satisfy ci note
r must leave literal l unassigned one assignment would satisfy ci
hence force literals x used
would falsify c cij
j
negative hyper resolution step satisfied cij absorbed ci
would falsified contradicting fact r inconclusive
hence branching strategy chooses falsify literals ci l whenever
choice construct inconclusive round r l unassigned since
decision assignments r assigned values r implied assignments
r must assigned values r shown r leaves l
unassigned branching strategy chooses falsify remaining literal l ci
would construct conclusive round r ci falsified
see lemmas work atserias et al formal statement proof
assertion



fijeavons petke

decision assignments falsify literals ci hence assumption would
learn asserting clause c add obtain set
since c asserting clause contains exactly one literal l falsified
highest level r hence inconclusive round r started falsifies ci l
falsify one literal c hence force remaining literal l satisfied
unit propagation implied assignment l propagates force l true
r satisfies ci hence absorbs ci l branching strategy
choose falsify remaining literal l ci cause asserting
clause learned added since asserting clause forces literal
satisfied falsifying ci l process repeated fewer n times
certain absorbs ci l
consider sequence k random branching choices first k
falsify literal ci l final choice falsifies l shown
associated round reach conflict add asserting clause random
branching strategy described assumption probability happens
least probability first k random choices consist fixed set variables
order final choice variable associated l number
random choices fall fixed set follows hypergeometric distribution overall

probability n nk
k nk
k
obtain upper bound expected number restarts consider worst case
require n asserting clauses added absorb clause ci k
literals l since require upper bound
treat round independent
n
trial success probability p k k consider worst case
achieve nk successes ensure ci absorbed case
total number restarts follow negative binomial distribution expected value
nk p hence cases expected number restarts less mnk nk
tighter bound number restarts obtained focus decision
learning scheme atserias et al zhang et al next indicates
theorem set non empty clauses n boolean variables negative hyperresolution refutation width k length expected number restarts required
standard randomised sat solver
decision learning scheme discover

unsatisfiable less nk
proof proof similar proof theorem except decision learning scheme additional feature literals chosen conflict clause falsify
subset current decision assignments hence situation consider
decision assignments falsify literals clause ci learning scheme learn
subset ci hence immediately absorb ci lemma hence maximum
number learnt clausesrequired
reduced nk probability

increased k nk nk giving tighter bound

note similar argument shows standard deviation number restarts
less standard deviation negative binomial distribution parameters


filocal consistency sat solvers




nk less nk hence chebyshevs inequality one tailed version
probability standard randomised sat solver decision learning scheme

discover unsatisfiable nk restarts greater

k consistency sat solvers
combining theorem theorem obtain following linking k consistency
sat solvers
theorem k consistency closure csp instance p empty expected
number restarts required standard randomised sat solver decision learning scheme discover direct encoding p unsatisfiable n k k n
number variables p maximum domain size
proof length negative hyper resolution refutation width k bounded
pk
n
number possible goods length
k

p



hence



theorem theorem obtain bound


n


pk

nd
k

n k k

hence standard randomised sat solver suitable learning strategy decide
satisfiability csp instance tree width k n k k expected restarts
even set restart immediately conflict particular satisfiability
tree structured binary csp instance e tree width decided
solver n expected conflicts comparable growth rate
optimal arc consistency binary constraints note cannot
obtained directly work atserias et al direct encoding
instance tree width k set clauses whose tree width may high dk
moreover standard randomised sat solver decide satisfiability csp
instance structure within polynomial bounds constraint relations
satisfy certain algebraic properties ensure bounded width barto kozik
examples constraint types include relations defined cooper et al
connected row convex relations defined deville et al
decided consistency
shown gent support encoding binary csp instance
made arc consistent consistent applying unit propagation alone hence
standard sat solver mimic effect enforcing arc consistency encoding
making decisions restarts combining theorem observation
example direct encoding obtained support encoding negativehyper resolution obtain following corollary concerning support encoding
higher levels consistency
corollary k k consistency closure binary csp instance p
empty expected number restarts required standard randomised satsolver decision learning scheme discover support encoding p
unsatisfiable n k k n number variables p maximum
domain size


fijeavons petke

csp literature describes many variations notion consistency
considered k consistency note generalised
types consistency singleton arc consistency bessiere
extension singleton arc consistency follows recent discovery family
csp instances solvable enforcing singleton arc consistency instances
bounded width chen dalmau gruien words instances
solved enforcing k consistency fixed k hence theorem
solved polynomial expected time standard randomised sat solver

experimental
polynomial upper bounds obtain asymptotic apply
values n k however conservative likely met
easily practice
investigate existing sat solver actually performs measured runtime
minisat solver een sorensson version family csp instances
decided fixed level consistency comparison ran experiments two state art constraint solvers used minion gent jefferson
miguel version g finite domain solver nethercote et al
version
match simplified assumptions analysis closely ran
set experiments core version minisat order get solver uses
unit propagation conflict directed learning restarts modified solver
follow random branching strategy described solver delete learnt
clauses uses extreme restart policy makes restart whenever encounters
conflict uses learning scheme minisat refer modified solver
simple minisat
characteristic feature instances tested relatively low tree width
used toulbar solver sanchez et al solver implements btd
backtracking tree decomposition technique shown efficient
practice contrast earlier methods proposed attempt exploit
tree decompositions input jegou terrioux
finding tree decomposition minimal width e tree width np hard btd
technique uses approximations described jegou terrioux note
toulbar designed solving optimization namely weighted csps
wcsps wcsp instance certain partial assignments associated cost however
toulbar solver used solve standard csps simply setting costs
times given elapsed times lenovo n laptop
intel core duo processor running ghz gb ram generated
instance run five times mean times mean number restarts shown
example consider family instances specified two parameters w
w w variables arranged groups size w domain
minisat simple minisat run different seeds five runs instance
instances marked run runtime simple minisat instances
exceeded hours moreover toulbar run parameter b enables btd



filocal consistency sat solvers

impose constraint arity w pair successive groups requiring
sum values assigned first two groups strictly smaller
sum values assigned second ensures instances generated
unsatisfiable instance w shown diagrammatically defined
specification language minizinc nethercote et al figure b
respectively similar format used toulbar instance encoded
format shown figure c note hard constraint cost

graphical representation

chain
x
x
x
x
x
x
x
x
hard x x x x
hard x x x x
hard x x x x

array var x
array var x
constraint
forall
x x x x
solve satisfy
b specification minizinc

c specification cp format

figure example csp instance w tree width

structure instances described example simple tree decomposition
path nodes node corresponding constraint scope hence tree width
instances w shown unsatisfiable enforcing w consistency atserias et al however instances cannot solved efficiently
standard propagation prune individual domain values
structure direct encoding instances tree decomposition
node corresponding constraint scope original csp instance however
direct encoding introduces boolean variables represent variable
order run instance cp solver one must usually use translator convert original
model minizinc distribution provides mzn fzn translator minion one use tailor
available http www cs st andrews ac uk andrea tailor
cp wcsp translator description cp wcsp formats available
http carlit toulouse inra fr cgi bin awki cgi softcsp



fijeavons petke

original instance tree width encoded sat instances larger approximately
factor fact wd see figure

tree decomposition original instance

b tree decomposition direct
encoding

figure tree decompositions csp instance figure
table shows runtimes simple minisat original minisat solver
family instances along times two state art cp solvers
wcsp solver toulbar far best solver set instances toulbar
explicitly designed exploit low tree width constructing tree decomposition
class instances considering widths tree decompositions found
toulbar matched tree widths instances tested e w
however note minisat remarkably effective solving chains
inequalities compared minion g even though use minisat requires
encoding instance large number clauses much larger tree width
original although simplified version minisat solver takes little longer
current highly optimised version still performs well instances
comparison conventional cp solvers moreover number restarts hence
number conflicts appears grow polynomially size instance
see figure cases actual number restarts much lower polynomial
upper bound expected number restarts given theorem
best theoretical upper bounds expected run time obtained
decision learning scheme theorem standard version minisat uses
uip learning scheme conflict clause minimization allow direct comparison
theoretical upper bounds implemented decision scheme simpleminisat uip learning scheme generally found efficient
practice zhang et al switched conflict clause minimization simpleminisat order compare two standard learning schemes ran set
experiments counted number restarts two modified solvers instances
form described example see table


filocal consistency sat solvers

group
size
w


















domain
size



















csp
variables
n


















minion

g

sec






min
min
min


min
min
min

min
min

sec






min
min
min



min
min


min

toulbar

minisat

sec


















sec


















simpleminisat
sec













min


min

simpleminisat
restarts


















table average performance solvers instances example
group
size
w

domain
size


csp
variables
n

clauses
direct
encoding





































































simpleminisat
uip
sec













hours



simpleminisat
uip
restarts

















simpleminisat
decision
sec













hours



simpleminisat
decision
restarts

















table average performance simple minisat uip decision learning schemes instances example



fijeavons petke

figure log log plot number restarts conflicts used simple minisat

instances example solid lines growth function w nd w


n number csp variables empirically derived polynomial
function appears fit experimental data well much lower
upper bound expected number restarts calculated theorem
w n w



filocal consistency sat solvers

although performance simple minisat decision learning scheme
uip scheme significantly worse performance original simpleminisat solver twice many restarts required instance hence
theoretical upper bounds still easily met standard learning schemes

conclusions
shown notion k consistency precisely captured single
inference rule direct encoding csp instance restricted deriving clauses
k literals used clause learning sat solver purely
random branching strategy simulate effect enforcing k consistency expected
polynomial time fixed k sufficient ensure solvers able
solve certain families much efficiently conventional cp solvers relying
gac propagation
principle clause learning sat solvers much known
appropriate branching strategy restart policy able p simulate general
resolution beame et al pipatsrisawat darwiche general resolution
proofs exponentially shorter negative hyper resolution proofs considered hwang mitchell practice seems current clause learning
sat solvers highly tuned learning schemes branching strategies restart policies
often able exploit structure boolean encoding csp instance even
effectively local consistency techniques hence considerable work remains done
understanding relevant features instances able exploit order
predict effectiveness solving different kinds csp instances

acknowledgments
would thank albert atserias marc thurley comments conference
version well anonymous referees provision epsrc
doctoral training award justyna petke gratefully acknowledged
preliminary version appeared proceedings th international
conference principles practice constraint programming cp

references
atserias bulatov dalmau v power k consistency
international colloquium automata languages programming icalp
pp
atserias dalmau v combinatorial characterization resolution width
journal computer system sciences
atserias fichte j k thurley clause learning many
restarts bounded width resolution journal artificial intelligence
jair
bacchus f gac via unit propagation principles practice constraint
programming cp pp


fijeavons petke

barto l kozik constraint satisfaction bounded width
symposium foundations computer science focs pp
beame p kautz h sabharwal towards understanding harnessing
potential clause learning journal artificial intelligence jair

bessiere c constraint propagation rossi f van beek p walsh eds
handbook constraint programming chap elsevier
buning h lettmann propositional logic deduction cambridge tracts theoretical computer science cambridge university press
chen h dalmau v gruien b arc consistency friends computing
repository corr abs
cooper c optimal k consistency artificial intelligence

cooper c cohen jeavons p characterising tractable constraints
artificial intelligence
de kleer j comparison atms csp techniques international joint
conference artificial intelligence ijcai pp
deville barette hentenryck p v constraint satisfaction connected
row convex constraints international joint conference artificial intelligence ijcai pp
een n sorensson n extensible sat solver theory applications
satisfiability testing sat pp
freuder e c synthesizing constraint expressions communications acm

gent p arc consistency sat european conference artificial intelligence
ecai pp
gent p jefferson c miguel minion fast scalable constraint solver
european conference artificial intelligence ecai pp
hooker j n integrated methods optimization international series operations management science springer verlag york inc secaucus
nj usa
hoos h h sat encodings search space structure local search performance
international joint conference artificial intelligence ijcai pp
hwang j mitchell g way vs way branching csp principles
practice constraint programming cp pp
jegou p terrioux c hybrid backtracking bounded tree decomposition
constraint networks artificial intelligence
kolaitis p g vardi game theoretic constraint satisfaction conference artificial intelligence aaai innovative applications
artificial intelligence conference iaai pp


filocal consistency sat solvers

mackworth k consistency networks relations artificial intelligence

montanari u networks constraints fundamental properties applications
picture processing information sciences
moskewicz w madigan c f zhao zhang l malik chaff engineering efficient sat solver design automation conference dac pp

nethercote n stuckey p j becket r brand duck g j tack g
minizinc towards standard cp modelling language principles practice
constraint programming cp pp
petke j jeavons p tractable benchmarks constraint programming technical report rr department computer science university oxford
pipatsrisawat k darwiche power clause learning sat solvers
restarts principles practice constraint programming cp pp
prestwich cnf encodings biere heule van maaren h walsh
eds handbook satisfiability pp ios press
rish dechter r resolution versus search two strategies sat journal
automated reasoning
robinson j machine oriented logic resolution principle journal
acm
sanchez bouveret de givry heras f jegou p larrosa j ndiaye rollon
e schiex terrioux c verfaillie g zytnicki max csp competition toulbar solver description proceedings third international
csp solver competition
schiex verfaillie g nogood recording static dynamic constraint
satisfaction international conference tools artificial intelligence
ictai pp
tamura n taga kitagawa banbara compiling finite linear csp
sat constraints
van dongen lecoutre c roussel rd international csp solver competition instances available http www cril univ artois fr cpai
van dongen lecoutre c roussel th international csp solver competition instances available http www cril univ artois fr cpai
walsh sat v csp principles practice constraint programming cp pp
zhang l madigan c f moskewicz w malik efficient conflict driven
learning boolean satisfiability solver international conference computeraided design iccad pp
zhang l malik quest efficient boolean satisfiability solvers
computer aided verification cav pp




