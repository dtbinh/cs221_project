journal artificial intelligence

submitted published

completeness guarantees incomplete ontology
reasoners theory practice
bernardo cuenca grau
boris motik
giorgos stoilos
ian horrocks

bernardo cuenca grau cs ox ac uk
boris motik cs ox ac uk
giorgos stoilos cs ox ac uk
ian horrocks cs ox ac uk

department computer science university oxford
wolfson building parks road ox qd oxford

abstract
achieve scalability query answering developers semantic web applications
often forced use incomplete owl reasoners fail derive answers
least one query ontology data set lack completeness guarantees however
may unacceptable applications areas health care defence
missing answers adversely aect applications functionality furthermore even
application tolerate level incompleteness often advantageous
estimate many kind answers lost
present novel logic framework allows one check whether
reasoner complete given query q ontology whether reasoner
guaranteed compute answers q w r arbitrary data set since
ontologies typical queries often fixed application design time allows
application developers check whether reasoner known incomplete general
actually complete kinds input relevant application
present technique given query q ontology reasoners
r r satisfy certain assumptions used determine whether
data set reasoner r computes answers q w r reasoner r
allows application developers select reasoner provides highest degree
completeness q compatible applications scalability requirements
thus provide theoretical practical foundation design future
ontology information systems maximise scalability minimising even
eliminating incompleteness query answers

introduction
ecient management querying large amounts data core growing
range applications fields diverse biology sidhu dillon chang sidhu
medicine golbreich zhang bodenreider geography goodwin astronomy
derriere richard preite martinez agriculture soergel lauser liang fisseha
keizer katz defence lacy aviles fraser gerber mulvehill gaskill
order facilitate interoperability applications often use standard data
query languages particular rdf hayes provides standard model
semistructured data sparql prudhommeaux seaborne standard query
language rdf ontology languages owl horrocks patel schneider
van harmelen owl cuenca grau horrocks motik parsia patel schneider
c

ai access foundation rights reserved

ficuenca grau motik stoilos horrocks

sattler b used describe background knowledge application
domain thus answering sparql queries rdf data sets structured owl
ontology key service ontology information systems
important question design systems selection appropriate
reasoner systems pellet sirin parsia cuenca grau kalyanpur katz
hermit motik shearer horrocks b racer haarslev moller
hyper tableau provably completethat guaranteed compute answers query ontology data set completeness however
comes cost scalability answering queries owl ontologies high computational complexity glimm horrocks lutz sattler ortiz calvanese eiter
calvanese de giacomo lembo lenzerini rosati lutz toman wolter
thus complete systems often fail meet scalability demands applications
manage data sets consisting hundreds millions even billions assertions
scalability query answering ensured restricting expressive power
ontology language level makes provably complete reasoning tractable
led development three profiles owl motik cuenca grau horrocks wu
fokoue lutz owl el owl rl owl ql query answering
three profiles implemented polynomial time w r size data even
logarithmic space case owl ql appealing theoretical properties
spurred development specialised reasoners quonto acciarri calvanese
de giacomo lembo lenzerini palmieri rosati target specific profiles
typically reject ontologies fall outside target profile
dierent solution scalability adopted reasoners oracles semantic data store wu eadon das chong kolovski annamalai srinivasan
sesame broekstra kampman van harmelen jena mcbride brian
owlim kiryakov ognyanov manov minerva yang qiu xie pan liu
dle jena meditskos bassiliades virtuoso erling mikhailov
reasoners accept owl ontologies inputthat never reject inputs
furthermore best knowledge systems intended sound
means query indeed correct answers finally reasoners
typically use scalable reasoning techniques deductive database
consequence reasoners incomplete reasoner least one query ontology data set exist reasoner return answers query
reasoners actually designed complete particular profile
owl typically owl rl due close connection datalog
often additionally handle certain kinds axiom fall outside target profile
since incomplete reasoners handle large data sets often provide best practical choice developers ontology applications example owlim used
reasoning backend bbcs world cup website oracles reasoner
used university texas health science center improve large scale public
health surveillance order verify selected reasoner meets applications
requirements developers typically resort empirical testing check reasoners answers w r application ontology queries representative data sets
although primarily intended testing performance benchmark suites lehigh


ficompleteness guarantees incomplete ontology reasoners

university benchmark lubm guo pan heflin university ontology
benchmark uobm et al used completeness testing
empirical completeness testing however several important limitations first tests
generic data sets used testing typically fixed repetitive structure skew test second test data exhaustive completeness
tested w r limited number data sets finally query answers may verifiable since complete reasoners fail handle large data sets often cannot compute
control answers needed check answers produced incomplete reasoner
consequence empirical completeness tests provide limited assurance reasoners
ability meet requirements given application
present radically dierent solving
observed given query q ontology even reasoner complete
language reasoner may able correctly answer q w r arbitrary data
set case say reasoner q complete given ontology
applications often use limited set queries fixed ontology least queries
ontology evolve relatively slowly scalable reasoner generally incomplete
q complete relevant combinations q may provide solid foundation
ontology applications allowing enjoy best worlds regardless
data set encountered applications enjoy completeness guarantees normally
available computationally intensive complete reasoners time
exhibiting scalability levels normally available sacrificing completeness develop
testing q completeness given reasoner proceed follows
section develop logic framework allows us establish formally
provable q completeness guarantees following two notions central
framework first order abstract away implementation details concrete
reasoners introduce notion abstract reasoner idealised reasoner captures intended behaviour salient features soundness monotonicity
class concrete reasoners second introduce notion test suitea finite set
data sets queries intuitively given q goal construct test suite
reasoner correctly answers queries data sets test suite
reasoner guaranteed q complete
unfortunately section certain q impossible
construct finite test suite provide aforementioned completeness guarantees
therefore investigate assumptions q reasoner testing q completeness becomes practically feasible
section consider case q rewritten union
conjunctive queries rthat answering q w r data set equivalent
evaluating r expressed owl ql rewriting r computed
calvanese et al additionally perez urbina
motik horrocks sometimes compute r even syntactically outside
fragment r converted test suite er used
testing q completeness reasoner satisfies basic assumptions
roughly speaking reasoners answers depend names individuals
occurring data set answers must increase monotonically data added
size test er polynomial size longest conjunctive query r


ficuenca grau motik stoilos horrocks

feasible compute correct answers tests complete reasoner
number tests er however exponential size r may lead
practice remedy section strengthen assumptions require
reasoner drop answers merging individualsthat reasoner returns
given inputs q possibly noninjective mapping reasoner
returns given inputs q q completeness
reasoners checked test suite ir obtained r linear transformation
q rewritable union conjunctive queries eectively prevents stating recursive axioms overcome restriction section consider first order reproducible reasonersthat reasoners whose behaviour q
seen computing certain answers q w r possibly unknown first order
theory ft since ft datalog program reasoners deductive
databases first order reproducible addition require q rewritable
datalog extension datalog allows existential quantifiers disjunction rule heads many cases transformed datalog program
equivalence preserving transformations furthermore perez urbina
et al many cases produce plain datalog rewriting
transform datalog rewriting q test suite used test
q completeness first order reproducible reasoners
section turn attention comparing incomplete reasoners roughly speaking given q reasoner r complete reasoner r data set
reasoner r computes answers q w r computed r
comparing incomplete reasoners infeasible general therefore introduce
notion compact reasonersthat reasoners whose behaviour q
seen first selecting subset complete reasoner evaluate
q w r thus class compact reasoners captures reasoners reduce
input ontology set axioms match certain parameters fitting
language fragments q rewritten union conjunctive queries
r test suite ir used compare compact reasoners
implemented approaches computing test suites tested completeness several well known reasoners see section test suites
eciently computed realistic ontologies furthermore able guarantee
q completeness evaluated reasoners many queries ontologies finally
q completeness guarantee could provided able compute
counter examplea small data set reasoner hand incomplete

preliminaries
section briefly introduce description logics dls baader mcguinness nardi
patel schneider family knowledge representation formalisms underpin
owl owl ontology languages describe description logics wider
framework first order logic since many hold arbitrary first order theories
introduce datalog datalog languages define syntax
semantics unions conjunctive queries ucqs finally introduce notions
ucq datalog datalog rewritings underpin many techniques


ficompleteness guarantees incomplete ontology reasoners

description logics first order logic
hold arbitrary first order theories rather description logics work however motivated description logics ontologies use
dl terminology throughout example often talk tboxes
aboxes instead first order theories sets facts
definitions implicitly parameterised signature p
consists countably infinite disjoint sets predicates p individuals commonly
called constants first order logic predicate associated nonnegative
arity predicates zero arity commonly called propositional symbols notions
variables terms atoms first order formulae sentences defined usual fitting
consider function symbols article assume formulae
function free atom false true interpretations written
atom fact contain variables use standard first order notions
satisfiability unsatisfiability entailment written sets first order sentences
assume p contains special equality inequality predicates
respectively atoms form commonly written
respectively make technical assumption distinct predicates
rather common first order logic abbreviation
furthermore assume theory uses axiomatises semantics
follows instantiated predicate p arity n n
x x x



x x x



x xi xn yi p x xi xn xi yi p x yi xn



x x x



x z x z x z



note according assumption set facts satisfiable example
set atoms b b satisfiable since b b positive variable free
atoms semantically independent moreover axiom required
obtain expected contradiction
individual renaming often renaming partial function
maps individuals individuals domain range written dom
rng unless otherwise noted assume dom finite object containing
individuals formula set formulae tuple individuals ind
set individuals occurring obtained simultaneously replacing
individual ind dom
use notion substitutions first order logic substitution
mapping variables terms term atom formula applying
substitution written
tbox finite set first order sentences contains axioms whenever
used abox finite set facts note definition allows
atoms form b b aboxes furthermore since aboxes contain
positive atoms abox considered without tbox satisfiable


ficuenca grau motik stoilos horrocks

dl name
el
fl
alc
h
r


q


roles
r
r
r

concepts
c c r c
c c r c
c c c c c r c r c
r self

tbox axioms
c c
c c
c c
r r
rs
trans r

r
ns c ns c


table syntax standard description logics typical extensions el alc fl
named appending calligraphic letters h r q
description logic dl usually infinite recursive set tboxes satisfying
following conditions
dl renaming dl
dl dl

dl say dl tbox finally fol largest description logic
contains finite sets first order sentences signature question
next present overview dls commonly considered literature typically predicates dl signatures required unary binary former
commonly called atomic concepts latter commonly called atomic roles dls
typically use specialised syntax summarised table provides set constructors
constructing complex concepts roles simpler ones well dierent kinds
axioms translation table concepts translated first order
formulae one free variable roles translated first order formulae two
free variables axioms translated first order sentences note translation uses counting quantifiers n n expressed ordinary
quantifiers equality well known transformations
rest commonly write tboxes aboxes dl syntax however
simplify presentation identify written dl syntax
datalog
next introduce fragment first order logic called datalog extension
datalog cal gottlob lukasiewicz marnette pieris datalog rule
commonly rule r formula form bj atom dierent
whose free variables contained x
x

formula x yi conjunction atoms dierent
whose free variables contained x yi


ficompleteness guarantees incomplete ontology reasoners

mapping dl roles first order logic
r x r x
r x r x
mapping dl concepts first order logic
x
x
x x
x x
c x c x
c x c x x
c x c x x
r c x r x c x
r self x r x x
r c x r x c x
ns c x n x c x
ns c x n x c x
mapping tbox axioms first order logic
c x c x x
r x r x x
trans r x z r x r z r x z
r x z r x z x z
mapping abox axioms first order logic
c c
r b r b
b b
b b
table translation dl syntax first order logic

x b bn






yi x yi



rule safe variable x occurs bj unless otherwise noted rules
assumed safe brevity outer quantifier x commonly left implicit
body r
set atoms body r b bn head r formula
head r
yi x yi datalog program finite set safe datalog rules

note since treated ordinary predicates occur rules provided
semantics appropriately axiomatised furthermore note latter
achieved datalog rules
let r datalog rule r datalog rule head r contains existential
quantifier r datalog rule finally r datalog rule
head r single atom without existential quantifiers ceri gottlob tanca
several places check whether set first order sentences entails
datalog rule accomplished following simple


ficuenca grau motik stoilos horrocks

proposition let f set first order sentences let r datalog rule
form substitution mapping free variables r distinct
individuals occurring f r f r
f b bn






yi x yi

proof let x tuple free variables r let arbitrary substitution
mapping variables x distinct individuals occurring f r claim
proposition follows following equivalences
f x b bn




yi x yi





f x b bn
f x b bn

f b bn
f b bn






yi x yi unsatisfiable

skolem x






yi x yi unsatisfiable

yi x yi unsatisfiable





f b bn

yi x yi unsatisfiable














yi x yi

queries
order achieve high degree generality define query q finite set firstorder sentences containing distinct query predicate q intuitively query predicate q
determines answers q order simplify notation typically assume
association q query predicate implicit e g may require query
contain precisely one predicate assume query predicate occurs
tbox abox
tuple constants certain answer query q query predicate q
respect tbox abox arity agrees arity q
q q set certain answers q w r denoted
cert q query predicate q propositional e query boolean
cert q empty contains tuple zero length cases
commonly write cert q f cert q respectively
use special boolean query checks first order theory unsatisfiability
thus cert unsatisfiable
query q query predicate q union conjunctive queries ucq
datalog program rule contains q head body ucq q
conjunctive query cq contains exactly one rule


ficompleteness guarantees incomplete ontology reasoners

union conjunctive queries q ground rule r q variable occurring body r occurs head r roughly speaking computing
cert q ground q variables q matched individuals
unnamed objects whose existence guaranteed existential quantifiers
many state art reasoners used practice support ground ucqs note
q x q x r x q x ground ucq fact q even valid
first order theory since predicate q unique arity obtain ucq one
pad head first rulethat one introduce special fresh individual null
rewrite rules q x q x null r x q x
properties first order logic entailment cert satisfies following properties
query q tboxes aboxes
monotonicity imply
cert implies cert
cert q cert q

invariance renamings renaming tuple individuals
cert implies cert

cert q implies cert q
rewritings
intuitively rewriting query q w r tbox another query captures
information relevant answering q arbitrary abox calvanese
et al artale calvanese kontchakov zakharyaschev perez urbina et al
practice ucqs calvanese et al datalog perez urbina et al
widely used target languages query rewriting sake generality
however use notion datalog rewriting
definition let q query let tbox datalog rewriting simply
rewriting q w r triple r rd r rq
rd datalog program containing q rd
r datalog program head r r r
rq ucq whose query predicate q
following properties hold abox
cert cert rd r
cert f cert q cert rq rd r
rewriting r datalog rewriting rd datalog program furthermore rewriting r
ucq rewriting rd r usually written r r rq


ficuenca grau motik stoilos horrocks

note definition requires rd hold precludes rewritings consisting
axioms unsound w r example let q x q x
rd b x x satisfy definition rewriting since formula
b x x logical consequence
wide range q datalog rewriting q w r computed
straightforward equivalence preserving transformations optimised
eliminating axioms irrelevant answering q furthermore several
computing ucq datalog rewritings proposed literature
example calvanese et al showed compute ucq rewriting cases
expressed logic dl lite family extended
owl ql profile owl motik et al similarly perez urbina et al
proposed computing simplest possible datalog rewriting
expressed description logic elhio
rewritings produced known often contain predicates occur
q predicates sometimes called fresh example many rewriting
normalise tboxes replacing complex concepts fresh atomic concepts
rewriting r rd r rq obtained way unlikely satisfy requirement
rd however predicates occurring r often eliminated
via unfolding example let q x q x r b assume
rewriting produces
rd x b x c x r x c x
satisfy definition predicate c unfolded rd replaced
rd r x z b z x
rd holds unfolding however may possible e g might
case fresh predicates occur recursive axioms may limit applicability presented

completeness guarantees incomplete reasoners
section introduce formal framework allow us establish completeness guarantees incomplete reasoners restricted particular
description logic applicable tboxes satisfy following criterion
definition tbox admissible description logic dl exists
dl tbox checking tbox satisfiability answering boolean ucqs w r
arbitrary abox decidable dl
concrete abstract reasoners
concrete reasoners complex software systems dier greatly functionality
supported interfaces use range dierent implementation techniques
make general independent specific implementation techniques
introduce notion abstract reasoner abstract reasoner thought


ficompleteness guarantees incomplete ontology reasoners

idealised reasoner captures intended behaviour salient features class
concrete reasoners concrete reasoner belonging class may use arbitrary
long observable behaviour mirrors abstract reasoner
definition abstract reasoner ans description logic dl computable function takes input arbitrary dl tbox arbitrary abox
special unsatisfiability query arbitrary ucq q return value ans defined
follows
ans f
ans ans q interest arbitrary
ans f ans q finite set tuples individuals
arity tuple equal arity query predicate q
abstract reasoner ans dl said applicable tbox dl tbox
intuitively ans asks abstract reasoner check whether unsatisfiable ans q asks abstract reasoner evaluate q w r
unsatisfiable tuple constants arity query predicate q
answer q therefore ans q interest
ans fthat ans identifies satisfiable
example consider abstract reasoners rdf rdfs rl classify given
input ucq q tbox abox compute answer q w r
described next
abstract reasoner rdf ignores evaluates q w r precisely rdf f
rdf q cert q thus rdf captures behaviour rdf reasoners
abstract reasoner rdfs evaluates q w r datalog program prdfs constructed translating rdfs axiom equivalent datalog rule
precisely rdfs f rdfs q cert q prdfs thus rdfs captures
behaviour rdfs reasoners sesame
abstract reasoner rl evaluates q w r datalog program prl constructed
translating owl rl axiom equivalent datalog rule precisely
rl cert prl rl q cert q prl thus rl captures behaviour
owl rl reasoners jena oracles semantic data store
abstract reasoner classify first classifies complete owl dl reasoner
computes tbox containing subclass axiom b b
b atomic concepts occurring abstract reasoner proceeds rl
considers instead precisely classify rl
classify q rl q way classify captures behaviour owl
rl reasoners minerva dle jena try complete materialising
certain consequences


ideal abstract reasoner one arbitrary ucq q tbox
abox ans cert ans q cert q whenever
ans f next introduce discuss several properties abstract reasoners


ficuenca grau motik stoilos horrocks

likely aect close come ideal may relevant
applicability
following notion soundness describes abstract reasoners return answers
logically follow q
definition abstract reasoner ans dl sound following conditions hold
ucq q dl tbox abox
ans implies cert
ans f implies ans q cert q
following notion monotonicity describes abstract reasoners extending
input tbox abox never leads dropping answers consider weaker
notion q monotonicity input query q tbox fixed
definition abstract reasoner ans dl monotonic following conditions
hold ucq q dl tboxes aboxes

ans implies ans
ans f ans f imply ans q ans q
given ucq q dl tbox ans q monotonic following conditions
hold aboxes
ans implies ans
ans f ans f imply ans q ans q
discussed section logical consequences first order theory invariant
renaming merging individuals define analogous properties abstract
reasoners first introduce notions stable q stable renamingsthat
renamings leave individuals occurring respectively q unchanged
definition let q query let tbox let renaming stable individual dom ind furthermore q stable
individual dom ind q
following notion weak faithfulness describes abstract reasoners whose answers
invariant replacement individuals fresh individuals furthermore weak
q faithfulness relaxes property case q fixed
definition abstract reasoner ans dl weakly faithful following conditions hold ucq q dl tbox abox injective renaming tuple
ans ind dom imply ans
ans f ind q dom ans q imply
ans f ans q


ficompleteness guarantees incomplete ontology reasoners

given ucq q dl tbox ans weakly q faithful following conditions
hold abox injective renaming tuple
ans ind dom stable imply ans

ans f ind q dom q stable ans q
imply ans f ans q
following notion strong faithfulness describes abstract reasoners whose answers
invariant merging individuals furthermore strong q faithfulness relaxes
property case q fixed
definition abstract reasoner ans dl strongly faithful following conditions hold ucq q dl tbox abox renaming tuple
ans implies ans
ans f ans q ans f imply
ans q
given ucq q dl tbox ans strongly q faithful following conditions hold abox renaming tuple
ans stable imply ans
ans f q stable ans q ans f imply
ans q
present rest applicable abstract
reasoners satisfy combinations properties minimum require
q monotonicity weak q faithfulness abstract reasoners described example satisfy properties testing case concrete reasoners may
however infeasible practice indeed aware technique would allow one check whether concrete reasoner satisfies required properties believe
however concrete reasoners commonly used practice intended sound
monotonic least weakly faithful strong faithfulness reasonable assumption cases concrete reasoner fails satisfy properties
certain inputs likely due implementation bugs thus consequent failure
completeness seen bug detecting situations viewed
part general testing software systems
next present several examples abstract reasoners satisfy
mentioned properties
example consider abstract reasoner behaves rdf whenever number
assertions input abox smaller certain threshold returns
empty set answers larger aboxes intuitively abstract reasoner characterises
concrete rdf reasoner processes inputs certain size reasoner
q monotonic arbitrary q



ficuenca grau motik stoilos horrocks

example consider abstract reasoner behaves rdf trust
reasons removes input abox assertions whose individuals blacklisted
e g come untrusted source abstract reasoner weakly q faithful arbitrary q

example suggests abstract reasoner weakly faithful
make decisions depend specific names individuals
example consider abstract reasoner rl given input ucq q tbox
abox proceeds follows first rl computes abox obtained
evaluating datalog program prl example second rl computes
query q obtained q adding body rule r q inequality x
pairs distinct variables x occurring r third rl evaluates q
considering databasethat finite first order interpretation
individual mapped thus dierent individuals distinct thus rl characterises concrete reasoners evaluate queries matching dierent variables dierent
individuals abstract reasoner rl sound monotonic weakly faithful
strongly faithful example given query q r x q x abox r b
renaming c b c rl q rl q
example suggests abstract reasoner strongly faithful
allow distinct variables queries axioms mapped individuals
next identify classes abstract reasoners use throughout note
soundness required contributes generality
definition given ucq q tbox cwq csq class q monotonic weakly strongly q faithful abstract reasoners applicable
finally note abstract reasoners introduced example sound monotonic strongly therefore weakly faithful consequently concrete reasoners
reasoning techniques outlined example considered sound monotonic
strongly faithful modulo implementation bugs
completeness abstract reasoners
next define central notion abstract reasoner completeness given query q
tbox intuitively q complete abstract reasoner indistinguishable
complete abstract reasoner applied q arbitrary abox
definition let dl description logic let ans abstract reasoner dl
ans q complete ucq q dl tbox following conditions
hold abox
cert ans
cert f ans f cert q ans q
finally ans complete q complete ucq q dl tbox


ficompleteness guarantees incomplete ontology reasoners

example consider el tbox consisting following axioms translation
axioms first order logic shown symbol
takesco mathco st



mathst takesco mathco



calcco mathco



st prof



x takesco x mathco st x
x calcco x mathco x




x mathst x takesco x mathco
x st x prof x



axiom states everyone taking maths course student axiom states
calculus course maths course axiom states maths student takes
maths course axiom states person student
professor axiom rdfs axiom axioms apart owl
rl axioms consider query retrieves students taking maths course
q st x takesco x mathco q x



none abstract reasoners rdf rdfs rl classify example complete
general answering ucqs el tboxes furthermore q previous
paragraph abstract reasoners rdf rdfs rl q complete return
empty set answers abox mathst c contrast following sections
abstract reasoner classify q completethat returns
certain answers q arbitrary abox

test suites
checking q completeness concrete reasoner applying reasoner possible
aboxes comparing reasoners answers complete reasoner clearly
infeasible practice since infinitely many candidate input aboxes obtain
practical need finite number tests formalise idea
following definition
definition let tbox test suite pair sq
finite set aboxes cert
sq finite set pairs abox cert f
ucq
abstract reasoner ans applicable passes test suite ans satisfies
following two conditions
ans
sq ans f cert ans
let q ucq let c class abstract reasoners applicable
exhaustive c q ans c passes q complete
test suite q simple q query occurring sq sq commonly written set aboxes q sq commonly abbreviated sq


ficuenca grau motik stoilos horrocks

intuitively test suite sq determines tests abstract reasoner
subjected reasoner pass must correctly identify abox
unsatisfiable aboxquery pair sq reasoner must
correctly answer w r
given q goal identify test suite exhaustive qthat
test suite abstract reasoner passes guaranteed q complete depending properties abstract reasoners however dierent test suites
may may achieve goal therefore notion exhaustiveness relative
class abstract reasoners c exhaustive class abstract reasoners c
used test arbitrary abstract reasoner c note depends
target class abstract reasoners actual abstract reasoner tested
order words construction depends properties one assume hold
target abstract reasoner furthermore abstract reasoner contained c
passes general imply q completeness guarantee
example let q specified example let
following aboxes
takesco c mathco
takesco c calcco
mathst c

takesco c c mathco c
takesco c c calcco c
st c prof c

following sections q simple test suite sq defined
sq exhaustive class cwq q consequently
used test abstract reasoners example
particular note abstract reasoners rdf rdfs fail tests sq
abstract reasoner rl fails test sq furthermore failed tests provide counterexample q completeness contrast abstract reasoner classify example
passes tests implies abstract reasoner indeed q complete
finally consider variant abstract reasoner classify similarly abstract
reasoner described example returns empty set answers input abox
contains say ten assertions abstract reasoner q monotonic
hence belong cwq abstract reasoner clearly passes however since
belong cwq passing correctly imply abstract reasoner
q complete

next state following property proof trivial

proposition let q ucq let tbox let c c classes
abstract reasoners applicable c c
test suite exhaustive c q exhaustive c q
test suite exists exhaustive c q test suite exists
exhaustive c q
therefore proving existence test suite exhaustive q general
one applies largest possible class abstract reasoners furthermore


ficompleteness guarantees incomplete ontology reasoners

following section identify cases test suite exhaustive q
found proposition suces provide nonexistence smallest
possible class abstract reasoners
finish section pointing important practically relevant property
q simple test suites illustrated example
proposition let sq q simple test suite let ans abstract
reasoner applicable ans pass ans q complete
proof abox sq ans satisfy conditions definition
counterexample q completeness ans
thus q simple test suite exhaustive c q provides sucient necessary test q completeness abstract reasoners c contrast
q simple section provides sucient
necessary test q completeness abstract reasoners c
negative
sections resp section identify restrictions ucq q tbox
guarantee existence test suites exhaustive cwq resp csq q
presenting positive first outline limits q completeness testing
thus justify restrictions use following sections
monotonicity weak faithfulness
approaches testing q completeness abstract reasoners applicable
reasoners q monotonic weakly q faithful section provide
formal justification requirements form following two theorems
theorem shows exhaustive test suites exist consider class
abstract reasoners satisfying properties section apart q monotonicity includes soundness strong faithfulness implies weak faithfulness monotonicity w r tbox
theorem shows exhaustive test suites exist consider class
abstract reasoners satisfying properties defined section exception
q weak faithfulness properties include soundness monotonicity
negative theorems strong hold smallest
classes abstract reasoners define notions introduced section
proposition smaller class abstract reasoners general negative
hold regardless q considered modulo minor technicality
unlike theorem theorem requires satisfiable
proof theorem intuitively understood follows first assume
test suite exhaustive q class abstract reasoners
theorem applies specify abstract reasoner ans right thing e
returns correct answer given input query q tbox


ficuenca grau motik stoilos horrocks

arbitrary abox containing many assertions largest test abox
otherwise ans returns sound incomplete answer finally following
three properties ans
abstract reasoner ans belongs relevant class abstract reasoners
abstract reasoner ans passes
abstract reasoner ans incomplete least one input abox
three properties exhaustive q relevant class
abstract reasoners intuitively means class abstract reasoners large
allowing abstract reasoners treat input erratic way
theorem let q arbitrary ucq let arbitrary admissible tbox
test suite exists exhaustive q class sound strongly
faithful abstract reasoners applicable satisfying following conditions tbox
abox
ans implies ans
ans f ans f imply ans q ans q
proof consider arbitrary test suite sq let n maximum number
assertions abox furthermore let ans abstract reasoner takes
input ucq qin fol tbox tin abox ans tin
determined follows
try renaming dom ind tin
exists return f
contains n assertions check satisfiability
sound complete reasoner return unsatisfiable
return f
furthermore ans qin tin determined follows
try renaming dom ind q tin q qin
exists return
contains n assertions compute cert q sound
complete reasoner return
return
since admissible checks steps performed finite time furthermore step realised enumerating mappings ind ind tin step
realised analogously consequently ans implemented terminates
inputs see ans sound monotonic w r tbox consider arbitrary
input qin tin tin tin tin


ficompleteness guarantees incomplete ontology reasoners

assume ans tin qin tin abstract reasoner
returns step unsatisfiable since tin
tin unsatisfiable well required soundness furthermore
since tin tin qin tin abstract reasoner returns step
well ans tin required monotonicity w r tbox
assume ans qin tin qin tin abstract reasoner
returns step therefore cert q since
q qin tin cert qin tin required soundness furthermore since tin tin qin tin abstract reasoner
returns step well ans qin tin required monotonicity w r
tbox
see ans strongly faithful consider arbitrary renaming renaming
exists q qin tin clearly renaming exists
q qin tin consequently ans tin returns step
ans tin returns step well similarly ans qin tin returns step
ans qin tin returns step well clearly ans strongly faithful
finally straightforward see ans passes
let abox containing least n assertions cert q
clearly exists unsatisfiable ans f furthermore
satisfiable ans q consequently ans q complete thus
exhaustive q class abstract reasoners considered theorem
next prove theorem proof similar proof theorem
main dierence abstract reasoner ans construct particular given test
suite take ans return correct answer query q tbox
abox contains individuals occurring otherwise abstract reasoner
returns sound incomplete answer class abstract reasoners
large allowing ans treat inputs erratic way
unlike theorem following theorem requires satisfiable understand
consider arbitrary unsatisfiable tbox ucq q let sq
test suite defined e contains single empty abox sq e
sq contains aboxes consider arbitrary monotonic abstract reasoner ans
passes since ans passes ans since ans monotonic
arbitrary abox ans well turn implies ans
q complete failure satisfy weak faithfulness thus irrelevant unsatisfiable
theorem let arbitrary admissible satisfiable tbox let q
arbitrary ucq test suite exists exhaustive q class
sound monotonic abstract reasoners applicable
proof consider arbitrary test suite sq let set individuals
occurring q furthermore let ans abstract reasoner takes
input ucq qin fol tbox tin abox ans tin
determined follows
tin return f


ficuenca grau motik stoilos horrocks

let set assertions mention individuals
check satisfiability sound complete reasoner return
unsatisfiable return f otherwise
furthermore given ucq qin ans qin tin determined follows
tin q
qin return
let set assertions mention individuals
compute cert q sound complete reasoner return
ans implemented terminates inputs shown
proof theorem furthermore soundness ans follows following
two observations
assume ans tin abstract reasoner returns step since
unsatisfiable since tin
tin unsatisfiable well required
assume ans qin tin abstract reasoner returns step
therefore cert q since q qin tin
cert qin tin required
monotonicity consider arbitrary tin tin tin
clearly tin monotonicity first order logic
ans tin implies ans tin ans q tin ans q tin finally straightforward see ans passes
consider arbitrary abox ind cert q
clearly exists unsatisfiable since abox constructed step empty
satisfiable ans f furthermore satisfiable since
abox constructed step empty ans q cannot contain individuals occurring
consequently ans q complete thus exhaustive q
class abstract reasoners considered theorem
monotonicity weak faithfulness suffice
next q monotonicity q faithfulness general guarantee
existence test suite exhaustive q particular theorem shows
contains single recursive axiom test suite exists exhaustive class
sound monotonic strongly faithful abstract reasoners proposition
csq cwq well ucq q although applicable
particular q straightforward adapt proof tbox recursive
axiom relevant given query example however shows concept
relevance rather dicult formalise even entails recursive axiom axiom
necessarily relevant answering query order complicate matters
state following fixed q hope proof clearly
illustrates limitations incurred recursive axioms


ficompleteness guarantees incomplete ontology reasoners

theorem q x q x r test suite exists
exhaustive q class sound monotonic strongly faithful abstract
reasoners applicable

proof consider arbitrary test suite sq since test suite
contains aboxes unsatisfiable clearly abox exists
stated theorem let sq arbitrary finite set pairs
abox ucq let n maximum number assertions abox
sq furthermore consider following abox ai aj j n
r r
next construct abstract reasoner pevaln following properties
p sq cert pevaln
p pevaln q
p pevaln sound monotonic strongly faithful
note cert q three properties imply exhaustive
q class abstract reasoners considered theorem
abstract reasoner pevaln accepts input fol tbox tin abox
pevaln tin determined follows
return f

furthermore given ucq qin pevaln qin tin determined follows
tin q
qin return
asat
repeat following computation n times
asat asat x substitution r x asat
return cert q asat

abstract reasoner pevaln clearly satisfies property p deriving assertion
requires n iterations loop step furthermore pevaln satisfies p
every abox occurring sq contains n individuals seen
rule r x x pevaln applies n times input abox
finally p abstract reasoner pevaln clearly sound furthermore
renaming q q pevaln clearly strongly faithful
pevaln monotonic consider arbitrary tin tin
tin tin since pevaln tin f input following
relevant cases
pevaln returns step input qin tin case tin
q qin since tin tin clearly pevaln returns step input qin tin
monotonicity holds


ficuenca grau motik stoilos horrocks

pevaln returns step input qin tin pevaln return
step step input qin tin former case monotonicity holds
trivially latter case pevaln qin tin pevaln qin tin follows
directly fact
following example shows presence recursive axioms preclude existence test suite exhaustive q
example consider q defined follows
q x b x q x
r b r
note contains axiom mentioned theorem however note
b
r b x q x

ucq rewriting q w r section existence ucq rewriting q w r guarantees existence q simple test suite exhaustive cwq
hence csq q example b one test suite
intuitively b consequence relevant answering q hence
b q x q x cert q cert q
arbitrary abox hence recursive axiom irrelevant answering q
therefore presence preclude existence test suite exhaustive
cwq q

testing q monotonic weakly q faithful abstract reasoners

section identify sucient condition guarantees existence q simple
test suite exhaustive cwq q proposition applies csq
well roughly speaking computed instantiating rules
ucq rewriting q w r suitable way requirement q ucqrewritable w r invalidates negative theorem since ucq rewriting
q x q x w r r exists
allows one compute q simple test suites exhaustive q numerous
practically relevant cases particular ucq rewriting guaranteed exist
expressed dls underpinning ql profile owl motik et al calvanese
et al furthermore illustrated example ucq rewriting may exist even
expressed fragments owl owl el motik et al
baader brandt lutz practice rewritings computed systems
quonto acciarri et al requiem perez urbina et al
establish desired two steps first section present general
characterisation q simple test suites exhaustive cwq q section
use characterisation establish desired connection rewritings
q simple test suites exhaustive q


ficompleteness guarantees incomplete ontology reasoners

characterisation simple exhaustive test suites
next prove q simple test suite sq exhaustive cwq q
contains isomorphic copy data pattern e subset abox
produce certain answer q w r preserves identity
individuals occurring q sucient
necessary condition existence exhaustive test suite observe
contain one copy data pattern abstract reasoner
cwq passes misses certain answers obtained via missing data pattern
therefore q complete
theorem let q ucq let admissible tbox let sq
q simple test suite exhaustive cwq q following
properties satisfied abox
unsatisfiable exist abox injective stable
renaming dom ind
satisfiable tuple cert q exist abox
sq tuple b cert q injective q stable renaming
b dom ind q
proof let arbitrary q simple test suite satisfies properties
next exhaustive cwq q consider arbitrary abstract reasoner
ans cwq passes sthat ans satisfies following two properties
ans
b ans f implies cert q ans q sq
next ans q completethat ans satisfies two conditions
definition arbitrary abox arbitrary following
two possibilities depending satisfiability
assume unsatisfiable since satisfies property exist abox
injective stable renaming dom ind
condition ans since ans weakly q faithful injective
stable dom ind ans finally since ans
q monotonic ans required definition
assume satisfiable ans f furthermore consider arbitrary tuple cert q since satisfies property exist abox sq
tuple b cert q injective q stable renaming b
dom ind q since ans f ans
q monotonic ans f furthermore ind dom
injective q stable ans weakly q faithful ans f implies ans f condition b cert q ans q
b ans q since ans weakly q faithful injective q stable
dom ind q b ans q since b


ficuenca grau motik stoilos horrocks

ans q finally since ans q monotonic
ans q required definition

assume exhaustive cwq q next properties
satisfied arbitrary abox end consider particular abstract reasoner
ans prove ans cwq ans passes abstract reasoner
help us identify abox tuple renaming required prove properties
let ans abstract reasoner takes input ucq qin fol tbox tin
abox ans tin determined follows

tin return f

abox following
check satisfiability sound complete terminating
reasoner
b unsatisfiable injective stable renaming exists
dom ind return
return f
furthermore ans qin tin determined follows

tin q
qin return

tuple constants occurring arity equal arity query
predicate q sq following
compute c cert q sound complete terminating reasoner
b tuple b c injective q stable renaming exist
b dom ind q add
return
next ans belongs cwq end prove ans terminates
inputs q monotonic weakly q faithful
termination since admissible checking satisfiability computation
cert q decidable relevant sound complete terminating reasoners
exist furthermore checking whether stable resp q stable injective renaming
exists done enumerating renamings ind resp ind q
ind resp ind q therefore ans implemented
terminates input
q monotonicity consider arbitrary input qin tin
assume ans tin tin abstract reasoner terminates
step b since tin
abstract reasoner terminates step b ans tin
required


ficompleteness guarantees incomplete ontology reasoners

assume ans tin f ans tin f consider arbitrary
tuple ans qin tin added step b sq
since qin tin abstract reasoner
adds step b ans qin tin required
weak q faithfulness consider arbitrary input qin tin arbitrary
injective renaming
assume ans tin dom ind stable thus
tin abstract reasoner terminates step b let
renaming c c c ind clearly
dom ind renaming stable injective
thus tin abstract reasoner terminates step b therefore
ans tin required
assume ans tin f dom ind q q stable
consider arbitrary truple ans qin tin added step
b sq b let renaming defined c c
individual c ind q clearly dom ind q
renaming q stable injective b thus
qin tin abstract reasoner terminates step b clearly
ans qin tin required
concludes proof ans cwq furthermore ans clearly passes
since exhaustive cwq q abstract reasoner ans q complete next
prove main claim theorem end consider arbitrary abox
following possibilities depending satisfiability
assume unsatisfiable ans abstract reasoner
returns step b abox stable renaming
dom ind thus property holds required
assume satisfiable consider arbitrary tuple cert q
ans f ans q added step b
abox sq tuple b cert q injective q stable renaming
b dom ind q thus property
holds required
following example illustrates theorem
example let q specified example let sq
specified example section exhaustive cwq q
consider abox st mathst b takesco b clearly satisfiable cert q b theorem certain answer obtained
evaluating q w r abox sq indeed note abox sq isomorphic
subset mathst b via renaming b c applying q
produces c isomorphic b via


ficuenca grau motik stoilos horrocks

note remove longer test suite
exhaustive q example abstract reasoner rl example would pass
test suite would return required certain answers applied
consequently applied

computing test suites exhaustive cwq

theorem section test suite exhaustive cwq
q obtained instantiating ucq rewriting r q w r replacing
variables r individuals possible ways please note instantiation
must full sense possible replacements must considered
class cwq contain abstract reasoners rl example
strongly faithful may incorrectly handle case distinct variables bound
individuals
definition let set individuals let r datalog rule let
substitution instantiation substitution r w r x
variable x occurring r latter holds instantiation r w r abox
ar b b body r
let q ucq let tbox let r r rq ucq rewriting q w r
let maximum number distinct variables occurring rule r let
set containing individuals occurring r q well fresh individuals
r
r
full instantiation r w r pair er er
er
q
eq e
smallest sets aboxes
ar er
r r instantiation substitution r w r
ar er
q r rq instantiation substitution r w r
cert r ar f
er clearly unique renaming fresh individuals typically left
r
implicit one talks full instantiation er er
eq r
example let q specified example let r r rq
r st x prof x rq consists following datalog rules
takesco x mathco q x
takesco x calcco q x
mathst x q x

r ucq rewriting q w r one see q simple test suite
sq example full instantiation r


following theorem shows full instantiation ucq rewriting q w r
q simple test suite exhaustive cwq q according theorem
test suite example exhaustive cwq q


ficompleteness guarantees incomplete ontology reasoners

theorem let q ucq let admissible tbox let r r rq
r
ucq rewriting q w r let er er
eq full instantiation r
er q simple test suite exhaustive cwq q

proof let set individuals er obtained first er
q simple test suitethat satisfies two properties definition
consider arbitrary abox er
rule r r instantiation
substitution r exist ar clearly cert r since r
ucq rewriting unsatisfiable required
consider arbitrary abox er
q cert r f definition
since r ucq rewriting satisfiable required
next er satisfies properties theorem arbitrary
abox
property assume unsatisfiable since r ucq rewriting
definition cert r rule r r substitution
exist ar cert r ar let injective renaming
individual c occurring r c c individual
occurring ar r fresh individual
exists since number variables r smaller equal number fresh individuals
let instantiation substitution r x x variable
r
x occurring r ar er
holds since e full instantiation r w r let
injective renaming coincides inverse individual occurring
ar r exists since injective range contains individual
occurring ar r clearly ar ar holds ar furthermore
clearly stable thus property satisfied ar er

property assume satisfiable consider arbitrarily chosen tuple
cert q since r ucq rewriting definition cert r f
cert rq r clearly cert rq well rule r rq
substitution exist ar cert r ar let injective
renaming individual c occurring r q c c
individual occurring ar r q fresh
individual clearly exists since number variables r smaller equal
number fresh individuals let instantiation substitution r
r
x x variable x occurring r ar er
q holds since e
full instantiation r w r let injective renaming coincides
inverse individual occurring ar r q exists since
injective range contains individual occurring ar r q
furthermore clearly tuple b cert r ar exists head r q b since
r ucq rewriting ar satisfiable b cert q ar furthermore
since injective b clearly holds property satisfied ar er
q

b


ficuenca grau motik stoilos horrocks

minimising exhaustive test suites
practice clearly beneficial compute test suites small possible
goal achieved applying known techniques minimising ucq rewritings
calvanese et al perez urbina horrocks motik theorem
smallest rewriting instantiated obtain exhaustive test suite
state art query rewriting systems employ subsumption condensation techniques order reduce size rewriting datalog rule r subsumes datalog rule
r substitution exists r r intuitively r general r
rewriting contains rules r r r safely removed rewriting
furthermore rule r contains distinct unifiable body atoms bi bj condensation
r rule r general unifier bi bj rewriting contains
rule r r subsumes r rule safely replaced r following
example illustrates techniques used obtain small test suites
example let q specified example let r rewriting
q w r example r r rq rq consists following
rules ucq rewriting q w r
takesco x takesco x z mathco q x



takesco x calcco q x



mathst x q x



takesco x x calcco x mathco x q x



st x mathst x q x



theorem full instantiation r test suite exhaustive cwq
q rewriting r however contains redundancy hence resulting test suite
unnecessarily large particular applying condensation query subsumption
queries subsumption queries obtain
simpler rewriting r

finally note test suites obtained via full instantiation contain isomorphic
aboxes clearly isomorphic copies abox safely eliminated test
suite without losing exhaustiveness cwq q
testing q monotonic strongly q faithful abstract reasoners

due full instantiation test suites obtained definition exponentially larger
rewriting generated even rewritings moderate size
yield test suites containing thousands aboxes intuitively full instantiation required
obtain test suite exhaustive class cwq class contains abstract
reasoners rl example correctly handle case
distinct variables query matched individual
section test suites exhaustive class csq obtained
injective instantiation rewritingthat replacing variable distinct
fresh individual test suites obtained way linear size rewriting
thus substantially smaller test suites obtained full instantiation


ficompleteness guarantees incomplete ontology reasoners

example let q specified example let sq
q simple test suite example furthermore consider abstract reasoner rl
example weakly strongly q faithful easy check
rl returns complete answers therefore theorem
exhaustive cwq q must include sq aboxes
respectively obtained aboxes merging individual c
strongly q faithful abstract reasoners however correctly handle inputs obtained
merging individuals observation section q simple
test suite sq sq obtained injectively instantiating
rewriting r example exhaustive csq q



section first develop characterisation q simple test suites
exhaustive csq q analogous theorem

theorem let q ucq let admissible tbox let sq
q simple test suite exhaustive csq q following
properties satisfied abox
unsatisfiable exist abox stable renaming
dom ind
satisfiable tuple cert q exist abox
sq tuple b cert q q stable renaming b
dom ind q
proof let arbitrary q simple test suite satisfies properties
next exhaustive csq q consider arbitrary abstract reasoner
ans csq passes sthat ans satisfies following two properties
ans
b ans f implies cert q ans q sq
next ans q completethat ans satisfies two conditions
definition arbitrary abox arbitrary following
two possibilities depending satisfiability
assume unsatisfiable since satisfies property exist abox
stable renaming dom ind
condition ans since ans strongly q faithful stable ans finally since ans q monotonic
ans required definition
assume satisfiable ans f furthermore consider arbitrary tuple cert q since satisfies property exist abox sq
tuple b cert q q stable renaming b
dom ind q since ans f ans q monotonic
ans f furthermore q stable ans strongly faithful ans f implies ans f condition b
cert q ans q b ans q ans strongly q faithful


ficuenca grau motik stoilos horrocks

q stable b ans q since b ans q
finally since ans q monotonic ans q required
definition
assume exhaustive csq q next properties
satisfied arbitrary abox end consider particular abstract reasoner
ans prove ans csq ans passes abstract reasoner
help us identify abox tuple renaming required prove properties
let ans abstract reasoner takes input ucq qin fol tbox tin
abox ans tin determined follows

tin return f
abox following
check satisfiability sound complete terminating
reasoner
b unsatisfiable stable renaming exists
dom ind return
return f
furthermore ans qin tin determined follows

tin q
qin return

tuple constants occurring arity equal arity query
predicate q sq following
compute c cert q sound complete terminating reasoner
b tuple b c q stable renaming exist b
dom ind q add

return
next ans belongs csq proofs ans terminates
q monotonic analogous proofs theorem strong q faithfulness consider arbitrary qin tin arbitrary renaming
assume ans tin stable thus tin abstract
reasoner terminates step b let renaming
c c c ind clearly dom ind
renaming stable thus tin abstract
reasoner terminates step b ans tin required
assume ans tin f q stable consider arbitrary
tuple ans qin tin added step b sq


ficompleteness guarantees incomplete ontology reasoners

b let renaming defined c c individual c ind q clearly dom ind q mapping
q stable b thus qin tin
abstract reasoner terminates step b ans qin tin required
concludes proof ans csq furthermore ans clearly passes
since exhaustive csq q abstract reasoner ans q complete main
claim theorem shown theorem
next use theorem q simple test suite exhaustive
q obtained injective instantiation ucq rewriting q w r

csq

definition let q ucq let tbox let r r rq ucq rewriting
q w r let substitution mapping variable occurring r distinct
r
fresh individual injective instantiation r w r pair ir ir
iq
ir
ir
smallest sets aboxes
q

ar ir
r r

ar ir
r rq cert r ar f
q
ir clearly unique renaming fresh individuals typically left
r
implicit one talks injective instantiation ir ir
iq r
theorem let q ucq let admissible tbox let r r rq
r
ucq rewriting q w r let ir ir
iq injective instantiation r
ir q simple test suite exhaustive csq q

proof let substitution ir obtained first ir
q simple test suitethat satisfies two properties definition
r
consider arbitrary ir
rule r r exist clearly
cert r since r ucq rewriting unsatisfiable required

consider arbitrary ir
q cert r f definition since r
ucq rewriting satisfiable required
next ir satisfies properties theorem arbitrary
abox
property assume unsatisfiable since r ucq rewriting
definition cert r rule r r substitution
exist ar cert r ar let renaming
individual c occurring r c c variable x r
x x clearly ar ar ar furthermore clear
stable thus property holds ar ir

property assume satisfiable consider arbitrarily chosen tuple
cert q since r ucq rewriting definition cert r f
cert rq r clearly cert rq well rule r rq


ficuenca grau motik stoilos horrocks

substitution exist ar cert r ar let renaming
individual c occurring r q c c
variable x r x x clearly ar ar ar furthermore
clear q stable finally clearly tuple b cert r ar exists
head r q b since r ucq rewriting ar satisfiable
b cert q ar furthermore b clearly holds property satisfied

ar ir


b
q
dealing recursive axioms
negative theorem applies cwq csq depends
presence recursive axiom tbox thus positive sections
require input ucq rewritable w r input tbox eectively
prohibits recursion tbox axioms instead disallowing recursive axioms section
overcome limitation theorem placing additional requirements
abstract reasoners requiring first order reproducible intuitively latter
means reasoners behaviour seen complete reasoning unknown
first order theory abstract reasoners allowed partially evaluate recursive
axioms invalidates used prove theorem
test suite exhaustive q class first order reproducible
abstract reasoners obtained instantiating datalog rewriting q w r
rewritings exist wide range tboxes queries turn allows
applicable range practically interesting cases contrast test
suites computed ucq rewriting however test suites obtained datalog
rewriting may q simple fact section certain q
test suite exhaustive q class first order reproducible abstract
reasoners exists test suite q simple important practicallyrelevant consequence test suite q simple first order reproducible abstract
reasoner passes guaranteed q complete however abstract reasoner
pass general cannot conclude reasoner q complete
first order reproducible abstract reasoners
state art concrete reasoners oracles reasoner jena owlim minerva virtuoso dle jena implemented rdf triple stores extended deductive
database features given input reasoners first precompute assertions
follow preprocessing step practice step commonly implemented technique seen evaluating datalog program
preprocessing reasoners answer arbitrary ucq q simply evaluating
q precomputed set assertions
motivated observation next introduce class first order reproducible
abstract reasonersthat abstract reasoners whose behaviour conceived complete reasoning unknown first order theory note theory required
datalog program example contain existential quantifiers used
capture behaviour concrete reasoners jena owlim bishop kiryakov


ficompleteness guarantees incomplete ontology reasoners

ognyano peikov tashev velkov handle existential quantifiers input
introducing fresh individuals
definition abstract reasoner ans description logic dl first order reproducible dl tbox set first order sentences ft exists
abox
ans cert ft

ans f ucq q ans q cert q ft

ft contains predicates individuals occurring assumed
internal ans accessible queries tboxes aboxes test suites
given tbox cft class first order reproducible abstract reasoners applicable

example abstract reasoners rdf rdfs rl classify example firstorder reproducible indeed theory ft empty case rdf precisely prdfs
prl cases rdfs rl respectively finally abstract reasoner classify theory
ft union prl program containing axiom x x b x
atomic subsumption b entailed input tbox


please note first order reproducible abstract reasoner ans need actually construct ft matters possibly unknown theory ft exists
characterises reasoners behaviour specified definition
since qft qft whenever first order reproducible abstract
reasoner q monotonic arbitrary q furthermore straightforward
see first order reproducible abstract reasoner strongly q faithful
consequently cft csq ucq q tbox
next negative theorem directly apply
class cft particular abstract reasoner pevaln used prove
theorem first order reproducible intuitively pevaln understood
partial evaluation datalog programthat rules program applied
facts fixed number times rather fixpoint reached
proposition positive integer n abstract reasoner pevaln defined
proof theorem first order reproducible
proof let r let q x q x consider arbitrary nonnegative integer n furthermore assume pevaln cft finite set first order
sentences ft exists pevaln q cert q ft abox
let k positive integer furthermore let rk datalog rule let ak
abox defined follows ak arbitrary distinct fixed individuals occurring
q ft
rk r x x r xk xk xk x
ak r r ak ak ak
following condition holds proposition
ft rk

ft ak




ficuenca grau motik stoilos horrocks

definition pevaln
pevaln q ak k n
pevaln q ak k n
since pevaln q cert q ft
cert q ft ak k n
cert q ft ak k n
since q contains atom x body
ft ak k n
ft ak k n
condition
ft rk k n
ft rk k n
however contradicts obvious observation r rk k
note proof proposition relies fact theory ft depends
input tbox input query shown next defined first order
reproducible abstract reasoners allowing ft depend input query
negative theorem would applied
definition abstract reasoner ans dl first order q reproducible
ucq q dl tbox finite set first order sentences fq exists
abox
ans cert fq
ans f ans q cert q fq
theorem q x q x r test suite exists
exhaustive q class sound monotonic strongly faithful qreproducible abstract reasoners applicable
proof prove claim suces nonnegative integer n
abstract reasoner pevaln defined proof theorem first order q reproducible
consider arbitrary nonnegative integer n arbitrary dl tbox arbitrary
ucq q define fq q q fq otherwise
fq consists following n rules
x q x

r x x x q x


r x x r x x r xn xn xn q x


ficompleteness guarantees incomplete ontology reasoners

clearly pevaln cert fq f ucq q dl tbox
abox required furthermore q q q
abox pevaln q cert q fq finally
q q abox clearly pevaln q
cert q fq required
simple vs non simple test suites
proposition section shows q simple test suite exhaustive
q class abstract reasoners provides sucient necessary test q completeness next analogous hold contains recursive
axioms even consider first order reproducible abstract reasoners theorem prove claim fixed q since concept relevant recursive
axioms might dicult formalise however proof easily adapted
ucqs tboxes essentially states test suite exists provides
necessary sucient condition q completeness abstract reasoner
cft consequently proposition test suite exhaustive cft q
q simple furthermore section compute test suite exhaustive
cft q following claim hold vacuously
theorem let q x b x q x let r let c
class sound monotonic strongly faithful first order reproducible abstract reasoners applicable test suite exists satisfies following two properties
exhaustive c q
abstract reasoner ans c ans q complete ans passes
proof assume test suite sq exists satisfies properties
theorem let n maximal number assertions occurring abox
next define two abstract reasoners ans ans straightforward check
sound monotonic strongly faithful first order reproducible
given arbitrary fol tbox tin abstract reasoner ans uses datalog program
ft defined follows
tin ft
tin ft contains following n rules
r
r
r

b x x x
b x r x x x x
b x r x x r x x x x

rn b x r x x r xn xn xn x
given arbitrary fol tbox tin abstract reasoner ans uses datalog program
defined follows predicate z private ft hence aect
soundness abstract reasoner
ft



ficuenca grau motik stoilos horrocks

tin ft
tin ft contains ft well following rules
rz r x x r xn xn xn z x
rz
r x x z x z x
rz
z x b x x
let arbitrary abox containing n assertions next
assertion containing predicate z ft
ft direction trivial since ft ft consider
direction furthermore since rz rule ft ft contain
z head claim nontrivial form individual occurring since antecedent rz satisfied b
ft z latter implied rz rz individuals
ak k exist r ai ai k ak
since contains n assertions w l g assume k n since
ft contains rule rk ft well proves claim consequence claim fact aboxes contain n assertions
cert ft cert ft cert ft cert ft
sq
let b r r cert q
cert q ft ans q complete since exhaustive c q
abstract reasoner ans pass claim previous paragraph abstract
reasoner ans pass next ans q complete
contradicts assumption satisfies property thus proves claim
theorem
consider arbitrary abox containing assertions clearly cert q
individuals ak k exist b r ai ai
k ak assume k n since rk ft
ft thus cert q ft contrast assume k n since
rz ft ft z akn since rz ft ft z ai
k n finally since rz ft ft
cert q ft required
corollary theorem next testing abstract reasoners cft
cannot done general q simple test suites
corollary q x b x q x r q simple test suite exists exhaustive q class sound monotonic strongly
faithful first order reproducible abstract reasoners applicable
proof q simple test suite exhaustive q class mentioned
theorem proposition abstract reasoner ans class
pass q complete contradicts theorem


ficompleteness guarantees incomplete ontology reasoners

theorem eectively says abstract reasoner ans cft pass test suite cannot conclude ans q complete please note holds
ans fails test form q
q counterexample
q completeness ans thus may ans q complete
guaranteed illustrated following example
example let q x b x q x let r r c c furthermore let sq general test suite defined follows
sq

c
x b x q x
r c c q
r c c c c q


let r rd q rd r x x r x c c x clearly
r rewriting q w r section compute r
variant injective instantiation way guarantees exhaustiveness cft q
let ans cft abstract reasoner defined ft r x x
reasoner pass since cert c c q ft r c c f note however reasoner q complete thus test suite q simple passing
sucient necessary condition q completeness fact note
contains tbox theorem theorem cannot reduce
correctly identifies reasoners cft q complete
practice however one try mitigate fundamental theoretical limitation
eliminating irrelevant axioms rewriting r thus increasing likelihood
obtaining test suite q complete abstract reasoner pass example
techniques cuenca grau horrocks kazakov sattler
extract module r relevant query example previous paragraph
would remove rule r x c c x r injective instantiation
produce test suite sq sq defined follows
sq

c
x b x q x
r c c q


abstract reasoner ans previous paragraph passes thus guaranteed
q complete
let ans abstract reasoner defined ft b x r x x
clearly abstract reasoner ans q complete ans pass sq
latter however cannot immediately conclude q complete test
fails involve original query q possible remedy try unfold
r certain level injectively instantiate hope obtaining test
suite identify ans q complete particular first unfolding
r produces following query
b x r x q x

instantiating rewriting produces following test suite prove
ans q complete
sq

b c r c x b x q x


ficuenca grau motik stoilos horrocks

another round unfolding however produces following query
b x r x r z z q x
instantiating query produces following test suite

q

b c r c r e e x b x q x

ans pass
q conclude ans q complete



better understand example consider first order reproducible abstract reasoner
ans arbitrary ucq q tbox r rd rq datalog rewriting
q w r datalog program rd rq equivalent possibly infinite ucq ruq
obtained rd rq via exhaustive unfolding following possibilities
first assume ans q complete since rd rq equivalent ruq
certain answer q w r arbitrary abox produced r ruq
injective instantiation ar r provide us counterexample
q completeness ans thus prove ans q complete
generating elements ruq fair manner e without indefinitely delaying
generation element ruq checking whether cert q ar ans q ar
guaranteed eventually encounter r ruq invalidates condition
thus proves ans q complete
second assume ans q complete determine cert q ar ans q ar holds r ruq ruq finite e
unfolding rd rq terminates ruq ucq rewriting q w r
section conclude ans indeed q complete however ruq infinite never obtain sucient assurance q complete
ans following section possible remedy
testing first order reproducible abstract reasoners
section compute test suite sq exhaustive cft
q datalog rewriting r rd r rq q w r since first order
reproducible abstract reasoners strongly faithful need consider injective
instantiations r thus rules r rq instantiated section
rule r rd however instantiated pair sq abox obtained
instantiating body r boolean ucq obtained instantiating head
r intuitively tests allow us check whether unknown first order theory ft
captures behaviour abstract reasoner entails r
definition let q ucq query predicate q let admissible tbox
let r rd r rq datalog rewriting q w r let substitution
mapping variable occurring r distinct fresh individual injective instanr
r
tiation r w r pair ir ir
smallest set aboxes
iq
ir
smallest set pairs abox ucq
q
ar ir
r r



ficompleteness guarantees incomplete ontology reasoners

ar q ir
r rq cert rd r ar f
q
ar ir
r rd form cert rd r ar f
q
ucq x yi q propositional query
predicate q
ir clearly unique renaming fresh individuals typically left
r
implicit one talks injective instantiation ir ir
iq r
example consider query q x q x el tbox consisting
following axioms whose translation first order logic shown symbol
r b



bc



ad



r c



c r



x r x b x
x r x c x
x b x c x

x c x r x
x x x

r rd r rq defined next datalog rewriting q w r
rd r x b x r x c x b x c x
r x x

rq x q x

r
injective instantiation ir ir
iq r shown

ir
c c

ir
x q x
q c
r c b c q
r c c c q
b c
c c q




injective instantiation datalog rewriting q w r
test suite exhaustive cft q
theorem let q ucq let tbox let r rd r rq datalog
r
r
rewriting q w r let ir ir
iq injective instantiation r
test suite exhaustive cft q
proof let substitution ir obtained first ir test
suite
r
consider arbitrary ir
rule r r exist clearly
cert r cert rd r well since r datalog rewriting q w r unsatisfiable required



ficuenca grau motik stoilos horrocks

consider arbitrary ir
q cert rd r f definition

since r datalog
rewriting q w r satisfiable
required
ir exhaustive cft q consider arbitrary abstract reasoner
ans cft passes ir ans satisfies following two properties
ans ir

b ans f implies cert ans ir
q
since ans first order reproducible set first order sentences ft exists
abox
ans cert ft
ans f ans q cert q ft
assumption ft definition fact maps variables fresh
individuals rng ind ft
let r r smallest sets rules satisfying following conditions
rule r rd
cert ft ar implies r r r obtained r replacing head

cert ft ar f implies r r
furthermore let r q r q sets rules obtained rq analogous way
since r r obtained rd replacing head formulae clearly
r r rd analogously r q r q rq

next ft r latter holds ft r rule r r
consider arbitrary rule r r note head r definition
r
r
ar ir
ans definition cert ft
hence ft ar finally since rng ind ft proposition
ft r required
next ft r latter holds ft r rule r r
consider arbitrary rule r r note head r definition r
cert ft ar hence ft ar finally since rng ind ft
proposition ft r required
completely analogous way previous paragraph possible
ft r q
next ft r latter holds ft r rule
r r consider arbitrary rule r r form definition r
cert ft ar f definition ans ar f definition
ar ir
x yi q note
q ucq
r definition proposition ar
x yi

definition fact q occur ar q


ficompleteness guarantees incomplete ontology reasoners

cert ar latter observation ans ar f b imply
ans ar definition cert ft ar since q occurs

note predicate occurring
ft private ft q cannot
r
occur ft ft x yi finally since rng ind ft
proposition ft r required
next q ft r q latter holds q ft r
rule r r q consider arbitrary rule r r q note head r atom predicate
q definition r q cert ft ar f definition
ans ar f furthermore definition cert rd r ar f
let tuple arguments head r definition
ar q ir
cert r ar cert rq rd r ar
q clearly
monotonicity first order logic since r rewriting q w r definition cert q ar latter observation ans ar f b
imply ans q ar definition cert q ft ar hence
ft ar q finally since rng ind ft proposition
ft r required
following table summarises entailment relationships first order
theories obtained thus far
ft r
q ft r q

ft r
r q r q rq

ft r
r r rd

ft r q

clearly implies following entailments
ft rd r

q ft rd r rq

complete proof theorem ans q complete
end consider arbitrary abox following possibilities depending
satisfiability
assume unsatisfiable cert rd r definition
mentioned entailments cert ft consequently
ans definition required
assume satisfiable ans f consider arbitrary tuple
cert q cert rd r f cert rq rd r
definition mentioned entailments cert q ft
hence ans q definition required
note size test suite obtained theorem linear size
rewriting believe makes suitable use practice
testing ground queries
shown section abstract reasoner ans cft pass test suite
q simple cannot conclude ans q complete
practical point view would highly beneficial identify situations passing
would ans indeed incomplete q furthermore applications


ficuenca grau motik stoilos horrocks

prototypical queries known design time would design completeness
tests query independentthat test abstract reasoner completeness
w r regardless input data query section
achieve two goals focusing ground queries restriction unreasonable
practice since sparql query equivalently expressed ground ucq
first define query independent notion exhaustiveness test suite
definition let tbox let test suite let c class abstract
reasoners applicable exhaustive c ground ucqs ans c
passes q complete ground ucq q
define notion ground rewriting rewriting captures
query answers w r regardless input ground query aboxand
instantiate ground rewritings

definition ground rewriting tbox pair r rd r
ground ucq q triple rd r q datalog rewriting w r q

injective instantiation ir r defined ir ir r rd r
note definition implies variable occurring head rule
r occurs rule body tools requiem kaon easily
adapted compute ground rewriting tbox practice next
injective instantiation ground rewriting yields test suite provides us
sucient necessary check completeness w r ground ucqs

theorem let tbox let r rd r ground rewriting
following two claims hold
ir exhaustive cft ground ucqs
abstract reasoner ans cft pass ir q complete
ground ucq q

proof property consider arbitrary abstract reasoner ans cft passes ir let
ft first order theory characterises behaviour ans proof
theorem fact ans passes ir implies ft rd r furthermore consider
arbitrary ground ucq q arbitrary abox ans q complete
shown proof theorem minor dierence cert q
implies cert q rd r definition
property note since r ground rewriting definition ucqs
ir ground thus abstract reasoner ans cft pass ir clearly
shows ans q complete ground ucq q

comparing incomplete abstract reasoners
section investigate techniques given query q tbox allow us
determine whether abstract reasoner ans complete abstract reasoner
ans whether aboxes abstract reasoner ans computes answers
q abstract reasoner ans idea formalised following definition


ficompleteness guarantees incomplete ontology reasoners

definition let q ucq let tbox let ans ans abstract
reasoners applicable ans q ans following conditions hold
abox
cert ans imply ans
cert f ans f ans f imply
ans q cert q ans q cert q
furthermore ans q ans ans q ans abox exists least one
following two conditions holds
cert ans f ans
cert f ans f ans f
ans q cert q ans q cert q
example consider abstract reasoners rdf rdfs rl classify introduced example query q tbox example clearly following
rdf q rdfs q rl q classify
furthermore two abstract reasoners abox exists distinguishes
abstracts reasoners w r q example abox takesco c mathsco
rdfs q rl q c following
rdf q rdfs q rl q classify



would check whether ans q ans ans q ans given pair
abstract reasoners subjecting reasoners finite set tests towards goal
r
next define relations r
q q compare abstract reasoners w r given
finite set r aboxes ideally given q would compute finite r
r
r
q q coincide q q abstract reasoners class c
interest ideas captured following definitions
definition let q ucq let tbox let r finite set aboxes let
ans ans abstract reasoners applicable
ans r
q ans conditions definition hold abox
r
r furthermore ans r
q ans ans q ans condition condition
definition holds abox r
definition let q ucq let tbox let c class abstract reasoners
applicable finite set r aboxes q representative c following
conditions hold ans ans c
ans r
q ans ans q ans


ficuenca grau motik stoilos horrocks

ans r
q ans ans q ans
next prove r q representative suces
implication condition implication condition definition
proposition let q ucq let tbox let c class abstract reasoners
applicable let r finite set aboxes
ans r
q ans implies ans q ans
ans q ans implies ans r
q ans
r q representative c
proof note ans q ans trivially implies ans r
q ans thus condition
proposition clearly implies condition definition furthermore abox r
satisfies condition definition condition definition holds well
consequently conditions proposition imply condition definition
obvious question whether q simple test suite exhaustive class
c q q representative c following example shows
necessarily case
example let q specified example let r
aboxes specified example shown section q simple test suite
sq sq exhaustive cwq q
let trivial abstract reasoner returns empty set input consider rdf abstract reasoner rdf example ignores tbox
evaluates query directly abox clearly trivial q rdf furthermore
trivial q rdf since st c takesco c mathco rdf q c
whereas trivial q abstract reasoners however return empty set
answers aboxes r thus rdf r
q trivial hence r cannot
dierentiate two abstract reasoners

negative
following strong shows numerous tboxes finite set aboxes
exists dierentiate two arbitrary abstract reasoners class sound
first order reproducible monotonic strongly faithful reasoners note
stronger negative theorem applies smaller class abstract
reasoners tboxes imply least one concept subsumption
theorem let arbitrary tbox mentioning atomic role r atomic
concepts b b let q b x q x finite set
aboxes exists q representative class sound monotonic strongly
faithful first order reproducible abstract reasoners applicable


ficompleteness guarantees incomplete ontology reasoners

proof assume finite set aboxes r exists q representative class
sound monotonic strongly faithful first order reproducible abstract reasoners
applicable let n maximum number assertions abox r
arbitrary integer k let ansk first order reproducible abstract reasoner
given fol tbox tin uses following datalog program ftkin
ftkin






tin b
x r x x r xk xk b x tin b

clearly ansk sound monotonic strongly faithful furthermore ansk f
abox next ansn q ansn q abox
r consider arbitrary ansn q individuals exist
r n since contains n assertions
rule ftn contains n body atoms ai aj jthat
contains r cycle rule ftn matched mapping x
ansn q therefore ansn r
q ansn
r r however ansn q
ansn q thus ansn q ansn hold contradicts assumption r exhaustive class abstract reasoners theorem
compact abstract reasoners
theorem suggests need make additional assumptions abstract reasoners wish compare finite set aboxes section
representative sets aboxes computed practice restrict
abstract reasoners call q compact intuitively abstract reasoner
processes q computing certain answers q subset
subset depends q words behaviour compact
abstract reasoners simulated following process select subset axioms
input tbox processed compute certain answers w r
selected fragment tbox class q compact abstract reasoners thus captures properties concrete reasoners jena oracles semantic data store
discard axioms input tbox fall outside certain fragment e g existential
restrictions right hand implications encode remaining axioms
suitable set rules
definition let q ucq let tbox abstract reasoner ans applicable
q compact tbox exists following properties hold
abox
cert implies ans
cert f implies ans f ans q cert q
abstract reasoner ans compact q compact ucq q tbox
ans applicable finally ccq class q compact strongly
q faithful abstract reasoners applicable


ficuenca grau motik stoilos horrocks

example abstract reasoners defined example q compact
query q el tbox example indeed abstract reasoner rdf subset
given abstract reasoner rdfs abstract reasoner
rl abstract reasoner classify

abstract reasoners ansk defined proof theorem q compact query tboxes theorem applies

proposition let q b x q x let b c r
k abstract reasoner ansk proof theorem q compact
proof let q stated theorem consider arbitrary k let
aboxes defined follows


r r ak ak

clearly following
ansk q

ansk q

one straightforwardly check however following holds
cert q cert q
thus ansk q compact
thus negative theorem immediately apply class
containing compact abstract reasoners
comparing compact abstract reasoners
section set aboxes q representative ccq
obtained computing subset q simple test suite exhaustive

csq minor complication arises due fact contain fewer individuals

deal cases correctly aboxes st allowed contain

individuals occurring aboxes stq allowed contain
individuals occurring q assumption without loss generality

given q test suite st one replace individuals q

fresh individuals replacement q test suite exhaustive csq
theorem let q ucq let tbox furthermore let




st st stq q simple test suite exhaustive csq q


abox st contains individual ind ind abox stq contains
individual ind ind q set r aboxes defined



r
st stq


q representative ccq


ficompleteness guarantees incomplete ontology reasoners

proof assume r satisfies conditions theorem let ans ans
arbitrary abstract reasoners ccq next ans ans satisfy two
properties proposition
property proposition

ans r
q ans implies ans q ans

property proposition

ans q ans implies ans r
q ans

since ans q compact tbox exists satisfies conditions
definition assume ans r
q ans next conditions
definition satisfied arbitrary abox
condition assume cert ans contrapositive property definition cert since r contains aboxes

q simple test suite exhaustive csq q theorem
exist abox r stable renaming dom ind
since contain individuals ind ind renaming
stable definition test suite cert furthermore property

definition ans since ans r
q ans ans

since ans strongly q faithful stable ans finally since ans q monotonic ans required
condition assume cert f ans f ans f
consider arbitrary tuple ans q cert q contrapositive
property definition cert f property definition cert q since r contains aboxes q
simple test suite exhaustive csq q theorem exist
abox r tuple b cert q q stable renaming
dom ind q b since contain individuals ind ind q renaming q stable definition
q test suite cert f furthermore property definition
b ans q since ans r ans b ans q since ans strongly
q
q faithful q stable ans q finally since
ans q monotonic ans q required
assume ans q ans definition ans q ans abox
exists satisfying conditions definition clearly ans r
q ans hence
remains shown r contains abox satisfies conditions
definition since ans q compact tbox exists satisfies
conditions definition
condition assume cert assume ans
ans f proof condition identify abox r
stable renaming ans since ans q monotonic ans f ans f furthermore since ans
strongly q faithful stable ans f
condition definition satisfied r
condition assume cert f ans ans f
consider arbitrary tuple ans q cert q ans q
proof condition identify abox r q stable renaming


ficuenca grau motik stoilos horrocks

tuple b cert q b b ans q since ans
q monotonic ans q ans q furthermore since
ans strongly q faithful q stable b ans q
condition definition satisfied r
theorems immediately suggest computing set aboxes
q representative ccq first compute ucq rewriting q w r
subset instantiate rule rewriting injective
instantiation mapping finally compute r union aboxes test suites
nave procedure however practical since requires computing exponential
number ucq rewritings next present practical computing
set aboxes q representative ccq intuitively instead computing
exponentially many rewritings one compute single ucq rewriting q w r
subset closed contains rewriting subset
definition ucq rewriting r r rq q w r subset closed
tuple r r rq exists r r rq rq r
ucq rewriting q w r
following corollary immediate consequence theorems

corollary let q ucq let tbox let r subset closed ucq rewriting
r
q w r let ir ir
iq injective instantiation r set
q
r
aboxes r ir

iq q representative cc

practical query rewriting systems requiem optimised produce small
ucq rewriting possible output typically subset closed therefore
technique requires modification ucq rewriting implemented existing systems illustrated following example required modification typically
involves disabling least partially subsumption optimisations
example let q specified example let sq
test suite example system requiem compute r
given q note however r subset closed example ucq
rewriting q w r q subset rq rewriting made
subset closed extending rq following rules
st x takesco x mathco x q x
st x takesco x calcco x q x
mathst x st x q x

systems requiem however typically discard rules applying subsumption
optimisations described section

following example shows subset closed ucq rewriting q w r
worst case exponentially larger minimal ucq rewritings q w r
example let q c x q x let following tbox
b ai n c


ficompleteness guarantees incomplete ontology reasoners

furthermore let r r rq r rq contains following rules
c x q x

b x q x

x x q x
clearly r ucq rewriting q w r however number rules subset closed
ucq rewriting q w r exponential n


evaluation
implemented techniques computing exhaustive test suites comparing incomplete concrete reasoners prototype tool called sygenia tool uses requiem
computing ucq datalog rewritings
considered two evaluation scenarios first one uses well known lehigh
university benchmark lubm guo et al consists relatively small
tbox academic domain test queries data generator second one
uses small version galen rector rogers complex ontology commonly
used medical applications
evaluated following concrete reasoners sesame v prl dle jena v
owlim v minerva v jena v three variants micro mini
max
computing exhaustive test suites
given ucq q tbox tool uses requiem compute datalog rewriting
r q r ucq rewriting tool computes simple test suite
full injective instantiation see sections respectively otherwise
tool computes non simple test suite instantiating r described section
simple test suites
case lubm benchmark test queries leads ucq rewriting w r tbox therefore computed ucq rewriting query q
benchmark requiem instantiated fully injectively thus obtaining
q simple test suites exhaustive q cwq csq respectively
times needed compute test suites size test suite shown table
denotes total number aboxes corresponding test suites









http code google com p sygenia
http www cs ox ac uk projects requiem home html
http www openrdf org
http lpis csd auth gr systems dle jena
http www ontotext com owlim
http www alphaworks ibm com tech semanticstk
http jena sourceforge net
since requiem currently support individuals queries replaced individuals
queries distinguished variables



ficuenca grau motik stoilos horrocks

q
cw

csq

q
time


time



q q q q q q q q q q q q q


















table computation simple test suites lubm times given seconds

q
cw

csq

time

time


q





q





q





q





table computation simple test suites galen times given seconds
shown table simple test suites could computed times ranging
seconds cwq csq optimisations implemented requiem ensure
ucq rewritings relatively small resulting test suites consist
relatively small number aboxes notice however significant dierence
numbers aboxes test suites obtained via injective instantiation range
average obtained via full instantiation range
average furthermore rule rewriting contains
atoms therefore abox test suite contains assertions
case galen used following sample queries requiem
compute ucq rewriting
q
q
q
q






haemoglobinconcentrationprocedure x q x
plateletcountprocedure x q x
lymphocytecountprocedure x q x
hollowstructure x q x

instantiated ucq rewriting fully injectively times needed compute test suites size test suite shown table
shown table simple test suites galen computed times ranging
seconds average seconds thus computing test suites
galen time consuming lubm unsurprising since tbox
galen significantly complex lubm number aboxes
test suites ranged case injective instantiations
case full instantiations note significant dierence
sizes two kinds test suites cases however individual abox
small largest one containing assertions
non simple test suites
computed non simple test suites cases ucq rewriting exists
already mentioned lubm queries ucq rewritable therefore manually added
following query requiem computes recursive datalog rewriting


ficompleteness guarantees incomplete ontology reasoners

time


cft

lubm
q



q



galen
q q




q



table general test suites computed datalog rewritings lubm galen
system
completeness guarantee completeness w r lubm data set
jenamax dle jena
q q
q q
owlim
q q q q q q
q q
jena mini micro
q q q q q q
q q
minerva
q q q q
q q
sesame
q q q q
q q q q

table completeness guarantees ucq rewritable queries lubm
q

organization x q x

due complex structure galen tbox test queries ucq rewritable
easily identified evaluated following four
q
q
q
q






westergrenesrprocedure x q x
arthroscopicprocedure x q x
truecavity x q x
bacterialcellwall x q x

times needed compute test suites size test suite shown table
completeness guarantees
already discussed existing concrete reasoners captured strongly q faithful
abstract reasoners hence order establish completeness guarantees concrete
reasoners restricted tests test suites computed injective instantiations
simple test suites
original queries lubm benchmark shown table
concrete reasoner first column table shows queries
able prove completeness techniques e queries complete
arbitrary data set second column table shows queries
concrete reasoner computes answers canonical lubm data set one university
clearly completeness w r data set lubm benchmark
guarantee completeness arbitrary data sets example owlim minerva
jena mini micro complete queries w r lubm data set
systems even complete expressive uobm benchmark however certain
queries systems found incomplete data set test suites
jena max dle jena systems guaranteed complete
lubm queries regardless data setthat systems behave exactly
complete owl reasoner lubm queries lubm tbox according jenas


ficuenca grau motik stoilos horrocks

documentation jena max supports types axioms used lubm tbox hence
expected complete lubm tbox queries interestingly tested
lubm data sets jena max could compute answers many
queries used smaller lubm data sets instead demonstrates additional
advantage require reasoning w r large data sets since
aboxes test suites typically contain small number assertions regarding dlejena according technical description meditskos bassiliades system
uses complete dl reasoner materialise certain subsumptions preprocessing step
uses jena saturate abox much abstract reasoner classify
example hence dle jena least complete jena mini addition
able draw inferences jena mini missing see
owlim complete lubm queries involve reasoning existential
quantifiers consequent implications well known latter supported
system jena mini micro exhibited exactly behaviour owlim
despite fact jena mini handle larger fragment owl owlim clearly
lubm tbox queries suciently complex reveal dierences
owlim jena mini micro
minerva guaranteed complete six queries dle jena uses
dl reasoner materialise entailed subsumptions atomic concepts uses
custom method saturating abox investigating several aboxes test
suites concluded minerva cannot correctly handle least inverse role axioms
example cannot entailment r r r b r b
finally sesame complete four queries unsurprising since sesame
rdfs reasoner thus complete small fragment owl dl
next discuss tests galen ontology test queries
q q could run jena max since galen heavily uses existential restrictions
according jenas documentation might cause minerva
system provided completeness guarantee least one query q
minerva precomputes subsumption relationships atomic concepts depend
existential restrictions right hand side tbox axioms systems
handle unlike lubm version galen used contain
inverse roles minerva performed much better ontology systems
identified incomplete test queries
non simple test suites
test queries ucq rewritable summarised table symbol
indicates concrete reasoner found complete given query furthermore whenever concrete reasoner failed test suite tried prove reasoner
incomplete discussed examples section cases successful
symbol indicates concrete reasoner identified incomplete
given query finally symbol indicates concrete reasoner ran memory
case lubm able establish completeness guarantees w r query
q owlim jena micro dle jena jena max note systems
handle recursive tbox statements completeness q surprising rdfs


ficompleteness guarantees incomplete ontology reasoners

owlim
jena max
jena micro
dle jena
minerva
sesame

lubm
q







q






galen
q q











q






table completeness guarantees datalog rewritable queries

csq

q q q q q q q q q q q q q q
time
r



table representative sets aboxes lubm times given seconds
however cannot express recursive tbox statements involving roles sesamean rdfs
reasonerfails compute certain answers tests
case galen completeness guaranteed query q owlim jena micro
dle jena minerva additionally query q minerva already mentioned
answers queries galen depend positive occurrences existential restrictions
axioms systems cannot handle could run jena max galen
comparing incomplete concrete reasoners
implemented techniques comparing reasoners section end
modified requiem compute subset closed rewritings injectively
instantiated obtain q representative sets aboxes r
tests lubm
shown table representative sets aboxes could computed seconds
lubm queries exception q requiem terminate
disabling rule subsumption optimisations size representative sets ranged
aboxes expected representative sets contain aboxes
exhaustive test suites query tbox see table
combinations system query tests section identified
system incomplete shown table table shows proportion certain
answers system returned applied lubm data set aboxes r
aboxes test suite used section check systems completeness
shown table owlim jena micro exhibited behaviour
almost complete contrast sesame least complete queries furthermore
please note dierence values obtained r particular
sesame compute certain answer q whereas system able
compute certain answers q aboxes e g lubm data set
aboxes cannot distinguish sesame trivial reasoner
returns empty set answers however set r make distinction


ficuenca grau motik stoilos horrocks

lubm

r

q




q




lubm

r

q




q




minerva
q
q
q





sesame
q
q
q
q





q




q




owlim jmicro
q
q
q










q




q




q




q




table reasoner comparison lubm

csq

time
r

q



q



q



q



table representative sets aboxes galen
tests galen
shown table representative sets aboxes galen could computed
times ranging seconds set contains small number aboxes
system query table shows proportion certain answers returned
system r test suite section minerva complete
system jena micro better dle jena apart query q dle jena
owlim behaved almost way apart query q expected
sesame least complete system
discrepancies owlim jena micro dle jena minerva rather
surprising owlim jena theoretically support features owl furthermore
dle jena extension jena meditskos bassiliades dle jena
least complete jena case lubm order explain discrepancies
analysed test suites queries q q precisely selected aboxes
owlim fails return certain answers jena micro complete
identified minimal set tbox axioms entail certain answers analysis
revealed query q owlim fails entailment
device hollowtopology b hastopology b hollowstructure

follows following galen axioms

hollowtopology topology hasstate hollow
device solidstructure

hollowstructure solidstructure hastopology topology hasstate hollow

although existential restrictions appear several axioms observe reasoning
existential variables actually required first third axioms imply simple
structural transformation following axiom
solidstructure hastopology hollowtopology hollowstructure


ficompleteness guarantees incomplete ontology reasoners

sesame
owlim
dle jena
jmicro
minerva

q

r






q

r






q

r






q

r







table reasoner comparison galen
axiom entails required answer systems deal axioms form
however unlike jena micro owlim appears incapable dealing cases
regarding dle jena according technical description meditskos bassiliades
system replaced several inference rules jena queries dl reasoner strictly extend jena investigation exhaustive test suite
query q revealed dle jena returns many answers existential
restrictions right hand side tbox axioms jena misses however investigation revealed dle jena misses several inferences jenas tbox reasoner
capture probably due replacement jenas inference rules
explains dle jena performs worse minerva galen
clearly behaviour systems greatly depends given
application scenario example dle jena complete lubm queries
perform equally well galen contrast minerva perform well
lubm complete system galen thus allow application
developers conduct thorough comparison reasoning systems given application

conclusion
proposed theoretical framework practical techniques establishing formally provable algorithmically verifiable completeness guarantees incomplete ontology reasoners radically departs ad hoc evaluation
well known benchmarks provides solid foundation striking balance
scalability completeness practical applications
opens numerous exciting possibilities future
example work opens door design ontology information systems
optimised class ontologies queries data relevant particular application information systems could maximise scalability reasoning still ensuring
completeness query answers even rich ontologies sophisticated queries

acknowledgments
extended version incomplete semantic web reasoner
giorgos stoilos bernardo cuenca grau ian horrocks published aaai
completeness guarantees incomplete reasoners authors
published iswc


ficuenca grau motik stoilos horrocks

supported eu project seals fp ict
epsrc projects exoda ep h hermit ep f b cuenca
grau supported royal society university fellowship

references
acciarri calvanese de giacomo g lembo lenzerini palmieri
rosati r quonto querying ontologies proceedings th national
conference artificial intelligence aaai pp aaai press
mit press
artale calvanese kontchakov r zakharyaschev dl lite family
relations j artificial intelligence jair
baader f mcguinness nardi patel schneider p description logic
handbook theory implementation applications cambridge university press
baader f brandt lutz c pushing el envelope proceedings
th international joint conference ai ijcai pp morgankaufmann publishers
bishop b kiryakov ognyano peikov tashev z velkov r
owlim family scalable semantic repositories semantic web
broekstra j kampman van harmelen f sesame generic architecture
storing querying rdf rdf schema proceedings st international
semantic web conference iswc pp
cal gottlob g lukasiewicz marnette b pieris datalog
family logical knowledge representation query languages applications
proc th annual ieee symposium logic computer science lics
pp
calvanese de giacomo g lembo lenzerini rosati r tractable
reasoning ecient query answering description logics dl lite family
journal automated reasoning
ceri gottlob g tanca l wanted know datalog
never dared ask ieee trans knowledge data engineering
cuenca grau b horrocks kazakov sattler u modular reuse
ontologies theory practice journal artificial intelligence

cuenca grau b horrocks motik b parsia b patel schneider p sattler u
b owl next step owl journal web semantics jws

derriere richard preite martinez ontology astronomical
object types virtual observatory proc th meeting iau
virtual observatory action science technology next generation
facilities pp prague czech republic


ficompleteness guarantees incomplete ontology reasoners

erling mikhailov rdf support virtuoso dbms pellegrini
auer tochtermann k schaert eds networked knowledge networked
media pp springer berlin heidelberg
fitting first order logic automated theorem proving nd edition texts
computer science springer
glimm b horrocks lutz c sattler u conjunctive query answering
description logic shiq proceedings international joint conference
ai ijcai pp
golbreich c zhang bodenreider foundational model anatomy
owl experience perspectives journal web semantics
goodwin j experiences owl ordnance survey proc
owl experiences directions workshop owled galway ireland
guo pan z heflin j lubm benchmark owl knowledge base
systems journal web semantics
haarslev v moller r racer system description gore r leitsch
nipkow eds proc st int joint conf automated reasoning ijcar
vol lnai pp siena italy springer
hayes p rdf semantics world wide web consortium w c recommendation
horrocks patel schneider p f van harmelen f shiq rdf
owl making web ontology language journal web semantics
kiryakov ognyanov manov owlim pragmatic semantic repository
owl dean guo jun w kaschek r krishnaswamy pan z
sheng q z eds wise workshops pp
lacy l aviles g fraser k gerber w mulvehill gaskill r experiences
owl military applications proc owl experiences directions
workshop owled galway ireland
lutz c toman wolter f conjunctive query answering description
logic el relational database system proceedings st international
joint conference ai ijcai pp
l yang qiu z xie g pan liu towards complete owl
ontology benchmark proceedings rd european semantic web conference
eswc pp
mcbride brian jena implementing rdf model syntax specification
international workshop semantic web
meditskos g bassiliades n combining dl reasoner rule engine
improving entailment owl reasoning proceedings th international
semantic web conference iswc pp
motik b cuenca grau b horrocks wu z fokoue lutz c owl
web ontology language profiles w c recommendation


ficuenca grau motik stoilos horrocks

motik b shearer r horrocks b hypertableau reasoning description
logics j artificial intelligence jair
ortiz calvanese eiter data complexity query answering expressive description logics via tableaux journal automated reasoning
perez urbina h horrocks motik b ecient query answering owl
proceedings th international semantic web conference iswc vol
lncs pp springer
perez urbina h motik b horrocks tractable query answering rewriting
description logic constraints journal applied logic
prudhommeaux e seaborne sparql query language rdf world
wide web consortium w c w c recommendation
rector l rogers j ontological practical issues description
logic represent medical concept systems experience galen barahona
p bry f franconi e henze n sattler u eds reasoning web second
international summer school pp
sidhu dillon chang e sidhu b protein ontology development
owl proc owl experiences directions workshop owled
galway ireland
sirin e parsia b cuenca grau b kalyanpur katz pellet practical
owl dl reasoner journal web semantics
soergel lauser b liang fisseha f keizer j katz reengineering
thesauri applications agrovoc example j digital information

wu z eadon g das chong e kolovski v annamalai srinivasan j
implementing inference engine rdfs owl constructs user defined
rules oracle proceedings ieee th international conference
data engineering icde pp ieee computer society




