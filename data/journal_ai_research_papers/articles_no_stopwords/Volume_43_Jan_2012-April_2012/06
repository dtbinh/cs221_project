journal artificial intelligence

submitted published

reformulating situation calculus event
calculus general theory stable
answer set programming

joohyung lee
ravi palla

joolee asu edu
ravi palla asu edu

school computing informatics
decision systems engineering
arizona state university
tempe az usa

abstract
circumscription logic programs stable model semantics two nonmonotonic formalisms former served basis classical logic
action formalisms situation calculus event calculus temporal action
logics latter served basis family action languages language
several descendants discovery circumscription stable
model semantics coincide class canonical formulas reformulate situation
calculus event calculus general theory stable present
translation turns reformulations answer set programs efficient
answer set solvers applied compute situation calculus event calculus

introduction
circumscription mccarthy logic programs stable model semantics gelfond lifschitz two well known nonmonotonic formalisms one
oldest nonmonotonic formalisms circumscription found many applications commonsense reasoning model diagnoses e g mccarthy shanahan besnard
cordier stable model semantics mathematical basis answer set programming asp marek truszczynski niemela lifschitz
widely applied thanks availability several efficient implementations known
answer set solvers
two nonmonotonic formalisms applied overlapping classes
minimal model reasoning ensured circumscription coincide stable
model reasoning moreover formalisms different roots circumscription
defined terms translation classical second order logic stable proposed
gelfond lifschitz defined terms grounding fixpoints
style reiters default logic reiter differences part account fact
two formalisms formed rather disparate traditions knowledge representation
particular area temporal reasoning former served basis
classical logic action calculi situation calculus mccarthy hayes
reiter event calculus shanahan temporal action logics doherty
c

ai access foundation rights reserved

filee palla

gustafsson karlsson kvarnstrom whereas latter served basis
family action languages language gelfond lifschitz several
descendants translated logic programs stable model semantics
however recent generalization stable model semantics shed light
relationship circumscription stable first order stable model semantics defined ferraris lee lifschitz characterizes stable
first order sentence sense first order logic sentence
satisfy stability condition expressed second order formula similar
one used define circumscription since logic programs viewed special
class first order sentences stable model semantics definition extends
stable model semantics gelfond lifschitz full first order level without
limiting attention herbrand essentially characterization independently given lin zhou via logic knowledge justified assumption lin
shoham definitions equivalent definition quantified equilibrium logic given pearce valverde defined terms logic
heyting
definition stable model motivates us investigate relationship
stable model reasoning minimal model reasoning particular focus
relationship area temporal reasoning situation calculus
event calculus reformulated first order stable model semantics
asp theoretically interesting practically useful allows us
leverage efficient answer set solvers computing circumscriptive action theories
develop two technical first circumscription
first order stable model semantics coincide class canonical formulas
largest syntactic class identified far two semantics coincide general
enough cover several circumscriptive action formalisms situation calculus
event calculus temporal action logics allows us reformulate
action formalisms first order stable model semantics minimal model reasoning
sometimes leads unintuitive circumscriptive action formalisms carefully
designed avoid cases implies minimal model reasoning
action formalisms viewed stable model reasoning
second identify class almost universal formulas turned
syntax logic program preserving stable turns reformulations situation calculus event calculus first order stable model
semantics fall class formulas introduce system f lp turns formulas
class logic programs conjunction canonical formulas use
combination f lp answer set solvers compute situation calculus
event calculus
work makes explicit relationship classical logic logic program traditions temporal reasoning interestingly development event calculus
spanned traditions original version event calculus kowalski sergot formulated logic programs stable model semantics
time invention stable model semantics extensive developments later carried classical logic foundation via circumscription e g
shanahan miller shanahan mueller relation


fireformulating situation calculus event calculus

logic program formulation remained implicit reduction circumscription completion sat event calculus systems implemented one shanahan
witkowski another mueller latter system called dec
reasoner outperforms former thanks efficient general compilation
method propositional logic system handles large fragment event
calculus still cannot handle recursive disjunctive axioms since completion cannot
applied axioms asp hand handle
full version event calculus assumption domain given finite
thanks efficiency asp solvers experiments indicate asp event
calculus reasoner significantly faster dec reasoner appendix b
similar logic programming tradition event calculus situation calculus mccarthy hayes reiter implemented prolog
fact clarks completion semantics accounts definitional axioms unlike
event calculus best knowledge efficient propositional solvers
applied directly compute situation calculus theories
reformulate lins causal action theories reiters basic action theories
first order stable model semantics asp basic action theories provide
asp encoding method obtains reiters successor state axioms effect
axioms generic inertia axioms adopted asp idea close reiters
frame default
organized follows next section reviews definitions circumscription first order stable model semantics presents definition
canonical formula sections reformulate event calculus
situation calculus first order stable model semantics section shows translation
turns almost universal formulas logic programs accepted asp
solvers sections use turn reformulations event calculus
situation calculus given sections input language asp solvers
complete proofs given appendix c

circumscription first order stable model semantics
assume following set primitive propositional connectives quantifiers
falsity
understand f abbreviation f symbol stands f g
stands f g g f
review circumscription
let p list distinct predicate constants p pn let u list distinct
predicate variables u un u p denote conjunction formulas
x ui x pi x n x list distinct object variables whose
length arity pi expression u p stands u p p u
http decreasoner sourceforge net



filee palla

instance p q unary predicate constants u v p q


x u x p x x v x q x x p x u x x q x v x
circumscription defined terms circ operator minimized predicates
first order formula f expression circ f p stands second order formula
f u u p f u
f u formula obtained f substituting ui pi f sentence
e formula free variables intuitively circ f p
f minimal p
definition straightforwardly extended case f many sorted firstorder formula lifschitz section language event calculus
situation calculus
review first order stable model semantics
review follows definition ferraris et al stable
defined terms sm operator whose definition similar circ operator
previous section first order formula f finite list predicate constants
p p pn formula sm f p defined
f u u p f u
u defined circ f p f u defined recursively follows
pi ui list terms
f f atomic formula f including equality contain
members p
f g f g
f g f g
f g f g f g
xf xf
xf xf
predicates p called intensional predicates intend
characterize f terms non intensional predicates f sentence
second order sentence sm f p called p stable f
f stable p often simply write sm f place sm f p
p list predicate constants occurring f according lee lifschitz
intensional predicates analogous output predicates datalog non intensional predicates
analogous input predicates datalog lifschitz



fireformulating situation calculus event calculus

palla answer sets defined special class stable follows f
denote signature consisting object function predicate constants occurring
f f contains least one object constant herbrand interpretation f
satisfies sm f called answer set f answer sets logic program defined
answer sets fol representation e conjunction universal
closures implications corresponding rules example fol representation
program
p
q b
r x p x q x

p q b x p x q x r x



sm f
p q b x p x q x r x
uvw u v w p q r u v b
x u x v x q x w x p x q x r x
equivalent first order sentence
x p x x x q x x b x r x p x q x



ferraris et al example stable f first order
answer set f herbrand model p q b r
according ferraris et al definition answer set applied
syntax logic programs equivalent traditional definition answer set
grounding fixpoints gelfond lifschitz
note definition stable model general definition
answer set following ways stable restricted herbrand
underlying signature arbitrary intensional predicates fixed
list predicate constants occurring formula last fact essential view
following proposition pr f denote list predicate constants occurring
f choice p denote conjunction choice formulas x p x p x
predicate constants p p x list distinct object variables false p
denote conjunction xp x predicate constants p p sometimes identify
list corresponding set confusion
proposition formula
sm f p sm f choice pr f p false p pr f



logically valid
notice implicit intensional predicates right hand side
pr f p choice formula makes predicates pr f p exempt
stability checking hand false formula makes predicates
p pr f stabilized e empty extents though occur f


filee palla

ferraris et al incorporate strong negation stable model semantics
distinguishing intensional predicates two kinds positive negative
negative intensional predicate form p p positive intensional predicate
symbol strong negation syntactically logical connective
appear part predicate constant interpretation underlying
signature coherent satisfies formula
x p x p x



x list distinct object variables negative predicate p usually
consider coherent interpretations intuitively p represents p false
different p represents known p true similarly
p represents known p false p represents
known p known true note unlike first order logic p
different p instance formula p one answer set p p
answer sets
extension circumscription many sorted first order sentences definition
stable model straightforwardly extended many sorted first order sentences
equivalence stable model semantics circumscription
canonical formulas
neither stable model semantics circumscription stronger
example
circ x p x p x p

equivalent xp x
sm x p x p x p



equivalent stronger hand
circ x p x q x p q



equivalent x p x q x
sm x p x q x p q



equivalent x p x q x stronger
section two semantics coincide class formulas called
canonical formulas define first review notions positive negative
strictly positive occurrences
definition say occurrence predicate constant subexpression formula f positive number implications containing occurrence
antecedent even negative otherwise recall treat g shorthand
g say occurrence strictly positive number implications f
containing occurrence antecedent


fireformulating situation calculus event calculus

example occurrences q positive first one strictly
positive
definition say formula f canonical relative list p predicate constants

occurrence predicate constant p antecedents one
implication f
every occurrence predicate constant p scope strictly positive
occurrence f strictly positive f
example formula
x p x q x



shown canonical relative p q since satisfy first clause
definition p occurs antecedents two implications p x shorthand
p x hand formula canonical relative q formula
x p x p x



canonical relative p since satisfy second clause second occurrence p scope strictly positive occurrence strictly positive
formula
p x p x x q x

canonical relative p q
p x p x p b x



canonical relative p q since satisfy second clause second
occurrence p scope strictly positive occurrence strictly
positive formula
following theorem states canonical formula circumscription coincides
stable model semantics
theorem canonical formula f relative p
circ f p sm f p



logically valid
instance formula canonical relative p q formulas circ p q
sm p q equivalent sentence f clearly canonical
relative circ f equivalent sm f turn equivalent f
hand equivalence may necessarily hold non canonical formulas
instance observed formula canonical relative p formulas equivalent formula canonical


filee palla

relative p q formulas equivalent observe
formula canonical relative p q circ p q equivalent
sm p q herbrand interpretation p p b satisfies sm p q
satisfy circ p q
note non canonical formulas often equivalently rewritten canonical formulas since equivalent transformation preserves circumscription theorem applied non canonical formulas first rewriting canonical
formulas example formula equivalent
x p x q x



canonical relative p q circ p q equivalent sm p q
another example formula equivalent
x p x p x



canonical relative p circ p equivalent sm p
clear treatment applied quantifier free formula including
propositional formula quantifier free formula equivalently rewritten
canonical formula first rewriting clausal normal form turning
clause form c c conjunction atoms disjunction
atoms
sections use theorem reformulate event calculus situation
calculus first order stable model semantics

reformulating event calculus general theory stable

section review syntax circumscriptive event calculus described chapter
book mueller observation syntax conforms
condition canonicality present reformulations event calculus general
theory stable
review circumscriptive event calculus
assume many sorted first order language contains event sort fluent sort
timepoint sort fluent term term whose sort fluent event term
timepoint term defined similarly
definition condition defined recursively follows
terms comparisons
conditions
appears unlikely knowledge encoded non canonical formula
cannot easily turned equivalent canonical formula c f guide axiomatizing domains
first order logic http cs nyu edu faculty davise guide html surprise
circumscriptive action theories mentioned satisfy canonicality assumption



fireformulating situation calculus event calculus

f fluent term timepoint term holdsat f holdsat f
conditions
conditions conditions
v variable condition v condition
use e ei denote event terms f denote fluent terms ti
denote timepoint terms denote conditions
event calculus circumscribe initiates terminates releases minimize
unexpected effects events circumscribe happens minimize unexpected events
circumscribe ab abnormality predicates minimize abnormalities formally event
calculus description circumscriptive theory defined
circ initiates terminates releases circ happens
circ ab ab n




conjunction universal closures axioms form
initiates e f
terminates e f
releases e f
e f e f
effect constraint
happens e happens en initiates e f
happens e happens en terminates e f
initiates terminates means
optional
conjunction universal closures temporal ordering formulas comparisons
timepoint terms axioms form
happens e
f f n fn happens e
causal constraints
happens e happens e happens en disjunctive event axiom
started stopped j j n initiated
terminated
conjunction universal closures cancellation axioms form
abi
conjunction first order sentences outside scope circ including unique
name axioms state constraints event occurrence constraints set domainindependent axioms event calculus ec continuous event calculus dec discrete event calculus mueller chapter


filee palla

includes following definitions predicates used causal constraints
def

started f holdsat f e happens e initiates e f

cc

def

stopped f holdsat f e happens e terminates e f
def

initiated f started f e happens e terminates e f
def

terminated f stopped f e happens e initiates e f

cc
cc
cc

remark following facts easy check
canonical relative initiates terminates releases
canonical relative happens
canonical relative ab ab n
facts used next section reformulate event calculus general
theory stable
reformulating event calculus general theory stable
following ferraris lee lifschitz palla formula f say
negative list p predicate constants members p strictly positive
occurrences f example formula negative p negative p q
formula form f shorthand f negative list predicates
assume already equivalently rewritten negative initiates
terminates releases happens ab ab n easily done prepending
strictly positive occurrences predicates following theorem shows
equivalent reformulations circumscriptive event calculus general theory stable

theorem event calculus description following theories equivalent

circ r circ h circ ab ab n
b sm r sm h sm ab ab n
c sm r h ab ab n
sm choice pr r h ab ab n
equivalence b immediate theorem equivalence
b c shown splitting theorem ferraris et al
assumption negative intensional predicates essential showing
note distinguish formula negative p occurrence negative
section
brevity abbreviate names circumscribed predicates



fireformulating situation calculus event calculus

equivalence details see proof appendix c equivalence
c follows proposition since
r h ab ab n pr
empty set

reformulating situation calculus general theory stable

section review reformulate two versions situation calculuslins
causal action theories reiters basic action theories
review lins causal action theories
assume many sorted first order language contains situation sort action
sort fluent sort truth value sort object sort understand expression p x
p fluent name shorthand holds p x consider functional
fluents simplicity
according lin formula called simple state formula
mention poss caused situation term possibly variable
assume causal action theory consists finite number following
sets axioms often identify conjunction universal closures
axioms following f fluent names action name v vi truth
values situation variables simple state formula symbols
action variables f variable sort fluent v variable sort truth value x
xi yi lists variables
dcaused conjunction axioms form
poss x caused f v x
direct effect axioms
caused f x v caused fn xn vn caused f x v
indirect effect axioms
dposs conjunction precondition axioms form
poss x



drest conjunction following axioms
basic axioms
caused f true holds f
caused f false holds f
true false v v true v false
r h occur domain independent axioms part





filee palla

unique name assumptions fluent names
x fj j
x x



similarly action names
foundational axioms discrete situation calculus
















p p p p p





frame axiom
poss vcaused f v
holds f holds f
axioms domain knowledge
causal action theory defined
circ dcaused caused dposs drest



remark easy check dcaused canonical relative caused
fact used next section reformulate causal action theories general
theory stable
reformulating causal action theories general theory stable

let dposs conjunction axioms poss x axiom dposs
instead second order axiom consider following first order formula dsit
introduces intensional predicate constant sit whose argument sort situation
sit sit sit ssit




following drest
theory obtained drest dropping

theorem given causal action theory following theories equivalent
disregard auxiliary predicate sit
circ dcaused caused dposs drest

b sm dcaused caused dposs drest
sm dsit sit

c sm dcaused caused sm dposs poss drest
sm dsit sit

sm dcaused dposs drest
dsit caused poss sit

simplicity omit two axioms regarding partial order among situations
suggested vladimir lifschitz personal communication



fireformulating situation calculus event calculus

review reiters basic action theories
causal action theories understand p x p fluent name shorthand
holds p x consider functional fluents
basic action theory bat form
dss dap duna ds




conjunction foundational axioms section
dss conjunction successor state axioms form
f x f x
f x formula uniform
among x



whose free variables

dap conjunction action precondition axioms form
poss x x
x formula uniform whose free variables among x
duna conjunction unique name axioms fluents actions
ds conjunction first order formulas uniform
reformulating basic action theories general theory stable

note bat theory first order logic view fact first order
logic sentence f equivalent sm f trivial view bat first order theory
stable model semantics list intensional predicates empty
rest section consider alternative encoding bat asp
need provide explicit successor state axioms dss instead successor state
axioms entailed effect axioms generic inertia axioms adopted asp
making intensional positive predicate holds negative predicate holds
recall definitions positive negative predicates section following
assume underlying signature contains predicates
asp style bat form
deffect dprecond dinertia dexogenous duna ds

duna ds defined
refer reader book reiter definition uniform formula
simplicity disregard second order axiom





filee palla

deffect conjunction axioms form

r
x holds r x




r
x holds r x





r
x


r
x



variables among x

formulas uniform whose free

dprecond conjunction axioms form
x poss x



x formula uniform whose free variables among x
dinertia conjunction axioms
holds r x holds r x holds r x
holds r x holds r x holds r x
fluent names r
dexogenous conjunction
holds r x holds r x
fluent names r
note axioms dinertia typically used answer set programming represent
common sense law inertia lifschitz turner similarly dexogenous used
represent initial value fluent arbitrary
asp style bat related reiters bat first since use
strong negation convenient define following notions given signature
bat holds signature obtained adding holds say
interpretation holds complete holds satisfies
holds holds
list distinct variables given interpretation holds expression
denotes projection
let dss conjunction successor state axioms

holds r x
r x holds r x r x



r x disjunction r x axioms deffect r x

disjunction r x axioms deffect dap denote conjunction axioms poss x x x disjunction x
axioms dprecond

axioms dinertia dexogenous closely related translation c nonmonotonic
causal logic giunchiglia lee lifschitz mccain turner



fireformulating situation calculus event calculus

theorem let theory signature holds coherent interpretation
holds complete holds satisfies

x
r x r x

every fluent name r satisfies
sm poss holds holds
iff satisfies bat
dss dap duna ds

translating almost universal sentences logic programs
theorems present reformulations situation calculus event calculus
general theory stable may contain nested quantifiers connectives
hand input languages asp solvers limited simple rule forms
analogous clausal normal form classical logic although first order formula
rewritten clausal normal form preserving satisfiability transformations
necessarily preserve stable due fact notion equivalence
stronger stable model semantics lifschitz pearce valverde
definition ferraris et al formula f strongly equivalent formula g
formula h containing f subformula possibly containing object function
predicate constants occur f g list p distinct predicate
constants sm h p equivalent sm h p h obtained h replacing
occurrence f g
words replacing subformula another strongly equivalent subformula
change stable whole formula strongly equivalent theories
classically equivalent e equivalent classical logic converse hold
consequently classically equivalent transformations necessarily preserve stable instance consider p p p intensional former stable
latter
known every propositional formula rewritten logic program cabalar
ferraris cabalar pearce valverde lee palla translations extended quantifier free formulas straightforward way section
however method work presence arbitrary quantifiers
target formalism logic programs variables implicitly universally quantified
section present translation turns certain class sentences called
almost universal sentences logic programs preserving stable turns
reformulations situation calculus event calculus sections
belong class almost universal sentences use asp solvers
computing


filee palla

translating quantifier free formulas logic programs
cabalar et al define following transformation turns propositional formula stable model semantics logic program
left side rules
f g



f g

l

f g





l

f g h



l

f g h k



f g h k



g f h


f h k
gh k



f h k
gh k


h f g k

f g



f g

r

f g





r

f g h



r

f g h k



f g h k



g f h


f gk
f h k


gf h k
h f g k

l

l

right side rules

r
r

applying transformation formula lefthand side assume
formula already written negation normal form negation applied
literals following transformation
negation normal form conversion


f
f g
f g
f g















f
f g
f g
f g

according cabalar et al successive application rewriting rules
turn propositional formula disjunctive logic program simply
extended turn quantifier free formula logic program
noted cabalar et al translation may involve exponential blowup
size theorem shows indeed vocabulary preserving
polynomial time convert general propositional theories stable model
semantics disjunctive logic programs alternatively one use another translation
linear size involves auxiliary atoms
complex


fireformulating situation calculus event calculus

quantifier elimination
introduce quantifier elimination method distinguishes two kinds occurrences quantifiers singular non singular non singular occurrence
quantifier easy eliminate singular occurrence eliminated certain
syntactic condition
definition say occurrence qxg f singular
q occurrence qxg positive f
q occurrence qxg negative f
example occurrence x q x singular occurrence x p x

non singular occurrences quantifiers eliminated view fact every
first order sentence rewritten prenex form prenex form conversion rules given
section pearce valverde preserve strong equivalence leads
following theorem
theorem lee palla proposition every first order formula strongly
equivalent formula prenex form
prenex form conversion turns non singular occurrence quantifier
outermost preserving strong equivalence consequently sentence contains
singular occurrence quantifier used turn sentence
universal sentence set asp rules however presence
singular occurrence quantifier prenex form conversion turns occurrence
outermost allowed logic programs consider handle
occurrences
obviously herbrand universe finite interested herbrand stable
e answer sets quantified formulas rewritten multiple disjunctions
conjunctions even need consider turning formula prenex form
example formula
r x p x q x



occurring theory whose signature contains n object constants
function constants replace x p x q x multiple disjunctions
turn resulting program nested expressions usual disjunctive program
lifschitz tang turner n rules generated instance n
pearce valverde sentence qnc monotonic basis quantified equilibrium
logic turned prenex form follows



filee palla

resulting logic program
r
r
r
r
r
r
r
r

p
p
p
p
q
q
q
q

p
p
q
q
p
p
q
q

p
q
p
q
p
q
p
q

translation modular depends underlying domain multiple
disjunctions conjunctions need updated domain changes importantly method applicable theory contains function constants positive
arity herbrand universe infinite
one may consider introducing skolem constants first order logic presuming
sentence f skolem form f sm f p satisfiable iff sm f p
satisfiable however idea work
example formula
f x p x q x q p x
sm f q equivalent first order sentence
q x p x x q p x
unsatisfiable equivalence established theorems ferraris et al formula f strongly equivalent prenex form

xy p x q q p



however introduce object constants b replace existentially quantified
variables
f p q q p b
formula sm f q equivalent
q p q p b
satisfiable
present method eliminating singular occurrences quantifiers introducing auxiliary predicates idea generalization practice logic programming
pearce valverde skolemization works qnc monotonic basis quantified equilibrium logic example shows imply skolemization works
quantified equilibrium logic



fireformulating situation calculus event calculus

simulates negated existential quantification body rule introducing auxiliary predicates instance order eliminate introduce
predicate constant p turn
r p x p x q x p



corresponds logic program
r p
p p x q x



sm p q r stable disregard
p method involve grounding translation depend
domain restricted herbrand method formally justified
following proposition
recall formula h negative p members p strictly positive
occurrences h given formula f say occurrence subformula g
p negated f contained subformula h f negative p
proposition let f sentence let p finite list distinct predicate constants
let q predicate constant occur f consider non strictly
positive p negated occurrence yg x f x list free variables
yg x let f formula obtained f replacing occurrence yg x
q x
sm f p x q x yg x
equivalent
sm f xy g x q x p q
proposition tells us sm f p sm f xy g x q x p q
disregard predicate constant q notice f retain
occurrence
example formula x p x q x contained negative formula relative
set intensional predicates accordance proposition sm p q r
sm p q r p disregard p
singular p negated occurrence subformula yg x eliminated
proposition first rewriting yg x yg x note yg x
strongly equivalent yg x general classically equivalent transformation may necessarily preserve stable however theorem double
negations ferraris et al reviewed appendix c tells us transformation ensured preserve p stable replaced occurrence p negated
given formula
ready present quantifier elimination method applies
class almost universal formulas


filee palla

definition say formula f almost universal relative p every singular
occurrence qxg f p negated f
example formula almost universal relative set predicates
singular occurrence x p x q x contained x p x q x
negative list predicates formula f example almost universal relative
q singular occurrence x p x contained formula
negative q singular occurrence x q p x contained x q p x
negative q
following procedure used eliminate possibly nested quantifiers
almost universal sentence
definition translation elim quantifiers given formula f first prepend
every maximal strictly positive occurrence formula form yh x
repeat following process occurrences quantifiers remaining select
maximal occurrence formula form qyg x f q x
list free variables qyg x
occurrence qyg x f non singular f set f formula
obtained f replacing occurrence qyg x g z x z
variable
b otherwise q occurrence qyg x f positive set f

f g x pg x
pg predicate constant f formula obtained f replacing occurrence qyg x pg x
c otherwise q occurrence qyg x f negative set f
formula obtained f replacing occurrence qyg x
yg x
assume predicate constants introduced translation belong
signature input formula f clear process terminates yields
formula quantifier free since number times step b applied
number quantifiers input formula formulas added
size polynomial input formula follows size resulting quantifier free
formula polynomial size input formula
following theorem tells us almost universal sentence f turned
form xg g quantifier free formula second order sentences f
g signature subset signature say f equivalent
g denoted f g class f restricted identical class
g restricted
maximality understood terms subformula relation select strictly positive
occurrence subformula f form yh x contained subformula
f form



fireformulating situation calculus event calculus

theorem let f sentence signature let f universal closure
formula obtained f applying translation elim quantifiers let q list
predicate constants introduced translation f almost universal relative
p sm f p equivalent sm f p q
statement theorem becomes incorrect require f almost
universal relative p instance elim quantifiers applied x p x
q p x q however sm x p x p p equivalent
sm x q p x q p q former equivalent saying p singleton
latter equivalent q xp x q xp x inconsistent
f lp computing answer sets first order formulas
translation elim quantifiers defined previous section introduce translation f lp turns almost universal formula logic program assume
underlying signature contains finitely many predicate constants
definition translation f lp
given formula f list intensional predicates p apply translation elim quantifiers definition f
add choice formulas q x q x non intensional predicates q
turn resulting quantifier free formula logic program applying translation section cabalar et al reviewed
section
explained section due third step transformation may involve
exponential blowup size one obtain polynomial translation replacing step
alternative translation given section cabalar et al
following theorem asserts correctness translation
theorem let f sentence signature let p list intensional predicates
let f fol representation program obtained f applying translation
f lp p intensional predicates f almost universal relative p sm f p
equivalent
sm f false p pr f
example consider one domain independent axioms discrete event calculus
dec axiom
holdsat f releasedat f
e happens e terminates e f holdsat f
step translation f lp introduces formula
happens e terminates e f q f
replaces
holdsat f releasedat f q f holdsat f




filee palla

step turns formulas rules
q f happens e terminates e f
holdsat f holdsat f releasedat f q f
turning program obtained applying translation f lp input languages
lparse gringo requires minor rewriting moving equality negated
atoms head body adding domain predicates body variables
occurring rule order reduce many sorted signature non sorted one
system f lp implementation translation f lp turns first order formula
languages lparse gringo system downloaded home
page
http reasoning eas asu edu f lp
first order formulas encoded f lp extended rule form f g
f g first order formulas contain ascii representation
quantifiers connectives shown following table
symbol
ascii

















false


true

xyz
x z

xyz
x z

example formula encoded input language f lp
holdsat f holdsat f releasedat f
e happens e terminates e f

usual lparse gringo rules rule arrow allowed
f lp rules simply copied output program returned f lp
passed asp grounders solvers accept lparse gringo languages

computing event calculus asp solvers
translation f lp turn event calculus reformulation section
answer set programs following procedure describes process
definition translation ec asp
given event calculus description rewrite
definitional axioms form
def

x p x g



x g p x g obtained g prepending
occurrences intensional predicates initiates terminates releases happens
ab ab n prepend strictly positive occurrences intensional
predicates remaining axioms let resulting formula obtained






http www tcs hut software smodels
http potassco sourceforge net
instance x q x p x turned x q x p x
alternatively done declaring variables domain directive lparse gringo
languages



fireformulating situation calculus event calculus

apply translation f lp intensional predicates
initiates terminates releases happens ab ab n p
p set predicate constants p considered step
following theorem states correctness translation
theorem let event calculus description signature contains finitely
many predicate constants let f fol representation program obtained
applying translation ec asp equivalent sm f
view theorem system f lp used compute event calculus descriptions
simple rewriting stated translation ec asp system used place
dec reasoner many existing applications event calculus robotics
security video games web service composition listed
http decreasoner sourceforge net csr decapps html
computational mechanism dec reasoner similar method
reduction event calculus reasoning propositional satisfiability uses
efficient sat solvers computation however method advantages
first significantly faster due efficient grounding mechanisms implemented
asp systems evidenced experiments reported appendix b
second f lp allows us compute full version event calculus assuming
domain given finite hand reduction implemented dec
reasoner completion weaker circumscription makes
system unable handle recursive axioms disjunctive axioms effect constraints
disjunctive event axioms section example dec reasoner allow
following effect constraints describe indirect effects agents walking
objects holding
holdsat holding initiates e inroom r
initiates e inroom r
holdsat holding terminates e inroom r
terminates e inroom r



third enhance event calculus reasoning combining asp rules
event calculus description words event calculus viewed high
level action formalism top asp illustrate example work
dogandag ferraris lifschitz rooms doors shown
figure initially robot robby middle room doors closed
goal robot make rooms accessible figure file robby
shows encoding language f lp atom door x denotes
door rooms x open x denotes event robby opening door
kim lee palla presented prototype f lp called ecasp tailored event
calculus computation



filee palla

figure robbys apartment grid
rooms x goto x denotes event robby going room x opened x
denotes door x opened inroom x denotes robby
room x accessible x denotes accessible x note rules
defining relation accessible part event calculus axioms section
example illustrates advantage allowing asp rules event calculus descriptions
minimal number steps solve given
plan combination f lp gringo grounder claspd solver disjunctive
programs following way
f lp dec robby gringo c maxstep claspd
file dec f lp encoding domain independent axioms discrete event
calculus file listed appendix following one plans found
happens open happens open happens open
happens goto happens open happens open
happens goto happens open happens goto
happens open happens open

computing situation calculus asp solvers
translation f lp turn situation calculus reformulations sections
answer set programs
representing causal action theories answer set programs
following theorem shows turn causal action theories answer set programs
theorem let finite causal action theory signature contains finitely
many predicate constants let f fol representation program obtained
applying translation f lp

dcaused dposs drest
dsit



intensional predicates caused poss sit equivalent sm f
one use clingo instead gringo claspd output f lp nondisjunctive program
file available http reasoning eas asu edu f lp along f lp encodings
domain independent axioms versions event calculus



fireformulating situation calculus event calculus

file robby
objects
step maxstep
astep maxstep maxstep
room
variables
domain step
domain room r
domain room r
domain room r
position
door r r r
door r r r
door r r r
door r r r

doors





r
r
r
r

r r r r
r r r r
r r r r
r

door r r door r r
fluents
fluent opened r r door r r
fluent inroom r
f ranges fluents
domain fluent f
events
event open r r door r r
event goto r
e e range events
domain event e
domain event e
effect axioms
initiates open r r opened r r
initiates open r r opened r r
initiates goto r inroom r
holdsat opened r r holdsat inroom r
terminates e inroom r
holdsat inroom r initiates e inroom r
action precondition axioms
holdsat inroom r happens open r r



filee palla

event occurrence constraint
happens e happens e e e
state constraint
holdsat inroom r holdsat inroom r r r
accessibility
accessible r r holdsat opened r r
accessible r r accessible r r accessible r r
initial state
holdsat opened r r
holdsat inroom
goal state
accessible r r maxstep
happens exempt minimization order plan
happens e maxstep
fluents inertial
releasedat f

figure robby f lp

similar computation event calculus section herbrand stable
computed f lp answer set solvers input f lp
simplified limit attention herbrand drop axioms
ensured herbrand order ensure finite grounding instead
dsit include following set rules situation input f lp
nesting
nesting l nesting l action l maxdepth
situation nesting l
final nesting maxdepth

situation used generate finitely many situation terms whose depth maxdepth
value given option invoking gringo splitting theorem
section c difficult check program containing rules
occurrence predicate nesting rules occurrence predicate situation head rules every answer set contains
atoms situation possible sequences actions
maxdepth though program satisfy syntactic conditions restricted gebser schaub thiele restricted syrjanen
finite domain programs calimeri cozza ianni leone answer set solvers
usually impose order ensure finite grounding rules still finitely grounded


fireformulating situation calculus event calculus

file suitcase
value
value f

lock l

lock l

domain value v
domain lock x
fluent x
fluent open
domain fluent f
action flip x
domain action
depth maxdepth
domain depth l
defining situation domain
nesting
nesting l nesting l l maxdepth
situation nesting l
final nesting maxdepth
basic axioms
h f situation caused f
h f situation caused f f
caused
caused x f flip x situation final poss flip x h x
caused x flip x situation final poss flip x h x
caused open situation h l h l
poss
poss flip x situation
frame axioms
h f h f situation final poss
v caused f v
h f h f situation final poss
v caused f v
h non intensional
h f situation

figure lins suitcase language f lp


filee palla

gringo version x check syntactic conditions difficult
see program leads finite grounding since provide explicit upper
limit nesting depth function
addition situation use following program executable order represent
set executable situations reiter
executable
executable executable poss final
situation action

figure shows encoding lins suitcase example language f lp
h used represent holds describes suitcase two locks spring
loaded mechanism open suitcase locks example
illustrates ramification handled causal action theories since fix
domain situations finite require actions effective final
situations done introducing atom final
consider simple temporal projection lin initially first lock
second lock happen first lock flipped intuitively
expect locks suitcase open automate reasoning
combination f lp gringo claspd first add executable
following rules theory figure order check theory entails flipping
first lock executable suitcase open action encode
negation facts last rule
initial situation
h l
h l
query
executable flip l h open flip l

check answer temporal projection running command
f lp suitcase gringo c maxdepth claspd

claspd returns answer set expected
consider simple opening suitcase locks
initially add executable following rules theory figure
last rule encodes goal
initial situation
h l
h l
h open
goal
executable h open

maxdepth combined use f lp gringo claspd
answer sets maxdepth finds unique answer set contains
similarly system dlv complex allows us turn finite domain checking option nofdcheck
system used conference lee palla article



fireformulating situation calculus event calculus

h open flip l flip l h open flip l flip l
encodes plan words single answer set encodes multiple plans
different branches situation tree allows us combine information
different branches one model instance hypothetical reasoning
elegantly handled situation calculus due branching time structure belleghem
denecker schreye note linear time structure event calculus
limited handle hypothetical reasoning allowed situation calculus
representing basic action theories answer set programs
since bat including second order axiom viewed first order
theory stable model semantics list intensional predicates empty
follows f lp used turn logic program focus
asp style bat
theorem let asp style bat signature contains finitely many
predicate constants let f fol representation program obtained applying translation f lp intensional predicates holds holds poss
sm holds holds poss equivalent sm f f poss
figure shows encoding broken object example discussed reiter
consider simple projection determining object next
bomb b broken bomb explodes add executable following rules
theory figure
initial situation
h broken h fragile h nexto b
h holding p h exploded b
query
executable explode b h broken explode b

command
f lp broken gringo c maxdepth claspd

returns answer set expected

related work
identifying syntactic class theories different semantics coincide important
understanding relationship known tight logic programs
tight first order formulas stable model semantics coincides completion
semantics fages erdem lifschitz ferraris et al fact helps us
understand relationship two semantics led design answer
set solver cmodels computes answer sets completion likewise class
canonical formulas introduced helps us understand relationship
stable model semantics circumscription class canonical formulas largest
http www cs utexas edu users tag cmodels



filee palla

file broken
domains situations
person p
object
bomb b
domain person r
domain object
domain bomb b
fluent holding r
fluent broken

fluent nexto b
fluent exploded b

fluent fragile

action drop r

action explode b

action repair r

domain fluent f
domain action
depth maxdepth
domain depth l
defining situation domain
nesting
nesting l nesting l l maxdepth
situation nesting l
final nesting maxdepth
effect axioms
h broken drop r situation h fragile final
h broken explode b situation h nexto b final
h exploded b explode b situation final
h broken repair r situation final
h holding r drop r situation final
action precondition axioms
poss drop r h holding r situation
poss explode b situation h exploded b
poss repair r situation h broken
inertial axioms
h f h f h f situation final
h f h f h f situation final
exogeneous
h f h f
consider interpretations complete holds
h f h f situation

figure broken object example language f lp



fireformulating situation calculus event calculus

syntactic class first order formulas identified far stable coincide
circumscription words minimal model reasoning stable
model reasoning indistinguishable canonical formulas
proposition work lee lin shows embedding propositional circumscription logic programs stable model semantics theorem
canonical formulas generalization first order case janhunen
oikarinen showed another embedding propositional circumscription logic
programs implemented system circ dlp translation appears quite
different one lee lin
zhang zhang ying zhou embedding first order circumscription
first order stable model semantics theorem reproduced follows
theorem zhang et al thm let f formula negation normal form
let p finite list predicate constants let f formula obtained f
replacing every p p let f c formula obtained f replacing
every p p choice p p p list terms circ f p
equivalent sm f f c p
comparison theorem theorem applied characterize circumscription arbitrary formulas terms stable first rewriting formulas
negation normal form theorem applicable canonical formulas
require transformation characterization bidirectional sense
viewed characterization stable terms circumscription
zhang et al introduce translation turns arbitrary first order formulas
logic programs work limited finite structures hand
translation f lp definition works almost universal formulas
limited finite structures
situation calculus event calculus widely studied action formalisms
several papers compare relate e g belleghem denecker
schreye provetti belleghem et al kowalski sadri
prolog provides natural implementation basic action theories since definitional
axioms represented prolog rules according clarks theorem reiter
chapter lloyd topor transformation used turn formulas prolog rules
similar translation f lp difference former preserves completion
semantics latter preserves stable model semantics
lin wang describe language used represent syntactically
restricted form lins causal situation calculus called clausal causal theories
allow quantifiers translate language answer set programs
strong negation answer sets used obtain fully instantiated
successor state axioms action precondition axioms quite different
computes propositional full situation calculus theories
directly
kautz selman introduce linear encodings similar propositionalized version situation calculus mccarthy hayes lin introduces
http www tcs hut software circ dlp
bit simpler original statement redundancy dropped



filee palla

action description language describes procedure compile action domain
language complete set successor state axioms strips
description extracted soundness procedure shown respect
translation action domain descriptions lins causal action theories however
procedure completion cannot handle recursive axioms unlike

denecker ternovska present inductive variant situation calculus
represented id logic denecker ternovska classical logic extended inductive definitions id logic first order stable model semantics appear closely
related precise relationship yet shown

conclusion
first order stable model semantics defined similar circumscription
takes advantage definition identify class formulas minimal model
reasoning stable model reasoning coincide uses idea reformulate situation calculus event calculus first order stable model semantics together
translation turns almost universal sentence logic program
reasoning situation calculus event calculus reduced computing
answer sets implemented system f lp front end asp solvers allows us
compute circumscriptive action theories mathematical tool sets system presented may useful relating circumscriptive theories
logic programs advances asp solvers may improve computation
circumscriptive theories

acknowledgments
grateful yuliya lierler vladimir lifschitz erik mueller heng zhang yan zhang
anonymous referees useful comments discussions authors
partially supported national science foundation grant iis

appendix file dec language f lp
file dec encodes domain independent axioms discrete event calculus file
used together event calculus domain descriptions shown section
file dec
domain
domain
domain
domain
domain
domain
domain

fluent f
fluent f
fluent f
event e
time
time
time

time maxstep


fireformulating situation calculus event calculus

dec
stoppedin f happens e terminates e f
dec
startedin f happens e initiates e f
dec
holdsat f happens e initiates e f
trajectory f f stoppedin f maxstep
dec
holdsat f happens e terminates e f
antitrajectory f f startedin f
maxstep
dec
holdsat f holdsat f releasedat f
e happens e terminates e f maxstep
dec
holdsat f holdsat f releasedat f
e happens e initiates e f maxstep
dec
releasedat f releasedat f e happens e
initiates e f terminates e f maxstep
dec
releasedat f releasedat f
e happens e releases e f maxstep
dec
holdsat f happens e initiates e f maxstep
dec
holdsat f happens e terminates e f maxstep
dec
releasedat f happens e releases e f maxstep
dec
releasedat f happens e
initiates e f terminates e f maxstep
holdsat f
releasedat f



filee palla


max step

dec
reasoner

dec
reasoner minisat

f lp
lparse cmodels

f lp
gringo cmodels

f lp
gringo clasp

f lp
clingo

busride














r



kitchen
sink



c



c



r



thielscher
circuit



c



c



r



walking
turkey







r



falling w
antitraj



c



c



r



falling w
events



c



c



r



hotair
baloon



c



c



r



telephone




c



c



r
c


r
c


r
c


r
c


r
c


r
c


r
c


r
c


r
c



r

commuter




r
c


r
c


r
c


r
c


r
c


r
c


r
c


r
c


r
c



r



number atoms c number clauses r number ground rules
figure comparing dec reasoner f lp answer set solvers

appendix b comparing dec reasoner asp event
calculus reasoner
compared performance dec reasoner v running relsat v
minisat v following
f lp v lparse v cmodels v running minisat v
beta
f lp v gringo v cmodels v running minisat v beta
f lp v gringo v clasp v claspd v used instead
disjunctive programs
f lp v clingo v clasp v
f lp turns input theory languages lparse gringo lparse
gringo turn ground asp program cmodels turns ground program
set clauses invokes sat solver compute answer sets clasp
computes answer sets techniques similar used sat solvers clingo
system combines gringo clasp monolithic way
first five examples figure part benchmark work
shanahan next four mueller increased timepoints


fireformulating situation calculus event calculus


max step
zootest


f lp
gringo cmodels


r
c
zootest
h



r
c
zootest
h



r
c
number atoms c number clauses r number
dec
reasoner minisat
h

f lp
gringo clasp


r


r


r
ground rules

figure zoo world dec reasoner asp

see notable differences examples found f lp homepage
experiments done pentium machine ghz cpu gb ram running
bit linux reported run times seconds obtained linux
time command user time sys time except dec reasoner recorded
times reported system fair comparisons order avoid including
time spent dec reasoner producing output neat format sometimes
takes non negligible time dec reasoner times parentheses sat encoding time sat solving time others times spent
grounder solver cmodels time includes time spent converting ground
program generated lparse gringo set clauses calling sat solver
time spent f lp translating event calculus description answer set
program retaining variables negligible denotes system
cannot solve example due limited expressivity instance busride includes
disjunctive event axioms disjunctive program cannot handled
clingo similarly dec reasoner cannot handle busride disjunctive event axioms
commuter compound events walking turkey effect constraints evident
experiments main reason efficiency asp efficient grounding mechanisms implemented asp grounders though dec reasoner
cmodels call sat solver minisat number atoms processed dec
reasoner general much smaller dec reasoner adopts optimized
encoding method predicate completion avoids large number
ground instances atoms initiates e f terminates e f releases e f
mueller section hand several examples number clauses
generated cmodels means answer sets found without calling
sat solver examples unique answer set coincides
well founded model efficiently computed cmodels preprocessing step
calling sat solvers benchmark examples shanahan
belong case lparse used grounding


filee palla

experiments figure solving times negligible experimented computationally hard solving takes
time grounding figure shows runs medium size action domain zoo
world akman erdogan lee lifschitz turner tests shown table
max step length minimal plan cut time
hours dec reasoner terminate within time fact entire time spent sat encoding sat solver never
called hand asp grounder gringo took seconds ground
domain unlike figure solvers took much time grounder
see cmodels minisat performed better clasp two
check time taken minisat encoding generated dec reasoner
ran zootest completion dec reasoner terminated seconds
hours

appendix c proofs
c review useful theorems
review theorems ferraris et al ferraris et al
used prove main fact provide version splitting theorem
slightly general one given ferraris et al order
facilitate proof efforts
lemma formula
u p f u f
logically valid
theorem ferraris et al thm first order formula f
disjoint lists p q distinct predicate constants
sm f p sm f choice q p q
logically valid
let f first order formula rule f implication occurs strictly positively
f predicate dependency graph f relative p directed graph
members p vertices
edge p q rule g h f
p strictly positive occurrence h
q positive occurrence g belong subformula g
negative p
theorem ferraris et al splitting thm let f g first order sentences
let p q finite disjoint lists distinct predicate constants


fireformulating situation calculus event calculus

strongly connected component predicate dependency graph f g relative
p q subset p subset q
b f negative q
c g negative p

sm f g p q sm f p sm g q
logically valid
theorem slightly general one ferraris et al
notion dependency graph yields less edges one given ferraris et al
instead
q positive occurrence g belong subformula g
negative p
ferraris et al definition
q positive occurrence g belong subformula
form k
instance according ferraris et al dependency graph
p q r p



relative p two edges p r p p dependency graph
according definition edges
hand generalization essential view following theorem
theorem ferraris et al thm double negations let h sentence f
subformula h h sentence obtained h inserting front f
occurrence f p negated h sm h p equivalent sm h p
instance sm p equivalent sm p q r p p dependency
graph p q r p relative p according definition ferraris et al
identical dependency graph relative p according definition
next say formula f clark normal form relative list p intensional
predicates conjunction sentences form
x g p x



one intensional predicate p x list distinct object variables g
free variables x completion relative p formula f
clark normal form obtained replacing conjunctive term
x p x g
following theorem relates sm completion say f tight p
predicate dependency graph f relative p acyclic
theorem ferraris et al formula f clark normal form tight
p formula sm f p equivalent completion f relative p


filee palla

c proof proposition
theorem theorem
sm f p sm f p pr f sm p pr f
sm f p pr f false p pr f
sm f choice pr f p false p pr f
sm f choice pr f p false p pr f

c proof theorem
following f formula p list distinct predicate constants p pn u
list distinct predicate variables u un length p
lemma ferraris et al lemma formula
u p f u f
logically valid
lemma every occurrence every predicate constant p strictly positive f
u p f u f u
logically valid
proof induction case f g h cases
straightforward consider
f u g u h u g h
since every occurrence predicate constants p f strictly positive g contains
predicate constants p g u equivalent g u
g h h u h u logically valid therefore sufficient prove
assumption u p
g h u g h g h u
logically valid left right clear assume u p g h u g get
h u equivalent h u h lemma conclude h

proof theorem immediate following lemma proved
induction
lemma f canonical relative p formula
u p f f u f u
logically valid


fireformulating situation calculus event calculus

proof
f atomic formula trivial
f g h follows h
f g h assume u p g h since g h canonical relative p
every occurrence every predicate constant p strictly positive g h
lemma g u equivalent g u h u equivalent h u
f g h assume u p g h sufficient
g u h u g u h u



since g h canonical relative p every occurrence every predicate constant
p g strictly positive g lemma g u equivalent
g u
case g lemma g u claim follows since g u equivalent
g u
case h h h u equivalent h u claim follows since g u
equivalent g u
f xg follows h
f xg since every occurrence every predicate constant p g strictly
positive g claim follows lemma

c proof theorem
proof b
b c

follows immediately theorem

note first equivalent sm since

every strongly connected component dependency graph relative
r h belongs r h
negative h
negative r
follows theorem b equivalent
sm r h sm ab abn sm
similarly applying theorem repeatedly formula
equivalent c
c

proposition





filee palla

c proof theorem
since dcaused canonical relative caused theorem

b
equivalent


sm dcaused caused dposs drest




consequently sufficient prove claim assumption sit
formula equivalent sm dsit sit
first note assumption equivalently rewritten

p p p p p sit

hand sit sm dsit sit equivalent
sit sit sit

p p sit p p p sit sit
assumption sit equivalent
p p p p p sit



furthermore
b c since contain poss equivalence follows
equivalence completion stable model semantics
c since dcaused contains strictly positive occurrence poss
dposs contains occurrence caused every strongly connected component
predicate dependency graph dcaused dposs relative caused poss belongs
caused belongs poss theorem follows b equivalent

sm dcaused dposs caused poss drest
sm dsit sit

similarly applying theorem two times get formula equivalent
c

c proof theorem
theory
deffect dprecond ds duna dinertia dexogenous
corresponding bat
dss dap ds duna
without loss generality assume already equivalently rewritten
exactly one positive effect axiom exactly one negative effect axiom fluent r
exactly one action precondition axiom action


fireformulating situation calculus event calculus

consider
sm deffect dprecond ds duna dinertia dexogenous poss holds holds
since duna negative intensional predicates formula equivalent
sm deffect dprecond ds dinertia dexogenous p oss holds holds duna

since p oss occur
deffect ds dinertia dexogenous
since dprecond negative holds holds theorem equivalent
sm deffect ds dinertia dexogenous holds holds
sm dprecond p oss duna



equivalent
sm deffect ds dinertia dexogenous holds holds
dap duna
therefore statement theorem proven showing following

x
r x r x







sm ds dexogenous deffect dinertia holds holds



every fluent r
satisfies

iff satisfies
ds dss
dexogenous follows equivalent
sm ds
dexogenous deffect dinertia holds holds




ds
formula obtained ds prepending occurrences holds

assumption
ds
dexogenous deffect dinertia

holds atomic tight w r relationship completion sm
stated corollary lee meng iff satisfies
ds fluent r
see section work lee meng definition



filee palla

holds r x
r x holds r x holds r x




holds r x
r x holds r x holds r x
x lists object names corresponding sorts
remains assumption satisfies iff satisfies

holds r x
r x holds r x r x



following use following facts
holds r x iff holds r x
f ground formula contain f iff f
left right assume
case holds r x clearly holds r x
two subcases consider
subcase
r x clearly satisfies lhs rhs
subcase holds r x follows
r x
x


clearly

satisfies

lhs

rhs
consequently

r
case holds r x follows
r x
x



since

holds r x

equivalent saying
r
two subcases consider
subcase
r x clearly satisfies neither lhs rhs
subcase holds r x equivalent saying
holds r x clearly satisfies neither lhs rhs
right left assume
case holds r x follows satisfies rhs
two subcases consider
subcase
r x clearly satisfies lhs rhs
follows
r x consequently satisfies neither
lhs rhs
subcase holds r x
r x clearly satisfies lhs
rhs since
x



satisfies neither lhs rhs
r
case holds r x follows
r x
holds r x
x




latter
consider

two
subcases
r


fireformulating situation calculus event calculus

subcase holds r x clearly satisfies neither lhs rhs
satisfies lhs rhs
subcase
r x clearly satisfies neither lhs rhs
satisfies lhs rhs

c proof proposition
lemma let f formula let p list distinct predicate constants let g
subformula f let g formula classically equivalent g let f
formula obtained f substituting g g occurrence g subformula
f negative p occurrence g subformula f negative
p
sm f p sm f p
logically valid
proof let f formula obtained f prepending g let f
formula obtained f prepending g theorem double
negations theorem following formulas logically valid
sm f p sm f p
sm f p sm f p
lemma follows
u p g g f u f u
logically valid u list predicate variables corresponding p consequently
sm f p sm f p
logically valid



proof proposition formula
sm f xy g x q x p q



clearly f negative q xy g x q x negative p let h
subformula f negative p contains occurrence yg x consider
two cases
case occurrence yg x h strictly positive thus dependency
graph f xy g x q x relative p q incoming edges q
case occurrence yg x h strictly positive since h negative p yg x negative p well dependency graph
f xy g x q x relative p q outgoing edges q


filee palla

therefore every strongly connected component dependency graph belongs
p q consequently theorem equivalent
sm f p sm xy g x q x q



since yg x negative q formula xy g x q x tight q theorem equivalent
sm f p x yg x q x



lemma follows equivalent
sm f p x yg x q x
consequently claim follows



c proof theorem
clear terminates yields quantifier free formula k
prove sm f p sm xk p q x list free variables k
let f formula obtained initial formula f prepending double
negations front every maximal strictly positive occurrence formulas form
yg x since f almost universal relative p occurrence subformula
f negative p thus theorem double negations theorem
sm f p equivalent sm f p note f contains strictly positive occurrence
formulas form yg x
iteration let us assume formula iteration
h hn
h transformed f previous iterations hi
formula form g x pg x introduced step b initially h f
n let r p let ri pg hi induction prove

every positive occurrence formulas form yg x hi strictly positive subformula hi negative ri
ii every negative occurrence formulas form yg x hi subformula
hi negative ri
prove step step c applied turn hk hk
sm x h r sm xn hn rn



sm x h r sm x n hn rn



equivalent
hj hj j different k xi list free variables
hi x list free variables hi


fireformulating situation calculus event calculus

indeed step part prenex form conversion preserves strong equivalence
theorem clear equivalent
step c applied turn since yh x subformula
hk negative rk equivalence follows lemma
step b applied turn hk hk introduces conjunctive term

hn formula r rn equivalent

sm x h r sm x n hn rn sm x n hn
rn



proposition due condition
let

h hm



final quantifier free formula h transformed f induction
follows sm f p equivalent

sm x h r sm x hm
rm



x list free variables hi
since every non strictly positive occurrence predicate ri hj
j positive incoming edge ri dependency graph relative
r r rm consequently every strongly connected component dependency
graph belongs one ri moreover clear hi negative
every rj j case h recall occurrence rj j
strictly positive since f h obtained contains strictly positive
occurrence formulas form yg x thus splitting theorem theorem
formula equivalent

sm x h x hm
r rm




c proof theorem
use notations introduced proof theorem theorem sm f p
equivalent theorem equivalent

sm x h x hm
choice pred p pred r rm



r p pred set predicate constants signature follows
proposition cabalar et al equivalent

sm x h x hm
choice pred p pred r rm



hi obtained hi applying translation cabalar et al
section turns quantifier free formula set rules easy see f
formula

x h x hm
choice pred p



filee palla

pred r rm p pr f written
sm f p pr f
equivalent
sm f false p pr f
proposition



c proof theorem
assume
circ initiates terminates releases circ happens
circ ab ab n
equivalent
sm initiates terminates releases sm happens
sm ab ab n



theorem
let def set definitions let formula obtained
applying step theorem follows formula def equivalent

sm x g p x p
g described step consequently equivalent
sm initiates terminates
v releases sm happens
sm ab ab n def sm x g p x p



conjunction axioms ones obtained
definitional axioms
applying theorem repeatedly follows equivalent
v
sm def x g p x
initiates terminates releases happens ab ab n p



according syntax event calculus reviewed section
every positive occurrence formula form yg contained
subformula negative
initiates terminates releases happens ab ab n p
negative occurrences formula form yg
consequently statement theorem follows theorem





fireformulating situation calculus event calculus

c proof theorem
since almost universal relative caused poss sit follows theorems

c proof theorem
dexogenous follows sm holds holds poss equivalent
sm holds holds poss obtained prepending
occurrences holds ds definition uniform formula reiter
follows almost universal relative holds holds poss follows
theorem


references
akman v erdogan lee j lifschitz v turner h representing zoo
world traffic world language causal calculator artificial
intelligence
belleghem k v denecker schreye combining situation calculus
event calculus proceedings international conference logic programming
iclp pp
belleghem k v denecker schreye relation situation
calculus event calculus journal logic programming
besnard p cordier explanatory diagnoses characterization
circumscription annals mathematics artificial intelligence
cabalar p ferraris p propositional theories strongly equivalent logic
programs theory practice logic programming
cabalar p pearce valverde reducing propositional theories equilibrium logic logic programs proceedings portuguese conference artificial
intelligence epia pp
calimeri f cozza ianni g leone n computable functions asp theory
implementation proceedings international conference logic programming iclp pp
denecker ternovska e inductive situation calculus artificial intelligence

denecker ternovska e logic nonmonotone inductive definitions acm
transactions computational logic
doherty p gustafsson j karlsson l kvarnstrom j tal temporal action
logics language specification tutorial linkoping electronic articles computer
information science issn http www ep liu se ea cis



filee palla

dogandag ferraris p lifschitz v almost definite causal theories
proceedings international conference logic programming nonmonotonic
reasoning lpnmr pp
erdem e lifschitz v tight logic programs theory practice logic
programming
fages f consistency clarks completion existence stable journal
methods logic computer science
ferraris p lee j lifschitz v perspective stable proceedings international joint conference artificial intelligence ijcai pp
ferraris p lee j lifschitz v stable circumscription artificial
intelligence
ferraris p lee j lifschitz v palla r symmetric splitting general
theory stable proceedings international joint conference artificial
intelligence ijcai pp
gebser schaub thiele gringo grounder answer set
programming proceedings international conference logic programming
nonmonotonic reasoning lpnmr pp
gelfond lifschitz v stable model semantics logic programming
kowalski r bowen k eds proceedings international logic programming
conference symposium pp mit press
gelfond lifschitz v action languages electronic transactions artificial
intelligence http www ep liu se ea cis
giunchiglia e lee j lifschitz v mccain n turner h nonmonotonic
causal theories artificial intelligence
heyting die formalen regeln der intuitionistischen logik sitzungsberichte
der preussischen akademie von wissenschaften physikalisch mathematische klasse

janhunen oikarinen e capturing parallel circumscription disjunctive
logic programs proc th european conference logics artificial intelligence
jelia pp
kautz h selman b satisfiability proceedings european
conference artificial intelligence ecai pp
kim w lee j palla r circumscriptive event calculus answer set programming proceedings international joint conference artificial intelligence
ijcai pp
kowalski r sergot logic calculus events generation
computing
kowalski r sadri f reconciling event calculus situation
calculus journal logic programming


fireformulating situation calculus event calculus

lee j lifschitz v palla r reductive semantics counting choice
answer set programming proceedings aaai conference artificial
intelligence aaai pp
lee j lin f loop formulas circumscription artificial intelligence

lee j meng first order stable model semantics first order loop formulas
journal artificial inteligence jair
lee j palla r yet another proof strong equivalence propositional
theories logic programs working notes workshop correspondence
equivalence nonmonotonic theories
lee j palla r situation calculus answer set programming proceedings
aaai conference artificial intelligence aaai pp
lifschitz v circumscription gabbay hogger c robinson j eds
handbook logic ai logic programming vol pp oxford university press
lifschitz v answer set programming proceedings aaai conference artificial intelligence pp mit press
lifschitz v datalog programs stable de moor gottlob
g furche sellers eds datalog reloaded first international workshop
datalog oxford uk march revised selected papers springer
lifschitz v pearce valverde strongly equivalent logic programs acm
transactions computational logic
lifschitz v tang l r turner h nested expressions logic programs annals
mathematics artificial intelligence
lifschitz v turner h representing transition systems logic programs
proceedings international conference logic programming nonmonotonic
reasoning lpnmr pp
lin f embracing causality specifying indirect effects actions proceedings international joint conference artificial intelligence ijcai pp

lin f compiling causal theories successor state axioms strips systems journal artificial intelligence
lin f shoham logic knowledge justified assumptions artificial
intelligence
lin f wang k causal theories logic programs sometimes
proceedings international conference logic programming nonmonotonic
reasoning lpnmr pp
lin f zhou answer set logic programming circumscription via logic
gk artificial intelligence


filee palla

marek v truszczynski stable alternative logic programming
paradigm logic programming paradigm year perspective pp
springer verlag
mccarthy j circumscriptiona form non monotonic reasoning artificial intelligence
mccarthy j applications circumscription formalizing common sense knowledge artificial intelligence
mccarthy j hayes p philosophical standpoint
artificial intelligence meltzer b michie eds machine intelligence vol
pp edinburgh university press edinburgh
miller r shanahan event calculus classical logic alternative axiomatisations electronic transactions artificial intelligence
mueller e commonsense reasoning morgan kaufmann
mueller e event calculus reasoning satisfiability journal logic
computation
niemela logic programs stable model semantics constraint programming
paradigm annals mathematics artificial intelligence
pearce valverde first order nonmonotonic extension constructive
logic studia logica
provetti hypothetical reasoning actions situation calculus event
calculus computational intelligence
reiter r logic default reasoning artificial intelligence
reiter r frame situation calculus simple solution sometimes completeness goal regression lifschitz v ed artificial
intelligence mathematical theory computation papers honor john mccarthy pp academic press
reiter r knowledge action logical foundations specifying implementing dynamical systems mit press
shanahan circumscriptive calculus events artif intell
shanahan solving frame mathematical investigation
common sense law inertia mit press
shanahan event calculus explained artificial intelligence today lncs
pp springer
shanahan witkowski event calculus satisfiability
journal logic computation
syrjanen cardinality constraint programs proceedings european conference logics artificial intelligence jelia pp
zhang h zhang ying zhou translating first order theories logic
programs proceedings international joint conference artificial intelligence
ijcai pp




