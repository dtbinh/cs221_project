journal artificial intelligence

submitted published

computing pairs shortest paths
leveraging low treewidth
leon planken
mathijs de weerdt

l r planken tudelft nl
deweerdt tudelft nl

faculty eemcs delft university technology
delft netherlands

roman van der krogt

roman c ucc ie

cork constraint computation centre
university college cork cork ireland

abstract
present two efficient computing pairs shortest paths
operate directed graphs real possibly negative weights make use
directed path consistency along vertex ordering run n wd
time wd graph width induced vertex ordering graphs constant
treewidth yields n time optimal chordal graphs
run nm time addition present
variant exploits graph separators

arrive run time nwd n sd general graphs sd wd size
largest minimal separator induced vertex ordering empirically
constructed realistic benchmarks many cases outperform
floydwarshalls well johnsons

represent current state


art run time n nm n log n respectively
used spatial temporal reasoning simple temporal
underlines relevance scheduling community

introduction
finding shortest paths important fundamental communication
transportation networks circuit design bioinformatics internet node traffic social networking graph analysis generale g computing betweenness girvan newman sub many combinatorial
represented network flow particular context
scheduling finding shortest paths important solve set binary linear constraints
events e simple temporal stp dechter meiri pearl
stp turn appears sub np hard temporal constraint satisfaction
tcsp dechter et al disjunctive temporal dtp stergiou
koubarakis powerful enough model e g job shop scheduling shortest path computations applications account significant
part total run time solver thus hardly surprising topics received substantial interest scheduling community satish kumar
bresina jonsson morris rajan rossi venable yorke smith shah
williams conrad shah williams
c

ai access foundation rights reserved

fiplanken de weerdt van der krogt

instances stp called simple temporal networks stns natural representation directed graphs real edge weights recently specific interest
stns stemming hierarchical task networks htns castillo fernandez olivares
gonzalez bui yorke smith graphs sibling restricted
property task represented pair vertices connected sibling tasks
parent children graphs number children task restricted
constant branching factor therefore resulting stns tree structure
canonical way solving stp instance dechter et al computing
pairs shortest paths apsp stn thus achieving full path consistency
graphs n vertices edges done n time floydwarshall
floyd warshalls formulation efficiently computing
transitive closure boolean matrices however state art computing apsp
sparse graphs technique originally proposed johnson
preprocessing allow n runs dijkstras
fibonacci heap fredman tarjan runs n log n nm time
remainder refer johnson
present two apsp real edge weights section one dubbed chleqapsp point point shortest path
chleq named snowball similar planken de weerdt
van der krogts enforcing partial instead full path consistency p c advance state art computing apsp
graphs constant treewidth sibling restricted stns htns
con

stant branching factor run time
bounded n
optimal since output n addition stns examples graphs
constant treewidth outerplanar graphs graphs bounded bandwidth graphs
bounded cutwidth series parallel graphs bodlaender
chleqapsp snowball applied chordal graphs run time
nm strict improvement
state art chaudhuri zaroliagis

run time nmwd wd defined chordal graphs important
subset general sparse graphs interval graphs trees k trees split graphs special
cases chordal graphs golumbic moreover graph made chordal
called triangulation operates eliminating vertices one
one connecting neighbours eliminated vertex thereby inducing cliques
graph
induced width wd vertex ordering defined equal cardinality
largest set neighbours encountered upper
bound run time
proposed general graphs n wd depends induced
width finding vertex ordering minimum induced width however np hard
arnborg corneil proskurowski minimum induced width
tree likeness property graph mentioned e treewidth denoted w
contrast induced width direct measure input graph bound
n wd quite proper still better bound johnson wd log n
prefer write x f n instead common x f n formally right hand
side represents set functions grow strictly slower f n traditional equality
fact works one direction see graham knuth patashnik section



ficomputing apsp leveraging low treewidth


see note bound johnson never better n log n regardless
value
present variant snowball exploits graph separators
attains upper bound run time nwd n sd upper bound even
better one two since sd wd size largest
minimal separator induced vertex ordering theoretical bounds run
time usually give good indication performance see especially
last variant predict best settings
section therefore experimentally establish computational efficiency
proposed wide range graphs varying random scale free networks
parts road network york city stns generated htns job shop
scheduling
first give detailed introduction required concepts
induced width chordal graphs triangulation present
analysis

preliminaries
section briefly introduce enforces directed path consistency dpc vertex ordering required
present pairs shortest paths require enforcing dpc
stronger property first step treatment assume weights edges
graph real possibly negative
directed path consistency
dechter et al presented dpc included way check whether
stp instance consistent equivalent checking graph
contain negative cycle closed path negative total weight takes
input weighted directed graph g hv ei vertex ordering bijection
v natural numbers n simply represent ith
vertex ordering natural number possibly negative weight
arc j represented wij r shorthand existence arc
vertices direction j e finally denote gk graph
induced vertices k likewise set vertices v v gv denotes graph
induced v particular gv gn g
iteration k adds edges line pairs lower numbered
neighbours j k thus triangulating graph moreover lines updates
edge j weight paths k j j k shorter
consequently j defining property dpc ensures wij higher
total weight path j consists vertices outside gj except
j implies particular running dpc w w
labelled shortest paths vertices
note algorithmssuch bellmanfordcan used purpose well usually
perform better practice



fiplanken de weerdt van der krogt

dpc dechter et al
input weighted directed graph g hv ei vertex ordering v n
output dpc version g inconsistent g contains negative cycle



k n
forall j k k j k e
wij min wij wik wkj
wji min wji wjk wki
e e j
wij wji
return inconsistent
end
end
end



return g hv ei











run time dpc depends measure wd called induced width relative
ordering vertices dechter et al define induced width vertex
ordering procedurally exactly highest number neighbours j k j k
encountered dpc includes neighbours original graph e
j k e well vertices became neighbours edges added
earlier iteration however definition original
graph vertex ordering making use following
proposition suppose g hv ei undirected graph v n
bijection vertex ordering suppose given n sets
edges ek k n defined follows


ek j k v j k path k j g j k k n
ek exactly set edges visited iteration k dpc
proof note definition set ek superset original edges
vertex k lower numbered neighbours use fact prove equivalence
induction
equivalence holds first iteration k n en exactly set
original edges vertex n lower numbered neighbours earlier
iterations dpc may added edges j k j k assuming
equivalence holds sets e k holds ek
inductive case prove inclusion relations separately
reach contradiction assume exists edge j k ek j k
visited dpc iteration k ek includes original edges
k lower numbered neighbours must edge added earlier
iteration k must exist edges j k e induction hypothesis
j k therefore connected induced subgraph g j k n


ficomputing apsp leveraging low treewidth

must connected larger subgraph g j k k n thus definition
included ek contradiction
assume reaching contradiction exists edge j k ek
part e iteration k dpc therefore visited clearly
j k cannot one original edges definition ek must therefore
exist path least one intermediate vertex j k induced subgraph
g j k k n let lowest numbered vertex j k path
k j induction hypothesis must exist edges
j k e visited dpc iteration
reach contradiction since dpc must added j k e iteration k
formally define induced width follows conclude proposition
equivalent original procedural definition
definition given undirected graph g hv ei vertex ordering n sets
edges ek proposition induced width wd g relative following
measure

wd max fiek
kv

follows run time dpc property graph per se rather
dependent graphand vertex ordering used careful implementation
dpcs time bound nwd ordering known beforehand
edges added dpc called fill edges make graph chordal sometimes
called triangulated indeed dpc differs triangulation procedure
manipulation arc weights chordal graph every cycle length four
edge joining two vertices adjacent cycle definition number
edges chordal graph denoted mc nwd give formal
definitions concepts


definition given graph g hv ei set v v v k v vertices
form cycle g chord
cycle edge non adjacent vertices
cycle e edge v v j e j k graph g hv ei called chordal
cycles size larger chord
definition given graph g hv ei triangulation g e
set edges g hv e chordal edges called fill edges
minimal triangulation g exists proper subset
triangulation g
finding vertex ordering
principle dpc use vertex ordering make graph chordal directionally path consistent however since vertex ordering defines induced width
directly influences run time number edges mc resulting graph mentioned introduction finding ordering minimum induced width wd w
even determining treewidth w np hard general still
class constant treewidth graphs recognised optimally triangulated n


fiplanken de weerdt van der krogt

time bodlaender g already chordal perfect ordering resulting fill edges time e g maximal cardinality search mcs tarjan
yannakakis perfect ordering called simplicial ordering every vertex k together lower numbered neighbours ordering induces clique
simplex subgraph gk implies following known relating induced
width treewidth size largest clique g
proposition graph g chordal size largest clique exactly w
non chordal graph g triangulated along vertex ordering yielding chordal graph g
size largest clique g exactly wd treewidth g equals wd
upper bound treewidth original graph g w wd
general graphs heuristics exist often produce good mention
minimum degree heuristic rose iteration chooses vertex
lowest degree since ordering produced heuristic fully known
dpc starts depends fill edges added adjacency list implementation
require another log n factor dpcs time bound however purposes
article afford
comfort maintaining adjacency matrix yields bounds

n nwd time n space

pairs shortest paths
even though best knowledge dpc apsp yet
proposed computing single source shortest paths sssp dpc
obtained known relatively straightforward manner chleq
proposed point point shortest path trivial adaptation computes
sssp planken de weerdt yorke smith implicitly compute sssp part
ippc run mc time thus
simply run

vertex yield apsp nmc n wd time complexity
first adapt chleqs compute apsp present
efficient named snowball relates planken et al p c
chleqs
chleqs point point shortest path simply called minpath computes shortest path two arbitrary vertices v directionally pathconsistent graph g reproduced seen run mc
time edge considered twice shortest distance source
vertex maintained array iterates downward
upward updating distance array shorter path found
since sink vertex used bound second loop clear
actually contains shortest distances pairs therefore
easily adapt compute sssp within mc time bound setting
n returning entire array instead call chleqapsp
included calls sssp referred minpaths n times
compute pairs shortest paths nmc nwd time


ficomputing apsp leveraging low treewidth

minpath chleq
input weighted directed dpc graph g hv ei
arbitrary source vertex destination vertex
output distance inconsistent g contains negative cycle



v

k
forall j k j k e
j min j k wkj
end
end
k
forall j k j k e
j min j k wkj
end
end



return













chleqapsp
input weighted directed graph g hv ei vertex ordering v n
output distance matrix inconsistent g contains negative cycle



g dpc g
return inconsistent dpc



n
minpaths g
end



return






fiplanken de weerdt van der krogt

snowball
input weighted directed graph g hv ei vertex ordering v n
output distance matrix inconsistent g contains negative cycle



g dpc g
return inconsistent dpc



j v j
v
k n
forall j k j k e
forall k
k min k j wjk
k min k wkj j
end
end
end



return











snowball
section present computes apsp full path consistency
dubbed snowball included asymptotic worst case time
bounds chleqapsp requires strictly less computational work
chleqapsp first ensures input graph directionally pathconsistent idea behind grow execution
outermost loop clique k computed shortest distances one vertex
time starting trivial clique consisting vertex dpc performed
backward sweep along snowball iterates direction adding vertex k
clique two inner loops ensure compute distances k
vertices k works know dpc pair k
must exist shortest path k form j k vice versa
j k e j k edge chordal graph means
needs look vertices j k follows inductively j
j guaranteed correct earlier iteration
name derives snowball effect clique computed
distances grows quadratically course operation small example
operation snowball given figure originally graph contained shortest path
dashed edges added dpc path
shortest path particular w holds correct value snapshot taken
k shaded vertices already visited shortest distances j
computed j iteration k j
sets correct weight taking sum w
theorem
snowball correctly computes pairs shortest paths nmc
n wd time


ficomputing apsp leveraging low treewidth









figure snapshot k graph operation snowball

proof proof induction enforcing dpc w w labelled
shortest distances vertices k j
sets correct values
assume j set correctly vertices j k let v
v v v k shortest path k let hmax
arg maxh vh dpc hmax exists path
weight shortcut vhmax vhmax taken argument repeated
conclude must exist shortest path k lies completely gk
except last arc gk thus induction hypothesis observation
considers arcs subgraph gk k k set correct
value analogous argument holds k
regard time complexity note two outermost loops
together mc edges chordal graph visited exactly
inner loop fewer n iterations yielding run time nmc time


observation mc nwd state looser time bound n wd
briefly discuss consequences two special cases graphs constant
treewidth chordal graphs chordal graphs recognised time
substitute mc run time complexity described
perfect ordering exists found time gives total run time
complexity nm likewise stated given constant
determined n time whether graph treewidth w vertex ordering wd w found within time bound omitting
constant factor wd runs n time follows pseudocode noting every vertex k constant number w
neighbours j k
note similarity snowball p c planken et al
presented snowball p c operates enforcing dpc followed
single

backward sweep along vertex ordering p c computes nwd time shortest


fiplanken de weerdt van der krogt

p c planken et al
input weighted directed graph g hv ei vertex ordering v n
output ppc version g inconsistent g contains negative cycle



g dpc g
return inconsistent dpc



k n
forall j k k j k e
wik min wik wij wjk
wkj min wkj wki wij
end
end



return g







paths arcs present chordal graph similarity property chordal
graphs fact prompt us present version snowball improved time complexity
improving run time complexity separators

section present improvement snowball nwd n sd run time
sd size largest minimal separator chordal graph obtained
triangulation along
definition given connected graph g hv ei separator set v v
gv v longer connected separator v minimal proper subset v
separator
bound better seen holds sd wd improvement hinges property chordal graphs called partial path consistency ppc
partially path consistent graph arc labelled length shortest path
endpoints p c presented depends dpc computes ppc
nwd time current state art use clique tree
ppc graph compute shortest path vertices figure shows example
chordal graph associated clique tree clique tree following useful
properties heggernes section
property every chordal graph g hv ei associated clique tree hc si
constructed linear time mc
property clique tree node c c associated subset vc v induces
maximal clique g conversely every maximal clique g associated clique tree
node c c
property coherent vertex v v clique tree nodes whose associated
cliques contain v induce subtree
full path consistency fpc achieved arc exists pairs vertices u v v



ficomputing apsp leveraging low treewidth

chordal graph

b clique tree

figure chordal graph clique tree shaded shape represents maximal
clique graph containing vertices corners
property two clique tree nodes ci cj c connected edge ci cj
vci vcj minimal separator g conversely minimal separator v g
clique tree edge ci cj v vci vcj
property
vertices appear least one clique associated node

v

v

cc c
since proposition page size largest clique chordal
graph exactly wd follows properties sd wd

idea behind snowballseparators first compute ppc nwd time
p c traverse clique tree ppc ensures shortest paths within clique
computed traversing clique tree arbitrary root node
grow set vvisited vertices cliques whose nodes already traversed
clique node c c visited traversal shortest paths vertices
clique vc vertices vvisited must run separator vsep c cs
parent sd size largest minimal separator g
pair vertices

suffices consider sd alternative routesfor total n sd routes yielding
stated overall time complexity nwd n sd formally present
idea associated recursive procedure processcliquetreenode
following page
note visit nodes parent visiting node
holds vcparent vvisited note simplicity presentation assume
graph connected simply connected components linear
time construct clique tree
improved edge original separators
small treewidth htn sibling restricted stns described
part experimental validation section instance many separators

size every task many n subtasks every task subtasks

induces clique
wd n sd implying snowballseparators still


optimal n time complexity instances
proceed prove correct meets stated run time
bounds introduce following definition
however since general every task subtasks form clique low value sd usually
attained practice



fiplanken de weerdt van der krogt

snowballseparators
input weighted directed graph g hv ei vertex ordering v n
output distance matrix inconsistent g contains negative cycle











g p c g
return inconsistent p c
j v j
v
j e j wij
j e j wji
build clique tree hc si g
select arbitrary root node croot c
vvisited processcliquetreenode croot nil
return

procedure processcliquetreenode c cparent vvisited
input current clique tree node c cs parent cparent distance matrix set
visited vertices vvisited
output updated matrix set vvisited



cparent nil
vnew vc vcparent
vsep vc vcparent
vother vvisited vc
forall j k vnew vsep vother
k min k j j k
k min k k j j
end
end
vvisited vvisited vc
forall children c c
vvisited processcliquetreenode c c vvisited
end



return vvisited
















recursive call

ficomputing apsp leveraging low treewidth

definition define distance matrix valid set u vertices u
valid pair pairs vertices j u u j holds shortest distance
g j
split correctness proof three parts lemmas
culminate theorem first step processcliquetreenode called
valid pair u clique node c procedure extends validity
u vc
lemma consider call procedure processcliquetreenode arguments clique
node c cs parent cparent distance matrix set visited vertices vvisited
valid vvisited upon calling becomes valid vc vvisited running lines
processcliquetreenode
proof first note property vc induces clique g therefore edges exist
pair k vertices vc since graph ppc wik labelled
shortest distance k due lines main
contains shortest distances valid vc
remains shown pair vertices k vc vvisited
shortest distances k k set correctly case k
case analogous
desired follows trivially cparent nil since procedure called
vvisited otherwise let vnew vc vcparent vsep vc vcparent vother vvisited vc
set procedure lines k lies vsep correctness k
value already proven need consider pairs vertices k vnew vother
pair k vsep separator k property
shortest path k necessarily concatenation shortest paths j
j k j vsep since follows definitions vnew vsep vother
j vnew vsep j k vsep vother j j k correctly
set validity vc vvisited respectively loop lines yields
desired
next step prove recursive calls validity fact extended
entire subtree rooted c
lemma consider call procedure processcliquetreenode arguments
clique node c cs parent vcparent distance matrix set visited vertices vvisited

valid vvisited upon calling returned updated pair vvisited

valid
proof first note lemma valid vvisited update line
assume clique tree depth proof reverse induction
depth clique tree node c clique tree node depth e leaf loop
lines op immediately obtain desired
assume lemma holds nodes depth k let c clique tree
node depth k first call made child node c loop
lines lemma applied consequence returned updated


fiplanken de weerdt van der krogt

pair valid argument repeated loop ends procedure
returns valid pair
disposal state prove main theorem
section
theorem
snowballseparators correctly computes pairs shortest paths

nwd n sd time
proof note vvisited call processcliquetreenode line snowball
separators therefore pair vvisited trivially valid lemma call thus
returns valid updated pair vvisited since processcliquetreenode recursively tras
versed entire clique tree vvisited contains union cc vc cliques clique
tree hc si property equals set vertices g therefore
contains correct shortest paths pairs vertices graph

time complexity note initialisations lines carried

n time whereas lines require mc time property
clique tree built linear time mc since clique tree contains
n nodes

processcliquetreenode called n times line requires wd time implement
lines processcliquetreenode represent characteristic function
vvisited array size n vvisited instead vcparent everywhere simply
iterate wd members vc perform required computations
complexity loop lines remains shown note
vsep sd definition vother n observation
n vertices graph appears vnew exactly one invocation processcliquetree
node
becomes staunch member vvisited obtain total time bound

n sd loop invocations
recursive description perhaps easier grasp satisfies claimed
time bounds found efficiency benefited practice iterative implementation
turns good heuristic first visit child nodes connected already
visited subtree large separator postponing processing children connected
small separator set visited vertices still small way sum
terms vsep vvisited kept low implementation therefore used priority queue
clique nodes ordered separator sizes future must point whether
feasible determine optimal traversal clique tree within given time bounds
presented proven correctness formal complexity move empirical evaluation performance

experiments
evaluate two together efficient implementations floydwarshall
johnson fibonacci heap across six different benchmark sets
johnson used corrected fibonacci heap implementation fiedler since widely
used pseudocode cormen leiserson rivest stein contains mistakes
available
http dx doi org uuid c c fb f cca edccf



ficomputing apsp leveraging low treewidth

table properties benchmark sets
type
chordal
figure
figure
scale free
figure
figure
york
diamonds
job shop
htn

cases

n



wd

sd



















































properties test cases summarised table table lists number
test cases range number vertices n edges induced width wd produced
minimum degree heuristic well size largest minimal separators sd
graphs details different sets found one thing
stands immediately sd often equal marginally smaller wd
however median size minimum separator less instances except
constructed chordal graphs
implemented java went intensive profiling phase
experiments run java openjdk b server mode intel
xeon e cpus running bit linux java processes allowed maximum
heap size gb used default stack size report measured cpu times
including time spent running triangulation heuristic chleqapsp
snowball reported run times averaged runs unique instance
moreover generated unique instances parameter setting obtained
different random seeds thus reported statistic represents average runs
unless otherwise indicated finally graph instance ensured contain cycles
negative weight
triangulation
discussed section finding optimal vertex ordering minimum induced
width np hard several efficient triangulation heuristics exist
ran experiments six different heuristics minimum fill minimum degree
heuristics static variants taking account original graph ordering
produced running maximum cardinality search mcs original graph
random ordering except minimum fill time complexities within bound
run time chleqapsp snowball found minimum degree heuristic
gave average induced widths less higher found minimum fill
implementations available binary form
http dx doi org uuid e c ee c b



fiplanken de weerdt van der krogt

table summed induced width triangulation total run time snowball
experiments general non chordal graphs minimum degree heuristic
best choice
heuristic
min fill
min degree
mcs
static min fill
static min degree
random

p

wd







triangulation







snowball








total







drastically lower run time exorbitant time consumption minimum
fill heuristic partially explained fact used libtw package
compute ordering whose implementation probably improved however
known literature theoretical bound minimum fill heuristic
worse minimum degree kjrulff heuristics
slower minimum degree yield induced width least higher resulting
longer total triangulation time longer total run time snowball see summary
benchmarks given table confirms kjrulffs earlier
work experimental included therefore
minimum degree heuristic
chordal graphs
evaluate performance chordal graphs construct chordal
graphs fixed size vertices treewidth ranging less
number vertices thus yielding nearly complete graph high end
experiment depicted figure figures error
bars represent standard deviations measured run time instances
size graphs induced width three quarters number vertices
snowball significantly outperforms floydwarshall yields expected horizontal line
overall run time well johnson across
entire range figure shows run times chordal graphs constant treewidth
increasing number vertices two outperform johnson
nearly order magnitude factor snowball around n even
regarding floydwarshall confirming expectations theoretical upper bounds
general graphs

general non chordal graphs expect theoretical analysis nwd time chleqapsp snowball faster johnson nm n log n
available http treewidth com



ficomputing apsp leveraging low treewidth



time solve ms log scale

f w
johnson
chleq
snowball









induced width log scale

figure run times generated chordal graphs fixed number vertices
varying treewidth

e

f w
johnson
chleq
snowball

time solve ms log scale











number vertices log scale



figure run times generated chordal graphs fixed treewidth



fiplanken de weerdt van der krogt


f w
johnson
chleq
snowball

time solve ms log scale

















induced width









figure run times scale free benchmarks graphs vertices varying
induced width
time bound wd low johnson faster sparse graphs low
large induced width wd main question induced width changeover
occurs regarding floydwarshall n bound expect larger n
outperformed
scale free graphs
scale free networks networks whose degree distribution follows power law
large values k fraction p k vertices network k connections
vertices tends p k ck constant c parameter words
vertices many connections many vertices connections
property found many real world graphs social networks
internet instances randomly generated albert barabasis
preferential attachment method iteration vertex added graph
attached number existing vertices higher degree existing
vertex likely connected newly added vertex see
induced width johnson faster compare run times generated graphs
vertices varying number attachments vertex
n obtain graphs induced width ranging graphs
induced width already quite large small attachment values example
value induced width already
experiment found figure see
induced width attachment value snowball efficient higher
induced widths johnson becomes efficient wd around even floydwarshall
becomes faster snowball consistent observation different angle
made figure induced width number edges


ficomputing apsp leveraging low treewidth

time solve ms log scale



f w
johnson
chleq
snowball













number vertices







figure run times scale free benchmarks graphs induced widths
varying vertex count
number vertices varied
see small graphs vertices johnson fastest snowball overtakes
around vertices chleqapsp faster johnson holds
sparse graph vertices
around mark vertices decrease run time
snowball chleqapsp artifact preferential attachment benchmark
generator since cannot generate scale free graphs specific induced width
modify attachment value instead turns graphs size one
attachment value yields induced width within desired range graph size
width high end interval whereas graph size near
low end explains reduced run time larger graph
scale free networks conclude snowball fastest four induced width large one third number vertices
benchmark set however observe structure scale free networks
particularly high induced width relatively sparse graphs exactly
vertices connections therefore snowball efficient
relatively small attachment values
selections york road network
interesting artificially constructed graphs graphs real networks
shortest path calculations relevant first series road
network york city obtained dimacs challenge website
network large vertices edges decided compute
http www dis uniroma challenge



fiplanken de weerdt van der krogt

figure coordinates vertices york city input graph examples
extent subgraphs respectively vertices

e
f w
johnson
chleq
snowball

time solve ms log scale

e













number vertices log scale

figure run times york benchmarks subgraphs varying vertex count



ficomputing apsp leveraging low treewidth

shortest paths induced subgraphs varying sizes obtained running
simple breadth first search random starting location desired number
vertices visited extent subnetworks thus obtained illustrated
three different sizes figure subgraphs
found figure observe ranking chordal
graphs fixed treewidth diamonds floydwarshall slowest n
run time johnson chleqapsp snowball significantly faster
predecessor explained considering induced width graphs even
largest graphs induced width around considerably smaller
number vertices
stns diamonds
benchmark set instances difference logic proposed strichman
seshia bryant appearing smt lib ranise tinelli
constraint graph instance takes form circular chain diamonds
diamond consists two parallel paths equal length starting single vertex
ending another single vertex latter vertex two paths start converge
third vertex pattern repeated diamond chain final vertex
connected first one sizes diamond total number
diamonds varied benchmarks
class actually instances np complete disjunctive temporal
dtp constraints take form disjunction inequalities dtp
instance obtain stp instance e graph randomly selecting one inequality
disjunction stp probably inconsistent constraint graph
contains negative cycle remedy modifying weights constraint edges
idea behind procedure structure graph still conforms type
networks one might encounter solving corresponding dtp instance
run time mostly depends structure moreover reduce
influence randomized extraction procedure repeat different seeds
benchmark set considered instances size
diamonds fixed number varying interesting property set
graphs generated sparse ran experiments graphs
ranging size vertices induced width induced width
clearly extremely small translates chleqapsp snowball considerably
faster johnson floydwarshall evidenced figure
stns job shop scheduling
generated graphs job shop set instance real jobshop instances type available smt lib ranise tinelli
larger range included benchmark collection obtain
graphs job shop instances used extraction procedure described
previous section striking observation taken figure
difference johnson two quite pronounced
though snowball consistently fastest three small margin fact


fiplanken de weerdt van der krogt


f w
johnson
chleq
snowball

time solve ms log scale













number vertices log scale

figure run times diamonds benchmarks graphs varying vertex count



f w
johnson
chleq
snowball

time solve ms log scale









number vertices log scale



figure run times job shop benchmarks graphs varying vertex count



ficomputing apsp leveraging low treewidth

margin small likely due structure graphs reflected
relatively high induced width note run times floydwarshall
better graphs vertices larger graphs
significantly faster
stns htns
finally consider benchmark set whose instances imitate called sibling restricted
stns originating hierarchical task networks set therefore particularly interesting point view graphs constraints may occur
parent tasks children sibling tasks bui yorke smith
consider extension includes landmark variables castillo fernandez olivares
gonzalez mimic synchronisation tasks different parts network thereby cause deviation tree htn structure generate
htns following parameters number tasks initial htn tree fixed
note tasks start end point ii branching factor determining
number children task iii depth htn tree
iv ratio landmark time points number tasks
htn varying step size v probability constraints
siblings varying step size
settings graphs vertices induced widths
varying though induced width seems high light claim
constant verified wd branching factor landmarks
instances filling maximal values respectively upper
bound wd well actual maximum encountered
figure shows experiments function induced widths
graphs see larger induced widths johnson chleqapsp
come close large induced widths found high landmark ratios
indicate majority stns stemming htns snowball significantly
efficient johnson
snowballseparators
section presented version snowball improved worst case run time
vanilla snowball taking advantage separators graph section
discuss experiments comparing two variants first turn
attention benchmark regular graphs summarised
figure one see snowballseparators actually performs strictly worse sets
terms run time performance compared original snowball
however seen table largest minimal separator often equal
marginally smaller induced width even though may
separators large many may substantially smaller noted
instances median separator size prompts us run experiments
instances separator sizes artificially kept small indeed found
cases snowballseparators shows improvement vanilla snowball comparing
number update operations performedi e lines snowball lines


fiplanken de weerdt van der krogt

f w
johnson
chleq
snowball

time solve ms log scale













induced width







figure run times htn benchmarks graphs vertices
varying induced width point average instances induced width within
range k k k instances per data point


snowball
snowball sep

time solve ms log scale



chordal


scale free

ny
diamonds


htn


job shop





number vertices log scale

figure run times snowball benchmark sets listed
table



ficomputing apsp leveraging low treewidth



number updates x log scale

snowball
snowball sep
dpc
p c
















induced width







figure number distance matrix updates chordal instances vertices
largest minimal separator size varying treewidth point represents
instances
processcliquetreenode along lines dpc lines p c one
case presented figure describes collection chordal
graphs vertices largest minimal separator fixed size
treewidth varied figure includes dpc p c
respective subroutines snowball snowballseparators graphs
snowballseparators performs strictly fewer update operations snowball instances
although difference becomes smaller induced width increases number
updates shows distinct improvement snowball run times snowballseparators
improvement instead seen figure
run times snowball strictly better snowballseparators instances
snowball even seen outperform p c better theoretical bound
reason adjacency matrix data structure used snowball fast
adjacency list used p c though staying within theoretical bound inflicts larger
constant factor run time
experiments conclude graphs sizes additional
bookkeeping required snowballseparators outweighs potential improvement
number distance matrix updates
proper upper bound run time
general graphs run time proposed depends induced width wd
ordering produced triangulation heuristic induced width direct
measure input graph given upper bound run time quite proper
arrive proper bound section aim relate run time treewidth
denoted w property input however determining treewidth


fiplanken de weerdt van der krogt



time solve ms log scale

snowball
snowball sep
dpc
p c















induced width









figure run times chordal instances vertices largest minimal separator
size varying treewidth point represents instances

np hard intractable task benchmark used therefore

compare measured induced width wd w upper bound treewidth lower
bound x w unaware guarantee quality relative treewidth
minimum degree triangulation heuristic lower bound used however
calculate ratio wd x get upper bound ratio wd w
measure obtain upper bound run time expressed treewidth
least benchmark
computations found figure plot ratios
york htn scale free job shop benchmarks function lower
bound x least squares fitted functions wd x cxk showing
straight line log log plot plotted data points functions found
fitting get k york k htn k job shop
small multiplicative constants c one see plotted data
points scale free instances amenable fit therefore omit
figure
decreasing trend job shop data indicates quality triangulation
e upper bound represented induced width gradually increases lower
upper bound less factor apart indeed plot line representing
function wd x x yielding horizontal line figure describes
comfortable upper bound data points benchmark set
htn data prompts us plot function wd x x exponent slightly
higher one found least squares fit tweaked slightly
lower bound computed libtw package see http treewidth com used
mmd least c heuristic



firelative induced width vs lower bound

computing apsp leveraging low treewidth

york
htn
scale free
job shop
x

x











lower bound treewidth

figure upper bound induced width relative treewidth determined experimentally comparing lower bound treewidth
multiplicative coefficient bring view function plotted represents ample
upper bound htn benchmarks well job shop ones
fit data points york benchmark good trend
points clear lower bound spans interval
therefore cannot give upper bound set benchmarks
acceptable level confidence
however scale free data points plotted could fitted function
yielding straight line mostly follow clear curving trend hypothesis
behaviour quality upper lower bound deteriorates mostly middle
sizes benchmarks smaller larger scale free graphs easier triangulate well
give upper bound could plot line outer hull data points e g
horizontal line represented wd x x would work pessimistic assumption
would choose function highest slope upper bound
wd x x found htn benchmarks works
discussion
may conclude
benchmarks ran except
snowball
york wd x x turn w run time

chleqapsp instances therefore bounded n w
conclude section remark alternative triangulation heuristic
would use approximation bound induced width
theoretically determined example bouchitte kratsch muller todinca
give log w approximation treewidth w approximation
would

give upper bound run time snowball n w log w however run
mirrors earlier observations authors



fiplanken de weerdt van der krogt


time obtaining approximate induced width n log nw log w high
constant well work isfor nowmainly theoretical value

related work
dense directed
graphs real weights state art apsp run


n logn time chan han represent serious improvement
n bound floydwarshall profit fact graphs
occur practice number edges significantly lower n
profit exactly sparse graphs aim achieve recently
improvement published nm n log n johnsons
fredman tarjans
work sparse directed graphs running

nm n log log n time pettie theory thus faster
johnson worst cases large graphs n log n however currently
implementation exists confirmed
personal communication pettie june

upper bound n wd run time snowball smaller
established upper bound induced width small e wd log log n
course chordal graphs graphs constant treewidth
familiar one earlier work compute shortest paths leveraging low
treewidth chaudhuri zaroliagis present
answering point

wd
point shortest path queries wd n log n preprocessing time query time

direct extension apsp would imply run time n wd general
graphs ando nmwd chordal graphs computing apsp general graphs
n wd nm chordal graphs thus strict improvement
large part state art point point shortest paths focused road
networks positive edge weights studies strong focus heuristics ranging goal directed search bi directional search creating hierarchical
structure see example geisberger sanders schultes delling bauer delling
sanders schieferdecker schultes wagner one hierarchical heuristics
similarities idea chordal graphs heuristic called contraction
idea distinguish important core vertices may possible end points
vertices never used start end point latter vertices
removed bypassed one one connecting neighbours directly
restrictions input graphs shortest paths computed
assumed sometimes lead tighter bounds
example

unweighted chordal graphs apsp lengths determined n time balachandhran
rangan han sekharan sridhar pairs distance two known
see dragan overview unification approaches considering
planar graphs recent work shows apsp found n log n klein mozes


weimann improvement johnson cases n log n
context scheduling number similar apsp need
computed sequentially potentially allowing efficient dynamic even gazit provide method addition single edge
require n steps deletion n average thorup deme explain use notation x f n footnote page



ficomputing apsp leveraging low treewidth

trescu italiano
later give alternative amortized run time
n log n log n

especially context scheduling esn
sential shortest paths time points maintained often sufficient
shortest paths selection pairs maintained already mentioned
p c planken et al single shot case planken et al
describe incrementally maintains property partial path consistency
chordal graphs time linear number edges

conclusions future work
give three computing pairs shortest paths run
time bounded n graphs constant treewidth matching earlier
required n chaudhuri zaroliagis
ii nm chordal graphs improving earlier nmwd iii n wd general
graphs showing


improvement previously known tightest bound n wd bounds wd
induced width ordering used experimentally determined bounded
treewidth power benchmarks
contributions obtained applying directed path consistency combined
known graph theoretic techniques vertex elimination tree decomposition
computing shortest paths supports general idea techniques may help
solving graphically representable combinatorial main contribution
article narrow focusing improving state art single
important computing apsp
extensive experiments make recommendations
best suited type small instances
floydwarshall used probably mostly thanks simplicity yielding
straightforward implementation low overhead snowball exploit fact
perfect elimination ordering efficiently found chordal graphs makes
efficient class graphs experiments different
types general graphs conclude snowball consistently outperforms johnson
floydwarshall except induced width high experiments
snowball outperforms chleqapsp snowballseparators although
latter better bound run time surprisingly actual performance worse
snowball instances benchmark sets holds even instances
snowballseparators performs significantly fewer updates thus conclude
additional bookkeeping required snowballseparators pay
regarding experiments must noted although utmost
obtain fair comparison constant factor measurements depends significant
way exact implementation details e g whether lookup table heap used
put forward earlier work experimentally comparing shortest path mondou crainic nguyen cherkassky goldberg radzik
implementation higher constant factor snowball may caused
adhering object oriented paradigm e inheriting dpc p c superclasses
choosing reuse code rather inlining method calls nonetheless confident
general trends identified hold independently details


fiplanken de weerdt van der krogt

note strictly speaking introduced compute pairs
shortest distances one wants actually trace shortest paths
extended keep track midpoint whenever distance matrix updated
one floydwarshall pair vertices actual shortest path
graph traced n time
current implementation snowballseparators used priority queue decide
heuristically clique tree node visit next giving precedence nodes connected
large separator part clique tree already visited noted defer
answering question whether optimal ordering found efficiently future work
remark minimum degree heuristic triangulation provides snowball
natural edge delaying processing vertices number iterations
middle loop small k grows large
cherkassky goldberg compared several innovative singlesource shortest paths gave better efficiency standard bellmanford
practice worst case bound nm run time future
work investigate clever improvements exploited snowball
snowballseparators improved way influence theoretical complexity may yield better performance practice iterating vother
seen reverse traversal part clique tree visited starting cs parent
instead separator current clique node containing k
parent previously visited vertices vother keep track smallest
separator encountered backwards traversal extra asymptotic cost since
shown table largest minimal separator often hardly smaller
induced width might well pay search smaller separators plan implement
improvement near future
another possible improvement suggested following observation dpc
variant dpc proposed edge directionality taken account
iteration k neighbours j k considered directed path
k j resulting addition arc j set added arcs would often
much smaller twice number edges added standard dpc
graph produced directed variant would chordal correctness
snowball would impacted
furthermore would experimentally compare recent
pettie graphs constant treewidth chaudhuri zaroliagis future work addition interested efficient
triangulation heuristics triangulation heuristics guaranteed quality able
give guaranteed theoretical bound general graphs another direction especially
interesting context scheduling use ideas presented
design faster dynamic pairs shortest paths maintaining shortest paths
edge deletions relaxations additions tightenings

acknowledgments
roman van der krogt supported science foundation ireland grant number
rfp cms


ficomputing apsp leveraging low treewidth

offer sincere gratitude reviewers comments helped us
improve clarity article strengthen empirical
article conference title received
honourable mention best student international conference automated
scheduling planken de weerdt van der krogt

appendix johnsons heap
experiments presented johnson
fibonacci

heap theoretical bound nm n log n time attained
practice binary heap theoretical bound nm log n time turns
efficient occasions section
figure shows run times johnson binary heap fibonacci
heap benchmark sets listed table diamonds htn
york benchmarks binary heap percent faster fibonacci heap
slope lines doubly logarithmic scale conclude
average case run time similar asymptotic behavior however larger job shop
binary heap factor slower fibonacci heap chordal
graph benchmark even factor benchmark scale free graphs
fixed number vertices help explaining difference
figure run time variants johnson found scale free graphs
vertices number edges varying almost
see sparsest scale free graphs edges binary
heap slightly faster edges considered fibonacci heap
significantly outperforms binary heap particular run time fibonacci
heap implementation increases slowly number edges run time
binary heap increases much significantly explained fact
running dijkstras subroutine johnson update candidate
shortest path done amortized constant time fibonacci heap
binary heap worst case cost log n time per update number updates
bounded run dijkstras yielding bound nm updates
johnson binary heap nm log n bound accounts significant part
run time fibonacci heap operations extracting minimum
element heap bigger relative contribution run time
benchmark sets conclude although johnson
binary heap help reducing actual run time sparse graphs johnson fibonacci
heap overall better choice large



fiplanken de weerdt van der krogt

e
binary
fibonacci

time solve ms log scale

e

chordal





ny



diamonds
scale free



htn
job shop






number vertices log scale



figure run times johnson binary heap fibonacci heap
benchmark sets listed table

e
binary
fibonacci

time solve ms log scale

e

















number edges log scale





figure run times johnson binary heap fibonacci heap scale free
graphs vertices increasing number edges



ficomputing apsp leveraging low treewidth

references
albert r barabasi l statistical mechanics complex networks reviews
modern physics
arnborg corneil g proskurowski complexity finding embeddings
k tree siam journal algebraic discrete methods
balachandhran v rangan c p pairs shortest length strongly chordal
graphs discrete applied mathematics
bauer r delling sanders p schieferdecker schultes wagner
combining hierarchical goal directed speed techniques dijkstras experimental wea vol lncs pp
springer
bodlaender h l classes graphs bounded tree width tech rep ruu cs utrecht university
bodlaender h l linear time finding tree decompositions
small treewidth siam journal computing
bouchitte v kratsch muller h todinca treewidth approximations
discrete applied mathematics
bresina j l jonsson k morris p h rajan k activity
mars exploration rovers proc th int conf automated
scheduling pp
bui h h yorke smith n efficient variable elimination semi structured
simple temporal networks continuous domains knowledge engineering review
castillo l fernandez olivares j gonzalez temporal constraint network
temporal planner proc st workshop uk
scheduling special interest group pp delft netherlands
castillo l fernandez olivares j gonzalez efficiently handling temporal
knowledge htn planner proc th int conf automated
scheduling pp

chan pairs shortest paths real weights n log n time
datastructures lncs pp springer
chaudhuri zaroliagis c shortest paths digraphs small treewidth
part sequential algorithmica
cherkassky b v goldberg v radzik shortest paths theory
experimental evaluation mathematical programming
cherkassky b v goldberg v negative cycle detection mathematical programming
chleq n efficient networks quantitative temporal constraints
proc st int workshop constraint reasoning pp


fiplanken de weerdt van der krogt

conrad p r shah j williams b c flexible execution plans
choice proc th int conf automated scheduling
cormen h leiserson c e rivest r l stein c introduction nd edition mit press
dechter r meiri pearl j temporal constraint networks artificial intelligence
demetrescu c italiano g f fully dynamic pairs shortest paths
real edge weights journal computer system sciences
dijkstra e w note two connexion graphs numerische
mathematik
dragan f f estimating pairs shortest paths restricted graph families
unified journal
even gazit h updating distances dynamic graphs methods operations
fiedler n analysis java implementations fibonacci heap http tinyurl
com fibo heap
floyd r w shortest path communications acm

fredman tarjan r e fibonacci heaps uses improved network
optimization journal acm
geisberger r sanders p schultes delling contraction hierarchies
faster simpler hierarchical routing road networks proc int workshop
experimental pp springer
girvan newman e j community structure social biological
networks proc national academy sciences usa
golumbic algorithmic graph theory perfect graphs elsevier
graham r l knuth e patashnik concrete mathematics foundation
computer science st edition addison wesley
han k sekharan c n sridhar r unified pairs shortest path
chordal hierarchy discrete applied mathematics

han note n log n time pairs shortest paths
information processing letters
heggernes p minimal triangulations graphs survey discrete mathematics
minimal separation minimal triangulation
johnson b efficient shortest paths sparse networks journal
acm
kjrulff u triangulation graphs giving small total state space
tech rep aalborg university


ficomputing apsp leveraging low treewidth

klein p n mozes weimann shortestpaths directed planar graphs
negative lengths linear space n log n time acm transactions
mondou j f crainic g nguyen shortest path computational study c programming language computers operations

pettie pairs shortest paths real weighted graphs
theoretical computer science
planken l r de weerdt van der krogt r p j p c
simple temporal proc th int conf automated
scheduling pp
planken l r de weerdt van der krogt r p j computing allpairs shortest paths leveraging low treewidth proc st int conf
automated scheduling pp
planken l r de weerdt yorke smith n incrementally solving stns
enforcing partial path consistency proc th int conf automated
scheduling pp
ranise tinelli c smt lib format initial proposal proc
pragmatics decision procedures automated reasoning
rose j graph theoretic study numerical solution sparse positive
definite systems linear equations read r ed graph theory computing
pp academic press
rossi f venable k b yorke smith n uncertainty soft temporal constraint general framework controllability fuzzy
case journal ai
satish kumar k tractability restricted disjunctive temporal proc th int conf automated scheduling pp

shah j williams b c fast dynamic scheduling disjunctive temporal
constraint networks incremental compilation proc th int conf
automated scheduling pp
stergiou k koubarakis backtracking disjunctions temporal
constraints artificial intelligence
strichman seshia bryant r e deciding separation formulas
sat proc th int conf computer aided verification vol
lncs pp springer
tarjan r e yannakakis simple linear time test chordality
graphs test acyclicity hypergraphs selectively reduce acyclic hypergraphs siam journal computing


fiplanken de weerdt van der krogt

thorup fully dynamic pairs shortest paths faster allowing negative
cycles theory vol lncs pp springer
warshall theorem boolean matrices journal acm




