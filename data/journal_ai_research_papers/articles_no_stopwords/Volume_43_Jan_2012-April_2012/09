Journal Artificial Intelligence Research 43 (2012) 353388

Submitted 10/11; published 03/12

Computing All-Pairs Shortest Paths
Leveraging Low Treewidth
Leon Planken
Mathijs de Weerdt

l.r.planken@tudelft.nl
m.m.deweerdt@tudelft.nl

Faculty EEMCS, Delft University Technology,
Delft, Netherlands

Roman van der Krogt

roman@4c.ucc.ie

Cork Constraint Computation Centre,
University College Cork, Cork, Ireland

Abstract
present two new efficient algorithms computing all-pairs shortest paths.
algorithms operate directed graphs real (possibly negative) weights. make use
directed path consistency along vertex ordering d. algorithms run n2 wd
time, wd graph width induced vertex ordering. graphs constant
treewidth, yields n2 time, optimal. chordal graphs, algorithms
run (nm) time. addition, present
variant exploits graph separators

arrive run time nwd2 + n2 sd general graphs, sd wd size
largest minimal separator induced vertex ordering d. show empirically
constructed realistic benchmarks, many cases algorithms outperform
FloydWarshalls well Johnsons
algorithm,
represent current state


art run time n3 nm + n2 log n , respectively. algorithms
used spatial temporal reasoning, Simple Temporal Problem,
underlines relevance planning scheduling community.

1. Introduction
Finding shortest paths important fundamental problem communication
transportation networks, circuit design, bioinformatics, Internet node traffic, social networking, graph analysis generale.g. computing betweenness (Girvan & Newman, 2002)and sub-problem many combinatorial problems,
represented network flow problem. particular, context planning
scheduling, finding shortest paths important solve set binary linear constraints
events, i.e. Simple Temporal Problem (STP; Dechter, Meiri, & Pearl, 1991).
STP turn appears sub-problem NP-hard Temporal Constraint Satisfaction
Problem (TCSP; Dechter et al., 1991) Disjunctive Temporal Problem (DTP; Stergiou
& Koubarakis, 2000), powerful enough model e.g. job-shop scheduling problems. shortest path computations applications account significant
part total run time solver. Thus, hardly surprising topics received substantial interest planning scheduling community (Satish Kumar, 2005;
Bresina, Jonsson, Morris, & Rajan, 2005; Rossi, Venable, & Yorke-Smith, 2006; Shah &
Williams, 2008; Conrad, Shah, & Williams, 2009).
c
2012
AI Access Foundation. rights reserved.

fiPlanken, De Weerdt, & Van der Krogt

Instances STP, called Simple Temporal Networks (STNs), natural representation directed graphs real edge weights. Recently, specific interest
STNs stemming hierarchical task networks (HTNs; Castillo, Fernandez-Olivares,
& Gonzalez, 2006; Bui & Yorke-Smith, 2010). graphs sibling-restricted
property: task, represented pair vertices, connected sibling tasks,
parent children. graphs number children task restricted
constant branching factor, therefore resulting STNs tree-like structure.
canonical way solving STP instance (Dechter et al., 1991) computing
all-pairs shortest paths (APSP) STN, thus achieving full path consistency.
graphs n vertices edges, done n3 time FloydWarshall
algorithm (Floyd, 1962), based Warshalls (1962) formulation efficiently computing
transitive closure Boolean matrices. However, state art computing APSP
sparse graphs algorithm based technique originally proposed Johnson
(1977), preprocessing allow n runs Dijkstras (1959) algorithm. Using
Fibonacci heap (Fredman & Tarjan, 1987), algorithm runs n2 log n + nm time.
remainder paper, refer algorithm Johnson.
paper present two new algorithms APSP real edge weights (in Section 3). One algorithm, dubbed ChleqAPSP, based point-to-point shortest path
algorithm Chleq (1995); other, named Snowball, similar Planken, de Weerdt,
van der Krogts (2008) algorithm enforcing partial (instead full) path consistency (P3 C). new algorithms advance state art computing APSP.
graphs constant treewidth, sibling-restricted STNs based HTNs
con
2
stant branching factor, run time
algorithms bounded n ,
optimal since output n2 . addition STNs, examples graphs
constant treewidth outerplanar graphs, graphs bounded bandwidth, graphs
bounded cutwidth, series-parallel graphs (Bodlaender, 1986).
ChleqAPSP Snowball applied chordal graphs, run time
(nm), strict improvement
state art (Chaudhuri & Zaroliagis,

2000, run time nmwd2 ; wd defined below). Chordal graphs important
subset general sparse graphs: interval graphs, trees, k-trees split graphs special
cases chordal graphs (Golumbic, 2004). Moreover, graph made chordal using
so-called triangulation algorithm. algorithm operates eliminating vertices one
one, connecting neighbours eliminated vertex thereby inducing cliques
graph.
induced width wd vertex ordering defined equal cardinality
largest set neighbours encountered. upper
bound run time
proposed algorithms general graphs, n2 wd , depends induced
width. Finding vertex ordering minimum induced width, however, NP-hard
problem (Arnborg, Corneil, & Proskurowski, 1987). minimum induced width
tree-likeness property graph mentioned above, i.e. treewidth, denoted w .
contrast, induced width direct measure input (graph), bound
n2 wd quite proper. Still, better bound Johnson wd (log n).1
1. prefer write x (f (n)) instead common x = (f (n)). Formally, right-hand
side represents set functions grow strictly slower f (n), traditional equality
fact works one direction (see Graham, Knuth, & Patashnik, 1989, Section 9.2).

354

fiComputing APSP Leveraging Low Treewidth


see this, note bound Johnson never better n2 log n , regardless
value m.
paper, present variant Snowball exploits graph separators
attains upper bound run time nwd2 + n2 sd . upper bound even
better one two new algorithms, since sd wd size largest
minimal separator induced vertex ordering d. theoretical bounds run
time usually give good indication performance algorithms, see especially
last variant always predict algorithm best settings.
Section 4, therefore, experimentally establish computational efficiency
proposed algorithms wide range graphs, varying random scale-free networks
parts road network New York City, STNs generated HTNs job-shop
scheduling problems.
Below, first give detailed introduction required concepts,
induced width, chordal graphs triangulation, present new algorithms
analysis.

2. Preliminaries
section, briefly introduce algorithm enforces directed path consistency (DPC) find vertex ordering required algorithm.
present algorithms all-pairs shortest paths, require enforcing DPC (or
stronger property) first step. treatment, assume weights edges
graph real possibly negative.
2.1 Directed Path Consistency
Dechter et al. (1991) presented DPC, included Algorithm 1, way check whether
STP instance consistent.2 equivalent checking graph
contain negative cycle (a closed path negative total weight). algorithm takes
input weighted directed graph G = hV, Ei vertex ordering d, bijection
V natural numbers {1, . . . , n}. paper, simply represent ith
vertex ordering natural number i. (possibly negative) weight
arc j represented wij R. shorthand existence arc
vertices, either direction, {i, j} E. Finally, denote Gk graph
induced vertices {1, . . . , k}; likewise, set vertices V 0 V , GV 0 denotes graph
induced V 0 . So, particular, GV = Gn = G.
iteration k, algorithm adds edges (in line 5) pairs lower-numbered
neighbours i, j k, thus triangulating graph. Moreover, lines 3 4, updates
edge j weight paths k j j k i, shorter.
Consequently, < j, defining property DPC ensures wij higher
total weight path j consists vertices outside Gj (except
j themselves). implies particular running DPC, w12 w21
labelled shortest paths vertices 1 2.
2. Note algorithmssuch BellmanFordcan used purpose well, usually
perform better practice.

355

fiPlanken, De Weerdt, & Van der Krogt

Algorithm 1: DPC (Dechter et al., 1991)
Input: Weighted directed graph G = hV, Ei; vertex ordering : V {1, . . . , n}
Output: DPC version G, inconsistent G contains negative cycle

10

k n 1
forall < j < k {i, k} , {j, k} E
wij min {wij , wik + wkj }
wji min {wji , wjk + wki }
E E {{i, j}}
wij + wji < 0
return inconsistent
end
end
end

11

return G = hV, Ei

1
2
3
4
5
6
7
8
9

run time DPC depends measure wd called induced width relative
ordering vertices. Dechter et al. (1991) define induced width vertex
ordering procedurally exactly highest number neighbours j k j < k
encountered DPC algorithm. includes neighbours original graph (i.e.
{j, k} E) well vertices became neighbours edges added
earlier iteration algorithm. However, definition based original
graph vertex ordering, making use following result.
Proposition 1. Suppose G = hV, Ei undirected graph : V {1, . . . , n}
(where bijection) vertex ordering. Suppose given n sets
edges Ek0 1 k n, defined follows:


Ek0 = {j, k} V | j < k path k j G{j}{k,k+1,...,n}
Then, Ek0 exactly set edges visited iteration k DPC.
Proof. Note definition, set Ek0 superset original edges
vertex k lower-numbered neighbours. use fact prove equivalence
induction.
equivalence holds first iteration k = n, En0 exactly set
original edges vertex n lower-numbered neighbours, earlier
iterations DPC may added edges {j, k} j < k. Now, assuming
equivalence holds sets E`0 ` > k, show holds Ek0 .
inductive case, prove inclusion relations separately.
() reach contradiction, assume exists edge {j, k} 6 Ek0 , j < k,
visited DPC iteration k. Ek0 includes original edges
k lower-numbered neighbours, must new edge added earlier
iteration ` > k, must exist edges {j, `} , {k, `} E`0 . induction hypothesis,
j k therefore connected induced subgraph G{j,k}{`,`+1,...,n} .
356

fiComputing APSP Leveraging Low Treewidth

must connected larger subgraph G{j}{k,k+1,...n} thus definition
included Ek0 : contradiction.
() Assume, reaching contradiction, exists edge {j, k} Ek0
part E iteration k DPC therefore visited algorithm. Clearly,
{j, k} cannot one original edges. definition Ek0 must therefore
exist path least one intermediate vertex j k induced subgraph
G{j}{k,k+1,...n} . Let ` lowest-numbered vertex j k path;
` > k > j. Then, induction hypothesis, must exist edges
{j, `} , {k, `} E`0 , visited DPC iteration `. more,
reach contradiction, since DPC must added {j, k} E iteration ` > k.
formally define induced width follows, conclude Proposition 1
equivalent original procedural definition.
Definition 1. Given undirected graph G = hV, Ei, vertex ordering d, n sets
edges Ek0 Proposition 1, induced width wd G (relative d) following
measure:

wd = max fiEk0
kV

follows run time DPC property graph per se; rather,
dependent graphand vertex ordering used. careful implementation,
DPCs time bound nwd2 ordering known beforehand.
edges added DPC called fill edges make graph chordal (sometimes
called triangulated). Indeed, DPC differs triangulation procedure
manipulation arc weights. chordal graph, every cycle length four
edge joining two vertices adjacent cycle. Definition 1, number
edges chordal graph, denoted mc m, (nwd ). give formal
definitions concepts.


Definition 2. Given graph G = hV, Ei set v 1 , v 2 , . . . , v k V vertices
form cycle G, chord
cycle edge non-adjacent vertices
cycle, i.e. edge v , v j E 1 < j < k 1. graph G = hV, Ei called chordal
cycles size larger 3 chord.
Definition 3. Given graph G = hV, Ei, triangulation G, E = ,
set edges G0 = hV, E chordal. edges called fill edges.
minimal triangulation G exists proper subset 0 0
triangulation G.
2.2 Finding Vertex Ordering
principle, DPC use vertex ordering make graph chordal directionally path-consistent. However, since vertex ordering defines induced width,
directly influences run time number edges mc resulting graph. mentioned introduction, finding ordering minimum induced width wd = w ,
even determining treewidth w , NP-hard problem general. Still,
class constant-treewidth graphs recognised, optimally triangulated, (n)
357

fiPlanken, De Weerdt, & Van der Krogt

time (Bodlaender, 1996). G already chordal, find perfect ordering (resulting fill edges) (m) time, using e.g. maximal cardinality search (MCS; Tarjan &
Yannakakis, 1984). perfect ordering called simplicial ordering, every vertex k together lower-numbered neighbours ordering induces clique
(simplex) subgraph Gk . implies following (known) result, relating induced
width treewidth size largest clique G.
Proposition 2. graph G chordal, size largest clique exactly w + 1.
non-chordal graph G triangulated along vertex ordering d, yielding chordal graph G0 ,
size largest clique G0 exactly wd + 1. treewidth G0 equals wd
upper bound treewidth original graph G: w wd .
general graphs, various heuristics exist often produce good results. mention
minimum degree heuristic (Rose, 1972), iteration chooses vertex
lowest degree. Since ordering produced heuristic fully known
DPC starts depends fill edges added, adjacency-list-based implementation
require another (log n) factor DPCs time bound. However, purposes
article, afford
comfort maintaining adjacency matrix, yields bounds

n2 + nwd2 time n2 space.

3. All-Pairs Shortest Paths
Even though, best knowledge, DPC-based APSP algorithm yet
proposed, algorithms computing single-source shortest paths (SSSP) based DPC
obtained known results relatively straightforward manner. Chleq (1995)
proposed point-to-point shortest path algorithm trivial adaptation computes
SSSP; Planken, de Weerdt, Yorke-Smith (2010) implicitly compute SSSP part
IPPC algorithm. algorithms run (mc ) time thus
simply run
2
vertex yield APSP algorithm (nmc ) n wd time complexity.
Below, first show adapt Chleqs algorithm compute APSP; then, present
new, efficient algorithm named Snowball relates Planken et al.s (2008) P3 C.
3.1 Chleqs Approach
Chleqs (1995) point-to-point shortest path algorithm simply called Minpath computes shortest path two arbitrary vertices s, V directionally pathconsistent graph G. reproduced Algorithm 2 seen run (mc )
time edge considered twice. shortest distance source
vertex maintained array D; algorithm iterates downward 1
upward 1 t, updating distance array shorter path found.
Since sink vertex used bound second loop, clear
actually contains shortest distances pairs (s, t0 ) t0 t. Therefore,
easily adapt algorithm compute SSSP within (mc ) time bound setting
= n returning entire array instead D[t]. call result ChleqAPSP,
included Algorithm 3, calls SSSP algorithm (referred Minpaths) n times
compute all-pairs shortest paths (nmc ) nwd2 time.
358

fiComputing APSP Leveraging Low Treewidth

Algorithm 2: Minpath (Chleq, 1995)
Input: Weighted directed DPC graph G = hV, Ei;
(arbitrary) source vertex destination vertex
Output: Distance t, inconsistent G contains negative cycle

12

V : D[i]
D[s] 0
k 1
forall j < k {j, k} E
D[j] min {D[j], D[k] + wkj }
end
end
k 1
forall j > k {j, k} E
D[j] min {D[j], D[k] + wkj }
end
end

13

return D[t]

1
2
3
4
5
6
7
8
9
10
11

Algorithm 3: ChleqAPSP
Input: Weighted directed graph G = hV, Ei; vertex ordering : V {1, . . . , n}
Output: Distance matrix D, inconsistent G contains negative cycle
1
2

G DPC(G, d)
return inconsistent DPC

5

1 n
D[i][] Minpaths(G, i)
end

6

return

3
4

359

fiPlanken, De Weerdt, & Van der Krogt

Algorithm 4: Snowball
Input: Weighted directed graph G = hV, Ei; vertex ordering : V {1, . . . , n}
Output: Distance matrix D, inconsistent G contains negative cycle
1
2

G DPC(G, d)
return inconsistent DPC

12

i, j V : D[i][j]
V : D[i][i] 0
k 1 n
forall j < k {j, k} E
forall {1, . . . , k 1}
D[i][k] min {D[i][k], D[i][j] + wjk }
D[k][i] min {D[k][i], wkj + D[j][i]}
end
end
end

13

return

3
4
5
6
7
8
9
10
11

3.2 Snowball Algorithm
section, present algorithm computes APSP (or full path-consistency),
dubbed Snowball included Algorithm 4, asymptotic worst-case time
bounds ChleqAPSP requires strictly less computational work.
ChleqAPSP, algorithm first ensures input graph directionally pathconsistent. idea behind algorithm grow, execution
outermost loop, clique {1, . . . , k} computed (shortest) distances, one vertex
time, starting trivial clique consisting vertex 1; DPC performed
backward sweep along d, Snowball iterates direction. adding vertex k
clique, two inner loops ensure compute distances k
vertices < k. works know DPC pair (i, k),
must exist shortest path k form j k (and vice versa),
{j, k} E j < k edge chordal graph. means algorithm
needs look vertices i, j < k, follows inductively D[i][j]
D[j][i] guaranteed correct earlier iteration.
name algorithm derives snowball effect: clique computed
distances grows quadratically course operation. small example
operation Snowball given Figure 1. Originally, graph contained shortest path
4762513. Dashed edges added DPC, path 4213
shortest path; particular, w42 holds correct value. snapshot taken
k = 4; shaded vertices 13 already visited shortest distances D[i][j]
computed i, j 3. Then, iteration k = 4, j = 2 = 3,
algorithm sets correct weight D[4][3] taking sum w42 + D[2][3].
Theorem
3. Algorithm 4 ( Snowball) correctly computes all-pairs shortest paths (nmc )
n2 wd time.
360

fiComputing APSP Leveraging Low Treewidth

7
6
5
4
3
2
1

Figure 1: Snapshot (k = 4) graph operation Snowball.

Proof. proof induction. enforcing DPC, w12 w21 labelled
shortest distances vertices 1 2. k = 2 = j = 1, algorithm
sets D[1][2] D[2][1] correct values.
Now, assume D[i][j] set correctly vertices i, j < k. Let : = v0
v1 v`1 v` = k shortest path k, let hmax =
arg maxh{0,1,...,`} {vh }. DPC, 0 < hmax < `, exists path
weight shortcut vhmax 1 vhmax +1 taken. argument repeated
conclude must exist shortest path 0 k lies completely Gk and,
except last arc, Gk1 . Thus, induction hypothesis observation
algorithm considers arcs subgraph Gk1 k, D[i][k] set correct
value. analogous argument holds D[k][i].
regard algorithms time complexity, note two outermost loops
together result mc edges chordal graph visited exactly once.
inner loop always fewer n iterations, yielding run time (nmc ) time.

2
observation mc nwd , state looser time bound n wd .
briefly discuss consequences two special cases: graphs constant
treewidth chordal graphs. chordal graphs, recognised (m) time,
substitute mc run-time complexity; further, described above,
perfect ordering exists found (m) time. gives total run-time
complexity (nm). Likewise, stated given constant ,
determined (n) time whether graph treewidth w , so, vertex ordering wd = w found within time bound. Then, omitting
constant factor wd , algorithm runs n2 time. follows algorithms pseudocode noting every vertex k constant number (at w )
neighbours j < k.
note similarity Snowball P3 C algorithm (Planken et al.,
2008), presented below. Snowball, P3 C operates enforcing DPC, followed
single

backward sweep along vertex ordering. P3 C computes, nwd2 time, shortest
361

fiPlanken, De Weerdt, & Van der Krogt

Algorithm 5: P 3 C (Planken et al., 2008)
Input: Weighted directed graph G = hV, Ei; vertex ordering : V {1, . . . , n}
Output: PPC version G, inconsistent G contains negative cycle
1
2

G DPC(G, d)
return inconsistent DPC

8

k 1 n
forall i, j < k {i, k} , {j, k} E
wik min {wik , wij + wjk }
wkj min {wkj , wki + wij }
end
end

9

return G

3
4
5
6
7

paths arcs present chordal graph. similarity property chordal
graphs fact prompt us present version Snowball improved time complexity.
3.3 Improving Run-Time Complexity Using Separators

section, present improvement Snowball nwd2 + n2 sd run time,
sd size largest minimal separator chordal graph obtained
triangulation along d.
Definition 4. Given connected graph G = hV, Ei, separator set V 0 V
GV \V 0 longer connected. separator V 0 minimal proper subset V 0
separator.
bound better because, seen below, always holds sd wd . improvement hinges property chordal graphs called partial path consistency (PPC).
partially path-consistent graph, arc labelled length shortest path
endpoints.3 P3 C, presented Algorithm 5, depends DPC computes PPC
nwd2 time, current state art. Then, use clique tree
PPC graph compute shortest path vertices. Figure 2 shows example
chordal graph associated clique tree. clique tree following useful
properties (Heggernes, 2006, Section 3.2).
Property 1. Every chordal graph G = hV, Ei associated clique tree = hC, Si,
constructed linear time (mc ).
Property 2. clique tree node c C associated subset Vc V induces
maximal clique G. Conversely, every maximal clique G associated clique tree
node c C.
Property 3. coherent: vertex v V , clique tree nodes whose associated
cliques contain v induce subtree .
3. Full path-consistency (FPC) achieved arc exists pairs vertices u, v V .

362

fiComputing APSP Leveraging Low Treewidth

(a) Chordal graph

(b) Clique tree

Figure 2: chordal graph clique tree. shaded shape represents maximal
clique graph, containing vertices corners.
Property 4. two clique tree nodes ci , cj C connected edge {ci , cj } S,
Vci Vcj minimal separator G. Conversely, minimal separator V 0 G,
clique tree edge {ci , cj } V 0 = Vci Vcj .
Property
5. vertices appear least one clique associated node , so:

V
=
V
.
cC c
Since Proposition 2 page 358 size largest clique chordal
graph exactly wd + 1, follows Properties 2 4 sd wd .

Now, idea behind SnowballSeparators first compute PPC nwd2 time using
P3 C, traverse clique tree. PPC ensures shortest paths within clique
computed. Then, traversing clique tree arbitrary root node
out, grow set Vvisited vertices cliques whose nodes already traversed.
clique node c C visited traversal, shortest paths vertices
clique Vc vertices Vvisited must run separator Vsep c cs
parent. sd size largest minimal separator G,
pair vertices
2
suffices consider sd alternative routesfor total n sd routes, yielding
stated overall time complexity nwd2 + n2 sd . formally present algorithm based
idea Algorithm 6 associated recursive procedure Processcliquetreenode
(on following page).
Note visit nodes parent visiting node itself, always
holds Vcparent Vvisited . note that, simplicity presentation, assume
graph connected. not, simply find connected components linear
time construct clique tree them.
improved algorithm edge original algorithm separators
small treewidth not. HTN-based sibling-restricted STNs (which described
part experimental validation Section 4.3.5), instance, many separators

size 2. every task many ( n) subtasks every task subtasks

induces clique,
wd ( n) sd = 2, implying SnowballSeparators still

2
optimal n time complexity instances.4
proceed prove algorithm correct meets stated run-time
bounds, introduce following definition.
4. However, since general every task subtasks form clique, low value sd usually
attained practice.

363

fiPlanken, De Weerdt, & Van der Krogt

Algorithm 6: Snowballseparators
Input: Weighted directed graph G = hV, Ei; vertex ordering : V {1, . . . , n}
Output: Distance matrix D, inconsistent G contains negative cycle
1
2
3
4
5
6
7
8
9
10

G P3 C(G, d)
return inconsistent P3 C
i, j V : D[i][j]
V : D[i][i] 0
{i, j} E : D[i][j] wij
{i, j} E : D[j][i] wji
build clique tree = hC, Si G
select arbitrary root node croot C
(D, Vvisited ) Processcliquetreenode(croot , nil, D, )
return

Procedure Processcliquetreenode(c, cparent , D, Vvisited )
Input: Current clique tree node c, cs parent cparent , distance matrix D, set
visited vertices Vvisited
Output: Updated matrix set Vvisited

13

cparent 6= nil
Vnew Vc \ Vcparent
Vsep Vc Vcparent
Vother Vvisited \ Vc
forall (i, j, k) Vnew Vsep Vother
D[i][k] min {D[i][k], D[i][j] + D[j][k]}
D[k][i] min {D[k][i], D[k][j] + D[j][i]}
end
end
Vvisited Vvisited Vc
forall children c0 c
(D, Vvisited ) Processcliquetreenode(c0 , c, D, Vvisited )
end

14

return (D, Vvisited )

1
2
3
4
5
6
7
8
9
10
11
12

364

// recursive call

fiComputing APSP Leveraging Low Treewidth

Definition 5. define distance matrix valid set U vertices, (D, U )
valid pair, pairs vertices (i, j) U U , D[i][j] holds shortest distance
G j.
split correctness proof algorithm three parts: Lemmas 4 5
culminate Theorem 6. first step show Processcliquetreenode called
valid pair (D, U ) clique node c, procedure extends validity
U Vc .
Lemma 4. Consider call procedure Processcliquetreenode with, arguments, clique
node c, cs parent cparent , distance matrix D, set visited vertices Vvisited .
valid Vvisited upon calling, becomes valid Vc Vvisited running lines
18 Processcliquetreenode.
Proof. First, note Property 2, Vc induces clique G. Therefore, edges exist
pair (i, k) vertices Vc , since graph PPC, wik labelled
shortest distance k. Due lines 5 6 main algorithm,
contains shortest distances, valid Vc .
Now, remains shown pair vertices (i, k) Vc Vvisited
shortest distances D[i][k] D[k][i] set correctly. show case D[i][k];
case analogous.
desired result follows trivially cparent = nil, since procedure called
Vvisited = . Otherwise, let Vnew = Vc \ Vcparent , Vsep = Vc Vcparent Vother = Vvisited \ Vc
set procedure lines 24. either k lies Vsep , correctness D[i][k]s
value already proven, need consider pairs vertices (i, k) Vnew Vother .
pair (i, k), Vsep separator k Property 4,
shortest path k necessarily concatenation shortest paths j
j k, j Vsep . Since follows definitions Vnew , Vsep Vother
(i, j) Vnew Vsep (j, k) Vsep Vother , D[i][j] D[j][k] correctly
set (by validity Vc Vvisited , respectively), loop lines 58 yields
desired result.
next step prove recursive calls, validity fact extended
entire subtree rooted c.
Lemma 5. Consider call procedure Processcliquetreenode with, arguments,
clique node c, cs parent Vcparent , distance matrix D, set visited vertices Vvisited .
0
valid Vvisited upon calling, returned, updated pair (D0 , Vvisited
)
valid.
Proof. First, note Lemma 4, valid Vvisited update line 10.
Assume clique tree depth d; proof reverse induction
depth clique tree node. c clique tree node depth (i.e. leaf), loop
lines 1113 no-op, immediately obtain desired result.
assume lemma holds nodes depth k let c clique tree
node depth k 1. first call (if any) made child node c0 loop
lines 1113, lemma applied. consequence, returned updated
365

fiPlanken, De Weerdt, & Van der Krogt

pair valid. argument repeated loop ends procedure
returns valid pair.
results disposal, state prove main theorem
section.
Theorem 6. Algorithm
6 ( SnowballSeparators) correctly computes all-pairs shortest paths

nwd2 + n2 sd time.
Proof. Note Vvisited = call Processcliquetreenode line 9 Snowball
Separators; therefore, pair (D, Vvisited ) trivially valid. Lemma 5, call thus
returns valid updated pair (D, Vvisited ). Since Processcliquetreenode recursively traS
versed entire clique tree, Vvisited contains union cC Vc cliques clique
tree = hC, Si, Property 5 equals set vertices G. Therefore,
contains correct shortest paths pairs vertices graph.

time complexity, note initialisations lines 3 4 carried
2
n time, whereas lines 5 6 require (mc ) time. Property 1,
clique tree built linear time (mc ). Since clique tree contains
n nodes,

Processcliquetreenode called (n) times. Line 1 requires wd2 time. implement
lines 24 10 Processcliquetreenode, represent characteristic function
Vvisited array size n; using Vvisited instead Vcparent everywhere, simply
iterate (wd ) members Vc perform required computations.
Now, complexity loop lines 58 remains shown. Note
|Vsep | sd definition, |Vother | < n always. using observation
n vertices graph appears Vnew exactly one invocation Processcliquetree
node (after
becomes staunch member Vvisited ), obtain total time bound
2
n sd loop invocations.
recursive description perhaps easier grasp satisfies claimed
time bounds, found efficiency benefited practice iterative implementation.
turns good heuristic first visit child nodes connected already
visited subtree large separator, postponing processing children connected
small separator, set visited vertices still small. way, sum
terms |Vsep Vvisited | kept low. implementation, therefore used priority queue
clique nodes ordered separator sizes. Future research must point whether
feasible determine optimal traversal clique tree within given time bounds.
presented new algorithms proven correctness formal complexity, move empirical evaluation performance.

4. Experiments
evaluate two algorithms together efficient implementations FloydWarshall
Johnson Fibonacci heap5 across six different benchmark sets.6
5. Johnson used corrected Fibonacci heap implementation Fiedler (2008), since widely
used pseudocode Cormen, Leiserson, Rivest, Stein (2001) contains mistakes.
6. Available
http://dx.doi.org/10.4121/uuid:49388c35-c7fb-464f-9293-cca1406edccf

366

fiComputing APSP Leveraging Low Treewidth

Table 1: Properties benchmark sets
type
Chordal
Figure 3
Figure 4
Scale-free
Figure 5
Figure 6
New York
Diamonds
Job-shop
HTN

#cases

n



wd

sd

250
130

1,000
2143,125

75,840499,490
22,788637,009

79995
211

79995
211

130
160
170
130
400
121

1,000
2501,000
1083,906
1112,751
171,321
500625

1,99667,360
2,1763,330
1136,422
1112,751
32110,220
7481,599

88864
150200
251
2
3331
2128

80854
138190
240
2
3311
2127

properties test cases summarised Table 1. table lists number
test cases, range number vertices n, edges m, induced width wd produced
minimum degree heuristic, well size largest minimal separators sd
graphs. details different sets found below, one thing
stands immediately sd often equal marginally smaller wd .
However, median size minimum separator less 10 instances except
constructed chordal graphs.
algorithms implemented Java went intensive profiling phase.7
experiments run using Java 1.6 (OpenJDK-1.6.0.b09) server mode, Intel
Xeon E5430 CPUs running 64-bit Linux. Java processes allowed maximum
heap size 4 GB, used default stack size. report measured CPU times,
including time spent running triangulation heuristic ChleqAPSP
Snowball. reported run times averaged 10 runs unique problem instance.
Moreover, generated 10 unique instances parameter setting, obtained using
different random seeds. Thus, reported statistic represents average 100 runs,
unless otherwise indicated. Finally, graph instance ensured contain cycles
negative weight.
4.1 Triangulation
discussed Section 2.2, finding optimal vertex ordering (with minimum induced
width) NP-hard, several efficient triangulation heuristics problem exist.
ran experiments six different heuristics: minimum fill minimum degree
heuristics, static variants (taking account original graph), ordering
produced running maximum cardinality search (MCS) original graph,
random ordering. these, except minimum fill, time complexities within bound
run time ChleqAPSP Snowball. found minimum degree heuristic
gave average induced widths less 1.5% higher found minimum fill,
7. implementations available binary form
http://dx.doi.org/10.4121/uuid:776a266e-81c6-41ee-9d23-8c89d90b6992

367

fiPlanken, De Weerdt, & Van der Krogt

Table 2: summed induced width, triangulation, total run time Snowball
experiments general (non-chordal) graphs show minimum degree heuristic
best choice.
heuristic
min-fill
min-degree
MCS
static min-fill
static min-degree
random

P

wd
321,492
326,222
365,662
388,569
388,707
505,844

triangulation (s)
1,204,384
498
1,520
1,387
1,317
2,436

Snowball (s)

2,047
3,166
3,348
2,746
2,748
5,179

total (s)
1,206,431
3,664
4,868
4,133
4,064
7,615

drastically lower run time. exorbitant time consumption minimum
fill heuristic partially explained fact used LibTW package8
compute ordering, whose implementation probably improved. However,
known literature theoretical bound minimum fill heuristic
worse minimum degree (Kjrulff, 1990). heuristics
slower minimum degree, yield induced width least 12% higher, resulting
longer total triangulation time longer total run time Snowball (see summary
results benchmarks given Table 2). Again, confirms Kjrulffs earlier
work. experimental results included therefore show results based
minimum degree heuristic.
4.2 Chordal Graphs
evaluate performance new algorithms chordal graphs, construct chordal
graphs fixed size 1,000 vertices treewidth ranging 79 less
number vertices, thus yielding nearly complete graph high end.
results experiment depicted Figure 3. this, figures, error
bars represent standard deviations measured run time instances
size. graphs induced width three quarters number vertices,
Snowball significantly outperforms FloydWarshall (which yields expected horizontal line),
overall run time new algorithms well Johnson across
entire range. Figure 4 shows run times chordal graphs constant treewidth
increasing number vertices. Here, two new algorithms outperform Johnson
nearly order magnitude (a factor 9.3 Snowball around n = 1300), even
regarding FloydWarshall, confirming expectations based theoretical upper bounds.
4.3 General Graphs

general, non-chordal graphs, expect theoretical analysis nwd2 time ChleqAPSP Snowball algorithms faster Johnson nm + n2 log n
8. Available http://treewidth.com/.

368

fiComputing APSP Leveraging Low Treewidth

100000

time solve (ms, log scale)

F-W
Johnson
Chleq
Snowball

10000

1000

100
100

1000
induced width (log scale)

Figure 3: Run times generated chordal graphs fixed number 1000 vertices
varying treewidth.

1e+06

F-W
Johnson
Chleq
Snowball

time solve (ms, log scale)

100000

10000

1000

100
300

1000
number vertices (log scale)

3000

Figure 4: Run times generated chordal graphs fixed treewidth 211.

369

fiPlanken, De Weerdt, & Van der Krogt

100000
F-W
Johnson
Chleq
Snowball

time solve (ms, log scale)

10000

1000

100

10
100

200

300

400

500
induced width

600

700

800

900

Figure 5: Run times scale-free benchmarks graphs 1,000 vertices varying
induced width.
time bound wd low, Johnson faster sparse graphs (where low)
large induced width wd . main question induced width changeover
occurs. Regarding FloydWarshall n3 bound, expect larger n
always outperformed algorithms.
4.3.1 Scale-Free Graphs
Scale-free networks networks whose degree distribution follows power law. is,
large values k, fraction P (k) vertices network k connections
vertices tends P (k) ck , constant c parameter . words,
vertices many connections many vertices connections.
property found many real-world graphs, social networks
Internet. instances randomly generated Albert Barabasis (2002)
preferential attachment method, iteration new vertex added graph,
attached number existing vertices; higher degree existing
vertex, likely connected newly added vertex. see
induced width Johnson faster, compare run times generated graphs
1,000 vertices. varying number attachments new vertex 2
n/2, obtain graphs induced width ranging 88 866. graphs,
induced width already quite large small attachment values: example,
value 11, induced width already 500.
results experiment found Figure 5. see
induced width 350 (attachment value 5), Snowball efficient. higher
induced widths, Johnson becomes efficient; wd around 800, even FloydWarshall
becomes faster Snowball. consistent observation different angle
made Figure 6, induced width 150 200, number edges
370

fiComputing APSP Leveraging Low Treewidth

time solve (ms, log scale)

10000

F-W
Johnson
Chleq
Snowball

1000

100

300

400

500

600
700
number vertices

800

900

1000

Figure 6: Run times scale-free benchmarks graphs induced widths 150 200
varying vertex count.
2,176 3,330 number vertices varied 250 1,000.
see small graphs 350 vertices, Johnson fastest; Snowball overtakes
it, around 750 vertices ChleqAPSP faster Johnson (this holds results
sparse graph 1,000 vertices).
Around mark 750 vertices, results show decrease run time
Snowball ChleqAPSP. artifact (preferential attachment) benchmark
generator. Since cannot generate scale-free graphs specific induced width,
modify attachment value instead. turns out, graphs size one
attachment value yields induced width within desired range; graph size
750, width high end interval, whereas graph size 800 near
low end. explains reduced run time larger graph.
scale-free networks, conclude Snowball fastest four algorithms induced width large (at one third number vertices
benchmark set). However, observe structure scale-free networks
particularly high induced width relatively sparse graphs, exactly
vertices connections. Therefore, Snowball efficient
relatively small attachment values.
4.3.2 Selections New York Road Network
interesting artificially constructed graphs graphs based real networks,
shortest path calculations relevant. first series based road
network New York City, obtained DIMACS challenge website.9
network large (with 264,346 vertices 733,846 edges) decided compute
9. http://www.dis.uniroma1.it/~challenge9/

371

fiPlanken, De Weerdt, & Van der Krogt

Figure 7: Coordinates vertices New York City input graph, examples
extent subgraphs respectively 250, 1000, 5000 vertices.

1e+07
F-W
Johnson
Chleq
Snowball

time solve (ms, log scale)

1e+06

100000

10000

1000

100

10
100

1000
number vertices (log scale)

Figure 8: Run times New York benchmarks subgraphs varying vertex count.

372

fiComputing APSP Leveraging Low Treewidth

shortest paths (induced) subgraphs varying sizes. obtained running
simple breadth-first search random starting location desired number
vertices visited. extent subnetworks thus obtained illustrated
three different sizes Figure 7. results algorithms subgraphs
found Figure 8. observe ranking algorithms chordal
graphs fixed treewidth diamonds: FloydWarshall slowest n3
run time, Johnson, ChleqAPSP, Snowball significantly faster
predecessor. explained considering induced width graphs. Even
largest graphs induced width around 30, considerably smaller
number vertices.
4.3.3 STNs Diamonds
benchmark set based problem instances difference logic proposed Strichman,
Seshia, Bryant (2002) appearing smt-lib (Ranise & Tinelli, 2003),
constraint graph instance takes form circular chain diamonds.
diamond consists two parallel paths equal length starting single vertex
ending another single vertex. latter vertex, two paths start again, converge
third vertex. pattern repeated diamond chain; final vertex
connected first one. sizes diamond total number
diamonds varied benchmarks.
Problems class actually instances NP-complete Disjunctive Temporal
Problem (DTP): constraints take form disjunction inequalities. DTP
instance, obtain STP instance (i.e. graph) randomly selecting one inequality
disjunction. STP probably inconsistent, constraint graph
contains negative cycle; remedy modifying weights constraint edges.
idea behind procedure structure graph still conforms type
networks one might encounter solving corresponding DTP instance,
run time algorithms mostly depends structure. Moreover, reduce
influence randomized extraction procedure, repeat 10 different seeds.
benchmark set, considered problem instances size
diamonds fixed 5 number varying. interesting property set
graphs generated sparse. ran experiments 130 graphs,
ranging size 111 2751 vertices, induced width 2. induced width
clearly extremely small, translates ChleqAPSP Snowball considerably
faster Johnson FloydWarshall, evidenced Figure 9.
4.3.4 STNs Job-Shop Scheduling
generated 400 graphs job-shop set instance real jobshop problem. instances type available smt-lib (Ranise & Tinelli,
2003), larger range included benchmark collection. obtain
graphs job-shop instances, used extraction procedure described
previous section. striking observation taken Figure 10
difference Johnson two new algorithms quite pronounced,
though Snowball consistently fastest three small margin. fact
373

fiPlanken, De Weerdt, & Van der Krogt

100000
F-W
Johnson
Chleq
Snowball

time solve (ms, log scale)

10000

1000

100

10

1
100

1000
number vertices (log scale)

Figure 9: Run times diamonds benchmarks graphs varying vertex count.

10000

F-W
Johnson
Chleq
Snowball

time solve (ms, log scale)

1000

100

10

1
100
number vertices (log scale)

1000

Figure 10: Run times job-shop benchmarks graphs varying vertex count.

374

fiComputing APSP Leveraging Low Treewidth

margin small likely due structure graphs, reflected
relatively high induced width. Note run times FloydWarshall
better graphs 160 vertices, larger graphs algorithms
significantly faster.
4.3.5 STNs HTNs
Finally, consider benchmark set whose instances imitate so-called sibling-restricted
STNs originating Hierarchical Task Networks. set therefore particularly interesting planning point view. graphs, constraints may occur
parent tasks children, sibling tasks (Bui & Yorke-Smith, 2010).
consider extension includes landmark variables (Castillo, Fernandez-Olivares, &
Gonzalez, 2002) mimic synchronisation tasks different parts network, thereby cause deviation tree-like HTN structure. generate
HTNs using following parameters: (i) number tasks initial HTN tree (fixed
250; note tasks start end point), (ii) branching factor, determining
number children task (between 4 7), (iii) depth HTN tree
(between 3 7), (iv) ratio landmark time points number tasks
HTN, varying 0 0.5 step size 0.05, (v) probability constraints
siblings, varying 0 0.5 step size 0.05.
settings result graphs 500 625 vertices, induced widths
varying 2 128. Though induced width seems high light claim
constant, verified wd 2 branching factor + #landmarks + 1
instances. Filling maximal values 7 125 respectively, find upper
bound wd 140, well actual maximum encountered.
Figure 11 shows results experiments function induced widths
graphs. see larger induced widths, Johnson ChleqAPSP
come close. large induced widths found high landmark ratios 0.5.
results indicate majority STNs stemming HTNs, Snowball significantly
efficient Johnson.
4.4 SnowballSeparators
Section 3.3 presented version Snowball improved worst-case run time
vanilla Snowball taking advantage separators graph. section,
discuss results experiments comparing two variants. First, turn
attention benchmark problems regular graphs. results summarised
Figure 12. one see, SnowballSeparators actually performs strictly worse sets
terms run-time performance compared original Snowball.
However, seen Table 1, largest minimal separator often equal
marginally smaller induced width. Even though may
separators large, many may substantially smaller (as noted above,
instances median separator size 10), prompts us run experiments
instances separator sizes artificially kept small. Indeed, found
cases SnowballSeparators shows improvement vanilla Snowball comparing
number update operations performedi.e. lines 8 9 Snowball lines 6 7
375

fiPlanken, De Weerdt, & Van der Krogt

F-W
Johnson
Chleq
Snowball

time solve (ms, log scale)

1000

100

10
0

20

40

60
induced width

80

100

120

Figure 11: Run times HTN benchmarks graphs 500 625 vertices
varying induced width. point average instances induced width within
range [5k, 5k + 4], k. results 5 11 instances per data point.

100000
Snowball
Snowball-Sep

time solve (ms, log scale)

10000

chordal

1000
scale-free

ny
diamonds

100
htn

10
job shop

1
100

1000
number vertices (log scale)

Figure 12: Run times Snowball algorithms benchmark problem sets listed
Table 1.

376

fiComputing APSP Leveraging Low Treewidth

100000

number updates (x1000, log scale)

Snowball
Snowball-Sep
DPC
P3C

10000

1000

100
50

100

150

200

250
300
induced width

350

400

450

Figure 13: Number distance matrix updates chordal instances 512 vertices,
largest minimal separator size 2 varying treewidth. point represents 5
10 instances.
Processcliquetreenode, along lines 3 4 DPC lines 5 6 P3 C. One
case presented Figure 13. describes results collection chordal
graphs 512 vertices, largest minimal separator fixed size 2,
treewidth varied 16 448. figure includes results DPC P3 C,
respective subroutines Snowball SnowballSeparators. graphs,
SnowballSeparators performs strictly fewer update operations Snowball instances,
although difference becomes smaller induced width increases. number
updates shows distinct improvement Snowball, run times SnowballSeparators
algorithms show improvement. Instead, seen Figure 14,
run times Snowball strictly better SnowballSeparators instances.
Snowball even seen outperform P3 C better theoretical bound;
reason adjacency matrix data structure used Snowball fast,
adjacency list used P3 C, though staying within theoretical bound, inflicts larger
constant factor run time.
experiments, conclude graphs sizes, additional
bookkeeping required SnowballSeparators outweighs potential improvement
number distance matrix updates.
4.5 Proper Upper Bound Run Time
general graphs, run time proposed algorithms depends induced width wd
ordering produced triangulation heuristic. induced width direct
measure input (graph), given upper bound run time quite proper.
arrive proper bound, section aim relate run time treewidth,
denoted w , property input. However, determining treewidth,
377

fiPlanken, De Weerdt, & Van der Krogt

10000

time solve (ms, log scale)

Snowball
Snowball-Sep
DPC
P3C

1000

100

10
50

100

150

200

250
induced width

300

350

400

450

Figure 14: Run times chordal instances 512 vertices, largest minimal separator
size 2 varying treewidth. point represents 5 10 instances.

NP-hard problem, intractable task benchmark problems used. therefore

compare measured induced width wd w , upper bound treewidth, lower
bound x w .10 unaware guarantee quality relative treewidth
either minimum degree triangulation heuristic lower bound used. However,
calculate ratio wd /x get upper bound ratio wd /w .
measure obtain upper bound run time expressed treewidth,
least benchmark problems paper.
results computations found Figure 15, plot ratios
New York, HTN, scale-free job-shop benchmarks function lower
bound x. Using least-squares approach, fitted functions wd (x) = cxk (showing
straight line log-log plot) plotted data points. functions found
fitting, get k = 4.6 New York, k = 2.3 HTN, k = 0.98 job-shop,
small multiplicative constants 0.012 < c < 1.62. one see plotted data
points scale-free instances, amenable fit therefore omit
figure.
decreasing trend job-shop data indicates quality triangulation
(i.e. upper bound represented induced width) gradually increases: lower
upper bound always less factor 2 apart. Indeed, plot line representing
function wd0 (x) = 2x (yielding horizontal line figure), find describes
comfortable upper bound data points benchmark set.
HTN data prompts us plot function wd00 (x) = 25 x2.5 , exponent slightly
higher one found least-squares fit, tweaked slightly
10. lower bound computed LibTW package; see http://treewidth.com/. used
MMD + Least-c heuristic.

378

firelative induced width (vs. lower bound)

Computing APSP Leveraging Low Treewidth

New York
HTN
scale-free
job shop
2x
2
/5x2.5

8

4

2

1
10

100
lower bound treewidth

Figure 15: upper bound induced width relative treewidth determined experimentally comparing lower bound treewidth.
multiplicative coefficient bring view. function plotted represents ample
upper bound HTN benchmarks (as well job-shop ones).
fit data points New York benchmark good trend
points clear, lower bound spans interval
1 4. Therefore, cannot give upper bound set benchmarks
acceptable level confidence.
However, scale-free data points plotted, could fitted function
yielding straight line, mostly follow clear curving trend. hypothesis
behaviour quality upper lower bound deteriorates mostly middle
sizes benchmarks; smaller larger scale-free graphs easier triangulate well.11
give upper bound, could plot line outer hull data points; e.g.
horizontal line represented wd (x) = 8x would work. pessimistic assumption
would choose function highest slope, find upper bound
wd00 (x) = 25 x2.5 , found HTN benchmarks, works here.
discussion,
may conclude
benchmarks ran except New
Snowball
York, wd (x) x2.5 turn w 2.5 ; run time algorithms

ChleqAPSP instances therefore bounded n2 w 2.5 .
conclude section, remark alternative triangulation heuristic
would use approximation algorithm bound induced width
theoretically determined. example, Bouchitte, Kratsch, Muller, Todinca (2004)
give (log w ) approximation treewidth w . Using approximation
would

give upper bound run time Snowball n2 w log w . However, run
11. mirrors earlier observations authors.

379

fiPlanken, De Weerdt, & Van der Krogt


time obtaining approximate induced width n3 log4 nw 5 log w high
constant well, work isfor nowmainly theoretical value.

5. Related Work
dense, directed
graphs real weights, state-of-the-art APSP algorithms run

3
n / logn time (Chan, 2005; Han, 2008). represent serious improvement
n3 bound FloydWarshall profit fact graphs
occur practice, number edges significantly lower n2 .
profit exactly algorithms sparse graphs aim achieve. Recently,
improvement published nm + n2 log n algorithm based Johnsons (1977)
Fredman Tarjans
(1987) work: algorithm sparse directed graphs running

nm + n2 log log n time (Pettie, 2004). theory, algorithm thus faster
Johnson (in worst cases, large graphs) (n log n).12 However, currently
implementation exists (as confirmed
personal communication Pettie, June

2011). upper bound n2 wd run time Snowball smaller
established upper bound induced width small (i.e. wd (log log n)),
and, course, chordal graphs graphs constant treewidth.
familiar one earlier work compute shortest paths leveraging low
treewidth. Chaudhuri Zaroliagis (2000) present
algorithm answering (point-to

wd3 .
point) shortest path queries wd3 n log n preprocessing time query time

direct extension results APSP would imply run time n2 wd3 general
graphs andO nmwd2 chordal graphs. result computing APSP general graphs
n2 wd (nm) chordal graphs thus strict improvement.
large part state-of-the-art point-to-point shortest paths focused road
networks (with positive edge weights). studies strong focus heuristics, ranging goal-directed search bi-directional search using creating hierarchical
structure, see example (Geisberger, Sanders, Schultes, & Delling, 2008; Bauer, Delling,
Sanders, Schieferdecker, Schultes, & Wagner, 2008). One hierarchical heuristics
similarities idea using chordal graphs. heuristic called contraction.
idea distinguish important (core) vertices, may possible end points,
vertices never used start end point. latter vertices
removed (bypassed) one-by-one, connecting neighbours directly.
restrictions input graphs shortest paths computed
assumed, sometimes lead algorithms tighter bounds.
example,

unweighted chordal graphs, APSP lengths determined n2 time (Balachandhran
& Rangan, 1996; Han, Sekharan, & Sridhar, 1997) pairs distance two known.
See (Dragan, 2005) overview unification approaches. Considering
planar graphs, recent work shows APSP found n2 log2 n (Klein, Mozes,
&
2
Weimann, 2010), improvement Johnson cases n log n .
context planning scheduling, number similar APSP problems need
computed sequentially, potentially allowing efficient approach using dynamic algorithms. Even Gazit (1985) provide method addition single edge
require n2 steps, deletion n4 /m average. Thorup (2004) Deme12. explain use notation x (f (n)) Footnote 1 page 354.

380

fiComputing APSP Leveraging Low Treewidth

trescu Italiano (2006)
later give alternative approach amortized run time
n2 (log n + log2 n+m
)
. Especially context planning scheduling, esn
sential shortest paths time points maintained. Often, sufficient
shortest paths selection pairs maintained. Above, already mentioned
P3 C algorithm Planken et al. (2008) single-shot case; Planken et al. (2010)
describe algorithm incrementally maintains property partial path consistency
chordal graphs time linear number edges.

6. Conclusions Future Work
paper give three algorithms computing all-pairs shortest paths, run
time bounded (i) n2 graphs constant treewidth, matching earlier results
required n2 (Chaudhuri & Zaroliagis, 2000);
(ii) (nm) chordal graphs, improving earlier nmwd2 ; (iii) n2 wd general
graphs, showing
2
3
improvement previously known tightest bound n wd . bounds, wd
induced width ordering used; experimentally determined bounded
treewidth power 2.5 benchmarks.
contributions obtained applying directed path consistency combined
known graph-theoretic techniques, vertex elimination tree decomposition,
computing shortest paths. supports general idea techniques may help
solving graphically-representable combinatorial problems, main contribution
article narrow, focusing improving state art single,
important problem computing APSP.
results extensive experiments make recommendations
algorithm best suited type problems. small instances,
FloydWarshall used; probably mostly thanks simplicity, yielding
straightforward implementation low overhead. Snowball exploit fact
perfect elimination ordering efficiently found chordal graphs, makes
efficient algorithm class graphs. experiments different
types general graphs, conclude Snowball consistently outperforms Johnson (and
FloydWarshall), except induced width high. experiments show
Snowball always outperforms ChleqAPSP SnowballSeparators. Although
latter better bound run time, surprisingly actual performance worse
Snowball instances benchmark sets. holds even instances
SnowballSeparators performs significantly fewer updates. Thus, conclude
additional bookkeeping required SnowballSeparators pay off.
Regarding experiments, must noted that, although utmost
obtain fair comparison, constant factor measurements depends significant
way exact implementation details (e.g. whether lookup-table heap used),
put forward earlier work experimentally comparing shortest path algorithms (Mondou, Crainic, & Nguyen, 1991; Cherkassky, Goldberg, & Radzik, 1996).
implementation higher constant factor Snowball algorithms may caused
adhering object-oriented paradigm, i.e. inheriting DPC P3 C superclasses,
choosing reuse code rather inlining method calls. Nonetheless, confident
general trends identified hold independently details.
381

fiPlanken, De Weerdt, & Van der Krogt

Note strictly speaking, algorithms introduced paper compute all-pairs
shortest distances. one wants actually trace shortest paths, algorithms
extended keep track midpoint whenever distance matrix updated,
one FloydWarshall. Then, pair vertices, actual shortest path
graph traced (n) time.
current implementation SnowballSeparators, used priority queue decide
heuristically clique tree node visit next, giving precedence nodes connected
large separator part clique tree already visited. noted before, defer
answering question whether optimal ordering found efficiently future work.
remark using minimum-degree heuristic triangulation provides Snowball
natural edge, delaying processing vertices number iterations
middle loop small k grows large.
Cherkassky Goldberg (1999) compared several innovative algorithms singlesource shortest paths gave better efficiency standard BellmanFord algorithm
practice, worst-case bound (nm) run time. future
work, investigate clever improvements exploited Snowball.
SnowballSeparators improved way influence theoretical complexity may yield better performance practice. Iterating Vother
seen reverse traversal part clique tree visited before, starting cs parent.
Then, instead always using separator current clique node (containing k)
parent previously visited vertices Vother , keep track smallest
separator encountered backwards traversal extra asymptotic cost. Since
shown Table 1 largest minimal separator often hardly smaller
induced width, might well pay search smaller separators. plan implement
improvement near future.
Another possible improvement suggested following observation DPC.
variant DPC proposed edge directionality taken account:
iteration k, neighbours i, j < k considered directed path
k j, resulting addition arc j. set added arcs would often
much smaller twice number edges added standard DPC algorithm,
graph produced directed variant would chordal, correctness
Snowball would impacted.
Furthermore, would experimentally compare algorithms recent
algorithms Pettie (2004) algorithms graphs constant treewidth Chaudhuri Zaroliagis (2000) future work. addition, interested efficient
triangulation heuristics, triangulation heuristics guaranteed quality, able
give guaranteed theoretical bound general graphs. Another direction, especially
interesting context planning scheduling, use ideas presented
design faster algorithm dynamic all-pairs shortest paths: maintaining shortest paths
edge deletions (or relaxations) additions (or tightenings).

Acknowledgments
Roman van der Krogt supported Science Foundation Ireland Grant number
08/RFP/CMS1711.
382

fiComputing APSP Leveraging Low Treewidth

offer sincere gratitude reviewers comments, helped us
improve clarity article strengthen empirical results.
article based conference paper title, received
honourable mention best student paper International Conference Automated
Planning Scheduling (Planken, de Weerdt, & van der Krogt, 2011).

Appendix A. Johnsons Heap
experiments paper, presented results Johnson
using Fibonacci
2
heap, theoretical bound nm + n log n time attained.
practice, using binary heap theoretical bound (nm log n) time turns
efficient occasions, show results section.
Figure 16 shows run times Johnson binary heap Fibonacci
heap benchmark sets listed Table 1. diamonds, HTN, New
York benchmarks binary heap percent faster Fibonacci heap,
slope lines doubly logarithmic scale same, conclude
average-case run time similar asymptotic behavior. However, larger job-shop
problems, binary heap factor 2 slower Fibonacci heap, chordal
graph benchmark problems even factor 10. benchmark problems scale-free graphs
fixed number vertices help explaining difference.
Figure 17, run time variants Johnson found scale-free graphs
1,000 vertices, number edges varying 2,000 almost 80,000.
Here, see sparsest scale-free graphs 2, 000 edges, binary
heap slightly faster, edges considered, using Fibonacci heap
significantly outperforms using binary heap. particular, run time Fibonacci
heap implementation increases slowly number edges, run time
binary heap increases much significantly. explained fact
running Dijkstras algorithm subroutine Johnson, update (candidate)
shortest path done amortized constant time Fibonacci heap,
binary heap worst-case cost (log n) time per update. number updates
bounded run Dijkstras algorithm, yielding bound (nm) updates
Johnson. binary heap (nm log n) bound accounts significant part
run time, Fibonacci heap operations (such extracting minimum
element heap) bigger relative contribution run time.
Based results benchmark sets, conclude although Johnson
binary heap help reducing actual run time sparse graphs, Johnson Fibonacci
heap overall better choice large.

383

fiPlanken, De Weerdt, & Van der Krogt

1e+07
Binary
Fibonacci

time solve (ms, log scale)

1e+06

chordal

100000

10000

ny

1000

diamonds
scale-free

100

htn
job shop

10

10

100
number vertices (log scale)

1000

Figure 16: Run times Johnson binary heap Fibonacci heap
benchmark problem sets listed Table 1.

1e+07
Binary
Fibonacci

time solve (ms, log scale)

1e+06

100000

10000

1000

100

10

2000

4000

8000
16000
number edges (log scale)

32000

64000

Figure 17: Run times Johnson binary heap Fibonacci heap scale-free
graphs 1,000 vertices increasing number edges.

384

fiComputing APSP Leveraging Low Treewidth

References
Albert, R., & Barabasi, A.-L. (2002). Statistical Mechanics Complex Networks. Reviews
Modern Physics, 74 (1), 4797.
Arnborg, S., Corneil, D. G., & Proskurowski, A. (1987). Complexity Finding Embeddings
k -Tree. SIAM Journal Algebraic Discrete Methods, 8 (2), 277284.
Balachandhran, V., & Rangan, C. P. (1996). All-pairs-shortest-length strongly chordal
graphs. Discrete applied mathematics, 69 (1-2), 169182.
Bauer, R., Delling, D., Sanders, P., Schieferdecker, D., Schultes, D., & Wagner, D. (2008).
Combining hierarchical goal-directed speed-up techniques Dijkstras algorithm. Experimental Algorithms (WEA 2008), Vol. 5038 LNCS, pp. 303318.
Springer.
Bodlaender, H. L. (1986). Classes graphs bounded tree-width. Tech. rep. RUU-CS86-22, Utrecht University.
Bodlaender, H. L. (1996). Linear-Time Algorithm Finding Tree-Decompositions
Small Treewidth. SIAM Journal Computing, 25 (6), 13051317.
Bouchitte, V., Kratsch, D., Muller, H., & Todinca, I. (2004). Treewidth Approximations.
Discrete Applied Mathematics, 136 (2-3), 183196.
Bresina, J. L., Jonsson, A. K., Morris, P. H., & Rajan, K. (2005). Activity Planning
Mars Exploration Rovers. Proc. 15th Int. Conf. Automated Planning
Scheduling, pp. 4049.
Bui, H. H., & Yorke-Smith, N. (2010). Efficient Variable Elimination Semi-Structured
Simple Temporal Networks Continuous Domains. Knowledge Engineering Review, 25 (3), 337351.
Castillo, L., Fernandez-Olivares, J., & Gonzalez, A. (2002). Temporal Constraint Network
Based Temporal Planner. Proc. 21st Workshop UK Planning
Scheduling Special Interest Group, pp. 99109, Delft, Netherlands.
Castillo, L., Fernandez-Olivares, J., & Gonzalez, A. (2006). Efficiently Handling Temporal
Knowledge HTN planner. Proc. 16th Int. Conf. Automated Planning
Scheduling, pp. 6372.

Chan, T. (2005). All-Pairs Shortest Paths Real Weights n3 / log n Time.
Algorithms Datastructures, LNCS, pp. 318324. Springer.
Chaudhuri, S., & Zaroliagis, C. D. (2000). Shortest Paths Digraphs Small Treewidth.
Part I: Sequential Algorithms. Algorithmica, 27 (3), 212226.
Cherkassky, B. V., Goldberg, A. V., & Radzik, T. (1996). Shortest paths algorithms: theory
experimental evaluation. Mathematical programming, 73 (2), 129174.
Cherkassky, B. V., & Goldberg, A. V. (1999). Negative-cycle detection algorithms. Mathematical Programming, 85, 277311.
Chleq, N. (1995). Efficient Algorithms Networks Quantitative Temporal Constraints.
Proc. 1st Int. Workshop Constraint Based Reasoning, pp. 4045.
385

fiPlanken, De Weerdt, & Van der Krogt

Conrad, P. R., Shah, J. A., & Williams, B. C. (2009). Flexible execution plans
choice. Proc. 19th Int. Conf. Automated Planning Scheduling.
Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2001). Introduction Algorithms, 2nd edition. MIT Press.
Dechter, R., Meiri, I., & Pearl, J. (1991). Temporal Constraint Networks. Artificial Intelligence, 49 (13), 6195.
Demetrescu, C., & Italiano, G. F. (2006). Fully Dynamic All-Pairs Shortest Paths
Real Edge Weights. Journal Computer System Sciences, 72 (5), 813837.
Dijkstra, E. W. (1959). note two problems connexion graphs.. Numerische
Mathematik, 1, 269271.
Dragan, F. F. (2005). Estimating pairs shortest paths restricted graph families:
unified approach. Journal Algorithms, 57 (1), 121.
Even, S., & Gazit, H. (1985). Updating Distances Dynamic Graphs. Methods Operations Research, 49, 371387.
Fiedler, N. (2008). Analysis Java implementations Fibonacci Heap. http://tinyurl.
com/fibo-heap.
Floyd, R. W. (1962). Algorithm 97: Shortest path. Communications ACM, 5 (6),
345.
Fredman, M., & Tarjan, R. E. (1987). Fibonacci Heaps Uses Improved Network
Optimization Algorithms. Journal ACM, 34 (3), 596615.
Geisberger, R., Sanders, P., Schultes, D., & Delling, D. (2008). Contraction hierarchies:
Faster simpler hierarchical routing road networks. Proc. Int. Workshop
Experimental Algorithms, pp. 319333. Springer.
Girvan, M., & Newman, M. E. J. (2002). Community Structure Social Biological
Networks. Proc. National Academy Sciences USA, 99 (12), 78217826.
Golumbic, M. (2004). Algorithmic Graph Theory Perfect Graphs. Elsevier.
Graham, R. L., Knuth, D. E., & Patashnik, O. (1989). Concrete Mathematics: Foundation
Computer Science (1st edition). Addison-Wesley.
Han, K., Sekharan, C. N., & Sridhar, R. (1997). Unified All-Pairs Shortest Path Algorithms
Chordal Hierarchy. Discrete Applied Mathematics, 77 (1), 5971.

Han, Y. (2008). Note n3 / log n -time Algorithm All-Pairs Shortest Paths.
Information Processing Letters, 105 (3), 114116.
Heggernes, P. (2006). Minimal triangulations graphs: survey. Discrete Mathematics,
306 (3), 297317. Minimal Separation Minimal Triangulation.
Johnson, D. B. (1977). Efficient Algorithms Shortest Paths Sparse Networks. Journal
ACM, 24 (1), 113.
Kjrulff, U. (1990). Triangulation Graphs - Algorithms Giving Small Total State Space.
Tech. rep., Aalborg University.
386

fiComputing APSP Leveraging Low Treewidth

Klein, P. N., Mozes, S., & Weimann, O. (2010). ShortestPaths Directed Planar Graphs
Negative Lengths: Linear-space n log2 n -time Algorithm. ACM Transactions Algorithms, 6 (2), 118.
Mondou, J. F., Crainic, T. G., & Nguyen, S. (1991). Shortest path algorithms: computational study C programming language. Computers & Operations Research,
18 (8), 767786.
Pettie, S. (2004). New Approach All-pairs Shortest Paths Real-weighted Graphs.
Theoretical Computer Science, 312 (1), 4774.
Planken, L. R., de Weerdt, M. M., & van der Krogt, R. P. J. (2008). P3 C: New Algorithm
Simple Temporal Problem. Proc. 18th Int. Conf. Automated
Planning Scheduling, pp. 256263.
Planken, L. R., de Weerdt, M. M., & van der Krogt, R. P. J. (2011). Computing allpairs shortest paths leveraging low treewidth. Proc. 21st Int. Conf.
Automated Planning Scheduling, pp. 170177.
Planken, L. R., de Weerdt, M. M., & Yorke-Smith, N. (2010). Incrementally Solving STNs
Enforcing Partial Path Consistency. Proc. 20th Int. Conf. Automated
Planning Scheduling, pp. 129136.
Ranise, S., & Tinelli, C. (2003). SMT-LIB Format: Initial Proposal. Proc.
Pragmatics Decision Procedures Automated Reasoning.
Rose, D. J. (1972). Graph-Theoretic Study Numerical Solution Sparse Positive
Definite Systems Linear Equations. Read, R. (Ed.), Graph theory computing,
pp. 183217. Academic Press.
Rossi, F., Venable, K. B., & Yorke-Smith, N. (2006). Uncertainty soft temporal constraint problems: general framework controllability algorithms fuzzy
case. Journal AI Research, 27, 617674.
Satish Kumar, T. K. (2005). Tractability Restricted Disjunctive Temporal Problems. Proc. 15th Int. Conf. Automated Planning Scheduling, pp.
110119.
Shah, J. A., & Williams, B. C. (2008). Fast Dynamic Scheduling Disjunctive Temporal
Constraint Networks Incremental Compilation. Proc. 18th Int. Conf.
Automated Planning Scheduling, pp. 322329.
Stergiou, K., & Koubarakis, M. (2000). Backtracking algorithms disjunctions temporal
constraints. Artificial Intelligence, 120 (1), 81117.
Strichman, O., Seshia, S. A., & Bryant, R. E. (2002). Deciding Separation Formulas
SAT. Proc. 14th Int. Conf. Computer Aided Verification, Vol. 2404
LNCS, pp. 209222. Springer.
Tarjan, R. E., & Yannakakis, M. (1984). Simple Linear-time Algorithms Test Chordality
Graphs, Test Acyclicity Hypergraphs, Selectively Reduce Acyclic Hypergraphs. SIAM Journal Computing, 13 (3), 566579.
387

fiPlanken, De Weerdt, & Van der Krogt

Thorup, M. (2004). Fully-dynamic All-Pairs Shortest Paths: Faster Allowing Negative
Cycles. Algorithm Theory, Vol. 3111 LNCS, pp. 384396. Springer.
Warshall, S. (1962). Theorem Boolean Matrices. Journal ACM, 9 (1), 1112.

388


