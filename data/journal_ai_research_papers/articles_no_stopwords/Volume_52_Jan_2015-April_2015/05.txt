Journal Artificial Intelligence Research 52 (2015) 287-329

Submitted 10/14; published 02/15

Revision History
Paolo Liberatore

liberato@dis.uniroma1.it

Sapienza University Rome, DIAG
Via Ariosto 25, 00185 Rome, Italy

Abstract
article proposes solution problem obtaining plausibility information,
necessary perform belief revision: given sequence revisions, together
results, derive possible initial order generated them; different
usual assumption starting all-equal initial order modifying sequence revisions. Four semantics iterated revision considered: natural, restrained,
lexicographic reinforcement. each, necessary sufficient condition existence order generating given history revisions results proved. Complexity
proved coNP complete cases one (reinforcement revision unbounded sequence length).

1. Introduction
Many belief revision operators based sort plausibility order (Spohn, 1988;
Boutilier, 1996; Nayak, 1994; Williams, 1994; Areces & Becher, 2001; Zhang, 2004; Benferhat, Kaci, Le Berre, & Williams, 2004; Hild & Spohn, 2008; Ferme & Hansson, 2011).
Whenever revising done two different ways, result disjunction
either (Alchourron & Makinson, 1982; Fagin, Ullman, & Vardi, 1983; Winslett,
1988) plausible ones according order (Gardenfors, 1988; Katsuno
& Mendelzon, 1991; Peppas, 2008; Nebel, 1992; Ferme & Hansson, 2011). Fewer disjuncts
imply formulae; therefore, discriminating order, informative
result. fine-grained order central usefulness revised knowledge base.
Iterated revision provides way obtaining plausibility order. Even starting
all-equal plausibility order (the least discriminating one), revision changes
making possibilities plausible others (Spohn, 1988; Boutilier, 1996; Nayak,
1994; Williams, 1994; Booth & Meyer, 2006; Jin & Thielscher, 2007). sequence revisions
produces order that, depending revising formulae, less informative.
cases, solution problem obtaining plausibility order: sequence
previous revisions (Konieczny & Pino Perez, 2000; Baltag, Gierasimczuk, & Smets, 2011).
However, even long history revisions may produce fine discrimination. limit
case, revising a, a, a, a, etc., final order discriminates models
models a.
way obtain initial plausibility order? One possibility derive
knowledge previous results (this done merging, Liberatore,
2014b, 2014a). words, previous revising formulae given,
results produced. K0 initial knowledge base P1 first revising
formula, result another knowledge base K1 , revised P2 .
article, Ki Pi assumed known certain point:
c
2015
AI Access Foundation. rights reserved.

fiLiberatore

P

P

P

P

1
2
3
n
K0
K1
K2
K3 . . . Kn1
Kn

sequence consistent formulae [K0 , P1 , K1 , . . . , Pn , Kn ] called revision sequence. gives information initial plausibility order models, following example shows.
Example 1 Let [K0 , P1 , K1 ] revision sequence where:
K0 =
P1 =
K1 = b c
specific K1 = b c possible result revising K0 =
P1 = a. example b c possible, b c actual revision
result. means model {a, b, c} considered plausible {a, b, c},
another model P1 . information useful subsequent revisions.
revision sequence may seen form training: first n revisions manually performed human operators, following others done automatically using initial plausibility order obtained training. Technically, revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] containing revising formulae resulting
knowledge bases Kn , one derives initial plausibility order, revised
P1 , . . . , Pn , Pn+1 , Pn+2 , . . . obtain Kn+1 , Kn+2 , . . . similar mechanism studied
Nittka Booth (2008); comparison approach conclusions.
Example 2 part research project, PhD student Polyxena tasked automating incorporation new data database, process far manually performed
database maintainers, specialized group people. soon realizes information
incorporated may disjunctive, revisions may done multiple ways. Introducing data form either b b database requires
erasing either a, b both. Studying relevant literature topic, finds
choices require plausibility information. Since previous revisions performed
database maintainers, possess information. therefore asks
rank models, getting answers ranging mean? rank Brazilian
redhead models top, Swiss models bad. spending half hour trying
explain concepts plausibility, consistency, propositional models (and
differ fashion models) ranking, gives up.
leave room, one maintainers suggests
look logs, since files record everything happened database.
does, indeed previous revisions stored logs: new information
database maintainers incorporated it. problem shifts eliciting
rank database maintainers, proved difficult, determining
previous history revisions. finds sequence revisions results
natural-compatible (Definition 4) compatible revisions. means
288

fiRevision History

initial plausibility order calculated using Lemma 2,
people performed previous revisions (unknowingly) adopted policy minimal
plausibility change.
Apart remarks operators, admittedly surreal comedic purposes,
example shows not-so-uncommon scenario: process performed hand automated, eliciting information people performed far difficult.
First, information may never expressed explicit form; second, may
hard formalize people lacking background formal logic.
case belief revision, information needed perform subsequent revisions
initial order models. However, eliciting order easy may seem,
shown research similar concept preference (Sandholm & Conen, 2010; Carson &
Louviere, 2011), mention experimental results cognitive psychology (Tversky
& Kahneman, 1983): given background information, majority
participants test reckoned Linda bank teller active feminist movement
likely Linda bank teller, probability theory forbids b
likely a.
Furthermore, providing plausibility information additional work people
manually performed process far. Instead, Example 1 shows, information
may derived previous history revisions.
Another example data synchronization: SyncML protocol (OMA, 2002) allows
synchronizing data (phonebook, calendar notes, etc.) mobile phone computer, conflicts may arise; implementation may ask user do,
take decision (like phone always wins) may however later manually reversed
user. Either way, result tells conflict solved. Again,
revising formula resulting knowledge base given, used
derive information unknown plausibility order.
Example 1 shows,
knowledge revision sequence
[K0 , P1 , K1 , P2 , K2 , . . . , Pn , Kn ] information initial plausibility models
derived. information depends revision semantics, sequences
generated semantics.
Example 3 Let [K0 , P1 , K1 , P2 , K2 , P3 , K3 ] revision sequence defined follows.
K0 =
P1 = b
K1 = b
P2 = c
K2 = b c
P3 =
K3 =
shown exists initial order models generates sequence
using natural revision semantics. contrast, order generates restrained
lexicographic semantics.
289

fiLiberatore

technical results provided article are: first, equivalent formulations
problem establishing existence order generating revision sequence using
natural, lexicographical, restrained reinforcement revision; second, initial order
built one exists; third, complexity characterization.
Since number models exponential number variables, exists
order models . . . quantification data structure may
exponential size. result, brute-force search takes double exponential time.
equivalent formulations avoid high computational cost recasting problem
terms polynomial-size data structures.
problem establishing existence initial order generating given sequence
coNP-complete cases one (reinforcement revision unbounded sequence
length), therefore showing problem expressed validity QBF.
proves problem recast form contain existential
quantification initial order.

2. Preliminaries
Belief revision considered article propositional formulae built finite
alphabet variables. truth evaluation alphabet called model: function
variables either true false. Following common terminology propositional
logic, model satisfies formula model formula, formula
model. set models formula F denoted Mod(F ). QBF
propositional formula variables quantified, either universally (like a.a
b), existentially (like ab.a b) (like ab.a b). variables
universally quantified formula QBF .
revision sequence represents evolution beliefs time, including
revising formulae results.
Definition 1 revision sequence odd sequence consistent propositional formulae
[K0 , P1 , K1 , . . . , Pn , Kn ] finite set variables.
semantics belief revision considered article work ordering
models, representing relative plausibility, modified new information
arrives. orderings defined follows.
Definition 2 total preorder C partition models finite sequence classes
[C(0), C(1), C(2), . . . , C(m)] C(0) 6= .
Intuitively, partition represents way compare models: J compare
class, compares greater J class higher
index. use partitions instead usual notation J simplifies definitions
proofs. Since classes empty (except first), several partitions may represent
way comparing models. problem total preorders never checked
equality article.
total preorder depicted shelf, Figure 1. bottom drawer C(0)
contains plausible models. represent situations currently believed possible: C(0) = Mod(K0 ). Revising C P1 changes new preorder CP1 takes
290

fiRevision History

account new information. class CP1 (0) contains models considered
plausible; therefore, CP1 (0) = Mod(K1 ).

C(7)
C(6)
C(5)
C(4)
C(3)
C(2)
C(1)
C(0)

Figure 1: graphical representation total preorder C
partition formalizes plausibility models: models C(i) plausible
models C(i + 1). lower class, plausible model; reason,
total preorder often seen representing implausibility rather plausibility.
inverse ordinal conditional function (Spohn, 1988): (I) = n C(n).
study two semantics considered article involves prefixes
maxsets sequence. Sequences denoted using brackets [. . .]. Given sequence
formulae [P1 , . . . , Pn ], h-prefix sequence containing first h 1 formulae
sequence. maxset sequence extends concept maximal consistent subsets
sets sequences.

maxset([P1 , . . . , Pn ]) = maxset(; [P1 , . . . , Pn ])


maxset([Q1 , . . . , Qi , P1 ]; [P2 , . . . , Pn ])


Q1 Qi P1 consistent
maxset([Q1 , . . . , Qi ]; [P1 , P2 , . . . , Pn ]) =

maxset([Q1 , . . . , Qi , true], [P2 , . . . , Pn ])



otherwise
maxset([Q1 , . . . , Qn ]; ) = [Q1 , . . . , Qn ]
sequence formulae used context propositional formula expected
implicitly represents conjunctions formulae. example, [b, c, c d] means
(b c (c d)). According notation, Q1 Qi P1 inconsistent
[Q1 , . . . , Qi ] |= P1 . result, [Q1 , . . . , Qi , true] replaced [Q1 , . . . , Qi , P1 ]
definition maxset.
definition prefixes maxsets, commute: h-prefix maxset
sequence maxset h-prefix sequence. result, P
h-th element sequence P maxset(S) P maxset(prefixh (S))
consistent.
maxset often written maxset(P1 , . . . , Pn ) shorthand maxset([P1 , . . . , Pn ]).
number properties maxsets shown. proofs appendix.
291

fiLiberatore

Lemma 1 F consistent F |= maxset(P1 , . . . , Pn ), maxset(P1 , . . . , Pn )
{Pi | 1 n F |= Pi }.
Lemma 2 F consistent F |= maxset(P1 , . . . , Pn ), every consistent subset
{P1 , . . . , Pn } contains formulae entailed F equivalent maxset(P1 , . . . , Pn ).
article, sequence formulae replaced true called
subsequence. similar usual definition, difference formulae
maintain position sequence.
Lemma 3 F consistent F 6|= maxset(P1 , . . . , Pn ) exists
subsequence R [P1 , . . . , Pn ] that:
1. R consistent;
2. F |= Pi Pi R;
3. i, Pi 6 R Pi prefixi (R) consistent.
conditions lemma existential type: exists R, exists
model R, either F 6|= Pi Pi R Pi prefixi (R) consistent. proves
checking F 6|= maxset(P1 , . . . , Pn ) expressed validity QBF,
therefore NP.
Corollary 1 F consistent, checking F 6|= maxset(P1 , . . . , Pn ) NP.
lemma avoids constructing maxset one formula time replacing test
satisfiability Pi prefixi (maxset(P1 , . . . , Pn )) F |= Pi , F
consistent entails maxset. way, sequence satisfiability checks required
build maxset parallelized, is, turned number validity checks
performed parallel.
order check F maxset(P1 , . . . , Pn ), one first checks whether F |=
maxset(P1 , . . . , Pn ), maxset(P1 , . . . , Pn ) |= F . Assuming first condition
true, second shown coNP.
Theorem 1 F consistent, checking F maxset(P1 , . . . , Pn ) coNP.
article, revisions satisfying AGM postulate 4 considered: K P
K P K P consistent. Also, formulae Pi Ki sequences assumed
consistent. checking sequence generated total preorder, Ki1 Pi
consistent Ki Ki1 Pi . particular, sequence generated
total preorder Ki1 Pi consistent AGM postulate Ki1 Pi equivalent
Ki ; conversely, Ki Ki1 Pi consistent consistency Ki implies
Ki1 Pi . property important allows replacing satisfiability test
unsatisfiability test.
292

fiRevision History



P

P

-

Figure 2: Natural revision

3. Natural Revision
Natural revision (Boutilier, 1996) modifies total preorder plausibility models C
light new piece information P new total preorder CP close possible
original one. new preorder P true plausible models,
CP (0). minimal change C ensuring setting CP (0) minimal models
P according C, leaving rest preorder unaltered.
Definition 3 natural revision total preorder C formula P defined
total preorder CP follows, minimal index C(i) Mod(P ) 6= :
(

CP (j) =

C(i) Mod(P ) j = 0
C(j 1)\CP (0) otherwise

example, CP (0) = C(i) Mod(P ), CP (1) = C(1 1)\CP (0) = C(0)\CP (0).
Graphically, change P produces preorder natural revision depicted
cutting lowest models P placing others, shown
Figure 2.
CP1 ,...,Pi result revising C P1 , P2 , etc. using natural revision,
Mod(Ki ) = CP1 ,...,Pi (0) revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ].
Example 4 Let C = [C(0), C(1)] total preorder that:

C(0) = Mod(a)
C(1) = Mod(a)
Revising P1 = b, P2 = c P3 = using natural revision generates revision
sequence Example 3. Indeed, revising C P1 = b makes minimal models P1
form new class zero. Since C(0) Mod(P ) 6= , index definition natural
revision zero. resulting preorder therefore:
293

fiLiberatore

CP1 (0) = C(0) Mod(P1 ) = Mod(a b)
CP1 (1) = C(0)\CP1 (0) = Mod(a b)
CP1 (2) = C(1)\CP1 (0) = Mod(a)
Since Mod(K1 ) = CP1 (0), follows K1 b. similar change happens
revising P2 = c, since CP (0) Mod(P2 ) 6= , implies = 0.
CP1 P2 (0) = Mod(a b c)
CP1 P2 (1) = Mod(a b c)
CP1 P2 (2) = Mod(a b)
CP1 P2 (3) = Mod(a)
Again, Mod(K2 ) = CP1 P2 (0), implies K2 b c. minimal models
P3 = entire class CP1 P2 (3). Therefore, = 3 preorder becomes:
CP1 P2 P3 (0) = Mod(a)
CP1 P2 P3 (1) = Mod(a b c)
CP1 P2 P3 (2) = Mod(a b c)
CP1 P2 P3 (3) = Mod(a b)
proves K3 a. revision sequence coincides Example 3.
Looking example direction, shows revision sequence [a, b,
b, c, b c, a, a] generated natural revision preorder. proved
case restrained lexicographic revisions.
aim article establish whether sequence generated preorder,
finding it. Unfortunately, direct search space total preorders unfeasible:
number models exponential number variables, number
total preorders therefore double exponential. Fortunately, natural revision
difficulty overcome thanks necessary sufficient condition sequence
generated total preorder. number lemmas needed prove it. first
shows revising formula alter relative order models
resulting knowledge base.
Lemma 4 CP (0) Mod(F ) = CP compares models F C does, CP
natural revision total preorder C formula P .
result iterated number revising formulae: resulting knowledge
bases Ki inconsistent formula F , relative order models F
changed. result final revision F therefore calculated original
ordering, case. following lemma formulated fragment revision
sequence later applied.
294

fiRevision History

Lemma 5 Let [Kj , Pj+1 , . . . , Pi , Ki ] revision sequence generated natural revision
total preorder C. Kj Pi consistent none Kj+1 Pi , . . . , Ki1 Pi is,
CPj+1 ,...,Pi (0) = Mod(Kj Pi ).
lemma similar result Boutilier (1996, Thm. 17), lifts assumption
conjunctions Kj Pj+1 , . . . , Ki2 Pi1 consistent. shows Pi
consistent previous Kj , natural revision Pi produces result
determined Kj only, independent initial preorder. following lemma covers
case, Pi inconsistent previous Kj .
Lemma 6 revision sequence [K0 , P1 , K1 , . . . , Pi , Ki ] generated natural revision
total preorder C Pi inconsistent K0 , . . . , Ki1 , models
Ki minimal models Pi according C.
last two lemmas prove that, natural revision, Ki equivalent Kj Pi
maximal j conjunction consistent one exists, otherwise determined
initial preorder. first necessary condition existence total
preorder generating sequence.
Definition 4 revision sequence [K0 , P1 , . . . , Pn , Kn ] natural-compatible if, every
{1, . . . , n}, holds:
1. Ki |= Pi ;
2. j maximal index j < Kj Pi consistent (if any),
Ki Kj Pi .
sequence natural-compatible generated natural revision
initial total preorder.
Theorem 2 [K0 , P1 , K1 , . . . , Pn , Kn ] natural-compatible generated natural
revision initial preorder C = [C(0), . . . , C(n + 1)].


Mod(Ki )

n l < . Kl Pi |=

otherwise, n
C(i) =

S{Mod(K ) | l < j . K P 6|= } = n + 1
j
j
l
Natural-compatibility sufficient condition sequence generated
natural revision initial preorder. following theorem proves
necessary. Therefore, characterizes exactly revision sequences natural revision
generates.
Theorem 3 revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] generated natural revision
initial total preorder natural-compatible.
following example illustrates natural compatibility application natural
revision.
295

fiLiberatore

Example 5 revision sequence previous example natural-compatible. first
condition natural compatibility satisfied: K1 = b implies P1 = b; K2 = b c
implies P2 = c; K3 = implies P3 = a.
last preceding formula Kj consistent P1 = b K0 = a, indeed K1 =
K0 P1 = b. last preceding formula Kj consistent P2 = c K1 = b,
indeed K2 = K1 P2 = b c. Finally, P3 = consistent none K0 , K1 , K2 .
Therefore, second condition natural compatibility places constraint it.
Theorem 2 proves revision sequence generated natural revision
preorder, provides one: C(0) = Mod(a), C(1) = Mod(a).
indeed preorder used previous example generate sequence.
Natural compatibility rewritten number satisfiability unsatisfiability
tests. particular, j maximal index property written as:
Kj Pi consistent Kh Pi not, j < h < i. way, satisfiability check
dependent another, problem solved two parallel calls NP oracle,
one positive one negative. assumption formulae revision sequences
consistent allows rewriting first.
Lemma 7 Checking existence total preorder C generating revision sequence
[K0 , P1 , K1 , . . . , Pn , Kn ] using natural revision coNP.
problem hard coNP. Therefore, coNP complete.
Theorem 4 problem establishing existence preorder generating revision
sequence using natural revision coNP complete.

4. Restrained Revision
Restrained revision (Booth & Meyer, 2006) common natural revision
revising total preorder C formula P , minimal models P becomes new class
zero. addition, every class split two according satisfaction P : models
P go lower class, others higher.
Equivalently, every class refined (Papini, 2001) classes 2i 2i + 1,
first class contains models class satisfying P second models class
satisfying P ; then, natural revision applied.
Definition 5 restrained revision total preorder C formula P defined
total preorder CP follows, minimal index C(i) Mod(P ) 6=
/ denotes quotient (integer division, truncated):


C(i) Mod(P )

CP (j) =

j = 0
(C((j 1)/2)\CP (0)) Mod(P ) j > 0 odd

(C((j 1)/2)\C (0))\Mod(P )
otherwise
P

example,
CP (0) = C(i) Mod(P ),
CP (1) = (C((1 1)/2)\CP (0))
Mod(P ) = (C(0)\CP (0)) Mod(P ) CP (2) = (C((2 1)/2)\CP (0))\Mod(P ) =
(C(0)\CP (0))\Mod(P ) since (2 1)/2 = 1/2 = 0 using integer division.
296

fiRevision History

-

P



-

-

Figure 3: Restrained revision
graphical example application restrained revision total preorder
Figure 3.
revision sequence Example 3 generated preorder using restrained
revision. proved using necessary sufficient condition existence
preorder generating sequence. now, illustrate restrained revision works,
preorder shown natural revision used.
Example 6 Let C following total preorder:
C(0) = Mod(a)
C(1) = Mod(a)
Restrained revision P1 = b, P2 = c P3 = generates revision sequence
different Example 3. Since K0 = Mod(C(0)), follows K0 a. Revising C
P1 = b makes minimal models P1 new class zero splits every
class b/b. resulting total preorder removing empty classes therefore:
CP1 (0) = Mod(a b)
CP1 (1) = Mod(a b)
CP1 (2) = Mod(a b)
CP1 (3) = Mod(a b)
Since Mod(K1 ) = CP1 (0), follows K1 b. similar change happens
revising P2 = c:
297

fiLiberatore

CP1 P2 (0) = Mod(a b c)
CP1 P2 (1) = Mod(a b c)
CP1 P2 (2) = Mod(a b c)
CP1 P2 (3) = Mod(a b c)
CP1 P2 (4) = Mod(a b c)
CP1 P2 (5) = Mod(a b c)
CP1 P2 (6) = Mod(a b c)
CP1 P2 (7) = Mod(a b c)
Again, Mod(K2 ) = CP1 P2 (0), implies K2 b c. minimal models
P3 = whole class CP1 P2 (4). preorder therefore becomes:
CP1 P2 P3 (0) = Mod(a b c)
CP1 P2 P3 (1) = Mod(a b c)
CP1 P2 P3 (2) = Mod(a b c)
CP1 P2 P3 (3) = Mod(a b c)
CP1 P2 P3 (4) = Mod(a b c)
CP1 P2 P3 (5) = Mod(a b c)
CP1 P2 P3 (6) = Mod(a b c)
CP1 P2 P3 (7) = Mod(a b c)
result, K3 b c. revision sequence coincides Example 3
P3 K3 different, K3 = previous example. shown
preorder generates sequence using restrained revision.
following property similar Lemma 5 natural revision, difference
maxset introduces account class split.
Lemma 8 Let [Kj , Pj+1 , . . . , Pi , Ki ] revision sequence generated restrained revision
initial total preorder C. Kj Pi consistent none Kj+1 Pi , . . . ,
Ki1 Pi is, CPj+1 ,...,Pi (0) = Mod(maxset(Kj Pi , Pj+1 , . . . , Pi1 )).
result first half necessary sufficient condition sequence
generated restrained revision preorder, involves following definition.
Definition 6 revision sequence [K0 , P1 , K1 . . . , Pn , Kn ] restrained-compatible if,
every {1, . . . , n}, holds:
1. Ki |= Pi ;
2. Ki maxset(Kj Pi , Pj+1 , . . . , Pii ) j maximal index j <
Kj Pi consistent, any;
298

fiRevision History

3. either Ki |= Pl Ki |= Pl every l < j exists.
side remark, condition either Ki |= Pl Ki |= Pl third point
definition refers indexes l < i, including ones Kl consistent
previous Kj .
revision sequence restrained-compatible generated restrained revision
initial preorder. following lemma specifies one is.
Lemma 9 [K0 , P1 , K1 , . . . , Pn , Kn ] restrained-compatible generated restrained revision total preorder C = [C(0), . . . , C(n + 1)], where:


Mod(Ki )

C(i) =

n l < . Pi Kl |=
otherwise, n

S{Mod(K ) | l < j P K 6|= } = n + 1
j
j
l


results proved far collected equivalent formulation existence
preorder generating sequence.
Theorem 5 revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] generated restrained revision
initial total preorder restrained-compatible.
sequence Example 3 shown restrained-compatible. Therefore,
generated restrained revision preorder worked natural
revision, generated other.
Example 7 revision sequence [K0 , P1 , K1 , P2 , K2 , P3 , K3 ] K0 = a, P1 = b, K1 =
b, P2 = c, K2 = b c, P3 = a, K3 = restrained-compatible (this
sequence Example 3). Indeed, P3 = inconsistent K0 , K1 K2 ,
yet K3 = entails neither P1 = b P1 = b, thereby violating third condition
restrained compatibility.
definition restrained compatibility involves consistency entailment checks.
following lemma rewrites form shown use inconsistencies.
Lemma 10 revision sequence [K0 , P1 , K1 . . . , Pn , Kn ] restrained-compatible
if, every index i:
1. Ki |= Pi ;
2. every 0 j < i, either Kj Pi inconsistent Ki |= Kl Pi j < l <
Ki maxset(Kj Pi , Pj+1 , . . . , Pi1 );
3. every 0 j < i, Ki |= Pj , Ki |= Pj , Ki |= Kl Pi 0 l < i.
Since checking equivalence consistent formula maxset problem coNP
Theorem 1, expressed universally quantified formula. result,
quantifiers conditions lemma universal, whole problem coNP.
Hardness class easy prove.
Theorem 6 Establishing existence total preorder generating restrained revision
sequence coNP-complete.
299

fiLiberatore

5. Intermezzo: Multiple Preorders
revision sequence may generated one total preorder. Examples
exist even two variables only, sequence [K0 , P1 , K1 , P2 , K2 ] K0 = ab,
P1 = b, K1 = b, P2 = b K2 = b.
ab

ab

b b b
According Lemma 9, sequence generated restrained revision initial
preorder C = [C(0), C(1), C(2), C(3)].
C(0) = Mod(a b)
C(1) = Mod(a b)
C(2) = Mod(a b)
C(3) = Mod(a b)
However, preorder generating sequence. Classes C(1) C(2)
swapped, still leading result.
C(0) = Mod(a b)
C(1) = Mod(a b)
C(2) = Mod(a b)
C(4) = Mod(a b)
Intuitively, revising single-model formula always single possible outcome:
formula itself. result, even Mod(K1 ) contained class greater
Mod(K2 ), still minimal models P1 Mod(K1 ).
way, expected: revision performed single possible
way, initial preorder irrelevant. intuition holds considered revisions,
confirmed simplifying preorder: indeed, apart C(0), classes
shuffled every possible way, even merged:
C(0) = Mod(a b)
C(1) = Mod(a b) Mod(a b) Mod(a b)
kind preorder works whenever Pi single model, general.
Even restricting Pi Pi Kj |= j < i, l < Pi Kl
guaranteed inconsistent, Pl Ki not. words, Mod(Ki ) cannot always
swapped merged Mod(Kl ).
one preorder possible, sensible principle choose least discriminating one. preorder would compare different J strictly necessary
obtain revision sequence. words, carry plausibility information
follow revision sequence. minimization similar spirit
300

fiRevision History

way rational closure conditional logic rationally rooted consequence
relation (Lehmann & Magidor, 1992; Booth & Nittka, 2008). last preorder shown
obeys principle, question whether least discriminating preorder exists
revision sequences considered revision semantics open problem.
different possible solution proceed refutation:
sequence
[K0 , P1 , K2 , . . . , Pn , Kn ] generated revision preorder
[K0 , P1 , K2 , . . . , Pn , Kn , Pn+1 , Kn+1 ] not, Kn+1 might considered true
revising Pn+1 .
correctly pointed one reviewers, revision sequence may even
generated different revisions different initial preorder, adding second dimension
problem: preorder, semantics revision chosen.
sequence shown example one kind: generated four revision
semantics considered article every initial preorder C C(0) = Mod(a b).

6. Lexicographic Revision
seminal work iterated revision, Spohn (1988) defined tentative semantics based
principle newer formulae plausible older ones levels
plausibility: even unlikely models P preferred likely
P . spite apparent drawbacks pointed author, semantics
later recognized principled way perform iterated revision (Nayak, 1994; Darwiche &
Pearl, 1997; Booth & Meyer, 2006; Jin & Thielscher, 2007; Konieczny & Pino Perez, 2000).
revisions used article, lexicographic revision works total
preorder plausibility models C. particular, revision P changes moving
models P classes index lower others.
Definition 7 lexicographic revision total preorder C formula P defined
following total preorder, j respectively indexes lowest
highest classes containing models P :
(

CP (k) =

C(k + i) Mod(P )
k j
C(k j + 1)\Mod(P ) otherwise

new class zero CP (0) = C(0 + i) Mod(P ); expected, comprises minimal
models P , since C(i) lowest class containing models P . class CP (j i) =
C(j + i) Mod(P ) = C(j) Mod(P ) contains highest-class models P , since
assumption C(j). models C(0) satisfy P , any, moved
class CP (j + 1) = C(j + 1 j + 1)\Mod(P ) = C(0)\Mod(P ). index
j + 1 lower classes CP (0), . . . , CP (j i) contain models P coming
C(i), . . . , C(j).
Figure 4 shows total preorder C changed formula P using lexicographic
revision.
Graphically, lexicographic revision cuts models P classes
wedges shelf. way, every model P belongs lower class
models P . time, relative position two models P changed,
holds every two models P .
301

fiLiberatore

P


-

P

Figure 4: Lexicographic revision
Example 8 shown sequence Example 3 generated lexicographic
revision total preorder. Meanwhile, illustrate definition lexicographic
revision preorder used example natural revision revised P1 = b, P2 = c
P3 = a.
C(0) = Mod(a)
C(1) = Mod(a)
Revising C P1 = b using lexicographic revision removes models P1
classes creates new classes bottom:
CP1 (0) = Mod(a b)
CP1 (1) = Mod(a b)
CP1 (2) = Mod(a b)
CP1 (3) = Mod(a b)
result, K1 = b. Revising P2 = c similar effect:
CP1 P2 (0) = Mod(a b c)
CP1 P2 (1) = Mod(a b c)
CP1 P2 (2) = Mod(a b c)
CP1 P2 (3) = Mod(a b c)
CP1 P2 (4) = Mod(a b c)
302

fiRevision History

CP1 P2 (5) = Mod(a b c)
CP1 P2 (6) = Mod(a b c)
CP1 P2 (7) = Mod(a b c)

preorder produces K2 = b c. Finally, revising P3 = removing
empty classes makes classes 1, 3, 5, 7 become new classes 0, 1, 2, 3.
CP1 P2 P3 (0) = Mod(a b c)
CP1 P2 P3 (1) = Mod(a b c)
CP1 P2 P3 (2) = Mod(a b c)
CP1 P2 P3 (3) = Mod(a b c)
CP1 P2 P3 (4) = Mod(a b c)
CP1 P2 P3 (5) = Mod(a b c)
CP1 P2 P3 (6) = Mod(a b c)
CP1 P2 P3 (7) = Mod(a b c)

Since K3 = b c equivalent a, revision sequence Example 3
generated lexicographic revision initial preorder C. shown
preorder generates sequence using lexicographic revision.
every preorder C consistent formula P , revised preorder CP using lexicographic revision three properties:
1. CP (0) set minimal models P preorder C;
2. exists index h



i=0,...,h CP (i)

= Mod(P );

3. two models satisfy P falsify it, CP compares C does.
Lexicographic revision recast terms maxsets reversed sequence.
Booth Nittka (2008) proved following property; precisely, proved
implies following property arbitrary preorder [C(0), . . . , C(n)] obtained
revising ordering models class zero sequence formulae
C(n), . . . , C(0) sets models.
Property 1 [K0 , P1 , . . . , Kn , Pn ] revision sequence generated lexicographic revision total preorder C, Mod(Ki ) set minimal models
maxset(Pi , . . . , P1 ) according C.
property following consequences:
1. models Ki class C;
303

fiLiberatore

2. models maxset(Pi , . . . , P1 ) greater classes.
Two properties follow. First, Ki Kj consistent models Mod(Ki )
Mod(Kj ) class C. Indeed, since Ki Kj consistent, model
I; since models Ki class I, Kj , models
two formulae class. Second, Kj models common
Ki maxset(Pi , . . . , P1 ), models class C, greater
models Ki .
allows shifting total preorder among models total preorder among
formulae Ki . Since preorder formulae Ki , results
revision process, called result preorder.
Definition 8 result preorder revision sequence [K0 , P1 , . . . , Pn , Kn ] total
preorder among formulae Ki that:
1. Ki Kj consistent Ki Kj class;
2. Ki Kj maxset(Pi , . . . , P1 ) consistent Ki lower class Kj .
advantage result preorders built revision sequence,
shown. Before, proved existence result preorder
existence initial total preorder models generating sequence
lexicographic revision. Since two preorders involved (one among models, one among
formulae), distinction made preorder among models C preorder among
formulae R; result preorders second kind.
Lemma 11 revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] generated lexicographic
revision total preorder among models C result preorder R defined
by:
R(i) = {Ki | Mod(Ki ) C(i)}
converse holds: result preorder revision sequence one derive
preorder among models generates sequence using lexicographic revision.
Lemma 12 R result preorder revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
Ki |= maxset(Pi , . . . , P1 ) every i, lexicographic revision following
total preorder C among models generates revision sequence, z index
greatest class R:
(

C(h) =

{Mod(Ki ) | Ki R(h)} h z
{I | 6 K1 Kn }
h = z + 1

two lemmas together imply following corollary.
Corollary 2 revision sequence [K0 , P1 , . . . , Pn , Kn ] generated lexicographic revision
initial preorder among models result preorder sequence
exists Ki |= maxset(Pi , . . . , P1 ) every i.
304

fiRevision History

condition existence result preorder already simpler existence
initial total preorder models, since number formulae Ki linear size
revision sequence number models may exponential. existence
result preorder recast terms condition revision sequence.
Definition 9 revision sequence [K0 , P1 , . . . , Kn , Pn ] lexicographic compatible Ki |=
maxset(Pi , . . . , P1 ) every relations ' < defined follows form
cycles containing < links:
Ki ' Kj Ki Kj consistent;
Ki < Kj Ki Kj maxset(Pi , . . . , P1 ) consistent.
rationale definition Ki ' Kj Ki Kj
class R, Ki < Kj Ki lower class. intuition
confirmed following lemma.
Lemma 13 revision sequence generated lexicographic revision total preorder lexicographic compatible.
result applied running example.
Example 9 revision sequence presented Example 3 lexicographic compatible.
Indeed, maxset(P3 , P2 , P1 ) = maxset(a, c, b) = c b, entailed K3 =
a. result, revision sequence generated lexicographic revision
preorder.
Given revision sequence, one determine consistency Ki Kj Ki Kj
maxset(Pi , . . . , P1 ) every pair formulae Ki Kj . problem non-existence
preorder generating sequence turned existence cycles,
computationally easy (polynomial size revision sequence). hard part
checking consistency. Since problem polynomial NP oracle available (which
turns consistency checks constant-time operations), problem p2 . However,
proved even computationally easier that.
Lemma 14 revision sequence [K0 , P1 , K1 . . . , Pn , Kn ] lexicographic compatible
either Ki 6|= maxset(Pi , . . . , P1 ) consistent sets R1 , . . . , Rn exist
that:
1. {Pj | 1 j Ki |= Pj } Ri every i;
2. exists cycle Ki1 , . . . , Kim = Ki1 either Kij Kij+1 Kij Kij+1 Ri
consistent ij {i1 , . . . , im1 }, second consistent least one
index.
advantage reformulation lexicographic incompatibility entailment tests contains reformulated terms consistency. means incompatibility NP. Therefore, compatibility coNP. shown hard
class.
Theorem 7 problem checking existence total preorder generating revision
sequence using lexicographic revision coNP-complete.
305

fiLiberatore

P


P

Figure 5: Reinforcement revision

7. Reinforcement Revision
Reinforcement revision (Jin & Thielscher, 2007) takes input total preorder
revise C revising formula P , parameter encodes degree
belief P (more precisely, degree disbelief P ). sake simplicity,
restriction case = 1 analyzed.
Definition 10 reinforcement revision total preorder C formula P parameter = 1 following total preorder CP , minimal index
C(i) Mod(P ) 6= .
(

CP (j) =

C(i) Mod(P )
j = 0
C(j 1)\Mod(P ) C(j + i) Mod(P ) j > 0

general definition j instead j 1; article, always 1. two
cases merged single one CP (j) = C(j 1)\Mod(P ) C(j + i) Mod(P )
j 0 assuming C(1) = . example, CP (0) = C(1)\Mod(P ) C(i)
Mod(P ) = C(i) Mod(P ), CP (1) = C(0)\Mod(P ) C(i + 1) Mod(P ).
graphical example revision Figure 5.
behavior revision shown preorder formulae Example 3.
Example 10 Revising preorder C = [C(0), C(1)] C(0) = Mod(a) C(1) =
Mod(a) P1 = b using reinforcement revision effect increasing class
every model P1 one; models P1 decrease class since
already class zero, means = 0 definition CP .
CP1 (0) = Mod(a b)
CP1 (1) = Mod((a b) (a b))
CP1 (2) = Mod(a b)

306

fiRevision History

happens revising P2 = c: every class union original class
conjoined c previous class conjoined c:
CP1 P2 (0) = Mod(a b c)
CP1 P2 (1) = Mod((a b c) (a b c) (a b c))
CP1 P2 (2) = Mod((a b c) (a b c) (a b c))
CP1 P2 (3) = Mod(a b c)
minimal class containing models P3 = CP1 P2 (1). Therefore, models
decreased one class. Models P3 = increased one class, usual:
CP1 P2 P3 (0) = Mod((a b c))
CP1 P2 P3 (1) = Mod((a b c) (a b c) (a b c))
CP1 P2 P3 (2) = Mod((a b c) (a b c) (a b c))
CP1 P2 P3 (3) = Mod(a b c)
result, K3 = b c.
revision semantics, every Ki assumed consistent; case inconsistent Ki degenerated, preorder produces knowledge base.
Given fixed revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] generated reinforcement revision initial total preorder C, lowest class index models Pi
ordering CP1 ,...,Pi denoted DC (i). Formally:
DC (i) = min{j | CP1 ,...,Pi1 (j) Mod(Pi ) 6= }
Revising Pi shifts models Pi DC (i) classes raises models
one class. result, DC (1), . . . , DC (n) tell model moved every
step, allowing determine model moved step step j.
Definition 11 movement j according DC revision sequence
[K0 , P1 , K1 , . . . , Pn , Kn ] MDC (I, i, j) where:
MDC (I, i, i) = 0;
MDC (I, i, + 1) = DC (i + 1) |= Pi+1 MDC (I, i, + 1) = 1 otherwise;
j > MDC (I, i, j) =

P

l=i,...,j1 MDC (I, l, l

+ 1);

j < MDC (I, i, j) = MDC (I, j, i).
Since DC (i) minimal class models Pi step 1 according initial preorder, MDC (I, i, j) change classes j using
preorder. initial preorder C affects definition MDC (I, i, j) indirectly, via
sequence DC = [DC (1), . . . , DC (n)]. result, MV (I, i, j) defined
arbitrary sequence n numbers V = [V (1), . . . , V (n)].
307

fiLiberatore

Lemma 15 every sequence n numbers V = [V (1), . . . , V (n)], holds MV (I, i, j) =
MV (I, i, h) + MV (I, h, j) every three indexes i, j h.
lemma holds even h j.
Since MDC (I, i, j) defined change class model step
step j, particular case |= Ki class step j, since
step zero.
Lemma 16 revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] generated reinforcement revision total preorder C DC = [DC (1), . . . , DC (n)] DC (i) =
min{j | CP1 ,...,Pi1 (j) Mod(Pi ) 6= } |= Ki then, every j:
MDC (I, i, j) = 0 |= Kj ;
MDC (I, i, j) > 0 otherwise.
lemma reversed, sense sequence values property
allows determine preorder generating sequence.
Definition 12 sequence nonnegative integer values V = [V (1), . . . , V (n)] reinforcement mover revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] if, every j,
|= Ki then:
MV (I, i, j) = 0 |= Kj ;
MV (I, i, j) > 0 otherwise.
previous lemma therefore recast as: sequence generated reinforcement revision total preorder C, reinforcement mover: DC .
converse holds: reinforcement mover one determine total preorder generating revision sequence.
Lemma 17 V = [V (1), . . . , V (n)] reinforcement mover revision sequence
[K0 , P1 , K1 , . . . , Pn , Kn ], following initial preorder C = [C(0), . . . , C(V (1) + + V (n +
1))] generates revision sequence reinforcement revision DC = V .
(

C(j) =

{I | |= Ki MV (I, i, 0) = j} j < V (1) + . . . + V (n) + 1
{I | . 6|= Ki }
j = V (1) + . . . + V (n) + 1

contrast condition compatibility revision semantics, one
explicitly require Ki |= Pi . however implied: 6|= Pi MV (I, 1, i) = 1
definition movement (Definition 11) |= Ki MV (I, i, j) 0 every j
definition reinforcement mover (Definition 12). particular case j = 1
MV (I, i, j) = MV (I, i, 1) = MV (I, 1, i) = 1, greater
equal zero. Therefore, reinforcement mover exists Ki 6|= Pi .
lemma allows checking existence preorder generating sequence
guessing V (1), . . . , V (n) checking class every model satisfies least
Ki . However, membership polynomial hierarchy follows values V (i)
representable polynomial space, possible values bounded
exponential size sequence.
308

fiRevision History

Lemma 18 reinforcement revision generates revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
total preorder, generates sequence preorder
minimal initial class models P1 0 1.
lemma proves sequence generated preorder generated
preorder C DC (1) either 0 1. particular, K0 P1 consistent
DC (1) = 0, otherwise DC (1) = 1. base case recursive proof giving bound
size DC (i). Intuitively, done lowering models Pi
number classes initial preorder; revising Pi moved together
minimal ones class zero, resulting ordering obtained
original one. lowering cannot however large models enter
class zero previous step j satisfy Kj .
Lemma 19 reinforcement revision generates sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
total preorder, generates sequence total preorder C
DC (i + 1) DC (1) + . . . + DC (i) + + 1.
lemma seen inductive part proof, previous one
base case. lead following conclusion.
Lemma 20 Reinforcement revision generates revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
total preorder generates sequence total preorder
DC (i) bounded 2i 1.
values DC (1), . . . , DC (n) bounded exponential value n,
lower bound size sequence [K0 , P1 , . . . , Pn , Kn ]. Therefore, DC (i)
represented space polynomial size sequence.
Theorem 8 Establishing existence total preorder generating revision sequence
[K0 , P1 , . . . , Pn , Kn ] reinforcement revision p2 , coNP n constant.
case constant-length sequences, hardness easy prove.
Theorem 9 Checking existence preorder generating reinforcement revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] coNP-complete, n constant.

8. Conclusions
Belief revision employs plausibility orders revise knowledge base, obtain
orders largely neglected. solution proposed studied article
assume knowledge previous revisions, reversing obtain initial order,
used revisions. method similar deriving order
hypothetical revisions K P |= Q, K R |= , etc., assumes knowledge
would happen revising formula P , R, etc. approach considered
article results iteratively incorporating series new formulae given,
nested counterfactuals (Eiter & Gottlob, 1996). Booth Nittka (2008) considered
problem deriving facts holding time points partial information expressed
309

fiLiberatore

terms positive negative conditions (i.e., formulae hold others
hold certain time points), done constructing initial ordering.
study focuses lexicographic revision only, allows partial knowledge
revisions results, includes choice initial ordering among possible ones.
Rather entailment information K P R |= Q, article history revisions
resulting knowledge bases assumed fully known. could actual results
manually performed changes, may already available.
analysis shown simple equivalent conditions existence ordering generating given series revisions results natural (Boutilier, 1996), restrained (Booth
& Meyer, 2006), lexicographic (Spohn, 1988; Nayak, 1994) reinforcement revisions (Jin
& Thielscher, 2007). conditions allow construct initial ordering one exists.
Using equivalent conditions, complexity establishing existence orderings generating sequence established considered semantics. Surprisingly,
turned relatively simple: coNP complete cases one (reinforcement
revision unbounded sequence length). checking propositional entailment, means checking generability increase complexity
base language propositional logic.
shown Section 5, revision sequence may generated one
ordering. leads question whether one may considered
natural sequence. example less J ordering another,
second may seen cautious, end rational: sequence
generated without assuming represents plausible world J,
reason draw conclusion. question whether single least informative
ordering exists every sequence, considered revision semantics, open
problem.
Still open comparison generable sequences various revisions: shown
running example, sequence generated natural revision generated
ordering restrained lexicographic revision. sequence
opposite property? not, natural revision may seen suited explaining
revision sequence generated. hand, may give less information
initial ordering used generate them; case orderings generating
sequence numerous semantics.
four semantics iterated belief revisions ones defined literature (Williams, 1994; Darwiche & Pearl, 1997; Areces & Becher, 2001; Benferhat et al.,
2004; Konieczny & Pino Perez, 2000; Zhang, 2004); recent survey counted least twenty
seven revision-related operators (Rott, 2009). Natural lexicographic semantics regarded extreme forms revision satisfying Darwiche-Pearl postulates (Darwiche &
Pearl, 1997), minimal maximal hearing respectively given new information. Restrained reinforcement revision considered middle,
obey conditions (Booth & Meyer, 2006; Jin & Thielscher, 2007). four
considered semantics therefore constitute reasonable spectrum possibilities, others
exist.
require additional information (like strength every revision, Spohn, 1988;
Williams, 1994; Benferhat et al., 2004), others families revisions rather single
ones (Darwiche & Pearl, 1997; Zhang, 2004). These, particular, open interesting
310

fiRevision History

line research: whether revision sequence generated ordering
revision semantics satisfying given set conditions, Darwiche Pearl (1997)
postulates. words, ordering semantics solution
problem, given revision sequence.
assumption reliability strictly increasing time gives directions
study. Indeed, principle realized true general (Peppas, 2008)
iterated revision recognized form prioritized merging (Delgrande, Dubois, & Lang,
2006). perspective, giving preference last formula particular case.
case interest, yet searching initial plausibility order possible
general case.
Yet another open problem combine approach article results
people actually perform revision. Indeed, experimentally proved
human revision suffers number biases (Tversky & Kahneman, 1983; See,
Morrison, Rothman, & Soll, 2011; Wang, Zhang, & Johnson, 2000), anchoring
order effect, excessive preference knowledge acquired early. studies show
revision performed people fully rational, contrary belief revision
formal semantics attempt be. psychological, extra-logical biases kept
account working sequences manually-performed revisions.
8.1 Acknowledgements
author thanks anonymous referees useful suggestions previous
versions article.

Appendix A. Proofs
following sections contain proofs lemmas theorems article.
A.1 Preliminaries: Proofs
Lemma 1 F consistent F |= maxset(P1 , . . . , Pn ), maxset(P1 , . . . , Pn )
{Pi | 1 n F |= Pi }.
Proof. Since F |= maxset(P1 , . . . , Pn ) F implies every Pi maxset.
possibility claim hold F implies Pi
maxset. Since every element maxset(P1 , . . . , Pn ) implied F , every element
prefixi (maxset(P1 , . . . , Pn )) is. Since F entails Pi , every model F satisfies
prefixi (maxset(P1 , . . . , Pn )) Pi . consistency Pi prefixi (maxset(P1 , . . . , Pn ))
contradicts assumption Pi maxset.
Lemma 2 F consistent F |= maxset(P1 , . . . , Pn ), every consistent subset
{P1 , . . . , Pn } contains formulae entailed F equivalent maxset(P1 , . . . , Pn ).
Proof. Lemma 1, since F consistent F |= maxset(P1 , . . . , Pn )
maxset(P1 , . . . , Pn ) {Pi | 1 n F |= Pi }. proves maxset(P1 , . . . , Pn )
contains formulae entailed F .
Let R consistent proper superset
311

fiLiberatore

maxset(P1 , . . . , Pn ). Let Pi lowest-index formula R
maxset(P1 , . . . , Pn ). Since lowest index, R maxset(P1 , . . . , Pn )
formulae among {P1 , . . . , Pi1 }. Since R consistent, intersection set
consistent well. Since R contains Pi , follows prefixi (P1 , . . . , Pn ) {Pi }
consistent, contradicting assumption Pi maxset(P1 , . . . , Pn ).
Lemma 3 F consistent F 6|= maxset(P1 , . . . , Pn ) exists
subsequence R [P1 , . . . , Pn ] that:
1. R consistent;
2. F |= Pi Pi R;
3. i, Pi 6 R Pi prefixi (R) consistent.
Proof. Two cases considered: first, F entails maxset; second, F not.
first, R proved exists; second, one R shown.
F |= maxset(P1 , . . . , Pn ), F implies elements maxset. result,
second condition true R contains formulae maxset. R
contains formulae maxset, since formula maxset inconsistent
maxset, R inconsistent. result, R consistent coincides
maxset. contradicts third point, showing every R, first
second conditions true third false.
F 6|= maxset(P1 , . . . , Pn ), three conditions satisfied R containing precisely
formulae Pi entailed F . choice meets first condition F consistent
second construction. third condition proved hold well.
Since F entail maxset F entail formulae maxset.
Let least index formula maxset(P1 , . . . , Pn ) entailed F .
construction, every formula Pj maxset R j < i. shown
converse holds. contrary, let j < lowest index formula R
maxset.
assumptions j least indexes R maxset differ (in
way other) imply prefixj (R) = prefixj (maxset(P1 , . . . , Pn )). Since assumption
Pj maxset, inconsistent prefixj (maxset(P1 , . . . , Pn )). result,
inconsistent prefixj (R). Since Pj R, implies inconsistency R,
proved consistent.
contradiction proves R maxset equal index
j < i, i. words, prefixi (R) = prefixi (maxset(P1 , . . . , Pn )).
assumption Pi formula maxset R. maxset
means Pi prefixi (maxset(P1 , . . . , Pn )) consistent. proved,
latter equivalent Pi prefixi (R). concludes proof third condition.
Theorem 1 F consistent, checking F maxset(P1 , . . . , Pn ) coNP.
Proof. F maxset(P1 , . . . , Pn ) holds F |= maxset(P1 , . . . , Pn ) maxset(P1 , . . . , Pn ) |=
F . first condition true, Lemma 1 maxset comprises exactly formulae
312

fiRevision History

entailed F . Therefore, converse maxset(P1 , . . . , Pn ) 6|= F happen
exists model satisfying formulae Pi entailed F F itself. words:
F maxset(P1 , . . . , Pn )
iff F |= maxset(P1 , . . . , Pn ) maxset(P1 , . . . , Pn ) |= F
iff F |= maxset(P1 , . . . , Pn ) (I . 6|= F i(F |= Pi |= Pi ))
iff F |= maxset(P1 , . . . , Pn ) (I . 6|= F i(F 6|= Pi |= Pi ))
iff F |= maxset(P1 , . . . , Pn ) . |= F i(F |= Pi 6|= Pi ))

Lemma 3 reformulates converse first condition F |= maxset(P1 , . . . , Pn ) using
existential quantifiers (the second point equivalent either F 6|= Pi Pi R).
result, first condition expressed using universal quantifiers.
existential quantifier second condition i, replaced
disjunction. Since quantifiers universal, problem coNP.
A.2 Natural Revision: Proofs
Lemma 4 CP (0) Mod(F ) = CP compares models F C does, CP
natural revision total preorder C formula P .
Proof. Let J two models F , l classes. Since models F
CP (0) Mod(F ) = , belong CP (0). result, CP (m + 1) = C(m)\CP (0)
contains CP (l + 1) = C(l)\CP (0) contains J. proves revising C F
increases classes J one each. Therefore, greater equal J
according CP according C.
Lemma 5 Let [Kj , Pj+1 , . . . , Pi , Ki ] revision sequence generated natural revision
total preorder C. Kj Pi consistent none Kj+1 Pi , . . . , Ki1 Pi is,
CPj+1 ,...,Pi (0) = Mod(Kj Pi ).
Proof. Lemma 4, CPj+1 ,...,Pi1 compares models Pi way C does.
result, Mod(Ki ) minimal models Pi C. Since C(0) = Mod(Kj ) Kj Pi
consistent, minimal models C(0) Mod(Pi ) = Mod(Kj Pi ).
Lemma 6 revision sequence [K0 , P1 , K1 , . . . , Pi , Ki ] generated natural revision
total preorder C Pi inconsistent K0 , . . . , Ki1 , models
Ki minimal models Pi according C.
Proof. Lemma 4, revising C P1 , . . . , Pi1 affect order
models Pi . result, minimal models Pi according CP1 ,...,Pi1 minimal
models Pi according C.
313

fiLiberatore

Theorem 2 [K0 , P1 , K1 , . . . , Pn , Kn ] natural-compatible generated natural
revision initial preorder C = [C(0), . . . , C(n + 1)].


Mod(Ki )

C(i) =

n l < . Kl Pi |=
otherwise, n

S{Mod(K ) | l < j . K P 6|= } = n + 1
j
j
l


Proof. Since formula index lower zero, C(0) equal Mod(K0 ) therefore
empty. classes C contain models C(n + 1) comprises every model
C(0), . . . , C(n). prove C total preorder, proved sets
C(i) disjoint. model C(i) n Mod(Ki ). Therefore,
model Pi . Since Pi inconsistent K0 , . . . , Ki1 , model
C(0), . . . , C(i 1). class C(n + 1) contains exactly models
C(0) C(n). proves C total preorder.
formulae Ki generated different ways depending whether Kj Pi consistent j < i:
index j exists, assumption natural compatibility Ki Kj Pi
maximal j; Lemma 5, exactly result revising C
P1 , . . . , Pi .
otherwise, Pi inconsistent K0 , . . . , Ki1 ; Lemma 6, Mod(Ki )
minimal models Pi initial preorder C. Since Pi inconsistent K0 , . . . , Ki1 , then: first, since C(0), . . . , C(i 1) subsets
Mod(K0 ), . . . , Mod(Ki1 ), classes contain models Pi ; second, C(i)
empty equal Mod(Ki ). result, minimal models Pi exactly
Mod(Ki ).

Theorem 3 revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] generated natural revision
initial total preorder natural-compatible.
Proof. previous theorem shows every natural-compatible sequence generated
natural revision total preorder. converse proved: sequence
natural-compatible generated natural revision preorder.
Since Mod(Ki ) = CP1 ,...,Pi1 ,Pi (0) = CP1 ,...,Pi1 (l) Mod(Pi ) l, holds
Mod(Ki ) Mod(Pi ), Ki |= Pi . Therefore, Ki 6|= Pi preorder
generate revision sequence. Otherwise, natural-compatibility violated if, j
i:
1. Kj Pi consistent;
2. formulae Kj+1 Pi , . . . , Ki1 Pi inconsistent;
3. Kj Pi equivalent Ki .
314

fiRevision History

Lemma 5, first two points imply revising Cj Pj+1 , . . . , Pi generates
formula equivalent Kj Pi , contradicting third point. proves revision
sequence natural-compatible generated natural revision preorder.
Lemma 7 Checking existence total preorder C generating revision sequence
[K0 , P1 , K1 , . . . , Pn , Kn ] using natural revision coNP.
Proof. According Theorem 3, preorder C exists if, every
{1, . . . , n}, holds Ki |= Pi and, j maximal index j < Kj Pi
consistent (if any), Ki Kj Pi . first part, Ki |= Pi i, verified
linear number independent unsatisfiability tests.
second part rewritten as: Kj Pi consistent Kh Pi inconsistent
every h j i, Ki Kj Pi . Rewriting implication disjunction,
every j = 0, . . . , 1:
1. either K0 Pi inconsistent Kh Pi consistent 0 < h < Ki K0 Pi ;

2. either K1 Pi inconsistent Kh Pi consistent 1 < h < i, Ki K1 Pi ;

3. . . . ;
4. either Ki1 Pi inconsistent Ki K0 Pi .
conditions index i. hold every {1, . . . , n}. Since
formulae Ki consistent, conditions simplified: Kj Pi consistent,
either Kh Pi consistent j < h < Ki Kj Pi ; latter case, Ki Kh Pi
one index h (the last). Therefore, condition recast as:
Kj Pi |= Ki Kj+1 Pi . . . Ki Ki1 Pi Ki Kj Pi
condition checked number independent unsatisfiability tests,
therefore coNP.
Theorem 4 problem establishing existence preorder generating revision
sequence using natural revision coNP complete.
Proof. Membership proved previous lemma. Hardness proved reduction
problem checking whether formula G unsatisfiable. instance [K0 , P1 , K2 ]
K0 = a, K1 = P1 = G, new variable, G. G satisfiable,
K0 P1 consistent; therefore, equivalent K1 . Instead, G.
G unsatisfiable, K1 = P1 = inconsistent K0 . Theorem 3, preorder
generating sequence using natural revision exists.

315

fiLiberatore

A.3 Restrained Revision: Proofs
Lemma 8 Let [Kj , Pj+1 , . . . , Pi , Ki ] revision sequence generated restrained revision
initial total preorder C. Kj Pi consistent none Kj+1 Pi , . . . ,
Ki1 Pi is, CPj+1 ,...,Pi (0) = Mod(maxset(Kj Pi , Pj+1 , . . . , Pi1 )).
Proof. Proof induction j. j = + 1 claim CPi (0) = Mod(maxset(Kj
Pi )) holds Kj Pi consistent assumption.
inductive claim CPj+1 ,...,Pi2 ,Pi1 ,Pi (0)
=
Mod(maxset(Kj
Pi , Pj+1 , . . . , Pi2 , Pi1 )), inductive assumption without Pi1 :
CPj+1 ,...,Pi2 ,Pi (0) = Mod(maxset(Kj Pi , Pj+1 , . . . , Pi2 ))
definition, CPj+1 ,...,Pi2 ,Pi (0) CPj+1 ,...,Pi2 (k) Mod(Pi ) k minimal
integer making intersection non-empty. result, CPj+1 ,...,Pi2 (l) Mod(Pi ) =
indexes l 0 l < k. Revising preorder Pi1 changes classes of:
models Ki1 , become class zero;
models class, split according whether satisfy Pi1 .
Since model Ki1 satisfies Pi assumption, CPj+1 ,...,Pi2 ,Pi1 (0) Mod(Pi ) =
holds. None classes CPj+1 ,...,Pi2 index 0 l < k intersect Mod(Pi ); therefore,
neither ones resulting splitting them. result, minimal-index class
intersecting Mod(Pi ) one two resulting splitting CPj+1 ,...,Pi2 (k), are:
CPj+1 ,...,Pi2 (k) Mod(Pi1 )
CPj+1 ,...,Pi2 (k)\Mod(Pi1 )
first intersects Mod(Pi ), Mod(Ki ); otherwise, Mod(Ki ) second.
formulae:
(

Mod(Ki ) =

CPj+1 ,...,Pi2 (k) Mod(Pi1 ) Mod(Pi ) empty
(CPj+1 ,...,Pi2 (k)\Mod(Pi1 )) Mod(Pi ) otherwise

properties set operators, equation rewritten as:
(

Mod(Ki ) =

CPj+1 ,...,Pi2 (k) Mod(Pi ) Mod(Pi1 ) empty
(CPj+1 ,...,Pi2 (k) Mod(Pi ))\Mod(Pi1 ) otherwise

way k defined, CPj+1 ,...,Pi2 (k) Mod(Pi ) equal CPj+1 ,...,Pi2 ,Pi (0).
latter inductive assumption Mod(maxset(Kj Pi , Pj+1 , . . . , Pi2 )). Intersecting
set Mod(Pi1 ) result empty, subtracting Mod(Pi1 ) otherwise
adding Pi1 end sequence, definition maxset
sequence. Since Mod(Ki ) = CPj+1 ,...,Pi2 ,Pi1 ,Pi (0), proves inductive claim
set equal Mod(maxset(Kj Pi , Pj+1 , . . . , Pi2 , Pi1 )).

316

fiRevision History

Lemma 9 [K0 , P1 , K1 , . . . , Pn , Kn ] restrained-compatible generated restrained revision total preorder C = [C(0), . . . , C(n + 1)], where:


Mod(Ki )

C(i) =

n l < . Pi Kl |=
otherwise, n

S{Mod(K ) | l < j P K 6|= } = n + 1
j
j
l


Proof. formula index less zero; therefore, C(0) = Mod(K0 ), empty
formulae sequences consistent assumption. Since C(n + 1) contains
models C(0) C(n), union classes include models, model
C(n+1) another classes. order prove C partition, shown
model C(i) C(l) l < n. C(i) n Mod(Ki )
Pi Kl inconsistent l < i. Since Ki |= Pi , Ki Kl inconsistent.
proves model cannot C(i) C(l) l < i.
previous lemma shows that, regardless initial total preorder, revision
sequence generated restrained revision Ki maxset(Kj Pi , Pj+1 , . . . , Pii )
j maximal index j < Kj Pi consistent, any. Since restrained
compatibility ensures condition holds, Ki j exists obtained
revision regardless C.
Remains show C generates Ki even Pi Kl inconsistent l < i.
models Pi C(i) = Mod(Ki ) classes greater index. Indeed, model
Pi C(l) l < k Pi Kl would consistent. Revising C Pl ,
l = 1, . . . , 1, changes preorder two ways:
1. models Kl moved class zero;
2. classes split according satisfaction Pl .
Since Pi Kl inconsistent, model Pi moved class zero. result,
relative position models Pi modified second change, splitting
classes. could break class Mod(Ki ) two, case. Indeed, since
either Ki |= Pl Ki |= Pl , either models Ki satisfy Pl falsify Pl .
words, change may alter comparison two models Pi ,
Mod(Ki ).
Two claims therefore proved: models Pi C(i) = Mod(Ki )
greater classes; first 1 revisions minimal models Pi still
Mod(Ki ). proves result i-th revision Ki .
Theorem 5 revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] generated restrained revision
initial total preorder restrained-compatible.
Proof. previous lemma shows every restrained-compatible revision sequence
generated certain initial preorder. Remains therefore prove converse:
revision sequence restrained-compatible generated initial preorder.
Lemma 8 proves every sequence generated restrained revision satisfies condition Ki maxset(Pi Kj , Pj+1 , . . . , Pi1 ) j maximal j <
317

fiLiberatore

Pi Kj consistent. Ki |= Pi holds consequence Mod(Ki ) set minimal models satisfying Pi . Remains therefore prove necessity third condition
restrained compatibility: Pi consistent Kj j < k either Ki |= Pl
Ki |= Pl every l < i.
contrary, let l < Ki 6|= Pl Ki 6|= Pl . two conditions
imply Mod(Ki ) contains models Pl models Pl . Even
models Ki class l 1 revisions, l-th one separates ones
satisfying Pl ones satisfying Pl . may end two consecutive classes,
new class zero another class, either way models Ki placed two
separate classes. Since constrained revision never merges classes, models still
separate classes 1-th revision. result, revising Pi select part
Mod(Ki ) it.
Lemma 10 revision sequence [K0 , P1 , K1 . . . , Pn , Kn ] restrained-compatible
if, every index i:
1. Ki |= Pi ;
2. every 0 j < i, either Kj Pi inconsistent Ki |= Kl Pi j < l <
Ki maxset(Kj Pi , Pj+1 , . . . , Pi1 );
3. every 0 j < i, Ki |= Pj , Ki |= Pj , Ki |= Kl Pi 0 l < i.
Proof. three conditions restrained compatibility rewritten follows,
every index i.
1. Ki |= Pi ;
2. every j 0 j < i, either Kj Pi inconsistent Kl Pi consistent
j < l < Ki maxset(Kj Pi , Pj+1 , . . . , Pi1 );
3. every j 0 j < i, either Ki |= Pj Ki |= Pj Kl Pi consistent
0 l < i.
second third point include Kl Pi consistent h l < i:
first, h = j + 1; second, h = 0. particular conditions lemma,
two conditions shown equivalent:
1. Kl Pi satisfiable l h l < i;
2. Ki |= Kl Pi l h l < i.
proved that: first, sequence restrained-compatible Condition 1 implies
Condition 2; second, three conditions lemma true Condition 2 implies
Condition 1.
Condition 1 Kl Pi consistent h l < i. Either l maximal
index property index h is. Let g maximal
index. restrained compatibility, Ki maxset(Kg Pi , Pi1 , . . . , Pg+1 ). maxset
318

fiRevision History

sequence implies first element, consistent. Since case, Ki |= Kg Pi .
means Condition 2 holds index g.
Condition 2 Ki |= Kh Pi h l < i. Since Ki consistent, Kh Pi
consistent well, proving Condition 1 index l.
Theorem 6 Establishing existence total preorder generating restrained revision
sequence coNP-complete.
Proof. Membership follows previous lemma. conditions reformulated
entailments (like Ki |= Pi ), inconsistencies (like Kj Pi ) equivalences
maxsets (Ki maxset(Kj Pi , Pj+1 , . . . , Pi1 )). problems coNP,
therefore rewritten universal quantified formulae. whole problem combination
these; renaming variables taking quantifiers, single universally
quantified formula results. Since QBF coNP, problem coNP.
Hardness proved reduction problem propositional unsatisfiability. Given
formula F , associated revision sequence [a, b F, b], b fresh
variables, occurring F . F unsatisfiable b F equivalent b,
sequence [a, b, b] generated preorder C = [C(0), C(1)] C(0) = Mod(a)
C(1) = Mod(a). F satisfiable (b F ) satisfiable equivalent
b, makes sequence generated restrained revision preorder.
sequence therefore generated restrained revision preorder
F unsatisfiable.
A.4 Lexicographic Revision: Proofs
Lemma 11 revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] generated lexicographic
revision total preorder among models C result preorder R defined
by:
R(i) = {Ki | Mod(Ki ) C(i)}
Proof. R total preorder because: first, R(0) empty C(0) = Mod(K0 ),
implies Mod(K0 ) C(0) K0 R(0); second, formula two classes
R C partition. Third, every Ki class R Property 1:
since Mod(Ki ) set minimal models C, models class C(j);
therefore, Ki R(j). Remains prove preorder satisfies two conditions
result preorder sequence.
Ki Kj consistent other, common model I. Let h
class. construction, since |= Ki Ki R(h). holds Kj , since
|= Kj . result, Kj R(h).
Let Ki Kj Ki Kj maxset(Pi , . . . , P1 ) consistent. assumption,
sequence generated lexicographic revision C. result, models Ki
exactly minimal models maxset(Pi , . . . , P1 ) according C. Let h class
models. construction R, holds Ki R(h). models Ki maxset(Pi , . . . , P1 )
belong greater class l > h. Since Ki Kj maxset(Pi , . . . , P1 ) consistent, Kj
319

fiLiberatore

models C(l). Since models Kj class, follows Mod(Kj ) C(l),
implies Kj R(l). Since l > h, claim proved.
Lemma 12 R result preorder revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
Ki |= maxset(Pi , . . . , P1 ) every i, lexicographic revision following
total preorder C among models generates revision sequence, z index
greatest class R:
(

C(h) =

{Mod(Ki ) | Ki R(h)} h z
{I | 6 K1 Kn }
h = z + 1

Proof. C proved total preorder. First, C(0) empty since R(0) empty.
Second, model belongs one class: C(h) C(l)
definition exists Ki R(h) Kj R(l) satisfied I; implies
Ki Kj consistent; since R result preorder sequence, follows l = h.
Models C(z + 1) exactly ones contained classes.
Remains proved lexicographic revision generates revision sequence
C: revising C P1 , . . . , Pi generates Ki . Since Ki |= maxset(Pi , . . . , P1 ) assumption,
models Ki models maxset(Pi , . . . , P1 ). Remains proved
minimal ones: models greater classes. Let h class models
Ki , model Ki maxset(Pi , . . . , P1 ). satisfy Kj
R(z + 1), z + 1 > h since z greatest index classes R.
satisfies Kj satisfies Ki Kj maxset(Pi , . . . , P1 ), therefore satisfiable.
Since R result preorder sequence, Kj class R(l) l > h. implies
C(l). proves every model maxset(Pi , . . . , P1 ) Mod(Ki )
class greater h.
Lemma 13 revision sequence generated lexicographic revision total preorder lexicographic compatible.
Proof. revision sequence generated total preorder Ki |=
maxset(Pi , . . . , P1 ) holds every i. Furthermore, result preorder R exists
Lemma 11. it, define relations ' < as: Ki ' Kj Ki Kj
class R(h); Ki < Kj Ki R(h), Kj R(l) h < l. Since R revision
preorder sequence, Ki Kj consistent Ki Kj class,
implies Ki ' Kj . way, Ki Kj maxset(Pi , . . . , P1 ) consistent
Ki lower class Kj , implying Ki < Kj . cycle containing < impossible
Ki < Kj means class Ki lower class Kj .
prove lexicographic compatibility, requires Ki ' Kj Ki < Kj
respectively equivalent consistency Ki Kj Ki Ki maxset(Pi , . . . , P1 ),
merely implied them. However, removing relations pairs Ki
Kj satisfying respective condition makes relations weaker. Therefore, new
cycle created.
prove direction, assume Ki |= maxset(Pi , . . . , P1 ) every
' < two relations defined sequence specified definition
320

fiRevision History

lexicographic compatibility. result preorder sequence shown. Together
Ki |= maxset(Pi , . . . , P1 ), implies revision sequence generated initial
preorder Lemma 12.
' <, relation defined: Ki Kj either Ki ' Kj Ki < Kj .
relation necessarily transitive, number properties:
1. Ki ' Kj Ki Kj Kj Ki ; indeed, Ki ' Kj holds Ki Kj
consistent, implies Kj Ki consistent; therefore, Kj ' Ki , implies
Kj Ki ;
2. Ki < Kj Ki Kj Kj 6 Ki ; converse, Kj Ki , either
Kj ' Ki Kj < Ki ; cases, cycle ' < containing one < link,
contradicts assumption cycle exists;
3. reflexive; indeed, formulae Ki consistent assumption; therefore, Ki Ki
consistent, implies Ki ' Ki Ki Ki ;
4. Suzumura consistent (Suzumura, 1976): form cycles Ki1 , . . . , Kim =
Ki1 Kij Kij+1 j j Kij+1 6 Kij ; proved
below.
Properties 1 2 mean ' < equivalence strict part , respectively. Indeed, Ki Kj holds either Ki ' Kj Ki < Kj ; former implies
Kj Ki , latter Kj 6 Ki . Property 4 consequence fact assumption
nonexistence cycles ' < containing least one link <.
Since reflexive (Property 3) Suzumura consistent (Property 4), Suzumura
extension theorem (Suzumura, 1976) total preorder R extending exists. Extending
means equivalence strict parts preserved R. Since
proved ' <, total preorder R Ki Kj class Ki ' Kj
Ki lower class Ki < Kj .
Ki Kj consistent Ki ' Kj , implies Ki Kj
class R. Ki Kj maxset(Pi , . . . , P1 ) consistent Ki < Kj , implies
class Ki R less class Kj . proves R result preorder
revision sequence.
Lemma 14 revision sequence [K0 , P1 , K1 . . . , Pn , Kn ] lexicographic compatible
either Ki 6|= maxset(Pi , . . . , P1 ) consistent sets R1 , . . . , Rn exist
that:
1. {Pj | 1 j Ki |= Pj } Ri every i;
2. exists cycle Ki1 , . . . , Kim = Ki1 either Kij Kij+1 Kij Kij+1 Ri
consistent ij {i1 , . . . , im1 }, second consistent least one
index.
Proof.
revision sequence lexicographic compatible Ki |=
maxset(Pi , . . . , P1 ) cycle specified definition. Inverting
321

fiLiberatore

condition, sequence lexicographic compatible either Ki 6|= maxset(Pi , . . . , P1 )
cycle exists. result, one check whether Ki 6|= maxset(Pi , . . . , P1 ) i;
true, check needed: sequence lexicographic compatible.
presence cycles irrelevant case. case Ki |= maxset(Pi , . . . , P1 )
i, sequence lexicographic compatible contains
cycles.
point condition presence cycles written
assumption Ki |= maxset(Pi , . . . , P1 ), since case condition
matters. Lemma 2, consistent subset {P1 , . . . , Pi } containing formulae entailed Ki maxset(Pi , . . . , P1 ). means Ri used place
maxset(Pi , . . . , P1 ), since Ri satisfying first condition statement
lemma maxset(Pi , . . . , P1 ).
Theorem 7 problem checking existence total preorder generating revision
sequence using lexicographic revision coNP-complete.
Proof. Membership follows previous lemma: sequence generated
lexicographic revision preorder lexicographic compatible,
turns checked existential quantifiers only:
1. Ki 6|= maxset(Pi , . . . , P1 );
2. exists Ri ;
3. Ri consistent;
4. either Ki 6|= Pj Pj Ri ;
5. exists cycle Ki1 , . . . , Kim = Ki1 ;
6. Kij Kij+1 consistent;
7. Kij Kij+1 Ri consistent.
first condition expressed terms existential quantifiers shown
Lemma 3. holds conditions well. result, incompatibility
NP, means existence preorder generating sequence coNP.
Hardness proved reduction propositional unsatisfiability. formula F
satisfiable [K0 , P1 , K1 ] generated preorder, K0 = a, P1 =
K1 = F new variable contained F . Indeed, F unsatisfiable,
K1 = a, sequence generated preorder C = [C(0), C(1)] C(0) = Mod(a)
C(1) = Mod(a). F satisfiable, K1 models satisfy P1 :
ones F . result, K1 6|= P1 , sequence generated preorder.

322

fiRevision History

A.5 Reinforcement Revision: Proofs
Lemma 15 every sequence n numbers V = [V (1), . . . , V (n)], holds MV (I, i, j) =
MV (I, i, h) + MV (I, h, j) every three indexes i, j h.
Proof. < j MV (I, i, j) sum MV (I, l, l+1) < l j. Otherwise,
sum MV (I, l, l + 1) = MV (I, l + 1, l). MV (I, i, h) MV (I, h, j) expressed
way. h j result follows immediately. Otherwise, < j
h > j MV (I, i, h) includes MV (I, l, l + 1) l > j, MV (I, h, j) includes
MV (I, l + 1, l) = MV (I, l, l + 1), subtracts amount sum.
case h < similar.
Lemma 16 revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] generated reinforcement revision total preorder C DC = [DC (1), . . . , DC (n)] DC (i) =
min{j | CP1 ,...,Pi1 (j) Mod(Pi ) 6= } |= Ki then, every j:
MDC (I, i, j) = 0 |= Kj ;
MDC (I, i, j) > 0 otherwise.
Proof. model CP1 ...Pi1 (c) CP1 ...Pi (c DC (i)) |= Pi
CP1 ...Pi1 (c + 1) otherwise. result, MDC (I, i, + 1) difference class
preorder step + 1 preorder step i. Since MDC (I, i, j) sum
amounts index index j, difference class step
j i. |= Ki class step zero. result, MDC (I, i, j) class
step j. zero |= Kj greater otherwise.
Lemma 17 V = [V (1), . . . , V (n)] reinforcement mover revision sequence
[K0 , P1 , K1 , . . . , Pn , Kn ], following initial preorder C = [C(0), . . . , C(V (1) + + V (n +
1))] generates revision sequence reinforcement revision DC = V .
(

C(j) =

{I | |= Ki MV (I, i, 0) = j} j < V (1) + . . . + V (n) + 1
{I | . 6|= Ki }
j = V (1) + . . . + V (n) + 1

Proof. Since K0 consistent, least model I. Since |= K0 MV (I, 0, 0) = 0
definition, follows C(0), proving C(0) empty. Every model
class |= Ki C(MV (I, i, 0)), otherwise C(V (1) + . . . + V (n) +
1). prove C total preorder, remains prove model belongs two
classes. |= Ki |= Kj MV (I, j, i) = 0 V reinforcement mover;
therefore, MV (I, i, 0) = 0 + MV (I, i, 0) = MV (I, j, i) + MV (I, i, 0) = MV (I, j, 0). model
C(V (1) + . . . + V (n) + 1) satisfy Ki ; therefore, cannot
class C(j). proves C total preorder.
longest part proof show reinforcement revision generates
sequence C. Inductively, assumed DC (1) = V (1), DC (2) = V (2), . . . ,
DC (i) = V (i), DC (l) = min{j | CP1 ,...,Pl1 (j) Mod(Pl ) 6= }. proved
323

fiLiberatore

models Ki CP1 ,...,Pi (0) models classes greater index
total preorder. Furthermore, minimal class models Pi+1 preorder
V (i + 1), proving DC (i + 1) = V (i + 1), allows iterate proof.
base case = 0: proved Mod(K0 ) = C(0) DC (1) =
V (1). construction C, model C(0) MV (I, i, 0) = 0 |= Ki i;
hold = 0. Vice versa, C(0) |= Ki MV (I, i, 0) = 0 i.
6|= K0 , definition reinforced mover j = 0 implies MV (I, i, 0) > 0,
turn implies 6 C(0), contradiction.
order prove DC (1) = V (1), let model P1 . construction C,
|= K1 C(V (1)). 6|= K1 two cases possible. first, 6|= Kj every
j. implies C(V (1) + . . . + V (n) + 1), V (1) + . . . + V (n) + 1 > V (1).
second case, |= Kj j. definition reinforcement mover, MV (I, j, 1) > 0.
class C containing index MV (I, j, 0) = MV (I, j, 1)+MV (I, 1, 0) = MV (I, j, 1)+
V (1), last step consequence |= Pi . Since MV (I, j, 1) > 0, follows
amount greater V (1). proves V (1) index minimal class
models P1 C: DC (1) = V (1). concludes base case.
assumed DC (1) = V (1), . . . , DC (i) = V (i), proved CP1 ...Pi
class zero equal Mod(Ki ) minimal models Pi+1 class V (i + 1),
proves DC (i + 1) = V (i + 1). induction, proves sequence generated
reinforcement revision total preorder C.
Let model Ki . construction, C(MV (I, i, 0)). first revisions
increase class MDC (I, 0, i). Since DC (1), . . . , DC (i) equal V (1), . . . , V (i)
inductive assumption, MV (I, 0, i). definition MV ,
holds MV (I, i, 0) = MV (I, 0, i). result, MV (I, i, 0) + MDC (I, 0, i) = MV (I, i, 0)
MV (I, i, 0) = 0: model CP1 ...Pi (0).
model Ki , may model Kj not. second
case, C(V (1) + + V (n) + 1). first steps reduce class number
DC (1) + . . . + DC (i), leading V (1) + + V (n) + 1 + DC (1) + . . . + DC (i). Since
first values V DC coincide, V (1) + + V (n) + 1 V (1) V (i) =
1 + V (i + 1) + + V (n), greater zero.
model Kj C(MV (I, j, 0)) definition C. class step
therefore MV (I, j, 0)+MDC (I, 0, i). Since DC (1), . . . , DC (i) coincide V (1), . . . , V (i)
induction hypothesis, second term equal MV (I, 0, i). sum therefore
equal MV (I, j, 0) + MV (I, 0, i) = MV (I, j, 0) MV (I, i, 0) = MV (I, j, i) + MV (I, i, 0)
MV (I, i, 0) = MV (I, j, i). definition reinforced mover j reversed, since
|= Kj 6|= Ki MV (I, j, i) > 0. proves class order
CP1 ...Pi index larger zero.
last step proof show models Pi+1 classes index
V (i + 1) greater according ordering step i, CP1 ...Pi . Let model
Pi+1 . satisfy Kj C(V (1)+ +V (n)+1). step class
least V (1) + + V (n) + 1 DC (1) DC (i), since DC (j) maximal decrease
classes step j. Since DC (1), . . . , DC (i) coincide V (1), , V (i) induction
assumption, equal V (1)+ +V (n)+1V (1) V (i) = V (i+1)+ +V (n)+1,
larger V (i + 1).
324

fiRevision History

satisfies Kj , possibly j = + 1, C(MV (I, j, 0)) definition
C. step i, class index MV (I, j, 0) + MDC (I, 0, i). Since DC (1), . . . , DC (i)
assumed equal V (1), . . . , V (i), second term equal MV (I, 0, i) sum
MV (I, j, 0) + MV (I, 0, i) = MV (I, j, i). Since |= Pi+1 , MV (I, i, + 1) = V (i + 1)
definition MV (Definition 11 V place DC ). definition reinforced mover
ensures MV (I, j, + 1) = MV (I, j, i) + MV (I, i, + 1) = MV (I, j, i) V (i + 1) equal
0 |= Ki+1 greater otherwise. Since Ki+1 models, minimal value
MV (I, j, i) V (i + 1) zero, proving minimal value MV (I, j, i) V (i + 1).
proves DC (i + 1) = V (i + 1).
Lemma 18 reinforcement revision generates revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
total preorder, generates sequence preorder
minimal initial class models P1 0 1.
Proof. K0 P1 consistent P1 models K0 , class zero.
Otherwise, let class indexes models P1 k1 < k2 < k3 < . . . Revision P1
decreases numbers k1 , making k1 k1 = 0, k2 k1 , k3 k1 , etc.
given initial preorder, new one generated reducing model
P1 k1 1 classes. new initial preorder generates revision sequence.
models satisfy P1 changed initial class, revising P1
still moved one class.
models P1 classes k1 (k1 1), k2 (k1 1), k3 (k1 1), etc.
new preorder. Since k1 minimal index models P1 , none indexes zero.
Therefore, model P1 enters K0 .
minimal class models P1 new initial preorder 1, proving DC (1) =
1. implies revising P1 decreases class models P1 one.
result, indexes classes k1 (k1 1) 1, k2 (k1 1) 1, k3 (k1 1) 1,
etc. coincide k1 k1 = 0, k2 k1 , k3 k1 , etc. classes
obtained revising original preorder P1 . models satisfy P1
initial class still moved one class. proves ordering
revising P1 before. Therefore, point revision sequences
identical.
Lemma 19 reinforcement revision generates sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
total preorder, generates sequence total preorder C
DC (i + 1) DC (1) + . . . + DC (i) + + 1.
Proof. claim proved two cases separately: Pi+1 models satisfy
Kj j < i, not.
Case 1: models Pi+1 satisfy Kj j < i. models class zero
step j. Therefore, class j step i. proves Pi+1
models class j, minimal class models j less: DC (i + 1) j,
less DC (1) + . . . + DC (i) + + 1 j < + 1.
Case 2: model Pi+1 Kj j < i. Let C(l) minimal initial class
models Pi+1 . l > DC (1) + . . . + DC (i), models Pi+1 decreased
325

fiLiberatore

l (DC (1) + . . . + DC (i)) 1 classes without affecting generated sequence. Models
class l move class l(l(DC (1)+. . .+DC (i)1)) = DC (1)+. . .+DC (i)+1. maximal
class model may reach step DC (1) + . . . + DC (i) + 1 + i, since step may
increase class model one. Therefore, DC (i+1) DC (1)+. . .+DC (i)+i+1.
remains proved change affect revision results.
Regarding steps + 1, since models Pi+1 initial class DC (1) +
. . . + DC (i) + 1 greater, models K1 initial class DC (1), minimal
class models P1 still DC (1) result revision still K1 . Since DC (1)
before, similar line reasoning applied models K2 DC (2),
K3 Ki , proving neither K1 , . . . , Ki DC (1), . . . , DC (i)
affected change. Since DC (1), . . . , DC (i) tell models moved, step
models Pi+1 classes change. models Pi+1
lowered DC (i + 1) classes. Since change altered relative initial positions,
modify relative positions step i. preorder step + 1 therefore
before.
Lemma 20 Reinforcement revision generates revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ]
total preorder generates sequence total preorder
DC (i) bounded 2i 1.
Proof. proved DC (1) 1, preorder modified make
so.
Since DC (i + 1) bounded DC (1) + . . . + DC (i) + + 1, assuming claim
DC (1), . . . , DC (i) leads DC (i + 1) (21 1) + + (2i 1) + + 1,
DC (i + 1) (20 + 21 + + 2i ) 20 1 + + 1 = 21 + + 2i , 2i+1 1.
Theorem 8 Establishing existence total preorder generating revision sequence
[K0 , P1 , . . . , Pn , Kn ] reinforcement revision p2 , coNP n constant.
Proof. lemma, revision sequence generated preorder
generated preorder DC (i) 0 2i 1. result,
problem solved guessing reinforcement mover V = [V (1), . . . , V (n)]
sequence, V (i) 0 2i 1, since implies existence
total preorder C generating sequence DC (i) = V (i) indexes.
n constant guessing replaced disjunction. Checking whether V
reinforcement mover amount check whether, I, j, holds |= Ki
implies MV (I, i, j) = 0 |= Kj MV (I, i, j) > 0 otherwise. Calculating MV (I, i, j)
done polynomial time since checks requires form j >
|= Pl . Therefore, verification coNP, whole problem p2
guessing V .
Theorem 9 Checking existence preorder generating reinforcement revision sequence [K0 , P1 , K1 , . . . , Pn , Kn ] coNP-complete, n constant.
326

fiRevision History

Proof. Membership proved previous theorem. Hardness proved
problem propositional unsatisfiability. Given formula F , corresponding revision
sequence [K0 , P1 , K1 ] K0 = F , P1 = b K1 = b, b
fresh variables occurring F . sequence, K0 = F consistent P1 = b.
Therefore, K1 = b equivalent conjunction (a F ) b. F
unsatisfiable case. Otherwise, model F extended assigning false
b false model K0 P1 model K1 . proves sequence
generated preorder F unsatisfiable.

References
Alchourron, C., & Makinson, D. (1982). logic theory change: Contraction functions
associated revision functions. Theoria, 48 (1), 1437.
Areces, C., & Becher, V. (2001). Iterable AGM functions. Rott, H., & Williams, M.A. (Eds.), Frontiers Belief Revision, Applied Logic Series, pp. 261277. Kluwer
Academic Publisher.
Baltag, A., Gierasimczuk, N., & Smets, S. (2011). Belief revision truth-tracking process.
Proceedings Thirteenth Conference Theoretical Aspects Rationality
Knowledge (TARK 2011), pp. 187190.
Benferhat, S., Kaci, S., Le Berre, D., & Williams, M.-A. (2004). Weakening conflicting
information iterated revision knowledge integration. Artificial Intelligence,
153, 339371.
Booth, R., & Meyer, T. (2006). Admissible restrained revision. Journal Artificial
Intelligence Research, 26, 127151.
Booth, R., & Nittka, A. (2008). Reconstructing agents epistemic state observations
beliefs non-beliefs. Journal Logic Computation, 18, 755782.
Boutilier, C. (1996). Iterated revision minimal change conditional beliefs. Journal
Philosophical Logic, 23, 263305.
Carson, R., & Louviere, J. (2011). common nomenclature stated preference elicitation
approaches. Environmental Resource Economics, 49 (4), 539559.
Darwiche, A., & Pearl, J. (1997). logic iterated belief revision. Artificial Intelligence Journal, 89 (12), 129.
Delgrande, J., Dubois, D., & Lang, J. (2006). Iterated revision prioritized merging.
Proceedings, Tenth International Conference Principles Knowledge Representation Reasoning, KR-2006, pp. 210220.
Eiter, T., & Gottlob, G. (1996). complexity nested counterfactuals iterated
knowledge base revisions. Journal Computer System Sciences, 53 (3), 497512.
Fagin, R., Ullman, J. D., & Vardi, M. Y. (1983). semantics updates databases.
Proceedings Second ACM SIGACT SIGMOD Symposium Principles
Database Systems (PODS83), pp. 352365.
327

fiLiberatore

Ferme, E., & Hansson, S. (2011). AGM 25 years - Twenty-five years research belief
change. Journal Philosophical Logic, 40 (2), 295331.
Gardenfors, P. (1988). Knowledge Flux: Modeling Dynamics Epistemic States.
Bradford Books, MIT Press, Cambridge, MA.
Hild, M., & Spohn, W. (2008). measurement ranks laws iterated contraction. Artificial Intelligence, 172 (10), 11951218.
Jin, Y., & Thielscher, M. (2007). Iterated belief revision, revised. Artificial Intelligence
Journal, 171 (1), 118.
Katsuno, H., & Mendelzon, A. O. (1991). Propositional knowledge base revision minimal change. Artificial Intelligence, 52, 263294.
Konieczny, S., & Pino Perez, R. (2000). framework iterated revision. Journal
Applied Non-Classical Logics, 10, 339367.
Lehmann, D., & Magidor, M. (1992). conditional knowledge base entail?
Artificial Intelligence, 55, 160.
Liberatore, P. (2014a). Belief revision examples.
(CoRR), abs/1409.5340.

Computing Research Repository

Liberatore, P. (2014b). Belief revision reliability assessment. Manuscript.
Nayak, A. (1994). Iterated belief change based epistemic entrenchment. Erkenntnis, 41,
353390.
Nebel, B. (1992). Syntax-Based Approaches Belief Revision, pp. 5288. Cambridge
University Press.
Nittka, A., & Booth, R. (2008). method reasoning agents beliefs
observations. Logic foundation game decision theory, Vol. 3 Texts
logic games, pp. 153182.
Papini, O. (2001). Iterated revision operations stemming history agents
observations. Frontiers belief revision, Vol. 22 Applied Logic Series, pp. 279
301. Springer.
Peppas, P. (2008). Belief revision, pp. 317359. Elsevier.
Rott, H. (2009). Shifting priorities: Simple representations twenty-seven iterated theory change operators. Towards Mathematical Philosophy, Vol. 28, pp. 269296.
Springer.
Sandholm, T., & Conen, W. (2010). Preference elicitation combinatorial auctions. US
Patent 7,742,971.
See, K., Morrison, W., Rothman, N., & Soll, J. (2011). detrimental effects power
confidence, advice taking, accuracy. Organizational Behavior Human
Decision Processes, 116 (2), 272285.
Spohn, W. (1988). Ordinal conditional functions: dynamic theory epistemic states.
Causation Decision, Belief Change, Statistics, pp. 105134. Kluwer Academics.
Suzumura, K. (1976). Remarks theory collective choice. Economica, New Series,
43, 381390.
328

fiRevision History

SyncML (2002). SyncML sync protocol, version 1.1.
Tversky, A., & Kahneman, D. (1983). Extensional versus intuitive reasoning: conjunction fallacy probability judgment. Psychological review, 90 (4), 293315.
Wang, H., Zhang, J., & Johnson, T. R. (2000). Human belief revision order effect.
Proceedings 22th Annual Conference Cognitive Science Society.
Williams, M. (1994). Transmutations knowledge systems. Proceedings Fourth International Conference Principles Knowledge Representation Reasoning
(KR94), pp. 619629.
Winslett, M. (1988). Reasoning actions using possible models approach. Proceedings Seventh National Conference Artificial Intelligence (AAAI88), pp.
8993.
Zhang, D. (2004). Properties iterated multiple belief revision. Proceedings Seventh International Conference Logic Programming Nonmonotonic Reasoning
(LPNMR 2004), pp. 314325.

329


