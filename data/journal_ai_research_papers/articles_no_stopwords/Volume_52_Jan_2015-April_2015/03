journal artificial intelligence

submitted published

distributed evaluation nonmonotonic multi context systems
minh dao tran
thomas eiter
michael fink
thomas krennwallner

dao kr tuwien ac
eiter kr tuwien ac
fink kr tuwien ac
tkren kr tuwien ac

institute fur informationssysteme tu wien
favoritenstrasse vienna austria

abstract
multi context systems mcss formalism systems consisting knowledge bases
possibly heterogeneous non monotonic interlinked via bridge rules global
system semantics emerges local semantics knowledge bases called contexts
equilibrium mcss related formalisms inherently targeted distributed settings truly distributed evaluation available address shortcoming present suite includes basic dmcs advanced version dmcsopt exploits topology optimizations streaming
dmcs streaming computes equilibria packages bounded size behave quite differently several respects experienced thorough experimental evaluation
system prototype experimental derive guideline choosing appropriate
running mode particular situations determined parameter settings

introduction
last decade increasing interest systems comprise information
multiple knowledge bases includes wide range application fields data integration multi agent systems argumentation many others picture concrete real world
application may consider metis velikova et al industrial prototype system facilitating timely human decision making maritime control application human operators
need support determine whether ship entering port might hide identity illegal activities might high risk environmental hazard access risks metis relies
number heterogeneous external information sources commercial ship database ihs
fairplay ship tracking websites news items history pollution events ship may
involved
rise word wide web distributed systems propelled development
date several ai formalisms available host multiple possibly distributed knowledge
bases compound system well known formalisms distributed sat solving hirayama
yokoo distributed constraint satisfaction faltings yokoo yokoo hirayama
distributed ontologies different flavors homola mweb analyti antoniou
damasio different approaches multi context systems giunchiglia serafini
ghidini giunchiglia brewka roelofsen serafini brewka eiter bikakis
www ihs com products maritime information
marinetraffic com myship com
c

ai access foundation rights reserved

fidao ran e iter f ink k rennwallner

figure pinpointing joker
antoniou rooted mccarthys work among focus heterogeneous nonmonotonic multi context systems mcss brewka eiter
generalization previous proposals mcss powerful formalism specify systems
knowledge bases may different formats reasoning powers ranging simple
query answering relational database reasoning description logic knowledge bases see
baader et al well nonmonotonic formalisms default logic reiter
answer set programs gelfond lifschitz allow heterogeneous knowledge bases
deal impedance mismatch mcss abstract knowledge bases plain mathematical structures top special bridge rules interlink knowledge bases bridge rule
adds formula knowledge base depending certain beliefs knowledge bases hence
semantics knowledge base associated bridge rules forms context depends
contexts possibly cyclic manner mcss equilibrium semantics
terms global states every context adopts abstract local model called belief set
conformant local adopted contexts addition obeys
bridge rules following simple example paraphrase ghidini giunchiglias
magic box illustrates power idea
example suppose computer game players batman robin chased player joker
partially occluded area shown figure robin wounded cannot read distance
objects neither batman robin tell jokers exact position box batman
assure columns robin tell row however
exchange partial knowledge pinpoint joker row column
model batman robin contexts whose local knowledge bases include information jokers position exchanged bridge rules row x
row x batman informally imports robins knowledge context row
positions full encoding given example equilibrium emerging mcs discloses
jokers position batman robin


fid istributed e valuation n onmonotonic ulti context ystems

although mcss related formalisms inherently target distributed systems truly distributed computing equilibria mcss available brewka eiter
encoded equilibria hex programs eiter ianni schindlauer tompits
evaluated dlvhex solver however elegantly offers full heterogeneity fully centralized needs technical assumptions roelofsen serafini cimatti
proposed earlier check satisfiability homogeneous monotonic mcs
centralized control accesses contexts parallel hence truly distributed bikakis
antoniou instead gave distributed defeasible multi context systems
however latter homogeneous possibly nonmonotonic contexts particular type
semantics serves query answering model building
lack distributed evaluating mcss local context handlers due
several obstacles
abstract view local semantics belief sets limits global level
interference knowledge bases evaluation process context
towards real life applications certain levels information hiding security required
e g information exchange knowledge bases companies selected
information transferred contexts via well defined interfaces prevents context
getting insight neighbors optimization instance learn conflicts e
joint beliefs leading contradiction across contexts
mcs system topology e structure context linkage might unknown context
disables decomposing system efficient modular evaluation
bridge rules might fuel cyclic information flow group contexts even
context easy evaluate e g knowledge bases acyclic logic programs global cycles
require nontrivial care
article address obstacles present towards efficient distributed evaluation mcss main contributions suite generic dmcs dmcsopt
dmcs streaming work truly distributed implementation system prototype
detail contributions follows
optimization techniques
first basic dmcs aims fully distributed setting deal obstacles
generic way contexts exchange belief sets call history e access path
traversing bridge rules information global level belief states formed
tuples belief sets context bridge rules must respect belief sets neighbors
computing belief sets local solver knowledge base cycles detected
call history context gets request finds call history break cycle
guessing technique used checks return path
localizing contexts knowledge system information exchange dmcs
fairly easily adapt context changes additions deletions time faces
scalability issues enhance performance optimized version dmcsopt disclose
meta level information contexts viz topology context dependencies exploited
decomposing mcs sub mcss blocks linked block tree ii interface contexts optimizing data transfer blocks breaks cycles


fidao ran e iter f ink k rennwallner

advance ii significantly reduces duplicate local evaluation yields remarkable performance gain
still dmcs dmcsopt compute equilibria mcs escape
scalability memory issues multiple local belief sets lead combinatorial explosion
global level thus consider computing equilibria streaming mode end contexts pass
belief sets one shot parents gradually small packages memory blowup
thus avoided moreover contexts continue earlier wait answers
neighbors seems user friendly equilibria gradually appear rather
possibly long time one may quit computation seeing sufficiently
many e equilibria
implementation experiments
implemented system prototype assess effects optimization techniques set benchmarking system conducted comprehensive experiments
mcss topologies interlinking confirm expectation optimization techniques general nutshell decomposition technique clearly improves
performance non streaming mode ii streaming worthwhile may still answers
non streaming times iii streaming choosing package size important
iv system topology important optimization techniques drastic improvements
specific topologies v sometimes techniques yield gain incur overhead
work provide truly distributed evaluating mcss
distributed versions non monotonic knowledge base formalisms
e g distributed answer set programs underlying principles techniques might
exploited related contexts furthermore may provide basis evaluation extensions generalizations mcss non ground mcss fink ghionna weinzierl
managed mcss brewka eiter fink weinzierl supported mcs tasharrofi ternovska
reactive mcss goncalves knorr leite brewka ellmauthaler puhrer
organization
remainder article organized follows next section provides preliminaries
multi context systems section introduces basic distributed dmcs section develops optimized dmcsopt section presents streaming dmcs streaming experimental prototype implementation reported
section section consider related works section summarize address
open issues increase readability proofs moved appendix

preliminaries
sections briefly introduces preliminaries needed rest article
multi context systems
first present formalization heterogeneous nonmonotonic multi context systems mcss
proposed brewka eiter described brewka eiter fink


fid istributed e valuation n onmonotonic ulti context ystems

serves base work idea behind mcss allow different logics used
different contexts model information flow among contexts via bridge rules notion
logic defined follows
definition cf brewka eiter logic l kbl bsl accl composed
following components
kbl set well formed knowledge bases l consists set
elements called formulas
bsl set possible belief sets bsl set elements called beliefs

accl kbl bsl function describing semantics logic assigning
element kbl set acceptable sets beliefs
notion logic generic abstracts formation agents beliefs bare
minimum structure formulas knowledge base belief sets dismissed
viewed naked elements likewise particular inference mechanism associated
knowledge base logical properties imposed belief sets term belief
reflects statements held agent might epistemic basis without going
detail assignment acceptable beliefs sets knowledge base intuitively
set beliefs agent willing adopt given knowledge base captures logics
e g nonmonotonic logics multiple even acceptable belief sets possible
abstract model allows us capture range different logics knowledge representation
reasoning including classical logic modal logics epistemic logics spatial logics description
logics etc nonmonotonic logics default logic reiter answer set programs
gelfond lifschitz different varieties settings comparison formalisms
given brewka et al example classical propositional predicate logic may
modeled follows
kb set well formed sentences signature
bs set deductively closed sets sentences e cn cn
denotes deductive closure
acc kb singleton containing deductive closure kb e acc kb cn kb
example nonmonotonic logics disjunctive logic programs answer set semantics gelfond lifschitz modeled
kb set logic programs signature
bs set consistent sets literals
acc kb set kb answer sets kb according gelfond lifschitz
refer setting used repeatedly sequel answer set programming
asp note answer sets knowledge base kb amount particular valued kb
intuitively positive literal p answer set p known true negative
common exclude inconsistent answer sets admitted gelfond lifschitz



fidao ran e iter f ink k rennwallner

literal p p known false known means literal present
fact derivable rules neither p p truth value p unknown
mcs modeling possible worlds scenarios view via answer sets generated
answer set solver however asp implementations capture inference truth
query respectively answer sets forms belief set formation
bridge rules logics bridge rules introduced provide uniform way interlinking
heterogeneous information sources follows
definition cf brewka eiter let l l ln multi set logics lk bridge rule l k n form
c p cj pj cj pj cm pm



ci n pi element belief set lci
ii kb kbk holds kb kbk
informally bridge rules refer bodies contexts identified ci thus add
information contexts knowledge base depending believed disbelieved
contexts contrast giunchiglias multi context systems single global set
bridge rules context knows bridge rules
means connecting contexts available mcss formally defined
definition brewka eiter multi context system mcs c cn consists
collection contexts ci li kb br li kbi bsi acci logic kb
kbi knowledge base br set li bridge rules l ln
example contd scenario example formalized mcs c c
contexts l l instances answer set programming


col x see col x
kb f f
r
col x see col x


row x row x
br
row x covered row x see row x row x


row x see row x
kb f f
r
row x see row x


col x col x
br

col x covered col x see col x col x

f row row row col col col
f see col see col
f see row


fid istributed e valuation n onmonotonic ulti context ystems


r





joker row x
joker col x

row x joker
row x joker
col x joker



col x joker




row x row x
row x row x
col x col x
col x col x










x variables used schematic rules range rows resp columns e
intuitively c formalizes batmans knowledge scene c robin
knowledge bases kb kb facts f represent box size f f state
batman robin see viz joker columns respectively
row next two rules simply map sensed locations respective facts informally rules
r make guess row column joker concluded box first
two rules may lead multiple belief sets importantly batman adjusts knowledge base
depending beliefs communicated robin bridge rules br vice versa bridge rules br
convenience introduce following notation conventions mcs
c
cn denote bi set
beliefs occur belief sets context ci e
bi sbsi let bm ni bi simply b understood without loss
generality assume distinct contexts ci cj bi bj bridge
atom form bi appearing bridge rule holds bi bi
semantics multi context systems
semantics mcs defined terms special belief states sequences
sn si element bsi intuitively si belief set
knowledge base kb however bridge rules must respected end kb augmented
conclusions bridge rules applicable precisely bridge rule r form
applicable pi sci j pk
sck j k denote
head r head r app r set bridge rules r r applicable

definition brewka eiter belief state sn mcs c
cn equilibrium si acci kb head r r app br n
equilibrium thus belief state contains context acceptable belief set
given belief sets contexts
example contd mcs example single equilibrium
f f f f f f f joker row row
row col col col equilibrium indeed reflects intuition
scenario example batman robin together infer location joker
single one cannot accomplish task without communication
example let c c c c mcs li asp logics signatures
b c e f g suppose
kb br b c


fidao ran e iter f ink k rennwallner

kb br b g
kb c c br c e f
kb f g br
one check b c g equilibrium
computation equilibria given mcs realized declarative implementation hex programs eiter et al evaluated dlvhex system
idea translate mcs hex program disjunctive facts guessing
truth values beliefs ii hex rules capturing bridge rules iii constraints external
atoms capturing acceptability functions details concrete implementation
refer reader mcs ie system bogl eiter fink schuller
article pursue sophisticated e design implement distributed
compute equilibria mcss evaluation centralized component
controls communication contexts context independently runs instance
communicates exchange beliefs well detect break
cycles novel contributions described next sections

basic dmcs
section introduces first basic truly distributed evaluating equilibria
mcs takes general setting input context minimal
knowledge whole system words knows interface direct neighbors parents child contexts topological information metadata
system setting concentrate distributeness section shifts focus towards
optimization techniques metadata provided
taking local stance consider context ck compute parts potential equilibria
system contain coherent information contexts reachable ck
basic notions
start basic concepts import closure formally captures reachability
definition import closure let c cn mcs import neighborhood
context ck k n set
k ci ci pi b r r br k
furthermore import closure ic k ck smallest set k ii

equivalently define import closure constructively ic k k

ic k k ic j k iic j k



j ic

j

k

example consider example
import closure c ic see figure
www kr tuwien ac systems dlvhex



fid istributed e valuation n onmonotonic ulti context ystems

c

c

ic


c

c

c

c

c

c
import neighborhood c

b import closure c

figure import neighborhood import closure














sj



sn











ti



tj



tn











ti



sj tj



figure joining partial belief states
import closure define partial equilibria
definition
partial belief states equilibria let c cn mcs let
sn

bsi sequence sn si bsi n
partial belief state pbs partial equilibrium pe w r ck k n
ic k implies si acci kb head r r app br ic k implies
si n
note ic k essentially defines subsystem connected bridge rules use
pes instead equilibria keep original mcs intact
combining partial belief states sn tn define
join partial belief state u un

si ti si ti
ui
n
ti ti si
see figure note void couples si ti bsi different naturally
join two sets partial belief states
example consider two sets partial belief states
b f g b f g
c e f g c e f g c e f g


fidao ran e iter f ink k rennwallner

join given



b c e f g b c e f g
b c e f g




basic
given mcs starting context ck aim finding pes w r ck distributed
way end design dmcs whose instances run independently node
context communicate exchanging sets partial belief states
provides method distributed model building dmcs applied
mcs provided appropriate solvers respective context logics available main
feature dmcs compute projected partial equilibria e pes projected relevant
part beliefs showing ck import closure exploited specific tasks
e g local query answering consistency checking computing projected pes
information communicated contexts minimized keeping communication cost low
sequel present basic version abstracting low level implementation issues overall mcs structure assumed unknown context nodes idea
follows starting context ck visit import closure expanding import neighborhood
context ci depth first search dfs leaf context reached cycle detected finding current context set hist already visited contexts leaf context simply
computes local belief sets transforms partial belief states returns
parent invoking context figure case cycle figure c context ci detects
cycle must break guessing belief sets export interface ii transforming
guesses partial belief states iii returning invoking context
intermediate context ci produces partial belief states joined e consistently
combined partial belief states neighbors enable ci returns local belief sets
joined neighbors figure b
computing projected pes offers parameter v called relevant interface
must fulfill conditions w r import closure next discuss
notation given partial belief state set v b beliefs denote v restriction
v e partial belief state v sn v si v si v si
v set partial belief states let v v next
definition recursive import interface mcs c cn k n
call v k pi ci pi b r r brk import interface context ck v k

iic k v recursive import interface context ck
correct relevant interface v two extremal cases v v k v vb b
dmcs basically checks consistency import closure ck computing pes
projected interface beliefs computes pes w r ck providing fixed
interface v specific knowledge query variables infrastructure information
exploited keep computations focused relevant projections partial belief states
projections partial belief states cached every context recomputation
recombination belief states local belief sets kept minimum
assume context ck background process daemon unix terminology
waits incoming requests form v hist upon starts computation outlined


fid istributed e valuation n onmonotonic ulti context ystems

si



ss sj

lsolve

v hist





v hist

sj





ci

c

v

h






cj

c
lsolve
leaf context

b intermediate context

v
ci

hi

st










cj





c
ct
c cycle breaking

figure basic distributed casewise
process serves purpose keeping cache c k persistent
write ci dmcs v hist specify send v hist process context ci wait
return message
uses following primitives
function lsolve augments knowledge base kb current context
heads bridge rules br applicable w r partial belief state computes
local belief sets function acc combines local belief set returns
resulting set partial belief states
function guess v ck guesses possible truth assignments relevant interface w r
ck e bk v
dmcs proceeds following way

check cache appropriate partial belief state
order relate beliefs bk v vector sets variables v prefixed context ids
simplicity kept v set without assumptions



fidao ran e iter f ink k rennwallner

dmcs v hist ck lk kb k br k
input v relevant interface hist visited contexts
data c k static cache
output set accumulated partial belief states


c k empty return c k


b
c



k hist
guess v ck
else
hist hist k
foreach k
ti
ci dmcs v hist

e

foreach lsolve

f

c k v

cyclic guess local beliefs w r v
acyclic collect neighbor beliefs add local ones

return v
lsolve ck lk kb k br k
input partial belief state sn
output set locally acceptable partial belief states
acck kb k head r r app brk
return sk tk sk sn tk

b check cycle
c cycle detected guess partial belief states relevant interface context
running dmcs
cycle detected import neighbor contexts needed request partial belief
states neighbors join
e compute local belief states given partial belief states collected neighbors
f cache current projected partial belief state
next examples illustrate evaluation runs dmcs finding partial equilibria
different mcs start acyclic run
example reconsider example suppose user invokes c dmcs v
v b c f g trigger evaluation process next c forwards requests c
c call c called first time c calculates e belief sets
assembles set partial belief states
f g f g


fid istributed e valuation n onmonotonic ulti context ystems

v

c
c
v

v

c

c
c

c
v

figure cyclic topology
caching v f c returns v one contexts c c whose request arrived
first second call c simply returns v context cache
c c next call lsolve e two times resp
example
b f g b f g
c e f g c e f g c e f g
thus
v

b f g b f g

v

c f g c f g c f g

c computing
v v b c f g b c f g b c f g
calls lsolve e thrice compute final
v b c f g b c f g b c f g
next example illustrates run dmcs cyclic topology
example let c c c mcs li asp logic
kb br b
kb br b c
kb br c
figure shows cyclic topology suppose user sends request c calling c dmcs v v b c step c calls c dmcs v
context c issues call c dmcs v thus c invokes c dmcs v
point instance dmcs c detects cycle b guesses partial belief states



fidao ran e iter f ink k rennwallner

v following dotted lines figure set v return value
request c joins initial empty belief state gives us
calls lsolve e resulting
c c c
next step c return v back c proceed c
set belief states
b c b c b c
sent back c v notice belief state b c inconsistent
c eventually eliminated c evaluates v lsolve
next c join v yields v use call lsolve
union gives us
b c b c
sent back user final
given mcs c cn context ck recursive import interface ck
e v k relevant interface safe lower bound correctness
follows let ck v k
theorem correctness dmcs partial equilibrium every v v k holds
ck dmcs v iff partial equilibrium w r ck v
compute partial equilibria ck use vb holds vb preserves
belief sets returned step e projection step f takes effect
corollary partial equilibrium w r ck iff ck dmcs vb
assumption single root context c e ic
n dmcs computes equilibria
corollary mcs single root context c equilibrium iff
c dmcs vb
analysis yields following upper bound computational complexity
communication activity
proposition let c cn mcs run dmcs context ck
interface v holds
total number calls lsolve exponentially bound n v e n v
number messages exchanged contexts ci ic k bounded
e k e k cj ic k r bri cj pj b r


fid istributed e valuation n onmonotonic ulti context ystems

discussion
dmcs naturally proceeds forward import direction context ck thus starting
computes partial equilibria cover ck contexts import closure
contexts ignored fact unknown contexts closure partial
equilibria may exist ck import closure whole mcs could equilibrium
e g p contexts access beliefs ck closure get inconsistent p
isolated context subsystem inconsistent
enhancements dmcs may deal situations p context neighborhood
may include importing supporting contexts intuitively ci imports cj ci
must register cj carefully adapting dmcs solve p however p remains
needs knowledge global system topology
suitable assumption manager exists every context ci system
reach ask whether isolated inconsistent context subsystem exists confirms
ci dmcs instance simply returns eliminating partial equilibria
improve decentralization information hiding weaken manager assumption
introducing routers instead asking context ci queries assigned router r collects
topology information needed ci looks cache information exchange ci
r flexible depending system setting could contain contexts import information
ci isolated inconsistent contexts
advantage topological information ci recognize cyclic acyclic
branches upfront invocation order neighborhood optimized starting
acyclic branches entering cyclic subsystems caching mechanism adapted
acyclic branches intermediate complete cache meaningful even across
different evaluation sessions
setting safe assuming v k v needed resp ck
import closure join contexts e contexts least two parents access
path information context could calculate v fly adjust
mcs traversal particular tree ring shaped restrict v locally shared
interface ck import neighbors e restricting v bridge atoms br k
presence join contexts v must made big enough e g path information furthermore
join contexts may eliminated virtually splitting orthogonal parts contexts
accessed way scalability many contexts achieved
next present optimization techniques topological information system

topology optimization dmcsopt
basic version dmcs uses metadata apart minimal information
context must know interface every neighboring context scalability
issues tracked following
contexts unaware context dependencies system beyond neighbors thus
treat neighbors equally specifically cyclic dependencies remain undetected context
seeing invocation chain requests context chain furthermore context
ci know whether neighbor cj already requested another neighbor cj
would passed ci hence ci makes possibly superfluous request cj


fidao ran e iter f ink k rennwallner

context ci returns local combined neighbors case
multiple size become huge system size number neighbors
increases fact one main performance obstacles
section address optimizations increase scalability distributed mcs evaluation resorting methods graph theory aim decomposing pruning improved
cycle breaking dependencies mcss focusing describe decomposition method
biconnected components inter context dependencies break cycles
prune acyclic parts ahead create acyclic query plan address foster partial view
system often sufficient satisfactory answer compromise partial
information performance thus define set variables import dependency
system project context bare minimum remain meaningful
manner omit needless information circumvent excessive model combinations
proceed follows introducing running example superficial explanation
optimization present details techniques section section introduces
notion query plans used section describe dmcsopt
intertwines decomposition pruning variable projection performance gains mcs evaluation
running scenario
first present scenario example running example section
example scientists group group four scientists alice bob charlie demi meets
conference closing arrange travel back home options going train car
slower use train bring along food alice group
leader finally decides information gets bob charlie
alice prefers go car would object bob charlie want go train
charlie daughter fiona mind option fiona sick wants
fastest transport get home demi got married husband eddie wants back
soon even sooner would come soon demi tries yield husbands plea
charlie charge buying provisions go train might choose salad
peanuts notably alice allergic nuts options beverages coke juice bob
modest agrees choice charlie demi transport dislikes coke charlie
demi want bother others personal matters communicate
preferences sufficient reaching agreement

example scenario example encoded mcs c c
alice bob etc lexicographical order li asp logics knowledge bases kbi
bridge rules bri follows




car train
train train train
c kb
br

nuts
nuts peanuts
similar scenarios already investigated realm multi agent systems social answer set programming see e g buccafurri caminiti aim introducing semantics scenarios
example serves plain mcs showcase



fid istributed e valuation n onmonotonic ulti context ystems

b
















b







b




b diamond ring block tree

diamond ring

figure topologies decomposition scientist group example

c kb

c kb

c kb
c kb
c kb



car car car
car train br train train train


coke


car train








train urgent
urgent sick


br
salad peanuts train
train train





coke juice train




car train br train sooner




sooner soon br soon train


sick fit br

context dependencies shown fig three equilibria namely
train train train urgent juice salad train
soon sooner sick
train train train juice salad train soon sooner fit
car car car car fit
example consider mcs c c context dependencies drawn figure user queries c cares local belief sets c
evaluation process c discard local belief sets c c answering call
c c however c calls c c invoked context must carry local belief sets
c answers c reason belief sets c cause inconsistent joins c
partial belief states returned c c c c contribute directly
computing local belief sets c note belief sets c c play role determining
applicability bridge rules c


fidao ran e iter f ink k rennwallner

query

query
c
c

c
c

c

c

c



c
original topology

c

c


b triangle

c



c

c











c





c



c

c

c transitive reduction

figure topology example two stacked zig zag diamonds
take sub system including c c c assuming c bridge rules atoms
p p body c atoms p c depends c
c c depends c see fig b straightforward evaluate mcs asks
c belief sets c c c depends c would need another query
c c evaluate c w r belief sets c shows evident redundancy c
need compute belief sets twice simple caching strategies could mellow second belief
state building c nonetheless c asks c context transmit belief states back
thus consuming network resources
moreover c asks pes c receive set pes covers belief sets
c addition contexts c import closure excessive c view
needs know p p however c needs belief states c
c reply c c reports belief sets consistent w r c c cant
align belief sets received c received c realizing c reports
belief sets c call c must made
decomposition nonmonotonic mcs
observations present optimization strategy pursues two orthogonal
goals prune dependencies mcs cut superfluous transmissions belief state building
joining belief states ii minimize content transmissions start defining
topology mcs
definition topology topology mcs c cn directed graph gm
v e v c cn resp v n j e iff rule br
atom j p body
first optimization technique made three graph operations get coarse view
topology splitting biconnected components form tree representation mcs
edge removal techniques yield acyclic structures


fid istributed e valuation n onmonotonic ulti context ystems

sequel use standard terminology graph theory see bondy murty
graphs directed default may view undirected graphs directed graphs
edges u v v u undirected edge u v
graph g edges e g denote g maximal subgraph g
edges suppose v v g nonempty subgraph g v e g
vertex set v edge set e u v e g u v v g subgraph induced
v denoted g v induced subgraph g v v denoted g v g
deleting vertices v together incident edges v v write g v g v
two vertices u v g said connected directed path u v
g e sequence vertices u v v vn v vi vi e g
n path trivial n undirected graph g connectedness equivalence
relation v g thus partition v g nonempty subsets v v vw
two vertices u v g connected iff belong set vi
subgraphs g v g v g vw called components g w e g exactly
one component g connected otherwise g disconnected
directed graph g strongly connected vertices u v v g path u v
vice versa exists strongly connected components g subgraphs g v g vm
unique partition graph g pairwise disjoint induced subgraphs e vi vj
strongly connected
furthermore directed graph g weakly connected turning edges undirected edges
yields connected graph vertex c weakly connected graph g cut vertex g c
disconnected biconnected graph weakly connected graph without cut vertices
block graph g maximal
biconnected
subgraph g given set blocks b


union blocks b defined b bb b union two graphs g v e
g v e defined g g v v e e
let g b c e denote undirected bipartite graph called block tree graph g

b set blocks g
ii c set cut vertices g
iii b c e b b c c iff c v b
note g forest graph g rooted tree g weakly connected
example consider graph figure one check cut vertex
two blocks viz subgraphs induced
next example shows block tree scenario example
example topology gm example shown figure two cut vertices
namely thus block tree gm figure b contains blocks b b b
subgraphs gm induced respectively
topological sort directed graph linear ordering vertices every
directed edge u v vertex u vertex v u comes v ordering


fidao ran e iter f ink k rennwallner

pruning acyclic topologies triangle presented figure b exploit minimal
graph representation avoid unnecessary calls contexts namely transitive reduction
graph gm recall aho garey ullman graph g transitive
reduction directed graph g whenever following two conditions satisfied
directed path vertex u vertex v g iff directed path u v
g
ii graph fewer edges g satisfying condition
note g unique g acyclic instance graph figure c unique transitive
reduction one figure
ear decomposition another essential part optimization strategy break cycles removing edges end use ear decompositions cyclic graphs block may multiple
cycles necessarily strongly connected thus first decompose blocks strongly
connected components tarjans tarjan task one gets byproduct topological sort directed acyclic graph formed strongly connected components
yield sequence nodes r rs used entry points component next
step break cycles
ear decomposition strongly connected graph g rooted node r sequence p
hp pm subgraphs g
g p pm
ii p simple cycle e repeated edges vertices r v p
iii pi non trivial path without cycles whose endpoint ti p pi
nodes
let cb g p set edges containing r p last edge ti pi
vertex belonging edge root node r simple cycle p
example take example strongly connected graph g figure ear decomposition g rooted node p hp p p p
vp ep

vp ep

vp ep

vp ep

last edges pi dashed form set cb g p
removing edges acyclic topology figure b
intuitively ear decomposition used remove cycles original system
resulting acyclic topology evaluating mcss designed conveniently
trade edge removed context c despite leaf
context guess values variables ct following example shows application
optimization techniques running scenario
example contd block b gm acyclic transitive reduction gives b
edges b cyclic hb ear decomposition rooted
removing cb b hb obtain b edges b acyclic already
reduced fig b shows final dotted edges removed


fid istributed e valuation n onmonotonic ulti context ystems





















strongly connected component

b acyclic topology

figure ear decomposition example
graph theoretic concepts introduced particular transitive reduction acyclic blocks
ear decomposition cyclic blocks used implement first optimization mcs
evaluation outlined intuitively block apply ear decomposition get rid cycles trade guessing use transitive reduction minimize communication
given transitive reduction b acyclic block b b total order v b one
evaluate respective contexts reverse order total order computing pes
context ck first context simply computes local belief sets whichrepresented
set partial belief states constitutes initial set partial belief states iteration
step ti computed joining ti local belief sets si considered context ci
given final tk tk v k set pes ck restricted contexts v b
refined recursive import next define second part optimization strategy
handles minimization information needed transmission two neighboring contexts
ci cj purpose refine notion recursive import interface definition
context w r particular neighbor given sub graph
definition given mcs c cn subgraph g gm
edge j


e g recursive import interface ci cj w r g v j g v g j b
g j contains nodes g reachable j
example contd mcs example v train train peanuts
car coke car train sooner sick focus block b refined recursive
import interface v b obtained removing bridge atoms contexts

blocks b b yielding train train peanuts car coke car train
combine optimization techniques outlined intuitively
optimizetree takes input block tree parent cut vertex cp root cut vertex cr traverses dfs manner calls optimizeblock every block call collected
note v k defined definition



fidao ran e iter f ink k rennwallner

optimizetree b c e cp cr
input block tree cp identifiesslevel cr identifies
level cp

output f removed edges b v labels b f
b f v
cp cr
b b b cr v b
else
b b b b cp e



b

initialize siblings b return values

foreach sibling block b b
sibling blocks b parent cp
e optimizeblock b cp
prune block

c c c b c e c cp
children cut vertices b
b b e f f e
foreach edge j b dos
setup interface pruned b

v j v j b cc v cp bc e v cp bt
foreach child cut vertex c c
accumulate children
f v optimizetree b c cp
f f f v v v
return f v

set f removed edges blocks processed final optimizetree
pair f v v labeling remaining edges optimizeblock takes graph g calls
cyclebreaker cyclic g decomposes g strongly connected components creates
ear decomposition p component gc breaks cycles removing edges cb gc p
resulting acyclic subgraph g optimizeblock computes transitive reduction g
returns edges removed g optimizetree continues computing labeling v remaining edges building recursive import interface keeping relevant
interface beliefs child cut vertices removed edges example appendix b illustrates
detailed run mcs example
formally following property holds
proposition given mcs context ck k cut vertex topology gm
optimizetree gm k k returns pair f v
subgraph g gm f induced ic k acyclic
ii block b g j e b holds v j v j b
regarding computational cost computation obtain
proposition given mcs context ck k cut vertex topology gm
optimizetree gm k k runs polynomial quadratic time size gm resp gm



fid istributed e valuation n onmonotonic ulti context ystems

optimizeblock g graph r context id

c


f
g cyclic
f cyclebreaker g r

ear decomposition strongly connected components

let g transitive reduction g f
return e g e g

removed edges g

query plan
given topology mcs need represent stripped version contains
minimal dependencies contexts interface beliefs need transferred contexts representation query plan used execution processing
syntactically query plans following form
definition query plan query plan mcs w r context ck labeled subgraph
gm induced ic k e e gm edge labels v e g
mcs context ck every query plan suitable evaluating however
following query plan fact effective
definition effective query plan given mcs context ck effective query plan
respect ck k v g e g f v g subgraph gm induced
ic k f v optimizetree gm k k
next use k mcs evaluation tacitly assume query plans effective
evaluation query plans
present dmcsopt dmcs exploits optimization
techniques idea dmcsopt follows start context ck traverse
given query plan k expanding outgoing edges k context dfs
leaf context ci reached context simply computes local belief sets transforms belief
sets partial belief states returns parent ci j p bridge rules
bodies context cj query plan means broke cycle removing last
edge cj possible truth assignments import interface cj considered
context ci set partial belief states amounts join e
consistent combination local belief sets neighbors final
obtained ck keep recomputation recombination belief states local belief sets
minimum partial belief states cached every context
shows distributed dmcsopt instance context ck
input id c predecessor context process awaits proceeds
acyclic query plan r w r context cr e starting context system
maintains cache k cache ck kept persistent
ci dmcsopt c send id c dmcsopt context ci wait
guess v guess possible truth assignments interface beliefs v


fidao ran e iter f ink k rennwallner

dmcsopt c context id predecessor ck lk kb k br k
data r query plan w r starting context cr label v cache k cache
output set accumulated partial belief states


b
c



e

cache k empty
cache k
else

foreach k e r ci dmcsopt k

neighbor belief sets

k k
e r ti
guess v c k
guess removed dependencies r

foreach lsolve
get local beliefs w r
cache k
c k e r e ck non root
return v c k
else
return

lsolve given partial belief state augment kbk heads
bridge rules brk applicable w r kb k compute local belief sets acc kb k
merge return resulting set partial belief states
steps explained follows
b check cache empty get neighbor contexts query plan request
partial belief states neighbors join
c p bridge rules brk k
e r neighbor delivered
belief sets ci step b e ti call guess interface v c k
join intuitively happens edges removed
cycles
compute local belief states given partial belief states collected neighbors
e return locally computed belief states project variables v c k nonroot contexts point mask parts belief states needed
contexts lying different block gm
theorem shows dmcsopt sound complete
theorem let ck context mcs let k query plan definition let
b p v k j k j e k
v
ck dmcsopt k exists partial equilibrium w r ck
vb
ii partial equilibrium w r ck exists ck dmcsopt k
vb


fid istributed e valuation n onmonotonic ulti context ystems

streaming equilibria dmcs streaming
dmcsopt shows substantial improvements dmcs however sizes
local knowledge bases context interfaces increase suffers bottlenecks
stems way exchanged contexts suppose context c
accesses several neighbors c cm acyclic information flow ci n
ni pes ci computes dmcs resp dmcsopt local must join pes
neighbors may lead n n nm many pes input
local solver may take considerable time exhaust memory even
local model computation starts
note however instead neighbor would transfer portion pes
computation c avoid memory blowup moreover strategy helps reduce
inactive running time c waiting neighbors return pes c already start
local computing neighbors producing
general indispensable trade computation time due recomputations less
memory eventually partial equilibria c shall computed idea underlying
streaming evaluation method distributed mcs particularly useful user interested
obtaining instead answers system realistic scenarios
current evaluation manage output resource constraints
practice equilibrium
section turn idea concrete streaming dmcs streaming
computing partial equilibria main features briefly summarized follows
fully distributed e instances components run every context
communicate thus cooperating level peers
invoked context ci streams e computes k partial equilibria
ci time particular setting k allows consistency checking mcs
sub system
issuing follow invocations one may compute next k partial equilibria context c
equilibria exist e evaluation scheme complete
local buffers used storing exchanging local partial belief states
contexts avoiding space explosion
section mainly studies streaming aspect simplify presentation omit interface contexts principles presented applied
dmcs dmcsopt adapting interface pruning topology preprocessing
time furthermore assume work acyclic mcss treatment cyclic cases easily
achieved adding guessing code solving component dmcs dmcsopt
best knowledge similar streaming neither developed
particular case computing equilibria mcs generally computing
distributed knowledge bases thus obtained interest setting
heterogeneous mcs relevant general model computation reasoning
distributed potentially homogeneous knowledge bases e g distributed sat instances


fidao ran e iter f ink k rennwallner

request k k

k belief states

handler

ci

cj

solver

joiner




output

cjm

figure dmcs streaming architecture
handler k k package range ci
output k k output k k
solver k k joiner k k k
call solver

basic streaming procedure
basic idea follows pair neighboring contexts communicate multiple rounds
request effect receive k pes communication window k pes
ranges k th pe k th k k pe parent context ci requests child
context cj pair k k receive time later package k pes receiving
indicates cj fewer k parallelized version discussed section
important subroutines dmcs streaming take care receiving
requests parents receiving joining answers neighbors local solving returning
parents reflected four components handler solver output joiner
active non leaf contexts see figure architectural overview
components except handler shown communicate message queues
joiner j queues store partial equilibria j neighbors solver one queue hold joined
pes joiner output queue carry solver bound space usage
queue limit number entries queue full resp empty enqueuing writer
resp dequeuing reader automatically blocked furthermore getting element removes
queue makes room pes queue later property frees us
synchronization technicalities
solver joiner work use following primitives
lsolve works lsolve dmcs dmcsopt addition may return one
answer time may able tell whether left moreover require
lsolve returned fixed order regardless called property
key guarantee correctness
get first k send neighbor c c request first k partial equilibria e k k k return store respective queues
return true otherwise return false neighbor inconsistent


fid istributed e valuation n onmonotonic ulti context ystems

solver ci
data input queue q maximal number k


b

count
count k
ci leaf
else call joiner pop q
count k

c

count k
pick next model lsolve

push output q
count count
else break
refresh push output q

get next k request next k equilibria neighbor cc cc sends back store queue q return true otherwise return false neighbor already
exhaustively returned pes previous request note subroutine needs keep
track range already asked neighbor maintaining set counters
counter w r neighbor cc initialized increased time get next k called
value request cc asks tth package k e range
given k k k k get first k called counters
range reset
refresh reset counters flags joiner starting states e g first join true
counters
process context ci triggered message parent contains
range k k arrives handler latter notifies solver compute k output
collect range k k return parent furthermore sets package
size joiner k k k case ci needs query neighbors cf
solver receives notification handler first prepares input local solver
ci leaf context input gets empty set assigned step otherwise solver triggers
joiner step b input neighbors fed input lsolve used step c
compute k send output queue
joiner activated intermediate contexts discussed gathers partial equilibria neighbors fixed ordering stores joined consistent input local buffer
communicates one input time solver upon request fixed joining order guaranteed asking first package k neighbors beginning step
subsequent rounds begin finding first neighbor cc return
step e reset query ask first packs k neighbors cc cc
neighbors run step f joining process ends sends solver
note procedure guarantees missed lead consider combinations inputs solver multiple times cache helps mitigate


fidao ran e iter f ink k rennwallner

joiner ci
data queue q queue qj c cj buffer partial equilibria buf
flag first join
true
buf empty
pop buf push solver q
return



e

f

first join
get first j k false
push solver q
return
else first join false
else

get next k false j
j
get first k
else j
push solver q
return
q sj qj add sj buf
c

c

c

c

c

c

c

figure binary tree mcs

recomputation unlimited buffering quickly exceeds memory limits recomputation
inevitable part trading computation time less memory
output component simply reads queue receives reaches k
cf upon reading throws away first k keeps ones
k onwards eventually fewer k returned solver output
return parent
example let c cn mcs given integer n
contexts let integer let contexts asp logics


fid istributed e valuation n onmonotonic ulti context ystems

output ci
data input queue q starting model k end model k
buf count
count k
pick output q
count k
else count count
count k
wait output q
count k
else
count count
add buf
buf empty
send parent
else
send content buf parent

context ci li kbi bri

kbi

aji



aji

ti j bri




ti aj
j
ti aj



let ci
kbi aji aji j bri



intuitively binary tree shaped mcs depth size alphabet
context figure shows mcs n contexts depth internal contexts
knowledge bases bridge rules leaf contexts directed
edges dependencies bridge rules system equilibria sn
si aki ti k
compute one pe dmcs dmcsopt one needs transfer packages
pes context parent context ci computes subsets
intermediate context receives children whose join leads inputs
lsolve invokes lsolve often returns parent
wait
hand dmcs streaming needs transfer single pe pair
connected contexts significant saving indeed consider e g e
c c c querying c package size k first causes query forwarded
c pair k k c leaf context invokes local solver eventually gets five
different however returns one pe c say note projected
among atoms c accessed c happens c assume


fidao ran e iter f ink k rennwallner

return c root context c two pes neighbors consistently
combined feeding local solver c obtains five returns
one say
following proposition shows correctness
proposition let c cn mcs n let k integer
input k ci handler ci output returns k different partial equilibria respect ci
fact k least k partial equilibria exist
parallelized streaming
one might expect strategy ignoring k collecting next k
likely effective reason context uses one solver
general serve one parent e requests different ranges size k
parent context requests refresh state solver joiner
redo scratch unavoidable unless context satisfies specific property one
parent call
way address parallelization idea serve parent suite
handler joiner solver output basic interaction units still shown
figure notable difference component runs individual thread
significant change solver control joiner waits queue get input
local solving process joiner independently queries neighbors combines pes
neighbors puts solver queue
effect waste recomputation time unused however parallelization limits practice dmcsopt may run memory unlimited parallel
instances streaming exceed number threads processes operating
system support happens contexts reach others many alternative paths
stacked diamond topology number threads exponential number connected contexts prohibits scaling large system sizes however real world applications number
paths might still ok
compromise two extremes bounded parallel idea create
fixed size pool multiple threads components share among contexts incoming requests cannot served resources available continues basic
streaming procedure realization remains future work

experimental evaluation
implemented c system prototype called dmcs
available online space reasons omit detailed presentation refer work
bairakdar dao tran eiter fink krennwallner b dao tran ch briefly
main components global architecture command line frontend dmcs user
access system ii demons daemon represent nodes contain set contexts
iii manager dmcsm containing meta information mcs topology interfaces
http www kr tuwien ac systems dmcs
https github com distributedmcs dmcs



fid istributed e valuation n onmonotonic ulti context ystems

c

c

c

c

c

c
c

c

c

c

c

c

c

c

c

c
c

c
c

c

c

c

c

binary tree

c

c

b diamond

c zig zag z

c

ring r

figure topologies testing dmcs
helper dmcsgen generating configurations optimized components contexts implemented groups threads communicate concurrent message queues
system two main command line tools viz running algorihms test case generation respectively allows switch different modes simply changing
command line arguments
turn experimental evaluation dmcs aspects next describe
benchmarks set go runs interpretation
benchmark setup
idea analyze strong weak points respect different parameters
namely system topology system size local theory e knowledge base size interface size
specifically considered mcss topologies figure including
binary tree binary trees grow balanced e every level except last one complete
topology edge needs removed form optimal topology every
intermediate node cut vertex import interface query plan drastically reduced
leading extreme performance improvement
stack diamond diamond consists four nodes connecting c c figure b stack diamonds combines multiple diamonds row e stacking diamonds
tower contexts similar binary tree edge removed constructing
query plan w r topology every context connecting two diamonds cut vertex
import interface query plan refined every diamond avoids
significantly repetition partial pes evaluation
stack zig zag diamond z zig zag diamond diamond connection
two middle contexts depicted contexts c c figure c stack zigzag diamonds built topology interesting removing two edges per
block query plan turns linear topology
ring r ring figure query plan removes connection context cn c
carries interface way back c topology requires guess

fidao ran e iter f ink k rennwallner

















figure local theory structure
ing checking dmcs thus quite unpredictable
performs better general
quantitative parameters represented tuple p n b r
n system size number contexts
local theory size number ground atoms local theory
b number local atoms used bridge atoms contexts
words number interface atoms
r maximal number bridge rules generator generates bridge rule iterating
r chance hence average r bridge rules generated allow
bridge bodies size
test configuration formulated x n b r x z r represents topology n b r integers representing quantitative e size related parameters
would run several instances one configuration final formulation test instance
xi n b r index test instance
inside context local theories structured follows context ci ground atoms
indicated ai ai rules form ai j ai k k j j odd
otherwise randomly choose k j j probability possibility
case k rule exist example context local theory size
illustrated dependency graph figure bold arrows stand fixed
rules dashed arrows stands rules decided randomization corresponding local
theory figure

















setting local context answer sets
furthermore one obtain deterministic contexts one answer set disallowing
cycles structure local theories
experiments
conducted experiments host system core intel r xeon r cpu ghz processor gb ram running ubuntu linux furthermore used dlv build ben sep
gcc back end asp solver
ran comprehensive set benchmarks setup described section
parameter space p n b r huge singled initial probing phase following
values experiments


fid istributed e valuation n onmonotonic ulti context ystems



dmcs
dmcsopt




















z


r










z


r




figure dmcs vs dmcsopt non streaming mode
system size n depending topology



n
n

z
r

n
n

b r fixed respectively
combination topology x parameters p n b r denoted x n b r x n b r
used figures parameter setting tested five instances instance
measured total running time total number returned partial equilibria dmcs
dmcsopt non streaming streaming mode latter mode dmcs streaming
asked k answers k parameter influences size packages
transferred contexts k partial equilibria transferred one message
streaming mode asking one pe may require multiple rounds get answers
interest see fast first answers arrive compared answers thus compared
running time tasks k k
observations interpretations
figures summarize experiments run times seconds timeout
seconds data several interesting properties observed organize
analysis along following aspects comparing dmcs dmcsopt comparing
streaming non streaming mode effect package size role topologies
behavior deterministic contexts
dmcs vs dmcsopt
figure shows running time dmcs dmcsopt computing partial equilibria e
non streaming mode five instances respective parameter settings clearly dmcsopt
outperforms dmcs explained fact computing answers dmcs
produces partial equilibria dmcsopt one pe returned dmcsopt


fidao ran e iter f ink k rennwallner




dmcs st
dmcsopt st
dmcs
dmcsopt

dmcs st
dmcsopt st
dmcs
dmcsopt

































b




dmcs st
dmcsopt st
dmcs
dmcsopt

dmcs st
dmcsopt st
dmcs
dmcsopt















z

z

z

z

z

r

c z

r

r

r

r

r

figure dmcs vs dmcsopt streaming mode
obtained projecting many partial equilibria returned dmcs imported interface
furthermore intermediate transferred one message makes difference
terms number communications dmcs must spend
time processing possibly exponentially input hence unsurprisingly consistently
slower dmcsopt
however observation streaming mode different figure shows running time
dmcs dmcsopt streaming mode compute first respectively unique partial
equilibria respectively z r
first view dmcsopt consistently slower dmcs one might question correctness
however surprise pe returned dmcsopt correspond several pes returned dmcs hence batch first k unique answers dmcs
corresponds smaller number unique answers dmcsopt
therefore comparing dmcs dmcsopt streaming mode measuring runtime
compute first k answers fair thus took time finished first
round answers denoted dmcs st dmcsopt st figure setting
observed following
majority cases dmcsopt finishes first round faster dmcs however
instances way around shows effect query plan


fid istributed e valuation n onmonotonic ulti context ystems

however cases dmcs wins explained follows first streaming
mode transfer packages k partial equilibria time therefore effect reducing
amount total work done apply non streaming mode furthermore
every context compute k pes project output interface returning
according strategy context ci returns k partial equilibria non streaming
mode k partial equilibria streaming another context cj might happen k much
smaller k hence provide enough input cj compute k pes therefore cj
issue requests ci asking packages k pes e g k k k k
etc costs dmcsopt time even compute first batch pes root context
another compute k unique partial equilibria returning parent
context however strategy risks compute even local k unique partial
equilibria found
overall much difference running time dmcsopt slower dmcs except
instance r figure however comes different reason cyclic topology
guess check effects play much important role choosing dmcs
dmcsopt see section
treaming vs n streaming dmcs
compare streaming non streaming dmcs resp dmcsopt
figure shows dmcs dmcsopt compute
first resp pes small systems local knowledge bases b large systems local theories c excluding ring behaves abnormally due guess check
one see
dmcs streaming mode definitely worth pursuing since dmcs non streaming
mode times many cases see figure streaming mode still could
answers reasonable time
dmcsopt situation bit different streaming loses non streaming
small instances due recomputation streaming mode pays transferring
chunks partial equilibria contexts furthermore duplications answers
one moves larger systems local knowledge bases streaming mode starts gaining
back however win recomputation still significantly takes time cases
summing system small enough one try non streaming mode
avoids recomputation duplication pes different rounds computation large
systems streaming rescue us timing even pay recomputation still
helps cases needed e g brave query answering membership
query pe
e ffects package ize treaming ode
considerations raise question optimal number pes transferred
return messages contexts analyze experimental streaming
mode package sizes give hints
figure shows average time compute pe dmcsopt streaming mode
respect three package sizes one see transferring single pe get first answer


fidao ran e iter f ink k rennwallner



non streaming
streaming
streaming























z



r




dmcs


non streaming
streaming
streaming























z



r




b dmcsopt small systems local theories


non streaming
streaming
streaming























z



r




c dmcsopt large systems local theories

figure non streaming vs streaming dmcs dmcsopt
acceptable cases particular guessing needed moving size small
package size sometimes better one save communication time sending
package partial equilibria vs sending ten times package single pe setting
small package sizes effective communication big factor


fid istributed e valuation n onmonotonic ulti context ystems



streaming
streaming
streaming



















z


r




figure average time dmcsopt one partial equilibrium streaming mode varying
package size
happens real applications contexts located physically distributed nodes
cases computing partial equilibria faster computing pe consecutive times
furthermore package size safe cases guessing applied e g
r cases large enough package size might help cover correct
guess general guarantee coverage thoroughly solve
one needs apply conflict learning whole mcs evaluation
interesting see package size dmcsopt usually times
reason many duplications dmcsopt stuck local search branch
promises fewer partial equilibria lose time without finding
unique answers eventually time
good package size p specific setting topology system size local theory size
one may run system training set apply binary search p
e ffect opology
quick glance plots figures reveals pattern especially
optimizations perform better tree zigzag diamond depending dmcs
dmcsopt worst ring
system topology plays important role aspects affect performance
number connections ii structure block trees cut vertices
iii acyclicity vs cyclicity
regarding topology introduces number connections system size tree
fewer connections diamond zigzag reduces communication
local solving time fewer requests made performance dmcs topologies
proves observation one follows argument ring must offer best performance
however actually case due aspect iii shortly analyze
concerning ii tree ultimately optimized every intermediate node cut vertex
hence applying query plan dmcsopt strip beliefs pes sent
child contexts parent context words local beliefs context ci needed
transferred back parents drastically decreases amount information


fidao ran e iter f ink k rennwallner


dmcs
dmcsopt










r






r






r






figure dmcs vs dmcsopt streaming mode package size ring
communicated importantly number calls lsolve due special property
dmcsopt performs extremely well tree topology scales hundreds contexts
comparing diamond zigzag number cut vertices however zigzag
converted linear topology optimal query plan cf figure c therefore
processed much faster diamond figure dmcsopt scales zigzag contexts
average time compute one answer still better one diamond contexts
regarding iii ring cyclic topology topologies acyclic hence
must guess check context topology making
right guess important even important reducing communication calls local
solvers running dmcs dmcsopt topology figure follow
pattern absolutely depends specific instance whether sequential guessing
luckily arrives therefore frequently see dmcs outperforms dmcsopt
streaming mode cases guessing root context detecting cycle
effective guessing parent root context according optimal query plan
observations one come best strategy evaluate different types
topologies dealing mcss arbitrary topologies looks natural decompose
parts familiar topologies efficient strategies known combine
strategies overall evaluation method studying beyond scope work
interesting issue future
b ehavior eterministic c ontexts
considered mcss consisting possibly non deterministic contexts
e one acceptable belief set per knowledge base intriguing see
behave contexts exactly one accepted belief set per knowledge base
might underlying logic genuinely deterministic accepted belief set
clear e g closure classical logic among multiple candidates particular belief set chosen
implementations typically first best solution computed e g sat solving asp
observed
non cyclic topologies performance difference dmcs dmcsopt
smaller interface used dmcsopt reduce number intermediate pes
transferred contexts one partial equilibrium computed every context


fid istributed e valuation n onmonotonic ulti context ystems



dmcs
dmcsopt
mcs ie




















z


r










z


r




figure dmcs vs dmcsopt streaming mode package size ring
cyclic topology ring guessing plays main role hence depends individual
instance whether dmcs dmcsopt wins case non deterministic contexts cf
section
non streaming mode much faster streaming dmcs dmcsopt
reasonable request partial equilibria redundant
c omparison mcs ie p p dr
systems close dmcs mcs ie bogl et al p p dr bikakis antoniou hassapis former plugin dlvhex system originally developed compute
explanations inconsistency multi context systems includes mode computing
equilibria mcs however mcs ie implemented centralized figure
presents run time dmcs dmcsopt comparison mcs ie computing partial equilibria respective configurations shows mcs ie outperforms dmcs since
inherits powerful decomposition technique dlvhex however decomposition
topological information dmcsopt turns efficient localizes interface beliefs communicate blocks contexts specific mcs
exploited general decomposition technique dlvhex
p p dr supports distributed query answering multi context systems defeasible
logic details see section present comparison dmcs p p dr
converted benchmark p p drs style converting local knowledge bases
bridge rules defeasible local meta rules added fixed trust order contexts
queried root context atom appearing one answers dmcs streaming
package size turned p p dr found answers around seconds
regardless tested instance behavior explained follows answers
query atom p p dr first evaluates local theory determine truth
value query terminates otherwise consults neighbors get evidence
reasoning local knowledge base structure converted p p drs defeasible
theories allows local decision system works local theory root context
http www kr tuwien ac systems mcsie tut



fidao ran e iter f ink k rennwallner

every test case thus almost constant execution time even asking neighbours
necessary p p dr general may much faster dmcs query answering process
inherently deterministic low complexity logic turn formalism less expressive
detailed study issue remains future work
ummary
summing analysis experimental shows clear winner among
dmcs vs dmcsopt different running modes streaming vs non streaming
different package size different topologies distill guideline choose
setup fits specific instances practice including issues open investigation
briefly stated follows
choose dmcsopt dmcs non streaming mode except cyclic topologies
streaming mode choose appropriate package size carefully e g binary search
training instances
decompose random topologies parts whose topologies effective strategies evaluate
study combine strategies systems

related work
section resume discussion related work starting multi context systems
provide details work roelofsen et al bikakis et al consider
work move related formalisms sat csp asp
roelofsen et al described evaluation monotone mcs classical theories
sat solvers contexts parallel used co inductive fixpoint strategy check mcs
satisfiability centralized process iteratively combines sat solvers apart
truly distributed extension nonmonotonic mcs non obvious furthermore
caching technique used
serafini borgida tamilin serafini tamilin developed distributed
tableaux reasoning distributed ontologies regarded multi context
systems special bridge rules serve decide whether system consistent provided cyclic context dependencies exist technical terms distributed tbox
acyclic drago system serafini tamilin implements owl ontologies compared work tailored specific class multi context systems resp
knowledge bases without nonmonotonic negation cyclic dependencies challenging furthermore targets query answering rather model building sense dual

related work regards distributed evaluation system p p dr bikakis
et al developed distributed query evaluation multi context system
framework specifically propositional defeasible logic framework contexts built defeasible rules exchange literals via bridge rules trust order
contexts supplied knowledge base context terminology single
accepted belief set contains literals concluded global system semantics given
terms unique three valued assignment literals determined whether literal l provably logical conclusion system whether remains


fid istributed e valuation n onmonotonic ulti context ystems

open apart tailored particular logic preference mechanisms evaluating interlinked contexts applying model building straightforward particular
produces unique belief sets dealing nondeterminism multiple equilibria possible
work computing equilibria distributed multi context systems clearly related
work solving constraint satisfaction csp sat solving distributed setting
yokoo hirayama survey distributed csp solving usually developed setting node agent holds exactly one variable constraints
binary communication done via messages every node holds constraints
involved adopted later works gao sun zhang generalized
yokoo hirayama relation topology optimization techniques section
biconnected components used baget tognetti decompose csp
decomposition used localize computation single solution components undirected constraint graphs along lines directed dependencies
allows us use query plan mcs evaluation
predominant solution methods csp backtracking bessiere bouyakhf
mechqrane wahbi took step backtracking dynamic total ordering agents guided nogoods however allows cyclic dependency
contexts hirayama yokoo presented suite solving distributed sat dissat random assignment improvement flips reduce conflicts
however geared towards finding single model extension streaming
multiple straightforward works distributed csp sat
similar
finally distributed sat csp solving concerns monotonic systems removal clauses
resp constraints preserves satisfiability mcss evaluation concerns nonmonotonic systems
even contexts monotonic e g clause sets makes efficient evaluation difficult
important structural properties search space cannot exploited
adjiman chatalic goasdoue rousset simon present framework peer peer
inference systems local theories propositional clause sets share atoms special consequence finding available pursue dual model building
applying needs straightforward furthermore dealing non monotonic
systems peer peer systems adjiman et al monotonic
moving asp pontelli son nguyens asp prolog shares mcs idea
integrating several knowledge bases called modules possibly different semantics however restricted module semantics asp prolog least herbrand model
asp prolog pursues query answering instead model building
streaming answer set streaming hex programs generalize asp
external information access given eiter fink ianni krennwallner schuller
despite similarities dmcs streaming rather different monolithic programs syntactically decomposed modules answer sets computed modular
fashion fully distributed combines partial lower components input
upper components straightforwardly moreover may use exponential space components


fidao ran e iter f ink k rennwallner

conclusion
considered distributed evaluation multi context systems mcss introduced
brewka eiter general formalism interlink possibly nonmonotonic heterogeneous knowledge bases presented suite generic compute equilibria e semantics mcs fully distributed manner local solvers knowledge
bases contexts contains basic dmcs advanced version dmcsopt
uses topology optimizations streaming variant dmcs streaming computing
partial equilibria gradually believe underlying principles techniques might
exploited related contexts particular distributed evaluation non monotonic
knowledge base formalisms
implemented prototype system available open source
top implementation conducted comprehensive experiments compare performance gave insight analysis points advantages
disadvantages well time memory trade different situations
depending parameters system topology local interface theory size number
equilibria desired user user choose setting mode
fits need best finding partial equilibria mcs extensive treatment given
dao tran
work open issues several issues remain investigation one improvement experimental ring topology strongly suggest
incorporate conflict learning proved valuable asp sat solving dmcs
dmcsopt expect cyclic topologies benefit better guided guessing process another issue concerns semantics variants mcss former grounded
equilibria considered dao tran akin answer sets logic programs
applicable mcss satisfy certain algebraic conditions characterized answer
sets adapted loop formula lee lifschitz dealing supported
equilibria tasharrofi ternovska however open
regarding mcs variants managed mcss brewka et al generalize bridge rules derive
operations commands management function applied knowledge bases seems
possible generalize setting efficient realization straightforward another generalization mcs concerns dynamic data areas sensor networks social
networks smart city applications data may change even continuously arrive nodes
motivates reactive stream processing mcss goncalves et al brewka et al
last least allowing contexts evolve via interation users changes environment valuable extention extending settings interesting
challenging
finally extending work query answering mcss user poses query
context receives derived partial equilibria another natural issue
need building whole equilibria better performance may achieved

acknowledgments
supported austrian science fund fwf projects p
p


fid istributed e valuation n onmonotonic ulti context ystems

c

c

c

c

c

c

c

figure introducing guess context
thank reviewers pointing corrections constructive suggestions
helped improve presentation work thank antonis bikakis providing us
p p dr system experimental comparison

appendix proofs
proof theorem
prove theorem first prove following lemmas latter aims simplifying
proof cyclic case notion converting cyclic mcss acyclic ones
lemma context ck partial belief state mcs c cn
app brk app brk v vb v v k
proof r app brk ci pi b r pi sci
cj pj b r pj
scj need pi sci vci pj
scj vcj indeed
v vb vcj vbj scj vcj scj therefore pj
scj pj
scj vcj
assume pi
sci vci fact pi sci follows pi
vci hence

pi
v k contradiction fact pi occurs bridge rule body
therefore r app brk v

next lemma following notions convert cyclic mcss acyclic
ones corresponding equilibria intuition illustrated figure
examples introduce additional context ck take care guessing every cycle
breaker ck bridge rules ck parents modified point ck
formally realize idea starting function ren renames part bridge rules
definition let ck context mcs let v interface running dmcs
renaming function ren defined follows

atom ren k v

ag


bk v
otherwise


context index c ren c k v

c
c

c n
otherwise

bridge atom ci pi ren ci pi k v ren ci k v ren pi k v



fidao ran e iter f ink k rennwallner

bridge body b c p cj pj
ren b k v ren ci pi k v ci pi b
bridge rule r head r b r
ren r k v head r ren b r k v
set bridge rules br ren br k v ren r k v r br
context ci li kb br ren ci k v li kb ren bri k v
example let us slightly modify mcs c c c example follows
kb e e br e b
kb br b c
kb br c
applying function ren contexts c c following bridge rules wrt interface v b c e
ren br v eg b
ren br v c ag
two contexts ci cj former called parent latter respect interface
v denoted parent ci cj v iff exists bridge rule r br exists c p
b r p bj v
set contexts cc cc cc mcs called cycle w r interface v iff

parent cc c v
parent cci cci v


holds one pick arbitrary context set cycle breaker given mcs
several ways choose finite set contexts cycle breakers dmcs
step practically establishes cycle breakers order elements k
iterated next definition interested particular set cycle breakers
definition given mcs c cn let cb rm cc ccj set cyclebreakers application dmcs starting context cr conversion
equal acyclic cb rm interface v done follows

ren ci v ci cb rm


let ci li kb br
ci
otherwise
let ci li kb br ck cbm ren ci k v

br ag bi v

let ci li kb br


br



br

ci cb rm
otherwise

cj cb rm introduce cj lj kb j br j br j kb j ag ag
bj v c cn cc ccj
order composing function ren different parameters k matter



fid istributed e valuation n onmonotonic ulti context ystems

example contd let mcs example cb rm c conversion definition gives c c c c
g
kb e e br
e b

ag

e eg

kb br
b c
g
kb br
c

kb eg eg

ag ag br

lemma let mcs conversion acyclic mcs definition
equilibria correspondence
proof sketch let r r runs dmcs respectively due
selection cb rm construct r r order visiting contexts
except r revisits cycle breaker ck cb rm counterpart r visits ck
corresponding locations
r calls guess v ck step c
r calls lsolve step e since ck leaf context
construction local knowledge base ck gives us exactly guess ck furthermore
guesses passed parent contexts ck later unified additional
bridge rules k ag introduced br
k therefore belief combinations step done
ck executed input runs r r correspondence equilibria
hence follows

proof theorem thanks lemma need prove theorem acyclic
case automatically get cyclic case
start showing soundness dmcs let ck dmcs v v v k
partial equilibrium acyclic w r ck v
proceed structural induction topology
base case ck leaf k brk k
hist means
executed hence e lsolve runs exactly get set belief
states lsolve tk tk acck kbk
v towards contradiction assume partial equilibrium sn
w r ck v k get ic k k thus partial belief
state tk tk acck kbk partial equilibrium w r ck
contradiction
induction step assume context ck import neighborhood k im
ci dmcs v hist k


im cim dmcs v hist k


fidao ran e iter f ink k rennwallner

induction hypothesis every ij ij exists partial equilibrium ij
w r cij ij v ij
let ck dmcs v hist need every partial equilibrium w r ck v indeed since k step executed let
im
combining partial belief states
scalling dmcs ci cim furthermore


step e v lsolve eventually v
since every dmcs ci cim returns partial equilibria w r cij projected v
every partial equilibrium w r cij projected v acyclic visited
contexts k thus lemma get every app brk gives us
applicable bridge rules r regardless tj j
k hence lsolve
returns partial belief states component projected v except kth component
every preserves applicability rules lemma get every v
exists partial equilibrium w r ck v
give proof completeness dmcs structural induction topology
acyclic let sn partial equilibrium w r ck let v
ck dmcs v
base case ck leaf context executing ck dmcs v step ignored
step e called input lsolve gives us belief sets ck
equilibrium w r ck hence v returned ck dmcs v
induction case suppose import neighborhood context ck k im let
restriction every context cij k denoted ij

ic ij



ij
sn

otherwise
informally speaking restriction keeps belief sets contexts reachable cij
sets non reachable contexts induction hypothesis ij v computed
cij dmcs v ij k v computed ck dmcs v
indeed considering acyclic holds ij v returned call
cij dmcs v k k plays role calls cij neighbors means
step contains si sim sij appears position ij
since partial equilibrium w r ck sk acck kbk head r
r app brk furthermore choosing v v k lemma tells us applicability
bridge rules preserved projection belief sets v gives us sk lsolve
step e hence v returned ck dmcs v

proof proposition
context ck let number calls local solver denoted c k number
calculated computation step bounded maximal number
combined partial belief sets neighbors formally speaking
c k iin k vbi k v n v


fid istributed e valuation n onmonotonic ulti context ystems

hence whole mcs upper bound calls lsolve run dmcs
c kn c k n n v
context ck mcs c cn set e k contains dependencies
contexts ci ic k visit j e k exactly twice dfs traversal
calling cj dmcs v hist ci retrieving v cj ci furthermore
caching technique step prevents recomputation already visited nodes thus prevents
recommunication subtree visited node claim hence follows

proof proposition
item trivial see since cyclebreaker applied prove item ii let us look
two cases edge removed original topology step
removed cyclebreaker causes certain nodes graph cannot reach
via however interface ct provides already attached v j via v cp bt
removed transitive reduction change reachability
nodes therefore interface ct provides already included v j b


argument gives us property ii
proof proposition
first estimate complexity compute v j loop


v j v j b
v cp bc
v cp bt
cc

e

one hand refined recursive import v j b defined definition
v j b v



b

b j

b j contains nodes reachable j
hand since sets possible beliefs different contexts disjoint


cc

v cp bc



v cp bt v cp scc bc e bt

e


since recursive import interface node k defined v k iic k v
expression compute v j end combination set intersection union projection
implementation sets hash set look takes operators
implemented linear time therefore v j computed linear time total number
beliefs contexts system
given gm block tree graph gm constructed linear time vats moura
ear decomposition step c done linear time valdes tarjan lawler


fidao ran e iter f ink k rennwallner

transitive reduction step computed quadratic time respect number
edges block
optimizetree gm k k iterates blocks assume blocks b
bm bi contains ni edges n
ni total number edges original
graph let ti time process block bi bound total processing time
assessed follows



x
x
x


ti
ni
ni n






therefore ignore loop optimizetree done quadratic time size
original input e size gm

proof theorem
prove need proposition claim partial equilibria returned dmcs
dmcsopt correspondence first need following supportive notion

definition let ck context mcs let k query plan definition
block b k block interface b whose root vertex cb
vb p v j j e b bcb
let ci context b self recursive import interface ci b

v b bi
v b
e k

proposition let ck context mcs
let k query plan definition
ck belongs block b k let v bk vb
dmcsopt k called cc c k e k c k exists
partial equilibrium ck dmcs v v c k b c k e k
v k b c k
ii ck dmcs v exists dmcsopt k called cc
v c k b c k e k v k b c k
detailed proof proposition given next section give proof theorem
proof theorem let ck dmcsopt k dmcsopt proposi


tion
sc k exists ck dmcs v v k b
choose v bk vb note v k v v collects bridge atoms blocks
might contain blocks reachable k theorem exists partial equilibrium
v thus
v v k b
v k b
v k b v
b v k b
vb
v
ii let partial equilibrium ms theorem exists ck dmcs v
v choose v bk vb v k v proposition ii
c k exists ck dmcsopt k v k b
vb



fid istributed e valuation n onmonotonic ulti context ystems

proof proposition
support proof proposition need following lemmas
lemma assume context ck import neighborhood k im k ij removed original topology optimizeblock b cb


dmcsopt k ci





ci dmcs vb



im

dmcsopt k cim

im

cim dmcs vb

every partial equilibrium ij exists ij v k ij b
let im ssim exists

v k ij b
vinput vinput j

proof prove induction number neighbors k
base case k claim trivially holds
induction case k u u
u u exists u u u u vinput need
u exists u vinput
assume opposite holds e exists u u u
u u u u vinput v k b
u void
means exists context ct reachable ck two different ways one via
via one ut st ut st
ut st
ii ut st
case cannot happen ct reachable ck hence vinput bt
v k bt
concerning case ii ut vinput st v k hence exists
ut ut vinput
st v k means vinput bt v k bt


however definition recursive import interface v k ix b v k
b k b b ix contains nodes b reachable ix follows v k

v k ij j reaches share projection bt hence vinput
bt v k bt
reach contradiction therefore lemma proved


lemma join operator following properties given arbitrary belief states u
size ii iii u u
properties hold sets belief states
proof first two properties trivial prove prove associativity
let r u w u consider joins left right
position n ri wi determined locally comparing si ti ui


fidao ran e iter f ink k rennwallner

si




ti


n

ui

n




n

n

n





n



n

n

n



n

n

n

si ti


n
n
n
n
n
n

n


n
n

ti ui

n
n

n

n
n
n
n

n

n

ui si

n

n
n
n

n
n
n

n
n
n

ri

ui
ti
ti
void
si
si
void
si
void
si
void
void
void

wi

ui
ti
ti
void
si
si
void
si
void
si
void
void
void

table possible cases joining position

reach inconsistency process terminates void returned otherwise conclude value
ri wi continue next position final join returned position n processed
without inconsistency
possible combination si ti wi shown table one see
outcome ri wi therefore end r w
void concludes join operator commutative

lemma let ci cj two contexts block executing
optimizetree directed path ci cj suppose dmcsopt k ci
j dmcsopt k cj j

proof use cache dmcsopt change disregarded e
assume without loss generality cache k dmcsopt indeed cache k filled
computation empty e ck accessed first time
never changed dmcsopt returns cache k e value computation
empty cache k
assumption lemma proven taking path ci cp cph
cj connects ci cj arguing index h holds p p
j indeed induction path
base case h statement holds ph j j j j identity
lemma
induction case consider h suppose already established induction hypothesis
p p j


fid istributed e valuation n onmonotonic ulti context ystems

definition p dmcsopt holds p lsolve
statements b c form p holds edge p p
e commutative associative lemma ii iii induction
hypothesis get
p p j j p
form j
next lsolve change value component interpretation
defined j lsolve j lsolve means p lsolve lsolve
j p j proves statement holds
eventually get p p j j

lemma following
lemma assume import neighborhood context ck k im
ij dmcsopt k cij j furthermore suppose edge k ij removed
optimization process j ci neighbor ck exists path
k ij optimized topology ij words input
dmcsopt ck affected removal k ij
proof since cij ci direct children ck follows belong block
therefore lemma ij

proof proposition proceed structural induction block tree mcs first
consider case topology single block b case interface passed
dmcs v vb
base case ck leaf compare call dmcsopt k ck ck dmcs v
v v k b bk returns local belief sets ck projected v returns plain local belief sets claim follows v v k b bk
induction case assume import neighborhood context ck k im


dmcsopt k ci





ci dmcs vb



im

dmcsopt k cim

im

cim dmcs vb

every partial equilibrium ij exists ij v k ij b
two cases first edge k ij removed optimization procedure
lemma correspondence input dmcsopt dmcs ck
hand assume edge k ij removed optimization process
removal transitive reduction ear decomposition former case lemma
shows input ck affected removal edge latter case removal
one three possibilities illustrated figure assuming context c gets called
last edge simple cycle p
abuse notation write lsolve





lsolve



fidao ran e iter f ink k rennwallner























figure possible cycle breakings
ii last edge path p
iii last edge path p
cases iii differ case ii sense cycle recognized dmcs
case ii cycle detected along corresponding path
consider k ij removed situations similar cases iii dmcsopt
issue guess step c v k ij includes v cb bij vb bij
hand dmcs recognize cycle cij issue guess vb bij step c
therefore guess fed equally ck
k ij removed situations similar case ii guesses ck interface
cij eventually filtered combined local belief states computed cij
starting node path containing k ij last edge ear decomposition
figure node
cases whenever input lsolve dmcsopt k called
cc input lsolve ck dmcs vb therefore claim output holds
proposition holds single leaf block one see upper blocks
need import interface
beliefs cut vertices root contexts lower blocks
setting v bk vb dmcsopt dmcs projected interface
cut vertices identical therefore upper blocks receive input regarding
interfaces cut vertices running therefore final projected
v k b end


proof proposition
note components handler output simply take care communication part
dmcs streaming output makes sure sent back invokers correspondence request handler got routines joiner solver main
components play role step b respectively


fid istributed e valuation n onmonotonic ulti context ystems













































































p







tm





tm pm





tm





tm pm



tm pm

tm pm




tm





tm pm



tm



tm





tm pm





tm






p








p

tm

tm








tm

tm

tm pm














tm p


p



p







tm pm



tm pm









p











tm




f















f





p









f





p









f





p







tm pm

tm

tm pm

tm pm



f





p















p









p







f

f

f



f







p f



f







table accumulation joiner

prove correctness dmcs streaming need input lsolve
complete sense step e exhaustively executed full join
partial equilibria neighboring contexts delivered


fidao ran e iter f ink k rennwallner

formally assume current contexts import neighborhood assume
neighbor ci full partial equilibria ti returned packages size
k denoted ti ti pi ti ti ti pi correctness
assume ti ti pi fixed partition ti possible example lsolve
returns answers fixed order need accumulation join
actually tm
indeed possible join tm im considered joiner performs
lexicographical traversal suitable combinations formally speaking let f p q q
q denote join neighbors p q f p q tp tp
tq
according lexicographical order accumulation joiner pj
j
f f demonstrated table
shows input lsolve complete hence dmcs streaming correct


appendix b detailed run optimizetree
example illustrate call optimizetree b c e cp cr block set b
b b b b b b c e b b
b cp cr
local knowledge bases presented example
b car train nuts
b car train
b car train salad peanuts coke juice urgent

b car train
b soon sooner
b fit sick

since cp cr start b b f v
call optimizeblock b since b acyclic transitive reduction applied
get b subroutine returns e
child cut vertices b c update f
next update label edges j b let us enumerate recursive
import interfaces starting import interface every node
v train train peanuts
v car coke train car train
v
v
v
v
v
v

v train sick
v train

v sooner
v

train train peanuts car coke car train sooner sick
train car coke train car sooner sick
train sooner sick
train sooner
train sooner


let us compute v b v b b b thus







v b v b b train train peanuts car coke car train
similarly b b
v v b car train
v v b train


fid istributed e valuation n onmonotonic ulti context ystems

removed edges updated labels stored respectively f v block b
summarized
f
v

v



v b



v b

v v v b v b
v v v b v b




train train peanuts

car coke car train
train peanuts car coke car train
train peanuts car coke car train

next call optimizetree b optimizetree b eventually process
blocks b b manner two calls respectively return
f
v sooner

f
v train sick

combining together optimizetree returns set removed edges
f
updated labels v remaining edges blocks
v
v
v
v
v







train train peanuts car coke car train
train peanuts car coke car train
train peanuts car coke car train
sooner
train sick

references
adjiman p chatalic p goasdoue f rousset c simon l distributed reasoning
peer peer setting application semantic web j artif intell res
aho v garey r ullman j transitive reduction directed graph
siam j comput
analyti antoniou g damasio c v mweb principled framework modular
web rule bases semantics acm trans comput log
baader f calvanese mcguinness nardi patel schneider p f eds
description logic handbook cambridge university press
baget j f tognetti backtracking biconnected components constraint
graph nebel b ed proceedings seventeenth international joint conference
artificial intelligence ijcai seattle washington usa august pp
morgan kaufmann
bairakdar e dao tran eiter fink krennwallner decomposition
distributed nonmonotonic multi context systems janhunen niemela eds
logics artificial intelligence th european conference jelia helsinki finland
september proceedings vol lecture notes computer science pp
springer


fidao ran e iter f ink k rennwallner

bairakdar e dao tran eiter fink krennwallner b dmcs
solver distributed nonmonotonic multi context systems janhunen niemela
eds logics artificial intelligence th european conference jelia helsinki
finland september proceedings vol lecture notes computer science pp springer
bessiere c bouyakhf e mechqrane wahbi agile asynchronous backtracking
distributed constraint satisfaction ieee rd international conference
tools artificial intelligence ictai boca raton fl usa november
pp
bikakis antoniou g defeasible contextual reasoning arguments ambient
intelligence ieee transactions knowledge data engineering
bikakis antoniou g hassapis p strategies contextual reasoning conflicts
ambient intelligence knowl inf syst
bogl eiter fink schuller p mcs ie system explaining inconsistency
multi context systems logics artificial intelligence th european conference
jelia helsinki finland september proceedings vol lecture
notes computer science pp springer
bondy murty u r graph theory vol graduate texts mathematics
springer
brewka g eiter fink weinzierl managed multi context systems walsh
ed proceedings nd international joint conference artificial intelligence
ijcai pp aaai press ijcai
brewka g ellmauthaler puhrer j multi context systems reactive reasoning
dynamic environments ellmauthaler puhrer j eds proceedings international workshop reactive concepts knowledge representation reactknow pp
tech rep computer science institute univ leipzig issn
brewka g eiter equilibria heterogeneous nonmonotonic multi context systems
proceedings twenty second aaai conference artificial intelligence july
vancouver british columbia canada pp aaai press
brewka g eiter fink nonmonotonic multi context systems flexible integrating heterogeneous knowledge sources balduccini son c
eds logic programming knowledge representation nonmonotonic reasoning essays dedicated michael gelfond occasion th birthday vol lecture notes computer science pp springer
brewka g roelofsen f serafini l contextual default reasoning veloso
ed ijcai proceedings th international joint conference artificial intelligence hyderabad india january pp
buccafurri f caminiti g logic programming social features theory practice
logic programming
dao tran distributed nonmonotonic multi context systems efficient
evaluation ph thesis faculty informatics vienna university technology austria


fid istributed e valuation n onmonotonic ulti context ystems

dao tran eiter fink krennwallner distributed nonmonotonic multicontext systems lin f sattler u truszczynski eds principles knowledge representation reasoning proceedings twelfth international conference
kr toronto ontario canada may aaai press
dao tran eiter fink krennwallner model streaming distributed multicontext systems mileo fink eds nd international workshop logicbased interpretation context modeling applications vol ceur workshop
proceedings pp
eiter fink ianni g krennwallner schuller p pushing efficient evaluation
hex programs modular decomposition delgrande j p faber w eds th international conference logic programming nonmonotonic reasoning lpnmr
vancouver bc canada may vol lecture notes computer science
pp springer
eiter ianni g schindlauer r tompits h uniform integration higher order
reasoning external evaluations answer set programming ijcai pp
faltings b yokoo introduction special issue distributed constraint satisfaction
artif intell
fink ghionna l weinzierl relational information exchange aggregation
multi context systems delgrande j p faber w eds th international conference logic programming nonmonotonic reasoning lpnmr vancouver bc
canada may vol lecture notes computer science pp
springer
gao j sun j zhang improved concurrent search distributed csps
australian conference artificial intelligence pp
gelfond lifschitz v classical negation logic programs disjunctive databases
generation comput
ghidini c giunchiglia f
local semantics contextual reasoning locality compatibility artif intell
giunchiglia f contextual reasoning epistemologia special issue linguaggi e le
macchine
giunchiglia f serafini l multilanguage hierarchical logics without
modal logics artif intell
goncalves r knorr leite j evolving multi context systems schaub
friedrich g osullivan b eds proceedings st eureopean conference
artificial intelligence ecai prague czech republic august ios press
hirayama k yokoo distributed breakout artif intell

homola semantic investigations distributed ontologies ph thesis comenius
university bratislava slovakia


fidao ran e iter f ink k rennwallner

lee j lifschitz v loop formulas disjunctive logic programs palamidessi c
ed logic programming th international conference iclp mumbai india december proceedings lecture notes computer science pp springer
mccarthy j notes formalizing context bajcsy r ed proceedings th
international joint conference artificial intelligence chambery france august september pp morgan kaufmann
pontelli e son nguyen n h combining answer set programming prolog
asp prolog system balduccini son eds logic programming knowledge
representation nonmonotonic reasoning vol pp springer berlin heidelberg
reiter r logic default reasoning artificial intelligence
roelofsen f serafini l cimatti many hands make light work localized satisfiability multi context systems de mantaras r l saitta l eds proceedings
th eureopean conference artificial intelligence ecai including prestigious
applicants intelligent systems pais valencia spain august pp
ios press
serafini l borgida tamilin aspects distributed modular ontology reasoning nineteenth international joint conference artificial intelligence ijcai
pp aaai press
serafini l tamilin drago distributed reasoning architecture semantic web
gomez perez euzenat j eds semantic web applications
second european semantic web conference eswc heraklion crete greece may
june proceedings lecture notes computer science pp springer
tarjan r e depth first search linear graph siam j comput

tasharrofi ternovska e generalized multi context systems baral c giacomo
g eiter eds principles knowledge representation reasoning proceedings fourteenth international conference kr vienna austria july
aaai press
valdes j tarjan r e lawler e l recognition series parallel digraphs siam
j comput
vats moura j f graphical block tree graphs corr abs
velikova novak p huijbrechts b laarhuis j hoeksma j michels
integrated reconfigurable system maritime situational awareness ecai st
european conference artificial intelligence august prague czech republic
including prestigious applications intelligent systems pais pp
yokoo hirayama k distributed constraint satisfaction review
autonomous agents multi agent systems




