journal articial intelligence

submitted published

lazy model expansion
interleaving grounding search

broes decat gmail com

broes de cat

om partners belgium

marc denecker cs kuleuven

marc denecker

dept computer science kuleuven belgium

pstuckey unimelb edu au

peter stuckey

national ict australia
dept computing information systems
university melbourne australia

maurice bruynooghe

dept computer science kuleuven belgium

maurice bruynooghe cs kuleuven

abstract

finding satisfying assignments variables involved set constraints
cast bounded model generation search bounded theory
logic state art bounded model generation rich knowledge representation languages answer set programming asp fo csp
modeling language zinc ground solve reduce theory ground
propositional one apply search resulting theory
important bottleneck blow size theory caused grounding
phase lazily grounding theory search way overcome bottleneck
present theoretical framework implementation context fo
knowledge representation language instead grounding parts theory justications
derived parts given partial assignment grounded part
theory valid justications formulas non grounded part justications
provide recipe construct complete assignment satises non grounded part
justication particular formula becomes invalid search one
derived fails formula split part grounded part
justied experimental illustrate power generality

introduction
world lled combinatorial

include important combinatorial

optimization tasks scheduling rostering combinatorics
extremal graph theory countless puzzles games solving combinatorial
hard methods know tackle involve kind search


declarative paradigms

developed solve



approaches objects attributes searched represented symbols
constraints satised objects represented expressions symbols

c ai access foundation rights reserved


fide cat denecker stuckey bruynooghe
declarative language solvers search values symbols satisfy
constraints idea found elds constraint programming cp apt
asp marek truszczyski sat mixed integer programming mip etc
terminology logic declarative method amounts expressing desired properties

logical theory data particular instance
partial interpretation structure solving process
apply model generation specically model expansion mitchell ternovska
class sentences

corresponds naturally

task nding structure expands input partial structure satises
theory resulting structure solution model generation expansion
studied example eld knowledge representation kr baral thus
analogous task solving constraint satisfaction studied cp
generating answer sets logic programs studied asp
similarities areas go deeper extend level used techniques

state art approaches often follow two phase solving methodology



rst phase input theory rich language hand reduced fragment
language supported search second phase search
applied reduced theory eectively search example
model generation language minizinc nethercote et al performed reducing ground language flatzinc search available similarly
language

pc

fo

denecker ternovska reduced propositional fragment

see e g wittocx marin denecker asp reduced propositional

asp see e g gebser schaub thiele reduced theory often ground
fragment language refer resulting reduced theory
rst phase

grounding

grounding



phase quantiers instantiated elements

domain elds grounding referred attening unrolling splitting
propositionalization solving methodology generally referred

solve

ground

grounding becomes bottleneck users turn applications large domains
complex constraints indeed easy see grounding size fo formula
exponential nesting depth quantiers arity predicates polynomial
size universe discourse

increasing number applications

size grounded theory large memory



example son pontelli le discuss several asp applications groundand solve turns inadequate
present novel remedy bottleneck called

lazy model

expansion grounding generated lazily search instead upfront works associating justications non ground parts theory
valid justication non ground formula recipe expand partial structure
precise partial structure satises formula course crucial
recipe lot compact grounding formula given partial structure
valid justication non ground formulas total structure obtained
extending partial structure literals justications non ground
formulas justications selected way total structure model
whole initial theory

consequently model generation limited grounded

part theory model found part extended model



filazy model expansion interleaving grounding search
whole theory however assignment model generation conict one
justications case alternative justication needs sought none
found associated formula split two parts one part grounded one
part valid justication still available

example

consider

sokoban

robot

push blocks around grid arrange given goal conguration constraint
move action target position
time



pp

moved block

bb

currently

empty expressed

b p b p move b p empty p



known advance many time steps needed one ideally wants assume
large even innite number steps ground solve blows size
grounding incremental grounding iteratively extending time domain
large enough allow plan developed avoid blow context
gebser et al general depend
presence one domain incrementally increased
returning example instead grounding sentence associate
justication recipe satisfy

make

move b p

false

b p







recipe search nds model grounded part
conict recipe model extended literals recipe obtain
model whole theory however search would decide move block

p

b

position

time conict created recipe resolve instance sentence

conict partial model search split sentence replaced
equivalent sentences

move b p empty p



b p b p b p move b p empty p



sentence grounded passed search component use check


empty p

holds

sentence non ground satised recipe

move b p false except

move b p

search makes moves

instances grounded search nds partial plan hand
literals recipe remaining non ground formula making

move b p

false instances sentence grounded complete plan
main contributions



theoretical framework

lazy model expansion

aiming minimally instantiat

ing quantied variables paves way solution long standing
handling quantiers search encountered e g elds asp lefvre
nicolas sat modulo theories ge de moura framework
generalizes existing approaches related grounding bottleneck
incremental domain extension claessen srensson lazy clause generation ohrimenko stuckey codish



fide cat denecker stuckey bruynooghe


complete lazy model expansion logic

fo id

extension

rst order logic fo inductive denitions language closely related asp
shown denecker et al includes ecient derive consistent
sets justications maintain throughout changes partial structure
e g search



idp

implementation extending

knowledge base system de cat et al

experiments illustrate power generality lazy grounding
lazy grounding step ability solve complex combinatorial
avoiding front grounding step previous approaches lazy grounding ground
enough solve method developed logic

fo id



become clear justications associated rules rules similar
rules used asp systems hence discussed towards end
framework applied context asp
organized follows

section necessary background nota

tions introduced formal denitions lazy grounding

fo id

presented

section followed presentation relevant heuristics sections
experimental evaluation provided section followed discussion related
future work conclusion preliminary version appeared work
de cat denecker stuckey de cat ch

preliminaries
section provide necessary background logic
tasks model generation model expansion

fo id

fo id

inference

ground solve

model expansion



fo id

first dene syntax semantics logic

fo id

denecker ternovska

extension rst order logic fo inductive denitions assume familiarity
fo without loss generality limit

fo id

function free fragment function

symbols eliminated graph predicates enderton
function free vocabulary



consists set predicate symbols

propositional

denoting true
false respectively predicate symbols usually denoted p q r atoms literals
atoms negation l variables x domain elements e
denote ordered set objects e en p n predicate p arity n

symbols ary predicate symbols include symbols

methods model generating developed require possibly innite
domain



domain atom

p p n dn n tuple domain elements likewise

given xed given function free vocabulary

atom form
consider

domain literals

consists domain n ary relation p dn
predicate symbols p n alternatively n ary relation viewed
n
function f propositional symbols respectively interpreted
f
structure



interpreting



filazy model expansion interleaving grounding search
model generation maintain


inconsistent

partial

structures may temporarily nd

state example conict arises represent

introduced consist domain
n ary predicate p three four valued relation p
n
function f u structure two valued range relations f
partial three valued range f u four valued general thus two valued
states three valued four valued structures





structures three valued four valued

unqualied term

structure

stands general four valued case
given xed





alternative way represent

domain

ai









f







ai inconsistent
ai u unknown

domain atom




domain literals
structures


set

indeed one one correspondence sets

otherwise hence

may treat four valued structures sets domain literals vice versa structure

inconsistent least one domain atom inconsistent

vocabulary naturally viewed structure larger
namely setting ai u domain atom predicate
set predicate symbols use denote restriction symbols


set domain atoms use denote restriction

u otherwise call two valued structure two valued
domain atoms unknown otherwise
truth value v dened follows f f u u
inverse v

truth order truth values dened u f f
precision order p dened p p u p f p u orders pointwise

extended arbitrary structures say expansion p



domain atom
p viewing structures sets domain literals

corresponds
structure


vocabulary

assume familiarity syntax function free fo facilitate reasoning
partially grounded formulas deviate standard fo quantify explicitly

x x
sometimes abbreviate x xn dn x similarly
given formula x indicates x free variables substitution
variable x formula term denoted x ground formula domain
specied subsets domain



denoted



formula without variables hence without quantiers similar properties notations
used

rules

introduced

voc set predicate symbols occur theory
structure voc set symbols interpreted unless specied otherwise
theories structures range vocabulary
language fo id extends fo inductive denitions theory fo id
nite set sentences denitions denition nite set rules
form x p x xn p predicate symbol fo formula
atom p x referred head rule body given rule r let
head r body r denote respectively head body r given denition
domain atom p dened exists rule x p x



otherwise p open domain literal p dened p
denote



fide cat denecker stuckey bruynooghe
sets dened open domain atoms denoted defined
open respectively

dened


without loss generality assume denition domain atom dened
one rule technically means rules

p x

x p x x

rules made disjunct
x p x x p x

pairwise disjunct

transforming

x p x
model semantics
semantics

fo id

two valued model semantics

nevertheless introduce

concepts three four valued semantics useful dening semantics
denitions formalizing lazy grounding

use standard four valued truth

assignment function dened structural induction pairs fo domain formulas



interpret


p p

structures

min
max

x max x
x min x
assignment function monotonic precision order

p



p





hence formula true partial structure true two valued expansions






two valued respectively three valued four valued



two valued



two valued

respectively three valued four valued
structure








model



satises

sentence



notation





satisfaction relation dened denitions well semantics

denitions parametrized well founded semantics extension wellfounded semantics logic programs informally described rst work van gelder
formally dened

fo id

denitions denecker semantics

formalizes informal semantics rule sets inductive denitions denecker
structure
notation two valued wellfounded model denoted wf open structure open denecker
ternovska case wf open two valued model expanding
open structure satises theory two valued model
sentences denitions next subsection present formalization
denecker bruynooghe marek denecker vennekens


model



satises

denition

well founded semantics notion
according

fo id

justication

methodology formal denitions used express informal

denitions work denecker vennekens shown

fo id

de

nitions oer uniform representation important types informal denitions



filazy model expansion interleaving grounding search
expressing informal denitions leads rule sets



called

total

well founded model



two valued denecker ternovska

total

formally denition

two valued structure



open



general totality undecidable however

broad syntactically dened classes denitions proven total e g nonrecursive positive stratied locally stratied denitions see denecker ternovska
inspection current

fo id

applications shows practice non total deni

tions occur rarely almost contain modeling error cases totality
established simple syntactic check

totality usefully exploited

computation lazy grounding techniques introduced exploit totality
applied total denitions restriction matches

fo id

methodology practice impose strong limitation

design

case

input theory contain denitions known total lost
denitions grounded completely front case lazy grounding applied
safely remaining sentences total denitions input

equivalence
equivalent

two theories







dierent vocabularies




expanded model vice

restricted
strongly equivalent expansions
unique extension strong equivalence structure dened similarly

model expanding expanded model expanding vice versa
obtain strong equivalence expansions unique theory often

derive strongly voc equivalent theory given structure transformations

preserve satisability number model directly mapped
model projection voc
versa

model

two theories



canonical theories



simplify presentation lazy grounding techniques

presented theories form

pt

single denition function free rules



pt

propositional symbol

without loss generality



first

mentioned standard techniques enderton allow one make theory functionfree second multiple denitions combined one described denecker
ternovska marin gilis denecker achieved renaming
dened predicates denitions merging rules one set adding
equivalence constraints predicates renamings

n

equivalent theory

pt pt n



pt


voc

third theory

resulting previous step translated strongly

propositional symbol

transformation ground set sentences denition consisting
set ground non ground rules lazy grounding cope non ground
rules furthermore assume rule bodies negation normal form negation
occurs front atoms dened domain atom
rule

x p x



dd


p

unique



methods proposed extended full

fo id

functions

extended methods implemented system however introduces number
rather irrelevant technicalities want avoid



fide cat denecker stuckey bruynooghe
justifications

canonical theory explained
correspond one one sets domain literals

denition direct
justication direct justication dened domain literal p

respectively p consistent non empty set domain literals

rule x p x holds x respectively

x f


consistent superset direct justication p direct justication

well indeed body x true true precise direct
justication empty denition true every structure minimal
direct justication

assume presence domain

recall structures domain

example

consider domain



direct justication

dn

denition

x p x q x r x
x q x p x

q di



p di



q di







p di

domain literals

many direct justications unique minimal ones

p di q di r di
p di q di r di atoms r di open

subset relation minimal direct justications
minimal direct justication
direct justication

g pair hv ei set v nodes set e directed
vi vj nodes node v v denote g v
g v w v w e

directed graph
e ordered pairs
children

v

e

denition justication
domain literals





justication

denition

domain literal

l j l



graph

j

edges
set

set

empty direct

justication l
thus justication graph encodes every dened domain literal none one
direct justication sequel say
denoted set pairs

l





j



dened l



j l

justication

direct justication l

denition justication subgraph

let

j

justication



justication

literal l subgraph jl nodes edges j reachable l justication
set literals l subgraph jl nodes edges j reachable l l
justication j total l j dened literal reachable
l dened total set literals l total literal l
justication j consistent structure consistent none literals



j
j

dened false



total l leaves

jl

open domain literals



filazy model expansion interleaving grounding search
denition
li li

positive literals

cycle

j

path justication

sequence

edge li li

negative

justication

j

j

l l

path

positive

consists negative literals

set domain literals path

j



consists

mixed

otherwise

starts ends

domain literal cycle positive respectively negative domain literals
positive literals respectively negative literals otherwise cycle mixed
innite path may cyclic
intuitively justication
truth

l

j



nite every innite path cyclic

containing domain literal

l

provides argument

strength argument depends truth leaves

innite paths cycles
provides argument

jl
l

leaves true every innite path negative
true leaf false unknown

mixed loop argument

l

jl

jl

contains positive

weak notice justications

l

may still

argue l truth

denition justies

l well founded justication
j every innite path jl negative otherwise l unfounded j
justication j justies set literals l dened set l literals
justication j jl total l ii literal l well founded j iii
set literals jl consistent

p

q

say dened literal

p

r

p

q

p

q

r

q


ii

iii

figure justications denition

example



p



example contain dened domain atoms

justication ii justies

iii however total


example

figure possible justications ordered iv left

right denition

q



iv



p



p
q



q

iv justies

p

p
q



positive cycle unfounded

q

relationship justications well founded semantics investigated dierent publications denecker de schreye marin
recall relies rst states
literals


l

l
jl

model







leaves

jl

j

justies

true satises literals



proposition j justication justies set domain literals l
literals jl true every model open leaves jl true


fide cat denecker stuckey bruynooghe
interpretation iopen two valued open well founded model
wf iopen computed time polynomial size domain shown chen
warren general wf iopen three valued structure wf iopen twovalued unique model expands iopen otherwise model
expands iopen proposition follows fact justication j justies
l leaves j true iopen literals l true wf iopen

example





r

true



r

justication ii justies l q
iopen interpreting open predicates
wf iopen particular model

continued example

unique open leaf


r

structure

iopen q
true q true

true

proposition model justication j exists consists
literals true dened dened domain literals true justies


corollary case

total justication j justies set domain
literals l every two valued open structure consistent jl extended
unique way model satises literals l
pt
justies pt

hence canonical theory
justication

j

exists

recall



total theory satisable

generating
model generation
model



inference task takes input theory



returns output

model expansion mx dened mitchell et al inference

task takes input theory
subvocabulary





vocabulary

returns expansion










two valued structure
satises







general inference dened wittocx marin denecker
takes input potentially partial structure
satises







returns expansion









already mentioned state art model expansion
similar asp grounding



context



fo id

afterwards applying search

resulting ground theory latter e g accomplished sat id search
marin et al
present grounding basis lazy mx
assume familiarity basic conict driven clause learning cdcl
sat solvers marques silva lynce malik

grounding
overview intelligent grounding techniques

fo id

refer reader

work wittocx denecker bruynooghe wittocx et al
present basic principle

vocabulary partial structure
returns ground theory strongly

grounder takes input theory
domain



interpreting least







filazy model expansion interleaving grounding search
equivalent



assume









theory



called

canonical theory form

grounding





given



recall

pt

one way compute grounding top process theory iteratively
applying grounding steps direct subformulas rule formula hand grounding
let x
let domains x tseitin transformation replaces

atom x x ary predicate symbol called tseitin symbol extends
rule x x theory strongly equivalent

may replace subformulas predicate symbols follows
formula

original one vennekens et al
procedure one step ground outlined figure performs one step grounding process called formula rule



canonical form replaces

g
rules formulas possibly non ground part r rules formula g
consists ground formulas replacing returned ground formulas extending
returned rules produces theory strongly voc equivalent original
rule g consists ground rules replacing sets returned
rules theory strongly voc equivalent original
direct subformulas tseitin symbols returns pair consisting ground part

one step ground
function one step ground formula rule

switch

case p return h

case p













hg

one step ground

return h p gg g
case w
n
return h n ti ti n
case n
return h ti n ti n
case x p x
return h p x x x
case x w x
return h dd x x x
case x x
return h x x x


v

grounding theory boils applying one step ground sentence
copies

pt

pt

ground part rule theory repeatedly applying

one step ground returned rules

r returned sentences rules g ground

use ground refer overall process
tseitin introduced symbols part normal form transformation



fide cat denecker stuckey bruynooghe
improvements exist returning



returning



atoms interpreted





conjunctions whenever false conjunct encountered analogously

disjunctions quantications
one step ground introduces large number tseitin symbols stateof art grounding use number optimizations reduce number
symbols optimizations directly applicable techniques presented
start naive one step ground section present
optimized version one step ground introduces fewer tseitin symbols hence
smaller groundings

lazy grounding lazy model expansion
lazy grounding refer process partially grounding theory
lazy model expansion lazy mx process interleaves lazy grounding

use term
term

model expansion grounded part section formalize framework
lazy model expansion

fo id

theories section formalize instance

framework basis current implementation section illustrate
operation

lazy model expansion fo id theories
given canonical theory

pt

input structure

iin

expanding

iin

searched interleaving lazy grounding search already grounded part
rst focus lazy grounding
apart initial step moves

pt

grounded part input step

consists set rules still grounded already grounded theory three valued
structure expansion initial input structure
subsequent grounding step replace non ground rules ground rules might
introduce rules hence state grounding includes set
set





delayed denition

g

ground rules

possibly non ground rules denitions

g follows abbreviated gd voc equivalent
original denition hence gd total grounding procedure guarantee
times g total
given partial structure iin rule sets g key idea behind lazy
model expansion use search search model g
expansion iin pt true ii maintain justication j literals
true dened justied gd j consistent iii
interleave steps ii move parts g literal dened
property

needs justied cannot justied

hg j ii
yet grounded justication j
g j empty graph

thus control lazy model expansion suces maintain state
consisting grounded rules
three valued structure



g

initially

rules





iin

lazy model expansion searches space

denition acceptable state
tence

acceptable

states

tuple hg j ii theory atomic senpt total denition input structure iin acceptable state gd g



filazy model expansion interleaving grounding search




gd strongly voc equivalent ii domain
iii j justication gd iv expansion
l literals true dened justied j vi jl
literals l consistent

total denitions

atom dened


v

iin

set

justication

example

g



consider theory

pt





denition



pt



x q x


x r x




x q x
let



structure

pt

hence



















unknown

g







denitions consisting rst rule remaining rules respectively furthermore let

j q tuple hg j ii acceptable
literal dened justied j

state indeed

already said lazy model expansion starts initial state

j iin

acceptable dened literals unknown

state renes



propagation choice backjumps

g

iin



resulting

state unacceptable repair operation restores acceptability steps described
section


gd

tries compute acceptable state



corollary would entail model

pt

justied

exists computed

eciently well founded model computation intermediate states justication
may non total

pt

iii

note
justied



contain unfounded literals inconsistent

justication must

gd

indeed assume literal

justication graph leaf dened

g

l



depends positively negatively l every attempt extend justication graph

l gd might fail e g forbidden
cycle consider e g denitions g p q q p case
would correct take p justication q true even though valid
justication within indeed model exists justies q full denition gd
total justication graph justies

proposition let hg j ii acceptable state

gd well founded model
expands literals true dened delayed denition

proof

l

let

set literals true

justies literals
expands

l



dened

open literals



state acceptable

j

hence corollary exists well founded model

l

example continued example






model

j

e

g pt

interpreted randomly

well founded evaluation assigning

q

derives



true

moreover

true well founded model note

r atoms

occur





j

following theorem states obtained expansion model





r



fide cat denecker stuckey bruynooghe
theorem let hg j ii acceptable state theory pt input
structure iin pt true voc g model g exists
model expands voc g
proof voc g
justication

jg

model


g

domain literals true
combine one

follows proposition exists

voc g

g

consists

two justications

follows dened literal

l



gd



j

j



jg



l
jg

dened

jc l jg l jc takes edges j
dened literal justication gd
verify jc justies pt first total pt indeed path pt
consists literals dened g branch total jg g passes

literal l dened justied j according condition v hence
jc l jl total pt cannot reach dened literal gd
jc undened second jc contain unfounded literals starting pt
path pt path jg well founded justies g
tail j well founded property v finally set literals reachable pt
jc consistent see look paths jc pt rst follow
jg consists true literals may get path j contains
literals consistent case impossible reach literal
set

jc l j l

jc

g

justies every true dened literal

otherwise set

negation
follows proposition exists model


pt

true since

gd

expands

voc g

gd strongly equivalent proposition follows

achieved well founded evalstarting two valued open gd

recall eectively computing model
uation

gd

polynomial data complexity

structure expanding

voc g

chen warren

theorem required
compute two valued model
justication justies

pt

g



model

g

actually need

suces search partial structure

relax requirement expense

maintaining justications literals true



dened

g

corollary let hg j ii acceptable state theory

pt input

structure iin pt true j justies pt gd exists
model expands set dened literals jpt
g expanding iin pt true implies lack
g model expanding iin unsatisable
core e set rules g model exists expands iin hence
unsatisable core pt nd unsatisable core one example
failure nd model





expanding

iin

indeed

use techniques described torlak chang jackson

practical justication management fo id theories
roughly speaking lazy model expansion framework consists two components
one hand standard model expansion operates

pt g
gd lazily

hand justication manager maintains justication





filazy model expansion interleaving grounding search
grounds



lazy model expansion performs search space acceptable states

aims reaching state theorem corollary applicable avoid slowing
search model expansion work done justication manager
lazy grounding must limited achieve designed system
justication manager access grounded denition

g

need restore

state search backtracks current structure
manager access



g

particular literal dened



justication

maintains justications restricted





allowed direct justication justication

manager maintains following properties



literals direct justications open



direct justications
structure



j

gd

dened



kept consistent current



justication graph dened

j

unfounded literals total

distinguish acceptable states meet additional requirements acceptable
states dened denition call

denition

default acceptable state



default acceptable states dene

state



hg j ii

default acceptable

state acceptable state addition literals direct justications
open

gd

dened



ii



j

justies set literals

j

dened

follows default acceptable states satisfy two extra conditions justify
literals dened
consistent



terms literals dened

g

dened



consistent

j



true



set literals

acceptable state suces literals

j

since default acceptable states acceptable states

theorem corollary hold default acceptable states
standard model expansion main state changing operations make



precise making literals true choice propagation make



less precise backjumping

model expansion modies








hg j ii default acceptable state

state hg j necessarily

default acceptable state following propositions identify situations acceptability
preserved

proposition let hg j ii default acceptable state l set literals unknown
consistent structure l literals l dened
direct justication j ii direct justication j contains negation
literal l hg j default acceptable state
proof



literals true

literals true


j

consistent

literals true









direct justication follows
direct justication justications
consistent hence j justies

dened

dened

ii



dened



proposition let hg j ii default acceptable state hg j
p default acceptable state



fide cat denecker stuckey bruynooghe
proof


j

j

justication

justies literals dened

justies literals dened



true

default acceptable state literals dened
literals dened
hidden loops


g







gd



true







subset



g

allowed direct justications

restriction quite limiting see next section avoid

loops detected maintaining justication

current implementation several methods exist

l dened g allowed direct
provided established l justication cannot loop gd
one case body rule l dened literals step analyze
dependency graph literal dened g allowed direct justication
literal dened provided literals belong strongly connected

extend class default acceptable states literals
justications

component dependency graph case cannot part cycle

example
rest section illustrate behavior lazy model expansion articial
example constructed way main features illustrated next section
processes involved described detail
focus operation justication manager interaction
solving process manager activated unacceptable state solver
falsies literal occurs direct justication

j

l dened
l extend

true literal

justied j one option repair search justication
j general hard model expansion
corollary manager searches
extend

j

nd one grounds l denition moves

example uses theory



shown

locally direct justication justies l
g

states symmetric graph edge exists

r
dn
equality predicate identity relation omitted predicates edge r
root interpreted r root dened particular root dened
singleton specifying root

least one node root node predicate
root node input structure

p












pt
c
c
x root x
x r x



root

reachable predicate

interprets domain

c c
x root x r x
x edge x edge x
x
root x edge x r



















lazy mx proceeds follows
initial default acceptable state


hg j ii



g



j

empty



propagation

pt g

sets





pt

expands structure

conditions proposition longer satised







resulting state

filazy model expansion interleaving grounding search
acceptable since

j

pt

true dened



direct justication

j direct justication pt
atom pt unique direct justication c c extending j
restore default acceptability since c c direct justication j
pt remains unjustied therefore alternative taken rule moved
g default acceptable state obtained
one option repair acceptability extend

pt c c c c justied consider
c rule edge open manager build direct justication
edge sets negative edge literals true extends j
setting positive edge literals true would equally good justies c
avoids grounding rule dening c

unit propagation sets
rst

literal

c

cannot justied local since direct jus

tications contains unjustied dened literals

however rule existentially

quantied one avoid grounding whole rule performing tseitin transformation isolate one instance ground instance purpose



root r

x root x r x b

illustration make bad choice instantiating



c


rule moved

g

x



default acceptable state reached

acceptable state propagation possible choice
made

c

true body rule become true preferably

selecting tseitin would trigger grounding rst disjunct selected
model expansion propagation extends structure
literal

root

denition
dening

root

root




dened

unique direct justication

root r

rule cannot justied since
false manager partially grounds

splits ground rule non ground rule b

domain elements



root
x root x x b



g note root justied gd hence
root direct justications whenever grounding

rule moved
safe use

done justication manager interrupted propagation infer truth
additional literals detect inconsistency backjumping
cases manager resume revision justication afterwards
acceptable state reached
unacceptable due unjustied

even though resulting state still

r

g
root conict

creation rule

interrupts manager propagation rule derives

pt c c subsequent propagation sets structure
pt c c root still default acceptable state justied

backtracking





rule b transformed split another instance



root r
ba
x root x r x bb





fide cat denecker stuckey bruynooghe
g

rule ba moved

rule bb remains



state default

acceptable

choosing rst disjunct rule ba
r literal root dened
justied direct justication literal r cannot justied
direct justication edge literals false current justication graph
rule transformed split instance actually instance

search avoids tseitin
propagates

root



turn disjunctive body complex subformula avoid grounding
subformula break two parts introduce another tseitin







r root
aa


edge r
ab
x r x root x





edge x r
b
rule aa moved

g

others remain



pt c c root root r hence propagation rule aa g extends direct justication justifying
hence rule ab partially grounded splitting case


edge r
aba
edge r abb

current structure

rule aba moved

g

rule abb remains

search selects rst disjunct

r


literal

extending

j

r

dened



rule body propagates edge
root direct justication

direct justication yields acceptable default

root dened g however root justied gd
j direct justication discussed earlier
justication manager faces true literal edge conict



direct justication edge c rule handle
conict splits aected instance x rule


c edge edge

x edge x edge x b

acceptable state since

making safe extend

g rule b remains direct justication
edge unaected part direct
justication c restores acceptability

rule moved



set

propagation rule extends





edge



literal edge
rule b resolve

true conict direct justication

justication manager partially grounds rule b splits instance

x follows


ba
edge edge
x


edge x edge x bb



filazy model expansion interleaving grounding search
g rule bb remains inherits direct
edge removed propagation rule ba extends
state acceptable dened justied

rule ba moved
justication










resulting

g

consists rules ba aa aba ba

consists rules b bb b abb bb cur pt c c root root edge edge r r
model pt g
literals root r dened literal root dened
rule b direct justication literal r dened rule b
root direct justication literal dened rule bb direct justication
set negative edge literals except edge edge obtain
full model theory extended literals direct justications

residual denition
rent structure





case assigns open literals model completed wellfounded model computation

gd

actually done without grounding

denition jansen jorissen janssens

justication management
section instantiated general framework developed section
justication manager access



example section justi

cation constructed demand e time literal needed dierent direct
justication body dening rule analyzed justication extracted
failed part rule grounded called
imagine

global

rules



local

one

considered attempt

select direct justications minimize grounding rules whole obviously
global time consuming applied every time
adjustment justication required section describe approaches
describing introduce notations assume normalizations done function nnf reduces formula negation normal form

set single element used shorthands
j justication denote j l graph identical j except l
justied assume quantiers range single variable variable names


reused formula furthermore assume basic reductions applied
formulas e g



reduces

x

reduces





local
shows top level lazy mx model expansion taking input
theory

pt



iin denitions g initialized
initialized iin set ground sentences tg
initial justication j empty auxiliary fifo

initialized empty

latter keeps track literals direct

input structure

empty denition respectively
initialized fact
queue

qch

pt

justication needs checked
main loop performs model expansion

tg g

interleaved work

justication manager towards establishing default acceptable state model expansion



fide cat denecker stuckey bruynooghe
part consists propagation call propagate test whether current state
inconsistent learning backjumping test whether model

tg g

found returning model justication choice step

tg g

selects literal unknown

assigns value

propagation returns literals

entailed ground theory partial structure example applying
unit propagation unfounded wellfoundedness propagation marin et al
test model performed default acceptable state e queue

qch

empty test succeeds ensures well founded model computation
expand current structure



extended direct justications literals

model whole theory choice step takes place default acceptable
state ensures search space limited state space default acceptable
states

justication manager activated propagation choice step assigns

literal
valid



l
l

calling check literal checked whether current justication remains
dened

queue

qch



justication needs justication added

processing justication manager



l


justication another literal l justication becomes inconsistent
another justication added

qch

occurs





l

needs

processing done selecting

elements queue calling lazy ground function

latter function rst

attempts nd dierent consistent direct justication l fails splits
rule instance dening

l





partially grounds hence

g

extended

clauses may trigger propagation therefore processing queued literals interleaved
propagation possibly backtracking note backtracking might restore
consistency



direct justication

j l

literal

l



qch

lazy grounding one rule
function lazy ground checks whether literal
tion simply returns otherwise checks whether

l

l

needs direct justica

valid justication e

one satises invariants detailed returns otherwise passes
rule body used construct justication negation dening rule
literal negative build djust function attempts nd valid direct
justication besides literal rule body initial justication derived
rule body passed build djust latter function successful justication
updated lazy ground done direct justication literal

false

l

set

split ground called ground part rule dening l

going details rst analyze properties want maintain
current justication
considered part

j

j

direct justications literals

qch queue
j



since might invalid global invariants



literals unfounded



set literals

j

recall negative cycles allowed

j

consistent

direct justication

j l j



l

queue invariants lazy

grounding process



contains literals dened

g

unless literal safely justied

discussed



gd



filazy model expansion interleaving grounding search

lazy mx lazy model expansion
function lazy mx atomic sentence pt denition structure iin
output model g j false
























tg

pt

g

true







j







iin qch



l propagate tg g
l
foreach l l qch check literal l qch
inconsistent
tg learn nogood tg
conict root level return false
state backjump point
else qch empty
l qch dequeue qch
lazy ground l
else model tg g
return j

else

select choice literal l





l

qch check literal l qch

function check literal literal l literal queue qch
data global j output updated queue
l dened j l undef qch enqueue l qch
foreach l l j l qch enqueue l qch
return qch

lazy grounding literal
function lazy ground literal l
data global j

l l dened

j l exists obeys invariants return

else













body rule dening l

l negative literal

nnf
dj build djust l init l
dj false j j l dj return

else

j



j l false

split ground l





fide cat denecker stuckey bruynooghe


literals
queue


qch

dened



direct justication

j

belong

qch

invariants imply default acceptable state reached

queue

empty indeed follows invariants current justication total
situation hence literals direct justication justied denition
due policy followed queue literals current justication consistent



literals true



dened



justication hence

hg j ii



default acceptable state

building direct justification
purpose build djust extend
literal

l



dened


formula



l

j

suitable direct justication

literal

j l

currently undened



inconsistent

recursive function takes three parameters literal

l

made true direct justication initially whole body

ii



rule dening literal note initialization takes negation rule

iii description direct justication derived far initialized

literal negative

init l assume

dierent quantiers range

dierent variables
going details discuss represent direct justications

basically

could represent direct justication set ground literals however set
quite large ground representation might hence defy purpose lazy

hl bi l set
b set bindings xi di xi variable di
domain set bindings b x xn dn represents set variable
substitutions sb x xn dn di di n set ground
literals represented hl bi l l l sb direct justication
literal p dn dened rule x p x initialized init l
h x xn dn eect b allows identify relevant rule instantiation

grounding

instead represent direct justication pair

possibly non ground literals

providing appropriate variable instantiation domains set literals
empty
build djust searches set literals making
recursively calling subformulas
larger justication







true

works

composing afterwards

set literals found example none

exists consistent direct justications

false

returned

base case formula literal make literal true instances
literal set bindings

b

must true hence set literals

l

extended

literal resulting direct justication satisfy invariants
checked call valid returns

true call valid l dj dj
l j l dj satises

part direct justication

satises invariants
invariants

justication
universally quantied formula
quantied variable

x

x

true instance

hence recursive call set bindings

b

extended

existentially quantied formula suces one instance true hence

minimal try instance separately one succeeds fail



false



filazy model expansion interleaving grounding search

build djust
function build djust literal l formula justication hl bi
input b binds free variables
output direct justication false

switch

case literal

valid l hl bi return hl bi

else return false

case x

return build djust l hl b x

case x

large

return build djust l hl b x

foreach di




hl b build djust l hl b x di
hl b
false return hl b








return false
case n
foreach n







return hl bi
case n
foreach n



hl b build djust l hl bi
hl b false return false
else hl bi hl b

hl b build djust l hl bi
hl b
false return hl b

return false



fide cat denecker stuckey bruynooghe
returned note however want iterate domain element
large would similar constructing grounding instead
extend binding

x







large

conjunction similar universal quantication except

explicit iteration conjunct needed soon one conjunct fails whole
conjunction fails disjunction similar existential quantication small domain
note build djust non deterministic due choices domain element justify
existentially quantied formula disjunct justify disjunction

example

consider following rule large domain



h x p x q x r x
assume

j empty
h p x x

loops keep track

applying build djust

p x body chosen
corresponds direct justication p x x alternatively second disjunct chosen returns h q x r x x represents direct
justication q x x r x x


h

returns

rst disjunct

partially grounding rule
last bit lazy model expansion handles case justication
found denition literal

l

grounded

straightforward way

would call one step ground rule dening l store

g





however many cases operation much grounding

example

form x p x situation
p applying one step ground r would instantiate
x elements resulting rules fact suces split r two rules
one instance x one remainder another example applies rule r
form h x q x r x direct justication j h q x x
q becomes false justication manager may need ground rule applying
one step ground would instantiate universally quantied x elements
instead better split instance x introduce tseitin
remainder producing h q r g x q x r x
direct justication obtained incrementally removing q
h discussed section
consider rule

r

justication found atom

split ground ground part rule dening
given literal
dening



l

l

say


p

rst step split rule instance rule

grounded call split

denes


p

let

replace rule

additionally return rule


p x

x p x rule
x p x

afterwards apply one step ground

latter rule add computed rules

g





split ground denition
one limit ground denition
equivalent

gd



gd ground previous
empty g strongly voc



recall head grounded rule dierent head already grounded rules



filazy model expansion interleaving grounding search
split ground
function split ground literal l
input l dened
update g j qch



r split l split updates
g one step ground r
g g



even justication found better splitting

l

applying

one step ground shown example first splitting made signicantly
intelligent discussed section second improve one step ground
ground part expressions possible describe

improving one step ground
subformulas instantiations
consists



l iterates
x p x

applying one step ground rule



example



sentence

rules many tseitin symbols instead depending

value l sucient introduce one subformulas shown
extends switch statement one step ground two higherpriority cases



l

true sucient ground one disjunct existential instantiation

delay rest tseitin introduction

l

false take similar

conjunction universal quantication

additional cases one step ground
switch r

case l n l









choose

n

return h l
case l x l

w

choose

j n j



return h l x
analogous cases









x
combination l f

algorithmic properties
correctness termination presented discussed following theorem

theorem correctness termination lazy mx returns interpretation

expanding literals direct justications j applying well founded evaluation gd restricting voc model returns
false interpretation exists precise iin satises



fide cat denecker stuckey bruynooghe
lazy mx terminates nite domain otherwise termination
possible guaranteed
proof

lazy mx returns interpretation



model

g



qch

empty given

properties split ground applying lazy ground literal l
valid justication dened
state theorem
returns

false



g

gd

qch



empty default acceptable

expanded model whole theory lazy mx

proven



hence

l

hence



g



iin

case

iin

expanding

without calls lazy ground search terminates nite
tion lazy ground produces ever increasing ground theory
limit hence lazy mx terminates





nite

g

g func

full grounding

innite limit

g



innite grounding termination cannot guaranteed

symbolic justifications incremental querying splitting
presented sound complete

however

improved taking formulas justications derived account

symbolic justications incremental querying
subformulas formula

example



multiple justications exist

grounding delayed

consider formula

x p x q x



h p x x

h q x x justications could derive justication
make p q true hence grounding necessary
p q become false





automatically changing build djust follows



allowed select multiple disjunctions existential quantications
even valid justication already found one lines



build djust longer returns justication symbolic

justication formula



entails original formula formula built build djust reects
subformulas instantiations selected





justication


p x x
x p x q x

derived directly set non false literals full grounding
example formula




x p x q x

instead justication

build djust might return justication formula

validity check valid extended return false justication formula false

allowing complex formulas instead conjunction universally quantied literals validity check whether formula become false incremental changes




expensive fact

incremental query

exper

iments limit depth allowed formulas use straightforward expensive
evaluates whole formula whenever assignment falsify
possible change integration

lazy ground lazy mx guarantee termination nite

model exists see section



filazy model expansion interleaving grounding search
body splitting

described section split simply splits

rule instance denes l one step ground grounds rule instance step step
accordance structure formula however grounding triggered
conict current justication one step ground blind origin
conict

conicting literals one could focus grounding part

formula contributes conict one restructuring rule part
grounded contains conict part grounded
old justication adjusted still apply

latter part split

introducing tseitins transformation called body splitting
inserted call split original justication call

jold

passed extra argument split ground

example

h x p x let h p x x justication h true p becomes false easy see split
violating instantiation rewriting original rule h p adding
rule x p x crucially justication second part derived
original justication namely h p x x second part hence
added justication j rst part added g
consider rule

r direct justication jold done ecient way
v true domain literal partial structure direct justication
rule r contains negation v implementation binding
justication instantiates v extracted representation
direct justication rule simplicity assume x dn single
instance recursive visits formula body r depth rst whenever
quantication x encountered x equal xj x replaced
x dj x dj tseitin transformation applied left hand
revision rule

assume

conjunct recurses right hand conjunct remains
binding rule dening tseitin jold v direct justication similarly
existential quantication replaced disjunction

set rules

justication sought smaller rule

r

passed

one step ground correctness follows fact jold v valid justication none
rules contains

example

v

correctness tseitin transformation

example justications sought

h

rule

h x p x q x r x
j q x x r x x
l q becomes false j longer
consistent cannot repaired j l however still consistent
justication whole body hand j l justication
subformula p x q x r x instantiation x dierent
consequently split quantication x x x

assume selected justication





p

true

apply tseitin transformation former afterwards recursively visit latter
formula apply similar reasoning existential quantication operations



fide cat denecker stuckey bruynooghe
split
x







p x




q x

split

p









r x
q

r q r

x p x q x r x split violating
q original justication without q justication

figure rule body
literal

left hand side splits justication formula shown blue
remaining non justied formula shown red

formula illustrated figure consists following rules
rule

h

even ground




h p q r






x p x q x r x




q r





optimize traversal formula
path taken parse tree

example





build djust extended store

direct justications subformulas

c x edge x edge x
justied j empty interpret edge build djust recursively
visits body rule edge x returned valid literal use going
one level store edge x edge x selected edge x assuming
disjuncts selected edge x returned going back
quantications store quantications selected set relevant

domain elements build djust returns justication formula x edge x
assume rule

build djust given access
direct justication

jold

similar optimizations possible repairing

consider example assume

p

unknown





case left branch figure transformed rule still valid

p direct
justication rule h p q r
example

direct justication right branch repair select disjunct

global
finding justications greedy local easily lead grounding
necessary consider example sentences



x p x



x p x q x

filazy model expansion interleaving grounding search
applying local second sentence rst empty
construction makes atoms

p

j

might

false applying local

rst sentence nds valid justication fully grounded global
takes set rules input tries select direct justications


expected

grounding size whole set minimal

cast task called

optimal justication graph
rule nodes r justication nodes j

follows graph consists two types nodes

justication node symbolic set literals representing possible justication

rule node pair
f u pair hr ti rule r head l
expresses exists direct justication l pair hr f exists direct
justication l pair hr ui r justication

literals dened rule

hr ti

r

rule







given current partial structure

truth value

three types edges

valid edges

rule node

negation head

conict edges

hr ti hr f justication node j



j

justies

r



ii

rule nodes rule dierent truth value

iii rule node hr ti hr f
l l iv rule node hr ui

justication nodes contain opposite literals

r

denes




r

l

l

justication node contains

denes

l

justication node contains



l

conict

l

hr ti hr f

j

needs justication

depends edges

justication node

contains negative positive literals dened
aim select subsets



l

rsel r



j
r

jsel j

rule node





selected rule node connected valid edge least one selected justication node



conict edges exist pairs selected nodes



neither positive mixed cycles exist subgraph consisting valid
depends edges selected nodes

selection

rsel jsel

extracted follows
rule

r



satisfying constraints initial justication

literal

hr ti hr f

l l



selected rule direct justication union

justications justication nodes
edge

j

given direct justication dened

jsel

connected

hr ti hr f

valid

moreover literals dened rules rule node selected

added initial

qch

queue handled local complete solution

must justication

hr ui

selected means grounding

instances rule delayed literals denes become assigned
type somewhat related np hard

hitting set



set cover

karp given set top bottom nodes edges
task nd minimal set bottom nodes top node edge
least one selected bottom node



fide cat denecker stuckey bruynooghe
hg j ii input optimal justication
node constructed
truth value known conict

given default acceptable state

generated follows rule
three truth values one
edges added

valid edges justication nodes obtained straightforward

adaptation build djust returns set possible justications make head
rule true false e g rule

p x

x p x build djust called literal
x conict depends edges derived

binding initialized

checking dependencies justications rules justications



keep ecient done symbolic level

example

pt c



c

x root x r x
x edge x edge x
x
root x edge x r











consider theory running example

propagated true denition






c
c
x



root x



x r x











associated optimal construction set input shown figure note rule

c c true
root x root x

nodes use dened head literals identify rule literal
hence one rule node rules neither
justied

x

hence

hroot ui

tuple

four solutions subset maximal respect rule nodes namely
following rule node selections

hr ui hroot ui hc ti



hr f hc ti

b

hr ti hc ti

c

hc ti hc ti



multiple justication selections possible shown figure


c

select justication

iv



c

choose

v



vi




objective maximize number selected rule nodes minimize
expected grounding size

obtain estimate expected grounding size

following conditions taken account



depend size grounding rule



assigning multiple justications rule lower estimate rule
grounded false



variables occurring multiple justications less matching instantiations



practical applications number false atoms far exceeds number
true ones model hence positive literals justication higher
cost negative ones



filazy model expansion interleaving grounding search
hr f

h root x edge x x

hr ui

h root x r x x

hr ti

h root x x

hc ti

h root x r x x

hc ti

h edge x x

hroot ui

h edge x x



ii

iii
iv
v
vi

figure graph part input optimal justication example

rule nodes shown left justication nodes right

valid edges shown green conict edges red depends edges blue
readability conicts justications unknown rule nodes
shown

approximate expected grounding size function
input rule

r

head

h

j

takes

n

selected type justication rule selected

justication u justication
cations

expsize

h

justication

h f

set justi

function returns expected grounding size rule size r dened

weighted depending type justication weights derived two
estimates

pval

ptr

probability atom become assigned

probability

n

assigned atom true hence dened formally non delayed rules

u

full size used rule without justication weighted



weighted

ptr

product justications
namely

pt

literals

f

false one

j



j

ptr

true justication

latter two weights multiplied

factor product sum two terms

times number negative literals

j

pval

j



ptr

times number positive

eect expected size decreases number justications

increases expected size increases justication literals

expsize r n size r
expsize r u size r pval
expsize r f j size r pval ptr



ptr pos

lits

j

jj

ptr neg lits j

expsize r j size r pval ptr
ptr pos lits j
jj

ptr neg
probabilities assumed

pval

lots literals get value

lits

j

small currently reect hope

ptr

less half reect atoms



fide cat denecker stuckey bruynooghe
often assigned false true function

size

dened function returns

number atoms grounding rule formula except existential quantication
disjunction take account grounded partially
tseitin transformation taking logarithm total grounding size

size l
size l size
size x size
x
size
size n
n

size x log size
p

n size

size n log n

n

solutions optimal justication minimize term

x

expsize r r j r

rd


r

type

f



u



j r

justication literal dened

r

example continued example size rule c log c

log root r log log
consider assigning justication iv c expected cost rule
log construction relies making r true additionally
would force grounding rule dening r increasing cost size
rule r optimal solution figure rule node selection

justication vi c cost sum log justication
vi log expected size rule c rule c


passed local
solve optimal justication

idp

optimization inference applied

meta level declarative specication task



larger theories





turns quite hard two approximations considered reduce search
space

first number selected justications rule limited

values

size r

grow quite large approximation

standard rounding integer values applied

dlog size r e

idp

second

used

support oating

point number still preliminary resulting specication could solved optimality
within seconds tested theories lazy model expansion global
applied initial phase tseitin literals representing sentences original
theory propagated true

heuristics inference tasks
section discusses tune lazy grounding search heuristics
underlying sat solver obtain eective implementation lazy model expansion
specication part

idp

public distribution



filazy model expansion interleaving grounding search
describe inferences tasks beyond model expansion useful
context lazy grounding less important issues discussed appendix

heuristics
heuristics play important role lazy grounding serve nd
right balance much ground long search rst discuss
heuristics chosen afterwards discuss alternative minimize
grounding

balance grounding search
leave room number heuristic choices important
eect performance

briey discuss choices

guideline

decisions following principles used



avoid leaving search process without enough information make informed
decision example avoid losing much unit propagation introducing
many tseitin symbols



prevent creating grounding large may example happen
long propagate ground sequence

recall goal create minimal grounding solve model expansion
avoiding large grounding
introduce number parameters aect heuristics

exact

values used experimental evaluation parameters introduced specied
appendix
split ground handling disjunction existential quantication
choice many disjuncts expand expand one instantiation time
rule

h x p x

done lines iterative application

ground theory

h p
p
p




tn x dn p x
sat solver minisat used


p di

idp

system initially assigns

atoms choice triggers iteration propagation grounding

f





resulting thrashing behavior reduced somewhat grounding compact
grounding introduces

n

disjuncts time

h p p dn
x dn p x



fide cat denecker stuckey bruynooghe
remedy two search related heuristics changed first initial truth
value randomized favoring false many atoms false
true second search typically

restart

ever increasing threshold

number conicts sometimes caching truth value assigned atoms

polarity caching

allows solver take learned information account search heuristic
staying approximately part search space

case lazy grounding

might want jump another part search space come across long
propagate ground sequences end introduce concept

randomized restarts

take place ever increasing threshold number times

g

extended

randomly ipping cached truth values
addition build djust returns

false

estimated formula

small grounding indeed grounding formulas help search whether formula
considered small determined terms estimated grounding size
strategy used split ground



whenever formula one step ground

would applied small ground applied instead completely ground formula

late grounding
grounding applied search process soon unit propagation taken place
focus current location search space danger
grounding much solution part space alternatively could
apply opposite strategy namely ground late possible apply additional
grounding search terminates without ever found model
acceptable default state strategy well known elds incremental proving
domain number time steps increased search
previous smaller bound nished guarantees minimal grounding prototype
strategy implemented

idp

good

related inference tasks
bulk focuses model expansion mx
solutions structures two valued

voc

fo id

theories





often one interested

small subset symbols voc example case model generation
id language extends fo id existential quantication relations
id p pn initial structure relation symbols p
pn fo id theory solved model generation fo id theory
initial structure dropping interpretation symbols p pn
another example query evaluation fo id given theory initial
structure formula free variables x fo id purpose evaluating
query ht nd assignments domain elements x model
exists expands x true solve model expansion
fo id predicate symbol introduced answers query tuples

domain elements true model theory extended
sentence x x denition x x
cases approaches standard model expansion compute total interpretation afterwards drop unnecessary information quite inecient lazy model



filazy model expansion interleaving grounding search
expansion save lot work partially grounding theory however
model found grounded part justications remaining denitions
used expand structure model full theory

although expansion

obtained polynomial time still inecient afterwards large part model
dropped
remedy dene variant model expansion task denoted



restricted

mx

additional list symbols

called output symbols solutions structures two valued symbols
expansion exists extends model adapting lazy
restricted mx takes input theory

structure

grounding solve restricted mx done analysis justications
need added completely structure splitting

gd

multiple denitions

evaluating dening output symbols symbols depend
stratication argument
mentioned inference tasks cast trivially restricted mx
lazy restricted mx greatly improves eciency respect ground solve
shown experimental section
extension

fo id



procedurally interpreted

symbols de cat et al

provides another class interesting predicate symbols xed interpretation know whether tuple belongs predicate procedural function
executed provides clean way combine declarative procedural specications consider example symbol

isp rime n

interpreted

procedure executes ecient prime verication returns true
given argument prime generally interested complete interpretation

isp rime cast restricted mx isp rime

solving

lazy grounding benet executing associated function



search relevant atoms

isp rime

task experimental

evaluation next section

experiments


idp

system state art model expansion engine observed

previous answer set programming competitions denecker et al calimeri et al
alviano et al lazy model expansion presented
implemented

idp

system extending existing de cat bogaerts

devriendt denecker
current implementation incomplete sense cycle check justications implemented yet aects inductive denitions non inductive
ones replaced fo formulas completion

workaround

lack cycle check build djust function constructs direct justication returns
false rules dening inductive predicates consequence instance rule
immediately grounded although lazily domain atom dened rule assigned value another consequence inductively dened predicates cannot used
justications rules aects three benchmarks asp competition de within asp community sometimes referred predicates



fide cat denecker stuckey bruynooghe
scribed section namely

reachability sokoban



labyrinth



grounding might delayed even complete implementation
section organized follows section evaluate overhead completely
grounding theory presented section evaluate eect
lazy grounding number benchmarks asp competition

section

number additional properties presented demonstrated
tested three dierent setups
referred

g idp

idp

standard ground solve

lazy model expansion lazy award winning asp

system gringo clasp asp used

idp

version lazy gringo clasp st

parameters lazy grounding discussed section values
used experiments documented appendix experiments sections
run bit ubuntu system quad core ghz processor
gb ram experiments section run bit ubuntu system
core ghz processor gb ram timeout seconds
memory limit gb used time indicated



memory



eect grounding time
lazy grounding may reduce grounding size time causes overhead instance
expect naive incremental querying justications costly discussed previously aim section quantify overhead caused lazy grounding
experiments compare grounding time standard idp system


naive

instance lazy grounding forced generate complete

grounding starting search instance obtained standard small changes shortcut ground small formulas turned
disjuncts instances existentially quantied formulas grounded one one
dened literal enqueued lazy grounding soon appears

g

comparison

measure cost standard lazy grounding computes partial
groundings
devised six benchmarks test aspects novel benchmark simple theory two sentences simple solve benchmarks
designed measure cost dierent aspects lazy grounding delaying resuming grounding querying needed resume grounding splitting formulas etc
specically tested aspects following
overhead delaying resuming grounding case existential quantier
large domain

sentence

n disjuncts naive lazy
n tseitin symbols

clause
introduces

x p x

standard grounding creates single

grounding grounds formula piece piece

overhead case inductive denition

x p x p x q x

standard grounding naive lazy grounding construct ground rule



p

atom
benchmarks experimental data complete available

krr experiments lazygrounding jair



http dtai cs kuleuven

filazy model expansion interleaving grounding search
overhead case universal quantication
standard grounding creates

n

sentence

x p x



atomic formulas naive lazy grounding splits one

instance time introduces

n

tseitin symbols

lifted unit propagation lup wittocx et al important preprocessing step reduce grounding size concretely applying lup rules

x r x
x r x p x
derives second formula follows rst hence need
grounded theory used check whether lup remains equally important
system lazy grounding

x
r x p x standard grounding creates formula instance
x tseitin grounding p naive lazy grounding creates
extra tseitin instance x extra set tseitins piece piece
grounding subformula p

overhead case nested universal quantication sentence form

overhead incremental querying case symbolic justication validated sentence

x r x x

identical justication formula

formula validated checking falsity query
query evaluated time

r atom



atom

x r x x



falsied


experiments done predicates

p



q

arity

r





arity

domains size none predicates symbols interpreted
structure
experiments overhead time required solve initial optimization
global around seconds negligible
rst three experiments shown dierences standard
grounding naive lazy grounding negligible

expected experiment

experiments shows actual implementation eliminates overhead
tseitins quantiers nested three experiments standard lazy
grounding able justify formulas without grounding hence fast almost
insensitive domain size shown figure dierence standard
grounding naive lazy grounding experiment cases use lup
big impact size grounding hence time experiment
showed top level quantier create overhead lazy grounding experiment
shows hold anymore nested quantiers naive lazy grounding
substantial overhead compared standard grounding note overhead
worst case

tseitins justied denitions grounded

explains normal lazy grounding faster standard grounding insensitive
domain size

experiment shows complex justication formula causes

signicant overhead naive lazy grounding overhead worst case



fide cat denecker stuckey bruynooghe

grounding bounds

nested universal quantification



complex justification shared variables




ground without lup
ground lup
naive lazy ground without lup
naive lazy ground lup
lazy ground lup




ground
naive lazy ground
lazy ground



ground
naive lazy ground
lazy ground









seconds

seconds

seconds










































domain size





domain size

















domain size

figure time overhead naive lazy grounding ground solve completely
grounding input theory benchmarks time includes grounding solving time needed nd justications time required
standard lazy grounding shown comparison

visible normal lazy grounding still important part future reduce
overhead incremental querying complex justication formulas

asp competition benchmarks
second selected benchmarks previous asp competitions evaluate lazy
grounding realistic setting many benchmarks solutions competition carefully ne tuned speed minimal grounding lazy grounding usually
unable substantially reduce grounding theories due overhead
slower standard ground solve reason sometimes selected
modelings benchmarks natural less optimized time grounding size justify ground aim work improve inference
declarative

modeling

de cat et al emphasis developing intricate

encodings modeling close natural language specication
selected following see competition websites complete descriptions consist known hard order evaluate eect
lazy model expansion search typically large grounding

reachability

given directed graph determine whether path exists two

given nodes

labyrinth

agent traverses graph moving

connected nodes reach given goal node addition graph manipulated
change connectedness

packing

given rectangle number squares squares grid

without overlaps

disjunctive scheduling

schedule number actions given earliest start

latest end time additional constraints precedence disjointness



filazy model expansion interleaving grounding search
inst

solved

g

benchmark

sokoban
disj sched
packing
labyrinth
reachability
stable marr
graph col









lazy
































avg time sec

asp



g

lazy

asp


















































table number solved instances asp benchmarks average time taken
solved instances dierent solvers solve quite dierent sets instances

sokoban

robot push number blocks goal

positions constrained maze

graph colouring

given graph assign colour nodes given set colours

connected nodes colour

stable marriage

given set men women set preferences nd

stable assignment swap better match
used instances competitions except


reachability

instances huge data les none systems

stable marriage graph colouring reachability
packing disjunctive
idp
scheduling constructed natural fo encoding made faithful translation
asp complex benchmarks labyrinth sokoban used original
fo idp gringo clasp asp specications submitted competition

designed handle



encodings available asp core encodings

lazy model expansion replaced cardinality expressions fo encoding
former justications derived yet increases size full grounding


number solved instances average time shown table average grounding
size

idp



setup shown table

time grounding size unsolved instances

reachability times g
asp disjunctive scheduling times asp labyrinth times g
asp packing times g times lazy times asp stable
marriage times asp unsolved instances caused time
taken account memory overows happened
times

grounding consists variable instantiation interleaved formula simplication e g dropping false
disjuncts true conjuncts replacing disjunctions true disjuncts true conjunctions false
conjunctions false etc simplication steps may seriously reduce grounding size


idp

automatic symmetry breaking cause dierence

colouring



g



asp



graph

fide cat denecker stuckey bruynooghe
ground size atoms
benchmark

sokoban
disj sched
packing
labyrinth
reachability
stable marr
graph col

g








lazy








ground time

asp








table average grounding size number
marks setups
taken

g



asp

lazy

solved

g sec

asp










sec









instances asp bench

setup size nal ground theory

average grounding time shown

lazy model expansion solved instances setups
four seven cases cases got solved signicantly
time threshold

seven cases nal grounding size smaller

lazy model expansion orders magnitude one case

colouring

sokoban labyrinth graph

lazy model expansion outperformed ground solve indicating

sokoban
lazy grounding size even higher g possible due fo encoding
cardinalities indicating large part search space explored stable
marriage relatively small dierence grounding size g lazy leads us
loss information outweighed gain grounding less front e g
nal

believe dierent search heuristic main factor lazy grounding
experimented

airport pickup asp benchmark fairly standard

scheduling transporting passengers taxis taking account fuel consumption
except upper bound time provided



hence ground solve

would need construct innite grounding applying straightforward lazy model expansion resulted grounding large however prototype uses
late grounding heuristic described section

idp

solved one ten instances

others grounding search took long
time intervals

n

considered get sucient

n

solve even

standard search heuristic
presented although often benecial lazy model expansion
considerable overhead hard search hand inspecting
outcome experiments observed class specications instances
solved lazy grounding traditional grounding partially overlap suggests
might good idea integrate approaches

portfolio

system system

select heuristically whether use ground solve lazy model expansion
input running parallel aborting one uses much
memory however considered lazy model expansion could start search
possible derive nite worst case thresholds airport pickup however
part original specication



filazy model expansion interleaving grounding search
much earlier ground solve even though got lost often search
leads us believe realize full potential lazy grounding work necessary
developing suitable heuristics possibly user specied ones

specic experiments
addition asp competition benchmarks experiments conducted
crafted benchmarks illustrate specic properties lazy grounding
rst part table shows scalability experiments
benchmarks

packing sokoban



disjunctive scheduling

selected simple prob

lem instance gradually extended domain size orders magnitude size
grid packing number time points sokoban

disjunctive scheduling



instances lazy model expansion scales much better
ground solve strategies
satisable instances however
signicantly

idp

gringo clasp satisable well un

disjunctive scheduling solving time still increases

reason lazy heuristics still naive make uninformed

choices often
mentioned previous section asp competition typically small
groundings since running benchmarks large system handle
provide useful comparison systems hence evaluated lazy model expansion
number crafted benchmarks grounding non trivial
work look practical applications type

part future

constructed following

benchmarks

dynamic reachability


lazy evaluation

example described section

procedurally interpreted

prime numbers

symbols simple theory

described section predicate symbol

isp rime



interpreted procedure returns true argument prime

function



predicate encoding



experiment simulates model generation theory unknown domain

huge domain

used quantied formulas
x used x model

domain size

unknown domain expressed predicate

x

translated

x used x



x

generation simulated model expansion



one faithful asp encoding constructed second part table shows
benchmarks signicant improvement lazy model expansion ground solve examples case
memory overow grounding


disjunctive scheduling

lazy

g



asp

went

found solutions within seconds however

evident lazy would benet

improved heuristics increasing domain size signicantly increases solving time
instances intrinsically harder

closer inherent complexity
modeling phase application dierent encodings typically tested
attempt improve performance locate bugs modeling experimental



fide cat denecker stuckey bruynooghe
benchmark

packing
packing
packing
sokoban
sokoban
sokoban
disj sched sat
disj sched sat
disj sched sat
disj sched unsat
disj sched unsat
disj sched unsat
dynamic reachability
procedural
function
modelgeneration

lazy

g

asp




















































































table solving time additional crafted benchmarks one instance

benchmarks noticed simplifying theory dropping constraints often resulted
dramatic reduction time lazy model expansion took nd model standard
model expansion hand much less aected simplications



opinion observation hardly denitive evidence another indication
presented able derive justications parts theory
satised cheaply way able distinguish better
inherently dicult would large grounding

related work
lazy model expansion oers solution blow grounding often occurs
ground solve model expansion methodology

fo id

theories

answer set

programming asp sat modulo theories smt techniques process theories
large grounding constraint store constraint programming cp mixed
integer programming clauses sat considered equivalent grounded
theory often derived quantied descriptions ci

j

cj



become large lefvre nicolas ge

de moura reported blow paradigms multitude
techniques developed address distinguish four approaches
first concerning grounding front done towards

grounding

static analysis
ii



reducing size

input derive bounds variable

instantiations wittocx et al techniques

compile

specic types sen

tences compact ground sentences tamura et al metodi codish

iii detect parts evaluated polynomially leone et al gebser et al
iv detect parts relevant task hand e g



jansen et al



filazy model expansion interleaving grounding search
context query shown work leone et al naturally
approaches used conjunction lazy grounding reduce
size grounding

idp



e g lazy grounding already combined

second size grounding reduced

enriching

language

iii

ex

ample asp solvers typically support ground aggregates interpreted second order functions
cardinality sum take sets arguments cp smt solvers support
uninterpreted functions recently constraint asp paradigm developed ostrowski schaub integrates asp cp extending asp language

constraint

atoms interpreted constraints csp thus

handled cp techniques casp solvers already available clingcon ostrowski schaub ezcsp balduccini mingo liu janhunen niemel
inca drescher walsh technique integrated
cat et al

inca

idp

idp

de

fact implement lazy clause generation ohrimenko

et al optimized form lazy grounding specic types constraints
language hex asp eiter et al extends asp time

external



atoms

represent higher order external function calls
third

incremental approaches

well known model generation theorem proving

tasks domain typically xed advance part
structure sought number time steps recall
sokoban example introduction typically works grounding
initial guess number elements domain

afterwards

search applied model found domain extended grounding
done iterated model found bound maximum domain size
hit one known

technique applied e g prover paradox claessen

srensson asp solver iclingo gebser et al
fourth closest lazy grounding large body devoted
delaying grounding specic types expressions necessary example
propagation propagation techniques rst order level delay grounding
propagation ensues researched within asp lefvre nicolas dal
pal et al dao tran et al within cp ohrimenko et al



techniques used conjunction lazy grounding derive intelligent
justications specic types constraints presented example dao tran et
al presented ecient bottom propagation denition within
smt theory propagators work lazily transforming theory sat
theory bit vectors bruttomesso et al

ge de moura

investigated quantier handling combining heuristic instantiation methods
decidable fragments fo theories eciently checked
within asp work done goal directed reasoning bonatti pontelli
son marple bansal min gupta demonstrate approaches
style sld resolution apply top instantiation answer queries innite
domains saptawijaya pereira extend abduction framework lazily generate
part relevant sentences search justications

watches

used

derive constraint propagation already satised hence need
checked propagation phase nightingale et al maintaining
short justications signicantly reduce cost propagation phase



fide cat denecker stuckey bruynooghe
fact well known technique already exists combines search lazy instantiation quantiers namely

skolemization

existentially quantied variables

placed newly introduced function symbols

universal quantications handled

instantiating introduced function symbols

reasoning consistency

e g achieved congruence closure capable deriving consistency without eectively assigning interpretation function symbols

techniques

used tableau theorem proving hhnle smt solvers detlefs nelson saxe


formula jackson bjorner schulte interleaves creating ground pro

gram giving smt solver iterating symbolic guesses proved wrong
skolemization techniques typically work well case small number constants
needs introduced diculty case relevant domain large one
see lazy grounding support function symbols could incorporate skolemization adapting rules grounding existential universal quantication expect
skolemization complementary lazy grounding depth investigation part
future work
eld probabilistic inference several related techniques developed
rely lazy instantiation first problog system uses form static dependency
analysis ground probabilistic program context given query constructing
possible ways derive query top fashion kimmig et al second
called

lazy inference

applied e g

lazysat

fact considered inference xed

singla domingos exploits

default

assumption exists

expression certainly contribute probabilities

hence expressions

assumption certainly holds considered search third

cutting plane inference

riedel applies lazy inference interleaved setting

constructing part program assumptions satised

future work
several aspects presented work need investigation one aspect extending
support lazily ground complex expressions including aggregate expressions

p
xd p x f x
atom p true p

nested function terms consider example sentence
expresses sum terms
predicate

f

f



function larger one observe necessary

ground whole sentence front
hence positive set

example

p f

f

maps natural numbers

minimal justication

even easy

justication found suce grounding part sentence delay

p

p f
p
p
tseitin symbol dened
p f xd p x f x indeed
model sentence false original inequality satised

remainder

example create ground sentence



second aspect whether advantages grounding earlier example
guarantee propagation lost grounding later possibly reducing size grounding even example consider sentences

p



p









large formulas justication found instead grounding least one
sentences might add

p

list atoms search assign



filazy model expansion interleaving grounding search
ground sentences

p

assigned value might even

unsatisability detected grounding one
given lazy grounding useful lazy

forgetting

grounded theory

ground theory extended making structure precise ground theory
could reduced backtracking

storing justication violations

caused grounding derive grounding forgotten violation
longer problematic e g backtracking needs developed
tracks grounding splitting dependencies rules given justications
closely resembles techniques used tableau theorem proving smt theory
hand compacted moving dierent part search space
described lazy grounding applied answer set generation
eld asp asp logic program stable semantics seen one rule
set single denition however asp programs satisfy major condition
apply lazy grounding indeed programs typically non total due presence
constraints rules form

p np np p



choice rules



multiple stable however described denecker et al practical
asp programs partitioned set choice rules set

total

denitions set

constraints called generate dene test partition asp program
gdt partitioned translated straightforwardly equivalent

fo id

theory

contains total denitions suggests way apply lazy grounding
asp programs

conclusion
solvers used domains sat smt asp often confronted
large ground lazy model expansion technique described
interleaves grounding search order avoid grounding bottleneck technique
builds upon concept justication deterministic recipe extend interpretation
satises certain constraints theoretical framework developed lazy
model expansion language

fo id presented derive

maintain justications interleave grounding state art cdcl search


framework aims bounded model expansion domains

nite initial step towards handling innite domains eciently experimental
evaluation provided implementation

idp

system lazy

model expansion compared state art ground solve



experiments showed considerable improvement ground solve existing benchmarks
well applications main disadvantage less informed search
caused delay propagation introduction additional symbols possible
solution develop heuristics portfolio approaches combine strengths
methods finally indicated way proposed methods applied
beyond

fo id

asp solvers general



fide cat denecker stuckey bruynooghe
acknowledgements
broes de cat funded agency innovation science
technology flanders iwt supported fwo vlaanderen
project goa fund kuleuven

nicta funded

australian government department communications australian
council ict centre excellence program

appendix details
appendix mention parameter values well optimizations
reduce grounding overhead improve search optimization indicate currently implemented part experimental part
future work

parameter values
number parameters introduced control behavior lazy model
expansion

provide details values used experimental evaluation

values set manually experience limited number observations
e g extension threshold works similar conict threshold sat solver
part future work study impact dierent values



existential quantication instantiations grounded time disjunction disjuncts grounded time turned give best balance
introducing many tseitin atoms grounding much



initial truth value



initial threshold randomized restarts extensions ground theory



probability





f

otherwise

doubled restart



formula considered small estimated grounding size



atoms

extension fo idp
far described lazy model expansion function free
however

fo idp

knowledge base language

idp

fo id

system supports much richer

input language besides types use initialize domains supports
partial functions aggregates arithmetic

current implementation ignores

latter extensions straightforward adaptation build djust
case literals extended return

fo id

false

literal part function free

language example given rule

justication

q f x

h x p x q f x p x used

cannot functions option replace

graph predicates preprocessing step experiments section
functions given input structure hence play role
part future work extend lazy grounding extensions especially
functions techniques developed smt constraint programming handle ground



filazy model expansion interleaving grounding search
atoms containing function symbols useful reduce size grounding improve
search previous work techniques integrated

idp

system de cat

et al certainly worthwhile fully integrate lazy grounding

cheap propagation checks
lazy mx checked assigned literal whether dened



whether

violates justications implement cheaply implementation maintains
mapping literals

g

states whether literal dened



lists

justications negation occurs mapping extended whenever literal
added

g

maintained whenever justications change

performance

search loop unaected long literals assigned mapping empty

stopping early
took standard stopping criterion used search
line stop conict free state



two valued symbols

principle may stop earlier partial structure

pt

indeed corollary tells us





tg g



admits total justication

expanded model

dened
irrelevant eect appear justication trigger grounding
denition turn might introduce literals dened causing cascade

considerable impact grounding size indeed assigning truth value atom


unnecessary groundings assignments
justication

g

solver maintain

cannot know exactly justication exists

instead

implemented chooses literals watched formula rule



stops partial structure unwatched literals may assigned
shown suces guarantee



admits justication hence safe stop

search

approximate justications
cases build djust cannot nd valid justication large formula


false least one atom p
literals already false

example formula

x p x

build djust returns

false instead adapted build djust heuristic

check number expected violations small enough justication still
returned naturally required check whether real violations
querying justication formula



apply lazy ground

references
alviano calimeri f charwat g dao tran dodaro c ianni g krennwallner
kronegger oetsch j pfandler phrer j redl c ricca f schneider
p schwengerer spendier l k wallner j p xiao g fourth
answer set programming competition preliminary report
c eds
apt k r

cabalar p son

lpnmr vol lncs pp springer
principles constraint programming cambridge university press


fide cat denecker stuckey bruynooghe
balduccini

industrial size scheduling asp cp

delgrande j p

lpnmr vol lncs pp springer
knowledge representation reasoning declarative solving

faber w eds
baral c

cambridge university press york ny usa
bonatti p pontelli e son c

credulous resolution answer set

programming fox gomes c p eds

aaai pp aaai press

bruttomesso r cimatti franzn griggio hanna z nadel palti
sebastiani r
verication

lazy layered smt bv solver hard industrial

damm w hermanns h eds

lncs pp springer

cav

vol

calimeri f ianni g ricca f third open answer set programming competition

tplp

chen w warren tabled evaluation delaying general logic programs

j acm

claessen k srensson n

techniques improve mace style model

proceedings cade workshop model computation principles
applications
nding

dal pal dovier pontelli e rossi g answer set programming
constraints lazy grounding hill p warren eds


lncs pp springer

dao tran eiter fink weidinger g weinzierl

iclp

vol

omiga

open minded grounding answer set solver del cerro l f herzig

jelia vol lncs pp springer
cat b separating knowledge computation fo knowledge base
system model expansion inference ph thesis ku leuven leuven belgium
mengin j eds

de

de cat b bogaerts b bruynooghe denecker
modelling language idp system

corr abs

predicate logic

de cat b bogaerts b devriendt j denecker model expansion
presence function symbols constraint programming

ictai pp

ieee
de cat b denecker stuckey p j lazy model expansion incremental
grounding dovier costa v eds

iclp technical communications

lipics pp schloss dagstuhl leibniz zentrum fuer informatik
delgrande j p faber w eds logic programming nonmonotonic reasoning th international conference lpnmr vancouver canada may
proceedings vol lncs springer
vol

denecker well founded semantics principle inductive denition
dix j del cerro l f furbach u eds
springer



jelia vol lncs pp

filazy model expansion interleaving grounding search
denecker extending classical logic inductive denitions lloyd j w
dahl v furbach u kerber lau k k palamidessi c pereira l sagiv
stuckey p j eds

cl vol lncs pp springer

denecker bruynooghe marek v w logic programming revisited logic
programs inductive denitions

acm trans comput log

denecker de schreye justication semantics unifying framework
semantics logic programs

tech rep department computer science

k u leuven
denecker de schreye justication semantics unifying framework
semantics logic programs pereira l nerode eds

lpnmr pp

mit press
denecker lierler truszczynski vennekens j
mal semantics answer set programming

iclp technical communications

vol

tarskian infor

dovier costa v eds

lipics

pp schloss dagstuhl

leibniz zentrum fuer informatik
denecker ternovska e logic nonmonotone inductive denitions

trans comput log

acm

denecker vennekens j well founded semantics principle inductive denition revisited baral c de giacomo g eiter eds

kr

pp

aaai press
denecker vennekens j bond gebser truszczyski second
answer set programming competition

erdem e lin f schaub eds

lpnmr vol lncs pp springer
detlefs nelson g saxe j b
checking

j acm

simplify theorem prover program

technical communications th international conference logic programming iclp september budapest
hungary proceedings vol lipics schloss dagstuhl leibniz zentrum fuer

dovier costa v eds

formatik
drescher c walsh answer set solving lazy nogood generation dovier
costa v eds

iclp technical communications

vol

lipics

pp

schloss dagstuhl leibniz zentrum fuer informatik
eiter ianni g schindlauer r tompits h uniform integration higherorder reasoning external evaluations answer set programming

kaelbling

ijcai pp professional book center
mathematical introduction logic second edition

l p saotti eds
enderton h b

academic

press

logic programming nonmonotonic reasoning th international conference lpnmr potsdam germany september
proceedings vol lncs springer

erdem e lin f schaub eds



fide cat denecker stuckey bruynooghe
ge de moura l complete instantiation quantied formulas satisabiliby modulo theories bouajjani maler eds

lncs pp springer

cav

vol

gebser kaminski r kaufmann b ostrowski schaub thiele
engineering incremental asp solver
eds

garca de la banda pontelli e

iclp vol lncs pp springer

gebser kaminski r knig schaub advances gringo series
delgrande j p faber w eds

lpnmr

vol

lncs

pp

springer
gebser schaub thiele

gringo grounder answer set

programming baral c brewka g schlipf j eds

lncs pp springer

hhnle r
eds

tableaux related methods

lpnmr vol

robinson j voronkov

handbook automated reasoning pp elsevier mit press

jackson e k bjorner n schulte w

open world logic programs

foundation formal specications tech rep msr tr microsoft
jansen j jorissen janssens g compiling input


tabled prolog rules idp

fo inductive denitions

tplp

karp r reducibility among combinatorial miller r thatcher j
eds

complexity computer computations pp plenum press

kimmig demoen b de raedt l santos costa v rocha r
implementation probabilistic logic programming language problog



lefvre c nicolas p



tplp

rst version asp solver asperix

erdem e lin f schaub eds

lpnmr

vol

lncs



pp

springer
leone n pfeifer g faber w eiter gottlob g perri scarcello f
dlv system knowledge representation reasoning

log

acm trans comput

liu g janhunen niemel answer set programming via mixed integer
programming

brewka g eiter mcilraith eds

kr

pp

aaai press
marek v w truszczyski
gramming paradigm
eds

stable alternative logic pro

apt k r marek v w truszczyski warren

logic programming paradigm year perspective

pp

springer verlag
marin

model generation id logic

ph thesis department computer

science ku leuven belgium
marin gilis denecker relation id logic answer
set programming alferes j j leite j eds
pp springer



jelia

vol

lncs

filazy model expansion interleaving grounding search
marin wittocx j denecker bruynooghe sat id satisability
propositional logic extended inductive denitions kleine bning h zhao
x eds

sat vol lncs pp springer

marple k bansal min r gupta g goal directed execution answer
set programs schreye janssens g king eds

ppdp

pp

acm
marques silva j p lynce malik

conict driven clause learning sat

handbook
satisability vol frontiers articial intelligence applications pp
solvers

biere heule van maaren h walsh eds

ios press
metodi codish compiling nite domain constraints sat bee

tplp

mitchell g ternovska e

framework representing solving np

search veloso kambhampati eds

aaai

pp

aaai press mit press
mitchell g ternovska e hach f mohebali r

model expansion

framework modelling solving search tech rep tr simon
fraser university canada
nethercote n stuckey p becket r brand duck g tack g minizinc
towards standard cp modelling language bessiere c ed


lncs pp springer

cp

vol

nightingale p gent p jeerson c miguel short long supports
constraint propagation

j artif intell res jair

ohrimenko stuckey p j codish propagation via lazy clause generation

constraints

ostrowski schaub



asp modulo csp clingcon system

riedel cutting plane map inference markov logic

statistical relational learning srl

saptawijaya pereira l

tplp

international workshop

towards practical tabled abduction logic

programs correia l reis l p cascalho j eds

epia vol lncs

pp springer
singla p domingos p memory ecient inference relational domains gil
mooney r j eds

aaai pp aaai press

son c pontelli e le

two applications asp prolog system

decomposable programs multi context systems flatt guo h f eds

padl vol lecture notes computer science pp springer

tamura n taga kitagawa banbara compiling nite linear csp
sat

constraints



fide cat denecker stuckey bruynooghe
torlak e chang f h jackson finding minimal unsatisable cores
declarative specications cullar j maibaum e sere k eds
vol

lncs pp springer

fm

tseitin g complexity derivation propositional calculus slisenko
ed

studies constructive mathematics mathematical logic ii pp

consultants bureau n
van gelder alternating xpoint logic programs negation

syst sci

j comput

vennekens j marin wittocx j denecker predicate introduction
logics xpoint semantics part logic programming



fundamenta informaticae

wittocx j denecker bruynooghe constraint propagation rst order
logic inductive denitions

acm trans comput logic

wittocx j marin denecker

idp system model expansion system

extension classical logic denecker ed

lash pp acco

wittocx j marin denecker grounding fo fo id bounds

j artif intell res jair




