Journal Articial Intelligence Research 52 (2015) 235-286

Submitted 10/14; published 02/15

Lazy Model Expansion:
Interleaving Grounding Search

broes.decat@gmail.com

Broes De Cat

OM Partners, Belgium

Marc.Denecker@cs.kuleuven.be

Marc Denecker

Dept. Computer Science, KULeuven, Belgium

pstuckey@unimelb.edu.au

Peter Stuckey

National ICT Australia
Dept. Computing Information Systems
University Melbourne, Australia

Maurice Bruynooghe

Dept. Computer Science, KULeuven, Belgium

Maurice.Bruynooghe@cs.kuleuven.be

Abstract

Finding satisfying assignments variables involved set constraints
cast (bounded) model generation problem: search (bounded) models theory
logic. state-of-the-art approach bounded model generation rich knowledge representation languages Answer Set Programming (ASP) FO() CSP
modeling language Zinc, ground-and-solve : reduce theory ground
propositional one apply search algorithm resulting theory.
important bottleneck blow-up size theory caused grounding
phase. Lazily grounding theory search way overcome bottleneck.
present theoretical framework implementation context FO()
knowledge representation language. Instead grounding parts theory, justications
derived parts it. Given partial assignment grounded part
theory valid justications formulas non-grounded part, justications
provide recipe construct complete assignment satises non-grounded part.
justication particular formula becomes invalid search, new one
derived; fails, formula split part grounded part
justied. Experimental results illustrate power generality approach.

1. Introduction
world lled combinatorial problems.

include important combinatorial

optimization tasks planning, scheduling rostering, combinatorics problems
extremal graph theory, countless puzzles games. Solving combinatorial problems
hard, methods know tackle involve kind search.
Various

declarative paradigms

developed solve problems.



approaches, objects attributes searched represented symbols,
constraints satised objects represented expressions symbols

c 2015 AI Access Foundation. rights reserved.


fiDe Cat, Denecker, Stuckey & Bruynooghe
declarative language. Solvers search values symbols satisfy
constraints. idea found elds Constraint Programming (CP) (Apt, 2003),
ASP (Marek & Truszczyski, 1999), SAT, Mixed Integer Programming (MIP), etc.
terminology logic, declarative method amounts expressing desired properties

logical theory. data particular problem instance
partial interpretation (or structure). solving process
apply model generation, specically model expansion (Mitchell & Ternovska, 2005),
problem class sentences

corresponds naturally

task nding structure expands input partial structure satises
theory. resulting structure solution problem. Model generation/expansion,
studied example eld Knowledge Representation (KR) (Baral, 2003), thus
analogous task solving constraint satisfaction problems, studied CP,
generating answer sets logic programs, studied ASP.
similarities areas go deeper extend level used techniques.

State-of-the-art approaches often follow two-phase solving methodology.



rst phase, input theory, rich language hand, reduced fragment
language supported search algorithm. second phase, search
algorithm applied reduced theory eectively search models. example,
model generation language MiniZinc (Nethercote et al., 2007) performed reducing ground language FlatZinc, search algorithms available. Similarly,
language

PC()

FO()

(Denecker & Ternovska, 2008) reduced propositional fragment

(see, e.g., Wittocx, Marin, & Denecker, 2010), ASP reduced propositional

ASP (see, e.g., Gebser, Schaub, & Thiele, 2007). reduced theory often ground
fragment language, refer resulting reduced theory
rst phase

grounding

grounding



phase (where quantiers instantiated elements

domain). elds, grounding referred attening, unrolling, splitting
propositionalization. solving methodology generally referred

and-solve.

ground-

Grounding becomes bottleneck users turn applications large domains
complex constraints. Indeed, easy see grounding size FO formula
exponential nesting depth quantiers arity predicates polynomial
size universe discourse.

increasing number applications

size grounded theory large memory.



example, Son, Pontelli, Le (2014) discuss several ASP applications groundand-solve approach turns inadequate.
paper, present novel approach remedy bottleneck, called

lazy model

expansion, grounding generated lazily (on-the-y) search, instead upfront. approach works associating justications non-ground parts theory.
valid justication non-ground formula recipe expand partial structure
precise (partial) structure satises formula. course, crucial
recipe lot compact grounding formula. Given partial structure
valid justication non-ground formulas, (total) structure obtained
extending partial structure literals justications non-ground
formulas. Justications selected way total structure model
whole initial theory.

Consequently, model generation limited grounded

part theory; model found part, extended model

236

fiLazy Model Expansion: Interleaving Grounding Search
whole theory. However, new assignment model generation conict one
justications. case, alternative justication needs sought. none
found, associated formula split two parts, one part grounded one
part valid justication still available.

Example 1.1.

Consider

Sokoban

problem, planning problem robot

push blocks around 2-D grid arrange given goal conguration. constraint
move action target position
(at time

T)

pP

moved block

bB

currently

empty, expressed

(t, b, p) B P : move(b, p, t) empty(p, t).

(1)

known advance many time steps needed, one ideally wants assume
large even innite number steps. Using ground-and-solve, blows size
grounding. Incremental grounding, iteratively extending time domain
large enough allow plan, developed avoid blow-up context
planning (Gebser et al., 2008). approach general depend
presence one domain incrementally increased.
Returning example, instead grounding sentence (1), associate
justication, recipe satisfy it.

Make

move(b, p, t)

false

b, p







recipe. search nds model grounded part problem
conict recipe, model extended literals recipe obtain
model whole theory. However, search would decide move block

p1

b1

position

time t1 , conict created recipe. resolve it, instance sentence (1)

conict partial model search split sentence (1) replaced
equivalent sentences:

move(b1 , p1 , t1 ) empty(p1 , t1 )

(2)

(t, b, p) B P \(t1 , b1 , p1 ) : move(b, p, t) empty(p, t)

(3)

Sentence (2) grounded passed search component use check


empty(p1 , t1 )

holds.

Sentence (3) non-ground satised recipe

move(b, p, t) false except

move(b1 , p1 , t1 ).

search makes moves,

instances grounded, search nds partial plan problem hand.
literals recipe remaining non-ground formula making

move(b, p, t)

false instances sentence (1) grounded complete plan.
main contributions paper are:



theoretical framework

lazy model expansion.

aiming minimally instantiat-

ing quantied variables, paves way solution long-standing problem
handling quantiers search problems, encountered, e.g., elds ASP (Lefvre
& Nicolas, 2009) SAT Modulo Theories (Ge & de Moura, 2009). framework
generalizes existing approaches related grounding bottleneck
incremental domain extension (Claessen & Srensson, 2003) lazy clause generation (Ohrimenko, Stuckey, & Codish, 2009).

237

fiDe Cat, Denecker, Stuckey & Bruynooghe


complete algorithm lazy model expansion logic

FO(ID ),

extension

rst-order logic (FO) inductive denitions (a language closely related ASP
shown Denecker et al., 2012). includes ecient algorithms derive consistent
sets justications maintain throughout changes partial structure
(e.g., search).



IDP

implementation extending

knowledge-base system (De Cat et al., 2014)

experiments illustrate power generality lazy grounding.
Lazy grounding new step ability solve complex combinatorial problems.
avoiding up-front grounding step previous approaches, lazy grounding ground
enough problem solve it. method developed logic

FO(ID ),



become clear, justications associated rules, rules similar
rules used ASP systems. Hence, discussed towards end paper,
framework algorithms applied context ASP.
paper organized follows.

Section 2, necessary background nota-

tions introduced. Formal denitions lazy grounding

FO(ID )

presented

Section 3, followed presentation relevant algorithms heuristics Sections 4
5. Experimental evaluation provided Section 6, followed discussion related
future work conclusion. preliminary version paper appeared work
De Cat, Denecker, Stuckey (2012) De Cat (2014, ch. 7).

2. Preliminaries
section, provide necessary background logic
tasks model generation model expansion

FO(ID )

FO(ID ),

inference

ground-and-solve

approach model expansion.

2.1

FO(ID )

First, dene syntax semantics logic

FO(ID )

(Denecker & Ternovska, 2008),

extension rst-order logic (FO) inductive denitions. assume familiarity
FO. Without loss generality, limit

FO(ID )

function-free fragment. Function

symbols always eliminated using graph predicates (Enderton, 2001).
(function-free) vocabulary



consists set predicate symbols.

Propositional

> , denoting true
false respectively. Predicate symbols usually denoted P , Q, R; atoms a, literals
(atoms negation) l; variables x, ; domain elements d. e
denote ordered set objects e1 , . . . , en ; P/n predicate P arity n.

symbols 0-ary predicate symbols; include symbols

methods model generating developed require (possibly innite)
domain



, domain atom

P P/n Dn , n-tuple domain elements. Likewise,

given xed. Given (function-free) vocabulary

atom form
consider

domain literals.

consists domain n-ary relation P Dn
predicate symbols P/n . Alternatively, n-ary relation viewed
n
function {t, f }. propositional symbols > respectively interpreted
f .
structure



interpreting

238

fiLazy Model Expansion: Interleaving Grounding Search
Model generation algorithms maintain


inconsistent

partial

structures may (temporarily) nd

state, example conict arises. represent

introduced; consist domain
n-ary predicate P , three- four-valued relation P .
n
function {t, f , u, i}. structure two-valued range relations {t, f },
partial three-valued range {t, f , u}) four-valued general. Thus, two-valued
states, three-valued four-valued structures



and,

structures three-valued four-valued.

unqualied, term

structure

stands general, four-valued case.
Given xed





, alternative way represent

domain

aI

=t







=f







a, aI = (inconsistent)
aI = u (unknown)

domain atom


,

domain literals.
-structures
,

set

Indeed, one-to-one correspondence sets

otherwise. Hence,

may treat four-valued structures sets domain literals vice versa. structure

inconsistent least one domain atom inconsistent.

vocabulary naturally viewed structure larger
, namely setting aI = u domain atom predicate 0 \ .
set predicate symbols, use I| denote restriction symbols
I|

. set domain atoms, use I|S denote restriction : =
I|
= u otherwise. call two-valued structure two-valued
domain atoms unknown otherwise.
1 truth value v dened follows: t1 = f , f 1 = t, u1 = u
inverse v
1
= i. truth order >t truth values dened >t u >t f >t >t f .
precision order >p dened >p >p u >p f >p u. orders pointwise
0
extended arbitrary -structures. say ' expansion p ,
0


domain atom a,
p . Viewing structures sets domain literals,
0
corresponds .
structure

0
vocabulary

assume familiarity syntax (function-free) FO. facilitate reasoning
partially grounded formulas, deviate standard FO quantify explicitly

x D0 : x D0 : ,
D. sometimes abbreviate x1 D1 : . . . xn Dn : x : , similarly
. Given formula , [x] indicates x free variables . Substitution
variable x formula term denoted [x/t]. ground formula (in domain )
specied subsets domain

D.

denoted

D0

formula without variables (hence without quantiers). Similar properties notations
used

rules

(introduced below).

voc(T ) set predicate symbols occur theory .
structure , voc(I) set symbols interpreted . Unless specied otherwise,
theories structures range vocabulary .
language FO(ID ) extends FO (inductive) denitions. theory FO(ID )
(nite) set sentences denitions. denition (nite) set rules
form x : P (x1 , . . . , xn ) , P predicate symbol FO formula.
atom P (x) referred head rule body. Given rule r , let
head (r) body(r) denote respectively head body r. Given denition ,
domain atom P dened exists rule x : P (x)



. Otherwise P open . domain literal P dened P
denote

239

fiDe Cat, Denecker, Stuckey & Bruynooghe
. sets dened open domain atoms denoted defined ()
open(), respectively.

dened


Without loss generality, assume denition domain atom dened
one rule. Technically, means rules

P (x) 2

x D1 : P (x) 1 , x D2 :

D1 D2 = . Rules always made disjunct
x D1 D2 : P (x) 1 2 , x D1 \ D2 : P (x) 1 ,

pairwise disjunct,

transforming

x D2 \ D1 : P (x) 2 .
2.1.1 Model Semantics
semantics

FO(ID )

two-valued model semantics.

Nevertheless, introduce

concepts three- four-valued semantics useful dening semantics
denitions formalizing lazy grounding.

use standard four-valued truth

assignment function, dened structural induction pairs FO domain formulas



interpret :


P = P (d ),

structures

( )I = min<t ( , ),
( )I = max<t ( , ),
()I = ( )1 ,
(x : )I = max<t ({[x/d]I | D}),
(x : )I = min<t ({[x/d]I | D}).
assignment function monotonic precision order:

p 0 ,



p

0

.

Hence, formula true partial structure, true two-valued expansions
it.

Also,



two-valued (respectively three-valued, four-valued)



two-valued



two-valued

(respectively three-valued, four-valued).
structure


= t.





model

/

satises

sentence



(notation

|= )



satisfaction relation dened denitions well. semantics

denitions based parametrized well-founded semantics, extension wellfounded semantics logic programs informally described rst work Van Gelder
(1993), formally dened

FO(ID )'s

denitions Denecker (2000). semantics

formalizes informal semantics rule sets (inductive) denitions (Denecker, 1998;
structure
(notation |= ) two-valued wellfounded model denoted wf ( I|open() ) structure I|open() (Denecker
& Ternovska, 2008). case wf ( I|open() ) two-valued, model expanding
I|open() . structure satises theory two-valued model
sentences denitions . next subsection, present formalization
Denecker, Bruynooghe, & Marek, 2001; Denecker & Vennekens, 2014).


model

/

satises

denition

well-founded semantics using notion
According

FO(ID )'s

justication.

methodology, (formal) denitions used express informal

denitions. work Denecker Vennekens (2014), shown

FO(ID )

de-

nitions oer uniform representation important types informal denitions

240

fiLazy Model Expansion: Interleaving Grounding Search
expressing informal denitions leads rule sets



called

total

well-founded model



two-valued (Denecker & Ternovska, 2008).

total.

Formally, denition

two-valued structure



open()



general, totality undecidable; however

broad, syntactically dened classes denitions proven total (e.g., nonrecursive, positive, stratied locally stratied denitions, see Denecker & Ternovska,
2008). Inspection current

FO(ID )

applications shows practice, non-total deni-

tions occur rarely almost always contain modeling error. Also, cases totality
established simple syntactic check.

Totality usefully exploited

computation. lazy grounding techniques introduced exploit totality
applied total denitions. restriction matches

FO(ID )'s

methodology and, practice, impose strong limitation.

design

case

input theory contain denitions known total, lost:
denitions grounded completely up-front, case lazy grounding applied
safely remaining sentences total denitions input.

Equivalence.
equivalent

Two theories





0,

dierent vocabularies,

-

0
expanded model vice

restricted
0 strongly -equivalent expansions
unique. extension, (strong) -equivalence structure dened similarly:
0
model expanding expanded model expanding vice versa;
obtain strong equivalence, expansions unique. theory , often
0
derive strongly voc(T )-equivalent theory given structure . transformations
0
preserve satisability number models model directly mapped
model projection voc(T ).
versa.

model

Two theories



Canonical theories.



simplify presentation, lazy grounding techniques

presented theories form

{PT , },

single denition function-free rules.



PT

propositional symbol,

without loss generality.



First,

mentioned above, standard techniques (Enderton, 2001) allow one make theory functionfree. Second, multiple denitions always combined one described Denecker
Ternovska (2008) Marin, Gilis, Denecker (2004). achieved renaming
dened predicates denitions, merging rules one set adding
equivalence constraints predicates renamings.

{1 , . . . , n , }

equivalent theory

{PT , {PT 1 n }}



PT

=
voc(T )-

Third, theory

resulting previous step translated strongly

new propositional symbol.

transformation results ground set sentences denition consisting
set (ground non-ground) rules, lazy grounding cope non-ground
rules. Furthermore, assume rule bodies negation normal form (negation
occurs front atoms) that, dened domain atom
rule

x : P (x)



dD


P ,

unique

.

methods proposed extended full

FO(ID )

functions,

extended methods implemented system. However, introduces number
rather irrelevant technicalities want avoid here.

241

fiDe Cat, Denecker, Stuckey & Bruynooghe
2.1.2 Justifications

canonical theory = {, } explained
correspond one-to-one sets domain literals.

Denition 2.1 (Direct
justication). direct justication dened domain literal P

(respectively P ) consistent non-empty set domain literals that,

rule x : P (x) , holds [x/d] = (respectively

[x/d] = f ).

0
consistent superset direct justication P direct justication
0
well. Indeed, body [x/d] true true precise . Also, direct
justication empty denition; true every structure, minimal
direct justication {>}.

assume presence domain

above. Recall, structures domain

Example 2.2.

Consider domain



direct justication

= {d1 , . . . , dn }

denition

x : P (x) Q(x) R(x)
x : Q(x) P (x)

Q(di )



{P (di )}



Q(di )







{P (di )}.

domain literals

many direct justications, unique minimal ones

P (di ) {Q(di )} {R(di )}
P (di ) {Q(di ), R(di )}. Atoms R(di ) open

subset relation. Minimal direct justications
minimal direct justication
direct justication.

G pair hV, Ei set V nodes set E directed
(vi , vj ) nodes. node v V , denote G(v)
G(v) = {w | (v, w) E}.

(directed) graph
i.e., ordered pairs
children

v,

i.e.,

Denition 2.3 (Justication).
domain literals





justication

denition

domain literal

l, J(l)



graph

J

edges,
set

set

either empty direct

justication l.
Thus, justication graph encodes every dened domain literal none one
direct justication. sequel say
denoted set pairs

l S,





J



dened l



J(l) 6= .

justication

direct justication l.

Denition 2.4 (Justication subgraph).

Let

J

justication

.

justication

literal l subgraph Jl nodes edges J reachable l. justication
set literals L subgraph JL nodes edges J reachable l L.
justication J total l J dened literal reachable
l dened ; total set literals L total literal L.
justication J consistent structure consistent none literals



J
J

dened false

I.

total l, leaves

Jl

open domain literals.

242

fiLazy Model Expansion: Interleaving Grounding Search
Denition 2.5.
li li+1 ,

positive literals;

cycle

J

path justication

sequence

edge li li+1

negative

justication

J

J.

l0 l1 . . .

path

positive

consists negative literals;

set domain literals path

J

that,

consists

mixed

otherwise.

starts ends

domain literal. cycle positive (respectively, negative) domain literals
positive literals (respectively, negative literals); otherwise cycle mixed.
innite path may cyclic not.
Intuitively, justication
truth

l.

J



nite, every innite path cyclic.

containing domain literal

l

provides argument

strength argument depends truth leaves

innite paths cycles
provides argument

Jl .
l

leaves true every innite path negative,
true. leaf false unknown,

mixed loop, argument

l

Jl

Jl

contains positive

weak. Notice justications

l

may still

argue l's truth.

Denition 2.6 (Justies).

l well-founded justication
J every innite path Jl negative. Otherwise l unfounded J .
justication J justies set literals L dened (the set L literals
justication J ) (i) JL total L; (ii) literal L well-founded J ; (iii)
set literals JL consistent.

P (d)

Q(d)

say dened literal

P (d)

R(d)

P (d)

Q(d)

P (d)

Q(d)

R(d)

Q(d)
(i)

(ii)

(iii)

Figure 1: Justications denition

Example 2.7.



P (d)

D.

Example 2.2 contain dened domain atoms

Justication (ii) justies

(iii), however, total


Example 2.2,

Figure 1, show possible justications (ordered (i)-(iv) left

right) denition

Q(d) (d D).



(iv)



P (d)



P (d)
Q(d)



Q(d)

(iv) justies

P (d)

P (d)
Q(d);



(i) positive cycle unfounded

Q(d).

relationship justications well-founded semantics investigated dierent publications (Denecker & De Schreye, 1993, 1992; Marin, 2009).
recall results paper relies. rst result states
literals


L

L,
JL .

model







leaves

JL

J

justies

true, satises literals



Proposition 2.8. J justication justies set domain literals L
literals JL true every model (open) leaves JL true.
243

fiDe Cat, Denecker, Stuckey & Bruynooghe
interpretation Iopen two-valued open(), well-founded model
wf (Iopen ) computed time polynomial size domain, shown Chen
Warren (1996). general, wf (Iopen ) three-valued structure. wf (Iopen ) twovalued, unique model expands Iopen ; otherwise, model
expands Iopen . proposition follows fact justication J justies
L leaves J true Iopen , literals L true wf (Iopen ).

Example 2.9

.



R(d)

true



R(d)

Justication (ii) justies L = {Q(d)}
Iopen interpreting open predicates ,
wf (Iopen ). particular, model

(Continued Example 2.7)

unique open leaf


R(d).

structure

Iopen , Q(d)
true, Q(d) true.

true

Proposition 2.10. model , justication J exists consists
literals true , dened dened domain literals true justies
them.

Corollary 2.11. case

total, justication J justies set domain
literals L, every two-valued open()-structure consistent JL extended
unique way model satises literals L.
{PT , }
justies PT .

Hence, canonical theory
justication

J

exists

(recall,



total), theory satisable

2.2 Generating Models
Model generation
model

T.

inference task takes input theory



returns output

Model Expansion (MX) dened Mitchell et al. (2006) inference

task takes input theory
subvocabulary

,



vocabulary

returns expansion










two-valued structure
satises

T.



Here,

general inference problem dened Wittocx, Marin, Denecker (2008)
takes input (potentially partial) structure
satises





,

returns expansion







T.

already mentioned, state-of-the-art approach model expansion
(similar ASP) grounding



context



FO(ID )

afterwards applying search

resulting ground theory. latter can, e.g., accomplished SAT(ID) search
algorithm (Marin et al., 2008).
Below, present grounding algorithm basis lazy MX algorithm.
assume familiarity basic Conict-Driven Clause-Learning (CDCL) algorithm
SAT solvers (Marques Silva, Lynce, & Malik, 2009).

2.2.1 Grounding
overview intelligent grounding techniques

FO(ID ),

refer reader

work Wittocx, Denecker, Bruynooghe (2013) Wittocx et al. (2010).
present basic principle.

vocabulary , partial structure
, returns ground theory 0 strongly

grounder takes input theory
domain

D,

interpreting least

>



244

fiLazy Model Expansion: Interleaving Grounding Search
-equivalent



assume







I.

Theory

T0

called

canonical theory form

grounding





given

I.

Recall

{PT , }.

One way compute grounding using top-down process theory, iteratively
applying grounding steps direct subformulas rule formula hand. grounding
Let [x]
let domains x. Tseitin transformation replaces
1
atom (x), new |x|-ary predicate symbol called Tseitin symbol, extends
rule x : (x) . new theory strongly -equivalent

algorithm may replace subformulas new predicate symbols follows.
formula

original one (Vennekens et al., 2007).
procedure one_step_ground, outlined Figure 1, performs one step grounding process. Called formula rule



canonical form, algorithm replaces

G
(rules formulas) possibly non-ground part R (rules). formula, G
consists ground formulas. Replacing returned ground formulas extending
returned rules produces theory strongly voc(T )-equivalent original.
rule , G consists ground rules, replacing sets returned
rules results theory strongly voc(T )-equivalent original.
direct subformulas Tseitin symbols returns pair consisting ground part

Algorithm 1: one_step_ground algorithm.
1 Function one_step_ground (formula rule )
2
switch
3
case []P return h{}, i;
4
case P
5
6
7
8
9
10
11
12
13
14
15
16

hG,

:= one_step_ground( );

return h{P gG g}, i;
case 1 . . . W
n
return h{ i[1,n] Ti }, {Ti | [1, n]}i;
case 1 . . . n
return h{Ti | [1, n]}, {Ti | [1, n]}i;
case x : P (x)
return h, {P (x)[x/d] [x/d] | D}i;
case x :W[x]
return h{ dD T[x/d] }, {T[x/d] [x/d] | D}i;
case x : [x]
return h{T[x/d] | D}, {T[x/d] [x/d] | D}i;


V

Grounding theory boils applying one_step_ground sentence
(which copies

PT

PT

ground part) rule theory repeatedly applying

one_step_ground returned rules

R (all returned sentences rules G ground).

use ground refer algorithm overall process.
1. Tseitin (1968) introduced symbols part normal form transformation.

245

fiDe Cat, Denecker, Stuckey & Bruynooghe
Various improvements exist, returning



returning

>/

atoms interpreted





conjunctions whenever false conjunct encountered (analogously

disjunctions quantications).
Also, algorithm one_step_ground introduces large number Tseitin symbols. Stateof-the-art grounding algorithms use number optimizations reduce number
symbols. optimizations directly applicable techniques presented
paper, start naive one_step_ground algorithm. Section 5, present
optimized version one_step_ground introduces fewer Tseitin symbols hence
results smaller groundings.

3. Lazy Grounding Lazy Model Expansion
lazy grounding refer process partially grounding theory
lazy model expansion (lazy MX) process interleaves lazy grounding

use term
term

model expansion grounded part. Section 3.1, formalize framework
lazy model expansion

FO(ID )

theories; Section 3.2, formalize instance

framework basis current implementation; Section 3.3, illustrate
operation.

3.1 Lazy Model Expansion FO(ID) Theories
Given canonical theory

= {PT , }

input structure

Iin ,

models expanding

Iin

searched interleaving lazy grounding search already grounded part.
rst focus lazy grounding.
Apart initial step moves

PT

grounded part, input step

consists set rules still grounded, already grounded theory three-valued
structure expansion initial input structure.
subsequent grounding step replace non-ground rules ground rules might
introduce new rules. Hence, state grounding includes set
set



(the

delayed denition )

g

ground rules

(possibly) non-ground rules. denitions

g (in follows abbreviated gd ) voc()-equivalent
original denition hence, gd total. grounding procedure guarantee
that, times, g total.
Given partial structure Iin rule sets g , key idea behind lazy
model expansion (i) use search algorithm search model g
expansion Iin PT true; (ii) maintain justication J literals
true dened justied gd J consistent ; (iii)
interleave steps (i) (ii) move parts g literal dened
property

needs justied cannot justied.

hg , , J, Ii
yet grounded, justication J ,
, g = , J empty graph.

Thus, control lazy model expansion, suces maintain state
consisting grounded rules
three-valued structure

I.

g ,

Initially,

rules





Iin ,

Lazy model expansion searches space

Denition 3.1 (Acceptable state).
tence

acceptable

states.

tuple hg , , J, Ii theory atomic senPT , total denition , input structure Iin acceptable state (i) gd , g

246

fiLazy Model Expansion: Interleaving Grounding Search




gd strongly voc()-equivalent , (ii) domain
, (iii) J justication gd , (iv) expansion
L literals true dened justied J , (vi) JL ,
literals L, consistent .

total denitions

atom dened


v

Iin ,

( ) set

justication

Example 3.2.

g



Consider theory

{PT , },





denition



PT T1 T2 T3 .



x : Q(x).
1

T2 x : R(x).




T3 x : Q(x).
Let



structure

{PT , T1 }

(hence,

T2



T3













unknown),

g







denitions consisting rst rule remaining rules, respectively. Furthermore, let

J {T1 {Q(d) | D}}. tuple hg , , J, Ii acceptable
T1 literal dened justied J .

state. Indeed,

already said, lazy model expansion algorithm starts initial state

, = , J = , = Iin ,

acceptable dened literals unknown

state, either renes



propagation choice, backjumps.

g =

Iin .



resulting

state unacceptable, repair operation restores acceptability; steps described
Section 3.2.


gd .

algorithm tries compute acceptable state



Corollary 2.11, would entail model

PT

justied

exists; computed

eciently well-founded model computation. intermediate states, justication
may non-total

PT ,

iii),

Note that, (
justied

.

contain unfounded literals, inconsistent.

justication must

gd .

Indeed, assume literal

justication graph leaf dened

g

l



depends positively negatively l. every attempt extend justication graph

l gd might fail, e.g., forbidden
cycle. Consider, e.g., denitions g = {P Q} = {Q P }. case,
would correct take P justication Q true, even though valid
justication within . Indeed, model exists justies Q full denition gd .
total justication graph justies

Proposition 3.3. Let hg , , J, Ii acceptable state.

gd well-founded model
expands literals true dened (delayed) denition .

Proof.

L

Let

set literals true

justies literals
expands

L.



dened

open literals



state acceptable,

J

Hence, Corollary 2.11, exists well-founded model

L.

Example 3.4 (Continued Example 3.2).
>

.



model

J

(i.e.,

g , PT

interpreted randomly,

well-founded evaluation, assigning

{Q(d) | D}),

derives

T1

true.

Moreover,

true well-founded model. Note

R-atoms

occur





J.

following theorem states obtained expansion model

247

T.

R



fiDe Cat, Denecker, Stuckey & Bruynooghe
Theorem 3.5. Let hg , , J, Ii acceptable state theory = (PT , ) input
structure Iin PT true I|voc(g ) model g . exists
model expands I|voc(g ) .
Proof. I|voc(g )
justication

Jg

model


g

domain literals true
combine one

follows Proposition 2.10 exists

I|voc(g ) .

g

consists

two justications:

follows: dened literal

l



gd ,



J

J



Jg .



l,
Jg

dened

Jc (l) = Jg (l). Jc takes edges either J
dened literal, justication gd .
verify Jc justies PT . First, total PT . Indeed, path PT either
consists literals dened g , branch total Jg g , passes
0
literal l dened , justied J according condition (v) hence
(Jc )l0 = Jl0 total. such, PT cannot reach dened literal gd
Jc undened. Second, Jc contain unfounded literals starting PT .
path PT either path Jg (so well-founded justies g )
tail J (well-founded property (v)). Finally, set literals reachable PT
Jc consistent. see look paths Jc PT : rst follow
Jg consists true literals , may get path J contains
literals consistent . case, impossible reach literal
set

Jc (l) = J(l);

Jc

g .

justies every true dened literal

otherwise, set

negation.
follows Proposition 2.8 exists model


PT

true. Since

gd

expands

I|voc(g )

gd strongly equivalent , proposition follows.

achieved well-founded evalstarting two-valued open(gd )-

Recall eectively computing model
uation

gd ,

polynomial data complexity,

structure expanding

I|voc(g )

(Chen & Warren, 1996).

theorem, required
compute two-valued model
justication justies

PT .

g .



model

g .

Actually, need

suces search partial structure

So, relax requirement expense

maintaining justications literals true



dened

g .

Corollary 3.6. Let hg , , J, Ii acceptable state theory

= {PT , } input

structure Iin PT true J justies PT gd . exists
model expands I|S set dened literals JPT .
g expanding Iin PT true implies lack models
g model expanding Iin , unsatisable
core, i.e., set rules g model exists expands Iin . Hence,
unsatisable core = (PT , ). nd unsatisable core, one can, example,
Failure nd model





expanding

Iin .

Indeed,

use techniques described Torlak, Chang, Jackson (2008).

3.2 Practical Justication Management FO(ID) Theories
Roughly speaking, lazy model expansion framework consists two components.
one hand, standard model expansion algorithm operates

{PT , g } and,
gd lazily

hand, justication manager maintains justication

248



fiLazy Model Expansion: Interleaving Grounding Search
grounds

.

Lazy model expansion performs search space acceptable states

aims reaching state Theorem 3.5 (or Corollary 3.6) applicable. avoid slowing
search model expansion, work done justication manager
lazy grounding must limited. achieve this, designed system
justication manager access grounded denition

g

need restore

state search algorithm backtracks current structure
manager access



g

particular, literal dened

I.

justication

maintains justications restricted

.



allowed direct justication. justication

manager maintains following properties:



Literals direct justications either open



direct justications
structure



J

gd

dened

.

kept consistent current

I.

justication graph dened

J

unfounded literals total.

distinguish acceptable states meet additional requirements acceptable
states dened Denition 3.1, call

Denition 3.7

(Default acceptable state)

.

default acceptable states ; dene as:

state



hg , , J, Ii

default acceptable

state acceptable state and, addition, ( ) literals direct justications either
open

gd

dened

,

ii

( )

J

justies set literals

J

dened.

follows default acceptable states satisfy two extra conditions: justify
literals dened
consistent.



terms literals dened

g ,

dened

,

consistent.

J



true



set literals

acceptable state, suces literals

J

Since default acceptable states acceptable states,

Theorem 3.5 Corollary 3.6 hold default acceptable states.
standard model expansion, main state-changing operations make



precise (by making literals true, either choice propagation) make



less precise (by backjumping).

model expansion modies






',

= hg , , J, Ii default acceptable state
0
new state hg , , J, necessarily

default acceptable state. following propositions identify situations acceptability
preserved.

Proposition 3.8. Let hg , , J, Ii default acceptable state, L set literals unknown
0 consistent structure L. (i) literals L either dened
direct justication J (ii) direct justication J contains negation
literal L, hg , , J, 0 default acceptable state.
Proof.



literals true

( ) literals true


J

consistent

literals true

I'

I'

I,



direct justication, follows
direct justication. justications
consistent '. Hence, J justies

dened

dened

ii

then, ( ),

dened

.

Proposition 3.9. Let hg , , J, Ii default acceptable state. hg , , J, 0
0 <p default acceptable state.

249

fiDe Cat, Denecker, Stuckey & Bruynooghe
Proof.


I, J

J

justication

justies literals dened

justies literals dened



true

default acceptable state, literals dened
literals dened
hidden loops


g



,

.

gd .



true

I.



I'

subset

'.

g

allowed direct justications

restriction quite limiting (see next section) avoid

loops detected maintaining justication

current implementation do. Several methods exist

l dened g allowed direct
, provided established l's justication cannot loop gd .
One case body rule l dened literals. step analyze
dependency graph: literal dened g allowed direct justication
literal dened provided literals belong strongly connected

extend class default acceptable states. Literals
justications

component dependency graph. case, cannot part cycle.

3.3 Example
rest section, illustrate behavior lazy model expansion articial
example, constructed way main features illustrated. next section,
processes involved described detail.
focus operation justication manager interaction
solving process. manager activated unacceptable state, either solver
falsies literal occurs direct justication

J

l dened
l extend

true literal

justied J . One option repair search justication
J . general problem hard model expansion problem itself,
Corollary 2.11. manager searches
extend

J,

nd one, grounds l's denition moves

example uses theory



shown

locally direct justication justies l
g .

states symmetric graph (edge/2) exists

R/1)
= {d1 , . . . , dn }
equality predicate identity relation (below omitted ). Predicates edge, R
root interpreted; R root dened. particular, root dened
singleton {d1 }, specifying root d1 .

least one node root node (predicate
root node. input structure

P












PT
C1
C2
x : root(x)
x : R(x)



root/1)

reachable (predicate

interprets domain

C1 C2
x : root(x) R(x)
(x y) D2 : edge(x, y) edge(y, x)
x = d1
root(x) : edge(x, y) R(y)

(1)
(2)
(3)
(4)
(5)













lazy MX algorithm proceeds follows:
1. initial default acceptable state


hg , , J, Ii



g ,



J

empty,

= .

2. Propagation

{PT , g }

sets





{PT }.

expands structure

conditions Proposition 3.8 longer satised.

250

I,



resulting state

fiLazy Model Expansion: Interleaving Grounding Search
acceptable since

J.

PT

true dened



direct justication

J direct justication PT .
atom PT unique direct justication {C1 , C2 } extending J
restore (default) acceptability since C1 , C2 direct justication J
PT remains unjustied. Therefore, alternative taken rule (1) moved
g . Now, default acceptable state obtained.
One option repair acceptability extend

{PT , C1 , C2 }. C1 C2 justied. Consider
C2 rule (3). edge open, manager build direct justication
{edge(d, d0 ) | (d, d0 ) D2 }, sets negative edge literals true, extends J
(setting positive edge literals true would equally good). justies C2
avoids grounding rule dening C2 .

3. Unit propagation sets
rst

4. Literal

C1

cannot justied (with local approach) since direct jus-

tications contains unjustied dened literals.

However, rule (2) existentially

quantied, one avoid grounding whole rule performing Tseitin transformation isolate one instance ground instance. purpose

d1 :

(root(d1 ) R(d1 ))
(2a)
x \ {d1 } : root(x) R(x) (2b)

illustration, make (bad) choice instantiating



C1


Rule (2a) moved

g

x



default acceptable state reached.

5. acceptable state propagation possible, choice
made.

C1

true, body rule (2a) become true. Preferably

selecting Tseitin (this would trigger grounding), rst disjunct selected
model expansion propagation extends structure
literal

root(d1 )

denition
dening

root

root


{(d1 = d1 )}

dened

unique direct justication

root(d1 ) R(d1 ).

rule (4) cannot justied since
false. manager partially grounds

splits ground rule (4a) non-ground rule (4b)

domain elements:



root(d1 ) d1 = d1 (4a)
x \ {d1 } : root(x) x = d1 (4b)



g . Note root(d1 ) justied {d1 = d1 } gd , hence
root(d1 ) direct justications . Whenever grounding

Rule (4a) moved
safe use

done, justication manager interrupted propagation, infer truth
additional literals, detect inconsistency (which result backjumping).
cases, manager resume revision justication afterwards,
acceptable state reached.
unacceptable (due unjustied

Here, even though resulting state still

R(d1 )),

g
root(d1 ) conict.

creation new rule (4a)

interrupts manager. Propagation using new rule derives

= {PT , C1 , C2 }, subsequent propagation sets structure
{PT , C1 , C2 , root(d1 ), }. Still default acceptable state (T justied),

backtracking





rule (2b) transformed split another instance.



(root(d2 ) R(d2 )) T2
(2ba)
T2 x \ {d1 , d2 } : root(x) R(x) (2bb)

251



fiDe Cat, Denecker, Stuckey & Bruynooghe
g ,

Rule (2ba) moved

rule (2bb) remains

.

state default

acceptable.

T2 , choosing rst disjunct rule (2ba)
R(d2 ). literal root(d2 ) dened ,
justied direct justication {(d2 = d1 )}. literal R(d2 ) cannot justied
direct justication (as edge literals false current justication graph)
rule (5) transformed split instance d2 . Actually, instance

6. Again, search avoids new Tseitin
propagates

root(d2 )



turn disjunctive body complex subformula, avoid grounding
subformula, break two parts introduce another Tseitin.







R(d2 ) root(d2 ) T3
(5aa)


T3 : edge(d2 , y) R(y)
(5ab)
x \ {d2 } : R(x) root(x)





: edge(x, y) R(y)
(5b)
Rule (5aa) moved

g ,

others remain

.

{PT , C1 , C2 , root(d1 ), T, root(d2 ), R(d2 )}, hence propagation rule (5aa) g extends T3 . direct justication justifying
T3 and, hence, rule (5ab) partially grounded splitting d1 case:


T3 (edge(d2 , d1 ) R(d1 )) T4
(5aba)
T4 \ {d1 } : edge(d2 , y) R(y) (5abb)

7. current structure

Rule (5aba) moved

g

rule (5abb) remains

8. search selects rst disjunct

R(d1 ).
it.

literal

Extending

J

R(d1 )

dened

.

T3 's rule body propagates edge(d2 , d1 )
, {root(d1 )} direct justication

direct justication yields acceptable default

root(d1 ) dened g . However, root(d1 ) justied gd ,
J direct justication discussed earlier.
justication manager faces new problem: true literal edge(d2 , d1 ) conict
0
0
2
direct justication {edge(d, ) | (d, ) } C2 (rule (3)). handle
conict, splits aected instance (x = d2 , = d1 ) rule:


C2 (edge(d2 , d1 ) edge(d1 , d2 )) T5
(3a)
T5 (x y) D2 \ {(d2 , d1 )} : edge(x, y) edge(y, x) (3b)

acceptable state, since

making safe extend

g rule (3b) remains . direct justication
{edge(d, d0 ) | (d, d0 ) D2 \ {(d2 , d1 )}}, unaected part direct
justication C2 . restores acceptability.

Rule (3a) moved

T5

set

9. Propagation rule (3a) extends





edge(d1 , d2 )



T5 . literal edge(d1 , d2 ),
T5 (rule (3b)). resolve

true, conict direct justication

it, justication manager partially grounds rule (3b) splits instance

{x = d1 , = d2 } follows.


(3ba)
T5 (edge(d1 , d2 ) edge(d2 , d1 )) T6
T6 (x y) D2 \ {(d2 , d1 ), (d1 , d2 )} :


edge(x, y) edge(y, x) (3bb)

252

fiLazy Model Expansion: Interleaving Grounding Search
g rule (3bb) remains ; T6 inherits direct
edge(d1 , d2 ) removed. Propagation rule (3ba) extends
state acceptable, T6 dened justied.

Rule (3ba) moved
justication


T6 .

now,

T5



resulting

g

consists rules (1), (2a), (4a), (2ba), (5aa), (5aba), (3a), (3ba),

consists rules (4b), (2bb), (5b), (5abb), (3bb). cur{PT , C1 , C2 , root(d1 ), root(d2 ), edge(d2 , d1 ), edge(d1 , d2 ), R(d1 ), R(d2 ),
T, T3 , T5 , T6 }, model PT g .
literals, root(d2 ), R(d1 ) T6 dened . Literal root(d2 ), dened
rule (4b) {(d2 = d1 )} direct justication. Literal R(d1 ), dened rule (5b),
{root(d1)} direct justication. Literal T6 , dened rule (3bb) direct justication
set negative edge literals except edge(d1 , d2 ) edge(d2 , d1 ). obtain
full model theory, extended literals direct justications.

residual denition
rent structure





case, assigns open literals model completed wellfounded model computation

gd .

Actually, done without grounding

denition (Jansen, Jorissen, & Janssens, 2013).

4. Justication Management
Section 3.2, instantiated general framework, developed Section 3.1,
justication manager access

.

example Section 3.3, justi-

cation constructed demand, i.e., time literal needed (dierent) direct
justication, body dening rule analyzed justication extracted.
failed, part rule grounded. called
imagine

global approach,

rules



local approach.

One

considered attempt

select direct justications minimize grounding rules whole. Obviously,
global approach time consuming, applied every time
adjustment justication required. section, describe approaches.
describing algorithms, introduce notations assume normalizations done. function nnf reduces formula negation normal form.

set single element, + used shorthands {s}
S\{s}. J justication, denote J[l d] graph identical J except l
justied d. assume quantiers range single variable variable names


reused formula. Furthermore, assume basic reductions applied
formulas, e.g.,

>

reduces

, x :

reduces

t,

...

4.1 Local Approach
Algorithm 2 shows top level lazy_mx model expansion algorithm, taking input
theory

{PT , }



Iin . Denitions g initialized
initialized Iin . set ground sentences Tg
initial justication J empty. auxiliary (FIFO)

initialized empty.

latter keeps track literals direct

input structure

empty denition, respectively,
initialized fact
queue

qch

PT

justication needs checked.
main loop performs model expansion

Tg g ,

interleaved work

justication manager towards establishing default acceptable state. model expansion

253

fiDe Cat, Denecker, Stuckey & Bruynooghe
part consists propagation (the call propagate), test whether current state
inconsistent (with learning backjumping), test whether model

Tg g

found (returning model justication) choice step

Tg g

selects literal unknown

assigns value.

Propagation returns literals

entailed ground theory (partial) structure, example applying
unit propagation unfounded/wellfoundedness propagation (Marin et al., 2008).
test model performed default acceptable state (i.e., queue

qch

empty). test succeeds, ensures well-founded model computation
expand current structure



extended direct justications literals

model whole theory. choice step takes place default acceptable
state; ensures search space limited state space default acceptable
states.

justication manager activated propagation choice step assigns

literal
valid.



l.
l

calling check_literal, checked whether current justication remains
dened

queue

qch



justication, needs justication added

processing justication manager.



l

0
justication another literal l , justication becomes inconsistent
another justication added

qch .

occurs





l0

needs

processing done selecting

elements queue calling lazy_ground function.

latter function rst

attempts nd (dierent) consistent direct justication l; fails, splits
rule instance dening

l





partially grounds it, hence

g

extended. new

clauses may trigger propagation; therefore processing queued literals interleaved
propagation and, possibly, backtracking . Note backtracking might restore
consistency



direct justication

J(l)

literal

l



qch .

4.1.1 Lazy Grounding One Rule
function lazy_ground, Algorithm 3, checks whether literal
tion; not, simply returns. Otherwise, checks whether

l

l

needs direct justica-

valid justication, i.e.,

one satises invariants detailed below. so, returns; otherwise, passes
rule body used construct justication (the negation dening rule
literal negative) build_djust, function attempts nd valid direct
justication. Besides literal rule body, initial justication, derived
rule body, passed build_djust. latter function successful, justication
updated lazy_ground done; not, direct justication literal

false

l

set

split_and_ground called ground part rule dening l.

going details, rst analyze properties want maintain
current justication
considered part

J

J.

direct justications literals

qch queue
J are:



since might invalid. global invariants



literals unfounded



set literals

J

(recall, negative cycles allowed),

J

consistent.

direct justication

= J(l) J



l

queue, invariants lazy

grounding process are:



contains literals dened

g

(unless literal safely justied

discussed before),

254

gd ,



fiLazy Model Expansion: Interleaving Grounding Search

Algorithm 2: lazy_mx lazy model expansion algorithm.
1 Function lazy_mx (atomic sentence PT , denition , structure Iin )
Output: either model g J false

2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19

20
21
22

Tg

:= {PT };

g

true

:=

;

:=

; J

:=

;

:=

Iin ; qch

:=

L := propagate(Tg g , );
:= L;
foreach l L qch :=check_literal(l,qch );
inconsistent
Tg += learn_nogood(I , Tg );
conict root level return false ;
:= state backjump point;
else qch empty
(l, qch ) := dequeue(qch );
lazy_ground(l);
else model Tg g
return , J ;

else

select choice literal l;



:=

+ l;

qch :=check_literal(l,qch );

Function check_literal (literal l, literal queue qch )
Data: global J Output: updated queue
l dened J(l) = undef qch := enqueue(l,qch ) ;
foreach l0 l J(l0 ) qch := enqueue(l0 ,qch ) ;
return qch ;

Algorithm 3: lazy grounding literal.
1 Function lazy_ground (literal l)
Data: global , J
2
l l dened
3
J(l) exists obeys invariants return;
4
else

5
6
7
8
9
10
11

;



:= body rule dening l;

l negative literal

:= nnf ()
dj := build_djust(l, , init_just(l));
dj 6= false J := J[l dj]; return;

else

J

=

J[l false];

split_and_ground(l);

255

;

fiDe Cat, Denecker, Stuckey & Bruynooghe


literals
queue


qch .

dened



either direct justication

J

belong

qch

invariants imply default acceptable state reached

queue

empty. Indeed, follows invariants current justication total
situation hence literals direct justication justied (Denition 2.6).
Due policy followed queue literals, current justication consistent



literals true



dened



justication, hence

hg , , J, Ii



default acceptable state.

4.1.2 Building Direct Justification
purpose build_djust, Algorithm 4, extend
literal

l

.

dened

I.
formula



l

J

suitable direct justication

literal

J(l)

currently undened



inconsistent

recursive function takes three parameters: ( ) literal

l,

made true direct justication (initially whole body

ii

( )

rule dening literal; note initialization takes negation rule

iii) description direct justication derived far, initialized

literal negative), (

init_just(l). algorithm, assume

dierent quantiers range

dierent variables.
going details, discuss represent direct justications.

Basically,

could represent direct justication set ground literals. However, set
quite large using ground representation might hence defy purpose lazy

hL, Bi L set
B set bindings xi Di xi variable Di
domain. set bindings B = {x1 D1 , . . . , xn Dn } represents set variable
substitutions SB = {{x1 /d1 , . . . , xn /dn } | di Di [1, n]}. set ground
literals represented hL, Bi {l | l L SB }. direct justication
literal P (d1 , . . . , dn ), dened rule x : P (x) , initialized init_just(l)
h, {x1 {d1 }, . . . , xn {dn }}i. eect, B allows identify relevant rule instantiation

grounding.

Instead, represent direct justication pair

possibly non-ground literals

providing appropriate variable instantiation domains, set literals
empty.
build_djust algorithm searches set literals making
recursively calling subformulas
larger justication

.





true.

works

composing results afterwards

set literals found, example none

exists consistent direct justications,

false

returned.

base case formula literal. make literal true, instances
literal set bindings

B

must true, hence, set literals

L

extended

literal itself. resulting direct justication satisfy invariants,
checked call valid: returns

true call valid(l, dj) dj
l J[l dj] satises

(part ) direct justication

satises invariants
invariants

justication.
universally quantied formula
quantied variable.

x D.

x :

true instance

Hence, recursive call, set bindings

B

extended

existentially quantied formula, suces one instance true. Hence,

minimal approach try instance separately one succeeds; fail,

256

false



fiLazy Model Expansion: Interleaving Grounding Search

Algorithm 4: build_djust algorithm.
1 Function build_djust (literal l, formula justication hL, Bi)
Input: B binds free variables
Output: either direct justication false
2
switch
3
case literal
4
valid(l, hL {}, Bi) return hL {}, Bi;
5
else return false ;
6
case x D0 :
7
return build_djust(l, , hL, B {x D0 }i);
8
case x D0 :
9
large(D0 )
10
return build_djust(l, , hL, B {x D0 }i);
11
foreach di D0

12
13

hL0 , B 0 := build_djust(l, , hL, B {x {di }}i);
hL0 , B 0 =
6 false return hL0 , B 0 i;

14
15
16
17
18
19

return false ;
case 1 . . . n
foreach [1, n]

20
21
22
23
24

return hL, Bi;
case 1 . . . n
foreach [1, n]

25

hL0 , B 0 := build_djust(l, , hL, Bi);
hL0 , B 0 = false return false ;
else hL, Bi := hL0 , B 0 i;

hL0 , B 0 := build_djust(l, , hL, Bi);
hL0 , B 0 =
6 false return hL0 , B 0 i;

return false ;

257

fiDe Cat, Denecker, Stuckey & Bruynooghe
returned. Note however want iterate domain element
large, would similar constructing grounding itself. Instead,
extend binding

x D.







large,

Conjunction similar universal quantication, except

explicit iteration conjunct needed. soon one conjunct fails, whole
conjunction fails. Disjunction similar existential quantication small domain.
Note build_djust non-deterministic due choices domain element justify
existentially quantied formula, disjunct justify disjunction.

Example 4.1.

Consider following rule large domain

D.

H x : P (x) (y : Q(x, y) R(x, y))
Assume

J empty
h{P (x)}, {x D}i

loops keep track of.

Applying build_djust

P (x) body chosen.
corresponds direct justication {P (x) | x D}. Alternatively, second disjunct chosen, returns h{Q(x, y), R(x, y)}, {x D, D}i, represents direct
justication {Q(x, y) | x D, D} {R(x, y) | x D, D}.


H

returns

rst disjunct

4.1.3 Partially Grounding Rule
last bit lazy model expansion algorithm handles case justication
found denition literal

l

grounded.

straightforward way

would call one_step_ground rule dening l, store result

g



.

However, many cases operation results much grounding.

Example 4.2.

form x : P (x) situation
P (d). Applying one_step_ground r1 would instantiate
x elements D, resulting |D| rules, fact suces split r1 two rules,
one instance x = one remainder. Another example applies rule r2
form H x : Q(x) R(x) direct justication J(H) = {Q(x) | x D}.
Q(d) becomes false, justication manager may need ground rule. Applying
one_step_ground would instantiate universally quantied x elements .
Instead, better split instance x = introduce Tseitin
remainder, producing H (Q(d) R(d)) g x : Q(x) R(x)
. direct justication obtained incrementally removing Q(d)
H , discussed Section 4.1.5.
Consider rule

r1

justication found atom

split_and_ground algorithm (Algorithm 5) ground part rule dening
given literal
dening



l

l,

say


P .

rst step split rule instance rule

grounded (the call split).

denes


P .

Let

replace rule

additionally return rule


P [x/d].

x : P (x) rule
x : P (x)

Afterwards, apply one_step_ground

latter rule add computed rules either

g



. 2

result split_and_ground denition
one. limit ground denition
equivalent

gd



gd ground previous
empty g strongly voc()-

.

2. Recall, head new grounded rule always dierent head already grounded rules.

258

fiLazy Model Expansion: Interleaving Grounding Search
Algorithm 5: split_and_ground algorithm.
1 Function split_and_ground (literal l)
Input: l dened
Result: update g , , J , qch
2
3

r := split(l); // split updates
(0g , 0d ) := one_step_ground(r);
g = g '; = ';

4

Even justication found, better splitting

l

applying

one_step_ground, shown Example 4.2. First, splitting made signicantly
intelligent, discussed Section 4.1.5. Second, improve one_step_ground
ground part expressions possible, describe below.

Improving one_step_ground.
subformulas/instantiations
result consists

|D|

l iterates
x : P (x),

Applying one_step_ground rule

.

example



sentence

new rules many new Tseitin symbols. Instead, depending

value l, sucient introduce one (or some) subformulas, shown
Algorithm 6, extends switch statement one_step_ground two higherpriority cases.



l

true, sucient ground one disjunct/existential instantiation

delay rest Tseitin introduction.

l

false, take similar approach

conjunction/universal quantication.

Algorithm 6: Additional cases one_step_ground algorithm.
1 switch r
2
case l 1 . . . n I(l) =

3
4

5
6
7
8

choose

[1, n];

return h{l }, {T
case l x : I(l) =

W

choose

j{1...n}i j }i;

D;

return h{l [x/d] }, {T
analogous cases









x : }i;
combination I(l) = f .

4.1.4 Algorithmic Properties
Correctness termination presented algorithms discussed following theorem.

Theorem 4.3 (Correctness termination). lazy_mx returns interpretation ,

expanding literals direct justications J , applying well-founded evaluation gd restricting voc(T ) results model . algorithm returns
false , interpretation exists precise Iin satises .

259

fiDe Cat, Denecker, Stuckey & Bruynooghe
Algorithm lazy_mx terminates nite domain D. Otherwise, termination
possible guaranteed.3
Proof.

lazy_mx returns interpretation

I,

model

g



qch

empty. Given

properties split_and_ground, applying lazy_ground literal l, either
valid justication dened
state and, Theorem 3.5,
returns

false ,



g .

gd

qch



empty, default acceptable

expanded model whole theory. lazy_mx

proven

models

Hence

l

hence



g

models

Iin .

case,

Iin .

models expanding

Without calls lazy_ground, search algorithm terminates nite
tion lazy_ground produces ever-increasing ground theory
limit. Hence, lazy_mx always terminates





nite.

g

g ; func-

full grounding

innite, limit

g



innite grounding, termination cannot guaranteed.

4.1.5 Symbolic Justifications, Incremental Querying Splitting
algorithms presented sound complete.

However,

improved taking formulas justications derived account.

Symbolic justications incremental querying.
(subformulas ) formula

Example 4.4.

,

multiple justications exist

grounding delayed.

Consider formula

x : P (x) Q(x),



h{P (x)}, {x D}i

h{Q(x)}, {x D}i justications. that, could derive justication:
D, make either P (d) Q(d) true. Hence, grounding necessary
P (d) Q(d) become false d.





automatically changing build_djust follows:



algorithm allowed select multiple disjunctions / existential quantications
even valid justication already found one (Lines 13 24).



build_djust longer returns justication, symbolic

justication formula



entails original formula. formula built build_djust reects
subformulas/instantiations selected.



,

justication

.
{P (x) | x
x : P (x) Q(x).

derived directly set non-false literals (full) grounding
example, formula

D},


x : P (x) Q(x),

instead justication

build_djust might return justication formula

validity check (valid) extended return false justication formula false.

allowing complex formulas (instead conjunction universally quantied literals), validity check whether formula become false incremental changes




expensive. fact

incremental query

problem. exper-

iments, limit depth allowed formulas use straightforward (expensive)
algorithm evaluates whole formula whenever assignment falsify it.
3. possible change integration

lazy_ground lazy_mx guarantee termination nite

model exists, see Section 5.1.

260

fiLazy Model Expansion: Interleaving Grounding Search
Body splitting.

described Algorithm 3 Section 4.1.3, split simply splits

rule instance denes l, one_step_ground grounds rule instance step step,
accordance structure formula. However, grounding triggered
conict current justication, one_step_ground blind origin
conict.

using conicting literals, one could focus grounding part

formula contributes conict. One restructuring rule part
grounded, contains conict, part grounded,
old justication adjusted still apply.

latter part split

introducing new Tseitins transformation called body splitting. approach
inserted Algorithm 3 call split. this, original justication (call

jold )

passed extra argument split_and_ground.

Example 4.5.

h x : P (x); let h{P (x)}, {x D}i justication h true . P (d) becomes false, easy see split
violating instantiation rewriting original rule h P (d) adding
rule x : P (x). Crucially, justication second part derived
original justication, namely h{P (x)}, {x d}i. second part hence
added justication J rst part added g .
Consider rule

r direct justication jold done ecient way.
v true domain literal partial structure direct justication
rule r contains negation v . implementation binding(s)
justication instantiates v extracted representation
direct justication rule. simplicity, assume {x = d1 , . . . , dn } single
instance. recursive algorithm visits formula body r depth-rst. Whenever
quantication x : encountered x equal xj x, replaced
(x dj : ) [x = dj ]. Tseitin transformation applied left-hand
revision rule

Assume

conjunct algorithm recurses right-hand conjunct remains
binding. new rule dening new Tseitin jold v direct justication. Similarly,
existential quantication replaced disjunction.

result set new rules

new justication sought smaller rule

r0

passed

one_step_ground. Correctness follows fact jold v valid justication, none
new rules contains

Example 4.6.

v,

correctness Tseitin transformation.

Example 4.1, justications sought

H

rule

H x : P (x) (y : Q(x, y) R(x, y)).
J = {Q(x, y) | x D, D} {R(x, y) | x
, l = Q(d1 , d2 ) becomes false, J longer
consistent cannot repaired. J l, however, still consistent ,
justication whole body. hand, J l justication
subformula P (x) : Q(x, y) R(x, y) instantiation x dierent
d1 . Consequently, split quantication x : x d1 x = d1

Assume selected justication

D, D}.



P (d1 )

true

apply Tseitin transformation former. Afterwards, recursively visit latter
formula apply similar reasoning existential quantication. operations

261

fiDe Cat, Denecker, Stuckey & Bruynooghe
(split 1)
x d1

.





P (x)




Q(x, y)

(split 2)

P (d1 )

0 d2

.





R(x, y)
Q(d1 , 0 )

R(d1 , 0 ) Q(d1 , d2 ) R(d1 , d2 )

x : P (x) : Q(x, y) R(x, y) split violating
Q(d1 , d2 ). original justication without Q(d1 , d2 ) justication

Figure 2: rule body
literal

left-hand side splits, justication formula shown blue.
remaining non-justied formula shown red.

formula illustrated Figure 2. result consists following rules,
rule

H

even ground.




H T1 (P (d1 ) (T2 (Q(d1 , d2 ) R(d1 , d2 )))).






T1 x d1 : P (x) : Q(x, y) R(x, y).




: Q(d , y) R(d , y).

2
2
1
1
optimize traversal formula
path taken parse tree

Example 4.7.



,

build_djust extended store

direct justications subformulas.

C1 (x y) D2 : edge(x, y) edge(y, x)
justied, J empty interpret edge. build_djust algorithm recursively
visits body rule edge(x, y) returned valid literal use. Going
one level, store edge(x, y) edge(y, x), selected {edge(x, y)}. Assuming
disjuncts selected, edge(x, y) returned again. Going back
quantications, store that, quantications, selected set relevant
2
domain elements, build_djust returns justication formula (x y) : edge(x, y).
Assume rule

build_djust given access
direct justication.

jold ,

similar optimizations possible repairing

Consider Example 4.6, assume

P (d1 )

unknown

I.



case, left branch Figure 2 transformed rule still valid,

P (d1 ) direct
justication rule H T1 (P (d1 ) (y (D d1 ) : Q(d1 , y) R(d1 , y))),
T1 Example 4.6.

direct justication. right branch, repair select disjunct

4.2 Global Approach
Finding justications using greedy local approach easily lead grounding
necessary. Consider example sentences

262

x : P (x)



x : P (x) Q(x).

fiLazy Model Expansion: Interleaving Grounding Search
Applying local approach second sentence rst (with empty
construction makes atoms

P

J ),

might result

false. applying local approach

rst sentence nds valid justication it; fully grounded. global
approach takes set rules input tries select direct justications


expected

grounding size whole set minimal.

cast task, called

optimal justication problem, problem graph
rule nodes R justication nodes J .

follows. graph consists two types nodes,

justication node symbolic set literals representing possible justication (for

). rule node pair
(t, f , u); pair hr, ti rule r head l
expresses exists direct justication l; pair hr, f exists direct
justication l pair hr, ui r justication.

literals dened rule

hr, ti

r

rule





,

given current partial structure

truth value

three types edges:

Valid edges

rule node

(the negation ) head

Conict edges

hr, ti (hr, f i) justication node j



j

justies

r.



ii

( ) rule nodes rule dierent truth value, ( )

iii) rule node hr, ti (hr, f i)
l (l), (iv) rule node hr, ui,

justication nodes contain opposite literals, (

r

denes


(or

r

l)

l,

justication node contains

denes

l,

justication node contains



l

(a conict

l

hr, ti (hr, f i)

j

needs justication).

Depends-on edges

justication node

contains negative (positive) literals dened
aim select subsets



l

Rsel R



j
r.

Jsel J

rule node





selected rule node connected valid edge least one selected justication node.



conict edges exist pairs selected nodes.



Neither positive mixed cycles exist subgraph consisting valid
depends-on edges selected nodes.

selection

{Rsel , Jsel }

extracted follows.
rule

r



satisfying constraints, initial justication

literal

hr, ti (hr, f i)

l (l)



selected rule. direct justication union

justications justication nodes
edge.

J

given direct justication dened

Jsel

connected

hr, ti (hr, f i)

valid

Moreover, literals dened rules rule node selected

added initial

qch

queue, handled local approach, complete solution

must justication them.

hr, ui

selected, means grounding

instances rule delayed literals denes become assigned.
type problem somewhat related NP-hard

hitting set

(or

set cover )

problem (Karp, 1972): given set top bottom nodes edges them,
task nd minimal set bottom nodes top node edge
least one selected bottom node.

263

fiDe Cat, Denecker, Stuckey & Bruynooghe
hg , , J, Ii, input optimal justication
, node constructed
truth value known ) conict

Given default acceptable state

problem generated follows. rule
three truth values (only one
edges added.

Valid edges justication nodes obtained using (straightforward)

adaptation build_djust returns set possible justications make head
rule true (false). E.g., rule

P (x)

x : P (x) , build_djust called literal
{x D}. Conict depends-on edges derived

binding initialized

checking dependencies justications rules justications.



keep ecient, done symbolic level.

Example 4.8.

PT , C1



C2

x : root(x) R(x)
(x y) D2 : edge(x, y) edge(y, x)
x = d1
root(x) : edge(x, y) R(y)

(2)
(3)
(4)
(5)






Consider theory running example,

propagated true. Denition






C1
C2
x


:
root(x)



x : R(x)











associated optimal construction set input shown Figure 3. Note rule

C1 C2 true ,
root(x) root(x)

nodes, use dened head literals identify rule. Literal
hence one rule node rules (2) (3). Neither
justied

x D,

hence

hroot, ui

tuple.

four solutions subset-maximal respect rule nodes, namely
following rule node selections:

{hR, ui , hroot, ui , hC2 , ti}

(a)

{hR, f , hC2 , ti}

(b)

{hR, ti , hC2 , ti}

(c)

{hC1 , ti , hC2 , ti}

(d)

these, multiple justication selections possible (also shown Figure 3).


C1 ,

select justication

(iv),



C2

choose

(v)



(vi)

(but

both).
objective maximize number selected rule nodes, minimize
expected grounding size.

obtain estimate expected grounding size,

following conditions taken account:



depend size grounding rule.



Assigning multiple justications rule result lower estimate rule
grounded false.



Variables occurring multiple justications result less matching instantiations.



practical applications, number false atoms far exceeds number
true ones model. Hence, positive literals justication higher
cost negative ones.

264

fiLazy Model Expansion: Interleaving Grounding Search
hR, f

h{root(x), edge(x, y)}, {x D, D}i

hR, ui

h{root(x), R(x)}, {x D}i

hR, ti

h{root(x)}, {x D}i

hC1 , ti

h{root(x), R(x)}, {x D}i

hC2 , ti

h{edge(x, y)}, {x D, D}i

hroot, ui

h{edge(x, y)}, {x D, D}i

(i)

(ii))

(iii)
(iv)
(v)
(vi)

Figure 3: graph part input optimal justication problem Example 4.8.

Rule nodes shown left, justication nodes right;

valid edges shown green, conict edges red depends-on edges blue.
readability, conicts justications unknown rule nodes
shown.

approximate expected grounding size function
input rule

r

(with head

h),

J.

takes

n

selected type justication (rule selected ( ),

justication (u), justication
cations

expsize

h (t)

justication

h (f ))

set justi-

function returns expected grounding size rule (size(r), dened

below) weighted depending type justication. weights derived two
estimates:

pval

ptr

probability atom become assigned

probability

n

assigned atom true. Hence, dened formally below, non-delayed rules ( ),

u

full size used; rule without justication ( ) weighted



( ) weighted

ptr ,

product justications
namely

pt

literals

f

false one ( )

j



J.

1 ptr ;

true justication

latter two weights multiplied

factor product sum two terms,

times number negative literals

j.

pval ;

j



1 ptr

times number positive

eect expected size decreases number justications

increases expected size increases justication literals.

expsize (r, n, ) = size(r)
expsize (r, u, ) = size(r) pval
expsize (r, f , J) = size(r) pval (1 ptr )



((1 ptr ) |pos.

lits.

j|

jJ

+ ptr |neg. lits. j|)

expsize (r, t, J) = size(r) pval ptr
((1 ptr ) |pos. lits. j|
jJ

+ ptr |neg.
probabilities, assumed

pval

lots literals get value,

lits.

j|)

small (currently 0.1) reect hope

ptr

less half, reect atoms

265

fiDe Cat, Denecker, Stuckey & Bruynooghe
often assigned false true. function

size

dened below. function returns

number atoms grounding rule formula, except existential quantication
disjunction. these, take account grounded partially
using Tseitin transformation, taking logarithm total grounding size.

size(L) = 1
size(L ) = size() + 1
size(x : ) = size()
X
size(i )
size(1 . . . n ) =
i[1,n]

size(x : ) = log(D) size()
P

i[1,n] size(i )

size(1 . . . n ) = log(n)

n

Solutions optimal justication problem minimize term

X

expsize (r, t(r), J(r))

rd


t(r)

type (t,

f,



u)



J(r)

justication literal dened

r.

Example 4.9 (Continued Example 4.8). size rule C1 1+log(D)2, C2

1+D2 log(2), root D(1+1), R D(1+log(2)(1+log(D)2)/2.
Consider assigning justication (iv) C1 : results expected cost rule
(1 + log(D) 2) 0.3 1 (as construction relies making R true). Additionally,
would force grounding rule dening R, increasing cost size
rule R. optimal solution problem Figure 3 rule node selection (a)
2
justication (vi) C2 . cost sum (1 + log(2) 0.3 (for justication
(vi)) 1 + log(D) 2 (the expected size rule C1 ). Now, rule C1


passed local approach.
solve optimal justication problem,

IDP's

optimization inference applied

(meta-level) declarative specication task.

4

larger theories

T,

problem

turns quite hard, two approximations considered reduce search
space.

First, number selected justications rule limited 2.

values

size(r)

grow quite large, approximation

standard approach). Rounding integer values applied

dlog(size(r))e

IDP's

Second,

used (a

support oating

point number still preliminary. resulting specication could solved optimality
within seconds tested theories. lazy model expansion, global approach
applied initial phase Tseitin literals representing sentences original
theory propagated true.

5. Heuristics Inference Tasks
section discusses tune lazy grounding search heuristics
underlying SAT solver obtain eective implementation lazy model expansion.
4. specication part

IDP

's public distribution.

266

fiLazy Model Expansion: Interleaving Grounding Search
describe inferences tasks beyond model expansion useful
context lazy grounding. less important issues discussed Appendix A.

5.1 Heuristics
Heuristics play important role lazy grounding algorithms, serve nd
right balance much ground long search. rst discuss
heuristics chosen. Afterwards, discuss alternative approach minimize
grounding.

5.1.1 Balance Grounding Search
algorithms leave room number heuristic choices important
eect performance.

briey discuss choices.

guideline

decisions, following principles used:



Avoid leaving search process without enough information make informed
decision; example, avoid losing much (unit) propagation introducing
many Tseitin symbols.



Prevent creating grounding large; may example happen
result long propagate-ground sequence.

Recall, goal create minimal grounding, solve model expansion problems
avoiding large grounding.
Below, introduce number parameters aect heuristics.

exact

values used experimental evaluation parameters introduced specied
Appendix A.
split_and_ground, handling disjunction existential quantication,
choice many disjuncts expand. expand one instantiation time
rule

h x : P (x),

done Algorithm 6 (lines 3 6), iterative application results

ground theory

h P (d1 ) T1
T1 P (d2 ) T2
T2 P (d3 ) T3
.
.
.

Tn x \ {d1 , d2 , . . . , dn } : P (x).
SAT-solver MiniSAT, used


P (di )

IDP

system, initially assigns

atoms; choice triggers iteration propagation grounding.

f





resulting thrashing behavior reduced somewhat, grounding compact
grounding introduces

n

disjuncts time:

h P (d1 ) . . . P (dn )
x \ {d1 , d2 , . . . , dn } : P (x).

267

fiDe Cat, Denecker, Stuckey & Bruynooghe
remedy this, two search-related heuristics changed. First, initial truth
value randomized, favoring false (as models, many atoms false
true). Second, search algorithms typically

restart

(ever-increasing) threshold

number conicts, sometimes caching truth value assigned atoms (

polarity caching ).

allows solver take learned information account search heuristic
staying approximately part search space.

case lazy grounding,

might want jump another part search space come across long
propagate-ground sequences. end, introduce concept

randomized restarts,

take place (ever-increasing) threshold number times

g

extended

randomly ipping cached truth values.
addition, build_djust always returns

false

estimated formula

small grounding. Indeed, grounding formulas help search. Whether formula
considered small determined terms (estimated) grounding size.
strategy used split_and_ground:



whenever formula one_step_ground

would applied small, ground applied instead, completely ground formula.

5.1.2 Late Grounding
Grounding applied search process soon unit propagation taken place.
result focus current location search space, danger
grounding much solution part space. Alternatively, could
apply opposite strategy, namely ground late possible: apply additional
grounding search algorithm terminates without ever found model
acceptable default state. strategy well-known elds incremental proving
planning, domain (number time steps) increased search
previous, smaller bound nished. guarantees minimal grounding. prototype
strategy implemented

IDP

good results planning problems.

5.2 Related Inference Tasks
bulk paper focuses model expansion (MX)
solutions structures two-valued

voc(T ).

FO(ID )

theories

T,



Often, one interested

small subset symbols voc(T ). example case model generation
SO(ID), language extends FO(ID) existential quantication relations.
SO(ID ) problem P1 , . . . , Pn : initial structure , relation symbols P1 , . . . ,
Pn , FO(ID) theory, solved model generation FO(ID) theory
initial structure dropping interpretation symbols P1 , . . . , Pn
models. Another example query evaluation FO(ID ): given theory , initial
structure formula free variables x (all FO(ID )), purpose evaluating
query hT , I, nd assignments domain elements x model
exists expands [x/d] true. solve model expansion
FO(ID ), new predicate symbol introduced answers query tuples

domain elements true model theory extended
sentence x : (x) denition {x : (x) }.
cases, approaches using (standard) model expansion compute total interpretation afterwards drop unnecessary information, quite inecient. Lazy model

268

fiLazy Model Expansion: Interleaving Grounding Search
expansion save lot work partially grounding theory. However,
model found grounded part, justications remaining denitions
used expand structure model full theory.

Although expansion

obtained polynomial time, still inecient afterwards large part model
dropped.
remedy this, dene variant model expansion task, denoted

T,

restricted

MX.

additional list symbols O,
5
called output symbols. Solutions structures two-valued symbols
expansion exists extends model . Adapting lazy
Restricted MX takes input theory

structure

grounding solve restricted MX done analysis justications
need added (completely) structure, splitting

gd

multiple denitions

evaluating dening output symbols symbols depend (using
stratication argument).
above-mentioned inference tasks cast trivially restricted MX problems
lazy restricted MX greatly improves eciency respect ground-and-solve,
shown experimental section.
extension

FO(ID )



procedurally interpreted

symbols (De Cat et al., 2014)

provides another class interesting problems. predicate symbols xed interpretation, know whether tuple belongs predicate, procedural function
executed. approach provides clean way combine declarative procedural specications. Consider example symbol

isP rime(N)

interpreted

procedure executes ecient prime-verication algorithm returns true
given argument prime. generally interested complete interpretation

isP rime, cast restricted MX problem isP rime O.

Solving

problem using lazy grounding benet executing associated function



search relevant atoms

isP rime(d).

task, show experimental

evaluation next section.

6. Experiments


IDP

system state-of-the-art model expansion engine, observed

previous Answer-Set Programming competitions (Denecker et al., 2009; Calimeri et al., 2014;
Alviano et al., 2013). lazy model expansion algorithms presented paper
implemented

IDP

system, extending existing algorithms (De Cat, Bogaerts,

Devriendt, & Denecker, 2013).
current implementation incomplete sense cycle check justications implemented yet. aects inductive denitions non-inductive
ones replaced FO formulas completion.

workaround

lack cycle check, build_djust, function constructs direct justication, returns
false rules dening inductive predicates. consequence, instance rule
immediately grounded, although lazily, domain atom dened rule assigned value. Another consequence inductively dened predicates cannot used
justications rules. aects three benchmarks ASP competition (de5. Within ASP community, sometimes referred show predicates.

269

fiDe Cat, Denecker, Stuckey & Bruynooghe
scribed Section 6.2), namely

Reachability, Sokoban



Labyrinth.

these,

grounding might delayed even complete implementation.
section organized follows. Section 6.1, evaluate overhead completely
grounding theory using presented approach. Section 6.2, evaluate eect
lazy grounding number benchmarks ASP competition.

Section 6.3,

number additional properties presented algorithms demonstrated.
tested three dierent setups:
(referred

g&s), IDP

IDP

standard ground-and-solve approach

lazy model expansion (lazy) award-winning ASP

system Gringo-Clasp (ASP). used

IDP

version 3.2.1-lazy, Gringo 3.0.5 Clasp 2.1.2-st.

parameters lazy grounding algorithms discussed Section 5.1, values
used experiments documented Appendix A. experiments Sections 6.1
6.3 run 64-bit Ubuntu 13.10 system quad-core 2.53 GHz processor
8 GB RAM. Experiments Section 6.2 run 64-bit Ubuntu 12.10 system
24-core 2.40-Ghz processor 128 GB RAM. timeout 1000 seconds
memory limit 3 GB used; out-of-time indicated

T,

out-of-memory

M.6

6.1 Eect Grounding Time
Lazy grounding may reduce grounding size time causes overhead. instance,
expect (naive) incremental querying justications costly discussed previously. aim section quantify overhead caused lazy grounding.
experiments compare grounding time standard IDP system


naive

instance lazy grounding algorithm forced generate complete

grounding starting search. instance obtained standard algorithm using small changes: shortcut ground small formulas turned
o, disjuncts instances existentially quantied formulas grounded one one,
dened literal enqueued lazy grounding soon appears

g .

comparison,

measure cost standard lazy grounding algorithm computes partial
groundings.
devised six benchmarks test various aspects novel algorithm. benchmark simple theory two sentences simple solve. benchmarks
designed measure cost dierent aspects lazy grounding: delaying resuming grounding, querying needed resume grounding, splitting formulas, etc.
Specically, tested aspects following:
1. Overhead delaying resuming grounding case existential quantier
large domain.

sentence

n disjuncts; naive lazy
n 2 Tseitin symbols.

clause
introduces

x : P (x).

Standard grounding creates single

grounding grounds formula piece piece

2. Overhead case inductive denition,

{x : P (x) P (x) Q(x)}.

standard grounding naive lazy grounding construct ground rule



P (d)

atom.
6. Benchmarks, experimental data complete results available

krr/experiments/lazygrounding/jair.

270

http://dtai.cs.kuleuven.be/

fiLazy Model Expansion: Interleaving Grounding Search
3. Overhead case universal quantication.
standard grounding creates

n

sentence

x : P (x).



atomic formulas, naive lazy grounding splits one

instance time introduces

n2

Tseitin symbols.

4. Lifted Unit Propagation (LUP) (Wittocx et al., 2010, 2013) important preprocessing step reduce grounding size. Concretely, applying LUP rules

x : R(x)
x : R(x) : P (x, y)
derives second formula follows rst hence need
grounded all. theory used check whether LUP remains equally important
system lazy grounding.

x :
R(x) : P (x, y). Standard grounding creates formula instance
x Tseitin grounding : P (d, y). Naive lazy grounding creates
extra Tseitin instance x extra set Tseitins piece piece
grounding subformula : P (d, y).

5. Overhead case nested universal quantication. sentence form

6. Overhead incremental querying case symbolic justication validated. sentence

x : R(x) S(x),

identical justication formula.

formula validated checking falsity query
query re-evaluated time

R-atom



-atom

x : R(x) S(x).



falsied.

6.1.1 Results
Experiments done predicates

P



Q

arity 3

R





arity 2,

domains size 10, 20, 30, 40 50. None predicates symbols interpreted
structure.
experiments, overhead time required solve initial optimization
problem (for global approach) always around 0.02 seconds, negligible.
results rst three experiments shown dierences standard
grounding naive lazy grounding negligible.

expected experiment 2,

experiments 1 3, shows actual implementation eliminates overhead
Tseitins quantiers nested. three experiments, standard lazy
grounding able justify formulas without grounding hence fast almost
insensitive domain size. shown Figure 4, dierence standard
grounding naive lazy grounding experiment 4. cases, use LUP
big impact size grounding hence time. experiment 1 3
showed top level quantier create overhead lazy grounding, experiment 5
shows hold anymore nested quantiers naive lazy grounding
substantial overhead compared standard grounding. Note overhead
worst case.

Tseitins justied, denitions grounded,

explains normal lazy grounding faster standard grounding insensitive
domain size.

Experiment 6 shows complex justication formula causes

signicant overhead naive lazy grounding. here, overhead worst case

271

fiDe Cat, Denecker, Stuckey & Bruynooghe

4. Grounding bounds

5. Nested universal quantification

16

6. Complex justification, shared variables
4.5

14

ground without LUP
ground LUP
naive lazy ground without LUP
naive lazy ground LUP
lazy ground LUP

14
12

ground
naive lazy-ground
lazy-ground

12

ground
naive lazy-ground
lazy-ground

4.0
3.5

10
3.0

8

Seconds

Seconds

Seconds

10
8

6

2.5
2.0

6
1.5
4

4

1.0

2

2

0

0
0

10

20

30

40

50

0.5
0.0
0

10

Domain size

20

30

Domain size

40

50

0

10

20

30

40

50

Domain size

Figure 4: Time overhead naive lazy grounding ground-and-solve completely
grounding input theory, benchmarks 4, 5 6. time includes grounding, solving time needed nd justications. time required
standard lazy grounding algorithm shown comparison.

visible normal lazy grounding. Still, important part future research reduce
overhead incremental querying complex justication formulas.

6.2 ASP Competition Benchmarks
Second, selected benchmarks previous ASP competitions evaluate lazy
grounding algorithm realistic setting. Many benchmarks solutions competition carefully ne tuned speed minimal grounding. Lazy grounding usually
unable substantially reduce grounding theories and, due overhead,
slower standard ground solve. reason, sometimes selected
modelings benchmarks natural less optimized time grounding size. justify ground aim work improve inference
declarative

modeling

(De Cat et al., 2014), emphasis developing intricate

encodings, modeling problem close natural language specication.
selected following problems (see competition websites complete descriptions). consist problems known hard, order evaluate eect
lazy model expansion search, problems typically result large grounding.

Reachability:

Given directed graph, determine whether path exists two

given nodes.

Labyrinth:

planning problem agent traverses graph moving

connected nodes reach given goal node. addition, graph manipulated
change connectedness.

Packing:

Given rectangle number squares, squares grid

without overlaps.

Disjunctive Scheduling:

Schedule number actions given earliest start

latest end time additional constraints precedence disjointness.

272

fiLazy Model Expansion: Interleaving Grounding Search
# inst.

# solved

g&s

benchmark

Sokoban
Disj. Sched.
Packing
Labyrinth
Reachability
Stable Marr.
Graph Col.

50

44

21

5

lazy
25

50

44

21
44

261

83

72

16

2

106

21

60

16
94

34

12

avg. time (sec.)

ASP

50

g&s

lazy

ASP

102

59

5

130

207

6

173

121

20
5

196

245

181
40

141
4

110

12

5

643

402

18

211

21

437
44
85

Table 1: number solved instances ASP benchmarks average time taken
solved instances. Dierent solvers solve quite dierent sets instances.

Sokoban:

planning problem robot push number blocks goal

positions, constrained 2-D maze.

Graph Colouring:

Given graph, assign colour nodes (from given set colours),

connected nodes colour.

Stable Marriage:

Given set men women set preferences, nd

stable assignment: swap results better match.
these, used instances 2011 2013 competitions, except
2013

Reachability

instances, huge data les none systems

Stable Marriage, Graph Colouring Reachability,
Packing Disjunctive
IDP
Scheduling, constructed natural FO() encoding made faithful translation
ASP. complex benchmarks Labyrinth Sokoban, used original
FO()IDP Gringo-Clasp's ASP specications submitted 2011 competition.

designed handle.



based encodings available ASP-Core-2 encodings.

lazy model expansion, replaced cardinality expressions FO encoding
former justications derived yet; increases size full grounding.

6.2.1 Results
number solved instances average time shown Table 1; average grounding
size

IDP

7

setup shown Table 2.

time grounding size, unsolved instances

Reachability (9 times g&s,
ASP), Disjunctive Scheduling (6 times ASP) Labyrinth (160 times g&s,
ASP), Packing (4 times g&s, 4 times lazy, 30 times ASP) Stable
Marriage (66 times ASP); unsolved instances caused time-out.8
taken account. Memory overows happened
9 times

7. Grounding consists variable instantiation interleaved formula simplication (e.g., dropping false
disjuncts, true conjuncts, replacing disjunctions true disjuncts true conjunctions false
conjunctions false, etc). simplication steps may seriously reduce grounding size.
8.

IDP

automatic symmetry breaking, cause dierence

Colouring.

273

g&s



ASP



Graph

fiDe Cat, Denecker, Stuckey & Bruynooghe
ground size (# atoms)
benchmark

Sokoban
Disj. Sched.
Packing
Labyrinth
Reachability
Stable Marr.
Graph Col.

g&s
2.65 104
5.17 106
3.86 107
1.68 106
2.87 107
2.11 107
1.15 104

lazy
2.90 105
2.72 106
1.69 107
1.38 106
1.61 104
1.20 107
1.58 104

ground time

ASP
4.63 104
8.04 105
4.53 106
3.55 105
1.35 106
3.36 106
2.80 104

Table 2: average grounding size number
marks, setups.
taken.

g&s



ASP,

lazy

solved

g&s(sec.)

ASP

2.0
129.7
165.6
101.0
109.7
642.7

0.1

(sec.)

0.3
0.7
4.7
2.3
14.5
3.2
0.1

instances ASP bench-

setup, size nal ground theory

average grounding time shown.

results show lazy model expansion solved instances setups
four seven cases. cases, problems got solved signicantly
time threshold.

seven cases, (nal) grounding size smaller

lazy model expansion, orders magnitude one case.

Colouring,

Sokoban, Labyrinth Graph

lazy model expansion outperformed ground-and-solve, indicating

Sokoban,
lazy grounding size even higher g&s (possible due FO encoding
cardinalities), indicating large part search space explored. Stable
Marriage, relatively small dierence grounding size g&s lazy leads us
loss information outweighed gain grounding less up-front. E.g.,
nal

believe dierent search heuristic main factor, lazy grounding itself.
experimented

Airport Pickup ASP-2011 benchmark, fairly standard

scheduling problem (transporting passengers taxis taking account fuel consumption)
except upper bound time provided.

9

Hence ground-and-solve approach

would need construct innite grounding. Applying straightforward lazy model expansion resulted grounding large. However, prototype uses
late grounding heuristic described Section 5.1,

IDP

solved one ten instances.

others, grounding problem, search took long
time intervals

1..n

considered get sucient

n

solve problem (even

standard search heuristic).
presented results show that, although often benecial, lazy model expansion
considerable overhead hard search problems. hand, inspecting
outcome experiments, observed class specications instances
solved lazy grounding traditional grounding partially overlap. suggests
might good idea integrate approaches

portfolio

system. system

either select heuristically whether use ground-and-solve lazy model expansion
(based input) running parallel, aborting either one uses much
memory. However, problems considered, lazy model expansion could start search
9. possible derive nite worst-case thresholds Airport Pickup problem. is, however,
part original specication.

274

fiLazy Model Expansion: Interleaving Grounding Search
much earlier ground-and-solve, even though got lost often search.
leads us believe realize full potential lazy grounding, work necessary
developing suitable heuristics (possibly user-specied ones).

6.3 Specic Experiments
addition ASP competition benchmarks, experiments conducted using
crafted benchmarks illustrate specic properties lazy grounding algorithm.
rst part Table 3 shows results scalability experiments.
benchmarks

Packing, Sokoban



Disjunctive Scheduling,

selected simple prob-

lem instance gradually extended domain size orders magnitude: size
grid (Packing) number time points (Sokoban,

Disjunctive Scheduling).



results show instances, lazy model expansion scales much better
ground-and-solve strategies
satisable instances. However,
signicantly.

IDP

Gringo-Clasp satisable well un-

Disjunctive Scheduling solving time still increases

reason lazy heuristics still naive make uninformed

choices often.
mentioned previous section, ASP competition problems typically small
groundings since running benchmarks large system handle
provide useful comparison systems. Hence, evaluated lazy model expansion
number crafted benchmarks grounding non-trivial.
work look practical applications type.

part future

constructed following

benchmarks:

Dynamic reachability,


Lazy evaluation

example described Section 3.3.

procedurally interpreted

prime numbers.

symbols, using simple theory

described Section 5.2, predicate symbol

isP rime/1



interpreted procedure returns true argument prime.

function



predicate encoding



experiment simulates model generation theory unknown domain.

huge domain.

used/1; quantied formulas
x : (used(x) ); model
6
domain size 10 .

unknown domain expressed new predicate

x :

translated

x : (used(x) )



x :

generation simulated model expansion



one, faithful ASP encoding constructed. second part Table 3 shows
results benchmarks. show signicant improvement lazy model expansion ground-and-solve examples: case,
memory overow grounding,


Disjunctive Scheduling,

lazy

g&s



ASP

went

found solutions within seconds. However,

evident lazy approach would benet

improved heuristics: increasing domain size signicantly increases solving time,
instances intrinsically harder.

6.3.1 Closer Inherent Complexity?
modeling phase application, dierent encodings typically tested out,
attempt improve performance locate bugs. modeling experimental

275

fiDe Cat, Denecker, Stuckey & Bruynooghe
benchmark

packing-10
packing-25
packing-50
sokoban-103
sokoban-104
sokoban-105
disj-sched-sat-103
disj-sched-sat-104
disj-sched-sat-105
disj-sched-unsat-103
disj-sched-unsat-104
disj-sched-unsat-105
dynamic reachability
procedural
function
modelgeneration

lazy

g&s

ASP

0.2

2.0

0.1

0.3

2.0

0.1

1.1

10.03

5.8

0.31

0.3

0.1

0.5

20.0

1.1

2.6



68.0

0.39

0.49

0.07
17.44

13.04

16.05

164.18





0.24

0 49

0.09

4.11

16.04

19.85













164.2
0.18
1.24
0.79
0.19

Table 3: solving time additional crafted benchmarks, one instance each.

benchmarks, noticed simplifying theory dropping constraints often resulted
dramatic reduction time lazy model expansion took nd model. Standard
model expansion, hand, much less aected simplications.



opinion, observation, hardly denitive evidence, another indication
presented algorithms able derive justications parts theory
satised cheaply. way, approach able distinguish better problems
inherently dicult problems would large grounding.

7. Related Work
Lazy model expansion oers solution blow-up grounding often occurs
ground-and-solve model expansion methodology

FO(ID )

theories.

Answer Set

Programming (ASP) SAT Modulo Theories (SMT) techniques process theories
large grounding; constraint store Constraint Programming (CP) Mixed
Integer Programming clauses SAT considered equivalent grounded
theory (they often derived quantied descriptions ci

j

< cj



. . . ) become large. Lefvre Nicolas (2009) Ge

de Moura (2009) reported blow-up problem paradigms multitude
techniques developed address it. distinguish four approaches.
First, concerning grounding up-front, research done towards

grounding

static analysis
ii

( )

reducing size

input derive bounds variable

instantiations (Wittocx et al., 2010, 2013), ( ) techniques

compile

specic types sen-

tences compact ground sentences (Tamura et al., 2009; Metodi & Codish, 2012),

iii) detect parts evaluated polynomially (Leone et al., 2006; Gebser et al., 2011;
iv) detect parts relevant task hand (e.g.,

(

Jansen et al., 2013) (

276

fiLazy Model Expansion: Interleaving Grounding Search
context query problems) shown work Leone et al. (2006). Naturally,
approaches used conjunction lazy grounding reduce
size grounding.

IDP,



e.g., lazy grounding already combined ( ) (

Second, size grounding reduced

enriching

language.

iii).

ex-

ample, ASP solvers typically support ground aggregates (interpreted second-order functions
cardinality sum take sets arguments), CP SMT solvers support
(uninterpreted) functions. recently, Constraint-ASP paradigm developed (Ostrowski & Schaub, 2012), integrates ASP CP extending ASP language

constraint

atoms. interpreted constraints CSP problem thus

handled using CP techniques. Various CASP solvers already available, Clingcon (Ostrowski Schaub), Ezcsp (Balduccini, 2011), Mingo (Liu, Janhunen, & Niemel,
2012) Inca (Drescher & Walsh, 2012). technique integrated
Cat et al., 2013).

Inca

IDP

IDP

(De

fact implement Lazy Clause Generation (Ohrimenko

et al., 2009), optimized form lazy grounding specic types constraints.
language HEX-ASP (Eiter et al., 2005) extends ASP, time

external



atoms

represent (higher-order) external function calls.
Third,

incremental approaches

well-known model generation, theorem proving

planning. tasks, domain typically xed advance, part
structure sought, number time steps planning problem (recall
Sokoban example introduction). approach typically works grounding
problem initial guess (the number elements in) domain.

Afterwards,

search applied; model found, domain extended grounding
done. iterated model found bound maximum domain size
hit (if one known).

technique applied, e.g., prover Paradox (Claessen &

Srensson, 2003) ASP solver IClingo (Gebser et al., 2008).
Fourth, closest lazy grounding itself, large body research devoted
delaying grounding specic types expressions necessary (for example
result propagation). Propagation techniques rst-order level delay grounding
propagation ensues researched within ASP (Lefvre & Nicolas, 2009; Dal
Pal et al., 2009; Dao-Tran et al., 2012) within CP (Ohrimenko et al., 2009).



techniques used conjunction lazy grounding derive intelligent
justications specic types constraints presented here. example, Dao-Tran et
al. presented ecient algorithm bottom-up propagation denition. Within
SMT, various theory propagators work lazily transforming theory SAT,
theory Bit Vectors Bruttomesso et al. (2007).

Ge de Moura (2009)

investigated quantier handling combining heuristic instantiation methods research
decidable fragments FO theories, eciently checked models.
Within ASP, work done goal-directed reasoning. Bonatti, Pontelli,
Son (2008) Marple, Bansal, Min, Gupta (2012) demonstrate approaches,
style SLD resolution, apply top-down instantiation answer queries innite
domains. Saptawijaya Pereira (2013) extend abduction framework lazily generate
part relevant sentences. search algorithms, justications (or

watches )

used

derive constraint result propagation already satised, hence need
checked propagation phase. Nightingale et al. (2013) show maintaining
(short) justications signicantly reduce cost propagation phase.

277

fiDe Cat, Denecker, Stuckey & Bruynooghe
fact, well-known technique already exists combines search lazy instantiation quantiers, namely

skolemization,

existentially quantied variables re-

placed newly introduced function symbols.

Universal quantications handled

instantiating introduced function symbols.

Reasoning consistency can,

e.g., achieved congruence closure algorithms, capable deriving consistency without eectively assigning interpretation function symbols.

techniques

used Tableau theorem proving (Hhnle, 2001) SMT solvers (Detlefs, Nelson, & Saxe,
2005).

Formula (Jackson, Bjorner, & Schulte, 2013) interleaves creating ground pro-

gram giving SMT solver, iterating symbolic guesses proved wrong.
Skolemization-based techniques typically work well case small number constants
needs introduced, diculty case relevant domain large. One
see lazy grounding (with support function symbols) could incorporate skolemization adapting rules grounding existential universal quantication. expect
skolemization complementary lazy grounding, in-depth investigation part
future work.
eld probabilistic inference, several related techniques developed
rely lazy instantiation. First, Problog system uses form static dependency
analysis ground (probabilistic) program context given query, constructing
possible ways derive query top-down fashion (Kimmig et al., 2011). Second,
so-called

lazy inference,

applied e.g.

LazySAT

fact that, considered inference, (xed)

(Singla & Domingos, 2006), exploits

default

assumption exists

expression certainly contribute probabilities.

Hence, expressions

assumption certainly holds considered search. Third,

cutting plane inference

(Riedel, 2009) applies lazy inference interleaved setting,

constructing part program assumptions satised.

8. Future Work
Several aspects presented work need investigation. One aspect extending
support lazily ground complex expressions, including aggregate expressions

P
( xD P (x) f (x)) > 3,
atom P (d) true, , P

(nested) function terms. Consider example sentence
expresses sum terms
predicate

f

f (d)



function, larger 3. One observe necessary

ground whole sentence up-front.
(hence positive), set

example,

{P (d1 ), f (d1 ) > 3}

f

maps natural numbers

minimal justication.

Even easy

justication found, suce grounding part sentence delay

P

P (d1 ) f (d1 )) > 3 ,
P
P
Tseitin symbol dened (
P (d1 ) f (d1 )) + ( xD\d1 P (x) f (x)) > 3. Indeed,
model sentence false, original inequality satised.

remainder.

example, create ground sentence

(

second aspect whether advantages grounding earlier, example
guarantee propagation lost, grounding later, possibly reducing size grounding even more. example, consider sentences

P



P ,









large formulas justication found. Instead grounding least one
sentences, might add

P

list atoms search algorithm assign

278

fiLazy Model Expansion: Interleaving Grounding Search
ground either sentences

P

assigned value (it might even

unsatisability detected grounding either one).
Given lazy grounding useful, lazy

forgetting

grounded theory?

ground theory extended making structure precise, ground theory
could reduced backtracking.

storing justication violations

caused grounding, derive grounding forgotten violation
longer problematic (e.g., backtracking). this, algorithm needs developed
tracks grounding/splitting dependencies rules given justications.
closely resembles techniques used tableau theorem proving SMT, theory
hand compacted moving dierent part search space.
approach described lazy grounding applied answer set generation
eld ASP. ASP, logic program stable semantics seen one rule
set, single denition. However, ASP programs satisfy major condition
apply lazy grounding. Indeed programs typically non-total, due presence
constraints rules form

p np, np p



choice rules

result

multiple stable models. However, described Denecker et al. (2012), practical
ASP programs partitioned set choice rules, set

total

denitions set

constraints (the so-called Generate-Dene-Test partition). ASP program
GDT-partitioned, translated straightforwardly equivalent

FO(ID )

theory

contains total denitions. suggests way apply lazy grounding
ASP programs.

9. Conclusion
Solvers used domains SAT, SMT ASP often confronted problems
large ground. Lazy model expansion, technique described paper,
interleaves grounding search order avoid grounding bottleneck. technique
builds upon concept justication, deterministic recipe extend interpretation
satises certain constraints. theoretical framework developed lazy
model expansion language

FO(ID ) algorithms presented derive

maintain justications interleave grounding state-of-the-art CDCL search
algorithms.

framework aims bounded model expansion, domains

nite, initial step towards handling innite domains eciently. Experimental
evaluation provided, using implementation

IDP

system, lazy

model expansion compared state-of-the-art ground-and-solve approach.



experiments showed considerable improvement ground-and-solve existing benchmarks
well new applications. main disadvantage less-informed search algorithm,
caused delay propagation introduction additional symbols. possible
solution develop new heuristics portfolio approaches combine strengths
methods. Finally, indicated way proposed methods applied
beyond

FO(ID ),

ASP solvers general.

279

fiDe Cat, Denecker, Stuckey & Bruynooghe
Acknowledgements
research, Broes De Cat funded Agency Innovation Science
Technology Flanders (IWT). research supported FWO-Vlaanderen
project GOA 13/010, Research Fund KULeuven.

NICTA funded

Australian Government Department Communications Australian
Research Council ICT Centre Excellence Program.

Appendix A. Details Algorithms
appendix, mention parameter values well optimizations
reduce grounding overhead and/or improve search. optimization, indicate currently implemented (and part experimental results) part
future work.

A.1 Parameter Values
5.1, number parameters introduced control behavior lazy model
expansion.

Here, provide details values used experimental evaluation.

values set manually, based experience limited number observations
(e.g., extension threshold works similar conict threshold SAT solver).
part future work study impact dierent values.



existential quantication, 10 instantiations grounded time; disjunction, 3 disjuncts grounded time. turned give best balance
introducing many Tseitin atoms grounding much.



initial truth value



initial threshold randomized restarts 100 extensions ground theory.



probability

0.2



f

otherwise.

doubled restart.



formula considered small estimated grounding size

104

atoms.

A.2 Extension FO()IDP
far, described lazy model expansion algorithm function-free
However,

FO()IDP ,

knowledge-base language

IDP

FO(ID ).

system, supports much richer

input language. Besides types use initialize domains supports
(partial) functions, aggregates arithmetic.

current implementation ignores

latter extensions straightforward adaptation build_djust (Algorithm 4):
case literals extended return

FO(ID )

false

literal part function-free

language. example, given rule

justication

Q(f (x))

h x : P (x) Q(f (x)), P (x) used

cannot. functions, option replace

graph predicates preprocessing step. experiments Section 6.2,
functions, any, given input structure hence play role.
part future work extend lazy grounding extensions, especially
functions. Techniques developed SMT Constraint Programming handle (ground)

280

fiLazy Model Expansion: Interleaving Grounding Search
atoms containing function symbols useful reduce size grounding improve
search. previous work, techniques integrated

IDP

system (De Cat

et al., 2013) certainly worthwhile fully integrate lazy grounding.

A.3 Cheap Propagation Checks.
lazy_mx, checked assigned literal whether dened



whether

violates justications. implement cheaply, implementation maintains
mapping literals

g .

states whether literal dened



lists

justications negation occurs. mapping extended whenever new literal
added

g

maintained whenever justications change.

performance

search loop unaected long literals assigned mapping empty.

A.4 Stopping Early
Algorithm 2, took standard stopping criterion used search algorithms
(Line 14): stop conict-free state



two-valued symbols

principle, may stop earlier, partial structure

PT .

Indeed, Corollary 3.6 tells us





Tg g .



admits total justication

expanded model.

dened
irrelevant (in eect, appear justication) trigger grounding
A's denition, turn might introduce new literals dened , causing cascade

considerable impact grounding size. Indeed, assigning truth value atom


unnecessary groundings assignments.
justication

g ,

solver algorithm maintain

cannot know exactly justication exists.

Instead,

implemented algorithm chooses literals watched formula/rule.



stops partial structure unwatched literals may assigned.
shown suces guarantee



admits justication. Hence safe stop

search.

A.5 Approximate Justications
cases, build_djust cannot nd valid justication large formula

I.
false least one atom P
literals already false

example formula

x : P (x),

build_djust returns

false. Instead, adapted build_djust heuristic

check number expected violations. small enough, justication still
returned. Naturally, required check whether real violations,
querying justication formula

I,

apply lazy_ground them.

References
Alviano, M., Calimeri, F., Charwat, G., Dao-Tran, M., Dodaro, C., Ianni, G., Krennwallner,
T., Kronegger, M., Oetsch, J., Pfandler, A., Phrer, J., Redl, C., Ricca, F., Schneider,
P., Schwengerer, M., Spendier, L. K., Wallner, J. P., & Xiao, G. (2013). fourth
Answer Set Programming competition: Preliminary report.
T. C. (Eds.),
Apt, K. R. (2003).

Cabalar, P., & Son,

LPNMR, Vol. 8148 LNCS, pp. 4253. Springer.
Principles Constraint Programming. Cambridge University Press.
281

fiDe Cat, Denecker, Stuckey & Bruynooghe
Balduccini, M. (2011).

Industrial-size scheduling ASP+CP.

Delgrande, J. P., &

LPNMR, Vol. 6645 LNCS, pp. 284296. Springer.
Knowledge Representation, Reasoning, Declarative Problem Solving.

Faber, W. (Eds.),
Baral, C. (2003).

Cambridge University Press, New York, NY, USA.
Bonatti, P. A., Pontelli, E., & Son, T. C. (2008).

Credulous resolution answer set

programming. Fox, D., & Gomes, C. P. (Eds.),

AAAI, pp. 418423. AAAI Press.

Bruttomesso, R., Cimatti, A., Franzn, A., Griggio, A., Hanna, Z., Nadel, A., Palti, A.,
& Sebastiani, R. (2007).
verication problems.

lazy layered SMT(BV) solver hard industrial

Damm, W., & Hermanns, H. (Eds.),

LNCS, pp. 547560. Springer.

CAV,

Vol. 4590

Calimeri, F., Ianni, G., & Ricca, F. (2014). third open answer set programming competition.

TPLP, 14 (1), 117135.

Chen, W., & Warren, D. S. (1996). Tabled evaluation delaying general logic programs.

J. ACM, 43 (1), 2074.

Claessen, K., & Srensson, N. (2003).

New techniques improve MACE-style model

Proceedings CADE-19 Workshop: Model Computation - Principles,
Algorithms, Applications.
nding.

Dal Pal, A., Dovier, A., Pontelli, E., & Rossi, G. (2009). Answer set programming
constraints using lazy grounding. Hill, P. M., & Warren, D. S. (Eds.),
5649

LNCS, pp. 115129. Springer.

Dao-Tran, M., Eiter, T., Fink, M., Weidinger, G., & Weinzierl, A. (2012).

ICLP,

Vol.

Omiga :

open minded grounding on-the-y answer set solver. del Cerro, L. F., Herzig, A.,

JELIA, Vol. 7519 LNCS, pp. 480483. Springer.
Cat, B. (2014). Separating Knowledge Computation: FO(.) Knowledge Base
System Model Expansion Inference. Ph.D. thesis, KU Leuven, Leuven, Belgium.
& Mengin, J. (Eds.),

De

De Cat, B., Bogaerts, B., Bruynooghe, M., & Denecker, M. (2014).
modelling language: IDP system.

CoRR, abs/1401.6312.

Predicate logic

De Cat, B., Bogaerts, B., Devriendt, J., & Denecker, M. (2013). Model expansion
presence function symbols using constraint programming.

ICTAI, pp. 10681075.

IEEE.
De Cat, B., Denecker, M., & Stuckey, P. J. (2012). Lazy model expansion incremental
grounding. Dovier, A., & Costa, V. S. (Eds.),

ICLP (Technical Communications),

LIPIcs, pp. 201211. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik.
Delgrande, J. P., & Faber, W. (Eds.). (2011). Logic Programming Nonmonotonic Reasoning - 11th International Conference, LPNMR 2011, Vancouver, Canada, May 16-19,
2011. Proceedings, Vol. 6645 LNCS. Springer.
Vol. 17

Denecker, M. (1998). well-founded semantics principle inductive denition.
Dix, J., del Cerro, L. F., & Furbach, U. (Eds.),
Springer.

282

JELIA, Vol. 1489 LNCS, pp. 116.

fiLazy Model Expansion: Interleaving Grounding Search
Denecker, M. (2000). Extending classical logic inductive denitions. Lloyd, J. W.,
Dahl, V., Furbach, U., Kerber, M., Lau, K.-K., Palamidessi, C., Pereira, L. M., Sagiv,
Y., & Stuckey, P. J. (Eds.),

CL, Vol. 1861 LNCS, pp. 703717. Springer.

Denecker, M., Bruynooghe, M., & Marek, V. W. (2001). Logic programming revisited: Logic
programs inductive denitions.

ACM Trans. Comput. Log., 2 (4), 623654.

Denecker, M., & De Schreye, D. (1992). Justication semantics: unifying framework
semantics logic programs.

Tech. rep. 157, Department Computer Science,

K.U.Leuven.
Denecker, M., & De Schreye, D. (1993). Justication semantics: unifying framework
semantics logic programs. Pereira, L. M., & Nerode, A. (Eds.),

LPNMR, pp.

365379. MIT Press.
Denecker, M., Lierler, Y., Truszczynski, M., & Vennekens, J. (2012).
mal semantics answer set programming.

ICLP (Technical Communications),

Vol. 17

Tarskian infor-

Dovier, A., & Costa, V. S. (Eds.),

LIPIcs,

pp. 277289. Schloss Dagstuhl

- Leibniz-Zentrum fuer Informatik.
Denecker, M., & Ternovska, E. (2008). logic nonmonotone inductive denitions.

Trans. Comput. Log., 9 (2), 14:114:52.

ACM

Denecker, M., & Vennekens, J. (2014). well-founded semantics principle inductive denition, revisited. Baral, C., De Giacomo, G., & Eiter, T. (Eds.),

KR,

pp.

2231. AAAI Press.
Denecker, M., Vennekens, J., Bond, S., Gebser, M., & Truszczyski, M. (2009). second
answer set programming competition.

Erdem, E., Lin, F., & Schaub, T. (Eds.),

LPNMR, Vol. 5753 LNCS, pp. 637654. Springer.
Detlefs, D., Nelson, G., & Saxe, J. B. (2005).
checking.

J. ACM, 52 (3), 365473.

Simplify: theorem prover program

Technical Communications 28th International Conference Logic Programming, ICLP 2012, September 4-8, 2012, Budapest,
Hungary. Proceedings, Vol. 17 LIPIcs. Schloss Dagstuhl - Leibniz-Zentrum fuer In-

Dovier, A., & Costa, V. S. (Eds.). (2012).

formatik.
Drescher, C., & Walsh, T. (2012). Answer set solving lazy nogood generation. Dovier,
A., & Costa, V. S. (Eds.),

ICLP (Technical Communications),

Vol. 17

LIPIcs,

pp.

188200. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik.
Eiter, T., Ianni, G., Schindlauer, R., & Tompits, H. (2005). uniform integration higherorder reasoning external evaluations answer-set programming.

Kaelbling,

IJCAI, pp. 9096. Professional Book Center.
Mathematical Introduction Logic (Second edition).

L. P., & Saotti, A. (Eds.),
Enderton, H. B. (2001).

Academic

Press.

Logic Programming Nonmonotonic Reasoning, 10th International Conference, LPNMR 2009, Potsdam, Germany, September
14-18, 2009. Proceedings, Vol. 5753 LNCS. Springer.

Erdem, E., Lin, F., & Schaub, T. (Eds.). (2009).

283

fiDe Cat, Denecker, Stuckey & Bruynooghe
Ge, Y., & de Moura, L. M. (2009). Complete instantiation quantied formulas satisabiliby modulo theories. Bouajjani, A., & Maler, O. (Eds.),

LNCS, pp. 306320. Springer.

CAV,

Vol. 5643

Gebser, M., Kaminski, R., Kaufmann, B., Ostrowski, M., Schaub, T., & Thiele, S. (2008).
Engineering incremental ASP solver.
(Eds.),

Garca de la Banda, M., & Pontelli, E.

ICLP, Vol. 5366 LNCS, pp. 190205. Springer.

Gebser, M., Kaminski, R., Knig, A., & Schaub, T. (2011). Advances Gringo series 3.
Delgrande, J. P., & Faber, W. (Eds.),

LPNMR,

Vol. 6645

LNCS,

pp. 345351.

Springer.
Gebser, M., Schaub, T., & Thiele, S. (2007).

GrinGo : new grounder Answer Set

Programming. Baral, C., Brewka, G., & Schlipf, J. S. (Eds.),

LNCS, pp. 266271. Springer.

Hhnle, R. (2001).
(Eds.),

Tableaux related methods.

LPNMR, Vol. 4483

Robinson, J. A., & Voronkov, A.

Handbook Automated Reasoning, pp. 100178. Elsevier MIT Press.

Jackson, E. K., Bjorner, N., & Schulte, W. (2013).

Open-world logic programs: new

foundation formal specications. Tech. rep. MSR-TR-2013-55, Microsoft Research.
Jansen, J., Jorissen, A., & Janssens, G. (2013). Compiling input

3
tabled Prolog rules IDP .

FO() inductive denitions

TPLP, 13 (4-5), 691704.

Karp, R. (1972). Reducibility among combinatorial problems. Miller, R., & Thatcher, J.
(Eds.),

Complexity Computer Computations, pp. 85103. Plenum Press.

Kimmig, A., Demoen, B., De Raedt, L., Santos Costa, V., & Rocha, R. (2011).
implementation probabilistic logic programming language ProbLog.

11 (2-3), 235262.

Lefvre, C., & Nicolas, P. (2009).



TPLP,

rst version new ASP solver: ASPeRiX.

Erdem, E., Lin, F., & Schaub, T. (Eds.),

LPNMR,

Vol. 5753

LNCS,



pp. 522527.

Springer.
Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., Perri, S., & Scarcello, F. (2006).
DLV system knowledge representation reasoning.

Log., 7 (3), 499562.

ACM Trans. Comput.

Liu, G., Janhunen, T., & Niemel, I. (2012). Answer Set Programming via Mixed Integer
Programming.

Brewka, G., Eiter, T., & McIlraith, S. A. (Eds.),

KR,

pp. 3242.

AAAI Press.
Marek, V. W., & Truszczyski, M. (1999).
gramming paradigm.
D. S. (Eds.),

Stable models alternative logic pro-

Apt, K. R., Marek, V. W., Truszczyski, M., & Warren,

Logic Programming Paradigm: 25-Year Perspective,

pp. 375398.

Springer-Verlag.
Marin, M. (2009).

Model Generation ID-Logic.

Ph.D. thesis, Department Computer

Science, KU Leuven, Belgium.
Marin, M., Gilis, D., & Denecker, M. (2004). relation ID-Logic answer
set programming. Alferes, J. J., & Leite, J. A. (Eds.),
pp. 108120. Springer.

284

JELIA,

Vol. 3229

LNCS,

fiLazy Model Expansion: Interleaving Grounding Search
Marin, M., Wittocx, J., Denecker, M., & Bruynooghe, M. (2008). SAT(ID): Satisability
propositional logic extended inductive denitions. Kleine Bning, H., & Zhao,
X. (Eds.),

SAT, Vol. 4996 LNCS, pp. 211224. Springer.

Marple, K., Bansal, A., Min, R., & Gupta, G. (2012). Goal-directed execution answer
set programs. Schreye, D. D., Janssens, G., & King, A. (Eds.),

PPDP,

pp. 3544.

ACM.
Marques Silva, J. P., Lynce, I., & Malik, S. (2009).

Conict-driven clause learning SAT

Handbook
Satisability, Vol. 185 Frontiers Articial Intelligence Applications, pp. 131
solvers.

Biere, A., Heule, M., van Maaren, H., & Walsh, T. (Eds.),

153. IOS Press.
Metodi, A., & Codish, M. (2012). Compiling nite domain constraints SAT BEE.

TPLP, 12 (4-5), 465483.

Mitchell, D. G., & Ternovska, E. (2005).

framework representing solving NP

search problems. Veloso, M. M., & Kambhampati, S. (Eds.),

AAAI,

pp. 430435.

AAAI Press / MIT Press.
Mitchell, D. G., Ternovska, E., Hach, F., & Mohebali, R. (2006).

Model expansion

framework modelling solving search problems. Tech. rep. TR 2006-24, Simon
Fraser University, Canada.
Nethercote, N., Stuckey, P., Becket, R., Brand, S., Duck, G., & Tack, G. (2007). Minizinc:
Towards standard CP modelling language. Bessiere, C. (Ed.),


LNCS, pp. 529543. Springer.

CP'07,

Vol. 4741

Nightingale, P., Gent, I. P., Jeerson, C., & Miguel, I. (2013). Short long supports
constraint propagation.

J. Artif. Intell. Res. (JAIR), 46, 145.

Ohrimenko, O., Stuckey, P. J., & Codish, M. (2009). Propagation via lazy clause generation.

Constraints, 14 (3), 357391.

Ostrowski, M., & Schaub, T. (2012).

12 (4-5), 485503.

ASP modulo CSP: clingcon system.

Riedel, S. (2009). Cutting plane MAP inference Markov logic.

Statistical Relational Learning (SRL-2009).

Saptawijaya, A., & Pereira, L. M. (2013).

TPLP,

International Workshop

Towards practical tabled abduction logic

programs. Correia, L., Reis, L. P., & Cascalho, J. (Eds.),

EPIA, Vol. 8154 LNCS,

pp. 223234. Springer.
Singla, P., & Domingos, P. (2006). Memory-ecient inference relational domains. Gil,
Y., & Mooney, R. J. (Eds.),

AAAI, pp. 488493. AAAI Press.

Son, T. C., Pontelli, E., & Le, T. (2014).

Two applications ASP-Prolog system:

Decomposable programs multi-context systems. Flatt, M., & Guo, H.-F. (Eds.),

PADL, Vol. 8324 Lecture Notes Computer Science, pp. 87103. Springer.

Tamura, N., Taga, A., Kitagawa, S., & Banbara, M. (2009). Compiling nite linear CSP
SAT.

Constraints, 14 (2), 254272.

285

fiDe Cat, Denecker, Stuckey & Bruynooghe
Torlak, E., Chang, F. S.-H., & Jackson, D. (2008). Finding minimal unsatisable cores
declarative specications. Cullar, J., Maibaum, T. S. E., & Sere, K. (Eds.),
Vol. 5014

LNCS, pp. 326341. Springer.

FM,

Tseitin, G. S. (1968). complexity derivation propositional calculus. Slisenko,
A. O. (Ed.),

Studies Constructive Mathematics Mathematical Logic II, pp. 115

125. Consultants Bureau, N.Y.
Van Gelder, A. (1993). alternating xpoint logic programs negation.

Syst. Sci., 47 (1), 185221.

J. Comput.

Vennekens, J., Marin, M., Wittocx, J., & Denecker, M. (2007). Predicate introduction
logics xpoint semantics. Part I: Logic programming.

79 (1-2), 187208.

Fundamenta Informaticae,

Wittocx, J., Denecker, M., & Bruynooghe, M. (2013). Constraint propagation rst-order
logic inductive denitions.

ACM Trans. Comput. Logic, 14 (3), 17:117:45.

Wittocx, J., Marin, M., & Denecker, M. (2008).

idp system: model expansion system

extension classical logic. Denecker, M. (Ed.),

LaSh, pp. 153165. ACCO.

Wittocx, J., Marin, M., & Denecker, M. (2010). Grounding FO FO(ID) bounds.

J. Artif. Intell. Res. (JAIR), 38, 223269.

286


