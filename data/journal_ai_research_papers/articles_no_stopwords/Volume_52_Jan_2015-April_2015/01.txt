Journal Artificial Intelligence Research 52 (2015) 97-169

Submitted 05/14; published 01/15

Deterministic Oversubscription Planning Heuristic Search:
Abstractions Reformulations
Carmel Domshlak
Vitaly Mirkis

dcarmel@ie.technion.ac.il
mirkis80@gmail.com

Faculty Industrial Engineering & Management,
Technion - Israel Institute Technology,
Haifa, Israel

Abstract
classical planning objective achieve one equally attractive goal
states low total action cost possible, objective deterministic oversubscription
planning (OSP) achieve valuable possible subset goals within fixed
allowance total action cost. Although numerous applications various fields share
latter objective, substantial algorithmic advances made deterministic
OSP. Tracing key sources progress classical planning, identify severe lack
effective domain-independent approximations OSP.
focus optimal planning, goal bridge gap. Two classes
approximation techniques found especially useful context optimal
classical planning: based state-space abstractions based logical landmarks goal reachability. question study whether similar-in-spirit,
yet possibly mathematically different, approximation techniques developed OSP.
context abstractions, define notion additive abstractions OSP, study
complexity deriving effective abstractions rich space hypotheses, reveal
substantial, empirically relevant islands tractability. context landmarks,
show standard goal-reachability landmarks certain classical planning tasks
compiled OSP task interest, resulting equivalent OSP task lower
cost allowance, thus smaller search space. empirical evaluation confirms
effectiveness proposed techniques, opens wide gate developments
oversubscription planning.

1. Introduction
tools automated action planning allow autonomous systems selecting course
action get things done. Deterministic planning probably basic, thus
fundamental, setting automated action planning (Russell & Norvig, 2009).
viewed problem finding trajectories interest large-scale yet concisely
represented state-transition systems. Computational approaches deterministic planning
vary around way trajectories interest defined.
basic structure acting situations underconstrained overconstrained
resources respectively captured days called classical deterministic
planning (Fikes & Nilsson, 1971), Smith (2004) termed oversubscription
deterministic planning (OSP). classical planning, task find cost-effective
trajectory possible goal-satisfying state. oversubscription planning, task
find goal-effective (or valuable) state possible via cost-satisfying trajectory.
c
2015
AI Access Foundation. rights reserved.

fiDomshlak & Mirkis

optimal classical planning optimal OSP, tasks constrained finding
cost-effective trajectories goal-effective states, respectively. Classical
planning OSP viewed foundational variants deterministic planning,
many variants, net-benefit planning cost-bounded planning, defined
terms mixing relaxing two.1
OSP extensively advocated years, theory practice
classical planning studied advanced much intensively. remarkable
success continuing progress heuristic-search solvers classical planning one notable example. Primary enablers success advances domain-independent
approximations, heuristics, cost needed achieve goal state given state.
thus possible similarly rich palette effective heuristic functions
OSP would advance state art problem.
Two classes approximation techniques found especially useful context optimal classical planning: based state-space abstractions (Edelkamp, 2001;
Haslum, Botea, Helmert, Bonet, & Koenig, 2007; Helmert, Haslum, Hoffmann, & Nissim,
2014; Katz & Domshlak, 2010a) based logical landmarks goal reachability (Karpas & Domshlak, 2009; Helmert & Domshlak, 2009; Domshlak, Katz, & Lefler,
2012; Bonet & Helmert, 2010; Pommerening & Helmert, 2013). Considering OSP heuristic search, question whether similar-in-spirit, yet possibly mathematically
different, approximation techniques developed heuristic-search OSP. precisely question study here.
Starting basic question state-space abstractions OSP actually are, show notion abstraction differs substantially classical planning OSP. Hence, first define (additive) abstractions abstraction
heuristics OSP. investigate computational complexity deriving
effective abstraction heuristics scope homomorphic abstraction skeletons,
paired cost, value, budget partitions. Along revealing significant
islands tractability, study exposes interesting interplay knapsackstyle problems combinatorial optimization, continuous convex optimization,
certain principles borrowed explicit abstractions classical planning.
introduce study -landmarks, logical properties OSP plans achieve
valuable states. show -landmarks correspond regular goal-reachability
landmarks certain classical planning tasks straightforwardly derived
OSP tasks interest. show -landmarks compiled
back OSP task interest, resulting equivalent OSP task,
stricter cost satisfaction constraint, thus smaller effective search space.
Finally, show landmark-based task enrichment combined
mutually stratifying way best-first branch-and-bound search used OSP
planning, resulting incremental procedure interleaves search landmark
discovery. entire framework independent OSP planner specifics,
particular, heuristic functions employs.
1. connections differences popular variants deterministic planning discussed
Section 2.

98

fiOn Oversubscription Planning Heuristic Search

empirical evaluation large set OSP tasks confirms effectiveness proposed techniques. Moreover, best knowledge, implementation constitutes
first domain-independent solver optimal OSP, hope advances
important computational problem follow.
work revision extension formulations results presented
authors ICAPS-2013 ECAI-2014 (Mirkis & Domshlak, 2013, 2014). paper
structured follows. Section 2 formulate general model deterministic planning,
define several variants deterministic planning terms model, and, particular,
show oversubscription planning differs conceptually classical planning,
popular variants deterministic planning net-benefit planning
cost-bounded planning. specify simple model representation language
OSP, well provide essential background heuristic search, and, particular,
OSP heuristic search. Sections 3 4 devoted, respectively, abstractions
abstraction approximations OSP. Section 5 devoted exploiting reachability
landmarks OSP tasks. Section 6 conclude discuss promising directions
future work. sake readability, proofs relegated Appendix A,
details empirical results relegated Appendix B.

2. Background
mentioned introduction, specific variants deterministic planning differ
way interest preference trajectories defined. instance, classical
planning (Fikes & Nilsson, 1971), trajectory interest connects designated initial
state one designated goal states, preference towards trajectories
lower total cost transitions along them. Among other, non-classical variants
deterministic planning
oversubscription planning (Smith, 2004), topic interest here;
net-benefit planning (van den Briel, Sanchez, Do, & Kambhampati, 2004; Sanchez
& Kambhampati, 2005; Baier, Bacchus, & McIlraith, 2009; Bonet & Geffner, 2008;
Benton, Do, & Kambhampati, 2009; Coles & Coles, 2011; Keyder & Geffner, 2009);
cost-bounded (also known resource-constrained) planning (Haslum & Geffner, 2001;
Hoffmann, Gomes, Selman, & Kautz, 2007; Gerevini, Saetti, & Serina, 2008; Thayer &
Ruml, 2011; Thayer, Stern, Felner, & Ruml, 2012; Haslum, 2013; Nakhost, Hoffmann,
& Muller, 2012);
planning preferences temporal properties trajectories (Baier et al.,
2009; Gerevini, Haslum, Long, Saetti, & Dimopoulos, 2009; Benton, Coles, & Coles,
2012).
Interestingly, working paper, learned quite different
variants deterministic planning often collectively referred oversubscription
planning. result, difference terms expressiveness necessarily clear, thus, relationship already
done collective sense oversubscription planning always apparent.
issue address first.
99

fiDomshlak & Mirkis

2.1 Models
Adopting extending notation Geffner Bonet (2013), view many
variants deterministic planning, including classical planning, well many popular
non-classical variants, special cases state model
= hS, s0 , u, O, , c, Qi

(1)

with:
finite set states S,
initial state s0 S,
state value function u : 7 R0+ {},
operators O(s) applicable state S,
deterministic state transition function (s, o) s0 = (s, o) stands
state resulting applying O(s) s,
operator cost function c : R0+ ,
quality measure Q : P 7 R {}, P (infinite) set trajectories
s0 along operators O. trajectory P sequence operators ho1 , . . . ,
o1 O(s0 ) and, inductively, oi O(((. . . (s0 , o1 ) . . . , oi2 ), oi1 )).
model, trajectory P solution, preference towards solutions
higher quality.
P follows, sJK stands end-state trajectory applied
state s, c() = c(o) additive cost . Likewise, graphical skeleton
GM = hS, , Oi model refers edge-annotated, unweighted digraph induced
nodes GM states S, edge labels operators O,
contains edge s0 labeled iff O(s) s0 = (s, o).
First, consider quality measure
Q+ () = u(sJK) c().

(2)

measure assumes state values operator costs comparable, thus represents tradeoff value end-state cost trajectory. Consider
fragment state model (1), instances quality measure Q+ ,
instance, value function
(
,
Sgoal
u(s) =
(3)
, otherwise
partitions state space Sgoal S, u takes finite value 0,
rest states, u takes value . Finding optimal solution
instance fragment corresponds finding shortest path s0 single node
edge-weighted digraph G, obtained GM (i) annotating edges
latter costs c, (ii) adding dummy node zero-cost edges
100

fiOn Oversubscription Planning Heuristic Search

constraint

preference

Net Benefit

Oversubscription

constraint

End-state value

Action cost
preference

Classical

Cost-bounded

Figure 1: Schematic classification four deterministic planning models along strictness
approach cost operator sequences value
operator sequence end-states. White blocks planning models
solved single-source single-target shortest path problems.

goal nodes Sgoal . specified non-canonical way, fragment
easily verified correspond model classical planning, Sgoal classical
planning goal states.
Staying quality measure Q+ removing requirement u comply
Eq. 3, obtain fragment generalizes classical planning, constitutes
basic model called net-benefit planning (Sanchez & Kambhampati, 2005). Importantly, instance fragment reduced finding shortest path
single node s0 single node edge-weighted digraph G, obtained GM
(i) annotating edges GM costs c, (ii) adding dummy node andPedges
nodes , (ii) setting cost new edge (s, ) s0 S\{s} u(s0 ).
reduction works net-value maximization end state equivalent
minimization net-loss giving possible end states.
basic idea underlies Keyder Geffners (2009) scheme compiling certain standard representation formalisms net-benefit planning standard classical planning
formalism.2
Consider alternative quality measure
(
u(sJK), c() b
Q () =
,
,
otherwise
b

(4)

2. worth noting wost-case complexity equivalence classical planning net-benefit
planning shown prior work Keyder Geffner (2009) van den Briel et al. (2004).
However, equivalence prescriptive enough suggest practically effective compilations
compactly represented net-benefit planning tasks classical planning tasks.

101

fiDomshlak & Mirkis

b R0+ predefined bound cost trajectories. fragment
basic model, instances characterized quality measure Qb
value functions Eq. 3, constitutes model called costbounded planning (Thayer & Ruml, 2011). well, finding optimal solution
problem instance corresponds finding shortest path s0 edge-weighted
digraph G, derived GM identically case classical planning.3 This,
particular, explains natural heuristic-search methods cost-bounded
planning exploit heuristics developed classical planning (Haslum, 2013).
arrive fourth fragment basic model. Staying quality measure Qb removing requirement u comply Eq. 3, obtain fragment
generalizes cost-bounded planning, constitutes model oversubscription planning (Smith, 2004). illustrated Figure 1, hard constraint classical planning
translates soft preference OSP, hard constraint OSP translates soft preference classical planning. However, contrast cost-optimal, net-benefit, classical
planning, fragment appear reducible single-source single-target
shortest path problem. terms digraph G obtained GM annotating
edges costs c, finding optimal solution instance oversubscription planning
requires (i) finding shortest paths s0 states u(s) > 0, (ii) filtering
states reachable s0 within cost allowance b, (iii)
selecting remaining states state maximizes u.
contrast oversubscription planning three popular variants
deterministic planning discussed least two important implications. First,
single shortest path searched using best-first forward search procedures
, searching shortest paths numerous targets simultaneously requires different,
exhaustive, forward search framework branch-and-bound. Second, net-benefit
cost-bounded planning clearly potential (directly indirectly) reuse rich
toolbox heuristic functions developed years classical planning. contrast,
due differences underlying computational model, necessarily
true oversubscription planning, examining prospects heuristic functions
OSP precisely focus work here.
2.2 Notation
k N+ , [k] denote set {1, 2, . . . , k}. indicator function subset
set X function 1A : X {0, 1} defined 1A (x) = 1 x 1A (x) = 0 x 6 A.
Following Nebel (2000), talk size mathematically well-defined object
x, symbolically ||x||, mean size (reasonable) encoding x. assignment
variable v value denoted hv/di; often refer single variable assignments
propositions.

3. Strictly speaking, shortest path s0 found, still checked
cost bound b. test, however, local , problem solving finishes independently tests
outcome.

102

fiOn Oversubscription Planning Heuristic Search

2.3 Model Representation
Departing general model oversubscription planning, follows restrict attention instances model compactly representable language
close sas+ language classical planning (Backstrom & Klein, 1991; Backstrom &
Nebel, 1995). language, deterministic oversubscription planning (OSP) task
given sextuple
= hV, s0 , u; O, c, bi,

(5)


(1) V = {v1 , . . . , vn } finite set finite-domain state variables, complete
assignment V representing state, = dom(v1 ) dom(vn ) state
space task;
(2) s0 designated initial state;
(3) u efficiently computable state value function u : R0+ ;
(4) finite set operators, operator represented pair
hpre(o), eff(o)i partial assignments V , called preconditions effects o, respectively;
(5) c : R0+ operator cost function;
(6) b R0+ cost budget allowed task.
consider semantics task description terms
basic model.

OSP task = hV, s0 , u; O, c, bi said induce model = S, s0 , u, O, , c, Qb ,
Qb quality measure (4) instantiated budget b, transition
function specified follows. partial assignment p V , let V(p) V denote
subset variables instantiated p, and, v V(p), p[v] denote value provided
p variable v. Similarly classical planning semantics sas+ , operator
applicable state iff s[v] = pre(o)[v] v V(pre(o)). Applying changes
value v V(eff(o)) eff(o)[v], resulting state denoted sJoK.
notation defined applicable s. Denoting empty sequence operators ,
applying sequence operators ho1 , . . . , om state defined inductively sJK :=
sJo1 , . . . , oj K := sJo1 , . . . , oj1 KJoj K. operator sequence called s-plan
applicable state Qb () 6= , is, c() b.

auxiliary notation used later on: OSP task = hV, s0 , u; O, c, bi,
= vV dom(v) denote union (uniquely labeled) state-variable domains.
state proposition hv/di D, hv/di used shortcut notation
s[v] = d.
example simple OSP task Figure 2 used illustrate model representation. example, truck initially location A, drive (only) location
location B location B location C. Two packages, x y, initially
location B. package truck location, package
loaded onto truck, package truck, unloaded
103

fiDomshlak & Mirkis

x



B

C

(a)
oi
pre(oi )
eff(oi )

driveAB
i=1
{ht/Ai}
{ht/Bi}

driveBC
i=2
{ht/Bi}
{ht/Ci}

loadBx
i=3
{ht/Bi , hx/Bi}
{hx/T i}

loadBy
i=4
{ht/Bi , hy/Bi}
{hy/T i}

unloadCx
i=5
{ht/Ci , hx/T i}
{hx/Ci}

oi
pre(oi )
eff(oi )

unloadBx
i=6
{ht/Bi , hx/T i}
{hx/Bi}

unloadBy
i=7
{ht/Bi , hy/T i}
{hy/Bi}

unloadCy
i=8
{ht/Ci , hy/T i}
{hy/Ci}

loadCx
i=9
{ht/Ci , hx/Ci}
{hx/T i}

loadCy
= 10
{ht/Ci , hy/Ci}
{hy/T i}

(b)
u=1

CBB

o2
ABB

o1

BBB

BTB
o6
o3
o7
o4
BBT

CTB

o9
o5

CCB

BTT

o2

CTT

o2
o7
o4
o3
o6
o2

o10
o8
u=1

o10
o8

CBC

CTB

o9
o5

CCB

BTT

o2

CTT

CBT

u=1

o9
o5

CTC

u=1
CCT

o9 u=2
o5
CCC

o10
o8

(c)
u=1

CBB

o2
ABB

o1

BBB

BTB
o6
o3
o7
o4
BBT

o2
o7
o4
o3
o6
o2

o10
o8
u=1

CBT

o10
o8

u=1

o9
o5

CTC

u=1
CCT

o9 u=2
o5
CCC

o10
o8

CBC

(d)

Figure 2: simple running example OSP task, (a) illustrating story, (b) listing operators, (c)-(d) depicting graphical skeleton induced state
model; (c) shows region graphical skeleton GM structurally
reachable initial state ABB, grayed area (d) corresponds
sub-region cannot reached initial state budget
b = 4.

trucks current location. (drive, load, unload) operator task costs one unit
cost, cost budget set four units cost. Finally, value one (value unit)
earned package present location C.
OSP task described using three state variables V = {t, x, y},
dom(t) = {A, B, C} dom(x) = dom(y) = {A, B, C, }, corresponding possible
locations truck two packages, respectively.

operator set ffO = {o1 , . . . , o10 }
detailed Figure 2(b). state model = S, s0 , u, O, , c, Qb induced
104

fiOn Oversubscription Planning Heuristic Search

BFBB ( = hV, s0 , u; O, c, bi)
open := new max-heap ordered f (n) = h(shni, b g(n))
initialize best solution n := make-root-node(s0 )
open.insert(n )
closed:= ;
best-cost:= 0
open.empty()
n := open.pop-max()
f (n) u(shn i): break
u(shni) > u(shn i): update n := n
shni 6 closed g(n) < best-cost(shni):
closed:= closed {shni}
best-cost(shni) := g(n)
foreach O(shni):
n0 := make-node(shniJoK, n)
g(n0 ) > b f (n0 ) u(shn i): continue
open.insert(n0 )

return n
Figure 3: Best-first branch-and-bound (BFBB) search OSP
task, = dom(t)dom(x)dom(y), initial state s0 = ABB (with three letters names states capturing three components domain cross-product),
operator cost c(oi ) = 1 operators oi , cost budget b = 4, state values


1, {?AC, ?BC, ?CA, ?CB}
u(s) = 2, {?CC}


0, otherwise

.

graphical skeleton GM depicted Figures 2(c) 2(d): Figure 2(c) shows
region graphical skeleton GM structurally reachable initial state
ABB, grayed area Figure 2(d) corresponds sub-region cannot
reached initial state budget b = 4.
2.4 OSP Heuristic Search
two major ingredients heuristic-search planner search algorithm
heuristic function. classical planning, heuristic typically function h : R0+
{}, h(s) estimating cost h (s) optimal s-plans. heuristic h admissible
lower-bounding, is, h(s) h (s) states s. common heuristic search
algorithms optimal classical planning, , require admissible heuristics.
contrast, heuristic OSP function h : R0+ R0+ , h(s, b) estimating
value h (s, b) optimal s-plans cost budget b. heuristic h admissible
upper-bounding, is, h(s, b) h (s, b) states cost budgets b. well,
105

fiDomshlak & Mirkis

search algorithms optimal OSP, best-first branch-and-bound (BFBB),4 require
admissible heuristics pruning search branches without violating solution optimality.
Figure 3 depicts pseudo-code description BFBB OSP; shni denotes state
associated search node n, cost-so-far g(n) total cost action sequence
associated n. Unlike , order nodes selected OPEN
list affect optimality guarantees (though may, course, seriously affect
empirical efficiency search). Figure 3, ordering OPEN corresponds
decreasing order h(shni, b g(n)). duplicate detection reopening mechanisms
BFBB similar (Pearl, 1984). addition, BFBB maintains best
solution n found far uses prune generated nodes evaluated higher
u(shn i). Likewise, complying semantics OSP, generated nodes n costso-far g(n) higher problems budget b immediately pruned.
OPEN list becomes empty node n selected list promises less lower
bound, BFBB returns (the plan associated with) best solution n . h admissible,
is, h-based pruning generated nodes sound, returned plan
guaranteed optimal.
Let us return heuristic functions. domain-independent planning
automatically derived description model language choice.
useful heuristic function must efficiently computable description
model, well relatively accurate estimates. Improving accuracy heuristic
function without substantially worsening time complexity computing translates
faster search plans.
classical planning, numerous approximation techniques, monotonic relaxation (Bonet & Geffner, 2001, 2001; Hoffmann & Nebel, 2001), critical trees (Haslum
& Geffner, 2000), network flow (van den Briel, Benton, Kambhampati, & Vossen, 2007;
Bonet, 2013), logical landmarks goal reachability (Richter, Helmert, & Westphal, 2008;
Karpas & Domshlak, 2009; Helmert & Domshlak, 2009; Bonet & Helmert, 2010),
abstractions (Edelkamp, 2001; Helmert, Haslum, & Hoffmann, 2007; Katz & Domshlak,
2010a), translated effective heuristic functions. Likewise, different heuristics
classical planning combined point-wise maximizing and/or additive
ensembles (Edelkamp, 2001; Haslum, Bonet, & Geffner, 2005; Coles, Fox, Long, & Smith,
2008; Katz & Domshlak, 2010b; Helmert & Domshlak, 2009).
contrast, development heuristic functions OSP progressed beyond
initial ideas Smith (2004). principle, reduction Keyder Geffner (2009)
net-benefit classical planning used reduce OSP classical planning realvalued state variables (Koehler, 1998; Helmert, 2002; Fox & Long, 2003; Hoffmann, 2003;
Gerevini, Saetti, & Serina, 2003; Gerevini et al., 2008; Edelkamp, 2003; Dvorak & Bartak,
2010; Coles, Coles, Fox, & Long, 2013). far, however, progress heuristic-search classical
planning numeric state variables mostly achieved around direct extensions
delete relaxation heuristics via numeric relaxed planning graphs (Hoffmann, 2003;
Edelkamp, 2003; Gerevini et al., 2003, 2008). Unfortunately, heuristics preserve
information consumable resources budgeted operator cost oversubscription
4. BFBB extensively used net-benefit planning (Benton, van den Briel, & Kambhampati, 2007;
Coles & Coles, 2011; Do, Benton, van den Briel, & Kambhampati, 2007), well variants
deterministic planning (Bonet & Geffner, 2008; Brafman & Chernyavsky, 2005).

106

fiOn Oversubscription Planning Heuristic Search

planning: negative action effects decrease values numeric variables
ignored, possibly special handling so-called cyclic resource transfer (Coles
et al., 2013).
first step overcoming lack effective heuristics OSP, next section
study abstractions OSP, definition properties, prospects
deriving admissible abstraction heuristics. Section 5 study prospects
adapting OSP toolbox logical landmarks goal reachability. date, abstractions
landmarks responsible state-of-the-art admissible heuristics classical
planning, thus special interest here.

3. Abstractions
term abstraction usually associated simplifying original model, factoring
details less crucial given context. Context determines details reduced, better preserved, abstraction created used (Cousot
& Cousot, 1992; Clarke, Grumberg, & Peled, 1999; Helmert et al., 2014; Domshlak, Hoffmann, & Sabharwal, 2009; Katz & Domshlak, 2010b). general terms, abstracting model
corresponds associating set (typically computationally attractive)
models M1 , . . . , Mk solutions models satisfy certain properties respect solutions . particular, deterministic planning heuristic search,
abstractions used derive heuristic estimates states model interest :
Given state abstraction M1 , . . . , Mk ,
(1) mapped abstract states s1 M1 , . . . , sk Mk ,
(2) k models abstraction solved respective initial states s1 , . . . , sk ,

(3) aggregation quality resulting k solutions used heuristic estimate
s.
Sometimes schematically sometimes precisely, process constructing abstractions state model = hS, s0 , u, O, , c, Qi seen two-step process

(1) selecting abstraction skeleton = {(G1 , 1 ), . . . , (Gk , k )}, pair
(Gi , ) comprises edge-labeled digraph Gi = hSi , Ti , Oi i, nodes Si , edges Ti ,
edge labels Oi , state mapping : Si ,
(2) extending set abstract models = {M1 , . . . , Mk }, that, [k],
Gi graphical skeleton GMi Mi .
qualify valid abstraction model , resulting set abstract models
satisfy certain conditions specific variant deterministic planning
consideration. instance, optimal solutions abstract models classical
planning required costly respective solutions original
models, constraint satisfied individual abstract models case maxaggregation (Pearl, 1984), k abstract models jointly, case additive abstractions (Yang, Culberson, Holte, Zahavi, & Felner, 2008; Katz & Domshlak, 2010b).
107

fiDomshlak & Mirkis

show, concept abstractions general, additive abstractions particular,
different OSP, and, better worse, many degrees freedom
respective concepts classical planning.
3.1 Abstractions OSP Problems
Given
abstraction


skeleton = {(G1 , 1 ), . . . , (Gk , k )} OSP state model =
S, s0 , u, O, , c, Qb , digraph Gi = hSi , Ti , Oi implicitly defines set OSP state
models consistent it. set given Ci Ui Bi , Ci set
functions operators Oi R0+ , Ui set functions states Si R0+ ,
Bi = R0+ . terms, point (c, u, b) Ci Ui Bi induces OSP model
consistent Gi , vice versa.
Connecting sets models digraphs AS, let
C = C1 Ck ,
U = U1 Uk ,
B = B1 Bk .
state , every point (c, u, b) C U B induces set models
n

(c,u,b)
(c,u,b)
M(c,u,b) = M1
, . . . , Mk
,
(c,u,b)

Mi




= Si , (s0 ), u[i], Oi , , c[i], Qb[i] :

states Si operators Oi correspond nodes edge labels Gi ;
transition function (s, o) = s0 iff Ti contains arc s0 labeled
Oi ;
initial state (s0 ) determined initial state s0 state mapping ;

operator cost function, state value function, cost budget directly determined choice (c, u, b).
choices (c, u, b) C U B, induced sets models M(c,u,b)
used deriving admissible estimates state interest s0 , others cannot.
respective qualification defined below.
Definition
1 (Additive OSP
Abstraction)
Let = S, s0 , u, O, , c, Qb OSP model = {(G1 , 1 ), . . . , (G1 , k )}
abstraction skeleton . (c, u, b) C U B, M(c,u,b) (additive)
abstraction , denoted
M(c,u,b) AAS M,

def

h (s0 , b) hM(c,u,b) (s0 , b) =

X

hi (i (s0 ), b[i]),

i[k]

is, hM(c,u,b) (s0 , b) admissible estimate h (s0 , b).
108

fiOn Oversubscription Planning Heuristic Search

GM

= s1
o1 |||
||
||
/ s2
s0
o2

o3

/ s3

G1

G2


= 2;1
o1 zz
z
zz
zz

o1

o5
o4

/ s4

s1;0

o2

/ s1;2

(a)

o4

/ 1;4

s2;0

o2

o3

/ s2;3
o5



/ s2;4

(b)
Figure 4: Illustration running example

simple terms, set models forms additive OSP abstraction jointly models
underestimate value obtained initial state, within
5 example, let G
given cost budget.
4a graphical skeleton state
Figure


model = {s0 , . . . , s4 }, s0 , u, {o1 , . . . , o5 }, , c, Qb , c(oi ) = 1 operators oi ,
b = 2, u(si ) = 1{4} (i). Let = {(G1 , 1 ), (G2 , 2 )} abstraction skeleton
, G1 G2 Figure 4b state mappings
(
s1;4 , {1, 3}
1 (si ) =
,
s1;i , otherwise
(
s2;4 , = 2
2 (si ) =
.
s2;i , otherwise
Consider set models M(c,u,b) , constant c[1]() = c[2]() = 1, b[1] = b[2] = 2, and,
j [2], u[i](si;j ) = 1{4} (j). optimal plan s0 -plan = h(s0 , o2 , s2 ), (s2 , o4 , s4 )i,
(c,u,b)

Qb () = 1, optimal 1 (s0 )-plan M1
1 = h(s1;0 , o1 , s1;4 )i,
(c,u,b)
b[1]
Q (1 ) = 1, optimal 2 (s0 )-plan M2
2 = h(s2;0 , o2 , s2;4 )i,
Qb[2] (2 ) = 1. Since
h (s0 , b) = Qb () Qb[1] (1 ) + Qb[2] (2 ) = h1 (1 (s0 ), b[1]) + h2 (2 (s0 ), b[2]),
M(c,u,b) additive abstraction .
Theorem 1 OSP task = hV, s0 , u; O, c, bi, abstraction skeleton =
{(G1 , 1 ), . . . , (Gk , k )} , AAS , digraphs given
explicitly, hM (s0 , b) computed time polynomial |||| ||M||.



Proof: Let = {Mi }i[k] , Mi = Si , (s0 ), ui , Oi , , ci , Qbi , additive abstraction basis AS. [k], let Si0 = {s Si | ci (i (s0 ), s) bi }. Since
5. optimal classical planning, requirement abstraction overestimate costs typically
posed states original model, initial state (Yang et al., 2008; Katz &
Domshlak, 2010b; Helmert et al., 2014). extra requirement, however, pragmatic reasons
efficiency allows abstraction computed preprocessing individually every
state examined search. Heuristics OSP, however, functions state
available cost budget, latter directly applies initial (aka current) state only.
sum, defining abstractions respect entire state space necessity classical
planning, OSP even clear whether defining abstractions respect specific pair
state budget deliver practical benefits. not, however, interpreted
formal impossibility claim, investigation direction definitely worthwhile.

109

fiDomshlak & Mirkis

(, , )

SSSS
kk
SS
kkkk
(, u, )
SSSSkk (c, , ) SSSSkk (, , b)
kkkkSS
kkkkSS
(c, u, )

(, u, b)
(c, , b)
SSS
SSS
kkk
kkk
(c, u, b)

Figure 5: Fragments restricted optimization abstractions C U B
digraphs given explicitly, shortest paths (s0 ) states Gi (and
thus, particular, determining Si0 ) computed time polynomial
||M||
P
[k]. turn, since hi (i (s0 ), bi ) = maxsSi0 ui (s), hM (s0 , b) = i[k] hi (i (s0 ), bi )
computed time polynomial ||M||.

message Theorem 1 positive, yet establishes necessary condition
relevance OSP abstractions practice. Given OSP task , fixed
abstraction skeleton joint performance measure space C U B,
able automatically separate (c, u, b) C U B constitute
abstractions not, within former set, denoted
C U B,
home abstraction provides us accurate (aka low) estimate
h (s0 , b) possible. Here, even first item agenda necessarily trivial as,
general, seems lack convenient combinatorial properties. instance, generally
form combinatorial rectangle C U B: Consider OSP state model
GM abstraction skeleton running example. Let c C cost function
vector c[1] c[2] constant functions value 1, two performance
measures (c, u, b), (c, u0 , b0 ) CUB defined via budget vectors b = {b[1] = 2, b[2] = 0}
b0 = {b0 [1] = 0, b0 [2] = 2}, value function vectors u u0 , u[1], u[2], u0 [1],
u0 [2] evaluating zero states except u[1](s1;4 ) = u0 [2](s2;4 ) = 1.
0 0
hard verify M(c,u,b) AAS M(c,u ,b ) AAS : M(c,u,b) , state
(c,u,b)
s1;4 u[1](s1;4 ) = 1 reachable M1
s1;0 = 1 (s0 ) b[1] = 2,
0
0
(c,u0 ,b0 )
(c,u
,b
)
0

, state s2;4 u [2](s2;4 ) = 1 reachable M2
s2;0 = 2 (s0 )
0
0
b0 [2] = 2. contrast, M(c,u ,b) 6AAS M(c,u,b ) 6AAS : sets
models, model either comes budget (and initial state model
0
value zero), states non-zero value all. Hence, M(c,u ,b)
0
M(c,u,b ) estimate h (s0 , b) zero, h (s0 , b) = 1.
light above, approach overall agenda complexity analysis abstractionbased heuristic functions steps, different fixations three dimensions
A: If, instance, given vector value functions u known belong
projection U, search quality abstraction abstraction
subset A(, u, ) A, corresponding projection {u}. show below,
even constrained optimizations kind challenging. lattice Figure 5 depicts range options constrained optimization; extreme settings,
110

fiOn Oversubscription Planning Heuristic Search

o1

G1

G2

: s2;1
uu
u
u
uu

o3

/ s2;3

o1

s1;0

o2

/ s1;2

o4

/ 1;4
j

s2;0

o3 ,o5

o2



o5

/ s2;4
j

o4

Figure 6: Homomorphic abstraction skeleton G() Figure 4
A(, , ) simply renaming A, A(c, u, b) corresponds single abstraction
M(c,u,b) A.
3.2 Partitions Homomorphic Abstractions
proceed consider specific family additive abstractions, reveal
interesting properties, show contains substantial islands tractability.
Definition 1 allowing general abstraction skeletons, work focus homomorphic abstraction skeletons6 (Helmert et al., 2014).
Definition
2 abstraction skeleton
= {(G1 , 1 ), . . . , (Gk , k )} OSP state

model = S, s0 , u, O, , c, Qb homomorphic if, [k], Oi = O, (s, o) = s0
(i (s), o, (s0 )) Ti .
instance, running example, abstraction skeleton Figure 4b homomorphic (since, e.g., (s1 , o3 , s3 ) GM yet (1 (s1 ), o3 , 1 (s3 )) = (s1;4 , o3 , s1;4 ) 6 GM1 ),
abstraction skeleton Figure 6 homomorphic. Furthermore, focus fragment
additive abstractions
Ap = [Cp Bp ] ,
Cp C, U, Bp B correspond cost, value, budget partitions,
respectively.



Definition 3 Given OSP state model = S, s0 , u, O, , c, Qb , homomorphic
abstraction skeleton = {(G1 , 1 ), . . . , (Gk , k )} joint performance measure
C U B,
P
c C cost partition iff, operator O, i[k] c[i](o) c(o);
P
u U value partition iff, state S, i[k] u[i](i (s)) u(s);
P
b B budget partition iff, i[k] b[i] b.
follows, node x lattice Figure 5, Ap (x) refer A(x)Ap ;
e.g., Ap (, u, ) = A(, u, ) Ap .
begin analysis Ap establishing interesting completeness relationship
sets Cp Bp , well even stronger individual completeness Cp
Bp . Formulated Theorem 2, properties Ap play key role computational
analysis later on.
6. results hold verbatim general labeled paths preserving abstraction skeletons
studied Katz Domshlak (2010b) context optimal classical planning. However,
presentation somewhat accessible restricted homomorphic abstraction skeletons.

111

fiDomshlak & Mirkis

c

Cp

b

Bp



(1)

b

c

Bp

Cp



(2)

Figure 7: Illustration sub-claims (1) (2) Theorem 2: (1), gray ellipse
within Bp stands subset budget partitions b pair c
abstraction, is, Ap (c, , b) 6= . However, pairing budget
partitions b c requires careful selection value partition u (so
M(c,u,b) abstraction), exists budget partition b
choice u job.

Theorem 2 Given OSP task = hV, s0 , u; O, c, bi homomorphic abstraction
skeleton = {(G1 , 1 ), . . . , (Gk , k )} ,
(1) cost partition c Cp , exists budget partition b Bp

M(c,u,b ) value partitions u ;

(2) budget partition b Bp , exists cost partition c Cp

M(c ,u,b) value partitions u .
proof Theorem 2 appears Appendix A, p. 145. Figure 7 illustrates statement sub-claim (1) Theorem 2, well as, indirectly, corollaries.7 first
corollary Theorem 2 projections Ap Cp , , Bp entire sets
Cp , , Bp , respectively. is, cost partition c (and similarly, budget partition value partition) matched abstraction partition
component. Second, budget partition b paired given cost
partition c abstractions , is, b Bp , Ap (c, , b) 6= ,
always budget partitions paired c. Finally, pairing
c-compatible budget partitions b c requires careful selection value
partition u, exists c-compatible budget partition b choice
u result M(c,u,b) abstraction .
priori, properties Ap simplify task abstraction discovery
optimization within space partitions Cp Bp , later show
indeed case. However, complexity analysis abstraction discovery within Cp Bp
general terms still problematic OSP formalism parametric
7. respective illustration sub-claim (2) Theorem 2 completely similar, mutatis mutandis.

112

fiOn Oversubscription Planning Heuristic Search

representation value functions. Hence, proceed examining abstraction
discovery OSP context fixed value partitions u .

4. Value Partitions Complete Abstractions
Let OSP task, explicitly given homomorphic abstraction skeleton ,
u value partition AS. immediate corollary Theorem 2
Ap (, u, ) empty, thus try computing min(c,u,b)Ap (,u,) hM(c,u,b) (s0 ).
yet, however, know whether task polynomial-time solvable
non-trivial class value partitions. fact, although Ap (, u, ) known, Theorem 2,
non-empty, so, too, subsets Ap (, u, b) Ap (c, u, ), finding even
abstraction (c, u, b) Ap (, u, ) necessarily easy.
4.1 0-Binary Value Partitions
first step, examine abstraction discovery within fragment Ap
value functions u[i] abstract models call 0-binary. Later, Section 4.2,
show findings 0-binary abstract value functions extended general
value partitions.
Definition 4 real-valued function f called 0-binary codomain f {0, }
R+ . set F 0-binary functions called strong functions F
codomain {0, }.
one hand, 0-binary functions constitute rather basic family value functions.
Hence, abstraction optimization hard them, likely hard nontrivial family abstract value functions. hand, 0-binary abstract value
functions seem fit well abstractions planning tasks value functions linear
combinations indicators, representing achievement goal value state
variable.
respect, first tractability results abstraction discovery Ap (, u, )
u strong 0-binary value partition. first (and simpler) result Theorem 3
assumes fixed action cost partition, next result, Theorem 7,
simultaneous selection admissible pairs cost budget partitions. Corollary 4
Theorem 10 show results Theorem 3 Theorem 7, respectively,
extended pseudo-polynomial algorithms general 0-binary value partitions.
4.1.1 Strong 0-Binary Value Partitions Knapsack problem
first tractability result abstraction discovery within Ap (c, u, ) u strong
0-binary value partition c arbitrary cost partition. key role played
well-known
Knapsackffproblem (Dantzig, 1930; Kellerer, Pferschy, & Pisinger, 2004).


instance {wi , }i[n] , W Knapsack problem given weight allowance W
set objects [n], object [n] annotated
.
Pwith weight wi value
0 [n]
objective


find

subset
Z

[n]

maximizes



subsets
Z
iZ
P

w

W.

strict
Knapsack

refer


variant Knapsack
0

iZ
inequality constraint strict. Knapsack NP-hard (Karp, 1972; Garey & Johnson,
113

fiDomshlak & Mirkis

1978), exist pseudo-polynomial algorithms run time polynomial
description problem unary representation W (Dudzinski & Walukiewicz,
1987). latter property makes solving Knapsack practical many applications
ratio minWi wi reasonably low. Likewise, = j i, j [n], greedy algorithm
solves problem linear time iteratively expanding Z one weight-wise
lightest objects [n] \ Z, Z cannot expanded within W .
Theorem 3 (Ap (c, u, ) & strong 0-binary u)
Let = hV, s0 , u; O, c, bi OSP task, explicit homomorphic abstraction skeleton , u strong 0-binary value partition. Given cost partition c Cp ,
finding abstraction (c, u, b) Ap (c, u, ) computing corresponding heuristic
estimate hM(c,u,b) (s0 , b) done time polynomial |||| ||AS||.
Proof: proof reduction polynomial fragment Knapsack problem
corresponding items identical value. Let = {(G1 , 1 ), . . . , (Gk , k )}, and,
given u strong 0-binary value partition, let codomain u[i] {0, }
R+ .
[k], let wi cost cheapest path Gi (s0 ) (one the)
states Si u[i](s) = . Since explicit abstraction skeleton, set {wi }i[k]
computed time polynomial ||AS|| using one standard algorithms




single-source shortest paths problem. Consider Knapsack problem {wi , }i[k] , b ,
weights wi value identical objects. Let Z [k]
solution (optimization) Knapsack problem; recall computable
polynomial time. Given that, define budget profile b B follows:
(
wi , Z
[k], b [i] =
0,
otherwise.
remains shown (c, u, b ) actually induces additive abstraction

. Assume contrary M(c,u,b ) 6AAS , let optimal s0 -plan
. construction Knapsack problem b , Z,

(c,u,b )
(s)-plan P
Qb [i] (i ) = . Definition 1, assumption implies
Mi

Qb () > iZ Qb [i] (i ) = |Z|. However, Theorem 2, exists least one
budget partition b Bp M(c,u,b) AAS . Note budget partition
induces aP
feasible solution Z 0 = {i | wi b[i]} Knapsack problem, satisfying
Qb () iZ 0 Qb[i] (i ) = |Z 0 |. This, however, implies |Z| < |Z 0 |, contradicting

optimality Z, thus accomplishing proof M(c,u,b ) AAS .

construction proof Theorem 3 may appear somewhat counterintuitive:
interested minimizing heuristic estimate h (s0 , b), abstraction

M(c,u,b ) selected via value-maximizing Knapsack problem. Indeed, ultimately
would obtain
min
hM(c,u,b) (s0 , b),
(6)
b : (c,u,b)Ap

heuristic manage compute polynomial time actually
max
b : (c,u,b)Ap

hM(c,u,b) (s0 , b).
114

(7)

fiOn Oversubscription Planning Heuristic Search

time, note that, fixed pair c Cp u , estimate Eq. 7
still least (and possibly much more) accurate estimate would obtained
providing k abstract models entire budget b. Later show
superior accuracy verified experiments, first proceed examining
working general 0-binary value partitions.
strong 0-binary value partitions rather restrictive, finding element
Ap (c, u, ) general 0-binary u longer polynomiala reduction Knapsack
straightforward. However, Knapsack solvable pseudo-polynomial time, plugging
Knapsack algorithm proof Theorem 3 results search algorithm
Ap (c, u, ) general 0-binary u.
Corollary 4 (Ap (c, u, ) & 0-binary u)
Let = hV, s0 , u; O, c, bi OSP task, explicit homomorphic abstraction skeleton , u 0-binary value partition. Given cost partition c Cp , finding
abstraction (c, u, b) Ap (c, u, ) computing corresponding heuristic estimate
hM(c,u,b) (s0 , b) done time polynomial ||||, ||AS||, unary representation
budget b .
test illustrate value additive abstractions bring heuristic-search
OSP, implemented prototype heuristic-search OSP solver8 top Fast Downward
planner (Helmert, 2006). Since, unlike classical net-benefit planning, OSP still lacks
standard suite benchmarks comparative evaluation, cast role
STRIPS classical planning tasks International Planning Competitions (IPC) 19982006. translation OSP done associating separate unit-value
proposition conjunctive goal corresponding classical IPC task.
Within prototype, implemented BFBB search OSP, provided support
basic pattern-database abstraction skeletons, action cost partitions, abstraction selection Ap (c, u, ) strong 0-binary value partitions proof Theorem 3.
Specifically, task k sub-goals:
(i) abstraction skeleton comprised set k projections planning task onto
connected subsets ancestors respective k goal variables causal graph.
size projection limited 1000 abstract states, ancestors
goal variable v added corresponding projection (initialized contain
v) breadth-first manner, v back along arcs causal graph,
abstraction could expanded within aforementioned size limit.
(ii) value partition u associated entire value sub-goal hv/di (only)
projection associated v.
(iii) cost partition c distributed cost operator uniformly
projections invalidate o, i.e., reflected least one state variable
affected o.
evaluation, compared BFBB node expansions three heuristic functions,
tagged blind, basic, hM . three heuristics, h-value node n set 0
cost budget n over-consumed. cost budget over-consumed, then:
8. aware domain-independent planner optimal OSP.

115

fiDomshlak & Mirkis

airport (25)
blocks (23)
depot (3)
driverlog (12)
freecell (5)
grid (2)
gripper (6)
logistics (10)
miconic (50)
mystery (4)
openstacks (7)
rovers (10)
satellite (9)
tpp (7)
trucks (9)
pipesw-t (12)
pipesw-nt (7)
psr-small (30)
zenotravel (10)
total

hM
23
23
3
12
5
2
6
10
50
4
7
10
9
7
9
12
7
30
10
239

25%
basic
23
23
3
12
5
2
6
10
50
4
7
10
8
7
9
12
7
30
10
238

blind
23
23
3
12
5
2
6
10
50
4
7
10
8
7
9
12
7
30
10
238

hM
20
23
3
12
5
2
6
10
50
4
7
10
7
7
9
12
7
30
10
234

50%
basic
20
23
3
12
5
2
6
10
50
4
7
7
6
7
8
12
7
30
9
228

blind
20
23
3
11
5
2
6
10
50
4
7
7
6
7
8
12
7
30
8
226

hM
19
22
3
11
5
2
6
10
50
4
7
7
6
6
6
12
7
30
9
222

75%
basic
20
18
3
9
5
2
6
10
50
4
7
6
4
6
5
11
7
30
8
211

blind
18
17
3
9
5
2
6
10
50
4
7
6
5
6
5
11
7
30
8
209

hM
19
17
3
10
5
1
6
10
50
3
7
6
5
6
5
11
7
30
8
209

100%
basic
20
17
2
7
5
1
6
10
45
3
7
5
4
5
5
10
6
30
7
195

blind
18
17
2
6
5
1
6
10
45
2
7
5
4
5
5
10
6
30
7
191

Table 1: Number problems solved across different budgets using OPEN list ordered heuristic evaluation Figure 3

Blind BFBB constitutes trivial baseline h(n) simply set total value
goals.
basic BFBB, h(n) set total value goals, individually
achieved within respective projection abstraction (see Theorem 1) given entire
remaining budget.
hM additive abstraction heuristic selected Ap (c, u, )
proof Theorem 3.
evaluation contained planning tasks could determine offline
minimal cost budget needed achieve goals. task approached
four different budgets, corresponding 25%, 50%, 75%, 100% minimal
cost needed achieve goals task, run restricted 10 minutes.
Table 1 shows number tasks solved within domain level cost budget.9
Figure 8 depicts results terms expanded nodes across four levels cost budget.
(Figures 18-21 Appendix B provide detailed view results Figure 8
breaking different levels cost budget.) Despite simplicity
abstraction skeletons used, number nodes expanded BFBB hM
typically substantially lower number nodes expanded basic BFBB,
difference sometimes reaching three orders magnitude.
9. reiterate task considered solved upon termination BFBB, is,
optimal plan found proven optimal.

116

fiOn Oversubscription Planning Heuristic Search

(a)
108

unsolved

107
106
105
hM

104
103
102

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

101

100 0
10 101 102 103 104 105 106 107 108
blind

(b)
108

unsolved

107
106
hM

105
104
103
unsolved

102
101

100 0
10 101 102 103 104 105 106 107 108
basic

Figure 8: Comparative view empirical results Table 1 terms expanded nodes

4.1.2 Freeing Cost Partition: Knapsack Meets Convex Optimization
Returning algorithmic analysis context strong 0-binary value partitions,
proceed relaxing constraint sticking fixed action cost partition c.
buys flexibility selecting abstractions Ap (, u, ), allowing us improve
accuracy heuristic estimates, still retaining computational tractability.
117

fiDomshlak & Mirkis

input: = hV, s0 , u; O, c, bi, = {(G1 , 1 ), . . . , (Gk , k )} ,
strong 0-binary value partition u
output: (u)
= 1 k
reduce Gi nodes reachable (s0 )
= k downto 1
always-achievable(m) return
return 0
always-achievable(m):

ellipsoid-method(separation-oracle-Lm
1 ) 7 solution x dom(X ) L1
x[] b return true
else return false
(a)
separation-oracle-Lm
1 (x dom(X )):
let permutation [k]
x[b[
P(1)]] x[b[ (2)]] x[b[ (k)]]
x[] i[m] x[b[ (i)]] return Yes
P
else return constraint i[m] b[ (i)]
(b)
Figure 9: polynomial-time algorithm computing (u) strong 0-binary value
partition u (Theorem 7)

Given OSP task = hV, s0 , u; O, c, bi, homomorphic abstraction skeleton AS,
value partition u AS, let


(u) = min
max
(8)
hM(c,u,b) (s0 , b) .
cCp

b : (c,u,b)Ap

Obviously, estimate h(s0 , b) = (u) least accurate estimate Eq. 7
derived respect fixed cost partition c.
show that, OSP task , abstraction skeleton = {(G1 , 1 ), . . . ,
(Gk , k )} , strong 0-binary value partition u AS, (u)
computed polynomial time. corresponding algorithm shown Figure 9,
Figure 9a depicting macro-flow algorithm Figure 9b depicting specific
implementation solve sub-routine makes overall time complexity
algorithm polynomial.
high-level flow algorithm Figure 9a follows. Since u strong 0binary value partition, let codomain abstract value functions u[i] {0, }
R+ . Given that, (c, u, b) Ap (, u, ), holds hM(c,u,b) (s) =
{0} [k]. k abstract models M(c,u,b)
contribute additive estimate hM(c,u,b) (s) either 0.
118

fiOn Oversubscription Planning Heuristic Search

first loop algorithm preprocessing for-loop eliminates
abstraction skeleton nodes structurally unreachable abstract initial
states 1 (s0 ), . . . , k (s0 ).10 ease presentation, follows assume
cleanup abstraction skeleton leaves Gi least one state whose value
. second for-loop algorithm decreasingly iterates values {k, (k
1), . . . , 2, } possibly come abstractions Ap (, u, ) positive
estimate h (s0 , b). candidates (u) tested turn via sub-routine
always-achievable. test returns positive first time, done,
tested candidate identified (u). Otherwise, test fails [k],
(u) = 0, particular implying state value greater 0 reached
s0 budget b.
test always-achievable (u) = based linear program (LP) Lm
1 , given
Eq. 10. linear program defined variables
#
"
[
[
(9)
{c[i](o)} ,
X = {}
{d(s)}sGi {b[i]}
oO

i[k]

constraints (10a)-(10c), objective maximizing value variable .
Lm
1 :
max
subject


d(i (s0 )) = 0,
[k] : d(s) d(s0 ) + c[i](o), (s0 , o, s) Gi
,


b[i] d(s),
Gi s.t. u[i](s) =
(
c[i](o) 0,
[k]
: P
,
i[k] c[i](o) c(o)
X
Z [k], |Z| = :
b[i].

(10a)

(10b)
(10c)

iZ

roles different variables Lm
1 follows.
Variable c[i](o) captures cost associated label digraph Gi
AS.
state Gi , variable d(s) captures cost cheapest path Gi
(s0 ) s, given edges Gi weighted consistently values
variables c[i]().
Variable b[i] captures minimal budget needed reaching Gi state value
state (s0 ), given that, again, edges Gi weighted consistently
variable vector c[i].
10. preprocessing step replaced adding extra constraints linear program described
below. However, would unnecessarily complicate presentation without adding much value.

119

fiDomshlak & Mirkis

singleton variable captures minimal total cost reaching states value
precisely k models M(c,u,b) .
semantics constraints Lm
1 follows.
first two sets constraints (10a) come simple LP formulation

P single
P source shortest paths problem source node (s0 ): Optimizing
i[k]
sGi d(s) fixed weighting c edges leads computing precisely
that, k digraphs simultaneously.
third set constraints (10a) establishes costs cheapest paths {Gi }
states (s0 ) states valued , enforcing semantics variables b[1], . . . , b[k].
Constraints (10b) cost partition constraints enforce c Cp .
Constraints (10c) enforce aforementioned semantics objective variable .
Two things worth noting here. First, nodes digraphs G1 , . . . , Gk
structurally reachable source nodes 1 (s0 ), . . . , k (s0 ), respectively (as

ensured first for-loop algorithm),
polytope induced L1 bounded
non-empty. Indeed, assignment oO {c[i](o)} consistent
positiveness constraints (10b), variables d() bounded
lengths respective shortest paths. turn, bounding d() bounds
variables c[1], . . . , c[k] via third set constraints (10a), constraints (10c)
bound objective .
Second, number variables, well number constraints (10a)


k
(10b), polynomial |||| ||AS||, number constraints (10c)
. Thus,
solving Lm
1 using standard methods linear programming infeasible. Lemma 5
show problem actually mitigated, then, Lemma 6 show
semantics Lm
1 match objective finding (u).
Lemma 5 algorithm Figure 9 terminates time polynomial |||| ||AS||.
Proof: runtime complexity algorithm boils complexity solving
Lm
1 , and, number variables L1 (m), well number constraints
(10a)
polynomial |||| ||AS||, number constraints (10c)
(10b),
k
cannot solved polynomial time using standard methods linear
.
Thus,
L
1

programming, Simplex algorithm (Dantzig, 1963) Interior-Point methods (Nemirovsky & Yudin, 1994). However, using algorithms,
Ellipsoid algorithm (Grotschel, Lovasz, & Schrijver, 1981) Random Walks family
algorithms originating work Bertsimas Vempala (2004), LP
exponential number constraints solved polynomial time, provided
polynomial time separation oracle LP. polynomial-time separating oracle
convex set K Rn procedure given x Rn , either verifies x K
returns hyperplane separating x K. procedure run polynomial time.
case, separation problem is, given assignment variables Lm
1 , test
whether satisfies (10a), (10b), (10c), not, produce inequality among (10a),
(10b), (10c) violated assignment.
120

fiOn Oversubscription Planning Heuristic Search

show separation problem Lm
1 solved polynomial time
using called m-sum minimization LPs (Punnen, 1992), precisely
(parametrized m) procedure separation-oracle-Lm
1 Figure 9b does. number
constraints (10a) (10b) polynomial, satisfaction assignment x dom(X )
tested directly substitution. constraints (10c), letP permutation [k]
x[b[ (1)]] x[b[ (2)]] x[b[ (k)]]. x[] i[m] x[b[ (i)]],
easy see
Px satisfies constraints (10c). Otherwise, violated
inequality i[m] b[ (i)].

Lemma 6 algorithm Figure 9a computes (u).
proof Lemma 6 appears Appendix A, p. 146. Combining statements
Lemmas 5 6, Theorem 7 summarizes tractability result abstraction discovery
Ap (, u, ) strong 0-binary value partitions u.
Theorem 7 (Ap (, u, )(s) & strong 0-binary u)
Given OSP task = hV, s0 , u; O, c, bi, homomorphic explicit abstraction skeleton
, strong 0-binary value partition u , (u) computed time polynomial
|||| ||AS||.
Unfortunately, practical value result Theorem 7 yet evaluated.
far, found reasonably efficient implementation Ellipsoid method
linear inequalities, while, best knowledge, Random Walks algorithms (Bertsimas & Vempala, 2004) never implemented all. hope state
affairs change soon, allowing powerful algorithms used theory,
practice.
4.1.3 Strong General 0-Binary Value Partitions
Recall polynomial result Theorem 3 strong 0-binary value partitions easily
extends Corollary 4 pseudo-polynomial algorithm general 0-binary value partitions. turns pseudo-polynomial extension Theorem 7 possible well,
though technically involved. corresponding algorithm shown Figure 10.
Following format Figure 9, Figure 10a depicts macro-flow algorithm
Figure 10b shows specific implementation solve sub-routine desired
time complexity achieved.
Similarly algorithm Figure 9, preprocessing for-loop algorithm first
eliminates abstraction skeleton nodes structurally unreachable
abstract initial states 1 (s0 ), . . . , k (s0 ). Next, algorithm performs binary
search interval containing (u).11 Since u 0-binary value partition, [k],
{0, }, R+ , denote codomain abstract value
P function u[i]. Given that,
(c, u, b) Ap (, u, ), holds h(c,u,b) (s) = iZ Z [k].
size combinatorial hypothesis space prohibitive, while-loop Figure 10
performs binary search relaxed hypothesis space, corresponding continuous
11. binary search could used algorithm Figure 9 well, would
mere optimization, necessary avoid exponential blowup time complexity.

121

fiDomshlak & Mirkis

input: = hV, s0 , u; O, c, bi, = {(G1 , 1 ), . . . , (Gk , k )} ,
0-binary value partition u
output: (u)
= 1 k
reduce Gi nodes reachable (s0 )
let 0 < < mini[k]
P
0
i[k]
>
v + ( )/2
always-achievable(v) v
else v
= 0 return 0
else return
always-achievable(v):
ellipsoid-method(separation-oracle-Lv2 ) 7 solution x dom(X ) Lv2
x[] b return true
else return false
(a)
separation-oracle-Lv2
(x dom(X )):

strict-Knapsack( {x[b[i]], }i[k] , x[] ) 7 solution Z [k]
P
iZ < v return Yes
P
else return constraint iZ b[i]
(b)
Figure 10: pseudo-polynomial algorithm approximating (u) general 0-binary
value partitions u (Theorem 10)

P
interval [0, i[k] ] R+0 . parameter serves sufficient precision criterion
termination.
iteration corresponding interval [, ], algorithm uses sub-routine
always-achievable test hypothesis (u) v, v mid-point [, ].
test positive, next tested hypothesis (u) v 0 , v 0 midpoint
[v, ]. Otherwise, next hypothesis corresponds midpoint [, v).
while-loop done, reported estimate set ; still might lag
(u), lag arbitrarily reduced reducing , anyway, (u)
ensures admissibility estimate. If, however, while-loop terminates = 0,
(u) < mini[k] implies (u) = 0, return.
test always-achievable (u) v based linear program Lv2 ,
defined variables X Eq. 9, obtained Lm
1 replacing constraints (10c)
constraints (11c):
122

fiOn Oversubscription Planning Heuristic Search

Lv2 :
max
subject


d(i (s0 )) = 0,
[k] : d(s) d(s0 ) + c[i](o), (s0 , o, s) Gi
,


b[i] d(s),
Gi s.t. u[i](s) =
(
c[i](o) 0,
[k]
: P
,
i[k] c[i](o) c(o)
X
X
Z [k] s.t.
v :
b[i].
iZ

(11a)

(11b)
(11c)

iZ

semantics variables remains Lm
1 , captures minimal
total cost ofPreaching states {si }i[k] abstract models M(c,u,b)
total value i[k] u[i](si ) v. new constraint (11c) enforces semantics .
Lemma 8 > 0, algorithm Figure 10 terminates time polynomial
||||, ||AS||, log 1 , unary representation budget b .
P



Proof: number iterations while-loop approximately log2 i[k]
,

run-time iterations boils complexity solving Lv2 . Here,
v
Lemma 5 linear programs Lm
1 , number variables L2 , well number
constraints (11a) (11b), polynomial |||| ||AS||, number
constraints (11c) (2k ). Therefore, always-achievable(v) employs ellipsoid
method sub-routine separation-oracle-Lv2 associated separation problem.
show separation problem Lv2 solved pseudo-polynomial time
using standard pseudo-polynomial procedure strict Knapsack problem.
Given assignment x dom(X ), feasibility respect (11a) (11b)
tested directly substitution.
constraints (11c),
let Z [k] optimal solution
strict Knapsack problem {x[b[i]], }i[k] , x[] , weight allowance x[] k
objects, object [k] associated weight x[b[i]] value .
P
value iZ Z smaller v, x satisfies constraints
(11c). Assume contrary x violatesP
constraint (11c), corresponding
0
setPZ [k]. definition (11c),
iZ 0 v, assumption,
x[] >
x[b[i]].
That,
however,
implies
Z 0 feasible solution
0
iZ
strict Knapsack, value higher presumably optimal Z.
P
Otherwise, iZ v, Z itselfPprovides us constraint (11c)
violated x. x[] >
iZ x[b[i]] holds
virtue Z
solution strict Knapsack problem {x[b[i]], }i[k] , x[] .


123

fiDomshlak & Mirkis

Lemma 9 0 < < mini[k] , algorithm Figure 10a computes
(u) .
proof Lemma 9 appears Appendix A, p. 147. Combining statements
Lemmas 8 9, Theorem 10 summarizes result optimized abstraction discovery
Ap (, u, ) general 0-binary value partitions u. Importantly, note algorithm
Figure 10 depends unary representation budget, possible
state values. particular, means dependence complexity number
alternative sub-goals OSP task interest polynomial. Finally, Theorem 10
formulated terms estimate precision values abstract value
functions u[i] arbitrary real numbers. case integer-valued sets functions
u, well various special cases real-valued functions, (u) determined
precisely using simplification algorithm Figure 10. instance, 1 , . . . , k
integers, setting value (0, 1) results while-loop terminating
= (u). details, however, theoretical interest; reasonably small
values , practice difference estimates h(s, b) h(s, b) + .
Theorem 10 (Ap (, u, )(s) & 0-binary u)
Given OSP task = hV, s0 , u; O, c, bi, homomorphic explicit abstraction skeleton =
{(G1 , 1 ), . . . , (Gk , k )} , 0-binary value partition u , > 0, possible
approximate (u) within additive factor time polynomial ||||, ||AS||, log 1 ,
unary representation budget b .
4.2 General Value Partitions
0-binary value partitions rather useful themselves, turns
pseudo-polynomial algorithms abstraction discovery explicit homomorphic abstraction skeletons 0-binary value partitions extended rather easily arbitrary value
partitions, using following observations:
(1) OSP task = hV, s0 , u; O, c, bi, homomorphic abstraction skeleton =
{(G1 , 1 ), . . . , (Gk , k )} , value partition u AS, number
distinct values taken u[i] trivially upper-bounded number states Gi ;

(2) pseudo-polynomial solvability Knapsack problem extends general
variant known Multiple-Choice Knapsack (Dudzinski & Walukiewicz, 1987; Kellerer
et al., 2004).
Multiple-Choice (MC) Knapsack problem hN1 , . . . , Nm ; W given weight
allowance W classes objects N1 , . . . , Nm , object j Ni annotated
weight wij value ij . objective
find set Z contains
P
one
P object class maximizes (i,j)Z ij sets satisfying
(i,j)Z wij W. strict MC-Knapsack, refer variant MC-Knapsack
inequality constraint strict. MC-Knapsack generalizes regular Knapsack
thus NP-hard. However, similarly regular Knapsack problem, MC-Knapsack
admits pseudo-polynomial, dynamic programming algorithm runs time polynomial
124

fiOn Oversubscription Planning Heuristic Search

description problem unary representation W (Dudzinski &
Walukiewicz, 1987; Kellerer et al., 2004).
Theorem 11 (Ap (c, u, ))
Let = hV, s0 , u; O, c, bi OSP task, let = {(G1 , 1 ), . . . , (Gk , k )} explicit homomorphic abstraction skeleton , let u arbitrary value
partition AS. Given cost partition c Cp , possible find abstraction
(c, u, b) Ap (c, u, ) compute corresponding heuristic estimate hM(c,u,b) (s0 , b)
time polynomial ||||, ||AS||, unary representation budget b.
Proof: proof similar proof Theorem 3, compilation
MC-Knapsack problem.
[k], let ni number distinct values taken u[i], let {i1 , . . . , ini } R+
codomain u[i], and, j [ni ], let wij cost cheapest path Gi
(s0 ) (one the) states Si u[i](s) = ij . Since explicit abstraction
skeleton, [k], holds ni |Si |, set {wij }i[k],j[ni ] computed
time polynomial ||AS|| using one standard algorithms single-source shortest
paths problem.
Consider MC-Knapsack problem weight allowance b k classes
objects N1 , . . . , Nk , |Ni | = ni object j Ni annotated weight wij

value ij . Let Z ki=1 Ni solution (optimization) MC-Knapsack problem;
recall computable pseudo-polynomial time. Given that, define budget profile
b B follows:
(
wij , (i, j) Z

[k], b [i] =
0,
otherwise.
Showing (c, u, b ) actually induces additive abstraction completely identical proof corresponding argument Theorem 3, thus omitted.

Theorem 12 (Ap (, u, ))
Given OSP task = hV, s0 , u; O, c, bi, homomorphic explicit abstraction skeleton =
{(G1 , 1 ), . . . , (Gk , k )} , arbitrary value partition u AS, > 0,
possible approximate (u) within additive factor time polynomial ||||,
||AS||, log 1 , unary representation budget b .
algorithm abstraction discovery Theorem 12 depicted Figure 11.
high-level flow differs flow algorithm Figure 10 general 0-binary
value partitions initialization parameters . major difference
algorithms tests candidate values v based linear
programs Lv3 , defined follows.
[k], let {i1 , . . . , ini } R+ codomain u[i]. v R+ , linear
program Lv3 defined Eq. 13 variables


[
[
[
{d(s)}sGi
X = {}
{b[i, j]}
{c[i](o)}.
(12)
i[k]

j[ni ]

125

oO

fiDomshlak & Mirkis

input: = hV, s0 , u; O, c, bi, = {(G1 , 1 ), . . . , (Gk , k )} ,
0-binary value partition u
output: (u)
= 1 k
reduce Gi nodes reachable (s0 )
let 0 < < mini[k] minj[ni ] ij
P
0
i[k] maxj[ni ] ij
>
v + ( )/2
always-achievable(v) v
else v
= 0 return 0
else return
always-achievable(v):
ellipsoid-method(separation-oracle-Lv3 ) 7 solution x dom(X ) Lv3
x[] b return true
else return false
(a)
separation-oracle-Lv3 (x
dom(X )):

strict-MC-Knapsack( {x[b[1, j]], 1j }j[n1 ] , . . . , {x[b[k, j]], kj }j[nk ] ; x[] )
7 solution Z [n1 ] [nk ]
P
i[k] iZ(i) < v return Yes
P
else return constraint i[k] b[i, Z(i)]
(b)
Figure 11: (a) modification algorithm Figure 10 arbitrary value partitions
u (Theorem 12), (b) pseudo-polynomial time separation oracle
corresponding linear programs Lv3 Eq. 13

variables differ variable set Lv2 (see Eq. 9) larger set b-variables:
Variable b[i, j] captures minimal budget needed reaching Gi state
value i,j state (s0 ), given edges Gi weighted consistently
variable vector c[i].
126

fiOn Oversubscription Planning Heuristic Search

Lv3 :
max
subject


d(i (s0 )) = 0,
[k] : d(s) d(s0 ) + c[i](o), (s0 , o, s) Gi
,


b[i, j] d(s),
j [ni ]s Gi s.t. u[i](s) = ij
(13a)
(
c[i](o) 0,
[k]
: P
,
(13b)
i[k] c[i](o) c(o)
Z [n1 ] [nk ]
X
X
s.t.
iZ(i) v :
b[i, Z(i)].
i[k]

(13c)

i[k]

Lemma 8 linear programs Lv2 , number variables
Lv3 , well number constraints (13a) (13b), polynomial ||||
||AS||, number constraints (13c) (dk ) = maxi[k] ni . Therefore,
always-achievable(v) employs ellipsoid method pseudo-polynomial time separation oracle, latter based solving strict MC-Knapsack problem (see
Figure 11b). Otherwise, solving Lv2 solving Lv3 similar.
Lemma 13 > 0, algorithm Figure 11 terminates time polynomial
||||, ||AS||, log 1 , unary representation budget b .
Lemma 14 Given OSP task = hV, s0 , u; O, c, bi, homomorphic explicit abstraction
skeleton = {(G1 , 1 ), . . . , (Gk , k )} , arbitrary value partition u
AS, > 0, algorithm Figure 11 computes (u) .
proof Lemma 13 similar proof Lemma 8, strict Knapsack
separation problems replaced strict MC-Knapsack separation problems.
proof Lemma 14 similar proof Lemma 9, mutatis mutandis. Together,
Lemmas 14 13 establish Theorem 12.

5. Landmarks OSP
addition state-space abstractions, family approximation techniques
found extremely effective context optimal classical planning based notion
logical landmarks goal reachability (Karpas & Domshlak, 2009; Helmert & Domshlak,
2009; Domshlak et al., 2012; Bonet & Helmert, 2010; Pommerening & Helmert, 2013).
section proceed examining prospects reachability landmarks
heuristic-search OSP planning.
127

fiDomshlak & Mirkis

5.1 Landmarks Classical Planning
state classical planning task , landmark property operator sequences
satisfied s-plans (Hoffmann, Porteous, & Sebastia, 2004). instance,
fact landmark state assignment single variable true point
every s-plan. state-of-the-art admissible heuristics classical planning use
called disjunctive action landmarks, corresponding set operators
every s-plan contains least one operator set (Karpas & Domshlak, 2009;
Helmert & Domshlak, 2009; Bonet & Helmert, 2010; Pommerening & Helmert, 2013).
follows consider popular notion landmarks, simply refer disjunctive
action landmarks state s-landmarks. ease presentation, discussion take place context landmarks initial state task,
simply referred landmarks (for ).
Deciding whether operator set L landmark classical planning task
PSPACE-hard (Porteous, Sebastia, & Hoffmann, 2001). Therefore, landmark heuristics
employ landmark discovery methods polynomial-time sound, incomplete.
follows assume access procedure; actual way landmarks
discovered tangential contribution.
landmark cost
P set L s-landmarks,

0+
function lcost : L R admissible
lcost(L) h (s). singleton set
L = {L}, lcost(L) := minoL c(o) natural admissible landmark cost function,
extends directly non-singleton sets pairwise disjoint landmarks. general sets
landmarks, lcost devised polynomial time via operator cost partitioning (Katz
& Domshlak, 2010b), either given L (Karpas & Domshlak, 2009), within actual
process generating L (Helmert & Domshlak, 2009).
5.2 -Landmarks Budget Reduction
landmarks play important role (both satisficing optimal) classical planning,
far exploited OSP. first glance, probably surprise,
OSP investigated much less classical planning: Since
landmarks must satisfied plans empty operator sequence always
plan OSP task, notion landmark seem useful here. said
that, consider anytime output improvement property BFBB forward search.
empty plan interesting useless,
found BFBB right beginning. general, stages search,
anytime search algorithms BFBB maintain best-so-far solution , prune
branches promise value lower equal Qb (). Hence, principle, algorithms
may benefit information properties satisfied plans value
larger Qb (). Polynomial-time discovery value landmarks arbitrary OSP
tasks still open problem. However, looking needed available,
show classical planning machinery reachability landmarks actually
effectively exploited OSP.
P follows, assume value function additive, u(s) =
hv/dis uv (d), uv (d) 0 variable-value pairs hv/di. is, value state
sum (mutually independent) non-negative marginal values propositions
comprising s. value different s-plans OSP task varying zero
128

fiOn Oversubscription Planning Heuristic Search

value optimal s-plan (which may zero), let -landmark state
property satisfied s-plan achieves something valuable.
instance, disjunctive action landmarks use here, L -landmark
s, every s-plan Qb () > 0 contains operator L. follows, unless
stated otherwise, focus -landmarks (the initial state of) .
Definition 5 Given OSP task = hV, s0 , u; O, c, bi, -compilation classical planning task = hV , s0 , G ; , c
V = V {g},
dom(g) = {0, 1},
s0 = s0 {hg/0i},
G = {hg/1i},


= Og = ohv/di | hv/di D, uv (d) > 0 ,
pre(ohv/di ) = {hv/di} eff(ohv/di ) = {hg/1i},
(
c(), =
c (o) =
.
0,
= ohv/di Og
put simply, semantics value hg/1i auxiliary variable g
verified proposition positive value achieved.
terms, simply extends structure set zero-cost actions
applying corresponds verifying positive value achieved
. Constructing trivially polynomial time, allows us discover
-landmarks using standard machinery classical planning landmark discovery.
Theorem 15 OSP task , landmark L L landmark .
Proof: proof rather straightforward. Let P set plans
Qb () > 0 P set plans . definition P, plan P,
exists proposition hv/di uv (d) > 0 hv/di s0 JK. Likewise, since
s0
:= s0ff {hg/0i} O, applicable

s0 . ffHence, definition


ohv/di ,
ohv/di applicable s0
hg/1i

J

K,

is,


0
hv/di
hv/di P . turn,

L landmark , ohv/di contains operator L, L O,
contains operator L well. proves landmarks L
operators -landmarks .

Theorem 15 hand, derive -landmarks using method
classical planning landmark extraction, employed LAMA planner (Richter et al., 2008) LM-Cut family techniques (Helmert & Domshlak, 2009;
Bonet & Helmert, 2010). However, first glance, discriminative power knowing
needed achieve something valuable seems negligible comes deriving effective heuristic estimates OSP. good news that, OSP, information
effectively exploited slightly different way.
129

fiDomshlak & Mirkis

Consider schematic example searching optimal plan OPS task
budget b, using BFBB admissible heuristic h. Suppose one
sequence (all unit-cost) operators, = ho1 , o2 , . . . , ob+1 i, applicable initial state
, positive value state along end-state. clearly
value higher zero achieved given budget b, search
continue beyond initial state, unless h(s0 , ) counts cost b + 1 operators
. Now, suppose h(s0 , ) counts cost {oi , . . . , ob+1 } > 0,
{o1 }, {o2 }, . . . , {oi1 } discovered -landmarks . Given that, suppose
modify (a) setting cost operators o1 , o2 , . . . , oi1 zero, (b) reducing
budget b + 1. Since operators o1 , o2 , . . . , oi1 applied anyway
along value collecting plan , modification seems preserve semantics
. time, modified task, BFBB heuristic h prune
initial state thus establish without search empty plan optimal plan
. course, way modified example simplistic example itself.
Yet, example motivate idea landmark-based budget reduction OSP,
well illustrates basic idea behind generically sound task modifications
discuss next.

Definition 6 Let = hV, s0 , u; O, c, bi OSP task, L = {L1 , . . . , Ln } set
pairwise disjoint -landmarks , lcost admissible landmark cost function
L. budget reducing compilation OSP task L = hVL , s0L , uL ; OL , cL , bL

n
X
bL = b
lcost(Li )
(14)
i=1


VL = V {vL1 , . . . , vLn }
dom(vLi ) = {0, 1},
s0L = s0 {hvL1 /1i , . . . , hvLn /1i},
uL = u,
OL =

n
[
i=1

OLi =

n
[

{o | Li },

i=1

pre(o) = pre(o) {hvLi /1i} eff(o) = eff(o) {hvLi /0i},
(
c(o),
=oO
cL () =
.
c(o) lcost(Li ), = OLi
words, L extends structure
mirroring operators -landmark Li cheaper lcost(Li ) versions,
130

fiOn Oversubscription Planning Heuristic Search

CBB

o2
o2

o2 o2
ABB

o1
o1

o3
BTB
o6
o3
BBB
o7
o4
BBT
o4

CTB

o4
o7
o4
BTT
o3
o3
o6
o2
CBT
o2

u=1

o5
o9
o5

u=1

CCB

o8
o10
o8
o5
CTT
o9
o5
u=1

o2
o2
o8
o10
o8

CTC

u=1
CCT

o5
u=2
o9
o5
o8
CCC
o10
o8

CBC

(a)
u=1

CBB
CTB

o2
ABB

o1

BBB

BTB
o6
o3
o7
o4
BBT

o2
o7
o4
BTT

o3
o6
o2

o9
o5

o2

CBB

o10
o8
CTT

u=1
CBT

o10
o8

u=1

CCB

o9
o5

CTC

o2 o2

o9 u=2

o5
u=1
CCT

CCC

ABB

o10
o8

CBC

o1
o1

o3
BTB
o6
o3
BBB
o7
o4
BBT
o4

o2
o2

CTB

o4
o7
o4
BTT
o3
o3
o6
o2
CBT
o2

o5
o9
o5

o2
o2
o8
o10
o8

u=1
CCB

o8
o10
o8
o5
CTT
o9
o5
u=1

u=1
CTC

u=1
CCT

o5
u=2
o9
o5
o8
CCC
o10
o8

CBC

Figure 12: Illustrations example landmark-based budget reducing compilation
L : (a) structurally reachable parts graphical skeleton model
induced L , illustrated projection L variables original
task , along comparison budget-wise reachable parts
graphical skeletons induced models (b) original task (c)
compiled task L .

using disposable propositions hvL1 /1i , . . . , hvLn /1i ensure one
instance discounted operators Li applied along operator
sequence initial state12 ,
compensating discounted operators Li reducing budget precisely
lcost(Li ).
example, consider simple OSP task Figure 2 (p. 104) cost budget
b = 4, assume provided set four landmarks L = {L1 , . . . , L4 }
L1 = {o1 }, L2 = {o2 }, L3 = {o3 , o4 } L4 = {o5 , o8 }, admissible landmark cost
function lcost(Li ) = 1 [4]. Compiling (L, lcost) using budget reducing
compilation Definition
6 results task L budget bL = 0 c(o) = 0
discounted operators ni=1 OLi = {o1 , o2 , o3 , o4 , o5 , o8 }.
states correspond complete assignments three variables V =
{t, x, y}, L already seven variables VL = {t, x, y, vL1 , vL2 , vL3 , vL4 }. Thus, depicting
12. Note that, auxiliary variable g -compilation effectively change value
hg/0i hg/1i, auxiliary variables vLi L change values (only) hvLi /1i hvLi /0i.
difference reflects positive semantics usually associated value 1, aka value
true, planning propositions: semantics state L containing proposition hvLi /1i
still allowed apply (one the) discounted operators associated landmark Li
onwards.

131

fiDomshlak & Mirkis

compile-and-BFBB ( = hV, s0 , u; O, c, bi)
:= -compilation
L := set landmarks
lcost := admissible landmark cost function L
L := budget reducing compilation (L, lcost)
n := BFBB(L )
return plan associated n
Figure 13: BFBB search landmark-based budget reduction
structurally reachable parts graphical skeleton GML problematic. Still,
illustrate search space , Figure 12(a) show (structurally reachable parts
the) graphical skeleton model induced projection variables
{t, x, y} only. arcs corresponding discounted operators colored, color
distinguishing landmark responsible respective discounted operators.
Figures 12(b) 12(c) illustrate effect budget-reducing compilation depicting parts graphical skeletons GM GML actually reachable
respective cost budgets b = 4 bL = 0: states BTT CTT
reachable initial state budget allowance 4, states corresponding BTT CTT longer reachable L , reducing size search space
BFBB. time, formulated Theorem 16 below, reduction
search space affect plans lead valuable states, resulting effective
equivalence L .
Theorem 16 Let = hV, s0 , u; O, c, bi OSP task, L set pairwise disjoint
-landmarks , lcost admissible landmark cost function L, L
respective budget reducing compilation . every Qb () > 0,
plan L L QbL (L ) = Qb (), vice versa.
proof Theorem 16 appears Appendix A, p. 149. budget reducing OSPto-OSP compilation Definition 6 clearly polynomial time. compile-and-BFBB
procedure, depicted Figure 13,
(1) generates -compilation ;
(2) uses off-the-shelf tools classical planning generate set landmarks L
admissible landmark cost function lcost;
(3) compiles (L, lcost) , obtaining OSP task L .
optimal solution L (and thus ) searched using search algorithm
optimal OSP BFBB.
proceed consider general sets landmarks, comments concerning setup Theorem 16 order. First, reduced budget bL turns
lower cost cheapest action applicable initial state, obviously
search needed, empty plan reported optimal right away. Second,
132

fiOn Oversubscription Planning Heuristic Search

zero-cost landmarks useless compilation much useless deriving
landmark heuristics optimal planning. Hence, lcost follows assumed
strictly positive. Third, applicable state brings benefits
yet adds branching search. Hence, implementation, landmark Li L
operator Li , precondition regular operators OL extended
{hvLi /0i}. hard verify extension preserves correctness
L terms Theorem 16. Finally, value initial state zero, is,
empty plan positive value, -compilation positive
cost landmarks all. However, easily fixed considering valuable
propositions hv/di uv (d) > 0 hv/di 6 s0 . ignore time
problem non-zero-value initial states (and assume Qb () = 0), return
later systematic discussion.
5.3 Non-Disjoint -Landmarks
budget reducing compilation L sound pairwise disjoint landmarks,
general sets -landmarks. example, consider planning task
which, operator o, c(o) = b, Qb (hoi) > 0, Qb () = 0
operator sequences 6= hoi. is, value greater zero achievable ,
via operator o. Suppose set -landmarks L = {L1 , . . . , Ln },
n > 1, lcost(Li ) > 0 [n],
Pnthat -landmarks contain o.
case, budget L bL = b i=1 lcost(Li ), cost cheapest replica
o, is, cost cheapest operator sequence achieving non-zero value ,
n

n

i=1

i=1

c(o) max lcost(Li ) = b max lcost(Li ) > b

n
X

lcost(Li ) = bL .

i=1

Hence, state positive value reachable s0L L , thus L
value equivalent sense Theorem 16.
example shows compiling non-disjoint -landmarks independently
sound. principle, made sound follows. Let = hV, s0 , u; O, c, bi
OSP task, let L = {L1 , . . . , Ln } set -landmarks , let lcost admissible
landmark cost function L. components L = hVL , s0L , uL ; OL , cL , bL
still defined Definition 6, except operator sets OL1 , . . . , OLn . latter
constructed independently other, sequentially, content
OLi depending content OLj , j < i. ordering sets OLi
constructed arbitrary.
operator 1 n, let Oo;i denote set cost
discounted representatives introduced
construction OL1 , . . . , OLi .

1 n, operator o0 Li Oo0 ;i1 cL (o) = 0, OLi := .
Otherwise, OLi contains operator operator
Li

[
o0 Li

133

Oo0 ;i1 ,

(15)

fiDomshlak & Mirkis

defined similarly Definition 6 as:
pre(o) = pre(o) {hvLi /1i},
eff(o) = eff(o) {hvLi /0i},
(
c(o) lcost(Li ),
cL (o) =
cL (o) lcost(Li ),

Li ,
.

o0 Li Oo0 ;i1

(16)

compilation extended way sound arbitrary sets -landmarks,
pairwise disjoint landmarks reduces basic compilation used Theorem 16.
general, however, extended compilation longer polynomial size
explicit representation
|Oo;i | = 2|{Lj |ji,oLj }| .
example, let L = {L1 , L2 , L3 }, L1 = {a, b}, L2 = {a, c}, L3 = {a, d}. Generation
OL1 := {a1 , b1 } effectively follows Definition 6, OL2 , base set operators
Eq. 15 already {a, c, a1 }. Thus, OL2 := {a2 , c1 , a3 }, where, {2, 3} denoting
a0 , ai derived according Eq. 16 ai2 . Consequently, base set operators
OL3 {a, d, a1 , a2 , a3 }, resulting OL3 = {a4 , d1 , a5 , a6 , a7 }, where, {4, 5, 6, 7},
ai derived ai4 . sum, L ends 8 = 2|L| representatives operator a.
Since non-disjoint landmarks bring information, typical outputs
standard techniques landmark extraction classical planning, present
different, slightly involved, compilation polynomial sound arbitrary
sets -landmarks.
Definition 7 Let = hV, s0 , u; O, c, bi OSP task, L = {L1 , . . . , Ln } set
pairwise disjoint -landmarks , lcost admissible landmark cost function
L. operator o, let L(o) denote set landmarks L contain
o. Then, generalized budget reducing compilation OSP task L =
hVL , s0L , uL ; OL , cL , bL
bL = b

n
X

lcost(Li ),

i=1

VL = V {vL1 , . . . , vLn }
dom(vLi ) = {0, 1},
s0L = s0 {hvL1 /1i , . . . , hvLn /1i},
uL = u,
OL = {o | L} {get(L) | L L}

pre(o) = pre(o) {hvL /1i | L L(o)},
eff(o) = eff(o) {hvL /0i | L L(o)},

(17)


pre(get(L)) = {hvL /0i},
eff(get(L)) = {hvL /1i},
134

(18)

fiOn Oversubscription Planning Heuristic Search




c(o), P
cL () = c(o) LL(o) lcost(L),


lcost(L),

=oO
.
=o

(19)

= get(L)

illustrate compilation, let L = {L1 , L2 , L3 },
L1 = {a, b},
L2 = {b, c},
L3 = {a, c},
operators cost 2, let
lcost(L1 ) = lcost(L2 ) = lcost(L3 ) = 1.
L , VL = V {vL1 , vL2 , vL3 }
OL = {a, b, c, get(L1 ), get(L2 ), get(L3 )},
with, e.g.,
pre(a) = pre(a) {hvL1 /1i , hvL3 /1i},
eff(a) = eff(a) {hvL1 /0i , hvL3 /0i},
cL (a) = 0,
and, get(L1 ),
pre(get(L1 )) = {hvL /0i},
eff(get(L1 )) = {hvL /1i},
cL (get(L1 )) = 1.
intuition behind compilation Definition 7 follows. Eq. 19, applying
discounted operator saves total cost landmarks containing o. Therefore,
executed states corresponding control propositions
{hvL /1i | L L(o)} hold, indicating cost landmark L(o) already
saved reaching s,
avoid double savings around L(o), applying turns control propositions sJoK.
However, considering example above, suppose optimal plan original
task contains instance operator a, followed instance operator b,
instance operator c. Applying instead would block us applying b instead
b, thus value optimal plan compilation lower Qb ().
rescue comes get(L) actions allow selective spending
individual landmark costs lcost(L). example, applying saves cost
landmarks L1 L3 , applying get(L1 ) spend lcost(L1 ) safely set
135

fiDomshlak & Mirkis

control proposition hvL1 /1i. turn, enable b applied next steps,
applying b save cost L2 re-save cost L1 . way,
compilation leads equivalence L , formulated Theorem 17
proven Appendix A, p. 149.
Theorem 17 Let = hV, s0 , u; O, c, bi OSP task, let L = {L1 , . . . , Ln } set
-landmarks , let lcost admissible landmark cost function L, let L
(generalized) budget reducing compilation . every Qb () > 0,
plan L L QbL (L ) = Qb (), vice versa.
5.4 -Landmarks & Incremental BFBB
discussed earlier, value initial state zero, empty plan
positive value, thus -compilation Definition 5
landmarks positive cost. passing noted small problem remedied
considering valuable facts hv/di uv (d) > 0 hv/di 6 s0 .
consider aspect OSP closely, show discovery -landmarks
incremental revelation plans BFBB combined mutually stratifying
way.
Let = hV, s0 , u; O, c, bi OSP task interest, suppose given set
plans 1 , . . . , n . so, longer interested searching plans
achieve something, searching plans achieve something beyond
1 , . . . , n already achieve. Specifically, let si = s0 Ji K end-state ,
set propositions D, let goods(s) set propositions hv/di
uv (d) > 0. new plan end-state achieves something beyond 1 , . . . , n
already achieve, then, 1 n,
goods(s) \ goods(si ) 6= .
put observation work.
Definition 8 Given OSP task = hV, s0 , u; O, c, bi set reference states Sref =
{s1 , . . . , sn } , (, Sref )-compilation classical planning task (,Sref ) =
hV , s0 , G ; , c
V = V {x1 , . . . , xn , search, collect},
dom(xi ) = dom(search) = dom(collect) = {0, 1},
s0 = s0 {hsearch/1i , hcollect/0i , hx1 /0i , . . . , hxn /0i},
G = {hx1 /1i , . . . , hxn /1i},
n
[
=
Oi {f inish},
i=1


136

fiOn Oversubscription Planning Heuristic Search

= {o | O},
pre(o) = pre(o) {hsearch/1i},
eff(o) = eff(o),
c (o) = c(o).

pre(f inish) = ,
eff(f inish) = {hcollect/1i , hsearch/0i},
c (f inish) = 0.
Oi = {oi,g | si Sref , g goods(D) \ si },
pre(oi,g ) = {g, hcollect/1i},
eff(oi,g ) = {hxi /1i},
c (oi,g ) = 0.
Note
goal G cannot achieved without applying f inish operator;
regular operators applied f inish;
subgoal achieving operators oi,g applied f inish.
way, first part plan (,Sref ) determines plan , second part
verifies end-state plan achieves subset value-carrying propositions
goods(D) included state Sref .13
Theorem 18 Let = hV, s0 , u; O, c, bi OSP task, Sref = {s1 , . . . , sn } subset
states, L landmark (,Sref ) L O. plan
goods(s0 JK) \ goods(si ) 6= si Sref , contains instance least one
operator L0 = {o | L}.
Proof: Assume contrary exists plan = ho1 , . . . , ok
goods(s0 JK) \ goods(si ) 6= si Sref , yet L0 = . Let {g1 , . . . , gn }
arbitrary set propositions goods(s0 JK) \ goods(s1 ), . . . , goods(s0 JK) \ goods(sn ),
respectively. construction (,Sref ) , immediate
(,Sref ) = ho1 , . . . , ok , f inish, o1,g1 , . . . , on,gn
plan (,Sref ) and, assumption L0 , holds (,Sref ) L = .
This, however, contradicts L landmark (,Sref ) .

13. solve & verify technique appears helpful many planning formalism compilations; see,
e.g., work Keyder Geffner (2009).

137

fiDomshlak & Mirkis

inc-compile-and-BFBB ( = hV, O; s0 , c, u, bi)
initialize global variables:
n := s0
// best solution far
Sref := {s0 } // current reference states
loop:
(,Sref ) = (, Sref )-compilation
L := set landmarks (,Sref )
lcost := admissible landmark cost function L
L := budget reducing compilation (L, lcost)
inc-BFBB(L , Sref , n ) = done:
return plan associated n
inc-BFBB (, Sref , n )
open := new max-heap ordered f (n) = h(shni, b g(n))
open.insert(make-root-node(s0 ))
closed:=
best-cost:= 0
open.empty()
n := open.pop-max()
f (n) u(shn i): break
u(shni) > u(shn i): update n := n
goods(shni) 6 goods(s0 ) s0 Sref :
Sref := Sref {shni}
termination criterion: return updated
// rest similar BFBB Figure 3

shni 6 closed g(n) < best-cost(shni):
closed:= closed {shni}
best-cost(shni) := g(n)
foreach O(shni):
n0 := make-node(shniJoK, n)
g(n0 ) > b f (n0 ) u(shn i): continue
open.insert(n0 )
return done
Figure 14: Iterative BFBB landmark enhancement
Theorem 18 allows us define iterative version BFBB, inc-compile-and-BFBB,
depicted Figure 14. successive iterations inc-compile-and-BFBB correspond
running regular BFBB successively informed (, Sref )-compilations ,
states discovered iteration making (, Sref )-compilation used iteration + 1
informed.
inc-compile-and-BFBB maintains pair global variables: set reference states
Sref best solution far n . iteration loop, modified version
BFBB, inc-BFBB, called (, Sref )-compilation , created basis
138

fiOn Oversubscription Planning Heuristic Search

current Sref . reference set Sref extended inc-BFBB non-redundant
value-carrying states discovered search, n updated search discovers
nodes higher value.
OPEN list becomes empty node n selected list promises
less lower bound, inc-BFBB returns indicator, done, best solution
n found far, across iterations inc-compile-and-BFBB, optimal. case,
inc-compile-and-BFBB leaves loop extracts optimal plan n . However,
inc-BFBB may terminate different way, certain complementary termination
criterion satisfied. latter criterion comes assess whether updates Sref
performed current session inc-BFBB warrant updating (, Sref )-compilation
restarting search. terminated way, inc-BFBB returns respective indicator,
inc-compile-and-BFBB goes another iteration loop, updated Sref
n . note that, optimality algorithm holds termination
condition, latter greatly affect runtime efficiency algorithm.
Theorem 19 inc-compile-and-BFBB search algorithm sound complete optimal OSP.
Proof: First, complementary termination criterion employed inc-BFBB procedure, inc-compile-and-BFBB guaranteed terminate. complementary termination criterion checked inc-BFBB proper expansion
global reference set Sref , thus number calls inc-BFBB inc-compile-and-BFBB
upper-bounded |S|.
terms search, inc-BFBB different regular BFBB procedure. turn,
Theorem 18, additional pruning power budget-reducing compilation reference
states Sref affects search nodes n u(shni) < maxsSref u(s). Note that,
time best solution far n updated inc-BFBB, necessarily added Sref
(since goods(shn i) new n included goods(s) Sref ). Thus, optimal
solutions cannot pruned inc-BFBB overall search inc-compile-and-BFBB
therefore sound.

5.5 Empirical Evaluation
evaluate merits landmark-based budget reducing compilation, extended prototype OSP solver Section 3 following components:
(, Sref )-compilation OSP tasks arbitrary sets reference states Sref ;
generation disjunctive action landmarks (, Sref )-compilations using LM-Cut
procedure (Helmert & Domshlak, 2009) Fast Downward;
incremental BFBB procedure inc-compile-and-BFBB Figure 14,
search termination criterion satisfied (only) examined node n improves
current value lower bound, i.e., n becomes new best-so-far node n .
preliminary evaluation, added two optimality preserving enhancements search. auxiliary variables compilations increase dimensionality problem, known negatively affect quality abstraction
139

fiDomshlak & Mirkis

(a) blind
108

unsolved

107
106
105
104
103
102

unsolved

compile-and-BFBB

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

101

100
100 101 102 103 104 105 106 107 108
BFBB

(b) hM
108

unsolved

106
105
104
103
102

unsolved

compile-and-BFBB

107

101

100
100 101 102 103 104 105 106 107 108
BFBB

Figure 15: Comparative view empirical results terms expanded nodes, BFBB
vs. compile-and-BFBB, (a) blind (b) abstraction hM heuristics

heuristics (Domshlak et al., 2012), first devised projections respect original OSP problem , open list ordered search done original
problem, is,


X
h shniV , b g(n) +
lcost(L) ,
vL 6shni

sV projection L state variables original OSP task .
change heuristic evaluation sound, Theorem 17 particular implies
140

fiOn Oversubscription Planning Heuristic Search

admissible heuristic admissible heuristic L , vice versa. Second,
new node n generated, check whether
X
X
lcost(L),
lcost(L) g(n0 ) +
g(n) +
L:hvL /0ishn0

L:hvL /0ishni

previously generated node n0 corresponds state original
problem , is, shn0 iV = shniV . so, n pruned right away. Optimality
preservation enhancement established Lemma 20 proven Appendix A,
p. 151.
Lemma 20 Let OSP task, (,Sref ) (, Sref )-compilation , L set
landmarks (,Sref ) , lcost admissible landmark cost function L, L
respective budget reducing compilation (L, lcost) . Let 1 2 pair plans
V
L end-states s1 s2 , respectively, sV
1 = s2
cL (1 ) +

X

lcost(L) cL (2 ) +

L:hvL /0is1

X

lcost(L).

(20)

L:hvL /0is2

Then, plan 10 extends 1 , exists plan 20 extends 2
= QbL (10 ).

QbL (20 )

evaluation included regular BFBB planning , solving using landmarkbased compilation via compile-and-BFBB, simple setting inc-compile-and-BFBB
described above. three approaches evaluated blind heuristic
additive abstraction heuristic hM described Section 3. Figures 15-17 depict results
evaluation terms expanded nodes. Similarly experiment reported
Section 3, task approached four different budgets, corresponding 25%,
50%, 75%, 100% minimal cost needed achieve goals task,
run restricted 10 minutes. Figures 15a 15b compare number
expanded nodes BFBB compile-and-BFBB across four levels cost budget,
blind (a) abstraction hM (b) heuristics. Figures 16a 16b provide similar
comparison BFBB inc-compile-and-BFBB. Figures 17a 17b
compile-and-BFBB inc-compile-and-BFBB.14 Figures 22-25 Figures 26-29
Appendix B provide detailed view results Figures 15 16, respectively,
breaking different levels cost budget.
Figure 8 shows, results satisfactory. informative heuristic
guidance all, number nodes expanded compile-and-BFBB typically much
lower number nodes expanded BFBB, difference reaching three
orders magnitude once. 760 task/budget pairs behind Figure 8a, 81
pairs solved compile-and-BFBB search (by proving plan
achieve value higher initial state), while, unsurprisingly, 4
tasks solved search BFBB.
14. present detailed comparison terms running times, per-node CPU
time overhead due landmark-based budget reduction 10%. technical difficulties
implementation inc-compile-and-BFBB led us limit comparison graph tasks
solved methods.

141

fiDomshlak & Mirkis

(a) blind
108
107
inc-compile-and-BFBB

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

106
105
104
103
102
101
100
100 101 102 103 104 105 106 107 108
BFBB

(b) hM
108
inc-compile-and-BFBB

107
106
105
104
103
102
101
100
100 101 102 103 104 105 106 107 108
BFBB

Figure 16: Comparative view empirical results terms expanded nodes, BFBB
vs. inc-compile-and-BFBB, (a) blind (b) abstraction hM heuristics

expected, impact landmark-based budget reduction lower
search equipped meaningful heuristic (Figure 15b). Nonetheless, even
abstraction heuristic hand, number nodes expanded compile-and-BFBB
often substantially lower number nodes expanded BFBB. Here, BFBB
compile-and-BFBB solved search 39 85 task/budget pairs, respectively. Finally, despite rather ad hoc setting incremental inc-compile-and-BFBB procedure,
switching compile-and-BFBB inc-compile-and-BFBB typically beneficial. Obvi142

fiOn Oversubscription Planning Heuristic Search

(a) blind
108
107
inc-compile-and-BFBB

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

106
105
104
103
102
101
100 0
10 101 102 103 104 105 106 107 108
compile-and-BFBB

(b) hM
108
inc-compile-and-BFBB

107
106
105
104
103
102
101
100 0
10 101 102 103 104 105 106 107 108
compile-and-BFBB

Figure 17: Comparative view empirical results terms expanded nodes,
compile-and-BFBB vs. inc-compile-and-BFBB, (a) blind (b) abstraction hM heuristics

ously, much deeper investigation development inc-compile-and-BFBB still required,
especially context choice iteration termination criterion.

6. Summary Future Work
Deterministic oversubscription planning captures computational core one
important setups automated action selection, yet, despite apparent importance
143

fiDomshlak & Mirkis

problem, sufficiently investigated. work, progressed towards
translating spectacular advances classical deterministic planning deterministic
OSP. Tracing key sources progress classical planning, identified severe lack
effective approximations OSP, worked towards bridging gap.
focus two classes approximation techniques underly state-ofthe-art optimal heuristic-search solvers classical planning: state-space abstractions
goal-reachability landmarks. First, defined notion additive abstractions OSP,
studied complexity deriving effective abstractions rich space hypotheses,
revealed substantial, empirically relevant islands tractability abstraction
discovery problem. Next, showed standard goal-reachability landmarks certain
classical planning tasks compiled OSP task interest, resulting
equivalent OSP task lower cost allowance, thus sometimes dramatically
smaller search space.
techniques proposed satisfy properties required efficient search
algorithms optimal OSP. However, believe techniques, especially
landmark-based budget reducing compilations, beneficial satisficing OSP
optimal OSP, particular difference optimal satisficing
planning appears much smaller OSP classical deterministic planning.
Many interesting questions remain open future work, prospects
developments oversubscription planning appear quite promising. Within specific
context work, two interesting research directions (1) optimization value
partitions given cost partitions, is, optimizing abstraction discovery Ap (c, , ),
(2) thoroughly investigating interleaved landmark discovery search OSP
introduced Section 5.4. broader context, propose, well, additional candidates
future research:
Following work Katz Domshlak (2010a) implicit abstractions classical planning, computational merits implicit abstractions OSP
investigated. inevitably give us better understanding computational
tractability boundaries deterministic OSP.
basic model deterministic planning Section 2.1 used provide unifying
comparative view basic models classical, cost-bounded, net-benefit,
oversubscription planning. One practically motivated extension model lift
action costs vectors action costs. variant cost-bounded planning
already investigated (Nakhost et al., 2012), natural examine
extension context OSP.
Unfortunately, results abstractions seem extend directly vectors
costs: level planning model, adding cost measures shifts problem solving
polynomial time shortest path(s) problems NP-hard restricted shortest path(s)
problems (Handler & Zang, 1980). Nonetheless, Knapsack problem, restricted shortest path problem solved pseudo-polynomial time (Desrochers
& Soumis, 1988), thus extension results vectors costs might still
achievable.
time, machinery landmark-based budget reducing compilations
OSP straightforwardly extends vectors costs budgets. Hence, even
144

fiOn Oversubscription Planning Heuristic Search

quality heuristic OSP multiple cost measures available, blind search
still stratified information coming problem landmarks.
pruning mechanism BFBB must rely admissible, upper-bounding
heuristic estimates, special properties required heuristic used guide
search choices BFBB. Thus, developing informative yet necessarily admissible
heuristics OSP clearly interest.
Acknowledgments
work partially supported EOARD grant FA8655-12-1-2096, ISF
grant 1045/12.

Appendix A. Proofs
Theorem 2 Given OSP task = hV, s0 , u; O, c, bi homomorphic abstraction
skeleton = {(G1 , 1 ), . . . , (Gk , k )} ,
(1) cost partition c Cp , exists budget partition b Bp

M(c,u,b ) value partitions u ;
(2) budget partition b Bp , exists cost partition c Cp

M(c ,u,b) value partitions u .
Proof: Let = h(s0 , o1 , s1 ), (s1 , o2 , s2 ), . . . , (sn1 , , sn )i optimal s0 -plan ,
and, [k], let = h(i (s0 ), o1 , (s1 )), . . . , (i (sn1 ), , (on ))i mapping
Gi . Since homomorphic, paths 1 , . . . , k well-defined.
(1) P
Given cost partition c Cp , let budget profile b B defined b [i] =

j[n] c[i](oj ), [k]. First, note b Bp since
X
i[k]

()

X X

b [i] =

c[i](oj )

i[k] j[n]

X

()

c(oj ) b,

j[n]

() c cost partition, () s0 -plan .
Second, u U, construction b , (s0 )-plan abstract
(c,u,b )
model Mi
. Now, let u , [k], let optimal (s0 )-plan
(c,u,b )
Mi
.
X
i[k]

Qb

[i]

()

(i )

X

[i]

Qb

()

(i ) Qb (),

(21)

i[k]

() optimality , () (sn ) end-state u
value partition. Therefore, (c, u, b ) induces additive abstraction ,

is, M(c,u,b ) AAS .
145

fiDomshlak & Mirkis

(2) Given budget partition b, let cost profile c C defined c [i](o) = c(o) b[i]
b ,
forPall operators O, [k]. First, c Cp since b Bp implies
1

i[k] b[i] [0, 1]. Second, u U, construction c , (s0 )b
(c ,u,b)

plan Mi
. Following exactly line reasoning Eq. 21

accomplishes proof M(c ,u,b) AAS u .

Lemma 6 algorithm Figure 9a computes (u).
Proof: Due boundness non-emptiness polytope induced Lm
1 , termination algorithm straightforward. Thus, given strong 0-binary partition u,
question whether value algorithm terminates (u). First, let
us show that:
() [k], x solution Lm
1 , x[] b if, cost partition
c Cp , exists budget partition b Bp (c, u, b) abstraction
hM(c,u,b) (s0 ) m.
() Assume contrary that, cost partition c Cp , exists budget partition b Bp hM(c,u,b)
(s0 ) m, yet x[] > b. Given values provided x cost variables oO {c[i](o)}, let c corresponding cost partition,
1 , . . . , k induced lengths shortest paths 1 (s0 ), . . . , k (s0 ) valued states G1 , . . . , Gk , respectively. assumption, let b budget partition
hM(c,u,b) (s0 ) m. First, definition strong 0-binary value partitions,
hM(c,u,b) (s0 ) implies exists Z k, |Z| = that, Z, b[i] .
Second, constraint (10c), maximization , fact bound b[i]
imply together that, Z, x[b[i]] = . Putting things together, obtain
bBp

b

X

b[i]

iZ

X

=

iZ

X

(10c)

x[b[i]] ,

iZ

contradicting assumption.
() Assume contrary that, x[] b, yet exists cost partition c Cp
that, budget partitions b Bp (c, u, b) Ap , hM(c,u,b) (s0 ) < m.
Let shortest path lengths 1 , . . . , k defined above, respect
specific cost partition c assumption.
Likewise, let xc solution Lm
1

extra constraint cost variables oO {c[i](o)} assigned c. Since objective
Lm
1 maximize value ,
x[] xc [].

(22)

Now, let
Z=

argmax

X

Z 0 [k],|Z 0 |=m iZ 0

146

.

fiOn Oversubscription Planning Heuristic Search

Together, constraint (10c), maximization , fact bound
b[i] (via cost variables) imply
xc [] =

X

xc [b[i]] =

iZ

X

.

(23)

iZ

turn, together x[] b Eq. 22, Eq. 23 implies
(
xc [b[i]],
b[i] =
0,

iZ
otherwise

budget partition (c, u, b) Ap , hM(c,u,b) (s0 ) m, contradicting assumption.
proved sub-claim (), basically captures semantics Lm
1 , suppose
algorithm terminates within loop, returns > 0.
construction algorithm, x solution Lm
1 , x[] b. (), cost
partition c Cp , exists (c, u, b) Ap h(c,u,b) (s) m. = k,
trivially (u) = m. Otherwise, < k, know algorithm terminate
previous iteration corresponding + 1. Again, () implies exists
cost partition c Cp (c, u, b) Ap induce h(c,u,b) (s) (m + 1). Hence,
definition (u), (u) < (m + 1), turn, since u strong 0-binary value
partition, (u) = m. Finally, algorithm terminates loop
returns 0, precisely argument basis () implies (u) = 0.

Lemma 9 0 < < mini[k] , algorithm Figure 10a computes
(u) .
Proof: arguments boundness non-emptiness polytope induced
Lv2 precisely polytope Lm
1 studied Lemma 6, thus
termination algorithm straightforward. follows, prove value
returned algorithm satisfies claim lemma. Let u given 0-binary
partition. Similarly proof Lemma 9, first prove sub-claim that:
() v R0+ , x solution Lv2 , x[] b if, cost partition
c Cp , exists budget partition b Bp (c, u, b) abstraction
hM(c,u,b) (s0 ) v.
proof () mirrors proof respective sub-claim Lemma 5, mutatis mutandis,
thus provided ease verification.
() Assume contrary that, cost partition c Cp , exists budget
partition b Bp hM(c,u,b) (s0 ) v, yet x[] > b.

Given values provided x cost variables oO {c[i](o)}, let c corresponding cost partition, and, [k], let induced length shortest
path (s0 ) -valued states Gi . assumption, let b budget
partition hM(c,u,b) (s0 ) v. First,
P definition 0-binary value partitions,
hM(c,u,b) (s0 ) v implies exists Z k, iZ v that, Z, b[i] .
147

fiDomshlak & Mirkis

Second, constraint (11c), maximization , fact bound b[i]
, imply together that, Z, x[b[i]] = . Putting things together, obtain
bBp

b

X

b[i]

iZ

X

=

iZ

X

(11c)

x[b[i]] ,

iZ

contradicting assumption.
() Assume contrary that, x[] b, yet exists cost partition c Cp
that, budget partitions b Bp (c, u, b) Ap , hM(c,u,b) (s0 ) < v.
Let shortest path lengths 1 , . . . , k defined above, respect
specific cost partition c assumption.
Likewise, let xc solution Lv2

extra constraint cost variables oO {c[i](o)} assigned c. Since objective
Lv2 maximize value ,
x[] xc [].

(24)

Now, let
Z = argmax

X

0
PZ [k], iZ 0
iZ 0 v

.

Together, constraint (11c), maximization , fact bound
b[i] (via cost variables) imply
xc [] =

X

xc [b[i]] =

iZ

X

.

(25)

iZ

turn, together x[] b Eq. 24, Eq. 25 implies
(
xc [b[i]], Z
b[i] =
,
0,
otherwise
budget partition (c, u, b) Ap , hM(c,u,b) (s0 ) v, contradicting assumption.
finalizes proof sub-claim (). Now,Pconsider interval end-points
termination
while-loop. =
i[k] , then, trivially, (u) .
P
Otherwise, < i[k] , then, construction algorithm, iteration
loop, test always-achievable() issued, came back negative, thus,
solutions x L2 , x [] > b. Hence, (), (u) < . Now, 6= 0, then,
construction algorithm, iteration loop, test always-achievable()
issued, came back positive, thus, solutions x L2 , x [] b.
Hence, (), (u) . Putting properties together while-loops
termination condition implies (u) = (u) . Finally, = 0,
< mini[k] implies < mini[k] . turn, since (u) corresponds sum values
states k models M(c,u,b) , (u) concluded implies = (u) = 0.

148

fiOn Oversubscription Planning Heuristic Search

Theorem 16 Let = hV, s0 , u; O, c, bi OSP task, L set pairwise disjoint
-landmarks , lcost admissible landmark cost function L, L
respective budget reducing compilation . every Qb () > 0,
plan L L QbL (L ) = Qb (), vice versa.
Proof: Let L plan
Snfor L , let operator sequence obtained replacing
operators i=1 OLi along L respective operators O.
definition
action set L Eq. 15, applicable s0 , s0 JK =
s0L JL K \ ni=1 dom(vLi ). Thus, Qb () = QbL (L ). Likewise, definition
action set L Eq. 15 fact operator OL achieves control
propositions {hvL1 /1i , . . . , hvLn /1i}, |OLi L | 1. that,

c() cL (L ) +

n
X

lcost(Li ).

i=1

P
turn, b = bL + ni=1 lcost(Li ) Eq. 14, cL (L ) bL virtue L
plan L . Therefore, holds c() b, thus plan .
opposite direction, let plan Qb () > 0, let L
operator sequence obtained replacing, -landmark L L, every first occurrence
operator L respective cost reduced operator OL . easy
verify L applicable s0L , QbL (L ) = Qb (). Likewise, definition
-landmarks, every L L presence along . that,

c(L ) = c()

n
X

lcost(Li ) b

i=1

n
X

lcost(Li ) = bL ,

i=1

first equality pairwise disjointness {L1 , . . . , Ln }, inequality
plan , second equality Eq. 14. Thus, L plan L .


Theorem 17 Let = hV, s0 , u; O, c, bi OSP task, let L = {L1 , . . . , Ln } set
-landmarks , let lcost admissible landmark cost function L, let L
(generalized) budget reducing compilation . every Qb () > 0,
plan L L QbL (L ) = Qb (), vice versa.
Proof: Let L plan L , let operator sequence obtained (i) replacing
operators respective operators O, (ii) removal get operators.
Eq. 17, applicable s0 , s0 JK = s0L JL K \ {hvL1 /1i , . . . , hvLn /1i}. Thus,
Qb () = QbL (L ). Now, -landmark L L, let (L) number instances
cost reduced counterparts operators L along L . Eqs. 17 18,
L L, L must contain least (L) 1 instances operator get(L). that,

149

fiDomshlak & Mirkis

X

c() cL (L ) +

X

lcost(L)

oL LL(o)

= cL (L ) +

X
X

((L) 1)lcost(L)



(L)lcost(L)



= cL (L ) +

X

X

((L) 1)lcost(L)



lcost(L)



bL +

X

lcost(L)



= b,
thus plan .
opposite direction, let = ho1 , . . . , om plan Qb () > 0.
definition -landmarks, every landmark Li L presence along . Let
(i) , f (i) [n], first occurrence
ffoperator Li along , is, f (i) =


let = o(1) , . . . , o(k) , k n, operator sequence obtained
argminj[m] {oj Li },
ordering operators i[n] {of (i) } consistently . Note that, since -landmarks
L necessarily disjoint, may f (i) = f (j) 1 6= j n, thus
k strictly smaller n.
Given above, let L operator sequence obtained based
(1) replacing o(i) along o(i) ,
(2) inserting right o(i) arbitrary ordered sequence actions
i1
[

{get(L) | L L, {o(j) , o(i) } L}.

(26)

j=1

Note set union semantics Eq. 26: even multiple operators {o(1) , . . . , o(i1) }
appear landmark L together o(i) , one instance operator get(L)
inserted step (2) o(i) .
hard verify L applicable s0L , QbL (L ) = Qb (). Now,
step (1) expanding L reduces cost operator sequence
k
X

X

lcost(L) =

i=1 LL(o(i) )

X

(L)lcost(L),



(L) number occurrences operators fromP
L . turn, step (2)
expanding L increases cost operator sequence ((L) 1)lcost(L).
because, Eq. 26, among (L) operators o(i) along L o(i) L,
first preceded dedicated instances operator get(L). Thus,
X
X
cL (L ) = c()
lcost(L) b
lcost(L) = bL ,




is, L plan L .


150

fiOn Oversubscription Planning Heuristic Search

Lemma 20 Let OSP task, (,Sref ) (, Sref )-compilation , L set
landmarks (,Sref ) , lcost admissible landmark cost function L, L
respective budget reducing compilation (L, lcost) . Let 1 2 pair plans
V
L end-states s1 s2 , respectively, sV
1 = s2
cL (1 ) +

X

lcost(L) cL (2 ) +

Then, plan
b
L
Q (20 ) = QbL (10 ).

lcost(L).

(20)

L:hvL /0is2

L:hvL /0is1

10

X

extends 1 , exists plan 20 extends 2

Proof: notation claim, proof constructive mapping plan
10 corresponding plan 20 .
First, derive 10 plan 01 (i) removing f inish operator
get() operators, (ii) replacing instances discounted operator
instances respective original operator o. results plan 01 := 1 1e
P
s0 [[1 ]] = sV
1 c(1 ) = cL (1 ) +
L:hvL /0is1 lcost(L). see latter,

operator OL , let () 0 denote number instances along 1 . Given that,

c(1 ) = cL (1 )

X

(get(L))lcost(L) +



X

= cL (1 ) +

lcost(L)



= cL (1 ) +

X

X

X

(o)



o:LL(o)






X

lcost(L)

(o) (get(L))

o:LL(o)

(27)

lcost(L) 1s1 (hvL /0i)



= cL (1 ) +

X

lcost(L),

L:hvL /0is1

second fourth equalities formula manipulations, first equality
direct construction 1 , third equality definition budget
reducing compilation, specifically, Eqs. 17 18.
Similarly construction P
1 1 , construct 2 2 ,

s0 [[2 ]] = sV

c(
)
=
c
(
)
+
2
2
L
2
L:hvL /0is2 lcost(L). Thus, Eq. 20, c(1 ) c(2 ),
also, setting lemma, s0 [[1 ]] = s0 [[2 ]]. Hence, 02 = 2 1e plan
, Qb (01 ) = Qb (02 ).
last step, construct 02 plan 20 L claim. First,
properties 2 claim, plan 2 achieves landmarks L6s2 = {L |
hvL /0i s2 }. Second, definition landmark set L, 1e must satisfy rest
landmarks, is, Ls2 = {L | hvL /1i s2 }. Let us denote operator instances along
1e ho1 , . . . , ok i, k = |1e |, let {L1 , . . . , Lk } partition Ls2 Li Ls2
subset landmarks Ls2 oi first achiever along 1e .
Given that, consider operator sequence 2e := (k) , recursively defined via (0) = ,
and, Li = , (i) = (i1) hoi i, else (i) = (i1) hoi i, (arbitrary)
151

fiDomshlak & Mirkis

sequencing operators
{get(L) | L Li hvL /0i s0 J2 KJ (i1) K}.
Finally, set 20 := 2 2e .
Eqs. 17 18 definition budget reducing compilation,
easy
P
verify construction 2e ensures cL (2e ) = c(1e ) hvL /1is2 lcost(L)
QbL (2e ) = Qb (02 ). turn, properties 2 , implies QbL (20 ) = QbL (10 )
cL (20 ) = cL (2 ) + cL (2e ).
Finally, since
X
lcost(L)
cL (2 ) = c(2 )
hvL /0is2


X

cL (2e ) = c(1e )

lcost(L),

hvL /1is2


cL (20 ) = c(2 ) + c(1e )

X

lcost(L).



Thus, since c(1 ) c(2 ) 01 = 1 1e valid plan ,
X
cL (20 ) c(1 ) + c(1e )
lcost(L)




c(01 )



X

lcost(L)



b

X

lcost(L),



finalizing proof 20 plan L claim.

152



fiOn Oversubscription Planning Heuristic Search

Appendix B. Detailed Evaluation Results
(a)
108

unsolved

107
106
105
hM

104
103
102

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

101

100 0
10 101 102 103 104 105 106 107 108
blind

(b)
108

unsolved

107
106
hM

105
104
103
unsolved

102
101

100 0
10 101 102 103 104 105 106 107 108
basic

Figure 18: comparison Figure 8, p. 117, restricted tasks budgeted 25%
minimal cost achieving entire set subgoals

153

fiDomshlak & Mirkis

(a)
108

unsolved

107
106
105
hM

104
103
102

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

101

100 0
10 101 102 103 104 105 106 107 108
blind

(b)
108

unsolved

107
106
hM

105
104
103
unsolved

102
101

100 0
10 101 102 103 104 105 106 107 108
basic

Figure 19: comparison Figure 8, p. 117, restricted tasks budgeted 50%
minimal cost achieving entire set subgoals

154

fiOn Oversubscription Planning Heuristic Search

(a)
108

unsolved

107
106
105
hM

104
103
102

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

101

100 0
10 101 102 103 104 105 106 107 108
blind

(b)
108

unsolved

107
106
hM

105
104
103
unsolved

102
101

100 0
10 101 102 103 104 105 106 107 108
basic

Figure 20: comparison Figure 8, p. 117, restricted tasks budgeted 75%
minimal cost achieving entire set subgoals

155

fiDomshlak & Mirkis

(a)
108

unsolved

107
106
105
hM

104
103
102

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

101

100 0
10 101 102 103 104 105 106 107 108
blind

(b)
108

unsolved

107
106
hM

105
104
103
unsolved

102
101

100 0
10 101 102 103 104 105 106 107 108
basic

Figure 21: comparison Figure 8, p. 117, restricted tasks budgeted 100%
minimal cost achieving entire set subgoals

156

fiOn Oversubscription Planning Heuristic Search

(a) blind
108

unsolved

107
compile-and-BFBB

106
105
104
103
102

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

101

100
100 101 102 103 104 105 106 107 108
BFBB

(b) hM
108

unsolved

compile-and-BFBB

107
106
105
104
103
unsolved

102
101

100
100 101 102 103 104 105 106 107 108
BFBB

Figure 22: comparison Figure 15, p. 140, restricted tasks budgeted 25%
minimal cost achieving entire set subgoals

157

fiDomshlak & Mirkis

(a) blind
108

unsolved

107
compile-and-BFBB

106
105
104
103
102

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

101

100
100 101 102 103 104 105 106 107 108
BFBB

(b) hM
108

unsolved

compile-and-BFBB

107
106
105
104
103
unsolved

102
101

100
100 101 102 103 104 105 106 107 108
BFBB

Figure 23: comparison Figure 15, p. 140, restricted tasks budgeted 50%
minimal cost achieving entire set subgoals

158

fiOn Oversubscription Planning Heuristic Search

(a) blind
108

unsolved

107
compile-and-BFBB

106
105
104
103
102

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

101

100
100 101 102 103 104 105 106 107 108
BFBB

(b) hM
108

unsolved

compile-and-BFBB

107
106
105
104
103
unsolved

102
101

100
100 101 102 103 104 105 106 107 108
BFBB

Figure 24: comparison Figure 15, p. 140, restricted tasks budgeted 75%
minimal cost achieving entire set subgoals

159

fiDomshlak & Mirkis

(a) blind
108

unsolved

107
compile-and-BFBB

106
105
104
103
102

unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

101

100 0
10 101 102 103 104 105 106 107 108
BFBB

(b) hM
108

unsolved

compile-and-BFBB

107
106
105
104
103
unsolved

102
101

100 0
10 101 102 103 104 105 106 107 108
BFBB

Figure 25: comparison Figure 15, p. 140, restricted tasks budgeted 100%
minimal cost achieving entire set subgoals

160

fiOn Oversubscription Planning Heuristic Search

(a) blind
108
107
inc-compile-and-BFBB

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

106
105
104
103
102
101
100
100 101 102 103 104 105 106 107 108
BFBB

(b) hM
108

inc-compile-and-BFBB

107
106
105
104
103
102
101
100
100 101 102 103 104 105 106 107 108
BFBB

Figure 26: comparison Figure 16, p. 142, restricted tasks budgeted 25%
minimal cost achieving entire set subgoals

161

fiDomshlak & Mirkis

(a) blind
108
107
inc-compile-and-BFBB

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

106
105
104
103
102
101
100
100 101 102 103 104 105 106 107 108
BFBB

(b) hM
108

inc-compile-and-BFBB

107
106
105
104
103
102
101
100
100 101 102 103 104 105 106 107 108
BFBB

Figure 27: comparison Figure 16, p. 142, restricted tasks budgeted 50%
minimal cost achieving entire set subgoals

162

fiOn Oversubscription Planning Heuristic Search

(a) blind
108
107
inc-compile-and-BFBB

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

106
105
104
103
102
101
100
100 101 102 103 104 105 106 107 108
BFBB

(b) hM
108

inc-compile-and-BFBB

107
106
105
104
103
102
101
100
100 101 102 103 104 105 106 107 108
BFBB

Figure 28: comparison Figure 16, p. 142, restricted tasks budgeted 75%
minimal cost achieving entire set subgoals

163

fiDomshlak & Mirkis

(a) blind
108
107
inc-compile-and-BFBB

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr-small
tpp
trucks
rovers
satellite
zenotravel

106
105
104
103
102
101
100 0
10 101 102 103 104 105 106 107 108
BFBB

(b) hM
108

inc-compile-and-BFBB

107
106
105
104
103
102
101
100 0
10 101 102 103 104 105 106 107 108
BFBB

Figure 29: comparison Figure 16, p. 142, restricted tasks budgeted 100%
minimal cost achieving entire set subgoals

164

fiOn Oversubscription Planning Heuristic Search

References
Backstrom, C., & Klein, I. (1991). Planning polynomial time: SAS-PUBS class.
Computational Intelligence, 7 (3), 181197.
Backstrom, C., & Nebel, B. (1995). Complexity results SAS+ planning. Computational
Intelligence, 11 (4), 625655.
Baier, J. A., Bacchus, F., & McIlraith, S. (2009). heuristic search approach planning
temporally extended preferences. Artificial Intelligence, 173 (5-6), 593618.
Benton, J., Coles, A. J., & Coles, A. I. (2012). Temporal planning preferences
time-dependent continuous costs. Proceedings 22nd International Conference
Automated Planning Scheduling (ICAPS), pp. 210.
Benton, J., Do, M., & Kambhampati, S. (2009). Anytime heuristic search partial satisfaction planning. Artificial Intelligence, 173 (5-6), 562592.
Benton, J., van den Briel, M., & Kambhampati, S. (2007). hybrid linear programming
relaxed plan heuristic partial satisfaction planning problems. Proceedings
Seventeenth International Conference Automated Planning Scheduling
(ICAPS), pp. 3441.
Bertsimas, D., & Vempala, S. (2004). Solving convex programs random walks. Journal
ACM, 51 (4), 540556.
Bonet, B. (2013). admissible heuristic SAS+ planning obtained state
equation. Proceedings 23rd International Joint Conference Artificial
Intelligence (IJCAI), pp. 22682274.
Bonet, B., & Geffner, H. (2001). Planning heuristic search. Artificial Intelligence, 129 (1
2), 533.
Bonet, B., & Geffner, H. (2008). Heuristics planning penalties rewards formulated logic computed circuits. Artificial Intelligence, 172 (12-13),
15791604.
Bonet, B., & Helmert, M. (2010). Strengthening landmark heuristics via hitting sets.
Proceedings 19th European Conference Artificial Intelligence (ECAI), pp.
329334.
Brafman, R. I., & Chernyavsky, Y. (2005). Planning goal preferences constraints.
Proceedings International Conference Automated Planning Scheduling, pp. 182191.
Clarke, E., Grumberg, O., & Peled, D. (1999). Model Checking. MIT Press.
Coles, A. I., Fox, M., Long, D., & Smith, A. J. (2008). Additive-disjunctive heuristics
optimal planning. Proceedings 18th International Conference Automated
Planning Scheduling (ICAPS), pp. 4451.
Coles, A. J., Coles, A., Fox, M., & Long, D. (2013). hybrid LP-RPG heuristic modelling
numeric resource flows planning. Journal Artificial Intelligence Research, 46,
343412.
165

fiDomshlak & Mirkis

Coles, A. J., & Coles, A. I. (2011). LPRPG-P: Relaxed plan heuristics planning
preferences. Proceedings 21st International Conference Automated Planning Scheduling (ICAPS), pp. 3745.
Cousot, P., & Cousot, R. (1992). Abstract interpretation frameworks. Journal Logic
Computation, 2 (4), 511547.
Dantzig, G. B. (1963). Linear Programming Extensions. Princeton University Press.
Dantzig, T. (1930). Number: Language Science. Macmillan.
Desrochers, M., & Soumis, F. (1988). generalized permanent labelling algorithm
shortest path problem time windows. Information Systems Operations
Research, 26, 191212.
Do, M. B., Benton, J., van den Briel, M., & Kambhampati, S. (2007). Planning goal
utility dependencies. Proceedings 20th International Joint Conference
Artificial Intelligence (IJCAI), pp. 18721878.
Domshlak, C., Hoffmann, J., & Sabharwal, A. (2009). Friends foes? planning
satisfiability abstract CNF encodings. Journal Artificial Intelligence Research,
36, 415469.
Domshlak, C., Katz, M., & Lefler, S. (2012). Landmark-enhanced abstraction heuristics.
Artificial Intelligence, 189, 4868.
Dudzinski, K., & Walukiewicz, S. (1987). Exact methods Knapsack problem
generalizations. European Journal Operational Research, 28, 321.
Dvorak, F., & Bartak, R. (2010). Integrating time resources planning. Proceedings 22nd IEEE International Conference Tools Artificial Intelligence
(ICTAI), pp. 7178.
Edelkamp, S. (2001). Planning pattern databases. Proceedings European
Conference Planning (ECP), pp. 8490.
Edelkamp, S. (2003). Taming numbers durations model checking integrated
planning system. Journal Artificial Intelligence Research, 20, 195238.
Fikes, R. E., & Nilsson, N. (1971). STRIPS: new approach application theorem
proving problem solving. Artificial Intelligence, 2, 189208.
Fox, M., & Long, D. (2003). PDDL2.1: extension PDDL expressing temporal
planning problems. Journal Artificial Intelligence Research, 20, 61124.
Garey, M. R., & Johnson, D. S. (1978). Computers Intractability: Guide Theory
NP-Completeness. W.H. Freeman Company, New York.
Geffner, H., & Bonet, B. (2013). Concise Introduction Models Methods Automated Planning. Synthesis Lectures Artificial Intelligence Machine Learning.
Morgan & Claypool.
Gerevini, A., Haslum, P., Long, D., Saetti, A., & Dimopoulos, Y. (2009). Deterministic
planning fifth international planning competition: PDDL3 experimental
evaluation planners. Artificial Intelligence, 173 (5-6), 619668.
166

fiOn Oversubscription Planning Heuristic Search

Gerevini, A., Saetti, A., & Serina, I. (2003). Planning stochastic local search
temporal action graphs LPG. Journal Artificial Intelligence Research, 20, 239
290.
Gerevini, A., Saetti, A., & Serina, I. (2008). approach efficient planning numerical
fluents multi-criteria plan quality. Artificial Intelligence, 172 (8-9), 899944.
Grotschel, M., Lovasz, L., & Schrijver, A. (1981). ellipsoid method consequences
theorems combinatorial optimization. Combinatorica, 1, 169197.
Handler, G., & Zang, I. (1980). dual algorithm constrained shortest path problem.
Networks, 10, 293310.
Haslum, P. (2013). Heuristics bounded-cost search. Proceedings 23rd International Conference Automated Planning Scheduling (ICAPS), pp. 312316.
Haslum, P., Bonet, B., & Geffner, H. (2005). New admissible heuristics domainindependent planning. Proceedings 20th National Conference Artificial
Intelligence (AAAI), pp. 11631168.
Haslum, P., Botea, A., Helmert, M., Bonet, B., & Koenig, S. (2007). Domain-independent
construction pattern database heuristics cost-optimal planning. Proceedings
19th National Conference Artificial Intelligence (AAAI), pp. 10071012.
Haslum, P., & Geffner, H. (2000). Admissible heuristics optimal planning. Proceedings 15th International Conference Artificial Intelligence Planning Systems
(AIPS), pp. 140149.
Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. Proceedings
6th European Conference Planning (ECP), pp. 107112.
Helmert, M. (2002). Decidability undecidability results planning numerical
state variables. Proceedings Sixth International Conference Artificial
Intelligence Planning Scheduling (AIPS), pp. 4453.
Helmert, M. (2006). Fast Downward planning system. Journal Artificial Intelligence
Research, 26, 191246.
Helmert, M., & Domshlak, C. (2009). Landmarks, critical paths abstractions: Whats
difference anyway?. Proceedings 19th International Conference Automated Planning Scheduling (ICAPS), pp. 162169.
Helmert, M., Haslum, P., & Hoffmann, J. (2007). Flexible abstraction heuristics optimal
sequential planning. Proceedings 17th International Conference Automated
Planning Scheduling (ICAPS), pp. 200207.
Helmert, M., Haslum, P., Hoffmann, J., & Nissim, R. (2014). Merge-and-shrink abstraction:
method generating lower bounds factored state spaces. Journal ACM,
61 (3), 16:163.
Hoffmann, J. (2003). Metric-FF planning system: Translating ignoring delete lists
numeric state variables. Journal Artificial Intelligence Research, 20, 291341.
Hoffmann, J., Gomes, C. P., Selman, B., & Kautz, H. A. (2007). SAT encodings statespace reachability problems numeric domains. Proceedings 20th International Joint Conference Artificial Intelligence (IJCAI), pp. 19181923.
167

fiDomshlak & Mirkis

Hoffmann, J., & Nebel, B. (2001). planning system: Fast plan generation
heuristic search. Journal Artificial Intelligence Research, 14, 253302.
Hoffmann, J., Porteous, J., & Sebastia, L. (2004). Ordered landmarks planning. Journal
Artificial Intelligence Research, 22, 215278.
Karp, R. (1972). Reducibility among combinatorial problems. Complexity Computer
Computations, pp. 85103. Plenum Press, New York.
Karpas, E., & Domshlak, C. (2009). Cost-optimal planning landmarks. Proceedings
International Joint Conference Artificial Intelligence (IJCAI-09), pp. 1728
1733.
Katz, M., & Domshlak, C. (2010a). Implicit abstraction heuristics. Journal Artificial
Intelligence Research, 39, 51126.
Katz, M., & Domshlak, C. (2010b). Optimal admissible composition abstraction heuristics. Artificial Intelligence, 174, 767798.
Kellerer, H., Pferschy, U., & Pisinger, D. (2004). Knapsack Problems. Springer-Verlag
Berlin.
Keyder, E., & Geffner, H. (2009). Soft goals compiled away. Journal Artificial
Intelligence Research, 36, 547556.
Koehler, J. (1998). Planning resource constraints. Proceedings 13th European
Conference Artificial Intelligence (ECAI), pp. 489493.
Mirkis, V., & Domshlak, C. (2013). Abstractions oversubscription planning. Proceedings 23rd International Conference Automated Planning Scheduling
(ICAPS), pp. 153161.
Mirkis, V., & Domshlak, C. (2014). Landmarks oversubscription planning. Proceedings
23rd European Conference Artificial Intelligence (ECAI), pp. 633638.
Nakhost, H., Hoffmann, J., & Muller, M. (2012). Resource-constrained planning: Monte
Carlo random walk approach. Proceedings 22nd International Conference
Automated Planning Scheduling (ICAPS), pp. 181189.
Nebel, B. (2000). compilability expressive power propositional planning
formalisms. Journal Artificial Intelligence Research, 12, 271315.
Nemirovsky, A., & Yudin, N. (1994). Interior-Point Polynomial Methods Convex Programming. SIAM.
Pearl, J. (1984). Heuristics - Intelligent Search Strategies Computer Problem Solving.
Addison-Wesley.
Pommerening, F., & Helmert, M. (2013). Incremental LM-Cut. Proceedings 23rd
International Conference Automated Planning Scheduling (ICAPS), pp. 162
170, Rome, Italy.
Porteous, J., Sebastia, L., & Hoffmann, J. (2001). extraction, ordering, usage
landmarks planning. Proceedings 6th European Conference Planning
(ECP 01), pp. 3749.
168

fiOn Oversubscription Planning Heuristic Search

Punnen, A. P. (1992). K-sum linear programming. Journal Operational Research
Society, 43 (4), 359363.
Richter, S., Helmert, M., & Westphal, M. (2008). Landmarks revisited. Proceedings
23rd AAAI Conference Artificial Intelligence (AAAI-08), pp. 975982.
Russell, S., & Norvig, P. (2009). Artificial Intelligence: Modern Approach (3 edition).
Pearson.
Sanchez, R., & Kambhampati, S. (2005). Planning graph heuristics selecting objectives over-subscription planning problems. Proceedings 15th International
Conference Automated Planning Scheduling (ICAPS), pp. 192201.
Smith, D. (2004). Choosing objectives over-subscription planning. Proceedings
14th International Conference Automated Planning Scheduling (ICAPS), pp.
393401.
Thayer, J. T., & Ruml, W. (2011). Bounded suboptimal search: direct approach using
inadmissible estimates. Proceedings 22nd International Joint Conference
Artificial Intelligence (IJCAI), pp. 674679.
Thayer, J. T., Stern, R. T., Felner, A., & Ruml, W. (2012). Faster bounded-cost search
using inadmissible estimates. Proceedings 22nd International Conference
Automated Planning Scheduling (ICAPS), pp. 270278.
van den Briel, M., Sanchez, R., Do, M. B., & Kambhampati, S. (2004). Effective approaches
partial satisfaction (over-subscription) planning. Proceedings 19th AAAI
Conference Artificial Intelligence (AAAI), pp. 562569.
van den Briel, M., Benton, J., Kambhampati, S., & Vossen, T. (2007). LP-based heuristic optimal planning. Proceedings 13th International Conference
Principles Practice Constraint Programming (CP), pp. 651665.
Yang, F., Culberson, J., Holte, R., Zahavi, U., & Felner, A. (2008). general theory
additive state space abstractions. Journal Artificial Intelligence Research, 32,
631662.

169


