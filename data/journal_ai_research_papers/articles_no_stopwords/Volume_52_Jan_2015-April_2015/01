journal artificial intelligence

submitted published

deterministic oversubscription heuristic search
abstractions reformulations
carmel domshlak
vitaly mirkis

dcarmel ie technion ac il
mirkis gmail com

faculty industrial engineering management
technion israel institute technology
haifa israel

abstract
classical objective achieve one equally attractive goal
states low total action cost possible objective deterministic oversubscription
osp achieve valuable possible subset goals within fixed
allowance total action cost although numerous applications fields share
latter objective substantial algorithmic advances made deterministic
osp tracing key sources progress classical identify severe lack
effective domain independent approximations osp
focus optimal goal bridge gap two classes
approximation techniques found especially useful context optimal
classical state space abstractions logical landmarks goal reachability question study whether similar spirit
yet possibly mathematically different approximation techniques developed osp
context abstractions define notion additive abstractions osp study
complexity deriving effective abstractions rich space hypotheses reveal
substantial empirically relevant islands tractability context landmarks
standard goal reachability landmarks certain classical tasks
compiled osp task interest resulting equivalent osp task lower
cost allowance thus smaller search space empirical evaluation confirms
effectiveness proposed techniques opens wide gate developments
oversubscription

introduction
tools automated action allow autonomous systems selecting course
action get things done deterministic probably basic thus
fundamental setting automated action russell norvig
viewed finding trajectories interest large scale yet concisely
represented state transition systems computational approaches deterministic
vary around way trajectories interest defined
basic structure acting situations underconstrained overconstrained
resources respectively captured days called classical deterministic
fikes nilsson smith termed oversubscription
deterministic osp classical task cost effective
trajectory possible goal satisfying state oversubscription task
goal effective valuable state possible via cost satisfying trajectory
c

ai access foundation rights reserved

fidomshlak mirkis

optimal classical optimal osp tasks constrained finding
cost effective trajectories goal effective states respectively classical
osp viewed foundational variants deterministic
many variants net benefit cost bounded defined
terms mixing relaxing two
osp extensively advocated years theory practice
classical studied advanced much intensively remarkable
success continuing progress heuristic search solvers classical one notable example primary enablers success advances domain independent
approximations heuristics cost needed achieve goal state given state
thus possible similarly rich palette effective heuristic functions
osp would advance state art
two classes approximation techniques found especially useful context optimal classical state space abstractions edelkamp
haslum botea helmert bonet koenig helmert haslum hoffmann nissim
katz domshlak logical landmarks goal reachability karpas domshlak helmert domshlak domshlak katz lefler
bonet helmert pommerening helmert considering osp heuristic search question whether similar spirit yet possibly mathematically
different approximation techniques developed heuristic search osp precisely question study
starting basic question state space abstractions osp actually notion abstraction differs substantially classical osp hence first define additive abstractions abstraction
heuristics osp investigate computational complexity deriving
effective abstraction heuristics scope homomorphic abstraction skeletons
paired cost value budget partitions along revealing significant
islands tractability study exposes interesting interplay knapsackstyle combinatorial optimization continuous convex optimization
certain principles borrowed explicit abstractions classical
introduce study landmarks logical properties osp plans achieve
valuable states landmarks correspond regular goal reachability
landmarks certain classical tasks straightforwardly derived
osp tasks interest landmarks compiled
back osp task interest resulting equivalent osp task
stricter cost satisfaction constraint thus smaller effective search space
finally landmark task enrichment combined
mutually stratifying way best first branch bound search used osp
resulting incremental procedure interleaves search landmark
discovery entire framework independent osp planner specifics
particular heuristic functions employs
connections differences popular variants deterministic discussed
section



fion oversubscription heuristic search

empirical evaluation large set osp tasks confirms effectiveness proposed techniques moreover best knowledge implementation constitutes
first domain independent solver optimal osp hope advances
important computational follow
work revision extension formulations presented
authors icaps ecai mirkis domshlak
structured follows section formulate general model deterministic
define several variants deterministic terms model particular
oversubscription differs conceptually classical
popular variants deterministic net benefit
cost bounded specify simple model representation language
osp well provide essential background heuristic search particular
osp heuristic search sections devoted respectively abstractions
abstraction approximations osp section devoted exploiting reachability
landmarks osp tasks section conclude discuss promising directions
future work sake readability proofs relegated appendix
details empirical relegated appendix b

background
mentioned introduction specific variants deterministic differ
way interest preference trajectories defined instance classical
fikes nilsson trajectory interest connects designated initial
state one designated goal states preference towards trajectories
lower total cost transitions along among non classical variants
deterministic
oversubscription smith topic interest
net benefit van den briel sanchez kambhampati sanchez
kambhampati baier bacchus mcilraith bonet geffner
benton kambhampati coles coles keyder geffner
cost bounded known resource constrained haslum geffner
hoffmann gomes selman kautz gerevini saetti serina thayer
ruml thayer stern felner ruml haslum nakhost hoffmann
muller
preferences temporal properties trajectories baier et al
gerevini haslum long saetti dimopoulos benton coles coles

interestingly working learned quite different
variants deterministic often collectively referred oversubscription
difference terms expressiveness necessarily clear thus relationship already
done collective sense oversubscription apparent
issue address first


fidomshlak mirkis


adopting extending notation geffner bonet view many
variants deterministic including classical well many popular
non classical variants special cases state model
hs u c qi




finite set states
initial state
state value function u r
operators applicable state
deterministic state transition function stands
state resulting applying
operator cost function c r
quality measure q p r p infinite set trajectories
along operators trajectory p sequence operators ho
inductively oi oi oi
model trajectory p solution preference towards solutions
higher quality
p follows sjk stands end state trajectory applied
state c c additive cost likewise graphical skeleton
gm hs oi model refers edge annotated unweighted digraph induced
nodes gm states edge labels operators
contains edge labeled iff
first consider quality measure
q u sjk c



measure assumes state values operator costs comparable thus represents tradeoff value end state cost trajectory consider
fragment state model instances quality measure q
instance value function


sgoal
u

otherwise
partitions state space sgoal u takes finite value
rest states u takes value finding optimal solution
instance fragment corresponds finding shortest path single node
edge weighted digraph g obtained gm annotating edges
latter costs c ii adding dummy node zero cost edges


fion oversubscription heuristic search

constraint

preference

net benefit

oversubscription

constraint

end state value

action cost
preference

classical

cost bounded

figure schematic classification four deterministic along strictness
cost operator sequences value
operator sequence end states white blocks
solved single source single target shortest path

goal nodes sgoal specified non canonical way fragment
easily verified correspond model classical sgoal classical
goal states
staying quality measure q removing requirement u comply
eq obtain fragment generalizes classical constitutes
basic model called net benefit sanchez kambhampati importantly instance fragment reduced finding shortest path
single node single node edge weighted digraph g obtained gm
annotating edges gm costs c ii adding dummy node andpedges
nodes ii setting cost edge u
reduction works net value maximization end state equivalent
minimization net loss giving possible end states
basic idea underlies keyder geffners scheme compiling certain standard representation formalisms net benefit standard classical
formalism
consider alternative quality measure

u sjk c b
q


otherwise
b



worth noting wost case complexity equivalence classical net benefit
shown prior work keyder geffner van den briel et al
however equivalence prescriptive enough suggest practically effective compilations
compactly represented net benefit tasks classical tasks



fidomshlak mirkis

b r predefined bound cost trajectories fragment
basic model instances characterized quality measure qb
value functions eq constitutes model called costbounded thayer ruml well finding optimal solution
instance corresponds finding shortest path edge weighted
digraph g derived gm identically case classical
particular explains natural heuristic search methods cost bounded
exploit heuristics developed classical haslum
arrive fourth fragment basic model staying quality measure qb removing requirement u comply eq obtain fragment
generalizes cost bounded constitutes model oversubscription smith illustrated figure hard constraint classical
translates soft preference osp hard constraint osp translates soft preference classical however contrast cost optimal net benefit classical
fragment appear reducible single source single target
shortest path terms digraph g obtained gm annotating
edges costs c finding optimal solution instance oversubscription
requires finding shortest paths states u ii filtering
states reachable within cost allowance b iii
selecting remaining states state maximizes u
contrast oversubscription three popular variants
deterministic discussed least two important implications first
single shortest path searched best first forward search procedures
searching shortest paths numerous targets simultaneously requires different
exhaustive forward search framework branch bound second net benefit
cost bounded clearly potential directly indirectly reuse rich
toolbox heuristic functions developed years classical contrast
due differences underlying computational model necessarily
true oversubscription examining prospects heuristic functions
osp precisely focus work
notation
k n k denote set k indicator function subset
set x function x defined x x x x
following nebel talk size mathematically well defined object
x symbolically x mean size reasonable encoding x assignment
variable v value denoted hv di often refer single variable assignments
propositions

strictly speaking shortest path found still checked
cost bound b test however local solving finishes independently tests
outcome



fion oversubscription heuristic search

model representation
departing general model oversubscription follows restrict attention instances model compactly representable language
close sas language classical backstrom klein backstrom
nebel language deterministic oversubscription osp task
given sextuple
hv u c bi




v v vn finite set finite domain state variables complete
assignment v representing state dom v dom vn state
space task
designated initial state
u efficiently computable state value function u r
finite set operators operator represented pair
hpre eff partial assignments v called preconditions effects respectively
c r operator cost function
b r cost budget allowed task
consider semantics task description terms
basic model

osp task hv u c bi said induce model u c qb
qb quality measure instantiated budget b transition
function specified follows partial assignment p v let v p v denote
subset variables instantiated p v v p p v denote value provided
p variable v similarly classical semantics sas operator
applicable state iff v pre v v v pre applying changes
value v v eff eff v resulting state denoted sjok
notation defined applicable denoting empty sequence operators
applying sequence operators ho om state defined inductively sjk
sjo oj k sjo oj kjoj k operator sequence called plan
applicable state qb c b

auxiliary notation used later osp task hv u c bi
vv dom v denote union uniquely labeled state variable domains
state proposition hv di hv di used shortcut notation
v
example simple osp task figure used illustrate model representation example truck initially location drive location
location b location b location c two packages x initially
location b package truck location package
loaded onto truck package truck unloaded


fidomshlak mirkis

x



b

c


oi
pre oi
eff oi

driveab

ht ai
ht bi

drivebc

ht bi
ht ci

loadbx

ht bi hx bi
hx

loadby

ht bi hy bi
hy

unloadcx

ht ci hx
hx ci

oi
pre oi
eff oi

unloadbx

ht bi hx
hx bi

unloadby

ht bi hy
hy bi

unloadcy

ht ci hy
hy ci

loadcx

ht ci hx ci
hx

loadcy

ht ci hy ci
hy

b
u

cbb


abb



bbb

btb




bbt

ctb




ccb

btt



ctt










u




cbc

ctb




ccb

btt



ctt

cbt

u




ctc

u
cct

u

ccc




c
u

cbb


abb



bbb

btb




bbt










u

cbt




u




ctc

u
cct

u

ccc




cbc



figure simple running example osp task illustrating story b listing operators c depicting graphical skeleton induced state
model c shows region graphical skeleton gm structurally
reachable initial state abb grayed area corresponds
sub region cannot reached initial state budget
b

trucks current location drive load unload operator task costs one unit
cost cost budget set four units cost finally value one value unit
earned package present location c
osp task described three state variables v x
dom b c dom x dom b c corresponding possible
locations truck two packages respectively

operator set ffo
detailed figure b state model u c qb induced


fion oversubscription heuristic search

bfbb hv u c bi
open max heap ordered f n h shni b g n
initialize best solution n make root node
open insert n
closed
best cost
open empty
n open pop max
f n u shn break
u shni u shn update n n
shni closed g n best cost shni
closed closed shni
best cost shni g n
foreach shni
n make node shnijok n
g n b f n u shn continue
open insert n

return n
figure best first branch bound bfbb search osp
task dom dom x dom initial state abb three letters names states capturing three components domain cross product
operator cost c oi operators oi cost budget b state values


ac bc ca cb
u cc


otherwise



graphical skeleton gm depicted figures c figure c shows
region graphical skeleton gm structurally reachable initial state
abb grayed area figure corresponds sub region cannot
reached initial state budget b
osp heuristic search
two major ingredients heuristic search planner search
heuristic function classical heuristic typically function h r
h estimating cost h optimal plans heuristic h admissible
lower bounding h h states common heuristic search
optimal classical require admissible heuristics
contrast heuristic osp function h r r h b estimating
value h b optimal plans cost budget b heuristic h admissible
upper bounding h b h b states cost budgets b well


fidomshlak mirkis

search optimal osp best first branch bound bfbb require
admissible heuristics pruning search branches without violating solution optimality
figure depicts pseudo code description bfbb osp shni denotes state
associated search node n cost far g n total cost action sequence
associated n unlike order nodes selected open
list affect optimality guarantees though may course seriously affect
empirical efficiency search figure ordering open corresponds
decreasing order h shni b g n duplicate detection reopening mechanisms
bfbb similar pearl addition bfbb maintains best
solution n found far uses prune generated nodes evaluated higher
u shn likewise complying semantics osp generated nodes n costso far g n higher budget b immediately pruned
open list becomes empty node n selected list promises less lower
bound bfbb returns plan associated best solution n h admissible
h pruning generated nodes sound returned plan
guaranteed optimal
let us return heuristic functions domain independent
automatically derived description model language choice
useful heuristic function must efficiently computable description
model well relatively accurate estimates improving accuracy heuristic
function without substantially worsening time complexity computing translates
faster search plans
classical numerous approximation techniques monotonic relaxation bonet geffner hoffmann nebel critical trees haslum
geffner network flow van den briel benton kambhampati vossen
bonet logical landmarks goal reachability richter helmert westphal
karpas domshlak helmert domshlak bonet helmert
abstractions edelkamp helmert haslum hoffmann katz domshlak
translated effective heuristic functions likewise different heuristics
classical combined point wise maximizing additive
ensembles edelkamp haslum bonet geffner coles fox long smith
katz domshlak b helmert domshlak
contrast development heuristic functions osp progressed beyond
initial ideas smith principle reduction keyder geffner
net benefit classical used reduce osp classical realvalued state variables koehler helmert fox long hoffmann
gerevini saetti serina gerevini et al edelkamp dvorak bartak
coles coles fox long far however progress heuristic search classical
numeric state variables mostly achieved around direct extensions
delete relaxation heuristics via numeric relaxed graphs hoffmann
edelkamp gerevini et al unfortunately heuristics preserve
information consumable resources budgeted operator cost oversubscription
bfbb extensively used net benefit benton van den briel kambhampati
coles coles benton van den briel kambhampati well variants
deterministic bonet geffner brafman chernyavsky



fion oversubscription heuristic search

negative action effects decrease values numeric variables
ignored possibly special handling called cyclic resource transfer coles
et al
first step overcoming lack effective heuristics osp next section
study abstractions osp definition properties prospects
deriving admissible abstraction heuristics section study prospects
adapting osp toolbox logical landmarks goal reachability date abstractions
landmarks responsible state art admissible heuristics classical
thus special interest

abstractions
term abstraction usually associated simplifying original model factoring
details less crucial given context context determines details reduced better preserved abstraction created used cousot
cousot clarke grumberg peled helmert et al domshlak hoffmann sabharwal katz domshlak b general terms abstracting model
corresponds associating set typically computationally attractive
mk solutions satisfy certain properties respect solutions particular deterministic heuristic search
abstractions used derive heuristic estimates states model interest
given state abstraction mk
mapped abstract states sk mk
k abstraction solved respective initial states sk

aggregation quality resulting k solutions used heuristic estimate

sometimes schematically sometimes precisely process constructing abstractions state model hs u c qi seen two step process

selecting abstraction skeleton g gk k pair
gi comprises edge labeled digraph gi hsi ti oi nodes si edges ti
edge labels oi state mapping si
extending set abstract mk k
gi graphical skeleton gmi mi
qualify valid abstraction model resulting set abstract
satisfy certain conditions specific variant deterministic
consideration instance optimal solutions abstract classical
required costly respective solutions original
constraint satisfied individual abstract case maxaggregation pearl k abstract jointly case additive abstractions yang culberson holte zahavi felner katz domshlak b


fidomshlak mirkis

concept abstractions general additive abstractions particular
different osp better worse many degrees freedom
respective concepts classical
abstractions osp
given
abstraction


skeleton g gk k osp state model
u c qb digraph gi hsi ti oi implicitly defines set osp state
consistent set given ci ui bi ci set
functions operators oi r ui set functions states si r
bi r terms point c u b ci ui bi induces osp model
consistent gi vice versa
connecting sets digraphs let
c c ck
u u uk
b b bk
state every point c u b c u b induces set
n

c u b
c u b
c u b
mk

c u b

mi




si u oi c qb

states si operators oi correspond nodes edge labels gi
transition function iff ti contains arc labeled
oi
initial state determined initial state state mapping

operator cost function state value function cost budget directly determined choice c u b
choices c u b c u b induced sets c u b
used deriving admissible estimates state interest others cannot
respective qualification defined
definition
additive osp
abstraction
let u c qb osp model g g k
abstraction skeleton c u b c u b c u b additive
abstraction denoted
c u b aas

def

h b hm c u b b

x

hi b

k

hm c u b b admissible estimate h b


fion oversubscription heuristic search

gm













g

g



zz
z
zz
zz

































b
figure illustration running example

simple terms set forms additive osp abstraction jointly
underestimate value obtained initial state within
example let g
given cost budget
graphical skeleton state
figure


model u c qb c oi operators oi
b u si let g g abstraction skeleton
g g figure b state mappings


si

otherwise


si

otherwise
consider set c u b constant c c b b
j u si j j optimal plan plan h
c u b

qb optimal plan
h
c u b
b
q optimal plan
h
qb since
h b qb qb qb h b h b
c u b additive abstraction
theorem osp task hv u c bi abstraction skeleton
g gk k aas digraphs given
explicitly hm b computed time polynomial



proof let mi k mi si ui oi ci qbi additive abstraction basis k let si si ci bi since
optimal classical requirement abstraction overestimate costs typically
posed states original model initial state yang et al katz
domshlak b helmert et al extra requirement however pragmatic reasons
efficiency allows abstraction computed preprocessing individually every
state examined search heuristics osp however functions state
available cost budget latter directly applies initial aka current state
sum defining abstractions respect entire state space necessity classical
osp even clear whether defining abstractions respect specific pair
state budget deliver practical benefits however interpreted
formal impossibility claim investigation direction definitely worthwhile



fidomshlak mirkis



ssss
kk
ss
kkkk
u
sssskk c sssskk b
kkkkss
kkkkss
c u

u b
c b
sss
sss
kkk
kkk
c u b

figure fragments restricted optimization abstractions c u b
digraphs given explicitly shortest paths states gi
thus particular determining si computed time polynomial

p
k turn since hi bi maxssi ui hm b k hi bi
computed time polynomial

message theorem positive yet establishes necessary condition
relevance osp abstractions practice given osp task fixed
abstraction skeleton joint performance measure space c u b
able automatically separate c u b c u b constitute
abstractions within former set denoted
c u b
home abstraction provides us accurate aka low estimate
h b possible even first item agenda necessarily trivial
general seems lack convenient combinatorial properties instance generally
form combinatorial rectangle c u b consider osp state model
gm abstraction skeleton running example let c c cost function
vector c c constant functions value two performance
measures c u b c u b cub defined via budget vectors b b b
b b b value function vectors u u u u u
u evaluating zero states except u u

hard verify c u b aas c u b aas c u b state
c u b
u reachable
b


c u b
c u
b



state u reachable



b contrast c u b aas c u b aas sets
model comes budget initial state model

value zero states non zero value hence c u b

c u b estimate h b zero h b
light overall agenda complexity analysis abstractionbased heuristic functions steps different fixations three dimensions
instance given vector value functions u known belong
projection u search quality abstraction abstraction
subset u corresponding projection u
even constrained optimizations kind challenging lattice figure depicts range options constrained optimization extreme settings


fion oversubscription heuristic search



g

g


uu
u
u
uu
















j












j



figure homomorphic abstraction skeleton g figure
simply renaming c u b corresponds single abstraction
c u b
partitions homomorphic abstractions
proceed consider specific family additive abstractions reveal
interesting properties contains substantial islands tractability
definition allowing general abstraction skeletons work focus homomorphic abstraction skeletons helmert et al
definition
abstraction skeleton
g gk k osp state

model u c qb homomorphic k oi
ti
instance running example abstraction skeleton figure b homomorphic since e g gm yet gm
abstraction skeleton figure homomorphic furthermore focus fragment
additive abstractions
ap cp bp
cp c u bp b correspond cost value budget partitions
respectively



definition given osp state model u c qb homomorphic
abstraction skeleton g gk k joint performance measure
c u b
p
c c cost partition iff operator k c c
p
u u value partition iff state k u u
p
b b budget partition iff k b b
follows node x lattice figure ap x refer x ap
e g ap u u ap
begin analysis ap establishing interesting completeness relationship
sets cp bp well even stronger individual completeness cp
bp formulated theorem properties ap play key role computational
analysis later
hold verbatim general labeled paths preserving abstraction skeletons
studied katz domshlak b context optimal classical however
presentation somewhat accessible restricted homomorphic abstraction skeletons



fidomshlak mirkis

c

cp

b

bp





b

c

bp

cp





figure illustration sub claims theorem gray ellipse
within bp stands subset budget partitions b pair c
abstraction ap c b however pairing budget
partitions b c requires careful selection value partition u
c u b abstraction exists budget partition b
choice u job

theorem given osp task hv u c bi homomorphic abstraction
skeleton g gk k
cost partition c cp exists budget partition b bp

c u b value partitions u

budget partition b bp exists cost partition c cp

c u b value partitions u
proof theorem appears appendix p figure illustrates statement sub claim theorem well indirectly corollaries first
corollary theorem projections ap cp bp entire sets
cp bp respectively cost partition c similarly budget partition value partition matched abstraction partition
component second budget partition b paired given cost
partition c abstractions b bp ap c b
budget partitions paired c finally pairing
c compatible budget partitions b c requires careful selection value
partition u exists c compatible budget partition b choice
u c u b abstraction
priori properties ap simplify task abstraction discovery
optimization within space partitions cp bp later
indeed case however complexity analysis abstraction discovery within cp bp
general terms still problematic osp formalism parametric
respective illustration sub claim theorem completely similar mutatis mutandis



fion oversubscription heuristic search

representation value functions hence proceed examining abstraction
discovery osp context fixed value partitions u

value partitions complete abstractions
let osp task explicitly given homomorphic abstraction skeleton
u value partition immediate corollary theorem
ap u empty thus try computing min c u b ap u hm c u b
yet however know whether task polynomial time solvable
non trivial class value partitions fact although ap u known theorem
non empty subsets ap u b ap c u finding even
abstraction c u b ap u necessarily easy
binary value partitions
first step examine abstraction discovery within fragment ap
value functions u abstract call binary later section
findings binary abstract value functions extended general
value partitions
definition real valued function f called binary codomain f
r set f binary functions called strong functions f
codomain
one hand binary functions constitute rather basic family value functions
hence abstraction optimization hard likely hard nontrivial family abstract value functions hand binary abstract value
functions seem fit well abstractions tasks value functions linear
combinations indicators representing achievement goal value state
variable
respect first tractability abstraction discovery ap u
u strong binary value partition first simpler theorem
assumes fixed action cost partition next theorem
simultaneous selection admissible pairs cost budget partitions corollary
theorem theorem theorem respectively
extended pseudo polynomial general binary value partitions
strong binary value partitions knapsack
first tractability abstraction discovery within ap c u u strong
binary value partition c arbitrary cost partition key role played
well known
knapsackffproblem dantzig kellerer pferschy pisinger


instance wi n w knapsack given weight allowance w
set objects n object n annotated

pwith weight wi value
n
objective




subset
z

n

maximizes



subsets
z
iz
p

w

w

strict
knapsack

refer


variant knapsack


iz
inequality constraint strict knapsack np hard karp garey johnson


fidomshlak mirkis

exist pseudo polynomial run time polynomial
description unary representation w dudzinski walukiewicz
latter property makes solving knapsack practical many applications
ratio minwi wi reasonably low likewise j j n greedy
solves linear time iteratively expanding z one weight wise
lightest objects n z z cannot expanded within w
theorem ap c u strong binary u
let hv u c bi osp task explicit homomorphic abstraction skeleton u strong binary value partition given cost partition c cp
finding abstraction c u b ap c u computing corresponding heuristic
estimate hm c u b b done time polynomial
proof proof reduction polynomial fragment knapsack
corresponding items identical value let g gk k
given u strong binary value partition let codomain u
r
k let wi cost cheapest path gi one
states si u since explicit abstraction skeleton set wi k
computed time polynomial one standard




single source shortest paths consider knapsack wi k b
weights wi value identical objects let z k
solution optimization knapsack recall computable
polynomial time given define budget profile b b follows

wi z
k b

otherwise
remains shown c u b actually induces additive abstraction

assume contrary c u b aas let optimal plan
construction knapsack b z

c u b
plan p
qb definition assumption implies
mi

qb iz qb z however theorem exists least one
budget partition b bp c u b aas note budget partition
induces ap
feasible solution z wi b knapsack satisfying
qb iz qb z however implies z z contradicting

optimality z thus accomplishing proof c u b aas

construction proof theorem may appear somewhat counterintuitive
interested minimizing heuristic estimate h b abstraction

c u b selected via value maximizing knapsack indeed ultimately
would obtain
min
hm c u b b

b c u b ap

heuristic manage compute polynomial time actually
max
b c u b ap

hm c u b b




fion oversubscription heuristic search

time note fixed pair c cp u estimate eq
still least possibly much accurate estimate would obtained
providing k abstract entire budget b later
superior accuracy verified experiments first proceed examining
working general binary value partitions
strong binary value partitions rather restrictive finding element
ap c u general binary u longer polynomiala reduction knapsack
straightforward however knapsack solvable pseudo polynomial time plugging
knapsack proof theorem search
ap c u general binary u
corollary ap c u binary u
let hv u c bi osp task explicit homomorphic abstraction skeleton u binary value partition given cost partition c cp finding
abstraction c u b ap c u computing corresponding heuristic estimate
hm c u b b done time polynomial unary representation
budget b
test illustrate value additive abstractions bring heuristic search
osp implemented prototype heuristic search osp solver top fast downward
planner helmert since unlike classical net benefit osp still lacks
standard suite benchmarks comparative evaluation cast role
strips classical tasks international competitions ipc translation osp done associating separate unit value
proposition conjunctive goal corresponding classical ipc task
within prototype implemented bfbb search osp provided support
basic pattern database abstraction skeletons action cost partitions abstraction selection ap c u strong binary value partitions proof theorem
specifically task k sub goals
abstraction skeleton comprised set k projections task onto
connected subsets ancestors respective k goal variables causal graph
size projection limited abstract states ancestors
goal variable v added corresponding projection initialized contain
v breadth first manner v back along arcs causal graph
abstraction could expanded within aforementioned size limit
ii value partition u associated entire value sub goal hv di
projection associated v
iii cost partition c distributed cost operator uniformly
projections invalidate e reflected least one state variable
affected
evaluation compared bfbb node expansions three heuristic functions
tagged blind basic hm three heuristics h value node n set
cost budget n consumed cost budget consumed
aware domain independent planner optimal osp



fidomshlak mirkis

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
rovers
satellite
tpp
trucks
pipesw
pipesw nt
psr small
zenotravel
total

hm






















basic





















blind





















hm






















basic





















blind





















hm






















basic





















blind





















hm






















basic





















blind





















table number solved across different budgets open list ordered heuristic evaluation figure

blind bfbb constitutes trivial baseline h n simply set total value
goals
basic bfbb h n set total value goals individually
achieved within respective projection abstraction see theorem given entire
remaining budget
hm additive abstraction heuristic selected ap c u
proof theorem
evaluation contained tasks could determine offline
minimal cost budget needed achieve goals task approached
four different budgets corresponding minimal
cost needed achieve goals task run restricted minutes
table shows number tasks solved within domain level cost budget
figure depicts terms expanded nodes across four levels cost budget
figures appendix b provide detailed view figure
breaking different levels cost budget despite simplicity
abstraction skeletons used number nodes expanded bfbb hm
typically substantially lower number nodes expanded basic bfbb
difference sometimes reaching three orders magnitude
reiterate task considered solved upon termination bfbb
optimal plan found proven optimal



fion oversubscription heuristic search




unsolved




hm





unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel





blind

b


unsolved



hm




unsolved






basic

figure comparative view empirical table terms expanded nodes

freeing cost partition knapsack meets convex optimization
returning algorithmic analysis context strong binary value partitions
proceed relaxing constraint sticking fixed action cost partition c
buys flexibility selecting abstractions ap u allowing us improve
accuracy heuristic estimates still retaining computational tractability


fidomshlak mirkis

input hv u c bi g gk k
strong binary value partition u
output u
k
reduce gi nodes reachable
k downto
achievable return
return
achievable

ellipsoid method separation oracle lm
solution x dom x l
x b return true
else return false

separation oracle lm
x dom x
let permutation k
x b
p x b x b k
x x b return yes
p
else return constraint b
b
figure polynomial time computing u strong binary value
partition u theorem

given osp task hv u c bi homomorphic abstraction skeleton
value partition u let


u min
max

hm c u b b
ccp

b c u b ap

obviously estimate h b u least accurate estimate eq
derived respect fixed cost partition c
osp task abstraction skeleton g
gk k strong binary value partition u u
computed polynomial time corresponding shown figure
figure depicting macro flow figure b depicting specific
implementation solve sub routine makes overall time complexity
polynomial
high level flow figure follows since u strong binary value partition let codomain abstract value functions u
r given c u b ap u holds hm c u b
k k abstract c u b
contribute additive estimate hm c u b


fion oversubscription heuristic search

first loop preprocessing loop eliminates
abstraction skeleton nodes structurally unreachable abstract initial
states k ease presentation follows assume
cleanup abstraction skeleton leaves gi least one state whose value
second loop decreasingly iterates values k k
possibly come abstractions ap u positive
estimate h b candidates u tested turn via sub routine
achievable test returns positive first time done
tested candidate identified u otherwise test fails k
u particular implying state value greater reached
budget b
test achievable u linear program lp lm
given
eq linear program defined variables





c
x
sgi b
oo

k

constraints c objective maximizing value variable
lm

max
subject



k c gi



b
gi u

c
k
p

k c c
x
z k z
b



b
c

iz

roles different variables lm
follows
variable c captures cost associated label digraph gi

state gi variable captures cost cheapest path gi
given edges gi weighted consistently values
variables c
variable b captures minimal budget needed reaching gi state value
state given edges gi weighted consistently
variable vector c
preprocessing step replaced adding extra constraints linear program described
however would unnecessarily complicate presentation without adding much value



fidomshlak mirkis

singleton variable captures minimal total cost reaching states value
precisely k c u b
semantics constraints lm
follows
first two sets constraints come simple lp formulation

p single
p source shortest paths source node optimizing
k
sgi fixed weighting c edges leads computing precisely
k digraphs simultaneously
third set constraints establishes costs cheapest paths gi
states states valued enforcing semantics variables b b k
constraints b cost partition constraints enforce c cp
constraints c enforce aforementioned semantics objective variable
two things worth noting first nodes digraphs g gk
structurally reachable source nodes k respectively

ensured first loop
polytope induced l bounded
non empty indeed assignment oo c consistent
positiveness constraints b variables bounded
lengths respective shortest paths turn bounding bounds
variables c c k via third set constraints constraints c
bound objective
second number variables well number constraints


k
b polynomial number constraints c
thus
solving lm
standard methods linear programming infeasible lemma
actually mitigated lemma
semantics lm
match objective finding u
lemma figure terminates time polynomial
proof runtime complexity boils complexity solving
lm
number variables l well number constraints

polynomial number constraints c
b
k
cannot solved polynomial time standard methods linear

thus
l


programming simplex dantzig interior point methods nemirovsky yudin however
ellipsoid grotschel lovasz schrijver random walks family
originating work bertsimas vempala lp
exponential number constraints solved polynomial time provided
polynomial time separation oracle lp polynomial time separating oracle
convex set k rn procedure given x rn verifies x k
returns hyperplane separating x k procedure run polynomial time
case separation given assignment variables lm
test
whether satisfies b c produce inequality among
b c violated assignment


fion oversubscription heuristic search

separation lm
solved polynomial time
called sum minimization lps punnen precisely
parametrized procedure separation oracle lm
figure b number
constraints b polynomial satisfaction assignment x dom x
tested directly substitution constraints c letp permutation k
x b x b x b k x x b
easy see
px satisfies constraints c otherwise violated
inequality b

lemma figure computes u
proof lemma appears appendix p combining statements
lemmas theorem summarizes tractability abstraction discovery
ap u strong binary value partitions u
theorem ap u strong binary u
given osp task hv u c bi homomorphic explicit abstraction skeleton
strong binary value partition u u computed time polynomial

unfortunately practical value theorem yet evaluated
far found reasonably efficient implementation ellipsoid method
linear inequalities best knowledge random walks bertsimas vempala never implemented hope state
affairs change soon allowing powerful used theory
practice
strong general binary value partitions
recall polynomial theorem strong binary value partitions easily
extends corollary pseudo polynomial general binary value partitions turns pseudo polynomial extension theorem possible well
though technically involved corresponding shown figure
following format figure figure depicts macro flow
figure b shows specific implementation solve sub routine desired
time complexity achieved
similarly figure preprocessing loop first
eliminates abstraction skeleton nodes structurally unreachable
abstract initial states k next performs binary
search interval containing u since u binary value partition k
r denote codomain abstract value
p function u given
c u b ap u holds h c u b iz z k
size combinatorial hypothesis space prohibitive loop figure
performs binary search relaxed hypothesis space corresponding continuous
binary search could used figure well would
mere optimization necessary avoid exponential blowup time complexity



fidomshlak mirkis

input hv u c bi g gk k
binary value partition u
output u
k
reduce gi nodes reachable
let mini k
p

k

v
achievable v v
else v
return
else return
achievable v
ellipsoid method separation oracle lv solution x dom x lv
x b return true
else return false

separation oracle lv
x dom x

strict knapsack x b k x solution z k
p
iz v return yes
p
else return constraint iz b
b
figure pseudo polynomial approximating u general binary
value partitions u theorem

p
interval k r parameter serves sufficient precision criterion
termination
iteration corresponding interval uses sub routine
achievable test hypothesis u v v mid point
test positive next tested hypothesis u v v midpoint
v otherwise next hypothesis corresponds midpoint v
loop done reported estimate set still might lag
u lag arbitrarily reduced reducing anyway u
ensures admissibility estimate however loop terminates
u mini k implies u return
test achievable u v linear program lv
defined variables x eq obtained lm
replacing constraints c
constraints c


fion oversubscription heuristic search

lv
max
subject



k c gi



b
gi u

c
k
p

k c c
x
x
z k
v
b
iz



b
c

iz

semantics variables remains lm
captures minimal
total cost ofpreaching states si k abstract c u b
total value k u si v constraint c enforces semantics
lemma figure terminates time polynomial
log unary representation budget b
p



proof number iterations loop approximately log k


run time iterations boils complexity solving lv
v
lemma linear programs lm
number variables l well number
constraints b polynomial number
constraints c k therefore achievable v employs ellipsoid
method sub routine separation oracle lv associated separation
separation lv solved pseudo polynomial time
standard pseudo polynomial procedure strict knapsack
given assignment x dom x feasibility respect b
tested directly substitution
constraints c
let z k optimal solution
strict knapsack x b k x weight allowance x k
objects object k associated weight x b value
p
value iz z smaller v x satisfies constraints
c assume contrary x violatesp
constraint c corresponding

setpz k definition c
iz v assumption
x
x b

however
implies
z feasible solution

iz
strict knapsack value higher presumably optimal z
p
otherwise iz v z itselfpprovides us constraint c
violated x x
iz x b holds
virtue z
solution strict knapsack x b k x




fidomshlak mirkis

lemma mini k figure computes
u
proof lemma appears appendix p combining statements
lemmas theorem summarizes optimized abstraction discovery
ap u general binary value partitions u importantly note
figure depends unary representation budget possible
state values particular means dependence complexity number
alternative sub goals osp task interest polynomial finally theorem
formulated terms estimate precision values abstract value
functions u arbitrary real numbers case integer valued sets functions
u well special cases real valued functions u determined
precisely simplification figure instance k
integers setting value loop terminating
u details however theoretical interest reasonably small
values practice difference estimates h b h b
theorem ap u binary u
given osp task hv u c bi homomorphic explicit abstraction skeleton
g gk k binary value partition u possible
approximate u within additive factor time polynomial log
unary representation budget b
general value partitions
binary value partitions rather useful turns
pseudo polynomial abstraction discovery explicit homomorphic abstraction skeletons binary value partitions extended rather easily arbitrary value
partitions following observations
osp task hv u c bi homomorphic abstraction skeleton
g gk k value partition u number
distinct values taken u trivially upper bounded number states gi

pseudo polynomial solvability knapsack extends general
variant known multiple choice knapsack dudzinski walukiewicz kellerer
et al
multiple choice mc knapsack hn nm w given weight
allowance w classes objects n nm object j ni annotated
weight wij value ij objective
set z contains
p
one
p object class maximizes j z ij sets satisfying
j z wij w strict mc knapsack refer variant mc knapsack
inequality constraint strict mc knapsack generalizes regular knapsack
thus np hard however similarly regular knapsack mc knapsack
admits pseudo polynomial dynamic programming runs time polynomial


fion oversubscription heuristic search

description unary representation w dudzinski
walukiewicz kellerer et al
theorem ap c u
let hv u c bi osp task let g gk k explicit homomorphic abstraction skeleton let u arbitrary value
partition given cost partition c cp possible abstraction
c u b ap c u compute corresponding heuristic estimate hm c u b b
time polynomial unary representation budget b
proof proof similar proof theorem compilation
mc knapsack
k let ni number distinct values taken u let ini r
codomain u j ni let wij cost cheapest path gi
one states si u ij since explicit abstraction
skeleton k holds ni si set wij k j ni computed
time polynomial one standard single source shortest
paths
consider mc knapsack weight allowance b k classes
objects n nk ni ni object j ni annotated weight wij

value ij let z ki ni solution optimization mc knapsack
recall computable pseudo polynomial time given define budget profile
b b follows

wij j z

k b

otherwise
showing c u b actually induces additive abstraction completely identical proof corresponding argument theorem thus omitted

theorem ap u
given osp task hv u c bi homomorphic explicit abstraction skeleton
g gk k arbitrary value partition u
possible approximate u within additive factor time polynomial
log unary representation budget b
abstraction discovery theorem depicted figure
high level flow differs flow figure general binary
value partitions initialization parameters major difference
tests candidate values v linear
programs lv defined follows
k let ini r codomain u v r linear
program lv defined eq variables





sgi
x
b j
c

k

j ni



oo

fidomshlak mirkis

input hv u c bi g gk k
binary value partition u
output u
k
reduce gi nodes reachable
let mini k minj ni ij
p

k maxj ni ij

v
achievable v v
else v
return
else return
achievable v
ellipsoid method separation oracle lv solution x dom x lv
x b return true
else return false

separation oracle lv x
dom x

strict mc knapsack x b j j j n x b k j kj j nk x
solution z n nk
p
k iz v return yes
p
else return constraint k b z
b
figure modification figure arbitrary value partitions
u theorem b pseudo polynomial time separation oracle
corresponding linear programs lv eq

variables differ variable set lv see eq larger set b variables
variable b j captures minimal budget needed reaching gi state
value j state given edges gi weighted consistently
variable vector c


fion oversubscription heuristic search

lv
max
subject



k c gi



b j
j ni gi u ij


c
k
p

b
k c c
z n nk
x
x

iz v
b z
k

c

k

lemma linear programs lv number variables
lv well number constraints b polynomial
number constraints c dk maxi k ni therefore
achievable v employs ellipsoid method pseudo polynomial time separation oracle latter solving strict mc knapsack see
figure b otherwise solving lv solving lv similar
lemma figure terminates time polynomial
log unary representation budget b
lemma given osp task hv u c bi homomorphic explicit abstraction
skeleton g gk k arbitrary value partition u
figure computes u
proof lemma similar proof lemma strict knapsack
separation replaced strict mc knapsack separation
proof lemma similar proof lemma mutatis mutandis together
lemmas establish theorem

landmarks osp
addition state space abstractions family approximation techniques
found extremely effective context optimal classical notion
logical landmarks goal reachability karpas domshlak helmert domshlak
domshlak et al bonet helmert pommerening helmert
section proceed examining prospects reachability landmarks
heuristic search osp


fidomshlak mirkis

landmarks classical
state classical task landmark property operator sequences
satisfied plans hoffmann porteous sebastia instance
fact landmark state assignment single variable true point
every plan state art admissible heuristics classical use
called disjunctive action landmarks corresponding set operators
every plan contains least one operator set karpas domshlak
helmert domshlak bonet helmert pommerening helmert
follows consider popular notion landmarks simply refer disjunctive
action landmarks state landmarks ease presentation discussion take place context landmarks initial state task
simply referred landmarks
deciding whether operator set l landmark classical task
pspace hard porteous sebastia hoffmann therefore landmark heuristics
employ landmark discovery methods polynomial time sound incomplete
follows assume access procedure actual way landmarks
discovered tangential contribution
landmark cost
p set l landmarks


function lcost l r admissible
lcost l h singleton set
l l lcost l minol c natural admissible landmark cost function
extends directly non singleton sets pairwise disjoint landmarks general sets
landmarks lcost devised polynomial time via operator cost partitioning katz
domshlak b given l karpas domshlak within actual
process generating l helmert domshlak
landmarks budget reduction
landmarks play important role satisficing optimal classical
far exploited osp first glance probably surprise
osp investigated much less classical since
landmarks must satisfied plans empty operator sequence
plan osp task notion landmark seem useful said
consider anytime output improvement property bfbb forward search
empty plan interesting useless
found bfbb right beginning general stages search
anytime search bfbb maintain best far solution prune
branches promise value lower equal qb hence principle
may benefit information properties satisfied plans value
larger qb polynomial time discovery value landmarks arbitrary osp
tasks still open however looking needed available
classical machinery reachability landmarks actually
effectively exploited osp
p follows assume value function additive u
hv dis uv uv variable value pairs hv di value state
sum mutually independent non negative marginal values propositions
comprising value different plans osp task varying zero


fion oversubscription heuristic search

value optimal plan may zero let landmark state
property satisfied plan achieves something valuable
instance disjunctive action landmarks use l landmark
every plan qb contains operator l follows unless
stated otherwise focus landmarks initial state
definition given osp task hv u c bi compilation classical task hv g c
v v g
dom g
hg
g hg


og ohv di hv di uv
pre ohv di hv di eff ohv di hg

c
c


ohv di og
put simply semantics value hg auxiliary variable g
verified proposition positive value achieved
terms simply extends structure set zero cost actions
applying corresponds verifying positive value achieved
constructing trivially polynomial time allows us discover
landmarks standard machinery classical landmark discovery
theorem osp task landmark l l landmark
proof proof rather straightforward let p set plans
qb p set plans definition p plan p
exists proposition hv di uv hv di jk likewise since

hg applicable

ffhence definition


ohv di
ohv di applicable
hg

j

k





hv di
hv di p turn

l landmark ohv di contains operator l l
contains operator l well proves landmarks l
operators landmarks

theorem hand derive landmarks method
classical landmark extraction employed lama planner richter et al lm cut family techniques helmert domshlak
bonet helmert however first glance discriminative power knowing
needed achieve something valuable seems negligible comes deriving effective heuristic estimates osp good news osp information
effectively exploited slightly different way


fidomshlak mirkis

consider schematic example searching optimal plan ops task
budget b bfbb admissible heuristic h suppose one
sequence unit cost operators ho ob applicable initial state
positive value state along end state clearly
value higher zero achieved given budget b search
continue beyond initial state unless h counts cost b operators
suppose h counts cost oi ob
oi discovered landmarks given suppose
modify setting cost operators oi zero b reducing
budget b since operators oi applied anyway
along value collecting plan modification seems preserve semantics
time modified task bfbb heuristic h prune
initial state thus establish without search empty plan optimal plan
course way modified example simplistic example
yet example motivate idea landmark budget reduction osp
well illustrates basic idea behind generically sound task modifications
discuss next

definition let hv u c bi osp task l l ln set
pairwise disjoint landmarks lcost admissible landmark cost function
l budget reducing compilation osp task l hvl l ul ol cl bl

n
x
bl b
lcost li




vl v vl vln
dom vli
l hvl hvln
ul u
ol

n



oli

n


li



pre pre hvli eff eff hvli

c
oo
cl

c lcost li oli
words l extends structure
mirroring operators landmark li cheaper lcost li versions


fion oversubscription heuristic search

cbb





abb





btb


bbb


bbt


ctb




btt




cbt


u





u

ccb





ctt


u







ctc

u
cct


u



ccc



cbc


u

cbb
ctb


abb



bbb

btb




bbt




btt










cbb



ctt

u
cbt




u

ccb




ctc



u


u
cct

ccc

abb




cbc





btb


bbb


bbt





ctb




btt




cbt












u
ccb





ctt


u

u
ctc

u
cct


u



ccc



cbc

figure illustrations example landmark budget reducing compilation
l structurally reachable parts graphical skeleton model
induced l illustrated projection l variables original
task along comparison budget wise reachable parts
graphical skeletons induced b original task c
compiled task l

disposable propositions hvl hvln ensure one
instance discounted operators li applied along operator
sequence initial state
compensating discounted operators li reducing budget precisely
lcost li
example consider simple osp task figure p cost budget
b assume provided set four landmarks l l l
l l l l admissible landmark cost
function lcost li compiling l lcost budget reducing
compilation definition
task l budget bl c
discounted operators ni oli
states correspond complete assignments three variables v
x l already seven variables vl x vl vl vl vl thus depicting
note auxiliary variable g compilation effectively change value
hg hg auxiliary variables vli l change values hvli hvli
difference reflects positive semantics usually associated value aka value
true propositions semantics state l containing proposition hvli
still allowed apply one discounted operators associated landmark li
onwards



fidomshlak mirkis

compile bfbb hv u c bi
compilation
l set landmarks
lcost admissible landmark cost function l
l budget reducing compilation l lcost
n bfbb l
return plan associated n
figure bfbb search landmark budget reduction
structurally reachable parts graphical skeleton gml problematic still
illustrate search space figure structurally reachable parts
graphical skeleton model induced projection variables
x arcs corresponding discounted operators colored color
distinguishing landmark responsible respective discounted operators
figures b c illustrate effect budget reducing compilation depicting parts graphical skeletons gm gml actually reachable
respective cost budgets b bl states btt ctt
reachable initial state budget allowance states corresponding btt ctt longer reachable l reducing size search space
bfbb time formulated theorem reduction
search space affect plans lead valuable states resulting effective
equivalence l
theorem let hv u c bi osp task l set pairwise disjoint
landmarks lcost admissible landmark cost function l l
respective budget reducing compilation every qb
plan l l qbl l qb vice versa
proof theorem appears appendix p budget reducing ospto osp compilation definition clearly polynomial time compile bfbb
procedure depicted figure
generates compilation
uses shelf tools classical generate set landmarks l
admissible landmark cost function lcost
compiles l lcost obtaining osp task l
optimal solution l thus searched search
optimal osp bfbb
proceed consider general sets landmarks comments concerning setup theorem order first reduced budget bl turns
lower cost cheapest action applicable initial state obviously
search needed empty plan reported optimal right away second


fion oversubscription heuristic search

zero cost landmarks useless compilation much useless deriving
landmark heuristics optimal hence lcost follows assumed
strictly positive third applicable state brings benefits
yet adds branching search hence implementation landmark li l
operator li precondition regular operators ol extended
hvli hard verify extension preserves correctness
l terms theorem finally value initial state zero
empty plan positive value compilation positive
cost landmarks however easily fixed considering valuable
propositions hv di uv hv di ignore time
non zero value initial states assume qb return
later systematic discussion
non disjoint landmarks
budget reducing compilation l sound pairwise disjoint landmarks
general sets landmarks example consider task
operator c b qb hoi qb
operator sequences hoi value greater zero achievable
via operator suppose set landmarks l l ln
n lcost li n
pnthat landmarks contain
case budget l bl b lcost li cost cheapest replica
cost cheapest operator sequence achieving non zero value
n

n





c max lcost li b max lcost li b

n
x

lcost li bl



hence state positive value reachable l l thus l
value equivalent sense theorem
example shows compiling non disjoint landmarks independently
sound principle made sound follows let hv u c bi
osp task let l l ln set landmarks let lcost admissible
landmark cost function l components l hvl l ul ol cl bl
still defined definition except operator sets ol oln latter
constructed independently sequentially content
oli depending content olj j ordering sets oli
constructed arbitrary
operator n let oo denote set cost
discounted representatives introduced
construction ol oli

n operator li oo cl oli
otherwise oli contains operator operator
li


li



oo



fidomshlak mirkis

defined similarly definition
pre pre hvli
eff eff hvli

c lcost li
cl
cl lcost li

li


li oo



compilation extended way sound arbitrary sets landmarks
pairwise disjoint landmarks reduces basic compilation used theorem
general however extended compilation longer polynomial size
explicit representation
oo lj ji olj
example let l l l l l b l c l generation
ol b effectively follows definition ol base set operators
eq already c thus ol c denoting
ai derived according eq ai consequently base set operators
ol resulting ol
ai derived ai sum l ends l representatives operator
since non disjoint landmarks bring information typical outputs
standard techniques landmark extraction classical present
different slightly involved compilation polynomial sound arbitrary
sets landmarks
definition let hv u c bi osp task l l ln set
pairwise disjoint landmarks lcost admissible landmark cost function
l operator let l denote set landmarks l contain
generalized budget reducing compilation osp task l
hvl l ul ol cl bl
bl b

n
x

lcost li



vl v vl vln
dom vli
l hvl hvln
ul u
ol l get l l l

pre pre hvl l l
eff eff hvl l l




pre get l hvl
eff get l hvl




fion oversubscription heuristic search




c p
cl c lcost l


lcost l

oo





get l

illustrate compilation let l l l l
l b
l b c
l c
operators cost let
lcost l lcost l lcost l
l vl v vl vl vl
ol b c get l get l get l
e g
pre pre hvl hvl
eff eff hvl hvl
cl
get l
pre get l hvl
eff get l hvl
cl get l
intuition behind compilation definition follows eq applying
discounted operator saves total cost landmarks containing therefore
executed states corresponding control propositions
hvl l l hold indicating cost landmark l already
saved reaching
avoid double savings around l applying turns control propositions sjok
however considering example suppose optimal plan original
task contains instance operator followed instance operator b
instance operator c applying instead would block us applying b instead
b thus value optimal plan compilation lower qb
rescue comes get l actions allow selective spending
individual landmark costs lcost l example applying saves cost
landmarks l l applying get l spend lcost l safely set


fidomshlak mirkis

control proposition hvl turn enable b applied next steps
applying b save cost l save cost l way
compilation leads equivalence l formulated theorem
proven appendix p
theorem let hv u c bi osp task let l l ln set
landmarks let lcost admissible landmark cost function l let l
generalized budget reducing compilation every qb
plan l l qbl l qb vice versa
landmarks incremental bfbb
discussed earlier value initial state zero empty plan
positive value thus compilation definition
landmarks positive cost passing noted small remedied
considering valuable facts hv di uv hv di
consider aspect osp closely discovery landmarks
incremental revelation plans bfbb combined mutually stratifying
way
let hv u c bi osp task interest suppose given set
plans n longer interested searching plans
achieve something searching plans achieve something beyond
n already achieve specifically let si ji k end state
set propositions let goods set propositions hv di
uv plan end state achieves something beyond n
already achieve n
goods goods si
put observation work
definition given osp task hv u c bi set reference states sref
sn sref compilation classical task sref
hv g c
v v x xn search collect
dom xi dom search dom collect
hsearch hcollect hx hxn
g hx hxn
n


oi f inish





fion oversubscription heuristic search


pre pre hsearch
eff eff
c c

pre f inish
eff f inish hcollect hsearch
c f inish
oi oi g si sref g goods si
pre oi g g hcollect
eff oi g hxi
c oi g
note
goal g cannot achieved without applying f inish operator
regular operators applied f inish
subgoal achieving operators oi g applied f inish
way first part plan sref determines plan second part
verifies end state plan achieves subset value carrying propositions
goods included state sref
theorem let hv u c bi osp task sref sn subset
states l landmark sref l plan
goods jk goods si si sref contains instance least one
operator l l
proof assume contrary exists plan ho ok
goods jk goods si si sref yet l let g gn
arbitrary set propositions goods jk goods goods jk goods sn
respectively construction sref immediate
sref ho ok f inish g gn
plan sref assumption l holds sref l
however contradicts l landmark sref

solve verify technique appears helpful many formalism compilations see
e g work keyder geffner



fidomshlak mirkis

inc compile bfbb hv c u bi
initialize global variables
n
best solution far
sref current reference states
loop
sref sref compilation
l set landmarks sref
lcost admissible landmark cost function l
l budget reducing compilation l lcost
inc bfbb l sref n done
return plan associated n
inc bfbb sref n
open max heap ordered f n h shni b g n
open insert make root node
closed
best cost
open empty
n open pop max
f n u shn break
u shni u shn update n n
goods shni goods sref
sref sref shni
termination criterion return updated
rest similar bfbb figure

shni closed g n best cost shni
closed closed shni
best cost shni g n
foreach shni
n make node shnijok n
g n b f n u shn continue
open insert n
return done
figure iterative bfbb landmark enhancement
theorem allows us define iterative version bfbb inc compile bfbb
depicted figure successive iterations inc compile bfbb correspond
running regular bfbb successively informed sref compilations
states discovered iteration making sref compilation used iteration
informed
inc compile bfbb maintains pair global variables set reference states
sref best solution far n iteration loop modified version
bfbb inc bfbb called sref compilation created basis


fion oversubscription heuristic search

current sref reference set sref extended inc bfbb non redundant
value carrying states discovered search n updated search discovers
nodes higher value
open list becomes empty node n selected list promises
less lower bound inc bfbb returns indicator done best solution
n found far across iterations inc compile bfbb optimal case
inc compile bfbb leaves loop extracts optimal plan n however
inc bfbb may terminate different way certain complementary termination
criterion satisfied latter criterion comes assess whether updates sref
performed current session inc bfbb warrant updating sref compilation
restarting search terminated way inc bfbb returns respective indicator
inc compile bfbb goes another iteration loop updated sref
n note optimality holds termination
condition latter greatly affect runtime efficiency
theorem inc compile bfbb search sound complete optimal osp
proof first complementary termination criterion employed inc bfbb procedure inc compile bfbb guaranteed terminate complementary termination criterion checked inc bfbb proper expansion
global reference set sref thus number calls inc bfbb inc compile bfbb
upper bounded
terms search inc bfbb different regular bfbb procedure turn
theorem additional pruning power budget reducing compilation reference
states sref affects search nodes n u shni maxssref u note
time best solution far n updated inc bfbb necessarily added sref
since goods shn n included goods sref thus optimal
solutions cannot pruned inc bfbb overall search inc compile bfbb
therefore sound

empirical evaluation
evaluate merits landmark budget reducing compilation extended prototype osp solver section following components
sref compilation osp tasks arbitrary sets reference states sref
generation disjunctive action landmarks sref compilations lm cut
procedure helmert domshlak fast downward
incremental bfbb procedure inc compile bfbb figure
search termination criterion satisfied examined node n improves
current value lower bound e n becomes best far node n
preliminary evaluation added two optimality preserving enhancements search auxiliary variables compilations increase dimensionality known negatively affect quality abstraction


fidomshlak mirkis

blind


unsolved








unsolved

compile bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel





bfbb

b hm


unsolved







unsolved

compile bfbb







bfbb

figure comparative view empirical terms expanded nodes bfbb
vs compile bfbb blind b abstraction hm heuristics

heuristics domshlak et al first devised projections respect original osp open list ordered search done original



x
h shniv b g n
lcost l
vl shni

sv projection l state variables original osp task
change heuristic evaluation sound theorem particular implies


fion oversubscription heuristic search

admissible heuristic admissible heuristic l vice versa second
node n generated check whether
x
x
lcost l
lcost l g n
g n
l hvl ishn

l hvl ishni

previously generated node n corresponds state original
shn iv shniv n pruned right away optimality
preservation enhancement established lemma proven appendix
p
lemma let osp task sref sref compilation l set
landmarks sref lcost admissible landmark cost function l l
respective budget reducing compilation l lcost let pair plans
v
l end states respectively sv

cl

x

lcost l cl

l hvl

x

lcost l



l hvl

plan extends exists plan extends
qbl

qbl

evaluation included regular bfbb solving landmarkbased compilation via compile bfbb simple setting inc compile bfbb
described three approaches evaluated blind heuristic
additive abstraction heuristic hm described section figures depict
evaluation terms expanded nodes similarly experiment reported
section task approached four different budgets corresponding
minimal cost needed achieve goals task
run restricted minutes figures b compare number
expanded nodes bfbb compile bfbb across four levels cost budget
blind abstraction hm b heuristics figures b provide similar
comparison bfbb inc compile bfbb figures b
compile bfbb inc compile bfbb figures figures
appendix b provide detailed view figures respectively
breaking different levels cost budget
figure shows satisfactory informative heuristic
guidance number nodes expanded compile bfbb typically much
lower number nodes expanded bfbb difference reaching three
orders magnitude task budget pairs behind figure
pairs solved compile bfbb search proving plan
achieve value higher initial state unsurprisingly
tasks solved search bfbb
present detailed comparison terms running times per node cpu
time overhead due landmark budget reduction technical difficulties
implementation inc compile bfbb led us limit comparison graph tasks
solved methods



fidomshlak mirkis

blind


inc compile bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel









bfbb

b hm

inc compile bfbb










bfbb

figure comparative view empirical terms expanded nodes bfbb
vs inc compile bfbb blind b abstraction hm heuristics

expected impact landmark budget reduction lower
search equipped meaningful heuristic figure b nonetheless even
abstraction heuristic hand number nodes expanded compile bfbb
often substantially lower number nodes expanded bfbb bfbb
compile bfbb solved search task budget pairs respectively finally despite rather ad hoc setting incremental inc compile bfbb procedure
switching compile bfbb inc compile bfbb typically beneficial obvi

fion oversubscription heuristic search

blind


inc compile bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel









compile bfbb

b hm

inc compile bfbb










compile bfbb

figure comparative view empirical terms expanded nodes
compile bfbb vs inc compile bfbb blind b abstraction hm heuristics

ously much deeper investigation development inc compile bfbb still required
especially context choice iteration termination criterion

summary future work
deterministic oversubscription captures computational core one
important setups automated action selection yet despite apparent importance


fidomshlak mirkis

sufficiently investigated work progressed towards
translating spectacular advances classical deterministic deterministic
osp tracing key sources progress classical identified severe lack
effective approximations osp worked towards bridging gap
focus two classes approximation techniques underly state ofthe art optimal heuristic search solvers classical state space abstractions
goal reachability landmarks first defined notion additive abstractions osp
studied complexity deriving effective abstractions rich space hypotheses
revealed substantial empirically relevant islands tractability abstraction
discovery next showed standard goal reachability landmarks certain
classical tasks compiled osp task interest resulting
equivalent osp task lower cost allowance thus sometimes dramatically
smaller search space
techniques proposed satisfy properties required efficient search
optimal osp however believe techniques especially
landmark budget reducing compilations beneficial satisficing osp
optimal osp particular difference optimal satisficing
appears much smaller osp classical deterministic
many interesting questions remain open future work prospects
developments oversubscription appear quite promising within specific
context work two interesting directions optimization value
partitions given cost partitions optimizing abstraction discovery ap c
thoroughly investigating interleaved landmark discovery search osp
introduced section broader context propose well additional candidates
future
following work katz domshlak implicit abstractions classical computational merits implicit abstractions osp
investigated inevitably give us better understanding computational
tractability boundaries deterministic osp
basic model deterministic section used provide unifying
comparative view basic classical cost bounded net benefit
oversubscription one practically motivated extension model lift
action costs vectors action costs variant cost bounded
already investigated nakhost et al natural examine
extension context osp
unfortunately abstractions seem extend directly vectors
costs level model adding cost measures shifts solving
polynomial time shortest path np hard restricted shortest path
handler zang nonetheless knapsack restricted shortest path solved pseudo polynomial time desrochers
soumis thus extension vectors costs might still
achievable
time machinery landmark budget reducing compilations
osp straightforwardly extends vectors costs budgets hence even


fion oversubscription heuristic search

quality heuristic osp multiple cost measures available blind search
still stratified information coming landmarks
pruning mechanism bfbb must rely admissible upper bounding
heuristic estimates special properties required heuristic used guide
search choices bfbb thus developing informative yet necessarily admissible
heuristics osp clearly interest
acknowledgments
work partially supported eoard grant fa isf
grant

appendix proofs
theorem given osp task hv u c bi homomorphic abstraction
skeleton g gk k
cost partition c cp exists budget partition b bp

c u b value partitions u
budget partition b bp exists cost partition c cp

c u b value partitions u
proof let h sn sn optimal plan
k let h sn mapping
gi since homomorphic paths k well defined
p
given cost partition c cp let budget profile b b defined b

j n c oj k first note b bp since
x
k



x x

b

c oj

k j n

x



c oj b

j n

c cost partition plan
second u u construction b plan abstract
c u b
model mi
let u k let optimal plan
c u b
mi

x
k

qb







x



qb



qb



k

optimality sn end state u
value partition therefore c u b induces additive abstraction

c u b aas


fidomshlak mirkis

given budget partition b let cost profile c c defined c c b
b
forpall operators k first c cp since b bp implies


k b second u u construction c b
c u b

plan mi
following exactly line reasoning eq

accomplishes proof c u b aas u

lemma figure computes u
proof due boundness non emptiness polytope induced lm
termination straightforward thus given strong binary partition u
question whether value terminates u first let
us
k x solution lm
x b cost partition
c cp exists budget partition b bp c u b abstraction
hm c u b
assume contrary cost partition c cp exists budget partition b bp hm c u b
yet x b given values provided x cost variables oo c let c corresponding cost partition
k induced lengths shortest paths k valued states g gk respectively assumption let b budget partition
hm c u b first definition strong binary value partitions
hm c u b implies exists z k z z b
second constraint c maximization fact bound b
imply together z x b putting things together obtain
bbp

b

x

b

iz

x



iz

x

c

x b

iz

contradicting assumption
assume contrary x b yet exists cost partition c cp
budget partitions b bp c u b ap hm c u b
let shortest path lengths k defined respect
specific cost partition c assumption
likewise let xc solution lm


extra constraint cost variables oo c assigned c since objective
lm
maximize value
x xc



let
z

argmax

x

z k z iz





fion oversubscription heuristic search

together constraint c maximization fact bound
b via cost variables imply
xc

x

xc b

iz

x





iz

turn together x b eq eq implies

xc b
b


iz
otherwise

budget partition c u b ap hm c u b contradicting assumption
proved sub claim basically captures semantics lm
suppose
terminates within loop returns
construction x solution lm
x b cost
partition c cp exists c u b ap h c u b k
trivially u otherwise k know terminate
previous iteration corresponding implies exists
cost partition c cp c u b ap induce h c u b hence
definition u u turn since u strong binary value
partition u finally terminates loop
returns precisely argument basis implies u

lemma mini k figure computes
u
proof arguments boundness non emptiness polytope induced
lv precisely polytope lm
studied lemma thus
termination straightforward follows prove value
returned satisfies claim lemma let u given binary
partition similarly proof lemma first prove sub claim
v r x solution lv x b cost partition
c cp exists budget partition b bp c u b abstraction
hm c u b v
proof mirrors proof respective sub claim lemma mutatis mutandis
thus provided ease verification
assume contrary cost partition c cp exists budget
partition b bp hm c u b v yet x b

given values provided x cost variables oo c let c corresponding cost partition k let induced length shortest
path valued states gi assumption let b budget
partition hm c u b v first
p definition binary value partitions
hm c u b v implies exists z k iz v z b


fidomshlak mirkis

second constraint c maximization fact bound b
imply together z x b putting things together obtain
bbp

b

x

b

iz

x



iz

x

c

x b

iz

contradicting assumption
assume contrary x b yet exists cost partition c cp
budget partitions b bp c u b ap hm c u b v
let shortest path lengths k defined respect
specific cost partition c assumption
likewise let xc solution lv

extra constraint cost variables oo c assigned c since objective
lv maximize value
x xc



let
z argmax

x


pz k iz
iz v



together constraint c maximization fact bound
b via cost variables imply
xc

x

xc b

iz

x





iz

turn together x b eq eq implies

xc b z
b


otherwise
budget partition c u b ap hm c u b v contradicting assumption
finalizes proof sub claim pconsider interval end points
termination
loop
k trivially u
p
otherwise k construction iteration
loop test achievable issued came back negative thus
solutions x l x b hence u
construction iteration loop test achievable
issued came back positive thus solutions x l x b
hence u putting properties together loops
termination condition implies u u finally
mini k implies mini k turn since u corresponds sum values
states k c u b u concluded implies u



fion oversubscription heuristic search

theorem let hv u c bi osp task l set pairwise disjoint
landmarks lcost admissible landmark cost function l l
respective budget reducing compilation every qb
plan l l qbl l qb vice versa
proof let l plan
snfor l let operator sequence obtained replacing
operators oli along l respective operators
definition
action set l eq applicable jk
l jl k ni dom vli thus qb qbl l likewise definition
action set l eq fact operator ol achieves control
propositions hvl hvln oli l

c cl l

n
x

lcost li



p
turn b bl ni lcost li eq cl l bl virtue l
plan l therefore holds c b thus plan
opposite direction let plan qb let l
operator sequence obtained replacing landmark l l every first occurrence
operator l respective cost reduced operator ol easy
verify l applicable l qbl l qb likewise definition
landmarks every l l presence along

c l c

n
x

lcost li b



n
x

lcost li bl



first equality pairwise disjointness l ln inequality
plan second equality eq thus l plan l


theorem let hv u c bi osp task let l l ln set
landmarks let lcost admissible landmark cost function l let l
generalized budget reducing compilation every qb
plan l l qbl l qb vice versa
proof let l plan l let operator sequence obtained replacing
operators respective operators ii removal get operators
eq applicable jk l jl k hvl hvln thus
qb qbl l landmark l l let l number instances
cost reduced counterparts operators l along l eqs
l l l must contain least l instances operator get l



fidomshlak mirkis

x

c cl l

x

lcost l

ol

cl l

x
x

l lcost l



l lcost l



cl l

x

x

l lcost l



lcost l



bl

x

lcost l



b
thus plan
opposite direction let ho om plan qb
definition landmarks every landmark li l presence along let
f n first occurrence
ffoperator li along f


let k k n operator sequence obtained
argminj oj li
ordering operators n consistently note since landmarks
l necessarily disjoint may f f j j n thus
k strictly smaller n
given let l operator sequence obtained
replacing along
inserting right arbitrary ordered sequence actions



get l l l j l



j

note set union semantics eq even multiple operators
appear landmark l together one instance operator get l
inserted step
hard verify l applicable l qbl l qb
step expanding l reduces cost operator sequence
k
x

x

lcost l



x

l lcost l



l number occurrences operators fromp
l turn step
expanding l increases cost operator sequence l lcost l
eq among l operators along l l
first preceded dedicated instances operator get l thus
x
x
cl l c
lcost l b
lcost l bl




l plan l




fion oversubscription heuristic search

lemma let osp task sref sref compilation l set
landmarks sref lcost admissible landmark cost function l l
respective budget reducing compilation l lcost let pair plans
v
l end states respectively sv

cl

x

lcost l cl

plan
b
l
q qbl

lcost l



l hvl

l hvl



x

extends exists plan extends

proof notation claim proof constructive mapping plan
corresponding plan
first derive plan removing f inish operator
get operators ii replacing instances discounted operator
instances respective original operator plan e
p
sv
c cl
l hvl lcost l see latter

operator ol let denote number instances along given

c cl

x

get l lcost l



x

cl

lcost l



cl

x

x

x












x

lcost l

get l





lcost l hvl



cl

x

lcost l

l hvl

second fourth equalities formula manipulations first equality
direct construction third equality definition budget
reducing compilation specifically eqs
similarly construction p
construct

sv

c


c





l

l hvl lcost l thus eq c c
setting lemma hence e plan
qb qb
last step construct plan l claim first
properties claim plan achieves landmarks l l
hvl second definition landmark set l e must satisfy rest
landmarks ls l hvl let us denote operator instances along
e ho ok k e let l lk partition ls li ls
subset landmarks ls oi first achiever along e
given consider operator sequence e k recursively defined via
li hoi else hoi arbitrary


fidomshlak mirkis

sequencing operators
get l l li hvl j kj k
finally set e
eqs definition budget reducing compilation
easy
p
verify construction e ensures cl e c e hvl lcost l
qbl e qb turn properties implies qbl qbl
cl cl cl e
finally since
x
lcost l
cl c
hvl


x

cl e c e

lcost l

hvl


cl c c e

x

lcost l



thus since c c e valid plan
x
cl c c e
lcost l




c



x

lcost l



b

x

lcost l



finalizing proof plan l claim





fion oversubscription heuristic search

appendix b detailed evaluation



unsolved




hm





unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel





blind

b


unsolved



hm




unsolved






basic

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fidomshlak mirkis




unsolved




hm





unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel





blind

b


unsolved



hm




unsolved






basic

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fion oversubscription heuristic search




unsolved




hm





unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel





blind

b


unsolved



hm




unsolved






basic

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fidomshlak mirkis




unsolved




hm





unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel





blind

b


unsolved



hm




unsolved






basic

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fion oversubscription heuristic search

blind


unsolved


compile bfbb







unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel





bfbb

b hm


unsolved

compile bfbb






unsolved






bfbb

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fidomshlak mirkis

blind


unsolved


compile bfbb







unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel





bfbb

b hm


unsolved

compile bfbb






unsolved






bfbb

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fion oversubscription heuristic search

blind


unsolved


compile bfbb







unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel





bfbb

b hm


unsolved

compile bfbb






unsolved






bfbb

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fidomshlak mirkis

blind


unsolved


compile bfbb







unsolved

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel





bfbb

b hm


unsolved

compile bfbb






unsolved






bfbb

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fion oversubscription heuristic search

blind


inc compile bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel









bfbb

b hm


inc compile bfbb










bfbb

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fidomshlak mirkis

blind


inc compile bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel









bfbb

b hm


inc compile bfbb










bfbb

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fion oversubscription heuristic search

blind


inc compile bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel









bfbb

b hm


inc compile bfbb










bfbb

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fidomshlak mirkis

blind


inc compile bfbb

airport
blocks
depot
driverlog
freecell
grid
gripper
logistics
miconic
mystery
openstacks
pipesworld
psr small
tpp
trucks
rovers
satellite
zenotravel









bfbb

b hm


inc compile bfbb










bfbb

figure comparison figure p restricted tasks budgeted
minimal cost achieving entire set subgoals



fion oversubscription heuristic search

references
backstrom c klein polynomial time sas pubs class
computational intelligence
backstrom c nebel b complexity sas computational
intelligence
baier j bacchus f mcilraith heuristic search
temporally extended preferences artificial intelligence
benton j coles j coles temporal preferences
time dependent continuous costs proceedings nd international conference
automated scheduling icaps pp
benton j kambhampati anytime heuristic search partial satisfaction artificial intelligence
benton j van den briel kambhampati hybrid linear programming
relaxed plan heuristic partial satisfaction proceedings
seventeenth international conference automated scheduling
icaps pp
bertsimas vempala solving convex programs random walks journal
acm
bonet b admissible heuristic sas obtained state
equation proceedings rd international joint conference artificial
intelligence ijcai pp
bonet b geffner h heuristic search artificial intelligence

bonet b geffner h heuristics penalties rewards formulated logic computed circuits artificial intelligence

bonet b helmert strengthening landmark heuristics via hitting sets
proceedings th european conference artificial intelligence ecai pp

brafman r chernyavsky goal preferences constraints
proceedings international conference automated scheduling pp
clarke e grumberg peled model checking mit press
coles fox long smith j additive disjunctive heuristics
optimal proceedings th international conference automated
scheduling icaps pp
coles j coles fox long hybrid lp rpg heuristic modelling
numeric resource flows journal artificial intelligence



fidomshlak mirkis

coles j coles lprpg p relaxed plan heuristics
preferences proceedings st international conference automated scheduling icaps pp
cousot p cousot r abstract interpretation frameworks journal logic
computation
dantzig g b linear programming extensions princeton university press
dantzig number language science macmillan
desrochers soumis f generalized permanent labelling
shortest path time windows information systems operations

b benton j van den briel kambhampati goal
utility dependencies proceedings th international joint conference
artificial intelligence ijcai pp
domshlak c hoffmann j sabharwal friends foes
satisfiability abstract cnf encodings journal artificial intelligence

domshlak c katz lefler landmark enhanced abstraction heuristics
artificial intelligence
dudzinski k walukiewicz exact methods knapsack
generalizations european journal operational
dvorak f bartak r integrating time resources proceedings nd ieee international conference tools artificial intelligence
ictai pp
edelkamp pattern databases proceedings european
conference ecp pp
edelkamp taming numbers durations model checking integrated
system journal artificial intelligence
fikes r e nilsson n strips application theorem
proving solving artificial intelligence
fox long pddl extension pddl expressing temporal
journal artificial intelligence
garey r johnson computers intractability guide theory
np completeness w h freeman company york
geffner h bonet b concise introduction methods automated synthesis lectures artificial intelligence machine learning
morgan claypool
gerevini haslum p long saetti dimopoulos deterministic
fifth international competition pddl experimental
evaluation planners artificial intelligence


fion oversubscription heuristic search

gerevini saetti serina stochastic local search
temporal action graphs lpg journal artificial intelligence

gerevini saetti serina efficient numerical
fluents multi criteria plan quality artificial intelligence
grotschel lovasz l schrijver ellipsoid method consequences
theorems combinatorial optimization combinatorica
handler g zang dual constrained shortest path
networks
haslum p heuristics bounded cost search proceedings rd international conference automated scheduling icaps pp
haslum p bonet b geffner h admissible heuristics domainindependent proceedings th national conference artificial
intelligence aaai pp
haslum p botea helmert bonet b koenig domain independent
construction pattern database heuristics cost optimal proceedings
th national conference artificial intelligence aaai pp
haslum p geffner h admissible heuristics optimal proceedings th international conference artificial intelligence systems
aips pp
haslum p geffner h heuristic time resources proceedings
th european conference ecp pp
helmert decidability undecidability numerical
state variables proceedings sixth international conference artificial
intelligence scheduling aips pp
helmert fast downward system journal artificial intelligence

helmert domshlak c landmarks critical paths abstractions whats
difference anyway proceedings th international conference automated scheduling icaps pp
helmert haslum p hoffmann j flexible abstraction heuristics optimal
sequential proceedings th international conference automated
scheduling icaps pp
helmert haslum p hoffmann j nissim r merge shrink abstraction
method generating lower bounds factored state spaces journal acm

hoffmann j metric system translating ignoring delete lists
numeric state variables journal artificial intelligence
hoffmann j gomes c p selman b kautz h sat encodings statespace reachability numeric domains proceedings th international joint conference artificial intelligence ijcai pp


fidomshlak mirkis

hoffmann j nebel b system fast plan generation
heuristic search journal artificial intelligence
hoffmann j porteous j sebastia l ordered landmarks journal
artificial intelligence
karp r reducibility among combinatorial complexity computer
computations pp plenum press york
karpas e domshlak c cost optimal landmarks proceedings
international joint conference artificial intelligence ijcai pp

katz domshlak c implicit abstraction heuristics journal artificial
intelligence
katz domshlak c b optimal admissible composition abstraction heuristics artificial intelligence
kellerer h pferschy u pisinger knapsack springer verlag
berlin
keyder e geffner h soft goals compiled away journal artificial
intelligence
koehler j resource constraints proceedings th european
conference artificial intelligence ecai pp
mirkis v domshlak c abstractions oversubscription proceedings rd international conference automated scheduling
icaps pp
mirkis v domshlak c landmarks oversubscription proceedings
rd european conference artificial intelligence ecai pp
nakhost h hoffmann j muller resource constrained monte
carlo random walk proceedings nd international conference
automated scheduling icaps pp
nebel b compilability expressive power propositional
formalisms journal artificial intelligence
nemirovsky yudin n interior point polynomial methods convex programming siam
pearl j heuristics intelligent search strategies computer solving
addison wesley
pommerening f helmert incremental lm cut proceedings rd
international conference automated scheduling icaps pp
rome italy
porteous j sebastia l hoffmann j extraction ordering usage
landmarks proceedings th european conference
ecp pp


fion oversubscription heuristic search

punnen p k sum linear programming journal operational
society
richter helmert westphal landmarks revisited proceedings
rd aaai conference artificial intelligence aaai pp
russell norvig p artificial intelligence modern edition
pearson
sanchez r kambhampati graph heuristics selecting objectives subscription proceedings th international
conference automated scheduling icaps pp
smith choosing objectives subscription proceedings
th international conference automated scheduling icaps pp

thayer j ruml w bounded suboptimal search direct
inadmissible estimates proceedings nd international joint conference
artificial intelligence ijcai pp
thayer j stern r felner ruml w faster bounded cost search
inadmissible estimates proceedings nd international conference
automated scheduling icaps pp
van den briel sanchez r b kambhampati effective approaches
partial satisfaction subscription proceedings th aaai
conference artificial intelligence aaai pp
van den briel benton j kambhampati vossen lp heuristic optimal proceedings th international conference
principles practice constraint programming cp pp
yang f culberson j holte r zahavi u felner general theory
additive state space abstractions journal artificial intelligence





