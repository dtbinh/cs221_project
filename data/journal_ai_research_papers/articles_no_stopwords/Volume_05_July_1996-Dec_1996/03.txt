Journal Artificial Intelligence Research 5 (1996) 95{137

Submitted 3/96; published 9/96

Accelerating Partial-Order Planners: Techniques
Effective Search Control Pruning
Alfonso Gerevini

gerevini@ing.unibs.it

Lenhart Schubert

schubert@cs.rochester.edu

Dipartimento di Elettronica per l'Automazione, Universita di Brescia
Via Branze 38, I-25123 Brescia, Italy
Department Computer Science, University Rochester
Rochester, NY 14627-0226, USA

Abstract

propose domain-independent techniques bringing well-founded partialorder planners closer practicality. first two techniques aimed improving
search control keeping overhead costs low. One based simple adjustment
default A* heuristic used ucpop select plans refinement. based
preferring \zero commitment" (forced) plan refinements whenever possible, using
LIFO prioritization otherwise. radical technique use operator parameter
domains prune search. domains initially computed definitions
operators initial goal conditions, using polynomial-time algorithm
propagates sets constants operator graph, starting initial conditions.
planning, parameter domains used prune nonviable operator instances
remove spurious clobbering threats. experiments based modifications ucpop,
improved plan goal selection strategies gave speedups factors ranging 5
1000 variety problems nontrivial unmodified version.
Crucially, hardest problems gave greatest improvements. pruning technique
based parameter domains often gave speedups order magnitude
dicult problems, default ucpop search strategy improved
strategy. Lisp code techniques test problems provided on-line
appendices.

1. Introduction

concerned improving performance \well-founded" domain-independent planners { planners permit proofs soundness, completeness, desirable
theoretical properties. state-of-the-art example planner ucpop (Barrett
et al., 1994; Penberthy & Weld, 1992), whose intellectual ancestry includes strips (Fikes &
Nilsson, 1971), tweak (Chapman, 1987), snlp (McAllester & Rosenblitt, 1991).
planners unfortunately perform well present, comparison practically
oriented planners sipe (Wilkins, 1988), prs (Georgeff & Lansky, 1987), O-Plan
(Currie & Tate, 1991).
However, appear ample opportunities bringing well-founded planners
closer practicality. following, begin suggesting improvements
search control planning, based carefully formulated strategies selecting partial
plans refinement, choosing open conditions selected partial plan. plan c 1996 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiGerevini & Schubert
selection strategy uses S+OC { number steps plan plus number open
conditions still established { heuristic measure ucpop's A* search
plan space. (Addition attenuated term ecting number threats \unsafe
conditions" UC, 0.1UC, sometimes advantageous.)1 aw-selection strategy,
term ZLIFO, prefers \zero commitment" plan refinements others, otherwise
uses LIFO (stack) discipline. Zero commitment refinements logically necessary ones:
either eliminate plan altogether contains irremediable aw, add
unique step unique causal link (from initial state) establish open condition
cannot established way. strategy closely related ones proposed
Peot & Smith (1993) Joslin & Pollack (1994) generally appears perform better
either.
describe two classes techniques Section 2 below, Section 3
report experimental results based slightly modified versions ucpop.2
dicult problems taken available ucpop test suite elsewhere, obtain
improvements factors ranging 5 1000, hardest problems
giving greatest improvements.
turn proposal using computed operator parameter domains
planning. particular, Section 4 motivate describe method precomputing parameter domains based propagating sets constants forward initial
conditions.3 process iterative, algorithm runs within time bound
polynomial size problem specification. provide details algorithm,
along theorems correctness tractability, Sections 4.2{4.3 Online
Appendix 1.
Section 5 show use parameter domain information ucpop-style planner. planning, parameter domains used prune operator instances whose
parameter domains inconsistent binding constraints, eliminate spurious
threats cannot, fact, realized without violating domain constraints. illustrate
effectiveness technique examples drawn ucpop test suite well
trains transportation planning world developed Rochester (Allen & Schubert,
1991; Allen et al., 1995). tests, apply parameter domain information
context default ucpop search strategy. demonstrate significant gains
problems, particularly challenging ones (e.g., speedups order
magnitude several problems strips world, 900-fold speedup
trains problem).
another set tests trains world, use improved search strategies
baseline, i.e., ask whether additional speedups obtainable use parameter
1. search strategy described \A* IDA*" search (Penberthy & Weld, 1992); code
ucpop 2.0 described generally best-first, since arbitrary ranking functions, necessarily
corresponding A* heuristics, may plugged in. choices S+OC S+OC+UC
plan-ranking heuristic (as discussed Section 2.2), natural view strategy A* strategy.
2. techniques describe applicable planners, focus ucpop
well-known Lisp code readily available. system obtained via anonymous ftp
cs.washington.edu.
3. hope notion parameter domain, set admissible bindings (constants), cause
confusion notion planning domain, specified set operators, along constraints
admissible initial conditions goal conditions.

96

fiAccelerating Partial-Order Planners
domains, obtainable S+OC ZLIFO search strategies. experimental results show speedups factor 10 use parameter
domains, top obtained improved search strategies (the combined speedup
2000).
evidence effectiveness using parameter domains combination
search strategy dependent peculiarity latter, include
results ucpop's default strategy, Joslin Pollack's \least cost aw repair" (LCFR)
strategy (Joslin & Pollack, 1994) Peot Smith's \least commitment" (LC) open
condition selection strategy (Peot & Smith, 1993) Section 5.
Section 6, state conclusions, comment related work mention
possible extensions techniques.

2. Plan Selection Goal Selection

basing discussion experiments ucpop, algorithm exemplifying
state art well-founded partial-order planning. Thus begin sketch
algorithm, referring reader (Barrett et al., 1994; Penberthy & Weld, 1992) details.
next two subsections motivate describe improved plan-selection
goal-selection strategies.

2.1 UCPOP

ucpop uses strips-like operators, positive negative preconditions positive

negative effects. initial state consists positive predications constant arguments
(if any), ground predications false default. Unlike strips, ucpop
allows conditional effects, expressed 2-part when-clauses specifying (possibly complex)
extra condition needed effect (possibly complex) effect itself. instance,
action PUTON(?x ?y ?z) (\put ?x ?y ?z") might conditional effects stating
?y table, clear end action, z
table, clear end action. \U" ucpop indicates
universally quantified conditions effects permitted well. instance,
permissible precondition PICKUP(?x) action says ?y, (not
(on ?y ?x)) holds. Universal statements handled explicit substitution domain
constants need concern us point.
essence, ucpop explores space partially specified plans, paired
agenda goals still satisfied threats still averted. initial plan contains
dummy *start* action whose effects given initial conditions, dummy
*end* action whose preconditions given goals. Thus goals uniformly viewed
action preconditions, uniformly achieved effects actions, including
*start* action.
plans consist collection steps (i.e., actions obtained instantiating available operators), along set causal links, set binding constraints,
set ordering constraints. open goal (precondition) selected
agenda, established (if possible) either adding step effect unifies
goal, using existing step effect unifies goal. (In
latter case, must consistent current ordering constraints place existing
97

fiGerevini & Schubert
step goal, i.e., step whose preconditions generated goal.)
new existing step used establish goal way, several side effects:
causal link (S ; Q; ) added, indicates step \producing"
goal condition Q indicates step \consuming" Q. causal link serves
protect intended effect added (or reused) step interference
steps.
Binding constraints added, corresponding unifier action effect
question goal (precondition) achieves.
ordering constraint added, placing step question step whose
precondition achieves.
action question new, preconditions added agenda new
goals (except EQ/NEQ conditions integrated binding constraints { see
below).
New threats (unsafe conditions) determined. new step causal link,
steps threaten causal link effects unifiable condition
protected causal link (and effects occur temporally causal
link); effects new step may similarly threaten causal links.
either case, new threats placed agenda. useful distinguish definite
threats potential threats: former unification
confirmed threat involved new binding variables.
Binding constraints assert identity (EQ) nonidentity (NEQ) two variables variable
constant. EQ-constraints arise unifying open goals action effects, NEQconstraints arise (i) NEQ-preconditions newly instantiated actions, (ii) matching
negative goals containing variables initial state, (iii) averting threats
\separation", i.e., forcing non-equality two variables variable constant
unified threat detection. NEQ-constraints may disjunctive, handled simply
generating separate plans disjunct.
overall control loop ucpop consists selecting plan current list
plans (initially single plan based *start* *end*), selecting goal threat
agenda, replacing plan corresponding refined plans. agenda item
goal, refined plans corresponding ways establishing goal using
new existing step. agenda item definite threat causal link (S ; Q; ),
three refined plans. Two constrain threatening step
step (demotion) step (promotion), thus averting threat.
third possibility arises effect threatening (S ; Q; ) conditional effect
threatening action. conditional threat averted creating goal denying
precondition needed conditional effect.
ucpop \delay separation" switch, *d-sep*, turned on,
definite threats dealt with. Note potential threats may become definite result
added binding constraints. (They may \expire" result added binding
ordering constraints, i.e., threatening effect may longer unify threatened
condition may forced occur threatened causal link. Expired
p

c

p

c

p

p

c

p

98

c

c

fiAccelerating Partial-Order Planners
threats removed agenda selected.) *d-sep* off, potential threats
well definite ones averted, separation additional method
besides three methods above.
Inconsistencies binding constraints ordering constraints detected
first occur (as result adding new constraint) corresponding plans eliminated. Planning fails plans remain. success condition creation plan
consistent binding ordering constraints empty agenda.
allowance conditional effects universal conditions effects causes
minor perturbations operation ucpop. instance, conditional effects lead
multiple matches operators given goal, match generating different
preconditions. (Of course, multiple matches even without conditional effects,
predicates occur effects.)
key issues us right strategic ones: plans selected
current set plans (discussed Section 2.2), goals selected given plan
(discussed Section 2.3).

2.2 Trouble Counting Unsafe Conditions

choice next plan refine ucpop system based A* best-first
search. Recall A* uses heuristic estimate f (p) overall solution cost consisting
part g (p) = cost current partial solution (plan) p part h(p) = estimate
additional cost best complete solution extends p. current context
helpful think f (p) measure plan complexity, i.e., \good" plans simple
(low-complexity) plans.
two points reader reminded. First, order A*
guarantee discovery optimal plan (i.e., \admissibility" condition), h(p)
overestimate remaining solution cost (Nilsson, 1980). Second, aim
necessarily find optimal solution find satisfactory solution quickly, f (p)
augmented include term estimates remaining cost finding solution.
One common way use term proportional h(p) well, i.e.,
emphasize h-component f relative g -component. reasonable
extent plans nearly complete (indicated low h-value) likely
take least effort complete. Thus prefer pursue plan p0 seems closer
complete plan p completion, even though overall complexity
estimate p0 may greater p (Nilsson, 1980) (pages 87{88). Alternatively,
could add heuristic estimate remaining cost finding solution f (p)
less independent estimate h(p).
considerations mind, evaluate advisability including
various terms ucpop's function guiding A* search, namely
S, OC, CL, UC,
number steps partial plan, OC number open conditions
(unsatisfied goals preconditions), CL number causal links, UC
number unsafe conditions (the number pairs steps causal links step
99

fiGerevini & Schubert
threatens causal link). default combination used ucpop S+OC+UC.4
becomes S+OC+UC+F special open conditions called \facts" present.
conditions state-dependent (e.g., numerical relation (add-one ?x ?y),
geometrical one (loc-in-room ?x ?y ?room)) established Lisp functions
(Barrett et al., 1994). Since test problems involved facts, discuss
F term except say followed ucpop default strategy including
term relevant (see TileWorld problems Section 3.2 remarks
Section 5.2 connection parameter-domain experiments).
2.2.1 S: number steps currently plan

naturally viewed comprising g (p), plan complexity far. Intuitively,
plan complex extent contains many steps. domains might
want make distinctions among costs different kinds steps, simple step count
seems reasonable generic complexity measure.
2.2.2 OC: number open conditions

viewed playing role h(p), since remaining open condition must
established step. catch may possible use existing steps
plan (including *start*, i.e., initial conditions) establish remaining open conditions.
Thus OC overestimate number steps still added, forfeiting admissibility.
Despite criticism, several considerations favor retention OC term. First,
better estimator residual plan complexity seems hard come by. Perhaps one could
modify OC discounting open conditions matched existing actions,
presumes open conditions actually achieved action re-use,
improbable remaining threats, remaining goals requiring new steps.5 Second,
possibility OC overestimate residual plan complexity rarely actualized, since typically steps still need added achieve goals,
steps typically introduce open conditions requiring new steps. Finally, extent OC times overestimate residual plan complexity,
viewed emphasizing h(p) term f (p), thus promoting faster problem-solving
explained above.
2.2.3 CL: number causal links

One might motivate inclusion term arguing numerous causal links
indicative complex plan. such, CL appears alternative step-counting.
4. way \recommended" strategy. ucpop implementation makes available various
options controlling search, used discretion experimenters. present work
prompted incorporation particular strategies option ucpop 4.0.
5. Note threats remaining goals impose constraints may consistent seemingly
possible instances action re-use. clear enough threats, often imply temporal ordering
constraints inconsistent re-use action. fairly clear remaining goals. instance,
Towers Hanoi small disk D1 initially medium disk D2, turn big disk
D3, D3 peg P1. goal move tower third peg P3, seems ucpop initially
(on D1 D2) (on D2 D3) could achieved \re-use" *start*. However, third goal (on
D3 P3) implies various actions must added plan inconsistent two
seemingly possible instances action re-use.

100

fiAccelerating Partial-Order Planners
However, note CL general larger S, since every step plan establishes
least one open condition thus introduces least one causal link. larger CL
relative S, subgoals achieved action re-use. Hence, use CL instead
(or addition to) g (p) term, would effect saying achieving multiple
subgoals single step undesirable; would tend search ways achieving
multiple goals multiple steps, even achieved single step.
clearly good idea, justifies exclusion CL f (p).
2.2.4 UC: number unsafe conditions

note first clearly g -measure. number threats
tend increase establish subgoals without curtailing threats, threats
elements plan constructed contribute
complexity. fact, plan done threats gone.
UC viewed h-measure? One argument sorts armative
following. partial plans expandable complete plans, high value
UC makes likely partial plan contains irresolvable con icts. regard
impossible plans infinite cost, inclusion term increasing UC part
h-measure reasonable. carries serious risk, though, since case
partial plan consistent completion (despite high UC-count), inclusion
term greatly overestimate residual plan complexity.
Another possible armative argument conditional threats sometimes resolved
\confrontation", introduces new goal denying condition required threatening conditional effect. new goal may turn require new steps achievement,
adding plan complexity. However, link complexity tenuous. first
place, many ucpop test domains involve conditional effects, threat removal
promotion, demotion separation adds steps. Even conditional effects
present, many unconditional well conditional threats averted methods.
Furthermore, UC could swamp terms since threats may appear expire
groups size O(n), n number steps plan. instance, consider
partial plan involves moves robot R locations L1, ..., Ln,
n causal links labeled (at R L1), ..., (at R Ln). new move location L
added, initially indefinite point departure ?x, produces effects (at
R L) (not (at R ?x)). latter threaten n causal links,
least new move first temporally unordered relative n existing moves.
new action subsequently happens demoted precede first move (or
promoted follow last), ?x becomes bound constant distinct
L1, ..., Ln, n threats expire. Keeping mind different steps plan may
similar effects, see half steps could threaten causal links
others. case could O(n2 ) unsafe conditions, destined expire result
O(n) promotions/demotions. fact even single new binding constraint may cause
O(n2 ) threats expire. instance, n=2 effects (not (P ?x)) threatening
n=2 causal links labeled (P ?y), binding constraint (NEQ ?x ?y) added, n2 =4
threats expire. Recall expired threats selected agenda ucpop,
recognized discarded without action.
101

fiGerevini & Schubert
conclusion would mistake include UC full general h-measure,
though increasing function UC remains small enough mask OC may
worth including h.
Finally, UC regarded measure remaining cost finding solution?
Here, similar arguments apply. armative side, argue
high value UC indicates may facing combinatorially explosive, timeconsuming search set promotions demotions produce con ict-free step
ordering. words, high value UC may indicate high residual problem-solving
cost. (And end search, may still lack solution, viable step
ordering exists.) hand, already noted unsafe conditions include
many possible con icts may expire result subsequent partial ordering choices
variable binding choices specifically aimed removing con icts. counting
unsafe conditions arbitrarily overestimate number genuine refinement steps,
hence problem-solving effort, still needed complete plan.
UC scarcely trustworthy measure residual planning cost
measure residual plan cost.
Thus conclude promising general heuristic measure plan selection
S+OC, possibly augmented attenuated form UC term dominate
S+OC component. (For instance, one might add small fraction term,
UC/10, subtly { avoid swamping quadratic component { term proportional
UC 5.)
:

2.3 Goal Selection Strategy

important opportunity improving planning performance independently domain
lies identifying forced refinements, i.e., refinements made deterministically.
Specifically, considering possible refinements given partial plan, makes sense
give top priority open conditions cannot achieved; preferring open
conditions achieved one way { either addition action
yet plan, unique match initial conditions.
argument giving top priority unachievable goals plan containing
goals eliminated once. Thus prevent allocation effort refinement
doomed plans, generation refinement doomed successor plans.
argument preferring open conditions achieved one way
equally apparent. Since every open condition must eventually established
action, follows action unique, must part every possible completion
partial plan consideration. So, adding action \zero-commitment"
refinement, involving choices guesswork. time, adding refinement
general narrows search space adding binding constraints, ordering constraints
threats, constrain existing steps subsequently added steps. unique
refinements narrowing-down monotonic, never needing revocation. example,
suppose refinement happens add constraints eliminate certain action instance
possible way achieving certain open condition C . refinement unique,
assured completion plan contains way establishing C .
unique, assurance, since alternative refinement may
102

fiAccelerating Partial-Order Planners
compatible use achieve C . short, zero-commitment strategy cuts
search space without loss access viable solutions.
Peot Smith (1993) studied strategy preferring forced threats unforced
threats, used \least commitment" (LC) strategy handling open conditions.
Least commitment always selects open condition generates fewest refined
plans. Thus entails priorities unachievable uniquely achievable goals
(while entailing certain prioritization nonuniquely achievable goals). Joslin
Pollack (1994) studied uniform application strategy threats open
conditions ucpop, terming strategy \least cost aw repair" (LCFR). Combining
ucpop's default plan selection strategy, obtained significant search reductions
(though less significant running time reductions, mainly implementation reasons,
intrinsic overhead computing \repair costs") majority
problems ucpop test suite.
Joslin & Pollack (1994) subsequently Srinivasan & Howe (1995) proposed
variants LCFR designed reduce overhead incurred LCFR aw selection.
strategies employ various assumptions aw repair costs, allowing
arduous forms cost estimation (requiring look-ahead generation plans) confined
subset aws plan, rest approximation used
significantly increase overhead. teams obtained quite significant reductions
overhead costs many cases, e.g., factors ranging 3 20
dicult problems. However, overall performance sometimes adversely affected.
Joslin Pollack found variant (QLCFR) solved fewer problems LCFR,
increase number plans generated cases. Srinivasan &
Howe's four strategies slightly better LCFR 10 problem domains
significantly worse others. terms plans examined search, best
overall strategy, uses similar action instances similar aws, slightly better
4 domains, slightly worse 4, significantly worse 2 (and cases
number plans examined factor 20 default ucpop).
unmodified form ucpop, goals selected agenda according
LIFO (last-in first-out, i.e., stack) discipline. Based experience search processes
AI general, strategy much recommend it, simple default.
first place, overhead cost low compared strategies use heuristic evaluation
lookahead prioritize goals. well, tend maintain focus achievement
particular higher-level goal regression { much Prolog goal chaining { rather
attempting achieve multiple goals breadth-first fashion.
Maintaining focus single goal advantageous least
goals achieved independent. instance, suppose two goals G1 G2
achieved various ways, choosing particular method achieving G1
rule methods achieving G2. maintain focus G1
solved, attempting G2, total cost solving goals sum
costs solving individually. switch back forth, solutions
goals involve searches encounter many dead ends, combined cost
much larger. tend search unsolvable subtree G1 search
tree repeatedly, combination various alternatives G2 search tree (and vice
versa). argument still validity even G1 G2 entirely
103

fiGerevini & Schubert
independent; i.e., long G1 gives rise subproblems tend fail
way regardless choices made attempt solve G2 (or vice versa), shifting
attention G1 G2 tend generate set partial plans unnecessarily
\cross-multiplies" alternatives.
therefore chosen stay ucpop's LIFO strategy whenever
zero commitment choices. led substantial improvements LCFR
experiments.
Thus strategy, term ZLIFO (\zero-commitment last-in first-out"), chooses
next aw according following preferences:
1. definite threat (*d-sep* turned on), using LIFO pick among these;
2. open condition cannot established way;
3. open condition resolved one way, preferring open conditions
established introducing new action established
using *start*;6
4. open condition, using LIFO pick among these.
Hence overhead incurred ZLIFO aw selection limited open conditions, lower overhead incurred LCFR. Furthermore,
significantly lower practice overhead incurred LC, testing
whether OC zero-commitment choice (i.e., whether established
one way) less expensive computing total number ways achieve it.
Online Appendix 1 give pseudocode ZLIFO selection open
condition (preferences 2{4). recently implementation packaged
ucpop 4.0, new version ucpop available anonymous ftp cs.washington.edu.

3. Experiments Using UCPOP

order test ideas modified version 2.0 ucpop (Barrett et al., 1994), replacing default plan-selection strategy (S+OC+UC) goal-selection strategy (LIFO)
incorporate strategies discussed previous sections.
tested modified planner several problems ucpop suite, emphasizing
proved challenging previous strategies, artificial problems
due Kambhampati et al. (1995), trains transportation domain developed
Rochester (Allen & Schubert, 1991; Allen et al., 1995), Joslin & Pollack's TileWorld
domain (Joslin & Pollack, 1994). brie describe test problems platforms
parameter settings used, present experimental results improved
search strategies.
6. 2. 3. zero-commitment choices. experiments, described next section,
sub-preference 3. gave improvements context Russell's tire changing domain (in particular
Fix3), without significant deterioration performance domains.

104

fiAccelerating Partial-Order Planners

3.1 Test Problems Experimental Settings

ucpop problems include Towers Hanoi (T H), Fixa, Fix3, Fixit, Tower-Invert4,
Test-Ferry, Sussman-Anomaly. case H, added 3-operator version
ucpop single-operator version, since H particularly hard problem ucpop
diculty long known sensitive formalization (e.g., (Green,
1969)). Fixa problem Dan Weld's \fridge domain", compressor
fridge exchanged, requiring unscrewing several screws, stopping fridge,
removing backplane, making exchange. Fix3 Stuart Russell's \ tire
domain", new wheel mounted lowered ground (the old wheel
jacked already nuts loosened); requires unscrewing nuts holding
old wheel, removing wheel, putting new wheel, screwing nuts, jacking
hub, tightening nuts. Fixit complicated, wheel yet
jacked initially nuts yet loosened, spare tire needs ated,
jack, wrench pump need taken trunk stowed
end. Tower-Invert4 problem blocks world, requiring topmost block stack
four blocks made bottom-most. Test-Ferry simple problem requiring two cars
moved B using one-car ferry, boarding, sailing, unboarding
car.
artificial problems correspond two parameter settings ART-# -# , one
two artificial domains served testbed Kambhampati et al.'s extensive
study behavior various planning strategies function problem parameters
(Kambhampati et al., 1995). ART-# -# provides two layers 10 operators each,
layer 1 achieve preconditions layer 2, operator
layer 2 achieves one 10 goals. However, operators layer establish
clobber preconditions neighbors, force operators used
certain order.
version trains domain encoded involves four cities (Avon, Bath,
Corning, Dansville) connected four tracks diamond pattern, fifth city (Elmira)
connected Corning fifth track. available resources, located various
cities, consist banana warehouse, orange warehouse, orange juice factory, three
train engines (not coupled cars), 4 boxcars (suitable transporting oranges
bananas), tanker car (suitable transporting orange juice). Goals typically
deliver oranges, bananas, orange juice city, requiring engine-car coupling, car
loading unloading, engine driving, possibly OJ-manufacture.
TileWorld domain consists grid holes tiles scattered. given
tile may may fit particular hole. goals fill one holes
using three possible actions: picking tile, going x-y location grid,
dropping tile hole. agent carry four tiles time.
Formalizations domains terms ucpop's language provided Online
Appendix 2. experiments problems except Fixit, trains problems
TileWorld problems conducted sun 10 using Lucid Common Lisp 4.0.0,
rest (Tables X{XI next subsection) conducted sun 20 using Allegro
Common Lisp 4.2. Judging repeated experiments, think
est

est

clob

105

clob

fiGerevini & Schubert

Goal-selection Plan-selection CPU sec
LIFO
LIFO
ZLIFO
ZLIFO

S+OC+UC
S+OC
S+OC+UC
S+OC

204.51
0.97
6.90
0.54

Plans

160,911/107,649
751/511
1816/1291
253/184

Table I: Performance plan/goal selection strategies T-of-H1
differences platforms significantly impact performance improvements.7 Among
search control functions provided ucpop, used default bestf-search
problem solvable within search limit 40,000 plans generated, used
function id-bf-search (an implementation linear-space best-first search algorithm
given Korf, 1992), limit exceeded.8 experiments delayseparation switch, *d-sep*, on, except using LCFR strategy.

3.2 Experimental Results ZLIFO S+OC

Tables I{XI show CPU time (seconds) number plans created/explored
ucpop twelve problems domains described above: Towers Hanoi three
disks either one operator (T-of-H1) three operators (T-of-H3), fridge domain
(Fixa), tire changing domain (Fix3 Fixit), blocks world (Tower-Invert4
Sussman-anomaly), ferry domain (Test-Ferry), artificial domain ART-# -#
(specifically, ART-3-6 ART-6-3), trains domain (Trains1, Trains2 Trains3)
TileWorld domain (tw-1, ..., tw-6). number plans created/explored
CPU time important performance measures. number plans, indicates
search space size, stable measure sense depends search
algorithm, implementation.9 time still interest since improvement
search may purchased price time-consuming evaluation
alternatives. turns pay price overhead substitute
strategies defaults (factors ranging 1.2 1.9, rarely higher, per plan
created). may due slightly greater inherent complexity ZLIFO versus LIFO,
think differences could reduced substituting modified data structures
ucpop { committed altering these.
Tables II show H plan selection strategy S+OC gives dramatic
improvements default S+OC+UC strategy. (In tests default LIFO goal
selection strategy used.) fact, ucpop solved T-of-H1 0.97 seconds using S+OC
versus 204.5 seconds using S+OC+UC. T-of-H3 proved harder solve T-of-H1, reest

clob

7. differences result available different times locales course
nearly two years experimentation.
8. choice motivated observation problem relatively easy solve
bestf-search appears ecient id-bf-search, hard problems
inecient considerable amount space used run time CPU time spent
garbage collection, cases made Lisp crash, reporting internal error.
9. worth noting number plans created implicitly takes account plan size, since
addition step plan counted creation new plan ucpop.

106

fiAccelerating Partial-Order Planners

Goal-selection Plan-selection CPU sec Plans
LIFO
S+OC+UC
> 600 > 500,000
LIFO
ZLIFO
ZLIFO

S+OC
S+OC+UC
S+OC

8.54

> 600
1.24

5506/3415
> 500,000
641/420

Table II: Performance plan/goal selection strategies T-of-H3

Goal-selection Plan-selection CPU sec
LIFO
LIFO
ZLIFO
ZLIFO

S+OC+UC
S+OC
S+OC+UC
S+OC

2.45
2.48
0.33
0.33

Plans

2131/1903
2131/1903
96/74
96/74

Table III: Performance plan/goal selection strategies Fixa
quiring 8.5 seconds using S+OC unknown time excess 600 CPU seconds using
S+OC+UC.
ZLIFO goal-selection strategy significantly accelerate planning compared
simple LIFO strategy. particular, ZLIFO combined S+OC planselection strategy solving H, reduced number plans generated
factor 3 T-of-H1 factor 8 T-of-H3. overall performance improvement
T-of-H1 thus factor 636 terms plans created factor 379 terms
CPU time (from 204.5 0.54 seconds).
Tables III{VIII provide data problems easier H, still challenging ucpop operating default strategy, namely Fixa (Table III), Fix3 (Table IV),
Tower-Invert4 (Table V), Test-Ferry (Table VI) artificial domain ART-# -#
# = 3 # = 6 (Table VII) # = 6 # = 3 (Table VII).
results show combination S+OC ZLIFO substantially improves
performance ucpop comparison performance using S+OC+UC LIFO.
number plans generated dropped factor 22 Fixa, factor 5.9
est

est

clob

est

Goal-selection Plan-selection CPU sec
LIFO
LIFO
ZLIFO
ZLIFO

S+OC+UC
S+OC
S+OC+UC
S+OC

6.50
0.43
1.12
1.53

clob

Plans

3396/2071
351/215
357/221
574/373

Table IV: Performance plan/goal selection strategies Fix3

107

clob

fiGerevini & Schubert

Goal-selection Plan-selection CPU sec Plans
LIFO
LIFO
ZLIFO
ZLIFO

S+OC+UC
S+OC
S+OC+UC
S+OC

1.35
0.19
2.81
0.36

808/540
148/105
571/378
142/96

Table V: Performance plan/goal selection strategies Tower-Invert4

Goal-selection Plan-selection CPU sec Plans
LIFO
LIFO
ZLIFO
ZLIFO

S+OC+UC
S+OC
S+OC+UC
S+OC

0.63
0.32
0.24
0.22

718/457
441/301
136/91
140/93

Table VI: Performance plan/goal selection strategies Test-Ferry

Goal-selection Plan-selection CPU sec
LIFO
LIFO
ZLIFO
ZLIFO

S+OC+UC
S+OC
S+OC+UC
S+OC

.67
1.36
0.16
0.18

Plans

568/392
1299/840
72/49
79/54

Table VII: Performance plan/goal selection strategies ART-# -#
# = 6 (averaged 100 problems)
est

clob

# = 3
est

clob

Goal-selection Plan-selection CPU sec
LIFO
LIFO
ZLIFO
ZLIFO

S+OC+UC
S+OC
S+OC+UC
S+OC

1.32
2.08
0.14
0.14

Plans

985/653
1743/1043
57/37
57/37

Table VIII: Performance plan/goal selection strategies ART-# -#
# = 3 (averaged 100 problems)
est

clob

# = 6

clob

Goal-selection Plan-selection CPU sec Plans
LIFO
LIFO
ZLIFO
ZLIFO

S+OC+UC
S+OC
S+OC+UC
S+OC

0.06
0.04
0.12
0.07

44/26
36/21
67/43
41/25

Table IX: Performance plan/goal selection strategies Sussman-anomaly
108

est

fiAccelerating Partial-Order Planners

1000

Fixit
Trains1
2

T-of-H1 2

Performance
Improvement

2

100

2
ART-6-3 2 Fixa
2 Search space reduction
ART-3-6 222
2 Fix3
Speedup
Tower-invert4
Test-ferry
Sussman-anomaly
2
1e+07
100
1000
10000 100000 1e+06
Problem size

10
1
10

Figure 1: Performance improvement due ZLIFO S+OC, relative number
plans generated LIFO S+OC+UC (log-log scale). improvements
problems ucpop unable solve even high search limit
(Trains2, Trains3, T-of-H3) included.
Fix3, factor 5.7 Tower-Invert4, factor 5.1 Test-Ferry, factor 7
ART-3-6, factor 17 ART-6-3.
Concerning ART-# -# , note performance obtained unenhanced
ucpop (568 plans generated ART-3-6 985 ART-6-3) much
(just marginally better than) reported Kambhampati et al. (1995) best planners
considered (700 { 1500 plans generated ART-3-6, 1000-2000 ART-6-3).
expected, since ucpop generalization earlier partial-order planners.
Relative standard ucpop predecessors, \accelerated" planner thus order
magnitude faster. Interestingly, entire improvement ascribed ZLIFO
(rather S+OC plan selection, actually little worse S+OC+UC).
probably due unusual arrangement operators ART-# -# \clobbering chain" (A , 1 clobbers , ,1 1 's preconditions, ..., A1 1 clobbers A0 1's preconditions;
similarly 2 ), makes immediate attention new unsafe conditions unusually
good strategy.
experimenting various combinatorially trivial problems unmodified ucpop
handles ease, found S+OC ZLIFO strategy neither beneficial
harmful general; may slight improvement slight degradation performance. Results Sussman anomaly Table IX provide illustrative example.
summarize results Tables I{X Figure 1, showing performance improvements obtained combined ZLIFO goal selection strategy S+OC plan selection
est

clob

est

n

;

n

;

;

i;

109

clob
;

fiGerevini & Schubert

ZLIFO &
S+OC
LC &
S+OC
LCFR &
S+OC
LIFO &
S+OC+UC

Trains1

Trains2

Trains3

Fixit

Plans
4097/2019
17,482/10,907 31,957/19,282
5885/3685
Time
13.7
80.6
189.8
32.5
Plans
438/242
34,805/24,000 253,861/168,852
71,154/46,791
Time
2.6
368.9
1879.9
547.8
Plans
1093/597
>1,000,000
>1,000,000
190,095/117,914
Time
10.65
>10,905
>9918
4412.36
Plans 1,071,479/432,881 > 10,000,000
> 1,000,000 8,090,014/4,436,204
Time
3050.15
> 37,879
> 2539
27,584.9

Table X: Performance plan selection strategy S+OC combination goal
selection strategies ZLIFO, LCFR LC solving problems
hard default strategies ucpop (S+OC+UC/LIFO). (The CPU seconds
include Lisp garbage collection. number plans generated LCFR
include created order estimate repair cost aws.)

Problem
ZLIFO*
LCFR
name CPU time Plans CPU time Plans
tw-1
tw-2
tw-3
tw-4
tw-5
tw-6

0.09
0.61
2.55
7.80
19.41
42.57

26/15
72/39
138/71
224/111
330/159
456/215

0.10
0.66
3.17
10.97
30.17
71.10

26/15
72/39
139/72
227/114
336/165
466/225

Table XI: Performance UCPOP TileWorld domain using ZLIFO* LCFR
goal selection, S+OC+F+0.1UC plan selection
strategy function problem diculty (as indicated number plans generated
default LIFO plus S+OC+UC strategy). trend toward greater speedups
complex problems (though somewhat dependent problem type) quite apparent
log-log plot.
direct comparison Joslin Pollack's LCFR strategy Peot Smith's
LC strategy, implemented strategies applied several problems.
well (sometimes better ZLIFO) problems lower end diculty
spectrum, poorly harder problems. (For problems ran, LC
*d-sep* switch performed better LCFR terms plans explored CPU
time required.) T-of-H1 LCFR combination default S+OC+UC plan
selection strategy, S+OC plan strategy find solution within search
limit 200,000 plans generated (cf. 253 ZLIFO S+OC, 751 ZLIFO
S+OC+UC), requiring unknown CPU time excess 4254 seconds S+OC+UC,
110

fiAccelerating Partial-Order Planners
excess 4834 seconds S+OC (cf. 0.54 seconds ZLIFO S+OC).10
LC performed much better LCFR still considerably worse ZLIFO, solving
T-of-H1 generating/exploring 8313/6874 plans S+OC 8699/6441 plans
S+OC+UC, requiring 44.4 CPU secs. 48.95 CPU secs. respectively. T-ofH3, LC found solution generating/exploring 21,429/15,199 plans S+OC+UC
17,539/14,419 plans S+OC, requiring 145.18 CPU secs. 77.84 CPU secs.
respectively.
Table X shows results plan strategy S+OC, goal strategies ZLIFO,
LCFR LC, applied three problems (Trains1, Trains2 Fixit). shown data
table hard default strategies ucpop (LIFO & S+OC+UC),
become relatively easy S+OC used combination either ZLIFO, LCFR
LC. LCFR LC slightly better ZLIFO Trains1 (the easiest
problems), performed quite poorly Fixit, Trains2 Trains3 (the hardest
problems) compared ZLIFO.
Joslin Pollack (1994) tested LCFR strategy six problems TileWorld
(tw-1, ..., tw-6), five hard default ucpop, easy ucpop using
LCFR.11 tested ZLIFO strategy TileWorld using six problems.
ZLIFO well tw-1{4, tw-5 tw-6 performance dropped well
LCFR. raised question whether particular problems crucial
minimize \repair cost" aw selection uniformly, rather certain special cases
(ZLIFO minimize repair cost threat aw list, least one zerocommitment open condition present). However, experiments aimed answering
question suggested poor choices made ZLIFO TileWorld problems
due selection \high cost" \low cost" aws. Instead two factors appear
crucial improving ZLIFO: (a) emphasizing zero-commitment open conditions giving
higher priority threats; (b) zero-commitment open conditions,
resolving threats soon enter agenda. (We realized relevance (b)
observing performance modified versions LCFR, *d-sep* switch
implicitly forced on, dramatically degraded tw-6 slightly different formulation
TileWorld.)
extended ZLIFO strategy include (a) (b), brie tested
resulting variant ZLIFO (ZLIFO*). Table XI shows results ZLIFO* together
plan selection strategy S+OC+0.1UC+F, discussed Section 2.3 included
attenuated form UC term (UC/10), F term equal number facts
since TileWorld uses facts track number tiles carried agent.12 ZLIFO*
10. *d-sep* turned off, implicit setting LCFR (Joslin, 1995). experiments
tested variant LCFR, switch forced on. resulting goal strategy
combination plan strategy S+OC performed significantly better T-of-H1, solving problem
generating/exploring 7423/6065 plans, using 110.45 CPU seconds. Note comparison
implementation LCFR Joslin & Pollack's implementation used experiments discussed
(Joslin & Pollack, 1994) showed implementation considerably faster (Joslin, 1995).
11. experiments tw-2, easiest among tw-2{6, solved ucpop even allowed run
eight hours. hand, ucpop using LCFR solves tw-6, hardest problem, without
ever reaching dead-end node search tree.
12. ZLIFO* experiments refined plans generated resolving threat added aw list
following order: first plan generated promotion, plan generated demotion,
finally plan generated confrontation separation.

111

fiGerevini & Schubert
performed eciently six TileWorld problems, fact little better LCFR.
Note problems ZLIFO* ecient LCFR terms CPU time,
even though number plans generated/explored two strategies approximately
same. overhead selecting next aw handled higher
LCFR ZLIFO* (and ZLIFO). fact, LCFR needs compute \repair
cost" aw (including threats) current plan, ZLIFO* (ZLIFO) needs
check presence zero-commitment open conditions, without processing threats.
Additional experiments indicated average performance ZLIFO* comparable
ZLIFO problems used experiments, terms
plans created/explored. However, CPU time tends increase since overhead
computing goal selection function higher ZLIFO* ZLIFO,
extra agenda-management costs. overhead, regard ZLIFO*
generally preferable ZLIFO. However, TileWorld experiments underscored us
worlds refinements ZLIFO advantageous.
Finally, another possible variant ZLIFO, suggested us David Smith,
based following preferences next aw handled: (i) threat cannot
resolved; (ii) open condition cannot established; (iii) threat
one possible resolution; (iv) open condition established one way; (v)
threats; (vi) open conditions (using LIFO pick among these). observe
strategy could give savings terms plans created/explored,
imposes additional overhead respect ZLIFO ZLIFO* could
degrade performance terms CPU time.

4. Precomputing Parameter Domains

Even speedups obtained improved search, ucpop-like algorithm remains
severely limited complexity problems solve. believe significant
progress requires fuller use global properties search space, determined
structure operators, initial conditions, goals. One way would
in-depth analysis alternatives search, lead high
overhead costs. Another precompute constraints search space, use
planning prune search. parameter domain method motivate
describe latter type.

4.1 Parameter Domains Help?

previous experimentation ucpop strategies, found ucpop goal regression often hypothesized steps doomed abandoned eventually,
stipulated impossible parameter bindings. clear example occurred Molgen
domain, encoded ucpop test suite. goal \Rat-insulin" test problem
(and (bacterium ?b) (molecule ?m)
(contains IG ?m) (contains ?m ?b) (pure ?b))

,

?b ?m existentially quantified variables. means wish
create purified bacterial culture ?b, ?b contains molecule ?m (necessarily
112

fiAccelerating Partial-Order Planners
exosome, turns out), molecule turn contains insulin gene, IG.
using abbreviations IG, EE, JE, L insulin-gene, e-coli-exosome, junk-exosome,
linker; E, J, A1 e-coli, junk, antibiotic-1. Roughly speaking, solution
involves processing initially given mRNA form insulin gene produce
form insulin DNA spliced e-coli-exosome, using ligate operator.
turn, exosome inserted e-coli bacterium using transform operator,
bacterial culture purified using screen operator, antibiotic-1. (The junk
bacterium exosome merely serve complicate task { nearly, quite,
substitutable e-coli bacterium exosome; junk exosome, unlike e-coli-exosome,
resistant antibiotic-1, violating precondition screen.)
Now, initial regression goals (bacterium ?b) (molecule ?m)
established *start* operator, i.e., initial conditions, thus
instantiated bizarre values. (The initial conditions supply E J
instances bacterium, IG, EE, JE, L instances molecule.)
hand, remaining goals turn match effects various instances
ligate, transform, screen operators Molgen, follows:
(contains IG ?m): (ligate IG ?m), (transform IG ?m)
(contains ?m ?b): (ligate ?m ?b) (transform ?m ?b)
(pure ?b):
(screen ?b ?y ?z)

,

ucpop happily regress actions. Yet two them,

(transform IG ?m)
doomed fail, perhaps great deal effort expended
trying satisfy preconditions. particular, examination constants
\ ow into" transform operator initial conditions Molgen operators
shows first argument restricted domain fEE, JEg, i.e., must one
given exosomes, second restricted fE, Jg, i.e., must one
given bacteria. Consequently instance (transform IG ?m) unrealizable, first
argument IG fEE, JEg. (Note distinct constants denote distinct entities
according unique-names assumption made ucpop.) (ligate ?m ?b) action
doomed slightly subtle reasons. result match (contains ?m
?b) \when-clause" (conditional effect) ligate operator, whose preconditions
reached second parameter ?b lies set molecules fIG, JE, EEg;
yet ?b restricted set bacteria fE, Jg, result goal condition
(bacterium ?b). fact sets disjoint allow us eliminate
(transform IG ?m) action.
Note elimination action candidates increases number zero commitment plan refinements made. example, left exactly one
action three goals, ZLIFO LCFR strategies prefer
regress goals rather regressing (bacterium ?b) (molecule ?m) {
would prematurely make arbitrary choices ?b ?m initial state.
(ligate ?m ?b),

4.2 Description Algorithm

completed plan, precondition action must instantiated effect
earlier action. values parameters action values
113

fiGerevini & Schubert
\produced" earlier actions, starting initial action, *start*. Moreover,
suppose parameter x certain action occurs preconditions P1, ..., Pk.
constant c possible value x earlier actions instantiate x c
P1, ..., Pk.
algorithm find-parameter-domains based observations. Beginning
initial state, propagates positive atomic predications possible operator preconditions. propagated ground atom, atom matches operator precondition,
algorithm adds constants ground atom individual domains
parameters unified with. individual domains particular specific preconditions. instance, individual domain ?x operator preconditions
(on ?x ?y), (clear ?x) general distinct two preconditions.
soon nonempty individual domains parameters preconditions
operator, form intersection individual domains parameter
operator. example, (on ?x ?y) (so far) matched (on B)
(on B C), (clear ?x) (so far) matched (clear A) (clear Table),
individual domain x fA,Bg first precondition fA,Tableg
second. Thus (assuming preconditions) intersected domain
?x fAg point. later (clear B) matched (clear ?x),
intersected domain ?x grow fA,Bg. ?x ?y nonempty
intersected domains, effects (postconditions) operator turn propagated,
?x ?y \bound" intersected domains.
propagated effects matched possible operator preconditions,
variable \bound" intersected domain successfully unified variable precondition, passes intersected domain individual domain
precondition-variable (via union operation). lead growth intersected domains operator whose precondition matched, effects operator
may propagated, on. individual domains intersected domains grow
monotonically propagation process, end represent desired parameter domains operators.
illustrate process example. Consider simple planning problem
depicted Figure 2 \operator graph" (Smith & Peot, 1993) used describe
logical dependencies among operators, iterative computation parameter
domains graphically illustrated \domain-propagation graph" operator
graph.
initial conditions (P A) (P B) unify precondition (P ?x) op1. So,
individual domain ?x relative precondition P op1 fA,Bg.
hand, precondition (Q ?x) op1 cannot satisfied initial state,
individual domain ?x relative Q initially empty set. Hence intersected domain
?x op1 empty set.
op2 different situation, since one precondition
established initial state. Therefore, individual domain ?y relative
precondition R op2 set constants fB,Cg, intersected domain ?y
op2 set (because R precondition op2 involving ?y). Since
intersected domain ?y enlarged (initially empty), propagated
individual domains operators effect (Q ?y) op2. particular,
114

fiAccelerating Partial-Order Planners

(P ?x)

indicates bundle edges
op1

(Q ?x)
(T B)

*start*
(R ?y)

*end*

op2
Init state: (P A),(P B),(R B),(R C),(S C)
(S ?z)

op1:

preconds: (P ?x),(Q ?x)

Goal: (T B)

op3
op2:

preconds: (R ?y)

op3:

preconds: (S ?z)
effects: (T ?z)

effects: (Q ?y)

effects: (S ?x)

(P A)
(P ?x)
(Q ?x)

id(?x)={B}

id(?x)={}
op1

(P B)

(Q ?x)

op1
ID(P,?x)={A,B}
ID(Q,?x)={B,C}

ID(P,?x)={A,B}
ID(Q,?x)={}
(Q ?y)
id(?y)={B,C}

(R B)
(R ?y)
(R C)

(S ?x)

op2
ID(R,?y)={B,C}

id(?z)={A}
S(A)

(S ?z)

id(?z)={A,B}

op3

(S ?z)

ID(S,?z)={A}

op3
ID(S,?z)={A,B}

Figure 2: Operator domain-propagation graphs simple planning problem.
ID(?x,P) indicates individual domain parameter ?x relative precondition P; id(?x) indicates intersected domain parameter ?x; final
intersected domains indicated using bold fonts.
matches precondition (Q ?x) op1. So, individual domain ?x relative
precondition Q op1 updated adding constants intersected domain ?y
it. Thus intersected domain ?x enlarged fBg, propagated
effect (S ?x) op1.
Similarly, propagation (S ?x) enlarge individual domain ?z op3,
intersected domain, set fA,Bg. Therefore, final intersected domains
are: fBg ?x op1; fB,Cg ?y op2; fA,Bg ?z op3.
presenting algorithm little formally, note parameter domains sometimes \too large", including values would found impossible
(Q ?y)

115

fiGerevini & Schubert
detailed state space exploration conducted. However, required
soundness use domains \too small" (i.e.,
contain parameter values actually occur problem consideration).
course, practical use parameter domains operator exclude
constants occurring problem specification, particularly
intuitively obvious wrong sort fill particular argument slots
operator. turned case problem domains far
experimented with.
preceding sketch method oversimplification since preconditions
effects ucpop operators may particular when-clause. case compute
individual domains intersected domains separately when-clause. example,
consider following schematic representation operator:
(define (operator op1)
:parameters (?x ?y)
:precondition (and P1 P2)
:effect (and E1 E2
(when 0 0)
(when " ") )),

PE
P E

conditions starting P E denote atomic formulas may involve ?x ?y.
think operator consisting primary when-clause whose preconditions
P1 P2 must always satisfied whose effects E1 E2 always asserted,
two secondary when-clauses whose respective preconditions P 0 P " may may
satisfied, are, corresponding effects E 0 E " asserted.
algorithm would maintain individual domains ?x ?y preconditions
P1, P2, P 0 , P ", would maintain intersected domains ?x ?y
primary when-clause two secondary clauses. intersected domains
secondary clauses would based individual domains ?x ?y
relative P 0 P ", relative P1 P2, since (as noted) primary
preconditions must hold operator effects, including conditional
effects.
complications arise ucpop operators contain universally quantified preconditions effects, disjunctive preconditions, facts (mentioned Section 2.2).
Rather dealing complications directly, assume operators occur input algorithm. Later describe semi-automated way
handling operators containing additional constructs.
algorithm outlined (a detailed description given Online Appendix 1). W list (names of) when-clauses whose effects propagated.
Individual parameter domains initially nil, intersected parameter domains initially either nil (where universal domain). intersected domain
parameter, relative given when-clause, case parameter occurs neither
preconditions when-clause primary preconditions. (In case
successful instantiation when-clause clearly independent choice value
parameter question.) Unification step 2(a) usual, except
effect variable v unified constant c precondition, unification succeeds,
116

fiAccelerating Partial-Order Planners
unifier v = c, case c element intersected domain v (for relevant when-clause). given inits (initial conditions) goals (which may omitted,
i.e., nil) treated operator *start* preconditions operator *end*
effects. Variables goals treated operator parameters. use terms
\parameters" \variables" interchangeably here.
Algorithm: find-parameter-domains(operators,inits,goals)
1. Initialize W initial conditions, contains (primary) when-clause
*start*.
2. Repeat steps (a{c) W = nil:
(a) Unify positive effects when-clauses W possible operator
preconditions, mark preconditions successfully matched way
\matched". (This marking permanent.) Augment individual domain
matched precondition variable certain set C constants, defined
follows. precondition variable unified constant c, C = fcg;
unified effect variable, C intersected domain
effect variable (relative when-clause effect belongs).
(b) Mark when-clauses \propagation candidates" preconditions (including corresponding primary preconditions) marked \matched"
involve least one variable relevant individual domain
augmented step (a).
(c) Reset W nil. when-clauses propagation candidates, compute
new intersected domains variables. intersected domain whenclause thereby enlarged, intersected domains when-clause
nonempty, add when-clause W.
3. restrict intersected domains using equative preconditions form (EQ u v),
i.e., form common intersected domain u v variables. u
constant v variable, reduce intersected domain v intersecting
fug; similarly u variable v constant. equation belongs
primary when-clause, use reduce intersected domains u v (whichever
variables) secondary clauses well.
4. Return intersected domains parameter domains, producing sequence
lists list form
(op (x1 a1 b1 c1 :::) (x2 a2 b2 c2 :::) :::),
operator op appears least once. op k conditional effects,
k + 1 successive lists headed op, first provides parameter
domains primary effects op rest provide parameter domains
conditional effects (in order appearance ucpop definition op).
Note match propagate negative conditions. problem negative
conditions large number may implicit initial conditions, given
117

fiGerevini & Schubert
use Closed World Assumption ucpop. instance, world n blocks,
O(n) on-relations (assuming block one block),
necessarily O(n2 ) implicit (not (on ...)) relations. fact, individual variable
domains negative preconditions goals really infinitely large. instance, given
empty initial state (paint-red ?x) operation precondition (not (red ?x))
effect (red ?x), achieve (red c) infinitely many constants c. Perhaps
negative conditions could effectively dealt maintaining anti-domains them,
explored since practice ignoring negative conditions seems cause
minimal \domain bloating". (We proved actual domain elements
lost neglect preconditions.)
use EQ-conditions could refined making use propagation
process, NEQ-conditions could used. However, would probably
marginal impact.
final comment, note output format specified step 4 algorithm
actually generalized implementation report inaccessible preconditions
goals. inaccessible conditions simply appended list parameter
domains appropriate when-clause appropriate operator. instance,
preconditions (oj ?oj) (at ?oj ?city) ld-oj (\load orange juice") operator
trains world (see Online Appendix 2) unreachable (say, oranges
producing orange juice provided), parameter domain list (unique)
when-clause ld-oj appearance
(ld-oj (?oj ...) (?car ...) (?city ...) (oj ?oj) (at ?oj ?city)).
feature turns useful debugging operator specifications detecting
unreachable goals.

4.3 Correctness Tractability

keeping remarks previous section, call algorithm computing
parameter domains correct domains computes subsume possible parameter values
actually occur (in given primary secondary when-clause) consider
possible sequences operator applications starting given initial state.
point property maintain soundness planning algorithm
uses precomputed parameter domains prune impossible actions (as well spurious
threats) partially constructed plan. assert following:

Theorem 1 find-parameter-domains algorithm correct computing parameter

domains ucpop-style sets operators (without quantification, disjunction, facts),
initial conditions, (possibly) goal conditions.
proof given Appendix A. preliminary step establish termination, using
monotonic growth domains finiteness set constants involved. Correctness
established showing exists valid sequence A0 A1 :::A actions
(operator instances) starting A0 = *start*, instance operator
Op, bindings parameters Op received instance eventually added
relevant intersected domains Op (where \relevant" refers when-clauses Op
whose preconditions satisfied beginning ). proved induction n.
n

n

n

n

118

fiAccelerating Partial-Order Planners
indicate deal universally quantified preconditions effects,
disjunctive preconditions, facts. make simple changes operator definitions
hand preparation parameter domain precomputation, use domains
computed find-parameter-domains, together original operators, running
planner. steps preparing operator parameter domain precomputation
follows:
Delete disjunctive preconditions, fact-preconditions,13 universally quantified preconditions (this includes universally quantified goals; would include universally
quantified sentences embedded within antecedents when-clauses, e.g.,
manner (:when (:forall (?x) ) ), though occur problem
domains seen).
Drop universal quantifiers occurring positively operator effects, i.e., occurring
top level embedded one :and's. example, effect
(:and (at robot ?to)
(:not (at robot ?from))
(:forall (?x)
(:when (:and (grasping ?x) (object ?x))
(:and (at ?x ?to) (:not (at ?x ?from))) )))

would become

(:and (at robot ?to)
(:not (at robot ?from))
(:when (:and (grasping ?x) (object ?x))
(:and (at ?x ?to) (:not (at ?x ?from))) )))

Note universally quantified variable renamed, necessary,
distinct variables operator parameters.
example universally quantified variable unrestricted.
quantified variable includes type restriction, (:forall (object ?x) ),
type restriction needs become antecedent matrix sentence .
example hand, rewritten equivalent (:when (object ?x)
). Since often when-clause, done adding (object ?x)
conjunct antecedent when-clause. cases conjunction
when-clauses, case quantifier restriction added
when-clause antecedent.
Drop existential quantifiers preconditions goals, adding restrictions
quantified variables conjuncts matrix sentence. example, goal
(:exists (bacterium ?y)
(:exists (molecule ?x)
(:and (contains IG ?x)
(contains ?x ?y)
(pure ?y) )))

13. E.g., strips-world would drop (fact
given coordinates lie given room.

(loc-in-room ?x ?y ?room)),

119

checks whether

fiGerevini & Schubert
becomes
(:and (bacterium ?y) (molecule ?x) (contains IG ?x)
(contains ?x ?y) (pure ?y) )

(Actually, :and dropped well, supplying goals find-parameterdomains.)
reductions, find-parameter-domains compute correct parameter
domains operators goals. see this, note first dropping preconditions (in initial step above) forfeit correctness, since
weaken constraints admissible parameter values, thus add constants
domains. effect dropping universal quantifier, perspective
find-parameter-domains, introduce new parameter place universal variable. (The operator normalization subroutine detects variables operator preconditions
effects listed parameters, treats additional parameters.)
course drastic change meaning operator, preserves correctness parameter domain calculation. domain new parameter
certainly contain constants (and hence, Closed World Assumption, objects) quantified variable ranges. example, ?x treated parameter
rather universally quantified variable conditional effect
(:forall (?x) (:when (object ?x) (in ?x box))),
domain ?x when-clause consist everything object,
state operator applied. Thus effect (in ?x box) propagated objects, required. Finally, elimination existential quantifiers
preconditions goals seen preserve meaning preconditions
goals, hence preserves correctness parameter domain calculation.
Next formally state tractability claim algorithm, follows (with
tacit assumptions, mentioned proof).
Theorem 2 Algorithm find-parameter-domains implemented run O(mn n (n +
n )) time O(mn ) space worst case, number constants
problem specification, n combined number preconditions operators (and
goals, included), n combined number operator effects (including
*start*).
proof Appendix A. time complexity find-parameter-domains
determined sum (1) cost unifications performed, (2) costs
individual domain updates attempted, (3) cost intersected domain
updates attempted. space complexity bound easily derived assuming
fixed upper bound number arguments predicate (in precondition
effect) have, fact when-clause O(m) constants
stored.
adding additional data structures find-parameter-domains obtain
version algorithm whose worst-case time complexity slightly improved. fact,
step 2.(c) instead propagating effects when-clause enlarged
p

e

p

p

e

120

e

p

fiAccelerating Partial-Order Planners
intersected domain (i.e., adding when-clause list W), sucient propagate
effects when-clause involve enlarged intersected-domain. could
done setting when-clause table maps parameter list
effects (of when-clause) involving parameter.
improved algorithm use W store list effects (instead list whenclauses) propagated next cycle algorithm, steps 1, 2
find-parameter-domains modified following way:
10. Initialize W list effects *start*.
20. Repeat steps (a{c) W = nil:
(a0) Unify positive effects W possible operator preconditions, mark
preconditions successfully matched way \matched" ...
0
(b ) 2.(b).
(c0) Reset W nil. when-clauses propagation candidates, compute new intersected domains variables. intersected domain
when-clause thereby enlarged, intersected domains when-clause
nonempty, add W subset effects when-clause
involving least one parameter whose intersected domain enlarged.
Note worst-case time complexity revised algorithm improved,
effect when-clause propagated O(m) times. decreases upper
bound number unifications performed, reducing complexity estimated step
(1) proof Theorem 2 O(mn n ). Hence proved following corollary.
e

p

Corollary 1 exists improved version find-parameter-domains
implemented run O(mn2 n ) time worst case.
p

e

5. Using Parameter Domains Accelerating Planner

already used example Molgen motivate use precomputed parameter
domains planning, showing domains may allow us prune non-viable actions
partial plan.
fundamentally, used time planner needs unify two predications involving parameter, either goal regression threat detection. (In
either case, one predication (sub)goal effect action
initial condition.) unifier inconsistent parameter domain, count
failure even consistent binding constraints current (partial)
plan. inconsistency, use unifier intersect thus refine
domains parameters equated unifier.
example, suppose G = (at ?x ?y) precondition step current
plan, E = (at ?w ?z) effect another (possibly new) step, ?x, ?y,
?w ?z parameters (or, case ?w ?z, existentially quantified variables)
binding constraints associated current plan. Assume
domains parameters are:
121

fiGerevini & Schubert
?x : {Agent1, Agent2, Agent3}
?w : {Agent1, Agent2}

?y : {City1, City2}
?z : {City3, City4}

unification G E gives binding constraints f?x = ?w, ?y = ?zg,
viable parameter domains ?y ?z empty intersection.
hand, domain ?z fCity2, City3, City4g, unification G E would judged viable, domains parameters would
refined to:
?x : {Agent1, Agent2}
?w : {Agent1, Agent2}

?y : {City2}
?z : {City2}

Thus parameter domains incrementally refined planning search progresses;
narrower become, often lead pruning.

5.1 Incorporating Parameter Domains UCPOP

preceding consistency checks domain refinements used partial-order,
causal-link planner ucpop follows. Given goal (open condition) G selected
ucpop next aw repaired,
(1) restrict set new operator instances ucpop would use establishing G;
instance operator effect E (matching G) disallowed precomputed
parameter domains relevant E incompatible current parameter domains binding constraints relevant G; (note current parameter domains
associated G may refinements initial domains);
(2) restrict set existing steps ucpop would reuse establishing G; reusing
step effect E (matching G) disallowed current parameter domains relevant
E incompatible current parameter domains binding constraints
relevant G.
Moreover, given potential threat effect Q protected condition P, inspection
relevant parameter domains may reveal threat actually spurious.
happens unifier P Q violates (possibly refined) domain constraints
parameter P Q. Thus often
(3) reduce number threats generated planner new causal
link introduced plan (this happens open condition established
either reusing step introducing new one);
(4) recognize threat list aws processed redundant, allowing
elimination. (Note since parameter domains incrementally refined
planning, even use (3) generation threats, still possible
threat becomes spurious added aw list).
four uses parameter domains cut search space without loss viable
solutions, since options eliminated cannot lead correct, complete plan.
122

fiAccelerating Partial-Order Planners
Note (3) (4) useful even planner deals definite
threats (i.e., *d-sep* switch turned on) least three reasons. First, determining
threat definite threat *d-sep* incurs overhead cost. So,
earlier elimination spurious threat could lead considerable savings threat
delayed many times search. second reason relates plan-selection
strategies adopted. one uses function includes (attenuated) term corresponding
number threats currently aw list, eliminating spurious threats
advance give accurate measure \badness" plan. Finally, parameter
domains could used threat processing prune search even *dsep*
on. particular, suppose modify notion definite threat,
parameter domains, e.g., (P ?x) (not (P ?y)) comprise definite threat
parameter domains associated ?x ?y c. case, even
d-sep* on, may discover early threat become definite { case might
forced threat, i.e., choice promotion demotion may dictated
ordering constraints; prune search space. However, current
implementation exploit third point.
incorporated techniques ucpop (version 2.0), along earlier
improvements plan goal selection strategies. Parameter domains handled
extension \varset" data structure (Weld, 1994) include domains
variables (parameters), extending unification process implement
filtering discussed above.14 describe experiments enhanced system.

5.2 Experimental Results Using Parameter Domains

main goal show overhead determined computing parameter domains significant (both preprocessing time planning time), exploitation parameter domains planning significantly prune search.
experiments used version find-parameter-domains described Section
4.2 Online Appendix 1. Note domains complex ones
considered might worthwhile use improved version algorithm discussed
Section 4.3. (However, remains seen whether problems significantly complex
consider solved ucpop-style planner.)
CPU times needed implementation find-parameter-domains negligible problems looked at. 10 msec less many problems
ucpop test suite (when running compiled Allegro CL 4.2 sun 20), 20 msec
two problems (Fixa fridge repair domain Fixit tire domain),
30msec trains world problems described below.
first set tests, relied search strategy used default ucpop.
function used A* plan selection thus S+OC+UC+F (allowing problems
involve \facts"), goals selected agenda according pure LIFO
discipline.15
14. current implementation new threats filtered protected condition established
step already plan.
15. experiments *d-sep* switch on. default delay-separation strategy selecting unsafe
conditions slightly modified version ucpop using parameter domains. particular,

123

fiGerevini & Schubert
began experimenting variety problems ucpop's test suite, comparing performance without use parameter domains. relatively easy
problems Sussman-anomaly, Fixa, Test-ferry, Tower-invert4 showed improvement use parameter domains, problems { particularly harder
ones { solved easily parameter domains. example, Rat-insulin
problem Molgen domain solved nearly twice fast, strips-world
problems (Move-boxes variants)16 Towers Hanoi (T-of-H1) solved
10 times fast. Note strips-world problems involve facts universally
quantified conditional effects. Two problems oce world, Oce5 Oce6,
knew readily solvable improved search strategy, remained dicult (in case Oce6, unsolvable) default ucpop strategy, despite use
parameter domains.17 experiments revealed source ineciency
default plan-selection strategy ucpop. fact, using S+OC+F strategy
instead S+OC+UC+F, without parameter domains Oce5 Oce6 solved generating/exploring 3058/2175 8770/6940 plans respectively; using parameter
domains plans numbered 1531/1055 2954/2204 respectively.
initial experiments suggested us promising application computed parameter domains would nontrivial problems involved variety types
entities relationships, significant amounts goal chaining (i.e., successive
action establishing preconditions next). perspective, trains world
struck us natural choice experimentation, additional advantage
design independently motivated research Rochester mixed-initiative
problem solving natural-language interaction. (Refer formalization
Online Appendix 2.) Recall Table X Trains1 problem extremely hard
unmodified ucpop, requiring 50 minutes generating million plans.
Running problem parameter domains produced solution 3.3 seconds
(with 1207 plans generated), i.e., 927 times faster.
Intuitively, use parameter domains constrain planning analogous using
type constraints parameters (although parameter domains take account initial
conditions). interest see whether adding type constraints provide similar
eciency gains use parameter domains. first set experiments therefore
included T-Trains1, \typed" version Trains1; operators slightly changed
adding new preconditions stating types parameters involved. example,
operator uncouple augmented preconditions (engine ?eng)
(car ?car). problem extremely hard unmodified ucpop, exceeding
search limit 1,000,000 plans generated requiring 2600 seconds.
parameter domains, solution obtained one second.
threats resolved separation recognized redundant use
parameter domains selected eliminated.
16. Move-boxes-2 differs slightly Move-boxes problem ucpop suite, goal (in-room
box2 rclk); Move-boxes-a differs slightly Move-boxes-2, initial state contains two
boxes.
17. Oce5 directly ucpop's test suite Oce6 minor variant Oce5. Oce5, persons
furnished checks made them, using check printer oce briefcase
picking checks bringing home. \Sam" \Sue" given persons, Oce6
added (person Alan) (person Smith) initial conditions.

124

fiAccelerating Partial-Order Planners

Problems

without domains
domains
Domain
Plans
CPU sec
Plans
CPU sec ratio
Trains1
1,071,479/432,881 3050.15
1207/824
3.29
0.425
T-Trains1
> 1,000,000
> 2335
404/296
0.98
0.425
Move-boxes
608,231/167,418 1024.04
5746/3253
18.8
0.705
Move-boxes-1
> 1,000,000
> 6165
1264/645
3.59
0.705
Move-boxes-2
13,816/3927
45.05
1175/587
2.66
0.705
Move-boxes-a
13,805/3918
46.11
1175/587
2.54
0.702
T-of-H1
160,911/107,649 204.51 17,603/12,250
37.5
0.722
Rat-insulin
364/262
0.36
196/129
0.19
0.714
Monkey-test1
96/62
0.12
75/46
0.11
0.733
Monkey-test2
415/262
0.61
247/149
0.50
0.529
Fix3
3395/2070
5.77
3103/1983
6.02
0.532
Oce5
809,345/500,578 1927.4 575,224/358,523 1556.8
0.625
Oce6
> 1,000,000
> 2730
> 1,000,000
> 2640 0.667
Tower-invert4
806/538
1.55
806/538
1.59
0.733
Sussman-anomaly
44/26
0.05
44/26
0.06
0.917
Fixa
2131/1903
2.2
2131/1903
2.34
1
Test-ferry
718/457
0.65
718/457
0.71
1

Table XII: Plans generated/visited CPU time (secs) standard ucpop
without parameter domains. ( result obtained sun 10
Lucid Common Lisp; others sun 20 Allegro Common Lisp.)
results indicate adding type constraints operator specifications
nearly effective use parameter domains boosting planning eciency.
discuss point context second set tests (below).
Table XII summarizes experimental results experiments used
default ucpop search strategy. table gives number plans generated/visited
planner CPU time (seconds) required solve problems.18 Note
use parameter domains gave dramatic improvements trains domain, strips-world domain. rightmost column supplies \domain ratio"
data, metric hoped would predict likely effectiveness using parameter
domains. idea parameter domains effective extent
filter many parameter bindings reached chaining back individual
preconditions operator initial state. bindings found using
variant algorithm propagating intersected domains instead propagates unions
individual domains, comparing union domains intersected domains.19
18. systems compiled Allegro CL 4.2, settings (space 0) (speed 3) (safety 1) (debug
0), run sun 20. CPU time includes Lisp garbage collection (it time given
output ucpop).
19. Actually, need explicitly propagate union domains, propagate (partial) bindings
one predication time, starting initial conditions. match predication possible
preconditions, adding constant arguments contains union domains matched operator

125

fiGerevini & Schubert

trains
without domains
domains
Domain
problems
Plans
CPU sec
Plans
CPU sec ratio
Trains1
4097/2019
13.7
297/238
1.4
0.425
Trains2 17,482/10,907 80.6 1312/1065 7.16
0.425
Trains3 31,957/19,282 189.8 3885/3175 25.1
0.411
Table XIII: Plans generated/visited CPU time (secs) ucpop without
parameter domains trains domain using ZLIFO strategy.

trains without domains
domains
Domain
problems Plans CPU sec Plans CPU sec ratio
Trains1 1093/597
8.1
265/194
2.3
0.425
Trains2 >50,000 >607 >50,000 >534
0.425
Trains3 >50,000 >655 >50,000 >564
0.411
Table XIV: Plans generated/visited CPU time (secs) ucpop without
parameter domains trains domain using LCFR strategy.
\domain ratio" provides comparison, dividing average union domain size
average intersected domain size, averages taken parameters when-clauses
operators.
largest speedups (e.g., trains problems) tend correlate
smallest domain ratios, smallest speedups largest domain ratio (unity {
see last rows). However, seen table problem diculty (as
measured plans CPU time) much useful domain ratio predictor
speedups expected using parameter domains. Problems generate
order million plans standard ucpop tend produce speedups 3 orders
magnitude, whereas domain ratio problems (e.g., Move-boxes-1)
better (or even worse) problems much smaller speedups (e.g., Move-boxesa, Rat-insulin, Monkey-test1, Monkey-test2). much lower diculty problems
predicts reduced speedup. complicate matters, dicult problems give
high speedups (see T-of-H1 especially Oce5); know subtleties
problem structure account unusual cases.
second round experiments, tested effectiveness parameter domain
technique combination improved search strategy, i.e., S+OC/ZLIFO. addition, combined S+OC LCFR (least cost aw selection) (Joslin & Pollack, 1994),
(or when-clause). find corresponding (partially bound) effects, add new effects
list predications still propagated. partially bound effect (P ?x ?y) new
identical similar predication (P ?u ?v) among previously propagated predications
among still propagated.

126

fiAccelerating Partial-Order Planners

t-trains

without domains
domains
Domain
problems
Plans
CPU sec
Plans
CPU sec ratio
T-Trains1 3134/2183
17.2
505/416
3.4
0.425
T-Trains2 5739/4325
37.3
3482/2749
27.3
0.425
T-Trains3 17,931/13,134 130.4 11,962/9401 105.1
0.425

Table XV: Plans generated/visited CPU time (secs) ucpop without parameter domains \typed" trains domain using ZLIFO strategy.

t-trains

without domains
domains
Domain
problems
Plans
CPU sec
Plans
CPU sec ratio
T-Trains1 3138/2412 31.5 1429/1157 14.5
0.425
T-Trains2 >50,000 >1035 >50,000 >1136
0.425
T-Trains3 >50,000
>976
>50,000
>962
0.425

Table XVI: Plans generated/visited CPU time (secs) ucpop without
parameter domains \typed" trains domain using LCFR strategy.
test possible sensitivity parameter-domains technique precise strategy
used. present set tests used search limit 50,000 plans generated.
began sampling problems ucpop test suite,
initial trials yielded results quite analogous default ucpop strategy.
obtained improvements several easier problems significant improvements
harder ones (e.g., close factor 2 Rat-insulin). Noteworthy members
latter category Oce5 Oce6 { recall Oce5 shown little speedup
standard ucpop Oce6 unsolvable. However, view computational
expense testing ZLIFO LCFR, decided narrow focus
trains world. mentioned, advantages world inherent interest
relative complexity.
Tables XIII-XVI provide experimental results trains domain S+OC/
ZLIFO strategy S+OC/LCFR strategy, case without parameter
domains.
results Tables XIII XIV show using parameter domains still give
significant improvements performance, obtained use
better search strategies. example, use parameter domains provided 11-fold
speedup Trains2, S+OC/ZLIFO strategy. particular problem speedup
(on metrics) result pruning 1482 plans (more half generated)
search., recognizing 305 unsafe conditions redundant. Evidently,
effect pruning amplified order magnitude overall performance,
futile searches cut short. Note speedups Trains1-3
127

fiGerevini & Schubert
roughly comparable (within factor 2) obtained problems previous set
comparable initial diculty (e.g., see Move-boxes-2 Move-boxes-a Table XII).
points rather consistent correlation problem diculty speedups
obtainable using parameter domains. constant domain ratios compatible
less invariant speedups here, though little import, given earlier
results. S+OC/LCFR gains appear less, though single result showing
3.5-fold speedup provides anecdotal evidence conclusion. Trains2
Trains3 remained dicult solution LCFR. Similar gains observed
S+OC/LC strategies best observed gain Trains domain 1.7-fold
speedup Trains2. case, results confirm effectiveness parameterdomains technique.
Tables XV XVI \typed" version trains. case parameter
typing gave modest improvements absence parameter-domains, (in contrast
results Trains1 default search strategy) significant deterioration
presence. know account results detail, seems
clear contrary effects involved. one hand, typing tend help
tends limit choices parameter values \sensible" ones. example, precondition
(engine ?eng) satisfiable use *start*, initial state thus
constrain ?eng assume sensible values. hand, adding type-preconditions
tend broaden search space, adding open conditions aw list.
lesson \typed" experiments appears best supply
explicit type constraints operator parameters, instead using automated method
calculating updating domains constrain parameter bindings.

6. Conclusions Work

began exploring simple, domain-independent improvements search strategies
partial order planning, described method using precomputed parameter domains prune search space. summarize conclusions techniques
point promising directions work.

6.1 Improving Search

proposed improvements search strategies based one hand carefully
considered choice terms A* heuristic plan selection,
preference choosing open conditions cannot achieved achieved
one way (with default LIFO prioritization open conditions). Since
plan refinements corresponding uniquely achievable goals logically necessary,
termed latter strategy zero-commitment strategy. One advantage technique
similar strategies incurs lower computational overhead.
experiments based modifications ucpop indicate strategies give
large improvements planning performance, especially problems hard
ucpop (and \relatives") begin with. best performance achieved
strategies plan selection goal selection used combination. practical terms,
able solve nearly every problem tried ucpop test suite fraction
second (except Fixit, required 38.2 seconds), problems
128

fiAccelerating Partial-Order Planners
previously required minutes unsolvable machine. included
sucient variety problems indicate techniques broad potential utility.
Further, results suggest zero-commitment best supplemented LIFO
strategy open conditions achievable multiple ways, rather generalization
zero-commitment favoring goals fewest children. somewhat surprising result
might thought due way designer domain orders
preconditions operators; i.e., \natural" ordering preconditions may correlate
best planning order, giving fortuitous advantage LIFO strategy relative
strategy LC.20
However, preliminary experiments performed randomized preconditions
T-of-H1 Trains1 indicate otherwise. 5 randomizations preconditions
T-of-H1, LC ZLIFO slowed somewhat, average factors 2.2 (2)
3.3 (4.2) terms plans expanded (CPU time used) respectively. (In cases,
S+OC used plan search.) still left ZLIFO performance advantage
factor 22 terms plans created 39 terms CPU time. Trains1
performance LC greatly deteriorated 2 5 cases (by factor close 70 terms
plans time), ZLIFO actually improved marginally. left
ZLIFO average performance advantage LC (whereas slightly slower
unrandomized case) { factor 3.3 terms plans 6.7 terms CPU time
(though values unreliable, view fact standard deviations
order means).
Despite results believe satisfactory understanding dependence
aw-selection strategies order operator preconditions require extensive
experimental investigation. currently undertaking work.

6.2 Using Parameter Domains

described implemented, tractable algorithm precomputing parameter domains
planning operators, relative given initial conditions. showed use precomputed domains planning process prune non-viable actions bogus threats,
update dynamically maximum effect.
idea using precomputed parameter domains constrain planning apparently
first proposed technical report Goldszmidt et al. (1994). contains essential
idea accumulating domains forward propagation initial conditions. Though
report sketches single-sweep propagation process initial conditions
goals, implemented Rockwell Planner (RNLP) handles cyclic operator graphs,
repeatedly propagating bindings quiescence, much algorithm. algorithm
deals additional complexities conditional effects equalities (and semiautomated fashion quantification) appears ecient (Smith, 1996).
distinctive features work method incrementally refining domains
20. suggested us David Smith well Mike Williamson. Williamson tried ZLIFO 5
randomized versions T-of-H1, reported large performance degradation (Williamson & Hanks,
1996). recently ran versions using implementation, obtaining far favorable results
(three five versions easier solve original version T-of-H1, two
versions slowed ZLIFO factor 1.84 4.86 terms plans explored.)

129

fiGerevini & Schubert
planning, theoretical analysis algorithm, systematic experimental
tests.
Another closely related study Yang Chan (1994), used hand-supplied
parameter domains planning much use precomputed domains. interesting
aspect work direct use sets constants variable bindings. instance,
establishing precondition (P ?x) using initial state containing (P a), (P b)
(P c), would bind ?x fa, b, cg rather specific constant. refine
\noncommittal" bindings planning much refine variable domains,
periodically use constraint satisfaction methods check consistency current
EQ/NEQ constraints. conclude delaying variable bindings works best problems
low solution densities (while degrading performance problems high
solution densities), optimal frequency making consistency checks depends
whether dead ends tend occur high low search tree. work distinguished
method precomputing parameter domains, use specific bindings
matching initial conditions OCs, use parameter domains threat detection
resolution, handling enriched syntax ucpop operators compared
snlp operators.
Judging examples experimented with, techniques well-suited
nontrivial problems involve diverse types objects, relations actions, significant logical interdependencies among steps needed solve problem. used
conjunction default search strategy ucpop, method gave significant speedups
nontrivial problems, reaching speedup factor 927 trains transportation planning domain, 1717 hardest strips-world problem tried .
combined S+OC ZLIFO search strategies, parameter domain technique
still gave speedups factor around 10 trains problems. Though implementation aimed ucpop-style planner, essentially techniques would
applicable many planners.
found parameter domain precomputations useful debugging
aid. fact, domain precomputation initial formulation trains world
immediately revealed several errors. instance, domain ?eng parameter
mv-engine turned contain oranges, bananas, OJ factory, indicating need
type constraint ?eng. (Without this, transportation problems would
solvable without benefit engines trains!) Another immediately apparent problem
revealed parameter domains ?city1 ?city2 mv-engine: domain
?city1 excluded Elmira, ?city2 excluded Avon. obvious diagnosis
neglected assert (connected c1 c2) (connected c2 c1)
track connecting two cities. Furthermore, parameter domains quickly identify
unreachable operators goals cases. instance, without make-oj operator,
computed domains show ld-oj operator unreachable, goal
(and (oj ?oj) (at ?oj Bath)) (getting orange juice Bath) unattainable (the
parameter domain ?oj empty).
course, running planner used debugging formalization,
planning general far time-consuming form preprocessing (especially
goal pose happens unachievable formalization!), trace
130

fiAccelerating Partial-Order Planners
anomalous planning attempt quite hard interpret, compared listing
parameter domains, obtained fraction second.

6.3 work

First all, additional experimentation would interest, assess
perhaps refine search strategies. experimentation might focus threathandling strategies, including best general form attenuated UC-term plan
selection, best way combine threat selection open condition selection.
preference definite threats open conditions used ZLIFO appear
good default according experience, TileWorld experiments indicated
re-ordering priorities threats open conditions sometimes desirable. Concerning choice UC-related term inclusion heuristic plan selection,
mention brie tried using S+OC+UC , UC number
definite threats, obtain significant uniform improvements.
One promising direction development search strategy make
zero-commitment strategy apply often finding ways identifying false options
early possible. is, possible action instance (obtained matching open
condition available operators well existing actions) easily recognizable inconsistent current plan, elimination may leave us single
remaining match hence opportunity apply zero-commitment strategy.
One way implementing strategy would check once, accepting
matched action possible way attain open condition, whether temporal
constraints action force violate causal link, alternatively, force causal
link violated. case action could immediately eliminated, perhaps
leaving one (or even no) alternative. could perhaps made even effective
broadening definition threats preconditions well effects actions
threaten causal links, hence bring light inconsistencies sooner. Note
precondition action inconsistent causal link, established
another action whose effects violate causal link; precondition really poses
threat outset.
Two possible extensions parameter domain techniques (i) fully automated
handling universally quantified preconditions effects, disjunctions facts
preprocessing algorithm; (ii) \intelligent" calculation domains, applying
constraint propagation process sets ground predications matched
preconditions operator; shown yield tighter domains, though
computational expense. Blum Furst (1995) recently explored similar idea, rather
computing parameter domains, directly stored sets ground atoms could
generated one operator application (starting initial state), two successive operator
applications, on, used sets atoms (and exclusivity relations among
atoms actions connecting them) guide regressive search plan.
algorithm describe allow conditional effects, though generalization
appears entirely possible. examples used tests, obtained dramatic
speedups.


131



fiGerevini & Schubert
Finally, working another preprocessing technique, namely inference
state constraints operator specifications. One useful form constraint implicational (e.g., (implies (on ?x ?y) (not (clear ?y)))), another single-valuedness
conditions (e.g., (on ?x ?y) may single-valued ?x ?y). conjecture
constraints tractably inferred used large speedups domainindependent, well-founded planning.
view results presented possibilities speedups
mentioned, think plausible well-founded, domain-independent planners may
yet become competitive pragmatically designed planners.

Acknowledgements

work amalgamates extends two conference papers improving search (Schubert
& Gerevini, 1995) using computed parameter domains (Gerevini & Schubert, 1996)
accelerate partial-order planners. research supported part Rome Lab contract F30602-91-C-0010 NATO Collaborative Research Grant CRG951285.
work AG carried IRST, 38050 Povo (TN), Italy, CS Department
University Rochester, Rochester NY USA. helpful comments perceptive
questions Marc Friedman, David Joslin, Rao Kambhampati, Colm O'Riain, Martha Pollack, David Smith, Dan Weld, Mike Williamson, Associate Editor Michael Wellman
anonymous reviewers gratefully acknowledged.

Appendix (Proofs Theorems)
Theorem 1 find-parameter-domains algorithm correct computing parameter

domains ucpop-style sets operators (without quantification, disjunction, facts),
initial conditions, (possibly) goal conditions.
Proof. preliminary observation, intersected parameter domains computed iteratively algorithm eventually stabilize, since grow monotonically
finitely many constants occur initial conditions operator effects.
Thus algorithm terminates.
order prove correctness need show exists valid sequence
A0 A1 :::A actions (operator instances) starting A0 = *start*,
instance operator Op, bindings parameters Op received instance
eventually added relevant intersected domains Op (where \relevant" refers
when-clauses Op whose preconditions satisfied beginning ).
prove induction n.
n = 0, = A0 = *start*, parameters claim trivially
true.
assume claim holds n = 1; 2; :::; k. consider operator instance
+1 validly follow A0 A1 :::A , i.e., +1 instance operator
Op whose primary preconditions, possibly along secondary ones, satisfied
end A0 A1 :::A . Let p precondition, write instance +1
(P c1 c2 ..). (P c1 c2 ..) must effect , 0 k. = 0
n

n

n

n

n

k

k

k

k

k



132

fiAccelerating Partial-Order Planners
(P c1 c2 ..) holds initial state, hence predication propagated
successfully matched p initial propagation phase find-parameter-domains.
> 0, instance operator Op' (P c1 c2 ..) corresponding
instance effect (P t1 t2 ..) Op', either parameter Op'
equal cj. Diagrammatically,


j

A0 . . .
j



. . .



+1
j

k

k

Op'

Op

effect (P t1 t2 ..) ,,,,! precond p
(P c1 c2 .. )

(P c1 c2 .. )

induction assumption, bindings parameters eventually added
relevant intersected domains Op'. implies intersected domains
Op' become nonempty, effect (P t1 t2 ..) eventually propagated,
variables among corresponding constant cj relevant intersected
domain. Consequently, much case = 0, effect (P t1 t2 ..) successfully matched
precondition p Op stage propagation. Given observations,
clear = 0 > 0, p marked \matched" Op eventually,
furthermore parameters Op occur p bindings resulting
unification (P c1 c2 ..) added appropriate individual domains associated
p.
argument applies preconditions Op satisfied instance +1 , particular primary preconditions. Since marked \matched", algorithm
compute intersected domains Op-parameters occur them. view
individual domain updates confirmed, since individual domains grow monotonically, intersected domains eventually contain parameter bindings +1 .
instance, parameter ?x Op occurs primary precondition bound
c +1 , shown c eventually added intersected domain
?x associated primary when-clause Op. parameter occur
primary preconditions Op, intersected domain set outset,
implicitly contains whatever binding parameter +1 .
similar argument made secondary when-clause Op whose preconditions satisfied +1 . Again, preconditions secondary clause,
well primary preconditions, marked \matched", parameter
occurring combined preconditions, intersected domain (relative secondary
clause) updated include binding +1 . parameters Op occurring
preconditions, intersected domains set initially,
implicitly contains possible binding. Finally, note since intersected
domains relative primary secondary when-clauses grow monotonically, augmentations intersected domains confirmed permanent. (In case
T-domains, remain T.)
leave additional details concerned ultimate use EQ-preconditions
find-parameter-domains reader. 2


j

k

k

k

k

k

k

133

fiGerevini & Schubert

Theorem 2 Algorithm find-parameter-domains implemented run O(mn n (n +
n )) time O(mn ) space worst case, number constants
problem specification, n combined number preconditions operators (and
goals, included), n combined number operator effects (including
p

e

e

p

p

p

e

*start*).

Proof. time complexity find-parameter-domains determined sum
(1) cost unifications performed, (2) costs individual domain
updates attempted, (3) cost intersected domain updates attempted.
estimate upper bound terms following assumptions:

(a) unification operator effect operator precondition requires constant
time;
(b) fixed upper bound number arguments predicate (in
precondition effect) have. follows O(n ) upper bound total
number intersected domains;21
(c) individual domains intersected domains stored hash tables (indexed
constants domain). So, check whether element belongs particular
(individual intersected) domain, possibly add domain essentially
constant time. Furthermore individual intersected domain, appropriate
data structures used keep track (possibly empty) set new elements
added domain last update attempt.
(1) particular intersected domain particular operator,
updates domain. update causes effects whenclause intersected domain belongs propagated. upper bound
number n . propagated effect may unified O(n ) preconditions. Thus
O(m) updates intersected domain may cause O(mn n ) unifications. Hence
(b), overall number unifications caused propagation intersected domains
individual domains O(mn2 n ). unifications add
initially performed effects *start* preconditions operators.
O(mn ) unifications, increase previous upper bound
number unifications. Thus, (a), cost unifications performed
algorithm O(mn2 n ).
(2) unification potentially followed attempt update individual
domain(s) relevant parameter(s). However, assumption (c) number
attempts limited set new elements intersected domain(s)
unifying effect (are) empty. Furthermore, attempt update
individual domain performing union relevant intersected domain ,
subset new elements need added (if already
there). Thus, since intersected domain grows monotonically, (b) (c)
overall cost update attempts one particular individual domain caused
e

e

p

e

e

p

p

p

e

p











21. Note parameter appears precondition when-clause, none effects,
intersected domain parameter propagated algorithm. Hence implementing
algorithm ignore parameters.

134

fiAccelerating Partial-Order Planners
one particular effect O(m). worst case one effect unify
O(n ) preconditions operators, yielding overall bound attempts
update individual domains O(mn n ).
(3) attempt update particular intersected domain relevant
individual domain update, relevant individual domain updated O(m) times
(because domains grow monotonically). Therefore (b) O(mn )
attempts update one intersected domain. (c) total cost attempts
O(mn2 ), checking whether new element individual domain belongs
O(n ) relevant individual domains takes O(n ) time. So, since (b)
O(n ) intersected domains, total cost incurred algorithm
updating intersected domains O(mn n2 ).
follows time complexity find-parameter-domains is:
O(mn2n ) + O(mn n ) + O(mn n2) = O(mn n (n + n )).
space complexity bound easily derived (b), fact
when-clause O(m) constants stored. 2
p

e

p

p

p

p

p

e

e

p

e

p

References

e

p

e

p

p

e

p

e

Allen, J., & Schubert, L. (1991). TRAINS project. Tech. rep. 382, Dept. Computer
Science, Univ. Rochester, Rochester, NY. slightly revised Language
discourse TRAINS project, A. Ortony, J. Slack, O. Stock (eds.), Communication Artificial Intelligence Perspective: Theoretical Springer-Verlag,
Heidelberg, pp. 91-120.
Allen, J., Schubert, L., Ferguson, G., Heeman, P., Hwang, C., Kato, T., Light, M., Martin,
N., Miller, B., Poesio, M., & Traum, B. (1995). TRAINS project: case study
building conversational planning agent. Experimental Theoretical Artificial
Intelligence, 7, 7{48.
Barrett, A., Golden, K., Penberthy, S., & Weld, D. (1994). UCPOP user's manual. Tech.
rep. 93-09-06, Dept. Computer Science Engineering, University Washington,
Seattle, WA 98105.
Blum, A., & Furst, M. (1995). Fast planning planning graph analysis. Proceedings
Fourteenth International Joint Conference Artificial Intelligence (IJCAI-95),
pp. 1636{1642 Montreal, CA. Morgan Kaufmann.
Chapman, D. (1987). Planning conjunctive goals. Artificial Intelligence, 32 (3), 333{377.
Currie, K., & Tate, A. (1991). O-Plan: open planning architecture. Artificial Intelligence, 51 (1).
Fikes, R., & Nilsson, N. (1971). STRIPS: new approach application theorem
proving problem solving. Artificial Intelligence, 2, 189{208.
Georgeff, M., & Lansky, A. (1987). Reactive reasoning planning. Proceedings
Sixth National Conference American Association Artificial Intelligence, pp.
677{682 Seattle, WA. Morgan Kaufmann.
135

fiGerevini & Schubert
Gerevini, A., & Schubert, L.K. (1995). Computing parameter domains aid planning.
Proc. 3rd Int. Conf. Artificial Intelligence Planning Systems (AIPS-96),
pp. 94{101 Menlo Park, CA. AAAI Press.
Goldszmidt, M., Darwiche, A., Chavez, T., Smith, D., & White, J. (1994). Decision-theory
crisis management. Tech. rep. RL-TR-94-235, Rome Laboratory.
Green, C. (1969). Application theorem proving problem solving. Proceedings
First International Joint Conference Artificial Intelligence (IJCAI-69), pp.
219{239.
Joslin, D. (1995). Personal communication.
Joslin, D., & Pollack, M. (1994). Least-cost aw repair: plan refinement strategy
partial-order planning. Proceedings Twelfth National Conference
American Association Artificial Intelligence (AAAI-94), pp. 1004{1009 Seattle,
WA. Morgan Kaufmann.
Kambhampati, S., Knoblock, C. A., & Yang, Q. (1995). Planning refinement search:
unified framework evaluating design tradeoff partial-order planning. Artificial
Intelligence. Special Issue Planning Scheduling, 76 (1-2).
Korf, R. (1992). Linear-space best-first search: Summary results. Proceedings
Tenth National Conference American Association Artificial Intelligence
(AAAI-92), pp. 533{538.
McAllester, D., & Rosenblitt, D. (1991). Systematic nonlinear planning. Proceedings
Ninth National Conference Artificial Intelligence (AAAI-91), pp. 634{639
Anheim, Los Angeles, CA. Morgan Kaufmann.
Nilsson, N. (1980). Principles Artificial Intelligence. Tioga Pub. Co., Palo Alto, CA.
Penberthy, J., & Weld, D. (1992). UCPOP: sound, complete, partial order planner
ADL. Nebel, B., Rich, C., & Swartout, W. (Eds.), Proceedings Third
International Conference Principles Knowledge Representation Reasoning
(KR92), pp. 103{114 Boston, MA. Morgan Kaufmann.
Peot, M. A., & Smith, D. E. (1993). Threat-removal strategies partial-order planning.
Proceedings Eleventh National Conference American Association
Artificial Intelligence (AAAI-93), pp. 492{499 Washington, D.C. Morgan Kaufmann.
Schubert, L., & Gerevini, A. (1995). Accelerating partial order planners improving
plan goal choices. Proc. 7th IEEE Int. Conf. Tools Artificial
Intelligence, pp. 442{450 Herndon, Virginia. IEEE Computer Society Press.
Smith, D. E., & Peot, M. A. (1993). Postponing threats partial-order planning.
Proceedings Eleventh National Conference American Association Artificial Intelligence (AAAI-93), pp. 500-506 Washington, D.C. Morgan Kaufmann.
Smith, D. E. (1996). Personal communication.
136

fiAccelerating Partial-Order Planners
Srinivasan, R., & Howe, A. (1995). Comparison methods improving search eciency
partial-order planner. Proceedings Fourteenth International Joint Conference Artificial Intelligence (IJCAI-95), pp. 1620{1626.
Weld, D. (1994). introduction least commitment planning. AI Magazine, 15 (4),
27{62.
Wilkins, D. (1988). Practical Planning: Extending Classical AI Planning Paradigm.
Morgan Kaufmann, San Mateo, CA.
Williamson, M., & Hanks, S. (1995). Flaw selection strategies value-directed planning.
Proceedings Third International Conference Artificial Intelligence Planning
Systems, pp. 237{244.
Yang, Q., & Chan, A.Y.M. (1994). Delaying variable binding commitments planning.
Proceedings Second International Conference Artificial Intelligence Planning
Systems, pp. 182{187.

137


