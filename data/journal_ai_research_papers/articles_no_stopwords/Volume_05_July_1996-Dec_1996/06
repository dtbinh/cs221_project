journal artificial intelligence

submitted published

muse csp extension
constraint satisfaction
randall helzerman
mary p harper

school electrical computer engineering
electrical engineering building
purdue university
west lafayette usa

helz ecn purdue edu
harper ecn purdue edu

abstract

describes extension constraint satisfaction csp called
muse csp mu ltiply se gmented c onstraint atisfaction p roblem extension
especially useful segment multiple sets partially shared
variables arise naturally signal processing applications including computer vision speech processing handwriting recognition applications
often dicult segment data one way given low level information utilized
segmentation muse csp used compactly represent several
similar instances constraint satisfaction multiple instances csp
common variables domains constraints
combined single instance muse csp reducing work required apply
constraints introduce concepts muse node consistency muse arc consistency
muse path consistency demonstrate muse csp used compactly represent lexically ambiguous sentences multiple sentence hypotheses
often generated speech recognition grammar constraints
used provide parses syntactically correct sentences muse arc
path consistency provided finally discuss create muse csp
set csps labeled indicate variable shared
single csp

introduction
describes extension constraint satisfaction csp called muse
csp mu ltiply se gmented c onstraint atisfaction p roblem extension especially
useful segment multiple sets partially shared variables
first describe constraint satisfaction define extension

constraint satisfaction
constraint satisfaction csp rich history artificial intelligence davis
rosenfeld dechter meiri pearl dechter pearl freuder
mackworth mackworth freuder villain kautz waltz
general reference see tsang constraint satisfaction provides convenient way
represent solve certain types general
solved assigning mutually compatible values predetermined number variables
c


ai access foundation morgan kaufmann publishers rights reserved

fihelzerman harper

set constraints used variety disciplines including
machine vision belief maintenance temporal reasoning graph theory circuit design
diagnostic reasoning csp e g figure variables typically depicted vertices nodes node associated finite set possible
values constraints imposed variables depicted arcs arc looping
node represents unary constraint constraint single variable
arc two nodes represents binary constraint constraint two variables
classic example csp map coloring e g figure color must
assigned country two neighboring countries color
variable represents country color constraint arc two variables indicates
two joined countries adjacent assigned color
formally csp mackworth defined definition

definition constraint satisfaction
n j g set nodes variables jn j n
l fa b g set labels jlj l
li faja l admissibleg
r unary constraint admissible r
r binary constraint j b admissible r j b
csp network contains n tuples ln satisfy r r since

labels associated node may incompatible labels assigned nodes
desirable constraints suciently tight van beek eliminate
many labels possible enforcing local consistency conditions globally
consistent solution extracted dechter node arc consistency defined
definitions respectively addition may desirable eliminate many label
pairs possible path consistency defined definition

definition node consistency instance csp said node consistent
node domain contains labels unary constraint r holds e
n li r
definition arc consistency instance csp said arc consistent

every pair nodes j element li domain least one element lj
binary constraint r holds e
j n li b lj r j b
red green blue
different
color






red green blue

different
color






red green blue

different
color

figure map coloring example csp


fimuse csp extension constraint satisfaction

definition path consistency instance csp said path consistent
j n j li b lj k n k k j p ath k j
r j b c lk r k c r k c j b
path k j indicates path arcs length two connecting j
goes k

node consistency easily enforced operation li li fxjr x g requiring
nl time n number variables l maximum domain size arc
consistency enforced ensuring every label node supported least one
label node shares binary constraint mackworth mackworth
freuder mohr henderson arc consistency ac mohr
henderson worst case running time el e number
constraint arcs ac mackworth freuder often performs better ac
practice though slower running time worst case ac bessiere
worst case running time ac faster ac ac practice
path consistency ensures pair labelings j b allowed j arc
directly allowed arc paths j montanari proven ensure
path consistency complete graph suces check every arc path length two
montanari path consistency pc han lee worstcase running time n l time n number variables csp

multiply segmented constraint satisfaction

many types solved csp less direct
fashion might benefit csp
dicult represent single csp class addresses
example suppose map represented figure scanned noisy computer
vision system resulting uncertainty whether line regions
really border artifact noise situation would yield two csp
depicted figure brute force would solve
would reasonable scenes containing ambiguous borders however
number ambiguous borders increases number csp networks would grow
combinatorially explosive fashion case ambiguous segmentation
ecient merge constraint networks single network would compactly
represent instances simultaneously shown figure notice csp
instances combined directed acyclic graph paths dag
start end correspond csps combined develop
extension csp called muse csp mu ltiply se gmented c onstraint atisfaction
p roblem represents multiple instances csp dag
multiple similar instances csp separately applying constraints
instance much duplicated work avoid duplication
provided way combine multiple instances csp muse csp


fihelzerman harper

red green blue

red green blue






different
color





red green blue






different
color



different
color




red green blue

red green blue





different
color

figure ambiguous map yields two csp

start

red green blue

different
color

different
color


red green blue


red green blue

different
color



red green
blue

different
color

different
color











end

red green blue

red green blue

red green blue

different
color

red green blue

different
color

figure two csp figure captured single instance
muse csp directed edges form dag directed paths
dag correspond instances csps combined



fimuse csp extension constraint satisfaction

developed concepts muse node consistency muse arc consistency muse path
consistency formally define muse csp follows

definition muse csp
n j g set nodes variables jn j n
n set segments jj
l fa b g set labels jlj l
li faja l admissible least one segmentg
r unary constraint admissible r
r binary constraint j b admissible r j b
segments different sets nodes representing csp instances
combined form muse csp solution muse csp defined solution
one segments

definition solution muse csp solution muse csp assignment
segment ip g li lip r ix ix holds
every node ix r ix ix iy iy holds every pair nodes ix iy
ix iy
depending application solution muse csp could set
consistent labels single path muse csp single set labels
paths csps compatible sets labels paths
muse csp solved modified backtracking finds
consistent label assignment segment however constraints suciently
tight search space pruned enforcing local consistency conditions node
arc path consistency gain eciency resulting enforcing local consistency
conditions backtracking node arc path consistency must modified muse
csp definitions muse csp node consistency arc consistency path consistency
appear definitions respectively

definition muse node consistency instance muse csp said node consistent
node domain li contains labels unary constraint r holds
e
n li r
definition muse arc consistency instance muse csp said muse arc consis

tent every label domain li least one segment whose nodes
domains contain least one label b binary constraint r holds e

n li j j b lj r j b

definition muse path consistency instance muse csp said path consistent


j n j li b lj j k k k j p ath k j
r j b c lk r k c r k c j b


fihelzerman harper



b



c

start



e



e



end



b


e

b
e

c
e

b
e

start

end




b




f

f
c

b


b
f

c
f

b



b
f

f




figure muse csp muse arc consistency achieved b muse csp
muse arc consistency achieved
muse csp node consistent segments node consistent unfortunately
muse csp arc consistency requires attention enforcing arc consistency
csp label li eliminated node whenever domain lj
labels together satisfy binary constraints however muse csp
label eliminated node must unsupported arcs every
segment appears required definition muse arc consistency shown
definition notice definition reduces definition number segments
one
demonstrate muse arc consistency applies muse csp consider muse
csp figure notice label c l supported labels l
l receive support labels l label considered
muse arc consistent answer node member paths
dag contain node node neither support label
c segment nodes label supports
c c eliminated l c eliminated l eliminated
l elimination c l causes loose support node
since node member every path segment provides support
muse arc consistent dag depicted figure b note muse arc consistency
ensure individual segments arc consistent csps example figure
muse arc consistent even though segments csp arc consistent
c receives arc support local computation arcs least
one paths cannot ensure values support label
mutually consistent considering muse arc consistency alone case muse path
consistency together muse arc consistency would needed eliminate illegal
labels c
enforcing path consistency csp r j b becomes false third
node k label c lk r k c r k c j b true


fimuse csp extension constraint satisfaction

c
e

b
e



c

start



e

end



b


f

c

b

b
f

c
f

figure muse csp muse arc consistent arc consistent
segment
muse csp binary constraint becomes path inconsistent one segment could still
allowed another therefore definition muse path consistency modified
shown definition
enforcement muse arc path consistency requires modification traditional
csp described introduce several applications
muse csp proven useful

muse csp constraint parsing
desirable represent muse csp directed acyclic graph dag
directed paths dag correspond instances csp often
easy determine variables shared construct dag
application presented section one muse csp useful parsing
naturally represented dag presence ambiguity many
cases word multiple parts speech convenient represent
words nodes muse csp speech recognition systems identification
correct words sentence improved syntactic constraints however word
recognition often produces lattice word candidates clearly individually
parsing sentences lattice inecient

parsing constraint dependency grammar
maruyama developed grammar called constraint dependency grammar cdg
maruyama b c showed cdg parsing cast
csp finite domain constraints used rule ungrammatical sentences
cdg four tuple h r l c


fihelzerman harper

finite set preterminal symbols lexical categories
r finite set uniquely named roles role ids fr rp g
l finite set labels fl lq g
c finite set constraints assignment must satisfy

sentence w w w wn string length n word wi
sentence must keep track p different roles variables role variable
takes role values form l l l fnil ng role values
denoted examples label modifiee parsing label l indicates different
syntactic function value role value l assigned particular
role wi specifies position word wi modifying takes
function specified label l e g subj indicates word label
subject modifies third word sentence sentence said
generated grammar g exists assignment maps role value
n p roles constraint set c described next paragraph
satisfied
constraint set logical formula form x x xa p p pm
xi ranges role values roles word
subformula pi c must form antecedent consequent antecedent
consequent predicates predicates joined logical connectives
basic components used express constraints

variables x x xa maruyama
constants elements subsets l r fnil ng n corresponds
number words sentence

functions
pos x returns position word role value x
rid x returns role id role value x
lab x returns label role value x
mod x returns position modifiee role value x
cat returns category e element word position
predicates
logical connectives
subformula pi called unary constraint contains one variable binary constraint contains two cdg grammar two associated parameters degree
arity degree grammar g number roles arity grammar
corresponds maximum number variables subformulas c
consider example grammar g defined following four tuple
h fdet noun verbg r fgovernorg l fdet root subjg c see constraints
figure g degree one arity two illustrate process parsing
note nil nil false nil integer muse networks relate position
intervals



fimuse csp extension constraint satisfaction

constraint satisfaction figure shows steps parsing sentence dog
eats simplify presentation example grammar uses single role
governor role denoted g constraint network figure governor
role indicates function word fills sentence governed head word
word called head phrase forms basis phrase e g verb
head sentence useful grammars would include several needs roles
e g need need make certain head word constituents needs
complete e g singular count noun needs determiner complete noun phrase
determine whether sentence dog eats generated grammar cdg
parser must able assign least one role value n p roles satisfies
grammar constraints n sentence length p number roles
values role selected finite set l fnil g cdg parsing
viewed constraint satisfaction finite domain therefore constraint
satisfaction used determine possible parses sentence
initially word possible role values assigned governor role
assume word must modify another word modify
word nil nothing gained cdg word modify next unary
constraints applied role values constraint network role value
incompatible unary constraint satisfies antecedent
consequent notice figure role values associated governor role
first word satisfy antecedent first unary constraint det nil subjnil subj subj root nil root root satisfy consequent
incompatible constraint role value violates unary constraint node
consistency eliminates role values role never participate
parse sentence unary constraints applied top constraint
network figure second network produced
next binary constraints applied binary constraints determine pairs role
values legally coexist keep track pairs role values arcs constructed connecting role roles network arc associated arc matrix
whose row column indices role values associated two roles connects
entries arc matrix indicating two role values indexing
entry compatible indicating role values cannot simultaneously exist initially entries matrix set indicating pair role values
indexing entry initially compatible constraints applied
example single binary constraint shown figure applied pairs
role values indexing entries matrices example x det
root nil eats consequent binary constraint fails hence role values
incompatible indicated replacing entry
following binary constraints roles constraint network still contain
role values incompatible parse sentence role values
supported binary constraints eliminated achieving arc consistency
example det supported remaining role value eats thus
deleted role
arc consistency example sentence single parse one
value per role sentence parse sentence consists assignment role values


fihelzerman harper


det


dog

eats

noun


verb


g

g
detnil det det
subjnil subj subj
rootnil root root

g

detnil det det
subjnil subj subj
rootnil root root

detnil det det
subjnil subj subj
rootnil root root

cat pos x det
cat pos x noun
lab x det
lab x subj
pos x mod x
pos x mod x

apply unary constraints
enforce node consistency

cat pos x verb
lab x root
mod x nil

det


dog

eats

noun


verb


g

g

g
subj

det det

rootnil
rootnil

subj
det



det



subj



rootnil
det



det



lab x det
mod x pos
cat pos noun

apply binary constraints


det


dog

eats

noun


g

verb


g

g
subj

det det

rootnil
rootnil

subj
det



det



subj



rootnil
det



det



enforce arc consistency


det


dog

eats

noun


verb


g

g

det

subj

g
rootnil

figure constraints parse sentence dog eats


fimuse csp extension constraint satisfaction

roles unary binary constraints satisfied assignment
general one parse sentence hence one
assignment values roles sentence note assignment example
sentence

pos word cat governor role value
det
det
dog noun
subj
eats verb
root nil
one possible sentence part speech words
known advance parsing cast csp however
ambiguity present written spoken sentences handled uniformly requires use
muse csp

processing lexically ambiguous sentences cdg
one shortcoming maruyama constraint parser requires word
single part speech however many words english language one
lexical category assumption captured way maruyama writes constraints
involving category information category determined position
word sentence however even simple example word dog could
noun verb prior propagation syntactic constraints since parsing
used lexically disambiguate sentence ideally parsing
require part speech words known prior parsing
lexically ambiguous words easily accommodated creating csp
possible combination lexical categories however would combinatorially explosive
contrast muse csp create separate word node legal part
speech word sharing words ambiguous across segments since
position uniquely define category word must allow category information
accessed role value rather position word sentence
e use cat x rather cat pos x associate category information
role value could instead create role values lexical category word
store values single word node however representation
convenient muse csp representation lexically augmented
csp one role per word usually case role values
associated one lexical category one role cannot support role values associated
another lexical category another role word additional constraints
must propagated enforce requirement muse csp representation
suffer separate node part speech muse csp
directly represents independence alternative lexical categories given word
space requirements arc matrices muse representation lower
lexicalized csp arc roles different lexical categories
word muse representation note muse arc consistency equivalent
performing arc consistency lexically augmented csp additional constraints


fihelzerman harper

propagated importantly muse csp represent lattices cannot
combined single csp
technique creating separate nodes different instances word
used handle feature analysis number person parsing harper helzerman
b since words multiple feature values often ecient create
single node set feature values apply syntactic constraints split node
set nodes single feature value prior applying constraints pertaining
feature type node splitting used support use context specific
constraints harper helzerman b

lattice example

much motivation extending csp comes work spoken language parsing
harper helzerman harper jamieson zoltowski helzerman zoltowski
harper jamieson helzerman output hidden markov model
speech recognizer thought lattice word candidates unfortunately
lattice contains many word candidates never appear sentence covering
duration speech utterance converting lattice word graph many word
candidates lattice eliminated figure depicts word graph constructed
simple lattice notice word tour eliminated word graph
constructed order accommodate words occur time intervals may
overlap word position lattice represented tuple b e
b e positional relations defined constraints easily modified operate
tuples harper helzerman
construction word graph often contains spurious sentence hypotheses
pruned variety constraints e g syntactic semantic etc
apply constraints individual sentences rule ungrammatical however
individually processing sentence hypothesis inecient since many high degree
similarity spoken language parsing structured muse csp
constraints used parse individual sentences would applied word graph
sentence hypotheses eliminating consideration many hypotheses
ungrammatical
developed muse csp constraint parser parsec harper helzerman b harper et al zoltowski et al capable parsing
word graphs containing multiple sentences produced speech recognition module
developed syntactic semantic constraints parsing single sentences
applied word graph eliminate hypotheses syntactically semantically
incorrect muse csp used parser thought parse forest
pruned constraints applying constraints wide variety knowledge
sources parser prunes composite structure many role values associated
role well word nodes remaining role values several experiments
harper et al zoltowski et al considered effective syntactic
simple demonstration consider merging nodes figure single node
value e f keep track fact type respectively circumstances
csp arc consistency give muse csp arc consistency even though c appear
solutions eliminated note example uses one role per node



fimuse csp extension constraint satisfaction

tour


wreck
hard






nice

beach


recognizes









wreck







hard

start








speech







nice







beach





end

recognizes


speech


figure multiple sentence hypotheses parsed simultaneously applying constraints word graph rather individual sentences extracted
lattice
semantic constraints pruning word nodes appear sentence hypothesis
work speech processing muse arc consistency effective
pruning role values composite structure never appear parse
sentence e individual csp constraints usually tight enough muse
arc consistency eliminates role values participate least one parse
represented sentences
muse csp useful way process multiple sentences arc consistency
effective eliminating role values cannot appear sentence parses
several factors contribute effectiveness arc consistency
first syntactic constraints fairly tight constraints second role
values contain segmental information constrain consider word
graph figure value associated role marked n word
cannot support values role marked g word dogs position
legal segment involving position figure mark
entries value associated one role segmentally incompatible values
another n entries equivalent third many times constraints
create symmetric dependencies words sentence example one constraint
might indicate verb needs subject left another subject must
governed verb right

demonstration utility muse csp parsing

demonstrate utility muse csp simultaneously parsing multiple csp instances
consider determining strings length n consisting b c


fihelzerman harper

obj obj


n

n







obj
obj

rootnil

g

start

n

g

n

n npnil

g
dogs





end

blanknil
subj
subj
subj






obj
obj

g

n np
np
dog


obj obj








n

n

figure parsing word graphs values assigned roles contain segmental
information make incompatible values associated
roles example cannot support values associated
g n roles word dogs
language bn cn value n represented
single muse csp shown figure roles role values depicted
simplify figure devised constraints language see figure
eliminate role values sentences language well ungrammatical
role values sentence language constraints applied followed
muse arc consistency lattice figure length divisible three
grammatical sentence remain single parse lattices containing
sentences lengths divisible three role values eliminated
muse arc consistency grammatical sentence hence search
required extract parse one n case figure parse appears
figure single parse regardless n chosen note modifiees
role values parse used ensure corresponding
c b corresponding c corresponding b figure
examines time needed extract parse sentences language bn cn
muse csps representing strings length n n containing b c
time perform muse ac extract solution compared time extract
solution without preprocessing time perform muse ac extract
parse stable sentence length grows time extract parse grows quickly
sentence lengths greater muse arc consistency used
previous example involves grammar one parse single
sentence lattice however simple matter provide similar demonstrations


fimuse csp extension constraint satisfaction

start





































b

b

b

b

b

b

b

b

b



















c

c

c

c

c

c













c

c

c







end

figure single muse csp simultaneously test possible orderings b
c membership language anbncn n



fa b cg
fgovernorg
l fa b cg
c see
r

unary constraints





cat
rid
lab
mod

x
x
x
x


governor

pos x






cat
rid
lab
mod

x
x
x
x

c
governor
c
pos x






cat
rid
lab
mod

x
x
x
x

b
governor
b
pos x

binary constraints
lab x
lab b
lab c
pos x pos

lab x b
lab c
pos x pos




mod

lab x
lab
pos x
x mod



pos





lab




mod

lab x
lab
pos x
x mod

b
b
pos


lab x b
mod x pos
rid governor
lab




mod

lab x
lab
pos x
x mod

c
c
pos





lab

lab x
mod x pos
rid governor
c

lab x c
mod x pos
rid governor
b

figure g h r l c accepts language bn cn n


fihelzerman harper

pos










cat governor role value



b
b
b
c
c
c




b
b
b
c
c
c

figure single parse remaining network depicted figure applying
constraints g enforcing muse arc consistency



cpu time seconds



extract without muse ac






extract plus muse ac













lattice length









figure graph depicts time extract parse language bn cn
muse csp representing sentences length n n varies
time extract parse without muse arc consistency compared
time perform muse ac extract parse



fimuse csp extension constraint satisfaction



fa b cg
fgovernorg
l fw w g
c see
r

unary constraints
lab x w
pos x mod

lab x w
pos x mod
binary constraints

lab x w
lab w
pos x pos



mod

lab x
lab
pos x
x mod

w
w
pos







lab
mod
lab
cat

w
pos
w
cat

x
x

x

lab x w
lab w
mod x mod
lab x w
lab w
pos x pos
mod x mod
lab x w
mod x pos
lab w

figure g h r l c accepts language ww
complex cases example constraint grammar shown figure
parse possible sentences given length language ww w
fa b cg consider muse csp figure roles role values
depicted simplify figure applying constraints performing muse arc
consistency muse csp precisely strings ww
parses compactly represented constraint network constraints plus muse
arc consistency eliminate every value cannot appear parse lattices containing
odd length sentences role values remain muse arc consistency figure shows
time needed extract parses sentences language ww
muse csps vary length w time perform muse ac
extract parses grows slowly sentence length increases number parses
increases sentence length however grows slowly time extract
parses muse arc consistency used
similar obtained grammars used parse word graphs constructed spoken sentences resource management atis domains harper
et al zoltowski et al harper helzerman

muse csp arc consistency
section introduce muse ac achieve muse csp arc consistency builds upon ac mohr henderson
present first comparison purposes


fihelzerman harper

start

































b

b

b

b

b

b

b

b

















c

c

c

c

c

c













c

c





end

figure single muse csp simultaneously test possible orderings b
c membership language ww jwj



cpu time seconds




extract without muse ac





extract plus muse ac









lattice length







figure graph depicts time extract parses language ww
muse csp representing sentences length w fa b cg
time extract parses without muse arc consistency compared
time perform muse ac extract parses



fimuse csp extension constraint satisfaction

notation

meaning

ordered pair nodes
node pairs j j e j e
e
ordered pair node label li

faja l permitted constraints e admissible g
li
r j b indicates admissibility li b lj given
r j b
binary constraints
counter j number labels lj compatible li
j b means li b lj simultaneously

admissible implies supports b
indicates label admissible

already eliminated node
queue arc support deleted
list
j

figure data structures notation arc consistency ac

csp arc consistency ac
ac builds maintains several data structures described figure allow
eciently achieve arc consistency csp note modified notation
slightly eliminate subscripts become quite cumbersome path consistency
figure shows code initializing data structures figure
contains eliminating inconsistent labels domains
requires el time e number constraint arcs l domain size mohr
henderson
ac label li compatible b lj supports b vice
versa keep track much support label number labels lj
compatible li counted total stored counter j
figure counter j zero removed li
cannot appear solution ordered pair placed list
set avoid removing element li
must keep track labels label supports set arc
label pairs example f j b j c g means li supports b c lj
ever removed li b c loose support
preprocessing step figure figure loops list
becomes empty point csp arc consistent popped list
procedure element j b counter j b decremented
counter j b becomes zero b would removed lj j b placed list
j b set


fihelzerman harper

list
n

li f



g
j e

li f

total

b lj

r j b f

total total

j b j b f g g

total f

li li fag

list list f g

g

counter j total g

figure initialization data structures ac

list f

pop list

j b f

counter j b counter j b

counter j b j b f

lj lj fbg

list list f j b g

j b g g g

figure eliminating inconsistent labels domains ac



fimuse csp extension constraint satisfaction

next describe muse arc consistency muse csp called muse
ac purposely keep notation presentation muse ac close possible
ac reader benefit similarity two

muse ac

muse arc consistency enforced removing labels li violate conditions definition muse ac builds maintains several data structures described
figure allow eciently perform operation many data structures
borrowed ac others exploit dag representation muse csp
determine values incompatible segments figure shows
code initializing data structures figures contain
eliminating inconsistent labels domains
muse ac ac label node compatible label b node j
supports b keep track much support label number labels lj
compatible li counted total stored counter j
csp arc consistency counter j zero would immediately removed
li would mean could never appear solution however muse
arc consistency may case even though participate
solution segments contain j could another segment
would perfectly legal label cannot become globally inadmissible
incompatible every segment hence muse csp counter j zero
simply places j list records fact setting j
placing j list indicating segments containing
j support label
muse ac must keep track labels j label li supports
j set node label pairs example j f j b j c g means
li supports b c lj ever invalid li b c loose
support
dag muse ac able use properties dag identify
local hence eciently computable conditions labels become globally
inadmissible segments defined paths muse csp start end
value associated variable supported variables precede
follow way value used segment
deleted arc consistency addition value variable domain
supported constraints values associated second variable second
variable preceded followed variables values supporting value
solution involves path variables muse dag value cannot
supported segment involving two variables two ideas provide basis
remaining data structures used muse ac
consider figure shows nodes adjacent node dag
every segment dag contains node represented directed path
dag going node node j node k must every segment containing
hence label remain li must compatible least one label
lj lk n must contained every segment containing


fihelzerman harper

notation

meaning

j

ordered pair nodes
node pairs j exists path directed edges g
j j e j e
ordered pair node label li

e


j

ordered pair node pair j label li
faja l permitted constraints e admissible g

li

j b

r

counter j
j
j
list

g

next edgei
prev edgei
local prev support
local next support
prev support j
next support j

j b indicates admissibility li b lj given
binary constraints
number labels lj compatible li
j b j means li b lj simultaneously
admissible implies supports b
j indicates label admissible
already eliminated segments containing j
queue arc support deleted
g set node pairs j exists directed
edge j
next edgei contains node pairs j exists
directed edge j g contains end last node
segment
prev edgei contains node pairs j exists
directed edge j g contains start first node
segment
set elements j j prev edgei j start
must compatible least one j labels
local prev support becomes empty longer admissible
set elements j j next edgei j end
must compatible least one j labels
local next support becomes empty longer admissible
k prev support j implies k j prev edgej
k start li compatible least one j
one k labels prev support j becomes empty
longer admissible segments containing j
k next support j implies j k next edgej
k end li compatible least one j
one k labels next support j becomes empty
longer admissible segments containing j
r

figure data structures notation muse ac



fimuse csp extension constraint satisfaction

n

j




k


localprevsupport n
localnextsupport j

figure local prev support local next support example dag sets indicate label allowed every segment contains n j
disallowed every segment contains k solid directed lines
members g solid undirected lines represent members e

label remain li must compatible least one label
ln lm
order track dependency two sets maintained label node
local next support local prev support local next support set
ordered node pairs j j next edgei j e least one
label b lj compatible local prev support set ordered pairs
j j prev edgei j e least one label b lj
compatible dummy ordered pairs created handle cases node
beginning end network start prev edgei start added
local prev support end next edgei end added local nextsupport prevent label ruled nodes precede
follow dag whenever one adjacent nodes j longer labels b
domain compatible j removed local prevsupport local next support depending whether edge j
j respectively local prev support local next support
becomes empty longer part muse arc consistent instance
eliminated li figure label admissible segments containing
j segments containing k constraints
labels j become inconsistent j would eliminated local nextsupport leaving empty set case would longer supported

segment
utilize similar conditions nodes directly connected
next edgei prev edgei consider figure suppose label node
compatible label lj incompatible labels lx ly
reasonable eliminate segments containing j segments
would include node x determine whether label admissible
set segments containing j calculate prev support j nextsupport j sets next support j includes k arcs support


fihelzerman harper

z


x
j

w



figure next edgej f j x j g counter x counter
inadmissible every segment containing j solid directed lines members g solid undirected lines represent members
e
given directed edge j k j supports prev support j
includes k arcs support given directed edge k
j j supports note prev support j contain ordered pair
j j prev edgej next support j contain ordered pair j
j next edgej elements included edge nodes
j sucient allow j labels support segment containing j dummy
ordered pairs created handle cases node beginning end
network start j prev edgej start added prev support j
j end next edgej end added next support j prevent
label ruled nodes precede follow dag
figure shows prev support next support local next support local prevsupport sets initialization creates simple example dag
initialization step sets contain node pairs allowed connectivity g later consistency step node pairs support
associated label eliminated set
illustrate data structures used second step muse ac shown
figure consider happens initially list muse csp depicted
figure placed list indicate label l supported
labels associated node value popped list necessary
x decrement counter x one counter x
becomes x already placed list added future
processing done necessary remove uence muse
dag handle examine two sets prev support f g


fimuse csp extension constraint satisfaction

























list
e f j j j j j n g
j e
li f
j
j
local prev support local next support
prev support j next support j g
j e
li f

total

b lj
r j b f

total total
j b j b f g g
total f
list list f j g
j g
counter j total
prev support j f x j x e x j prev edgej g
f j j j prev edgej g
f start j start j prev edgej g
next support j f x j x e j x next edgej g
f j j j next edgej g
f end j j end next edgej g
local prev support f x j x e x prev edgei g
f start j start prev edgei g
local next support f x j x e x next edgei g
f end j end next edgei g g
c



start





b

end


prev support f g
prev support f g
prev support b f g
prev support b f g
prev support c f start g
prev support c f g
prev support f start g
prev support f g
local prev support f start g
local prev support b f start g
local prev support c f g
local prev support f g

next support f g
next support f end g
next support b f g
next support b f end g
next support c f g
next support c f end g
next support f g
next support f g
local next support f g
local next support b f g
local next support c f g
local next support f end g

figure initialization data structures muse ac along simple example


fihelzerman harper

list f

pop j list

j b j f

counter j b counter j b

counter j b j b f

list list f j b g

j b g g

update support sets j see figure g

figure eliminating inconsistent labels domains muse ac
update support sets j f
x prev support j x j x start f

prev support j prev support j f x g

next support x next support x f j g

next support x x f

list list f x g

x g g
x next support j x j x end f

next support j next support j f x g

prev support x prev support x f j g

prev support x x f

list list f x g

x g g
j prev edgei
local prev support local prev support f j g
local prev support f
li li fag
x local next support x j x end f

local next support local next support f x g

x f

list list f x g

x g g g
j next edgei
local next support local next support f j g
local next support f
li li fag
x local prev support x j x start f

local prev support local prev support f x g

x f

list list f x g

x g g g g

figure function update support sets j muse ac


fimuse csp extension constraint satisfaction

next support f end g note value end next support
value prev support require action
dummy values however value prev support indicates
member next support since admissible
removed next support leaving empty set note nextsupport empty assuming added list
processing next removed local next support leaving set
f g next iteration loop popped list
prev support next support processed next support
prev support contains dummy requiring action finally
removed local next support set becomes empty longer compatible segment containing node eliminated consideration
possible label node eliminated node necessary remove
support l labels nodes precede node nodes x
x local prev support since local prev support f start g
start dummy node work done
contrast consider happens initially list muse csp
figure case prev support contains requires additional
work whereas next support contains indicating must removed
prev support set removal prev support non empty
segment containing nodes still supports label l reason
two cases provide different constraint arc nodes
contained every segment whereas constraint arc nodes found
one

running time space complexity muse ac
worst case running time routine initialize muse ac data structures
figure n l n l n number nodes muse csp l
number labels given number j elements e n
domain size l size counter arrays n l determine
number supporters given arc label pair requires l work hence initializing
counter arrays requires n l time however n l prev support
next support sets prev support j next support j requires
n time compute time calculate prev support next support sets
n l finally time needed calculate local next support local prevsupport sets n l nl sets n elements per set
worst case running time prunes labels muse
arc consistent figures operates n l n l time clearly
counter array contains n l entries similar argument made array
keep track counter j l magnitude
never become negative maximum running time line figure
given elements appear list n l
n l next support prev support lists n size maximum
running time required lines figure n l finally since nl


fihelzerman harper


csps
muse csp

nodes
degree
number
number
per path node splitting constraint networks nodes

n
n

kn

k
k



n
kn

asymptotic
time

kn n l

kn l kn l

table comparison space time complexity muse arc consistency
muse csp arc consistency multiple csps representing node splitting
e g lexical ambiguity parsing
local prev support local next support sets eliminate n elements
maximum running time lines figure n l hence maximum
running time muse csp arc consistency n l n l
space complexity muse csp ac n l n l arrays
counter contain n l elements n l sets containing l
items n l prev support next support sets containing n items nl
local next support local prev support sets containing n items
comparison worst case running time space complexity csp arc consistency n l assuming n constraint arcs note applications
l n worst case running times order
true parsing spoken language muse csp representable planar
dag terms prev edge next edge e running times two
order average number values prev support
next support would constant hand compare muse csp
use multiple csps k alternative variables particular
variable csp muse csp ac asymptotically attractive shown
table

correctness muse ac

next prove correctness muse ac
theorem label eliminated li muse ac label
unsupported arcs x every segment

proof
must label eliminated inadmissible every segment
label eliminated domain muse ac see lines figure
local prev support set local next support set becomes empty
see lines figure case label eliminated
make muse csp instance muse arc consistent prove label
local support sets become empty label cannot participate muse arc
consistent instance muse csp proven local next support localprev support follows symmetry observe li unsupported


fimuse csp extension constraint satisfaction

nodes immediately follow dag cannot participate
muse arc consistent instance muse csp line figure j
removed local next support set j must popped
list removal j local next support indicates
segment containing j li inadmissible remains shown
j put list li unsupported every segment contains
j proven induction number iterations loop
figure
base case initialization routine puts j list li incompatible every label lj line figure therefore li unsupported
segments containing j
induction step assume start kth iteration loop
x c ever put list indicate c lx inadmissible
every segment contains x remains kth
iteration j put list li unsupported every segment
contains j several ways j put
list
labels lj compatible li eliminated
item could placed list initialization see line
figure previous iteration loop see line figure
csp ac obvious case li
inadmissible every segment containing j
b prev support j see line figure indicating li
incompatible nodes k k j prev edgej way
j placed list reason line tuples
form k k j prev edgej already put list
induction hypothesis k items placed list
li inadmissible segments containing k dag
supported node immediately precedes j dag
unsupported every segment contains j therefore correct
put j list
c next support j see line figure indicating li
incompatible nodes k j k next edgej way j
placed list line reason tuples form
k j k next edgej already put list induction
hypothesis k items placed list li inadmissible segments containing k dag supported
node immediately follows j dag inadmissible
every segment contains j therefore correct put j list
local next support see line figure indicating li
incompatible nodes k k next edgei way
j placed list line reason node
follows dag supports pairs k legally removed


fihelzerman harper













c



b



local prev support j
local next support k

j



k

b

prev support j nonempty
c


c

prev support k k



next support k nonempty



b



next support j j



figure li muse ac must preceded node j followed
node k support
local next support previous iterations
segment containing supports follows segment containing
j supports label
e local prev support see line figure indicating li
incompatible nodes k k prev edgei way
j placed list line reason node
precedes dag supports pairs k legally
removed local prev support previous iterations
segment containing supports follows segment containing
j supports label
beginning k th iteration loop every x c list
implies c supported segment contains x therefore
induction true iterations loop figure hence
label local support sets become empty label cannot participate muse arc
consistent instance muse csp
must eliminated li muse arc consistency
must muse arc consistent muse arc consistent
must exist least one path start end goes node
nodes n path contain least one label compatible
li deleted muse ac local next support
local prev support hence must preceded followed least
one node supports li otherwise would deleted depicted
figure know must node j precedes
start must contain least one label b supports nextsupport j prev support j must non empty similarly must
node k follows end must contain least one
label c supports next support k prev support k must
non empty


fimuse csp extension constraint satisfaction

path dag must path beginning
start reaches nodes along path support li
path beginning reaches end nodes along
path support li necessity path end
nodes along path support li given remains muse ac
necessity path start shown similar way
base case li muse ac must exist least one node
follows say k k never placed list hence
r k c least one c lk next support k prevsupport k must non empty
induction step assume path n nodes follows supports
li none nodes end node implies n
nodes contains least one label compatible next support n
prev support n must non empty n nodes
next path length n must support li otherwise
label would deleted muse ac already noted
nth node path induction step next support n must
non empty hence must exist least one node say n follows nth
node path length n supports li n end node
case n end way n member
next support n n placed list
r n l least one l ln next support n prevsupport n must non empty case n would
removed next support n n would longer support li
hence li muse ac must path nodes end
node n end node r n l least one l ln
next support n prev support n must non empty hence
muse arc consistent




theorem may conclude muse ac builds largest muse arc
consistent structure muse arc consistency takes account segments
single csp selected muse csp muse arc consistency enforced
csp arc consistency could eliminate additional labels

profile muse ac

given fact muse ac operates composite data structure benefits
high payoff individually processing csps section
provided several examples payoff obvious gain insight factors
uencing effectiveness muse csp conducted experiment
randomly generate muse csp instances two different graph topologies tree
topology characterized two parameters branching factor many nodes follow
non leaf node tree path length many nodes path
root node leaf node lattice topology characteristic muse csp


fihelzerman harper

produced hidden markov model spoken language recognition system
constraint parser lattices characterized length
branching factor
experiment examined trees path length four branching
factor two three lattices path length four branching factor
two three initialized variable labels randomly
generated constraints network varying probability r j b
steps probability instances generated lower
probability r j b tighter constraints note probability
constraint two nodes understood probability constraint
two nodes given constraint allowed example nodes
level tree topology different segments constraints
cannot occur
experiment displayed figures four
panels figure four curves displayed muse ac appears curves
displaying average number labels remaining muse ac applied instances
muse csp probability constraint varies curves labeled solution
indicate average number labels remaining muse ac used
solution csp ac associated curves display number labels remain
least one segment segment extracted muse csp csp
arc consistency applied unused indicates difference number labels
remain muse ac number csp arc consistent least one
segment
topologies probability r j b low e g high
e g muse ac tracks performance arc consistency performed
individual instances topology however topology impact range
low high probabilities true constraints randomly generated
muse ac performed tree topology fewer remaining values lattice
topology csp arc consistent suggest muse csp ac may
effective topologies others however tree topology
randomly generated constraints values two variables independent
probabilities generated case lattice pair variables
set randomly generated constraints shared paths lattice
notice increasing number values domain seems impact
tree increasing branching factor probably branching factor
increases number independent nodes
experiment tightly constrained muse ac
effectively used eliminate values unsupported constraints clearly
case parsing presented section small set syntactic
constraints effectively eliminates values never used parse sentence
even lattice branching factor three arbitrarily long paths


fimuse csp extension constraint satisfaction

tree branching factor path length labels per variable variables

b tree branching factor path length labels per variable variables


average number role values per role

average number role values per role




muse ac


csp ac



solution






muse ac


csp ac


solution



unused

unused













probability r j b










c tree branching factor path length labels per variable variables











average number role values per role




muse ac


csp ac



solution






muse ac
csp ac



solution





unused







probability r j b

tree branching factor path length labels per variable variables



average number role values per role













probability r j b

unused



















probability r j b







figure simulation trees path length branching factor
labels per variable



fihelzerman harper

lattice branching factor path length labels per variable variables

b lattice branching factor path length labels per variable variables




muse ac

average number role values per role

average number role values per role

csp ac
muse ac




solution





unused














probability r j b







solution





unused







c lattice branching factor path length labels per variable variables











probability r j b







lattice branching factor path length labels per variable variables




muse ac

muse ac

average number role values per role

average number role values per role

csp ac



csp ac




solution







csp ac


solution




unused



unused













probability r j b




















probability r j b







figure simulation lattices path length branching factor
labels per variable



fimuse csp extension constraint satisfaction

local next support b b b e
local next support b b b c b e
local next support b b b c

next support b c b b
next support b c b b f

c
c

start







b

end

b b b
e

f

e

f

figure muse arc consistency data structures guide backtracking search

extracting solutions muse csp muse ac
solutions regular csp typically generated backtracking fancier
search assemble set labels one node consistently
admissible extracting solutions muse csps done similar way
desirable make modifications search take advantage
extra information contained muse ac data structures
consider example shown figure figure presents simple muse csp
suppose interested solutions segment highlighted fa b c
dg suppose one solution segment b b c
c wish solution depth first search
begin assigning however domain b addition desired
label b contains labels b b valid segments
initially naively choose b b continue depth first search would
waste lot time backtracking fortunately enforcing muse arc consistency
muse data structures contain useful information concerning segments
labels valid case backtracking check local next support b
b determine outgoing nodes b compatible since b c
element local next support b b smart search would choose b
label b
however looking local support sets might enough search
rejected b label b would go consider b local nextsupport b b indicates b valid label segments contain
c fails tell us b valid segment examining despite
search still eliminate b looking next support b c b
indicates b compatible segments containing node f clearly
type information effectively guide search solution along certain
path improved search strategies muse csps focus future efforts


fihelzerman harper

muse csp path consistency
section introduce achieve muse csp path consistency muse
pc builds upon pc han lee

muse pc

muse path consistency enforced setting r j b false violates
conditions definition muse pc builds maintains several data structures comparable data structures defined muse ac described figure allow
eciently perform operation figure shows code initializing data structures figures contain eliminating muse path inconsistent
binary constraints
muse pc must keep track labels lk support r j b keep track
much path support r j b number labels lk satisfy
r k c r k c j b counted counter j k b additionally
must keep track set j k b contains members form
k c r k c r k c j b supported r j b r j b
ever becomes false segment containing j k r k c r k c j b
loose support muse pc uses local next support local prevsupport prev support next support sets similar muse ac
muse pc able use properties dag identify local hence
eciently computable conditions binary constraints fail lack path
support consider figure shows nodes adjacent node j
dag every segment dag contains node j represented
directed path dag going node node j node must precede
follow nodes j r j b hold order track dependency two sets
maintained j b tuple local prev support j b local nextsupport j b note distinguish local prev support j b localprev support j b separately keep track elements directly preceding
directly preceding j distinguish local next support j b localnext support j b sets become empty j arc
longer support r j b local prev support j b set ordered node pairs
x x prev edgei x e least one label lx
compatible r j b local next support j b set ordered
node pairs x x next edgei x e least one label
lx compatible r j b dummy ordered pairs created
handle cases node beginning end network start prevedgei start added local prev support j b end next edgei
end added local next support j b
utilize similar conditions nodes may directly connected j consider figure suppose r j b compatible
label lk incompatible labels lx ly r j b
r j b false segments containing j k segments would
include node x determine whether constraint admissible
set segments containing j k calculate prev support j k b prev

fimuse csp extension constraint satisfaction

notation

meaning
ordered pair nodes

j

node pairs j exists path directed edges g
j j e j e
ordered quadruple node pair j node k labels
li b lj

e

j k b

faja l permitted constraints e admissible g

li

j b indicates admissibility li b lj given
binary constraints

j b

r

r

counter j k b
j k b
j k b
list

g

next edgei
prev edgei
local prev support j b
local next support j b
prev support j k b
next support j k b

number labels lk compatible r j b
k c j k b means c lk compatible
r j b
j k b indicates r j b false paths
including j k
queue path support deleted
g set node pairs j exists directed
edge j
next edgei contains node pairs j exists
directed edge j g contains end last
node segment
prev edgei contains node pairs j exists
directed edge j g contains start first
node segment
set elements k k prev edgei k start
r j b must compatible one k labels
local prev support j b becomes empty r j b becomes false
set elements k k next edgei k end
r j b must compatible one k labels
local next support j b becomes empty r j b becomes false
x prev support j k b implies x k prev edgek
x start r j b compatible least one k
one x labels prev support j k b becomes empty
r j b longer true segments containing j k
x next support j k b means k x next edgek
x end r j b compatible least one k
one x labels next support j k b becomes empty
r j b longer true segments containing j k

figure data structures notation muse pc



fihelzerman harper

l

n






p

r
j

q

b



localprevsupport j b l
localprevsupport j b j p j q
localnextsupport j b n
localnextsupport j b j r j

figure local prev support local next support path consistency example dag solid directed lines members g solid undirected
line represents j j members e
support j k b next support j k b next support j k b sets nextsupport j k b includes x arcs support r j b given
directed edge k x r j b r k c r k c j b nextsupport j k b defined similarly prev support j k b includes x arcs
support r j b given directed edge x k r j b
r k c r k c j b prev support j k b defined similarly
note prev support j k b contain ordered pair k k prevedgek j j k prev edgek next support j k b contain ordered
pair k k next edgek j k j next edgek elements included edge nodes sucient allow support dummy
ordered pairs created handle cases node beginning end
network start k prev edgek start added prev support j k b
k end next edgek end added next support j k b

running time space complexity correctness muse pc
worst case running time routine initialize muse pc data structures
figure n l n l n number nodes muse csp l
number labels given number j elements e n domain size
l n l entries counter array determine number
supporters requiring l work hence initializing counter array requires n l
time additionally n l sets determine l values
time required initialize n l determining prev support j k b


fimuse csp extension constraint satisfaction

z

x
c





k
w

j b


figure found next edgek f k x k g counter j x b
counter j b r j b ruled every segment containing j k solid directed lines members g
solid undirected lines represent members e



fihelzerman harper





























list
e f j j j j j n g
j e
li
b lj f
local prev support j b local next support j b
k n k e j k e f
j k b
j k b
prev support j k b next support j k b g g
j e
li
b lj r j b f
k n k e j k e f

total

c lk
r k c r k c j b f

total total
k j c k j c f j b g g
total f
list list f j k b g
j k b g
counter j k b total
prev support j k b
f x j x e x j j x e x k prev edgek g
f k j k prev edgek g
f start j start k prev edgek g
next support j k b
f x j x e x j j x e k x next edgek g
f k j k next edgek g
f end j k end next edgek g g
local prev support j b
f x j x e x j j x e x prev edge ig
f start j start prev edgei g
local next support j b
f x j x e x j j x e x next edgei g
f end j end next edgeig g

figure initialization data structures muse pc



fimuse csp extension constraint satisfaction

list

pop j k b list

k c j k b f

counter k j c counter k j c

counter k j c counter k j c

counter k j c k j c f

list list f k j c k j c g

k j c k j c g g

update support sets j k b see figure g

figure eliminating inconsistent binary constraints muse pc
update support sets j k b f
x prev support j k b x j x k x start f

prev support j k b prev support j k b f x g

next support j x b next support j x b f k g

next support j x b j x b f

list list f j x b j x b g

j x b j x b g g
x next support j k b x j x k x end f

next support j k b next support j k b f x g

prev support j x b prev support j x b f k g

prev support j x b j x b f

list list f j x b j x b g

j x b j x b g g
k prev edgei
local prev support j b local prev support j b f k g
local prev support j b f
r j b r j b
x local next support j b x j x k x end f

local next support j b local next support j b f x g

j x b f

list list f j x b j x b g

j x b j x b g g g
k next edgei
local next support j b local next support j b f k g
local next support j b f
r j b r j b
x local prev support j b x j x k x start dof

local prev support j b local prev support j b f x g

j x b f

list list f j x b j x b g

j x b j x b g g g g

figure function update support sets j k b muse pc


fihelzerman harper


csps
muse csp

nodes
degree
number
number
per path node splitting constraint networks nodes

n
n

kn

k
k



n
kn

asymptotic
time

knn l

kn l kn l

table comparison space time complexity muse path consistency
muse csp path consistency multiple csps representing node splitting
e g lexical ambiguity parsing
next support j k b requires n time time required calculate
prev support next support sets n l finally time needed calculate
local next support local prev support sets n l n l sets
n elements per set
worst case running time enforces muse path consistency
figures operates n l n l time clearly n l
entries counter array keep track counter j k b
l magnitude never become negative maximum running
time lines figure given elements appear list
n l n l prev support next support lists
n size maximum running time required eliminate n elements
support sets n l finally since n l local next support
local prev support sets eliminate n elements worst case time
eliminate items local sets n l hence worst case running time
muse csp path consistency n l n l
space complexity muse csp pc n l n l arrays
counter contain n l elements n l sets containing
l items n l prev support next support sets containing n items
n l local next support local prev support sets containing n items
comparison worst case running time space complexity csp path consistency pc n l note applications representable planar dag
l n worst case running times order compare
muse csp use multiple csps k alternative variables
particular variable csp muse csp path consistency asymptotically
attractive shown table
proof correctness muse pc similar proof muse ac
brie outline proof binary constraint looses support muse
pc see lines figure local prev support set local nextsupport set becomes empty see lines figure respectively case
inadmissible muse path consistent instance prove constraint local
support sets become empty cannot participate muse path consistent
instance muse csp proven local next support local prev support follows
symmetry observe r j b nodes immediately


fimuse csp extension constraint satisfaction

f j j jg
f j jg







start

end




figure example set csp would good candidate muse
csp lack node sharing
follow similarly j dag incompatible truth constraint
cannot participate muse path consistent instance line figure
k removed local next support j b j k b
popped list removal k local next support j b indicates
segment containing j k support r j b remains shown
j k b put list r j b must false every segment
contains j k proven induction number iterations
loop figure much proof muse ac must
r j b muse pc muse path consistent r j b
muse path consistent must exist least one path start end
goes nodes j nodes n path contain least one label
consistent constraint proof would similar second half proof
muse ac correctness may conclude muse pc builds
largest muse path consistent structure

combining csps muse csp
inherent lattice structure solved
node splitting natural areas application muse csp
exponential number csps replaced single instance muse csp dag
representation inherent section discuss dag construction
application areas would benefit muse csp
obvious construct dag set csp
used segments muse csp example figure illustrates two instances
csp combined single muse csp however muse csp
example would right choice node sharing cannot offset cost
extra muse ac data structures
multiple nodes name csps potentially represented
single node muse csp assume two nodes k k given
name say k two instances csp domain obey
constraints e
lk lk e domains equal
r k r k every lk lk e unary constraints



fihelzerman harper

f j jg
f j jg
f j jg




start

end







start

end





figure example maximal node sharing leads spurious segments
first dag contains two paths f g f g correspond none
segments second dag presents preferred sharing created
create dag routine
r k b r k b labels lk lk b li
segments e binary constraints
however illustrated figure much sharing common nodes introduce
additional segments appear original list csps extra
segments cause extra work done often desirable create dag
shares nodes without introducing extra segments create dag shown
figure takes arbitrary set csp input list segments outputs
dag representation csps shares nodes without introducing spurious
segments create dag calls auxiliary procedure order sigma defined figure
data structures used two routines defined figure
hold individual segments routine create dag uses special data
structure ordered sets supports useful operations segment n
integer n node position n start node
j j end node k ordered subset consisting
nodes positions k addition ordered set allows us insert node
immediately node j already set node pos structure
name field next set field set names nodes follow
node pos set segments
create dag begins adding special purpose start end nodes segment
calls routine order sigma shown figure order nodes
segment order sigma orders nodes segment ones
common tend occur earlier set order elements uses operator
e larger defined nodes note start node defined
largest node end node smallest node addition j means
appears segments j appear number
segments lower ordinal number j thus operator induces total
ordering nodes n
order sigma first called create dag selects largest node
smaller start node constructs set set segments
containing point segments ordered start node first
second calls order sigma order nodes smaller
recursive call done segments considered e z note


fimuse csp extension constraint satisfaction

notation

meaning



set node sets node set represents csp
node set segment set modified include
begin end nodes create dag work
properly note start node jj
end node node pos structure name
next set names nodes follow node dag
g set node pairs j exists
directed edge j dag created create dag
n set nodes placed dag
create dag
z set segments order respect node j
order sigma
node j used order sigma order remaining
elements smaller node
u set nodes already considered current call
order sigma
r set nodes z order sigma
node largest node smaller j r u
non empty r order sigma
order sigma set segments z contain node


g
n
z
j
u
r



figure data structures used create dag order sigma



fihelzerman harper

create dag f





































add start first node end last node every segment
order sigma start
pos maximum segment length f
copy
jj pos f
pos name end f
g g f pos pos g g




else f

edge set f j pos name pos name
pos name pos nameg
next set f pos name j edge setg
edge set
node pos name n f
n n pos
pos next next set
g g f pos pos g g




else f
node get node n name pos name
node next next set f
g g f pos pos g g
else f

node create node
node name concatenate pos name
node get node n named node name one
node node next next set f
node name concatenate node name
node get node n named node name one g
node null
n n node
else node node
node next next set
replace pos name node name pos next
g g f pos node g
replace every occurance pos pos node
segments edge set g g g g g
eliminate start end g g

figure routine create dag represent



fimuse csp extension constraint satisfaction

order sigma z j f
u
z f

r
















z

r u
largest node r u less j
else
largest node r less j
fj z g
z z
end f
f
put j
u u g
order sigma g g g

figure routine arrange nodes within segments convenient merging
first iteration loop preference select largest node
contained segments ordered recursive call order sigma
items independent ordered segments create spurious paths
placed early dag however items occur already ordered segments
placed earlier items occur ordered segments would tend introduce
spurious paths loop continues segments ordered worstcase running time order sigma n n sum cardinalities
segments
order sigma orders nodes segments create dag begins construct dag represented set nodes n set directed edges g
dag constructed going segment beginning position
second element position start loop line looks nodes left
right order one position time elements segment added
g node certain name already placed n e set nodes
already dag created adding node graph well directed
edge pos pos g cannot create spurious paths dag
hand node name pos already placed n
possible current segment could add paths dag correspond
segments avoid adding spurious segments deal segments
one time share previous node node name
current position basic idea add edge keep track nodes
follow node dag easily determine whether
node used occurs another segment later position node
used followed precisely set next nodes follow
node already placed graph otherwise second node would renamed
avoid adding spurious segments event create name node


fihelzerman harper

note dag complete eliminate start end nodes g
corresponding outgoing incoming edges make g consistent use
muse arc consistency muse path consistency running time
create dag n n sum cardinalities segments
even though dags produced routine create dag nice properties
routine probably used starting point custom combining routines
specific intended application area believe domain specific information play important role muse combination example domain specific
combining presented harper et al describes spoken language
parsing system uses muse csp distinguishing feature application combining instead avoiding creation extra segments allows controlled
introduction extra segments extra segments often represent sentences
n best sentence spoken language recognition system would miss

conclusion

conclusion muse csp used eciently represent several similar instances
constraint satisfaction simultaneously multiple instances csp
common variables domains compatible constraints
combined single instance muse csp much work required enforce
node arc path consistency need duplicated across instances especially
constraints suciently tight
developed muse csp constraint parser parsec harper helzerman harper et al zoltowski et al capable parsing word
graphs containing multiple sentence hypotheses developed syntactic semantic
constraints parsing sentences applied word graph eliminate hypotheses syntactically semantically incorrect work speech processing
muse arc consistency effective pruning incompatible labels
individual csps represented composite structure extracting
parses sentences remaining muse csp muse ac usually unnecessary enforce arc consistency csp represented directed path
network tightness syntactic semantic constraints
speech processing area segmenting signal higher level
chunks problematic vision systems handwriting analysis systems comparable
addition allow parallel alternative choices type
variable parsing lexically ambiguous sentences excellent candidates
muse csp
c implementations described available following location ftp transform ecn purdue edu pub speech harper code directory
contains readme file file called muse csp tar z



fimuse csp extension constraint satisfaction

acknowledgements
work supported part purdue foundation grant
intel council would thank anonymous reviewers insightful
recommendations improving

references

bessiere c arc consistency arc consistency artificial intelligence

davis l rosenfeld cooperating processes low level vision survey
artificial intelligence
dechter r local global consistency artificial intelligence
dechter r meiri pearl j temporal constraint networks artificial intelligence
dechter r pearl j network heuristics constraint satisfaction artificial intelligence
freuder e partial constraint satisfaction proceedings international joint
conference artificial intelligence pp
freuder e complexity k tree structured constraint satisfaction
proceedings eighth national conference artificial intelligence pp
han c lee c comments mohr henderson path consistency
artificial intelligence
harper p helzerman r extensions constraint dependency parsing
spoken language processing computer speech language
harper p helzerman r b managing multiple knowledge sources
constraint parsing spoken language fundamenta informaticae

harper p jamieson l h zoltowski c b helzerman r semantics
constraint parsing word graphs proceedings international conference
acoustics speech signal processing pp ii ii
mackworth k consistency networks relations artificial intelligence

mackworth k freuder e complexity polynomial networkconsistency constraint satisfaction artificial intelligence



fihelzerman harper

maruyama h constraint dependency grammar tech rep rt ibm
tokyo japan
maruyama h b constraint dependency grammar weak generative capacity
computer software
maruyama h c structural disambiguation constraint propagation
proceedings annual meeting acl pp
mohr r henderson c arc path consistency revisited artificial intelligence
montanari u networks constraints fundamental properties applications
picture processing information science
van beek p inherent level local consistency constraint networks
proceedings twelfth national conference artificial intelligence pp
villain kautz h constraint propagation temporal reasoning
proceedings fifth national conference artificial intelligence pp
waltz l understanding line drawings scenes shadows winston p
ed psychology computer vision mcgraw hill york
zoltowski c b harper p jamieson l h helzerman r parsec
constraint framework spoken language understanding proceedings
international conference spoken language understanding pp




