journal artificial intelligence

submitted published

hierarchy tractable subsets
computing stable
rachel ben eliyahu

rachel cs bgu ac il

mathematics computer science department
ben gurion university negev
p b beer sheva israel

abstract

finding stable knowledge base significant computational
artificial intelligence task computational heart truth maintenance
systems autoepistemic logic default logic unfortunately np hard
present hierarchy classes knowledge bases

following
properties first
class stratified knowledge bases second knowledge
base
stable may found time
length knowledge base number atoms third
arbitrary knowledge base minimum belongs

time polynomialsin size last k class knowledge bases
case
k every knowledge base belongs class
hierarchy


k

k

lnk



l

n

k



k



introduction
task computing stable knowledge base lies heart three
fundamental systems artificial intelligence ai truth maintenance systems tmss
default logic autoepistemic logic yet task intractable elkan kautz
selman marek truszczynski introduce hierarchy
classes knowledge bases achieves task polynomial time membership
certain class hierarchy testable polynomial time hence given knowledge base
cost computing stable bounded prior actual computation
hierarchy used
first let us elaborate relevance computing stable ai tasks define
knowledge base set rules form

c b bn



c b atoms propositional language substantial efforts
give meaning semantics knowledge base made logic programming
community przymusinska przymusinski one successful semantics
knowledge bases stable model semantics bidoit froidevaux gelfond lifschitz
fine associates knowledge base possibly empty set
called stable intuitively stable model represents set coherent
c


ai access foundation morgan kaufmann publishers rights reserved

fiben eliyahu
conclusions one might deduce knowledge base turns stable
play central role major deductive systems ai

stable tmss

tmss doyle inference systems nonmonotonic reasoning default assumptions tms manages set nodes set justifications node
represents piece information justifications rules state dependencies
nodes tms computes grounded set nodes assigns set
information believed true given point time intuitively set believed
nodes grounded satisfies rules node believed true solely basis
circular chain justifications elkan pointed nodes tms
viewed propositional atoms set justifications knowledge base
showed task computing grounded interpretations set tms justifications corresponds exactly task computing stable knowledge base
represented set tms justifications

stable autoepistemic logic

autoepistemic logic invented moore order formalize process
agent reasoning beliefs language autoepistemic logic propositional
language augmented modal operator l given theory set formulas
autoepistemic logic theory e called stable expansion iff
e sflf jf e gsf lf jf e g
denotes logical closure restrict subset
autoepistemic logic formula form
lb lbn c

c b propositional atoms call subset
class autoepistemic programs every autoepistemic program translated
knowledge base representing formula knowledge base rule elkan
shown stable model iff expansion e
set positive atoms e thus computing stable
may used computing expansions autoepistemic programs relationship
stable model semantics autoepistemic logic explored gelfond
gelfond lifschitz

stable default logic

default logic formalism developed reiter reasoning default assumptions default theory viewed set defaults default defined
expression form
fin




logic programming terminology knowledge bases discussed called normal logic
programs



fia hierarchy tractable subsets
fin formulas first order language according reiter e
extension default theory iff e coincides one minimal deductively
closed sets sentences e satisfying condition grounded instance
default e fin e e
consider subset default theories call default programs default
program set defaults form

b bn

c
c b atoms propositional language

default program associated knowledge base replacing
default form rule
gelfond lifschitz shown logical closure set atoms e
extension iff e stable model computing stable
thus used computing extensions reiter default theories


organized follows next section define terminology
section presents two computing stable knowledge base
complexity first depends number atoms appearing
negatively knowledge base complexity depends
number rules negative atoms bodies section present
main called aas aas works
bottom superstructure dependency graph knowledge base uses
two presented section subroutines section explains aas
generalized handle knowledge bases first order language finally
sections discuss related work make concluding remarks

preliminary definitions
recall knowledge base defined set rules form

c b bn



c b propositional atoms expression
left called head rule expression right called
body rule said appear positive rule accordingly
b said appear negative rule rule said c rule
empty body called unit rule sometimes treat truth assignment
words interpretation propositional logic set atoms set atoms
assigned true interpretation given interpretation set atoms ia
denotes projection given two interpretations j sets atoms
note appearance e condition



fiben eliyahu
b respectively interpretation j defined follows

p n b
ij pp
p btn
j p p
p b p j p


undefined otherwise

p j p every p b say j consistent

partial interpretation truth assignment subset atoms hence partial
interpretation represented consistent set literals positive literals represent
atoms true negative literals atoms false rest unknown
knowledge base called horn rules horn model theory set
clauses propositional logic truth assignment satisfies clauses one
looks knowledge base theory propositional logic horn knowledge base
unique minimal model recall model minimal among set iff
model
given knowledge base set atoms gelfond lifschitz defined
called gelfond lifschitz gl transform w r knowledge base
obtained deleting rule negative literal p body
p deleting negative literals bodies remaining rules note
horn knowledge base model stable model knowledge base iff
unique minimal model gelfond lifschitz
example consider following knowledge base used one
canonical examples throughout

warm blooded mammal
live land mammal ab

female mammal male

male mammal female

mammal dolphin

ab dolphin

mammal lion

lion

flion mammal warm blooded live land femaleg stable model indeed
gl transform w r









warm blooded
live land
female
mammal
ab
mammal
lion



mammal
mammal
mammal
dolphin
dolphin
lion

fia hierarchy tractable subsets
minimal model
set atoms satisfies body rule iff atom appears positive
body atom appears negative body set
atoms satisfies rule iff satisfy body satisfies body
atom appears head belongs
proof atom sequence rules atom derived formally
recursively define atom p proof w r set atoms
knowledge base
unit rule p p proof w r
rule p b bn every n bi
every ai already proof w r p
proof w r
theorem elkan ben eliyahu dechter set atoms stable
model knowledge base iff
satisfies rule
atom p proof p w r
simple matter following lemma true
lemma let knowledge base let set atoms define


si si fp jp b bn
belong si none b belong g

stable model iff

observe although every stable model minimal model knowledge base
viewed propositional theory every minimal model stable model
example consider knowledge base
b
fag fbg minimal knowledge base fbg stable
model knowledge base
note knowledge base may one stable stable model
knowledge base least one stable model say consistent
dependency graph knowledge base directed graph atom
node positive edge directed p q iff rule q
p appears positive body accordingly negative edge
p q iff rule q p appears negative body recall
source directed graph node incoming edges sink node
outgoing edges given directed graph g node g subgraph rooted
subgraph g nodes path directed g
children g nodes arc directed g


fiben eliyahu

example dependency graph shown figure negative edges
marked children mammal lion dolphin subgraph rooted
land subgraph include nodes lion mammal dolphin ab land

male

warm blood
female



land
mammal

lion



ab
dolphin

figure dependency graph
knowledge base stratified iff assign atom c positive integer ic
every rule form ia ic
b ib ic readily demonstrated knowledge base stratified iff
dependency graph directed cycles going negative edges well
known logic programming community stratified knowledge base unique
stable model found linear time gelfond lifschitz apt blair
walker

example stratified knowledge base following knowledge base

stratified assign ab penguin number atoms
number

live land
fly
bird
ab







bird
bird ab
penguin
penguin

fia hierarchy tractable subsets
strongly connected components directed graph g make partition
set nodes subset partition x
directed paths x x g strongly connected components
identifiable linear time tarjan

male




female
warm blood

land
mammal

lion



ab
dolphin

figure super dependency graph
super dependency graph knowledge base denoted g superstructure
dependency graph g directed graph built making strongly
connected component dependency graph node g arc exists
node node v iff arc one atoms one atoms v
dependency graph note g acyclic graph

example super dependency graph shown figure nodes

square grouped single node

two computing stable
main contribution presentation whose eciency
depends distance knowledge base stratified knowledge base
distance measured precisely section first describe two
computing stable two take account level
stratifiability knowledge base still work exponential time
stratified knowledge bases main use two procedures


fiben eliyahu
given truth assignment knowledge base verify polynomial time whether
stable model lemma therefore straightforward computing stable simply check possible truth assignments determine whether
stable model time complexity straightforward procedure
exponential number atoms used knowledge base present two
often function eciently straightforward procedure

depends number negative atoms
knowledge base
stable figure enables us stable time expo

nential number atoms appear negative knowledge base
follows work abductive extensions logic programming
stable characterized terms sets hypotheses drawn additional information eshghi kowalski dung kakas mancarella
done making negative atoms abductible imposing appropriate denials
disjunctions integrity constraints work eshghi kowalski dung
kakas mancarella implies following
theorem let knowledge base let h set atoms appear negated
stable model iff interpretation h
every atom p h p p
consistent

unique stable model
proof proof follows directly definition stable suppose
stable model knowledge base let h set atoms appear negative
definition stable model note mh hence
conditions theorem hold taking mh suppose
knowledge base theorem observe
hence since stable model stable model
stable model first note condition thus
satisfies rules atom p proof w r
proof w r theorem stable model
definition stable model
theorem implies stable figure computes stable
knowledge base hence following complexity analysis
proposition knowledge base k atoms appear negated
k stable found time nl k l size
knowledge base n number atoms used knowledge base
proof follows fact computing computing unique stable model
positive knowledge base nl


fia hierarchy tractable subsets

stable

input knowledge base
output set stable

possible interpretation set atoms appear negative

compute unique stable model

b consistent let fm g
return
figure stable

depends number non horn rules
stable figure depends number rules

negated atoms gets input knowledge base outputs set stable
upon observation stable model
built attempting possible means satisfying negated atoms bodies nonhorn rules two procedures called stable unitinst shown figure
negunitinst shown figure procedure unitinst gets input knowledge base
partial interpretation unitinst looks recursively unit rules unit rule
p p assigned false follows cannot part model
procedure returns false p false procedure instantiates p true
interpretation deletes positive appearances p body rule
deletes rules p rules p appears negative
procedure negunitinst receives input knowledge base partial interpretation
set atoms neg first instantiates atom neg false updates
knowledge base ect instantiation instantiations recorded
case con ict namely procedure tries instantiate true atom
already set false procedure returns false otherwise returns true

proposition stable correct stable model
knowledge base iff generated stable
proof suppose stable model knowledge base theorem every
atom set true proof w r let set non horn
rules whose bodies satisfied clearly point checked step
stable happens atoms proof w r
set true procedure negunitinst proved induction
length proof hence generated
suppose generated stable obviously every rule satisfied
step c ii every atom set true negunitinst proof w r


fiben eliyahu

stable
input knowledge base
output set stable

let set non horn rules
subset
neg fp jnot p body rule g
b
c negunitinst neg
p p null let p false

ii satisfies rules fmg
endfor
return
figure stable
unitinst
input knowledge base partial interpretation
output updates unit rules returns false con ict
unit rule value assigned atom otherwise returns true
unit rules
let p unit rule
b p false return false
c p true
erase p body rule
e erase rules p
f erase rules p appears negative
endwhile
return true
figure procedure unitinst


fia hierarchy tractable subsets
negunitinst neg
input knowledge base set atoms neg partial interpretation
output updates assuming atoms neg false returns false inconsistency
detected otherwise returns true
atom p neg
p false
b delete body rule occurrence p
c delete rule p appears positive body
endfor
return unitinst
figure procedure negunitinst






lion dolphin ab mammal warm b land male female


f

f







f





f

f









f

table generated stable
readily observable way negunitinst works hence theorem
stable model

proposition knowledge base c non horn rules c stable

found time nl c l size knowledge base
n number atoms used knowledge base

proof straightforward induction c
example suppose call stable input knowledge base
step set rules subsets include rules
considered step negunitinst return false unitinst

detect inconsistency subset containing rules considered
stable model table generated subset containing rules
considered stable model table generated
subsets contain rules tested step generated
satisfy rules hence appear output
stable stable take account structure
knowledge base example polynomial class stratified
knowledge bases present next exploits structure knowledge
base


fiben eliyahu

hierarchy tractable subsets level stratifiability
knowledge base

acyclic stable aas figure exploits structure knowledge
base ected super dependency graph knowledge base computes
stable traversing super dependency graph bottom
computing stable presented previous section subroutines
let knowledge base node g super dependency graph
associate ms subset containing rules
atoms set atoms subgraph g rooted ms set
stable associated subset knowledge base contains rules
atoms initially ms empty every traverses g
bottom node first combines submodels children
single set mc source mc set f g next
model mc aas converts knowledge base sm gl transform
transformations depend atoms finds stable
sm combines set ms obtained repeating operation
mc aas uses procedure cartesprod figure receives input
several sets returns consistent portion cartesian product one
sets cartesprod gets input empty set cartesprod
output empty set procedure convert gets input knowledge base
model set atoms performs following atom p
positive occurrence p deleted body rule rule
p body rule p rule deleted p
body rule p p p deleted body
procedure stable called aas may one procedures previously presented
stable stable may procedure generates stable


example suppose aas called compute stable suppose

traverses super dependency graph figure order flion
dolphin mammal ab land warm blooded female maleg recall nodes inside square make one node calling female male short fm
visiting nodes except last mlion ffliongg mdolphin f g
mmammal fflion mammalgg mon land fflion mammal onlandgg mwarm blooded
fflion mammal warm bloodedgg visiting node fm step c
mc fm mmammal step loops flion mammalg recall
fm knowledge base

female
male

mammal male
mammal female

note difference f g set one model model assigns
atoms set contains



false



fia hierarchy tractable subsets

acyclic stable

input knowledge base
output set stable
traverse g bottom node
ms
b let sj children
c j mc f g
else mc cartesprod fms msj g
mc
sm convert
ii stable sm

iii ms ms cartesprod ffmg g
output cartesprod fms msk g sk sinks g
figure acyclic stable aas
cartesprod
input set sets
output set consistent portion cartesian product
sets
single element fe g return e

let
cartesprod n fm g



consistent fm dg
b endfor
endfor
return
figure procedure cartesprod


fiben eliyahu
executing step fm set

female
male

male
female

knowledge base two stable ffemaleg fmaleg cartesian
product set flion mammalg yields mfm fflion mammal femaleg
flion mammal malegg step cartesian product mwarm blooded mon land
mfm taken thus outputs fflion mammal land warm blooded femaleg
flion mammal land warm blooded malegg indeed two stable
note aas ecient stable stable
knowledge base

theorem aas correct stable model knowledge base
iff generated aas applied
proof let sn ordering nodes super dependency graph

executed induction aas node
si generates stable portion knowledge base composed
rules use atoms asi
case case step ii aas sm thus claim follows
correctness stable called step ii
case showing every model generated stable straightforward induction hypothesis theorem direction suppose stable model
generated clearly child si projection
onto stable model part knowledge base uses atoms
induction mc projection onto union every
child si must belong mc si computed step c therefore
generated need mc stable model simc
easily done theorem
analyze complexity aas first given knowledge base
set atoms define knowledge base obtained deleting
negative occurrence atom belong body every rule
example fa b c ag fbg fa b c ag
visiting node execution aas compute step ii
stable knowledge base sm stable stable
estimated time required stable sm shorter equal
time required stable occurs number negative
atoms number rules negative atoms bodies higher
equal number negative atoms number rules negative atoms
bodies sm regardless thus horn knowledge base
stable model hence sm polynomial time matter


fia hierarchy tractable subsets
positive stable hence sm time
min ln k ln c l length n number atoms used c
number rules contain negative atoms k number atoms appear
negatively
knowledge base associate number follows associate
number vs every node g horn knowledge base vs else vs
min k c c number rules contain negative atoms
k number atoms appear negatively associate number ts
every node leaf node ts vs children sj g
ts vs ts tsj define ts tsk sk sink nodes
g
definition knowledge base belongs
j j
theorem knowledge base belongs
j j j stable
computed time lnj
proof induction j dependency graph super dependency graph
built time linear size knowledge base may consider
time takes compute stable super dependency graph given
case j
means every node g horn knowledge base
words stratified therefore exactly one stable model
n nodes graph node loop step executed
one model generated every node procedure convert runs
time ls ls length assume stored array
access atom constant time since every node
horn knowledge base sm computed time lsn thus overall complexity
ln
case j induction n number nodes super dependency graph
case n let single node g thus j vs
section stable found time lnvs
vs
case n assume without loss generality g single sink get
single sink add program rule p sk sk
sinks p atom let c ck children
child ci ci part knowledge base corresponds subgraph
rooted ci must belong
ti ti j induction n
child node ci stable ci computed time lnti
ci ti stable let us observe happens aas
visiting node first cartesian product computed
child nodes taken executed time n tk yields
tk mc every mc call convert ln
compute stable sm lnvs combine
cartesprod nvs thus overall complexity computing ms
computing stable lnt tk vs lnj


fiben eliyahu

note stratified knowledge bases belong
knowledge
base looks stratified ecient aas
given knowledge base easy minimum j belongs
j
follows building g finding c k every node g polynomialtime tasks hence
theorem given knowledge base minimum j belongs

j polynomial time
example nodes g except fm vs vfm thus

stratified knowledge base therefore belongs




male


female
warm blood

land
mammal

lion

fly




ab
dolphin

bird

ab

penguin



figure super dependency graph
next example shows step procedure cartesprod necessary
example consider knowledge base
b
b

c

e
f









b
c
c

fia hierarchy tractable subsets

f

e

c







b


figure super dependency graph





c

c








b

b









figure dependency graph super dependency graph


fiben eliyahu
super dependency graph shown figure run aas
mab set computed node fa bg set ffa bg f bgg aas
visits nodes c get mc ffa b cg f bgg md b dg fa bgg
aas visits node e cartesprod called input fmc mdg yielding output
ffa b cg f b dgg note cartesprod output model c
true fa b cg f b dg inconsistent cartesprod
checks consistency step visiting node f get mf ffa b c f g f bgg
aas returns cartesprod fme mf g ffa b c f g f b dgg
next example demonstrates generated nodes super dependency graph run aas may later deleted since cannot
completed stable model whole knowledge base

example consider knowledge base

b
c

b

c

dependency graph super dependency graph shown figure
run aas mab set computed node fa bg
set ffag fbgg however fbg stable model
despite deficiency illustrated example aas desirable
features first aas enables us compute stable modular fashion use
g structure store stable knowledge base changed
need resume computation nodes affected change example
suppose computing stable knowledge base add tos
knowledge base example gives us knowledge base
super dependency graph knowledge base shown figure
need compute stable nodes penguin bird ab land
combine generated sinks compute
stable nodes well
second aas compute stable
root node queried atom somewhere middle
graph often enough compute subgraph rooted
node represents atom example suppose given knowledge base
asked mammal true every stable model run aas
nodes dolphin lion mammal stop mammal true stable
computed node mammal e mmammal answer
yes otherwise must continue computation
third aas useful computing labeling tms subject
nogoods set nodes tms declared nogood means acceptable
labeling assign false least one node nogood set stable
terminology means handling nogoods look stable
logic programming terminology nogoods simply integrity constraints



fia hierarchy tractable subsets
least one atom nogood false straightforward would first
compute stable choose ones comply nogood
constraints since aas modular works bottom
many cases prevent generation unwanted stable early stage
computation exclude submodels comply nogood
constraints erase submodels ms node super
dependency graph includes members certain nogood

computing stable first order knowledge bases
section generalize aas stable
knowledge base first order language function symbols
called first acyclic stable faas
refer knowledge base set rules form

c b bn



b c atoms first order language function symbols
definitions head body positive negative appearances atom
propositional case expression p x xn p called predicate name
propositional case every knowledge base associated directed graph
called dependency graph predicate name node b
positive arc directed node p node q iff rule
p predicate name one ai q predicate name head c
negative arc directed node p node q iff rule
p predicate name one bi q predicate name head super
dependency graph g defined analogous manner define stratified knowledge
base knowledge base cycles negative edges
dependency graph knowledge base
knowledge base called safe iff rules safe rule safe iff
variables appearing head rule predicates appearing negative rule
appear positive predicates body rule section assume
knowledge bases safe herbrand base knowledge base set atoms
constructed predicate names constants knowledge base set
ground instances rule set rules obtained consistently substituting variables
rule constants appear knowledge base possible ways
ground instance knowledge base union ground instances rules note
ground instance first order knowledge base viewed propositional
knowledge base
model knowledge base subset knowledge base herbrand base
subset property every rule grounded knowledge base
atoms appear positive body rule belong atoms
appear negative body rule belong atom head
rule belongs stable model first order knowledge base herbrand
model stable model grounded version


fiben eliyahu

first acyclic stable

input first order knowledge base
output stable
traverse g bottom node
ms
b let sj children
c mc cartesprod fms msj g
mc
ms mssall stable sfp jp mg
output cartesprod fms msk g sk sinks g
figure first acyclic stable faas
present faas computes stable first order
knowledge base let first order knowledge base propositional case
node g super dependency graph associate ms
subset containing rules predicates whose names
set predicate names p appear subgraph g rooted ms
stable associated sub knowledge base contains rules
predicates whose names initially ms empty every faas
traverses g bottom node first combines
submodels children single set mc model
mc calls procedure finds stable union set
unit clauses p p procedure stable called faas
procedure computes stable first order knowledge base
procedure stable computes stable parts knowledge base
may take advantage fractions knowledge base stratified
property simplifies computation stable fraction

theorem faas correct stable model knowledge base
iff one output applying faas

proof proof theorem

note knowledge base appears stratified ecient
faas becomes

example consider knowledge base
warm blooded x
live land x
female x

mammal x
mammal x ab x
mammal x male x


fia hierarchy tractable subsets
male x
mammal x
ab x
mammal x
dolphin flipper







mammal x female x
dolphin x
dolphin x
lion x

bird x
bird x ab x
penguin x
penguin x

super dependency graph g super dependency graph
live land x
fly x
bird x
ab x
bird bigbird

knowledge base see figure observe node mammal example

step looks stable knowledge base mammal
f dolphin flipper g mammal fmammal x dolphin x mammal x lion x g
stratified knowledge base unique stable model found eciently
hence faas saves us ground rules knowledge base
starting calculate take advantage parts knowledge
base stratified

related work

recent years quite developed reasoning stable
nonetheless far know work presented original sense
provides partition set knowledge bases hierarchy tractable
classes partition structure dependency graph intuitively
task computing stable knowledge base aas becomes
increasingly complex distance knowledge base stratified becomes
larger next summarize work seems us relevant
aas idea appears work lifschitz turner
many cases logic program divided two parts
one part bottom part refer predicates defined top
part explain task computing stable program
simplified program split parts aas superstructure
dependency graph exploits specific method splitting program
bell et al subrahmanian et al implement linear integer programming techniques order compute stable among nonmonotonic logics however dicult assess merits approaches terms complexity
ben eliyahu dechter illustrate knowledge base translated
propositional theory model latter corresponds stable model
former follows finding stable
knowledge base corresponds finding propositional
theory satoh iwayama provide nondeterministic procedure computing


fiben eliyahu
stable logic programs integrity constraints junker konolige
present computing tms labels antoniou langetepe introduce
method representing classes default theories normal logic programs
way sldnf resolution used compute extensions pimentel cuadrado
develop label propagation uses data structures called compressible
semantic trees order implement tms stable model semantics developed marek truszczynski autoepistemic
logic adopted computing stable procedures marek
truszczynski antoniou langetepe pimentel cuadrado beneliyahu dechter satoh iwayama bell et al subrahmanian
et al junker konolige take advantage structure
knowledge base ected dependency graph therefore ecient
stratified knowledge bases
sacca zaniolo present backtracking fixpoint constructing one
stable model first order knowledge base similar allstable presented section complexity worse complexity
stable backtracking fixpoint modified
handle stratified knowledge bases ecient manner needs
adjustments deal eciently knowledge bases close
stratified leone et al present improved backtracking fixpoint
computing one stable model datalog program discuss improved
implemented one procedures called improved
backtracking fixpoint sacca zaniolo backtracking
fixpoint improved take advantage structure
program e ecient programs close stratified
several tractable subclasses computing extensions default theories hence
computing stable known kautz selman papadimitriou sideri
palopoli zaniolo dimopoulos magirou ben eliyahu dechter
tractable subclasses characterized graph ects
dependencies program atoms rules presented
papers complete subclass knowledge bases however
computing extensions stratified default theories extensions default theories
odd cycles precise sense given papadimitriou sideri
cholewinski b
handling tms nogoods developed ai community doyle charniak et al elkan points
faithful semantics tms complexities
analyzed dechter dechter provide manipulating tms
represented constraint network eciency depends
structure constraint network representing tms structure
employ differs dependency graph knowledge base


fia hierarchy tractable subsets

conclusion
task computing stable heart several systems central ai
including tmss autoepistemic logic default logic task shown
np hard present partition set knowledge bases classes


knowledge base
k k stable
may found time lnk l length knowledge base
n number atoms moreover arbitrary knowledge base
minimum k belongs
k time linear size intuitively
knowledge base stratified ecient becomes believe
beyond stratified knowledge bases expressive knowledge base e
rules nonstratified negation knowledge base less likely needed
hence analysis quite useful addition aas
several advantages dynamically changing knowledge base provide applications
answering queries implementing tms nogood strategies illustrate
generalization aas class first order knowledge bases
aas easily adjusted one stable model knowledge
base traversing super dependency graph generate one model
node arrive node cannot generate model
computed far backtrack recent node several available
choose take next model yet chosen worst case time
complexity equal worst case time complexity
finding stable may exhaust possible ways generating
stable model finding certain knowledge base stable model
nevertheless believe average case finding one model
easier finding similar modification aas required
interested finding one model one particular atom gets value true
work another attempt bridge gap declarative systems e g
default logic autoepistemic logic procedural systems e g atms prolog
nonmonotonic reasoning community argued declarative methods
sound impractical since computationally expensive procedural methods ecient dicult completely understand performance
evaluate correctness work presented illustrates declarative
procedural approaches combined yield ecient yet formally supported
nonmonotonic system

acknowledgments
thanks luigi palopoli useful comments earlier draft michelle
bonnice gadi dechter editing parts manuscript many thanks
anonymous referees useful comments
work done author visiting cognitive systems laboratory computer science department university california los angeles california
usa work partially supported nsf grant iri air force oce
scientific grant f


fiben eliyahu

references

antoniou g langetepe e soundness completeness logic programming
default logic aaai proceedings th national conference
artificial intelligence pp aaai press menlo park calif
apt k blair h walker towards theory declarative knowledge
minker j ed foundations deductive databases logic programs pp
morgan kaufmann
bell c nerode ng r subrahmanian v mixed integer programming
methods computing non monotonic deductive databases journal acm

ben eliyahu r dechter r propositional semantics disjunctive logic programs annals mathematics artificial intelligence short version
appears jicslp proceedings joint international conference
symposium logic programming
ben eliyahu r dechter r default reasoning classical logic artificial
intelligence
bidoit n froidevaux c minimalism subsumes default logic circumscription
stratified logic programming lics proceedings ieee symposium
logic computer science pp ieee computer science press los alamitos
calif
charniak e riesbeck c k mcdermott v artificial intelligence programming chap lawrence erlbaum hillsdale nj
cholewinski p reasoning stratified default theories marek w v
nerode truszczynski eds logic programming nonmonotonic reasoning proceedings rd international conference pp lecture notes
computer science springer verlag berlin
cholewinski p b stratified default theories pacholski l tiuryn eds
computer science logic th workshop csl selected papers pp lecture
notes computer science springer verlag berlin
dechter r dechter structure driven truth maintenance
artificial intelligence
dimopoulos magirou v graph theoretic default logic journal
information computation
doyle j truth maintenance system artificial intelligence
dung p negation hypothesis abductive foundation logic programming furukawa k ed iclp proceedings th international conference
logic programming pp mit press


fia hierarchy tractable subsets
elkan c rational reconstruction nonmonotonic truth maintenance systems
artificial intelligence
eshghi k kowalski r abduction compared negation failure levi
g martelli eds iclp proceedings th international conference
logic programming pp mit press
fine k justification negation failure logic methodology philosophy
science
gelfond stratified autoepistemic theories aaai proceedings
th national conference artificial intelligence pp morgan kaufmann
gelfond lifschitz v stable model semantics logic programming
kowalski r bowen k eds logic programming proceedings th
international conference pp mit press
gelfond lifschitz v classical negation logic programs disjunctive
databases generation computing
junker u konolige k computing extensions autoepistemic default logics tms aaai proceedings th national conference
artificial intelligence pp aaai press
kakas c mancarella p stable theories logic programs saraswat
v udea k eds islp proceedings international symposium
logic programming pp mit press
kautz h selman b hard simple default logics artificial
intelligence
leone n romeo n rullo sacca effective implementation negation
database logic query languages atzeni p ed logidata deductive
database complex objects pp lecture notes computer science
springer verlag berlin
lifschitz v turner h splitting logic program van hentenryck p ed
iclp proceedings th international conference logic programming pp
mit press
marek v w truszczynski nonmonotonic logic context dependent reasoning springer verlag berlin
marek w truszczynski autoepistemic logic journal acm

moore r c semantical consideration nonmonotonic logic artificial intelligence
palopoli l zaniolo c polynomial time computable stable annals
mathematics artificial intelligence press


fiben eliyahu
papadimitriou c h sideri default theories extensions
artificial intelligence
pimentel g cuadrado j l truth maintenance system stable
lusk e l overbeek r eds iclp proceedings
north american conference logic programming pp mit press
przymusinska h przymusinski semantic issues deductive databases
logic programs banerji r b ed formal techniques artificial intelligence
sourcebook pp north holland york
reiter r logic default reasoning artificial intelligence
sacca zaniolo c stable non determinism logic programs
negation pods proceedings th acm sigact sigmod sigart
symposium principles database systems pp acm press
satoh k iwayama n computing abduction tms furukawa k
ed iclp proceedings th international conference logic programming
pp mit press
subrahmanian v nau vago c wfs branch bound stable
ieee transactions knowledge data engineering
tarjan r depth first search linear graph siam journal
computing




