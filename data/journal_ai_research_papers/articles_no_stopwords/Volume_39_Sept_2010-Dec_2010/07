Journal Artificial Intelligence Research 39 (2010) 533-579

Submitted 12/09; published 10/10

Theta*: Any-Angle Path Planning Grids
Kenny Daniel
Alex Nash
Sven Koenig

KFDANIEL @ USC . EDU
ANASH @ USC . EDU
SKOENIG @ USC . EDU

Computer Science Department
University Southern California
Los Angeles, California 90089-0781, USA

Ariel Felner

FELNER @ BGU . AC . IL

Department Information Systems Engineering
Ben-Gurion University Negev
Beer-Sheva, 85104, Israel

Abstract
Grids blocked unblocked cells often used represent terrain robotics video
games. However, paths formed grid edges longer true shortest paths terrain
since headings artificially constrained. present two new correct complete anyangle path-planning algorithms avoid shortcoming. Basic Theta* Angle-Propagation
Theta* variants A* propagate information along grid edges without constraining
paths grid edges. Basic Theta* simple understand implement, fast finds short paths.
However, guaranteed find true shortest paths. Angle-Propagation Theta* achieves
better worst-case complexity per vertex expansion Basic Theta* propagating angle ranges
expands vertices, complex, fast finds slightly longer paths.
refer Basic Theta* Angle-Propagation Theta* collectively Theta*. Theta* unique
properties, analyze detail. show experimentally finds shorter paths
A* post-smoothed paths Field D* (the version A* know
propagates information along grid edges without constraining paths grid edges) runtime
comparable A* grids. Finally, extend Theta* grids contain unblocked cells
non-uniform traversal costs introduce variants Theta* provide different tradeoffs
path length runtime.

1. Introduction
article, study path planning robotics video games (Choset, Lynch, Hutchinson,
Kantor, Burgard, Kavraki, & Thrun, 2005; Deloura, 2000; Patel, 2000; Murphy, 2000; Rabin, 2002),
two-dimensional continuous terrain discretized grid blocked unblocked
cells. objective find short unblocked path given start vertex given goal vertex
(both corners cells). A* finds grid paths (that is, paths constrained grid edges) quickly,
grid paths often true shortest paths (that is, shortest paths terrain) since potential
headings artificially constrained multiples 45 degrees, shown Figure 1(a) (Yap, 2002).
shortcoming led introduction call any-angle path planning (Nash, Daniel,
Koenig, & Felner, 2007; Ferguson & Stentz, 2006). Any-angle path-planning algorithms find paths
c
2010
AI Access Foundation. rights reserved.

fiDANIEL , NASH , KOENIG , & F ELNER



1

2

3

4

5



start

B

C

1

2

3

4

5

start

B

C

goal
(a) Grid path

goal
(b) True shortest path

Figure 1: Grid path versus true shortest path
without constraining headings paths, shown Figure 1(b). present two new
correct complete any-angle path-planning algorithms. Basic Theta* Angle-Propagation
Theta* variants A* propagate information along grid edges (to achieve short
runtime) without constraining paths grid edges (to find any-angle paths). Unlike A* visibility
graphs, guaranteed find true shortest paths. asterisk names thus
denote optimality rather similarity A*. Basic Theta* simple understand
implement, fast finds short paths. Angle-Propagation Theta* achieves worst-case complexity
per vertex expansion constant rather linear number cells (like Basic
Theta*) propagating angle ranges expands vertices, complex, fast
finds slightly longer paths. refer Basic Theta* Angle-Propagation Theta* collectively
Theta*. Theta* unique properties, analyze detail. show experimentally
finds shorter paths A* post-smoothed paths Field D* (the version
A* know propagates information along grid edges without constraining paths grid
edges) runtime comparable A* grids. Finally, extend Theta* grids
contain unblocked cells non-uniform traversal costs introduce variants Theta*
provide different tradeoffs path length runtime.

2. Path-Planning Problem Notation
section, describe path-planning problem study article, namely path
planning eight-neighbor grids blocked unblocked cells uniform size. Cells labeled
either blocked (grey) unblocked (white). use corners cells (rather centers)
vertices. set vertices. path-planning problem find unblocked path
given start vertex sstart given goal vertex sgoal .
path unblocked iff vertex path line-of-sight successor path. Vertex
line-of-sight vertex , written LineOfSight(s, ), iff straight line vertex
vertex neither passes interior blocked cells passes blocked cells
share edge. Pseudocode implementing line-of-sight function given Appendix A.
simplicity, allow straight line pass diagonally touching blocked cells.
c(s, ) length straight line vertex vertex . nghbrsvis (s) set visible
neighbors vertex eight compass directions, neighbors vertex
534

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

line-of-sight vertex s. Figure 1 shows example visible neighbors vertex B4
vertices A3, A4, A5, B3, B5, C3 C4.

3. Existing Terrain Discretizations
Continuous terrain needs discretized path planning. section, compare grids
existing terrain discretizations. use grids discretize terrain since widely used
robotics video games (Deloura, 2000; Murphy, 2000; Rabin, 2004) several desirable
properties:
Grids simple data structures allow simple path-planning algorithms.
Terrain easily discretized grid laying grid terrain labeling
cells partially completely obstructed blocked.
Grids provide comprehensive picture traversable surfaces continuous terrain.
essential path planning algorithm used dynamic environment
must interact navigation planner. example robot video game character
encounters temporary blockage path, easily determine whether best
divert left (unblocked) right (blocked) (Tozour, 2004).
Cells store information addition traversability, amount gold
hidden region terrain corresponds cell rendering region
displaying terrain.
information stored cells accessed quickly since grids random access data
structures.
precision path navigation planning improved simply increasing grid
resolution.
list alternative terrain discretizations, assuming simplicity obstacles
terrain polygonal.
Voronoi graphs (Aurenhammer, 1991) discretize terrain biasing paths away
blocked polygons. resulting paths thus much longer true shortest paths.
discretization work Mitchell Papadimitriou (1991) partitions terrain
regions linear hyperbolic edges, allows one find true shortest paths
time space complexity O(m5/3 ), number corners blocked polygons.
Thus, runtime path planning grow superlinearly number corners blocked
polygons.
Framed Quadtrees (Yahja, Stentz, Singh, & Brumitt, 1998) recursively subdivide terrain
four equally sized cells cells completely obstructed, completely unobstructed
sufficiently small size. resulting paths unnecessary heading changes (that is,
heading changes occur free space rather corners blocked polygons).
535

fiDANIEL , NASH , KOENIG , & F ELNER

1 Main()
2
g(sstart ) := 0;
3
parent(sstart ) := sstart ;
4
open := ;
5
open.Insert(sstart , g(sstart ) + h(sstart ));
6
closed := ;
7
open 6=
8
:= open.Pop();
= sgoal
9
10
return path found;
11
12
13
14
15
16
17
18
19

closed := closed {s};
/* following line executed AP Theta*.
[UpdateBounds(s)];
foreach nghbrsvis (s)
6 closed
6 open
g(s ) := ;
parent(s ) := N U LL;

*/;

UpdateVertex(s, );

20
return path found;
21 end
22 UpdateVertex(s,s)
23
g(s) + c(s, ) < g(s )
24
g(s ) := g(s) + c(s, );
25
parent(s ) := s;
26
open
27
open.Remove(s );
28

open.Insert(s , g(s ) + h(s ));

29 end

Algorithm 1: A*

Probabilistic roadmaps (Kavraki, Svestka, Latombe, & Overmars, 1996) rapidly-exploring
random trees (LaValle & Kuffner, 2001) place vertices randomly (in addition start
goal vertex). Two vertices connected via straight line iff line-of-sight.
random placement vertices needs tuned carefully since influences runtime
path planning, likelihood finding path length path.
Visibility graphs (Lee, 1978; Lozano-Perez & Wesley, 1979) use corners blocked
polygon vertices (in addition start goal vertex). Two vertices connected via
straight line iff line-of-sight, allows one find true shortest paths.
runtime path planning grow superlinearly number vertices since number
edges grow quadratically number vertices.

4. Existing Path-Planning Algorithms
section, describe existing path-planning algorithms, variants A*
(Hart, Nilsson, & Raphael, 1968). A* popular path-planning algorithm robotics video
games. Algorithm 1 shows pseudocode A*. Line 13 ignored. A* maintains three
values every vertex s:
536

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

g-value g(s) length shortest path start vertex vertex found
far thus estimate start distance vertex s.
user-provided h-value h(s) estimate goal distance vertex s. A* uses
h-value calculate f-value focus A* search. f-value f (s) = g(s) + h(s)
estimate length shortest path start vertex via vertex goal vertex.
parent parent(s) used extract path start vertex goal vertex A*
terminates.
A* maintains two global data structures:
open list priority queue contains vertices A* considers expansion.
pseudocode, open.Insert(s, x) inserts vertex key x priority queue open,
open.Remove(s) removes vertex priority queue open, open.Pop() removes
vertex smallest key priority queue open returns it.
closed list set contains vertices A* already expanded. ensures
A* expands every vertex once.
A* sets g-value every vertex infinity parent every vertex NULL
encounters vertex first time [Lines 17-18]. sets g-value start vertex zero
parent start vertex start vertex [Lines 2-3]. sets open closed
lists empty list inserts start vertex open list f-value key
[4-6]. A* repeatedly executes following procedure: open list empty, reports
path [Line 20]. Otherwise, identifies vertex smallest f-value
open list [Line 8]. vertex goal vertex, A* reports found path [Line 10].
Path extraction [not shown pseudocode] follows parents goal vertex start
vertex retrieve path start vertex goal vertex reverse. Otherwise, A* removes
vertex open list [Line 8] expands inserting vertex closed list [Line
11] generating unexpanded visible neighbors, follows: A* checks whether
g-value vertex plus length straight line vertex vertex smaller
g-value vertex [Line 23]. so, sets g-value vertex g-value vertex
plus length straight line vertex vertex , sets parent vertex vertex
finally inserts vertex open list f-value key or, already
open list, sets key f-value [Lines 24-28]. repeats procedure.
summarize, A* updates g-value parent unexpanded visible neighbor
vertex procedure UpdateVertex, considers path start vertex vertex [= g(s)]
vertex vertex straight line [= c(s, )], resulting length g(s) + c(s, )
[Line 23]. A* updates g-value parent vertex considered path shorter
shortest path start vertex vertex found far [= g(s )].
describe several existing path-planning algorithms versions A*
trade two conflicting criteria, namely runtime path length, shown Figure 2.
introduce order decreasing path lengths.
537

fiDANIEL , NASH , KOENIG , & F ELNER

10

1

Runtime

A*
A* PS
FD*

0.1

Visibility Graphs
Basic Theta*

0.01

0.001
1

1.01

1.02

1.03

1.04

1.05

1.06

Path Length / Length True Shortest Path

Figure 2: Runtime versus path length (relative length true shortest path) random 100
100 grids 20 percent blocked cells

30 PostSmoothPath([s0 , . . . , sn ])
31
k := 0;
32
tk := s0 ;
33
foreach := 1 . . . n 1
34
LineOfSight(tk , si+1 )
35
k := k + 1;
36
tk := si ;
37
k := k + 1;
38
tk := sn ;
39
return [t0 , . . . , tk ];
40 end

Algorithm 2: Post-smoothing

4.1 A* Grids
One run A* grids, is, graphs given grid vertices edges. resulting
paths artificially constrained formed edges grid, seen Figure
1(a). result paths found A* grids equivalent true shortest paths
unrealistic looking since either deviate substantially true shortest paths
many heading changes, provides motivation smoothing them. use octile
distances, computed using Algorithm 5, h-values experiments.
538

fiT HETA *: NY-A NGLE PATH P LANNING

1

2

3

4

5





G RIDS

6
goal
true shortest path

B
shortest grid path
A* PS path

C

start

Figure 3: A* PS path versus true shortest path

4.2 A* Post-Smoothed Paths (A* PS)
One run A* post-smoothed paths (A* PS) (Thorpe, 1984). A* PS runs A* grids
smoothes resulting path post-processing step, often shortens increase
runtime. Algorithm 2 shows pseudocode simple smoothing algorithm A* PS uses
experiments (Botea, Muller, & Schaeffer, 2004), provides good tradeoff
runtime path length. Assume A* grids finds path [s0 , s1 , . . . , sn ] s0 = sstart
sn = sgoal . A* PS uses first vertex path current vertex. checks whether
current vertex s0 line-of-sight successor s2 successor path. so, A*
PS removes intermediate vertex s1 path, thus shortening it. A* PS repeats
procedure checking whether current vertex s0 line-of-sight successor s3
successor path, on. soon current vertex line-of-sight
successor successor path, A* PS advances current vertex repeats procedure
reaches end path. use straight-line distances h(s) = c(s, sgoal ) h-values
experiments.
A* PS typically finds shorter paths A* grids, guaranteed find true shortest paths.
Figure 3 shows example. Assume A* PS finds dotted blue path, one many
shortest grid paths. smoothes path solid blue path, true shortest
path. dashed red path, moves (rather below) blocked cell B2-B3-C3-C2
true shortest path. A* PS guaranteed find true shortest paths considers grid
paths A* search thus cannot make informed decisions regarding paths
A* search, motivates interleaving searching smoothing. fact, Theta* similar
A* PS except interleaves searching smoothing.
4.3 Field D* (FD*)
One run Field D* (Ferguson & Stentz, 2006) (FD*). FD* propagates information along grid
edges without constraining paths grid edges. FD* designed use D* Lite (Koenig &
Likhachev, 2002) fast replanning (by reusing information previous A* search speed
next one) searches goal vertex start vertex. version FD* uses
A* searches start vertex goal vertex, path-planning algorithms
article, allows us compare fairly, except replanning abilities. (Theta*
currently process extended fast replanning Nash, Koenig, & Likhachev, 2009.)
539

fiDANIEL , NASH , KOENIG , & F ELNER

1

B

2

3

4

2.00

2.32

2.83

1.00

1.41

2.41

5

sgoal
0.45



C



0.55

X

sstart
0.00

1.00

2.00

3.00

1.00

1.41

2.32

3.27

Field D* path
Figure 4: FD* path

Figure 5: Screenshot FD* path versus true shortest path
FD* updates g-value parent unexpanded visible neighbor vertex s,
considers paths start vertex point X (not necessarily vertex) perimeter
vertex [= g(X)] line-of-sight vertex , perimeter formed connecting
neighbors vertex , point X vertex straight line [= c(X, )], resulting
length g(X) + c(X, ). FD* updates g-value parent vertex considered
path shorter shortest path start vertex vertex found far [= g(s )]. use
straight-line distances h(s) = c(s, sgoal ) h-values experiments.
Figure 4 shows example. perimeter vertex = B4 formed connecting
neighbors vertex B4, shown bold. Consider point X perimeter. FD* know
g-value point X since stores g-values vertices. calculates g-value using
linear interpolation g-values two vertices perimeter adjacent
point X. Thus, linearly interpolates g(B3) = 2.41 g(C3) = 2.00, resulting
g(X) = 0.55 2.41 + 0.45 2.00 = 2.23 since 0.55 0.45 distances point X
vertices B3 C3, respectively. calculated g-value point X different true start
distance [= 2.55] even though g-values vertices B3 C3 equal true start
distances. reason mistake simple. exist true shortest paths start vertex
either vertex C3 vertex B3 goal vertex. Thus, linear interpolation assumption
predicts must exist short path start vertex point along
edge connects vertices B3 C3 goal vertex. However, case since
540

fiT HETA *: NY-A NGLE PATH P LANNING



1

2

3

4



G RIDS

5

start

B

C

goal
true shortest path
(a) Simple visibility graph

(b) Terrain resulting complex visibility graph

Figure 6: Visibility graphs
paths need circumnavigate blocked cell B2-B3-C3-C2, makes longer expected.
result miscalculating g-value point X, FD* sets parent vertex B4 point X,
resulting path unnecessary heading change point X longer even
shortest grid path.
authors FD* recognize paths found FD* frequently unnecessary heading
changes suggest use one-step look-ahead algorithm path extraction (Ferguson &
Stentz, 2006), FD* uses experiments. one-step look-ahead algorithm allows FD*
avoid unnecessary heading changes, one Figure 4, eliminate
them. Figure 5 shows example FD* path red corresponding true shortest
path blue. FD* path still many unnecessary heading changes.
4.4 A* Visibility Graphs
One run A* visibility graphs. visibility graph grid blocked unblocked
cells contains start vertex, goal vertex corners blocked cells (Lozano-Perez &
Wesley, 1979). use straight-line distances h(s) = c(s, sgoal ) h-values experiments.
A* visibility graphs finds true shortest paths, shown Figure 6(a). True shortest paths
heading changes corners blocked cells, paths found A* grids, A* PS
FD* unnecessary heading changes. hand, A* visibility graphs
slow. propagates information along visibility graph edges, whose number grow quadratically
number cells, A* grids, A* PS FD* propagate information along grid edges,
whose number grows linearly number cells. one constructed visibility graphs
A* search, one would need perform line-of-sight check every pair corners
blocked cells determine whether visibility graph edge them,
requires least 2,556 line-of-sight checks room Figure 6(b) (Tozour, 2004).
number line-of-sight checks performed A* visibility graphs reduced constructing
541

fiDANIEL , NASH , KOENIG , & F ELNER

41 UpdateVertex(s,s)
42
LineOfSight(parent(s), )
43
/* Path 2 */
44
g(parent(s)) + c(parent(s), ) < g(s )
45
g(s ) := g(parent(s)) + c(parent(s), );
46
parent(s ) := parent(s);
47
open
48
open.Remove(s );
open.Insert(s , g(s ) + h(s ));

49
50
51
52
53
54
55
56
57

else
/* Path 1 */
g(s) + c(s, ) < g(s )
g(s ) := g(s) + c(s, );
parent(s ) := s;
open
open.Remove(s );
open.Insert(s , g(s ) + h(s ));

58 end

Algorithm 3: Basic Theta*

visibility graphs A* search. expands vertex, performs line-of-sight checks
expanded vertex corners blocked cells (and goal vertex).
significantly reduce number line-of-sight checks performed environments,
simple outdoor terrain, fails others, cluttered indoor terrain.
complex optimizations, reduced visibility graphs reduce number line-ofsight checks, sufficiently speed A* visibility graphs (Liu & Arimoto, 1992).

5. Basic Theta*
section, introduce Theta* (Nash et al., 2007), version A* any-angle path
planning propagates information along grid edges without constraining paths grid edges.
combines ideas behind A* visibility graphs (where heading changes occur
corners blocked cells) A* grids (where number edges grows linearly
number cells). paths slightly longer true shortest paths (as found A*
visibility graphs), yet slightly slower A* grids, shown Figure 2. key
difference Theta* A* grids parent vertex vertex
using Theta*, parent vertex neighbor vertex using A*.
first introduce Basic Theta*, simple version Theta*.
Algorithm 3 shows pseudocode Basic Theta*. Procedure Main identical A*
Algorithm 1 thus shown. Line 13 ignored. use straight-line distances
h(s) = c(s, sgoal ) h-values experiments.
5.1 Operation Basic Theta*
Basic Theta* simple. identical A* except that, updates g-value parent
unexpanded visible neighbor vertex procedure UpdateVertex, considers two paths
542

fiT HETA *: NY-A NGLE PATH P LANNING

1

2

3

4



1

sgoal



B



C

Path 1

G RIDS

2

3

4



sstart

B

C

5



Path 2

sstart





sgoal

Path 1

(a) Path 2 unblocked

5

Path 2

(b) Path 2 blocked

Figure 7: Paths 1 2 considered Basic Theta*

instead one path considered A*. Figure 7(a) shows example. Basic Theta*
expanding vertex B3 parent A4 needs update g-value parent unexpanded
visible neighbor C3. Basic Theta* considers two paths:

Path 1: Basic Theta* considers path start vertex vertex [= g(s)]
vertex vertex straight line [= c(s, )], resulting length g(s) + c(s, ) [Line
52]. Path 1 path considered A*. corresponds dashed red path [A4, B3, C3]
Figure 7(a)).
Path 2: Basic Theta* considers path start vertex parent vertex [=
g(parent(s))] parent vertex vertex straight line [= c(parent(s), )],
resulting length g(parent(s)) + c(parent(s), ) [Line 44]. Path 2 considered
A* allows Basic Theta* construct any-angle paths. corresponds solid blue
path [A4, C3] Figure 7(a).

Path 2 longer Path 1 due triangle inequality. triangle inequality states
length side triangle longer sum lengths two sides.
applies since Path 1 consists path start vertex parent vertex s,
straight line parent vertex vertex (Line A) straight line vertex
vertex (Line B), Path 2 consists path start vertex parent vertex
straight line parent vertex vertex (Line C) Lines A, B C form
triangle. Path 1 guaranteed unblocked Path 2 not. Thus, Basic Theta* chooses Path
2 Path 1 vertex line-of-sight parent vertex Path 2 thus unblocked.
Figure 7(a) shows example. Otherwise, Basic Theta* chooses Path 1 Path 2. Figure 7(b)
shows example. Basic Theta* updates g-value parent vertex chosen path
shorter shortest path start vertex vertex found far [= g(s )]. use
straight-line distances h(s) = c(s, sgoal ) h-values experiments.
543

fiDANIEL , NASH , KOENIG , & F ELNER

1

2

5

4

3

1



1.00

0.00

1.00

A4

sstart

A4

B

1.41

1.00

1.41

A4

A4

A4

C

sgoal

2

3

B

C

A4

sgoal

2

1.00

A4

sstart

A4

2.41

1.41

1.00

1.41

B3

A4

A4

A4

2.83

2.24

2.00

A4

A4

A4

(b)

3

4

3.82

3.41

1.00

0.00

1.00

B2

B2

A4

sstart

A4

B

3.41

2.41

1.41

1.00

1.41

B3

B3

A4

A4

A4

3.65

2.83

2.24

2.00

B3

A4

A4

A4

sgoal

1

5



C

5

0.00

(a)
1

4
1.00



2

3

4

5



3.82

3.41

1.00

0.00

1.00

B2

B2

A4

sstart

A4

B

3.41

2.41

1.41

1.00

1.41

B3

B3

A4

A4

A4

C

3.65

2.83

2.24

2.00

B3

A4

A4

A4

sgoal

(c)

(d)

Figure 8: Example trace Basic Theta*

5.2 Example Trace Basic Theta*
Figure 8 shows example trace Basic Theta*. vertices labeled g-values
parents. arrows point parents. Red circles indicate vertices expanded,
blue arrows indicate vertices generated current expansion. First, Basic Theta*
expands start vertex A4 parent A4, shown Figure 8(a). sets parent unexpanded
visible neighbors vertex A4 vertex A4, A* would do. Second, Basic Theta* expands
vertex B3 parent A4, shown Figure 8(b). Vertex B2 unexpanded visible neighbor
vertex B3 line-of-sight vertex A4. Basic Theta* thus updates according
Path 1 sets parent vertex B3. hand, vertices C2, C3 C4 unexpanded
visible neighbors vertex B3 line-of-sight vertex A4. Basic Theta* thus updates
according Path 2 sets parents vertex A4. (The g-values parents
unexpanded visible neighbors vertex B3 updated.) Third, Basic Theta* expands vertex
B2 parent B3, shown Figure 8(c). Vertices A1 A2 unexpanded visible neighbors
vertex B2 line-of-sight vertex B3. Basic Theta* thus updates according
Path 1 sets parents vertex B2. hand, vertices B1 C1 unexpanded
visible neighbors vertex B2 line-of-sight vertex B3. Basic Theta* thus updates
according Path 2 sets parents vertex B3. Fourth, Basic Theta* expands goal
vertex C1 parent B3 terminates, shown Figure 8(d). Path extraction follows
parents goal vertex C1 start vertex A4 retrieve true shortest path [A4, B3, C1]
start vertex goal vertex reverse.
544

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

5.3 Properties Basic Theta*
discuss properties Basic Theta*.
5.3.1 C ORRECTNESS



C OMPLETENESS

Basic Theta* correct (that is, finds unblocked paths start vertex goal vertex)
complete (that is, finds path start vertex goal vertex one exists). use
following lemmata proof.
Lemma 1. exists unblocked path two vertices exists unblocked
grid path two vertices.
Proof. unblocked path two vertices exists iff unblocked any-angle path [s0 , . . . , sn ]
exists two vertices. Consider path segment sk sk+1 any-angle path.
path segment horizontal vertical, consider unblocked grid path vertex sk
vertex sk+1 coincides path segment. Otherwise, consider sequence (b0 , . . . , bm )
unblocked cells whose interior path segment passes through. two consecutive cells
bj bj+1 share least one vertex sj+1 since cells either share edge diagonally
touching. (If share one vertex, pick one arbitrarily.) Consider grid path [s0 =
sk , s1 , . . . , sm , sm+1 = sk+1 ]. grid path vertex sk vertex sk+1 unblocked since
two consecutive vertices corners unblocked cell thus visible neighbors.
Repeat procedure every path segment any-angle path concatenate resulting
grid paths unblocked grid path vertex s0 vertex sn . (If several consecutive vertices
grid path identical, one removed.)
Lemma 2. point execution Basic Theta*, following parents vertex
open closed lists start vertex retrieves unblocked path start vertex
vertex reverse.
Proof. prove induction lemma holds parent vertex union
open closed lists union open closed lists. statement holds
initially start vertex vertex union open closed lists
parent. show statement continues hold whenever vertex changes either
parent membership union open closed lists. vertex member
union open closed lists, continues member. vertex become member
union open closed lists Basic Theta* expands vertex updates
g-value parent unexpanded visible neighbor vertex procedure UpdateVertex.
Vertex thus closed list, parent union open closed lists according
induction assumption. Thus, following parents vertex (or parent) start
vertex retrieves unblocked path start vertex vertex (or parent, respectively)
reverse according induction assumption. Basic Theta* updates vertex according Path
1, statement continues hold since vertices visible neighbors path
segment vertex vertex thus unblocked. Basic Theta* updates vertex according
Path 2, statement continues hold since Basic Theta* explicitly checks path
545

fiDANIEL , NASH , KOENIG , & F ELNER

segment parent vertex vertex unblocked. ways
parent vertex change.
Theorem 1. Basic Theta* terminates path extraction retrieves unblocked path start
vertex goal vertex path exists. Otherwise, Basic Theta* terminates reports
unblocked path exists.
Proof. following properties together prove theorem. proofs utilize fact Basic
Theta* terminates iff open empty expands goal vertex. start vertex initially
open list. vertex initially neither open closed lists. vertex neither
open closed lists inserted open list. vertex open list removed
open list inserted closed list. vertex closed list remains closed list.
Property 1: Basic Theta* terminates. expands one vertex open list
iteration. process, removes vertex open list never insert
open list again. Since number vertices finite, open list eventually becomes
empty Basic Theta* terminate terminated earlier already.
Property 2: Basic Theta* terminates open list empty,
exist unblocked path start vertex goal vertex. prove contrapositive.
Assume exists unblocked path start vertex goal vertex. prove
contradiction Basic Theta* terminate open list empty.
Thus, assume Basic Theta* terminates open list empty. Then,
exists unblocked grid path [s0 = sstart , . . . , sn = sgoal ] start vertex goal
vertex according Lemma 1. Choose vertex si first vertex grid path
closed list Basic Theta* terminates. goal vertex closed list
Basic Theta* terminates since Basic Theta* would otherwise terminated
expanded goal vertex. Thus, vertex si exists. Vertex si start vertex since start
vertex would otherwise open list Basic Theta* could terminated
open list empty. Thus, vertex si predecessor grid path. predecessor
closed list Basic Theta* terminates since vertex si first vertex grid
path closed list Basic Theta* terminates. Basic Theta* expanded
predecessor, added vertex si open list. Thus, vertex si still open list
Basic Theta* terminates. Basic Theta* could terminated open
list empty, contradiction.
Property 3: Basic Theta* terminates expands goal vertex, path extraction
retrieves unblocked path start vertex goal vertex following
parents goal vertex start vertex retrieves unblocked path start
vertex goal vertex reverse according Lemma 2.

546

fiT HETA *: NY-A NGLE PATH P LANNING



1

2

3

4

5



G RIDS

6

7

8

9

10

6

7

8

9

10

B

C



E

start

(a)


1

2

3

4

5

B

C



E

start

(b)

true shortest path

Basic Theta* path

Figure 9: Basic Theta* paths versus true shortest paths

5.3.2 PTIMALITY
Basic Theta* optimal (that is, guaranteed find true shortest paths)
parent vertex either visible neighbor vertex parent visible neighbor,
always case true shortest paths. Figure 9(a) shows example dashed
red path [E1, B9] true shortest path start vertex E1 vertex B9 since vertex E1 lineof-sight vertex B9. However, vertex E1 neither visible neighbor parent visible
neighbor vertex B9 since vertex E1 line-of-sight vertices (highlighted
red). Thus, Basic Theta* cannot set parent vertex B9 vertex E1 find true
shortest path vertex E1 vertex B9. Similarly, Figure 9(b) shows example
dashed red path [E1, D8, C10] true shortest path vertex E1 vertex C10. However, vertex
D8 neither visible neighbor parent visible neighbor vertex C10 since start vertex
E1 either line-of-sight Basic Theta* found paths vertex E1
547

fiDANIEL , NASH , KOENIG , & F ELNER



1 sstart

2

3

4

5

6

B

C

f=6.02


f=6.00

true shortest path

sgoal
f=6.00

Basic Theta* path

Figure 10: Heading changes Basic Theta*

contain vertex D8. fact, truly shortest paths vertex E1 visible neighbors vertex
C10 vertex E1 line-of-sight move (rather below) blocked cell C7C8-D8-D7. Thus, Basic Theta* cannot set parent vertex C10 vertex D8 thus
find true shortest path vertex E1 vertex C10. solid blue path vertex E1 vertex
B9 Figure 9(a) solid blue path vertex E1 vertex C10 Figure 9(b) less
factor 1.002 longer true shortest paths.
5.3.3 H EADING C HANGES
Basic Theta* takes advantage fact true shortest paths heading changes
corners blocked cells. However, paths found Basic Theta* occasionally
unnecessary heading changes. Figure 10 shows example Basic Theta* finds solid blue
path [A1, D5, D6] vertex A1 vertex D6. reason mistake simple. Assume
open list contains vertices C5 D5. f-value vertex C5 f (C5) = g(C5) +
h(C5) = 4.61 + 1.41 = 6.02 parent vertex C4. f-value vertex D5 f (D5) =
5.00 + 1.00 = 6.00 parent vertex A1. Thus Basic Theta* expands vertex D5
vertex C5 (since f-value smaller). Basic Theta* expands vertex D5 parent A1,
generates vertex D6. Vertex D6 unexpanded visible neighbor vertex D5
line-of-sight vertex A1. Basic Theta* thus updates according Path 1, sets f-value
f (D6) = 6.00 + 0.00 = 6.00, sets parent vertex D5 inserts open list. Thus
Basic Theta* expands goal vertex D6 vertex C5 (since f-value smaller) terminates.
Path extraction follows parents goal vertex D6 start vertex A1 retrieve solid
blue path [A1, D5, D6]. Thus, Basic Theta* never expands vertex C5, would resulted
setting parent vertex D6 vertex C4 according Path 2 path extraction retrieving
dashed red path [A1, C4, D6] true shortest path. solid blue path vertex A1
vertex D6 Figure 10 less factor 1.027 longer true shortest path.
548

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

59 UpdateVertex(s,s)
60
6= sstart lb(s) (s, parent(s), ) ub(s)
61
/* Path 2 */
62
g(parent(s)) + c(parent(s), ) < g(s )
63
g(s ) := g(parent(s)) + c(parent(s), );
64
parent(s ) := parent(s);
65
open
66
open.Remove(s );
open.Insert(s , g(s ) + h(s ));

67
68
69
70
71
72
73
74
75

else
/* Path 1 */
g(s) + c(s, ) < g(s )
g(s ) := g(s) + c(s, );
parent(s ) := s;
open
open.Remove(s );
open.Insert(s , g(s ) + h(s ));

76 end
77 UpdateBounds(s)
78
lb(s) := ; ub(s) := ;
79
6= sstart
80
foreach blocked cell b adjacent
81
corners(b) : parent(s) = (s, parent(s), ) < 0
82
((s, parent(s), ) = 0 c(parent(s), ) c(parent(s), s))
83
lb(s) = 0;
84
85
86
87
88
89
90
91
92
93
94
95
96
97

corners(b) : parent(s) = (s, parent(s), ) > 0
((s, parent(s), ) = 0 c(parent(s), ) c(parent(s), s))
ub(s) = 0;
foreach nghbrsvis (s)
closed parent(s) = parent(s ) 6= sstart
lb(s ) + (s, parent(s), ) 0
lb(s) := max(lb(s), lb(s ) + (s, parent(s), ));
ub(s ) + (s, parent(s), ) 0
ub(s) := min(ub(s), ub(s ) + (s, parent(s), ));
c(parent(s), ) < c(parent(s), s) parent(s) 6= (s 6 closed parent(s) 6= parent(s ))

(s, parent(s), ) < 0
lb(s) := max(lb(s), (s, parent(s), ));
(s, parent(s), ) > 0
ub(s) := min(ub(s), (s, parent(s), ));

98 end

Algorithm 4: AP Theta*

6. Angle-Propagation Theta* (AP Theta*)
runtime Basic Theta* per vertex expansion (that is, runtime consumed generation unexpanded visible neighbors expanding vertex) linear number
cells since runtime line-of-sight check linear number cells.
section, introduce Angle-Propagation Theta* (AP Theta*), reduces runtime Basic
549

fiDANIEL , NASH , KOENIG , & F ELNER



1

2

B

3

4



1

5

6



2

C



E



F

Figure 11: Region points line-of-sight vertex
Theta* per vertex expansion linear constant.1 key difference AP Theta*
Basic Theta* AP Theta* propagates angle ranges uses determine whether
two vertices line-of-sight.
light source vertex light cannot pass blocked cells, cells
shadows line-of-sight vertex cells line-of-sight vertex.
contiguous region points line-of-sight vertex characterized two
rays emanating vertex thus angle range defined two angle bounds. Figure
11 shows example points within red angle range defined two angle bounds
1 2 line-of-sight vertex s. AP Theta* calculates angle range vertex
expands vertex propagates along grid edges, resulting constant runtime per
vertex expansion since angle ranges propagated constant time line-of-sight
checks performed constant time well.
Algorithm 4 shows pseudocode AP Theta*. Procedure Main identical A*
Algorithm 1 thus shown. Line 13 executed. use straight-line distances
h(s) = c(s, sgoal ) h-values experiments.
6.1 Definition Angle Ranges
discuss key concept angle range. AP Theta* maintains two additional values
every vertex s, namely lower angle bound lb(s) vertex upper angle bound ub(s)
vertex s, together form angle range [lb(s), ub(s)] vertex s. angle bounds correspond
headings rays (measured degrees) originate parent vertex s. heading
ray parent vertex vertex zero degrees. visible neighbor vertex
guaranteed line-of-sight parent vertex (but necessarily if) heading
ray parent vertex visible neighbor vertex contained angle
1. AP Theta* provides significant improvement worst case complexity Basic Theta*, experimental results Section 7 show slower finds slightly longer paths Basic Theta*.

550

fiT HETA *: NY-A NGLE PATH P LANNING

1

2

3

4





G RIDS

5

sstart
lb

B

18O


27
C

sgoal



ub

Figure 12: Angle range AP Theta*
range vertex s. Figure 12 shows example vertex C3 parent A4 angle range
[18, 27]. Thus, visible neighbors vertex C3 red region guaranteed line-ofsight parent vertex C3. example, vertex C4 guaranteed line-of-sight
parent vertex C3 vertex B2 not. AP Theta* therefore assumes vertex B2
line-of-sight parent vertex C3.
define concept angle range formally. (s, p, ) [90, 90], gives
AP Theta* name, angle (measured degrees) ray vertex p vertex
ray vertex p vertex . positive ray vertex p vertex clockwise
ray vertex p vertex , zero ray vertex p vertex heading
ray vertex p vertex , negative ray vertex p vertex counterclockwise
ray vertex p vertex . Figure 12 shows example (C3, A4, C4) = 27
(C3, A4, B3) = 18. visible neighbor vertex guaranteed line-of-sight
parent vertex (but necessarily if) lb(s) (s, parent(s), ) ub(s) (Visibility
Property).
6.2 Update Angle Ranges
discuss AP Theta* calculates angle range vertex expands vertex.
calculation complicated fact AP Theta* guaranteed sufficient
information determine angle range exactly since order vertex expansions depends
variety factors, h-values. case, AP Theta* constrain angle range
necessary guarantee Visibility Property holds finds unblocked paths.
AP Theta* expands vertex s, sets angle range vertex initially [, ], meaning
visible neighbors vertex guaranteed line-of-sight parent vertex.
constrains angle range vertex start vertex.
AP Theta* constrains angle range vertex based blocked cell b adjacent
vertex (that is, vertex corner b, written corners(b)) provided least one
two conditions satisfied:
Case 1: every corner blocked cell b satisfies least one following conditions:
parent(s) =
551

fiDANIEL , NASH , KOENIG , & F ELNER

(s, parent(s), ) < 0
(s, parent(s), ) = 0 c(parent(s), ) c(parent(s), s),
AP Theta* assumes vertex line-of-sight parent vertex
ray parent vertex vertex counterclockwise ray
parent vertex vertex , is, (s, parent(s), ) < 0. AP Theta* therefore sets
lower angle bound vertex (s, parent(s), s) = 0 [Line 83].
Case 2: every corner blocked cell b satisfies least one following conditions:
parent(s) =
(s, parent(s), ) > 0
(s, parent(s), ) = 0 c(parent(s), ) c(parent(s), s),
AP Theta* assumes vertex line-of-sight parent vertex
ray parent vertex vertex clockwise ray parent
vertex vertex , is, (s, parent(s), ) > 0. AP Theta* therefore sets upper
angle bound vertex (s, parent(s), s) = 0 [Line 86].
AP Theta* constrains angle range vertex based visible neighbor vertex
provided least one two conditions satisfied:
Case 3: vertex satisfies following conditions:
closed

parent(s) = parent(s )
6= sstart ,
AP Theta* constrains angle range vertex intersecting angle range
vertex [Lines 90 92]. that, first shifts angle range vertex
(s, parent(s), ) degrees take account angle range vertex calibrated
heading ray joint parent vertices vertex zero
degrees, angle range vertex calibrated heading ray
joint parent vertices vertex zero degrees. Lines 89 91 ensure
lower angle bound always remains non-positive upper angle bound always remains
non-negative, respectively. fact lower angle bounds non-positive (and
upper angle bounds non-negative) intuitive vertex assigned parent vertex p
angle ray vertex p vertex included angle range
vertex s.
Case 4: vertex satisfies following conditions:
c(parent(s), ) < c(parent(s), s)
parent(s) 6=
552

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

6 closed parent(s) 6= parent(s ),
AP Theta* insufficient information vertex . AP Theta* therefore cannot
determine angle range vertex exactly makes conservative assumption
vertex barely line-of-sight parent vertex [Lines 95 97].
Visibility Property holds AP Theta* updated angle range vertex procedure
UpdateBounds. Thus, AP Theta* checks whether visible neighbor vertex
line-of-sight parent vertex s, checks whether lb(s) (s, parent(s), )
ub(s) [Line 60] true instead whether LineOfSight(parent(s), ) [Line 42] true .
differences AP Theta* Basic Theta*.
Figure 13(a) shows example AP Theta* calculates angle range vertex A4. sets
angle range [, ]. Figure 13(b) shows example AP Theta* calculates angle
range vertex B3. sets angle range initially [, ]. sets lower angle bound
0 degrees according Case 1 based blocked cell A2-A3-B3-B2 [Line 83]. sets
upper angle bound 45 degrees according Case 4 based vertex B4, unexpanded
thus closed list [Line 97]. Figure 13(c) shows example AP Theta* calculates
angle range vertex B2. sets angle range initially [, ]. sets lower
angle bound 0 degrees according Case 1 based blocked cell A2-A3-B3-B2 [Line 83].
Assume vertex C1 goal vertex. Figure 13(d) shows example AP Theta*
calculates angle range vertex C1. sets angle range initially [, ]. sets
lower angle bound -27 degrees according Case 3 based vertex B2 [Line 90] upper
angle bound 18 degrees according Case 4 based vertex C2, unexpanded thus
closed list [Line 97].
6.3 Example Trace AP Theta*
Figure 13 shows example trace AP Theta* using path-planning problem Figure 8.
labels vertices include angle ranges.
6.4 Properties AP Theta*
discuss properties AP Theta*. AP Theta* operates way Basic Theta*
thus similar properties Basic Theta*. example, AP Theta* correct complete.
guaranteed find true shortest paths, paths occasionally unnecessary heading
changes.
AP Theta* sometimes constrains angle ranges necessary guarantee finds
unblocked paths, means line-of-sight checks sometimes fail incorrectly case
update vertices according Path 1 rather Path 2. AP Theta* still complete since
finds unblocked grid path line-of-sight checks fail, always exists unblocked
grid path exists unblocked any-angle path. However, paths found AP Theta*
longer found Basic Theta*. Figure 14 shows example. AP Theta* expands
vertex C4 parent B1 calculates angle range vertex C4, vertex C3 unexpanded
thus closed list. means AP Theta* insufficient information vertex
553

fiDANIEL , NASH , KOENIG , & F ELNER

2

3

4

1

5

1.00

0.00

1.00

A4

sstart

A4

3

4

1.00
A4

]

8
8

[ ,

2



B

1.41

1.00

1.41

A4

A4

A4

C

2.41

1.41

1.00

1.41

B3

A4
[0,45]

A4

A4

C

2.83

2.24

2.00

A4

A4

A4

2

(b)

3

3.82

3.41

B2

B2

4

1

5

0.00

1.00
A4

1.00
A4

sstart

2

3

3.82

3.41

B2

B2

4
1.00
A4

]

2.41

B3

B3
[0, ]

C

3.65

2.83

B3

A4

1.41
A4
[0,45]

1.00
A4

2.24
A4

2.00
A4

B

1.41
A4

3.41

2.41

B3

B3
[0, ]

3.65

2.83

B3
[27,18]

A4

8

3.41

8

B

5

0.00

sstart

1.00
A4

[ , ]

8
8

[ ,



8
8

1

1.00
A4

sstart
[ , ]

B

(a)


5

0.00
8
8

1


C

(c)

1.41
A4
[0,45]

1.00
A4

2.24
A4

2.00
A4

1.41
A4

(d)

Figure 13: Example trace AP Theta*
1

2

3

4

5

6




B

C



start

1111
0000
0000
1111
0000
1111
0000
1111
0000
1111
0000
1111
0000
1111
0000
1111
0000
1111

sgoal

Basic Theta* path

AP Theta* path

Figure 14: Basic Theta* path versus AP Theta* path
C3 because, example, know whether cell C2-C3-D3-D2 unblocked. AP
Theta* therefore cannot determine angle range vertex C4 exactly makes conservative
assumption vertex C3 barely line-of-sight vertex B1 sets lower angle bound
vertex C4 according Case 4 based vertex C3. uses resulting angle range
determine unexpanded visible neighbor D4 vertex C4 guaranteed line-ofsight vertex B1. However, vertex D4 line-of-sight vertex B1 cell C2-C3-D3-D2
554

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

Figure 15: Map Baldurs Gate II
unblocked. AP Theta* eventually finds solid blue path [B1, C3, D4] start vertex B1
vertex D4, Basic Theta* finds dashed red path [B1, D4], true shortest path.
correctness completeness proof Basic Theta* needs get changed slightly AP Theta*
since AP Theta* performs line-of-sight checks differently.
Theorem 2. AP Theta* terminates path extraction retrieves unblocked path start
vertex goal vertex path exists. Otherwise, AP Theta* terminates reports
unblocked path exists.
Proof. proof similar proof Theorem 1 since AP Theta* uses angle ranges
determine whether Path 2 blocked determine whether Path 1 blocked.
property needs proved differently two vertices indeed line-of-sight
(but necessarily if) line-of-sight check AP Theta* succeeds, see Appendix B.

7. Experimental Results
section, compare Basic Theta* AP Theta* A* grids, A* PS, FD* A*
visibility graphs respect path length, number vertex expansions, runtime (measured
seconds) number heading changes.
compare path-planning algorithms 100 100 500 500 grids different percentages randomly blocked cells (random grids) scaled maps real-time strategy
game Baldurs Gate II (game maps). Figure 15 (Bulitko, Sturtevant, & Kazakevich, 2005) shows
example game map. start goal vertices south-west corners cells. random
grids, start vertex south-west cell. goal vertex cell randomly chosen
column cells furthest east. Cells blocked randomly one-unit border unblocked
cells guarantees path start vertex goal vertex. game maps, start
goal vertices randomly chosen corners unblocked cells. average 500
random 100 100 grids, 500 random 500 500 grids 118 game maps.
555

fiDANIEL , NASH , KOENIG , & F ELNER

500500

100100

FD*
Game Maps
Random Grids 0%
Random Grids 5%
Random Grids 10%
Random Grids 20%
Random Grids 30%
Game Maps
Random Grids 0%
Random Grids 5%
Random Grids 10%
Random Grids 20%
Random Grids 30%

40.04
114.49
114.15
114.74
115.20
115.45
223.64
576.19
568.63
576.23
580.19
581.73

Basic Theta* AP Theta* A* Visibility Graphs A* Grids
(true shortest path)
39.98
40.05
39.96
41.77
114.33
114.33
114.33
120.31
113.94
113.94
113.83
119.76
114.51
114.51
114.32
119.99
114.93
114.95
114.69
120.31
115.22
115.25
114.96
120.41
223.30
224.40
N/A
233.66
575.41
575.41
N/A
604.80
567.30
567.34
N/A
596.45
574.57
574.63
N/A
603.51
578.41
578.51
N/A
604.93
580.18
580.35
N/A
606.38

A* PS
40.02
114.33
114.71
115.46
116.16
116.69
223.70
575.41
573.46
581.03
585.62
588.98

Table 1: Path length

500500

100100

FD*
Game Maps
Random Grids 0%
Random Grids 5%
Random Grids 10%
Random Grids 20%
Random Grids 30%
Game Maps
Random Grids 0%
Random Grids 5%
Random Grids 10%
Random Grids 20%
Random Grids 30%

0.0111
0.0229
0.0275
0.0305
0.0367
0.0429
0.1925
0.3628
0.4514
0.5608
0.6992
0.8562

Basic Theta* AP Theta* A* Visibility Graphs A* Grids
(true shortest path)
0.0060
0.0084
0.4792
0.0048
0.0073
0.0068
0.0061
0.0053
0.0090
0.0111
0.0766
0.0040
0.0111
0.0145
0.3427
0.0048
0.0150
0.0208
1.7136
0.0084
0.0183
0.0263
3.7622
0.0119
0.1166
0.1628
N/A
0.0767
0.1000
0.0234
N/A
0.0122
0.1680
0.1962
N/A
0.0176
0.2669
0.3334
N/A
0.0573
0.3724
0.5350
N/A
0.1543
0.5079
0.7291
N/A
0.3238

A* PS
0.0052
0.0208
0.0206
0.0204
0.0222
0.0240
0.1252
0.6270
0.6394
0.6717
0.6852
0.7355

Table 2: Runtime

500500

100100

FD*
Game Maps
Random Grids 0%
Random Grids 5%
Random Grids 10%
Random Grids 20%
Random Grids 30%
Game Maps
Random Grids 0%
Random Grids 5%
Random Grids 10%
Random Grids 20%
Random Grids 30%

247.07
592.74
760.17
880.21
1175.42
1443.44
6846.62
11468.11
15804.81
19874.62
26640.83
34313.28

Basic Theta* AP Theta* A* Visibility Graphs A* Grids
(true shortest path)
228.45
226.42
68.23
197.19
240.42
139.53
1.00
99.00
430.06
361.17
35.35
111.96
591.31
520.91
106.23
169.98
851.79
813.14
357.33
386.41
1113.40
1089.96
659.36
620.18
6176.37
6220.58
N/A
5580.32
2603.40
663.34
N/A
499.00
7450.85
5917.25
N/A
755.66
11886.95
10405.34
N/A
2203.83
18621.61
17698.75
N/A
6777.15
25744.57
25224.92
N/A
14641.36

A* PS
315.08
1997.29
1974.27
1936.56
2040.10
2153.28
9673.88
49686.47
49355.41
50924.01
50358.66
53732.82

Table 3: Number vertex expansions

path-planning algorithms implemented C# executed 3.7 GHz Core 2 Duo 2
GByte RAM. implementations optimized possibly improved.
556

fiT HETA *: NY-A NGLE PATH P LANNING

500500

100100

FD*
Game Maps
Random Grids 0%
Random Grids 5%
Random Grids 10%
Random Grids 20%
Random Grids 30%
Game Maps
Random Grids 0%
Random Grids 5%
Random Grids 10%
Random Grids 20%
Random Grids 30%

34.25
123.40
113.14
106.66
98.76
96.27
219.70
667.00
592.65
559.69
506.10
481.16

G RIDS



Basic Theta* AP Theta* A* Visibility Graphs A* Grids
(true shortest paths)
3.08
3.64
2.92
5.21
0.00
0.00
0.00
0.99
5.14
6.03
5.06
6.00
8.96
9.87
8.84
10.85
15.21
15.96
14.74
19.42
19.96
20.62
19.44
26.06
4.18
7.58
N/A
10.19
0.00
0.00
N/A
1.00
21.91
27.99
N/A
24.68
41.60
47.40
N/A
49.73
72.49
76.79
N/A
91.40
97.21
100.31
N/A
123.81

A* PS
2.83
0.00
4.53
8.48
14.45
18.35
3.84
0.00
22.27
43.16
69.44
89.43

592

0.9

589

0.8

586

0.7

583

0.6

580

0.5

Runtime

Path Length

Table 4: Number heading changes

577

0.4

574

0.3

571

0.2

568

0.1

565

0
0

5

10

20

30

0

5

10

% Blocked
FD*

Basic Theta*

20

30

% Blocked

AP Theta*

A* PS

FD*

Basic Theta*

(a) Path length

AP Theta*

A* PS

A*

(b) Runtime

60000

800

700

Number Heading Changes

50000

Vertex Expansions

40000

30000

20000

600

500

400

300

200
10000
100

0

0
0

5

10

20

30

0

5

% Blocked
FD*

Basic Theta*

10

20

30

% Blocked

AP Theta*

A* PS

A*

FD*

(c) Number vertex expansions

Basic Theta*

AP Theta*

A* PS

A*

(d) Number heading changes

Figure 16: Random 500 500 grids

557

fiDANIEL , NASH , KOENIG , & F ELNER

99 h(s)
x := |s.x (sgoal ).x|;
100
:= |s.y (sgoal ).y|;
101

102
largest := max(x , );
103
smallest := min(x , );

104
return 2 smallest + (largest smallest);
105 end

Algorithm 5: Calculation octile distances

A* grids, A* PS, FD* A* visibility graphs break ties among vertices fvalue open list favor vertices larger g-values (when decide vertex
expand next) since tie-breaking scheme typically results fewer vertex expansions thus
shorter runtimes A*. Care must thus taken calculating g-values, h-values fvalues precisely. numerical precision
floating point numbers improved A*
grids representing form + 2n integers n. Basic Theta* AP
Theta* break ties favor vertices smaller g-values reasons explained Section 9.
use path-planning algorithms consistent h-values since consistent h-values result
short paths A*. Consistent h-values satisfy triangle inequality, is, h-value
goal vertex zero h-value potential non-goal parent vertex greater
distance potential non-goal parent vertex vertex plus h-value
vertex (Hart et al., 1968; Pearl, 1984). Consistent h-values lower bounds corresponding
goal distances vertices. Increasing consistent h-values typically decreases number vertex
expansions A* thus runtime A*. thus use path-planning algorithms
largest consistent h-values easy calculate. Basic Theta*, AP Theta*, FD*
A* visibility graphs, goal distances vertices equal true goal distances,
is, goal distances grids paths constrained grid edges. therefore use
path planning algorithms straight-line distances h(s) = c(s, sgoal ) h-values
experiments. straight-line distances goal distances grids without blocked cells
paths constrained grid edges. A* grids A* PS, goal distances vertices
equal goal distances grids paths constrained grid edges. could therefore
use larger octile distances h-values experiments. octile distances
goal distances grids without blocked cells paths constrained grid edges. Algorithm
5 shows calculate octile distance given vertex s, s.x s.y x
coordinates vertex s, respectively. indeed use A* grids octile distances A*
PS straight-line distances since smoothing typically able shorten resulting
paths much increase number vertex expansions thus runtime. Grids without
blocked cells provide example. octile
distances h-values, A* grids finds paths
diagonal movements (whose lengths 2) precede horizontal vertical movements
(whose lengths 1) paths largest number diagonal movements
longest ones among paths number movements due tie-breaking scheme
used. hand, straight-line distances h-values, A* grids finds paths
interleave diagonal movements horizontal vertical movements (which means
likely lots opportunities smooth paths even grids blocked
cells) closer straight line start goal vertices (which means
likely paths closer true shortest paths even grids blocked cells),
558

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

Figure 17: True shortest paths found FD* (left), A* PS (middle) Basic Theta* (right)
h-values vertices closer straight line typically smaller h-values
vertices farther away straight line.
Tables 1-4 report experimental results. runtime A* visibility graphs (which finds
true shortest paths) long 500 500 grids thus omitted. Figure 16 visualizes
experimental results random 500 500 grids. path length A* grids much larger
path lengths path-planning algorithms thus omitted.
make following observations path lengths:
path-planning algorithms order increasing path lengths tend be: A* visibility
graphs (which finds true shortest paths), Basic Theta*, AP Theta*, FD*, A* PS A*
grids. random 500 500 grids 20 percent blocked cells, Basic Theta* finds shorter
paths AP Theta* 70 percent time, shorter paths FD* 97 percent time,
shorter paths A* PS 94 percent time shorter paths A* grids 99 percent
time.
paths found Basic Theta* AP Theta* almost short true shortest paths even
though AP Theta* sometimes constrains angle ranges necessary. example,
average less factor 1.003 longer true shortest paths 100 100
grids.
Basic Theta* finds true shortest paths often FD* A* PS. Figure 17 shows
example light green vertex center start vertex red, green
blue vertices represent goal vertices FD*, A* PS Basic Theta* find true shortest
paths, respectively.
make following observations runtimes. path-planning algorithms order
increasing runtimes tend be: A* grids, Basic Theta*, AP Theta*, A* PS, FD* A*
visibility graphs.
make following observations numbers vertex expansions. path-planning
algorithms order increasing numbers vertex expansions tend be: A* visibility graphs,
A* grids, AP Theta*, Basic Theta*, FD* A* PS. (The number vertex expansions A*
grids A* PS different use different h-values.)
559

fiDANIEL , NASH , KOENIG , & F ELNER

Runtime
Runtime per Vertex Expansion

FD*
5.21
0.000021

Basic Theta*
3.65
0.000015

AP Theta*
5.70
0.000023

A* PS
3.06
0.000012

Table 5: Path-planning algorithms without post-processing steps random 500 500 grids
20 percent blocked cells

Finally, make following observations number heading changes. pathplanning algorithms order increasing numbers heading changes tend be: A* PS, A*
visibility graphs, Basic Theta*, AP Theta*, A* grids FD*.
exceptions trends reported above. therefore perform paired t-tests.
show confidence level = 0.01 Basic Theta* indeed finds shorter paths AP Theta*,
A* PS FD* Basic Theta* indeed shorter runtime AP Theta*, A* PS
FD*.
summarize, A* visibility graphs finds true shortest paths slow. hand, A*
grids finds long paths fast. Any-angle path planning lies two extremes.
Basic Theta* dominates AP Theta*, A* PS FD* terms tradeoff runtime
path length. finds paths almost short true shortest paths almost fast
A* grids. simpler implement AP Theta*. Therefore, build Basic Theta*
remainder article, although report experimental results AP Theta*
well. However, AP Theta* reduces runtime Basic Theta* per vertex expansion linear
constant. currently unknown whether constant time line-of-sight checks devised
make AP Theta* faster Basic Theta*. interesting area future research since
AP Theta* potentially first step toward significantly reducing runtime any-angle path
planning via sophisticated line-of-sight checks.

8. Extensions Theta*
section, extend Basic Theta* find paths given start vertex vertices
find paths grids contain unblocked cells non-uniform traversal costs.
8.1 Single Source Paths
far, Basic Theta* found paths given start vertex given goal vertex. discuss
version Basic Theta* finds single source paths (that is, paths given start vertex
vertices) terminating open list empty instead either open list
empty expands goal vertex.
Finding single source paths requires path-planning algorithms expand number
vertices, minimizes influence h-values runtime thus results clean
comparison since h-values sometimes chosen trade runtime path length.
runtimes A* PS FD* effected Basic Theta* AP Theta*
finding single source paths since require post-smoothing path-extraction steps
560

fiT HETA *: NY-A NGLE PATH P LANNING



1

2

3

4

5



G RIDS

6
I6

I5
I4

B

I3
I2
I1

C

I0

Basic Theta* path Non-Uniform Traversal Costs

Figure 18: Basic Theta* grids contain unblocked cells non-uniform traversal costs

(a) Small contiguous regions uniform traversal costs
Path Cost
Runtime

A* Grids
4773.59
11.28

FD*
4719.26
14.98

Basic Theta*
4730.96
19.02

(b) Large contiguous regions uniform traversal costs
Path Cost
Runtime

A* Grids
1251.88
3.42

FD*
1208.89
5.31

Basic Theta*
1207.06
5.90

Table 6: Path-planning algorithms random 1000 1000 grids non-uniform traversal costs

path, thus need post-process many paths. Table 5 reports runtimes path-planning
algorithms without post-processing steps. runtime Basic Theta* per vertex expansion
similar A* PS shorter either AP Theta* FD* later two
algorithms require floating point operations.
8.2 Non-Uniform Traversal Costs
far, Basic Theta* found paths grids contain unblocked cells uniform traversal
costs. case, true shortest paths heading changes corners blocked cells
triangle inequality holds, means Path 2 longer Path 1. discuss
version Basic Theta* finds paths grids contain unblocked cells non-uniform
traversal costs computing comparing path lengths (which path costs) appropriately.
case, true shortest paths heading changes boundaries unblocked
cells different traversal costs triangle inequality longer guaranteed hold,
means Path 2 costly Path 1. Thus, Basic Theta* longer unconditionally
chooses Path 2 Path 1 Path 2 unblocked [Line 42] chooses path smaller
cost. uses standard Cohen-Sutherland clipping algorithm computer graphics (Foley, van
Dam, Feiner, & Hughes, 1992) calculate cost Path 2 line-of-sight check. Figure
18 shows example path segment C1A6 vertex C1 vertex A6. straight line
split line segments points intersects cell boundaries. cost path
segment sum costs line segments Ii Ii+1 , cost line segment
product length traversal cost corresponding unblocked cell.
found changing test Line 52 Algorithm 3 strictly less less
equal slightly reduces runtime Basic Theta*. result fact faster
compute cost path segment corresponds Path 1 Path 2 since tends consist
fewer line segments.
561

fiDANIEL , NASH , KOENIG , & F ELNER



2

1

3

4

5



goal

1

2

3

4

5

goal
h =2.24

h =3.16
B

B

g =1.41
g =2.24
C

C

start

start

(a)

(b)

Figure 19: Non-monotonicity f-values Basic Theta*

compare Basic Theta* A* grids FD* respect path cost runtime
(measured seconds) since A* easily adapted grids contain unblocked cells
non-uniform traversal costs FD* designed case. compare path-planning
algorithms 1000 1000 grids, cell assigned integer traversal cost 1 15
(corresponding unblocked cell) infinity (corresponding blocked cell), similar
technique used work Ferguson Stentz (2006) . path lies boundary
two cells different traversal costs, use smaller traversal cost two cells.
start goal vertices south-west corners cells. start vertex south-west cell.
goal vertex cell randomly chosen column cells furthest east. average
100 random grids. Table 6 (a) reports results every traversal cost chosen uniform
probability, resulting small contiguous regions uniform traversal costs. path cost
runtime FD* smaller Basic Theta*. path cost A* grids
1 percent larger FD* although runtime much smaller FD*. Thus,
any-angle planning large advantage A* grids. Table 6(b) reports results
traversal cost one chosen probability 50 percent traversal costs chosen
uniform probability, resulting large contiguous regions uniform traversal costs. path
cost Basic Theta* smaller FD* runtime
FD*. paths found FD* tend many unnecessary heading changes regions
traversal costs Basic Theta*, outweighs paths found Basic
Theta* necessary heading changes boundary two cells different
traversal costs. path cost A* grids 3 percent larger Basic Theta*.
Thus, any-angle planning larger advantage A* grids.

9. Trading Runtime Path Length: Exploiting h-Values
strategies trading runtime path length A* grids Basic Theta* share.
However, behavior different even though two algorithms similar
pseudocode. section, develop versions Basic Theta* might able find shorter
paths increase runtime, including versions use weighted h-values weights less
one, break ties among vertices f-value open list favor vertices
smaller g-values (when decide vertex expand next) re-expand vertices whose
f-values decreased.
562

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

use path-planning algorithms consistent h-values. A* grids following
properties (Pearl, 1984): f-value expanded vertex larger f-value
unexpanded visible neighbors updating according Path 1, implies
f-value vertex expanded vertex larger f-value
vertex. Consequently, point time search vertex expanded,
following parents expanded vertex start vertex retrieves shortest path
start vertex expanded vertex reverse, implies A* cannot find shorter paths
expanding vertices once. Basic Theta* different properties: f-value
expanded vertex larger f-value one unexpanded visible neighbors
updating according Path 2, implies f-value vertex expanded
vertex larger f-value vertex. Consequently,
point time search vertex expanded, following parents
expanded vertex start vertex guaranteed retrieve shortest path start vertex
vertex reverse, implies Basic Theta* might find shorter paths expanding
vertices once. Figure 19 shows example. Basic Theta* expands start vertex C1
parent C1, generates vertex B2. Vertex B2 unexpanded visible neighbor vertex C1
line-of-sight vertex C1. Basic Theta* thus updates according Path 2 (which
Path 1 case), sets f-value f (B2) = 1.41 + 3.16 = 4.57, sets parent vertex
C1 inserts open list (Figure 19(a)). Basic Theta* later expands vertex B2
parent C1, generates vertex B3. Vertex B3 unexpanded visible neighbor vertex B2
line-of-sight vertex C1. Basic Theta* thus updates according Path 2, sets f-value
f (B3) = 2.24 + 2.24 = 4.48, sets parent vertex C1 inserts open list (Figure
19(b)). Thus, f-value expanded vertex B2 indeed larger f-value unexpanded
visible neighbor B3 updating according Path 2 increase g-value vertex
B2 vertex B3 [= 0.83] less decrease h-value vertex B2 vertex B3 [= 0.92].
Basic Theta* later expands vertex B3, f-value vertex B2 [= 4.57] expanded
vertex B3 indeed larger f-value vertex B3 [= 4.48].
properties suggest Basic Theta* might able find shorter paths increase
runtime re-expanding vertices expanding additional vertices (for example using weighted
h-values weights less one) A* cannot. time, standard optimizations
A* decrease runtime might able decrease runtime Basic Theta* (such
breaking ties among vertices f-value open list favor vertices larger
g-values). section investigate tradeoffs.
9.1 Weighted h-Values
far, Basic Theta* used consistent h-values h(s). A* consistent h-values finds paths
length matter small large h-values are. Decreasing consistent h-values typically
increases number vertex expansions A*. therefore discuss version Basic
Theta* might able find shorter paths increase runtime using weighted h-values
weights less one. version Basic Theta* uses h-values h(s) = w c(s, sgoal )
given weight 0 w < 1 thus similar Weighted A* (Pohl, 1973), except Weighted
A* typically uses weights greater one. Figure 20(a) shows example resulting effect
number vertex expansions path length. green vertex north-east start

563

fiDANIEL , NASH , KOENIG , & F ELNER

(a) Expanded vertices Basic Theta* different weights
578.6

250000

578.4
200000
578.2

Path Length

150000

577.8

100000
577.6

Vertex Expansions

578

577.4
50000
577.2

577

0
0

0.25

0.5

0.75

0.8

0.85

0.9

0.95

1

w
Basic Theta* Path Length

AP Theta* Path Length

Basic Theta* Vertex Expansions

AP Theta* Vertex Expansions

(b) Random 500 500 grids 20 percent blocked cells

Figure 20: Weighted h-values

vertex, red vertex south-west goal vertex. Basic Theta* weight 1.00 (as
used far) expands orange vertices finds red path. Basic Theta* weight 0.75
expands blue vertices finds blue path. Thus, Basic Theta* expands vertices
564

fiT HETA *: NY-A NGLE PATH P LANNING

Path Length
Number Vertex Expansions
Runtime

Smaller g-Values
Basic Theta* AP Theta*
578.41
578.51
18621.61
17698.75
0.3724
0.5350



G RIDS

Larger g-Values
Basic Theta* AP Theta*
578.44
578.55
18668.03
17744.94
0.3829
0.5389

Table 7: Random 500 500 grids 20 percent blocked cells


weight 0.75 weight 1.00 resulting path shorter since passes vertices
expanded weight 0.75 weight 1.00.
Figure 20(b) reports effect different weights path length number vertex expansions Basic Theta* AP Theta* random 500 500 grids 20 percent blocked cells.
(The graphs number vertex expansions Basic Theta* AP Theta* nearly coincide.)
Decreasing weight decreases path length increase number vertex expansions
thus runtime. path length decreases AP Theta* Basic Theta* since AP
Theta* constrain angle ranges necessary thus benefits two ways expanding vertices. However, neither Basic Theta* AP Theta* guaranteed find true
shortest paths even weights zero.
9.2 Tie Breaking
far, Basic Theta* broken ties among vertices open list f-value favor
vertices larger g-values (when decides vertex expand next). A* consistent
h-values finds paths length matter tie-breaking scheme uses. Breaking ties
favor vertices smaller g-values typically increases number vertex expansions
thus runtime. therefore discuss version Basic Theta* might able find shorter
paths increase runtime breaking ties favor vertices smaller g-values. Figure 21
shows example resulting effect path length. Vertices C4 B4 f-value
vertex B4 larger g-value since f (C4) = 3.83+1.41 = 5.24 f (B4) = 4.24+1 = 5.24.
Basic Theta* breaks ties favor vertices larger g-values, expands vertex B4
parent E1 vertex C4 parent C3 eventually expands goal vertex parent B4
terminates. Path extraction follows parents goal vertex B5 start vertex E1
retrieve dashed red path [E1, B4, B5]. However, Basic Theta* breaks ties favor vertices
smaller g-values, expands vertex C4 parent C3 vertex B4 parent E1
eventually expands goal vertex parent C3 terminates. Path extraction follows
parents goal vertex B5 start vertex E1 retrieve shorter solid blue path [E1, C3,
B5].
Table 7 reports effect tie-breaking scheme path length, number vertex expansions
runtime Basic Theta* AP Theta* random 500 500 grids 20 percent blocked
cells. Breaking ties favor vertices smaller g-values neither changes path length,
number vertex expansions runtime significantly. effect tie-breaking scheme
small since fewer vertices f-value Basic Theta* AP Theta* A*
grids number possible g-values h-values larger any-angle path planning.
565

fiDANIEL , NASH , KOENIG , & F ELNER



1

2

3

B

4

5

goal

C



E

start

Basic Theta* path (Larger g-values)

Basic Theta* path (Smaller g-values)

Figure 21: Basic Theta* paths different tie-breaking schemes

Path Length
Number Vertex Expansions
Runtime

Basic Theta* without Vertex Re-Expansions
578.41
18621.61
0.3724

Basic Theta* Vertex Re-Expansions
577.60
22836.37
0.5519

Table 8: Random 500 500 grids 20 percent blocked cells

second method breaking ties effect path length. far, Basic Theta*
chosen Path 2 Path 1 unexpanded visible neighbor vertex line-of-sight
parent vertex. However, choose Path 1 Path 2 paths equally long,
increases runtime due additional comparison. Figure 21 shows example
resulting effect path length. Assume Basic Theta* expands vertex B4 vertex C4.
Basic Theta* chooses Path 2 Path 1 expands vertex B4 parent E1 eventually
expands goal vertex B5 parent B4 terminates. Path extraction follows parents
goal vertex B5 start vertex E1 retrieve dashed red path [E1, B4, B5]. However,
Basic Theta* chooses Path 1 Path 2 expands vertex B4 parent C3 eventually
expands goal vertex B5 parent C3 terminates. Path extraction follows parents
goal vertex B5 start vertex E1 retrieve shorter solid blue path [E1, C3, B5].
9.3 Re-Expanding Vertices
far, Basic Theta* used closed list ensure expands vertex once. A*
consistent h-values re-expand vertices whether uses closed list since
cannot find shorter path start vertex vertex expanding vertex.
hand, Basic Theta* re-expand vertices use closed list since find shorter
path start vertex vertex expanding vertex. re-inserts vertex
566

fiT HETA *: NY-A NGLE PATH P LANNING



1

2

3

4

5

6



7

G RIDS

8

B

9

goal

C



E

start

Basic Theta* path

Basic Theta* path vertex re-expansions

Figure 22: Basic Theta* paths without vertex re-expansions
open list eventually re-expands it.2 Figure 22 shows example effect vertex
re-expansions path length. Basic Theta* without vertex re-expansions eventually expands vertex
C8 parent D4. Vertex C9 unexpanded visible neighbor vertex C8 line-of-sight
vertex D4. Basic Theta* without vertex re-expansions thus updates according Path 2
sets parent vertex D4. termination, path extraction follows parents goal vertex
B9 start vertex E1 retrieve dashed red path [E1, D4, C9, B9]. However, Basic Theta*
vertex re-expansions eventually expands vertex C8 parent D4 later re-expands vertex C8
parent E1. Vertex C9 visible neighbor vertex C8 line-of-sight vertex E1.
Basic Theta* vertex re-expansions thus updates according Path 2 sets parent
vertex E1. termination, path extraction follows parents goal vertex B9 start vertex
E1 retrieve shorter solid blue path [E1, C9, B9].
Theorem 3. Basic Theta* vertex re-expansions terminates path extraction returns
unblocked path start vertex goal vertex path exists. Otherwise, Basic
Theta* vertex re-expansions terminates reports unblocked path exists.

Proof. proof similar proof Theorem 1. property needs proved
differently Basic Theta* vertex re-expansions terminates since longer true
never insert vertex open list removed vertex open list.
However, since number vertices finite, finite number acyclic paths
start vertex vertex. Therefore, number possible g-values finite. Therefore, Basic
Theta* vertex re-expansions reduce g-value vertex finite number times
thus inserts vertex open list finite number times. Thus, open list eventually
becomes empty Basic Theta* terminate terminated earlier already.
2. Basic Theta* vertex re-expansions could delay expansion goal vertex (for example, increasing
f-value artificially) re-expand vertices terminates version Basic Theta*
vertex re-expansions that.

567

fiDANIEL , NASH , KOENIG , & F ELNER

Table 8 reports effect vertex re-expansions path length, number vertex expansions
runtime Basic Theta* random 500 500 grids 20 percent blocked cells. Vertex
re-expansions decrease path length slightly increase number vertex expansions
thus runtime.

10. Trading Runtime Path Length: Approaches
additional strategies trading runtime path length specific Basic
Theta*. section, develop versions Basic Theta* might able find shorter
paths increase runtime examining paths, including versions check line-ofsight parent parent, use key vertices identify promising parents increase
number visible neighbors thus number potential parents updating vertices
according Path 1.
10.1 Three Paths
far, Basic Theta* considered two paths (namely Paths 1 2) updates gvalue parent unexpanded visible neighbor vertex s. discuss version
Basic Theta* considers third path, namely path start vertex parent
parent vertex [= g(parent(parent(s)))] vertex straight line [=
c(parent(parent(s)), )], resulting length g(parent(parent(s))) + c(parent(parent(s)), ).
version Basic Theta* might able find shorter paths increase runtime since
third path longer Path 2 due triangle inequality. However, experimental results
(not reported here) show third path decrease path length significantly
original version Basic Theta* already determines parent parent vertex
line-of-sight vertex shares parent vertex s. Thus, unlikely
parent parent vertex line-of-sight vertex thus third path
unblocked.
10.2 Key Vertices
far, Basic Theta* considered two paths (namely Paths 1 2) updates g-value
parent unexpanded visible neighbor vertex s. parent vertex either
visible neighbor vertex parent visible neighbor, always case
true shortest paths. discuss version Basic Theta* considers additional paths,
namely paths start vertex cached key vertices vertex straight
line. version Basic Theta* might able find shorter paths increase runtime
due fact parent vertex one key vertices. However,
experimental results (not reported here) show key vertices decrease path length slightly
larger increase runtime due overhead select key vertices, maintain
consider larger number paths.

568

fiT HETA *: NY-A NGLE PATH P LANNING

(a) Branching factor 4

(b) Branching factor 8



G RIDS

(c) Branching factor 16

Figure 23: Grids different branching factors

0.6

581
580.5

0.5

580

0.4

579
0.3

578.5

Runtime

Path Length

579.5

578
0.2

577.5
577

0.1

576.5
576

0
4

Basic Theta*

16

Branching Factor
Path Length

Runtime

Figure 24: Basic Theta* random 500 500 grids 20 percent blocked cells

10.3 Larger Branching Factors
far, Basic Theta* operated eight-neighbor grids. discuss version Basic Theta*
operates grids different numbers neighbors thus different branching factors.
Figure 23 shows neighbors center vertex branching factors 4, 8 16 respectively.
version Basic Theta* might able find shorter paths increase runtime since
larger branching factors increase number visible neighbors vertices thus number
potential parents updating according Path 1. Figure 24 reports effect larger
branching factors path length runtime Basic Theta* random 500 500 grids
20 percent blocked cells. Larger branching factors indeed decrease path length increase
runtime.
569

fiDANIEL , NASH , KOENIG , & F ELNER

11. Conclusions
Any-angle path-planning algorithms find paths without artificially constraining headings
paths. presented two new correct complete any-angle path-planning algorithms. Basic
Theta* Angle-Propagation Theta* (AP Theta*) variants A* propagate information along grid edges (to achieve short runtime) without constraining paths grid edges (to find
any-angle paths). Basic Theta* simple understand implement, fast finds short paths.
However, guaranteed find true shortest paths. AP Theta* achieves worst-case complexity per vertex expansion constant (like A* grids) rather linear number
cells (like Basic Theta*) propagating angle ranges expands vertices. However,
AP Theta* complex Basic Theta*, fast finds slightly longer paths.
proved correctness completeness Basic Theta* AP Theta* compared
three existing any-angle path-planning algorithms, namely A* post-smoothed
paths (A* PS), A* visibility graphs Field D* (FD*), version A* know
propagates information along grid edges without constraining paths grid edges. Basic
Theta* AP Theta* (unlike A* PS) consider paths constrained grid edges
search thus make informed decisions regarding paths search. Basic Theta*
AP Theta* (unlike FD*) take advantage fact true shortest paths heading changes
corners blocked cells.
A* visibility graphs finds true shortest paths slow. hand, A* grids finds
long paths fast. Any-angle path planning lies two extremes. Basic Theta*
dominates AP Theta*, A* PS FD* terms tradeoffs runtime path length.
finds paths almost short true shortest paths almost fast A* grids.
extended Basic Theta* find paths given start vertex vertices find
paths grids contain cells non-uniform traversal costs. f-value expanded vertex
Basic Theta* (unlike A* grids) consistent h-values larger f-value one
unexpanded visible neighbors, means Basic Theta* might able find
shorter paths increase runtime re-expanding vertices expanding additional vertices.
thus developed versions Basic Theta* use weighted h-values weights less one,
break ties among vertices f-value open list favor vertices smaller
g-values (when decide vertex expand next), re-expand vertices whose f-values
decreased, check line-of-sight parent parent, use key vertices identify
promising parents increase number visible neighbors.
future, intend develop worst-case bound path lengths Basic Theta* AP
Theta*, better understand properties investigate faster versions AP Theta*
perform line-of-sight checks constant time.

Appendix A. Checking Line-of-Sight
appendix, explain perform line-of-sight checks fast. simplicity, allow
straight lines pass diagonally touching blocked cells. Performing line-of-sight check
similar determining points plot raster display drawing straight line two points. plotted points correspond cells straight line passes through.
570

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

106 LineOfSight(s, s)
107
x0 := s.x;
108
y0 := s.y;
109
x1 := .x;
110
y1 := .y;
111
dy := y1 y0 ;
112
dx := x1 x0 ;
113
f := 0;
114
dy < 0
115
dy := dy ;
116
sy := 1;
117
118

else

119
120
121

dx < 0
dx := dx ;
sx := 1;

122
123

else

124
125
126
127
128
129

dx dy
x0 6= x1
f := f + dy ;
f dx
grid(x0 + ((sx 1)/2), y0 + ((sy 1)/2))
return false;

sy := 1;

sx := 1;

y0 := y0 + sy ;
f := f dx ;

130
131
132
133

f 6= 0 grid(x0 + ((sx 1)/2), y0 + ((sy 1)/2))
return false;

134
135

dy = 0 grid(x0 + ((sx 1)/2), y0 ) grid(x0 + ((sx 1)/2), y0 1)
return false;

136

x0 := x0 + sx ;

137
138
139
140
141
142

else
y0 6= y1
f := f + dx ;
f dy
grid(x0 + ((sx 1)/2), y0 + ((sy 1)/2))
return false;
x0 := x0 + sx ;
f := f dy ;

143
144
145
146

f 6= 0 grid(x0 + ((sx 1)/2), y0 + ((sy 1)/2))
return false;

147
148

dx = 0 grid(x0 , y0 + ((sy 1)/2)) grid(x0 1, y0 + ((sy 1)/2))
return false;

149

y0 := y0 + sy ;

150
return true;
151 end

Algorithm 6: Line-of-sight algorithm

Thus, two vertices line-of-sight iff none plotted points correspond blocked cells.
allows Basic Theta* perform line-of-sight checks standard Bresenham line-drawing
algorithm computer graphics (Bresenham, 1965), uses fast logical integer operations rather floating-point operations. Algorithm 6 shows resulting line-of-sight algorithm,
571

fiDANIEL , NASH , KOENIG , & F ELNER

II

yaxis



p
b0

xaxis

b1

b2
b3

b4

b5
b6

b7

b8
b9



III

b 10

Upper Boundary

IV
Lower Boundary

Figure 25: Parent, blocked cell boundary vertices
s.x s.y x coordinates vertex s, respectively, grid represents grid
grid(x, y) true iff corresponding cell blocked.

Appendix B. AP Theta* Returns Unblocked Paths
appendix, prove AP Theta* never returns blocked path.
Theorem 4. AP Theta* never returns blocked path.
Proof. define path blocked iff least one vertex path line-of-sight
successor path. Thus, path blocked iff least one path segments passes
interior blocked cell passes two blocked cells share edge.
first prove AP Theta* never returns path path segment passes
interior blocked cell. prove contradiction AP Theta* cannot assign parent p
vertex path segment parent p vertex passes interior
blocked cell b. Assume otherwise. simplify proof, translate rotate grid
blocked cell b immediately south-west origin b0 grid parent p quadrant
II, shown Figure 25. define quadrant vertex follows, s.x s.y
x coordinates vertex s, respectively:
Quadrant north-east quadrant (excluding x-axis) given s.x 0 s.y > 0.
Quadrant II north-west quadrant (excluding y-axis) given s.x < 0 s.y 0.
Quadrant III south-west quadrant (excluding x-axis) given s.x 0 s.y < 0.
572

fiT HETA *: NY-A NGLE PATH P LANNING

northwest(s)
west(s)
southwest(s)

north(s)


south(s)



G RIDS

northeast(s)
east(s)
southeast(s)

Figure 26: Neighbors vertex
Quadrant IV south-east quadrant (excluding y-axis including origin b0 ) given
s.x > 0 s.y 0 s.x = 0 s.y = 0.
refer neighbors vertex east(s), northeast(s), north(s), northwest(s), west(s),
southwest(s), south(s), southeast(s), shown Figure 26.
Assume light source vertex p light cannot pass blocked cell b,
creates shadow. vertex shadow iff straight line parent p vertex
passes interior blocked cell b. distinguish two parts perimeter
shadow, namely upper lower boundary, shown Figure 25. define boundary vertex
vertex shadow least one neighbor (although necessarily visible
neighbor) shadow. origin b0 shadow neighbor south(b0 )
shadow. Thus, origin b0 boundary vertex. consider upper boundary without
loss generality. Then, boundary vertex (to precise: upper boundary vertex) vertex
(s, p, b0 ) 0 (that is, upper boundary thus outside shadow)
least one neighbor (s , p, b0 ) > 0 (that is, upper boundary thus inside
shadow). easy see boundary vertices quadrant IV form infinite
boundary path [b0 , b1 , . . .] starts origin b0 repeatedly moves either south east,
is, bi+1 = south(bi ) bi+1 = east(bi ).
define vertex sufficiently constrained iff (s, p, b0 ) lb(s) parent p.
vertex sufficiently constrained, remains sufficiently constrained since operation AP
Theta* decrease lower angle bound lb(s). prove following every boundary
vertex sufficiently constrained time expanded expanded parent p. Consider
vertex upper boundary (that is, (s, p, b0 ) > 0 thus (b0 , p, s) < 0)
visible neighbor boundary vertex bi . Vertex cannot updated according Path 1
assigned parent p time parent p expanded since straight line parent p
vertex passes interior blocked cell therefore visible neighbors.
cannot updated according Path 2 assigned parent p time boundary
vertex bi expanded parent p boundary vertex bi sufficiently constrained
time thus (bi , p, b0 ) lb(bi ), implies (bi , p, s) = (bi , p, b0 ) + (b0 , p, s) <
(bi , p, b0 ) lb(bi ) condition Line 60 remains unsatisfied. Consequently, vertex
shadow parent p.
prove induction order vertex expansions every boundary vertex
sufficiently constrained time expanded expanded parent p. Assume
boundary vertex b0 expanded parent p. Then, condition Line 81 satisfied
573

fiDANIEL , NASH , KOENIG , & F ELNER

Line 83 executed blocked cell b time boundary vertex b0 expanded parent p.
Boundary vertex b0 sufficiently constrained afterwards since lower angle bound set zero.
assume boundary vertex bi > 0 expanded parent p. Then, boundary vertex bi
cannot identical parent p (since different quadrants) start vertex (since
start vertex parent p). Boundary vertex bi cannot updated according Path
1 assigned parent p time parent p expanded since p.x < 0 (bi ).x > 0
thus neighbors. Consequently, boundary vertex bi must updated according
Path 2 assigned parent p time one visible neighbors x expanded
parent p. Vertex x must upper boundary (that is, (x, p, b0 ) 0) cannot
identical parent p (since different quadrants). distinguish two cases:
Assume vertex x boundary vertex. sufficiently constrained time expanded parent p according induction assumption (that is, (x, p, b0 ) lb(x))
since expanded boundary vertex bi . Boundary vertex bi updated according
Path 2 time vertex x expanded parent p. Thus, condition Line
60 satisfied time (that is, lb(x) (x, p, bi )) thus lb(x) + (bi , p, x) =
lb(x) (x, p, bi ) 0. Then, conditions Lines 88 89 satisfied
Line 90 executed = x time boundary vertex bi expanded parent
p. Boundary vertex bi sufficiently constrained afterwards since lower angle bound
set max(lb(bi ), lb(x) + (bi , p, x)) (bi , p, b0 ) = (bi , p, x) + (x, p, b0 )
lb(x) + (bi , p, x) max(lb(bi ), lb(x) + (bi , p, x)).
Assume vertex x boundary vertex.
Lemma 3. Assume vertex boundary vertex bi visible neighbors, c(p, bi ) <
c(p, s) (s, p, bi ) < 0. Assume boundary vertex bi sufficiently constrained
time vertex expanded parent p boundary vertex bi expanded parent
p time. Then, vertex sufficiently constrained time expanded
expanded parent p.
Proof. Assume vertex expanded parent p. Then, (s, p, b0 ) = (s, p, bi ) +
(bi , p, b0 ) < 0 since (s, p, bi ) < 0 (bi , p, b0 ) 0. distinguish two cases:
Assume boundary vertex bi expanded vertex expanded
parent parent p. Then, conditions Lines 93 94 satisfied
Line 95 executed = bi time vertex expanded parent
p. Vertex sufficiently constrained afterwards since lower angle bound set
max(lb(s), (s, p, bi )) (s, p, b0 ) = (s, p, bi ) + (bi , p, b0 ) (s, p, bi )
max(lb(s), (s, p, bi )).
Assume boundary vertex bi expanded parent p vertex expanded
parent p. Boundary vertex bi sufficiently constrained time vertex
expanded parent p according premise (that is, (bi , p, b0 ) lb(bi )). Furthermore, lb(bi ) 0 (since operation AP Theta* make lower angle bound
positive) thus lb(bi ) + (s, p, bi ) 0. Then, conditions Lines 88 89
satisfied Line 90 executed = bi time vertex expanded
parent p. Vertex sufficiently constrained afterwards since lower angle bound
574

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

set max(lb(s), lb(bi ) + (s, p, bi )) (s, p, b0 ) = (s, p, bi ) + (bi , p, b0 )
lb(bi ) + (s, p, bi ) max(lb(s), lb(bi ) + (s, p, bi )).

Boundary vertex bi either immediately south east boundary vertex bi1 since
boundary path moves south east. distinguish three subcases:
Assume parent p x-axis quadrant II. Then, boundary path
along x-axis. Vertices west(bi ) east(bi ) boundary vertices, vertices
southwest(bi ), south(bi ), southeast(bi ) upper boundary. Thus,
vertex x identical one vertices northwest(bi ), north(bi ) northeast(bi ).
cases, boundary vertex bj immediately south vertex x. vertices x
bj visible neighbors, would blocked cells immediately southwest south-east vertex x vertices x bi could thus visible neighbors.
Thus, vertices x bj visible neighbors. Furthermore, boundary vertex bj immediately south vertex x thus c(p, bj ) < c(p, x) (x, p, bj ) < 0. Finally,
boundary vertex bj sufficiently constrained according induction assumption
time boundary vertex bi expanded parent p boundary vertex bj
expanded parent p time. Thus, vertex x sufficiently constrained time
expanded parent p according Lemma 3 (that is, (x, p, b0 ) lb(x)). Consequently, conditions Lines 88 89 satisfied (for reason given before)
Line 90 executed = x time boundary vertex bi expanded parent
p. Boundary vertex bi sufficiently constrained afterwards since lower angle bound
set max(lb(bi ), lb(x) + (bi , p, x)) (bi , p, b0 ) = (bi , p, x) + (x, p, b0 )
lb(x) + (bi , p, x) max(lb(bi ), lb(x) + (bi , p, x)).
Assume parent p x-axis quadrant II boundary vertex
bi immediately east boundary vertex bi1 thus c(p, bi1 ) < c(p, bi )
(bi , p, bi1 ) < 0. Furthermore, boundary vertex bi1 sufficiently constrained according induction assumption time boundary vertex bi expanded
parent p boundary vertex bi1 expanded parent p time. boundary vertices bi1 bi visible neighbors, boundary vertex bi sufficiently
constrained time expanded parent p according Lemma 3. boundary
vertices bi1 bi visible neighbors, must blocked cells immediately north-west south-west boundary vertex bi . Then, Line 81 satisfied
Line 83 executed blocked cell immediately south-west boundary vertex bi
time boundary vertex bi expanded parent p. Boundary vertex bi sufficiently
constrained afterwards since lower angle bound set zero.
Assume parent p x-axis quadrant II boundary vertex bi
immediately south boundary vertex bi1 .
Lemma 4. Assume vertex quadrant IV upper boundary.
Then, vertex boundary vertex iff vertex immediately south-west vertex
upper boundary.
575

fiDANIEL , NASH , KOENIG , & F ELNER

Proof. vertex immediately south-west vertex upper boundary,
vertex boundary vertex definition. hand, vertex
upper boundary (that is, (s , p, b0 ) 0), vertex boundary
vertex every neighbor upper boundary. neighbors
vertex
east(s), northeast(s), north(s), northwest(s),
west(s), southwest(s), south(s) southeast(s).
or, equivalently,
east(east(north(s ))), east(east(north(north(s )))), east(north(north(s ))),
north(north(s )), north(s ), , east(s ) east(east(s )).
Thus, every neighbor vertex reached vertex repeatedly moving either north east thus (s , p, ) 0. Consequently, (s , p, b0 ) =
(s , p, ) + (s , p, b0 ) 0 thus every neighbor vertex
upper boundary.
distinguish two subcases:
Assume boundary vertex bi+1 immediately east boundary vertex
bi . Vertices north(bi ) east(bi ) boundary vertices. Vertices west(bi ),
southwest(bi ) south(bi ) south-west boundary vertices bi1 , bi bi+1 ,
respectively, thus upper boundary according Lemma 4. Vertices
northwest(bi ) southeast(bi ) either boundary vertices south-west
boundary vertices bi2 bi+2 , respectively, upper boundary
according Lemma 4. Thus, vertex x identical vertex northwest(bi ).
Assume boundary vertex bi+1 immediately south boundary vertex bi .
Vertices north(bi ) south(bi ) boundary vertices. Vertices west(bi )
southwest(bi ) south-west boundary vertices bi1 bi , respectively,
thus upper boundary according Lemma 4. Vertex northwest(bi )
either boundary vertex south-west boundary vertex bi2
upper boundary according Lemma 4. Thus, vertex x identical one vertices
northeast(bi ), east(bi ) southeast(bi ).
cases, vertex x immediately east boundary vertex bj thus c(p, bj ) <
c(p, x) (x, p, bj ) < 0. vertices x bj visible neighbors,
would blocked cells immediately north-west south-west vertex x vertices
x bi could visible neighbors. Thus, vertices x bj visible neighbors.
Furthermore, boundary vertex bj sufficiently constrained according induction
assumption time boundary vertex bi expanded parent p boundary vertex bj expanded parent p time. Thus, vertex x sufficiently
constrained time expanded parent p according Lemma 3 (that is,
(x, p, b0 ) lb(x)). Consequently, conditions Lines 88 89 satisfied (for
reason given before) Line 90 executed = x time boundary vertex
bi expanded parent p. Boundary vertex bi sufficiently constrained afterwards
since lower angle bound set max(lb(bi ), lb(x) + (bi , p, x)) (bi , p, b0 ) =
(bi , p, x) + (x, p, b0 ) lb(x) + (bi , p, x) max(lb(bi ), lb(x) + (bi , p, x)).
576

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

concludes proof every boundary vertex sufficiently constrained time
expanded expanded parent p thus proof AP Theta* never returns path
path segment passes interior blocked cell.
prove AP Theta* never returns path path segment passes two
blocked cells share edge. prove contradiction AP Theta* cannot assign
parent p vertex path segment parent p vertex passes two
blocked cells share edge. Assume otherwise consider first time AP Theta* assigns
parent p vertex path segment parent p vertex passes
two blocked cells share edge. path segment must either horizontal vertical. Vertex
cannot updated according Path 1 assigned parent p time parent p
expanded since straight line parent p vertex passes interior
blocked cell therefore visible neighbors. cannot updated according
Path 2 assigned parent p time visible neighbor expanded parent p
since either a) neighbor would colinear vertices p straight line
parent p vertex would thus pass interior blocked cell b) neighbor would
colinear vertices p straight line parent p vertex would pass
two blocked cells share edge, contradiction assumption. concludes
proof AP Theta* never returns path path segment passes two blocked
cells share edge.
Thus, AP Theta* never returns blocked path.

Appendix C. Acknowledgments
article extension earlier publication (Nash et al., 2007) contains additional
expositions, examples proofs. thank Vadim Bulitko University Alberta
making maps real-time game Baldurs Gate II available us. research done
Ariel Felner spent sabbatical University Southern California, visiting Sven Koenig.
research partly supported U.S. Army Research Laboratory (ARL) U.S.
Army Research Office (ARO) award Sven Koenig grant W911NF-08-1-0468, Office
Naval Research (ONR) award Sven Koenig grant N00014-09-1-1031, National
Science Foundation (NSF) award Sven Koenig grant 0413196 Israeli Science
Foundation (ISF) award Ariel Felner grants 728/06 305/09. Alex Nash funded
Northrop Grumman Corporation. views conclusions contained document
authors interpreted representing official policies, either
expressed implied, sponsoring organizations, agencies, companies U.S. government.

References
Aurenhammer, F. (1991). Voronoi diagramsa survey fundamental geometric data structure.
ACM Computing Surveys, 23(3), 345405.
Botea, A., Muller, M., & Schaeffer, J. (2004). Near optimal hierarchical path-finding. Journal
Game Development, 1(1), 122.
577

fiDANIEL , NASH , KOENIG , & F ELNER

Bresenham, J. (1965). Algorithm computer control digital plotter. IBM Systems Journal,
4(1), 2530.
Bulitko, V., Sturtevant, N., & Kazakevich, M. (2005). Speeding learning real-time search via
automatic state abstraction. Proceedings AAAI Conference Artificial Intelligence,
pp. 13491354.
Choset, H., Lynch, K., Hutchinson, S., Kantor, G., Burgard, W., Kavraki, L., & Thrun, S. (2005).
Principles Robot Motion: Theory, Algorithms, Implementations. MIT Press.
Deloura, M. (2000). Game Programming Gems. Charles River Media.
Ferguson, D., & Stentz, A. (2006). Using interpolation improve path planning: Field D*
algorithm. Journal Field Robotics, 23(2), 79101.
Foley, J., van Dam, A., Feiner, S., & Hughes, J. (1992). Computer Graphics: Principles Practice. Addison-Wesley.
Hart, P., Nilsson, N., & Raphael, B. (1968). formal basis heuristic determination
minimum cost paths. IEEE Transactions Systems Science Cybernetics, SCC-4(2),
100107.
Kavraki, L., Svestka, P., Latombe, J., & Overmars, M. (1996). Probabilistic roadmaps path
planning high-dimensional configuration spaces. IEEE Transactions Robotics Automation, 12(4), 566580.
Koenig, S., & Likhachev, M. (2002). D* Lite. Proceedings AAAI Conference Artificial
Intelligence, pp. 476483.
LaValle, S., & Kuffner, J. (2001). Rapidly-exploring random trees: Progress prospects.
Donald, B., Lynch, K., & Rus, D. (Eds.), Algorithmic Computational Robotics: New
Directions, pp. 293308. K Peters.
Lee, D.-T. (1978). Proximity reachability plane. Ph.D. thesis, University Illinois
Urbana-Champaign.
Liu, Y.-H., & Arimoto, S. (1992). Path planning using tangent graph mobile robots among
polygonal curved obstacles. International Journal Robotics Research, 11(4), 376382.
Lozano-Perez, T., & Wesley, M. (1979). algorithm planning collision-free paths among
polyhedral obstacles. Communication ACM, 22, 560570.
Mitchell, J., & Papadimitriou, C. (1991). weighted region problem: Finding shortest paths
weighted planar subdivision. Journal ACM, 38(1), 1873.
Murphy, R. (2000). Introduction AI Robotics. MIT Press.
Nash, A., Daniel, K., Koenig, S., & Felner, A. (2007). Theta*: Any-angle path planning grids.
Proceedings AAAI Conference Artificial Intelligence, pp. 11771183.
Nash, A., Koenig, S., & Likhachev, M. (2009). Incremental Phi*: Incremental any-angle path planning grids. Proceedings International Joint Conference Aritificial Intelligence,
pp. 18241830.
Patel, A. (2000).
Amits Game Programming Information.
available online
http://theory.stanford.edu/amitp/GameProgramming/MapRepresentations.html.
578

fiT HETA *: NY-A NGLE PATH P LANNING



G RIDS

Pearl, J. (1984). Heuristics: Intelligent Search Strategies Computer Problem Solving. AddisonWesley.
Pohl, I. (1973). avoidance (relative) catastrophe, heuristic competence, genuine dynamic
weighting computational issues heuristic problem solving. Proceedings International Joint Conference Artificial Intelligence, pp. 1217.
Rabin, S. (2002). AI Game Programming Wisdom. Charles River Media.
Rabin, S. (2004). AI Game Programming Wisdom 2. Charles River Media.
Thorpe, C. (1984). Path relaxation: Path planning mobile robot. Proceedings AAAI
Conference Artificial Intelligence, pp. 318321.
Tozour, P. (2004). Search space representations. Rabin, S. (Ed.), AI Game Programming Wisdom
2, pp. 85102. Charles River Media.
Yahja, A., Stentz, A., Singh, S., & Brumitt, B. (1998). Framed-quadtree path planning mobile
robots operating sparse environments. Proceedings International Conference
Robotics Automation, pp. 650655.
Yap, P. (2002). Grid-based path-finding. Proceedings Canadian Conference Artificial
Intelligence, pp. 4455.

579


