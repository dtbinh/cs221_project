journal artificial intelligence

submitted published

theta angle path grids
kenny daniel
alex nash
sven koenig

kfdaniel usc edu
anash usc edu
skoenig usc edu

computer science department
university southern california
los angeles california usa

ariel felner

felner bgu ac il

department information systems engineering
ben gurion university negev
beer sheva israel

abstract
grids blocked unblocked cells often used represent terrain robotics video
games however paths formed grid edges longer true shortest paths terrain
since headings artificially constrained present two correct complete anyangle path avoid shortcoming basic theta angle propagation
theta variants propagate information along grid edges without constraining
paths grid edges basic theta simple understand implement fast finds short paths
however guaranteed true shortest paths angle propagation theta achieves
better worst case complexity per vertex expansion basic theta propagating angle ranges
expands vertices complex fast finds slightly longer paths
refer basic theta angle propagation theta collectively theta theta unique
properties analyze detail experimentally finds shorter paths
post smoothed paths field version know
propagates information along grid edges without constraining paths grid edges runtime
comparable grids finally extend theta grids contain unblocked cells
non uniform traversal costs introduce variants theta provide different tradeoffs
path length runtime

introduction
article study path robotics video games choset lynch hutchinson
kantor burgard kavraki thrun deloura patel murphy rabin
two dimensional continuous terrain discretized grid blocked unblocked
cells objective short unblocked path given start vertex given goal vertex
corners cells finds grid paths paths constrained grid edges quickly
grid paths often true shortest paths shortest paths terrain since potential
headings artificially constrained multiples degrees shown figure yap
shortcoming led introduction call angle path nash daniel
koenig felner ferguson stentz angle path paths
c

ai access foundation rights reserved

fidaniel nash koenig f elner















start

b

c











start

b

c

goal
grid path

goal
b true shortest path

figure grid path versus true shortest path
without constraining headings paths shown figure b present two
correct complete angle path basic theta angle propagation
theta variants propagate information along grid edges achieve short
runtime without constraining paths grid edges angle paths unlike visibility
graphs guaranteed true shortest paths asterisk names thus
denote optimality rather similarity basic theta simple understand
implement fast finds short paths angle propagation theta achieves worst case complexity
per vertex expansion constant rather linear number cells basic
theta propagating angle ranges expands vertices complex fast
finds slightly longer paths refer basic theta angle propagation theta collectively
theta theta unique properties analyze detail experimentally
finds shorter paths post smoothed paths field version
know propagates information along grid edges without constraining paths grid
edges runtime comparable grids finally extend theta grids
contain unblocked cells non uniform traversal costs introduce variants theta
provide different tradeoffs path length runtime

path notation
section describe path study article namely path
eight neighbor grids blocked unblocked cells uniform size cells labeled
blocked grey unblocked white use corners cells rather centers
vertices set vertices path unblocked path
given start vertex sstart given goal vertex sgoal
path unblocked iff vertex path line sight successor path vertex
line sight vertex written lineofsight iff straight line vertex
vertex neither passes interior blocked cells passes blocked cells
share edge pseudocode implementing line sight function given appendix
simplicity allow straight line pass diagonally touching blocked cells
c length straight line vertex vertex nghbrsvis set visible
neighbors vertex eight compass directions neighbors vertex


fit heta ny ngle path p lanning



g rids

line sight vertex figure shows example visible neighbors vertex b
vertices b b c c

existing terrain discretizations
continuous terrain needs discretized path section compare grids
existing terrain discretizations use grids discretize terrain since widely used
robotics video games deloura murphy rabin several desirable
properties
grids simple data structures allow simple path
terrain easily discretized grid laying grid terrain labeling
cells partially completely obstructed blocked
grids provide comprehensive picture traversable surfaces continuous terrain
essential path used dynamic environment
must interact navigation planner example robot video game character
encounters temporary blockage path easily determine whether best
divert left unblocked right blocked tozour
cells store information addition traversability amount gold
hidden region terrain corresponds cell rendering region
displaying terrain
information stored cells accessed quickly since grids random access data
structures
precision path navigation improved simply increasing grid
resolution
list alternative terrain discretizations assuming simplicity obstacles
terrain polygonal
voronoi graphs aurenhammer discretize terrain biasing paths away
blocked polygons resulting paths thus much longer true shortest paths
discretization work mitchell papadimitriou partitions terrain
regions linear hyperbolic edges allows one true shortest paths
time space complexity number corners blocked polygons
thus runtime path grow superlinearly number corners blocked
polygons
framed quadtrees yahja stentz singh brumitt recursively subdivide terrain
four equally sized cells cells completely obstructed completely unobstructed
sufficiently small size resulting paths unnecessary heading changes
heading changes occur free space rather corners blocked polygons


fidaniel nash koenig f elner

main

g sstart

parent sstart sstart

open

open insert sstart g sstart h sstart

closed

open

open pop
sgoal


return path found










closed closed
following line executed ap theta
updatebounds
foreach nghbrsvis
closed
open
g
parent n u



updatevertex


return path found
end
updatevertex

g c g

g g c

parent

open

open remove


open insert g h

end



probabilistic roadmaps kavraki svestka latombe overmars rapidly exploring
random trees lavalle kuffner place vertices randomly addition start
goal vertex two vertices connected via straight line iff line sight
random placement vertices needs tuned carefully since influences runtime
path likelihood finding path length path
visibility graphs lee lozano perez wesley use corners blocked
polygon vertices addition start goal vertex two vertices connected via
straight line iff line sight allows one true shortest paths
runtime path grow superlinearly number vertices since number
edges grow quadratically number vertices

existing path
section describe existing path variants
hart nilsson raphael popular path robotics video
games shows pseudocode line ignored maintains three
values every vertex


fit heta ny ngle path p lanning



g rids

g value g length shortest path start vertex vertex found
far thus estimate start distance vertex
user provided h value h estimate goal distance vertex uses
h value calculate f value focus search f value f g h
estimate length shortest path start vertex via vertex goal vertex
parent parent used extract path start vertex goal vertex
terminates
maintains two global data structures
open list priority queue contains vertices considers expansion
pseudocode open insert x inserts vertex key x priority queue open
open remove removes vertex priority queue open open pop removes
vertex smallest key priority queue open returns
closed list set contains vertices already expanded ensures
expands every vertex
sets g value every vertex infinity parent every vertex null
encounters vertex first time lines sets g value start vertex zero
parent start vertex start vertex lines sets open closed
lists empty list inserts start vertex open list f value key
repeatedly executes following procedure open list empty reports
path line otherwise identifies vertex smallest f value
open list line vertex goal vertex reports found path line
path extraction shown pseudocode follows parents goal vertex start
vertex retrieve path start vertex goal vertex reverse otherwise removes
vertex open list line expands inserting vertex closed list line
generating unexpanded visible neighbors follows checks whether
g value vertex plus length straight line vertex vertex smaller
g value vertex line sets g value vertex g value vertex
plus length straight line vertex vertex sets parent vertex vertex
finally inserts vertex open list f value key already
open list sets key f value lines repeats procedure
summarize updates g value parent unexpanded visible neighbor
vertex procedure updatevertex considers path start vertex vertex g
vertex vertex straight line c resulting length g c
line updates g value parent vertex considered path shorter
shortest path start vertex vertex found far g
describe several existing path versions
trade two conflicting criteria namely runtime path length shown figure
introduce order decreasing path lengths


fidaniel nash koenig f elner





runtime


ps
fd



visibility graphs
basic theta


















path length length true shortest path

figure runtime versus path length relative length true shortest path random
grids percent blocked cells

postsmoothpath sn

k

tk

foreach n

lineofsight tk si

k k

tk si

k k

tk sn

return tk
end

post smoothing

grids
one run grids graphs given grid vertices edges resulting
paths artificially constrained formed edges grid seen figure
paths found grids equivalent true shortest paths
unrealistic looking since deviate substantially true shortest paths
many heading changes provides motivation smoothing use octile
distances computed h values experiments


fit heta ny ngle path p lanning















g rids


goal
true shortest path

b
shortest grid path
ps path

c

start

figure ps path versus true shortest path

post smoothed paths ps
one run post smoothed paths ps thorpe ps runs grids
smoothes resulting path post processing step often shortens increase
runtime shows pseudocode simple smoothing ps uses
experiments botea muller schaeffer provides good tradeoff
runtime path length assume grids finds path sn sstart
sn sgoal ps uses first vertex path current vertex checks whether
current vertex line sight successor successor path
ps removes intermediate vertex path thus shortening ps repeats
procedure checking whether current vertex line sight successor
successor path soon current vertex line sight
successor successor path ps advances current vertex repeats procedure
reaches end path use straight line distances h c sgoal h values
experiments
ps typically finds shorter paths grids guaranteed true shortest paths
figure shows example assume ps finds dotted blue path one many
shortest grid paths smoothes path solid blue path true shortest
path dashed red path moves rather blocked cell b b c c
true shortest path ps guaranteed true shortest paths considers grid
paths search thus cannot make informed decisions regarding paths
search motivates interleaving searching smoothing fact theta similar
ps except interleaves searching smoothing
field fd
one run field ferguson stentz fd fd propagates information along grid
edges without constraining paths grid edges fd designed use lite koenig
likhachev fast replanning reusing information previous search speed
next one searches goal vertex start vertex version fd uses
searches start vertex goal vertex path
article allows us compare fairly except replanning abilities theta
currently process extended fast replanning nash koenig likhachev


fidaniel nash koenig f elner



b





















sgoal




c





x

sstart
















field path
figure fd path

figure screenshot fd path versus true shortest path
fd updates g value parent unexpanded visible neighbor vertex
considers paths start vertex point x necessarily vertex perimeter
vertex g x line sight vertex perimeter formed connecting
neighbors vertex point x vertex straight line c x resulting
length g x c x fd updates g value parent vertex considered
path shorter shortest path start vertex vertex found far g use
straight line distances h c sgoal h values experiments
figure shows example perimeter vertex b formed connecting
neighbors vertex b shown bold consider point x perimeter fd know
g value point x since stores g values vertices calculates g value
linear interpolation g values two vertices perimeter adjacent
point x thus linearly interpolates g b g c resulting
g x since distances point x
vertices b c respectively calculated g value point x different true start
distance even though g values vertices b c equal true start
distances reason mistake simple exist true shortest paths start vertex
vertex c vertex b goal vertex thus linear interpolation assumption
predicts must exist short path start vertex point along
edge connects vertices b c goal vertex however case since


fit heta ny ngle path p lanning













g rids



start

b

c

goal
true shortest path
simple visibility graph

b terrain resulting complex visibility graph

figure visibility graphs
paths need circumnavigate blocked cell b b c c makes longer expected
miscalculating g value point x fd sets parent vertex b point x
resulting path unnecessary heading change point x longer even
shortest grid path
authors fd recognize paths found fd frequently unnecessary heading
changes suggest use one step look ahead path extraction ferguson
stentz fd uses experiments one step look ahead allows fd
avoid unnecessary heading changes one figure eliminate
figure shows example fd path red corresponding true shortest
path blue fd path still many unnecessary heading changes
visibility graphs
one run visibility graphs visibility graph grid blocked unblocked
cells contains start vertex goal vertex corners blocked cells lozano perez
wesley use straight line distances h c sgoal h values experiments
visibility graphs finds true shortest paths shown figure true shortest paths
heading changes corners blocked cells paths found grids ps
fd unnecessary heading changes hand visibility graphs
slow propagates information along visibility graph edges whose number grow quadratically
number cells grids ps fd propagate information along grid edges
whose number grows linearly number cells one constructed visibility graphs
search one would need perform line sight check every pair corners
blocked cells determine whether visibility graph edge
requires least line sight checks room figure b tozour
number line sight checks performed visibility graphs reduced constructing


fidaniel nash koenig f elner

updatevertex

lineofsight parent

path

g parent c parent g

g g parent c parent

parent parent

open

open remove
open insert g h











else
path
g c g
g g c
parent
open
open remove
open insert g h

end

basic theta

visibility graphs search expands vertex performs line sight checks
expanded vertex corners blocked cells goal vertex
significantly reduce number line sight checks performed environments
simple outdoor terrain fails others cluttered indoor terrain
complex optimizations reduced visibility graphs reduce number line ofsight checks sufficiently speed visibility graphs liu arimoto

basic theta
section introduce theta nash et al version angle path
propagates information along grid edges without constraining paths grid edges
combines ideas behind visibility graphs heading changes occur
corners blocked cells grids number edges grows linearly
number cells paths slightly longer true shortest paths found
visibility graphs yet slightly slower grids shown figure key
difference theta grids parent vertex vertex
theta parent vertex neighbor vertex
first introduce basic theta simple version theta
shows pseudocode basic theta procedure main identical
thus shown line ignored use straight line distances
h c sgoal h values experiments
operation basic theta
basic theta simple identical except updates g value parent
unexpanded visible neighbor vertex procedure updatevertex considers two paths


fit heta ny ngle path p lanning













sgoal



b



c

path

g rids









sstart

b

c





path

sstart





sgoal

path

path unblocked



path

b path blocked

figure paths considered basic theta

instead one path considered figure shows example basic theta
expanding vertex b parent needs update g value parent unexpanded
visible neighbor c basic theta considers two paths

path basic theta considers path start vertex vertex g
vertex vertex straight line c resulting length g c line
path path considered corresponds dashed red path b c
figure
path basic theta considers path start vertex parent vertex
g parent parent vertex vertex straight line c parent
resulting length g parent c parent line path considered
allows basic theta construct angle paths corresponds solid blue
path c figure

path longer path due triangle inequality triangle inequality states
length side triangle longer sum lengths two sides
applies since path consists path start vertex parent vertex
straight line parent vertex vertex line straight line vertex
vertex line b path consists path start vertex parent vertex
straight line parent vertex vertex line c lines b c form
triangle path guaranteed unblocked path thus basic theta chooses path
path vertex line sight parent vertex path thus unblocked
figure shows example otherwise basic theta chooses path path figure b
shows example basic theta updates g value parent vertex chosen path
shorter shortest path start vertex vertex found far g use
straight line distances h c sgoal h values experiments


fidaniel nash koenig f elner























sstart



b













c

sgoal





b

c



sgoal







sstart











b



















b















b

b



sstart



b











b

b















b







sgoal







c

































b

b



sstart



b











b

b







c









b







sgoal

c



figure example trace basic theta

example trace basic theta
figure shows example trace basic theta vertices labeled g values
parents arrows point parents red circles indicate vertices expanded
blue arrows indicate vertices generated current expansion first basic theta
expands start vertex parent shown figure sets parent unexpanded
visible neighbors vertex vertex would second basic theta expands
vertex b parent shown figure b vertex b unexpanded visible neighbor
vertex b line sight vertex basic theta thus updates according
path sets parent vertex b hand vertices c c c unexpanded
visible neighbors vertex b line sight vertex basic theta thus updates
according path sets parents vertex g values parents
unexpanded visible neighbors vertex b updated third basic theta expands vertex
b parent b shown figure c vertices unexpanded visible neighbors
vertex b line sight vertex b basic theta thus updates according
path sets parents vertex b hand vertices b c unexpanded
visible neighbors vertex b line sight vertex b basic theta thus updates
according path sets parents vertex b fourth basic theta expands goal
vertex c parent b terminates shown figure path extraction follows
parents goal vertex c start vertex retrieve true shortest path b c
start vertex goal vertex reverse


fit heta ny ngle path p lanning



g rids

properties basic theta
discuss properties basic theta
c orrectness



c ompleteness

basic theta correct finds unblocked paths start vertex goal vertex
complete finds path start vertex goal vertex one exists use
following lemmata proof
lemma exists unblocked path two vertices exists unblocked
grid path two vertices
proof unblocked path two vertices exists iff unblocked angle path sn
exists two vertices consider path segment sk sk angle path
path segment horizontal vertical consider unblocked grid path vertex sk
vertex sk coincides path segment otherwise consider sequence b bm
unblocked cells whose interior path segment passes two consecutive cells
bj bj share least one vertex sj since cells share edge diagonally
touching share one vertex pick one arbitrarily consider grid path
sk sm sm sk grid path vertex sk vertex sk unblocked since
two consecutive vertices corners unblocked cell thus visible neighbors
repeat procedure every path segment angle path concatenate resulting
grid paths unblocked grid path vertex vertex sn several consecutive vertices
grid path identical one removed
lemma point execution basic theta following parents vertex
open closed lists start vertex retrieves unblocked path start vertex
vertex reverse
proof prove induction lemma holds parent vertex union
open closed lists union open closed lists statement holds
initially start vertex vertex union open closed lists
parent statement continues hold whenever vertex changes
parent membership union open closed lists vertex member
union open closed lists continues member vertex become member
union open closed lists basic theta expands vertex updates
g value parent unexpanded visible neighbor vertex procedure updatevertex
vertex thus closed list parent union open closed lists according
induction assumption thus following parents vertex parent start
vertex retrieves unblocked path start vertex vertex parent respectively
reverse according induction assumption basic theta updates vertex according path
statement continues hold since vertices visible neighbors path
segment vertex vertex thus unblocked basic theta updates vertex according
path statement continues hold since basic theta explicitly checks path


fidaniel nash koenig f elner

segment parent vertex vertex unblocked ways
parent vertex change
theorem basic theta terminates path extraction retrieves unblocked path start
vertex goal vertex path exists otherwise basic theta terminates reports
unblocked path exists
proof following properties together prove theorem proofs utilize fact basic
theta terminates iff open empty expands goal vertex start vertex initially
open list vertex initially neither open closed lists vertex neither
open closed lists inserted open list vertex open list removed
open list inserted closed list vertex closed list remains closed list
property basic theta terminates expands one vertex open list
iteration process removes vertex open list never insert
open list since number vertices finite open list eventually becomes
empty basic theta terminate terminated earlier already
property basic theta terminates open list empty
exist unblocked path start vertex goal vertex prove contrapositive
assume exists unblocked path start vertex goal vertex prove
contradiction basic theta terminate open list empty
thus assume basic theta terminates open list empty
exists unblocked grid path sstart sn sgoal start vertex goal
vertex according lemma choose vertex si first vertex grid path
closed list basic theta terminates goal vertex closed list
basic theta terminates since basic theta would otherwise terminated
expanded goal vertex thus vertex si exists vertex si start vertex since start
vertex would otherwise open list basic theta could terminated
open list empty thus vertex si predecessor grid path predecessor
closed list basic theta terminates since vertex si first vertex grid
path closed list basic theta terminates basic theta expanded
predecessor added vertex si open list thus vertex si still open list
basic theta terminates basic theta could terminated open
list empty contradiction
property basic theta terminates expands goal vertex path extraction
retrieves unblocked path start vertex goal vertex following
parents goal vertex start vertex retrieves unblocked path start
vertex goal vertex reverse according lemma



fit heta ny ngle path p lanning















g rids





















b

c



e

start














b

c



e

start

b

true shortest path

basic theta path

figure basic theta paths versus true shortest paths

ptimality
basic theta optimal guaranteed true shortest paths
parent vertex visible neighbor vertex parent visible neighbor
case true shortest paths figure shows example dashed
red path e b true shortest path start vertex e vertex b since vertex e lineof sight vertex b however vertex e neither visible neighbor parent visible
neighbor vertex b since vertex e line sight vertices highlighted
red thus basic theta cannot set parent vertex b vertex e true
shortest path vertex e vertex b similarly figure b shows example
dashed red path e c true shortest path vertex e vertex c however vertex
neither visible neighbor parent visible neighbor vertex c since start vertex
e line sight basic theta found paths vertex e


fidaniel nash koenig f elner



sstart











b

c

f


f

true shortest path

sgoal
f

basic theta path

figure heading changes basic theta

contain vertex fact truly shortest paths vertex e visible neighbors vertex
c vertex e line sight move rather blocked cell c c thus basic theta cannot set parent vertex c vertex thus
true shortest path vertex e vertex c solid blue path vertex e vertex
b figure solid blue path vertex e vertex c figure b less
factor longer true shortest paths
h eading c hanges
basic theta takes advantage fact true shortest paths heading changes
corners blocked cells however paths found basic theta occasionally
unnecessary heading changes figure shows example basic theta finds solid blue
path vertex vertex reason mistake simple assume
open list contains vertices c f value vertex c f c g c
h c parent vertex c f value vertex f
parent vertex thus basic theta expands vertex
vertex c since f value smaller basic theta expands vertex parent
generates vertex vertex unexpanded visible neighbor vertex
line sight vertex basic theta thus updates according path sets f value
f sets parent vertex inserts open list thus
basic theta expands goal vertex vertex c since f value smaller terminates
path extraction follows parents goal vertex start vertex retrieve solid
blue path thus basic theta never expands vertex c would resulted
setting parent vertex vertex c according path path extraction retrieving
dashed red path c true shortest path solid blue path vertex
vertex figure less factor longer true shortest path


fit heta ny ngle path p lanning



g rids

updatevertex

sstart lb parent ub

path

g parent c parent g

g g parent c parent

parent parent

open

open remove
open insert g h











else
path
g c g
g g c
parent
open
open remove
open insert g h

end
updatebounds

lb ub

sstart

foreach blocked cell b adjacent

corners b parent parent

parent c parent c parent

lb















corners b parent parent
parent c parent c parent
ub
foreach nghbrsvis
closed parent parent sstart
lb parent
lb max lb lb parent
ub parent
ub min ub ub parent
c parent c parent parent closed parent parent

parent
lb max lb parent
parent
ub min ub parent

end

ap theta

angle propagation theta ap theta
runtime basic theta per vertex expansion runtime consumed generation unexpanded visible neighbors expanding vertex linear number
cells since runtime line sight check linear number cells
section introduce angle propagation theta ap theta reduces runtime basic


fidaniel nash koenig f elner







b

















c



e



f

figure region points line sight vertex
theta per vertex expansion linear constant key difference ap theta
basic theta ap theta propagates angle ranges uses determine whether
two vertices line sight
light source vertex light cannot pass blocked cells cells
shadows line sight vertex cells line sight vertex
contiguous region points line sight vertex characterized two
rays emanating vertex thus angle range defined two angle bounds figure
shows example points within red angle range defined two angle bounds
line sight vertex ap theta calculates angle range vertex
expands vertex propagates along grid edges resulting constant runtime per
vertex expansion since angle ranges propagated constant time line sight
checks performed constant time well
shows pseudocode ap theta procedure main identical
thus shown line executed use straight line distances
h c sgoal h values experiments
definition angle ranges
discuss key concept angle range ap theta maintains two additional values
every vertex namely lower angle bound lb vertex upper angle bound ub
vertex together form angle range lb ub vertex angle bounds correspond
headings rays measured degrees originate parent vertex heading
ray parent vertex vertex zero degrees visible neighbor vertex
guaranteed line sight parent vertex necessarily heading
ray parent vertex visible neighbor vertex contained angle
ap theta provides significant improvement worst case complexity basic theta experimental section slower finds slightly longer paths basic theta



fit heta ny ngle path p lanning













g rids



sstart
lb

b





c

sgoal



ub

figure angle range ap theta
range vertex figure shows example vertex c parent angle range
thus visible neighbors vertex c red region guaranteed line ofsight parent vertex c example vertex c guaranteed line sight
parent vertex c vertex b ap theta therefore assumes vertex b
line sight parent vertex c
define concept angle range formally p gives
ap theta name angle measured degrees ray vertex p vertex
ray vertex p vertex positive ray vertex p vertex clockwise
ray vertex p vertex zero ray vertex p vertex heading
ray vertex p vertex negative ray vertex p vertex counterclockwise
ray vertex p vertex figure shows example c c
c b visible neighbor vertex guaranteed line sight
parent vertex necessarily lb parent ub visibility
property
update angle ranges
discuss ap theta calculates angle range vertex expands vertex
calculation complicated fact ap theta guaranteed sufficient
information determine angle range exactly since order vertex expansions depends
variety factors h values case ap theta constrain angle range
necessary guarantee visibility property holds finds unblocked paths
ap theta expands vertex sets angle range vertex initially meaning
visible neighbors vertex guaranteed line sight parent vertex
constrains angle range vertex start vertex
ap theta constrains angle range vertex blocked cell b adjacent
vertex vertex corner b written corners b provided least one
two conditions satisfied
case every corner blocked cell b satisfies least one following conditions
parent


fidaniel nash koenig f elner

parent
parent c parent c parent
ap theta assumes vertex line sight parent vertex
ray parent vertex vertex counterclockwise ray
parent vertex vertex parent ap theta therefore sets
lower angle bound vertex parent line
case every corner blocked cell b satisfies least one following conditions
parent
parent
parent c parent c parent
ap theta assumes vertex line sight parent vertex
ray parent vertex vertex clockwise ray parent
vertex vertex parent ap theta therefore sets upper
angle bound vertex parent line
ap theta constrains angle range vertex visible neighbor vertex
provided least one two conditions satisfied
case vertex satisfies following conditions
closed

parent parent
sstart
ap theta constrains angle range vertex intersecting angle range
vertex lines first shifts angle range vertex
parent degrees take account angle range vertex calibrated
heading ray joint parent vertices vertex zero
degrees angle range vertex calibrated heading ray
joint parent vertices vertex zero degrees lines ensure
lower angle bound remains non positive upper angle bound remains
non negative respectively fact lower angle bounds non positive
upper angle bounds non negative intuitive vertex assigned parent vertex p
angle ray vertex p vertex included angle range
vertex
case vertex satisfies following conditions
c parent c parent
parent


fit heta ny ngle path p lanning



g rids

closed parent parent
ap theta insufficient information vertex ap theta therefore cannot
determine angle range vertex exactly makes conservative assumption
vertex barely line sight parent vertex lines
visibility property holds ap theta updated angle range vertex procedure
updatebounds thus ap theta checks whether visible neighbor vertex
line sight parent vertex checks whether lb parent
ub line true instead whether lineofsight parent line true
differences ap theta basic theta
figure shows example ap theta calculates angle range vertex sets
angle range figure b shows example ap theta calculates angle
range vertex b sets angle range initially sets lower angle bound
degrees according case blocked cell b b line sets
upper angle bound degrees according case vertex b unexpanded
thus closed list line figure c shows example ap theta calculates
angle range vertex b sets angle range initially sets lower
angle bound degrees according case blocked cell b b line
assume vertex c goal vertex figure shows example ap theta
calculates angle range vertex c sets angle range initially sets
lower angle bound degrees according case vertex b line upper
angle bound degrees according case vertex c unexpanded thus
closed list line
example trace ap theta
figure shows example trace ap theta path figure
labels vertices include angle ranges
properties ap theta
discuss properties ap theta ap theta operates way basic theta
thus similar properties basic theta example ap theta correct complete
guaranteed true shortest paths paths occasionally unnecessary heading
changes
ap theta sometimes constrains angle ranges necessary guarantee finds
unblocked paths means line sight checks sometimes fail incorrectly case
update vertices according path rather path ap theta still complete since
finds unblocked grid path line sight checks fail exists unblocked
grid path exists unblocked angle path however paths found ap theta
longer found basic theta figure shows example ap theta expands
vertex c parent b calculates angle range vertex c vertex c unexpanded
thus closed list means ap theta insufficient information vertex


fidaniel nash koenig f elner



















sstart





















b













c









b








c















b







b

b















sstart









b

b









b

b


c





b
















b








b

b






b










b





sstart





















sstart


b













c

c



















figure example trace ap theta















b

c



start




















sgoal

basic theta path

ap theta path

figure basic theta path versus ap theta path
c example know whether cell c c unblocked ap
theta therefore cannot determine angle range vertex c exactly makes conservative
assumption vertex c barely line sight vertex b sets lower angle bound
vertex c according case vertex c uses resulting angle range
determine unexpanded visible neighbor vertex c guaranteed line ofsight vertex b however vertex line sight vertex b cell c c


fit heta ny ngle path p lanning



g rids

figure map baldurs gate ii
unblocked ap theta eventually finds solid blue path b c start vertex b
vertex basic theta finds dashed red path b true shortest path
correctness completeness proof basic theta needs get changed slightly ap theta
since ap theta performs line sight checks differently
theorem ap theta terminates path extraction retrieves unblocked path start
vertex goal vertex path exists otherwise ap theta terminates reports
unblocked path exists
proof proof similar proof theorem since ap theta uses angle ranges
determine whether path blocked determine whether path blocked
property needs proved differently two vertices indeed line sight
necessarily line sight check ap theta succeeds see appendix b

experimental
section compare basic theta ap theta grids ps fd
visibility graphs respect path length number vertex expansions runtime measured
seconds number heading changes
compare path grids different percentages randomly blocked cells random grids scaled maps real time strategy
game baldurs gate ii game maps figure bulitko sturtevant kazakevich shows
example game map start goal vertices south west corners cells random
grids start vertex south west cell goal vertex cell randomly chosen
column cells furthest east cells blocked randomly one unit border unblocked
cells guarantees path start vertex goal vertex game maps start
goal vertices randomly chosen corners unblocked cells average
random grids random grids game maps


fidaniel nash koenig f elner





fd
game maps
random grids
random grids
random grids
random grids
random grids
game maps
random grids
random grids
random grids
random grids
random grids














basic theta ap theta visibility graphs grids
true shortest path


























n



n



n



n



n



n


ps













table path length





fd
game maps
random grids
random grids
random grids
random grids
random grids
game maps
random grids
random grids
random grids
random grids
random grids














basic theta ap theta visibility graphs grids
true shortest path


























n



n



n



n



n



n


ps













table runtime





fd
game maps
random grids
random grids
random grids
random grids
random grids
game maps
random grids
random grids
random grids
random grids
random grids














basic theta ap theta visibility graphs grids
true shortest path


























n



n



n



n



n



n


ps













table number vertex expansions

path implemented c executed ghz core duo
gbyte ram implementations optimized possibly improved


fit heta ny ngle path p lanning





fd
game maps
random grids
random grids
random grids
random grids
random grids
game maps
random grids
random grids
random grids
random grids
random grids














g rids



basic theta ap theta visibility graphs grids
true shortest paths


























n



n



n



n



n



n


ps

































runtime

path length

table number heading changes




































blocked
fd

basic theta





blocked

ap theta

ps

fd

basic theta

path length

ap theta

ps



b runtime







number heading changes



vertex expansions




































blocked
fd

basic theta







blocked

ap theta

ps



fd

c number vertex expansions

basic theta

ap theta

ps



number heading changes

figure random grids



fidaniel nash koenig f elner

h
x x sgoal x

sgoal



largest max x

smallest min x


return smallest largest smallest
end

calculation octile distances

grids ps fd visibility graphs break ties among vertices fvalue open list favor vertices larger g values decide vertex
expand next since tie breaking scheme typically fewer vertex expansions thus
shorter runtimes care must thus taken calculating g values h values fvalues precisely numerical precision
floating point numbers improved
grids representing form n integers n basic theta ap
theta break ties favor vertices smaller g values reasons explained section
use path consistent h values since consistent h values
short paths consistent h values satisfy triangle inequality h value
goal vertex zero h value potential non goal parent vertex greater
distance potential non goal parent vertex vertex plus h value
vertex hart et al pearl consistent h values lower bounds corresponding
goal distances vertices increasing consistent h values typically decreases number vertex
expansions thus runtime thus use path
largest consistent h values easy calculate basic theta ap theta fd
visibility graphs goal distances vertices equal true goal distances
goal distances grids paths constrained grid edges therefore use
path straight line distances h c sgoal h values
experiments straight line distances goal distances grids without blocked cells
paths constrained grid edges grids ps goal distances vertices
equal goal distances grids paths constrained grid edges could therefore
use larger octile distances h values experiments octile distances
goal distances grids without blocked cells paths constrained grid edges
shows calculate octile distance given vertex x x
coordinates vertex respectively indeed use grids octile distances
ps straight line distances since smoothing typically able shorten resulting
paths much increase number vertex expansions thus runtime grids without
blocked cells provide example octile
distances h values grids finds paths
diagonal movements whose lengths precede horizontal vertical movements
whose lengths paths largest number diagonal movements
longest ones among paths number movements due tie breaking scheme
used hand straight line distances h values grids finds paths
interleave diagonal movements horizontal vertical movements means
likely lots opportunities smooth paths even grids blocked
cells closer straight line start goal vertices means
likely paths closer true shortest paths even grids blocked cells


fit heta ny ngle path p lanning



g rids

figure true shortest paths found fd left ps middle basic theta right
h values vertices closer straight line typically smaller h values
vertices farther away straight line
tables report experimental runtime visibility graphs finds
true shortest paths long grids thus omitted figure visualizes
experimental random grids path length grids much larger
path lengths path thus omitted
make following observations path lengths
path order increasing path lengths tend visibility
graphs finds true shortest paths basic theta ap theta fd ps
grids random grids percent blocked cells basic theta finds shorter
paths ap theta percent time shorter paths fd percent time
shorter paths ps percent time shorter paths grids percent
time
paths found basic theta ap theta almost short true shortest paths even
though ap theta sometimes constrains angle ranges necessary example
average less factor longer true shortest paths
grids
basic theta finds true shortest paths often fd ps figure shows
example light green vertex center start vertex red green
blue vertices represent goal vertices fd ps basic theta true shortest
paths respectively
make following observations runtimes path order
increasing runtimes tend grids basic theta ap theta ps fd
visibility graphs
make following observations numbers vertex expansions path
order increasing numbers vertex expansions tend visibility graphs
grids ap theta basic theta fd ps number vertex expansions
grids ps different use different h values


fidaniel nash koenig f elner

runtime
runtime per vertex expansion

fd



basic theta



ap theta



ps



table path without post processing steps random grids
percent blocked cells

finally make following observations number heading changes pathplanning order increasing numbers heading changes tend ps
visibility graphs basic theta ap theta grids fd
exceptions trends reported therefore perform paired tests
confidence level basic theta indeed finds shorter paths ap theta
ps fd basic theta indeed shorter runtime ap theta ps
fd
summarize visibility graphs finds true shortest paths slow hand
grids finds long paths fast angle path lies two extremes
basic theta dominates ap theta ps fd terms tradeoff runtime
path length finds paths almost short true shortest paths almost fast
grids simpler implement ap theta therefore build basic theta
remainder article although report experimental ap theta
well however ap theta reduces runtime basic theta per vertex expansion linear
constant currently unknown whether constant time line sight checks devised
make ap theta faster basic theta interesting area future since
ap theta potentially first step toward significantly reducing runtime angle path
via sophisticated line sight checks

extensions theta
section extend basic theta paths given start vertex vertices
paths grids contain unblocked cells non uniform traversal costs
single source paths
far basic theta found paths given start vertex given goal vertex discuss
version basic theta finds single source paths paths given start vertex
vertices terminating open list empty instead open list
empty expands goal vertex
finding single source paths requires path expand number
vertices minimizes influence h values runtime thus clean
comparison since h values sometimes chosen trade runtime path length
runtimes ps fd effected basic theta ap theta
finding single source paths since require post smoothing path extraction steps


fit heta ny ngle path p lanning















g rids







b





c



basic theta path non uniform traversal costs

figure basic theta grids contain unblocked cells non uniform traversal costs

small contiguous regions uniform traversal costs
path cost
runtime

grids



fd



basic theta



b large contiguous regions uniform traversal costs
path cost
runtime

grids



fd



basic theta



table path random grids non uniform traversal costs

path thus need post process many paths table reports runtimes path
without post processing steps runtime basic theta per vertex expansion
similar ps shorter ap theta fd later two
require floating point operations
non uniform traversal costs
far basic theta found paths grids contain unblocked cells uniform traversal
costs case true shortest paths heading changes corners blocked cells
triangle inequality holds means path longer path discuss
version basic theta finds paths grids contain unblocked cells non uniform
traversal costs computing comparing path lengths path costs appropriately
case true shortest paths heading changes boundaries unblocked
cells different traversal costs triangle inequality longer guaranteed hold
means path costly path thus basic theta longer unconditionally
chooses path path path unblocked line chooses path smaller
cost uses standard cohen sutherland clipping computer graphics foley van
dam feiner hughes calculate cost path line sight check figure
shows example path segment c vertex c vertex straight line
split line segments points intersects cell boundaries cost path
segment sum costs line segments ii ii cost line segment
product length traversal cost corresponding unblocked cell
found changing test line strictly less less
equal slightly reduces runtime basic theta fact faster
compute cost path segment corresponds path path since tends consist
fewer line segments


fidaniel nash koenig f elner















goal











goal
h

h
b

b

g
g
c

c

start

start



b

figure non monotonicity f values basic theta

compare basic theta grids fd respect path cost runtime
measured seconds since easily adapted grids contain unblocked cells
non uniform traversal costs fd designed case compare path
grids cell assigned integer traversal cost
corresponding unblocked cell infinity corresponding blocked cell similar
technique used work ferguson stentz path lies boundary
two cells different traversal costs use smaller traversal cost two cells
start goal vertices south west corners cells start vertex south west cell
goal vertex cell randomly chosen column cells furthest east average
random grids table reports every traversal cost chosen uniform
probability resulting small contiguous regions uniform traversal costs path cost
runtime fd smaller basic theta path cost grids
percent larger fd although runtime much smaller fd thus
angle large advantage grids table b reports
traversal cost one chosen probability percent traversal costs chosen
uniform probability resulting large contiguous regions uniform traversal costs path
cost basic theta smaller fd runtime
fd paths found fd tend many unnecessary heading changes regions
traversal costs basic theta outweighs paths found basic
theta necessary heading changes boundary two cells different
traversal costs path cost grids percent larger basic theta
thus angle larger advantage grids

trading runtime path length exploiting h values
strategies trading runtime path length grids basic theta share
however behavior different even though two similar
pseudocode section develop versions basic theta might able shorter
paths increase runtime including versions use weighted h values weights less
one break ties among vertices f value open list favor vertices
smaller g values decide vertex expand next expand vertices whose
f values decreased


fit heta ny ngle path p lanning



g rids

use path consistent h values grids following
properties pearl f value expanded vertex larger f value
unexpanded visible neighbors updating according path implies
f value vertex expanded vertex larger f value
vertex consequently point time search vertex expanded
following parents expanded vertex start vertex retrieves shortest path
start vertex expanded vertex reverse implies cannot shorter paths
expanding vertices basic theta different properties f value
expanded vertex larger f value one unexpanded visible neighbors
updating according path implies f value vertex expanded
vertex larger f value vertex consequently
point time search vertex expanded following parents
expanded vertex start vertex guaranteed retrieve shortest path start vertex
vertex reverse implies basic theta might shorter paths expanding
vertices figure shows example basic theta expands start vertex c
parent c generates vertex b vertex b unexpanded visible neighbor vertex c
line sight vertex c basic theta thus updates according path
path case sets f value f b sets parent vertex
c inserts open list figure basic theta later expands vertex b
parent c generates vertex b vertex b unexpanded visible neighbor vertex b
line sight vertex c basic theta thus updates according path sets f value
f b sets parent vertex c inserts open list figure
b thus f value expanded vertex b indeed larger f value unexpanded
visible neighbor b updating according path increase g value vertex
b vertex b less decrease h value vertex b vertex b
basic theta later expands vertex b f value vertex b expanded
vertex b indeed larger f value vertex b
properties suggest basic theta might able shorter paths increase
runtime expanding vertices expanding additional vertices example weighted
h values weights less one cannot time standard optimizations
decrease runtime might able decrease runtime basic theta
breaking ties among vertices f value open list favor vertices larger
g values section investigate tradeoffs
weighted h values
far basic theta used consistent h values h consistent h values finds paths
length matter small large h values decreasing consistent h values typically
increases number vertex expansions therefore discuss version basic
theta might able shorter paths increase runtime weighted h values
weights less one version basic theta uses h values h w c sgoal
given weight w thus similar weighted pohl except weighted
typically uses weights greater one figure shows example resulting effect
number vertex expansions path length green vertex north east start



fidaniel nash koenig f elner

expanded vertices basic theta different weights








path length








vertex expansions




























w
basic theta path length

ap theta path length

basic theta vertex expansions

ap theta vertex expansions

b random grids percent blocked cells

figure weighted h values

vertex red vertex south west goal vertex basic theta weight
used far expands orange vertices finds red path basic theta weight
expands blue vertices finds blue path thus basic theta expands vertices


fit heta ny ngle path p lanning

path length
number vertex expansions
runtime

smaller g values
basic theta ap theta









g rids

larger g values
basic theta ap theta







table random grids percent blocked cells


weight weight resulting path shorter since passes vertices
expanded weight weight
figure b reports effect different weights path length number vertex expansions basic theta ap theta random grids percent blocked cells
graphs number vertex expansions basic theta ap theta nearly coincide
decreasing weight decreases path length increase number vertex expansions
thus runtime path length decreases ap theta basic theta since ap
theta constrain angle ranges necessary thus benefits two ways expanding vertices however neither basic theta ap theta guaranteed true
shortest paths even weights zero
tie breaking
far basic theta broken ties among vertices open list f value favor
vertices larger g values decides vertex expand next consistent
h values finds paths length matter tie breaking scheme uses breaking ties
favor vertices smaller g values typically increases number vertex expansions
thus runtime therefore discuss version basic theta might able shorter
paths increase runtime breaking ties favor vertices smaller g values figure
shows example resulting effect path length vertices c b f value
vertex b larger g value since f c f b
basic theta breaks ties favor vertices larger g values expands vertex b
parent e vertex c parent c eventually expands goal vertex parent b
terminates path extraction follows parents goal vertex b start vertex e
retrieve dashed red path e b b however basic theta breaks ties favor vertices
smaller g values expands vertex c parent c vertex b parent e
eventually expands goal vertex parent c terminates path extraction follows
parents goal vertex b start vertex e retrieve shorter solid blue path e c
b
table reports effect tie breaking scheme path length number vertex expansions
runtime basic theta ap theta random grids percent blocked
cells breaking ties favor vertices smaller g values neither changes path length
number vertex expansions runtime significantly effect tie breaking scheme
small since fewer vertices f value basic theta ap theta
grids number possible g values h values larger angle path


fidaniel nash koenig f elner









b





goal

c



e

start

basic theta path larger g values

basic theta path smaller g values

figure basic theta paths different tie breaking schemes

path length
number vertex expansions
runtime

basic theta without vertex expansions




basic theta vertex expansions




table random grids percent blocked cells

second method breaking ties effect path length far basic theta
chosen path path unexpanded visible neighbor vertex line sight
parent vertex however choose path path paths equally long
increases runtime due additional comparison figure shows example
resulting effect path length assume basic theta expands vertex b vertex c
basic theta chooses path path expands vertex b parent e eventually
expands goal vertex b parent b terminates path extraction follows parents
goal vertex b start vertex e retrieve dashed red path e b b however
basic theta chooses path path expands vertex b parent c eventually
expands goal vertex b parent c terminates path extraction follows parents
goal vertex b start vertex e retrieve shorter solid blue path e c b
expanding vertices
far basic theta used closed list ensure expands vertex
consistent h values expand vertices whether uses closed list since
cannot shorter path start vertex vertex expanding vertex
hand basic theta expand vertices use closed list since shorter
path start vertex vertex expanding vertex inserts vertex


fit heta ny ngle path p lanning



















g rids



b



goal

c



e

start

basic theta path

basic theta path vertex expansions

figure basic theta paths without vertex expansions
open list eventually expands figure shows example effect vertex
expansions path length basic theta without vertex expansions eventually expands vertex
c parent vertex c unexpanded visible neighbor vertex c line sight
vertex basic theta without vertex expansions thus updates according path
sets parent vertex termination path extraction follows parents goal vertex
b start vertex e retrieve dashed red path e c b however basic theta
vertex expansions eventually expands vertex c parent later expands vertex c
parent e vertex c visible neighbor vertex c line sight vertex e
basic theta vertex expansions thus updates according path sets parent
vertex e termination path extraction follows parents goal vertex b start vertex
e retrieve shorter solid blue path e c b
theorem basic theta vertex expansions terminates path extraction returns
unblocked path start vertex goal vertex path exists otherwise basic
theta vertex expansions terminates reports unblocked path exists

proof proof similar proof theorem property needs proved
differently basic theta vertex expansions terminates since longer true
never insert vertex open list removed vertex open list
however since number vertices finite finite number acyclic paths
start vertex vertex therefore number possible g values finite therefore basic
theta vertex expansions reduce g value vertex finite number times
thus inserts vertex open list finite number times thus open list eventually
becomes empty basic theta terminate terminated earlier already
basic theta vertex expansions could delay expansion goal vertex example increasing
f value artificially expand vertices terminates version basic theta
vertex expansions



fidaniel nash koenig f elner

table reports effect vertex expansions path length number vertex expansions
runtime basic theta random grids percent blocked cells vertex
expansions decrease path length slightly increase number vertex expansions
thus runtime

trading runtime path length approaches
additional strategies trading runtime path length specific basic
theta section develop versions basic theta might able shorter
paths increase runtime examining paths including versions check line ofsight parent parent use key vertices identify promising parents increase
number visible neighbors thus number potential parents updating vertices
according path
three paths
far basic theta considered two paths namely paths updates gvalue parent unexpanded visible neighbor vertex discuss version
basic theta considers third path namely path start vertex parent
parent vertex g parent parent vertex straight line
c parent parent resulting length g parent parent c parent parent
version basic theta might able shorter paths increase runtime since
third path longer path due triangle inequality however experimental
reported third path decrease path length significantly
original version basic theta already determines parent parent vertex
line sight vertex shares parent vertex thus unlikely
parent parent vertex line sight vertex thus third path
unblocked
key vertices
far basic theta considered two paths namely paths updates g value
parent unexpanded visible neighbor vertex parent vertex
visible neighbor vertex parent visible neighbor case
true shortest paths discuss version basic theta considers additional paths
namely paths start vertex cached key vertices vertex straight
line version basic theta might able shorter paths increase runtime
due fact parent vertex one key vertices however
experimental reported key vertices decrease path length slightly
larger increase runtime due overhead select key vertices maintain
consider larger number paths



fit heta ny ngle path p lanning

branching factor

b branching factor



g rids

c branching factor

figure grids different branching factors

















runtime

path length

















basic theta



branching factor
path length

runtime

figure basic theta random grids percent blocked cells

larger branching factors
far basic theta operated eight neighbor grids discuss version basic theta
operates grids different numbers neighbors thus different branching factors
figure shows neighbors center vertex branching factors respectively
version basic theta might able shorter paths increase runtime since
larger branching factors increase number visible neighbors vertices thus number
potential parents updating according path figure reports effect larger
branching factors path length runtime basic theta random grids
percent blocked cells larger branching factors indeed decrease path length increase
runtime


fidaniel nash koenig f elner

conclusions
angle path paths without artificially constraining headings
paths presented two correct complete angle path basic
theta angle propagation theta ap theta variants propagate information along grid edges achieve short runtime without constraining paths grid edges
angle paths basic theta simple understand implement fast finds short paths
however guaranteed true shortest paths ap theta achieves worst case complexity per vertex expansion constant grids rather linear number
cells basic theta propagating angle ranges expands vertices however
ap theta complex basic theta fast finds slightly longer paths
proved correctness completeness basic theta ap theta compared
three existing angle path namely post smoothed
paths ps visibility graphs field fd version know
propagates information along grid edges without constraining paths grid edges basic
theta ap theta unlike ps consider paths constrained grid edges
search thus make informed decisions regarding paths search basic theta
ap theta unlike fd take advantage fact true shortest paths heading changes
corners blocked cells
visibility graphs finds true shortest paths slow hand grids finds
long paths fast angle path lies two extremes basic theta
dominates ap theta ps fd terms tradeoffs runtime path length
finds paths almost short true shortest paths almost fast grids
extended basic theta paths given start vertex vertices
paths grids contain cells non uniform traversal costs f value expanded vertex
basic theta unlike grids consistent h values larger f value one
unexpanded visible neighbors means basic theta might able
shorter paths increase runtime expanding vertices expanding additional vertices
thus developed versions basic theta use weighted h values weights less one
break ties among vertices f value open list favor vertices smaller
g values decide vertex expand next expand vertices whose f values
decreased check line sight parent parent use key vertices identify
promising parents increase number visible neighbors
future intend develop worst case bound path lengths basic theta ap
theta better understand properties investigate faster versions ap theta
perform line sight checks constant time

appendix checking line sight
appendix explain perform line sight checks fast simplicity allow
straight lines pass diagonally touching blocked cells performing line sight check
similar determining points plot raster display drawing straight line two points plotted points correspond cells straight line passes


fit heta ny ngle path p lanning



g rids

lineofsight

x x



x x



dy

dx x x

f

dy

dy dy

sy



else





dx
dx dx
sx




else








dx dy
x x
f f dy
f dx
grid x sx sy
return false

sy

sx

sy
f f dx






f grid x sx sy
return false




dy grid x sx grid x sx
return false



x x sx








else

f f dx
f dy
grid x sx sy
return false
x x sx
f f dy






f grid x sx sy
return false




dx grid x sy grid x sy
return false



sy


return true
end

line sight

thus two vertices line sight iff none plotted points correspond blocked cells
allows basic theta perform line sight checks standard bresenham line drawing
computer graphics bresenham uses fast logical integer operations rather floating point operations shows resulting line sight


fidaniel nash koenig f elner

ii

yaxis



p
b

xaxis

b

b
b

b

b
b

b

b
b



iii

b

upper boundary

iv
lower boundary

figure parent blocked cell boundary vertices
x x coordinates vertex respectively grid represents grid
grid x true iff corresponding cell blocked

appendix b ap theta returns unblocked paths
appendix prove ap theta never returns blocked path
theorem ap theta never returns blocked path
proof define path blocked iff least one vertex path line sight
successor path thus path blocked iff least one path segments passes
interior blocked cell passes two blocked cells share edge
first prove ap theta never returns path path segment passes
interior blocked cell prove contradiction ap theta cannot assign parent p
vertex path segment parent p vertex passes interior
blocked cell b assume otherwise simplify proof translate rotate grid
blocked cell b immediately south west origin b grid parent p quadrant
ii shown figure define quadrant vertex follows x
x coordinates vertex respectively
quadrant north east quadrant excluding x axis given x
quadrant ii north west quadrant excluding axis given x
quadrant iii south west quadrant excluding x axis given x


fit heta ny ngle path p lanning

northwest
west
southwest

north


south



g rids

northeast
east
southeast

figure neighbors vertex
quadrant iv south east quadrant excluding axis including origin b given
x x
refer neighbors vertex east northeast north northwest west
southwest south southeast shown figure
assume light source vertex p light cannot pass blocked cell b
creates shadow vertex shadow iff straight line parent p vertex
passes interior blocked cell b distinguish two parts perimeter
shadow namely upper lower boundary shown figure define boundary vertex
vertex shadow least one neighbor although necessarily visible
neighbor shadow origin b shadow neighbor south b
shadow thus origin b boundary vertex consider upper boundary without
loss generality boundary vertex precise upper boundary vertex vertex
p b upper boundary thus outside shadow
least one neighbor p b upper boundary thus inside
shadow easy see boundary vertices quadrant iv form infinite
boundary path b b starts origin b repeatedly moves south east
bi south bi bi east bi
define vertex sufficiently constrained iff p b lb parent p
vertex sufficiently constrained remains sufficiently constrained since operation ap
theta decrease lower angle bound lb prove following every boundary
vertex sufficiently constrained time expanded expanded parent p consider
vertex upper boundary p b thus b p
visible neighbor boundary vertex bi vertex cannot updated according path
assigned parent p time parent p expanded since straight line parent p
vertex passes interior blocked cell therefore visible neighbors
cannot updated according path assigned parent p time boundary
vertex bi expanded parent p boundary vertex bi sufficiently constrained
time thus bi p b lb bi implies bi p bi p b b p
bi p b lb bi condition line remains unsatisfied consequently vertex
shadow parent p
prove induction order vertex expansions every boundary vertex
sufficiently constrained time expanded expanded parent p assume
boundary vertex b expanded parent p condition line satisfied


fidaniel nash koenig f elner

line executed blocked cell b time boundary vertex b expanded parent p
boundary vertex b sufficiently constrained afterwards since lower angle bound set zero
assume boundary vertex bi expanded parent p boundary vertex bi
cannot identical parent p since different quadrants start vertex since
start vertex parent p boundary vertex bi cannot updated according path
assigned parent p time parent p expanded since p x bi x
thus neighbors consequently boundary vertex bi must updated according
path assigned parent p time one visible neighbors x expanded
parent p vertex x must upper boundary x p b cannot
identical parent p since different quadrants distinguish two cases
assume vertex x boundary vertex sufficiently constrained time expanded parent p according induction assumption x p b lb x
since expanded boundary vertex bi boundary vertex bi updated according
path time vertex x expanded parent p thus condition line
satisfied time lb x x p bi thus lb x bi p x
lb x x p bi conditions lines satisfied
line executed x time boundary vertex bi expanded parent
p boundary vertex bi sufficiently constrained afterwards since lower angle bound
set max lb bi lb x bi p x bi p b bi p x x p b
lb x bi p x max lb bi lb x bi p x
assume vertex x boundary vertex
lemma assume vertex boundary vertex bi visible neighbors c p bi
c p p bi assume boundary vertex bi sufficiently constrained
time vertex expanded parent p boundary vertex bi expanded parent
p time vertex sufficiently constrained time expanded
expanded parent p
proof assume vertex expanded parent p p b p bi
bi p b since p bi bi p b distinguish two cases
assume boundary vertex bi expanded vertex expanded
parent parent p conditions lines satisfied
line executed bi time vertex expanded parent
p vertex sufficiently constrained afterwards since lower angle bound set
max lb p bi p b p bi bi p b p bi
max lb p bi
assume boundary vertex bi expanded parent p vertex expanded
parent p boundary vertex bi sufficiently constrained time vertex
expanded parent p according premise bi p b lb bi furthermore lb bi since operation ap theta make lower angle bound
positive thus lb bi p bi conditions lines
satisfied line executed bi time vertex expanded
parent p vertex sufficiently constrained afterwards since lower angle bound


fit heta ny ngle path p lanning



g rids

set max lb lb bi p bi p b p bi bi p b
lb bi p bi max lb lb bi p bi

boundary vertex bi immediately south east boundary vertex bi since
boundary path moves south east distinguish three subcases
assume parent p x axis quadrant ii boundary path
along x axis vertices west bi east bi boundary vertices vertices
southwest bi south bi southeast bi upper boundary thus
vertex x identical one vertices northwest bi north bi northeast bi
cases boundary vertex bj immediately south vertex x vertices x
bj visible neighbors would blocked cells immediately southwest south east vertex x vertices x bi could thus visible neighbors
thus vertices x bj visible neighbors furthermore boundary vertex bj immediately south vertex x thus c p bj c p x x p bj finally
boundary vertex bj sufficiently constrained according induction assumption
time boundary vertex bi expanded parent p boundary vertex bj
expanded parent p time thus vertex x sufficiently constrained time
expanded parent p according lemma x p b lb x consequently conditions lines satisfied reason given
line executed x time boundary vertex bi expanded parent
p boundary vertex bi sufficiently constrained afterwards since lower angle bound
set max lb bi lb x bi p x bi p b bi p x x p b
lb x bi p x max lb bi lb x bi p x
assume parent p x axis quadrant ii boundary vertex
bi immediately east boundary vertex bi thus c p bi c p bi
bi p bi furthermore boundary vertex bi sufficiently constrained according induction assumption time boundary vertex bi expanded
parent p boundary vertex bi expanded parent p time boundary vertices bi bi visible neighbors boundary vertex bi sufficiently
constrained time expanded parent p according lemma boundary
vertices bi bi visible neighbors must blocked cells immediately north west south west boundary vertex bi line satisfied
line executed blocked cell immediately south west boundary vertex bi
time boundary vertex bi expanded parent p boundary vertex bi sufficiently
constrained afterwards since lower angle bound set zero
assume parent p x axis quadrant ii boundary vertex bi
immediately south boundary vertex bi
lemma assume vertex quadrant iv upper boundary
vertex boundary vertex iff vertex immediately south west vertex
upper boundary


fidaniel nash koenig f elner

proof vertex immediately south west vertex upper boundary
vertex boundary vertex definition hand vertex
upper boundary p b vertex boundary
vertex every neighbor upper boundary neighbors
vertex
east northeast north northwest
west southwest south southeast
equivalently
east east north east east north north east north north
north north north east east east
thus every neighbor vertex reached vertex repeatedly moving north east thus p consequently p b
p p b thus every neighbor vertex
upper boundary
distinguish two subcases
assume boundary vertex bi immediately east boundary vertex
bi vertices north bi east bi boundary vertices vertices west bi
southwest bi south bi south west boundary vertices bi bi bi
respectively thus upper boundary according lemma vertices
northwest bi southeast bi boundary vertices south west
boundary vertices bi bi respectively upper boundary
according lemma thus vertex x identical vertex northwest bi
assume boundary vertex bi immediately south boundary vertex bi
vertices north bi south bi boundary vertices vertices west bi
southwest bi south west boundary vertices bi bi respectively
thus upper boundary according lemma vertex northwest bi
boundary vertex south west boundary vertex bi
upper boundary according lemma thus vertex x identical one vertices
northeast bi east bi southeast bi
cases vertex x immediately east boundary vertex bj thus c p bj
c p x x p bj vertices x bj visible neighbors
would blocked cells immediately north west south west vertex x vertices
x bi could visible neighbors thus vertices x bj visible neighbors
furthermore boundary vertex bj sufficiently constrained according induction
assumption time boundary vertex bi expanded parent p boundary vertex bj expanded parent p time thus vertex x sufficiently
constrained time expanded parent p according lemma
x p b lb x consequently conditions lines satisfied
reason given line executed x time boundary vertex
bi expanded parent p boundary vertex bi sufficiently constrained afterwards
since lower angle bound set max lb bi lb x bi p x bi p b
bi p x x p b lb x bi p x max lb bi lb x bi p x


fit heta ny ngle path p lanning



g rids

concludes proof every boundary vertex sufficiently constrained time
expanded expanded parent p thus proof ap theta never returns path
path segment passes interior blocked cell
prove ap theta never returns path path segment passes two
blocked cells share edge prove contradiction ap theta cannot assign
parent p vertex path segment parent p vertex passes two
blocked cells share edge assume otherwise consider first time ap theta assigns
parent p vertex path segment parent p vertex passes
two blocked cells share edge path segment must horizontal vertical vertex
cannot updated according path assigned parent p time parent p
expanded since straight line parent p vertex passes interior
blocked cell therefore visible neighbors cannot updated according
path assigned parent p time visible neighbor expanded parent p
since neighbor would colinear vertices p straight line
parent p vertex would thus pass interior blocked cell b neighbor would
colinear vertices p straight line parent p vertex would pass
two blocked cells share edge contradiction assumption concludes
proof ap theta never returns path path segment passes two blocked
cells share edge
thus ap theta never returns blocked path

appendix c acknowledgments
article extension earlier publication nash et al contains additional
expositions examples proofs thank vadim bulitko university alberta
making maps real time game baldurs gate ii available us done
ariel felner spent sabbatical university southern california visiting sven koenig
partly supported u army laboratory arl u
army office aro award sven koenig grant w nf office
naval onr award sven koenig grant n national
science foundation nsf award sven koenig grant israeli science
foundation isf award ariel felner grants alex nash funded
northrop grumman corporation views conclusions contained document
authors interpreted representing official policies
expressed implied sponsoring organizations agencies companies u government

references
aurenhammer f voronoi diagramsa survey fundamental geometric data structure
acm computing surveys
botea muller schaeffer j near optimal hierarchical path finding journal
game development


fidaniel nash koenig f elner

bresenham j computer control digital plotter ibm systems journal

bulitko v sturtevant n kazakevich speeding learning real time search via
automatic state abstraction proceedings aaai conference artificial intelligence
pp
choset h lynch k hutchinson kantor g burgard w kavraki l thrun
principles robot motion theory implementations mit press
deloura game programming gems charles river media
ferguson stentz interpolation improve path field
journal field robotics
foley j van dam feiner hughes j computer graphics principles practice addison wesley
hart p nilsson n raphael b formal basis heuristic determination
minimum cost paths ieee transactions systems science cybernetics scc

kavraki l svestka p latombe j overmars probabilistic roadmaps path
high dimensional configuration spaces ieee transactions robotics automation
koenig likhachev lite proceedings aaai conference artificial
intelligence pp
lavalle kuffner j rapidly exploring random trees progress prospects
donald b lynch k rus eds algorithmic computational robotics
directions pp k peters
lee proximity reachability plane ph thesis university illinois
urbana champaign
liu h arimoto path tangent graph mobile robots among
polygonal curved obstacles international journal robotics
lozano perez wesley collision free paths among
polyhedral obstacles communication acm
mitchell j papadimitriou c weighted region finding shortest paths
weighted planar subdivision journal acm
murphy r introduction ai robotics mit press
nash daniel k koenig felner theta angle path grids
proceedings aaai conference artificial intelligence pp
nash koenig likhachev incremental phi incremental angle path grids proceedings international joint conference aritificial intelligence
pp
patel
amits game programming information
available online
http theory stanford edu amitp gameprogramming maprepresentations html


fit heta ny ngle path p lanning



g rids

pearl j heuristics intelligent search strategies computer solving addisonwesley
pohl avoidance relative catastrophe heuristic competence genuine dynamic
weighting computational issues heuristic solving proceedings international joint conference artificial intelligence pp
rabin ai game programming wisdom charles river media
rabin ai game programming wisdom charles river media
thorpe c path relaxation path mobile robot proceedings aaai
conference artificial intelligence pp
tozour p search space representations rabin ed ai game programming wisdom
pp charles river media
yahja stentz singh brumitt b framed quadtree path mobile
robots operating sparse environments proceedings international conference
robotics automation pp
yap p grid path finding proceedings canadian conference artificial
intelligence pp




