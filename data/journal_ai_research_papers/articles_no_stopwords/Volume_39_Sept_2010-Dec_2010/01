journal artificial intelligence

submitted published

implicit abstraction heuristics
michael katz
carmel domshlak

dugi tx technion ac il
dcarmel ie technion ac il

faculty industrial engineering management
technion israel

abstract
state space search explicit abstraction heuristics state art costoptimal heuristics inherently limited nonetheless size
abstract space must bounded even large constant targeting
shortcoming introduce notion additive implicit abstractions
task abstracted instances tractable fragments optimal
introduce concrete setting framework called fork decomposition
two novel fragments tractable cost optimal induced admissible
heuristics studied formally empirically study testifies accuracy
fork decomposition heuristics yet empirical evaluation stresses tradeoff
accuracy runtime complexity computing indeed
power explicit abstraction heuristics comes precomputing heuristic
function offline determining h evaluated state fast lookup
database contrast fork decomposition heuristics calculated
polynomial time computing far fast address
time per node complexity bottleneck fork decomposition heuristics
successfully overcome demonstrate equivalent explicit abstraction
notion database exists fork decomposition abstractions well despite
exponential size abstract spaces verify empirically heuristic search
databased fork decomposition heuristics favorably competes state art
cost optimal

introduction
heuristic search progression space world states regression space subgoals common successful classical
probably popular cost optimal finding plan
minimal total cost actions difference heuristic search
optimal mainly admissible heuristic functions employ
state space search heuristic estimates cost achieving goal given
state guarantees overestimate cost
useful heuristic function must accurate well efficiently computable improving
accuracy heuristic function without substantially worsening time complexity
computing usually translates faster search optimal solutions last
decade numerous computational ideas evolved admissible heuristics classical
include delete relaxing max heuristic hmax bonet geffner critical path heuristics hm haslum geffner landmark heuristics hl hla karpas
domshlak hlm cut helmert domshlak abstraction heuristics
c

ai access foundation rights reserved

fikatz domshlak

pattern database heuristics edelkamp merge shrink heuristics helmert
haslum hoffmann focus work abstraction heuristics
generally speaking abstraction task given mapping
states tasks transition system states abstract
transition system states cost upperbounded cost abstraction heuristic value h cost
closest goal state abstract transition system perhaps well known
abstraction heuristics pattern database pdb heuristics projecting
task onto subset state variables explicitly searching optimal
plans abstract space years pdb heuristics shown
effective several hard search including cost optimal culberson
schaeffer edelkamp felner korf hanan haslum botea helmert
bonet koenig conceptual limitation heuristics however
size abstract space dimensionality must fixed recent merge andshrink abstractions generalize pdb heuristics overcome latter limitation helmert
et al instead perfectly reflecting state variables merge shrink
abstractions allow imperfectly reflecting variables demonstrated formal
empirical analysis helmert et al flexibility often makes merge shrink
abstractions much effective pdbs however merge shrink abstract
spaces still searched explicitly thus still fixed size quality
heuristics estimates still obtained many limitation critical
obstacle many others
goal push envelope abstraction heuristics beyond explicit
abstractions introduce principled way obtain abstraction heuristics limit neither dimensionality size abstract spaces basic idea behind
call implicit abstractions simple intuitive instead relying abstract
easy solve small rely abstract belonging
provably tractable fragments optimal key point least theoretically moving implicit abstractions removes requirement abstractions size
small contribution however showing implicit abstractions far
theoretical interest specifically
specify acyclic causal graph decompositions general framework additive implicit abstractions decomposing hand along causal
graph introduce concrete family abstractions called fork decompositions two novel fragments tractable cost optimal
following type analysis suggested helmert mattmuller formally analyze asymptotic performance ratio fork decomposition heuristics
prove worst case accuracy selected domains comparable
even parametric state art admissible heuristics empirically evaluate accuracy fork decomposition heuristics large set domains
recent competitions accuracy competitive
state art
necessarily apply symbolic pdbs tasks may exponentially reduce
pdbs representation edelkamp



fiimplicit abstraction heuristics

key attraction explicit abstractions state goal costs abstract
space precomputed stored memory preprocessing phase
heuristic evaluation search done simple lookup necessary condition would seem small size abstract space however
equivalent pdb merge shrinks notion database
exists fork decomposition abstractions well despite exponential size abstract spaces latter databased implicit abstractions proper
partitioning heuristic computation parts shared search
states parts must computed online per state empirical evaluation
shows equipped databased fork decomposition heuristics favorably
competes state art cost optimal
work revision extension formulation presented katz
domshlak turn ideas first sketched katz
domshlak

preliminaries
consider classical tasks corresponding state single initial state
deterministic actions specifically consider state captured sas
formalism backstrom nebel nonnegative action costs task
given quintuple hv g costi
v set state variables v v associated finite domain
v subset variables v v denote set assignments v
v vv v complete assignment v called state v
state space initial state goal g partial assignment v
state goal state iff g
finite set actions action pair hpre eff partial assignments
v called preconditions effects respectively av denote actions
affecting value v cost r real valued nonnegative action cost
function
variable v value v instantiation v denoted v
partial assignment p v p v denotes subset state variables instantiated p
turn v v p p v denote value v p v v singleton
use p v p v sequence actions variable v v v denote
restriction actions changing value v v maximal subsequence
consisting actions av
action applicable state iff v pre v v v pre applying
changes value v v eff eff v resulting state denoted sjak
sjha ak ik denote state obtained sequential application respectively
applicable actions ak starting state action sequence plan
g sjha ak ik cost optimal follows optimal plan
sum action costs minimal among plans purpose optimal
finding optimal plan pair states cost refer


fikatz domshlak

p

b

c

f
c


c





c

c



e
p

c

c

p

g
p



b


c

b




f


e

c

e



b

c



e

f

g

g
c

c

c



figure logistics style example adapted helmert illustrated
goal deliver p c g p f e cars c c c
truck making sure c ends f cars may use city roads thin
edges truck may use highway thick edge figures b c
depict respectively causal graph domain transition
graphs labels omitted c c left center c right
identical domain transition graphs p p

cost cost optimal plan h mins g cost custom notation
cost optimal plan finally important roles follows played
pair standard graphical structures induced tasks
causal graph cg digraph nodes v arc v v cg
iff v v exists action v v v eff v pre
v eff case say v v induced succ v pred v
respectively denote sets immediate successors predecessors v cg
domain transition graph dtg v variable v v arc labeled digraph
nodes v arc labeled pre v v cost
exists graph iff eff v pre v v v pre
illustrate constructs use slight variation logistics style example
helmert example depicted figure sas


fiimplicit abstraction heuristics

v

p p c c c

p p b c e f g c c c
c c b c

c e f g
e

p c p f e c c b c g

g p g p e c f

actions corresponding possible loads unloads well single segment movements vehicles instance action captures loading p c c
pre p c c c eff p c actions example unit cost
causal graph example well domain transition graphs state
variables depicted figures b
heuristic functions used informed search procedures estimate cost
cheapest path search node nearest goal node focus statedependent admissible abstraction heuristics heuristic function h state dependent
estimate search node depends state associated node
h r heuristics use days state dependent though
see e g richter helmert westphal karpas domshlak different
case heuristic h admissible h h states h h two
admissible heuristics h h states say h dominates h
set admissible heuristics h hm pointwise maximum
admissible heuristic dominating individual heuristic set sets admissible heuristics pointwise sum admissible dominates pointwise
maximum many recent works cost optimal additive ensembles admissible heuristics includes critical path heuristics haslum bonet
geffner coles fox long smith pattern database heuristics edelkamp
haslum et al landmark heuristics karpas domshlak helmert
domshlak particular katz domshlak yang et al
independently introduced general criterion admissible additive ensembles
heuristics called former work action cost partitioning criterion formalized follows let hv g
task costi r

pcosti

family cost functions costi cost actions hi

set

arbitrary
admissible
heuristic
functions



hv


g
cost

respectively


p


hi admissible heuristic set cost functions costi
seen partition action costs cost

abstractions abstraction heuristics
semantics task given induced state transition model often
called transition graph



fikatz domshlak

definition transition graph tuple l tr finite
set states l finite set transition labels tr l set labeled
transitions initial state set goal states l r
transition cost function
state subset states cost cost
cheapest respect path state along transitions
state reachable cost
path plan cheapest plans called optimal
states transition graph induced task hv g costi
states transition labels actions transition
sjak tr iff applicable initial state set goal states
g transition cost function cost
proceed
formally specifying notion abstraction definition abstraction resembles
prieditis right beginning specify general notion
additive abstraction informally additive abstraction refer set abstractions
interconstrained requirement jointly overestimate transition path costs
abstracted transition graph
definition additive abstraction transition graph l tr
set pairs hti

ti si li tri si transition graph
si function called abstraction mapping
si
pairs states holds

x


cost cost



words use particular notion abstraction term abstraction
usually associated simplifying original system reducing factoring details
less crucial given context details reduced better
preserved depends course context instance context formal
verification abstract transition graphs required decrease reachability
states path original transition graph
path abstract transition graph clarke
grumberg peled addition reachability increased little
possible beyond precise relationship path costs original
abstract transition graphs secondary importance contrast abstractions
designed induce admissible heuristic functions heuristic search relationship
path costs captured eq must obeyed however requirements
beyond general requirement eq overestimate distances


fiimplicit abstraction heuristics

states unnecessary hence particular definition generalizes notion
abstraction helmert et al replacing condition preserving individual
transitions labels l l weaker condition stated
eq reader course may well ask whether generality condition
eq beyond condition helmert et al really delivers practical gain
later answer question affirmative proceed
adding requirements essential making abstraction usable basis heuristic
functions
definition let task states let hti
additive
abstraction transition graph poly states
p
cost cost si ti computable time poly

ha
cost si abstraction heuristic function
note admissibility ha implied cost conservation condition eq illustrate connection abstractions admissible heuristics consider three
well known mechanisms devising admissible heuristics delete relaxation bonet
geffner critical path relaxation haslum geffner pattern database
heuristics edelkamp
first typically considered way delete relaxation task

hv g costi correspond abstraction ht l tr


transition
graph

assuming
unique
naming


variable
values



des
noting vv v abstract states power set
labels l transitions come two sources abstract state
original action applicable jak tr
eff tr minor abuse notation initial state
g abstraction
goal states abstraction



mapping simply identity function easy state
h h delete relaxation
task cost
estimate cost goal aside note delete relaxation
abstraction ht particular exemplifies nothing definition requires
size abstract state space limited size original state space
event however abstraction ht induce heuristic terms definition
computing h known np hard bylander
situation critical path relaxation exactly opposite computing
corresponding family admissible estimates hm polynomial time fixed
computation computing shortest paths abstraction
task state graph hm computed graph
graph transition graphs actual computation hm corresponds
computing critical tree shortest path goal best
knowledge precise relation critical path abstraction heuristics currently
open question helmert domshlak
overall abstraction heuristics toolbox days appear
explicit homomorphism abstractions whose best known representative probably
assume reader familiar two relaxations discussion safely
skipped



fikatz domshlak

pattern database pdb heuristics given task state variables v
pdb heuristic projecting onto subset variables v v
homomorphism abstraction maps two states abstract state iff
v v inspired similarly named domain specific heuristics search
n puzzles rubiks cube culberson schaeffer hernadvolgyi holte felner et al pdb heuristics successfully exploited domain independent well edelkamp haslum et al
key decision constructing pdbs sets variables
projected edelkamp haslum et al however apart need
automatically select good projections two limitations pdb heuristics size
abstract space dimensionality first number abstract states
small enough allow reachability analysis exhaustive search moreover
bound typically set explicitly fit time memory limitations
system second since pdb abstractions projections explicit constraint
implies fixed dimensionality constraint v tasks informally
many alternative resources limitation pitfall instance suppose

sequence logistics growing size vi package
transported vehicles starting h account
movements vehicles essential solving helmert mattmuller
aiming preserving attractiveness pdb heuristic eliminating bottleneck fixed dimensionality helmert et al generalized methodology
drager finkbeiner podelski introduced called merge shrink
ms abstractions ms abstractions homomorphisms generalize pdb
abstractions allowing flexibility selection pairs states contracted
state space viewed synchronized product projections onto
single state variables starting atomic abstractions product
computed iteratively composing two abstract spaces replacing product
pdb size abstract space controlled limiting number
product compositions ms abstractions controlled interleaving iterative composition projections abstraction partial composites helmert et al
proposed concrete strategy interleaved abstraction refinement scheme empirically demonstrated power merge shrink abstraction heuristics pdbs
however ms abstractions explicit abstractions thus computing heuristic values explicitly searching optimal plans abstract spaces hence
merge shrink abstractions escape fixed dimensionality constraint pdbs
constraint abstract space fixed size still holds

implicit abstractions
focusing bound posted explicit abstractions size abstract
space first observation explicit abstractions necessarily way
proceed abstraction heuristics given task states suppose
transform different task
transformation induces abstraction mapping state
space


fiimplicit abstraction heuristics

transformation well computing state
done time polynomial
task task transformations mind define
call additive implicit abstractions
definition additive implicit abstraction task set pairs


hi
tasks ht
additive abstraction
let us examine notion implicit abstractions closely first implicit
abstractions allow natural additive combination admissible heuristics abstract
tasks composition formulated theorem extending original criterion
admissibility additive heuristics described section second formulated
theorem implicit abstractions composed via functional composition
abstraction mappings two easy prove properties implicit abstractions allow us
take desired step implicit abstractions implicit abstraction heuristics
theorem admissibility let task hi
additive implicit abstraction









h


admissible
heuristic


pm
function h hi admissible heuristic
proof proof straightforward let l tr transition graph
let state let ti si li tri si
transition graph
first hi admissible heuristic si si
hi cost si
state definition si eq

x


thus
h


x


cost cost

hi

giving us admissible estimate


x



h

cost cost


theorem composition let task hi
addimi
tive implicit abstraction
j j j additive
ai h

implicit abstraction
h






additive implicit abi j
j
j

straction
proof let l tr transition graph
let ti si li tri si transition graph j mi let
transition graph need
ti j si j li j tri j j si j
j
j
j abstraction mapping definition j abstraction
mappings


fikatz domshlak

j j j j

si thus j j si j
p


si si cost si
j cost j si j si thus

cost


x


cost


mi
x
x
j
mi
x
x
j

cost j j
cost j j


together theorems suggest following scheme deriving abstraction heuristics given additive implicit abstraction hi
individual abstract
tasks belong tractable fragments optimal use practice
sum true costs admissible estimates costs otherwise optimal abstract tasks cannot proven polynomial time
solvable abstract tasks obtaining admissible estimates
true costs
definition let task states let hi

additive implicit abstraction poly allp
states

h polynomial time computable ha
h
implicit abstraction heuristic function
compared explicit abstraction heuristics pdb heuristics merge andshrink heuristics direction implicit abstraction heuristics least principle
appealing neither dimensionality even size state spaces induced
implicit abstractions required bounded something restrictive
pitfall however implicit abstraction heuristics correspond tractable fragments
optimal palette known fragments extremely limited backstrom
nebel bylander jonsson backstrom jonsson katz domshlak b fact none far appeared us convenient automatically devising useful transformations fortunately next boundaries
tractability expanded right way allowing us successfully materialize
idea implicit abstraction heuristics
following key role played causal graphs induced
tasks informally basic idea behind call causal graph decompositions
abstract given task along subgraph causal graph goal
obtaining abstract specific structure naturally numerous possibilities
obtaining structure oriented abstractions present one decomposition
tailored abstractions around acyclic subgraphs informally decomposition
seen sequential application two kinds task transformations dropping
preconditions pearl certain form breaking actions conjunctive effects
single effect actions


fiimplicit abstraction heuristics

definition let hv g costi task let g vg eg
acyclic subgraph causal graph cg task g hvg ag ig gg costg
acyclic causal graph decomposition respect g
ig vg gg g vg

ag aa ag ag al set actions vg
topological respect g ordering variables v vl
v eff vg l

eff v
v vi

eff v
unspecified otherwise



v vi eg v v eff v vi
pre v
pre ai v eff v
v vi eg v v eff


unspecified otherwise
action

x
ag

costg cost



hard verify definition task acyclic
causal graph decomposition g causal graph cg g exactly subgraph g underlying decomposition illustrate notion acyclic causal graph decomposition
consider task hv g costi five state variables v u v x z
two unit cost actions figure initial state u v x z
goal g u v x z causal graph cg depicted figure
figures b c two subgraphs g g cg respectively well action sets ag ag figure b action
sets ag ag figure c let
hv ai g costi task ai agi agi costi
ai two tasks individually satisfy conditions definition respect gi thus acyclic causal graph decompositions
respect gi
proceed specifying implicit abstractions defined via acyclic causal graph
decompositions
definition let hv g costi task states let g gi

vgi egi
set acyclic subgraphs causal graph cg hgi
acyclic causal graph abstraction g set cost functions
costi r
satisfying



x


costi cost






fikatz domshlak

h x z x z

h x x
h x
h x z z

h
h z z
h z x x

h u v x u v x

h x x
h x u u
h x v v

h u u
h v v
h u v x x

u





x






x






v

z

u







v



u

b



z



v




z


x
c

figure actions causal graph cg graph example
illustrating definition b subgraph g cg induced action sets
ag ag c subgraph g cg induced action sets
ag ag arcs cg subgraphs g g
labeled actions inducing arcs

gi hvgi agi igi ggi costgi acyclic causal graph decomposition
hv g costi respect gi
abstraction mapping si projection mapping vgi
theorem acyclic causal graph abstractions tasks additive implicit
abstractions tasks
proof let hv g costi task let hgi

acyclic causal graph abstraction set subgraphs g gi vgi egi

let l tr transition graph ti
si li tri si transition graph gi need abstraction mapping definition
first definitions
igi vgi vgi
g thus vgi g vgi ggi providing us
si
state action pre state gi
pre vgi let action sequence ha al constructed
eq inductively prove applicable first v vgi
pre v pre v pre v unspecified thus ha applicable
inductive hypothesis j ha aj applicable

let jj k eq j j aj changes value vj eff vj


fiimplicit abstraction heuristics

change vj along j likewise since actions constructed
eq unary effect v vj variables vgi affected along j hence
v vgi v vj j j v eff v pre aj v otherwise
v v pre aj v specified pre aj v pre v v
implies aj applicable j ha aj applicable
finalizing inductive proof likewise exactly arguments affect
l
aj j immediately imply ha al sjak jk
next eqs

x

x

agi

costgi


x


costi cost



let pair original states cost let

ha ak sequence
pk labels along cheapest path

cost cost j cost aj decomposition path sequences
actions eq ap p
neccesarily cheapest path ti
k

thus cost j ag aj costgi providing us



x




cost




x
k
x

x



costgi

j agi aj
k
x

k x

x

x

costgi

j agi aj

cost aj cost

j


thus decompose given task set tractable acyclic causalgraph decompositions g gm solve tasks polynomial
time derive additive admissible heuristic proceed considering
concrete acyclic causal graph decomposition note definition leaves decision
actual partition action costs rather open follows adopt
straightforward uniform action cost partition thescost action equally
split among non redundant representatives
agi however better
choice action cost partition sometimes made fact sometimes even
optimized katz domshlak

fork decompositions
proceed introducing two concrete acyclic causal graph decompositions
combined certain variable domain abstractions provide us implicit abstraction heuristics called fork decomposition heuristics two novel
fragments tractable cost optimal tasks fork inverted fork structured
causal graphs
definition task variables v variable v v


fikatz domshlak

v fork subgraph gvf cg nodes vgvf v succ v edges
egvf v u u succ v
v ifork short inverted fork subgraph gvi cg nodes vgvi
v pred v edges egvi u v u pred v
sets v forks v iforks denoted gf gvf vv gi
gvi vv respectively
task state variables v v fork v ifork
acyclic digraphs allowing us define three implicit abstractions follows
definition task hv g costi

acyclic causal graph abstraction af hfv vf vv gf called
f abstraction set abstract tasks f fv vv called
f decomposition
acyclic causal graph abstraction ai hiv vi vv gi called
abstraction set abstract tasks iv vv called
decomposition
acyclic causal graph abstraction afi hfv vf hiv vi vv
gfi gf gi called abstraction set abstract tasks
fv iv vv called decomposition

definition better understood considering abstraction
logistics example figure schematically illustrates process simplify
example eliminate gfi single node subgraphs obtaining
afi hfc cf hfc cf hfc cf hft tf hip pi hip pi
considering action sets fc fc fc ft ip ip see
original driving action one nonredundant changing variable
representative three abstract tasks load unload action
one nonredundant representative five tasks instance action drive c one nonredundant representative tasks fc ip ip
action load p c one nonredundant representative tasks
fc fc fc ft ip since assume uniform partition action costs cost
driving load unload action relevant abstract task thus set
respectively theorem afi additive implicit
abstraction theorem

x
hfi
hf hi

v

v

vv

admissible estimate h question good estimate
optimal cost solving running example taking reference well known
admissible heuristics hmax bonet geffner h haslum geffner
hmax h considering abstraction optimal plans
tasks follows


fiimplicit abstraction heuristics

fc load p c c unload p c load p
unload p e load p c e unload p c g
load p c f unload p c e
fc load p c c unload p c load p
unload p e load p c e unload p c g
load p c f unload p c e
fc load p c c unload p c load p
unload p e drive c g e load p c e
drive c e g unload p c g drive c g e
drive c e f load p c f drive c f e
unload p c e drive c e f
ft load p c c unload p c drive e
load p drive e unload p e
load p c e unload p c g load p c f
unload p c e
ip drive c drive c c load p c c
drive c c unload p c drive e
load p drive e unload p e
drive c g e load p c e drive c e g
unload p c g drive c g e drive c e f
ip drive c g e drive c e f load p c f
drive c f e unload p c e drive c e f
hence
hfi hf

c






hf








c



hf



c






hf
















hi






p








hf






p










hfi appears least promising
unfortunately despite seeming simplicity tasks turns
implicit fork decomposition abstractions definitions fit requirements
implicit abstraction heuristics definition causal graphs
tasks f form directed forks directed inverted forks respectively
general number variables task large v
even satisficing sas fragments fork inverted
fork causal graphs np complete domshlak dinitz fact recent
chen gimenez sas fragment characterized
nontrivial form causal graph np hard moreover even domain transition graphs
state variables strongly connected example optimal
fork inverted fork structured remain np hard see helmert
respective next however end story
fork decompositions


fikatz domshlak



b

c

p

c

cg

f
c





p

g

p

c



e
c

c

c

p

fv iv vv
fc

c

p

c

p

c

c



ip

p

cg
cg p ip

cg fcfc
cg

figure schematic illustration decomposition running logistics example
hardness optimal fork inverted fork causal
graphs casts shadow relevance fork decompositions closer look proofs
corresponding hardness domshlak dinitz helmert
reveals particular rely root variables large domains exploiting
observation reliance incidental characterize two substantial
islands tractability within structural fragments sas
theorem tractable forks given task hv g costi fork
causal graph rooted r v r time complexity cost optimal
polynomial
proof observe task theorem fork structure
causal graph cg implies actions unary effect leaf variable
v succ r preconditions actions affecting v
following three properties satisfied optimal plans
leaf variable v succ r path v v g v induced
dtg v cycle free contains zero cost cycles case
otherwise nonzero cost cycles eliminated v preserving
validity violating assumed optimality without loss generality
follows assume path v dtg v cycle free case fork
causal graphs select optimal satisfies requirement
v succ r thus v v
ii fixed sequence value changes r forks leaves become mutually
independent ability change value one affect
ability change value others


fiimplicit abstraction heuristics

iii r binary valued v v r demanding leaf variable
terms number value changes required r action preconditions
along v value changes r along except possibly
final value change g r thus particular r maxvsucc r v
begin introducing auxiliary notations r let r
r let r alternating sequence starting
odd even positions sequence r r action
change rs value r action change rs value
action restore value otherwise r maxvsucc r v let
r set nonempty prefixes r g r unspecified otherwise let
set nonempty prefixes r ending g r note r
trivially unsolvable follows assume case
v succ r let dt g v dt g v subgraphs domain transition graphs
dtg v obtained removing dtg v arcs labeled r r
respectively
incrementally constructs set r valid plans starting
r
v succ r pair vs values x v compute cheapest
cost minimal paths v x v x x dt g v dt g v
respectively pairs values x one even paths may course
exist
sequence r v succ r construct layered digraph lv
node layers l l l consists v


li consists nodes v path v x node x li
constructed step x li li lv contains arc

x weighted cost v x

r let k candidate plan constructed follows

v succ r cost minimal path v g v lv
path exists proceed next prefix r otherwise note
th edge path taking us x li li corresponds

cost minimal path v x x let us denote path x
svi

b set r r k k sequence obtained
arbitrary merge sequences svi vsucc r cheapest action
changing value r value
r fail otherwise return argmin r cost
straightforward verify complexity procedure polynomial
description size prove correctness procedure returns
plan solvable task returned plan satisfies cost cost
optimal plan


fikatz domshlak

given solvable task let optimal plan v leaf variables
v cycle free let r ha ak numbering actions along r starts
simplify indexing later v succ r actions r divide v
subsequences v changing actions v v kv separated value changes
required r k actions iv preconditioned
value r two actions iv
preconditioned r
v
pre r pre r let r value sequence k r
v succ r v path v g v lv therefore added
r meaning finds solution r
v succ r let sv sv svk cost minimal path v g v
lv svi sequence actions changing value v preconditioned
r nothing odd r nothing even thus
cost sv sv svk

k
x


cost svi cost v

sequence obtained arbitrary merge sequences svi vsucc r
cheapest action changing value r k k
applicable sequence actions achieves goal values v succ r
well r
cost cost k k

k
x

cost



cost r

k
x


x

cost

cost v cost

vsucc r

hence solvable returns plan plan must
optimal finally solvable r necessarily remains empty thus
fails

theorem concerns tractability tasks fork structured causal graphs
roots binary domains earlier work reported additional tractability
fork structured causal graphs domains variables fixed
size though necessarily binary valued katz domshlak discuss
detail least far found helpful
context devising effective abstraction heuristics
theorem tractable inverted forks given task hv g costi
inverted fork causal graph sink r v r time complexity
cost optimal polynomial
proof let r observe inverted fork structure causal graph cg
implies actions unary effect sink r preconditions
actions affecting r hence follows assume g r specified otherwise


fiimplicit abstraction heuristics

given path ha r g r dtg r
hi
hg pred r
foreach v pred r xv v

foreach v pred r
pre ai v specified pre ai v xv
pre ai v reachable xv dtg v fail
append actions induced cost minimal path
pre ai v xv dtg v
xv pre ai v
append action ai
return
figure detailed outline step inverted fork structured
task

breaks set trivial single variable likewise
properties follows optimal plan path
r r g r induced dtg r cycle free contains zerocost cycles latter safely eliminated thus assume r
cycle free given simple finds cost optimal plan time
follows
create ar cycle free paths r g r dtg r
variable v pred r pair vs values x v compute
cost minimal path x dtg v whole set cost minimal paths
computed v applications floyd warshall
domain transition graphs sinks parents pred r
r g r path dtg r generated step construct plan
path r cheapest paths computed simple
construction depicted figure possible values parent variable
changed independently values variables inverted fork
take cheapest plan among constructed plan constructed
step unsolvable
already observed cost optimal plan r one r g r
paths generated step v pred r let sv denote sequence values
v required preconditions actions along r v pred r
v corresponding possibly cyclic path v g v dtg v traversing
values nodes sv order required sv turn plan generated
consists cost minimal paths v pred r therefore least one


fikatz domshlak

plans generated must cost optimal minimization step select
one

theorems clarify gap fork decompositions implicit abstraction
heuristics bridge gap abstracting task given fork
decomposition abstracting domains fork roots inverted fork
sinks meet requirements tractable fragments note idea
domain decomposition general hernadvolgyi holte
domain independent particular domshlak hoffmann sabharwal
fact shrinking step building merge shrink abstractions
precisely variable domain abstraction meta variables constructed merging
steps helmert et al
definition let hv g costi task states v v state
variable set mappings v sets
respectively hi
domain abstraction set
cost functions costi r
satisfying



x


costi cost




abstraction mapping states
u v


u
u
u

u v

u v

extending partial assignments v v v v
hv ai ii gi costi task
ii gi g
ai ai hi pre eff

action

costi ai costi



say domain decomposition hv g costi respect
theorem domain abstractions tasks additive implicit abstractions
tasks
proof let hv g costi task hi
domain
abstraction let l tr transition
graph let ti si li tri si transition graph
need abstraction mapping definition
first definition


fiimplicit abstraction heuristics

ii
g thus g gi providing us
si
state action pre state
pre ai pre thus ai applicable
applying ai jai k sjak
effect variables v v eff v eff ai eff ai jai k
eff ai eff sjak
variables v v eff sjak v v jai k v
v thus
jai k v v v sjak v sjak v
next eqs

x

costi ai




x


costi cost



let pair states cost let ha al
sequence
labels along cheapest path cost cost
pl
j
j cost decomposition path actions definition

cheapest path ti thus cost
pl neccesarily
j
j costi providing us

x


cost

x
l
x
j

costi aji

l x

x
j



costi aji

l
x

cost aj cost

j


put notion domain abstraction framework implicit abstractions
ready connect fork decompositions implicit abstraction heuristics given
abstraction afi hfv vf hiv vi vv task hv g costi
fv associate root v cg fv mappings fv fv fv kv
kv poly fv v abstract fv
f kv
afv hfv v

iv associate sink v cg iv mappings iv iv iv kv
kv poly iv v bv bv
k

v
abstract iv aiv hiv v




fikatz domshlak

theorem theorem composition theorem immediately


kv
kv


f

hfv v
afi
vf hiv v
vi

vv





additive implicit abstraction hence theorem


kv
kv
x x
x

hfi
hi
hf
vv

v





v



admissible estimate h theorems hfi computable
time poly
finalizes construction concrete family implicit abstraction heuristics
illustrate mixture acyclic causal graph domain abstractions
use running logistics example one bothersome question extent
abstracting fork decompositions domain abstractions affects informativeness
heuristic estimate though generally degradation unavoidable
answer question sometimes somewhat surprising
begin extreme setting let domain abstractions roots forks
sinks inverted forks binary valued domains among multiple options choosing mapping sets fv iv use simple choice distinguishing different values variable v basis cost v dtg v
specifically v v set fv iv value v
max v v

v
fv iv

otherwise
example fc decomposed see domain transition graph c
left figure c two fc fc binary abstract
domains c corresponding partitions b c b c
c respectively yet another example ip decomposed see
domain transition graph p figure six ip ip along
abstractions p depicted figure given decomposition
mappings fv iv vv consider ip obtained abstracting
along inverted fork p abstracting p

c
ip

b e f g c c c
hard verify original actions affecting p left ip
actions conditioned c c information lost remove
ip variables c well actions changing variables
information lost still keep fork inverted fork variable



fiimplicit abstraction heuristics



c



b

c



e

c

f

g

c




c



b

c





c

e

c

f

g



c

b

c



e

c

p fp



c

f



g

b

c



e

c

c

p fp

f

g

c

p fp

b
figure domain abstractions p binary valued domain abstractions values inside outside dashed contour mapped respectively
b ternary valued domain abstractions values mapped
abstract value shown nodes color borderline

redistribute cost removed actions representatives
originals latter revision action cost partition obtained directly
replacing cost partitioning steps corresponding eqs single joint
action cost partitioning applied final additive implicit abstraction afi eq
satisfying

kv
x x
cost

vv





x

costfv fv

f
g

kv
x

x


costiv iv




g
v

v

follows uniform action cost partition refer partition cost
action equally split among nonredundant representatives final additive
implicit abstraction
overall computing hfi eq binary valued domain abstractions

uniform action cost partition provides us hfi
knowing

original costs integers safely adjust h hence even
severe domain abstractions estimate hfi example task
lower h
let us slightly refine domain abstractions sinks inverted forks
ternary range mappings fv remain unchanged iv set


fikatz domshlak



v

v v v


v





example ip decomposed ip ip along abstractions
p depicted figure b applying computation hfi eq
set domain abstractions gives hfi safely
adjusted hfi note value higher hfi obtained
generally intractable pure fork decomposition abstractions eq first view
outcome may seem counterintuitive domain abstractions applied fork
decomposition one would expect coarser abstraction provide less precise estimates
however necessarily case employed action cost partition ad hoc
instance domain abstraction sink inverted fork may create independence
sink parent variables exploiting domain abstraction specific
independence relations leads targeted action cost partition via eq
see surprising estimate improvement obtained note
domain abstraction eq applied example truck moving actions
drive e drive e appear three abstractions ft ip ip
domain abstraction appear five abstractions ft ip ip ip
ip however closer look action sets five abstractions reveals
dependencies p cg ip cg ip p cg ip redundant
thus keeping representatives move e move e corresponding abstract
tasks entirely unnecessary hence two truck moving actions appear
two post domain abstraction tasks moreover abstractions truck moving
actions fully counted contrast predomain abstraction tasks portion
cost actions allocated ip simply gets lost

experimental evaluation take
evaluate practical attractiveness fork decomposition heuristics conducted empirical study wide sample domains international
competitions ipc plus non ipc schedule strips domain
domains selected allow comparative evaluation baseline
state art approaches planners supported pddl features
time evaluation
later formally prove ad hoc action cost partitions uniform
partition none three fork decompositions definition dominated
two hence implemented three additive fork decomposition heuristics hf
hi hfi within standard heuristic forward search framework fast downward
planner helmert full duplicate elimination hf
heuristic corresponds ensemble clearly redundant fork subgraphs
schedule strips appears domains distribution ipc later became aware
fact domain excluded competition encoding generated
planners



fiimplicit abstraction heuristics

domain



airport ipc
blocks ipc
depots ipc
driverlog ipc
freecell ipc
grid ipc
gripper ipc
logistics ipc
logistics ipc
miconic strips ipc
mprime ipc
mystery ipc
openstacks ipc
pathways ipc
pipes notank ipc
pipes tank ipc
psr small ipc
rovers ipc
satellite ipc
schedule strips
tpp ipc
trucks ipc
zenotravel ipc

























total



hf



















































hi



















































hfi


















































ms

ms









































































































hspf





















































gamer



















































blind



















































hmax



















































table summary experimental per domain denotes number
tasks solved planner per planner domain number tasks solved
planner given absolute number percentage
solved planners last row summarize number solved
instances

causal graph domains roots abstracted leave one value
binary valued domain decompositions follows


v fv


otherwise
hi heuristic inverted fork subgraphs domains
sinks abstracted distance goal value ternary valued domain decompositions eq


g v

v v g v



g v
ensemble hfi heuristic union hf hi action cost
partition three heuristics call uniform
make comparison two baseline approaches namely blind heuristic
value goal states otherwise hmax heuristic bonet geffner
well state art abstraction heuristics represented mergeand shrink abstractions helmert et al latter constructed
distance initial value reasonable evaluation initial state leave onevalue fork roots distance goal value inverted fork sinks typically much
attractive evaluation states examined



fikatz domshlak

linear f preserving abstraction strategy proposed authors two
fixed bounds size abstract state spaces notably
four baseline merge shrink heuristics implemented helmert et al
within system fork decomposition heuristics allowing
fairly unbiased comparison compare gamer edelkamp kissmann
hspf haslum planners winner runner sequential
optimization track ipc algorithmic side gamer bidirectional
blind search sophisticated symbolic search techniques hspf uses
additive critical path heuristic experiments conducted ghz intel e
cpu gb memory gb memory limit minute timeout
exception gamer used similar machines gb memory
gb memory limit done provide gamer environment
configured
table summarizes experimental terms number tasks solved
planner impression fork decomposition heuristics table somewhat
mixed one hand performance three fork decomposition planners
comparable one settings merge shrink heuristic clearly
testifies framework implicit abstractions theoretical interest
hand planners except merge shrink heuristic
failed outperform baseline hmax heuristic important
us unfortunately three fork decomposition planners failed outperform
even basic blind search
however end story fork decomposition heuristics
hope found detailed tables appendix appears
table e g logistics ipc domain hf almost consistently leads expanding
fewer search nodes better two merge shrink heuristics
domain ms difference hitting four orders magnitude however time
complexity hf per search node substantially higher ms
two expanding rate approximately nodes per second respectively
outcome simple time limits memory limit gb hf
solves tasks logistics ipc ms task solved hf
seconds standard time limit half hour used table
follows examine possibility exploiting informativeness fork decomposition
heuristics falling trap costly per node heuristic evaluation

back theory h partitions databased implicit abstraction
accuracy low time complexity desired yet competing properties heuristic
functions many powerful heuristics abstraction heuristics particular computing
h state isolation impractical computing h polynomial
description size often efficient enough performed search node
however costly heuristics obstacle largely overcome sharing
computation evaluations h different states possible
shared parts computing h states precomputed memorized
search reused search evaluations h different


fiimplicit abstraction heuristics

states mixed offline online heuristic computation henceforth called h partition
define time complexity h partition complexity computing h
set states given subset k states h partitions time
complexity computing h expressed x ky x
respectively complexity offline pre search online per node parts
computing h
days h partitions adopted optimal planners criticalpath heuristics hm haslum et al landmark heuristics hl hla karpas
domshlak pdb merge shrink abstraction heuristics edelkamp
helmert et al without effective h partitions optimal search
heuristics would scale well h partitions constitutes state
art cost optimal instance attractive property pdb abstractions
complexity natural h partition instead computing h h
scratch evaluated state impractical tiny projections practice
precompute store h abstract states per node
computation h boils hash table lookup h perfect hash
function terms time space complexity pdb h partition set
k states log k respectively precisely
makes pdb heuristics attractive practice respect picture mergeand shrink abstractions much similar order composites
formed choice abstract states contract crucial complexity
natural h partitions time space complexity concrete linear abstraction
strategy helmert et al respectively v log k v
similarly pdb abstractions per node computation h merge shrink
abstraction lookup data structure storing h abstract states
hence pre search computation ms abstractions
costly pdbs online part computing heuristic values still extremely
efficient per node efficiency provides merge shrink heuristics impressive
practical effectiveness numerous ipc domains helmert et al
sum say fixed size abstract spaces induced explicit abstractions pdbs merge shrink limitation key obtaining
effective h partitions contrast escaping limitation implicit abstractions might
trap us pay high price search node evaluation however time per node complexity bottleneck fork decomposition heuristics
successfully overcome specifically equivalent pdbs mergeand shrink notion database exists fork decomposition abstractions well despite
exponential size abstract spaces course unlike pdb merge shrink
abstractions databased fork decomposition heuristics cannot provide us
purely lookup online computation h online part h partition
nontrivial sense complexity cannot comes next
prove existence effective h partitions fork inverted fork abstractions
section empirically h partitions lead fast pre search
per node computations allowing informativeness fork decomposition heuristics
successfully exploited practice



fikatz domshlak

theorem let hv g costi task fork causal graph rooted
binary valued variable r exists h partition set k states
time space complexity h partition respectively v ar kd v
v maxv v
proof proof modification polynomial time computing
h state task used proof theorem tractable forks given
state let r r follows two roots
values r denotes opposite value r r dtg v dtg v
defined exactly proof theorem
two values r r root variable leaf variable v v r
pair values v let p r cost cheapest sequence
actions changing v provided r r whole set p r leaves
v v r computed straightforward variant pairs shortest paths
floyd warshall dtg v r time v
leaf variable v v r v let g cost
cheapest sequence actions changing v provided sequence r
value changes r values p r step set g
given solution recursive equation


ps v r







min g p r
odd


g


p r
min
g








even






g


v given

h

min

cost

r


x

gg v

vv r

p
cost cost cheapest action changing
value r
note step already state independent heavy step however
state dependence step mostly overcome follows v v r
v r r let g r cost cheapest sequence
actions changing g v provided value changes r induce sequence length
starting r set g r given solution recursive equation





p g v
r

g r p r

g r min



g

r




fiimplicit abstraction heuristics







r













































































cost

v

v v v

u

u u u u u




























































































































































b

figure database fork structured binary valued root variable r
two children v u g r g v g u depicts
domain transition graphs r top v middle u bottom numbers
edge precondition r cost respective
action b depicts database created instance entry
row r column v captures value gv r computed
eq shaded entries examined online computation
h r v u
solved time v note equation independent
evaluated state yet g r allow computing h given state via

h

min



cost

r r

x

gs v r



vv r

r r defined similarly r respect initial value r r
formulation computation performed online per
search node final minimization r r eq lightest
part whole anyway major computations notably p r
g r performed offline shared evaluated states
space required store information v contains fixed amount
information per pair values variable time complexity offline computation v ar ar component stems precomputing costs cost
time complexity online computation per state v v comes
internal summation comes size r r

figure b shows database created fork structured binary valued
root r two children v u g r g v g u domain transition


fikatz domshlak

graphs v u depicted figure online computation h eq
r v u sums shaded entries four rows
entries minimizes resulting four sums minimum obtained
row r
theorem let hv g costi task inverted fork causal graph
sink r r b exists h partition set
k states time space complexity h partition b v ar b v
k v ar b v ar b v respectively maxv v
proof proof theorem proof theorem modification
polynomial time computing h used proof theorem
tractable inverted forks
parent variable v v r pair values v let p
cost cheapest sequence actions changing whole set p
computed floyd warshall domain transition graph
v time v
given state cycle free path ha r g r dtg v
let g cost cheapest plan cheapest paths
p computed step g computed
g


x


cost ai


x
x

pprei v prei v

vv r

pre prem values required parents r along path
v v r


v




g v
g v specified
prei v


pre
v






pre
v

specified





pre v
otherwise

h min g
note step state independent step however dependence
step evaluated state substantially relaxed
different values r possible consider cycle free paths g r values r
path parent variable v v r know first value
v required would given precompute cost optimal plans induced
assuming parents start first required values remainder
computation h delegated online modified step follows
r r cycle free path ha r g r
dtg r let proxy state


v r
r
v g v
pre ai v unspecified


pre ai v argminj pre aj v specified


fiimplicit abstraction heuristics

nontrivial part captures first values v r required along given
let g cost cheapest plan cheapest
paths p computed g computed
g


x





cost ai



x

pprei v prei v

vv r

v v r


v




g v
g v specified
prei v


pre ai v pre ai v specified



pre v otherwise

storing pairs g accomplishes offline part computation given
search state compute

h

min


r r



g

x

ps v v



vv r

number cycle free paths g r dtg r ar b g
path computed time b v hence overall offline time complexity
b v ar b v space complexity including storage proxy states
v ar b v time complexity online computation per state via
eq v ar b v comes internal summation ar b upper
bound number cycle free paths r g r

figure b shows database created inverted fork structured
ternary valued sink variable r two parents u v g r g u g v
domain transition graphs u v depicted top figure actual
identities actions affecting two parents important actions affecting
sink r
h u r r
h v r r

h u r r

h v r r
domain transition graph r depicted bottom figure online computation h eq r v u sums shaded entries
four rows entries minimizes resulting four sums
minimum obtained lowest row


fikatz domshlak
























u

u











v

v





r



ha
ha
ha
ha
ha

ha





g

u

u u

v

u v
u v
u v
u v
u v
u v































v v














b

figure database inverted fork structured bounded sink
variable r two parents u v g r g u g v
depicts domain transition graphs u top left v top right r
bottom numbers edge preconditions
cost respective action respectively b depicts database created
shaded entries examined online computation
h r u v

experimental evaluation take ii
evaluate practical attractiveness databased fork decomposition heuristics
repeated empirical evaluation section databased versions
heuristics detailed evaluation relegated tables
appendix summarized table domain column
captures number tasks domain solved least one planner
suite per planner domain number tasks solved planner given
absolute number percentage solved planners
boldfaced indicate best performance within corresponding domain
last three rows summarize performance planners via three measures
first number tasks solved domains basically performance
evaluation measure used optimization track ipc domains equally
challenging equally discriminate planners performance second
domain normalized performance measure
p

x
domain

tasks solved planner p

tasks solved planners

finally third measure corresponds number domains w planner
question solved least many tasks planner
overall table clearly suggests heuristic search databased fork decomposition
heuristics favorably competes state art optimal particular
ease presentation omit case v required neither along goal
variables simply ignored accounting cost



fiimplicit abstraction heuristics

domain



airport ipc
blocks ipc
depots ipc
driverlog ipc
freecell ipc
grid ipc
gripper ipc
logistics ipc
logistics ipc
miconic strips ipc
mprime ipc
mystery ipc
openstacks ipc
pathways ipc
pipes notank ipc
pipes tank ipc
psr small ipc
rovers ipc
satellite ipc
schedule strips
tpp ipc
trucks ipc
zenotravel ipc

























total

w



hf






















































hi






















































hfi






















































ms

ms













































































































hspf























































gamer






















































blind






















































hmax






















































table summary experimental databased versions forkdecomposition heuristics per domain denotes number tasks solved
planner per planner domain number tasks solved planner
given absolute number percentage solved
planners boldfaced indicate best performance within
corresponding domain last three rows summarize number solved instances domain normalized measure solved instances number
domains planners achieved superior performance w

forks heuristic hf exhibited best overall performance according
three measures terms absolute number solved instances three
fork decomposition heuristics outperformed planners suite contribution
databasing success fork decomposition heuristics dramatic looking
back fully online heuristic computation depicted table note
total number solved instances fork decomposition heuristics hf hi hfi
increased respectively made whole difference
performed comparative evaluation domains
recent ipc ipc domains differ previous domains actions
costs importantly many actions zero cost latter
issue heuristic search planners heuristic functions cannot differentiate
subplans cost zero differ length case comparative
side evaluation ipc domains differ several points previous
one first neither merge shrink hmax heuristics implementation
supporting arbitrary action costs hence comparison gamer hspf
blind search second ensure admissibility blind search latter
modified return non goal states cost cheapest applicable action finally
planners run ghz intel e cpu gb memory gb memory


fikatz domshlak

domain



elevators strips ipc
openstacks strips ipc
parcprinter strips ipc
pegsol strips ipc
scanalyzer strips ipc
sokoban strips ipc
transport strips ipc
woodworking strips ipc










total

w



hf
























hi
























hfi
























hspf

























gamer
























blind
























table summary experimental per domain denotes number
tasks solved planner per planner domain number tasks solved
planner given absolute number percentage
solved planners boldfaced indicate best performance
within corresponding domain last three rows summarize number
solved instances domain normalized measure solved instances
number domains planners achieved superior performance w

limit minute timeout evaluation summarized table
detailed refer reader tables appendix overall
fork decomposition heuristics much competitive
ipc domains well

formal analysis asymptotic performance ratios
empirical evaluation concrete set benchmark tasks standard important
methodology assessing effectiveness heuristic estimates allows us study
tradeoff accuracy heuristics complexity computing
however rightfully noted helmert mattmuller evaluations almost
never lead absolute statements type heuristic h well suited solving benchmark suite x relative statements type heuristic h
expands fewer nodes heuristic h benchmark suite x moreover one would probably obtain formal evidence effectiveness heuristic proceeding
implementation especially complicated heuristic procedures underlying proofs theorems formal analysis effectiveness
fork decomposition heuristics methodology suggested exploited helmert
mattmuller motivated primarily desire formal evidence
given domain heuristic h helmert mattmuller consider
asymptotic performance ratio h goal value h

states h h h h
family n nn solvable non goal states sn nn
sn n limn h sn h sn h h sn h sn


fiimplicit abstraction heuristics

domain

h

hk

hpdb

hpdb
add

hf

hi

hfi

gripper
logistics
blocksworld
miconic strips
satellite











































table performance ratios multiple heuristics selected domains ratios
h hk hpdb hpdb
add helmert mattmuller

words h never worse domain h plus sublinear term
become bad h h plus sublinear term arbitrarily large inputs note
existence uniqueness h guaranteed h
helmert mattmuller study asymptotic performance ratio standard admissible heuristics set well known benchmark domains first four
ipcs gripper logistics blocksworld miconic satellite
shown first four columns table
h estimate corresponds optimal cost solving well known delete
relaxation original task generally np hard compute bylander
hk k n family heuristics relaxation cost
achieving partial assignment approximated highest cost achieving
sub assignment size k haslum geffner computing hk exponential
k
hpdb hpdb
add heuristics regular maximized additive pattern
database heuristics size pattern assumed log n
n v importantly choice patterns assumed optimal
provide us baseline evaluating fork decomposition heuristics
hi hfi first however theorem shows three heuristics worth
analyzing alone strictly informative two depending
task state evaluated
hf

theorem undominance uniform action cost partition none heuristic
functions hf hi hfi dominates another
proof proof example two tasks illustrate following
two cases hf hfi hi hf hfi hi two tasks
defined set binary valued variables v v v v u u u
initial state v v v u u u goal
theorem formulated proven uniform action cost partition use throughout
including experiments per step optimal action cost partitions katz domshlak
trivial hfi dominates hf hi tasks



fikatz domshlak



u

u

u

v

v

v











h v u u u v
h v u u u v
h v u u u v
h u u
h u u
h u u
h u u
h u u
h u u




f





































c

u

u

u

v v v

v v v

v v v

guf

guf

guf

u u u

u u u

u u u

v

v

v

gvi

gvi

gvi















b

h v u v
h v u v
h v u v
h v u v
h v u v
h v u v
h v u v
h v u v
h v u v
h u u
h u u
h u u


f
















































figure illustrations proof theorem causal graphs b fork
inverted fork subgraphs causal graph
action sets c well costs action representatives
abstract along subgraphs considering example
first row table c action single representative
three fork abstractions well representative inverted fork abstraction
g hence cost representatives f decomposition
v

cost sole representative decomposition

g v v v difference action sets listed
figure c actions unit cost actions two tasks induce identical
causal graphs depicted figure hence collections v forks v iforks
tasks identical depicted figure b fractional costs tasks
action representatives corresponding abstract given figure c
figure shows optimal plans abstract f decompositions f
g f g f g f f g f g f g f decompositions g g g
u

u

u

u

u

u

v

v

v

g g g decompositions f f
v

v

v

last column tables captures estimates three heuristics initial
states respectively together two cases none forkdecomposition heuristic functions hf hi hfi dominates since


fiimplicit abstraction heuristics

h
hf

hi

h



task
g f
u
g f
u
g f
u
g
v
g
v
g
v
g f
u
g f
u
g f
u
g
v
g
v
g
v

optimal plan

cost

ha



ha



ha



ha



ha



ha



ha



ha



ha



ha



ha



ha



h

h
hf



hi





h





task

optimal plan

g f
u
g f
u
g f
u
g
v
g
v
g
v
g f
u
g f
u
g f
u
g
v
g
v
g
v

ha



ha



ha

cost

h




ha



ha



ha



ha



ha



ha



ha



ha



ha











b

figure illustrations proof theorem optimal plans abstract hf hfi hi b
hf hfi hi

variables binary valued claim holds conjunction arbitrary variable
domain abstractions

one conclusion theorem worth studying asymptotic performance
ratios three heuristics last three columns table present
hf hi hfi gripper logistics blocksworld miconic satellite
domains studied performance ratios max hf hi hfi five
domains appear identical hf note ratio max
necessarily identical max ratios thus analysis worthwhile taking
conservative position performance ratios fork decomposition heuristics
table worst case sense
neither optimize action cost partition setting uniform rest
eliminate clearly redundant abstractions
ii use domain abstractions ternary valued abstract domains
domains fork roots abstracted leave one binary valued
domain decompositions eq domains inverted fork sinks
abstracted distance initial value ternary valued domain decompositions
eq
overall fork decomposition heuristics table gratifying first
note performance ratios hk hpdb every subgoal
set size k hk size log n hpdb reached number steps
depends k respectively log n n h sn grows linearly n
five domains leaves us hpdb
add state art tractable


fikatz domshlak

admissible heuristic compare table shows asymptotic performance
f
ratio hf heuristic least good hpdb
add five domains h

pdb
superior hpdb
add miconic getting quite close h comparing hadd
fork decomposition heuristics crucial recall ratios devised helmert
mattmuller hpdb
add respect optimal manually selected set patterns
contrast selection variable subsets fork decomposition heuristics completely
nonparametric thus requires tuning abstraction selection process
rest section prove asymptotic performance ratios hf hi

h table five domains begin brief outline
obtained familiarity domains assumed next domain addressed
detail provide informal domain description well sas representation
prove lower upper bounds ratios three heuristics
gripper assuming n balls moved one room another three
heuristics hf hi hfi account required pickup drop actions
portion move actions however former actions responsible
optimal plan length cost basic uniform action cost partition
hf hi hfi account whole n total pickup drop
actions cost respectively providing ratios table
logistics optimal plan contains least many load unload actions move actions
three heuristics hf hi hfi fully account former providing lower bound
instance three heuristics achieve exactly consists two
trucks airplanes one city n packages initial goal
locations packages trucks pair wise different
blocksworld arguments similar helmert mattmuller hpdb
add
miconic three heuristics fully account loads unload actions addition hf
accounts full cost move actions passengers initial locations
half cost move actions provides us lower
bounds respectively tightness hi hfi shown
task consisting n passengers n floors initial goal locations
pair wise different tightness hf shown task consisting n
passengers n floors elevator passengers initially floor n
passenger wishes get floor
satellite length optimal plan n images taken k
satellites moved end positions n k three heuristics fully
account image taking actions one satellite moving action per satellite
providing lower bound tightness three heuristics
shown task follows two satellites instruments li l
l

respectively l n n pair instruments l take images
modes mi set directions dj nj set image objectives
note slight modification uniform action cost partition ratio
three heuristics optimizations however outside scope



fiimplicit abstraction heuristics

right

lef

robot

right
b

b



bn


f
gright

lef
bn



b

right

robot
bn

b

f
glef






robot

bn

f
grobot

lef

b
gbi b balls

b

figure grippers causal graph b corresponding collection v forks
v iforks

oi ni l oi mi l n oi di
finally calibration direction pair instruments l di
gripper
domain consists one robot robot two arms arms right lef two rooms
rooms r r set balls n balls robot pick ball arm
arm arms arm empty release ball b balls arm arm arm currently
holds b move one room another balls robot initially room
r arms empty goal move balls room r natural
description task sas follows


variables v robot arms balls domains
robot rooms

lef right balls empty

b balls b rooms robot

initial state b r b balls robot r right empty lef empty
goal g b r b balls
actions
ove r r r r rooms



p ickup b arm r drop b arm r b balls arm arms r rooms

move robot ove r r h robot r robot r

pickup ball
p ickup b arm r h b r arm empty robot r b robot arm b

drop ball drop b arm r h b robot arm b robot r b r arm empty

parametric n causal graph task depicted figure


fikatz domshlak

frobot

action


ove r r
p ickup b arm r
drop b arm r

farm empty









farm b

farm b









farm




ib




ib




f








n

n

n


n

n

n


n

n

table number representatives original gripper action abstract task
well partition action costs representatives
frobot

fright empty
fright b
fright b
flef
ib
ib

p ickup b right r h robot r b r b robot
p ickup b right r h right empty right b
p ickup b right r h right b b r b robot
p ickup b right r h right empty right b
p ickup b right r h right b b r b robot
p ickup b right r h right b b r b robot
p ickup b right r h right b b r b robot
p ickup b right r h right empty right b
p ickup b right r h right b robot r b r b robot
p ickup b right r h right empty right b

table sets representatives original action p ickup b right r abstract
tasks

fork decomposition
since variables robot right lef goal value collection v forks
v iforks figure b domains inverted fork sinks ternary valued
domains fork roots abstracted eq leave one thus
f frobot fright flef empty balls
ib b balls

frobot fright flef empty balls ib b balls
original action number representatives abstract task well
cost assigned representative listed table table illustrates derivation numbers via decomposition example action p ickup b right r
fork decomposition abstractions action one nonredundant representative
frobot two representatives fright empty fright b one representative
fright b b balls b one representative flef balls empty
two representatives ib one representative ib b balls b


cost n
representative f n
representative

n representative
given optimal plans abstract tasks follows


fiimplicit abstraction heuristics

h

task
frobot

hf

fright
flef

hi

ib
frobot

hfi

fright
flef
ib

optimal plan
hp ickup b right r p ickup bn right r
ove r r drop b right r drop bn right r
hp ickup b lef r p ickup bn lef r
drop b lef r drop bn lef r
hp ickup b right r p ickup bn right r
drop b right r drop bn right r
hp ickup b right r p ickup b right r ove r r drop b lef r
hp ickup b right r p ickup bn right r ove r r
drop b right r drop bn right r
hp ickup b lef r p ickup bn lef r
drop b lef r drop bn lef r
hp ickup b right r p ickup bn right r
drop b right r drop bn right r
hp ickup b right r p ickup b right r ove r r drop b lef r

cost



n
n



n
n

n

n
n

n



n
n

n
n
n

n

n
n

n

n
n

n


n


n

h

n n
n

n
n


n


n
n

n

assuming n balls moved one room another cost optimal
plan original task n n even n n odd therefore
asymptotic performance ratios heuristics hf hi hfi gripper
respectively
logistics
logistics task consists k cities x airplanes trucks n packages
city associated set li li lii locations within city union

locations cities denoted l ki li addition precisely one location
city airport set airports la l lk l truck
move within city located airplanes fly airports
airplanes denoted u u ux trucks ty
packages p p pn let ti li denote trucks city
p p p p p p denote partition packages follows
package p p p p g p la initially airport
needs moved another airport
package p p p p la li g p lj la j initially
airport needs moved non airport location another city
package p p p p li g p li needs moved within one
city
package p p p p li la g p la li needs moved
non airport location one city airport city
package p p p p li la g p lj la j needs moved
non airport location one city non airport location another city
natural logistics task description sas follows
variables v u p domains
u u u la

k ti li

p p p l u


fikatz domshlak

u ux



ty

u
p

p

pi pn


u ux


pn

guf u u

p

pn

gtf
b

ty
p

gpi p p

figure logisticss causal graph b corresponding collection v forks
v iforks

initial state la x l lk l n
goal g p l pn ln l n
actions


k


lli tti




lla uu


lt p l u p l p p l l l li l


la p u l u p u l p p u l l l la l


load package p onto truck location l lt p l h p l l p
unload package p truck location l u p l h p l p l
move truck location l location l l l h l l
load package p onto airplane u l la p u l h p l u l p u
unload package p airplane u l u p u l h p u u l p l
move airplane u location l l u l l h u l u l
parametrized n x causal graph logistics tasks depicted figure
fork decomposition
since variables u u goal value collection v forks viforks figure b domains inverted fork sinks abstracted
eq distance initial value domains fork roots abstracted


fiimplicit abstraction heuristics

fu l fu l fu l fu l ft l ft l ft l ft l ip f

action


l l
u l l



































ni ni


ni ni


p la li
p li la
p p p p p p p p p p
p p
fu l ft l ip ip ip ip ip ip ip ip ip ip ip f

action
l li
l lj
la p u l u p u l

lt p l u p l






















































nf

nf

nf






nf

nf

nf

b
figure number representatives original logistics action abstract
task well partition action costs representatives
tables b capture move load unload actions respectively

eq leave one thus
f


uu lla





fu l





k

tti lli

ip
ip
pp
pp p p

uu lla

fu l



ft l


pp

k

tti lli

ip

ft l


pp

ip



ip

pp p p


pp

ip

p
total number forks nf f u la ki ti li total number
inverted forks ni p p p p p action
number representatives abstract task well cost assigned
representative given figure row tables figure
corresponds certain logistics action column except last three represents
abstract task entry captures number representatives action
corresponding task last three columns portion total cost
given action representative task three heuristics question
lower bound
note optimal plan logistics task contains least many load unload
actions move actions thus following lemma provides us lower bound
three heuristics question



fikatz domshlak

lemma logistics task hf hi hfi account full cost load unload
actions required optimal plan task
proof logistics task optimal plans task contain amount
load unload actions package p p follows

p p

actions one load onto airplane one unload airplane

p p actions one load onto airplane one unload airplane one load
onto truck one unload truck
p p

actions one load onto truck one unload truck

p p actions one load onto truck one unload truck one load onto
airplane one unload airplane
p p actions two loads onto trucks two unloads trucks one load
onto airplane one unload airplane
consider fork decomposition f optimal plan abstract tasks
contain number load unload actions exactly effects actions
remain unchanged tasks cost representative load unload
action n f nf abstract tasks therefore heuristic hf fully accounts
cost required load unload actions
consider fork decomposition domain decomposition
index abstraction optimal plan abstract task ip include one load
one unload actions follows
p p

one load onto airplane one unload airplane

p p

one load onto airplane one unload airplane

p p

one load onto truck one unload truck

p p

one load onto truck one unload truck

p p

one load onto truck one unload truck

p p

one load onto airplane one unload airplane

p p

one load onto truck one unload truck

p p

one load onto airplane one unload airplane

p p

one load onto truck one unload truck

cost representative load unload actions thus heuristic hi fully
accounts cost required load unload actions
finally consider fork decomposition optimal plan forkstructured abstract tasks contain number load unload actions f
cost representative load unload actions nf nf abstract
tasks addition load unload actions appear exactly one inverted
fork structured abstract task therefore heuristic hfi fully accounts cost
required load unload actions



fiimplicit abstraction heuristics


p





pn

p

gtf







pn

p
gpi p p

gtf

figure collection v forks v iforks logistics task used proof
upper bound

upper bound
instance three heuristics achieve exactly consists two trucks
airplanes one city n packages initial goal locations packages
pairwise different trucks initially located yet another location

formally l li n
sas encoding logistics task
follows
variables v p pn domains
l

p p p l
initial state l l p l pn ln
goal g p ln pn l n
actions lt p l u p l l l p p l l l l
l
collection v forks v iforks task depicted figure domains
inverted fork sinks abstracted eq distance initial value
domains fork roots abstracted eq leave one therefore

f ft l ft l l l
ip p p

ft l ft l l l ip p p
total number forks thus nf n total number inverted forks
ni n partition action costs logistics tasks described figure
p p thus action cost partition follows
ft l

action


l l
lt p l
u p l





ft l




ft l




ft l






ip




ip

f












n

n


n


n

n

n




fikatz domshlak

given optimal plans abstract task
h

task

hf

ft l
ft l
ipi
ft l
ft l
ipi

hi
hfi

optimal plan
hlt p l lt pn ln u p ln u pn l n
hlt p l lt pn ln u p ln u pn l n
hm l li lt pi li li ln u pi ln
hlt p l lt pn ln u p ln u pn l n
hlt p l lt pn ln u p ln u pn l n
hm l li lt pi li li ln u pi ln

cost



n
n
n
n


n
n
n
n
n

n
n
n
n
n
n


n




n

h
n
n
n

n
n

optimal plan original task e g hm l l lt p l l l lt p l
l l lt pn ln ln ln u p ln ln ln u p ln
ln ln u pn l n

cost n providing us upper bound
three heuristics putting lower upper bounds together asymptotic
ratio three heuristics question
blocksworld
blocksworld task consists table table crane c n blocks b
b bn block table top block
held crane crane pick block currently holds nothing
block block top crane drop held block table
top block
consider blocksworld task follows blocks initially form tower
b bn bn bn table goal move form
tower b bn bn bn bn table goal swap
lowest two blocks tower natural description task sas follows
variables v b clearb b b c domains
c empty b

b b b table c b b
clearb yes

initial state
c empty bn table clearb yes

bi bi n



clearb b b b
goal g bn table bn bn bn bn bi bi n
actions pt b dt b b b p b b b b b b b
pick block b table pt b h c empty b table clearb yes cb b c
pick block b block b
p b b h c empty b b clearb yes clearb c b b c clearb yes


fiimplicit abstraction heuristics

c

clearb clearbn

c
b
gbi b bn bn bn

clearb

clearb

c
b

b

bn

bn

clearb
bn

bn

gcf


bn

bn

f
gclear
b b
b

b

figure causal graph b corresponding collection v forks v iforks
blocksworld task used proof

drop block b table dt b h c b b c c empty b table
drop block b block b
b b h c b b c clearb yes c empty b b clearb

schematic version causal graph task depicted figure since
variables bn bn bn goal values different values initial
state collection v forks v iforks figure b leave one
eq domain abstraction variable c c fork gcf breaks n abstract
tasks sinks v iforks gbi n gbi n gbi n go process domain
decomposition distance initial value eq however due structure
domain transition graphs block variables domain decomposition
single abstract task v iforks thus
f fc empty fc b b b fclearb b b
ibn ibn ibn

fc empty fc b b b fclearb b b ibn ibn ibn
technically straightforward verify abstract task f
exists plan involves representatives actions
p bn bn dt bn p bn bn dt bn pt bn bn bn pt bn bn bn

ii involves representative original action even together
plans account total cost eight actions eq total cost
plans thus estimates three heuristics upper bounded
optimal plan original task e g hp b b dt b p b b dt b p bn bn dt bn
pt bn bn bn pt bn bn bn pt bn bn bn pt b b b cost


fikatz domshlak

e

p



e
p

pn

gef



e
pn

b

p
gpi p p

figure miconics causal graph b corresponding collection v forks
v iforks

n hence asymptotic performance ratio three heuristics blocksworld
domain
miconic
miconic task consists one elevator e set floors f passengers p
elevator move f floors floor load unload passengers
natural sas description miconic task follows
variables v e p domains
e f

p p p f e
initial state e fe p fp p p f p
goal g p fp p p f p
actions p f p f f f p p ove f f f f f
load passenger p e floor f p f h e f p f p e
unload passenger p e floor f p f h e f p e p f
move elevator floor f floor f ove f f h e f e f
parametrized n causal graph miconic tasks depicted figure
figure b depicts corresponding collection v forks v iforks domains
inverted fork sinks abstracted eq distance initial value
domains fork roots abstracted eq leave one thus
f fe f f f
ip p p

fe f f f ip p p
total number fork structured abstract tasks thus nf f f
total number inverted fork structured abstract tasks ni p
action number representatives abstract task well cost
assigned representative given table


fiimplicit abstraction heuristics

action
ove f f
p f
p f
p f
p f

fe f fe f fe f ip ip f

































nf

nf

nf

nf



ni ni
nf
nf
nf
nf

table number representatives original miconic action abstract task
well partition action costs among representatives

lower bounds
first miconic special case logistics domain lemma applies analogously package p corresponding passenger thus p p
three heuristics account full cost load unload actions required optimal
plan task
let us focus abstract tasks f fe f f f recall task fe f
induced e fork terms domain decomposition distinguishes
floor f somewhere else without loss generality set floors f
restricted initial goal values variables optimal
plan move elevator floor f neither initial goal location
passenger elevator let p p p fg g p p p costs
optimal plans abstract task fe f follows
f fg let p p p pair passengers initial goal locations f
respectively p g p f f e plan fe f move
elevator f order load passenger p move elevator back
f order unload passenger p therefore cost plan fe f

least p
f see last three columns table first component
summation comes summing costs representatives load unload
actions passengers second component sum costs
representatives two respective move actions similarly f e
plan fe f move elevator f order load passenger p
move elevator f order unload p therefore well cost

plan fe f least p
f

f fg let p p passenger initially f p f f e
plan fe f move elevator f order unload p thus
cost plan fe f least

p
f

otherwise f e plan

fe f move elevator f order load p move elevator
f order unload p hence case cost plan fe f
least

p
f




fikatz domshlak

f fg let p p passenger must arrive floor f g p f
f e plan fe f move elevator f order load p
move elevator back f order unload p hence well

cost plan fe f least p
f otherwise f e plan

fe f move elevator f order unload p thus cost plan

fe f least

p
f



f fg f e plan fe f include move f order



load unload passengers thus cost plan fe f least p
f
otherwise f e elevator initially set locations

thus cost plan fe f least p
f

putting case case analysis together

fg


e fg
p fg fg



p f f f f fg e f f

g

g

g



hf
fg

p


f

f


f

f





e

f

f

g

g
g





p f f f f fg
e fg

g

g



note value second case lowest gives us lower bound hf
estimate eq
fg

fg



let us provide upper bound length cost optimal plan
miconic task first let p p denote set passengers initial goal
locations fg let p fg denote length optimal traversal
floors fg passenger p p visit p comes visit
g p given case case basis necessarily optimal plan miconic
task hand follows
hf p fg

e fg collect passengers e traverse floors
fg collect passengers floors move elevator first
floor f optimal path traversing floors fg drop passengers
whose destination f collect passengers keep moving along
collecting dropping passengers initial target floors
traverse fg dropping remaining passengers destinations
cost plan thus optimal plan upper bounded eq

h p fg p fg fg

e fg collect passengers e traverse floors
fg collect passengers floors making sure traversal
ends first floor f optimal path traversing floors fg
follow collecting dropping passengers initial target floors
traverse fg dropping remaining passengers destinations
first case cost plan upper bounded eq


fiimplicit abstraction heuristics

e traverse floors fg collect passengers floors
move along optimal path traversing floors fg collecting
dropping passengers initial target floors traverse floors
fg dropping remaining passengers destinations well
cost plan upper bounded expression eq
lemma miconic task passengers p

hf
h



p
p

proof recall p p set passengers initial goal locations
fg first give two upper bounds length optimal traversal
floors fg passenger p p visit p comes visit
g p theorem helmert
p fg fg g



g size minimum feedback vertex set directed graph g
v e v fg e containing arc f f passenger
p p initially floor f arrive floor f
note g trivially bounded number graph nodes v addition
observe order nodes v arcs e partitioned forward

backward arcs one subsets must contain e arcs removing
g nodes origins arcs smaller subset e
directed acyclic graph hence set removed nodes necessarily minimum

feedback vertex set g size set larger e putting two
bounds g together eq obtain


p

p fg min fg fg



disjointness fg fg fact goal
passengers p fg p p eqs
p fg fg fg
hf


h
p fg fg p fg



f

interested lower bound ratio hh right hand side
inequality minimized thus safely set fg fg
p p obtaining



p p p
fg
hf
p p fg




h
p p p p fg
p p p fg



let us examine right expression eq respect two upper bounds
p fg eq

minimum obtained fg p fg fg

fg p last inequality reformulated
fg p


fikatz domshlak

allows us provide lower bound right expression eq
f
thus hh
hf
p p fg
p fg p
p




h
p p p fg
p fg p
p





minimum obtained fg p p fg fg p
fg last inequality reformulated
fg p
allows us provide lower bound

hf
h

via eq

p p fg
p fg p
p
hf








h
p p p fg
p fg p
p

note lower bounds
lemma

hf
h

eq eq required claim


upper bounds
miconic task heuristic hf achieves performance ratio exactly
consists elevator e floors f ni passengers p pi ni passengers
elevator initially f target floors passengers pairwise
disjoint sas encoding miconic task follows
variables v e p domains e f p p p f e
initial state e f p f pn f
goal g p f pn fn
actions p f p f f f p p ove f f f f f
causal graph task corresponding collection v forks consisting
one e fork depicted figure domain e abstracted eq
leave one providing us
f fe f fe f fe fn
costs action representatives abstract tasks given table
nf n optimal plans abstract tasks f
task optimal plan
fe f
fe f
fe fn

cost

hin p f pn f ove f f p f pn fn
hin p f pn f p f pn fn ove f f p f
hin p f pn f p f pn fn ove f fn pn fn














n
n
n
n
n
n



hf

n

n


fiimplicit abstraction heuristics

optimal plan original task hin p f pn f ove f f p f
cost n providing us
f
upper bound h heuristic miconic putting upper bound together
previously obtained lower bound conclude asymptotic performance
ratio hf miconic
miconic task heuristics hi hfi achieve exactly consists
n
elevator e floors f n
passengers p pi initial target floors
passengers elevator pairwise disjoint task description sas
follows
ove f f p f ove f f pn fn

variables v e p domains e f p p p f e
initial state e f p f pn fn
goal g p fn pn f n
actions p f p f f f p p ove f f f f f
causal graph task corresponding collection v forks v iforks
depicted figure domains inverted fork sinks abstracted eq
distance initial value domains fork roots abstracted
eq leave one provides us
ip ipn

fe f fe f fe fn fe fn fe f n ip ipn
costs action representatives abstract tasks given table
nf n ni n optimal plans abstract tasks
h

task

optimal plan

hi

ipi
fe f

hm ove f pi ove fn pi fn
hm ove f f p f pn fn
p fn pn f n
hm ove f f p f ove f f p f pn fn
p fn pn f n
hm ove f fn pn fn ove fn f
p f pn fn p fn pn f n
hin p f pn fn p fn pn f n
ove f fn p fn
hin p f pn fn p fn pn f n
ove f f n pn f n
hm ove f pi ove fn pi fn

hfi

fe f
fe fn
fe f

n

fe f n
ipi

cost



h

n


n


n


n
n


n



n
n

n


n



n
n


n



n
n


n



n
n


n




n


n

n

n
n

n

n

optimal plan original task hm ove f f p f ove f f p f
ove f f pn fn ove fn fn p fn ove fn fn p fn
ove fn fn pn f n cost n providing us upper bound
hi hfi heuristics miconic putting upper bound together
previously obtained lower bound conclude asymptotic performance ratio
hi hfi miconic



fikatz domshlak

satellite
satellite domain quite complex satellite tasks
consists satellites
finite set instruments onboard ss set image
modes mode set im instruments supporting
mode likewise set directions l image objectives lm functions
cal l p l p l cal calibration target
direction function p initial direction function p goal pointing direction
function
let us denote oi sm im subset images
taken instrument os iis oi subset images taken
instruments satellite sm im subset satellites
take images mode description sas follows
variables v oni ci domains
l

oni ci


initial state p oni ci
goal g p
actions



urn l swon cal swof f
ss

akeim sm im

turn satellite urn h

power instrument swon h oni oni
power instrument swof f h oni oni ci

calibrate instrument cal h ci oni cal ci
take image akeim h ci

fork decomposition
causal graph example satellite task representative subset collection
v forks v iforks depicted figure since variables oni ci
goal value collection v forks v iforks follows general
case
satellite fork leaves os


fiimplicit abstraction heuristics











c





c

c

c









c

c



c



c


gsf




c


f
gc



c

c


f
gc

c


f
gc


c









goi
b

figure satellite example task causal graph b representative subset
collection v forks v iforks

instrument ci fork leaves oi
image objective ifork parents ci im sm
root domains forks rooted instruments inverted fork sinks
binary first place root domains forks rooted satellites
abstracted eq leave one provides us
f fs l fci
io

fs l fci io
total number forks thus nf l total number inverted
forks ni action number representatives abstract
task well cost assigned representative given figure
lower bounds
first note optimal plan satellite task contains actions per image
objective one action per satellite g
three heuristics fully account cost least one action per image
objective one action per satellite provide us lower
bound asymptotic performance ratios three heuristics
lemma satellite task hf hi hfi fully account cost least
one take image action akeim image objective
proof image objective actions akeim h
ci appear optimal plans sm l fork abstract tasks rooted


fikatz domshlak

fs

action


urn
swon
cal
swof f






fs





fs

fs











fci





fci





oi os oi os
io
io
io
f


































oi

oi


oi

oi



action
akeim


sm sm im im
fs
fs
fci
fci
io io












f






sm l im




sm l im

b
figure number representatives original satellite action abstract
task well partition action costs representatives
table shows turn switch switch calibrate actions
table b shows take image actions

satellites im fork abstract tasks rooted instrument calibration status variables ci
one inverted fork abstract task sink together costs action
representatives abstract see figure
hf cost representative
tasks


sm l im

sm l im fork abstract

hi cost representative one inverted fork abstract task
hfi cost representative
tasks


sm l im

sm l im abstract

therefore cost one akeim action fully accounted
three heuristics

lemma satellite task hf hi hfi fully account cost least
one turn action urn g
proof satellite g action urn appear
optimal plan fs action urn g appear optimal plan
fs g os action urn g appear optimal plan
io together costs action representatives abstract see
figure
hf cost representative




fork abstract tasks


fiimplicit abstraction heuristics

hi cost representative
hfi cost representative


os

os inverted fork abstract tasks


os

os abstract tasks

therefore g cost one urn action
fully accounted three heuristics

h
h

together lemmas imply h hf hi hfi satellite


upper bound
satellite task three heuristics achieve ratio exactly consists
two identical satellites l instruments l l
l instruments l two modes mi set
n directions l di dn set n image objectives oi
di mi l oi di l n calibration direction
instruments l di sas encoding task follows
variables v oni ci
initial state di oni ci
goal g
actions



urn l swon cal swof f
ss



ss

akeim di mi di

n



akeim dj dj

j l

causal graph task depicted figure state variables oni ci
goal value thus collection v forks v iforks task
figure b domains inverted fork sinks binary domains
fork roots abstracted eq leave one provides us
f fs fs l fci
io

fs fs l fci io
total number forks task nf n l total number inverted
forks ni n costs action representatives abstract task given

figure os os n oi n l sm im l imi
l n
optimal plans per abstract task depicted table optimal plan
original hswon urn di cal urn di akeim di


fikatz domshlak






c

ok

oi

cl

cl

ci

ol









gsf

gsf

cl

c l


oni



ci





ci

oi

ol
f
gc





cl



c c l

onl

onl

onl

l

oi

oi

goi l

goi l n



b

figure causal graph b corresponding collection v forks v iforks
satellite task used proof upper bound

h

hf

hi

hfi

task

optimal plan

cost

ht akeim di l akeim ol di l
fs
akeim ol dl l akeim dn l
ht akeim di akeim ol di l
f

akeim ol dl l akeim dn l
ht akeim oi di l
f
ci
akeim ol dl l akeim dn l
ht akeim oi di
fci
akeim ol dl l akeim dn l
ioj j l ht urn di dj cal j urn dj di akeim oj di j
ioj l j n ht urn di cal urn dj akeim oj di
ht akeim di l akeim ol di l
fs
akeim ol dl l akeim dn l
ht akeim di akeim ol di l
f

akeim ol dl l akeim dn l
ht akeim oi di l
f
ci
akeim ol dl l akeim dn l
ht akeim oi di
fci
akeim ol dl l akeim dn l
ioj j l ht urn di dj cal j urn dj di akeim oj di j
ioj l j n ht urn di cal urn dj akeim oj di



l
n



nl
n l

n

l
n



nl
n l

n


n



nl
n l

l

nl

n l
n


nl

n




n
nl

l
l
nl

h

n

l
n



nl
n l

n

l
n



nl
n l

n


n



nl
n l

l

nl

n l
n


nl
n

n


nl

n

n l

l

n
n
nl

n

l

n
n



n
nl

nl

table optimal plans abstract tasks overall heuristic estimates
satellite task used proof upper bound

swof f swon l urn di dl cal l urn dl di akeim ol di l
swof f l swon l urn di dl cal l urn dl di akeim ol di l urn di dl
akeim ol dl l urn dn dn akeim dn l



cost l n

fiimplicit abstraction heuristics


l n n provides us asymptotic performance ratio three
heuristics

summary
considered heuristic search cost optimal introduced domain independent
framework devising admissible heuristics additive implicit abstractions
implicit abstraction corresponds abstracting task hand instance
tractable fragment optimal key motivation investigation escape restriction explicit abstractions pattern database merge shrink
abstractions abstract spaces fixed size presented concrete scheme additive
implicit abstractions decomposing task along causal graph suggested
concrete realization idea called fork decomposition two novel fragments tractable cost optimal studied induced admissible heuristics
formally empirically showed favorably compete informativeness
state art admissible heuristics theory practice empirical
evaluation stressed tradeoff accuracy heuristics runtime complexity computing alleviate expensive per search node runtime
complexity fork decomposition heuristics showed equivalent explicit
abstractions notion database exists fork decomposition abstractions
despite exponential size abstract spaces subsequent empirical evaluation
heuristic search databases fork decomposition heuristics showed
favorably competes state art cost optimal
basic principles implicit abstraction framework motivate
numerous directions importantly discovering islands tractability
optimal ii abstracting general tasks islands likewise promise combining implicit abstractions techniques deriving admissible heuristic estimates first step towards combining implicit abstractions
polynomial time discoverable landmarks tasks recently taken
domshlak katz lefler believe combinations techniques might well improve informativeness heuristics without substantially increasing runtime complexity

acknowledgments
work authors partly supported israel science foundation grants




fikatz domshlak

appendix detailed empirical evaluation
hf
task

hi

h nodes time nodes

hfi
time nodes

time

ms

ms

nodes

nodes

time

hspf

time

nodes













































time

blind
nodes time

hmax
nodes time

airport ipc































































































































































blocks ipc
































































































































































































depots ipc












































grid ipc























table runtimes cost optimal heuristic search planners airport
blocksworld depots grid domains description planners given section fork decomposition heuristics computed
fully online column task denotes instance column h denotes optimal
solution length columns capture run time number expanded
nodes



fiimplicit abstraction heuristics

hf
task

h

nodes

hi

hfi

time

nodes

time nodes

time




































hspf

ms

ms

nodes

time

nodes

time

nodes
















































blind
time

nodes

time

hmax
nodes
time

driverlog ipc





































































freecell ipc







































gripper ipc






























































logistics ipc









































































































































































































































logistics ipc























































































mprime ipc













































































































































































































































































table similar table driverlog freecell gripper logistics ipc
logistics ipc mprime domains


fikatz domshlak

hf
task

h

nodes

hi
time

nodes

hfi
time nodes

time

ms

ms

nodes

nodes

time

time

hspf

nodes

blind
time

nodes

time

hmax
nodes time

miconic strips ipc







































































































































































































































































































































































































































































































mystery ipc





































































































































































































table similar table miconic mystery domains























fiimplicit abstraction heuristics

hf
task

h

hi

hfi

ms

ms

time

nodes

nodes










































nodes

time

nodes

time

nodes

time

time

hspf

nodes

blind

hmax
nodes
time

time

nodes

time







































































openstacks ipc





























pathways ipc































































pipesworld notankage ipc




































































































































































pipesworld tankage ipc












































































































tpp ipc




































































































trucks ipc






























































table similar table openstacks pathways pipesworld notankage
pipesworld tankage tpp trucks domains



fikatz domshlak

hf
task

h

nodes

hi
time

nodes

hfi
time

nodes

time

ms

ms

nodes time

nodes

time

hspf

nodes

blind
time

hmax
nodes time

nodes

time




























































































































































































































































































psr small ipc




















































































































































































































































































































































































































































































rovers ipc





































































satellite ipc


















































































































zenotravel ipc

































































































table similar table psr rovers satellite zenotravel domains



fiimplicit abstraction heuristics

hf
task

h nodes

hi
timenodes

hfi
timenodes

ms
time nodes

ms

timenodes

hspf

time nodes

blind
hmax
time nodes time nodes
time

schedule strips





















































































































































































































































































































































table similar table non ipc schedule strips domain



fikatz domshlak
hf
task

h

nodes

hi
time

nodes

hfi
time

nodes

time

ms

ms

nodes

nodes

time

hspf

time

nodes













































time

blind
nodes time

hmax
nodes time

airport ipc

























































































































































































blocks ipc














































































































































































































































depots ipc












































driverlog ipc













































































































table runtimes cost optimal heuristic search planners airport
blocksworld depots driverlog domains
description
planners given section fork decomposition heuristics via
structural pattern databases column task denotes instance column
h denotes optimal solution length columns capture run time
number expanded nodes


fiimplicit abstraction heuristics

hf
taskh

nodes

hi
time

nodes

hfi
time

nodes

time

ms

ms

nodes

nodes

time

time

hspf

nodes

blind
time

nodes

time

hmax
nodes
time

freecell ipc













































grid ipc






























gripper ipc




































































logistics ipc



































































































































































logistics ipc




















































































































































mprime ipc














































































































































































































































































table similar table freecell grid gripper logistics ipc
logistics ipc mprime domains



fikatz domshlak

hf
task

h

nodes

hi
time

nodes

hfi
time

nodes

time

ms

ms

nodes

nodes

time

time

hspf

nodes

blind
time

nodes

time

hmax
nodes time

miconic strips ipc











































































































































































































































































































































































































































































mystery ipc



























































































































































































table similar table miconic mystery domains























fiimplicit abstraction heuristics

hf
task h

nodes

hi
time

nodes

hfi

ms

ms

nodes

time

nodes

nodes

time




























































time

time

hspf

nodes

blind
time

hmax
nodes
time

nodes

time


























































openstacks ipc





































pathways ipc
























































pipesworld notankage ipc






























































































































































































pipesworld tankage ipc














































































































rovers ipc







































































































satellite ipc

























































table similar table openstacks pathways pipesworldnotankage pipesworld tankage rovers satellite domains



fikatz domshlak

hf
task h

nodes

hi
time

nodes

hfi
time

nodes

time

ms

ms

nodes

nodes

time

time

hspf

nodes

blind
time

hmax
nodes time

nodes

time






























































































































































































































































































psr small ipc


















































































































































































































































































































































tpp ipc












































































trucks ipc
























































zenotravel ipc

















































































































table similar table psr tpp trucks zenotravel domains


fiimplicit abstraction heuristics

hf
task

h

hi

hfi

nodes timenodes time nodes

ms
time nodes

ms

timenodes

hspf

time nodes

blind
hmax
time nodes time nodes
time

schedule strips























































































































































































































































































































table similar table non ipc schedule strips domain



fikatz domshlak

hf
task

h

nodes

hi

hfi

hspf

blind

time

nodes

time

nodes

time

nodes

time

nodes

time




















































































































































































































































































































elevators strips ipc

























































openstacks strips ipc


















































































































































































































































































































parcprinter strips ipc

















































scanalyzer strips ipc







































table runtimes cost optimal heuristic search planners elevators
openstacks strips parcprinter scanalyzer domains description planners given section fork decomposition heuristics via structural pattern databases column task denotes instance
column h denotes optimal solution length columns capture run time
number expanded nodes



fiimplicit abstraction heuristics

hf
task

h

hi

nodes

hfi

hspf

blind

time

nodes

time

nodes

time

nodes

time

nodes

time




















































































































































































































































































































































































































































































































































































































































pegsol strips ipc




















































































sokoban strips ipc


























































transport strips ipc
















































woodworking strips ipc
















































































table similar table pegsol sokoban transport woodworking domains


fikatz domshlak

references
backstrom c nebel b complexity sas computational
intelligence
bonet b geffner h heuristic search artificial intelligence

bylander computational complexity propositional strips
artificial intelligence
chen h gimenez causal graphs structurally restricted proceedings th international conference automated scheduling
icaps pp sydney australia
clarke e grumberg peled model checking mit press
coles fox long smith j additive disjunctive heuristics
optimal proceedings th international conference automated
scheduling icaps pp
culberson j schaeffer j pattern databases computational intelligence

domshlak c dinitz multi agent line coordination structure complexity proceedings sixth european conference ecp pp
domshlak c hoffmann j sabharwal friends foes
satisfiability abstract cnf encodings journal artificial intelligence

domshlak c katz lefler abstractions met landmarks proceedings th international conference automated scheduling
icaps pp toronto canada
drager k finkbeiner b podelski directed model checking distancepreserving abstractions valmari ed proceedings th international
spin workshop model checking software vol lecture notes computer
science pp berlin heidelberg springer verlag
edelkamp pattern databases proceedings european
conference ecp pp
edelkamp symbolic pattern databases heuristic search proceedings international conference ai scheduling aips pp

edelkamp automated creation pattern database search heuristics proceedings th workshop model checking artificial intelligence mochart
edelkamp kissmann p optimal symbolic action costs
preferences proceedings st international joint conference artificial
intelligence ijcai pp pasadena ca us
felner korf r e hanan additive pattern database heuristics journal
artificial intelligence


fiimplicit abstraction heuristics

haslum p additive reversed relaxed reachability heuristics revisited proceedings th international competition
haslum p bonet b geffner h admissible heuristics domainindependent proceedings twentieth national conference artificial intelligence aaai pp
haslum p botea helmert bonet b koenig domain independent
construction pattern database heuristics cost optimal proceedings
th national conference artificial intelligence aaai pp
haslum p geffner h admissible heuristics optimal proceedings fifth international conference artificial intelligence systems
icaps pp
helmert complexity standard benchmark domains
artificial intelligence
helmert heuristic causal graph analysis proceedings
th international conference automated scheduling icaps
pp whistler canada
helmert fast downward system journal artificial intelligence

helmert domshlak c landmarks critical paths abstractions whats
difference anyway proceedings th international conference automated scheduling icaps pp thessaloniki greece
helmert haslum p hoffmann j flexible abstraction heuristics optimal
sequential proceedings th international conference automated
scheduling icaps pp providence ri usa
helmert mattmuller r accuracy admissible heuristic functions selected domains proceedings rd aaai conference artificial
intelligence pp chicago usa
helmert understanding tasks domain complexity heuristic
decomposition vol lecture notes computer science springer
hernadvolgyi holte r psvn vector representation production systems
tech rep university ottawa
jonsson role macros tractable causal graphs proceedings international joint conference artificial intelligence ijcai
pp
jonsson p backstrom c state variable structural restrictions
complexity artificial intelligence
karpas e domshlak c cost optimal landmarks proceedings
international joint conference artificial intelligence ijcai pp
pasadena ca usa


fikatz domshlak

katz domshlak c structural patterns heuristics icaps workshop heuristics domain independent progress ideas limitations
challenges providence ri usa
katz domshlak c b structural patterns tractable sequentially optimal
proceedings th international conference automated
scheduling icaps pp providence ri usa
katz domshlak c structural patterns heuristics via fork decomposition
proceedings th international conference automated scheduling icaps pp sydney australia
katz domshlak c structural pattern databases proceedings
th international conference automated scheduling icaps pp
thessaloniki greece
katz domshlak c optimal admissible composition abstraction heuristics
artificial intelligence
pearl j heuristics intelligent search strategies computer solving
addison wesley
prieditis machine discovery effective admissible heuristics machine learning

richter helmert westphal landmarks revisited proceedings
twenty third national conference artificial intelligence aaai pp
chicago il usa
yang f culberson j holte r general additive search abstraction tech
rep tr university alberta
yang f culberson j holte r zahavi u felner general theory
additive state space abstractions journal artificial intelligence





