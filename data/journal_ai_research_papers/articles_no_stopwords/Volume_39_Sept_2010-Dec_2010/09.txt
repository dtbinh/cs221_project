Journal Artificial Intelligence Research 39 (2010) 429-481

Submitted 02/10; published 10/10

Nominals, Inverses, Counting, Conjunctive Queries
or: Infinity Friend!
Sebastian Rudolph

rudolph@kit.edu

AIFB, Karlsruhe Institute Technology, DE

Birte Glimm

birte.glimm@comlab.ox.ac.uk

Oxford University Computing Laboratory, UK

Abstract
Description Logics knowledge representation formalisms provide, example,
logical underpinning W3C OWL standards. Conjunctive queries, standard
query language databases, recently gained significant attention expressive
formalism querying Description Logic knowledge bases. Several different techniques
deciding conjunctive query entailment available wide range DLs. Nevertheless,
combination nominals, inverse roles, number restrictions OWL 1 OWL 2
DL causes unsolvable problems techniques hitherto available. tackle problem
present decidability result entailment unions conjunctive queries DL
ALCHOIQb contains three problematic constructors simultaneously. Provided
queries contain simple roles, result shows decidability entailment
(unions of) conjunctive queries logic underpins OWL 1 DL believe
presented results pave way progress towards conjunctive query
entailment decision procedures Description Logics underlying OWL standards.

1. Introduction
present decidability result entailment unions conjunctive queries
expressive Description Logic ALCHOIQb. article extended version conference paper Status QIO: Conjunctive Query Entailment Decidable, Proceedings
12th International Conference Principles Knowledge Representation Reasoning (KR 2010), May 0913, 2010 (Glimm & Rudolph, 2010).
Description Logics (DLs) family logic based knowledge representation formalisms
(Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003). DLs correspond
function-free two variable fragment First-Order Logic (FOL) often extended
counting quantifiers (e.g., xn y(R(x, y))) DLs closely related (2variable) guarded fragment since DL formulae naturally result guarded formulae
translated FOL. line restriction 2 variables, DL formulae contain
unary binary predicates, called concepts roles DLs. constructors
building complex expressions usually chosen key inference problems,
concept satisfiability, decidable. DL knowledge base (KB) consists TBox,
contains intensional knowledge concept definitions general background
knowledge (essentially FOL theory), ABox, contains extensional knowledge
used describe individuals (a set ground facts). Using database metaphor,
TBox corresponds schema, ABox corresponds data. contrast
c
2010
AI Access Foundation. rights reserved.

fiRudolph & Glimm

databases, however, DL knowledge bases, FOL general, adopt open world semantics,
i.e., represent information domain incomplete way.
Standard DL reasoning services include testing concepts satisfiability retrieving
certain instances given concept. latter retrieves, knowledge base consisting ABox TBox , (ABox) individuals instances given
(possibly complex) concept expression C, i.e., individuals
entail instance C. underlying reasoning problems well-understood,
computational complexity standard reasoning tasks given knowledge base
input range PTime-complete DLs limited expresivity DL-Lite
(Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2005), EL (Baader, 2003), ELP
(Krotzsch, Rudolph, & Hitzler, 2008) 2-NExpTime-complete expressive DLs
SROIQ (Kazakov, 2008).
Despite high worst case complexity standard reasoning problems
expressive DLs SROIQ, highly optimized implementations available,
e.g., FaCT++ (Tsarkov & Horrocks, 2006), Pellet (Sirin, Parsia, Cuenca Grau, Kalyanpur, & Katz, 2007), HermiT (Motik, Shearer, & Horrocks, 2009). systems
used wide range applications, e.g., biology (Sidhu, Dillon, Chang, & Sidhu,
2005), bio informatics (Wolstencroft, Brass, Horrocks, Lord, Sattler, Turi, & Stevens, 2005),
medicine (Golbreich, Zhang, & Bodenreider, 2006), information integration (Calvanese,
De Giacomo, Lenzerini, Nardi, & Rosati, 1998b), geography (Goodwin, 2005), geology (Jet
Propulsion Laboratory, 2006), defense (Lacy, Aviles, Fraser, Gerber, Mulvehill, & Gaskill,
2005), configuration (McGuinness & Wright, 1998). prominently, DLs known
use logical underpinning ontology languages, e.g., OIL, DAML+OIL,
W3C standard OWL 1 (Bechhofer, van Harmelen, Hendler, Horrocks, McGuinness, PatelSchneider, & Stein, 2004), successor OWL 2 (W3C OWL Working Group, 2009).
three species OWL 1: OWL Lite, OWL DL, OWL Full. OWL 2 extends
OWL 1 adds three sublanguages (called OWL 2 profiles): OWL EL, OWL QL,
OWL RL. OWL Lite corresponds DL SHIF standard reasoning
tasks ExpTime-complete, OWL 1 DL corresponds DL SHOIN ,
standard reasoning tasks NExpTime-complete, OWL 2 DL extends DL
SROIQ. OWL Full standard reasoning tasks longer decidable. new
QL, EL, RL profiles restrictive OWL DL profiles trades
different aspects OWLs expressive power return different computational and/or
implementational benefits. OWL EL corresponds DL EL ++ (Baader, Brandt, &
Lutz, 2005) basic reasoning problems performed time polynomial
respect size input knowledge base. OWL 2 QL based DL-Lite
family Description Logics, data complexity conjunctive query entailment
AC0 . Thus, conjunctive query answering implemented using standard relational
database technology. OWL 2 RL enables implementation polynomial time reasoning
algorithms using rule-extended database technologies.
data-intensive applications, querying KBs plays central role. Instance retrieval
is, aspects, rather weak form querying: although possibly complex concept
expressions used queries, query tree-like relational structures,
DL concept cannot express arbitrary cyclic structures. property known
tree model property considered important reason decidability
430

fiNominals, Inverses, Counting, Conjunctive Queries

Modal Description Logics (Gradel, 2001; Vardi, 1997) heavily exploit
variant property establish decidability result. Conjunctive queries (CQs)
unions conjunctive queries (UCQs) well known database community
constitute expressive query language capabilities go well beyond standard
instance retrieval. FOL terms, CQs UCQs formulae positive existential
fragment. Free variables query (not bound existential quantifier) called
answer variables distinguished variables, whereas existentially quantified variables
called non-distinguished.
query contains distinguished variables, query answer true false
query called Boolean query. Given knowledge base K Boolean UCQ
q, query entailment problem deciding whether q true false w.r.t. K, i.e.,
decide whether model K provides suitable assignment variables
q. query distinguished variables, answers query tuples
individual names (constants) knowledge base entails query
obtained replacing free variables individual names answer tuple.
answers called certain answers. problem finding answer tuples
known query answering. present decidability result query entailment,
decision problem, restriction since query answering easily reduced
query entailment illustrate detail Section 3.
1.1 Related Work
Conjunctive queries first mentioned context Description Logics (DLs)
Levy Rousset (1996). first account conjunctive queries main topic given
Calvanese, De Giacomo, Lenzerini (1998a). particular recent years, problem
decidability conjunctive query entailment complexity problem different
logics gained significant attention. DLs SHIQ SHOQ decidability
2-ExpTime-completeness problem known (Glimm, Horrocks, Lutz, & Sattler,
2008a; Glimm, Horrocks, & Sattler, 2008b; Lutz, 2008; Eiter, Lutz, Ortiz, & Simkus,
2009). Conjunctive query entailment already 2-ExpTime-hard relatively weak
DL ALCI (Lutz, 2008), initially attributed inverse roles. Recently,
shown, however, transitive roles together role hierarchies DL SH
make conjunctive query entailment 2-ExpTime-hard (Eiter et al., 2009). techniques
Glimm et al. SHIQ SHOQ (Glimm et al., 2008a, 2008b) reduce query entailment
standard reasoning task knowledge base satisfiability checking DL extended
role conjunctions. alternative technique so-called knots technique (Ortiz,
Simkus, & Eiter, 2008b), instance mosaic technique originating Modal
Logic. technique gives worst-case optimal algorithms SHIQ several
sub-logics. Further, automata-based decision procedures positive existential
path queries (Calvanese, Eiter, & Ortiz, 2007, 2009). Positive existential path queries
generalize unions conjunctive queries and, therefore, decision procedures kind
query provides decision procedures unions conjunctive queries. particular
recent extension (Calvanese et al., 2009) close conjunctive query entailment
decision procedure OWL 2, corresponds DL SROIQ, covers
431

fiRudolph & Glimm

SRIQ, SROQ, SROI. use three problematic constructors nominals,
inverses, number restrictions is, however, covered.
Regarding data complexity, i.e., complexity respect ABox (the data)
only, CQ entailment usually coNP-complete expressive logics. example, DLs
ALE SHIQ case (Glimm et al., 2008a) holds CQ
entailment two variable guarded fragment counting (Pratt-Hartmann, 2009).
latter work quite closely related since many Description Logics translated
two variable guarded fragment counting, i.e., results Pratt-Hartmann
hold SHIQ simple roles (roles transitive transitive
subrole) query. Given restriction query, SHOQ SHOI
shown coNP-complete data complexity w.r.t. conjunctive query entailment
(Ortiz, Calvanese, & Eiter, 2008a).
Query entailment answering studied context databases
incomplete information (Rosati, 2006b; van der Meyden, 1998; Grahne, 1991).
setting, DLs used schema languages, expressivity considered DLs
usually much lower expressivity DL ALCHOIQb consider
reasoning usually tractable. example, constructors provided logics
DL-Lite family (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007) chosen
standard reasoning tasks PTime regarding combined complexity
query entailment AC0 respect data complexity. Thus, TBox reasoning
done independently ABox ABox stored accessed using standard
database SQL engine. Another tractable DL EL (Baader, 2003). Conjunctive query
entailment EL is, however, tractable complexity increases coNP-complete
(Rosati, 2007b). Moreover EL++ (Baader et al., 2005), still tractable extension EL,
query entailment even undecidable (Krotzsch, Rudolph, & Hitzler, 2007). mainly
EL++ , one use unrestricted role compositions. allows encoding
context-free languages, conjunctive queries used check intersection
languages, known undecidable problem. Since logics used
databases incomplete information considerable less expressive ALCHOIQb,
techniques developed area transfer setting.
Given query entailment (computationally) harder task than, example,
knowledge base satisfiability, surprising decidability latter task
necessarily transfer problem CQ entailment. undecidability results transferred FOL since many DLs directly translated
equivalent FOL theory. example, known conjunctive query entailment
undecidable two variable fragment First-Order Logic L2 (Rosati, 2007a),
Rosati identifies relatively small set constructors cause undecidability (most
notably role negation axioms, i.e., axioms form x, (R(x, y) P (x, y)) R, P
binary predicates). Pratt-Hartmann (2009) recently established decidability CQ entailment two variable guarded fragment counting (GC2 ). worth noting
Pratt-Hartmann assumes background theory (that knowledge base
case) constant free formulae form =1 x(P (x)), used simulate constants/nominals, considered guarded. result covers, therefore,
DL ALCHIQb applicable case, input knowledge base (the
background theory) contains nominals (individual constants).
432

fiNominals, Inverses, Counting, Conjunctive Queries

implemented DL reasoners, e.g., KAON2,1 Pellet, RacerPro,2 provide
interface conjunctive query answering, although KAON2 RacerPro consider
named individuals ABox assignments variables. restriction
queries longer standard FOL semantics decidability obviously
issue since conjunctive query answering restriction reduced standard
instance retrieval replacing variables individual names ABox
testing entailment conjunct separately. Pellet goes beyond provides
interface conjunctive queries FOL semantics restriction queries
kind tree shape. restriction decidability known since CQs
expressed normal concepts (possibly adding role conjunctions).
1.2 Contributions Overview
Given results, show great interest problem conjunctive query entailment expressive DLs, interesting DLs SHIF, SHOIN ,
SROIQ underpin widely adopted standards OWL Lite, OWL 1 DL, OWL 2
DL, respectively, decidability conjunctive query entailment established
OWL Lite. main obstacle devising decision procedure combination inverse
roles (I), nominals (O), number restrictions/counting quantifiers (F stands functionality, N unqualified number restrictions, Q qualified number restrictions).
complications arising combination constructors caused major
hurdle development implementable algorithms knowledge base satisfiability
SHOIN extensions thereof, Horrocks Sattler (2005) devised tableau-based
decision procedure since extended SROIQ. Meanwhile alternative
approaches resolution (Kazakov & Motik, 2008), hypertableau-based procedures
(Motik et al., 2009) available implemented.
key obstacle establishing decision procedure existence potentially
infinitely many new nominals, i.e., elements uniquely identifiable model
KB. example, consider KB K given Fig. 1. concept form {o}
interpreted singleton set, containing interpretation constant
o. simplicity, assume constant always interpreted itself, e.g.,
interpretation o. axiom form {o1 } v f.s.f .{o2 }
understood follows: constant o1 , must two elements, say d1 d2 ,
f (o1 , d1 ), s(d1 , d2 ), f (o2 , d2 ) holds. Note o2 occurs first element
f (o2 , d2 ) since inverse role (f ) used. Thus, interpretation KB must contain
three elements o1 , o2 , o3 , must interconnected following way: paths
f



f

shape lead o1 o2 well o2 o3 o3
o1 . Moreover, role f defined functional, meaning every element
one f -successor. applies individuals oi , forces existence
s-cycle. Observe cyclic Boolean query {s(x, y), s(y, z), s(z, x)} checks
existence cycle cannot answered applying standard techniques
replacing variables individual names (oi ) rewriting query equivalent
1. http://kaon2.semanticweb.org
2. http://www.racer-systems.com

433

fiRudolph & Glimm

{o1 } v f.s.f .{o2 }
{o2 } v

f.s.f .{o

{o1 }

3}

f

f




{o3 } v f.s.f .{o1 }

{o2 }


f

{o3 }

func(f )

Figure 1: Example knowledge base K representation model, three
elements s-cycle so-called new nominals.

tree-shaped query. elements cycle behave nominals,
names them.
tackle problem conjunctive query entailment expressive DL contains three problematic constructors simultaneously prove decidability (unions
of) conjunctive queries. challenging part establish finite representability
countermodels case query given input entailed knowledge base.
results hold SHOIQ knowledge bases, i.e., roles declared transitive,
provided queries contain simple roles (roles neither transitive
transitive subrole). essentially restriction placed roles
occur number restrictions since otherwise standard reasoning tasks become
undecidable. restriction, use standard techniques eliminating transitivity (Kazakov & Motik, 2008). Hence, show decidability conjunctive query
entailment OWL DL, queries simple roles.
believe work valuable understanding, general, structure
models DLs contain nominals, inverse roles, number restrictions. Furthermore,
devise non-trivial extensions standard techniques unraveling, believe
prove useful working expressive DLs.
paper organized follows: Section 2, give birds-eye view techniques
ideas used establish decidability. Section 3, give necessary definitions
introduce standard notations. Sections 4, 5, 6 present main results
use Section 7 show models satisfy query finitely
represented conclude Section 8.

2. Big Picture
going technical details, describe overall line argumentation
establishing decidability conjunctive query entailment ALCHOIQb.
2.1 Decidability via Finitely Representable Countermodels
Let K ALCHOIQb knowledge base let q conjunctive query question,
i.e., aim determine whether
K |= q.
Clearly, ALCHOIQb fragment first-order predicate logic equality, K
translated FOL sentence F OL(K). Likewise find FOL sentence F OL(q)
434

fiNominals, Inverses, Counting, Conjunctive Queries

q existentially quantified formula. Hence, checking entailment
equivalent determining whether first-order theory F OL(K) entails F OL(q).
result completeness theorem FOL (Godel, 1929), consequences finite FOL
theory recursively enumerable, provides us procedure terminates
K |= q. Hence, establish decidability providing another algorithm terminates
iff entailment hold i.e., so-called countermodel
model K 6|= q.
provide algorithm showing that, whenever countermodel
exists all, countermodel finitely representable. precisely,
encoded word Rep(I) finite length finite alphabet, whereby
encoding Rep property every finite word effectively checked
whether represents countermodel given knowledge base query.
consequence thereof, create desired algorithm enumerates words,
checks countermodel, terminates soon found one.
2.2 Finite Representability Bounding Nominals Blocking
outline going show always finitely representable
countermodel, one all. taking arbitrary countermodel
cautiously transforming countermodel finitely representable. Cautiously
means make sure transformation preserve two properties
1) model underlying knowledge base K 2) entailing considered
query q.
result overall transformation going regular model, i.e., structure
substructures certain sense periodically repeated. common practice
DL theory construct kind models arbitrary ones blocking techniques,
whereby certain element configurations occurring twice original model detected
new model generated infinitely stringing together finite substructure
delimited two configurations.
case consider, technique cannot applied directly original countermodel. due intricate interplay nominals, inverse roles cardinality
constraints arbitrary even infinite number domain elements
forced behave nominals; elements usually referred new
nominals DL setting. FOL, nominals often called kings new nominals
called court. case, presence infinitely many new nominals model
may prevent existence repeated configurations needed blocking.
overcome difficulty first applying transformation means
original countermodel converted countermodel finitely many new nominals. guarantees subsequent blocking-based transformation applicable
yield desired regular (and thus finitely representable) model.
2.3 Bounding Nominals Transformations Forest Quasi-Models
argumentation, introduce notion forest quasi-models. structures
satisfying originally considered knowledge base weakened form it.
435

fiRudolph & Glimm

return concession, exhibit proper forest structure easier handle
manipulate.
employ two techniques turn proper models forest quasi-models vice
versa: model unraveled yielding forest quasi-model. forest quasi-model
collapsed obtain proper model. techniques preserve certain structural properties.
strategy construct countermodel finitely many nominals consists
following three steps:
Take arbitrary countermodel unravel it.
Transform obtained forest quasi-model substituting critical parts wellbehaved ones,
Collapse obtained structure (proper) model.
mentioned critical parts giving rise new nominals.
least largely avoided (we care finite set critical parts
remaining).
central question is: mysterious well-behaved substitutes come from?
Fortunately, plethora critical parts brings remedy. use infinite
sets critical parts construct well-behaved ones infinite approximation process
(this infinity friend). thereby obtain parts present
structure before, well compatible hence used
reorganization.
informally introduced main line argumentation, move
technical details.

3. Preliminaries
first define syntax semantics roles, go SHOIQb-concepts,
individuals, knowledge bases. actually use full expressivity SHOIQb,
convenient umbrella DLs working define less
expressive DLs interest restrictions SHOIQb.
Definition 1 (Syntax SHOIQb). Let NC , NR , NI countable, infinite,
pairwise disjoint sets concept names, role names, individual names, respectively.
call = (NC , NR , NI ) signature. set rol(S) SHOIQb-roles (or roles
short) NR {r | r NR }, roles form r called inverse roles. role
inclusion axiom form r v r, roles. transitivity axiom form
trans(r) r role. role hierarchy H finite set role inclusion transitivity
axioms.
role hierarchy H, define function inv roles inv(r) := r r NR
inv(r) := r = role name NR . Further, define vH smallest transitive
reflexive relation roles r v H implies r vH inv(r) vH inv(s).
write r H r vH vH r. role r transitive w.r.t. H (notation r+ vH r)
436

fiNominals, Inverses, Counting, Conjunctive Queries

role exists r vH s, vH r, trans(s) H trans(inv(s)) H. role
called simple w.r.t. H role r r transitive w.r.t. H r vH s.
r rol(S) simple role, Boolean role expressions U defined follows:
U ::= r | U | U u U | U U.
use ` denote standard Boolean entailment set roles R rol(S) role
expressions. Let r rol(S), U Boolean role expression R. inductively define:
R ` r r R, R 6` r otherwise,
R ` U R 6` U , R 6` U otherwise,
R ` U u V R ` U R ` V , R 6` U u V otherwise,
R ` U V R ` U R ` V , R 6` U V otherwise.
Boolean role expression U safe 6` U .
Given signature = (NC , NR , NI ), set SHOIQb-concepts (or concepts
short) smallest set built inductively symbols using following
grammar, NI , NC , n IN0 , simple role, U role safe
Boolean role expression:
C ::= > | | {o} | | C | C1 u C2 | C1 C2 |
4
U.C | U.C | 6 n s.C | > n s.C.
Alternatively, safeness characterized follows: Boolean role expression U
safe if, transforming disjunctive normal form, disjunct contains least
one non-negated role. Intuitively, implies safe role expression never relate
individuals direct role relation other.
Definition 2 (Semantics SHOIQb-concepts). interpretation = (I , ) consists
non-empty set , domain I, function , maps every concept name
NC subset AI , every role name r NR binary relation rI ,
every individual name NI element aI . role name r NR ,

interpretation inverse role (r ) consists pairs h, 0
h 0 , rI .
semantics SHOIQb-concepts signature defined follows:
(r)I
>I
(C)I
(U.C)I
(U.C)I
(6 n s.C)I
(> n s.C)I

=
=
=
=
=
=
=

\ rI
(r1 u r2 )I = r1I r2I
(r1 r2 )I = r1I r2I



=
({o})I = {oI }
\ C
(C u D)I = C DI
(C D)I = C DI

0

0

{ | h, U , C }
{ | h, 0 U 0 C }
{ | ](sI (, C)) n}
{ | ](sI (, C)) n}

](M ) denotes cardinality set sI (, C) defined
{ 0 | h, 0 sI 0 C }.
concept C negation normal form (NNF) negation occurs front concept
names use nnf(C) denote negation normal form concept C.
4
437

fiRudolph & Glimm

concept transformed linear time equivalent one NNF pushing
negation inwards, making use de Morgans laws duality existential
universal restrictions, at-most at-least number restrictions form
6 n r.C > n r.C respectively (Horrocks, Sattler, & Tobies, 2000).
Definition 3 (Syntax Semantics Axioms Knowledge Bases). functionality
restriction expression func(f ) f role. C, concepts, general concept
inclusion (GCI) expression C v D. introduce C abbreviation
C v v C. finite set GCIs functionality restrictions called TBox.
.
.
(ABox) assertion expression form C(a), r(a, b), r(a, b), = b, =
6 b,
C concept, r role, a, b NI individual names. ABox finite set
assertions. knowledge base K triple (T , H, A) TBox, H role hierarchy,
ABox.
use con(K), rol(K), nom(K) denote, respectively, set concept names,
roles (including inverses), individual names occurring K. closure cl(K) K
smallest set containing nnf(C D) C v ; sub-concept C
C cl(K); nnf(C) C cl(K). role f functional K K contains
functionality axiom func(f ) inverse functional K K contains functionality
axiom func(inv(f )).
Let = (I , ) interpretation. satisfies role inclusion axiom r v
rI sI , satisfies transitivity axiom trans(r) rI transitive binary relation, role
hierarchy H satisfies role inclusion transitivity axioms H. interpretation
satisfies functionality restriction func(f ) if, , ]({ 0 | h, 0 f }) 1;
satisfies GCI C v C DI ; satisfies TBox satisfies functionality
restriction GCI . interpretation satisfies assertion C(a) aI C ,
.
.
r(a, b) haI , bI rI , r(a, b) haI , bI
/ rI , = b aI = bI , =
6 b aI 6= bI ;
satisfies ABox satisfies assertion A. say satisfies K satisfies
, H, A. case, say model K write |= K. say K
consistent K model.
4
knowledge base K clear context, simply say role f (inverse)
functional instead saying f (inverse) functional K.
names DLs indicate constructors supported. basic DL ALC
supports Boolean concept constructors GCIs, role hierarchies, functionality
restrictions et cetera. transitivity axioms added, use instead ALC. Inverse
roles indicated letter I, role inclusion axioms H, nominals, i.e., concepts
form {o} NI , O, functionality restrictions F, qualified number restrictions,
i.e., concepts form 6 n s.C > n s.C, Q, safe Boolean role expressions
b. number restrictions limited concepts form 6 n s.> > n s.>, use
letter N .
mostly refer particular DLs paper: DL SHOIQ obtained
SHOIQb disallowing Boolean role expressions. DLs SHIQ, SHOQ, SHOI
obtained SHOIQ disallowing nominals, inverse roles, number restrictions
(incl. functionality restrictions), respectively. Finally, DL ALCOIFb obtained
SHOIQb disallowing transitivity axioms (we use ALC instead name
DL indicate this), role inclusion axioms, concepts form 6 n s.C > n s.C.
438

fiNominals, Inverses, Counting, Conjunctive Queries

3.1 Conjunctive Queries Unions Conjunctive Queries
introduce Boolean conjunctive queries since basic form queries
concerned with. later define non-Boolean queries show
reduced Boolean queries. Finally, unions conjunctive queries disjunction
conjunctive queries.
Definition 4 (Syntax Semantics Conjunctive Queries). Let = (NC , NR , NI )
signature NV countably infinite set variables disjoint NC , NR , NI .
term element NV NI . Let NC concept name, r NR role
name, t, t0 terms. atom expression A(t) r(t, t0 ) refer two
types atoms concept atoms role atoms respectively. Boolean conjunctive query
q non-empty set atoms. use var(q) denote set (existentially quantified)
variables occurring q term(q) denote set variables individual names
occurring q. usual, use ](q) denote cardinality q, simply
number atoms q, use |q| size q, i.e., number symbols necessary
write q.
Let = (I , ) interpretation. total function : term(q) evaluation
(a) = aI individual name occurring q. A(t), r(t, t0 ) atoms, write
|= A(t) (t) AI ;
|= r(t, t0 ) ((t), (t0 )) rI .
If, evaluation , |= atoms q, write |= q. say
satisfies q write |= q exists evaluation |= q. call
match q I.
Let K knowledge base q conjunctive query. |= K implies |= q, say
K entails q write K |= q.
4
query entailment problem defined follows: given knowledge base K
query q, decide whether K |= q.
Definition 5 (Unions Conjunctive Queries). union Boolean conjunctive queries
formula q1 . . . qn , disjunct qi Boolean conjunctive query.
knowledge base K entails union Boolean conjunctive queries q1 . . . qn , written
K |= q1 . . . qn , if, interpretation |= K,
|= qi 1 n.
4
clarify connection query entailment query answering.
query answering, let variables conjunctive query typed: variable either
existentially quantified (also called non-distinguished ) free (also called distinguished
answer variables). Let q query n variables (i.e., ](var(q)) = n), v1 , . . . , vm
(m n) answer variables. answers K q m-tuples (a1 , . . . , )
individual names that, models K, |= q satisfies (vi ) = aIi
1 m. Recall use nom(K) denote set individual names
occurring K (in form nominals ABox individuals). hard see (cf.
Chandra & Merlin, 1977) answers K q computed testing,
439

fiRudolph & Glimm

(a1 , . . . , ) nom(K)m , whether query q[v1 ,...,vm /a1 ,...,am ] obtained q replacing
occurrence vi ai 1 entailed K. set certain answers
q set m-tuples (a1 , . . . , ) K |= q[v1 ,...,vm /a1 ,...,am ] . Let
k = ](nom(K)) number individual names occurring K. Since K finite, clearly
k finite. Hence, deciding tuples belong set answers checked
k entailment tests.
algorithm present paper decides query entailment. reasons
devising decision procedure query entailment instead query answering twofold: first, query answering reduced query entailment shown above; second,
contrast query answering, query entailment decision problem studied
terms complexity theory.
3.2 Simplifying Assumptions
following, make several assumptions without loss generality,
simplify presentation decision procedure.
3.2.1 SHOIQ ALCHOIQb simplified ALCOIFb Knowledge Bases
following, work ALCOIFb knowledge bases. Nevertheless, results
hold SHOIQ knowledge bases queries simple roles query
ALCHOIQb knowledge bases, i.e., knowledge base contains safe Boolean role
expressions, transitivity. restriction ALCOIFb without loss generality,
show now.
Provided query contains simple roles, use elimination techniques
transitivity (Kazakov & Motik, 2008) reduce SHOIQ knowledge base ALCHOIQ
knowledge base extended signature. eliminate qualified number restrictions role inclusion axioms transforming ALCHOIQb knowledge base
ALCOIFb knowledge base equivalent original one extension
signature (Rudolph, Krotzsch, & Hitzler, 2008). repeat formal proof here,
rather give informal argument reduction works.
assume knowledge base negation normal form, i.e., GCIs
form > v C C concept NNF. Now, consider concept expression form
> n r.C r role C concept. means least n distinct rneighbors satisfying C. However, situation enforced introducing n new roles
r1 , . . . , rn deemed r superrole (ri v r) pairwise
disjoint (> v (ri u rj ).). side conditions, concept expression
replaced r1 .C u . . . u rn .C.
somewhat dual argumentation possible concept expressions form 6 n r.C
restricting number r-neighbors satisfying C n. extend
signature introducing new roles r1 , . . . , rn , time, let cover outgoing
r-links following sense: whenever r-link leads domain element
satisfies C, one roles r1 , . . . , rn leads there. Indeed, safe Boolean role
expressions allow expressing correspondence via concept description (r u r1 u
. . . u rn ).C. easy see, concept expression replace
additionally demand roles r1 , . . . , rn functional.
440

fiNominals, Inverses, Counting, Conjunctive Queries

{o} v r.A

v r.A

v s.B

func(f )

func(g )

B vC tD

C v f.E

v g.E

E v B {o}

r
{o}
E



r


f

B
C E



r


g

B
DE



r


f

B
C E



r


g

B
DE

r




f

B
C E

g



Figure 2: Knowledge base running example representation model
knowledge base.

Finally consider role hierarchy statement r v s, stating whenever two domain
elements 1 2 connected role r, interconnected via s. Clearly,
statement reformulated as: two domain elements connected r
s. This, turn, equivalently rephrased saying domain element
r u s-neighbor or, expressed GCI, > v (r u s)..
transformations applied ALCHOIQb knowledge base, whereby
cardinality constraints role inclusion axioms eliminated. leaves us
equivalent ALCOIFb knowledge base extension signature.
Figure 2 displays ALCOIFb knowledge base according model,
refer running example throughout paper.
Furthermore, assume ABox internalized (e.g., C(a) replaced
equivalent GCI {a} v C, r(a, b) {a} v r.{b}, etc.). Thus, effectively decide query
entailment respect TBox since knowledge bases setting empty
ABox.
ALCOIFb TBox, always possible transform equivalent TBox
0 signature extension GCIs 0 one following simplified
forms:
l
G
Ai v
Bj | {o} | v U.B | v U.B | func(f ),
(1)
A(i) B(j) concept names, andindividual name, U safe Boolean
F role
expression, f role. = 0, interpret Ai > j = 0, interpret Bj
. ALCOIFb knowledge base K = (T , A) simplified simplified empty.
Every ALCOIFb knowledge base, form, transformed polynomial time desired form using standard structural transformation,
iteratively introduces definitions compound sub-concepts (Kazakov & Motik, 2008).
Thus, assume remainder knowledge base rewritten simplified
ALCOIFb knowledge base.
441

fiRudolph & Glimm

3.2.2 Connected Constant-free Queries
assume queries connected. precisely, let q conjunctive query.
say q connected if, t, t0 term(q), exists sequence t1 , . . . , tn
t1 = t, tn = t0 and, 1 < n, exists role name r r(ti , ti+1 ) q
r(ti+1 , ti ) q. collection q1 , . . . , qn queries partitioning q q = q1 . . . qn ,
term(qi ) term(qj ) = 1 < j n, qi connected.
Lemma 6. Let K knowledge base, q conjunctive query, q1 , . . . , qn partitioning
q. K |= q iff K |= qi 1 n.
proof given Tessaris (2001) and, lemma, clear restriction
connected queries indeed without loss generality since entailment q decided
checking entailment qi time. follows, therefore assume queries
connected without notice.
unions conjunctive queries, assume variable names disjunct
different variable names disjuncts. always achieved
naming variables apart. assume disjunct UCQ connected conjunctive query. without loss generality since UCQ contains unconnected
disjuncts always transformed conjunctive normal form; decide entailment resulting conjunct separately conjunct union connected
conjunctive queries (Glimm et al., 2008a). Note that, due transformation conjunctive normal form, resulting number unions connected conjunctive queries
test entailment exponential size original query.
assume queries contain constants (individual names) occur
position variables. presence nominals without loss generality:
individual name occurring q, extend knowledge base K axioms
{a} Na Na NC fresh concept name, replace occurrence q
fresh variable xa NV add concept atom Na (xa ) q.
3.2.3 General Notation
Throughout paper, concept names role expressions written upper case,
roles individual names written lower case. Unless stated otherwise, use
B concept names; C possibly complex concepts; r roles, f
functional inverse functional roles; U V safe Boolean role expressions;
nominals used TBox axioms occur complex concepts. Sub-
superscripts might appended necessary. stated otherwise, use q (possibly
subscripts) connected Boolean conjunctive query, K simplified ALCOIFb
knowledge base, interpretation (I , ), , evaluations.

4. Model Construction
section, introduce interpretations models kind forest shape.
main notion forest is, however, weak since allow arbitrary
relations tree elements roots. Without relations, call result
strict forest. exploit nice properties trees forests following sections,
442

fiNominals, Inverses, Counting, Conjunctive Queries

replace parts interpretations give rise infinite number new nominals.
Since even models ALCOIFb knowledge base kind forest shape
really forests, introduce approximations models nominals longer
interpreted singleton sets. call structures quasi-interpretations quasi-models
interpretations form real forests. Further, provide way
unraveling arbitrary model forest quasi-model knowledge base
way collapsing forest quasi-models back real models knowledge
base still kind forest shape.
Definition 7 (Forest (Quasi-)Interpretations (Quasi-)Models). tree nonempty, prefix-closed subset . w, w0 , call w0 successor w w0 = w c
c IN, denotes concatenation. call w0 predecessor w w = w0 c
c IN, w0 neighbor w w0 successor w vice versa. empty
word called root tree. use |w| denote length w.
forest F subset R , R countable, possibly infinite set elements
that, R, set {w | (, w) F } tree. pair (, ) F called
root F . (, w), (0 , w0 ) F , call (0 , w0 ) successor (, w) 0 = w0
successor w; (0 , w0 ) predecessor (, w) 0 = w0 predecessor w;
(0 , w0 ) neighbor (, w) (0 , w0 ) successor (, w) vice versa. node (, w)
ancestor node (0 , w0 ) = 0 w prefix w0 descendant
= 0 w0 prefix w.
forest interpretation knowledge base K interpretation = (I , )
satisfies following conditions:
FI1 forest roots R;
FI2 total surjective function : nom(K) R {} (o) = (, )
iff oI = (, );
FI3 role r rol(K), h(, w), (0 , w0 )i rI , either
(a) w = w0 = ,
(b) (, w) neighbor (0 , w0 ).
|= K, say forest model K. single root, call tree
interpretation tree model K, respectively.
Let K ALCOIFb knowledge base. nomFree(K), denote ALCIFb
knowledge base obtained K replacing nominal concept {o} nom(K)
fresh concept name . forest quasi-interpretation K interpretation
J = (J , J ) nomFree(K) satisfies following properties:
FQ1 J forest roots R;
FQ2 total surjective function : nom(K) R {} (o) = (, )
iff (, ) NoJ
FQ3 role r rol(K), h(, w), (0 , w0 )i rI , either
(a) w = w0 = ,
443

fiRudolph & Glimm

(b) (, w) neighbor (0 , w0 ).
Note condition FQ2 allows elements (, w) J w 6= (, w) NoJ .
call J strict condition FQ3, FQ3(b) allowed. J |= nomFree(K) say
J forest quasi-model K.
branching degree d(w) node w tree number successors w. Let
= (I , ) forest (quasi) interpretation K. k d(w) k
(, w) , say branching degree k.
4
remainder, use concept name , mean fresh concept name
introduced nomFree(K) nominal concept {o} nom(K). Elements
extension concept called nominal placeholders. Please note that,
forest quasi-interpretations J , several elements (, w) w 6=
(, w) NoJ .
following, define notion isomorphism forest interpretations. Note
demand structural identity w.r.t. concepts roles w.r.t.
successor relation.
Definition 8 (Isomorphism Forest Interpretations). Let I, 0 two forest inter0
pretations K 1 , 2 , 10 , 20 . pairs h1 , 2 i, h10 , 20 isomorphic
w.r.t. K, written h1 , 2
=K h10 , 20 iff
0

1. h1 , 2 rI iff h10 , 20 rI r rol(K),
0

2. AI iff i0 AI {1, 2} con(K),
0

3. = oI iff i0 = oI {1, 2} nom(K).
say 0 isomorphic w.r.t. K, written:
=K 0 , bijection
0
: that, 1 , 2 , h1 , 2
=K h(1 ), (2 )i 1
successor 2 iff (1 ) successor (2 ).
4
clear context, omit subscript K
=K . extend definition
obvious way forest quasi-interpretations, i.e., omitting condition 3 defining
isomorphism respect K0 = nomFree(K).
Forest quasi-models have, intuitively, purpose intermediate step arbitrary models K forest models K. identifying interpretation
concept knowledge base K0 root interpretation ,
obtain interpretation would model K apart functionality restrictions
nominals might violated. show later eliminate relations forest back roots violate functionality restrictions
eventually obtain forest model forest quasi-model.
Another useful property quasi-interpretations that, simplified ALCIFb knowledge bases, checked locally whether interpretation actually model
K.
Definition 9 (Local K-consistency). Let = (I , ) interpretation simplified
ALCIFb knowledge base K . define local satisfaction concepts
occur simplified ALCIFb axioms follows:
444

fiNominals, Inverses, Counting, Conjunctive Queries

1. A1 , . . . , con(K):
(a) I, |=



(b) I, |=

F

Ai AIi 1 n; I, 6|=



Ai otherwise;
F
Ai AIi 1 n; I, 6|= Ai otherwise;

2. U safe Boolean role expression rol(K), con(K):
(a) I, |= U.A 0 h, 0 U I, 0 |= A;
I, 6|= U.A otherwise;
(b) I, |= U.A if, 0 h, 0 U , I, 0 |= A; I, 6|= U.A
otherwise;
3. f rol(K), I, |= func(f ) ]({ 0 | h, 0 f }) 1; I, 6|= func(f )
otherwise.
element locally satisfies GCI C v C, ALCIFb-concepts I, |= C
implies I, |= D. locally satisfies functionality restriction func(f ) I, |= func(f ).
element locally K-consistent locally satisfies axiom K.
4

Lemma 10. Let K simplified ALCIFb knowledge base = (I , ) interpretation K. model K iff element locally K-consistent.

Proof. simplified ALCIFb knowledge bases, axioms form v U.B
v U.B involve checking neighbors element and, since B concept name
simplified knowledge bases, immediate satisfaction B checked locally
neighbor question.
knowledge base K nominals, use local K-consistency,
need additional global condition ensures nominals interpreted singleton
sets. following immediate consequence Lemma 10 extra condition 2
nominals:
Proposition 11. Let K simplified ALCOIFb knowledge base = (I , )
interpretation K. model K iff
1. element locally K-consistent and,
2. nom(K), exactly one element oI = .

445

fiRudolph & Glimm

show obtain forest quasi-model model K using
adapted version unraveling.
Definition 12 (Unraveling). Let K consistent ALCOIFb knowledge base =
(I , ) model K. Let choose function returns, concept C = U.B
cl(K) element (U.B)I element C, h, C, U
C, B .
Without loss generality, assume that, concepts C1 = U1 .B1 , C2 =
U2 .B2 cl(K) C1I C2I , choose(C1 , ) = 1 , choose(C2 , ) = 2 ,
h, 1
= h, 2 i, 1 = 2 .
unraveling element , denoted (I, ), interpretation
obtained follows: define set (I ) sequences
smallest set
sequence;
1 n n+1 sequence,
1 n sequence,
n > 2 hn , n1 f functional role f , n+1 6= n1 ,
n+1 = choose(C, n ) C = U.B cl(K).
fix set F {} bijection : F
(i) F forest,
(ii) (, ) = ,
(iii) (, w), (, w c) F w c successor w, (, w c) = (, w) n+1
n+1 .
forest F bijection exist prefix-closed set root . Thus,
map notion sequences forests.
nom(K), let NC fresh concept name. (, w) F , set
Tail(, w) = n (, w) = 1 n . Now, define unraveling interpretation
J = (J , J ) J = F and, (, w) J , define interpretation
concept role names follows:
(a) nom(K), NoJ = {(, w) J | Tail(, w) oI };
(b) concept name con(K), AJ = {(, w) J | Tail(, w) AI };
(c) role name r rol(K), h(, w), (, w0 )i rJ iff w0 neighbor w,
hTail(, w), Tail(, w0 )i rI .
Let R subset contains exactly oI =
nom(K). Let U set containing unraveling starting R.
union interpretations U called unraveling I, denoted (I),
unions interpretations defined natural way.
4
446

fiNominals, Inverses, Counting, Conjunctive Queries

E



BC
E

BD
E

f



BC
E

g

BC
E






r

BD
E

f

BD
E

f

g

BC
E

g

BC
E



..

.

r


BD
E
g

BC
E
f
..

r


r

r

r





r

BD
E
g

.

f
..

.

BD
E
g

f
..

E
..
.
E
..
.
E
..
.

.

Figure 3: Unraveling model displayed Figure 2.
Figure 3 shows unraveling example knowledge base model. dotted
lines non-root elements labeled indicate copy whole tree
appended since stop unraveling nominal placeholders.
might helpful think function Tail homomorphism (up signature
extension) elements unraveling J elements original model I.
Indeed, Tail satisfies following properties: (, w), ( 0 , w0 ) J ,
Tail(, w) = oI iff (, w) NoJ , nom(K),
Tail(, w) AI iff (, w) AJ , con(K),
hTail(, w), Tail( 0 , w0 )i rI iff h(, w), ( 0 , w0 )i rJ , r rol(K).
Unravelings first step process transforming arbitrary model K
forest model since resulting model forest quasi-model K, show
next lemma.
Lemma 13. Let K consistent ALCOIFb knowledge base = (I , ) model
K. J = (J , J ) = (I) strict forest quasi-model K.
Proof. Let K0 = nomFree(K). construction, J satisfies conditions FQ1 FQ3
forest quasi-models strictness condition. Since J obtained model
K, definition unravelings starting oI =
nom(K), condition (a) unravelings, is, nom(K), one root
(, ) J (, ) NoJ . Thus, J satisfies property FQ2 J forest
quasi-interpretation K. show J model K0 demonstrating
(, w) J locally K0 -consistent. Since assume knowledge bases simplified,
consider axioms form (1).
447

fiRudolph & Glimm


F

Let Ax axiom form Ai v Bj assume
(, w) ( Ai )J .

condition (b) unravelings, w = Tail(, w) ( Ai )I and, since |= K,
w BjI j. condition (b) unravelings, (, w) BjJ
required.
Axioms form {o} K rewritten K0 . consider v
v separately. Let Ax form v nom(K) assume
(, w) AJ . condition (b), w = Tail(, w) AI and, since |= K,
w {oI }. condition (a) unravelings, (, w) NoJ
required. v nom(K), assume (, w) NoJ . condition (a),
w = Tail(, w) {oI } and, since |= K, w AI . condition (b)
unravelings, (, w) AJ required.
Let Ax axiom form v U.B assume (, w) AJ . condition (b), w = Tail(, w) AI and, since |= K, w0
hw , w0 U w0 B . Let ( 0 , w0 ) h(, w), ( 0 , w0 )i U J
( 0 , w0 )
/ B J . condition (c) unravelings, hw , w0 U
w0 = Tail( 0 , w0 ) condition (b) w0
/ B , contradiction.
Let Ax axiom form v U.B assume (, w) AJ . condition (b), w = Tail(, w) AI and, since |= K, least one
w0 hw , w0 U w0 B . case one
element, let w0 w0 = choose(C, w ). Then, definition sequences,
neighbor (, w0 ) (, w) Tail(, w0 ) = w0 . Let (, w) = 1 n , i.e., n = w .
distinguish two cases:
1. element w0 w0 = n1 . definition bijection , w =
w0 c, definition J (condition (c)) since hw , w0 U ,
h(, w), (, w0 )i U J . Then, since B concept name w0 B ,
condition (b) (, w0 ) B J , proves claim.
2. element w0 w0 6= n1 . definition sequences bijection
, (, w0 ) = 1 n w0 . Now, definition J (in particular
properties (b) (c)), h(, w), (, w0 )i U J and, since B concept
name, (, w0 ) B J , proves claim.
Let Ax axiom form func(r) r rol(K). Assume, contrary
shown, (, w) two distinct neighbors (, w1 ), (, w2 )
h(, w), (, w1 )i, h(, w), (, w2 )i rJ . Since function introduced unraveling
bijection, two distinct sequences s1 s2 (, w1 ) = s1 (, w2 ) = s2
Tail(, w1 ) = 1 , Tail(, w2 ) = 2 1 6= 2 . Since h(, w), (, w1 )i, h(, w), (, w2 )i
rJ get, due condition (c), hTail(, w), 1 i, hTail(, w), 2 rI , contradiction since |= K.
Since (, w) arbitrarily chosen, element domain J
locally K0 -consistent required J |= K0 Lemma 10.
Lemma 14. Let K consistent ALCOIFb knowledge base, = (I , ) model K,
J = (J , J ) = (I) unraveling I. J branching degree bounded
|cl(K)|.

448

fiNominals, Inverses, Counting, Conjunctive Queries

Proof. Let number axioms K. axiom simplified knowledge base
contain one existential restriction and, due definition function
choose used unraveling, are, sequence S, elements
1 , . . . , 1 sequence S. Since mapping
forest J sequences bijection, J forest branching degree m.
following steps, traverse forest quasi-model order elements
smaller tree depth always smaller order elements greater tree depth.
Elements tree depth ordered lexicographically. bounded branching
degree unravelings guarantees that, finite number steps, go
next level forest process nodes eventually. Further, merge nodes
that, finally, nominal placeholders (in extension ) interpreted
nominals without violating functionality restrictions. fact,
merge nominal placeholders, elements related nominal placeholder
inverse functional role since, definition semantics, elements
correspond element model. order identify elements, define
notion backwards counting paths follows:
Definition 15 (Paths BCPs). Let = (I , ) interpretation. call 1 . . . n
path 1 n if, 1 < n, hi , i+1 riI role ri rol(K).
length |p| path p = 1 . . . n n 1. element path length
U

Un1

0. write 1 1 2 . . . n denote path 1 n hi , i+1 UiI
1 < n Ui safe Boolean role expression.
Let K ALCOIFb knowledge base = (I , ) forest model (a forest quasimodel) K. path p = 1 . . .n descending path root (, )
that, 1 n, = (, wi ) and, 1 < n, |wi | < |wi+1 |.
path p backwards counting path (BCP) n = oI (n NoI ) nominal
nom(K) and, 1 < n, hi , i+1 fiI inverse functional role
rol(K). path p descending BCP BCP descending path. Given
f1

fn

BCP p = 1 2 . . . n+1 n+1 oJ (n+1 NoJ ), call sequence f1 fn
path sketch p.
4
Please note element domain J already counts (descending) BCP
oJ (NoJ ) nom(K).
define order guarantees iterative parsing process,
process nodes, merge nodes required that, finally, nominal
placeholders interpreted nominals without violating functionality restrictions.
Definition 16 (Ordering). convenience without loss generality, assume
set individual names NI ordered. Let K consistent ALCOIFb knowledge
base J forest quasi-interpretation K. extend order elements J


follows: let w1 = wp c11 cn1 , w2 = wp c12 cm
2 wp longest
common prefix w1 w2 , w1 < w2 either n < n = c11 < c12 .
(1 , ), (2 , ) J , let o1 nom(K) smallest nominal (1 , ) NoJ1
o2 nom(K) smallest nominal (2 , ) NoJ2 . (1 , w1 ) < (2 , w2 ) either
(i) |w1 | < |w2 | (ii) |w1 | = |w2 | o1 < o2 (ii) |w1 | = |w2 |, o1 = o2 w1 < w2 .
449

fiRudolph & Glimm

following, merging elements unraveling and, process, create
new roots form (w, ) elements form (, w) elements form
(w, w0 ) (, ww0 ). extend, therefore, order elements form follows:
(1 w1 , w10 ) < (2 w2 , w20 ) (1 , w1 w10 ) < (2 , w2 w20 ).
4
Roughly speaking, proceed follows order transform quasi-forest model
J forest model I: work way downwards trees level level along
descending BCPs use defined order purpose. definition
semantics, elements start descending BCP or, precisely, start
BCPs identical path sketches, correspond element forest
model produce. traversal forest quasi-model, distinguish
two situations: (i) encounter element (, w) starts descending BCP
seen another element starts descending BCP path
sketch. case, promote (, w) become new root node form (w, )
shift subtree rooted (, w) it; (ii) encounter node (, w) starts
descending BCP, already seen node (0 , w0 ) starts descending BCP
path sketch root form (0 w0 , ). case, delete
subtree rooted (, w) identify (, w) (0 w0 , ). (, w) f -successor
predecessor inverse functional role f , delete f -successors (0 w0 , )
subtrees order satisfy functionality restriction. use notion collapsing
admissibility characterize models predecessor (, w) satisfies
atomic concepts deleted successor (0 , w0 ), ensures local consistency
preserved. virtue notion, characterize forest quasi-models
collapsed proper models irrespective whether obtained unraveling
model not.
order keep domain forest promoting element (, w) new root,
build new domain elements form (w, ) (, w) elements
form (w, w0 ) descendants (, ww0 ) (, w).
Definition 17 (Equivalence Relation Collapsings). Let K ALCOIFb knowledge base, K0 = nomFree(K), J = (J , J ) forest quasi-interpretation K.
define smallest equivalence relation J satisfies 1 2 1 , 2 start
descending BCPs identical path sketches.
Let J strict forest quasi-interpretation K, J0 = (J0 , J0 ) = J (0 , w0 )
J
0
smallest element w0 6= starts descending BCP. call J0 initial
collapsing J (0 , w0 ) focus J0 .
Let Ji collapsing J (i , wi ) Ji focus Ji . obtain collapsing
Ji+1 = (Ji+1 , Ji+1 ) focus (i+1 , wi+1 ) J Ji according following two
cases:
1. element (, ) Ji (, ) smaller focus (i , wi )
(, ) (i , wi ). Ji+i obtained Ji renaming element (i , wi wi0 )
Ji (i wi , wi0 ).
2. element (, ) Ji (, ) smaller focus (i , wi )
(, ) (i , wi ). Let (, ) smallest element.
450

fiNominals, Inverses, Counting, Conjunctive Queries

(a) Ji+1 = Ji \ ({(i , wi wi0 ) | wi0 } {(, w) | w = c w0 , c IN, w0
, (i , wi ) predecessor (i , wi0 ) h(i , wi0 ), (i , wi )i f Ji
inverse functional role f rol(K) h(, c), (, )i f Ji });
(b) concept name con(K) (, w) Ji+1 , (, w) AJi+1 iff (, w)
AJi ;
(c) role name r rol(K) (1 , w1 ), (2 , w2 ) Ji+1 , h(1 , w1 ), (2 , w2 )i
rJi+1 iff
i. h(1 , w1 ), (2 , w2 )i rJi
ii. (1 , w1 ) predecessor (i , wi ) Ji (i.e., 1 = wi = w1 c
c IN), (2 , w2 ) = (, ), h(1 , w1 ), (i , wi )i rJi .
focus (i+1 , wi+1 ) Ji+1 smallest descending BCP (i , wi ) < (i+1 , wi+1 ).
collapsing Ji , let safe(Ji ) restriction Ji elements (, w)
(, w) Jj j i. J denote non-disjoint union interpretations
safe(Ji ) obtained subsequent collapsings Ji J . interpretation obtained
J interpreting nom(K) (, ) NoJ denoted collapse(J ) called
purified interpretation respect J. collapse(J ) |= K, call collapse(J ) purified
model K.
4
Figures 4 7 illustrate first collapsing steps unraveling depicted
Figure 3. Apart nominal placeholder concepts, concept interpretations
shown figures, assumed indicated Figure 3. edges
descending BCPs shown red color, dashed lines Figure 4 indicate levels
tree because, within tree, order nodes processed depends firstly
level. Within level, assume order increases left right.
numbers next nodes Figure 4 indicate, elements used focus element
collapsing step order. initial collapsing (Figure 4) focus
first non-root element starts BCP, indicate black border around
node black triangle pointing focus.
first collapsing step rename elements promote focus Figure 4
root. focus element highlighted Figure 5 starts BCP path sketch
different ones started smaller elements, rename elements
obtain new root (Figure 6). Now, focus nominal placeholder since nominal
placeholder BCPs, root path sketch use second case
Definition 17. resulting collapsing depicted Figure 7.
Finally, obtain collapsing unraveling shown Figure 3 one depicted
Figure 8.
show collapsing unraveling results forest model
K. aim is, however, show something general. want collapse
unravelings forest models, forest quasi-models obtained
another way. Unfortunately, case collapsing forest quasi-model
results forest model K since elements merge collapsing process
necessarily satisfy atomic concepts. define, therefore, following
admissibility criterion characterizes forest quasi-models collapsed
forest models.
451

fiRudolph & Glimm





r

r



H
1

r
3

4
f

f
r
g








f

r



g

g

5
f
g

r

H

g


r

r


2
g



r



f



r


f



Figure 4: initial collapsing un- Figure 5: first collapsing step
raveling depicted Figure 3.
rename elements promote
focus Figure 4 root.

r

r


f

r
r

r

r

f





H

r



g

g



f


f



r

r

g



g

g






N

f



g

f





r







Figure 6: collapsing obtained Figure 7: collapsing obtained using
one depicted Figure 5.
second case Definition 17
collapsing Figure 6.

Definition 18 (Collapsing-admissibility). Let J forest quasi-interpretation
ALCOIFb knowledge base K. J collapsing-admissible exists function
ch : (cl(K) J ) J
1. concept C = U.B cl(K) C J , h, ch(C, )i U J
ch(C, ) B J . Moreover, functional role f h, ch(C, )i f J
ch(C, ) successor ,
2. concept C = U.B cl(K) elements , 0 C J start descending
BCPs identical path sketches, h, ch(C, )i
= h 0 , ch(C, 0 )i.
4
Lemma 19. Let K ALCOIFb knowledge base. unraveling J model
K collapsing-admissible.
452

fiNominals, Inverses, Counting, Conjunctive Queries

B
B
B
B
B
{o} E f C E g E f C E g E f C E g



r






r




r




r

r

r
..
.

Figure 8: Result collapsing unraveling Fig. 3. infinitely many new root
elements displayed top line.

Proof. define function ch directly function choose used unraveling follows: C cl(K) (, w) J (, w) = 1 . . . n
choose(C, Tail(, w)) = { 0 }, set ch(C, (, w)) = (, w0 ) (, w0 ) = (1 . . . n 0 )
1 . . . n 0 sequence (, w0 ) = (1 . . . n1 ) otherwise.
well-defined since function unravelings total bijective required
admissibility since elements start BCPs identical path sketches always
generated element I. first condition collapsing-admissibility holds
since unravelings, always add 1 . . . n 0 set sequences unless pair
hn , n1 interpretation functional role. case, function ch uses
predecessor instead successor, still admissible.
Lemma 20. Let K consistent ALCOIFb knowledge base, J = (J , J ) strict forest
quasi-model K branching degree b collapsing-admissible. collapse(J )
forest model K branching degree b.
Proof. Let K0 = nomFree(K). Since J forest quasi-model K assumption, J |= K0 .
first show collapsing Ji J forest quasi-model K, i.e., Ji |= K0 .
show collapsing Ji+1 produced admissible collapsing Ji
collapsing-admissible. Finally, show that, nom(K), exactly one
node J form (, ) (, ) NoJ , implies Proposition 11
collapse(J ) forest model K.
start first claim: initial collapsing immediate since J
forest quasi-model K. particular, J0 locally K0 -consistent. Assume Ji
locally K0 -consistent collapsing (i , wi ) focus Ji . show Ji+1 locally
453

fiRudolph & Glimm

K0 -consistent. Since K0 simplified assumption, consider axioms
form (1).
Ji+1 obtained according first case Definition 17, rename elements
domain order create new root node local K0 -consistency immediate.
assume, thus, Ji+1
according second case Definition 17.
obtained
F
Axioms form Ai v Bj {o} (rewritten K0 ) hold
immediately due condition 2.b collapsings.
Let Ax axiom form v U.B assume (, w) AJ .
interesting elements predecessor (i , wi0 ) focus (i , wi ) (, ). However,
(i , wi ) (, ) and, since J collapsing-admissible, (i , wi ) (, ) satisfy
atomic concepts respect con(K). Further, interpretation atomic concepts
changed due 2.b, implies local K0 -consistency kind axioms.
Let Ax axiom form v U.B assume (, w) AJi+1 . concentrate three interesting cases direct neighborhoods elements change:
1. start case focus (i , wi ) corresponding U -successor
(, w), i.e., = , wi = wc c IN, h(, w), (i , wi )i U Ji , (i , wi ) B Ji .
Since (, ) (i , wi ) equivalence class assumption, (, )
starts BCP path sketch (i , wi ) (, ) (i , wi ) satisfy
atomic concepts respect con(K). condition 2.(c)ii. ensures
(, ) required U -successor (, w) Ji+1 .
2. Assume (, w) = (, ), h(, ), (, c)i U Ji , (, c) B Ji , (, c)
/ Ji+1 ,
J
i+1
(, )
/ (U.B)
. Due 2.a, focus (i , wi ) predecessor (i , wi0 )
0
h(i , wi ), (i , wi )i f Ji inverse functional role f rol(K) h(, ), (, c)i
(f )Ji . Since f inverse functional Ji is, assumption, locally K0 -consistent,
successor (i , wi ci ) (i , wi ) h(i , wi ), (i , wi ci )i (f )Ji .
Similarly, element (0 , w0 ) h(, ), (0 , w0 )i (f )Ji . Then,
since Ji collapsing-admissible, (i , wi0 ) ch(U.B, (i , wi )), (, c)
ch(U.B, (, )), h(i , wi ), (i , wi0 )i
= h(, ), (, c)i since (i , wi ) (, ) start
descending BCPs identical path sketches. particular, h(i , wi ), (i , wi0 )i U Ji
(i , wi0 ) B Ji . Then, condition 2.(c)ii., h(, ), (i , wi0 )i U Ji+1 , condition 2.b, (i , wi0 ) B Ji+1 , and, thus, (, ) (U.B)Ji+1 required.
3. assume (i , wi ) predecessor (i , wi0 ) h(i , wi0 ), (i , wi )i f Ji
inverse functional role f rol(K) h(, c), (, )i f Ji , causing deletion
(, c) descendants, one which, say (, v) connected (, ),
h(, ), (, v)i U Ji (, v) B Ji . Now, inverse functional role
g h(, ), (, v)i g Ji , strictness collapsing-admissibility Ji
ensure existence c0 h(, ), (, c)i U Ji (, c) B Ji and,
consequently, h(, ), (, c)i U Ji+1 (, c) B Ji+1 . h(, ), (, v)i g Ji
inverse functional role g, strictness initial collapsing implies
(, v) started descending BCP and, due defined order, must
focus root itself. contradicts, however, initial
assumption (, v) descendant (, ) done.
cases, elements Ji+1 required successors.
454

fiNominals, Inverses, Counting, Conjunctive Queries

Let Ax axiom form func(f ) f rol(K). concentrate relations
predecessor (i , wi0 ) focus (, ) since otherwise local K0 -consistency
immediate. predecessor exists focus since process elements ascending order starting non-root nodes. Assume h(i , wi0 ), (i , wi )i f Ji , case
h(i , wi0 ), (, )i f Ji+1 due 2.(c)ii. assume (, ) successor (, c) Ji
h(, c), (, )i f Ji . case, (, c)
/ Ji+1 according 2.a together
0
local K -consistency Ji , implies (i , wi0 ) element Ji+1
h(i , wi0 ), (, )i f Ji+1 .
show Ji+1 produced admissible collapsing Ji admissible collapsing. assumption, initial collapsing admissible, let Ji
admissible collapsing chi required function. distinguish two cases:
1. Let Ji+1 produced according first case collapsings. define function
chi+1 Ji+1 follows: C cl(K) Ji+1 , set chi+1 (C, ) = 0
0 = (i wi , w10 ) chi (C, ) = (i , wi wi0 ) (i , wi ) focus Ji 0 = chi (C, )
otherwise. Since change names elements leave interpretation
concepts roles before, function required admissibility.
2. Let Ji+1 produced according second case collapsings. define function
chi+1 Ji+1 follows: C cl(K),
(a) Ji+1
/ {(i , wi0 ), (, )} (i , wi0 ) predecessor focus
(i , wi ), set chi+1 (C, ) = 0 0 0 Ji+1 0 = chi (C, );
well-defined since successors (, ) (i , wi0 ) deleted Ji+1 .
(b) = (, ) (i , wi0 ) predecessor focus, chi+1 (C, ) = 0
0 = (i , wi0 ) chi (C, ) = (, c) (, c)
/ Ji+1 0 = chi (C, ) otherwise;
(c) = (i , wi0 ) predecessor focus, set chi+1 (C, ) = 0 0 = (, )
chi (C, ) = (i , wi ) 0 = chi (C, ) otherwise.
elements apart predecessor focus (i , wi0 ) root (, )
replaces (i , wi ), interpretation concepts roles remains
properties 2.b 2.c function required. (i , wi0 ), change
function cases (i , wi ) returned, (, ) returned. Since
(i , wi ) (, ), admissible. Similarly, successor (, c) (, ) contained Ji+1 , (i , wi0 ) used instead. admissible since, case,
h(i , wi ), (i , wi0 )i
= h(, ), (, c)i argued axioms form v U.B.
show that, nom(K), exactly one node J form
(, ) (, ) NoJ . Nominal placeholders descending BCPs definition and,
nominal placeholder becomes focus, merged root
equivalence class definition lower order. root exists
property FQ2 forest quasi-interpretations.
interpretation J obtained building non-disjoint union safe parts
collapsings, contain elements neither renamed deleted.
Thus, J contain nominal placeholders required. Considering one element
(, w) J , find successors root neighbors
455

fiRudolph & Glimm

(, w) Ji J . shown, Ji locally K0 -consistent
therefore (, w) consistent neighborhood. Hence J forest quasi-model K.
Now, interpreting nom(K) {(, ) J | (, ) NoJ } collapse(J ),
obtain forest model K, set roots {(, ) | (, ) J }.
bounded branching degree immediate consequence construction since
never add successors construction starting forest quasi-interpretation
J bounded branching degree assumption.
Since unravelings model K strict forest quasi-models K branching degree bounded |cl(K)| Lemma 13, unravelings collapsing-admissible
Lemma 19, immediate consequence Lemma 20 collapsing unraveling
yields forest model branching degree bounded |cl(K)|.
Corollary 21. Let K ALCOIFb knowledge base interpretation
|= K, purified interpretation collapse((I)) forest model K branching
degree b bounded |cl(K)|.
Since number roots might still infinite purified models, could,
now, obtained result unraveling arbitrary model, take
elements BCPs roots instead taking nominals creating new roots
collapsing process. next sections, however, show transform
unraveling counter-model query remains collapsing-admissible
end collapsed forest model finite number
roots still counter model query. transformation much
convenient work real (strict) trees forests, use (strict) forest
quasi-interpretations.
next sections, use following alternative characterization result
collapsing, comes handy subsequent proofs.
start defining so-called pruning forest quasi-interpretation, is,
roughly speaking, structure obtained deleting nodes, erased
course collapsing process anyway.
Definition 22 (Pruning). Let J strict forest quasi-model ALCOIFb knowledge
base K collapsing-admissible let J0 , J1 , . . . , J defined Definition 17.
pruning J (written prune(J )) obtained restricting J set J
defined follows: contains hw1 , w2 w3 J hw1 w2 , w3 J
hw1 w2 , w3 focus Ji .
4
use equivalence relation elements start descending BCPs
identical path sketches Definition 17 construct interpretation pruning
identifying equivalent nodes, known factorization.
Definition 23 (Factorization). Let K ALCOIFb knowledge base, J strict forest
quasi-interpretation K collapsing-admissible, L = prune(J ).
factorization L (denoted L/ ) defined forest quasi-interpretation = (M , )
= {[] | L };
456

fiNominals, Inverses, Counting, Conjunctive Queries

con(K), = {[] | AL },
r rol(K), rM = {h[] , [ 0 ] | h, 0 rL },
nom(K), oM = [] NoL .
4
Note interpretation nominals well defined as, definition,
-instances -equivalence class.
ready establish wanted correspondence: collapsing forest
quasi-interpretation essentially obtained first pruning factorizing it.
Lemma 24. Let J strict forest quasi-model ALCOIFb knowledge base K
let J collapsing-admissible. collapse(J )
= prune(J )/ . Moreover new roots
collapse(J ) correspond -equivalence classes contain J -elements start
descending BCPs J .
Proof. Considering first claim, note definition collapsing procedure,
every (w, w0 ) collapse(J ) exactly one pair w1 , w2 w = w1 w2
(w1 , w2 w0 ) prune(J ) . Moreover, case 1 construction assures collapse(J ) contains one element every -equivalence class prune(J )/ . Hence mapping
: collapse(J ) prune(J )/ (w, w0 ) = [(w1 , w2 w0 )] bijection and, consequence construction, isomorphism.
second claim direct consequence construction collapsing.

5. Quasi-Entailment Quasi-Models
section, provide characterization forest quasi-models mirrors query
entailment corresponding proper models. argumentation,
talk initial part tree, i.e., part left branches cut
fixed length. forest interpretation = (I , ) n IN, therefore denote
cutn (I) interpretation obtained restricting pairs (, w)
|w| n.
following lemma ensures case purified models, find finitely
many unraveling trees depth n look different.
Lemma 25. Let K consistent ALCOIFb knowledge base. purified
interpretation |= K and, every n IN, finitely many
non-isomorphic trees depth n.
Proof. Since K model assumption, Corollary 21 guarantees
purified model K. particular, forest model branching degree bounded
size cl(K).
compute maximal number non-isomorphic trees depth n
domain I. denote bound Tn . argumentation close one used
Levy Rousset (1998) definition tree blocking.
457

fiRudolph & Glimm

Let c = |cl(K)| r = |rol(K)|. first consider trees depth n = 0. 2c
choices different subsets concepts cl(K). n > 0, concept level 0
trigger generation new successor number successors
0 c. Assume, now, single role name r rol(K)
node level smaller n root tree depth n 1 exactly
c ) non-isomorphic sub-trees
c successors node. case, O(2c Tn1
depth n. Taking account node necessarily c successors,
c ) number nonchoose number 0 c, get bound O(2c cTn1
isomorphic sub-trees depth n. Finally, since one choice r roles,
c )r ). abbreviate 2c cr x rc rewrite
get bound O(2c (cTn1
n1
n
obtained bound Tn = O(x(Tn1 )a ). Unfolding yields Tn = O((x1+a+...+a )(T0 )a )
n
n
n
bounded O((xa )(2c )a ) = O((x2c )a ). expanding abbreviated symbols,
n
obtain bound Tn O((2c cr )(rc) ).
considerations, introduce notion anchored n-components.
meant certain substructures forest quasi-interpretations. first
place, substructures contain connected set nodes W 0 situated closely
together original structure, closeness witnessed fact elements W 0 descendants node distance n . Moreover
nodes 0 W 0 , anchored n-component may (but need to)
contain finite number descending BCPs starting 0 .
Definition 26 (Anchored Components). Let J forest quasi-interpretation J .
interpretation C called anchored n-component J witness C
created restricting J set W J obtained follows:
Let J subtree J started let J,n := cutn (J ). Select
subset W 0 J,n closed predecessors.
every 0 W 0 , let P finite set (possibly empty) descending BCPs p starting
0 let W0 contain nodes p P .

Set W = W 0 0 W 0 W0 .
4
think forest quasi-model J query q. following definition
lemma employ notion anchored n-components come notion quentailment (short quasi-entailment), criterion reflects query-entailment world
forest quasi-models.
Definition 27 (Quentailment). Let q conjunctive query ](q) = n J
forest quasi-model ALCOIFb knowledge base K. say J quentails q (written
J | q) if, V = var(q), J contains connected anchored n-components C1 , . . . , C`
C
according functions : V 2 following hold:
Q1 every x V , least one Ci , (x) 6=
Q2 A(x) q, (x) AJ i.
458

fiNominals, Inverses, Counting, Conjunctive Queries

Q3 every r(x, y) q Ci 1 (x) 2 (y)
h1 , 2 rJ .
Q4 If, x V , connected anchored n-components Ci Cj
(x) 0 j (x),
sequence Cn1 , . . . , Cnk n1 = nk = j
sequence 1 , . . . , k 1 = k = 0 well nm (x)
1 < k,
that, every 1 < k,
Cnm contains descending BCP p1 started ,
Cnm+1 contains descending BCP p2 started m+1 ,
p1 p2 path sketch.
union conjunctive queries u = q1 . . . qh , say J quentails u (written
J | u) J | q q {q1 , . . . , qh }.
4
Note anchored component may contain none, one several instantiations
variable x V . Intuitively, definition ensures, find matches query parts
fitted together identifying BCP-equal elements yield complete query match.
Lemma 28. Let u = q1 . . . qh union conjunctive queries K ALCOIFb
knowledge base.
1. model K, (I) | u implies |= u.
2. strict forest quasi-model J K collapsing-admissible, collapse(J ) |= u
implies J | u.
Proof.
1. Let q disjunct u (I) | q, V = var(q), C1 , . . . , C`
connected anchored n-components witnessing quentailment. use function
Tail Definition 12 exploit properties homomorphism. Note Tail
maps nodes (I) individual I, start descending BCPs
path sketches. Due condition Q4 Definition 27, implies,
every x V every 1 (x) 2 j (x), Tail(1 ) = Tail(2 ). Hence,
total function : V defined letting (x) = whenever Tail() =
(x) 1 `, well-defined. show query
match q examining atoms q:
every unary atom A(x), definition quentailment ensures
exist Ci Ci (x) AJ . Then, definition Tail,
follows (x) = Tail() AI .
Likewise, every binary atom r(x, y), definition quentailment ensures
exists Ci 1 , 2 Ci 1 (x) 2 (y)
well h1 , 2 rJ . Again, definition Tail, follows h(x), (y)i =
hTail(1 ), Tail(2 )i rI .
459

fiRudolph & Glimm

2. prove this, employ alternative characterization collapsings established
0
0
0
Lemma 24. Let 0 = (I , ) = prune(J )/ let : V match
q 0 . use construct anchored n-components functions needed
show J quentails q.
Let V V contain variables maps singleton -equivalence class.
define V = {V1 , . . . , Vm } finest partitioning V that,
x, V , x partition whenever r(x, y) q r rol(K).
Next, assign every partition V 0 V set QV 0 query atoms containing
variables V 0 . construct every V 0 anchored n-component CV 0
function V 0 (initialized yielding inputs) follows:
every x V 0 , let CV 0 contain J -element (x) = {}. Note
0
consists -equivalence classes elements J , i.e., {}
0
one -equivalence classes . Moreover, set V 0 (x) = V 0 (x) {}.
every r(x, y) QV 0 6 V 0 (x) = {}, let CV 0 contain additional element 0 (y) h, 0 rJ (existence assured definition
collapsing via factorization) elements descending BCP
prune(J ) starting (existence assured since [ 0 ] singleton class).
Moreover set V 0 (y) = V 0 (y) { 0 }.
Likewise, every r(x, y) QV 0 x 6 V 0 (y) = {}, let CV 0 contain
additional element 0 (x) h 0 , rJ (existence assured definition collapsing via factorization) elements shortest descending
BCP prune(J ) starting 0 (existence assured since [ 0 ] singleton
class). Moreover set V 0 (x) = V 0 (x) { 0 }.
furthermore construct, query atom contains variables V ,
anchored n-component Ca function (again initialized always return
) follows:
= r(x, y), let Ca contain two nodes 1 2 1 (x)
2 (y) h1 , 2 rJ (existence assured definition via factorization)
well prune(J )-descending BCP starting 1 shortest
prune(J )-descending BCP starting 2 .
= A(x), let Ca contain node (x) AJ (existence
assured definition via factorization) well shortest prune(J )-descending BCP starting .
Let C contain CV 0 Ca defined far. Note C already satisfies conditions
Q1-Q3 Definition 27. add anchored n-components
order satisfy condition Q4 well. Let C0 initially empty. x V
(x) non-singleton equivalence class two C , C C (x)
0 (x), that, since 0 -equivalence class (x),
sequence 1 , . . . , k J -nodes = 1 0 = k every
i+1 start descending BCP path sketch. enhance C0 one
anchored component per contains corresponding descending
460

fiNominals, Inverses, Counting, Conjunctive Queries

(x1 )

r

r



{o}
E




BC
E

f

(x2 )

g

(x5 )

r




BD
E

(x3 ) f

r

r



BC
E

BD
E

g

(x4 )

r



BC
E
g

f





E
r

C1


1 (x1 )
r


1 (x2 )

C2

BC
E

r



BD
2 (x5 )1 (x3 )
E

f

g

BC
E

BD
f
2 (x3 )
E

f

r

BC
2 (x4 )
E



E
..
.

r




BD
E

r




BC
E

g

BC
E

g

BC
E

BD
E

f

BD
E

f

BD
E

f

r
..

.



g

g
..

E
..
.

g
..

.

.

E
..
.

..

.

Figure 9: Correspondence entailment quentailment.
BCPs. Then, construction, elements CC0 constitute necessary anchored
n-components justify J quentails q and, thus, J quentails u.

example correspondence (query) entailment quentailment,
consider conjunctive query
q = {r(x1 , x2 ), s(x2 , x3 ), f (x4 , x3 ), s(x5 , x4 )}.
match query example model Figure 2 displayed upper
part Figure 9, witnesses |= q. lower part, anchored components C1
C2 according functions 1 2 establish (I) | q.

6. Limits Forest Transformations
introducing following constructions detail, try provide highlevel explanation convey intuition behind subsequent steps. mentioned before,
one major obstacles decision procedure conjunctive query entailment
461

fiRudolph & Glimm

DLs including inverses, nominals, cardinality restrictions (or alternatively functionality), potentially infinitely many so-called new nominals: domain elements
identified linked proper nominal via BCP.
However, show every model knowledge base satisfy
conjunctive query (i.e., every countermodel), nice countermodel
finitely many new nominals (in subsequent section, argue ensures
existence procedure terminates query entailed knowledge
base question). provide construction transforms arbitrary countermodel
nice one first unraveling quasi forest model, substituting new
nominals uncritical elements finally collapsing result back proper model.
this, find appropriate substitutes new nominals.
substitutes fit environment without introducing new nominals.
Due global cardinality constraints BCPs impose elements, existence infinitely many new nominals implies witnessing BCPs must get
longer longer, looking finite-distance neighborhood,
new nominals look non-nominal domain elements. state affairs
exploited essentially constructing new domain elements environment-limits.
way, new domain elements characterized property
approximated arbitrary precision already present domain elements possibly without present domain.3 see following new
domain elements serve substitutes looking for.
Definition 29 (Limits Model). Let = (I , ) model
ALCOIFb knowledge base K. tree interpretation J said generated (written:
J C ), isomorphic restriction (I, ) elements {(, cw) | (, cw)
(I,) , c 6 H} H IN.
set limits (written lim I) set tree interpretations J
every k IN, infinitely many cutk (L)
= cutk (J )
L C .
4
Figure 10 displays one limit element example model.
following lemma gives useful properties limits. Besides rather obvious compatibility considerations respect knowledge base satisfaction, claim 3
Lemma 30 provides us pleasant useful insight root node limit
never part BCP all.
Lemma 30. Let K ALCOIFb knowledge base, K0 = nomFree(K), purified model
K, n fixed natural number. following hold:

1. Let L0 tree interpretation infinitely many L0 =
cutn (L) LC. Then, least one limit J lim cutn (J )
=
L0 .
2. Every J lim locally K0 -consistent apart root (, ).
3. analogy, consider fact real number approximated sequence rational
numbers, even irrational.

462

fiNominals, Inverses, Counting, Conjunctive Queries






BC
E



BD
E

f

BD
E



BC
E

g

BC
E

g

BC
E



BD
E

f

BD
E

f

BD
E

f

BD
E

BC
E

g

BC
E

g

BC
E

g

BC
E

g




.

r
..

r

r

r



r

f

..

f
.

..

f
.

..

f
.

..

BC
E
f

.

..

.

Figure 10: One limit model Fig. 2
3. every J lim holds root (, ) BCP (, w) J .
4. J lim contains node starting two backwards counting paths path sketches
s1 s2 , element unraveling holds: direct neighborhood
isomorphic starts descending BCP path sketch s1
starts descending BCP path sketch s2 .
5. Every J lim collapsing-admissible.
Proof.
1. Let b branching degree I, let Dn (by assumption infinite) set
L0
= cutn (L) L C , let Jn contain L.
Starting k = n, iteratively increase k construct sets Jk Dk
tree interpretations Lk . way, inductively prove properties.
induction hypothesis know Dk infinite Lk Lk
=
cutk (M) Jk . Lemma 25, finitely many non-isomorphic
tree interpretations depth k + 1 branching degree b, partition
Jk finitely many sets Jk,1 , . . . , Jk,m every two M, M0 Jk,i
satisfy cutk+1 (M)
= cutk+1 (M0 ). Likewise, define classes Dk,1 , . . . , Dk,m
Dk = Dk,1 . . . Dk,m Dk,i L C L Jk,i . Now,
Dk infinite, one Dk,i must infinite well set Dk+1 = Dk,i
Jk+1 = Jk,i . Hence, know Dk+1 infinite Lk+1
Lk+1
= cutk+1 (M) Jk+1 .
Thus, established infinite sequence Ln , Ln+1 , . . . Li
= cuti (Lj )
j > i. Without loss generality, assume isomorphic nodes named
identically, i.e., even Li = cuti (Lj ) j > i. define J
(non-disjoint) union Li . way established structure J
cutk (J ) = Lk know every k infinitely many (namely
elements Dk ) cutk (L)
= Lk L C . Hence J limit
element desired properties.
2. Let (, w) w 6= node J . choose cut|w|+1 (L)
=
cut|w|+1 (J ) L C (by definition, even infinitely many
463

fiRudolph & Glimm

choose from). L contains node whose direct neighborhood isomorphic
(, w). However, L contained (I, ) |= K assumption,
locally K0 -consistent hence is. Therefore (, w) locally K0 -consistent J .
3. Assume contrary, i.e., J lim BCP root (, )
(, w) J (, w) NoJ nom(K). Since functionality
definition BCPs, BCP uniquely identifies one domain individual.
definition lim I, however, infinitely many satisfying cut|w| (L)
=
cut|w| (J ) J C infinite number individuals
counting path oI . contradiction.
4. Choose k maximum length two BCPs. definition limit,
contains element cut|w|+k (L)
= cut|w|+k (J ) L C . Now,
let 0 L element (with respect isomorphism) corresponds
J . Then, 0 origin two descending BCPs path sketches s1
s2 . Let Tail( 0 ) = 0 . Since path sketches descending BCPs uniquely identify one
domain individual, every node unraveling starts descending BCP
path sketch s1 must caused 0 well. Furthermore (as
direct neighborhoods isomorphic specific design choose function
Definition 12 renders successors non-isomorphic), successors
uniquely correspond neighbors 0 turn successors 0 .
turn implies that, every successor , one finds successor 0
isomorphic direct neighbourhood. Yet, synchronicity argument inductively
applied thereby iterated BCP. Thus, obtain starts
descending BCP path sketch s2 .
5. define function ch : (cl(K) J ) J essentially proof
Lemma 19, namely referring function choose. given element J
starts BCP length ` J , choose 0 cut||+` (L)
= cut||+` (J )
L C 0 . L contained (I, 0 ), proceed define ch(C, )
demonstrated proof Lemma 19.

defined limit elements convenient building blocks restructuring forest
quasi-interpretations, following definition provides first hints inside
structure one existing node (and successors) safely exchanged limit
element.
Definition 31 (n-Secure Replacement). Let K ALCOIFb knowledge base, model
K, J forest quasi-model K J . strict tree quasi-interpretation
J 0 lim called n-secure replacement
cutn ((J , )) isomorphic cutn (J 0 ),
every anchored n-component J 0 witness 0 , isomorphic anchored
n-component J witness .
464

fiNominals, Inverses, Counting, Conjunctive Queries

E







.
..

BC
E

BD
E

f

BD
E


=



BC
E

g

BC
E

g

BC
E



BD
E

f

BD
E

f

BD
E

f

BD
E

BC
E

g

BC
E

g

BC
E

g

BC
E

g

r
/



r

r



r



f

..

f
.

..

f
.

..

f
.






r

..

BC
E
f

.

..



BD
E
g



r

BC
E

BD
E

f



BC
E

g

BC
E



BD
E

f

BD
E

f

BC
E

g

BC
E

g

BC
E

r

r

r

f
..



r





.



..


r



r

.

BD
E
g

f
..

.

BD
E
g

f
..

E
..
.
E
..
.
E
..
.

.

.

Figure 11: Forest quasi-model (right) according 3-secure replacement (left).
J n-secure replacement lim I, call n-replaceable w.r.t. I, otherwise
call n-irreplaceable w.r.t. I.
4
Figure 11 displays 3-secure replacement considered unraveling example
model.
defined elements forest quasi-model eligible replaced
limit element, make sure many elements (actually defined
terms original model) exempt replaced.
Lemma 32. Every purified model ALCOIFb knowledge base K contains
finitely many distinct elements start BCP cause n-irreplaceable nodes
unraveling I.

Proof. Assume converse: let purified model K contain infinite set elements
giving rise n-irreplaceable nodes (I). must L0
infinite set D0 every d0 D0 generates L cutn (L)
= L (since
Lemma 25, finitely many non-isomorphic choices L0 ). set D0
used guide construction specific limit element J lim according Lemma
30.1. Now, element (, w) J starting BCP, let l(,w) length
shortest BCP starting (, w). Then, let k maximum l(,w)
individuals (, w) J start BCP |w| n. construction, D0
contains one element d00 generating L cutk (L)
= cutk (J ) (actually infinitely many).
choice k Lemma 30.4, conclude J n-secure replacement
irreplaceable (I)-node caused d00 contradicts fact d00 D.
know, elements forest quasi-model replaced suitable limit
element. following definition exactly tells us, replacement carried out:
respective element successors deleted limit element (together
successors) inserted position.
465

fiRudolph & Glimm

E



BC
E

BD
E

f



BC
E

g

BC
E

BD
E

f

BD
E

f



BC
E

g

BC
E

g

BC
E



BD
E

f

BD
E

f

BD
E

f

BD
E

BC
E

g

BC
E

g

BC
E

g

BC
E

g





..

.

r

f

..

r


r

r


r

r



r






r

f

..

.

f
.

..

f
.

E
..
.
E
..
.

..

BC
E
f

.

..

.

Figure 12: Result replacing element 3-secure replacement depicted Figure 11. inserted component highlighted.

Definition 33 (Replacement Step). Let K ALCOIFb knowledge base, model
K, J forest quasi-model K, i.e., J |= K0 = nomFree(K). Let (, w) J
n-replaceable w.r.t. J 0 according n-replacement (, w) lim root
(, ).
define result replacing (, w) J 0 interpretation R
0

J
00
00
J
J
0
0
R = J
red {(, ww ) | (, w ) } red = ( \ {(, ww ) | |w | > 1})
0

0
0
J
con(K0 ), AR = (AJ J
red ) {(, ww ) | (, w ) }
J
0
00
0
00
r rol(K0 ), rR = (rJ J
red red ){h(, ww ), (, ww )i | h(, w ), (, w )i
0
rJ }
4

Figure 12 displays result carrying replacement step example.
following lemma assures replacement described above, new
anchored n-components introduced, instead anchored n-components present
n-secure transformation present completely contained inserted limit
element.
Lemma 34. Let K ALCOIFb knowledge base, model K, J forest quasimodel K, i.e., J |= K0 = nomFree(K), let (, w) J n-replaceable w.r.t. I. Let
J 0 n-replacement (, w) root (, ) R result replacing (, w)
J 0 . following hold:
1. cutn ((J , (, w))) isomorphic cutn ((R, (, w))).
466

fiNominals, Inverses, Counting, Conjunctive Queries

2. n 1, R locally K0 -consistent.
3. Whenever R contains anchored n-component C, one J J 0 contains
anchored n-component isomorphic C.
Proof.

1. direct consequence Definitions 31 33.

2. make case distinction element-wise investigating local consistency R
(note K K0 simplified local consistency node (, v) R
depends node direct neighbors):
v = ww0 w0 6= : direct neighborhood (, v) R isomorphic direct neighborhood (, w0 ) J 0 (recall (, ) root
J 0 ). Lemma 30.2, J 0 locally K0 -consistent except possibly (, ). Hence
(, v) locally K0 -consistent R.
v 6= ww0 w0 , i.e., (, v) affected replacement:
direct neighborhood (, v) changed replacement and, therefore,
neighborhoods (, v) J R coincide. J locally K0 -consistent
assumption, (, v) R.
v = w: case, direct neighborhood (, v) changed remained
isomorphic. follows preceding statement (34.1).
3. Let (0 , w0 ) witness C. distinguish three cases:
0 = w prefix w0 . Then, clearly C completely contained J 0 .
0 = w0 prefix w. Let C 0 structure obtained restricting C
elements form (, ww00 ) renaming every element (, ww00 )
(, w00 ), (, ) root J 0 . C 0 anchored n-component
J 0 witness (, ). Now, definition replacing, J must contain
isomorphic copy C 0 witness (, w). Since part C (consisting
nodes (0 , w0 ) w prefix w0 ) altered
replacement, conclude J must contain isomorphic copy C.
Neither above. Then, (0 , w0 ) subtree rooted (0 , w0 ) contained
J part J affected replacement. Then, clearly
C contained J .

ready defining whole process restructuring forest quasi-model
essentially substituting many nodes possible appropriate limit elements.
Definition 35 (n-Secure Transformation). Let model ALCOIFb knowledge
base K J unraveling I. interpretation J 0 called n-secure transformation
J obtained (possibly infinitely) repeating following step:
Choose one unvisited w.r.t. tree-depth minimal node (, w) n-replaceable
w.r.t. I. Replace (, w) one n-secure replacements lim mark (, w)
visited.
4
467

fiRudolph & Glimm

B
B
E f C E g E





BD
E

f

BD
E



BC
E

g

BC
E

g

BC
E



BD
E

f

BD
E

f

BD
E

f

BD
E

BC
E

g

BC
E

g

BC
E

g

BC
E

g

r

r

r
.

r





..



r

BC
E

r





r







r

f

..

f
.

..

f
.

..

f
.

..

BC
E
f

.

..

.

Figure 13: Result collapsing forest quasi-model displayed Figure 12.
Note well-defined every node visited formerly
irreplaceable node ever becomes replaceable. Hence every k IN, initial segment
cutk (J ) current intermediate structure J already isomorphic initial segment
cutk (J 0 ) J 0 bounded number replacement steps, due fact involved
structures bounded branching degree.
now, whole effort might still look bit contrived pointless, however,
following lemma establishes bunch properties end allow us deduce
existence well-behaved countermodel whenever all.
show process unraveling, n-secure transformation collapsing preserves property model knowledge base (with right choice n)
preserves property entailing conjunctive query. Moreover, model conversion process ensures resulting model contains finitely many new nominals
(witnessed bound length BCPs). Figure 13 illustrates properties
example model. Note two new nominals left whereas collapsing original
unraveling yields infinitely many.
Lemma 36. Let purified model ALCOIFb knowledge base K, J unraveling I, J 0 n-secure transformation J . following hold:
1. J 0 strict forest quasi-model K.
2. J 0 collapsing-admissible.
3. collapse(J 0 ) model K.
4. natural number J 0 contain node whose shortest
descending BCP length greater m.
468

fiNominals, Inverses, Counting, Conjunctive Queries

5. J 0 contains anchored n-component C, J contains anchored n-component
isomorphic C.
6. If, union conjunctive queries u = q1 . . . qh , J |6 u n >
maxq{q1 ,...,qh } ](q), J 0 |6 u.
7. If, union conjunctive queries u = q1 . . . qh , 6|= u
n > maxq{q1 ,...,qh } ](q), collapse(J 0 ) 6|= u.
Proof.
1. Let K0 = nomFree(K). Due Lemma 13, J strict forest quasi-model
K. Lemma 34.2, replacement step preserves local K0 -consistency results, thus, forest quasi-model K. Since n-replacement strict tree
quasi-interpretation strictness preserved. induction follows every interpretation produced n-secure transformation procedure strict forest quasimodel K. every node J 0 , direct predecessor direct successors
changed finitely many replacement steps local K0 -consistency
depends solely neighbors. Hence J 0 locally K0 -consistent.
2. Lemma 19, J collapsing-admissible, Lemma 30.5 every limit is. Moreover, obvious proofs propositions, possible define
respective ch-functions recurring original choose-function I, hence every
two elements (even different) unravelings limits start descending BCPs
identical path sketches correspond element whence
separate ch-functions compatible other. Therefore, replacing element unraveling yields strict forest quasi-model collapsing-admissible.
Applying argument inductively yields every intermediate strict forest
quasi-model n-secure transformation collapsing-admissible. Finally,
according ch-function stabilizes finitely many replacement steps (together
neighborhood considered elements), J 0 collapsing-admissible.
3. follows two previous facts (36.1 36.2) together Lemma 20.
4. Consider set causing n-irreplaceable nodes J . Lemma 32,
finite. obtain D0 removing start descending
BCPs.
D0 , let dBCP() denote set descending BCPs starting choose

:= max0


min


|p|

pdBCP()

assume 0 shortest descending BCP length greater
m. Obviously, 0 6 D0 , must (, w) generated 0 nreplaceable. However, n-secure transformation n-replaceable elements
replaced elements start descending BCPs due
Lemma 30.3.
469

fiRudolph & Glimm

5. prove induction replacement steps n-secure transformation
process showing true every intermediate replacement result R0 .
claim J 0 follows fact that, every considered C (which
always finite), finite part cut` (J 0 ) relevant every `,
bounded number replacement steps cut` (R0 ) = cut` (J 0 )
every intermediate R0 .
base case (zero replacement steps carried out), find R0 = J , claim
trivially true.
assume claim established R shown R0
created replacing (, w) R J 00 . Lemma 34.3, know
one following case:
R contains C. Yet, apply induction hypothesis conclude
J contains C claimed.
J 00 contains C. But, since C finite, already contained cutk (J 00 )
k and, J 00 limit element, find one cutk ((I, )) =
cutk (J 00 ). Since purified, find (, w) J corresponds , i.e.,
J contains isomorphic copy (I, ) turn contains isomorphic
copy C.
6. actually straightforward consequence preceding proposition
definition quentailment.
indirect proof, suppose J |6 u n > maxq{q1 ,...,qh } ](q) J 0 | u,
latter witnessed J 0 | q q {q1 , . . . , qh }. definition, latter assures
existence adequate anchored n-components J 0 . Then, applying preceding
proposition (36.5), obtain isomorphic copies anchored n-components contained J which, definition, means J | q and, therefore, J | u.
Hence, contradiction, proves claim.
7. prove indirectly, assume 6|= u, n > maxq{q1 ,...,qh } ](q), collapse(J 0 ) |=
u, witnessed collapse(J 0 ) |= q q {q1 , . . . , qh }.
Then, Lemma 28.2, follows J 0 | q. previous proposition (36.6),
conclude J | q, turn implies |= q Lemma 28.1. implies |= u,
contradiction.

able establish first milestone way showing finite representability countermodels.
Theorem 37. every ALCOIFb knowledge base K K 6|= u, forest model
K finitely many roots 6|= u. Moreover, bounded branching degree.

470

fiNominals, Inverses, Counting, Conjunctive Queries

Proof. Let u = q1 . . . qh . Since inconsistent knowledge base entails every query,
assume K consistent and, since K 6|= u, model K 6|= u.
Choose n > maxq{q1 ,...,qh } ](q) let J 0 obtained carrying n-secure
transformation (I) let 0 = collapse(J 0 ). know 0 model K (via
Lemma 36.3) 0 6|= u (by Lemma 36.7).
Lemma 36.4, know fixed natural number shortest
descending BCP started node J 0 shorter m. Note
finitely many path sketches length m. means every node J 0 starts
descending BCP assigned one path sketch. However, entails
finitely many elements (i.e., -equivalence classes) 0 contain
J 0 -elements starting descending BCPs J 0 . implies, via Lemma 24, 0 contains
finitely many roots.
fact 0 bounded branching degree direct consequence fact
initial unraveling bounded branching degree, replacement change
branching degree collapsings assured Lemma 20.

7. Finite Representations Models
section, show construct finite representation forest model
knowledge base finite number roots. show
finite representations used check query entailment. order this, use
technique similar blocking techniques used tableau algorithms (see, e.g.,
Horrocks & Sattler, 2007). tableau algorithm builds so-called completion graph
finite representation model. completion graph essentially structure
forest quasi-models. contains root nodes nominals occurring input
knowledge base plus root nodes new nominals start BCPs. (new
old) nominal root tree, relations occur direct neighbors within
tree, elements within tree root, roots. initial completion
graph contains nodes nominals occurring input knowledge base. Concepts
expanded according set expansion rules, new nodes added graph
expanding existential restrictions. New nominals added so-called NN-rule
whenever element within tree relationship inverse functional role
root node represents nominal input knowledge base, i.e., BCP
created. order obtain finite representation, tableau algorithms usually employ
cycle detection mechanism, called blocking. Otherwise depth trees
number new nominals might grow infinitely. logics expressive ALCOIFb,
blocking usually requires two pairs elements. notation, (non-root) node n
predecessor n0 blocks node predecessor m0 , hn0 , ni
= hm0 , mi. order
obtain real model finite representation, part n copied
appended infinitely often. use similar technique obtain finite representation
forest model. Since want preserve non-entailment, working pairs
elements sufficient. Instead, take length n query account use
isomorphic trees depth n define blocking. technique first employed
deciding query entailment ALCN role conjunctions (Levy & Rousset, 1998)
recently extended logics ALCHIQ, ALCHOQ, ALCHOI (Ortiz, 2008;
471

fiRudolph & Glimm

Ortiz et al., 2008a) extends, result, DLs SHIQ, SHOQ, SHOI (i.e.,
transitivity) long query contains simple roles.
forest quasi-interpretations, use isomorphisms forest interpretations
parts them.
Definition 38 (Isomorphism Forest Interpretations). Let K ALCOIFb
0
0
knowledge base = (I , ), 0 = (I , ) two forest interpretations K. Without
loss generality, assume root = (, ) extension
unique concept N occur con(K). 0 called isomorphic
0
w.r.t. K, written:
=K 0 , iff bijection : that:
1 successor 2 iff (1 ) successor (2 ) 1 , 2 ,
0

h1 , 2 rI iff h(1 ), (2 )i rI 1 , 2 r rol(K),
0

AI iff () AI con(K) {N | = (, ) }.
0

= oI iff () = oI nom(K).
4
Usually, omit subscript K
=K assume clear context.
Definition 39 (n-Blocking). Let n fixed natural number = (I , )
(, w) , w 6= forest interpretation ALCOIFb knowledge base K.
n-blocking-tree w.r.t. (, w), denoted blocknI (, w), interpretation obtained
restricting elements {(, ww0 ) | |w0 | n} {(, ) | (, ) }. n-blocking-tree
blocknI (, w) n-blocks n-blocking-tree blocknI (, ww0 )
1. blocknI (, w) blocknI (, ww0 ) disjoint domains except root elements,
2. bijection elements blocknI (, w) elements blocknI (, ww0 )
witnesses blocknI (, w)
= blocknI (, ww0 ),
3. descendant (, wv) (, w), inverse functional role f root
(, ) h(, wv), (, )i f .
node (, v) n-blocked, (, v) either directly indirectly n-blocked ; (, v)
indirectly n-blocked, one ancestors n-blocked; (, v) directly n-blocked none
ancestors n-blocked (, v) leaf n-blocking-tree blocknI (, ww0 )
n-blocked; case say (, v) (directly) n-blocked (, ww0 )
bijection witnessing
=.
Without loss generality, assume n-blocking-trees used minimal
w.r.t. order elements (cf. Definition 16).
forest interpretation = (I , ) K n-representation K
1. finite,
2. contains indirectly n-blocked nodes,
3. nom(K), one element form (, ) oI =
(, )I ,
472

fiNominals, Inverses, Counting, Conjunctive Queries

4. element directly n-blocked locally K-consistent.
4
Note n = 1 restrictive standard pairwise blocking since two trees
depth one need isomorphic blocking occurs, whereas standard blocking
already occurs two isomorphic pairs nodes. DLs expressive ALCOIFb,
however, n greater 0 (at least trees depth 1) want transform
n-representations models knowledge base. show knowledge
base n-representation fixed n and, afterwards, use
n-representation build model knowledge base.
Lemma 40. Let K consistent ALCOIFb knowledge base u = q1 . . . qh union
conjunctive queries n fixed natural number greater max1ih |qi |. K 6|= u,
n-representation K satisfy u.
Proof. assumption, K consistent K 6|= u. Then, Theorem 37, forest
model K finitely many roots branching degree bounded |cl(K)|,
q {q1 , . . . , qh } holds 6|= q. show find n-representation R I.
use similar argumentation Lemma 25 show finitely many
non-isomorphic n-blocking trees. denote bound Tn . Let c = |cl(K)|, r =
|rol(K)|, (finite) number roots I. root annotated
special concept N assumption. n = 0, 2c choices. n > 0,
element 0 c successors 0 relations roots.
roots 2c+m choices concepts. use 2cm bound choice
concepts roots clearly bounds choice non-roots well. non-root
node level smaller n root tree depth n 1 node
sub-tree relations root. Assuming single
cm ) number non-isomorphic
role name r rol(K), get bound O(2c cmTn1
sub-trees depth n relations roots. Since one
cm )r ). abbreviate 2c (cm)r
choice r roles, get bound O(2c (cmTn1
x cmr rewrite obtained bound Tn = O(x(Tn1 )a ). Unfolding
n
n1
n
n
n
yields Tn = O((x1+a+...+a )(T0 )a ) bounded O((xa )(2c )a ) = O((x2c )a ).
n
expanding abbreviated symbols, obtain bound Tn O((2c (cm)r )(cmr) ).
Together fact obtained collapsing relations elements
within tree root collapsings never inverse functional roles, shows
n-representation tree rooted node (, )
depth greater Tn , two nodes (, w) (, ww0 ) blocknI (, w)
n-blocks blocknI (, ww0 ), simply discard indirectly n-blocked nodes
obtain desired n-representation.
Since 6|= q n-representation restriction I, non-entailment q clearly
preserved.
Please note would obtain bound fixed bound
number new nominals (roots) beforehand cannot use standard tableau
algorithms obtain result. reason number new nominals
(roots) tableau algorithms depends length longest path blocking
473

fiRudolph & Glimm

occurs. n-blocking-trees, however, consider relations back
roots, means blocking occurs later roots have.
hand, delaying blocking may lead introduction new roots. Due
cyclic argument, termination cannot guaranteed tableau algorithms unless
fixed bound number new nominals beforehand. reason
tableau algorithm entailment conjunctive queries simple roles
query Calvanese et al. (2009) sound, complete, terminating SHIQ, SHOQ,
SHOI knowledge bases, guaranteed terminate SHOIQ knowledge
bases (transitivity, i.e., DL instead ALC impact
this).
show, obtain model knowledge base K nrepresentation K. use technique directly inspired tableau algorithms
resembles process building tableau complete clash-free completion
graph. particular tableau algorithm Ortiz et al. (Ortiz, 2008; Ortiz et al., 2008a)
similar uses tree blocking.
Definition 41 (Models n-Representations). Let R = (R , R ) n-representation
0
0
ALCOIFb knowledge base K. Let = 11 , . . . ,
sequence pairs elements

R
0
. |s| denote length s. sequence s, set last (s) =
0

0

0

0

m+1
last (s) = . | m+1
denote sequence 11 , . . . ,
, m+1 .
m+1
set R-induced elements, denoted elem(R), inductively defined follows:

= (, ) R ,




elem(R).

elem(R), = (, w) R , n-blocked, successor last (s),
| elem(R).
elem(R), = (, w) R , directly n-blocked 0 R ,
0
successor last (s), | elem(R).
define interpretation = (I , ) induced R follows:
= elem(R),
con(K), AI iff last (s) AR ,
nom(K), = oI iff last (s) = ,
s, s0 r rol(K), rI =
{hs, s0 | s0 = |
{hs, s0 | = s0 |
{hs, s0 | s0 =
{hs, s0 | =

0

0


hlast (s), last (s0 )i rR }
hlast (s), last (s0 )i rR }



hlast (s),

0
h, last (s )i

rR }
rR }.
4

interpretation nominals well-defined since n-representations forest interpretations K (hence, unique root nominal) pairs = (, )
never appended sequences elem(R).
474

fiNominals, Inverses, Counting, Conjunctive Queries

Lemma 42. Let K consistent ALCOIFb knowledge base, u = q1 . . . qh union
conjunctive queries, n 1 fixed natural number greater max1ih |qi |. R
n-representation K R 6|= u, model K 6|= u.
proof essentially one Ortiz et al. (2008a), adapted case,
work completely interpretations. n-representations correspond completion
graphs models tableaux case.
Proof. Let interpretation induced R. Since n-representations contain
relations element within tree root inverse functional role definition,
functionality restrictions violated I. Further, since K simplified R forest
interpretation K elements apart (directly) n-blocked ones locally
K-consistent, quite straightforward element induced interpretation
locally K-consistent. Together restriction nominals (property 3), implies
model K. essentially principle one used prove
tableaux constructed completion graphs proper representations models
input knowledge base.
Assume, contrary shown, |= u. disjunct
q {q1 , . . . , qh } match q |= q. use construct match
q R shifting mapping variables parts direct counterpart
R upwards.
define match graph G q undirected graph containing node
(x) = x var(q) containing edge hs, s0
s, s0 atom r(x, y) q, (x) = s, (y) = s0 . call nodes
G correspond roots root nodes G (i.e., nodes = )
call nodes tree nodes. Note restriction G tree nodes set trees
refer G1 , . . . , Gk tree depth smaller n.
x var(q) (x) = ( root node G), set (x) = last ( ).
Note root node R.
Gi {G1 , . . . , Gk }, distinguish two situations:
1. Gi contains node last (s) 6= last (s) (i.e., Gi contains path within
n-blocking tree copy path starting node blocks). Due
use n-blocking, single tree Gi never cover one n-blocking
tree use nodes two n-blocking trees (leaving one
entering next one less n steps). node s0 Gi |s0 | < |s|
x var(q) (x) = s0 , set (x) = (last (s0 )). s0 Gi
|s0 | |s| x var(q) (x) = s0 , set (x) = last (s0 ).
2. Gi contains node last (s) 6= last (s) (i.e., Gi contains path lies
completely within n-blocking tree path outside n-blocking-tree
n-blocking-tree). node Gi x var(q) (x) = s, set
(x) = last (s).
definition , induced model R, n-blocking, immediately
that, A(x) q, (x) AR . show that, r(x, y) q, h(x), (y)i rR ,
proves R |= q. distinguish three cases:
475

fiRudolph & Glimm

1. (x) = R . (x) = = (, ) R . distinguish three cases
(y):
0

(a) (y) = 0 root, (y) = 0 = (0 , ) R and, since match
q definition induced interpretation R,
h(x), (y)i = h, 0 rR .
0

(b) (y) successor (x) I, i.e., (y) = = | 0 . n-blocked
(y) = 0 = (0 , c) R c IN. Again, since match q
definition induced interpretation R,
h(x), (y)i = h, 0 rR .
0

(c) (y) neither root ((y) 6= 0 0 R ) successor (x)
0
((y) 6= | 0 0 R ). (y) belongs graph match component Gi (y) = last ((y)) (y) = (last ((y))). Since isomorphism
n-blocking trees takes relations root nodes account
parts direct counterparts R, h(x), (y)i rR .
0

2. (x) = 6= R . cases (y) = 0 0 R
above. assume, therefore, (y) = s0 |s0 | > 1. definition I,
means either = s0 | 0 s0 = s| 0 , 0 R . assume s0 = s| 0 .
opposite case analogous. definition match graph G, component
Gi G contains s0 . distinguish two cases:
(a) component Gi contains node last (s) 6= last (s).
interesting case last ((y)) 6= last ((y)), i.e., = s0 . (x) =
(last (s)) (y) = last (s0 ). Since last (s0 ) 6= last (s0 ), last (s0 )
node directly n-blocks last (s0 ) and, definition bijection
, witnesses isomorphism, (x) = (last (s))
predecessor (y) = last (s0 ) and, definition R, h(x), (y)i
rR .
(b) component Gi contains node last (s) 6= last (s). (x) =
last ((x)) (y) = last ((y)). definition R, immediately
h(x), (y)i rR .
case, h(x), (y)i rR , implies R |= q contradicting initial
assumption.
Lemma 40 guarantees that, case K 6|= q, always finite n-representation
R K R 6|= q Lemma 42 guarantees R transformed
model K 6|= q. suffices show enumerate (finite)
n-representations K check whether entail disjunct union conjunctive
queries. Together semi-decidability result FOL, get following theorem.
Theorem 43. Let K ALCOIFb knowledge base u = q1 . . . qh union
conjunctive queries. question whether K |= u decidable.

476

fiNominals, Inverses, Counting, Conjunctive Queries

8. Conclusions
solved long-standing open problem deciding conjunctive query entailment
presence nominals, inverse roles, qualified number restrictions. shown
problem decidable providing decision procedure proving correctness.
Since approach purely decision procedure, computational complexity
problem remains open.
result shows decidability entailment unions conjunctive queries
SHOIQ SROIQ (underlying OWL DL OWL 2) disallow non-simple roles
binary query predicates. thereby reached first important milestone towards
tackling problem conjunctive queries OWL 1 DL OWL 2 DL.
Entailment unions conjunctive queries closely related problem
adding rules DL knowledge base, e.g., form Datalog rules. Augmenting
DL KB arbitrary Datalog program easily leads undecidability (Levy & Rousset,
1998). order ensure decidability, interaction Datalog rules
DL knowledge base usually restricted imposing safeness condition. DL+log
framework (Rosati, 2006a) provides least restrictive integration proposed far
Rosati presents algorithm decides consistency DL+log knowledge base
reducing problem entailment unions conjunctive queries. Notably, Rosatis
results (2006a, Thm. 11) imply consistency ALCHOIQb knowledge base
extended (weakly-safe) Datalog rules decidable entailment unions
conjunctive queries ALCHOIQb decidable, established.
Corollary 44. consistency ALCHOIQb+log-knowledge bases (both FOL
semantics non-monotonic semantics) decidable.
Another related reasoning problem query containment. Given schema (or TBox)
two queries q q 0 , q contained q 0 w.r.t. iff every interpretation
satisfies q satisfies q 0 . well known query containment w.r.t.
TBox reduced deciding entailment unions conjunctive queries w.r.t.
knowledge base (Calvanese et al., 1998a). Decidability unions conjunctive query
entailment ALCHOIQb implies, therefore, decidability query containment w.r.t.
ALCHOIQb TBox.
two obvious avenues future work. embark extending
results order allow non-simple roles query predicates. non-trivial task
current approach heavily relies certain locality query matches,
relinquished considering non-simple roles. hand, eager
determine associated computational complexities provide techniques form
basis implementable algorithms.

Acknowledgments
stay Oxford collaboration started, Sebastian Rudolph supported
scholarschip German Academic Exchange Service (DAAD). Continuative work
subject enabled funding ExpresST project German Research
Foundation (DFG).
477

fiRudolph & Glimm

Birte Glimm supported EPSRC project HermiT: Reasoning Large
Ontologies.
thank three anonymous reviewers numerous helpful comments.
thank Ian Pratt-Hartmann (unknowingly) smashing graphomata, Maria Magdalena Ortiz de la Fuente establishing competitive atmosphere, Yevgeny Kazakov
breath-taking discussions black holes, Boris Motik motivating considerations
value academic life, last least God providing us extraordinary
weather notably infinity.

References
Baader, F. (2003). Terminological cycles description logic existential restrictions.
Proceedings 18th International Joint Conference Artificial Intelligence
(IJCAI 2003), pp. 325330.
Baader, F., Brandt, S., & Lutz, C. (2005). Pushing EL envelope. Proceedings
19th International Joint Conference Artificial Intelligence (IJCAI 2005). Morgan
Kaufmann, Los Altos.
Baader, F., Calvanese, D., McGuinness, D. L., Nardi, D., & Patel-Schneider, P. F. (2003).
Description Logic Handbook. Cambridge University Press.
Bechhofer, S., van Harmelen, F., Hendler, J., Horrocks, I., McGuinness, D. L., PatelSchneider, P. F., & Stein, L. A. (2004). OWL web ontology language reference. Tech.
rep., World Wide Web Consortium. http://www.w3.org/TR/2004/REC-owl-ref-20040210/.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2005). DL-Lite:
Tractable description logics ontologies. Veloso, M. M., & Kambhampati, S.
(Eds.), Proceedings 20th National Conference Artificial Intelligence (AAAI
2005), pp. 602607. AAAI Press/The MIT Press.
Calvanese, D., De Giacomo, G., Lembo, D., Lenzerini, M., & Rosati, R. (2007). Tractable
reasoning efficient query answering description logics: DL-Lite family.
Journal Automated Reasoning, 39 (3), 385429.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (1998a). decidability query
containment constraints. Proceedings 17th ACM SIGACT SIGMOD
Symposium Principles Database Systems (PODS 1998), pp. 149158. ACM Press
Addison Wesley.
Calvanese, D., De Giacomo, G., Lenzerini, M., Nardi, D., & Rosati, R. (1998b). Description
logic framework information integration. Proceedings 6th International
Conference Principles Knowledge Representation Reasoning (KR 1998).
Calvanese, D., Eiter, T., & Ortiz, M. (2007). Answering regular path queries expressive description logics: automata-theoretic approach. Proceedings 22th
National Conference Artificial Intelligence (AAAI 2007).
Calvanese, D., Eiter, T., & Ortiz, M. (2009). Regular path queries expressive description
logics nominals. Proceedings 21st International Joint Conference
Artificial Intelligence (IJCAI 2009), pp. 714720. AAAI Press/The MIT Press.
478

fiNominals, Inverses, Counting, Conjunctive Queries

Chandra, A. K., & Merlin, P. M. (1977). Optimal implementation conjunctive queries
relational data bases. Proceedings 9th ACM Symposium Theory
Computing (STOC 1977), pp. 7790. ACM Press Addison Wesley.
Eiter, T., Lutz, C., Ortiz, M., & Simkus, M. (2009). Query answering description logics
transitive roles. Proceedings 21st International Joint Conference
Artificial Intelligence (IJCAI 2009), pp. 759764. AAAI Press/The MIT Press.
Glimm, B., Horrocks, I., Lutz, C., & Sattler, U. (2008a). Conjunctive query answering
description logic SHIQ. Journal Artificial Intelligence Research, 31, 151198.
Glimm, B., Horrocks, I., & Sattler, U. (2008b). Unions conjunctive queries SHOQ.
Proceedings 11th International Conference Principles Knowledge
Representation Reasoning (KR 2008). AAAI Press/The MIT Press.
Glimm, B., & Rudolph, S. (2010). Status QIO: Conjunctive query entailment decidable.
Proceedings 12th International Conference Principles Knowledge
Representation Reasoning (KR 2010), pp. 225235. AAAI Press/The MIT Press.
Godel, K. (1929). Uber die Vollstandigkeit des Logikkalkuls. Ph.D. thesis, Universitat Wien.
Golbreich, C., Zhang, S., & Bodenreider, O. (2006). foundational model anatomy
OWL: Experience perspectives. Journal Web Semantics, 4 (3).
Goodwin, J. (2005). Experiences using OWL ordnance survey. Proceedings
1st OWL Experiences Directions Workshop (OWLED 2005), Vol. 188
CEUR Workshop Proceedings. CEUR (http://ceur-ws.org/).
Gradel, E. (2001). modal logics robustly decidable?. Paun, G., Rozenberg,
G., & Salomaa, A. (Eds.), Current Trends Theoretical Computer Science, Entering
21th Century, Vol. 2, pp. 393408. World Scientific.
Grahne, G. (1991). Problem Incomplete Information Relational Databases. Lecture
Notes Computer Science. Springer-Verlag.
Horrocks, I., & Sattler, U. (2005). tableaux decision procedure SHOIQ. Proceedings
19th International Joint Conference Artificial Intelligence (IJCAI 2005).
Horrocks, I., & Sattler, U. (2007). tableau decision procedure SHOIQ. Journal
Automated Reasoning, 39 (3), 249276.
Horrocks, I., Sattler, U., & Tobies, S. (2000). Reasoning Individuals Description
Logic SHIQ. McAllester, D. (Ed.), Proceedings 17th Conference Automated Deduction (CADE 2000), No. 1831 Lecture Notes Artificial Intelligence,
pp. 482496. Springer-Verlag.
Jet Propulsion Laboratory, C. I. o. T. (2006). Semantic web earth environmental
terminology (SWEET).. http://sweet.jpl.nasa.gov/.
Kazakov, Y. (2008). RIQ SROIQ harder SHOIQ. Proceedings
11th International Conference Principles Knowledge Representation
Reasoning (KR 2008). AAAI Press/The MIT Press.
Kazakov, Y., & Motik, B. (2008). resolution-based decision procedure SHOIQ.
Journal Automated Reasoning, 40 (23), 89116.
479

fiRudolph & Glimm

Krotzsch, M., Rudolph, S., & Hitzler, P. (2007). Conjunctive queries tractable fragment
OWL 1.1. Proceedings 7th International Semantic Web Conference (ISWC
2007), Vol. 4825 Lecture Notes Computer Science, pp. 310323. Springer-Verlag.
Krotzsch, M., Rudolph, S., & Hitzler, P. (2008). ELP: Tractable rules OWL 2.
Proceedings 8th International Semantic Web Conference (ISWC 2008), Vol.
5318 Lecture Notes Computer Science, pp. 649664. Springer-Verlag.
Lacy, L., Aviles, G., Fraser, K., Gerber, W., Mulvehill, A., & Gaskill, R. (2005). Experiences
using OWL military applications. Proceedings 1st OWL Experiences
Directions Workshop (OWLED 2005). CEUR (http://ceur-ws.org/).
Levy, A. Y., & Rousset, M.-C. (1996). CARIN: representation language combining horn
rules description logics. Proceedings 12th European Conference Artificial Intelligence (ECAI 1996), pp. 323327.
Levy, A. Y., & Rousset, M.-C. (1998). Combining horn rules description logics
CARIN. Artificial Intelligence, 104 (12), 165209.
Lutz, C. (2008). complexity conjunctive query answering expressive description
logics. Proceedings International Joint Conference Automated Reasoning
(IJCAR 2008), pp. 179193. Lecture Notes Computer Science.
McGuinness, D. L., & Wright, J. R. (1998). industrial strength description logic-based
configuration platform. IEEE Intelligent Systems, 13 (4).
Motik, B., Shearer, R., & Horrocks, I. (2009). Hypertableau reasoning description logics. Submitted journal. http://www.hermit-reasoner.com/publications/
msh08hypertableau-journal.pdf.
Ortiz, M. (2008). Extending CARIN description logics SH family. Proceedings Logics Artificial Intelligence, European Workshop (JELIA 2008), pp.
324337. Lecture Notes Artificial Intelligence.
Ortiz, M., Calvanese, D., & Eiter, T. (2008a). Data complexity query answering
expressive description logics via tableaux. Journal Automated Reasoning, 41 (1),
6198.
Ortiz, M., Simkus, M., & Eiter, T. (2008b). Conjunctive query answering sh using
knots. Proceedings 2008 Description Logic Workshop (DL 2008). CEUR
(http://ceur-ws.org/).
Pratt-Hartmann, I. (2009). Data-complexity two-variable fragment counting
quantifiers. Forthcoming Information Computation. http://arxiv.org/abs/0806.
1636.
Rosati, R. (2006a). DL+log: Tight integration description logics disjunctive datalog.
Proceedings 10th International Conference Principles Knowledge
Representation Reasoning (KR 2006), pp. 6878.
Rosati, R. (2006b). decidability finite controllability query processing
databases incomplete information. Proceedings 25th ACM SIGACT
SIGMOD Symposium Principles Database Systems (PODS 2006), pp. 356365.
ACM Press Addison Wesley.
480

fiNominals, Inverses, Counting, Conjunctive Queries

Rosati, R. (2007a). limits querying ontologies. Proceedings 11th International Conference Database Theory (ICDT 2007), Vol. 4353 Lecture Notes
Computer Science, pp. 164178. Springer-Verlag.
Rosati, R. (2007b). conjunctive query answering EL. Proceedings 2007
Description Logic Workshop (DL 2007). CEUR Workshop Proceedings.
Rudolph, S., Krotzsch, M., & Hitzler, P. (2008). Terminological reasoning SHIQ
ordered binary decision diagrams. Proc. 23rd National Conference Artificial
Intelligence (AAAI 2008), pp. 529534. AAAI Press/The MIT Press.
Sidhu, A., Dillon, T., Chang, E., & Sidhu, B. S. (2005). Protein ontology development using
OWL. Proceedings 1st OWL Experiences Directions Workshop (OWLED
2005), Vol. 188 CEUR Workshop Proceedings. CEUR (http://ceur-ws.org/).
Sirin, E., Parsia, B., Cuenca Grau, B., Kalyanpur, A., & Katz, Y. (2007). Pellet: practical
OWL-DL reasoner. Journal Web Semantics, 5 (2).
Tessaris, S. (2001). Questions answers: Reasoning querying Description Logic.
PhD thesis, University Manchester.
Tsarkov, D., & Horrocks, I. (2006). FaCT++ description logic reasoner: System description.
Proceedings International Joint Conference Automated Reasoning (IJCAR
2006), Vol. 4130 Lecture Notes Computer Science, pp. 292 297. Springer-Verlag.
van der Meyden, R. (1998). Logical approaches incomplete information: survey.
Logics Databases Information Systems, pp. 307356. Kluwer Academic Publishers.
Vardi, M. Y. (1997). modal logic robustly decidable?. Descriptive Complexity
Finite Models: Proceedings DIMACS Workshop, Vol. 31 DIMACS: Series
Discrete Mathematics Theoretical Computer Science, pp. 149184. American
Mathematical Society.
W3C OWL Working Group (2009).
OWL 2 web ontology language document
overview. Tech. rep., World Wide Web Consortium. http://www.w3.org/TR/2009/
REC-owl2-overview-20091027/.
Wolstencroft, K., Brass, A., Horrocks, I., Lord, P., Sattler, U., Turi, D., & Stevens, R.
(2005). Little Semantic Web Goes Long Way Biology. Proceedings
5th International Semantic Web Conference (ISWC 2005).

481


