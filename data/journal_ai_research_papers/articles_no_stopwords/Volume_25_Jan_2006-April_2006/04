journal artificial intelligence

submitted published

dynamic local search maximum clique
wayne pullan

w pullan griffith edu au

school information communication technology
griffith university
gold coast qld australia

holger h hoos

hoos cs ubc ca

department computer science
university british columbia
main mall vancouver bc v z canada

abstract
introduce dls mc stochastic local search maximum clique dls mc alternates phases iterative improvement
suitable vertices added current clique plateau search
vertices current clique swapped vertices contained current clique
selection vertices solely vertex penalties dynamically adjusted
search perturbation mechanism used overcome search stagnation
behaviour dls mc controlled single parameter penalty delay controls frequency vertex penalties reduced empirically dlsmc achieves substantial performance improvements state art
maximum clique large range commonly used dimacs benchmark
instances

introduction
maximum clique max clique calls finding maximum sized subgraph pairwise adjacent vertices given graph max clique prominent combinatorial optimisation many applications example information retrieval
experimental design signal transmission computer vision balus yu
recently applications bioinformatics become important pevzner sze ji
xu stormo search variant max clique stated follows given
undirected graph g v e v set vertices e set edges
maximum size clique g clique g subset vertices c v
pairs vertices c connected edge e v v c v v e
size clique c number vertices c max clique n p hard
associated decision n p complete garey johnson furthermore inapproximable sense deterministic polynomial time
cliques size v unless n p zpp hastad
best polynomial time approximation max clique achieves approximation ratio v log v boppana halldorsson therefore large hard
instances max clique typically solved heuristic approaches particular
zpp class solved expected polynomial time probabilistic
zero error probability
c

ai access foundation rights reserved

fipullan hoos

greedy construction stochastic local search sls simulated annealing genetic tabu search overview
methods solving max clique see bomze budinich pardalos pelillo
may noted maximum clique equivalent independent set well minimum vertex cover max clique
directly applied equally fundamental application relevant
bomze et al
recent literature max clique seems somewhat unsurprisingly single best although empirically
evaluated benchmark instances second dimacs challenge johnson trick
quite difficult compare experimental studies mostly
differences respective experimental protocols run time environments nevertheless particularly considering comparative reported grosso et al grosso
locatelli croce seems five heuristic max clique
achieve state art performance
reactive local search rls battiti protasi derived reactive
tabu search battiti tecchiolli advanced general tabu search method
automatically adapts tabu tenure parameter controls amount diversification search process rls uses dynamic restart strategy provide
additional long term diversification
qualex ms busygin deterministic iterated greedy construction uses vertex weights derived nonlinear programming formulation maxclique
recent deep adaptive greedy search dags grosso et al
uses iterated greedy construction procedure vertex weights weights
dags however initialised uniformly updated every iteration greedy
construction procedure dags weighted iterated greedy construction procedure
executed iterative improvement phase permits limited amount plateau
search empirical performance indicate dags superior qualex ms
max clique instances dimacs benchmark sets hard
instances reach performance rls grosso et al
k opt katayama hamamoto narihisa conceptually simple variable depth search procedure uses elementary search steps
vertex added removed current clique evidence
performs better rls many instances dimacs benchmark sets katayama
et al performance relative dags unclear
finally edge ac ls solnon fenet recent ant colony optimisation max clique uses elitist subsidiary local search procedure appears
reach exceed performance dags rls least dimacs
instances
work introduce sls max clique dubbed
dynamic local search max clique dls mc combination constructive search perturbative local search makes use penalty values associated
vertices graph dynamically determined search
help avoid search stagnation


fidynamic local search max clique

extensive computational experiments dls mc outperforms
state art max clique search particular dags broad
range widely studied benchmark instances hence represents improvement
heuristic max clique solving present detailed behaviour dls mc offer insights roles single parameter dynamic
vertex penalties note use vertex penalties dls mc inspired
dynamic weights dags generally current state art dynamic local
search dls well known combinatorial sat
max sat hutter tompkins hoos tompkins hoos thornton pham
bain ferreira pullan zhao general introduction dls see
work hoos stutzle therefore provide evidence
effectiveness broad applicability algorithmic
remainder article structured follows first describe dls mc
key aspects efficient implementation next present empirical performance establish dls mc state art heuristic max clique
solving followed detailed investigation behaviour dls mc
factors determining performance finally summarise main contributions
work insights gained study outline directions future

dls mc
dags grosso et al dls mc fundamental idea augmenting combination iterative improvement plateau search
vertex penalties modified search iterative improvement procedure used greedy construction mechanism starts
trivial clique consisting single vertex successively expands clique c adding
vertices adjacent vertices c expansion impossible
may still exist vertices connected one vertices c including
vertex v c removing single vertex c connected v clique
number vertices obtained type search called plateau
search noted one plateau search steps expansion
current clique may become possible therefore dls mc alternates phases
expansion plateau search
purpose vertex penalties provide additional diversification search
process otherwise could easily stagnate situations current clique
vertices common optimal solution given max clique instance
perhaps obvious avoiding kind search stagnation simply
restart constructive search process different initial vertex however even
random systematic variation choice initial vertex still risk
heuristic guidance built greedy construction mechanism causes bias towards
limited set suboptimal cliques therefore dags dls mc utilise numerical
weights associated vertices weights modulate heuristic selection function
used greedy construction procedure way vertices repeatedly occur
cliques obtained constructive search process discouraged used
future constructions following intuition consistent general


fipullan hoos

dynamic local search dls idea refer
numerical weights vertex penalties
general considerations dls mc works follows see
outline figure picking initial vertex given graph g
uniformly random setting current clique c set consisting single
vertex vertex penalties initialised zero search alternates
iterative improvement phase suitable vertices repeatedly added
current clique c plateau search phase repeatedly one vertex c
swapped vertex currently contained c
two subsidiary search procedures implementing iterative improvement
plateau search phases expand plateausearch shown figure note
expand plateausearch select vertex added current clique c
penalties associated candidate vertices case expand selection
made set ni c vertices connected vertices c
edge g call set improving neighbour set c plateausearch
hand vertex added c selected level neighbour set c nl c
comprises vertices connected vertices c except one vertex
say v subsequently removed c
note procedures maintain current clique c expand terminates
improving neighbour set c becomes empty plateausearch terminates
ni c longer empty nl c becomes empty order reduce
incidence unproductive plateau search phases dls mc implements plateau search
termination condition katayama et al recording current clique c
start plateau search phase terminating plateausearch overlap
recorded clique c current clique c
end plateau search phase vertex penalties updated incrementing
penalty values vertices current clique c one additionally every pd
penalty value update cycles pd parameter called penalty delay non zero
vertex penalties decremented one latter mechanism prevents penalty values
becoming large allows dls mc forget penalty values time
updating penalties current clique perturbed one two ways
penalty delay greater one e penalties decreased occasionally current
clique reduced last vertex v added removed vertices
increased penalty values unlikely added back current clique
subsequent iterative improvement phase equivalent restarting search
v however penalty delay one corresponds behaviour penalties
effectively used since increase vertex penalty immediately undone
keeping even single vertex current clique c carries high likelihood reconstructing
c subsequent iterative improvement phase therefore achieve diversification
search penalty delay one c perturbed adding vertex v
chosen uniformly random given graph g removing vertices c
connected v
stated penalty values used selection vertex given
neighbour set precisely selectminpenalty selects vertex choosing
uniformly random set vertices minimal penalty values vertex


fidynamic local search max clique

procedure dls mc g tcs pd maxsteps
input graph g v e integers tcs target clique size pd penalty delay maxsteps
output clique g size least tcs failed
begin
numsteps
c random v
initpenalties
numsteps maxsteps
c v expand g c
c tcs return c end
c c
c v plateausearch g c c
ni c
c v expand g c
c tcs return c end
c v plateausearch g c c
end
updatepenalties pd
pd
c v
else
v random v
c c v
remove vertices c connected v g
end
end
return failed
end

figure outline dls mc details see text

selected becomes unavailable subsequent selections penalties
updated perturbation performed prevents plateau search
phase repeatedly visiting clique safeguard prevent penalty
values becoming large vertices penalty value greater never
selected
order implement dls mc efficiently sets maintained two array data
structures first vertex list array contains vertices currently
set second one vertex index array indexed vertex number contains
index vertex vertex list array vertex set
additions set performed adding end vertex list array updating
vertex index array deletions set performed overwriting vertex list
entry vertex deleted last entry vertex list updating
vertex index array furthermore vertices swapped current
clique plateau search phase intersection current clique
recorded clique simply maintained recording size current clique
start plateau search decrementing one every time vertex swapped


fipullan hoos

procedure expand g c
input graph g v e vertex set c v clique
output vertex set c v expanded clique vertex v recently added vertex
begin
ni c
v selectminpenalty ni c
c c v
numsteps numsteps
end
return c v
end

procedure plateausearch g c c
input graph g v e vertex sets c v clique c c recorded clique
output vertex set c v modified clique vertex v recently added vertex
begin
ni c nl c c c
v selectminpenalty nl c
c c v
remove vertex c connected v g
numsteps numsteps
end
return c v
end

figure subsidiary search procedures dls mc details see text
current clique finally array elements accessed pointers rather
via direct indexing array
finally may noted order keep time complexity individual
search steps minimal selection improving level neighbour sets
attempt maximise size set respective search step rather chooses
vertex minimal penalty uniformly random keeping common
intuition context sls often preferable perform many
relatively simple efficiently computable search steps rather fewer complex search
steps

empirical performance
order evaluate performance behaviour dls mc performed extensive computational experiments max clique instances second dimacs
implementation challenge used extensively benchmarking purposes recent literature max clique dimacs
max clique instances generated coding theory fault diagnosis
kellers conjecture tilings hypercubes steiner triple
several techniques implementation details henry kautzs highly efficient walksat code see http www cs washington edu homes kautz walksat
http dimacs rutgers edu challenges



fidynamic local search max clique

addition randomly generated graphs graphs maximum clique
hidden incorporating low degree vertices instances range size
less vertices edges greater vertices edges
experiments study performed dedicated ghz pentium iv machine kb l cache mb ram running redhat linux
g c compiler option execute dimacs machine benchmark
machine required cpu seconds r cpu seconds r
cpu seconds r following unless explicitly stated otherwise cpu times
refer reference machine
following sections first present series experiments
aimed providing detailed assessment performance dls mc report
additional experimental facilitate direct comparison dls mc
state art max clique
dls mc performance
evaluate performance dls mc dimacs benchmark instances performed independent runs instance target clique sizes tcs corresponding respective provably optimal clique sizes cases provably
optimal solutions unknown largest known clique sizes order assess peak
performance dls mc conducted experiment multiple values
penalty delay parameter pd report best performance obtained behaviour
dls mc suboptimal pd values method used identify optimal pd value
discussed section remaining parameter dls mc maxsteps
set order maximise probability reaching target clique size
every run
experiments displayed table benchmark
instance dls mc performance averaged independent runs
complete set dimacs benchmark instances note dls mc finds optimal
best known solutions success rate runs per instance
instances cases target clique size reached consistently
within alotted maximum number search steps maxsteps
c runs successful giving maximum clique size average
clique size minimum clique size
mann runs obtained cliques size remaining
runs produced cliques size
mann runs achieved maximum clique size
three cases reported cpu time statistics successful runs
shown parentheses table furthermore expected time required dls mc
reach target clique size less cpu second instances

dmclique ftp dimacs rutgers edu directory pub dsj clique



fipullan hoos

instance
brock
brock
brock
brock
brock
brock
brock
brock
brock
brock
brock
brock
dsjc
dsjc
hamming
hamming
hamming
hamming
hamming
hamming
johnson
johnson
johnson
johnson
mann
mann
mann
mann
san
san
san
san
san
san
san
san
san
san
san
sanr

br









































pd









































cpu









































steps









































sols









































instance
sanr
sanr
sanr
c
c
c
c
c
c
c
c fat
c fat
c fat
c fat
c fat
c fat
c fat
gen p
gen p
gen p
gen p
gen p
keller
keller
keller
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat

br









































pd









































cpu









































steps









































sols









































table dls mc performance averaged independent runs complete set dimacs benchmark instances maximum known clique size
instance shown br column marked asterisk proven
optimal pd optimised dls mc penalty delay instance cpu
run time cpu seconds averaged successful runs instance average cpu times less seconds shown steps
number vertices added clique averaged successful runs
instance sols total number distinct maximum sized cliques found
instance runs achieved best known cliques size shown
exception c runs successful giving maximum
clique size average clique size minimum clique size mann
runs obtained giving mann
runs achieved maximum clique size



fidynamic local search max clique

expected run time cpu seconds required remaining
instances least vertices finally variation coefficients stddev mean run time distributions measured search steps order overcome
inaccuracies inherent extremely small cpu times instances success rate obtained found reach average maximum values
respectively
may interesting note time complexity search steps dls mc
generally low indicative example brock vertices
edges maximum clique size vertices dls mc performs average
search steps e additions current clique per cpu second generally timecomplexity dls mc steps increases size improving ni level nl
neighbour sets well lesser degree maximum clique size relationship
seen table shows randomly generated dimacs c
brock instances performance dls mc terms search steps per cpu
second decreases number vertices hence size ni nl increases
instance
c
c
c
c
c
brock
brock
brock

vertices









edges









br









dls mc pd









steps second









table average number dls mc search steps per cpu second reference machine runs dimacs c brock instances br
dls mc pd figures table shown factors direct
impact performance dls mc br increases greater
overhead maintaining sets within dls mc furthermore larger pd values
cause higher overhead maintaing penalties vertices tend
penalised c instances randomly generated edge probability
brock instances constructed hide maximum
clique considerably lower densities e average number edges per
vertex scaling average number search steps per cpu second performed dls mc c instances running reference machine
approximated n n number vertices
given graph approximation achieves r value
detailed analysis dls mcs performance terms implementation independent
measures run time search steps iteration counts beyond scope
work could yield useful insights future
comparative
reported previous section demonstrate clearly dls mc achieves
excellent performance standard dimacs benchmark instances however com

fipullan hoos

parative analysis compared found literature
state art max clique straight forward task
differences
computing hardware date computing hardware basically documented terms cpu speed allows basic means comparison
e scaling computer cpu speed example takes account features memory caching memory size hardware architecture
etc unfortunately realistic option available
us comparison
reporting methodology empirical performance
max clique found literature form statistics
clique size obtained fixed run time conduct performance comparisons
data care must taken avoid inconclusive situations
achieves larger clique sizes another b cost higher runtimes important realise relative performance b vary
substantially run time may reach higher clique sizes b relatively
short run times opposite could case longer run times finally seemingly
small differences clique size may fact represent major differences performance
since many hard optimisation finding slightly sub optimal cliques
typically substantially easier finding maximal cliques example c
average time needed clique size success rate
cpu seconds whereas reaching maximum clique size success
rate requires average successful runs cpu seconds
termination criteria max clique dags
terminate upon reaching given target clique size instead run given
number search steps fixed amount cpu time even optimal clique
encountered early search would obviously highly unfair directly compare published dls mc terminates
soon finds user supplied target clique size
therefore confirm dls mc represents significant improvement previous
state art max clique conducted experiments analyses
designed yield performance dls mc directly compared
max clique particular compared dls mc
following max clique dags grosso et al grasp resende
feo smith contained grosso et al k opt katayama
et al rls battiti protasi gene marchiori iter marchiori
qualex ms busygin rank performance max clique
determine dominant benchmark instances
used set criteria primarily quality solution
deemed equivalent cpu time requirements
criteria shown order application table



fidynamic local search max clique

largest known maximum clique instance
ranked dominant instance
one achieves success rate instance lowest
average scaled cpu time becomes dominant instance
single achieves success rate instance becomes dominant
instance
achieves success rate instance achieves largest
size clique highest average clique size lowest average cpu time becomes
dominant instance
instance meets four criteria listed conclusion
drawn dominant instance

table criteria used ranking max clique

instance
brock
brock
brock
brock
brock
brock
brock
brock
brock
brock
brock
brock
c
c
c
c
gen p
gen p
gen p
gen p
keller
mann
p hat
p hat
san
san
sanr

dls mc
clique size
cpu





















































dags
clique size
scpu






















































grasp
clique size
scpu






















































table performance comparison dls mc dags grasp selected dimacs
instances scpu columns contain scaled dags grasp average
run times cpu seconds dags grasp runs per
instance dls mc runs per instance cases
best known found runs clique size entries format
maximum clique size average clique size minimum clique size dls mc
dominant instances table



fipullan hoos

table contrasts performance dags grasp literature grosso
et al respective performance dls mc since dags
grasp runs performed ghz pentium iv cpu dls mc ran
ghz pentium iv reference machine scaled cpu times factor
note assumption linear scaling run time cpu clock
speed reality speedup typically significantly smaller ranking criteria
data shows dls mc dominates dags grasp benchmark
instances listed table confirm ranking modified dags terminated
soon given target clique size reached termination condition used
dls mc performed direct comparison dls mc dimacs instances
running reference machine seen
experiment shown table dls mc dominates dags one instance
exception san
table shows performance dls mc compared k opt katayama
et al gene marchiori iter marchiori rls battiti protasi
literature roughly compensate differences cpu speed scaled
cpu times k opt gene iter factor obtained
ghz pentium iv rls measured mhz pentium ii cpu
ranking criteria table rls dominant instances
keller mann k opt dominant mann dls mc
dominant exception c remainder dimacs
instances listed table identify dominant c experiment performed running dls mc maxsteps parameter controls
maximum allowable run time reduced point average clique size
dls mc exceeded reported rls experiment dls mc reached
optimum clique size independent runs average minimum
clique size respectively average run time cpu sec taking
account runs establishes dls mc dominant rls k opt instance
c
analagous experiments performed directly compare performance dlsmc k opt selected dimacs benchmark instances shown table
confirm dls mc dominates k opt instances
finally table shows performance dls mc comparison
qualex ms literature busygin cpu times qualex ms
scaled factor compensate differences cpu speed ghz
pentium iv cpu vs ghz pentium iv reference machine ranking
criteria table qualex ms dominates dls mc instances brock brock
brock brock dls mc dominates qualex ms remaining
dimacs instances



fidynamic local search max clique

instance
brock
brock
brock
brock
brock
brock
brock
brock
brock
brock
brock
brock
dsjc
dsjc
c
c
c
c
c
c
c
c fat
c fat
c fat
c fat
c fat
c fat
c fat
gen p
gen p
gen p
gen p
gen p
hamming
hamming
hamming
hamming
hamming
hamming
johnson

dls mc
success cpu
















































































dags
success cpu
















































































instance
johnson
johnson
johnson
keller
keller
keller
mann
mann
mann
mann
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
p hat
san
san
san
san
san
san
san
san
san
san
san
sanr
sanr
sanr
sanr

dls mc
success cpu















































































dags
success cpu

















































































table success rates average cpu times dls mc dags runs
per instance dimacs instances dls mc superior success rate
instances exception san required less cpu
time dags instances entries signify runs
terminated excessive cpu time requirements obtain meaningful
comparison dls mc dags mann mann
respectively used best known producing table
dls mc dags average cpu time successful runs
ranking criteria study dags dominant
san instance dls mc dominant instances



fipullan hoos

dls mc
instance
clique size
brock

brock

brock

brock

brock

brock

c

c

c

c

c

c

c

dsjc

dsjc

gen p

gen p

gen p

gen p

gen p

hamming

hamming

keller

keller

keller

mann

mann

mann
p hat

p hat

p hat

p hat

p hat

p hat

p hat

p hat

p hat


k opt

rls

cpu
clique size
scpu
clique size
scpu











































































































































































gene
iter
avg
avg
clique size clique size











































































table performance dls mc k opt rls gene iter selected dimacs
instances scpu columns contain scaled average run time cpu seconds
k opt rls dls mc rls runs per instance
k opt gene iter runs per instance
ranking criteria study rls dominant instances
mann keller dls mc dominant
instances



fidynamic local search max clique

dls mc
instance
clique size cpu
brock
brock

brock
brock

k opt
dls mc
k opt
clique size scpu instance clique size cpu clique size scpu

c



c


c





keller

table performance dls mc k opt dls mc parameter maxsteps
reduced point clique size comparable
k opt cpu values dls mc include unsuccessful runs dls mc
runs k opt runs per instance
dls mc
qualex ms
dls mc
qualex ms
instance
clique size cpu clique size scpu
instance
clique size
cpu clique size scpu
brock



johnson




brock



johnson




brock



johnson




brock




keller




brock




keller




brock




keller



brock




mann




brock




mann



brock



mann


brock



mann




brock



p hat




brock




p hat




c




p hat




c




p hat




c




p hat




c


p hat




c




p hat




c



p hat




c




p hat




c fat




p hat




c fat




p hat




c fat




p hat




c fat




p hat




c fat




p hat




c fat




p hat




c fat




san




dsjc



san




dsjc



san




gen p



san




gen p



san




gen p



san




gen p



san




gen p



san




hamming



san




hamming



san




hamming



san




hamming




sanr




hamming




sanr




hamming




sanr




johnson




sanr





table performance dls mc qualex ms scpu column contains
scaled run time qualex ms cpu seconds dls mc
runs per instance ranking criteria study qualex ms
dominant instances brock brock brock
brock dls mc dominant instances


fipullan hoos

overall comparative performance evaluations summarised
follows
qualex ms dominant brock brock brock brock
dimacs instances
rls dominant mann keller dimacs instances
dags dominant san dimacs instance
k opt dominant mann dimacs instance
dls mc dominant remaining dimacs instances
addition within alotted run time number runs dls mc obtained current best known dimacs instances exceptions mann
mann

discussion
gain deeper understanding run time behaviour dls mc efficacy
underlying mechanisms performed additional empirical analyses specifically
studied variability run time multiple independent runs dls mc
instance role vertex penalties general particular
impact penalty delay parameter performance behaviour dls mc
frequency pertubation well role perturbation mechanism
investigations performed two dimacs instances c brock
instances selected firstly reasonable size difficulty secondly c randomly generated instance vertices optimal maximum
clique predominantly higher vertex degree average vertex degree intuitively
would seem reasonable randomly generated vertices optimal
maximum clique would tend higher vertex degrees brock
hand vertices optimal maximum clique predominantly lower average
vertex degree note dimacs brock instances created attempt defeat
greedy used vertex degree selecting vertices brockington culberson

fundamental difference highlighted quantitative analysis maximum cliques instances showed c averaged
maximal cliques found dls mc average vertex degree vertices maximal cliques standard deviation compared averaged
vertices brock corresponding figures respectively
variability run time
variability run time multiple independent runs given important aspect behaviour sls dls mc following methology hoos stutzle studied aspect run time distributions
rtds dls mc two reference instances


fidynamic local search max clique

seen empirical rtd graphs shown figure
independent runs reached respective best known clique size dls mc
shows large variability run time closer investigation shows rtds quite
well approximated exponential distributions kolmogorov smirnov goodness fit test
failed reject null hypothesis sampled run times stem exponential
distributions shown figure standard confidence level p values
observation consistent similar highperformance sls e g sat hoos stutzle scheduling
watson whitley howe consequence performing multiple independent
runs dls mc parallel close optimal parallelisation speedup hoos
stutzle similar observation made difficult dimacs
instances




empirical rld dls mc
ed















p solve

p solve




























e

empirical rtd dls mc
ed




e



run time search steps




empirical rld dls mc
ed















p solve

p solve












e
e
run time search steps



e

e

empirical rtd dls mc
ed

















run time cpu sec








run time cpu sec





figure run time distributions dls mc applied c top brock
bottom measured search steps left cpu seconds right reference machine independent runs reached best
known clique size empirical rtds well approximated exponential
distributions labelled ed x x plots
penalty delay parameter vertex penalties
penalty delay parameter pd specifies number penalty increase iterations must
occur dls mc penalty decrease vertices currently


fipullan hoos

vertex frequency

penalty max clique pd basically provides mechanism focusing
lower degree vertices constructing current cliques pd e penalties
frequency vertices improving neighbour level neighbour sets
basically solely dependent degree increasing pd overcomes bias towards
higher degree vertices allows penalty values increase often
current clique inhibits selection current clique turn
allows lower degree vertices become part current clique effect penalty
delay parameter illustrated figure shows correlation degree
vertices frequency included current clique immediately prior
perturbation performed within dls mc

c pd



vertex frequency












vertex degree







brock pd












vertex degree










vertex degree







vertex frequency


brock pd








figure correlation vertex degree frequency vertices
present clique immediately prior dls mc perturbation
c brock pd higher degree vertices tend
higher frequency present clique immediately prior dls mc
perturbation brock pd frequency present
clique immediately prior dls mc perturbation almost independent
vertex degree
currently pd needs tuned family case brock instances
sub family instances general could done principled way rtd
graphs dls mc reasonably robust regard exact value
parameter shown figures actual tuning process simple almost
interactive process normally require evaluating rtd graphs still fine tuning
rtd data could possibly minor performance improvements



fidynamic local search max clique



success rate















penalty delay














penalty delay







median processor time









figure success rate median cpu time dls mc function penalty delay
parameter pd benchmark instance brock data point
independent runs

cumulative success rate




pd
pd
pd

















steps







cumulative success rate




pd
pd
pd















processor time seconds





figure run time distributions dls mc brock penalty delays
measuring run time search steps top cpu seconds bottom
performance penalty delay clearly dominates



fipullan hoos

effect penalty delay parameter vertex penalties clearly illustrated
figure shows cumulative distributions number penalised vertices
perturbation dls mc representative runs dls mc dimacs brock
instance varying values parameter pd note brock optimal
pd value corresponds point average vertices
penalised role pd parameter illustrated figure shows
sorted frequency vertices present current clique immediately
prior perturbation c brock note instances
higher penalty delay settings significanly reduces bias towards including certain
vertices current clique previously demonstrated without vertex penalties e
pd dls mc prefers include high degree vertices current clique
case instances c optimal cliques tend consist vertices
higher average degrees effective strategy instances brock
however optimal clique contains many vertices lower average degree
heuristic bias towards high degree vertices misleading needs counteracted e g
means vertex penalties

pd
pd
pd
pd
pd
pd
pd
pd
pd
pd
pd





cumulative frequency



























penalised vertices







figure cumulative distributions number penalised vertices measured
search perturbation representative independent runs dls mc dimacs brock instance penalty delay parameter pd varied left
curve corresponds pd note approx optimal penalty
delay pd solid line average vertices penalised e
penalty value greater zero
generally reducing bias cliques visited vertex penalties help diversify
search dls mc time penalties appear provide learning
mechanism dls mc identifies vertices included


fidynamic local search max clique

c
frequency vertex clique


pd
pd


















vertex











brock
frequency vertex clique


pd
pd

















vertex









figure sorted frequency vertices present current clique immediately prior dls mc perturbation c top brock
bottom representative run instance note
penalty delay values pd bias towards certain vertices
frequently others substantially reduced
current clique agreement recent saps high performance
dynamic local search sat hoos stutzle
perturbation mechanism search mobility
prevent search stagnation dls mc uses perturbation mechanism executed
whenever plateau search procedure failed lead clique
expanded since mechanism causes major changes current clique relatively
high time complexity therefore interesting investigate frequently rather
costly disruptive perturbation steps performed figure shows distribution
number improving search steps e clique expansions plateau steps e vertex
swaps successive perturbation phases representative run dls mc
c instance analogous brock shown figure figures
basically interactions improving plateau search steps
perturbation mechanism structure



fipullan hoos

c

cumulative frequency


pd
pd
pd



















improving steps

















plateau swaps









cumulative frequency


pd
pd
pd











figure number improving search steps plateau swaps successive perturbation phases dls mc c graphs cumulative distributions measures collected representative independent runs
pd value solid lines correspond approx optimal penalty delay
instance pd
brock

cumulative frequency


pd
pd
pd
















improving steps














plateau swaps









cumulative frequency


pd
pd
pd











figure number improving search steps plateau swaps successive perturbation phases dls mc brock graphs cumulative
distributions measures collected representative independent runs
pd value solid lines correspond approx optimal penalty delay
instance pd


fidynamic local search max clique

seen data compared higher penalty delay values pd
significantly shorter plateau phases somewhat longer improvement phases
time differences behaviour dls mc observed penalty
delay values greater one relatively small one explanation phenomenon lies
fact pd effectively vertex penalties used consequently
selection improving level neighbours sets search step less constrained
intuitively make easier exits plateaus underlying search
landscape follow gradients larger number search steps

whether renders search efficient clearly depends topology
given search landscape instance c least optimal solutions see table
construction optimal cliques higher average vertex degree suggests
respective search landscape relatively high fitness distance correlation
would explain instance relatively easy solve
less radical perturbation mechanism associated pd adds randomly chosen
vertex v current clique removes vertices connected v provides sufficient
diversification search process instance brock hand appears
single optimal solution many near optimal solutions e large nonoptimal cliques cannot extended since construction optimal clique
lower average vertex degree suggests respective search landscape
relatively low fitness distance correlation therefore radical perturbation
mechanism used pd restarts clique construction recently
added vertex uses vertex penalties diversification required order obtain
good performance hypothesis agreement relatively high cost
solving instance

investigate efficacy perturbation dls mc diversification mechanism measured relative mobility search defined hamming distance
current cliques e number different vertices consecutive perturbations
divided two times maximum clique size representative runs dls mc instances c brock mobility measure closely related used
previous studies schuurmans southey seen figure
large difference mobility two variants perturbation mechanism
pd pd former restarts search randomly chosen vertex
consequently leads large variability hamming distance previous clique
latter restarts recently added vertex vertex penalties
increase search diversification hence shows consistently much higher mobility note
vertex penalties used e pd pd value significant effect
search mobility time previously observed see figure performance
dls mc significantly depend penalty update delay pd demonstrates
order achieve peak performance increased mobility afforded use
vertex penalties needs combined correct amount additional diversification
achieved specific penalty update delay


fipullan hoos

c

cumulative frequency


delay
delay
delay



















relative mobility

















brock

cumulative frequency


delay
delay
delay



















relative mobility

figure mobility search consecutive perturbation phases dls mc instances c top brock bottom mobility measured terms
relative hamming distance e number different vertices respective cliques divided two times maximum clique size graphs
cumulative distributions relative mobility measurements collected
representative independent runs pd value instance
solid lines correspond respective approx optimal pd values

conclusions future work
demonstrated applying general paradigm dynamic local search
maximum clique state art max clique solving improved
dls mc similarity previous max clique
particular recently introduced dags use vertex penalties
guide heuristic selection vertices searching maximum cliques however
unlike dags initial phase unweighted greedy construction search dls mc
uses updates vertex penalties throughout entire search process furthermore
weight updates dags monotone dls mc vertex penalties subject
increases well occasional decreases effectively allows
forget vertex penalties time furthermore dls mc selects vertex added
current clique step solely penalty vertex selection
dags total weight neighbouring vertices hence implicitely uses
vertex degree heuristic guidance fact dls mc although conceptually slightly
simpler outperforms dags one standard dimacs benchmark instances
combination excellent performance compared high performance max

fidynamic local search max clique

clique clearly demonstrates value underlying paradigm dynamic
local search non monotone penalty dynamics
work presented article extended several directions particular
would interesting investigate extent use multiplicative penalty update
mechanisms dls mc instead current additive mechanism lead performance improvements believe current implementation dls mc
optimised example selection vertex added current
clique implementation dls mc performs complete scan improving
plateaus sets build list vertices lowest penalties would probably
efficient maintain list means incremental update scheme another
interesting direction future develop mechanisms automatically
adjusting dls mcs penalty delay parameter search similar scheme used
dynamically adapting tabu tenure parameter rls battiti protasi
reactive tabu search battiti tecchiolli mechanism used controlling
noise parameter adaptive novelty hoos finally given excellent performance dls mc standard max clique instances reported suggests
underlying dynamic local search method substantial potential provide basis
high performance combinatorial optimisation particularly
weighted versions max clique conceptually related clustering

acknowledgments
authors would thank liang zhao participation performing
initial experiments

references
balus e yu c finding maximum clique arbitary graph siam journal
computing
battiti r protasi reactive local search maximum clique
algorithmica
battiti r tecchiolli g reactive tabu search orsa journal computing

bomze budinich pardalos p pelillo maximum clique
z du p p ed handbook combinatorial optimization vol pp
boppana r halldorsson approximating maximum independent sets
excluding subgraphs bit
brockington culberson j camouflaging independent sets quasi random
graphs johnson ed cliques coloring satisfiability second
dimacs implementation challenge vol dimacs series american mathematical society


fipullan hoos

busygin trust region technique maximum clique internal
report http www busygin dp ua
garey r johnson computers intractability guide theory
n p completeness freeman san francisco ca usa
grosso locatelli croce f combining swaps node weights
adaptive greedy maximum clique journal heuristics

hastad j clique hard approximate within n acta mathematica

hoos h h adaptive noise mechanism walksat proceedings
eighteenth national conference artificial intelligence pp aaai press
mit press menlo park ca usa
hoos h h stutzle stochastic local search foundations applications
morgan kaufmann publishers usa
hoos h stutzle local search sat empirical evaluation
gent v maaren h walsh eds sat pp ios press
hutter f tompkins hoos h h scaling probabilistic smoothing efficient dynamic local search sat hentenryck p v ed principles
practice constraint programming cp vol lecture notes
computer science pp springer verlag berlin germany
ji xu x stormo g graph theoretical predicting common rna secondary structure motifs including pseudoknots unaligned sequences
bioinformatics
johnson trick eds cliques coloring satisfiability second dimacs implementation challenge vol dimacs series american mathematical
society
katayama k hamamoto narihisa h solving maximum clique k opt local search proceedings acm symposium applied
computing pp
marchiori e genetic iterated multistart local search maximum clique
applications evolutionary computing vol lecture notes
computer science pp springer verlag berlin germany
pevzner p sze h combinatorial approaches finding subtle signals
dna sequences proceedings eighth international conference intelligent
systems molecular biology pp aaai press
pullan w zhao l resolvent clause weighting local search tawfik
goodwin eds advances artificial intelligence th conference
canadian society computational studies intelligence vol lecture notes
computer science pp springer verlag berlin germany


fidynamic local search max clique

resende feo smith fortran subroutine approximate solution maximum independent set grasp acm
transactions mathematical software
schuurmans southey f local search characteristics incomplete sat
procedures proceedings seventeenth national conference artificial intelligence pp aaai press mit press menlo park ca usa
solnon c fenet study aco capabilities solving maximum clique
journal heuristics appear
thornton j pham n bain ferreira v additive versus multiplicative
clause weighting sat proceedings th national conference artificial
intelligence aaai pp aaai press mit press menlo park ca
usa
tompkins hoos h scaling probabilistic smoothing dynamic local
search unweighted max sat xiang chaib draa b eds advances
artificial intelligence th conference canadian society computational
studies intelligence vol lecture notes computer science pp
springer verlag berlin germany
watson j whitley l howe linking search space structure run time
dynamics difficulty step toward demystifying tabu search journal
artificial intelligence




