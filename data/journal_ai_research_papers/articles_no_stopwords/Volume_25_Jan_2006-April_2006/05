Journal Artificial Intelligence Research 25 (2006) 187-231

Submitted 03/05; published 02/06

Approach Temporal Planning Scheduling
Domains Predictable Exogenous Events
Alfonso Gerevini
Alessandro Saetti
Ivan Serina

gerevini@ing.unibs.it
saetti@ing.unibs.it
serina@ing.unibs.it

Dipartimento di Elettronica per lAutomazione
Universita degli Studi di Brescia
Via Branze 38, I-25123 Brescia, Italy

Abstract
treatment exogenous events planning practically important many realworld domains preconditions certain plan actions affected events.
paper focus planning temporal domains exogenous events happen
known times, imposing constraint certain actions plan must executed
predefined time windows. actions durations, handling temporal constraints adds extra difficulty planning. propose approach planning
domains integrates constraint-based temporal reasoning graph-based
planning framework using local search. techniques implemented planner
took part 4th International Planning Competition (IPC-4). statistical analysis
results IPC-4 demonstrates effectiveness approach terms
CPU-time plan quality. Additional experiments show good performance
temporal reasoning techniques integrated planner.

1. Introduction
many real-world planning domains, execution certain actions occur
predefined time windows one necessary conditions hold. instance,
car refueled gas station gas station open, space telescope
take picture certain planet region region observable. truth
conditions determined exogenous events happen known times,
cannot influenced actions available planning agent (e.g.,
closing gas station planet movement).
Several frameworks supporting action durations time windows proposed
(e.g., Vere, 1983; Muscettola, 1994; Laborie & Ghallab, 1995; Schwartz & Pollack, 2004;
Kavuluri & U, 2004; Sanchez, Tang, & Mali, 2004). However, domaindependent systems fast enough large-scale problems. paper, propose
new approach planning temporal features, integrating constraint-based
temporal reasoning graph-based planning framework.
last two versions domain definition language International planning competition (IPC) support action durations predictable (deterministic) exogenous
events (Fox & Long, 2003; Edelkamp & Hoffmann, 2004). PDDL2.1, predictable exogenous events implicitly represented (Fox, Long, & Halsey, 2004), PDDL2.2
explicitly represented timed initial literals, one two new PDDL
c
2006
AI Access Foundation. rights reserved.

fiGerevini, Saetti & Serina

features 2004 competition (IPC-4) focused. Timed initial literals specified
description initial state planning problem assertions form
(at L), real number, L ground literal whose predicate
appear effects domain action. obvious meaning (at L) L
true time t. set assertions involving ground predicate defines
sequence disjoint time windows timed predicate holds. example
well-known ZenoTravel domain (Penberthy, 1993; Long & Fox, 2003a)
(at
(at
(at
(at

8 (open-fuelstation city1))
12 (not (open-fuelstation city1)))
15 (open-fuelstation city1))
20 (not (open-fuelstation city1))).

assertions define two time windows (open-fuelstation city1) true,
i.e., 8 12 (excluded) 15 20 (excluded). timed initial literal relevant
planning process precondition domain action, call timed
precondition action. timed precondition action seen temporal
scheduling constraint action, defining feasible time window(s) action
executed. actions plan durations timed preconditions, computing
valid plan requires planning reasoning time integrated, order check
whether execution planned actions satisfy scheduling constraints.
action plan cannot scheduled, plan valid must revised.
main contributions work are: (i) new representation temporal plans
action durations timed preconditions, called Temporally-Disjunctive Action Graph,
(TDA-graph) integrating disjunctive constraint-based temporal reasoning recent
graph-based approach planning; (ii) polynomial method solving disjunctive temporal reasoning problems arise context; (iii) new local search techniques
guide planning process using representation; (iv) experimental analysis
evaluating performance methods implemented planner called lpg-td,
took part IPC-4 showing good performance many benchmark problems.
td extension name planner abbreviation timed initial literals
derived predicates, two main new features PDDL2.2.1 lpg-td, techniques
handling timed initial literals quite different techniques handling derived
predicates. first ones concern representing temporal plans predictable exogenous
events fast temporal reasoning action scheduling planning; second ones
concern incorporating rule-based inference system efficient reasoning derived
predicates planning. timed initial literals derived predicates require
change heuristics guiding search planner, radically different way.
paper, focus timed initial literals, significant useful
extension PDDL2.1. Moreover, analysis results IPC-4 shows lpg-td
top performer benchmark problems involving feature. treatment derived
predicates lpg-td presented another recent paper (Gerevini et al., 2005b).
1. Derived predicates allow us express concise natural way indirect action effects. Informally, predicates appear effect action, truth determined
domain rules specified part domain description.

188

fiAn Approach Temporal Planning Scheduling

paper organized follows. Section 2, necessary background,
introduce TDA-graph representation method solving disjunctive temporal
reasoning problems arise context. Section 3, describe new local
search heuristics planning space TDA-graphs. Section 4, present
experimental analysis illustrating efficiency approach. Section 5, discuss
related work. Finally, Section 6 give conclusions.

2. Temporally Disjunctive Action Graph
partial-order causal-link planning, (e.g., Penberthy & Weld, 1992; McAllester &
Rosenblitt, 1991; Nguyen & Kambhampati, 2001), framework search space
partial plans. search state partial temporal plan represent
Temporally-Disjunctive Action Graph (TDA-graph). TDA-graph extension
linear action graph representation (Gerevini, Saetti, & Serina, 2003) integrates disjunctive temporal constraints handling timed initial literals. linear action graph
variant well-known planning graph (Blum & Furst, 1997). section,
necessary background linear action graphs disjunctive temporal constraints,
introduce TDA-graphs, propose techniques temporal reasoning
context representation used next section.
2.1 Background: Linear Action Graph Disjunctive Temporal Constraints
linear action graph (LA-graph) planning problem directed acyclic leveled
graph alternating fact level, action level. Fact levels contain fact nodes,
labeled ground predicate . fact node f level l associated
no-op action node level l representing dummy action predicate f
precondition effect. action level contains one action node labeled
name domain action represents, no-op nodes corresponding
level.
action node labeled level l connected incoming edges fact nodes
level l representing preconditions (precondition nodes), outgoing edges
fact nodes level l + 1 representing effects (effect nodes). initial level
contains special action node astart , last level special action node aend .
effect nodes astart represent positive facts initial state , precondition
nodes aend goals .
pair action nodes (possibly no-op nodes) constrained persistent mutex
relation (Fox & Long, 2003), i.e., mutually exclusive relation holding every level
graph, imposing involved actions never occur parallel valid plan.
relations efficiently precomputed using algorithm proposed previous
work (Gerevini et al., 2003).
LA-graph contains set ordering constraints actions (partial) plan represented graph. constraints (i) constraints imposed
search deal mutually exclusive actions: action level l mutex
action node b level l, constrained finish start b; (ii)
constraints actions implied causal structure plan: action
189

fiGerevini, Saetti & Serina

used achieve precondition action b, constrained finish start
b.
effects action node automatically propagated next levels
graph corresponding no-ops, interfering (mutex) action
blocking propagation, last level graph reached (Gerevini et al.,
2003). rest paper, assume LA-graph incorporates propagation.
Disjunctive Temporal Problem (DTP) (Stergiou & Koubarakis, 2000; Tsamardinos
& Pollack, 2003) pair hP, Ci, P set time point variables, C set
disjunctive constraints c1 cn , ci form yi xi ki , xi yi P, ki
real number (i = 1...n). C contains unary constraints, DTP called Simple
Temporal Problem (STP) (Dechter, Meiri, & Pearl, 1991).
DTP consistent DTP solution. solution DTP
assignment real values variables DTP consistent every constraint
DTP. Computing solution DTP NP-hard problem (Dechter et al., 1991),
computing solution STP accomplished polynomial time. Given
STP special start time variable preceding others, compute
solution STP variable shortest possible distance O(n c)
time, n variables c constraints STP (Dechter et al., 1991; Gerevini & Cristani,
1997). call solution optimal solution STP. Clearly, DTP consistent
choose constraint DTP disjunct obtaining consistent
STP, solution STP solution original DTP.
Finally, STP consistent distance graph STP
contain negative cycles (Dechter et al., 1991). distance graph STP hP, Ci
directed labeled graph vertex labeled p p P, edge v P
w P labeled k constraint w v k C.
2.2 Augmenting LA-graph Disjunctive Temporal Constraints
Let p timed precondition set W (p) time windows. following, x x+
indicate start time end time x, respectively, x either time window
action. Moreover, al indicates action node level l LA-graph consideration.
clarity presentation, describe techniques focusing action preconditions
must hold whole execution action (except end point
action), operator effects hold end action execution, i.e., PDDL
conditions type all, PDDL effects type end (Fox & Long, 2003). 2
order represent plans actions durations time windows
execution, augment ordering constraints LA-graph (i) action duration
constraints (ii) action scheduling constraints. Duration constraints form
a+ = Dur(a),
Dur(a) denotes duration action (for special actions start aend ,
+

+
Dur(astart ) = Dur(aend ) = 0, since
start = astart aend = aend ). Duration
constraints supported representation proposed previous work (Gerevini
2. methods planner support types operator condition effect specified
PDDL 2.1 2.2.

190

fiAn Approach Temporal Planning Scheduling

Level 1
(0)
p1

Level 2

Level 3

Goal level

()

p1

p1

p1

p1
p

mutex

p2

(0)

(50)

p5

(50)

p5

(50)

p5

a3

a1
(0)

astart

(0)

p3

p3

p3

(0)

p7

p3
mutex

()

astart

p6

(90)

(70)

a1

aend

(70)

p8

(70)

p8

p

p10

[15]
(75)

[50]
(0)

p

(90)

a2
a3

(70)

p8

aend

a2
(0)

p4

(0)

p4

(0)

p4

[70]
(0)

(70)

p9

(70)

p9

(70)

p9

(70)

0

25

50

75

90

125

p9

Figure 1: example LA-graph nodes labeled -values (in round brackets),
Gantt chart actions labeling nodes LA-graph. Square
nodes action nodes; circle nodes fact nodes. Action nodes marked
duration represented actions (in square brackets). Unsupported
precondition nodes labeled (). Dashed edges form chains no-ops blocked
mutex actions. Grey areas Gantt chart represent time windows
timed precondition p a3 .

et al., 2003), representation treatment scheduling constraints major
contribution work.
Let plan represented LA-graph A. easy see set C formed
ordering constraints duration constraints actions
encoded STP. instance, ai used support precondition node aj ,

a+
aj 0 C; ai aj two mutex actions , ai ordered aj ,

a+
aj 0 C. Moreover, every action , following STP-constraints
C:
a+ Dur(a), a+ Dur(a),
equivalent a+ = Dur(a). scheduling constraint imposes constraint
execution action must occur time windows associated timed
precondition action. Syntactically, disjunctive constraint c1 cn ,
ci form


(yi x
hi ) (vi ui ki ),

u
, vi , xi , yi action start times action end times, hi , ki R . every action
timed precondition p, following disjunctive constraint added C:

191

fiGerevini, Saetti & Serina

_

wW (p)



+
3


+
a+
a+
.
start w
start w

Definition 1 temporally disjunctive action graph (TDA-graph) 4-tuple hA, , P, Ci

linear action graph;
assignment real values nodes A;
P set time point variables corresponding start times end times
actions labeling action nodes A;
C set ordering constraints, duration constraints scheduling constraints
involving variables P.
TDA-graph hA, , P, Ci represents (partial) plan formed actions labeling
action nodes start times assigned . Figure 1 gives LA-graph
-values simple TDA-graph containing five action nodes (astart , a1 , a2 , a3 , aend )
several fact nodes representing ten facts. ordering constraints duration constraints
C are:4

+

a+
1 a3 0, a2 a3 0,

+
+

+
a1 a1 = 50, a2
2 = 70, a3 a3 = 15.

Assuming p timed precondition a3 windows [25, 50) [75, 125),
scheduling constraint C is:

+
+
+

+
+
((a+
start a3 25) (a3 astart 50)) ((astart a3 75) (a3 astart 125)).

pair hP, Ci defines DTP D.5 Let Ds set scheduling constraints D.
represents set STPs, consists constraints
Ds one disjunct (pair STP-constraints) disjunction subset s0
Ds (Ds0 Ds ). call consistent STP induced STP D. induced
STP contains disjunct every disjunction Ds (i.e., Ds0 = Ds ), say
(consistent) STP complete induced STP D.
values assigned action nodes action start times corresponding optimal solution induced STP. call start times schedule
actions A. value labeling fact node f earliest time = Ta + Dur(a)
3. Note that, p timed condition action a, end time
exogenous event making p false happens, PDDL p required true end
(Fox & Long, 2003).

+

4. brevity, examples omit constraints a+
start ai 0 ai aend 0, action
ai , well duration constraints astart aend , duration zero.
5. disjunctive constraints C exactly DTP-form. However, easy see every
disjunctive constraint C translated equivalent conjunction constraints exact DTPform. use compact notation clarity efficiency reasons.

192

fiAn Approach Temporal Planning Scheduling

supports f A, starts Ta . induced STP derive
schedule incomplete, may violate scheduling constraint action nodes,
say unscheduled current TDA-graph.
following definitions present notions optimality complete induced STP
optimal schedule, used next section.
Definition 2 Given DTP point variable p, complete induced STP
optimal induced STP p iff solution assigning p value less
equal value assigned p every solution every complete induced
STP D.
Definition 3 Given DTP TDA-graph G, optimal schedule actions
G optimal solution optimal induced STP
end .
Note optimal solution minimizes makespan represented (possibly
partial) plan. DTP previous example (Figure 1) two induced STPs: one
time window p (S1 ), one including pair STP-constraints imposing
time window [75, 125) p (S2 ). STP obtained imposing time window [25, 50)
p induced STP DTP, consistent. S1 partial induced
STP D, S2 complete optimal start time aend . temporal values
derived optimal solution S2 assigned action nodes
+



+

TDA-graph are:
start = astart = 0, a1 = 0, a2 = 0, a3 = 75, aend = aend = 90.
2.3 Solving DTP TDA-graph
general, computing complete induced STP DTP (if exists) NP-hard problem
solved backtracking algorithm (Stergiou & Koubarakis, 2000; Tsamardinos
& Pollack, 2003). However, given particular structure temporal constraints
forming TDA-graph, show task accomplished polynomial time
backtrack-free algorithm. Moreover, algorithm computes optimal induced STP

end .
following, assume time window timed precondition shorter
duration action (otherwise, time window removed
available precondition and, time window remains, action cannot
used valid plan). Moreover, without loss generality, assume
action one timed precondition. easy see always replace
set timed conditions action single equivalent timed precondition,
whose time windows obtained intersecting windows forming different original
timed conditions a. set start timed conditions set end timed
conditions compiled single equivalent timed preconditions. achieved
translating conditions conditions type all. idea similar
one presented Edelkamp (2004), difference one
time window associated timed condition, Edelkamp assumes timed
condition associated unique time window. Specifically, every start timed
condition p action translated equivalent timed condition p 0 type
replacing scheduling constraint p,
193

fiGerevini, Saetti & Serina

p

p

Dur(a)

Dur(a)

q

Dur(a)

r

r

x
0

35 40

50

60

80

100

120

150

180

Figure 2: example set timed conditions compiled single timed precondition (x). solid boxes represent time windows associated timed
conditions p (of type start), q (of type end), r (of type all)
action a. solid box extended dashed box indicates extension
time window translation corresponding timed condition
timed condition a.

_

wW (p)







+
a+
a+
,
start < w
start < w

forcing occur one time windows,
_

wW (p)



6
+
+


a+
a+
start < w + Dur(a) .
start < w

Similarly, every end timed condition p translated equivalent
timed condition replacing scheduling constraint
_

wW (p)



+

+

+
a+
a+
,
start < w
start < w

forcing a+ occur one time windows,
_

wW (p)



+

+


+
a+
.
start < w + Dur(a) astart < w

Clearly, translation timed conditions domain action single timed
precondition action accomplished preprocessing step polynomial time.
Figure 2 shows example. Assume action duration 20 timed conditions
p type start, q type end r type all. Let [0, 50) [100, 150)
time windows p, [35, 80) time window q, finally [40, 60) [120, 180)
time windows r. compile timed conditions new timed condition x
time window [40, 60).
6. Note timed conditions type start end need use < instead . However,
properties algorithms STPs easily generalized STPs extended <-constraints
(e.g., Gerevini & Cristani, 1997).

194

fiAn Approach Temporal Planning Scheduling

Solve-DTP(X, S)
Input: set X meta-variables meta CSP DTP, partial solution meta CSP;
Output: Either solution meta CSP fail.
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

X = stop return S;
x SelectVariable(X); X 0 X {x};
D(x) 6=
SelectValue(D(x));
0 {x d}; D(x) D(x) {d};
D0 (x) D(x); /* Saving domain values */
ForwardCheck-DTP(X 0 , 0 )
Solve-DTP(X 0 , 0 );
D(x) 0 (x); /* Restoring domain values */
return fail; /* backtracking */

ForwardCheck-DTP(X, S)
Input: set X meta-variables, (partial) solution S;
Output: Either true false.
1.
2.
3.
4.
5.
6.

forall x X
forall D(x)
Consistency-STP(S {x d})
D(x) D(x) {d};
D(x) = return false; /* dead-end */
return true.

Figure 3: Basic algorithm solving DTP. D(x) global variable whose value
current domain meta-variable x. Consistency-STP(S) returns true,
STP formed variable values (partial) solution solution, false
otherwise.

observed Stergiou Kourbarakis (2000) Tsamardinos Pollack (2003),
DTP seen meta CSP: variables meta CSP constraints
original CSP, values (meta) variables disjuncts forming
constraints original CSP. constraints meta CSP explicitly
stated. Instead, implicitly defined follows: assignment values
meta-variables satisfies constraints meta CSP iff forms consistent STP (an
induced STP DTP). solution meta CSP complete induced STP
DTP.
Figure 3 shows algorithm solving meta CSP DTP (Tsamardinos &
Pollack, 2003), variant forward-checking backtracking algorithm solving
general CSPs. appropriately choosing next meta-variable instantiate (function
SelectVariable) value (function SelectValue), show algorithm finds
solution backtracking (if one exists). Moreover, simple modification Solve195

fiGerevini, Saetti & Serina

DTP, derive algorithm backtrack free even input meta CSP
solution. achieved exploiting information LA-graph
TDA-graph decompose DTP sequence growing DTPs
D1 D2 ... Dlast =
(i) last number levels A, (ii) variables Vi Di (i = 1..last)
variables corresponding action nodes level i, (iii)
constraints Di constraints involving variables Vi . E.g.,

+

+

+
DTP Figure 1, point variables D3 a+
start , a1 , a1 , a2 , a2 , a3 , a3 , set
constraints D3

+

+

+

+

{ a+
1 a3 0, a2 a3 0, a1 a1 = 50, a2 a2 = 70, a3 a3 = 15,

+
+
+

+
+
((a+
start a3 25) (a3 astart 50)) ((astart a3 75) (a3 astart 125))}.

decomposed DTP, derive ordered partition set metavariables meta CSP original DTP
X = X1 X2 ... Xlast ,
Xi set meta-variables corresponding constraints Di Di1 ,
> 1, D1 otherwise. ordered partition used define order
SelectVariable chooses next variable instantiate, crucial avoid backtracking. Specifically, every variable single domain value (i.e., ordering constraint,
duration constraint, scheduling constraint one time window) selected
every variable one possible value (i.e., scheduling constraint
one time window); moreover, xi Xi , xj Xj < j, xi selected
xj .
order avoid backtracking, order SelectValue chooses value
meta-variable important well: given meta-variable one value
(time window) current domain, choose value corresponding earliest
available time window. E.g., current domain selected meta-variable
possible values
[

i=1..m

+


+
+

a+
,
start wi astart wi

SelectValue chooses j-th value |wj | < |wh |, every h {1, ..., m},
j {1, ..., m}, h 6= j.
following give simple example illustrating order SelectVariable
SelectValue select meta-variables meta-values, respectively. Consider
TDA-graph Figure 1 additional time window [150, 200) timed precondition p a3 . DTP extended TDA-graph six meta-variables (x1 , x2 , . . . , x6 ),
whose domains (the disjuncts corresponding constraints original CSP) are:

x1 : {a+
1 a3 0}
+

x2 : {a2 a3 0}

196

fiAn Approach Temporal Planning Scheduling

x3 :
x4 :
x5 :
x6 :


{a+
1 a1 = 50}
+

{a2 a2 = 70}

{a+
3 a3 = 15}
+
+
+
+

+
+
{(astart
3 25) (a3 astart 50), (astart a3 75) (a3 astart 125),
+

+
+
(astart a3 150) (a3 astart 200)}.

exploiting level structure TDA-graph, derive ordered partition
meta-variables formed following sets:
X1 = {x3 }, X2 = {x4 }, X3 = {x1 , x2 , x5 , x6 }.
Since x3 belongs X1 x4 belongs X2 , SelectVariable selects x3 selecting
x4 . Similarly, function selects x4 meta-variables X3 . algorithm
instantiates x6 , first meta-value x6 (i.e., first time window timed precondition a3 ) removed domain forward checking, SelectValue selects

+
+
+

+
+
(a+
start a3 75) (a3 astart 125) (astart a3 150) (a3 astart 200),
first meta-value corresponds time window starting time 75,
second one corresponds time window starting time 150.
using techniques selecting next meta-variable instantiate
value, prove following theorem.
Theorem 1 Given DTP TDA-graph, meta CSP X solvable,
Solve-DTP finds solution X backtracking. Moreover, solution optimal
induced STP
end .
Proof. proof two key points: way meta-variables selected instantiated
SelectVariable SelectValue, respectively; particular type constraints D,
disjunctive constraints specific form encoding set disjoint time windows,
and, construction D,

j < j |=
j < ai ,

(1)


set ordering constraints duration constraints D,
(aj )
endpoint ai (aj ). property (1), cannot imply restriction
maximum distance endpoint ai endpoint aj (while, course,
lower bound distance). I.e., positive quantity u

j < j |= (a
j ai u).

(2)

Let assume SelectVariable chooses meta-variable x cannot consistently
instantiated value D(x) (and means reached backtracking point).
show cannot case.
SelectVariable chooses meta-variables STP-constraints metavariable scheduling constraint one value (time window). Let X
set meta-variables associated scheduling constraints D.
x must meta-variable X , assuming meta CSP X
solvable. use forward checking subroutine guarantees least one value x
consistent respect meta-variables instantiated current partial
197

fiGerevini, Saetti & Serina

solution S. Hence, case step 7 Solve-DTP ForwardCheck-DTP
returns false every value (time window) D(x), i.e., every D(x)
exists another uninstantiated meta-variable x0 X that, every d0 D(x0 ),
check Consistency-STP(S {x0 d0 }) executed forward checking subroutine returns
false. However, X solution (D consistent), cannot case
(i) value chosen SelectValue instantiate x previously instantiated metavariables (step 4) earliest available time window current domain
meta-variable consideration, least commitment assignment,
(ii) one scheduling constraint (meta-variable X ) level
TDA-graph.
Let a0 action constrained scheduling constraint associated x 0 . Since
SelectVariable selects x x0 , (ii) a0 level following level
action constrained scheduling constraint associated x. Thus, property (2),
x0 could instantiated, would every time window
a0 constrains a0 start early: current partial solution X augmented
possible values x implies start time a0 end
last time window a0 . then, (i) assumption X solvable guarantee
cannot case.
Moreover, since value every instantiated meta-variable propagated forward
checking unassigned variables, first value assigned metavariable value assigned variable solution found CSP (if
any) easy see first value chosen SelectValue(D(x)) feasible
(ForwardCheck-DTP(X 0 , 0 ) returns false), every next value chosen x
feasible.
Finally, since value chosen SelectValue meta-variable corresponds
earliest available window current domain meta-variable, follows
solution computed algorithm complete optimal induced STP
end . 2
consequence previous theorem, Solve-DTP performs backtracking (step 10),
input meta CSP solution. Thus, obtain general backtrack-free
algorithm DTP TDA-graph simply replacing step 10
10. stop return fail.
correctness modified algorithm, called Solve-DTP+ , follows
Theorem 1. next theorem states runtime complexity Solve-DTP + polynomial.
Theorem 2 Given TDA-graph G DTP D, Solve-DTP+ processes meta CSP
corresponding polynomial time respect number action nodes G
maximum number time windows scheduling constraint D. 7
7. noted main goal give complexity bound polynomial. use
improved forward checking techniques (e.g., Tsamardinos & Pollack, 2003) could lead complexity
bound lower one given proof theorem.

198

fiAn Approach Temporal Planning Scheduling

Proof. time complexity depends number times ForwardCheck-DTP executed, time complexity. contains linear number variables respect
number n domain action nodes LA-graph TDA-graph, O(n 2 ) ordering constraints, O(n) duration constraints scheduling constraints. Hence,
meta CSP O(n2 ) meta-variables (one variable constraint original
CSP). Let maximum number time windows scheduling constraint D.
ForwardCheck-DTP executed times meta-variable x, i.e., O( n 2 ) times
total. Consistency-STP decides satisfiability STP involving O(n) variables,
accomplished O(n3 ) time (Dechter et al., 1991; Gerevini & Cristani, 1997). (Note
variables STP processed Consistency-STP variables
original CSP, i.e., starting time end time actions plan.)
Finally, Consistency-STP run O( n2 ) times run ForwardCheck-DTP.
follows runtime complexity Solve-DTP+ O( 2 n7 ). 2
exploiting structure temporal constraints forming DTP TDAgraph, make following additional changes Solve-DTP+ improving efficiency
algorithm.
Instead starting empty assignment (no meta-variable instantiated),
initially every meta-variable associated ordering constraint duration
constraint instantiated value, X contains meta-variables associated
scheduling constraints. observed proof Theorem 1, meta
CSP solvable, values assigned meta-variables initial form
consistent STP.
Forward checking performed meta-variable.
proof Theorem 1 shown that, meta CSP solvable,
first value chosen SelectValue feasible (i.e., ForwardCheck-DTP returns
true). Thus, first value feasible, stop algorithm return fail
meta CSP solvable. Moreover, omit steps 6 9
save restore domain values meta-variables.
Finally, improved algorithm made incremental exploiting particular
way update DTP TDA-graph planning (i.e.,
search solution TDA-graph described next section). described
next section, search step either addition new action node certain
level l, removal action node l. cases, suffices recompute
sub-solution meta-variables subsets Xl , Xl+1 , ..., Xlast . values
assigned meta-variables assignment last solution
computed updating DTP, part input algorithm.
Moreover, order use local search techniques described next section,
need another change basic algorithm: algorithm detects X
solution, instead returning failure, (i) keeps processing remaining meta-variables,
(ii) terminates, returns (partial) induced STP Si formed values
assigned meta-variables. optimal solution Si defines -assignment
TDA-graph.
199

fiGerevini, Saetti & Serina

next section, SG denotes induced STP DTP TDA-graph G computed method.

3. Local Search Techniques TDA-Graphs
TDA-graph hA, , P, Ci contain two types flaw: unsupported precondition nodes
A, called propositional flaws, action nodes scheduled , called
temporal flaws. level contains flaw, say level flawed. example,
time window p TDA-graph Figure 1 [25, 50), level 3 would
flawed, start time a3 would 70, violates scheduling constraint
a3 imposing action must executed [25, 50).
TDA-graph flawed level represents valid plan called solution graph.
section, present new heuristics finding solution graph search space
TDA-graphs. heuristics used guide local search procedure, called Walkplan,
originally proposed Gerevini Serina (1999) heart
search engine planner.
initial TDA-graph contains astart aend . search step identifies
neighborhood N (G) (successor states) current TDA-graph G (search state),
set TDA-graphs obtained G adding helpful action node removing
harmful action node attempt repair earliest flawed level G. 8
following, sake brevity refer action node TDA-graph,
implicitly referring action node LA-graph TDA-graph. Similarly
level TDA-graph. Moreover, remind reader l denotes action
level l, la denotes level action a.
Definition 4 Given flawed level l TDA-graph G, action node helpful l iff
insertion G level l would remove propositional flaw l.
Definition 5 Given flawed level l TDA-graph G, action node level l
harmful l iff removal G would remove propositional flaw l, would
decrease -value al , al unscheduled.
Examples helpful action node harmful action node
action node representing action effect p1 helpful level 3 TDA-graph
Figure 1 added level 2 3 (bear mind insertion action node
level 3 determines expansion TDA-graph postponing a3 level 4; details
given end examples). Action node a3 Figure 1 harmful level 3,
precondition node p1 unsupported; action node a1 harmful level 3,
blocks no-op propagation p1 level 1, would support precondition node p1
level 3. Moreover, assuming W (p) = {[25, 50)}, a3 unscheduled plan represented
LA-graph. Action node a2 harmful level 3, removal a2
8. designed several flaw selection strategies described experimentally evaluated
recent paper (Gerevini, Saetti, & Serina, 2004). strategy preferring flaws earliest level
graph tends perform better others, used default strategy planner.
details discussion strategy given aforementioned paper.

200

fiAn Approach Temporal Planning Scheduling

would decrease temporal value a3 . contrary, a1 harmful level 3,
removal would affect possible scheduling a3 . Notice action
node helpful harmful: a3 harmful level 3, helpful
goal level (because supports precondition node p10 aend ).
add action node level l empty, LA-graph extended
one level, action nodes l shifted forward one level (i.e., moved
next level), new action inserted level l . Similarly, remove
action node level l, graph shrunk removing level l. additional
details process given another paper (Gerevini et al., 2003). Moreover,
pointed previous section, addition (removal) action node requires us
update DTP G adding (removing) appropriate ordering constraints
actions LA-graph G, duration constraint a, scheduling
constraint (if any). updated DTP, use method described
previous section revise , compute possibly new schedule actions G
(i.e., optimal solution SG ).
elements N (G) evaluated using heuristic evaluation function E consisting
two weighted terms, estimating additional search cost temporal cost, i.e.,
number search steps required repair new flaws introduced, contribution
makespan represented plan, respectively. element N (G) lowest
combined cost selected using noise parameter randomizing search escape
local minima (Gerevini et al., 2003). addition, order escape local minima,
new version planner uses short tabu list (Glover & Laguna, 1997). rest
section, focus search cost term E. techniques use
evaluation temporal cost (automatic) setting term weights E
similar introduced previous work (Gerevini et al., 2003).
search cost adding helpful action node repair flawed level l G
estimated constructing relaxed temporal plan achieving
(1) unsupported precondition nodes a, denoted Pre(a)
(2) propositional flaws remaining l adding a, denoted Unsup(l),
(3) supported precondition nodes action nodes G would become
unsupported adding a, denoted Threats(a).
Moreover, estimate number additional temporal flaws addition
G would determine, i.e., count number
(I) action nodes G would become unscheduled adding G,
(II) unsatisfied timed preconditions a, unscheduled TDA-graph extended ,
(III) action nodes scheduling constraint estimate cannot satisfied
context G.
search cost adding G number actions plus (I), (II) (III),
new terms heuristic evaluation. Note action nodes (I)
201

fiGerevini, Saetti & Serina

aend (90)

Goal level
(90)

p9

p8
[15]

a3 (75)

(70)

p8

Action
b1
b2
b3
b4

(70)

(70)

p10
p

(70)

p9

(70)

p9

p5

(70)

(70)

(70)

(50)

p1

p7

Est lower bound
0
0
15
50

(35)
[5]

q

p9

p8

p6

Relaxed Plan

Level 3
()

Action
b1
b2
b3
b4

N um acts
0
0
1
5

anew (30)

(20)

p5 (50)

p1

p3

Level 2
p1
p1

p5
mutex

p1

(0)

[50]

a1 (0)

Level 1
(0)

(50)

(0)

p2

mutex

p6

p3
p3
p3

(0)

(0)

a2 [70]
(0)
()

p4
p4
p4

(30)

q1

q2
[10]
(20)

(0)

b3

(20)

q3

(0)
[15]

p5

(0)

b1 (0)


astart (0)

(0)

p3

[100]

q
p4

b4 (50)

(0)

q4

p5

(50)

[20]

b2 (0)

p4

(0)

(50)

p5

Figure 4: example relaxed temporal plan . Square nodes represent action nodes,
nodes represent fact nodes; solid nodes correspond nodes
{anew }; dotted nodes correspond precondition nodes action nodes
considered construction ; gray dotted nodes
selected inclusion . Action nodes marked duration
represented actions (in square brackets) estimated start time (in
round brackets). meaning Num acts described text; lower
bounds earliest action start times (Est lower bound) computed
algorithm Appendix A.

would ordered (because used achieve one
preconditions, action nodes mutex a) that, given estimated end
time duration a, would excessively increase start time. (II)
consider original formulation timed preconditions (i.e., formulation
possible compilation one merged new precondition, discussed Section 2.3).
Finally, check scheduling constraint action , consider estimated end
time relaxed subplan used achieve preconditions action.
Example relaxed temporal plan additional temporal flaws (IIII)
Figure 4 gives example evaluating addition anew level 2 LAgraph left side figure (the graph one used Figure 1),
202

fiAn Approach Temporal Planning Scheduling

RelaxedTimePlan(G, I, A)
Input: set goal facts (G), initial state relaxed plan (I), set reusable actions (A);
Output: set actions Acts forming relaxed plan G earliest time
facts G achieved.
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.


Acts A; F aActs Add (a);
AX {T (g) | g G F g G I};
G G I;
G F 6=
g fact G F ;
b BestAction(g);
hA, t0 RelaxedTimePlan(Pre(b), I, Acts);
(b) ComputeEFT (b, t0 );
AX{t, (b)};
forall f Add(b)

(f ) (f ),ST (b) + Dur(b) ;
Acts {b}; F aActs Add (a);
return hActs, ti.

Figure 5: Algorithm computing relaxed temporal plan. ComputeEFT (b, 0 ) returns
estimated earliest finishing time b consistent scheduling
constraint b (if any), t0 + Dur(b) (for example see
Appendix A). Add (a) denotes set positive effects a.

helpful action node unsupported precondition p6 . goals unsupported
preconditions q1 q2 anew ; initial state formed fact nodes
supported level 2. actions anew , b2 b3. numbers name
actions facts relaxed plan indicate order RelaxedTimePlan
considers them. estimated start time end time b3 20 30, respectively.
Assume timed precondition q anew associated time window [0, 20).
Concerning point (I), action node G would become unscheduled adding
anew G. Concerning point (II), anew unscheduled one timed precondition
unsatisfied (q). Concerning point (III), b3 cannot scheduled
context current TDA-graph G. Finally, since contains three actions,
sum (I), (II) (III) 2, search cost adding anew G level 2
5.
evaluation TDA-graph derived removing harmful action node
flawed level l similar, achieving
precondition nodes supported would become unsupported removing

la < l, unsupported precondition nodes level l become supported removing a.
203

fiGerevini, Saetti & Serina

Regarding second point, note l = la , flaws l eliminated because,
remove action, (automatically) remove precondition nodes. While,
la < l, removal could leave flaws level l.
Plan relaxed sense derivation ignores possible (negative) interference actions , actions may unscheduled. derivation
takes account actions already current partial plan (the plan represented
TDA-graph G). particular, actions current plan used define
initial state , obtained applying actions G level la 1, ordered
according corresponding levels. Moreover, fact f marked temporal
value, (f ), corresponding time f becomes true (and remains )
current subplan formed actions level la 1.
relaxed plan constructed using backward process, called RelaxedTimePlan (see
Figure 5), extension RelaxedPlan algorithm proposed previous
work (Gerevini et al., 2003). algorithm outputs two values: set actions forming
(sub)relaxed plan, estimated earliest finishing time (used defined temporal
cost term E). set actions Acts forming derived running RelaxedTimePlan
twice: first goals Pre(a), initial state empty set reusable actions;
goals Unsup(l ) hreats(a), initial state Threats(a) Add (a), set reusable
actions formed actions computed first run plus a.
main novelty extended algorithm computing concerns choice
actions forming relaxed plan. action b chosen achieve (sub)goal g action
minimizing sum
estimated minimum number additional actions required support propositional preconditions (Num acts(b, I)),
number supported precondition nodes LA-graph would become
unsupported adding b G (Threats(b)),
number timed preconditions b estimate would unsatisfied G
extended (TimedPre(b));
number action nodes scheduled estimate would become unscheduled adding b G (TimeThreats(b)).
formally, action chosen BestAction(g) step 6 RelaxedTimePlan
achieve (sub)goal g action satisfying


0
0
0
0
ARGMIN Num acts(a , I) + |Threats(a )| + |TimedPre(a )| + |TimeThreats(a )| ,
{a0 Ag }

Ag = {a0 | g Add (a0 ), set domain actions whose preconditions
reachable I}.
Num acts(b, I) computed algorithm given Appendix A; Threats(b) computed previous method deriving (Gerevini et al., 2003), i.e., considering
negative interactions (through mutex relations) b precondition nodes
supported levels al ; TimedPre(b) TimeThreats(b) new components
action selection method, computed follows.
204

fiAn Approach Temporal Planning Scheduling

order compute TimedPre(b), estimate earliest start time b (Est(b))
earliest finishing time b (Ef t(b)). Using values, count number
timed preconditions b cannot satisfied. Ef t(b) defined Est(b) + Dur(b),
Est(b) maximum
lower bound possible earliest start time b (Est lower bound b), computed
reachability analysis algorithm given Appendix A;
-values action nodes ci current TDA-graph G, < la ,

mutex b addition b G would occur addition c+
b 0
DTP G;
maximum estimated lower bound time preconditions
b achieved relaxed plan; estimate computed causal structure
relaxed plan, duration scheduling constraints actions,
-values facts initial state I.
Example TimedPre
example Figure 4, estimated start time b3 maximum 15,
Est lower bound b3, 20, maximum time estimated
times preconditions b3 supported (p4 supported initial state
time 0, q3 supported time 20). Notice a1 mutex b3,
second point definition Est(b3) apply here. Since estimated earliest
start time b3 20 duration b3 10, Ef t(b3) = 20 + 10. Thus, assume
q associated time window [0,20), timed precondition q b3
cannot scheduled, i.e., q TimedPre(b3).
order compute TimeThreats(b), use following notion time slack
action nodes.
Definition 6 Given two action nodes ai aj TDA-graph hA, , P, Ci

C |= a+
< aj , Slack(ai , aj ) maximum time -value ai
consistently increased SG without violating time window chosen scheduling aj .
order estimate whether action b time threat action node k
current TDA-graph extended action node adding repairing level
l (l < k), check
(b , a) > Slack(a, ak )
holds, b portion relaxed plan computed far, (b , a)
estimated delay adding actions b G would cause start time a.
Examples time slack TimeThreat
slack anew a3 TDA-graph Figure 4 extended anew 35,
even anew started 35, a3 could still executed time window
[75, 125) (imposed timed precondition p); anew started 35 + , a3
would finish 125+ (determined summing start time anew , Dur(anew ), Dur(a2 ),
205

fiGerevini, Saetti & Serina

Dur(a3 )), scheduling constraint a3 would violated. Assume
evaluating inclusion b4 relaxed plan Figure 4 achieving q2.
(b4 , anew ) = 150,
i.e. estimated delay portion plan formed b4 would add end
time anew 150. Since slack anew a3 35,
Slack(anew , a3 ) < (b4 , anew ),
a3 TimeThreats(b4). contrary, since
Slack(anew , a3 ) > (b3 , anew ) = 30
a3 6 TimeThreats(b3).
conclude section, observe way consider scheduling constraints
evaluation search neighborhood similarity well-known
technique used scheduling. example, suppose evaluating TDA-graphs
obtained adding helpful action node one among alternative possible levels
graph, current TDA-graph contains another action node c mutex
a. search neighborhood contains two TDA-graphs corresponding (1) adding
level lc (2) adding level lc , (1) violates less scheduling
constraints (2), then, according points (I)(III), (1) preferred (2). similar
heuristic method, called constraint-based analysis, proposed Erschler, Roubellat
Vernhes (1976) decide whether action scheduled another
conflicting action, used scheduling work guiding search
toward consistent scheduling tasks involved problem (e.g., Smith & Cheng,
1993).

4. Experimental Results
implemented approach planner called lpg-td, obtained 2nd prize
metric-temporal track (satisficing planners) 4th International Planning Competition (IPC-4). lpg-td incremental planner, sense produces sequence
valid plans improves quality previous ones. Plan quality
measured using metric expression specified planning problem description.
incremental process lpg-td described another paper (Gerevini et al., 2003).
Essentially, process iterates search solution graph additional constraint
lower bound plan quality, determined quality previously
generated plans. lpg-td written C available http://lpg.ing.unibs.it.
section, present results experimental study two main goals:
testing efficiency approach temporal planning predictable exogenous
events comparing performance lpg-td recent planners
IPC-4 attempted benchmark problems involving timed initial literals (Edelkamp,
Hoffmann, Littman, & Younes, 2004);
206

fiAn Approach Temporal Planning Scheduling

Planner

lpg-td
sgplan
p-mep
crikey
lpg-ipc3
downward (diag)
downward
marvin
yahsp
macro-ff
fap
roadmapper
tilsapa
optop

Solved
845
1090
98
364
306
380
360
224
255
189
81
52
63
4

Attempted
1074
1415
588
594
594
432
432
432
279
332
193
186
166
50

Success ratio
79%
77%
17%
61%
52%
88%
83%
52%
91%
57%
42%
28%
38%
8%

Planning capabilities IPC-4
Propositional + DP, Metric-Temporal +TIL
Propositional + DP, Metric-Temporal +TIL
Propositional, Metric-Temporal +TIL
Propositional, Metric-Temporal
Propositional, Metric-Temporal
Propositional + DP
Propositional + DP
Propositional + DP
Propositional
Propositional
Propositional
Propositional
TIL
TIL

Table 1: Number problems attempted/solved success ratio (satisficing) planners took part IPC-4. DP means derived predicates; TIL means timed
initial literals; Propositional means STRIPS ADL. planning capabilities PDDL2.2 features test problems attempted planner
IPC-4.

testing effectiveness proposed temporal reasoning techniques integrated
planning process understand, particular, impact overall
performance system, compare existing techniques.
first analysis, consider test problems variant IPC-4 metrictemporal domains involving timed initial literals. comparison lpg-td IPC-4
planners considering variants IPC-4 metric-temporal domains given
Appendix B. Additional results available web site planner.
second experiments, use new domains problems obtained extending
two well-known benchmark domains (and relative problems) IPC-3 timed
initial literals (Long & Fox, 2003a).9
tests conducted Intel Xeon(tm) 3 GHz, 1 Gbytes RAM. ran lpg-td
default settings every problem attempted.
4.1 LPG-td IPC-4 Planners
section, use official results IPC-4 compare performance lpg-td
planners took part competition. performance lpg-td
corresponds single run. CPU-time limit run 30 minutes,
termination forced. lpg-td.s indicates CPU-time required planner derive
first plan; lpg-td.bq indicates best quality plan found within CPU-time limit.
9. description IPC-4 domains relative variants, reader visit
official web site IPC-4 (http://ls5-www.cs.uni-dortmund.de/edelkamp/ipc-4/index.html).
extended versions IPC-3 domains used experiments available
http://zeus.ing.unibs.it/lpg/TestsIPC3-TIL.tgz.

207

fiGerevini, Saetti & Serina

focusing analysis IPC-4 domains involving timed initial literals,
Table 1 give brief overview results IPC-4 (satisficing) planners,
terms planning capabilities problems attempted/solved planner. table
summarizes results domain variants IPC-4. lpg-td sgplan (Chen, Hsu,
& Wah B., 2004) planners supporting major features PDDL2.1
PDDL2.2. planners good success ratio (close 80%). downward (Helmert,
2004) yahsp (Vidal, 2004) success ratio better lpg-td sgplan,
handle propositional domains (downward supports derived predicates,
yahsp not). sgplan attempted problems lpg-td tested
compiled version variants derived predicates timed initial literals. 10
Moreover, lpg-td attempt numerical variant two versions Promela
domain ADL variant PSR-large, use equality numerical
preconditions conditional effects, currently planner support.
Figure 6 shows performance lpg-td variants three domains involving
predictable exogenous events respect (satisficing) planners IPC-4 supporting timed initial literals: sgplan, p-mep (Sanchez et al., 2004) tilsapa (Kavuluri
& U, 2004). Airport (upper plots figure), lpg-td solves 45 problems 50,
sgplan 43, p-mep 12, tilsapa 7. terms CPU-time, lpg-td performs much better
p-mep tilsapa. lpg-td faster sgplan nearly problems (except
problems 1 43). particular, gap performance problems 2131 nearly
one order magnitude. Regarding plan quality, performance lpg-td similar
performance p-mep tilsapa, while, overall, sgplan finds plan worse quality
(with exception problems 41 43, sgplan performs slightly better,
easiest problems lpg-td sgplan perform similarly).
lpg-td tilsapa planners IPC-4 attempted variant
PipesWorld timed initial literals (central plots Figure 6). lpg-td solves 23 problems 30, tilsapa solves 3 problems. domain variant lpg-td performs
much better tilsapa.
flaw version Umts (bottom plots Figure 6), lpg-td solves 50 problems,
sgplan solves 27 problems (p-mep tilsapa attempt domain variant).
Moreover, lpg-td one order magnitude faster sgplan every problem
solved. Compared IPC-4 benchmark problems, Umts problems generally
easier solve. test problems, main challenge finding plans good quality.
Overall, best quality plans lpg-td much better sgplan plans, except
simplest problems two planners generate plans similar quality. basic
version Umts without flawed actions, sgplan solves problems lpg-td, terms
plan quality lpg-td performs much better.
Figure 7 shows results Wilcoxon sign-rank test, known Wilcoxon
matched pairs test (Wilcoxon & Wilcox, 1964), comparing performance lpg-td
planners attempted benchmark problems IPC-4 involving timed initial literals. test used Long Fox (2003a) comparing performance
10. versions generated planners support features PDDL2.2.
competition test lpg-td problems compiled domains planner
supports original version domains. lpg-td attempted every problem (uncompiled)
IPC-4 domains could attempt terms planning language supports.

208

fiAn Approach Temporal Planning Scheduling

Airport-Windows

Milliseconds
1e+07

LPG-td.s (45 solved)
P-MEP (12 solved)
SGPlan (43 solved)
TilSapa (7 solved)

1e+06

Airport-Windows

Makespan
1400

LPG-td.bq (45 solved)
P-MEP (12 solved)
SGPlan (43 solved)
TilSapa (7 solved)

1200

1000
100000
800
10000
600
1000
400
100

200

10

0
0

5

10

15

20

25

30

35

40

45

PipesWorldNoTankage-Deadlines

Milliseconds
1e+07

0

5

10

15

20

25

30

35

40

45

PipesWorldNoTankage-Deadlines

Makespan
30

LPG-td.bq (23 solved)
TilSapa (3 solved)

LPG-td.s (23 solved)
TilSapa (3 solved)
1e+06

25

100000

20

10000

15

1000

10

100

5

10

0
0

5

10

15

20

25

30

UmtsFlaw-Windows

Milliseconds
10000

0

5

10

15

20

25

30

UmtsFlaw-Windows

Makespan
1900

LPG-td.s (50 solved)
SGPlan (27 solved)

LPG-td.bq (50 solved)
SGPlan (27 solved)
1850
1800

1000

1750
1700
1650

100

1600
1550
1500

10

1450
0

5

10

15

20

25

30

35

40

45

50

0

5

10

15

20

25

30

35

40

45

Figure 6: CPU-time plan quality lpg-td, p-mep, sgplan, tilsapa three
IPC-4 domains timed initial literals. x-axis problem
names simplified numbers. plots left, y-axis
CPU-milliseconds (logarithmic scale); plots right, y-axis
plan makespan (the lower better).
209

50

fiGerevini, Saetti & Serina

lpg-td.s vs p-mep
5.841
< 0.001
45

lpg-td.bq vs p-mep
< 0.001
12

CPU-Time Analysis
lpg-td.s vs sgplan
3.162
(0.0016)
197

lpg-td.s vs tilsapa
10.118
< 0.001
136

Plan Quality Analysis
lpg-td.bq vs sgplan lpg-td.bq vs tilsapa
9.837
6.901
< 0.001
< 0.001
154
63

Figure 7: Results Wilcoxon test performance lpg-td compared
IPC-4 (satisficing) planners terms CPU-times plan quality benchmark problems timed initial literals.

lpg-td.s

sgplan

tilsapa

p-mep

CPU-Time

lpg-td.bq

sgplan

tilsapa

p-mep



B:

consistently better B



B:

better B
significant number times
(confidence level 99.84%)

Plan Quality

Figure 8: Partial order performance IPC-4 (satisficing) planners according
Wilcoxon test benchmark problems timed initial literals.
dashed arrow indicates performance relationship holds confidence
level slightly less 99.9%.

IPC-3 planners. CPU-time analysis, consider problems attempted
compared planners solved least one (when planner
solve problem, corresponding CPU-time IEEE arithmetic representation
positive infinity). plan quality (makespan) analysis, consider problems
solved compared planners.
210

fiAn Approach Temporal Planning Scheduling

order carry Wilcoxon test, planning problem computed
difference CPU-times two planners compared, defining samples
test CPU-time analysis. Similarly, test concerning plan quality
analysis computed differences makespan plans generated
two planners. absolute values differences ranked increasing numbers
starting lowest value. (The lowest value ranked 1, next lowest value
ranked 2, on.) sum ranks positive differences, sum
ranks negative differences. performance two planners significantly
different, number positive differences approximately equal
number negative differences, sum ranks set positive
differences approximately equal sum ranks set. Intuitively,
test considers weighted sum number times one planner performs better
other. sum weighted test uses performance gap assign rank
performance difference.
cell Figure 7 gives result comparison performance
lpg-td another IPC-4 planner. number samples sufficiently large,
T-distribution used Wilcoxon test approximatively normal distribution.
Therefore, cells figure contain z-value p-value characterizing
normal distribution. higher z-value, significant difference
performance is. p-value represents level significance performance gap.
use confidence level 99.9%; hence, p-value lower 0.001,
performance compared planners statistically different. information
appears left (right) side cell, first (second) planner named title
cell performs better planner.11 analysis comparing CPUtime, value cell number problems solved least one planner;
analysis comparing plan quality, number problems solved
planners.
Figure 8 shows graphical description relative performance IPC-4 satisficing
planners according Wilcoxon test benchmark problems timed initial
literals. solid arrow planner planner B (or cluster planners B)
indicates performance statistically different performance B,
performs better B (every planner B). dashed arrow B
indicates better B significant number times, significant
Wilcoxon relationship B confidence level 99.9% (on
hand, relationship holds confidence level slightly less 99.9%). results
analysis say lpg-td consistently faster tilsapa p-mep,
faster sgplan significant number times. terms plan quality, lpg-td performs
consistently better p-mep, sgplan tilsapa.
Although lpg-td guarantee optimal plans, interesting compare
performance optimal planners took part IPC-4, especially see good
lpg-tds plans are. Figure 9 shows performance lpg-td best results
results optimal IPC-4 planners (AllOthers-Opt) temporal variants
Airport Umts (without flawed actions). plots plan quality (makespan)
11. p-value cell comparing lpg-td p-mep omitted number problems solved
lpg-td p-mep high enough approximate T-distribution normal distribution.

211

fiGerevini, Saetti & Serina

Airport-Time

Milliseconds
1e+07

Airport-Time

Makespan
1000

LPG-td.s (44 solved)
LPG-td.bq (44 solved)
AllOthers-Opt (21 solved)

LPG-td.s (44 solved)
LPG-td.bq (44 solved)
AllOthers-Opt (21 solved)

900

1e+06

800
700

100000

600
10000

500
400

1000

300
200

100

100
10

0
0

5

10

15

20

25

30

35

40

45

UMTS-Time

Milliseconds
1e+07

0

5

10

15

20

30

35

40

45

UMTS-Time

Makespan
900

LPG-td.s (50 solved)
LPG-td.bq (50 solved)
AllOthers-Opt (38 solved)

25

LPG-td.s (50 solved)
LPG-td.bq (50 solved)
AllOthers-Opt (38 solved)

850

1e+06
800
100000
750

10000

700

650
1000
600
100
550

10

500
0

5

10

15

20

25

30

35

40

45

50

0

5

10

15

20

25

30

35

40

45

50

Figure 9: Performance lpg-td best optimal planners IPC-4
(AllOthers-Opt) Airport-Time Umts-Time: CPU-time logarithmic scale
(left plots) plan makespan (right plots). x-axis problem
names simplified numbers.

show that, nearly every problem domains, best quality plan found lpg-td
optimal solution, first plan found lpg-td generally good solution.
plots CPU-time show lpg-td finds plan much quickly
optimal planner, CPU-time required lpg-td find best plan often
lower CPU-time required AllOthers-Opt (except problems 12, 16, 18
20 Airport). noted lpg-td.bq last plan sequence
computed plans increasing quality (and CPU-time). intermediate plans
sequence could already good quality. particular, shown plan quality plot
Airport, first plan (lpg-td.s) solving problem 12 near-optimal quality,
computed much quickly lpg-td.bq plan AllOthers-Opt plan.
212

fiAn Approach Temporal Planning Scheduling

Figure 10: Plan quality distance solutions found lpg-td corresponding optimal solutions. x-axis, classes quality distance
(e.g., 1025% means plan generated lpg-td worse
optimal plan factor 0.1 0.25). y-axis,
percentage solved problems classes.

Finally, Figure 10 gives results general analysis plan quality distance,
considering metric-temporal STRIPS variants IPC-4 domains. 12 analysis
uses problems solved least one IPC-4 optimal planner. important
note consider plans generated incremental process lpg-td using
CPU-time CPU-time required fastest optimal planner (AllOthersOpt). Overall, results Figure 10 provide significant empirical evidence supporting
claim often incremental local search approach allows us compute plans
good quality using less CPU-time optimal approach. particular,
bars 0%1% class plot metric-temporal problems show
percentage test problems best quality plan lpg-td (lpg-td.bq)
optimal nearly optimal (i.e., plan quality worse optimal factor
0 0.01, 0 meaning difference) 90%. Moreover, often first plan
computed lpg-td (lpg-td.s) good quality: 60% plans quality
optimal nearly optimal, 25% quality worse
optimal factor greater 0.5.
Interestingly, plot right Figure 10 shows similar results concerning good
quality lpg-tds plans STRIPS problems IPC-4 (with lower percentage
lpg-td.s plans 0%1% class, slightly higher percentage
lpg-td.bqs plans > 50% class).
4.2 Temporal Reasoning LPG-td
conducted two main experiments. first aimed testing performance
lpg-td number windows timed initial literals varies problems
12. STRIPS problems, plan quality metric number actions plan.

213

fiGerevini, Saetti & Serina

initial state goals. second experiment focused temporal
reasoning techniques main goals empirically evaluating performance,
understanding impact overall performance lpg-td.
experiments used two well-known IPC-3 domains, modified
include timed initial literals: Rovers ZenoTravel. version Rovers timed
initial literals obtained IPC-3 temporal version follows. problem
specification, waypoint, added collection pairs timed initial literals
type
(at t1 (in sun waypoint0))
(at t2 (not (in sun waypoint0)))

t1 < t2 . pairs defines time window involved literal.
operator specification file, recharge operator precondition
(over (in sun ?w))

imposes constraint recharging actions applied rover
sun (?w operator parameter representing waypoint recharging action.)
modified version ZenoTravel obtained similarly. problem specification,
city added collection pairs timed initial literals type
(at t1 (open-station city0))
(at t2 (not (open-station city0)))

operator specification file, added timed precondition
(over (open-station ?c))

refuel operator, ?c operator parameter representing city
refuel action executed.
Given planning problem collection time windows W timed literal ,
noted that, general, difficulty solving affected three parameters:
number windows W , size, way distributed time
line.13 considered two methods generating test problems taking account
parameters ( indicates original IPC-3 problem either Rovers ZenoTravel
domain, n indicates number windows W ):
(I) Let best (shortest makespan) plan among generated lpg-td
solving within certain CPU-time limit, makespan . time
interval [0, t] divided 2n 1 sub-intervals equal size. time windows
timed literal extended problem 0 odd sub-intervals [0, t],
i.e.,

nh
h

h
3t

2t
, 2n1
,

.
W = 0, 2n1
, 2n1
, . . . , (2n2)t
2n1
(II) Let maximum duration action timed precondition .
time interval = [0, (2n 1)] divided 2n 1 sub-intervals duration d.
13. general, parameters influence hardness temporal reasoning planning,
logical part planning process (i.e., selection actions forming plan,
lpg-td done using heuristics taking exogenous events account).

214

fiAn Approach Temporal Planning Scheduling

Rovers-Windows

Milliseconds
10000

ZenoTravel-Windows

Milliseconds
1e+06

1 time window per waypoint
10 time windows per waypoint

1 time window per city
10 time windows per city

100000

1000
10000

1000
100

100

10

10
0

2

4

6

8

10

12

14

16

18

20

0

2

4

6

8

10

12

14

16

18

20

Figure 11: Performance lpg-td Rovers ZenoTravel domains extended
timed initial literals (1 10 time windows timed literal). test
problems generated using method I. x-axis problem
names simplified numbers; y-axis CPU-milliseconds (logarithmic scale).

Similarly method (I), time windows extended problem 0
odd sub-intervals .
Notice use first method number windows relatively
small because, many time windows small size, extended problem
become unsolvable (no window large enough schedule necessary action
timed precondition). second method designed avoid problem,
used test techniques planning problems involving many time windows.
Figures 11 12 give results first experiment. CPU-times plots
median values five runs problem. results Figure 11, use
IPC-3 test problems modified method I, results Figure 12 use
IPC-3 test problems modified method II. cases lpg-td solves problems.
plots Figure 11 indicate performance degradation number
windows increases 1 10 generally moderate, except two cases. plots
Figure 12 indicate that, number windows increases exponentially 1
10,000, approach scales well benchmark problems considered. instance,
consider first ZenoTravel problem. 1 window lpg-td solves problem 10
milliseconds, 10 windows 20 milliseconds, 100 windows 30 milliseconds,
1000 windows 100 milliseconds, 10,000 windows 1 second.
Moreover, observed performance degradation mainly determined heavier
pre-processing phase (parsing instantiation operators).
Tables 2 3 give results concerning experiment temporal reasoning
techniques implemented lpg-td. consider problems 10 time windows
(for timed fluent) used tests Figure 11, examine computational
215

fiGerevini, Saetti & Serina

Performance LPG-td Rovers-TimeWindows

Milliseconds
100000

Performance LPG-td ZenoTravel-TimeWindows

Milliseconds
1e+06

1 time window per waypoint
10 time windows per waypoint
100 time windows per waypoint
1000 time windows per waypoint
10,000 time windows per waypoint

1 time window per city
10 time windows per city
100 time windows per city
1000 time windows per city
10,000 time windows per city

100000

10000

10000
1000
1000

100
100

10

10
0

2

4

6

8

10

12

14

16

18

20

0

2

4

6

8

10

12

14

16

18

20

Figure 12: Performance lpg-td Rovers ZenoTravel domains extended
timed initial literals (110,000 time windows timed literal). test
problems generated using method II. x-axis problem
names simplified numbers; y-axis CPU-milliseconds (logarithmic scale).

cost temporal reasoning planning problems. approach temporal
planning, search step defines set temporal constraints formed ordering
scheduling constraints current TDA-graph. Table 2 gives statistical information
DTPs using compact constraint representation lpg-td classical
DTP representation. action TDA-graph, two temporal variables
(the start/end times action), except astart aend (for which, pointed out,
use one variable). number scheduling constraints number
ordering constraints depend actions current TDA-graph,
actions (causally exclusively) related other, respectively (we
one scheduling constraint action timed precondition TDA-graph).
Notice representation scheduling constraints much compact
classical DTP formulation.14
table gives information average number DTPs (i.e., search steps)
generated planning, indicating many satisfiable (indicated
Sat. DTPs).
Table 3 gives CPU-time required temporal reasoning techniques implemented
lpg-td (Solve-DTP+ ) tsat++ (Armando, Castellini, Giunchiglia, & Maratea,
2004), state-of-the-art general DTP solver. DTPs considered
Table 2, i.e., sets temporal constraints TDA-graph search
14. classical DTP-translation scheduling constraint contains exponential number disjuncts
respect number time windows scheduling constraint. example, let q
timed precondition Wq = {[25, 50), [75, 125)}. scheduling constraint determined q

+

translated four classical DTP constraints (as abbreviates astart ): (a+
25 75),
+
+

+
+
+
+
+

+
+

50







75),
(a



50



125),
(a





25




(a+
125).






216

fiAn Approach Temporal Planning Scheduling

Problems
Rovers
Problem 1
Problem 5
Problem 10
Problem 15
Problem 20
ZenoTravel
Problem 1
Problem 5
Problem 10
Problem 15
Problem 20

Variables
max mean
28
56
94
98
206

18.4
30.0
65.8
58.8
105.0

8
36
114
172
282

6
20
83.4
122.4
194.6

SC 10 windows (DC)
max
mean
1
2
2
3
4

(1024)
(2048)
(2048)
(3072)
(4096)

1 (1024)
3 (3072)
16 (16,384)
24 (24,576)
42 (43,008)

DTPs
(Sat. DTPs)

0.13 (136.5)
0.33 (341.3)
1.41 (1447)
1.01 (1037)
1.45 (1489)

15 (15)
27 (27)
104 (47)
77 (55)
108 (108)

0.33 (341.3)
0.88 (910.2)
10.5 (10,769)
16.3 (16,673)
24.9 (25,536)

3 (3)
18 (18)
1162 (175)
291 (128)
750 (637)

Table 2: Characteristics DTPs generated planning lpg-td solving
problems Rovers ZenoTravel domains: maximum/mean number variables (2nd/3rd columns); maximum/mean number scheduling constraints (SC) non-unary disjunctions (DC) DTP-form translation (4th/5th columns); number DTPs satisfiable DTPs solved lpg-td
(6th column).

step planning process. noted comparison Solve-DTP +
tsat++ means intended determine one better other. Indeed
tsat++ developed manage much larger class DTPs. However, best
knowledge exists specialized DTP-solver handling scheduling constraints could used. goal comparison experimentally show
existing general DTP solvers, although designed work efficiently general case,
adequate managing class DTPs arise planning framework.
Hence, important develop specialized techniques which, empirically demonstrated results Table 3, much efficient. instance, consider problem
15 Rovers domain. indicated last column Table 2, lpg-td solves
problem 77 search steps, defines 77 DTPs. data Table 3 show
total CPU-time spent lpg-td solving temporal reasoning problems
negligible (< 106 seconds), tsat++ requires 16.8 CPU-seconds total (note
whole temporal planning problem solved lpg-td 0.25 seconds). 15 Overall,
specialized temporal reasoning technique several orders magnitude faster
efficient general DTP, terms CPU-time solving single DTP, CPU-time
solving DTPs generated planning.
15. CPU-time tsat++ includes neither generation explicit (classical) DTPs TDAgraph, parsing time. Moreover, tsat++ decides satisfiability input DTPs,
Solve-DTP+ finds schedule optimal, DTP satisfiable.

217

fiGerevini, Saetti & Serina

Problems

Rovers
Problem 1
Problem 5
Problem 10
Problem 15
Problem 20
ZenoTravel
Problem 1
Problem 5
Problem 10
Problem 15
Problem 20

CPU-seconds Temporal Reasoning
Solve-DTP+
tsat++
max
mean
total
max
mean
total

Total
CPU-Time
lpg-td

< 106
< 106
< 106
< 106
0.01

< 106
< 106
< 106
< 106
0.0008

< 106
< 106
< 106
< 106
0.03

0.005
0.045
0.54
0.54
3.17

0.002
0.002
0.039
0.028
0.10

0.09
0.14
12.7
16.8
107.1

0.02
0.03
0.30
0.25
3.03

< 106
< 106
0.01
0.01
0.01

< 106
< 106
0.00017
0.00014
0.00065

< 106
< 106
0.2
0.04
0.5

0.001
0.04
2.7
44.6
323.9

0.0003
0.004
9.8
3.9
24.2

0.01
0.21
6018
18,877
177,595

0.02
0.05
22.0
13.9
376.2

Table 3: Performance Solve-DTP+ tsat++ DTPs generated planning
lpg-td solving problems Rovers ZenoTravel domains:
maximum, mean total CPU-seconds. last column gives total CPUtime lpg-td solving planning problem. tsat++ run using default
settings.

Finally, experimentally tested effectiveness improvements Solve-DTP +
making algorithm incremental described end Section 2 (such
improvements included implementation Solve-DTP+ Table 3). particular
observed that, problems Table 3, average CPU-time basic (nonincremental) version Solve-DTP+ one three orders magnitude higher
incremental version. However, basic version still always significantly faster
tsat++ (from one four orders magnitude).

5. Related Work
Several researchers addressed temporal reasoning context DTP framework. general techniques aimed efficiently solving DTP proposed
(e.g., Armando et al., 2004; Tsamardinos & Pollack, 2003), worst-case complexity
remains exponential. Section 4, presented experimental results indicating
simple use state-of-the-art DTP solver adequate solving subclass
DTPs arise context.
Various planning approaches supporting temporal features considered paper
proposed. One first planners capable handling predictable
exogenous events deviser (Vere, 1983), developed nonlin (Tate, 1977).
deviser temporal partial order planner using network activities called plan
network. starting plan generation, plan network contains exogenous events
218

fiAn Approach Temporal Planning Scheduling

explicit nodes network. plan generation, activities added network
ordered respect scheduled events, depending relevance events
activities. similar explicit treatment exogenous events could adopted
context action-graph representation: initial action graph contains special
action nodes representing predicted exogenous events. However, simple method
disadvantages respect method, treats exogenous events
temporal level representation rather logical (causal) level. particular,
high number timed initial literals, explicit representation
exogenous events action graph could lead large graphs, causing memory
consumption problems possibly heavy CPU-time cost heuristic evaluation
(possibly large) search neighborhood.
late 80s early 90s temporal planners handling exogenous events
developed. general, systems use input descriptions planning problem/domain significantly different PDDL descriptions accepted modern
fully-automated planners. One successful among hsts (Frederking &
Muscettola, 1992; Muscettola, 1994), representation problem solving framework
provides integrated view planning scheduling. hsts represents predictable exogenous events non-controllable state variables. lpg-td hsts manage
temporal constraints, two systems use considerably different approaches temporal
planning (lpg-td adopts classical state-transition view change, hsts adopts
histories view change, Ghallab, Nau, & Traverso, 2003), based
different plan representations search techniques.
zeno (Penberthy, 1993; Penberthy & Weld, 1994) one first domain-independent
planners supports rich class metric-temporal features, including exogenous events.
zeno powerful extension causal-link partial-order planner ucpop (Penberthy &
Weld, 1992). However, terms computational performance, planner competitive recent temporal planners.
IxTeT (Ghallab & Laruelle, 1994; Laborie & Ghallab, 1995) another causal-link planner uses techniques ideas scheduling, temporal constraint reasoning,
graph algorithms. IxTeT supports expressive language temporal description actions, including timed preconditions features cannot
expressed PDDL2.2. expressive power language obtained cost increased semantic complexity (Fox & Long, 2005). observed Ghallab, Nau Traverso
(2003), IxTeT embodies compromise expressiveness complex temporal domains, planning efficiency; however, planner still remains noncompetitive
recent temporal planners.
Smith Weld (1999) studied extension Graphplan-style planning
managing temporal domains. proposed extension tgp planner makes
possible represent predictable exogenous events. tgp supports subclass
durative actions expressible PDDL2.1, prevents cases concurrency
PDDL2.1 admitted. tgp optimal planner (under assumed conservative
model action concurrency), lpg-td near-optimal (satisficing) planner. main
drawback tgp scale adequately.
recently, Edelkamp (2004) proposed method planning timed initial
literals based compiling action timed preconditions time window as219

fiGerevini, Saetti & Serina

sociated action, defining interval action scheduled.
gives efficient, polynomial algorithm based critical path analysis computing
optimal action schedule sequential plans generated using compiled representation. techniques presented Edelkamp assume unique time window
timed precondition. techniques propose general, sense
action representation treats multiple time windows associated timed precondition,
temporal reasoning method computes optimal schedules partially ordered plans
preserving polynomiality.
Cresswell Coddington (2004) proposed extension lpgp planner (Long
& Fox, 2003b) handle timed initial literals, represented special deadline
actions. literal asserted hold time represented deadline action
starting time initial state, duration t. deadline actions
plan construction translated particular linear inequalities that, together
equalities inequalities generated plan representation, managed
general linear programming solver. lpg-td uses different representation
encode timed initial literals special actions, temporal scheduling
constraints associated actions plan managed efficient algorithm
derived specializing general DTP solver.
order handle problems timed initial literals sapa planner (Do & Kambhampati, 2003), Do, Kambhampati Zimmerman (2004) proposed forward search
heuristic based relaxed plans, constructed exploiting technique similar
time slack analysis used scheduling (Smith & Cheng, 1993). Given set candidate
actions choosing action add relaxed plan construction, technique
computes minimum slack candidate action actions currently
relaxed plan. candidate action highest minimum slack preferred. lpg-td
uses different time slack analysis, exploited different way. method
selecting actions forming relaxed plan uses time slacks counting number
scheduling constraints would violated adding candidate action: prefer
candidate actions cause lowest number violations. Moreover, sapa
slack analysis limited actions relaxed plan, method considers
actions real plan construction.
dt-pop recent planner (Schwartz & Pollack, 2004) extending POP-style
planning action model involving disjunctive temporal constraints. language
dt-pop elegant express rich class temporal features,
indirectly (and less elegantly) expressed PDDL2.2 (Fox et al., 2004). treatment
temporal constraints required manage predictable exogenous events dt-pop
appears less efficient planner, since dt-pop uses general DTP solver
enhanced efficiency techniques, lpg-td uses polynomial solver specialized
subclass DTPs arise representation. dt-pop handles mutex actions
(threats) posting explicit temporal disjunctive constraints imposing disjointness
mutex actions, lpg-td implicitly decides disjunctions search time
choosing level graph actions inserted, asserting appropriate
precedence constraints. Moreover, search procedure heuristics dt-pop lpgtd significantly different.
220

fiAn Approach Temporal Planning Scheduling

IPC-4, planners reasoned timed initial literals tilsapa (Kavuluri &
U, 2004), sgplan (Chen et al., 2004), p-mep (Sanchez et al., 2004) lpg-td. first
two planners, time writing, best knowledge available literature
sufficiently detailed description clearly understand possible similarities
differences lpg-td treatment predictable exogenous events. Regarding
p-mep, planner uses forward state-space search guided relaxed plan heuristic which,
differently relaxed plans lpg-td, constructed without taking account
temporal aspects relaxed plan real plan construction (the makespan
constructed relaxed plans considered comparative evaluation).

6. Conclusions
presented techniques temporal planning domains certain fluents
made true false known times predictable exogenous events cannot
influenced actions available planner. external events present many
realistic domains, planner take account guarantee correctness
synthesized plans, generate plans good optimal quality (makespan),
use effective search heuristics fast planning.
approach, causal structure plan represented graph-based representation called TDA-graph, action ordering scheduling constraints managed
efficient constraint-based reasoning, plan search based stochastic local search
procedure. proposed algorithm managing temporal constraints
TDA-graph specialization general CSP-based method solving DTPs.
algorithm polynomial worst-case complexity and, combined plan
representation, practice efficient. presented local search
techniques temporal planning using new TDA-graph representation. techniques improve accuracy heuristic methods adopted previous version
lpg, extend consider action scheduling constraints evaluation
search neighborhood, based relaxed temporal plans exploiting (dynamic)
reachability information.
techniques implemented planner lpg-td. experimentally
investigated performance planner statistical analysis IPC-4 results
using Wilcoxons test. results analysis show planner performs well
compared recent temporal planners supporting predictable exogenous events,
terms CPU-time find valid plan quality best plan generated. Moreover,
comparison plans computed lpg-td generated optimal planners
IPC-4 shows often lpg-td generates plans good optimal quality.
Finally, additional experiments indicate temporal reasoning techniques manage
class DTPs arise context efficiently.
directions future work temporal planning within framework are:
extension local search heuristics temporal reasoning techniques explicitly handle action effects limited persistence delays; treatment predictable exogenous
events affecting numerical fluents discrete continuous way; development tech221

fiGerevini, Saetti & Serina

niques supporting controllable exogenous events;16 management actions
variable durations (Fox & Long, 2003), i.e., actions whose durations specified
inequalities constraining lower upper bounds, whose actual duration decided
planner.
Moreover, intend study integration framework techniques
goal partitioning subplan composition successfully used sgplan
(Chen et al., 2004) IPC-4, application approach plan revision.
latter already partially explored, simple strips domains using
less powerful search techniques (Gerevini & Serina, 2000).

Acknowledgments
paper revised extended version paper appearing Proceedings
Nineteenth International Joint Conference Artificial Intelligence (Gerevini, Saetti, &
Serina, 2005a). research supported part MIUR Grant anemone. work
Ivan Serina part carried Department Computer Information
Sciences University Strathclyde (Glasgow, UK), supported Marie Curie
Fellowship N HPMF-CT-2002-02149. would thank anonymous reviewers
helpful comments, Paolo Toninelli extended parser lpg-td handle
new language features PDDL2.2.

Appendix A: Reachability Information
techniques described paper computing action evaluation function use
heuristic reachability information minimum number actions required reach
preconditions domain action (N um acts) lower bound earliest
finishing time (Ef t) reachable actions (the actions whose preconditions reachable).
following, S(l) denotes state defined facts corresponding fact nodes
supported level l current TDA-graph. l = 1, S(l) represents initial state
planning problem (I).
action a, lpg-td pre-computes N um acts(a, I), i.e., estimated minimum
number actions required reach preconditions I, Ef t(a, I), i.e.,
estimated earliest finishing time (if reachable I). Similarly, fact f
reachable I, lpg-td computes estimated minimum number actions required
reach f (N um acts(f, I)) estimated earliest time f made
true plan starting (Et(f, I)). l > 1, N um acts(a, S(l)) Ef t(a, S(l))
computed search, depend action nodes
current TDA-graph levels preceding l. Since search many action nodes
added removed, operations N um acts(a, S(l)) Ef t(a, S(l))
could change (if operation concerns level preceding l), important
computed efficiently.
16. Consider instance transportation domain shuttle bus train station extra
run airport midnight booked advance. shuttle booking domain action
available planner, event night stop shuttle controlled planner.

222

fiAn Approach Temporal Planning Scheduling

ReachabilityInformation(I, O)
Input: initial state planning problem consideration (I) ground instances
(actions) operators (O);
Output: action a, estimate number actions (N um acts(a, I)) required reach
preconditions I, estimate earliest finishing time (Ef t(a, I)).
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.

forall facts f /* set facts precomputed operator instantiation phase */
f
N um acts(f, I) Et(f, I) 0; Action(f, I) astart ;
else N um acts(f, I) Et(f, I) ;
forall actions N um acts(a, I) Ef t(a, I) Lf t(a) ;
F I; Fnew I; O; Arev ;
( Fnew 6= Arev 6= )
F F Fnew ; Fnew ; Arev ; Arev ;
A0 = {a | P re(a) F } empty
action A0 ;
ComputeEFT(a, AX Et(f, I));
f P re(a)

< Ef t(a, I) Ef t(a, I) t;
Lf t(a) ComputeLFT(a);
Ef t(a, I) Lf t(a) /* scheduled */
ra RequiredActions(I, P re(a));
N um acts(a, I) > ra N um acts(a, I) ra;
forall f Add(a)
Et(f, I) >
Et(f, I) t;
Arev Arev {a0 | f P re(a0 )};
N um acts(f, I) > (ra + 1)
N um acts(f, I) ra + 1; Action(f, I) a;
Fnew Fnew Add(a) F ;
{a};

RequiredActions(I, G)
Input: set facts set action preconditions G;
Output: estimate min number actions required achieve facts G (ACTS).
1.
2.
3.
4.
5.
6.
7.
8.

ACT ;
G G I;
G 6=
g element G;
Action(g, I);
ACT ACT {a};
G G P re(a) bACT Add(b);
return(|ACT S|).

Figure 13: Algorithms computing heuristic information search cost
time reaching set facts G I.

223

fiGerevini, Saetti & Serina

Figure 13 gives ReachabilityInformation, algorithm used lpg-td computing
N um acts(a, I), Ef t(a, I), N um acts(f, I) Et(f, I). ReachabilityInformation similar
reachability algorithm used version lpg took part 2002 planning
competition (lpg-ipc3), significant differences. main differences are:
(i) order estimate earliest finishing time domain actions, ReachabilityInformation takes account scheduling constraints, considered
previous version algorithm;
(ii) algorithm used lpg-ipc3 applies domain action once, ReachabilityInformation apply once.
Notice (i) improves accuracy estimated finishing time actions
(Ef t), important piece information used search neighborhood
evaluation selecting actions forming temporal relaxed plans (see Section 3).
Moreover, (i) allows us identify domain actions cannot scheduled
time windows associated timed preconditions, pruned
away.
Regarding (ii), forward process computing reachability information,
action re-applied whenever estimated earliest time one preconditions
decreased. important two reasons. one hand, reconsidering actions already
applied useful lead better estimate action finishing times;
hand, necessary guarantee correctness reachability
algorithm. latter because, overestimate earliest finishing time action
scheduling constraint, could incorrectly conclude action cannot
scheduled (and would consider action inapplicable). action necessary
valid plan, incorrect estimate earliest finishing time could lead
incorrect conclusion planning problem unsolvable. words, estimated
finishing time action scheduling constraint lower bound actual
earliest finishing time.
ReachabilityInformation could used update N um acts(a, S(l)) Ef t(a, S(l))
action insertion/removal, l > 1 (when l > 1, instead I, input algorithm
S(l)). However, order make updating process efficient, revision done
selective focused way. Instead revising reachability information
graph modification (search step), evaluating search neighborhood
choosing estimated best modification. Specifically, repairing flawed level l,
update reachability information actions facts levels preceding
l updated yet. (For instance, suppose ith search step add
action level 5, (i + 1)th step add another action level 10.
(i + 1)th step need consider updating reachability information levels
610, since information levels 15 already updated ith step.)
sufficient search neighborhood repairing flawed level consideration
(l) contain graph modifications concerning levels preceding l.
describing steps ReachabilityInformation, need introduce notation. Add (a) denotes set positive effects a; Pre(a) denotes set
(non-timed) preconditions a; Arev denotes set actions already applied whose
224

fiAn Approach Temporal Planning Scheduling

reachability could revised estimated earliest time preconditions revised application. Given action node current
earliest start time computed maximum earliest times preconditions reachable, ComputeEFT (a, t) function computing earliest finishing
time consistent scheduling constraint (if any)
+ Dur(a) .17 ComputeLFT (a) function computing latest finishing time
action a, i.e., returns upper bound last time window
scheduled (if one exists), returns timed precondition.
example, let action preconditions true initial
state (i.e., = 0), duration 50, scheduling constraint imposing
action executed interval [25, 100). ComputeEFT (a, t) returns 75,
ComputeLFT (a, t) returns 100. Thus, scheduling constraint satisfied.
contrary, earliest start time 500, ComputeEFT (a, t) returns 550
cannot scheduled [25, 100).
sake clarity, first describe steps ReachabilityInformation used derive
N um acts, comment computation Ef t. steps 14,
every fact f , algorithm initializes N um acts(f, I) 0, f I, otherwise
(indicating f reachable); while, step 5, N um acts(a, I) initialized
(indicating reachable I). Then, steps 724 algorithm iteratively
constructs set F facts reachable I, starting F = I,
terminating F cannot extended set Arev actions reconsider
empty. set available actions initialized set possible actions
(step 6); reduced application (step 24), augmented set
actions Arev (step 8) action application. modify estimated time
precondition action becomes reachable, added rev (step 20).
internal while-loop (steps 924) applies actions current F , possibly deriving
new set facts Fnew step 23. Fnew Arev empty, F extended
Fnew , extended Arev , internal loop repeated. action A0
(the subset actions currently applicable F ) applied, reachability
information effects revised follows. First estimate minimum number
ra actions required achieve P re(a) using subroutine RequiredActions (step
15). use ra possibly update N um acts(a, I) N um acts(f, I) effect
f (steps 1516, 2122). number actions required achieve preconditions
lower current value N um acts(a, I), N um acts(a, I) set ra.
Moreover, application leads lower estimate f , i.e., ra + 1 less
current value N um acts(f, I), N um acts(f, I) set ra + 1. addition, data
structure indicating current best action achieve f (Action(f, I)) set
(step 22). information used subroutine RequiredActions.
fact f initial state, value Action(f, I) astart (step 3).
subroutine RequiredActions one reachability algorithm lpg-ipc3.
subroutine uses Action derive ra backward process starting input
set action preconditions (G), ending G I. subroutine incrementally
constructs set actions (ACTS) achieving facts G preconditions
17. scheduling constraint associated a, existing scheduling constraints cannot
satisfied starting action t, ComputeEFT (a, t) returns + Dur(a).

225

fiGerevini, Saetti & Serina

actions already selected (using Action). iteration set G revised adding
preconditions last action selected, removing facts belonging
effects actions already selected (step 7). Termination RequiredActions guaranteed
every element G reachable I.
briefly describe computation temporal information. Eft(a, I), computed way similar N um acts(a, I). steps 14, ReachabilityInformation initializes
estimated earliest time (Et(f, I)) fact f becomes reachable 0, f I,
otherwise; moreover, algorithm sets Ef t(a, I) Lf t(a, I) . Then, every
application action forward process described above, estimate earliest
finishing time Ef adding duration (current) maximum estimated earliest
time preconditions a, taking account scheduling constraints
using ComputeEFT (a) (step 11). addition, compute latest finishing time Lf
using ComputeLFT (a) (step 13). earliest finishing time action
greater latest finishing time, timed preconditions cannot satisfied
I, steps 1523 executed (see if-statement step 14). effect f
current temporal value higher earliest finishing time a, steps 1819
set Et(f, I) t, step 20 adds Arev (because decreased estimated
earliestx time f , revision could decrease estimated start time action
precondition f ).

Appendix B: Wilcoxon Test Metric-Temporal Domains IPC-4
appendix, present results Wilcoxon sign-rank test performance
lpg-td satisficing IPC-4 planners attempted metric-temporal
domains. performance evaluated terms CPU-times plan quality.
cell first two tables gives result comparison performance
lpg-td another IPC-4 planner. number samples sufficiently large,
T-distribution used Wilcoxon test approximatively normal distribution. Hence,
cell Figure give z-value p-value characterizing normal
distribution. higher z-value, significant difference performance
is. p-value represents level significance difference performance.
use confidence level 99.9%; therefore, p-value lower 0.001,
performance two planners statistically different. information appears
left (right) side cell, first (second) planner named title cell
performs better other. analysis comparing CPU-time, value
cell number problems solved least one planner; analysis
comparing plan quality, number problems solved planners.
pictures tables show partial order performance compared
planners terms CPU-time plan quality. solid edge planner another
planner B (or cluster planners B) indicates performance statistically
different performance B, performs better B (every planner
B). dashed edge B indicates better B significant number
times, significant Wilcoxon relationship confidence level
99.9%.
226

fiAn Approach Temporal Planning Scheduling

lpg-td.s vs crikey
11.275
< 0.001
169

Analysis CPU-Time
lpg-td.s vs p-mep
lpg-td.s vs sgplan
11.132
0.387
< 0.001
(0.699)
215
513

lpg-td.s vs tilsapa
12.324
< 0.001
136

lpg-td.bq vs crikey
10.500
< 0.001
173

Analysis Plan Quality
lpg-td.bq vs p-mep lpg-td.bq vs sgplan
4.016
16.879
< 0.001
< 0.001
21
452

lpg-td.bq vs tilsapa
6.901
< 0.001
63

lpg-td.s
crikey

p-mep

tilsapa

sgplan

CPU-Time

sgplan
lpg-td.bq
p-mep

crikey



B:

consistently better B

tilsapa



B:

better B significant number times
(confidence level 94.78%)

Plan Quality

227

fiGerevini, Saetti & Serina

References
Armando, A., Castellini, C., Giunchiglia, E., & Maratea, M. (2004). SAT-based decision
procedure boolean combination difference constraints. Proceedings
Seventh International Conference Theory Applications Satisfiability Testing
(SAT-04), Berlin, Heidelberg, New York. Springer-Verlag. SAT 2004 LNCS Volume.
Blum, A., & Furst, M. (1997). Fast planning planning graph analysis. Artificial
Intelligence, 90, pp. 281300.
Chen, Y., Hsu, C., & Wah B., W. (2004). SGPlan: Subgoal partitioning resolution
planning. Edelkamp, S., Hoffmann, J., Littman, M., & Younes, H. (Eds.),
Abstract Booklet Competing Planners ICAPS-04, pp. 3032.
Cresswell, S., & Coddington, A. (2004). Adapting LPGP plan deadlines. Proceedings Sixteenth European Conference Artificial Intelligence (ECAI-04),
pp. 983984, Amsterdam, Netherlands. IOS Press.
Dechter, R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artificial Intelligence, 49, pp. 6195.
Do, M., B., Kambhampati, S., & Zimmerman, T. (2004). Planning - scheduling connections
exogenous events. Proceedings ICAPS-04 Workshop Integrating
Planning Scheduling, pp. 3237.
Do, M., & Kambhampati, S. (2003). SAPA: multi-objective metric temporal planner.
Journal Artificial Intelligence Research (JAIR), 20, pp. 155194.
Edelkamp, S. (2004). Extended critical paths temporal planning. Proceedings
ICAPS-04 Workshop Integrating Planning Scheduling, pp. 3845.
Edelkamp, S., & Hoffmann, J. (2004). PDDL2.2: language classic part
4th international planning competition. Technical report 195, Institut fur Informatik,
Freiburg, Germany.
Edelkamp, S., Hoffmann, J., Littman, M., & Younes, H. (2004) Abstract Booklet
competing planners ICAPS-04.
Erschler, J., Roubellat, F., & Vernhes, J. P. (1976). Finding essential characteristics
feasible solutions scheduling problem. Operations Research (OR), 24, pp.
772782.
Fox, M., & Long, D. (2003). PDDL2.1: extension PDDL expressing temporal
planning domains. Journal Artificial Intelligence Research (JAIR), 20, pp. 61124.
Fox, M., & Long, D. (2005). Planning time. Fisher, M., Gabbay, D., & Vila, L. (Eds.),
Handbook Temporal Reasoning Artificial Intelligence, pp. 497536. Elsevier Science Publishers, New York, NY, USA.
Fox, M., Long, D., & Halsey, K. (2004). investigation expressive power
PDDL2.1. Proceedings Sixteenth European Conference Artificial Intelligence (ECAI-04), pp. 338342, Amsterdam, Netherlands. IOS Press.
Frederking, R., E., & Muscettola, N. (1992). Temporal planning transportation planning scheduling. IEEE International Conference Robotics Automation
(ICRA-92), pp. 11251230. IEEE Computer Society Press.
228

fiAn Approach Temporal Planning Scheduling

Gerevini, A., & Cristani, M. (1997). finding solution temporal constraint satisfaction
problems. Proceedings Fifteenth International Joint Conference Artificial
Intelligence (IJCAI-97), Vol. 2, pp. 14601465, San Francisco, CA, USA. Morgan
Kaufmann Publishers.
Gerevini, A., Saetti, A., & Serina, I. (2003). Planning stochastic local search
temporal action graphs. Journal Artificial Intelligence Research (JAIR), 20, pp.
239290.
Gerevini, A., Saetti, A., & Serina, I. (2004). empirical analysis heuristic features
local search LPG. Proceedings Fourteenth International Conference
Automated Planning Scheduling (ICAPS-04), pp. 171180, Menlo Park, CA,
USA. AAAI Press.
Gerevini, A., Saetti, A., & Serina, I. (2005a). Integrating planning temporal reasoning domains durations time windows. Proceedings Nineteenth
International Joint Conference Artificial Intelligence (IJCAI-05), pp. 12261235,
Menlo Park, CA, USA. International Joint Conference Artificial Intelligence Inc.
Gerevini, A., Saetti, A., Serina, I., & Toninelli, P. (2005b). Fast planning domains
derived predicates: approach based rule-action graphs local search.
Proceedings Twentieth National Conference Artificial Intelligence (AAAI05), pp. 11571162, Menlo Park, CA, USA. AAAI Press.
Gerevini, A., & Serina, I. (1999). Fast planning greedy action graphs. Proceedings
Sixteenth National Conference Artificial Intelligence (AAAI-99), pp. 503
510, Menlo Park, CA, USA. AAAI Press/MIT Press.
Gerevini, A., & Serina, I. (2000). Fast plan adaptation planning graphs: Local
systematic search techniques. Proceedings Fifth International Conference
Artificial Intelligence Planning Scheduling (AIPS-00), pp. 112121, Menlo Park,
CA, USA. AAAI Press/MIT Press.
Ghallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporal planner. Proceedings Second International Conference Artificial Intelligence
Planning Systems (AIPS-94), pp. 6167, Menlo Park, CA, USA. AAAI press.
Ghallab, M., Nau, D., & Traverso, P. (2003). Automated Planning: Theory Practice.
Morgan Kaufmann Publishers, San Francisco, CA, USA.
Glover, F., & Laguna, M. (1997). Tabu Search. Kluwer Academic Publishers, Boston, USA.
Helmert, M. (2004). planning heuristic based causal graph analysis. Proceedings
Fourteenth International Conference Automated Planning Scheduling
(ICAPS-04), pp. 161170, Menlo Park, CA, USA. AAAI Press.
Kavuluri, B. R., & U, S. (2004). Tilsapa - timed initial literals using SAPA. Edelkamp, S.,
Hoffmann, J., Littman, M., & Younes, H. (Eds.), Abstract Booklet Competing
Planners ICAPS-04, pp. 4647.
Laborie, P., & Ghallab, M. (1995). Planning sharable resource constraints. Proceedings Fourteenth International Joint Conference Artificial Intelligence
(IJCAI-95), Vol. 2, pp. 16431651, San Francisco, CA, USA. Morgan Kaufmann Publishers.
229

fiGerevini, Saetti & Serina

Long, D., & Fox, M. (2003a). 3rd international planning competition: Results
analysis. Journal Artificial Intelligence Research (JAIR), 20, pp. 159.
Long, D., & Fox, M. (2003b). Exploiting graphplan framework temporal planning.
Proceedings Thirteenth International Conference Automated Planning
Scheduling (ICAPS-03), pp. 5261, Menlo Park, CA, USA. AAAI Press.
McAllester, D., & Rosenblitt, D. (1991). Systematic nonlinear planning. Proceedings
Ninth National Conference Artificial Intelligence (AAAI-91), pp. 634639,
Menlo Park, CA, USA. AAAI Press.
Muscettola, N. (1994). HSTS: Integrating planning scheduling. Zweben, & Fox
(Eds.), Intelligent Scheduling, pp. 169212, San Francisco, CA, USA. Morgan Kaufmann Publishers.
Nguyen, X., & Kambhampati, S. (2001). Reviving partial order planning. Proceedings
Seventeenth International Joint Conference Artificial Intelligence (IJCAI-01),
Vol. 1, pp. 459464, San Francisco, CA, USA. Morgan Kaufmann Publishers.
Penberthy, J., & Weld, D. (1992). UCPOP: sound, complete, partial order planner
ADL. Proceedings Third International Conference Principles Knowledge
Representation Reasoning (KR92), pp. 103114, San Mateo, CA, USA. Morgan
Kaufmann Publishers.
Penberthy, J., & Weld, D. (1994). Temporal planning continuous change. Proceedings
Twelfth National Conference Artificial Intelligence (AAAI-94), pp. 1010
1015, Menlo Park, CA, USA. AAAI Press/MIT Press.
Penberthy, J., S. (1993). Planning Continuous Change. Ph.D. thesis, University
Washington, Seattle, WA, USA. Available technical report UW-CSE-93-12-01.
Sanchez, J., Tang, M., & Mali, A., D. (2004). P-MEP: Parallel expressive planner.
Edelkamp, S., Hoffmann, J., Littman, M., & Younes, H. (Eds.), Abstract Booklet
Competing Planners ICAPS-04, pp. 5355.
Schwartz, P., J., & Pollack, M., E. (2004). Planning disjunctive temporal constraints.
Proceedings ICAPS-04 Workshop Integrating Planning Scheduling,
pp. 6774.
Smith, D., & Weld, D. (1999). Temporal planning mutual exclusive reasoning.
Proceedings Sixteenth International Joint Conference Artificial Intelligence
(IJCAI-99), pp. 326337, San Francisco, CA, USA. Morgan Kaufmann Publishers.
Smith, S., & Cheng, C. (1993). Slack-based heuristics constraint satisfaction scheduling.
Proceedings Eleventh National Conference Artificial Intelligence (AAAI93), pp. 139144, Menlo Park, CA, USA. AAAI Press/The MIT press.
Stergiou, K., & Koubarakis, M. (2000). Backtracking algorithms disjunctions temporal
constraints. Artificial Intelligence, 120 (1), pp. 81117.
Tate, A. (1977). Generating project networks. Proceedings Fifth International
Joint Conference Artificial Intelligence (IJCAI-77), pp. 888889, Cambridge, MA,
USA. MIT, William Kaufmann.
230

fiAn Approach Temporal Planning Scheduling

Tsamardinos, I., & Pollack, M. E. (2003). Efficient solution techniques disjunctive
temporal reasoning problems. Artificial Intelligence, 151 (1-2), pp. 4389.
Vere, S. A. (1983). Planning time: Windows durations activities goals. IEEE
Transactions Pattern Analysis Machine Intelligence, 5 (3), pp. 246267.
Vidal, V. (2004). lookahead strategy heuristic search planning. Proceedings
Fourteenth International Conference Automated Planning Scheduling (ICAPS04), pp. 150159, Menlo Park, CA, USA. AAAI Press.
Wilcoxon, F., & Wilcox, R. A. (1964). Rapid Approximate Statistical Procedures.
American Cyanamid Co., Pearl River, NY, USA.

231


