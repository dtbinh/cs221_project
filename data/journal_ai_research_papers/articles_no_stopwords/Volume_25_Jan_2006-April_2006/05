journal artificial intelligence

submitted published

temporal scheduling
domains predictable exogenous events
alfonso gerevini
alessandro saetti
ivan serina

gerevini ing unibs
saetti ing unibs
serina ing unibs

dipartimento di elettronica per lautomazione
universita degli studi di brescia
via branze brescia italy

abstract
treatment exogenous events practically important many realworld domains preconditions certain plan actions affected events
focus temporal domains exogenous events happen
known times imposing constraint certain actions plan must executed
predefined time windows actions durations handling temporal constraints adds extra difficulty propose
domains integrates constraint temporal reasoning graph
framework local search techniques implemented planner
took part th international competition ipc statistical analysis
ipc demonstrates effectiveness terms
cpu time plan quality additional experiments good performance
temporal reasoning techniques integrated planner

introduction
many real world domains execution certain actions occur
predefined time windows one necessary conditions hold instance
car refueled gas station gas station open space telescope
take picture certain planet region region observable truth
conditions determined exogenous events happen known times
cannot influenced actions available agent e g
closing gas station planet movement
several frameworks supporting action durations time windows proposed
e g vere muscettola laborie ghallab schwartz pollack
kavuluri u sanchez tang mali however domaindependent systems fast enough large scale propose
temporal features integrating constraint
temporal reasoning graph framework
last two versions domain definition language international competition ipc support action durations predictable deterministic exogenous
events fox long edelkamp hoffmann pddl predictable exogenous events implicitly represented fox long halsey pddl
explicitly represented timed initial literals one two pddl
c

ai access foundation rights reserved

figerevini saetti serina

features competition ipc focused timed initial literals specified
description initial state assertions form
l real number l ground literal whose predicate
appear effects domain action obvious meaning l l
true time set assertions involving ground predicate defines
sequence disjoint time windows timed predicate holds example
well known zenotravel domain penberthy long fox





open fuelstation city
open fuelstation city
open fuelstation city
open fuelstation city

assertions define two time windows open fuelstation city true
e excluded excluded timed initial literal relevant
process precondition domain action call timed
precondition action timed precondition action seen temporal
scheduling constraint action defining feasible time window action
executed actions plan durations timed preconditions computing
valid plan requires reasoning time integrated order check
whether execution planned actions satisfy scheduling constraints
action plan cannot scheduled plan valid must revised
main contributions work representation temporal plans
action durations timed preconditions called temporally disjunctive action graph
tda graph integrating disjunctive constraint temporal reasoning recent
graph ii polynomial method solving disjunctive temporal reasoning arise context iii local search techniques
guide process representation iv experimental analysis
evaluating performance methods implemented planner called lpg td
took part ipc showing good performance many benchmark
td extension name planner abbreviation timed initial literals
derived predicates two main features pddl lpg td techniques
handling timed initial literals quite different techniques handling derived
predicates first ones concern representing temporal plans predictable exogenous
events fast temporal reasoning action scheduling second ones
concern incorporating rule inference system efficient reasoning derived
predicates timed initial literals derived predicates require
change heuristics guiding search planner radically different way
focus timed initial literals significant useful
extension pddl moreover analysis ipc shows lpg td
top performer benchmark involving feature treatment derived
predicates lpg td presented another recent gerevini et al b
derived predicates allow us express concise natural way indirect action effects informally predicates appear effect action truth determined
domain rules specified part domain description



fian temporal scheduling

organized follows section necessary background
introduce tda graph representation method solving disjunctive temporal
reasoning arise context section describe local
search heuristics space tda graphs section present
experimental analysis illustrating efficiency section discuss
related work finally section give conclusions

temporally disjunctive action graph
partial order causal link e g penberthy weld mcallester
rosenblitt nguyen kambhampati framework search space
partial plans search state partial temporal plan represent
temporally disjunctive action graph tda graph tda graph extension
linear action graph representation gerevini saetti serina integrates disjunctive temporal constraints handling timed initial literals linear action graph
variant well known graph blum furst section
necessary background linear action graphs disjunctive temporal constraints
introduce tda graphs propose techniques temporal reasoning
context representation used next section
background linear action graph disjunctive temporal constraints
linear action graph la graph directed acyclic leveled
graph alternating fact level action level fact levels contain fact nodes
labeled ground predicate fact node f level l associated
op action node level l representing dummy action predicate f
precondition effect action level contains one action node labeled
name domain action represents op nodes corresponding
level
action node labeled level l connected incoming edges fact nodes
level l representing preconditions precondition nodes outgoing edges
fact nodes level l representing effects effect nodes initial level
contains special action node astart last level special action node aend
effect nodes astart represent positive facts initial state precondition
nodes aend goals
pair action nodes possibly op nodes constrained persistent mutex
relation fox long e mutually exclusive relation holding every level
graph imposing involved actions never occur parallel valid plan
relations efficiently precomputed proposed previous
work gerevini et al
la graph contains set ordering constraints actions partial plan represented graph constraints constraints imposed
search deal mutually exclusive actions action level l mutex
action node b level l constrained finish start b ii
constraints actions implied causal structure plan action


figerevini saetti serina

used achieve precondition action b constrained finish start
b
effects action node automatically propagated next levels
graph corresponding ops interfering mutex action
blocking propagation last level graph reached gerevini et al
rest assume la graph incorporates propagation
disjunctive temporal dtp stergiou koubarakis tsamardinos
pollack pair hp ci p set time point variables c set
disjunctive constraints c cn ci form yi xi ki xi yi p ki
real number n c contains unary constraints dtp called simple
temporal stp dechter meiri pearl
dtp consistent dtp solution solution dtp
assignment real values variables dtp consistent every constraint
dtp computing solution dtp np hard dechter et al
computing solution stp accomplished polynomial time given
stp special start time variable preceding others compute
solution stp variable shortest possible distance n c
time n variables c constraints stp dechter et al gerevini cristani
call solution optimal solution stp clearly dtp consistent
choose constraint dtp disjunct obtaining consistent
stp solution stp solution original dtp
finally stp consistent distance graph stp
contain negative cycles dechter et al distance graph stp hp ci
directed labeled graph vertex labeled p p p edge v p
w p labeled k constraint w v k c
augmenting la graph disjunctive temporal constraints
let p timed precondition set w p time windows following x x
indicate start time end time x respectively x time window
action moreover al indicates action node level l la graph consideration
clarity presentation describe techniques focusing action preconditions
must hold whole execution action except end point
action operator effects hold end action execution e pddl
conditions type pddl effects type end fox long
order represent plans actions durations time windows
execution augment ordering constraints la graph action duration
constraints ii action scheduling constraints duration constraints form
dur
dur denotes duration action special actions start aend



dur astart dur aend since
start astart aend aend duration
constraints supported representation proposed previous work gerevini
methods planner support types operator condition effect specified
pddl



fian temporal scheduling

level

p

level

level

goal level



p

p

p

p
p

mutex

p





p



p



p






astart



p

p

p



p

p
mutex



astart

p







aend



p



p

p

p







p








p

aend




p



p



p






p



p



p















p

figure example la graph nodes labeled values round brackets
gantt chart actions labeling nodes la graph square
nodes action nodes circle nodes fact nodes action nodes marked
duration represented actions square brackets unsupported
precondition nodes labeled dashed edges form chains ops blocked
mutex actions grey areas gantt chart represent time windows
timed precondition p

et al representation treatment scheduling constraints major
contribution work
let plan represented la graph easy see set c formed
ordering constraints duration constraints actions
encoded stp instance ai used support precondition node aj


aj c ai aj two mutex actions ai ordered aj


aj c moreover every action following stp constraints
c
dur dur
equivalent dur scheduling constraint imposes constraint
execution action must occur time windows associated timed
precondition action syntactically disjunctive constraint c cn
ci form


yi x
hi vi ui ki

u
vi xi yi action start times action end times hi ki r every action
timed precondition p following disjunctive constraint added c



figerevini saetti serina



ww p











start w
start w

definition temporally disjunctive action graph tda graph tuple ha p ci

linear action graph
assignment real values nodes
p set time point variables corresponding start times end times
actions labeling action nodes
c set ordering constraints duration constraints scheduling constraints
involving variables p
tda graph ha p ci represents partial plan formed actions labeling
action nodes start times assigned figure gives la graph
values simple tda graph containing five action nodes astart aend
several fact nodes representing ten facts ordering constraints duration constraints
c













assuming p timed precondition windows
scheduling constraint c








start astart astart astart

pair hp ci defines dtp let ds set scheduling constraints
represents set stps consists constraints
ds one disjunct pair stp constraints disjunction subset
ds ds ds call consistent stp induced stp induced
stp contains disjunct every disjunction ds e ds ds say
consistent stp complete induced stp
values assigned action nodes action start times corresponding optimal solution induced stp call start times schedule
actions value labeling fact node f earliest time ta dur
note p timed condition action end time
exogenous event making p false happens pddl p required true end
fox long



brevity examples omit constraints
start ai ai aend action
ai well duration constraints astart aend duration zero
disjunctive constraints c exactly dtp form however easy see every
disjunctive constraint c translated equivalent conjunction constraints exact dtpform use compact notation clarity efficiency reasons



fian temporal scheduling

supports f starts ta induced stp derive
schedule incomplete may violate scheduling constraint action nodes
say unscheduled current tda graph
following definitions present notions optimality complete induced stp
optimal schedule used next section
definition given dtp point variable p complete induced stp
optimal induced stp p iff solution assigning p value less
equal value assigned p every solution every complete induced
stp
definition given dtp tda graph g optimal schedule actions
g optimal solution optimal induced stp
end
note optimal solution minimizes makespan represented possibly
partial plan dtp previous example figure two induced stps one
time window p one including pair stp constraints imposing
time window p stp obtained imposing time window
p induced stp dtp consistent partial induced
stp complete optimal start time aend temporal values
derived optimal solution assigned action nodes






tda graph
start astart aend aend
solving dtp tda graph
general computing complete induced stp dtp exists np hard
solved backtracking stergiou koubarakis tsamardinos
pollack however given particular structure temporal constraints
forming tda graph task accomplished polynomial time
backtrack free moreover computes optimal induced stp

end
following assume time window timed precondition shorter
duration action otherwise time window removed
available precondition time window remains action cannot
used valid plan moreover without loss generality assume
action one timed precondition easy see replace
set timed conditions action single equivalent timed precondition
whose time windows obtained intersecting windows forming different original
timed conditions set start timed conditions set end timed
conditions compiled single equivalent timed preconditions achieved
translating conditions conditions type idea similar
one presented edelkamp difference one
time window associated timed condition edelkamp assumes timed
condition associated unique time window specifically every start timed
condition p action translated equivalent timed condition p type
replacing scheduling constraint p


figerevini saetti serina

p

p

dur

dur

q

dur

r

r

x


















figure example set timed conditions compiled single timed precondition x solid boxes represent time windows associated timed
conditions p type start q type end r type
action solid box extended dashed box indicates extension
time window translation corresponding timed condition
timed condition



ww p











start w
start w

forcing occur one time windows


ww p










start w dur
start w

similarly every end timed condition p translated equivalent
timed condition replacing scheduling constraint


ww p











start w
start w

forcing occur one time windows


ww p











start w dur astart w

clearly translation timed conditions domain action single timed
precondition action accomplished preprocessing step polynomial time
figure shows example assume action duration timed conditions
p type start q type end r type let
time windows p time window q finally
time windows r compile timed conditions timed condition x
time window
note timed conditions type start end need use instead however
properties stps easily generalized stps extended constraints
e g gerevini cristani



fian temporal scheduling

solve dtp x
input set x meta variables meta csp dtp partial solution meta csp
output solution meta csp fail











x stop return
x selectvariable x x x x
x
selectvalue x
x x x
x x saving domain values
forwardcheck dtp x
solve dtp x
x x restoring domain values
return fail backtracking

forwardcheck dtp x
input set x meta variables partial solution
output true false







forall x x
forall x
consistency stp x
x x
x return false dead end
return true

figure basic solving dtp x global variable whose value
current domain meta variable x consistency stp returns true
stp formed variable values partial solution solution false
otherwise

observed stergiou kourbarakis tsamardinos pollack
dtp seen meta csp variables meta csp constraints
original csp values meta variables disjuncts forming
constraints original csp constraints meta csp explicitly
stated instead implicitly defined follows assignment values
meta variables satisfies constraints meta csp iff forms consistent stp
induced stp dtp solution meta csp complete induced stp
dtp
figure shows solving meta csp dtp tsamardinos
pollack variant forward checking backtracking solving
general csps appropriately choosing next meta variable instantiate function
selectvariable value function selectvalue finds
solution backtracking one exists moreover simple modification solve

figerevini saetti serina

dtp derive backtrack free even input meta csp
solution achieved exploiting information la graph
tda graph decompose dtp sequence growing dtps
dlast
last number levels ii variables vi di last
variables corresponding action nodes level iii
constraints di constraints involving variables vi e g






dtp figure point variables
start set
constraints



















start astart astart astart

decomposed dtp derive ordered partition set metavariables meta csp original dtp
x x x xlast
xi set meta variables corresponding constraints di di
otherwise ordered partition used define order
selectvariable chooses next variable instantiate crucial avoid backtracking specifically every variable single domain value e ordering constraint
duration constraint scheduling constraint one time window selected
every variable one possible value e scheduling constraint
one time window moreover xi xi xj xj j xi selected
xj
order avoid backtracking order selectvalue chooses value
meta variable important well given meta variable one value
time window current domain choose value corresponding earliest
available time window e g current domain selected meta variable
possible values












start wi astart wi

selectvalue chooses j th value wj wh every h
j h j
following give simple example illustrating order selectvariable
selectvalue select meta variables meta values respectively consider
tda graph figure additional time window timed precondition p dtp extended tda graph six meta variables x x x
whose domains disjuncts corresponding constraints original csp

x



x



fian temporal scheduling

x
x
x
x

















astart
astart astart astart




astart astart

exploiting level structure tda graph derive ordered partition
meta variables formed following sets
x x x x x x x x x
since x belongs x x belongs x selectvariable selects x selecting
x similarly function selects x meta variables x
instantiates x first meta value x e first time window timed precondition removed domain forward checking selectvalue selects








start astart astart astart
first meta value corresponds time window starting time
second one corresponds time window starting time
techniques selecting next meta variable instantiate
value prove following theorem
theorem given dtp tda graph meta csp x solvable
solve dtp finds solution x backtracking moreover solution optimal
induced stp
end
proof proof two key points way meta variables selected instantiated
selectvariable selectvalue respectively particular type constraints
disjunctive constraints specific form encoding set disjoint time windows
construction

j j
j ai




set ordering constraints duration constraints
aj
endpoint ai aj property cannot imply restriction
maximum distance endpoint ai endpoint aj course
lower bound distance e positive quantity u

j j
j ai u



let assume selectvariable chooses meta variable x cannot consistently
instantiated value x means reached backtracking point
cannot case
selectvariable chooses meta variables stp constraints metavariable scheduling constraint one value time window let x
set meta variables associated scheduling constraints
x must meta variable x assuming meta csp x
solvable use forward checking subroutine guarantees least one value x
consistent respect meta variables instantiated current partial


figerevini saetti serina

solution hence case step solve dtp forwardcheck dtp
returns false every value time window x e every x
exists another uninstantiated meta variable x x every x
check consistency stp x executed forward checking subroutine returns
false however x solution consistent cannot case
value chosen selectvalue instantiate x previously instantiated metavariables step earliest available time window current domain
meta variable consideration least commitment assignment
ii one scheduling constraint meta variable x level
tda graph
let action constrained scheduling constraint associated x since
selectvariable selects x x ii level following level
action constrained scheduling constraint associated x thus property
x could instantiated would every time window
constrains start early current partial solution x augmented
possible values x implies start time end
last time window assumption x solvable guarantee
cannot case
moreover since value every instantiated meta variable propagated forward
checking unassigned variables first value assigned metavariable value assigned variable solution found csp
easy see first value chosen selectvalue x feasible
forwardcheck dtp x returns false every next value chosen x
feasible
finally since value chosen selectvalue meta variable corresponds
earliest available window current domain meta variable follows
solution computed complete optimal induced stp
end
consequence previous theorem solve dtp performs backtracking step
input meta csp solution thus obtain general backtrack free
dtp tda graph simply replacing step
stop return fail
correctness modified called solve dtp follows
theorem next theorem states runtime complexity solve dtp polynomial
theorem given tda graph g dtp solve dtp processes meta csp
corresponding polynomial time respect number action nodes g
maximum number time windows scheduling constraint
noted main goal give complexity bound polynomial use
improved forward checking techniques e g tsamardinos pollack could lead complexity
bound lower one given proof theorem



fian temporal scheduling

proof time complexity depends number times forwardcheck dtp executed time complexity contains linear number variables respect
number n domain action nodes la graph tda graph n ordering constraints n duration constraints scheduling constraints hence
meta csp n meta variables one variable constraint original
csp let maximum number time windows scheduling constraint
forwardcheck dtp executed times meta variable x e n times
total consistency stp decides satisfiability stp involving n variables
accomplished n time dechter et al gerevini cristani note
variables stp processed consistency stp variables
original csp e starting time end time actions plan
finally consistency stp run n times run forwardcheck dtp
follows runtime complexity solve dtp n
exploiting structure temporal constraints forming dtp tdagraph make following additional changes solve dtp improving efficiency

instead starting empty assignment meta variable instantiated
initially every meta variable associated ordering constraint duration
constraint instantiated value x contains meta variables associated
scheduling constraints observed proof theorem meta
csp solvable values assigned meta variables initial form
consistent stp
forward checking performed meta variable
proof theorem shown meta csp solvable
first value chosen selectvalue feasible e forwardcheck dtp returns
true thus first value feasible stop return fail
meta csp solvable moreover omit steps
save restore domain values meta variables
finally improved made incremental exploiting particular
way update dtp tda graph e
search solution tda graph described next section described
next section search step addition action node certain
level l removal action node l cases suffices recompute
sub solution meta variables subsets xl xl xlast values
assigned meta variables assignment last solution
computed updating dtp part input
moreover order use local search techniques described next section
need another change basic detects x
solution instead returning failure keeps processing remaining meta variables
ii terminates returns partial induced stp si formed values
assigned meta variables optimal solution si defines assignment
tda graph


figerevini saetti serina

next section sg denotes induced stp dtp tda graph g computed method

local search techniques tda graphs
tda graph ha p ci contain two types flaw unsupported precondition nodes
called propositional flaws action nodes scheduled called
temporal flaws level contains flaw say level flawed example
time window p tda graph figure level would
flawed start time would violates scheduling constraint
imposing action must executed
tda graph flawed level represents valid plan called solution graph
section present heuristics finding solution graph search space
tda graphs heuristics used guide local search procedure called walkplan
originally proposed gerevini serina heart
search engine planner
initial tda graph contains astart aend search step identifies
neighborhood n g successor states current tda graph g search state
set tda graphs obtained g adding helpful action node removing
harmful action node attempt repair earliest flawed level g
following sake brevity refer action node tda graph
implicitly referring action node la graph tda graph similarly
level tda graph moreover remind reader l denotes action
level l la denotes level action
definition given flawed level l tda graph g action node helpful l iff
insertion g level l would remove propositional flaw l
definition given flawed level l tda graph g action node level l
harmful l iff removal g would remove propositional flaw l would
decrease value al al unscheduled
examples helpful action node harmful action node
action node representing action effect p helpful level tda graph
figure added level bear mind insertion action node
level determines expansion tda graph postponing level details
given end examples action node figure harmful level
precondition node p unsupported action node harmful level
blocks op propagation p level would support precondition node p
level moreover assuming w p unscheduled plan represented
la graph action node harmful level removal
designed several flaw selection strategies described experimentally evaluated
recent gerevini saetti serina strategy preferring flaws earliest level
graph tends perform better others used default strategy planner
details discussion strategy given aforementioned



fian temporal scheduling

would decrease temporal value contrary harmful level
removal would affect possible scheduling notice action
node helpful harmful harmful level helpful
goal level supports precondition node p aend
add action node level l empty la graph extended
one level action nodes l shifted forward one level e moved
next level action inserted level l similarly remove
action node level l graph shrunk removing level l additional
details process given another gerevini et al moreover
pointed previous section addition removal action node requires us
update dtp g adding removing appropriate ordering constraints
actions la graph g duration constraint scheduling
constraint updated dtp use method described
previous section revise compute possibly schedule actions g
e optimal solution sg
elements n g evaluated heuristic evaluation function e consisting
two weighted terms estimating additional search cost temporal cost e
number search steps required repair flaws introduced contribution
makespan represented plan respectively element n g lowest
combined cost selected noise parameter randomizing search escape
local minima gerevini et al addition order escape local minima
version planner uses short tabu list glover laguna rest
section focus search cost term e techniques use
evaluation temporal cost automatic setting term weights e
similar introduced previous work gerevini et al
search cost adding helpful action node repair flawed level l g
estimated constructing relaxed temporal plan achieving
unsupported precondition nodes denoted pre
propositional flaws remaining l adding denoted unsup l
supported precondition nodes action nodes g would become
unsupported adding denoted threats
moreover estimate number additional temporal flaws addition
g would determine e count number
action nodes g would become unscheduled adding g
ii unsatisfied timed preconditions unscheduled tda graph extended
iii action nodes scheduling constraint estimate cannot satisfied
context g
search cost adding g number actions plus ii iii
terms heuristic evaluation note action nodes


figerevini saetti serina

aend

goal level


p

p






p

action
b
b
b
b





p
p



p



p

p









p

p

est lower bound








q

p

p

p

relaxed plan

level


action
b
b
b
b

n um acts





anew



p

p

p

level
p
p

p
mutex

p







level






p

mutex

p

p
p
p









p
p
p



q

q





b



q




p



b


astart



p



q
p

b



q

p





b

p





p

figure example relaxed temporal plan square nodes represent action nodes
nodes represent fact nodes solid nodes correspond nodes
anew dotted nodes correspond precondition nodes action nodes
considered construction gray dotted nodes
selected inclusion action nodes marked duration
represented actions square brackets estimated start time
round brackets meaning num acts described text lower
bounds earliest action start times est lower bound computed
appendix

would ordered used achieve one
preconditions action nodes mutex given estimated end
time duration would excessively increase start time ii
consider original formulation timed preconditions e formulation
possible compilation one merged precondition discussed section
finally check scheduling constraint action consider estimated end
time relaxed subplan used achieve preconditions action
example relaxed temporal plan additional temporal flaws iiii
figure gives example evaluating addition anew level lagraph left side figure graph one used figure


fian temporal scheduling

relaxedtimeplan g
input set goal facts g initial state relaxed plan set reusable actions
output set actions acts forming relaxed plan g earliest time
facts g achieved















acts f aacts add
ax g g g f g g
g g
g f
g fact g f
b bestaction g
ha relaxedtimeplan pre b acts
b computeeft b
ax b
forall f add b

f f st b dur b
acts b f aacts add
return hacts ti

figure computing relaxed temporal plan computeeft b returns
estimated earliest finishing time b consistent scheduling
constraint b dur b example see
appendix add denotes set positive effects

helpful action node unsupported precondition p goals unsupported
preconditions q q anew initial state formed fact nodes
supported level actions anew b b numbers name
actions facts relaxed plan indicate order relaxedtimeplan
considers estimated start time end time b respectively
assume timed precondition q anew associated time window
concerning point action node g would become unscheduled adding
anew g concerning point ii anew unscheduled one timed precondition
unsatisfied q concerning point iii b cannot scheduled
context current tda graph g finally since contains three actions
sum ii iii search cost adding anew g level

evaluation tda graph derived removing harmful action node
flawed level l similar achieving
precondition nodes supported would become unsupported removing

la l unsupported precondition nodes level l become supported removing


figerevini saetti serina

regarding second point note l la flaws l eliminated
remove action automatically remove precondition nodes
la l removal could leave flaws level l
plan relaxed sense derivation ignores possible negative interference actions actions may unscheduled derivation
takes account actions already current partial plan plan represented
tda graph g particular actions current plan used define
initial state obtained applying actions g level la ordered
according corresponding levels moreover fact f marked temporal
value f corresponding time f becomes true remains
current subplan formed actions level la
relaxed plan constructed backward process called relaxedtimeplan see
figure extension relaxedplan proposed previous
work gerevini et al outputs two values set actions forming
sub relaxed plan estimated earliest finishing time used defined temporal
cost term e set actions acts forming derived running relaxedtimeplan
twice first goals pre initial state empty set reusable actions
goals unsup l hreats initial state threats add set reusable
actions formed actions computed first run plus
main novelty extended computing concerns choice
actions forming relaxed plan action b chosen achieve sub goal g action
minimizing sum
estimated minimum number additional actions required support propositional preconditions num acts b
number supported precondition nodes la graph would become
unsupported adding b g threats b
number timed preconditions b estimate would unsatisfied g
extended timedpre b
number action nodes scheduled estimate would become unscheduled adding b g timethreats b
formally action chosen bestaction g step relaxedtimeplan
achieve sub goal g action satisfying






argmin num acts threats timedpre timethreats
ag

ag g add set domain actions whose preconditions
reachable
num acts b computed given appendix threats b computed previous method deriving gerevini et al e considering
negative interactions mutex relations b precondition nodes
supported levels al timedpre b timethreats b components
action selection method computed follows


fian temporal scheduling

order compute timedpre b estimate earliest start time b est b
earliest finishing time b ef b values count number
timed preconditions b cannot satisfied ef b defined est b dur b
est b maximum
lower bound possible earliest start time b est lower bound b computed
reachability analysis given appendix
values action nodes ci current tda graph g la

mutex b addition b g would occur addition c
b
dtp g
maximum estimated lower bound time preconditions
b achieved relaxed plan estimate computed causal structure
relaxed plan duration scheduling constraints actions
values facts initial state
example timedpre
example figure estimated start time b maximum
est lower bound b maximum time estimated
times preconditions b supported p supported initial state
time q supported time notice mutex b
second point definition est b apply since estimated earliest
start time b duration b ef b thus assume
q associated time window timed precondition q b
cannot scheduled e q timedpre b
order compute timethreats b use following notion time slack
action nodes
definition given two action nodes ai aj tda graph ha p ci

c
aj slack ai aj maximum time value ai
consistently increased sg without violating time window chosen scheduling aj
order estimate whether action b time threat action node k
current tda graph extended action node adding repairing level
l l k check
b slack ak
holds b portion relaxed plan computed far b
estimated delay adding actions b g would cause start time
examples time slack timethreat
slack anew tda graph figure extended anew
even anew started could still executed time window
imposed timed precondition p anew started
would finish determined summing start time anew dur anew dur


figerevini saetti serina

dur scheduling constraint would violated assume
evaluating inclusion b relaxed plan figure achieving q
b anew
e estimated delay portion plan formed b would add end
time anew since slack anew
slack anew b anew
timethreats b contrary since
slack anew b anew
timethreats b
conclude section observe way consider scheduling constraints
evaluation search neighborhood similarity well known
technique used scheduling example suppose evaluating tda graphs
obtained adding helpful action node one among alternative possible levels
graph current tda graph contains another action node c mutex
search neighborhood contains two tda graphs corresponding adding
level lc adding level lc violates less scheduling
constraints according points iii preferred similar
heuristic method called constraint analysis proposed erschler roubellat
vernhes decide whether action scheduled another
conflicting action used scheduling work guiding search
toward consistent scheduling tasks involved e g smith cheng


experimental
implemented planner called lpg td obtained nd prize
metric temporal track satisficing planners th international competition ipc lpg td incremental planner sense produces sequence
valid plans improves quality previous ones plan quality
measured metric expression specified description
incremental process lpg td described another gerevini et al
essentially process iterates search solution graph additional constraint
lower bound plan quality determined quality previously
generated plans lpg td written c available http lpg ing unibs
section present experimental study two main goals
testing efficiency temporal predictable exogenous
events comparing performance lpg td recent planners
ipc attempted benchmark involving timed initial literals edelkamp
hoffmann littman younes


fian temporal scheduling

planner

lpg td
sgplan
p mep
crikey
lpg ipc
downward diag
downward
marvin
yahsp
macro
fap
roadmapper
tilsapa
optop

solved















attempted















success ratio















capabilities ipc
propositional dp metric temporal til
propositional dp metric temporal til
propositional metric temporal til
propositional metric temporal
propositional metric temporal
propositional dp
propositional dp
propositional dp
propositional
propositional
propositional
propositional
til
til

table number attempted solved success ratio satisficing planners took part ipc dp means derived predicates til means timed
initial literals propositional means strips adl capabilities pddl features test attempted planner
ipc

testing effectiveness proposed temporal reasoning techniques integrated
process understand particular impact overall
performance system compare existing techniques
first analysis consider test variant ipc metrictemporal domains involving timed initial literals comparison lpg td ipc
planners considering variants ipc metric temporal domains given
appendix b additional available web site planner
second experiments use domains obtained extending
two well known benchmark domains relative ipc timed
initial literals long fox
tests conducted intel xeon tm ghz gbytes ram ran lpg td
default settings every attempted
lpg td ipc planners
section use official ipc compare performance lpg td
planners took part competition performance lpg td
corresponds single run cpu time limit run minutes
termination forced lpg td indicates cpu time required planner derive
first plan lpg td bq indicates best quality plan found within cpu time limit
description ipc domains relative variants reader visit
official web site ipc http ls www cs uni dortmund de edelkamp ipc index html
extended versions ipc domains used experiments available
http zeus ing unibs lpg testsipc til tgz



figerevini saetti serina

focusing analysis ipc domains involving timed initial literals
table give brief overview ipc satisficing planners
terms capabilities attempted solved planner table
summarizes domain variants ipc lpg td sgplan chen hsu
wah b planners supporting major features pddl
pddl planners good success ratio close downward helmert
yahsp vidal success ratio better lpg td sgplan
handle propositional domains downward supports derived predicates
yahsp sgplan attempted lpg td tested
compiled version variants derived predicates timed initial literals
moreover lpg td attempt numerical variant two versions promela
domain adl variant psr large use equality numerical
preconditions conditional effects currently planner support
figure shows performance lpg td variants three domains involving
predictable exogenous events respect satisficing planners ipc supporting timed initial literals sgplan p mep sanchez et al tilsapa kavuluri
u airport upper plots figure lpg td solves
sgplan p mep tilsapa terms cpu time lpg td performs much better
p mep tilsapa lpg td faster sgplan nearly except
particular gap performance nearly
one order magnitude regarding plan quality performance lpg td similar
performance p mep tilsapa overall sgplan finds plan worse quality
exception sgplan performs slightly better
easiest lpg td sgplan perform similarly
lpg td tilsapa planners ipc attempted variant
pipesworld timed initial literals central plots figure lpg td solves tilsapa solves domain variant lpg td performs
much better tilsapa
flaw version umts bottom plots figure lpg td solves
sgplan solves p mep tilsapa attempt domain variant
moreover lpg td one order magnitude faster sgplan every
solved compared ipc benchmark umts generally
easier solve test main challenge finding plans good quality
overall best quality plans lpg td much better sgplan plans except
simplest two planners generate plans similar quality basic
version umts without flawed actions sgplan solves lpg td terms
plan quality lpg td performs much better
figure shows wilcoxon sign rank test known wilcoxon
matched pairs test wilcoxon wilcox comparing performance lpg td
planners attempted benchmark ipc involving timed initial literals test used long fox comparing performance
versions generated planners support features pddl
competition test lpg td compiled domains planner
supports original version domains lpg td attempted every uncompiled
ipc domains could attempt terms language supports



fian temporal scheduling

airport windows

milliseconds
e

lpg td solved
p mep solved
sgplan solved
tilsapa solved

e

airport windows

makespan


lpg td bq solved
p mep solved
sgplan solved
tilsapa solved





































pipesworldnotankage deadlines

milliseconds
e





















pipesworldnotankage deadlines

makespan


lpg td bq solved
tilsapa solved

lpg td solved
tilsapa solved
e




































umtsflaw windows

milliseconds
















umtsflaw windows

makespan


lpg td solved
sgplan solved

lpg td bq solved
sgplan solved




























































figure cpu time plan quality lpg td p mep sgplan tilsapa three
ipc domains timed initial literals x axis
names simplified numbers plots left axis
cpu milliseconds logarithmic scale plots right axis
plan makespan lower better




figerevini saetti serina

lpg td vs p mep




lpg td bq vs p mep



cpu time analysis
lpg td vs sgplan




lpg td vs tilsapa




plan quality analysis
lpg td bq vs sgplan lpg td bq vs tilsapa







figure wilcoxon test performance lpg td compared
ipc satisficing planners terms cpu times plan quality benchmark timed initial literals

lpg td

sgplan

tilsapa

p mep

cpu time

lpg td bq

sgplan

tilsapa

p mep



b

consistently better b



b

better b
significant number times
confidence level

plan quality

figure partial order performance ipc satisficing planners according
wilcoxon test benchmark timed initial literals
dashed arrow indicates performance relationship holds confidence
level slightly less

ipc planners cpu time analysis consider attempted
compared planners solved least one planner
solve corresponding cpu time ieee arithmetic representation
positive infinity plan quality makespan analysis consider
solved compared planners


fian temporal scheduling

order carry wilcoxon test computed
difference cpu times two planners compared defining samples
test cpu time analysis similarly test concerning plan quality
analysis computed differences makespan plans generated
two planners absolute values differences ranked increasing numbers
starting lowest value lowest value ranked next lowest value
ranked sum ranks positive differences sum
ranks negative differences performance two planners significantly
different number positive differences approximately equal
number negative differences sum ranks set positive
differences approximately equal sum ranks set intuitively
test considers weighted sum number times one planner performs better
sum weighted test uses performance gap assign rank
performance difference
cell figure gives comparison performance
lpg td another ipc planner number samples sufficiently large
distribution used wilcoxon test approximatively normal distribution
therefore cells figure contain z value p value characterizing
normal distribution higher z value significant difference
performance p value represents level significance performance gap
use confidence level hence p value lower
performance compared planners statistically different information
appears left right side cell first second planner named title
cell performs better planner analysis comparing cputime value cell number solved least one planner
analysis comparing plan quality number solved
planners
figure shows graphical description relative performance ipc satisficing
planners according wilcoxon test benchmark timed initial
literals solid arrow planner planner b cluster planners b
indicates performance statistically different performance b
performs better b every planner b dashed arrow b
indicates better b significant number times significant
wilcoxon relationship b confidence level
hand relationship holds confidence level slightly less
analysis say lpg td consistently faster tilsapa p mep
faster sgplan significant number times terms plan quality lpg td performs
consistently better p mep sgplan tilsapa
although lpg td guarantee optimal plans interesting compare
performance optimal planners took part ipc especially see good
lpg tds plans figure shows performance lpg td best
optimal ipc planners allothers opt temporal variants
airport umts without flawed actions plots plan quality makespan
p value cell comparing lpg td p mep omitted number solved
lpg td p mep high enough approximate distribution normal distribution



figerevini saetti serina

airport time

milliseconds
e

airport time

makespan


lpg td solved
lpg td bq solved
allothers opt solved

lpg td solved
lpg td bq solved
allothers opt solved



e











































umts time

milliseconds
e



















umts time

makespan


lpg td solved
lpg td bq solved
allothers opt solved



lpg td solved
lpg td bq solved
allothers opt solved



e





























































figure performance lpg td best optimal planners ipc
allothers opt airport time umts time cpu time logarithmic scale
left plots plan makespan right plots x axis
names simplified numbers

nearly every domains best quality plan found lpg td
optimal solution first plan found lpg td generally good solution
plots cpu time lpg td finds plan much quickly
optimal planner cpu time required lpg td best plan often
lower cpu time required allothers opt except
airport noted lpg td bq last plan sequence
computed plans increasing quality cpu time intermediate plans
sequence could already good quality particular shown plan quality plot
airport first plan lpg td solving near optimal quality
computed much quickly lpg td bq plan allothers opt plan


fian temporal scheduling

figure plan quality distance solutions found lpg td corresponding optimal solutions x axis classes quality distance
e g means plan generated lpg td worse
optimal plan factor axis
percentage solved classes

finally figure gives general analysis plan quality distance
considering metric temporal strips variants ipc domains analysis
uses solved least one ipc optimal planner important
note consider plans generated incremental process lpg td
cpu time cpu time required fastest optimal planner allothersopt overall figure provide significant empirical evidence supporting
claim often incremental local search allows us compute plans
good quality less cpu time optimal particular
bars class plot metric temporal
percentage test best quality plan lpg td lpg td bq
optimal nearly optimal e plan quality worse optimal factor
meaning difference moreover often first plan
computed lpg td lpg td good quality plans quality
optimal nearly optimal quality worse
optimal factor greater
interestingly plot right figure shows similar concerning good
quality lpg tds plans strips ipc lower percentage
lpg td plans class slightly higher percentage
lpg td bqs plans class
temporal reasoning lpg td
conducted two main experiments first aimed testing performance
lpg td number windows timed initial literals varies
strips plan quality metric number actions plan



figerevini saetti serina

initial state goals second experiment focused temporal
reasoning techniques main goals empirically evaluating performance
understanding impact overall performance lpg td
experiments used two well known ipc domains modified
include timed initial literals rovers zenotravel version rovers timed
initial literals obtained ipc temporal version follows
specification waypoint added collection pairs timed initial literals
type
sun waypoint
sun waypoint

pairs defines time window involved literal
operator specification file recharge operator precondition
sun w

imposes constraint recharging actions applied rover
sun w operator parameter representing waypoint recharging action
modified version zenotravel obtained similarly specification
city added collection pairs timed initial literals type
open station city
open station city

operator specification file added timed precondition
open station c

refuel operator c operator parameter representing city
refuel action executed
given collection time windows w timed literal
noted general difficulty solving affected three parameters
number windows w size way distributed time
line considered two methods generating test taking account
parameters indicates original ipc rovers zenotravel
domain n indicates number windows w
let best shortest makespan plan among generated lpg td
solving within certain cpu time limit makespan time
interval divided n sub intervals equal size time windows
timed literal extended odd sub intervals
e

nh
h

h



n



w n
n
n
n
ii let maximum duration action timed precondition
time interval n divided n sub intervals duration
general parameters influence hardness temporal reasoning
logical part process e selection actions forming plan
lpg td done heuristics taking exogenous events account



fian temporal scheduling

rovers windows

milliseconds


zenotravel windows

milliseconds
e

time window per waypoint
time windows per waypoint

time window per city
time windows per city


























































figure performance lpg td rovers zenotravel domains extended
timed initial literals time windows timed literal test
generated method x axis
names simplified numbers axis cpu milliseconds logarithmic scale

similarly method time windows extended
odd sub intervals
notice use first method number windows relatively
small many time windows small size extended
become unsolvable window large enough schedule necessary action
timed precondition second method designed avoid
used test techniques involving many time windows
figures give first experiment cpu times plots
median values five runs figure use
ipc test modified method figure use
ipc test modified method ii cases lpg td solves
plots figure indicate performance degradation number
windows increases generally moderate except two cases plots
figure indicate number windows increases exponentially
scales well benchmark considered instance
consider first zenotravel window lpg td solves
milliseconds windows milliseconds windows milliseconds
windows milliseconds windows second
moreover observed performance degradation mainly determined heavier
pre processing phase parsing instantiation operators
tables give concerning experiment temporal reasoning
techniques implemented lpg td consider time windows
timed fluent used tests figure examine computational


figerevini saetti serina

performance lpg td rovers timewindows

milliseconds


performance lpg td zenotravel timewindows

milliseconds
e

time window per waypoint
time windows per waypoint
time windows per waypoint
time windows per waypoint
time windows per waypoint

time window per city
time windows per city
time windows per city
time windows per city
time windows per city



























































figure performance lpg td rovers zenotravel domains extended
timed initial literals time windows timed literal test
generated method ii x axis
names simplified numbers axis cpu milliseconds logarithmic scale

cost temporal reasoning temporal
search step defines set temporal constraints formed ordering
scheduling constraints current tda graph table gives statistical information
dtps compact constraint representation lpg td classical
dtp representation action tda graph two temporal variables
start end times action except astart aend pointed
use one variable number scheduling constraints number
ordering constraints depend actions current tda graph
actions causally exclusively related respectively
one scheduling constraint action timed precondition tda graph
notice representation scheduling constraints much compact
classical dtp formulation
table gives information average number dtps e search steps
generated indicating many satisfiable indicated
sat dtps
table gives cpu time required temporal reasoning techniques implemented
lpg td solve dtp tsat armando castellini giunchiglia maratea
state art general dtp solver dtps considered
table e sets temporal constraints tda graph search
classical dtp translation scheduling constraint contains exponential number disjuncts
respect number time windows scheduling constraint example let q
timed precondition wq scheduling constraint determined q



translated four classical dtp constraints abbreviates astart




















































fian temporal scheduling


rovers





zenotravel






variables
max mean
























sc windows dc
max
mean


















dtps
sat dtps

























table characteristics dtps generated lpg td solving
rovers zenotravel domains maximum mean number variables nd rd columns maximum mean number scheduling constraints sc non unary disjunctions dc dtp form translation th th columns number dtps satisfiable dtps solved lpg td
th column

step process noted comparison solve dtp
tsat means intended determine one better indeed
tsat developed manage much larger class dtps however best
knowledge exists specialized dtp solver handling scheduling constraints could used goal comparison experimentally
existing general dtp solvers although designed work efficiently general case
adequate managing class dtps arise framework
hence important develop specialized techniques empirically demonstrated table much efficient instance consider
rovers domain indicated last column table lpg td solves
search steps defines dtps data table
total cpu time spent lpg td solving temporal reasoning
negligible seconds tsat requires cpu seconds total note
whole temporal solved lpg td seconds overall
specialized temporal reasoning technique several orders magnitude faster
efficient general dtp terms cpu time solving single dtp cpu time
solving dtps generated
cpu time tsat includes neither generation explicit classical dtps tdagraph parsing time moreover tsat decides satisfiability input dtps
solve dtp finds schedule optimal dtp satisfiable



figerevini saetti serina



rovers





zenotravel






cpu seconds temporal reasoning
solve dtp
tsat
max
mean
total
max
mean
total

total
cpu time
lpg td





















































































table performance solve dtp tsat dtps generated
lpg td solving rovers zenotravel domains
maximum mean total cpu seconds last column gives total cputime lpg td solving tsat run default
settings

finally experimentally tested effectiveness improvements solve dtp
making incremental described end section
improvements included implementation solve dtp table particular
observed table average cpu time basic nonincremental version solve dtp one three orders magnitude higher
incremental version however basic version still significantly faster
tsat one four orders magnitude

related work
several researchers addressed temporal reasoning context dtp framework general techniques aimed efficiently solving dtp proposed
e g armando et al tsamardinos pollack worst case complexity
remains exponential section presented experimental indicating
simple use state art dtp solver adequate solving subclass
dtps arise context
approaches supporting temporal features considered
proposed one first planners capable handling predictable
exogenous events deviser vere developed nonlin tate
deviser temporal partial order planner network activities called plan
network starting plan generation plan network contains exogenous events


fian temporal scheduling

explicit nodes network plan generation activities added network
ordered respect scheduled events depending relevance events
activities similar explicit treatment exogenous events could adopted
context action graph representation initial action graph contains special
action nodes representing predicted exogenous events however simple method
disadvantages respect method treats exogenous events
temporal level representation rather logical causal level particular
high number timed initial literals explicit representation
exogenous events action graph could lead large graphs causing memory
consumption possibly heavy cpu time cost heuristic evaluation
possibly large search neighborhood
late early temporal planners handling exogenous events
developed general systems use input descriptions domain significantly different pddl descriptions accepted modern
fully automated planners one successful among hsts frederking
muscettola muscettola representation solving framework
provides integrated view scheduling hsts represents predictable exogenous events non controllable state variables lpg td hsts manage
temporal constraints two systems use considerably different approaches temporal
lpg td adopts classical state transition view change hsts adopts
histories view change ghallab nau traverso
different plan representations search techniques
zeno penberthy penberthy weld one first domain independent
planners supports rich class metric temporal features including exogenous events
zeno powerful extension causal link partial order planner ucpop penberthy
weld however terms computational performance planner competitive recent temporal planners
ixtet ghallab laruelle laborie ghallab another causal link planner uses techniques ideas scheduling temporal constraint reasoning
graph ixtet supports expressive language temporal description actions including timed preconditions features cannot
expressed pddl expressive power language obtained cost increased semantic complexity fox long observed ghallab nau traverso
ixtet embodies compromise expressiveness complex temporal domains efficiency however planner still remains noncompetitive
recent temporal planners
smith weld studied extension graphplan style
managing temporal domains proposed extension tgp planner makes
possible represent predictable exogenous events tgp supports subclass
durative actions expressible pddl prevents cases concurrency
pddl admitted tgp optimal planner assumed conservative
model action concurrency lpg td near optimal satisficing planner main
drawback tgp scale adequately
recently edelkamp proposed method timed initial
literals compiling action timed preconditions time window

figerevini saetti serina

sociated action defining interval action scheduled
gives efficient polynomial critical path analysis computing
optimal action schedule sequential plans generated compiled representation techniques presented edelkamp assume unique time window
timed precondition techniques propose general sense
action representation treats multiple time windows associated timed precondition
temporal reasoning method computes optimal schedules partially ordered plans
preserving polynomiality
cresswell coddington proposed extension lpgp planner long
fox b handle timed initial literals represented special deadline
actions literal asserted hold time represented deadline action
starting time initial state duration deadline actions
plan construction translated particular linear inequalities together
equalities inequalities generated plan representation managed
general linear programming solver lpg td uses different representation
encode timed initial literals special actions temporal scheduling
constraints associated actions plan managed efficient
derived specializing general dtp solver
order handle timed initial literals sapa planner kambhampati kambhampati zimmerman proposed forward search
heuristic relaxed plans constructed exploiting technique similar
time slack analysis used scheduling smith cheng given set candidate
actions choosing action add relaxed plan construction technique
computes minimum slack candidate action actions currently
relaxed plan candidate action highest minimum slack preferred lpg td
uses different time slack analysis exploited different way method
selecting actions forming relaxed plan uses time slacks counting number
scheduling constraints would violated adding candidate action prefer
candidate actions cause lowest number violations moreover sapa
slack analysis limited actions relaxed plan method considers
actions real plan construction
dt pop recent planner schwartz pollack extending pop style
action model involving disjunctive temporal constraints language
dt pop elegant express rich class temporal features
indirectly less elegantly expressed pddl fox et al treatment
temporal constraints required manage predictable exogenous events dt pop
appears less efficient planner since dt pop uses general dtp solver
enhanced efficiency techniques lpg td uses polynomial solver specialized
subclass dtps arise representation dt pop handles mutex actions
threats posting explicit temporal disjunctive constraints imposing disjointness
mutex actions lpg td implicitly decides disjunctions search time
choosing level graph actions inserted asserting appropriate
precedence constraints moreover search procedure heuristics dt pop lpgtd significantly different


fian temporal scheduling

ipc planners reasoned timed initial literals tilsapa kavuluri
u sgplan chen et al p mep sanchez et al lpg td first
two planners time writing best knowledge available literature
sufficiently detailed description clearly understand possible similarities
differences lpg td treatment predictable exogenous events regarding
p mep planner uses forward state space search guided relaxed plan heuristic
differently relaxed plans lpg td constructed without taking account
temporal aspects relaxed plan real plan construction makespan
constructed relaxed plans considered comparative evaluation

conclusions
presented techniques temporal domains certain fluents
made true false known times predictable exogenous events cannot
influenced actions available planner external events present many
realistic domains planner take account guarantee correctness
synthesized plans generate plans good optimal quality makespan
use effective search heuristics fast
causal structure plan represented graph representation called tda graph action ordering scheduling constraints managed
efficient constraint reasoning plan search stochastic local search
procedure proposed managing temporal constraints
tda graph specialization general csp method solving dtps
polynomial worst case complexity combined plan
representation practice efficient presented local search
techniques temporal tda graph representation techniques improve accuracy heuristic methods adopted previous version
lpg extend consider action scheduling constraints evaluation
search neighborhood relaxed temporal plans exploiting dynamic
reachability information
techniques implemented planner lpg td experimentally
investigated performance planner statistical analysis ipc
wilcoxons test analysis planner performs well
compared recent temporal planners supporting predictable exogenous events
terms cpu time valid plan quality best plan generated moreover
comparison plans computed lpg td generated optimal planners
ipc shows often lpg td generates plans good optimal quality
finally additional experiments indicate temporal reasoning techniques manage
class dtps arise context efficiently
directions future work temporal within framework
extension local search heuristics temporal reasoning techniques explicitly handle action effects limited persistence delays treatment predictable exogenous
events affecting numerical fluents discrete continuous way development tech

figerevini saetti serina

niques supporting controllable exogenous events management actions
variable durations fox long e actions whose durations specified
inequalities constraining lower upper bounds whose actual duration decided
planner
moreover intend study integration framework techniques
goal partitioning subplan composition successfully used sgplan
chen et al ipc application plan revision
latter already partially explored simple strips domains
less powerful search techniques gerevini serina

acknowledgments
revised extended version appearing proceedings
nineteenth international joint conference artificial intelligence gerevini saetti
serina supported part miur grant anemone work
ivan serina part carried department computer information
sciences university strathclyde glasgow uk supported marie curie
fellowship n hpmf ct would thank anonymous reviewers
helpful comments paolo toninelli extended parser lpg td handle
language features pddl

appendix reachability information
techniques described computing action evaluation function use
heuristic reachability information minimum number actions required reach
preconditions domain action n um acts lower bound earliest
finishing time ef reachable actions actions whose preconditions reachable
following l denotes state defined facts corresponding fact nodes
supported level l current tda graph l l represents initial state

action lpg td pre computes n um acts e estimated minimum
number actions required reach preconditions ef e
estimated earliest finishing time reachable similarly fact f
reachable lpg td computes estimated minimum number actions required
reach f n um acts f estimated earliest time f made
true plan starting et f l n um acts l ef l
computed search depend action nodes
current tda graph levels preceding l since search many action nodes
added removed operations n um acts l ef l
could change operation concerns level preceding l important
computed efficiently
consider instance transportation domain shuttle bus train station extra
run airport midnight booked advance shuttle booking domain action
available planner event night stop shuttle controlled planner



fian temporal scheduling

reachabilityinformation
input initial state consideration ground instances
actions operators
output action estimate number actions n um acts required reach
preconditions estimate earliest finishing time ef

























forall facts f set facts precomputed operator instantiation phase
f
n um acts f et f action f astart
else n um acts f et f
forall actions n um acts ef lf
f fnew arev
fnew arev
f f fnew fnew arev arev
p f empty
action
computeeft ax et f
f p

ef ef
lf computelft
ef lf scheduled
ra requiredactions p
n um acts ra n um acts ra
forall f add
et f
et f
arev arev f p
n um acts f ra
n um acts f ra action f
fnew fnew add f


requiredactions g
input set facts set action preconditions g
output estimate min number actions required achieve facts g acts









act
g g
g
g element g
action g
act act
g g p bact add b
return act

figure computing heuristic information search cost
time reaching set facts g



figerevini saetti serina

figure gives reachabilityinformation used lpg td computing
n um acts ef n um acts f et f reachabilityinformation similar
reachability used version lpg took part
competition lpg ipc significant differences main differences
order estimate earliest finishing time domain actions reachabilityinformation takes account scheduling constraints considered
previous version
ii used lpg ipc applies domain action reachabilityinformation apply
notice improves accuracy estimated finishing time actions
ef important piece information used search neighborhood
evaluation selecting actions forming temporal relaxed plans see section
moreover allows us identify domain actions cannot scheduled
time windows associated timed preconditions pruned
away
regarding ii forward process computing reachability information
action applied whenever estimated earliest time one preconditions
decreased important two reasons one hand reconsidering actions already
applied useful lead better estimate action finishing times
hand necessary guarantee correctness reachability
latter overestimate earliest finishing time action
scheduling constraint could incorrectly conclude action cannot
scheduled would consider action inapplicable action necessary
valid plan incorrect estimate earliest finishing time could lead
incorrect conclusion unsolvable words estimated
finishing time action scheduling constraint lower bound actual
earliest finishing time
reachabilityinformation could used update n um acts l ef l
action insertion removal l l instead input
l however order make updating process efficient revision done
selective focused way instead revising reachability information
graph modification search step evaluating search neighborhood
choosing estimated best modification specifically repairing flawed level l
update reachability information actions facts levels preceding
l updated yet instance suppose ith search step add
action level th step add another action level
th step need consider updating reachability information levels
since information levels already updated ith step
sufficient search neighborhood repairing flawed level consideration
l contain graph modifications concerning levels preceding l
describing steps reachabilityinformation need introduce notation add denotes set positive effects pre denotes set
non timed preconditions arev denotes set actions already applied whose


fian temporal scheduling

reachability could revised estimated earliest time preconditions revised application given action node current
earliest start time computed maximum earliest times preconditions reachable computeeft function computing earliest finishing
time consistent scheduling constraint
dur computelft function computing latest finishing time
action e returns upper bound last time window
scheduled one exists returns timed precondition
example let action preconditions true initial
state e duration scheduling constraint imposing
action executed interval computeeft returns
computelft returns thus scheduling constraint satisfied
contrary earliest start time computeeft returns
cannot scheduled
sake clarity first describe steps reachabilityinformation used derive
n um acts comment computation ef steps
every fact f initializes n um acts f f otherwise
indicating f reachable step n um acts initialized
indicating reachable steps iteratively
constructs set f facts reachable starting f
terminating f cannot extended set arev actions reconsider
empty set available actions initialized set possible actions
step reduced application step augmented set
actions arev step action application modify estimated time
precondition action becomes reachable added rev step
internal loop steps applies actions current f possibly deriving
set facts fnew step fnew arev empty f extended
fnew extended arev internal loop repeated action
subset actions currently applicable f applied reachability
information effects revised follows first estimate minimum number
ra actions required achieve p subroutine requiredactions step
use ra possibly update n um acts n um acts f effect
f steps number actions required achieve preconditions
lower current value n um acts n um acts set ra
moreover application leads lower estimate f e ra less
current value n um acts f n um acts f set ra addition data
structure indicating current best action achieve f action f set
step information used subroutine requiredactions
fact f initial state value action f astart step
subroutine requiredactions one reachability lpg ipc
subroutine uses action derive ra backward process starting input
set action preconditions g ending g subroutine incrementally
constructs set actions acts achieving facts g preconditions
scheduling constraint associated existing scheduling constraints cannot
satisfied starting action computeeft returns dur



figerevini saetti serina

actions already selected action iteration set g revised adding
preconditions last action selected removing facts belonging
effects actions already selected step termination requiredactions guaranteed
every element g reachable
briefly describe computation temporal information eft computed way similar n um acts steps reachabilityinformation initializes
estimated earliest time et f fact f becomes reachable f
otherwise moreover sets ef lf every
application action forward process described estimate earliest
finishing time ef adding duration current maximum estimated earliest
time preconditions taking account scheduling constraints
computeeft step addition compute latest finishing time lf
computelft step earliest finishing time action
greater latest finishing time timed preconditions cannot satisfied
steps executed see statement step effect f
current temporal value higher earliest finishing time steps
set et f step adds arev decreased estimated
earliestx time f revision could decrease estimated start time action
precondition f

appendix b wilcoxon test metric temporal domains ipc
appendix present wilcoxon sign rank test performance
lpg td satisficing ipc planners attempted metric temporal
domains performance evaluated terms cpu times plan quality
cell first two tables gives comparison performance
lpg td another ipc planner number samples sufficiently large
distribution used wilcoxon test approximatively normal distribution hence
cell figure give z value p value characterizing normal
distribution higher z value significant difference performance
p value represents level significance difference performance
use confidence level therefore p value lower
performance two planners statistically different information appears
left right side cell first second planner named title cell
performs better analysis comparing cpu time value
cell number solved least one planner analysis
comparing plan quality number solved planners
pictures tables partial order performance compared
planners terms cpu time plan quality solid edge planner another
planner b cluster planners b indicates performance statistically
different performance b performs better b every planner
b dashed edge b indicates better b significant number
times significant wilcoxon relationship confidence level



fian temporal scheduling

lpg td vs crikey




analysis cpu time
lpg td vs p mep
lpg td vs sgplan







lpg td vs tilsapa




lpg td bq vs crikey




analysis plan quality
lpg td bq vs p mep lpg td bq vs sgplan







lpg td bq vs tilsapa




lpg td
crikey

p mep

tilsapa

sgplan

cpu time

sgplan
lpg td bq
p mep

crikey



b

consistently better b

tilsapa



b

better b significant number times
confidence level

plan quality



figerevini saetti serina

references
armando castellini c giunchiglia e maratea sat decision
procedure boolean combination difference constraints proceedings
seventh international conference theory applications satisfiability testing
sat berlin heidelberg york springer verlag sat lncs
blum furst fast graph analysis artificial
intelligence pp
chen hsu c wah b w sgplan subgoal partitioning resolution
edelkamp hoffmann j littman younes h eds
abstract booklet competing planners icaps pp
cresswell coddington adapting lpgp plan deadlines proceedings sixteenth european conference artificial intelligence ecai
pp amsterdam netherlands ios press
dechter r meiri pearl j temporal constraint networks artificial intelligence pp
b kambhampati zimmerman scheduling connections
exogenous events proceedings icaps workshop integrating
scheduling pp
kambhampati sapa multi objective metric temporal planner
journal artificial intelligence jair pp
edelkamp extended critical paths temporal proceedings
icaps workshop integrating scheduling pp
edelkamp hoffmann j pddl language classic part
th international competition technical report institut fur informatik
freiburg germany
edelkamp hoffmann j littman younes h abstract booklet
competing planners icaps
erschler j roubellat f vernhes j p finding essential characteristics
feasible solutions scheduling operations pp

fox long pddl extension pddl expressing temporal
domains journal artificial intelligence jair pp
fox long time fisher gabbay vila l eds
handbook temporal reasoning artificial intelligence pp elsevier science publishers york ny usa
fox long halsey k investigation expressive power
pddl proceedings sixteenth european conference artificial intelligence ecai pp amsterdam netherlands ios press
frederking r e muscettola n temporal transportation scheduling ieee international conference robotics automation
icra pp ieee computer society press


fian temporal scheduling

gerevini cristani finding solution temporal constraint satisfaction
proceedings fifteenth international joint conference artificial
intelligence ijcai vol pp san francisco ca usa morgan
kaufmann publishers
gerevini saetti serina stochastic local search
temporal action graphs journal artificial intelligence jair pp

gerevini saetti serina empirical analysis heuristic features
local search lpg proceedings fourteenth international conference
automated scheduling icaps pp menlo park ca
usa aaai press
gerevini saetti serina integrating temporal reasoning domains durations time windows proceedings nineteenth
international joint conference artificial intelligence ijcai pp
menlo park ca usa international joint conference artificial intelligence inc
gerevini saetti serina toninelli p b fast domains
derived predicates rule action graphs local search
proceedings twentieth national conference artificial intelligence aaai pp menlo park ca usa aaai press
gerevini serina fast greedy action graphs proceedings
sixteenth national conference artificial intelligence aaai pp
menlo park ca usa aaai press mit press
gerevini serina fast plan adaptation graphs local
systematic search techniques proceedings fifth international conference
artificial intelligence scheduling aips pp menlo park
ca usa aaai press mit press
ghallab laruelle h representation control ixtet temporal planner proceedings second international conference artificial intelligence
systems aips pp menlo park ca usa aaai press
ghallab nau traverso p automated theory practice
morgan kaufmann publishers san francisco ca usa
glover f laguna tabu search kluwer academic publishers boston usa
helmert heuristic causal graph analysis proceedings
fourteenth international conference automated scheduling
icaps pp menlo park ca usa aaai press
kavuluri b r u tilsapa timed initial literals sapa edelkamp
hoffmann j littman younes h eds abstract booklet competing
planners icaps pp
laborie p ghallab sharable resource constraints proceedings fourteenth international joint conference artificial intelligence
ijcai vol pp san francisco ca usa morgan kaufmann publishers


figerevini saetti serina

long fox rd international competition
analysis journal artificial intelligence jair pp
long fox b exploiting graphplan framework temporal
proceedings thirteenth international conference automated
scheduling icaps pp menlo park ca usa aaai press
mcallester rosenblitt systematic nonlinear proceedings
ninth national conference artificial intelligence aaai pp
menlo park ca usa aaai press
muscettola n hsts integrating scheduling zweben fox
eds intelligent scheduling pp san francisco ca usa morgan kaufmann publishers
nguyen x kambhampati reviving partial order proceedings
seventeenth international joint conference artificial intelligence ijcai
vol pp san francisco ca usa morgan kaufmann publishers
penberthy j weld ucpop sound complete partial order planner
adl proceedings third international conference principles knowledge
representation reasoning kr pp san mateo ca usa morgan
kaufmann publishers
penberthy j weld temporal continuous change proceedings
twelfth national conference artificial intelligence aaai pp
menlo park ca usa aaai press mit press
penberthy j continuous change ph thesis university
washington seattle wa usa available technical report uw cse
sanchez j tang mali p mep parallel expressive planner
edelkamp hoffmann j littman younes h eds abstract booklet
competing planners icaps pp
schwartz p j pollack e disjunctive temporal constraints
proceedings icaps workshop integrating scheduling
pp
smith weld temporal mutual exclusive reasoning
proceedings sixteenth international joint conference artificial intelligence
ijcai pp san francisco ca usa morgan kaufmann publishers
smith cheng c slack heuristics constraint satisfaction scheduling
proceedings eleventh national conference artificial intelligence aaai pp menlo park ca usa aaai press mit press
stergiou k koubarakis backtracking disjunctions temporal
constraints artificial intelligence pp
tate generating project networks proceedings fifth international
joint conference artificial intelligence ijcai pp cambridge
usa mit william kaufmann


fian temporal scheduling

tsamardinos pollack e efficient solution techniques disjunctive
temporal reasoning artificial intelligence pp
vere time windows durations activities goals ieee
transactions pattern analysis machine intelligence pp
vidal v lookahead strategy heuristic search proceedings
fourteenth international conference automated scheduling icaps pp menlo park ca usa aaai press
wilcoxon f wilcox r rapid approximate statistical procedures
american cyanamid co pearl river ny usa




