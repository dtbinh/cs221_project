Journal Artificial Intelligence Research 25 (2006) 159-185

Submitted 5/05; published 2/06

Dynamic Local Search Maximum Clique Problem
Wayne Pullan

w.pullan@griffith.edu.au

School Information Communication Technology,
Griffith University,
Gold Coast, QLD, Australia

Holger H. Hoos

hoos@cs.ubc.ca

Department Computer Science
University British Columbia
2366 Main Mall, Vancouver, BC, V6T 1Z4 Canada

Abstract
paper, introduce DLS-MC, new stochastic local search algorithm maximum clique problem. DLS-MC alternates phases iterative improvement,
suitable vertices added current clique, plateau search,
vertices current clique swapped vertices contained current clique.
selection vertices solely based vertex penalties dynamically adjusted
search, perturbation mechanism used overcome search stagnation.
behaviour DLS-MC controlled single parameter, penalty delay, controls frequency vertex penalties reduced. show empirically DLSMC achieves substantial performance improvements state-of-the-art algorithms
maximum clique problem large range commonly used DIMACS benchmark
instances.

1. Introduction
maximum clique problem (MAX-CLIQUE) calls finding maximum sized subgraph pairwise adjacent vertices given graph. MAX-CLIQUE prominent combinatorial optimisation problem many applications, example, information retrieval,
experimental design, signal transmission computer vision (Balus & Yu, 1986).
recently, applications bioinformatics become important (Pevzner & Sze, 2000; Ji,
Xu, & Stormo, 2004). search variant MAX-CLIQUE stated follows: Given
undirected graph G = (V, E), V set vertices E set edges,
find maximum size clique G, clique G subset vertices, C V ,
pairs vertices C connected edge, i.e., v, v C, {v, v } E,
size clique C number vertices C. MAX-CLIQUE N P-hard
associated decision problem N P-complete (Garey & Johnson, 1979); furthermore, inapproximable sense deterministic polynomial-time algorithm
find cliques size |V |1 > 0, unless N P = ZPP (Hastad, 1999).1
best polynomial-time approximation algorithm MAX-CLIQUE achieves approximation ratio O(|V |/(log |V |)2 ) (Boppana & Halldorsson, 1992). Therefore, large hard
instances MAX-CLIQUE typically solved using heuristic approaches, particular,
1. ZPP class problems solved expected polynomial time probabilistic algorithm
zero error probability.
c
2006
AI Access Foundation. rights reserved.

fiPullan & Hoos

greedy construction algorithms stochastic local search (SLS) algorithms simulated annealing, genetic algorithms tabu search. (For overview
methods solving MAX-CLIQUE, see Bomze, Budinich, Pardalos, & Pelillo, 1999.)
may noted maximum clique problem equivalent independent set problem well minimum vertex cover problem, algorithm MAX-CLIQUE
directly applied equally fundamental application relevant problems
(Bomze et al., 1999).
recent literature MAX-CLIQUE algorithms, seems that, somewhat unsurprisingly, single best algorithm. Although algorithms empirically
evaluated benchmark instances Second DIMACS Challenge (Johnson & Trick,
1996), quite difficult compare experimental results studies, mostly
differences respective experimental protocols run-time environments. Nevertheless, particularly considering comparative results reported Grosso et al. (Grosso,
Locatelli, & Croce, 2004), seems five heuristic MAX-CLIQUE algorithms
achieve state-of-the-art performance.
Reactive Local Search (RLS) (Battiti & Protasi, 2001) derived Reactive
Tabu Search (Battiti & Tecchiolli, 1994), advanced general tabu search method
automatically adapts tabu tenure parameter (which controls amount diversification) search process; RLS uses dynamic restart strategy provide
additional long-term diversification.
QUALEX-MS (Busygin, 2002) deterministic iterated greedy construction algorithm uses vertex weights derived nonlinear programming formulation MAXCLIQUE.
recent Deep Adaptive Greedy Search (DAGS) algorithm (Grosso et al., 2004)
uses iterated greedy construction procedure vertex weights; weights
DAGS, however, initialised uniformly updated every iteration greedy
construction procedure. DAGS, weighted iterated greedy construction procedure
executed iterative improvement phase permits limited amount plateau
search. Empirical performance results indicate DAGS superior QUALEX-MS
MAX-CLIQUE instances DIMACS benchmark sets, hard
instances reach performance RLS (Grosso et al., 2004).
k-opt algorithm (Katayama, Hamamoto, & Narihisa, 2004) based conceptually simple variable depth search procedure uses elementary search steps
vertex added removed current clique; evidence
performs better RLS many instances DIMACS benchmark sets (Katayama
et al., 2004), performance relative DAGS unclear.
Finally, Edge-AC+LS (Solnon & Fenet, 2004), recent ant colony optimisation algorithm MAX-CLIQUE uses elitist subsidiary local search procedure, appears
reach (or exceed) performance DAGS RLS least DIMACS
instances.
work, introduce new SLS algorithm MAX-CLIQUE algorithm dubbed
Dynamic Local Search Max Clique, DLS-MC, based combination constructive search perturbative local search, makes use penalty values associated
vertices graph, dynamically determined search
help algorithm avoid search stagnation.
160

fiDynamic Local Search Max-Clique Problem

Based extensive computational experiments, show DLS-MC outperforms
state-of-the-art MAX-CLIQUE search algorithms, particular DAGS, broad
range widely studied benchmark instances, hence represents improvement
heuristic MAX-CLIQUE solving algorithms. present detailed results behaviour DLS-MC offer insights roles single parameter dynamic
vertex penalties. note use vertex penalties DLS-MC inspired
dynamic weights DAGS and, generally, current state-of-the-art Dynamic Local
Search (DLS) algorithms well-known combinatorial problems, SAT
MAX-SAT (Hutter, Tompkins, & Hoos, 2002; Tompkins & Hoos, 2003; Thornton, Pham,
Bain, & Ferreira, 2004; Pullan & Zhao, 2004); general introduction DLS, see
work (Hoos & Stutzle, 2004). results therefore provide evidence
effectiveness broad applicability algorithmic approach.
remainder article structured follows. first describe DLS-MC
algorithm key aspects efficient implementation. Next, present empirical performance results establish DLS-MC new state-of-the-art heuristic MAX-CLIQUE
solving. followed detailed investigation behaviour DLS-MC
factors determining performance. Finally, summarise main contributions
work, insights gained study outline directions future research.

2. DLS-MC Algorithm
DAGS algorithm Grosso et al., new DLS-MC algorithm based fundamental idea augmenting combination iterative improvement plateau search
vertex penalties modified search. iterative improvement procedure used algorithms based greedy construction mechanism starts
trivial clique consisting single vertex successively expands clique C adding
vertices adjacent vertices C. expansion impossible,
may still exist vertices connected one vertices C. including
vertex v C removing single vertex C connected v, new clique
number vertices obtained. type search called plateau
search. noted one plateau search steps, expansion
current clique may become possible; therefore, DLS-MC alternates phases
expansion plateau search.
purpose vertex penalties provide additional diversification search
process, otherwise could easily stagnate situations current clique
vertices common optimal solution given MAX-CLIQUE instance.
Perhaps obvious approach avoiding kind search stagnation simply
restart constructive search process different initial vertex. However, even
random (or systematic) variation choice initial vertex, still risk
heuristic guidance built greedy construction mechanism causes bias towards
limited set suboptimal cliques. Therefore, DAGS DLS-MC utilise numerical
weights associated vertices; weights modulate heuristic selection function
used greedy construction procedure way vertices repeatedly occur
cliques obtained constructive search process discouraged used
future constructions. Following intuition, consistent general approach
161

fiPullan & Hoos

dynamic local search (DLS), based idea, paper, refer
numerical weights vertex penalties.
Based general considerations, DLS-MC algorithm works follows (see
algorithm outline Figure 1): picking initial vertex given graph G
uniformly random setting current clique C set consisting single
vertex, vertex penalties initialised zero. Then, search alternates
iterative improvement phase, suitable vertices repeatedly added
current clique C, plateau search phase, repeatedly one vertex C
swapped vertex currently contained C.
two subsidiary search procedures implementing iterative improvement
plateau search phases, expand plateauSearch, shown Figure 2. Note both,
expand plateauSearch select vertex added current clique C using
penalties associated candidate vertices. case expand, selection
made set NI (C) vertices connected vertices C
edge G; call set improving neighbour set C. plateauSearch,
hand, vertex added C selected level neighbour set C, NL (C),
comprises vertices connected vertices C except one vertex,
say v , subsequently removed C.
Note procedures always maintain current clique C; expand terminates
improving neighbour set C becomes empty, plateauSearch terminates
either NI (C) longer empty NL (C) becomes empty. Also, order reduce
incidence unproductive plateau search phases, DLS-MC implements plateau search
termination condition (Katayama et al., 2004) recording current clique (C )
start plateau search phase terminating plateauSearch overlap
recorded clique C current clique C.
end plateau search phase, vertex penalties updated incrementing
penalty values vertices current clique, C, one. Additionally, every pd
penalty value update cycles (where pd parameter called penalty delay), non-zero
vertex penalties decremented one. latter mechanism prevents penalty values
becoming large allows DLS-MC forget penalty values time.
updating penalties, current clique perturbed one two ways.
penalty delay greater one, i.e., penalties decreased occasionally, current
clique reduced last vertex v added it. removed vertices
increased penalty values, unlikely added back current clique
subsequent iterative improvement phase. equivalent restarting search
v. However, penalty delay one corresponds behaviour penalties
effectively used (since increase vertex penalty immediately undone),
keeping even single vertex current clique C carries high likelihood reconstructing
C subsequent iterative improvement phase. Therefore, achieve diversification
search, penalty delay one, C perturbed adding vertex v
chosen uniformly random given graph G removing vertices C
connected v.
stated above, penalty values used selection vertex given
neighbour set S. precisely, selectMinPenalty(S) selects vertex choosing
uniformly random set vertices minimal penalty values. vertex
162

fiDynamic Local Search Max-Clique Problem

procedure DLS-MC(G, tcs, pd, maxSteps)
input: graph G = (V, E); integers tcs (target clique size), pd (penalty delay), maxSteps
output: clique G size least tcs failed
begin
numSteps := 0;
C := {random(V )};
initPenalties;
numSteps < maxSteps
(C, v) := expand(G, C);
|C| = tcs return(C); end
C := C;
(C, v) := plateauSearch(G, C, C );
NI (C) 6=
(C, v) := expand(G, C);
|C| = tcs return(C); end
(C, v) := plateauSearch(G, C, C );
end
updatePenalties(pd );
pd > 1
C := {v};
else
v := random(V );
C := C {v};
remove vertices C connected v G;
end
end
return(failed);
end

Figure 1: Outline DLS-MC algorithm; details, see text.

selected S, becomes unavailable subsequent selections penalties
updated perturbation performed. prevents plateau search
phase repeatedly visiting clique. Also, safeguard prevent penalty
values becoming large, vertices penalty value greater 10 never
selected.
order implement DLS-MC efficiently, sets maintained using two array data
structures. first these, vertex list array, contains vertices currently
set; second one, vertex index array, indexed vertex number contains
index vertex vertex list array (or 1, vertex set).
additions set performed adding end vertex list array updating
vertex index array. Deletions set performed overwriting vertex list
entry vertex deleted last entry vertex list updating
vertex index array. Furthermore, vertices swapped current
clique plateau search phase, intersection current clique
recorded clique simply maintained recording size current clique
start plateau search decrementing one every time vertex swapped
163

fiPullan & Hoos

procedure expand(G, C)
input: graph G = (V, E); vertex set C V (clique)
output: vertex set C V (expanded clique); vertex v (most recently added vertex)
begin
NI (C) 6=
v := selectMinPenalty(NI (C));
C := C {v};
numSteps := numSteps + 1;
end while;
return((C, v));
end

procedure plateauSearch(G, C, C )
input: graph G = (V, E); vertex sets C V (clique), C C (recorded clique)
output: vertex set C V (modified clique); vertex v (most recently added vertex)
begin
NI (C) = NL (C) 6= C C 6=
v := selectMinPenalty(NL (C));
C := C {v};
remove vertex C connected v G;
numSteps := numSteps + 1;
end while;
return((C, v));
end

Figure 2: Subsidiary search procedures DLS-MC; details, see text.
current clique. Finally, array elements accessed using pointers rather
via direct indexing array. 2
Finally, may noted order keep time-complexity individual
search steps minimal, selection improving level neighbour sets
attempt maximise size set respective search step, rather chooses
vertex minimal penalty uniformly random; keeping common
intuition that, context SLS algorithms, often preferable perform many
relatively simple, efficiently computable search steps rather fewer complex search
steps.

3. Empirical Performance Results
order evaluate performance behaviour DLS-MC, performed extensive computational experiments MAX-CLIQUE instances Second DIMACS
Implementation Challenge (19921993)3 , used extensively benchmarking purposes recent literature MAX-CLIQUE algorithms. 80 DIMACS
MAX-CLIQUE instances generated problems coding theory, fault diagnosis
problems, Kellers conjecture tilings using hypercubes Steiner triple problem,
2. Several techniques based implementation details Henry Kautzs highly efficient WalkSAT code, see http://www.cs.washington.edu/homes/kautz/walksat.
3. http://dimacs.rutgers.edu/Challenges/

164

fiDynamic Local Search Max-Clique Problem

addition randomly generated graphs graphs maximum clique
hidden incorporating low-degree vertices. problem instances range size
less 50 vertices 1 000 edges greater 3 300 vertices 5 000 000 edges.
experiments study performed dedicated 2.2 GHz Pentium IV machine 512KB L2 cache 512MB RAM, running Redhat Linux 3.2.2-5 using
g++ C++ compiler -O2 option. execute DIMACS Machine Benchmark4 ,
machine required 0.72 CPU seconds r300.5, 4.47 CPU seconds r400.5 17.44
CPU seconds r500.5. following, unless explicitly stated otherwise, CPU times
refer reference machine.
following sections, first present results series experiments
aimed providing detailed assessment performance DLS-MC. Then, report
additional experimental results facilitate direct comparison DLS-MC
state-of-the-art MAX-CLIQUE algorithms.
3.1 DLS-MC Performance
evaluate performance DLS-MC DIMACS benchmark instances, performed 100 independent runs instance, using target clique sizes (tcs) corresponding respective provably optimal clique sizes or, cases provably
optimal solutions unknown, largest known clique sizes. order assess peak
performance DLS-MC, conducted experiment multiple values
penalty delay parameter, pd, report best performance obtained. behaviour
DLS-MC suboptimal pd values method used identify optimal pd value
discussed Section 4.2. remaining parameter DLS-MC, maxSteps,
set 100 000 000, order maximise probability reaching target clique size
every run.
results experiments displayed Table 1. benchmark
instance show DLS-MC performance results (averaged 100 independent runs)
complete set 80 DIMACS benchmark instances. Note DLS-MC finds optimal
(or best known) solutions success rate 100% 100 runs per instance 77
80 instances; cases target clique size reached consistently
within alotted maximum number search steps (maxSteps) are:
C2000.9, 93 100 runs successful giving maximum clique size (average
clique size, minimum clique size) 78 (77.93, 77);
MANN a81, 96 100 runs obtained cliques size 1098, remaining
runs produced cliques size 1097;
MANN a45, runs achieved maximum clique size 344.
three cases, reported CPU time statistics successful runs
shown parentheses Table 1. Furthermore, expected time required DLS-MC
reach target clique size less 1 CPU second 67 80 instances,

4. dmclique, ftp://dimacs.rutgers.edu directory /pub/dsj/clique

165

fiPullan & Hoos

Instance
brock200 1
brock200 2
brock200 3
brock200 4
brock400 1
brock400 2
brock400 3
brock400 4
brock800 1
brock800 2
brock800 3
brock800 4
DSJC1000 5
DSJC500 5
hamming10-2
hamming10-4
hamming6-2
hamming6-4
hamming8-2
hamming8-4
johnson16-2-4
johnson32-2-4
johnson8-2-4
johnson8-4-4
MANN a27
MANN a45
MANN a81
MANN a9
san1000
san200 0.7 1
san200 0.7 2
san200 0.9 1
san200 0.9 2
san200 0.9 3
san400 0.5 1
san400 0.7 1
san400 0.7 2
san400 0.7 3
san400 0.9 1
sanr200 0.7

BR
21
12*
15
17*
27
29*
31
33*
23
24
25
26
15*
13*
512
40
32
4
128
16*
8
16
4
14
126*
345*
1099
16
15
30
18
70
60
44
13
40
30
22
100
18

pd
2
2
2
2
15
15
15
15
45
45
45
45
2
2
5
5
5
5
5
5
5
5
5
5
3
3
3
3
85
2
2
2
2
2
2
2
2
2
2
2

CPU(s)
0.0182
0.0242
0.0367
0.0468
2.2299
0.4774
0.1758
0.0673
56.4971
15.7335
21.9197
8.8807
0.799
0.0138
0.0008
0.0089
<
<
0.0003
<
<
<
<
<
0.0476
(51.9602)
(264.0094)
<
8.3636
0.0029
0.0684
0.0003
0.0002
0.0015
0.1641
0.1088
0.2111
0.4249
0.0029
0.002

Steps
14091
11875
21802
30508
955520
205440
74758
28936
10691276
3044775
4264921
1731725
91696
2913
1129
1903
43
3
244
31
7
15
3
21
41976
(16956750)
(27840958)
21
521086
1727
33661
415
347
1564
26235
29635
57358
113905
1820
1342

Sols.
2
1
1
1
1
1
1
1
1
1
1
1
25
42
2
100
2
83
100
92
100
100
66
29
100
(100)
(96)
99
1
1
2
1
1
1
1
1
1
1
1
13

Instance
sanr200 0.9
sanr400 0.5
sanr400 0.7
C1000.9
C125.9
C2000.5
C2000.9
C250.9
C4000.5
C500.9
c-fat200-1
c-fat200-2
c-fat200-5
c-fat500-1
c-fat500-10
c-fat500-2
c-fat500-5
gen200 p0.9 44
gen200 p0.9 55
gen400 p0.9 55
gen400 p0.9 65
gen400 p0.9 75
keller4
keller5
keller6
p hat1000-1
p hat1000-2
p hat1000-3
p hat1500-1
p hat1500-2
p hat1500-3
p hat300-1
p hat300-2
p hat300-3
p hat500-1
p hat500-2
p hat500-3
p hat700-1
p hat700-2
p hat700-3

BR
42
13
21
68
34*
16
78
44*
18
57
12
24
58
14
126
26
64
44*
55*
55
65
75
11*
27
59
10
46
68
12*
65
94
8*
25*
36*
9
36
50
11*
44*
62

pd
2
2
2
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1

CPU(s)
0.0127
0.0393
0.023
4.44
0.0001
0.9697
(193.224)
0.0009
181.2339
0.1272
0.0002
0.001
0.0002
0.0004
0.0015
0.0004
0.002
0.001
0.0003
0.0268
0.001
0.0005
<
0.0201
170.4829
0.0034
0.0024
0.0062
2.7064
0.0061
0.0103
0.0007
0.0002
0.0007
0.001
0.0005
0.0023
0.0194
0.001
0.0015

Steps
15739
9918
8475
1417440
158
50052
(29992770)
845
5505536
72828
24
291
118
45
276
49
301
1077
369
18455
716
402
31
4067
11984412
230
415
1579
126872
730
1828
133
87
476
114
200
1075
1767
251
525

Sols.
18
4
61
70
94
93
(91)
85
93
3
14
1
3
19
3
18
3
4
4
1
1
1
98
100
100
82
87
23
1
90
98
13
42
10
48
14
36
2
72
85

Table 1: DLS-MC performance results, averaged 100 independent runs, complete set DIMACS benchmark instances. maximum known clique size
instance shown BR column (marked asterisk proven
optimal); pd optimised DLS-MC penalty delay instance; CPU(s)
run-time CPU seconds, averaged successful runs, instance. Average CPU times less 0.0001 seconds shown < ; Steps
number vertices added clique, averaged successful runs,
instance; Sols. total number distinct maximum sized cliques found
instance. runs achieved best known cliques size shown
exception of: C2000.9, 93 100 runs successful giving maximum
clique size (average clique size, minimum clique size) 78(77.93, 77); MANN a81,
96 100 runs obtained 1098 giving 1098(1097.96, 1097); MANN a45,
runs achieved maximum clique size 344.

166

fiDynamic Local Search Max-Clique Problem

expected run-time 10 CPU seconds required 8 13 remaining
instances, least 800 vertices. Finally, variation coefficients (stddev/mean) run-time distributions (measured search steps, order overcome
inaccuracies inherent extremely small CPU times) instances 100% success rate obtained found reach average maximum values 0.86 1.59,
respectively.
may interesting note time-complexity search steps DLS-MC
generally low. indicative example, brock800 1 800 vertices, 207 505
edges maximum clique size 23 vertices, DLS-MC performs, average, 189 235
search steps (i.e., additions current clique) per CPU second. Generally, timecomplexity DLS-MC steps increases size improving (NI ) level (NL )
neighbour sets well as, lesser degree, maximum clique size. relationship
seen Table 2 shows, (randomly generated) DIMACS C.9
brock 1 instances, performance DLS-MC terms search steps per CPU
second decreases number vertices (and hence size NI , NL ) increases.
Instance
C125.9
C250.9
C500.9
C1000.9
C2000.9
brock200 1
brock400 1
brock800 1

Vertices
125
250
500
1000
2000
200
400
800

Edges
6963
27984
112332
450079
1799532
14834
59723
207505

BR
34
44
57
68
78
21
27
23

DLS-MC pd
1
1
1
1
1
2
15
45

Steps / Second
1587399
939966
572553
319243
155223
774231
428504
189236

Table 2: Average number DLS-MC search steps per CPU second (on reference machine) 100 runs DIMACS C.9 brock 1 instances. BR
DLS-MC pd figures Table 1 shown, factors direct
impact performance DLS-MC. is, BR increases, greater
overhead maintaining sets within DLS-MC; furthermore, larger pd values
cause higher overhead maintaing penalties, vertices tend
penalised. C.9 instances randomly generated edge probability
0.9, brock 1 instances constructed hide maximum
clique considerably lower densities (i.e., average number edges per
vertex). scaling average number search steps per CPU second performed DLS-MC C.9 instances only, running reference machine,
approximated 9 107 n0.8266 , n number vertices
given graph (this approximation achieves R2 value 0.9941).
detailed analysis DLS-MCs performance terms implementation-independent
measures run-time, search steps iteration counts, beyond scope
work, could yield useful insights future.
3.2 Comparative Results
results reported previous section demonstrate clearly DLS-MC achieves
excellent performance standard DIMACS benchmark instances. However, com167

fiPullan & Hoos

parative analysis results, compared results found literature
state-of-the-art MAX-CLIQUE algorithms, straight-forward task
differences in:
Computing Hardware: date, computing hardware basically documented terms CPU speed allows basic means comparison
(i.e., scaling based computer CPU speed which, example, takes account features, memory caching, memory size, hardware architecture,
etc.). Unfortunately, algorithms, realistic option available
us comparison.
Result Reporting Methodology: empirical results performance
MAX-CLIQUE algorithms found literature form statistics
clique size obtained fixed run-time. conduct performance comparisons
data, care must taken avoid inconclusive situations algorithm
achieves larger clique sizes another algorithm B, cost higher runtimes. important realise relative performance B vary
substantially run-time; may reach higher clique sizes B relatively
short run-times, opposite could case longer run-times. Finally, seemingly
small differences clique size may fact represent major differences performance,
since (as many hard optimisation problems) finding slightly sub-optimal cliques
typically substantially easier finding maximal cliques. example, C2000.9,
average time needed find clique size 77 (with 100% success rate) 6.419
CPU seconds, whereas reaching maximum clique size 78 (with 93% success
rate) requires average (over successful runs only) 193.224 CPU seconds.
Termination Criteria: MAX-CLIQUE algorithms (such DAGS)
terminate upon reaching given target clique size, instead run given
number search steps fixed amount CPU time, even optimal clique
encountered early search. would obviously highly unfair directly compare published results algorithms DLS-MC, terminates
soon finds user supplied target clique size.
Therefore, confirm DLS-MC represents significant improvement previous
state-of-the-art MAX-CLIQUE algorithms, conducted experiments analyses
designed yield performance results DLS-MC directly compared
results MAX-CLIQUE algorithms. particular, compared DLS-MC
following MAX-CLIQUE algorithms: DAGS (Grosso et al., 2004), GRASP (Resende,
Feo, & Smith, 1998) (using results contained Grosso et al., 2004), k-opt (Katayama
et al., 2004), RLS (Battiti & Protasi, 2001), GENE (Marchiori, 2002), ITER (Marchiori,
2002) QUALEX-MS (Busygin, 2002). rank performance MAX-CLIQUE
algorithms determine dominant algorithm benchmark instances,
used set criteria based, primarily, quality solution then,
deemed equivalent, CPU time requirements algorithms.
criteria shown, order application, Table 3.

168

fiDynamic Local Search Max-Clique Problem

1. algorithm algorithm find largest known maximum clique instance
ranked dominant algorithm instance.
2. one algorithm achieves 100% success rate instance algorithm lowest
average (scaled) CPU time becomes dominant algorithm instance.
3. single algorithm achieves 100% success rate instance algorithm becomes dominant
algorithm instance.
4. algorithm achieves 100% success rate instance, algorithm achieves largest
size clique, highest average clique size lowest average CPU time becomes
dominant algorithm instance.
5. If, instance, algorithm meets four criteria listed above, conclusion
drawn dominant algorithm instance.

Table 3: criteria used ranking MAX-CLIQUE algorithms.

Instance
brock200 1
brock200 2
brock200 3
brock200 4
brock400 1
brock400 2
brock400 3
brock400 4
brock800 1
brock800 2
brock800 3
brock800 4
C1000.9
C2000.9
C4000.5
C500.9
gen200 p0.9 44
gen400 p0.9 55
gen400 p0.9 65
gen400 p0.9 75
keller6
MANN a45
p hat1000-3
p hat1500-1
san200 0.7 2
san400 0.7 3
sanr200 0.9

DLS-MC
Clique size
CPU(s)
21
0.0182
12
0.0242
15
0.0367
17
0.0468
27
2.2299
29
0.4774
31
0.1758
33
0.0673
23
56.4971
24
15.7335
25
21.9197
26
8.8807
68
4.44
78(77.93,77)
193.224
18 181.2339
57
0.1272
44
0.001
55
0.0268
65
0.001
75
0.0005
59 170.4829
344
51.9602
68
0.0062
12
2.7064
18
0.0684
22
0.4249
42
0.0127

DAGS
Clique size
SCPU(s)
21
0.256
12
0.064
15
0.064
17(16.8,16)
0.192
27(25.35,24)
1.792
29(28.1,24)
1.792
31(30.7,25)
1.792
33
1.792
23(20.95,20),
10.624
24(20.8,20)
10.752
25(22.2,21)
10.88
26(22.6,20)
10.816
68(65.95,65)
94.848
76(75.4,74)
1167.36
18(17.5,17)
2066.56
56(55.85,55)
8.64
44(41.15,40)
0.576
53(51.8,51)
4.608
65(55.4,51)
4.672
75(55.2,52)
4.992
57(56.4,56)
7888.64
344(343.95) 1229.632
68(67.85,67)
71.872
12(11.75,11)
19.904
18(17.9,17)
0.192
22(21.7,19)
1.28
42(41.85,41)
0.576

GRASP
Clique size
SCPU(s)
21
4.992
12
1.408
14
42.56
17
3.328
25
14.976
25
15.232
31(26.2,25)
14.848
25
15.232
21
32
21
32.96
22(21.85,21)
34.112
21
33.152
67(66.1,65)
154.368
75(74.3,73)
466.368
18(17.75,17)
466.944
56
80.896
44(41.95,41)
11.776
53(52.25,52)
35.264
65(64.3,63)
34.56
74(72.3,69)
36.16
55(53.5,53) 1073.792
336(334.5,334)
301.888
68
237.568
11
23.424
18(16.55,15)
3.264
21(18.8,17)
9.856
42
12.608

Table 4: Performance comparison DLS-MC, DAGS GRASP selected DIMACS
instances. SCPU columns contain scaled DAGS GRASP average
run-times CPU seconds; DAGS GRASP results based 20 runs per
instance, DLS-MC results based 100 runs per instance. cases
best known result found runs, clique size entries format
maximum clique size (average clique size, minimum clique size). DLS-MC
dominant algorithm instances table.

169

fiPullan & Hoos

Table 4 contrasts performance results DAGS GRASP literature (Grosso
et al., 2004) respective performance results DLS-MC. Since DAGS
GRASP runs performed 1.4 GHz Pentium IV CPU, DLS-MC ran
2.2 GHz Pentium IV reference machine, scaled CPU times factor 0.64.
(Note based assumption linear scaling run-time CPU clock
speed; reality, speedup typically significantly smaller.) Using ranking criteria,
data shows DLS-MC dominates DAGS GRASP benchmark
instances listed Table 4. confirm ranking, modified DAGS terminated
soon given target clique size reached (this termination condition used
DLS-MC) performed direct comparison DLS-MC 80 DIMACS instances,
running algorithms reference machine. seen results
experiment, shown Table 5, DLS-MC dominates DAGS one instance (the
exception san1000).
Table 6 shows performance results DLS-MC compared results k-opt (Katayama
et al., 2004), GENE (Marchiori, 2002), ITER (Marchiori, 2002) RLS (Battiti & Protasi,
2001) literature. roughly compensate differences CPU speed, scaled
CPU times k-opt, GENE ITER factor 0.91 (these obtained
2.0 GHz Pentium IV) RLS (measured 450 MHz Pentium II CPU)
0.21. Using ranking criteria Table 3, RLS dominant algorithm instances
keller6 MANN a45, k-opt dominant algorithm MANN a81 DLS-MC
dominant algorithm, exception C2000.9, remainder DIMACS
instances listed Table 6. identify dominant algorithm C2000.9, experiment performed, running DLS-MC maxSteps parameter (which controls
maximum allowable run-time) reduced point average clique size
DLS-MC exceeded reported RLS. experiment, DLS-MC reached
optimum clique size 78 58 100 independent runs average minimum
clique size 77.58 77, respectively average run-time 85 CPU sec (taking
account runs). establishes DLS-MC dominant RLS k-opt instance
C2000.9.
Analagous experiments performed directly compare performance DLSMC k-opt selected DIMACS benchmark instances; results, shown Table 7,
confirm DLS-MC dominates k-opt instances.
Finally, Table 8 shows performance results DLS-MC comparison results
QUALEX-MS literature (Busygin, 2002); CPU times QUALEX-MS
scaled factor 0.64 compensate differences CPU speed (1.4 GHz
Pentium IV CPU vs 2.2 GHz Pentium IV reference machine). Using ranking
criteria Table 3, QUALEX-MS dominates DLS-MC instances brock400 1, brock800 1,
brock800 2 brock800 3, DLS-MC dominates QUALEX-MS remaining 76
80 DIMACS instances.

170

fiDynamic Local Search Max-Clique Problem

Instance
brock200 1
brock200 2
brock200 3
brock200 4
brock400 1
brock400 2
brock400 3
brock400 4
brock800 1
brock800 2
brock800 3
brock800 4
DSJC1000 5
DSJC500 5
C1000.9
C125.9
C2000.9
C2000.5
C250.9
C4000.5
C500.9
c-fat200-1
c-fat200-2
c-fat200-5
c-fat500-1
c-fat500-10
c-fat500-2
c-fat500-5
gen200 p0.9 44
gen200 p0.9 55
gen400 p0.9 55
gen400 p0.9 65
gen400 p0.9 75
hamming10-2
hamming10-4
hamming6-2
hamming6-4
hamming8-2
hamming8-4
johnson16-2-4

DLS-MC
Success CPU(s)
100
0.0182
100
0.0242
100
0.0367
100
0.0468
100
2.2299
100
0.4774
100
0.1758
100
0.0673
100
56.4971
100
15.7335
100
21.9197
100
8.8807
100
0.799
100
0.0138
100
4.44
100
0.0001
93
193.224
100
0.9697
100
0.0009
100 181.2339
100
0.1272
100
0.0002
100
0.001
100
0.0002
100
0.0004
100
0.0015
100
0.0004
100
0.002
100
0.001
100
0.0003
100
0.0268
100
0.001
100
0.0005
100
0.0008
100
0.0089
100
<
100
<
100
0.0003
100
<
100
<

DAGS
Success CPU(s)
93
0.1987
98
0.1252
100
0.1615
82
0.2534
35
3.1418
75
2.3596
92
2.2429
99
1.653
9
20.0102
20
18.747
19
19.1276
45
16.9227
80
7.238
100
0.1139
5
2.87
100
0.0024
5 2.870608
100
17.9247
99
0.1725


4
16.2064
100
0.0002
100
0.0004
100
0.0012
100
0.0005
100
0.0067
100
0.0009
100
0.0028
14
0.9978
100
0.0267
0
9.0372
27
7.1492
14
8.6018
100
0.1123
100
3.8812
100
0.0003
100
<
100
0.0039
100
0.0006
100
0.0003

Instance
johnson32-2-4
johnson8-2-4
johnson8-4-4
keller4
keller5
keller6
MANN a27
MANN a45
MANN a81
MANN a9
p hat1000-1
p hat1000-2
p hat1000-3
p hat1500-1
p hat1500-2
p hat1500-3
p hat300-1
p hat300-2
p hat300-3
p hat500-1
p hat500-2
p hat500-3
p hat700-1
p hat700-2
p hat700-3
san1000
san200 0.7 1
san200 0.7 2
san200 0.9 1
san200 0.9 2
san200 0.9 3
san400 0.5 1
san400 0.7 1
san400 0.7 2
san400 0.7 3
san400 0.9 1
sanr200 0.7
sanr200 0.9
sanr400 0.5
sanr400 0.7

DLS-MC
Success CPU(s)
100
<
100
<
100
<
100
<
100
0.0201
100 170.4829
100
0.0476
100
51.9602
96 264.0094
100
<
100
0.0034
100
0.0024
100
0.0062
100
2.7064
100
0.0061
100
0.0103
100
0.0007
100
0.0002
100
0.0007
100
0.001
100
0.0005
100
0.0023
100
0.0194
100
0.001
100
0.0015
100
8.3636
100
0.0029
100
0.0684
100
0.0003
100
0.0002
100
0.0015
100
0.1641
100
0.1088
100
0.2111
100
0.4249
100
0.0029
100
0.002
100
0.0127
100
0.0393
100
0.023

DAGS
Success CPU(s)
100
0.0042
100
<
100
0.0001
100
0.0009
100
0.079


100
0.1886
94
8.194


100
0.0003
100
0.0353
100
0.0984
81
37.2
69
15.609
100
0.4025
100
6.3255
100
0.0078
100
0.0033
100
0.0609
100
0.0099
100
0.0215
100
0.4236
100
0.1217
100
0.0415
100
0.1086
100
0.967
100
0.0029
92
0.1001
100
0.0023
100
0.0368
100
0.0572
100
0.0336
100
0.0089
100
0.0402
90
0.5333
100
0.0322
100
0.0239
83
0.3745
93
0.231
100
0.1345

Table 5: Success rates average CPU times DLS-MC DAGS (based 100 runs
per instance). 80 DIMACS instances, DLS-MC superior success rate
31 instances and, exception san1000, required less CPU
time DAGS instances. Entries signify runs
terminated excessive CPU time requirements. obtain meaningful
comparison DLS-MC DAGS, MANN a45 MANN a81, 344
1098 respectively used best known results producing table.
DLS-MC DAGS, average CPU time successful runs only.
Using ranking criteria study, DAGS dominant algorithm
san1000 instance, DLS-MC dominant algorithm instances.

171

fiPullan & Hoos

DLS-MC
Instance
Clique size
brock200 2
12
brock200 4
17
brock400 2
29
brock400 4
33
brock800 2
24
brock800 4
26
C1000.9
68
C125.9
34
C2000.5
16
C2000.9
78(77.9,77)
C250.9
44
C4000.5
18
C500.9
57
DSJC1000 5
15
DSJC500 5
13
gen200 p0.9 44
44
gen200 p0.9 55
55
gen400 p0.9 55
55
gen400 p0.9 65
65
gen400 p0.9 75
75
hamming10-4
40
hamming8-4
16
keller4
11
keller5
27
keller6
59
MANN a27
126
MANN a45
344
MANN a81 1098(1097.96,1097)
p hat1500-1
12
p hat1500-2
65
p hat1500-3
94
p hat300-1
8
p hat300-2
25
p hat300-3
36
p hat700-1
11
p hat700-2
44
p hat700-3
62

k-opt

RLS

CPU(s)
Clique size
SCPU(s)
Clique size
SCPU(s)
0.0242
11
0.02184
12
2.01705
0.0468
16
0.01911
17
4.09311
0.4774
25(24.6,24)
0.28028 29(26.063,25)
8.83911
0.0673
25
0.18291 33(32.423,25) 22.81398
15.7335
21(20.8,20)
2.16034
21
0.99519
8.8807
21(20.5,20)
2.50796
21
1.40616
4.44
67
6.3063
68
8.7486
0.0001
34
0.00091
34
0.00084
0.9697
16 13.01846
16
2.09496
193.224
77(75.1,74) 66.14608 78(77.575,77) 172.90518
0.0009
44
0.05642
44
0.00609
181.2339
17 65.27885
18 458.44869
0.1272
57(56.1,56)
0.82264
57
0.65604
0.799
15
5.77941
15
1.35513
0.0138
13
0.12103
13
0.04074
0.001
44
0.06643
44
0.00777
0.0003
55
0.00273
55
0.00336
0.0268
53(52.3,51)
0.56238
55
0.25284
0.001
65
0.24934
65
0.0105
0.0005
75
0.16926
75
0.01071
0.0089
40
0.58422
40
0.01638
<
16
0.00182
16
0.00063
<
11
0.00091
11
0.00042
0.0201
27
0.07371
27
0.03591
170.4829
57(55.5,55) 125.03218
59 39.86094
0.0476
126
0.03276
126
0.65436
51.9602
344(343.6,343)
5.34716 345(343.6,343)
83.7417
264.0094 1099(1098.1,1098)
84.903
1098 594.4722
2.7064
12 15.43997
12
6.35754
0.0061
65
0.42224
65
0.03318
0.0103
94
2.093
94
0.04032
0.0007
8
0.00637
8
0.00378
0.0002
25
0.00546
25
0.00126
0.0007
36
0.0273
36
0.00441
0.0194
11
0.57876
11
0.03906
0.001
44
0.04914
44
0.00588
0.0015
62
0.08008
62
0.00735

GENE
ITER
Avg.
Avg.
Clique size Clique size
10.5
10.5
15.4
15.5
22.5
23.2
23.6
23.1
19.3
19.1
18.9
19
61.6
61.6
33.8
34
14.2
14.2
68.2
68.7
42.8
43
15.4
15.6
52.2
52.7
13.3
13.5
12.2
12.1
39.7
39.5
50.8
48.8
49.7
49.1
53.7
51.2
60.2
62.7
37.7
38.8
16
16
11
11
26
26.3
51.8
52.7
125.6
126
342.4
343.1
1096.3
1097
10.8
10.4
63.8
63.9
92.4
93
8
8
25
25
34.6
35.1
9.8
9.9
43.5
43.6
60.4
61.8

Table 6: Performance DLS-MC, k-opt, RLS, GENE ITER selected DIMACS
instances. SCPU columns contain scaled average run-time CPU seconds
k-opt RLS; DLS-MC RLS results based 100 runs per instance,
k-opt, GENE ITER results based 10 runs per instance. Using
ranking criteria study, RLS dominant algorithm instances
MANN a45 keller6, DLS-MC dominant algorithm
instances.

172

fiDynamic Local Search Max-Clique Problem

DLS-MC
Instance
Clique size CPU(s)
brock400 2 25(24.69,24) 0.1527
brock400 4
25 0.0616
brock800 2 21(20.86,20) 1.7235
brock800 4 21(20.65,20) 1.0058

k-opt
DLS-MC
k-opt
Clique size SCPU(s) Instance Clique size CPU(s) Clique size SCPU(s)
25(24.6,24)
0.280 C1000.9 67(66.07,64) 0.0373
67(66,65)
6.306
25
0.183 C2000.9 77(75.33,74) 0.6317 77(75.1,74)
66.146
21(20.8,20)
2.160 C4000.5
17 1.3005
17
65.279
21(20.5,20)
2.508
keller6 57(55.76,54) 2.6796 57(55.5,55) 125.032

Table 7: Performance DLS-MC k-opt DLS-MC parameter maxSteps
reduced point clique size results comparable
k-opt. CPU(s) values DLS-MC include unsuccessful runs; DLS-MC
results based 100 runs k-opt results 10 runs (per instance).
DLS-MC
QUALEX-MS
DLS-MC
QUALEX-MS
Instance
Clique size CPU(s) Clique size SCPU(s)
Instance
Clique size
CPU(s) Clique size SCPU(s)
brock200 1
21
0.0182
21
0.64 johnson32-2-4
16
<
16
5.12
brock200 2
12
0.0242
12
< 0.64 johnson8-2-4
4
<
4
< 0.64
brock200 3
15
0.0367
15
0.64 johnson8-4-4
14
<
14
< 0.64
brock200 4
17
0.0468
17
< 0.64
keller4
11
<
11
0.64
brock400 1
27
2.2299
27
1.28
keller5
27
0.0201
26
10.24
brock400 2
29
0.4774
29
1.92
keller6
59 170.4829
53
826.24
brock400 3
31
0.1758
31
1.28
MANN a27
126
0.0476
125
0.64
brock400 4
33
0.0673
33
1.28
MANN a45
344 51.9602
342
10.88
brock800 1
23 56.4971
23
11.52
MANN a81 1098(1097.96,1097) 264.0094
1096
305.28
brock800 2
24 15.7335
24
11.52
MANN a9
16
<
16
< 0.64
brock800 3
25 21.9197
25
11.52
p hat1000-1
10
0.0034
10
17.92
brock800 4
26
8.8807
26
11.52
p hat1000-2
46
0.0024
45
21.76
C1000.9
68
4.44
64
17.28
p hat1000-3
68
0.0062
65
20.48
C125.9
34
0.0001
34
< 0.64
p hat1500-1
12
2.7064
12
60.8
C2000.5
16
0.9697
16
177.92
p hat1500-2
65
0.0061
64
71.04
C2000.9 78(77.93,77) 193.224
72
137.6
p hat1500-3
94
0.0103
91
69.12
C250.9
44
0.0009
44
0.64
p hat300-1
8
0.0007
8
0.64
C4000.5
18 181.2339
17
1500.8
p hat300-2
25
0.0002
25
0.64
C500.9
57
0.1272
55
2.56
p hat300-3
36
0.0007
35
0.64
c-fat200-1
12
0.0002
12
< 0.64
p hat500-1
9
0.001
9
1.92
c-fat200-2
24
0.001
24
< 0.64
p hat500-2
36
0.0005
36
2.56
c-fat200-5
58
0.0002
58
< 0.64
p hat500-3
50
0.0023
48
2.56
c-fat500-1
14
0.0004
14
0.64
p hat700-1
11
0.0194
11
6.4
c-fat500-10
126
0.0015
126
1.28
p hat700-2
44
0.001
44
7.68
c-fat500-2
26
0.0004
26
1.28
p hat700-3
62
0.0015
62
7.04
c-fat500-5
64
0.002
64
1.28
san1000
15
8.3636
15
16.0
DSJC1000 5
15
0.799
14
23.04 san200 0.7 1
30
0.0029
30
0.64
DSJC500 5
13
0.0138
13
3.2 san200 0.7 2
18
0.0684
18
< 0.64
gen200 p0.9 44
44
0.001
42
< 0.64 san200 0.9 1
70
0.0003
70
< 0.64
gen200 p0.9 55
55
0.0003
55
0.64 san200 0.9 2
60
0.0002
60
0.64
gen400 p0.9 55
55
0.0268
51
1.28 san200 0.9 3
44
0.0015
40
< 0.64
gen400 p0.9 65
65
0.001
65
1.28 san400 0.5 1
13
0.1641
13
1.28
gen400 p0.9 75
75
0.0005
75
1.28 san400 0.7 1
40
0.1088
40
1.92
hamming10-2
512
0.0008
512
24.32 san400 0.7 2
30
0.2111
30
1.28
hamming10-4
40
0.0089
36
28.8 san400 0.7 3
22
0.4249
18
1.28
hamming6-2
32
<
32
< 0.64 san400 0.9 1
100
0.0029
100
1.28
hamming6-4
4
<
4
< 0.64
sanr200 0.7
18
0.002
18
0.64
hamming8-2
128
0.0003
128
< 0.64
sanr200 0.9
42
0.0127
41
< 0.64
hamming8-4
16
<
16
0.64
sanr400 0.5
13
0.0393
13
1.28
johnson16-2-4
8
<
8
< 0.64
sanr400 0.7
21
0.023
20
1.28

Table 8: Performance DLS-MC QUALEX-MS. SCPU column contains
scaled run-time QUALEX-MS CPU seconds; DLS-MC results based
100 runs per instance. Using ranking criteria study, QUALEX-MS
dominant algorithm instances brock400 1, brock800 1, brock800 2
brock800 3, DLS-MC dominant algorithm instances.
173

fiPullan & Hoos

Overall, results comparative performance evaluations summarised
follows:
QUALEX-MS dominant brock400 1, brock800 1, brock800 2 brock800 3
DIMACS instances.
RLS dominant algorithm MANN a45 keller6 DIMACS instances.
DAGS dominant algorithm san1000 DIMACS instance.
k-opt dominant algorithm MANN a81 DIMACS instance.
DLS-MC dominant algorithm remaining 72 DIMACS instances.
addition, within alotted run-time number runs, DLS-MC obtained current best known results DIMACS instances exceptions MANN a45
MANN a81.

4. Discussion
gain deeper understanding run-time behaviour DLS-MC efficacy
underlying mechanisms, performed additional empirical analyses. Specifically,
studied variability run-time multiple independent runs DLS-MC
problem instance; role vertex penalties general and, particular,
impact penalty delay parameter performance behaviour DLS-MC;
frequency pertubation well role perturbation mechanism.
investigations performed using two DIMACS instances, C1000.9 brock800 1.
instances selected because, firstly, reasonable size difficulty. Secondly, C1000.9 randomly generated instance vertices optimal maximum
clique predominantly higher vertex degree average vertex degree (intuitively
would seem reasonable that, randomly generated problem, vertices optimal
maximum clique would tend higher vertex degrees). brock800 1,
hand, vertices optimal maximum clique predominantly lower-than-average
vertex degree. (Note DIMACS brock instances created attempt defeat
greedy algorithms used vertex degree selecting vertices Brockington & Culberson,
1996).
fundamental difference highlighted results quantitative analysis maximum cliques instances, showed that, C1000.9, averaged
maximal cliques found DLS-MC, average vertex degree vertices maximal cliques 906 (standard deviation 9) compared 900 (9) averaged
vertices; brock800 1, corresponding figures 515 (11) 519 (13) respectively.
4.1 Variability Run-Time
variability run-time multiple independent runs given problem important aspect behaviour SLS algorithms DLS-MC. Following methology Hoos Stutzle (2004), studied aspect based run-time distributions
(RTDs) DLS-MC two reference instances.
174

fiDynamic Local Search Max-Clique Problem

seen empirical RTD graphs shown Figure 3 (each based
100 independent runs reached respective best known clique size), DLS-MC
shows large variability run-time. Closer investigation shows RTDs quite
well approximated exponential distributions (a Kolmogorov-Smirnov goodness-of-fit test
failed reject null hypothesis sampled run-times stem exponential
distributions shown figure standard confidence level = 0.05 p-values
0.16 0.62). observation consistent similar results highperformance SLS algorithms, e.g., SAT (Hoos & Stutzle, 2000) scheduling problems
(Watson, Whitley, & Howe, 2005). consequence, performing multiple independent
runs DLS-MC parallel result close-to-optimal parallelisation speedup (Hoos
& Stutzle, 2004). Similar observation made difficult DIMACS
instances.
1

1

empirical RLD DLS-MC
ed[2.5*105]

0.9

0.8

0.8

0.7

0.7

0.6

0.6

P(solve)

P(solve)

0.9

0.5
0.4

0.5
0.4

0.3

0.3

0.2

0.2

0.1

0.1

0
1000

10000

100000

1e+006

empirical RTD DLS-MC
ed[0.85]

0
0.001

1e+007

0.01

run-time [search steps]
1

1

empirical RLD DLS-MC
ed[0.7*107]

0.9

0.8

0.8

0.7

0.7

0.6

0.6

P(solve)

P(solve)

0.9

0.5
0.4

0.3
0.2

0.1

0.1
1e+006
1e+007
run-time [search steps]

10

1e+008

1e+009

empirical RTD DLS-MC
ed[35]

0.4

0.2

100000

1

0.5

0.3

0
10000

0.1
run-time [CPU sec]

0
0.01

0.1

1
10
run-time [CPU sec]

100

1000

Figure 3: Run-time distributions DLS-MC applied C1000.9 (top) brock800 1
(bottom), measured search steps (left) CPU seconds (right) reference machine (based 100 independent runs reached best
known clique size); empirical RTDs well approximated exponential
distributions, labelled ed[m](x) = 1 2x/m plots.
4.2 Penalty Delay Parameter Vertex Penalties
penalty delay parameter pd specifies number penalty increase iterations must
occur DLS-MC penalty decrease (by 1) vertices currently
175

fiPullan & Hoos

Vertex frequency

penalty. MAX-CLIQUE problem, pd basically provides mechanism focusing
lower degree vertices constructing current cliques. pd = 1 (i.e., penalties),
frequency vertices improving neighbour / level neighbour sets
basically solely dependent degree. Increasing pd overcomes bias towards
higher degree vertices, allows penalty values increase (as often
current clique), inhibits selection current clique. turn
allows lower degree vertices become part current clique. effect penalty
delay parameter illustrated Figure 4, shows correlation degree
vertices frequency included current clique immediately prior
perturbation performed within DLS-MC.

C1000.9 pd = 1
0.4
0.2

Vertex frequency

0
86

0.4

87

88

89
90
Vertex degree

91

92

93

brock800_1 pd = 1

0.3
0.2
0.1
0
58

60

62

64
Vertex degree

66

68

70

62

64
Vertex degree

66

68

70

Vertex frequency

0.25
brock800_1 pd = 45
0.2
0.15
0.1
0.05
58

60

Figure 4: Correlation vertex degree frequency vertices
present clique immediately prior DLS-MC perturbation.
C1000.9 brock800 1, pd = 1, higher degree vertices tend
higher frequency present clique immediately prior DLS-MC
perturbation. brock800 1, pd = 45, frequency present
clique immediately prior DLS-MC perturbation almost independent
vertex degree.
Currently, pd needs tuned family (or, case brock instances,
sub-family) instances. general, could done principled way based RTD
graphs, DLS-MC, reasonably robust regard exact value
parameter (as shown Figures 5 6), actual tuning process simple, almost
interactive process normally require evaluating RTD graphs. Still, fine-tuning
based RTD data could possibly result further, minor performance improvements.

176

fiDynamic Local Search Max-Clique Problem

100

% Success rate

95
90
85
80
75
70

0

10

20

30
Penalty delay

40

50

60

0

10

20

30
Penalty delay

40

50

60

Median processor time

300
250
200
150
100
50
0

Figure 5: Success rate median CPU time DLS-MC function penalty delay
parameter, pd, benchmark instance brock800 1. data point based
100 independent runs.

Cumulative success rate

100
80

pd = 35
pd = 45
pd = 50

60
40
20
0
4
10

5

6

10

7

10
Steps

8

10

10

Cumulative success rate

100
80

pd = 35
pd = 45
pd = 50

60
40
20
0
1
10

0

10

1

10
Processor time (seconds)

2

10

Figure 6: Run-time distributions DLS-MC brock800 1 penalty delays 35, 45
50, measuring run-time search steps (top) CPU seconds (bottom).
performance penalty delay 45 clearly dominates 35 50.

177

fiPullan & Hoos

effect penalty delay parameter vertex penalties clearly illustrated
Figure 7, shows cumulative distributions number penalised vertices
perturbation DLS-MC, representative runs DLS-MC DIMACS brock800 1
instance, varying values parameter pd. Note brock800 1, optimal
pd value 45 corresponds point where, average, 90% vertices
penalised. role pd parameter illustrated Figure 8, shows
(sorted) frequency vertices present current clique immediately
prior perturbation C1000.9 brock800 1. Note instances,
using higher penalty delay settings significanly reduces bias towards including certain
vertices current clique. previously demonstrated, without vertex penalties (i.e.,
pd = 1), DLS-MC prefers include high-degree vertices current clique,
case problem instances C1000.9, optimal cliques tend consist vertices
higher-than-average degrees, effective strategy. instances brock800 1,
however, optimal clique contains many vertices lower-than-average degree,
heuristic bias towards high-degree vertices misleading needs counteracted, e.g.,
means vertex penalties.
100
pd = 5
pd = 10
pd = 15
pd = 20
pd = 25
pd = 30
pd = 35
pd = 40
pd = 45
pd = 50
pd = 55

90

80

Cumulative frequency

70

60

50

40

30

20

10

0

0

100

200

300

400
500
Penalised vertices

600

700

800

Figure 7: Cumulative distributions number penalised vertices measured
search perturbation representative independent runs DLS-MC DIMACS brock800 1 instance penalty delay parameter pd varied (the left
curve corresponds pd = 5). Note approx. optimal penalty
delay pd = 45 (solid line), average 90% vertices penalised (i.e.,
penalty value greater zero).
Generally, reducing bias cliques visited, vertex penalties help diversify
search DLS-MC. time, penalties appear provide learning
mechanism DLS-MC identifies vertices included
178

fiDynamic Local Search Max-Clique Problem

C1000.9
% frequency vertex clique

0.5
pd = 1
pd = 10

0.4
0.3
0.2
0.1
0

0

100

200

300

400

500
Vertex

600

700

800

900

1000

brock800_1
% frequency vertex clique

0.4
pd = 1
pd = 45
0.3

0.2

0.1

0

0

100

200

300

400
Vertex

500

600

700

800

Figure 8: Sorted frequency vertices present current clique immediately prior DLS-MC perturbation C1000.9 (top) brock800 1
(bottom), based representative run problem instance. Note
using penalty delay values pd > 1, bias towards using certain vertices
frequently others substantially reduced.
current clique. agreement recent results SAPS, high-performance
dynamic local search algorithm SAT (Hoos & Stutzle, 2004).
4.3 Perturbation Mechanism Search Mobility
prevent search stagnation, DLS-MC uses perturbation mechanism executed
whenever plateau search procedure failed lead clique
expanded. Since mechanism causes major changes current clique, relatively
high time complexity. therefore interesting investigate frequently rather
costly disruptive perturbation steps performed. Figure 9 shows distribution
number improving search steps (i.e., clique expansions) plateau steps (i.e., vertex
swaps) successive perturbation phases representative run DLS-MC
C1000.9 instance. Analogous results brock800 1 shown Figure 10. figures
basically show result interactions improving plateau search steps,
perturbation mechanism problem structure.

179

fiPullan & Hoos

c1000.9

Cumulative frequency

100
pd = 1
pd = 2
pd = 10

80
60
40
20
0

0

10

20

30

40

50
60
Improving steps

70

80

90

100

20

30

40

50
60
Plateau swaps

70

80

90

100

Cumulative frequency

100
pd = 1
pd = 2
pd = 10

80
60
40
20
0

0

10

Figure 9: Number improving search steps plateau swaps successive perturbation phases DLS-MC C1000.9. graphs show cumulative distributions measures collected representative independent runs
pd value; solid lines correspond approx. optimal penalty delay
instance, pd = 1.
brock800_1

Cumulative frequency

100
pd = 1
pd = 2
pd = 45

80
60
40
20
0

0

5

10

15

20
Improving steps

25

30

35

40

10

15

20
Plateau swaps

25

30

35

40

Cumulative frequency

100
pd = 1
pd = 2
pd = 45

80
60
40
20
0

0

5

Figure 10: Number improving search steps plateau swaps successive perturbation phases DLS-MC brock800 1. graphs show cumulative
distributions measures collected representative independent runs
pd value; solid lines correspond approx. optimal penalty delay
instance, pd = 45.
180

fiDynamic Local Search Max-Clique Problem

seen data, compared higher penalty delay values, pd = 1
results significantly shorter plateau phases somewhat longer improvement phases.
time, differences behaviour DLS-MC observed various penalty
delay values greater one relatively small. One explanation phenomenon lies
fact pd = 1, effectively vertex penalties used, consequently,
selection improving level neighbours sets search step less constrained.
Intuitively, make easier find exits plateaus underlying search
landscape follow gradients larger number search steps.

Whether renders search efficient clearly depends topology
given search landscape. Instance C1000.9 least 70 optimal solutions (see Table 1),
construction, optimal cliques higher-than-average vertex degree. suggests
respective search landscape relatively high fitness-distance correlation,
would explain problem instance relatively easy solve using
less radical perturbation mechanism associated pd = 1 (which adds randomly chosen
vertex v current clique removes vertices connected v) provides sufficient
diversification search process. Instance brock800 1, hand, appears
single optimal solution many near-optimal solutions (i.e., large nonoptimal cliques cannot extended), since construction, optimal clique
lower-than-average vertex degree. suggests respective search landscape
relatively low fitness-distance correlation, therefore, radical perturbation
mechanism used pd > 1 (which restarts clique construction recently
added vertex uses vertex penalties diversification) required order obtain
good performance; hypothesis agreement relatively high cost
solving problem instance.

investigate efficacy perturbation DLS-MC diversification mechanism, measured relative mobility search, defined Hamming distance
current cliques (i.e., number different vertices) consecutive perturbations
divided two times maximum clique size, representative runs DLS-MC instances C1000.9 brock800 1 (this mobility measure closely related used
previous studies (Schuurmans & Southey, 2000)). seen Figure 11,
large difference mobility two variants perturbation mechanism
pd = 1 pd > 1; former restarts search randomly chosen vertex
consequently leads large variability Hamming distance previous clique,
latter restarts recently added vertex, using vertex penalties
increase search diversification, hence shows consistently much higher mobility. Note
vertex penalties used (i.e., pd > 1), pd value significant effect
search mobility. time, previously observed (see Figure 5), performance
DLS-MC significantly depend penalty update delay pd. demonstrates
order achieve peak performance, increased mobility afforded use
vertex penalties needs combined correct amount additional diversification
achieved using specific penalty update delay.
181

fiPullan & Hoos

C1000.9

Cumulative frequency

100
Delay 1
Delay 2
Delay 10

80
60
40
20
0

0

0.05

0.1

0.15

0.2

0.25
0.3
Relative mobility

0.35

0.4

0.45

0.5

0.35

0.4

0.45

0.5

brock800_1

Cumulative frequency

100
Delay 1
Delay 2
Delay 45

80
60
40
20
0

0

0.05

0.1

0.15

0.2

0.25
0.3
Relative mobility

Figure 11: Mobility search consecutive perturbation phases DLS-MC instances C1000.9 (top) brock800 1 (bottom). Mobility measured terms
relative Hamming distance, i.e., number different vertices respective cliques divided two times maximum clique size. graphs
show cumulative distributions relative mobility measurements collected
representative independent runs pd value problem instance;
solid lines correspond respective approx. optimal pd values.

5. Conclusions Future Work
demonstrated applying general paradigm dynamic local search
maximum clique problem, state art MAX-CLIQUE solving improved.
new algorithm, DLS-MC, similarity previous MAX-CLIQUE algorithms,
particular recently introduced DAGS algorithm: algorithms use vertex penalties
guide heuristic selection vertices searching maximum cliques. However,
unlike DAGS, initial phase unweighted greedy construction search, DLS-MC
uses updates vertex penalties throughout entire search process. Furthermore,
weight updates DAGS monotone while, DLS-MC, vertex penalties subject
increases well occasional decreases, effectively allows algorithm
forget vertex penalties time. Furthermore, DLS-MC selects vertex added
current clique step solely based penalty, vertex selection
DAGS based total weight neighbouring vertices hence implicitely uses
vertex degree heuristic guidance. fact DLS-MC, although conceptually slightly
simpler, outperforms DAGS one standard DIMACS benchmark instances
combination excellent performance compared high-performance MAX182

fiDynamic Local Search Max-Clique Problem

CLIQUE algorithms clearly demonstrates value underlying paradigm dynamic
local search non-monotone penalty dynamics.
work presented article extended several directions. particular,
would interesting investigate extent use multiplicative penalty update
mechanisms DLS-MC instead current additive mechanism lead performance improvements. believe current implementation DLS-MC
optimised. example, selection vertex added current
clique, implementation DLS-MC performs complete scan either improving
plateaus sets build list vertices lowest penalties; would probably
efficient maintain list means incremental update scheme. Another
interesting direction future research develop mechanisms automatically
adjusting DLS-MCs penalty delay parameter search, similar scheme used
dynamically adapting tabu tenure parameter RLS (Battiti & Protasi, 2001)
Reactive Tabu Search (Battiti & Tecchiolli, 1994), mechanism used controlling
noise parameter Adaptive Novelty+ (Hoos, 2002). Finally, given excellent performance DLS-MC standard MAX-CLIQUE instances reported suggests
underlying dynamic local search method substantial potential provide basis
high-performance algorithms combinatorial optimisation problems, particularly
weighted versions MAX-CLIQUE conceptually related clustering problems.

Acknowledgments
authors would thank Liang Zhao participation performing
initial experiments paper.

References
Balus, E., & Yu, C. (1986). Finding maximum clique arbitary graph. SIAM Journal
Computing, 15 (4), 10541068.
Battiti, R., & Protasi, M. (2001). Reactive local search maximum clique problem.
Algorithmica, 29, 610637.
Battiti, R., & Tecchiolli, G. (1994). reactive tabu search. ORSA Journal Computing,
6 (2), 126140.
Bomze, I., Budinich, M., Pardalos, P., & Pelillo, M. (1999). maximum clique problem.
D.Z. Du, P. P. (Ed.), Handbook Combinatorial Optimization, Vol. A, pp. 174.
Boppana, R., & Halldorsson, M. (1992). Approximating maximum independent sets
excluding subgraphs. Bit, 32, 180196.
Brockington, M., & Culberson, J. (1996). Camouflaging independent sets quasi-random
graphs. D.S. Johnson, M. T. (Ed.), Cliques, Coloring Satisfiability: Second
DIMACS Implementation Challenge, Vol. 26 DIMACS Series. American Mathematical Society.
183

fiPullan & Hoos

Busygin, S. (2002). new trust region technique maximum clique problem. Internal
report, http://www.busygin.dp.ua.
Garey, M. R., & Johnson, D. S. (1979). Computers Intractability: Guide Theory
N P-Completeness. Freeman, San Francisco, CA, USA.
Grosso, A., Locatelli, M., & Croce, F. D. (2004). Combining swaps node weights
adaptive greedy approach maximum clique problem. Journal Heuristics,
10, 135152.
Hastad, J. (1999). Clique hard approximate within n1 . Acta Mathematica, 182,
105142.
Hoos, H. H. (2002). adaptive noise mechanism WalkSAT. Proceedings
Eighteenth National Conference Artificial Intelligence, pp. 655660. AAAI Press /
MIT Press, Menlo Park, CA, USA.
Hoos, H. H., & Stutzle, T. (2004). Stochastic Local Search: Foundations Applications.
Morgan Kaufmann Publishers, USA.
Hoos, H., & Stutzle, T. (2000). Local search algorithms SAT: empirical evaluation.
Gent, I., v.Maaren, H., & Walsh, T. (Eds.), SAT 2000, pp. 4386. IOS Press.
Hutter, F., Tompkins, D. A. D., & Hoos, H. H. (2002). Scaling probabilistic smoothing: Efficient dynamic local search SAT. Hentenryck, P. V. (Ed.), Principles
Practice Constraint Programming CP 2002, Vol. 2470 Lecture Notes
Computer Science, pp. 233248. Springer Verlag, Berlin, Germany.
Ji, Y., Xu, X., & Stormo, G. D. (2004). graph theoretical approach predicting common RNA secondary structure motifs including pseudoknots unaligned sequences.
Bioinformatics, 20 (10), 15911602.
Johnson, D., & Trick, M. (Eds.). (1996). Cliques, Coloring Satisfiability: Second DIMACS Implementation Challenge, Vol. 26 DIMACS Series. American Mathematical
Society.
Katayama, K., Hamamoto, A., & Narihisa, H. (2004). Solving maximum clique problem k-opt local search. Proceedings 2004 ACM Symposium Applied
computing, pp. 10211025.
Marchiori, E. (2002). Genetic, iterated multistart local search maximum clique
problem. Applications Evolutionary Computing, Vol. 2279 Lecture Notes
Computer Science, pp. 112121. Springer Verlag, Berlin, Germany.
Pevzner, P. A., & Sze, S.-H. (2000). Combinatorial approaches finding subtle signals
DNA sequences. Proceedings Eighth International Conference Intelligent
Systems Molecular Biology, pp. 269278. AAAI Press.
Pullan, W., & Zhao, L. (2004). Resolvent clause weighting local search. Tawfik, A. Y.,
& Goodwin, S. D. (Eds.), Advances Artificial Intelligence, 17th Conference
Canadian Society Computational Studies Intelligence, Vol. 3060 Lecture Notes
Computer Science, pp. 233247. Springer Verlag, Berlin, Germany.
184

fiDynamic Local Search Max-Clique Problem

Resende, M., Feo, T., & Smith, S. (1998). Algorithm 786: FORTRAN subroutine approximate solution maximum independent set problem using GRASP. ACM
Transactions Mathematical Software, 24, 386394.
Schuurmans, D., & Southey, F. (2000). Local search characteristics incomplete SAT
procedures. Proceedings Seventeenth National Conference Artificial Intelligence, pp. 297302. AAAI Press / MIT Press, Menlo Park, CA, USA.
Solnon, C., & Fenet, S. (2004). study aco capabilities solving maximum clique
problem. Journal Heuristics, appear.
Thornton, J., Pham, D. N., Bain, S., & Ferreira, V. (2004). Additive versus multiplicative
clause weighting SAT. Proceedings 19th National Conference Artificial
Intelligence (AAAI-04), pp. 191196. AAAI Press / MIT Press, Menlo Park, CA,
USA.
Tompkins, D., & Hoos, H. (2003). Scaling probabilistic smoothing: Dynamic local
search unweighted MAX-SAT. Xiang, Y., & Chaib-draa, B. (Eds.), Advances
Artificial Intelligence, 16th Conference Canadian Society Computational
Studies Intelligence, Vol. 2671 Lecture Notes Computer Science, pp. 145159.
Springer Verlag, Berlin, Germany.
Watson, J., Whitley, L., & Howe, A. (2005). Linking search space structure, run-time
dynamics, problem difficulty: step toward demystifying tabu search. Journal
Artificial Intelligence, 24, 221261.

185


