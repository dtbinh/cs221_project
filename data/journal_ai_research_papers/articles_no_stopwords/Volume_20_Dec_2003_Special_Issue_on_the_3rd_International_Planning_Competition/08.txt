Journal Artificial Intelligence Research 20 (2003) 195-238

Submitted 6/03; published 12/03

Taming Numbers Durations Model Checking
Integrated Planning System
Stefan Edelkamp

stefan.edelkamp@cs.uni-dortmund.de

Baroper Strae 301
Fachbereich Informatik, GB IV
Universitat Dortmund
44221 Dortmund
Germany

Abstract
Model Checking Integrated Planning System (MIPS) temporal least commitment heuristic search planner based flexible object-oriented workbench architecture.
design clearly separates explicit symbolic directed exploration algorithms
set on-line off-line computed estimates associated data structures.
MIPS shown distinguished performance last two international planning competitions. last event description language extended pure propositional
planning include numerical state variables, action durations, plan quality objective
functions. Plans longer sequences actions time-stamped schedules.
participant fully automated track competition, MIPS proven
general system; track every benchmark domain efficiently computed plans
remarkable quality. article introduces analyzes important algorithmic
novelties necessary tackle new layers expressiveness benchmark
problems achieve high level performance.
extensions include critical path analysis sequentially generated plans generate
corresponding optimal parallel plans. linear time algorithm compute parallel
plan bypasses known NP hardness results partial ordering scheduling plans
respect set actions imposed precedence relations. efficiency
algorithm allows us improve exploration guidance: encountered planning
state corresponding approximate sequential plan scheduled.
One major strength MIPS static analysis phase grounds simplifies
parameterized predicates, functions operators, infers knowledge minimize
state description length, detects domain object symmetries. latter aspect
analyzed detail.
MIPS developed serve complete optimal state space planner,
admissible estimates, exploration engines branching cuts. competition
version, however, certain performance compromises made, including floating point
arithmetic, weighted heuristic search exploration according inadmissible estimate
parameterized optimization.

1. Introduction
Practical action planning model checking appear closely related. MIPS
project targets integration model checking techniques domain-independent
action planner. HSF-Spin experimental model checker (Edelkamp, Leue, & LluchLafuente, 2003) looking towards integration planning technology
c
2003
AI Access Foundation. rights reserved.

fiEdelkamp

existing model checker. Additional synergies exploited automated compilation
protocol software model checking problems planner inputs (Edelkamp, 2003).
Model checking (Clarke, Grumberg, & Peled, 1999) automated process verify
formal model system satisfies specified temporal property not. illustrative
example, take elevator control system together correctness property requires
elevator eventually stop every call passenger guarantees door
closed, elevator moving. Although success checking correctness limited,
model checkers found many errors current hardware software designs. Models
often consist many concurrent sub-systems. combination either synchronous,
often seen hardware design verification, asynchronous, frequently given communication security protocols, multi-threaded programming languages Java.
Model checking requires exploration large state spaces containing reachable system states. problem known state explosion problem occurs even
sets generated states much smaller set reachable states.
error shows safety property violation, deadlock failed assertion,
corresponds one set target nodes state space graph. Roughly speaking,
something bad occured. liveness property violation refers (seeded) cycle
graph. Roughly speaking, something good never occur. case elevator
example, eventually reaching target state request button pressed liveness
property, certifying closed doors refers safety property.
two main validation processes model checking explicit symbolic search.
explicit-state model checking state refers fixed memory location state
space graph implicitly generated successive expansions state.
symbolic model checking (McMillan, 1993; Clarke, McMillan, Dill, & Hwang, 1992),
(fixed-length) binary encodings system states used, state represented characteristic function representation. function evaluates true
Boolean state variables assigned bit values respect binary
encoding system state. Subsequently, characteristic function conjunction
literals plain variable 1 encoding negated variable 0. Sets
states expressed disjunction individual characteristic functions.
unique symbolic representation sets states Boolean formulae binary
decision diagrams (BDDs) (Bryant, 1992) often much smaller explicit one. BDDs
(ordered) read-once branching programs nodes corresponding variables, edges
corresponding variable outcomes, path corresponding assignment
variables resulting evaluation leaves. One reason succinctness
BDDs directed acyclic graphs may express exponentially many paths. transition
relation defined two state variable sets. evaluates true, operator
exists transforms state valid successor. sense, BDDs exploit regularities
state set often appear well suited regular hardware systems. contrast, many
software systems inherit highly asynchronous irregular structure, use
BDDs fixed variable ordering generally flexible enough.
symbolic exploration, set states combined transition relation
compute set possible successor states, i.e. image. Starting initial
state, iteration image computations eventually explores entire reachable state space.
196

fiTaming Numbers Durations MIPS

improve efficiency image computations, transition relations often provided
partitioned form.
correspondence action model checking (Giunchiglia & Traverso, 1999)
roughly characterized follows. Similar model checkers, action planners implicitly generate large state spaces, exploration approaches based applying
operators current state. States spaces model checking planning problems
often modelled Kripke structures, i.e. state space graphs states labelled propositional predicates. satisfaction specified property one side corresponds
complete exploration, unsolvable problem side. respect,
goal action planning cast error corresponding trail interpreted
plan. elevator example, goal planning task reach state,
doors open elevator moving. Action planning refers safety properties only,
since goal achievement traditional competition planning problems yet
extended temporal properties. However, temporally extended goals increasing
research interest (Kabanza, Barbeau, & St-Denis, 1997; Pistore & Traverso, 2001; Lago,
Pistore, & Traverso, 2002).
contrast model checkers perform either symbolic explicit exploration, MIPS
features both. Moreover, combines symbolic explicit search planning form
symbolic pattern databases (Edelkamp, 2002b). planner MIPS implements heuristic
search algorithms A* (Pearl, 1985) IDA* (Korf, 1985) exploration, include
state-to-goal approximation search process rank states expanded next.
Heuristic search brought considerable gains planning (Bonet & Geffner, 2001;
Refanidis & Vlahavas, 2000; Hoffmann & Nebel, 2001; Bertoli, Cimatti, & Roveri, 2001a;
Jensen, Bryant, & Veloso, 2002; Feng & Hansen, 2002) model checking (Yang & Dill,
1998; Edelkamp et al., 2003; Groce & Visser, 2002; Bloem, Ravi, & Somenzi, 2000; Ruys,
2003).
Including resource variables, fuel level vehicle distance two
different locations, well action duration relatively new aspects competitive
planning (Fox & Long, 2003). input format PDDL2.1 restricted variables
finite domain, includes rational (floating-point) variables precondition
effects. Similar set atoms described propositional predicate, set numerical
quantities described set parameters. notation PDDL2.1,
refer parameterized numerical quantities functions. example, fuel level might
parameterized vehicle present problem instance file description.
competition, domains provided different tracks according different layers language expressiveness: i) pure propositional planning, ii) planning numerical
resources, iii) planning numerical resources constant action duration, iv) planning
numerical resources variable action duration, and, cases, v) complex problems usually combining time numbers interesting ways. MIPS competed
fully automated system performed remarkably well five tracks; solved large
number problems fully automated planner produced solutions
track every benchmark domain.
paper main algorithmic techniques taming rational numbers, objective
functions, action duration described. article structured follows. First,
review development MIPS system assert main contributions.
197

fiEdelkamp

address object-oriented heuristic search framework system. Subsequently,
introduce terminology allows us give formal definition syntax
semantics grounded mixed numerical propositional planning problem instance.
introduce core contributions: critical path scheduling concurrent plans,
efficient methods detecting using symmetry cuts. PERT scheduling produces
optimal parallel plans linear time given sequence operators precedence relation
among them. paper discusses pruning anomalies effect different optimization
criteria. analyze correctness efficiency symmetry detection detail.
article closes related work concluding remarks.

2. Development MIPS
competition version MIPS refers initial work (Edelkamp & Reffel, 1999a)
heuristic symbolic exploration planning domains cke model checker (Biere,
1997). approach effective sample puzzle solving (Edelkamp & Reffel, 1998)
hardware verification problems (Reffel & Edelkamp, 1999).
implementing propositional planner, first used BDD library called
StaticBdd, large node tables allocated prior use. implementation process changed BDD representation mainly improve performance
small planning problems. selected public domain c++ BDD package Buddy (LindNielsen, 1999), flexible. planning process semi-automated (Edelkamp
& Reffel, 1999b); variable encodings provided hand, representations
operators established enumerating possible parameter instances.
state space encoding action transition relation fixed, exploration form
symbolic breadth-first search state-space could executed. time,
aware work BDD-based planning work Cimatti et al.
(1997), likely first link planning via symbolic model checking. team used
model checker (nu)SMV basis atom-to-variable planning state encoding
scheme top it.
Later on, developed parser static analyzer automate inference state
encodings, generation transition relations, extraction solution paths.
order minimize length state encoding, new analyzer clustered atoms
groups (Edelkamp & Helmert, 1999). confirmed attempts (Weismuller, 1998),
started experimenting PDDL specification cke, state minimization fact
crucial. simple encoding using one variable atom appears competitive
respect Graphplan-based (Blum & Furst, 1995) SAT-plan based planners (Kautz
& Selman, 1996). Subsequently, MIPS first fully automated planning system based
symbolic model checking technology could deal large domain descriptions.
second international planning competition MIPS (Edelkamp & Helmert, 2001)
could handle STRIPS (Fikes & Nilsson, 1971) subset PDDL language (McDermott, 2000) additional features ADL (Pednault, 1989), namely negative
preconditions (universal) conditional effects. MIPS one five planning systems
awarded Distinguished Performance fully automated track. competition
version (Edelkamp & Helmert, 2000) already included explicit heuristic search algorithms
based bit-vector state representation relaxed planning heuristic (RPH) (Hoff198

fiTaming Numbers Durations MIPS

mann & Nebel, 2001) well symbolic heuristic search based HSP heuristic (Bonet
& Geffner, 2001) one-to-one atom derivative RPH. competition, used
breadth-first bi-directional symbolic search whenever single state heuristic search engine
got stuck exploration.
planning competitions, explicit (Edelkamp, 2001c) symbolic pattern
databases (Edelkamp, 2002b) proposed off-line estimators completely explored
problem abstractions. Roughly speaking, pattern database abstractions slice state vector fluents pieces adjust operators accordingly. completely explored
subspaces serve admissible estimates overall search competitive
relaxed planning heuristic several benchmark domains.
third planning competition new levels planning domain description language (PDDL) designed. Level 1 considers pure propositional planning. Level 2
includes numerical resources objective functions minimized. Level 3 additionally
allows specification actions durations. Consequently, MIPS extended
cope new forms expressiveness.
First results MIPS planning PDDL2.1 problems presented (Edelkamp,
2001b). preliminary treatment illustrates parsing process two simple benchmark domains. Moreover, propositional heuristics manual branching cuts applied
accelerate sequential plan generation. work extended (Edelkamp, 2002a),
presented two approximate exploration techniques bound fix numerical
domains, first results symmetry detection based fact groups, critical path scheduling,
any-time wrapper produce optimal plans, numerical extension RPH.

3. Architecture MIPS
Figure 1 shows main components MIPS data flow input definition
domain problem instance resulting temporal plan output.
shown shaded light gray, MIPS divided four parts: pre-compilation, heuristics,
search algorithms, post-compilation (scheduling). Henceforth, planning process
coarsely grouped three stages, pre-compilation, heuristic search planning,
construction temporal plans. problem domain description files fed
system, analyzed grounded. fixes state space problem solved.
intermediate result implicit, saved file use planners model
checkers. basics pre-compilation covered Section 3.2.
next stage defines planning process. object-oriented workbench design
planner allows different heuristic estimates combined different search
strategies access data structures. Possible choices listed Sections 3.3 3.4.
Temporal planning based (PERT) scheduling. issue rearranging sequential
(relaxed) plans addressed detail Section 4.3.
planning system developed spirit heuristic search framework,
HSF short (Edelkamp, 1999), allows attachment newly implemented problem
(puzzle) domains already compiled system. Similar approach took
model checking within HSF-Spin, kept extensible general design. fact
characterized action planning protocol validation single-agent challenges.
contrast model checking approach, planning devised hierarchy system
199

fiEdelkamp

domain.pddl

problem.pddl

Precompiler
static analyzer
ground

symmetry

cluster

intermediate representation
Heuristics
explicit PDBs

symbolic PDBs

numerical
RPH

Search Algorithms

relaxed plan

symbolic search

explicit search
RPH

BDDA*, BDD-BFS

A*, IDA*, EHC
scheduling
RPH

sequential plan

relaxed
temporal plan

Scheduler
Critical Path

temporal plan

PERT

Figure 1: Architecture MIPS.

states: implementation numerical states derived class one propositional
states.
Similarily, heuristic search algorithms based abstract search class.
main procedures provided search algorithm state expansion
procedure, heuristic search evaluation function, located one hierarchically organized heuristic estimator classes. sense, algorithms MIPS general
node expanding schemes adapted different problems. Additional data
structures horizon list Open visited list Closed constructed parameters appropriate search algorithms. result, implementations heuristic
search algorithms associated data structures planner MIPS almost match
model checker.
3.1 Example Problem
running example paper instance rather simple PDDL2.1 problem
Zeno-Travel. illustrated Figure 2. initial configuration drawn left
200

fiTaming Numbers Durations MIPS



Scott

B

Dan

C

1000



C



600

B

800

1000

800

1000

Ernie

600

1000



Scott
Ernie

Dan

Figure 2: instance Zeno-Travel domain initial state (left) goal state(s)
(right).

figure goal configuration right. global local numeric variable
assignments shown.
Figures 3 4 provide domain problem specifications1 . instance asks
temporal plan fly passengers (dan, scott, ernie) located somewhere small
map (including cities city-a, city-b, city-c, city-d) aircraft (plane)
respective target destinations. Boarding debarking take constant amount
time. plane fixed fuel capacity. Fuel time consumed according
distances cities travel speed. Fuel restored refueling
aircraft. result, total amount fuel maintained numerical quantity.
3.2 Precompiler
static analyzer takes domain problem instance input, grounds propositional state information infers different forms planner independent static information.
Parsing simple Lisp parser generates tree Lisp entities. reads input files
recognizes domain problem name. cope variable typing, temporarily assert constant typed predicates removed together constant
predicates pre-compilation step. Thereby, infer type hierarchy
associated mapping objects types.
Indexing Based number counted objects, indices grounded predicates,
functions actions devised. Since example problem eight objects predicates two parameters, reserve 2 8 8 = 128
index positions. Similarly, function distance consumes 64 indices, fuel,
1. [...] denotes source fragments omitted sake brevity. given example
action definitions passenger debarking flying airplane.

201

fiEdelkamp

(define (domain zeno-travel)
(:requirements :durative-actions :typing :fluents)
(:types aircraft person city)
(:predicates (at ?x - (either person aircraft) ?c - city)
(in ?p - person ?a - aircraft))
(:functions (fuel ?a - aircraft) (distance ?c1 - city ?c2 - city)
(slow-speed ?a - aircraft) (fast-speed ?a - aircraft)
(slow-burn ?a - aircraft) (fast-burn ?a - aircraft)
(capacity ?a - aircraft)
(refuel-rate ?a - aircraft)
(total-fuel-used) (boarding-time) (debarking-time))
(:durative-action board
:parameters (?p - person ?a - aircraft ?c - city)
:duration (= ?duration boarding-time)
:condition (and (at start (at ?p ?c))
(over (at ?a ?c)))
:effect (and (at start (not (at ?p ?c)))
(at end (in ?p ?a))))
[...]
(:durative-action zoom
:parameters (?a - aircraft ?c1 ?c2 - city)
:duration (= ?duration (/ (distance ?c1 ?c2) (fast-speed ?a)))
:condition (and (at start (at ?a ?c1))
(at start (>= (fuel ?a) (* (distance ?c1 ?c2) (fast-burn ?a)))))
:effect (and (at start (not (at ?a ?c1)))
(at end (at ?a ?c2))
(at end (increase total-fuel-used
(* (distance ?c1 ?c2) (fast-burn ?a))))
(at end (decrease (fuel ?a)
(* (distance ?c1 ?c2) (fast-burn ?a))))))
(:durative-action refuel
:parameters (?a - aircraft ?c - city)
:duration (= ?duration (/ (- (capacity ?a) (fuel ?a)) (refuel-rate ?a)))
:condition (and (at start (< (fuel ?a) (capacity ?a)))
(over (at ?a ?c)))
:effect (at end (assign (fuel ?a) (capacity ?a))))
)

Figure 3: Zeno-Travel domain description PDDL2.1.

slow-speed, fast-speed, slow-burn, fast-burn, capacity, refuel-rate
reserve eight index positions. quantities total-fuel-used, boarding-time,
debarking-time single fact identifier needed. Last least model
duration additional quantity total-time. special variable one
overwritten least commitment planning approach scheduling plans
described Section 4.
202

fiTaming Numbers Durations MIPS

(define (problem zeno-travel-1)
(:domain zeno-travel)
(:objects plane - aircraft
ernie scott dan - person
city-a city-b city-c city-d - city)
(:init (= total-fuel-used 0) (= debarking-time 20) (= boarding-time 30)
(= (distance city-a city-b) 600) (= (distance city-b city-a) 600)
(= (distance city-b city-c) 800) (= (distance city-c city-b) 800)
(= (distance city-a city-c) 1000) (= (distance city-c city-a) 1000)
(= (distance city-c city-d) 1000) (= (distance city-d city-c) 1000)
(= (fast-speed plane) (/ 600 60)) (= (slow-speed plane) (/ 400 60))
(= (fuel plane) 750)
(= (capacity plane) 750)
(= (fast-burn plane) (/ 1 2))
(= (slow-burn plane) (/ 1 3))
(= (refuel-rate plane) (/ 750 60))
(at plane city-a) (at scott city-a) (at dan city-c) (at ernie city-c))
(:goal (and (at dan city-a) (at ernie city-d) (at scott city-d)))
(:metric minimize total-time)
)

Figure 4: Zeno-Travel problem instance.
Flattening Temporal Identifiers interpret action integral entity,
timed propositional numerical preconditions merged. Similarly,
effects merged, independent time happen. Invariant conditions
(over (at ?a ?c)) action board added precondition set.
discuss rationale step Section 4.1.
Grounding Propositions Fact-space exploration relaxed enumeration planning
problem determine superset reachable facts. Algorithmically, FIFO fact
queue compiled. Successively extracted facts front queue matched
operators. time preconditions operator fulfilled, resulting
atoms according positive effect (add) list determined enqueued.
allows us separate constant facts fluents, since latter reached
exploration.
Clustering Atoms concise encoding propositional part separate fluents
groups, state planning space expressed conjunction (possibly trivial) facts drawn fact group (Edelkamp & Helmert,
1999). precisely, let #pi (o1 , . . . , oi1 , oi+1 , . . . , ) number objects oi
fact (p o1 . . . ) true. establish single-valued invariant
#pi (o1 , . . . , oi1 , oi+1 , . . . , ) = 1. allow better encoding, predicates
merged. example, three groups determine unique position
persons (one five) one group determines position plane (one
four). Therefore, 3 dlog 5e + 1 dlog 4e = 11 bits suffice encode total 19
fluents.
203

fiEdelkamp

Grounding Actions Fact-space exploration determines grounded operators.
preconditions met grounded, symbolic effect lists instantiated.
case determine 98 instantiated operators, which, simplifications
eliminate duplicates trivial operators (no-ops), reduced 43.
Grounding Functions Simultanous fact space exploration propositional part
problem, heads numerical formulae effect lists grounded.
example case three instantiated formulae fluent (vary time): (fuel
plane) initial value 750 well total-fuel-used total-time initialized zero. numerical predicates fact constants
substituted formula-bodies. example, effect (board dan city-a)
reduces (increase (total-time) 30), (zoom plane city-a city-b)
numerical effects (increase (total-time) 150),(increase (total-fuel-used)
300)), (decrease (fuel plane) 300). Refuelling, however, reduce
single rational number, example effects (refuel plane city-a)
simplify (increase (total-time) (/ (- (750 (fuel plane)) / 12.5)))
(assign (fuel plane) 750). evaluate former assignment especially forward chaining planner, variable (total-time) instantiated on-the-fly.
due fact value quantity (fuel plane) constant
changes time.
Symmetry Detection Regularities planning problem respect transposition domain objects partially determined static analyzer addressed
detail Section 5.
intermediate textual format static analyzer annotated grounded PDDLlike representation serves interface planners model checkers,
additional resource plan visualization. Figures 5 6 show parts intermediate
representation inferred Zeno-Travel example.
3.3 Heuristics
MIPS incorporates following heuristic estimates.
Relaxed planning heuristic (RPH) Approximation number planning steps
needed solve propositional planning problem delete effects removed (Hoffmann & Nebel, 2001). heuristic constructive, returns set
operators appear relaxed plan.
Numerical relaxed planning heuristic (numerical RPH) extension RPH
deal numbers combined propositional numerical approximation
scheme allowing multiple operator application.
Pattern database heuristic (explicit PDB) Different planning space abstractions
found greedy manner, yielding selection pattern databases fit main
memory. contrast RPH, pattern database designed disjoint yielding
admissible estimate needed optimal planning A* (Edelkamp, 2001c).
204

fiTaming Numbers Durations MIPS

(define (grounded zeno-travel-zeno-travel-1)
(:fluents
(at dan city-a)
(at dan city-b)
(at dan city-c)
(at dan city-d)
(at ernie city-a) (at ernie city-b) (at ernie city-c) (at ernie city-d)
(at plane city-a) (at plane city-b) (at plane city-c) (at plane city-d)
(at scott city-a) (at scott city-b) (at scott city-c) (at scott city-d)
(in dan plane)
(in ernie plane) (in scott plane))
(:variables (fuel plane) (total-fuel-used) (total-time))
(:init
(at dan city-c)
(at ernie city-c) (at plane city-a) (at scott city-a)
(= (fuel plane) 750) (= (total-fuel-used) 0) (= (total-time) 0))
(:goal (at dan city-a)
(at ernie city-d) (at scott city-d))
(:metric minimize (total-time) )
(:group dan
(at dan city-a)
(at dan city-b)
(at dan city-c)
(at dan city-d)
(in dan plane))
(:group ernie
(at ernie city-a) (at ernie city-b) (at ernie city-c) (at ernie city-d)
(in ernie plane))
(:group plane
(at plane city-a) (at plane city-b) (at plane city-c) (at plane city-d))
(:group scott
(at scott city-a) (at scott city-b) (at scott city-c) (at scott city-d)
(in scott plane))

Figure 5: Grounded representation Zeno-Travel domain.
Symbolic pattern database heuristic (symbolic PDB) Symbolic PDBs apply explicit symbolic heuristic search engines (Edelkamp, 2002b). Due succinct
BDD-representation sets states, symbolic PDBs often orders magnitudes
larger explicit ones.
Scheduling relaxed plan heuristic (scheduling RPH) Critical-path analysis
scheduling guide plan finding phase. RPH, computes length
greedily extracted sequential plan, scheduling RPH takes relaxed sequence
operators account, searches suitable parallel arrangement,
turn defines estimator function.
3.4 Exploration Algorithms
algorithm portfolio includes three main explicit heuristic search algorithms.
A* A* algorithm (Hart, Nilsson, & Raphael, 1968) variant Dijkstras singlesource shortest path exploration scheme executed re-weighted state space graph.
lower bound heuristics, A* shown generate optimal plans (Pearl, 1985).
Weighting influence heuristic estimate may accelerate solution finding,
affects optimality (Pohl, 1977).
205

fiEdelkamp

(:action board dan plane city-a
:condition
(and (at dan city-a) (at plane city-a))
:effect
(and (in dan plane) (not (at dan city-a))
(increase (total-time) (30.000000))))
[...]
(:action zoom plane city-a city-b
:condition
(and
(at plane city-a)
(>= (fuel plane) (300.000000)))
:effect
(and (at plane city-b) (not (at plane city-a))
(increase (total-time) (60.000000))
(increase (total-fuel-used) (300.000000))
(decrease (fuel plane) (300.000000))))
[...]
(:action refuel plane city-a
:condition
(and
(at plane city-a)
(< (fuel plane) (750.000000)))
:effect
(and
(increase (total-time) (/ (- (750.000000) (fuel plane)) (12.500000)))
(assign (fuel plane) (750.000000))))
[...]
)

Figure 6: Grounded representation Zeno-Travel domain (cont.).

Iterative-Deepening A* (IDA*) memory-limited variant A* suited large
exploration problems evaluation functions small integer range low time
complexity (Korf, 1985). IDA* extended bit-state hashing (Edelkamp &
Meyer, 2001) improve duplicate detection respect ordinary transposition
tables (Reinefeld & Marsland, 1994).
(Enforced) Hill Climbing (HC) approach another compromise exploration exploitation. Enforced HC searches improved evaluation
breadth-first manner commits established action selections final (Hoffmann,
2000). Enforced HC complete undirected problem graphs.
MIPS features following two symbolic search algorithms2 .
2. non-deterministic domains, started implementing weak, strong strong cyclic exploration algorithms (Cimatti, Roveri, & Traverso, 1998).

206

fiTaming Numbers Durations MIPS

Bidirectional Symbolic Breadth-First-Search (BDD-BFS) implementation performs bidirectional blind symbolic search, choosing next search direction favor
faster execution previous iterations (Edelkamp & Helmert, 1999).
Symbolic A* (BDDA*) algorithm (Edelkamp & Reffel, 1998) performs guided symbolic search takes (possibly partitioned) symbolic representation heuristic
additional input.
3.5 Composition Competition Version
Figure 1 shaded parts actually used competition version
MIPS dark gray. used relaxed planning heuristic sequential plan generation.
scheduling relaxed planning heuristic used temporal domains. Level 2
problems use numerically extended RPH, since added system
final weeks competition. experimented (symbolic) pattern databases
mixed results. Since pattern databases purely propositional implementation
provide retrieval operators optimal abstract plan, include
competition version.
approach extend relaxed planning heuristic numerical information helps
find plans challenging numerical domains Settlers influenced Hoffmanns work competing planner Metric-FF (Hoffmann, 2002a). builds relaxed
planning graph computing fixed-point state vector restricted monotonically
increasing propositional numerical variables. version integrating numbers
relaxed planning heuristic general Hoffmanns contribution: restricted
variable-to-constant comparisons lacks ability simplify linear constraints.
Therefore, omit algorithmic details paper.
decided employ (enforced) hill climbing explicit plan generation done
Metric-FF probably LPG. Instead applied A* weight 2, merit
states fixed f (S) = g(S) + 2 h(S). conservative plan generation
engine chosen avoid unrecognized dead-ends, expected present
benchmark problems. objective that, least, completeness preserved.
avoided known incomplete pruning rules, action relevance cuts (Hoffmann &
Nebel, 2001) goal ordering cuts (Koehler & Hoffmann, 2000).
MIPS, (weighted) A* accesses Dial Weak-Heap priority queue data
structure. former used propositional planning only, latter applies
general planning scheduling estimates. Dial priority queue (Dial, 1969) linear
run time behavior, maximal value w(u, v) + h(v) h(u) edges (u, v)
weighted state space graph (labelled heuristic h) bounded constant. WeakHeaps (Edelkamp & Stiegeler, 2002) simple efficient relaxations ordinary heaps.
Priority queues implemented dynamic tables double sizes
become filled. Moreover, MIPS stores generated expanded states hash table
chaining 3 . compression planning state space, variables
appear objective function neglected hash address calculations state
3. alternative storage structure collection persistent trees (Bacchus & Kabanza, 2000), one
predicate. best case, queries update times structure logarithmic number
represented atoms.

207

fiEdelkamp

comparisons. general, may lead sub-optimal pruning duplicates. However,
benchmark domains destroy optimality, since variables addressed
objective function frequently monotonic synonyms found later search
refer worse solutions.
price paid selecting A*, especially planning problems large branching factors, storing frontier nodes space consuming. Recent techniques
partial expansion horizon list (Yoshizumi, Miura, & Ishida, 2000) reduced storage
visited list (Korf & Zhang, 2000; Zhou & Hansen, 2003) included
system. cases, number expanded nodes often large,
computing relaxed planning estimate appeared computational bottleneck.
retrospect, domains chosen, dead-ends central, hill
climbers appeared effective finding solutions.
temporal domains introduced additional parameter scale influence
propositional estimates (fp (S) = gp (S) + 2 hp (S)) scheduled ones (fs (S) =
gs (S) + 2 hs (S)). precisely, altered comparison function priority queue,
comparison parallel length priorities invoked propositional difference
values larger IN0 . higher value refers higher influence
scheduling RPH, = 0 indicates scheduling all. competition produced
data = 0 (pure MIPS), = 2 (optimized MIPS). comparisons MIPS
planners plain version used, since produces solutions.
(Edelkamp, 2002a) experimented enumeration approach fix numerical
variables finite domain, any-time wrapper optimization objective
functions. options excluded competition version
unpredictable impact planners performance.
3.6 Visualization
Visualization important ease plan understanding quickly detect inefficiencies
plan generation module. visualization plans MIPS extended
animation system Vega (Hipke, 2000); Client-Server architecture runs annotated
algorithm server side, visualized client side Java frontend.
main purpose server make algorithms accessible TCP/IP. able
receive commands multiple clients time. extended Vega two
ways (cf. Figures 7 8).
Gannt Chart Visualization Gannt Charts representations schedules,
horizontal bars drawn activity, indicating estimated duration/cost.
user selects planner executed domain problem file,
interpreted command line options. Alternatively, established plans sent
directly visualizer void planner merely mirrors solution file.
Benchmark Visualization second extension program suite visualize competition domains. moment, sequential plans shown. temporal
plans, refined simulation required, one produced PDDL2.1 plan
validator. Fortunately, MIPS temporal plan rescheduling sequential
one.
208

fiTaming Numbers Durations MIPS

Figure 7: Visualization plan Gannt Chart format.
images represent domain objects collected image web search
engine4 . generalize specific instances, advised MIPS planner export
propositional numeric state infomation established plan c-like syntax,
turn included header domain visualizer.

4. PDDL2.1 Planning
section elaborate metric temporal planning MIPS. give formal
description grounded planning instances introduce temporal model
4. used Google (cf. www.google.de) searched small GIFs

209

fiEdelkamp

Figure 8: Visualization planning problem instance Settlers.

chosen. Next look operator dependency resulting action precedence relation.
discuss optimality approach anomalies occur state
space pruning. Last least, turn treatment arbitrary plan objective
functions.
Table 1 displays basic terminology sets used paper. currently
successful planning system, MIPS grounds parameterized information present domain
description. set infer suitable index set, indicated bijective mapping
set finite domain. embedding important deal unique identifiers
entities instead textual internal representation. arrays containing
corresponding information accessed constant time.
210

fiTaming Numbers Durations MIPS

Set
OBJ
YPE
PRED
FUN C
ACT

F
V

Descriptor
objects
object types
predicates
functions
actions
operators
fluents/atoms
variables

Example(s)
dan, city-a, plane, . . .
aircraft, person, . . .
(at ?a ?c), (in ?p ?a), . . .
(fuel ?a), (total-time), . . .
(board ?a ?p), (refuel ?a), . . .
(board plane scott), . . .
(at plane city-b), . . .
(fuel plane), (total-time), . . .

Table 1: Basic set definitions.

Consequently, several planning systems, MIPS refers grounded planning
problem representations.
Definition 1 (Grounded Planning Instance) grounded planning instance quadruple
P = hS, I, O, Gi, set planning states, initial state, G
set goal states. mixed propositional numerical planning problem state
space given
2F IR|V| ,
2F power set F. Therefore, state pair (Sp , Sn ) propositional
part Sp 2F numerical part Sn IR|V| .
sake brevity, assume operators normal form, means
propositional parts (preconditions effects) satisfy standard STRIPS notation (Fikes &
Nilsson, 1971) numerical parts given form arithmetic trees taken
set trees arithmetic operations nodes numerical variables
evaluated constants leaves. However, fundamental difference
general representation preconditions effects. current implementation MIPS
simplifies ADL expressions preconditions takes generic precondition trees
numerical parts, thereby including comparison symbols, logical operators arithmetic
subtrees5 .
Definition 2 (Syntax Grounded Planning Operators) operator normal form
= (, , , ) propositional preconditions F, propositional effects = (a , )
F 2 add list delete list , numerical preconditions , numerical effects .
numerical precondition c triple c = (hc , , tc ), hc V, {, <, =, >, },
tc , arithmetic tree. numerical effect triple =
(hm , , tm ), hm V, {, , } tm . case, call hm head
numerical effect.
5. newer versions MIPS mixing numerical logical preconditions form (or P (< F 3)),
P F F V fact feasible. Boolean expressions put negational normal form
disjunction precondition produce different action instantiations.

211

fiEdelkamp

Obviously, {, <, =, >, } represents associated comparison relation, denotes assignment variable, indicate respective increase decrease
operation.
Definition 3 (Constraint Satisfaction Modifier Update) Let index mapping
variables. vector Sn = (S1 , . . . , S|V| ) numerical variables satisfies numerical
constraint c = (hc , , tc ) S(hc ) eval(Sn , tc ) true, eval(Sn , tc ) IR
obtained substituting v V tc S(hc ) followed simplification tc .
0 ) modifier
vector Sn = (S1 , . . . , S|V| ) updated vector Sn0 = (S10 , . . . , S|V|
= (hm , , tm ) ,
0
S(h
= eval(Sn , tm ) = ,
m)
0
S(h
= S(hm ) + eval(Sn , tm ) = ,
m)
0
S(h
= S(hm ) eval(Sn , tm ) = .
m)

next formalize application planning operators given state.
Definition 4 (Semantics Grounded Planning Operator Application) operator =
(, , , ) applied state = (Sp , Sn ), Sp 2F Sn IR|V| , yields successor
state 0 = (Sp0 , Sn0 ) 2F IR|V| follows.
Sp Sn satisfies c Sp0 = (Sp \ ) vector Sn updated
.
propositional update Sp0 = (Sd \ ) defined standard STRIPS.
example take state = (Sp , Sn )
Sp = {(at ernie city-d), (at plane city-a), (at scott city-d), (in dan plane)}
Sn = {(fuel plane) : 83.3333, (total-fuel-used) : 1666.6667, (total-time) : 710}.
successor Sn0 = (Sp0 , Sn0 ) due action (debark dan plane city-a)
Sp0 = {(at dan city-a), (at ernie city-d), (at plane city-a), (at scott city-d)}
Sn0 = {(fuel plane) : 83.3333, (total-fuel-used) : 1666.6667, (total-time) : 730}.
effect lists order update operations important. example
refuelling aircraft ZenoTravel, cf. Figure 6, fuel level reset variable
total-time updated.
set goal states G often given G = (Gp , Gn ) partial propositional state
description Gp F, Gn set numerical conditions c = (hc , , tc ). Moreover,
arithmetic trees tc usually collapses simple leaves labelled numerical constants.
Hence, sake simplifying complexity analysis object symmetry
might assume |Gn | |V|. Complex goal description limitation planner,
since easily transformed preconditions goal-enabling opererator.
212

fiTaming Numbers Durations MIPS

4.1 Temporal Model
simplest approach solving temporal planning problem generate sequential
plan. course, option assumes temporal structure contributes
value plan correctness. is, assumes necessary
concurrency valid plan. cases actions achieve conditions start
points delete end points, example, concurrency necessary
part structure valid plan.
Definition 5 (Sequential Plan) solution planning problem P = hS, I, O, Gi
form sequential plan ordered sequence operators Oi O, {1, . . . , k},
transforms initial state one goal states G G, i.e., exists
sequence states Si S, {0, . . . , k}, S0 = I, Sk = G Si outcome
applying Oi Si1 , {1, . . . , k}.
time stamp ti durational operator Oi , {1, . . . , k} starting time.
Pi1
d(Oj ).
d(Oi ) duration operator Oi , ti = j=1
sequential plans, time stamps calculated MIPS using extra variable
total-time. variable updated scheduling operators. example sequential plan time stamps shown Figure 12.
Minimizing sequential plan length objective first second planning competitions. Since Graphplan-like planners (Blum & Furst, 1995) IPP (Koehler,
Nebel, & Dimopoulos, 1997) STAN (Long & Fox, 1998) already produced parallel plans
(assuming action duration 1), indeed limiting factor evaluating plan quality.
important reason artificial restriction total-ordered plans
easier automatically validate, necessity checking correctness competition.
PDDL 2.1 domain descriptions include temporal modifiers start, all, end,
label start denotes preconditions effects invocation time
action, refers invariance condition end finalization conditions
consequences action.
Figure 9 show two different options flattening information simple
preconditions effects order derive semantic sequential plans. first
case (top right), compound operator split three smaller parts, one action
invocation, one invariance maintenance, one action termination.
semantics suggested (Fox & Long, 2003).
PDDL2.1 effects invariance pattern, i.e. B 0 = . action
board, quite natural code invariance form conditions (B) perform
actual status change: person boards aircraft city aircraft required
remain city throughout action. moving corridor, status
corridor could encoded invariant would change starting
time action execution.
Moreover, found benchmarks uncommon new effects at-start
preconditioned termination control invariance maintenance, i.e. A0 (B C) = .
Even though intersection conditions effects formally defined yet,
interpreted executing one construct interfere one. reflects
213

fiEdelkamp

pre: eff: pre: eff: pre: eff:
at-start

over-all

at-end

cond:



B

C

eff:

A0

B0

C0

A0

pre:

B B0

C C0

eff:

ABC

A0 B 0 C 0

Figure 9: Compiling temporal modifiers operators.
possible partition operator sub-operators A, B, C, A0 , B 0 , C 0 . Dependence
transposition separated conditions effects considered Section 4.2.
consider example problem more, observe, action board, A0
consists (person airplane) predicate. seen above, B requires plane stay
city boarding, C empty. action zoom, A0 contains effect
plane longer location flight started, B C empty.
cases A0 (B C) = .
B 0 = A0 (B C) = sequential execution sequence
sub-operators (A, A0 , B, B 0 , C, C 0 ) equal execution sequence (A, B, C, A0 , B 0 , C 0 ).
reasoning follows. Since B 0 = (A, A0 , B, B 0 , C, C 0 ) = (A, A0 , B, C, C 0 ).
Conditions A0 B = A0 C = allows us exchange order corresponding
items, (A, A0 , B, C, C 0 ) = (A, B, C, A0 , C 0 ). more, apply B 0 = derive
(A, B, C, A0 , C 0 ) = (A, B, C, A0 , B 0 , C 0 ). consequence remains valid condition
B 0 = weakened B 0 C = .
MIPS operator representation bottom right Figure 9 chosen. Note
intermediate format example problem Figures 5 6 implicitly assumed
temporal model. sequential planning competition benchmark domains
observed many deficiencies model6 .
However, applicability model exploiting parallelism limited. example
consider two people lift table two sides once, could done
one person alone. case parallel execution set actions
cannot totally ordered. allowed MIPS. may argued defining
action requires two different persons certain place would require
equality construct PDDL form numerical maintenance number
people room, found another (artificial) example planning problem
total order. Consider simple STRIPS planning problem domain = {B},
G = {{A, C}}, = {({B}, {A}, {B}), ({B}, {C}, {B})}. Obviously, operators
needed goal achievement, sequential plan length 2, since B
deleted operators. However, parallel plan could devised, since precondition
fulfilled first time step.
6. current versions MIPS refined model, at-start, all, at-end information
preserved grounding process attached action. approach allow
dependent operators overlap minimizes number gaps, start-start, start-end
end-end exclusions. domains, improvement yields much better solutions.

214

fiTaming Numbers Durations MIPS

4.2 Operator Dependency
definition operator dependency enables computing optimal schedules sequential
plans respect generated action sequence causal operator dependency
structure. operators dependent (or void respect optimizer function),
problem inherently sequential schedule leads improvement.
Definition 6 (Dependency/Mutex Relation) Let L(t) denote set leaf variables
tree . Two grounded operators = (, , , ) O0 = (0 , 0 , 0 , 0 )
dependent/mutex, one following three conflicts hold.
Propositional conflict propositional precondition set one operator nonempty intersection add delete list other, i.e., (a0 d0 ) 6=
(a ) 0 6= .
Direct numerical conflict head numerical modifier one operator contained
condition one, i.e. exists c0 = (h0c , , t0c ) 0
= (hm , , tm ) hm L(t0c ) {h0c } exists c = (hc , , tc )
m0 = (h0m , , t0m ) 0 h0m L(tc ) {hc }.
Indirect numerical conflict head numerical modifier one operator contained formula body modifier one, i.e., exists
= (hm , , tm ) m0 = (h0m , , t0m ) 0 hm L(t0m ) h0m L(tm ).
example, operators (board scott plan city-a) (fly plane city-a
city-c) propositional conflict fluent (at plane city-a), (refuel
plane-a city-a) (fly plane city-a city-c) direct numerical conflict
variable (fuel plane). Indirect conflicts subtle, appear
example problem.
use dependency find optimal concurrent arrangement operators
sequential plan. O2 dependent O1 O1 appears O2 sequential
plan, O1 invoked O2 starts. dependence relation reflexive, i.e.
conflict O0 O0 conflict O. Moreover, appears restrictive
compared PDDL 2.1 guidelines mutual exclusion (Fox & Long, 2003),
allows operators partially overlapping even dependent.
However, possible generalize approach. If, according model Fox
Long, two actions Oi represented (Ai , A0i , Bi , Bi0 , Ci , Ci0 ), {1, 2},
dependency violation O1 O2 located identifying sub-operators
interact. fact may identify eight possible refined conflicts (A1 A01 )
interacts (A2 A02 ), (A1 A01 ) interacts (B2 B20 ), (A1 A01 ) interacts
(C2 C20 ), (B1 B10 ) interacts (A2 A02 ), (B1 B10 ) interacts (C2 C20 ), (C1 C10 )
interacts (A2 A02 ), (C1 C10 ) interacts (A2 A02 ), (C1 C10 ) interacts
(A2 A02 ). asserting duration zero pair (Ai , A0i ), d(A) (Bi , Bi0 ), zero
pair (Ci , Ci0 ), one fix earliest start end time O2 respect O1 .
competition version MIPS, stick simplified temporal model.
competition domains, improving sequential plans according dependency relation
turned produce plans sufficient quality.
215

fiEdelkamp

implementation, dependence relation computed beforehand tabulated
constant time access. improve efficiency pre-computation, set leaf
variables maintained array, grounded operator constructed.
original Graphplan definition propositional mutex relation close ours.
fixes interference d0 (a ) 6= (a0 0 ) 6= .
Lemma 1 d0 0 , operator inference Graphplan model implied
propositional MIPS model dependence.
Proof: d0 0 , two independent operators = (, ) o0 = (0 , 0 ):
(a0 d0 ) = implies (a0 d0 ) = , turn yields d0 = . condition
a0 = inferred analogously.
notion dependency related partial order reduction explicit-state model
checking (Clarke et al., 1999), two operators O1 O2 independent
state following two properties hold:
1. Neither O1 O2 disable execution other.
2. O1 O2 commutative, i.e. O1 (O2 (S)) = O2 (O1 (S)) S.
next result indicates state space enumeration approaches refer
property.
Theorem 1 (Commutativity) Two independent (STRIPS) operators = (, ) O0 =
(0 , 0 ) d0 0 commutative preserve enabled property (i.e.
O0 enabled enabled O0 (S) O0 enabled O(S)).
Proof: Since d0 0 , d0 = a0 = Lemma 1. Let
state ((S \ ) ) let 00 state ((S \ d0 ) a0 ). Since (a0 d0 ) = ,
enabled 00 , since (a ) 0 = , O0 enabled 0 . Moreover,
S0

O(O0 (S)) = (((S \ d0 ) a0 ) \ )
= (((S \ d0 ) \ ) a0 )
= \ (d0 ) (a0 )
= \ (d d0 ) (a a0 )
= (((S \ ) \ d0 ) ) a0
= (((S \ ) ) \ d0 ) a0 = O0 (O(S)).

consequence, operator independence indicates possible transpositions two operators O1 O2 prune exploration sequential plan generation. less restrictive
notion independence, several actions may occur time even one
deletes add-effect another provided (Knoblock, 1994). detect domains
parallelization leads improvement, utilize following sufficient criterion.
216

fiTaming Numbers Durations MIPS

Definition 7 (Inherent Sequential Domains) planning domain said inherently
sequential operator sequential plan either instantaneous (i.e. zero
duration) dependent immediate predecessor.
static analyzer checks testing operator pair. benchmark domains DesertRats Jugs-and-Water inherently sequential, others ZenoTravel
Taxi not.
Definition 8 (Parallel Plan) solution planning problem P = hS, I, O, Gi
form parallel plan c = ((O1 , t1 ), . . . , (Ok , tk )) arrangement operators Oi O,
{1, . . . , k}, transforms initial state one goal states G G,
Oi executed time ti IR0 .
example parallel plan ZenoTravel problem depicted Figure 12.
Backstom (1998) clearly distinguishes partially ordered plans (O1 , . . . , Ok , ),
relation {O1 , . . . , Ok }2 partial order (reflexive, transitive, antisymmetric), parallel plans (O1 , . . . , Ok , , #), # ( 1 ) (irreflexive, symmetric)
expressing, actions must executed parallel.
Definition 9 (Precedence Ordering) ordering induced operators O1 , . . . , Ok
defined
Oi Oj : Oi Oj dependent 1 < j k.
Precedence partial ordering, since neither reflexive transitive. computing
transitive closure relation, however, precedence could extended partial
ordering. sequential plan O1 , . . . , Ok produces acyclic set precedence constraints
Oi Oj , 1 < j k, set operators. important observe,
constraints already topologically sorted according index order 1, . . . , k.
Definition 10 (Respecting Precedence Ordering Parallel Plan) let d(O)
IR0 duration operator sequential plan. parallel plan c = ((O1 , t1 ),
. . . , (Ok , tk )) respects , ti + d(Oi ) tj Oi Oj , 1 < j k.
optimizing plans (Backstrom, 1998) defines parallel execution time max{ti +
d(Oi ) | Oi {O1 , . . . , Ok }}, Oi Oj , ti + d(Oi ) tj , Oi #Oj ,
either ti + d(Oi ) tj tj + d(Oj ) ti . two possible choices # actually
apparent approach, since already precedence relation hand
seek optimal arrangement operators. Consequently assert one option,
namely ti + d(Oi ) tj true, reducing # . order find optimal schedules
sequential plans approach similar (Backstrom, 1998) would necessary.
would dramatically increase computational complexity, since optimal scheduling
set fixed-timed operators NP-hard. Therefore, decided restrict dependency
relation .
Definition 11 (Optimal Parallel Plan) optimal parallel plan respect sequence
operators O1 , . . . , Ok precedence ordering plan = ((O1 , t1 ), . . . , (Ok , tk ))
minimal parallel execution time OP = max{ti + d(Oi ) | Oi {O1 , . . . , Ok }} among
parallel plans c = ((O1 , t01 ), . . . , (Ok , t0k )) respect .
217

fiEdelkamp

Procedure Critical-Path
Input: Sequence operators O1 , . . . , Ok , precedence ordering
Output: Optimal parallel plan length max{ti + d(Oi ) | Oi {O1 , . . . , Ok }}
{1, . . . , k}
e(Oi ) d(Oi )
j {1, . . . , 1}
(Oj Oi )
e(Oi ) < e(Oj ) + d(Oi )
e(Oi ) e(Oj ) + d(Oi )
return max1ik e(Oi )

Figure 10: Algorithm compute critical path costs.
Many algorithms suggested convert sequential plans partially ordered
ones (Pednault, 1986; Regnier & Fade, 1991; Veloso, Perez, & Carbonell, 1990).
interpret totally ordered plan maximal constrained partial ordering =
{(Oi , Oj ) | 1 < j k} search less constrained plans. However, problem
minimum constraint deordering proven NP-hard, unless so-called
validity check polynomial (Backstrom, 1998), deordering maintains validity
plan lessening constrainedness, i.e. 0 new ordering 0 .
Since explicit model dependency time, optimal parallel plans
change ordering relation all.
4.3 Critical Path Analysis
Project Evaluation Review Technique (PERT) critical path analysis algorithm
usually applied project management problems. critical path sequence activities
total time activities path greater equal
path operators. delay tasks critical path leads delay project.
heart PERT network tasks needed complete project, showing order
tasks need completed dependencies them.
shown Figure 10, PERT scheduling reduces variant Dijkstras shortest
path algorithm acyclic graphs (Cormen, Leiserson, & Rivest, 1990). matter fact,
algorithm returns length critical path inferred partially ordered
plan. However, obtaining temporal plan easy. algorithm, e(Oi ) tentative
earliest end time operator Oi , {1, . . . , k}, earliest starting times ti
operators optimal plan given ti = e(Oi ) d(Oi ).
Theorem 2 (PERT Scheduling) Given sequence operators O1 , . . . , Ok precedence ordering , optimal parallel plan = ((O1 , t1 ), . . . , (Ok , tk )) computed
optimal time O(k + | |).
Proof: proof induction {1, . . . , k}. induction hypothesis
iteration value e(Oi ) correct, e.g. e(Oi ) earliest end time operator
218

fiTaming Numbers Durations MIPS

Oi . clearly true = 1, since e(O1 ) = d(O1 ). assume hypothesis
true 1 j < look iteration i. two choices. Either j
{1, . . . , 1} Oj Oi . case inner loop completed, e(Oi )
set max{e(Oj ) + d(Oj ) | Oj Oi , j {1, . . . , 1}}. hand, e(Oi )
optimal, since Oi cannot start earlier max{e(Oj ) | Oj Oi , j {1, . . . , 1}}, since
values e(Oj ) already smallest possible induction hypothesis.
j {1, . . . , 1} Oj Oi , e(Oi ) = d(Oi ) base case. Therefore,
end, max1ik e(Oi ) optimal parallel path length.
time space complexity algorithm Critical-Path clearly O(k 2 ),
k length sequential plan. Using adjacency list representation
efforts reduced time space proportional number vertices edges
dependence graph, size O(k + | |). bound optimal, since
input consists (k) operators (| |) dependencies among them.
apply critical path scheduling, even consider temporal model Fox
Long, allowing overlapping operator execution dependent operators? answer
yes. already seen considering two dependent operators Oi Oj
Fox Long model, determine earliest start (and end) time Oj respect
fixed start time Oi . need. proof Theorem 2 shows
determine earliest end time operators sequentially.
4.4 Optimality MIPS
Since MIPS optimally schedules sequential plans, question remains, system
eventually find optimal plan? competition, system terminates
first sequential plan found. Since relaxed planning heuristic admissible,
A* variants cannot guarantee optimal (sequential parallel) plans. However, computing
optimal plans desirable, even due limited computational resources finding optimal
plans hard.
According temporal model, optimal parallel plan, operator either starts
ends start end time another operator. Therefore, least finite number
actions optimal plan, possibly exponential finite number possible
parallel plans.
immediately leads following naive plan enumeration algorithm: |O|i
operator sequences length i, IN, generate possible parallel plans, check
individual schedule transforms initial state one goals, take
sequence smallest parallel plan length. Since parallel plans computed, yields
complete optimal algorithm. seen example two persons lifting table,
approach expressive applying algorithm finds sequential
plans first. However, algorithm inefficient.
practice, natural assumption parallel plan corresponds least one
(possible many) sequential one(s). Conversely, partially ordered plan established
generating totally ordered plan first applying scheduling algorithm
find best partial-order.
algorithm Figure 11 indicates wrap forward chaining planner
any-time performance gradually improves plan quality. general state
219

fiEdelkamp

Procedure Any-Time
Input: Planning Problem hS, I, O, Gi
Output: Optimal parallel plan length

Open
(Open 6= )
Extract(Open)
0 expand(S)
(S 0 G)
cp Critical-Path (path(S 0 ), )
(cp < )
cp
else
Change(Open, 0 )
return
Figure 11: General any-time search algorithm.
expanding scheme maintains search horizon list Open. simplicity maintenance stored nodes list Closed shown. algorithm, current best
critical path cost bounds upcoming exploration process. turn updated
time plan found shorter critical path.
CriticalPath procedure above, algorithm returns execution time only,
established plan. compute plan meets returned value ,
store schedule generating sequence path(S 0 ) global record. cases,
storing 0 sufficient, since path PERT scheduling restored calling
procedure CriticalPath end procedure.
Assuming optimal parallel plan schedule sequential plan state
space finite, any-time extension cycle-avoiding enumeration strategy indeed
complete optimal. reason completeness finite graphs number
acyclic paths G finite every node expansion, algorithm adds new
links traversal tree. newly added link represents new acyclic path, that,
eventually, reservoir paths must exhausted.
valid parallel plans cannot produced PERT scheduling
sequential plan? answer no. partial ordering algorithm terminates
optimal schedule, generate corresponding sequential plan preserving
dependency structure. Optimal PERT-scheduling plan respect set
operators imposed precedence relation yield optimal parallel plan.
sequential plans eventually generated, optimal parallel plan found
PERT scheduling.
problem enumeration infinite state spaces infinite plateaus
plan objective function constant value. Normally increasing length
plan increases cost. However, true benchmark problems, since
220

fiTaming Numbers Durations MIPS

may infinite sequence events contribute plan objective.
example, loading unloading tanks pre-competition test domain DesertRats
affect total-fuel consumption, minimized one instances.
Enumeration schemes contradict known undecidability results numerical planning (Helmert, 2002). additional information bound maximal
number actions plan number actions executed parallel,
cannot decide whether cycle-free enumeration terminate not. hand
solution, any-time algorithm eventually find it.
4.5 Pruning Anomalies
Acceleration techniques duplicate detection sequential plan generation
chosen carefully maintain parallel plan length optimality. approach affect
parallel optimality, following example shows. ZenoTravel problem consider
sequences
(zoom city-a city-c plane), (board dan plane city-c),
(refuel plane city-c), (zoom city-c city-a plane),
(board scott plane city-a), (debark dan plane city-a), (refuel plane city-a),

(board scott plane city-a), (zoom city-a city-c plane),
(board dan plane city-c), (refuel plane city-c),
(zoom city-c city-a plane), (debark dan plane city-a), (refuel plane city-a)
two sets operators resulting (sequentially generated)
states. However, PERT schedule first sequence shorter schedule
second one, boarding scott done parallel final two actions
plan.
small problems, anomalies avoided omitting duplicate pruning.
example Figure 12 depicts sequential plan example problem instance
PERT schedule, turns overall optimal parallel plan. Another option
store resulting parallel plan state caching instead sequential one. Note
order ease generation sequential solutions large planning problem instances,
competition version MIPS used sequential state pruning.
4.6 Heuristic Search
main drawback blind path enumeration seemingly slow practical
planning. Heuristic search algorithms A* IDA* reorder traversal states,
(assuming state caching) affect completeness optimality anytime wrapper. efficiency wrapper directly depends quality path
enumeration. competition version MIPS omitted any-time wrapping, since
optimal solutions required practical run-time behavior poor.
Instead used A* search engine, terminates first established solution.
question remains: still hope finding near optimal parallel plans? general
result applicable infinite graphs established (Pearl, 1985): cost every
221

fiEdelkamp

0:
100:
130:
160:
200:
300:
320:
350:
390:
490:
530:
630:
650:

(zoom plane city-a city-c) [100]
(board dan plane city-c)
[30]
(board ernie plane city-c) [30]
(refuel plane city-c)
[40]
(zoom plane city-c city-a) [100]
(debark dan plane city-a)
[20]
(board scott plane city-a) [30]
(refuel plane city-a)
[40]
(zoom plane city-a city-c) [100]
(refuel plane city-c)
[40]
(zoom plane city-c city-d) [100]
(debark ernie plane city-d) [20]
(debark scott plane city-d) [20]

0: (zoom plane city-a city-c) [100]
100: (board dan plane city-c)
[30]
(board ernie plane city-c) [30]
100: (refuel plane city-c)
[40]
140: (zoom plane city-c city-a) [100]
240: (debark dan plane city-a)
[20]
(board scott plane city-a) [30]
(refuel plane city-a)
[40]
280: (zoom plane city-a city-c) [100]
380: (refuel plane city-c)
[40]
420: (zoom plane city-c city-d) [100]
520: (debark ernie plane city-d) [20]
(debark scott plane city-d) [20]

Figure 12: sequential plan Zeno-Travel (left) PERT schedule (right).

infinite path unbounded, A*s cost function f = g + h preserve optimality.
additional rationale choosing A*-like exploration MIPS instead hill climbing
best-first. breadth-first search, rising influence g-value crucial.
find adequate heuristic estimate parallel plans easy. fact
established competitive admissible heuristic, required optimal plan
finding A*. choice scheduling extension RPH. contrast RPH,
new heuristic takes relaxed sequence operators searches suitable parallel
arrangement, turn defines estimator function.
found adding PERT-schedules path state sequence
actions relaxed plan accurate PERT-schedule combined paths.
Therefore, classical merit function A*-like search engines f = g +h generating path
length g heuristic estimate h immediate correspondence parallel planning.
Consequently, define heuristic value scheduling RPH parallel plan length
combined path minus parallel plan length generating path.
4.7 Arbitrary Plan Objectives
PDDL 2.1 plan metrics minimizing total (parallel) execution time
specified. influences inferred solutions. Figure 13 depict two plans found
MIPS objective functions minimizing total-fuel-used, minimizing
compound (+ (* 10 (total-time)) (* 1 (total-fuel-used))).
first case computed optimal value 1,333.33, second case
established 7,666.67 optimized merit. optimizing time, ordering board
zoom actions important. optimizing total-fuel reduce speed save fuel
consumption 333.33 per flight may board first passenger immediately.
save two refuel actions respect first case.
increasing importance time trade refueling actions time,
zooming flight actions chosen complex minimization criterion.
first attempt include arbitrary plan objectives alter PERT scheduling
process. However, results match ones produced validator (Long &
222

fiTaming Numbers Durations MIPS

0: (zoom plane city-a city-c) [100]
100: (board dan plane city-c)
[30]
(board ernie plane city-c) [30]
(refuel plane city-c)
[40]
140: (zoom plane city-c city-a) [100]
240: (debark dan plane city-a)
[20]
(board scott plane city-a) [30]
(refuel plane city-a)
[40]
280: (fly plane city-a city-c) [150]
430: (fly plane city-c city-d) [150]
580: (debark ernie plane city-d) [20]
(debark scott plane city-d) [20]

0: (board scott plane city-a) [30]
30: (fly plane city-a city-c) [150]
180: (board ernie plane city-c) [30]
(board dan plane city-c)
[30]
210: (fly plane city-c city-a) [150]
360: (debark dan plane city-a) [20]
(refuel plane city-a)
[53.33]
413.33: (fly plane city-a city-c) [150]
563.33: (fly plane city-c city-d) [150]
713.33: (debark ernie plane city-d)[20]
(debark scott plane city-d)[20]

Figure 13: Optimized plans Zeno-Travel according different plan objectives.
Fox, 2001), final time substituted objective function plan
built.
way MIPS evaluates objective functions time follows. First schedules
(relaxed final) sequential plan. Variable total-time temporarily substituted
critical path value objective formula evaluated. avoid conflicts subsequent
expansions, afterwards value total-time set back optimal one sequential
plan.

5. Object Symmetries
important feature parameterized predicates, functions action descriptions
domain specification file actions transparent different bindings parameters
objects. Disambiguating information present problem instance file.
case typed domains, many planners, including MIPS, compile type information additional predicates, attach additional preconditions actions enrich
initial states suitable object-to-type atoms.
consequence, symmetry viewed permutation objects present
current state, goal representation, transparent set operators.
n!, n = |OBJ |, possible permutations set objects. Taking
account type information reduces number possible permutation
n
t1 , 2 , . . . , k

!

=

n!
.
t1 !t2 ! . . . tk !

ti number objects type i, {1, . . . , k}. moderate sized logistic
domain 10 cities, 10 trucks, 5 airplanes, 15 packages, results 40!/(10! 10!
5! 15!) 1020 permutations.
reduce number potential symmetries tractable size restrict symmetries
object transpositions, n(n 1)/2 O(n2 ) candidates. Using
type information number reduces
k
X
ti
i=1

2

!

=

k
X

ti (ti 1)/2.

i=1

223

fiEdelkamp

following, set typed object transpositions denoted SYMM.
Logistics example, |SYMM| = 45 + 45 + 10 + 105 = 205.
5.1 Generating Object Symmetries Planning Problems
section compute subset SYMM includes object pairs
entire planning problem symmetric. start object transpositions smallest
entities planning problem.
Definition 12 (Object Transpositions Fluents, Variables, Operators) transposition objects (o, o0 ) SYMM applied fluent f = (p o1 , . . . , ok(p) ) F, written
f [o o0 ], defined (p o01 , . . . , o0k(p) ), o0i = oi oi
/ {o, o0 }, oi = o0 oi = o,
oi = oi = o0 , {1, . . . , k(p)}. Object transpositions [o o0 ] applied variable
v = (f o1 , . . . , ok(f ) ) V operator = (a o1 , . . . , ok(a) ) defined analogously.
example, ZenoTravel problem (at scott city-a)[scott dan] =
(at dan city-a).
Lemma 2 f F, v V, O, (o, o0 ) SYMM: f [o o0 ] = f [o0 o],
v[o o0 ] = v[o0 o], O[o o0 ] = O[o0 o], well f [o o0 ][o o0 ] = f ,
v[o o0 ][o o0 ] = v, O[o o0 ][o o0 ] = O.
brute-force time complexity computing f [o o0 ] F order O(k(p)),
k(p) number object parameters p. However, pre-computing O(|SYMM|
|F|) sized lookup table, containing index f 0 = f [o o0 ] (o, o0 ) SYMM,
time complexity reduced O(1).
Definition 13 (Object Transpositions States) Let mapping set
{1, . . . , |T |}. object transposition [o o0 ] applied state = (Sp , Sn )
Sn = (v1 , . . . , vk ), k = |V|, written S[o o0 ], equal (Sp [o o0 ], Sn [o o0 ])
Sp [o o0 ] = {f 0 F | f Sp f 0 = f [o o0 ]}
Sn [o o0 ] = (v10 , . . . , vk0 ) vi = vj0 1 (i)[o o0 ] = 1 (j) i, j {1, . . . , k}.
initial state example problem I[dan ernie] = I. definition
variables slightly difficult predicates, since, case, variable
contents, availability, must match.
time complexity compute Sn [o o0 ] O(k), since testing 1 (i)[o o0 ] =
1 (j) available time O(1) building another O(|SYMM| |V|) sized pre-computed
look-up table. Note times worst-case. terminate computation
object symmetry fluent variable contradictory. summarize complexity
results follows.
Lemma 3 worst-case time complexity compute S[o o0 ] state = (Sp , Sn )
(o, o0 ) SYMM O(|Sp | + |V|) using O(|SYMM| (|F| + |V|)) space.
next step lift concept object transposition planning problems.
224

fiTaming Numbers Durations MIPS

Definition 14 (Object Transpositions Domains) planning problem P = hS, O, I, Gi
symmetric respect object transposition [o o0 ], abbreviated P[o o0 ],
I[o o0 ] = G G: G[o o0 ] G.
Since goal descriptions partial, prefer writing G[o o0 ] G instead G G:
G[o o0 ] G. Moreover, assume goal description complexity G bounded
O(|Gp | + |V|).
ZenoTravel problem, goal descriptor purely propositional, containing three
facts target location dan, ernie, scott. initial state running
example planning problem contains object symmetry, since I[scott ernie] 6=
G[dan ernie] 6= G.
Applying Lemma 3 (o, o0 ) SYMM yields time complexity needed establish object symmetries.
Theorem 3 (Time Complexity Object Symmetry Detection) worst-case run-time
determine set object transpositions planning problem P = hS, O, I, Gi
symmetric O(|SYMM| (|Gp | + |Ip | + |V|)).
5.2 Including Goal Symmetry Conditions
Symmetries present initial state may vanish reappear exploration
forward chaining planner MIPS. DesertRats domain, example, initial set
supply tanks indistinguishable one loaded truck.
fuel levels supply tanks decrease tanks transported another location,
previously existing symmetries broken. However, two tanks one location become
empty, considered symmetric.
Goal conditions, however, change time, initial state transforms
current state C. Therefore, pre-compiling phase refine set SYMM
SYMM0 (o, o0 ) SYMM | G[o o0 ] = G .




Usually, |SYMM0 | much smaller |SYMM|. ZenoTravel problem instance,
object symmetry left SYMM0 transposition scott ernie.
Therefore, efficiently compute set
SYMM00 (C) {(o, o0 ) SYMM0 | C[o o0 ] = C}
symmetries present current state. initial state example
problem Zeno-Travel SYMM00 (I) = , scott ernie share
location state C object pair would included SYMM00 (C).
definition requires C[o o0 ] = C. include symmetric paths
different states. Let C = {(at ernie city-c), (at scott city-d)}. possible
symmetric plan {(at ernie city-d), (at scott city-c)} common
goal. Viewed differently, complex object symmetries form [o1 o01 ][o2 o02 ]
detected. example observe C[scott ernie][city-c city-d] = C.
respect Theorem 3 additional restriction reduces time complexity
detect remaining object symmetries O(|SYMM0 | (|Cp | + |V|)).
225

fiEdelkamp

5.3 Pruning Operators
planning problem current state C symmetric respect operator
transposition [o o0 ] either application operator application
operator O[o o0 ] neglected, significantly reducing branching factor. Lemma 4
indicates symmetry used reduce exploration.
Lemma 4 operator applicable = S[o o0 ] O[o o0 ] applicable

O(S)[o o0 ] = O[o o0 ](S).
Proof: applicable O[o o0 ] applicable S[o o0 ]. Since =
S[o o0 ], O[o o0 ] applicable S,
O[o o0 ](S) = O[o o0 ](S[o o0 ]) = O(S)[o o0 ].

pre-computing O(|SYMM| |O|) sized table index (O0 ) operator O0 =
O[o o0 ] determined time O(1) (o, o0 ) SYMM0 .
Definition 15 (Pruning Set) Let index mapping set {1, . . . , |T |} let
(C) set operators applicable state C S. pruning set (C) (C)
defined set operators symmetric counterpart
minimal index. symmetry reduction 0 (C) (C) defined (C) \ (C).
Theorem 4 (Correctness Operator Pruning) Reducing operator set (C) 0 (C)
exploration planning problem P = hS, O, I, Gi preserves completeness7 .
Proof: Suppose expanded state C, reducing operator set (C) 0 (C)
exploration planning problem P = hS, O, I, Gi preserve completeness.
Furthermore, let C state property maximal exploration order.
sequential plan = (O1 . . . , Ok ) PC = hS, O, C, Gi associated
state sequence (S0 = C, . . . , Sk G). Obviously, Oi (Si1 ), {1, . . . , k}.
choice C O1 (S0 ) \ 0 (S0 ) = (S0 ). definition pruning set
(S0 ) exists O10 = O1 [o o0 ] minimal index applicable S0 .
Since PC = hS, O, C, Gi = PC [o o0 ] = hS, O, C[o o0 ] = C, G[o o0 ] = Gi ,
sequential plan O1 [o o0 ], . . . , Ok [o o0 ] state sequence (S0 [o o0 ] = S0 , S1 [o
o0 ], . . . , Sk [o o0 ] = Sk ) reaches goal G. contradicts assumption
reducing operator set (C) 0 (C) preserve completeness C.
Since plan objective refers instantiated predicates objects, similar
initial goal state, symmetry breaking. order preserve optimality, one
additionally check, see object exchange influence plan objective.
practice, objective functions often based non-parameterized predicates,
case optimal planning algorithm affected symmetry cuts.
7. Generally completeness means planner find legal plan. intended here.
use completeness terms discarding legal plans favor equally good symmetric plans.

226

fiTaming Numbers Durations MIPS

5.4 Symmetry Reduction MIPS
main purpose restricted implementation MIPS reduce run
time object symmetry detection losing effectiveness. Especially
impact quantity O(|SYMM0 | |Cp |) running time considerable.
key observation symmetries present fact groups according
group representatives. shown Figure 5, fact group dan consists facts
(at dan city-a), (at dan city-b), (at dan city-c), (at dan city-d), (in dan
plane). Similarily, ernies group facts (at ernie city-a), (at ernie city-b), (at
ernie city-c), (at ernie city-d), (in ernie plane). ordering facts
groups chosen way that, except change group representative,
corresponding facts match. Together facts groups, operators change
facts groups, stored efficient dictionary.
Therefore, restrict object transpositions group representatives. reduces
set objects OBJ MIPS considers considerably smaller subset OBJ 0 .
example problem |OBJ | = 7, |OBJ 0 | = 4. Many objects, e.g. objects
type city ZenoTravel, selected representatives single attribute invariance
build group.
idea obtain possible transposition fact group representatives, followed
looking respective fact positions current goal state. may happen,
one group fixed representative OBJ 0 . case, link groups
representative common. symmetry detection test group chains
objects matching current goal position.
above, symmetries based non-matching goal predicates excluded beforehand. Let RSYMM number remaining symmetries object representatives.
Assume one representative per group yields running time propositional object
symmetry detection state C O(RSYMM + |Cp |). remaining comparisons variables v V implemented described previous section, performed
object pairs pass propositional check.
pruning operators, MIPS marks groups correspond object symmetry
larger index visited. guarantees operator least one
group executed. expanded state matching operator (S)
algorithm checks, whether applied operator present visited group, case
pruned. time complexity O(|(S)|), since operator group containment
preprocessed checked constant time.
Figure 14 shows effectiveness symmetry reduction planner MIPS DesertRats domain, scales respect total distance d, {300, 400, 500, 600},
passed (x-axis). direction, number expanded states A*
search MIPS object symmetry reduction (right bars) without symmetry reduction (left bars) shown logarithmic scale. expected, larger problems symmetry
reduction yields performance gains one order magnitude (d = 500).
yields solutions problems algorithms without symmetry reduction fail due
memory restrictions (d = 600)8 .
8. memory bound used example set 1/2 GByte.

227

fiEdelkamp

Figure 14: Results symmetry pruning Desert Rats. Bars show number states
expanded without/with symmetry detection.

6. Related Work
STRIPS problems tackled different planning techniques, notably
SAT-planning (Kautz & Selman, 1996), IP-planning (Kautz & Walser, 1999), CSPplanning (Rintanen & Jungholt, 1999), graph relaxation (Blum & Furst, 1995), heuristic
search planning (Bonet & Geffner, 2001).
Solving planning problems numerical preconditions effects allowed Level 2
Level 3 problems undecidable general (Helmert, 2002). However, structures
provided benchmark problems simpler general problem class,
problems fact solvable.
6.1 Temporal Planning Approaches
system Metric-FF (Hoffmann, 2002a) extends (Hoffmann & Nebel, 2001)
forward chaining heuristic state space planner Level 2 problems. Although, MIPS plan
generator shares several ideas Metric-FF, Hoffmanns system yet extended
deal temporal domains.
Planner TP4 (Haslum & Geffner, 2001) fact scheduling system based grounded
problem instances. cases formula trees numerical conditions assignments
reduce constants. Utilizing admissible heuristics, TP4 minimizes plan objective
optimal parallel plan length. planner distinctive advantages: handles
numerical preconditions, instantiates numerical conditions fly cope
complex objective functions. Besides input restriction, competition, TP4
somewhat limited focus producing optimal solutions.
SAPA system (Do & Kambhampati, 2001) domain-independent time resource planner cope metrics concurrent actions. SAPAs general expressivity judged close MIPS. adapts forward chaining algorithm
(Bacchus & Ady, 2001). planning approaches instantiate actions fly
228

fiTaming Numbers Durations MIPS

therefore, principle, adapted handle flexible mixed propositional numerical planning problems. search algorithm SAPA extends partial concurrent plans
instead parallelizing sequential plans. uses relaxed temporal planning graph
yet unplanned events different heuristic evaluation functions. additional feature,
SAPA provides option specifying deadlines.
planner LPG (Gerevini & Serina, 2002) based local search planning graphs.
uses variant planner grounding initial plans generated random walk. subsequent search space LPG consists so-called action graphs (Gerevini
& Serina, 1999). temporal module performs action graph modifications transforming
action graph another one. fast plan generation algorithm LPG seems
best explanation speed advantage LPG respect MIPS,
higher number problems LPG solved domains. Optimization LPG governed
Lagrange multipliers. temporal domains, actions ordered using precedence graph
maintained search, uses refined dependency relation ours.
may partly explain plan quality fact consistently better MIPS.
IxTeT (Laborie & Ghallab, 1995) general constraint-based planning system
input format. planner searches space partial plans allows general
resource temporal constraints posed. internal representation consists
chronicles, time linearly ordered discrete set instants, multi-valued state
variables either rigid flexible (contingent, controllable, resources), predicates
temporally qualified expressions (events, assertions, resources), temporal atemporal
constraints. clear compare expressivity chronicles PDDL2.1
constructs. makes difficult link different temporal models determine
technique critical path scheduling applicable IxTeT not. opinion
unlikely, since IxTeT partial-order. Note IxTeT allows conjunction
predicates, subtasks, constraints conditional expressions, available
PDDL2.1. analysis partial plans drives planning process divided
three different modules: feasibility, satisfiability resource conflict resolution.
competition domains IxTeT able compete local search heuristic search
planners.
HSTS (Muscettola, 1994) constraint-based planning system based temporal activity networks, written LISP CRL. NASA used many projects
Deep-Space One. already represent reason metric resources, parallel
activities, general constraints. IxTeT input format significantly different
PDDL2.1. HSTS yet adapted represent reason conditional
branches. However experiences HSTS planner showed partial-order planning
attractive metric/temporal problems, need better search control.
Although PDDL2.1 guidelines fact allow infinite branching, 2002 competition consisted finite branching problems. indicated earlier, paper
concentrates finite branching problems. finite branching, execution time
action fixed, infinite branching, continous range actions available.
problems confronted (real-time) model checking long time.
subclasses infinite branching problems timed automata exhibit finite partitioning symbolic representation states (Pettersson, 1999). technique
shortest-path reduction unique reduced normal form obtained.
229

fiEdelkamp

implemented temporal network structure, since main data structure
exploring timed automata done model checker Uppaal (Pettersson, 1999).
work, constraints must form xi xj c xi c. example,
set constraints x4 x0 1, x3 x1 2, x0 x1 1, x5 x2 8, x1 x2 2,
x4 x3 3, x0 x3 4, x1 x4 7, x2 x5 10, x1 x5 5 shortest-path
reduction x4 x0 1, x3 x1 2, x5 x2 8, x0 x3 4, x1 x4 7, x2 x5 10,
x1 x5 5. constraint set over-constrained, algorithm determine
unsolvability, otherwise feasible solution returned.
Critical path analysis timed precedence networks one simpler cases
scheduling. achieved simplification solving sequential path problem first.
Note many scheduling techniques apply presented critical path analysis
subcomponent (Syslo, Deo, & Kowalik, 1983).
6.2 Symmetry Detection Planning Model Checkers
previous results symmetry reduction planning, e.g. (Guere & Alami, 2001),
neglect combinatorial explosion possible symmetries least assume
information existing symmetries domain supplied user.
contrast, work shares similarities approach Fox & Long (1999,2002)
inferring object symmetry information fully automatically. Fox Longs work based
similarities established TIM inference module (Fox & Long, 1998). search
additional information current symmetry level form object transposition
matrix stored updated together state. approach different sense
efficiently computes object symmetries state scratch consumes
extra space per node expansion.
Model checking research long tradition symmetry reduction (Clarke et al., 1999).
recent work, Rintanen (2003) connects symmetry detection planning model checking
approaches transition systems SAT solving. Experiments provided SAT
encodings Gripper domain; prototypical example symmetry detection. (LluchLafuente, 2003), model checker HSF-Spin extended effectively combine heuristic
search symmetry detection. reflects fact (HSF-)Spins exploration
modelled using (labelled) transition systems. Positive empirical results given
non-trivial examples Petersons mutual exclusion algorithm Database Manager
protocol.
briefly review fundamental difference object symmetries (as considered
here) state space symmetries (as considered model checking).
latter approach constructs quotient state space problem (P/) based congruence relation, equivalence relation called congruence
s1 , s2 , s1 s1 s2 operator O(s1 ) = s01 s02
s01 s02 operator O0 O0 (s2 ) = s02 . [O][s] = [s0 ]
operator mapping s0 [s] s0 [s0 ].
bijection : said symmetry (I) = I, (G) G G G
s, s0 transition s0 exist transition (s)
(s0 ). set symmetries generates subgroup g(A) called symmetry group.
subgroup g(A) induces equivalence relation states, defined s0
230

fiTaming Numbers Durations MIPS

(s) = s0 g(A). equivalence relation called symmetry relation
P induced A. equivalence class called orbit s, denoted [s]A .
symmetry relation P congruence P. Moreover, reachable [s]A
reachable [I]A . reduces search goal G G finding state [G].
explore state space respect state (space) symmetry, function Canonicalize needed. time new successor node generated, determines representative
element equivalence class. Fixing canonical element trivial, many
systems approximate normal form. Automatically finding symmetries setting
difficult cast computationally hard graph isomorphism problem.
Therefore approaches expect information kind symmetry present
state space graph. One example rotational symmetry, defined right shift
variables state vector.
6.3 Model Checking Planners
2000 competition, two symbolic planners took part: PropPlan (Fourman,
2000), BDDPlan (Holldobler & Stor, 2000). Although receive awards
performance, show interesting properties. PropPlan performs symbolic forward
breadth first search explore propositional planning problems propositions generalized action preconditions generalized action effects. performed well full
ADL Miconic-10 elevator domain (Koehler, 2000). ProbPlan written Poly/ML
implementation SML. BDD-Plan based solving entailment problem fluent calculus BDDs. time authors acknowledged concise domain
encoding symbolic heuristic search used MIPS improvements.
Model-Based Planner MBP paradigm planning symbolic model checking (Giunchiglia & Traverso, 1999) implemented non-deterministic planning
domains (Cimatti et al., 1998), classified weak, strong, strong-cyclic
planning, plans represented state-action tables. partially observable
planning, system faced exploring space belief states; power set
original planning space. Therefore, contrast successor set generation based action application, observations introduce nodes search tree (Bertoli, Cimatti,
Roveri, & Traverso, 2001b). Since approach hybrid symbolic representation
belief states explicit search within And-Or search tree, simple heuristics
applied guide search. need heuristics trade information gain
exploration effort apparent conformant planning (Bertoli et al., 2001a). Recent
work (Bertoli & Cimatti, 2002) proposes improved heuristics belief space planning.
UMOP system parses non-deterministic agent domain language explicitly
defines controllable system uncontrollable environment (Jensen & Veloso, 2000).
planner applies BDD refinement techniques automated transition function
partitioning. New results UMOP system extend weak, strong strong cyclic
planning adversarial planning, environment actively influences outcome
actions. fact, proposed algorithm combines aspects symbolic search
game playing. UMOP yet participated planning competition.
recent developments symbolic exploration expected influence automated
planning near future. SetA*, (Jensen et al., 2002) provide improved imple231

fiEdelkamp

mentation symbolic heuristic search algorithm BDDA* (Edelkamp & Reffel, 1998)
Weighted BDDA* (Edelkamp, 2001a). One improvement SetA* maintains finer
grained sets states search horizon. kept matrix according matching g- h- values. contrasts plain bucket representation priority
queue based f -values. heuristic function implicitly encoded value differences
grounded actions. Since sets states evaluated heuristics state
rather operator dependent remains shown general approach is.
above, planning benchmarks considered seemingly simple single-state heuristic search exploration (Hoffmann, 2002b; Helmert, 2001). (Hansen, Zhou, & Feng, 2002)
re-implemented BDDA* suggest symbolic search heuristics exploration
algorithms probably better implemented algebraic decision diagrams (ADDs). Although authors achieved improvement (Edelkamp & Reffel, 1998) solving
(n2 1)-Puzzle, established generalization guide symbolic version LAO* exploration algorithm (Hansen & Zilberstein, 2001) probabilistic (MDP) planning results
remarkable improvement state-of-the-art (Feng & Hansen, 2002).

7. Conclusions
competition planning system MIPS, contributed flexible system
heuristic forward chaining, explicit symbolic search planner finds plans finitebranching numerical problems. planner parses, pre-compiles, solves, schedules
problem instances, including complex ones duration, resource variables different
objective functions. main contributions planner
object-oriented workbench architecture choose combine different heuristics different search algorithms storage structures. design includes
static analyzer applies efficient fact-space exploration distinguish constant
fluent quantities, clusters facts groups, infers static object
symmetries. static analyzer produces intermediate format grounded
simplified planning domain instances.
Optimal temporal planning enumeration algorithms, based precedence relation
PERT scheduling sequentially generated plans together concise analysis
correctness optimality, well integration PERT scheduling MIPS
computing refined heuristic estimate. guides search phase, favoring
states smaller parallel plan length. MIPS instantiates numerical pre- postconditions on-the-fly produces optimized parallel plans.
detection dynamic object symmetries, integration different pruning
methods hash transposition cuts, well different strategies optimizing objective functions implementation tricks made system
efficient.
paper analyzes theoretical properties contributions, sometimes slightly
abstracting actual implementation.
Essentially planning numerical quantities durative actions planning
resources time. given framework mixed propositional numerical planning
232

fiTaming Numbers Durations MIPS

problems presented intermediate format seen normal form temporal
metric planning. paper presents novel temporal planning scheme generates
sequential (totally ordered) plans efficiently schedules respect set
actions imposed causal structure, without falling known NP-hardness traps
optimized partial-ordering sequentially generated plans. smaller problems complete enumeration approach guarantees optimal solutions. improve solution quality
approximate enumeration, (numerical) estimate number operators replaced
scheduling relaxed plan state. addressed completeness optimality
different forms exploration. novel study time space complexity dynamic
object symmetry detection given.
Model checking always influenced development MIPS, e.g static analysis minimize state description length, symbolic exploration plan extraction,
dependence relation PERT schedules according given partial order, bit-state
hashing IDA*, importance symmetry detection, forth. Moreover,
successes planning MIPS exported back model checking, development heuristic search state model checkers parsing Promela protocol specifications
indicate.

Acknowledgments
author would thank Derek Long Maria Fox helpful discussions concerning
paper Malte Helmert cooperation second planning competition.
list editors anonymous reviewers comments helped lot improve text.
work supported Deutsche Forschungsgemeinschaft (DFG) projects
Heuristic Search (Ed 74/3) Directed Model Checking (Ed 74/2).

References
Bacchus, F., & Ady, M. (2001). Planning resources concurrency: forward chaning
approach. Proceedings IJCAI-01, pp. 417424.
Bacchus, F., & Kabanza, F. (2000). Using temporal logics express search control knowledge planning. Artificial Intelligence, 116, 123191.
Backstrom, C. (1998). Computational aspects reordering plans. Journal Artificial
Intelligence Research, 9, 99137.
Bertoli, P., & Cimatti, A. (2002). Improving heuristics planning search belief space.
Proceedings AIPS-02, pp. 143152.
Bertoli, P., Cimatti, A., & Roveri, M. (2001a). Heuristic search symbolic model checking =
efficient conformant planning. Proceedings IJCAI-01, pp. 467472.
Bertoli, P., Cimatti, A., Roveri, M., & Traverso, P. (2001b). Planning nondeterministic
domains partial observability via symbolic model checking. Proceedings
IJCAI-01, pp. 473478.
Biere, A. (1997). cke - efficient -calculus model checking. Proceedings CAV-97, pp.
468471.
233

fiEdelkamp

Bloem, R., Ravi, K., & Somenzi, F. (2000). Symbolic guided search CTL model checking.
Proceedings DAC-00, pp. 2934.
Blum, A., & Furst, M. L. (1995). Fast planning planning graph analysis.
Proceedings IJCAI-95, pp. 16361642.
Bonet, B., & Geffner, H. (2001). Planning heuristic search. Artificial Intelligence, 129 (12), 533.
Bryant, R. E. (1992). Symbolic boolean manipulation ordered binary-decision diagrams. ACM Computing Surveys, 24 (3), 142170.
Cimatti, A., Giunchiglia, E., Giunchiglia, F., & Traverso, P. (1997). Planning via model
checking: decision procedure AR. Proceedings ECP-97, pp. 130142.
Cimatti, A., Roveri, M., & Traverso, P. (1998). Automatic OBDD-based generation
universal plans non-deterministic domains. Proceedings AAAI-98, pp. 875
881.
Clarke, E. M., Grumberg, O., & Peled, D. A. (1999). Model Checking. MIT Press.
Clarke, E. M., McMillan, K. L., Dill, D. L., & Hwang, L. J. (1992). Symbolic model checking:
1020 states beyond. Information Computation, 98 (2), 142170.
Cormen, T. H., Leiserson, C. E., & Rivest, R. L. (1990). Introduction Algorithms.
MIT Press.
Dial, R. B. (1969). Shortest-path forest topological ordering. Communication
ACM, 12 (11), 632633.
Do, M. B., & Kambhampati, S. (2001). Sapa: domain-independent heuristic metric temporal planner. Proceedings ECP-01, pp. 109120.
Edelkamp, S. (1999). Datenstrukturen und Lernverfahren der Zustandsraumsuche. Ph.D.
thesis, University Freiburg. DISKI, Infix.
Edelkamp, S. (2001a). Directed symbolic exploration application AI-planning.
Proceedings AAAI-01 Spring Symposium Model-based Validation Intelligence,
pp. 8492.
Edelkamp, S. (2001b). First solutions PDDL+ planning problems. Proceedings
PlanSIG-01, pp. 7588.
Edelkamp, S. (2001c). Planning pattern databases. Proceedings ECP-01, pp.
1324.
Edelkamp, S. (2002a). Mixed propositional numerical planning model checking integrated planning system. Proceeding AIPS-02 Workshop Temporal
Planning, pp. 4755.
Edelkamp, S. (2002b). Symbolic pattern databases heuristic search planning. Proceedings AIPS-02, pp. 274283.
Edelkamp, S. (2003). Promela planning. Proceedings SPIN-03, pp. 197212.
Edelkamp, S., & Helmert, M. (1999). Exhibiting knowledge planning problems minimize state encoding length. Proceeding ECP-99, pp. 135147.
234

fiTaming Numbers Durations MIPS

Edelkamp, S., & Helmert, M. (2000). implementation MIPS. Proceedings
AIPS-00 Workshop Model Theoretic Approaches Planning, pp. 1825.
Edelkamp, S., & Helmert, M. (2001). model checking integrated planning system MIPS.
AI-Magazine, 6771.
Edelkamp, S., Leue, S., & Lluch-Lafuente, A. (2003). Directed explicit-state model checking
validation communication protocols. International Journal Software Tools
Technology (STTT), appear.
Edelkamp, S., & Meyer, U. (2001). Theory practice time-space trade-offs memory
limited search. Proceedings KI-01, Lecture Notes Computer Science, pp.
169184. Springer.
Edelkamp, S., & Reffel, F. (1998). OBDDs heuristic search. Proceedings KI-98, pp.
8192.
Edelkamp, S., & Reffel, F. (1999a). Deterministic state space planning BDDs.
Proceedings ECP-99, Preprint, pp. 381382.
Edelkamp, S., & Reffel, F. (1999b). Deterministic state space planning BDDs. Tech.
rep. 121, University Freiburg.
Edelkamp, S., & Stiegeler, P. (2002). Implementing HEAPSORT n log n 0.9n
QUICKSORT n log n + 0.2n comparisons. ACM Journal Experimental Algorithms, 7 (5).
Feng, Z., & Hansen, E. (2002). Symbolic heuristic search factored markov decision
processes. Proceedings AAAI-02.
Fikes, R., & Nilsson, N. (1971). Strips: new approach application theorem
proving problem solving. Artificial Intelligence, 2, 189208.
Fourman, M. P. (2000). Propositional planning. Proceedings AIPS-00 Workshop
Model-Theoretic Approaches Planning, pp. 1017.
Fox, M., & Long, D. (1998). automatic inference state invariants TIM. Journal
Artificial Intelligence Research, 9, 367421.
Fox, M., & Long, D. (1999). detection exploration symmetry planning
problems. Proceedings IJCAI-99, pp. 956961.
Fox, M., & Long, D. (2002). Extending exploitation symmetries planning.
Proceedings AIPS-02.
Fox, M., & Long, D. (2003). PDDL2.1: extension PDDL expressing temporal
planning domains. Journal Artificial Intelligence Research, issue.
Gerevini, A., & Serina, I. (1999). Fast planning greedy action graphs. Proceedings
AAAI-00.
Gerevini, A., & Serina, I. (2002). LPG: planner based local search planning graphs
action costs. Proceedings AIPS-02.
Giunchiglia, F., & Traverso, P. (1999). Planning model checking. Proceedings
ECP-99, pp. 119.
235

fiEdelkamp

Groce, A., & Visser, W. (2002). Model checking Java programs using structural heuristics.
Proceedings ISSTA-02.
Guere, E., & Alami, R. (2001). One action enough plan. Proceedings IJCAI-01.
Hansen, E., & Zilberstein, S. (2001). LAO*: heuristic search algorithm finds solutions
loops. Artificial Intelligence, 129, 3562.
Hansen, E. A., Zhou, R., & Feng, Z. (2002). Symbolic heuristic search using decision
diagrams. Proceedings SARA-02.
Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). formal basis heuristic determination
minimum path cost. IEEE Transactions Systems Science Cybernetics,
4, 100107.
Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. Proceedings
ECP-01, pp. 121132.
Helmert, M. (2001). complexity planning transportation domains. Proceedings ECP-01, pp. 349360.
Helmert, M. (2002). Decidability undecidability results planning numerical
state variables. Proceedings AIPS-02, pp. 4453.
Hipke, C. A. (2000). Verteilte Visualisierung von Geometrischen Algorithmen. Ph.D. thesis,
University Freiburg.
Hoffmann, J. (2000). heuristic domain independent planning use enforced
hill climbing algorithm. Proceedings ISMIS-00, pp. 216227.
Hoffmann, J. (2002a). Extending numerical state variables. Proceedings ECAI02.
Hoffmann, J. (2002b). Local search topology planning benchmarks: theoretical analysis.
Proceedings AIPS-02, pp. 92100.
Hoffmann, J., & Nebel, B. (2001). Fast plan generation heuristic search. Journal
Artificial Intelligence Research, 14, 253302.
Holldobler, S., & Stor, H.-P. (2000). Solving entailment problem fluent calculus using binary decision diagrams. Proceedings AIPS-00 Workshop ModelTheoretic Approaches Planning, pp. 3239.
Jensen, R. M., Bryant, R. E., & Veloso, M. M. (2002). SetA*: efficient BDD-based
heuristic search algorithm. Proceedings AAAI-02.
Jensen, R., & Veloso, M. M. (2000). OBDD-based universal planning synchronized
agents non-deterministic domains. Journal Artificial Intelligence Research, 13,
189226.
Kabanza, F., Barbeau, M., & St-Denis, R. (1997). Planning control rules reactive agents.
Artificial Intelligence, 95 (1), 67113.
Kautz, H., & Selman, B. (1996). Pushing envelope: Planning, propositional logic,
stochastic search. Proceedings AAAI-96, pp. 11941201.
Kautz, H., & Walser, J. (1999). State-space planning integer optimization. Proceedings
AAAI-99.
236

fiTaming Numbers Durations MIPS

Knoblock, C. (1994). Generating parallel execution plans partial order planner.
Proceedings AIPS-94, pp. 98103.
Koehler, J. (2000). Elevator control planning problem. Proceedings AIPS-00, pp.
331338.
Koehler, J., & Hoffmann, J. (2000). reasonable forced goal orderings use
agenda-driven planning algorithm. Journal Artificial Intelligence Research,
12, 338386.
Koehler, J., Nebel, B., & Dimopoulos, Y. (1997). Extending planning graphs ADL
subset. Proceedings ECP-97, pp. 273285.
Korf, R. E. (1985). Depth-first iterative-deepening: optimal admissible tree search.
Artificial Intelligence, 27 (1), 97109.
Korf, R. E., & Zhang, W. (2000). Divide-and-conquer frontier search applied optimal
sequence alignment. Proceedings AAAI-00, pp. 910916.
Laborie, P., & Ghallab, M. (1995). Planning sharable resources constraints. Proceedings IJCAI-95, pp. 16431649.
Lago, U. D., Pistore, M., & Traverso, P. (2002). Planning language extended
goals. Proceedings AAAI-02.
Lind-Nielsen, J. (1999). Buddy: Binary decision diagram package, release 1.7. Technical
Univeristy Denmark. Available jln@itu.dk.
Lluch-Lafuente, A. (2003). Symmetry reduction heuristic search error detection
model checking. Proceedings Workshop Model Checking Artificial
Intelligence (MoChart).
Long, D., & Fox, M. (1998). Efficient implementation plan graph STAN. Journal
Artificial Intelligence Research, 10, 87115.
Long, D., & Fox, M. (2001). Encoding temporal planning domains validating temporal plans. Workshop UK Planning Scheduling Special Interest Group
(PlanSIG).
McDermott, D. (2000). 1998 AI Planning Competition. AI Magazine, 21 (2).
McMillan, K. L. (1993). Symbolic Model Checking. Kluwer Academic Press.
Muscettola, N. (1994). HSTS: integrating planning scheduling. Zweben, M., & Fox,
M. S. (Eds.), Intelligent Scheduling, pp. 168212. Morgan Kaufmann.
Pearl, J. (1985). Heuristics. Addison-Wesley.
Pednault, E. (1986). Formulating multiagend, dynamic-world problems classical
framework. Reasoning Action Plans, pp. 4782. Morgan Kaufmann.
Pednault, E. (1989). ADL: Exploring middleground Strips situation calculus. Proceedings KR-89, pp. 324332. Morgan Kaufman.
Pettersson, P. (1999). Modelling Verification Real-Time Systems Using Timed Automata: Theory Practice. Ph.D. thesis, Department Computer Systems, Uppsala University.
237

fiEdelkamp

Pistore, M., & Traverso, P. (2001). Planning model checking extended goals nondeterministic domains. Proceedings IJCAI-01.
Pohl, I. (1977). Practical theoretical considerations heuristic search algorithms.
Machine Intelligence, 8, 5572.
Refanidis, I., & Vlahavas, I. (2000). Heuristic planning ressources. Proceedings
ECAI-00, pp. 521525.
Reffel, F., & Edelkamp, S. (1999). Error detection directed symbolic model checking.
Proceedings FM-99, pp. 195211.
Regnier, P., & Fade, B. (1991). Determination du parallelisme maximal et optimisation
temporelle dans les plans dactions lineaires. Revue dIntelligence Artificielle, 5 (2),
6788.
Reinefeld, A., & Marsland, T. (1994). Enhanced iterative-deepening search. IEEE Transactions Pattern Analysis Machine Intelligence, 16 (7), 701710.
Rintanen, J. (2003). Symmetry reduction SAT representations transition systems.
Proceedings ICAPS-03.
Rintanen, J., & Jungholt, H. (1999). Numeric state variables constraint-based planning.
Proceedings ECP-99, pp. 109121.
Ruys, T. C. (2003). Optimal scheduling using branch bound SPIN 4.0. Proceedings SPIN-03, pp. 117.
Syslo, M. M., Deo, N., & Kowalik, J. S. (1983). Discrete Optimization Algorithms
Pascal Programs. Prentice-Hall.
Veloso, M. M., Perez, M. A., & Carbonell, J. G. (1990). Nonlinear planning parallel
resource allocation. Innovative Approaches Planning, Scheduling Control,
pp. 207212.
Weismuller, M. (1998). Planen mit einem Modellprufer im -Kalkul . Masters thesis,
Universitat Ulm.
Yang, C. H., & Dill, D. L. (1998). Validation guided search state space.
Proceedings DAC-98, pp. 599604.
Yoshizumi, T., Miura, T., & Ishida, T. (2000). A* partial expansion large branching
factor problems. Proceedings AAAI-00, pp. 923929.
Zhou, R., & Hansen, E. (2003). Sparse-memory graph search. Proceedings IJCAI-03.

238


