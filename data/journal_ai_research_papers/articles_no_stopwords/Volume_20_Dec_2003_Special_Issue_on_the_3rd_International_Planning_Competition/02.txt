Journal Artificial Intelligence Research 20 (2003) 125132

Submitted 09/03; published 12/03

Commentary
Power Modelinga Response pddl2.1
Fahiem Bacchus

fbacchus@cs.toronto.edu

Department. Computer Science
6 Kings College Road
University Toronto
Toronto, Ontario
Canada, M5S 3H5.

Abstract
commentary argue although pddl2.1 useful standard
planning competition, design properly consider issue domain modeling.
Hence, would advocate use specifying planning domains outside context
planning competition. Rather, field needs explore different approaches
grapple directly problem effectively modeling utilizing
diverse pieces knowledge typically planning domains.

1. Introduction
Fox Long terrific job organizing 2002 Planning Competition. non-trivial
component work specifying extension pddl much interesting
range problems could addressed competition. Although extension represents
useful standard competition, design ignores power reality
domain modeling. argue new features pddl2.1 unnecessary:
similar effects easily captured robust modeling planning
domain.
Tlplan planning system competed 2002 planning competition. Despite
fact Tlplans specification language direct support features
pddl2.1, still able encode competition domains. Tlplan utilizes
language designed suitable robustly modeling planning domains.1
found many new features pddl2.1 used competition fact easy
capture simply robust modeling planning domain.
pddl2.1 takes approach adding new features language, rather
requiring domain robustly modeled, perhaps surprising given
dichotomy still persists AI planning field. dichotomy work
domain-independent planning control-intensive planning. work controlintensive planning tends ignore applicability power state-of-the-art search
algorithms planning, work domain-independent planning tends ignore power
gained, requirements imposed, domain modeling. planning researchers
freely acknowledge importance components, however, one rarely finds work
1. Tlplan includes constructs expressing domain specific control information, referring
component language.

c
2003
AI Access Foundation. rights reserved.

fiBacchus

(:durative-action load-truck
:parameters (?t - truck)
(?l - location)
(?o - cargo)
(?c - crane)
:duration (= ?duration 5)
:precondition (and (at ?t ?l)
(at ?o ?l)
(empty ?c))
:effect
(and (loading ?t)
(at end (not loading ?t))
...
)
(:action move-truck
:parameters (?t - truck)
...
:precondition (and (not (loading ?t))
...)
)

Figure 1: Converting (over all) conditions
interface two issues, many researchers work
issues.2
rest commentary elaborate argument presenting examples
features approaches appearing pddl2.1 demonstrate insensitivity domain
modeling.

2. Coordinating Concurrent Actions
Section 5 pddl2.1 document various constructs presented support durative
actions. actions whose effects either immediate (like ordinary non-durative
actions) occur end fixed duration. duration either
constant specified functional term. obvious extension, used, e.g., Bacchus
& Ady (2001), action could range effects different future
timepoint, included pddl2.1.3 Without extension (at start) (at
end) specifiers reasonable ways specifying delayed effects.
non-instantaneous actions concurrency control becomes issue. achieve
kind control pddl2.1 provides :condition constructs (at start), (at end),
(over all). Tlplan provide (at end) (over all) constructs ((at
start) simply ordinary precondition). Yet still able model
planning domains without them. would argue general constructs
necessary.
2. guilty colleagues.
3. Instead one must ascend much complex specification continuous effects (presented
Section 5.3 pddl2.1 document) achieve degree flexibility.

126

fiA Response pddl2.1

2.1 (over all):
Consider load-truck action given Figure 6 pddl2.1 article. contains
condition (over (at ?t ?l)): i.e., truck must stay location
load. must moved? allowed move vehicle
loaded. Similarly, drive car refueled,
turn oven used bake cake, attempt tie
shoelaces running, etc. knowledge abounds common sense conditions.
natural language use progressive tenses refer ongoing activities. Similarly,
natural way model (over all) condition simply action assert
activity ongoing, use negation activity precondition actions
could interfere. resulting transformation load-truck action given
Figure 1.
Figure 1 load-truck action advertises initiated on-going loading
truck adding loading predicate state. end action predicate
deleted. Actions move-truck could interfere loading blocked adding
(not loading) preconditions. Using technique able replace
(over all) conditions used competition domains. Interestingly replacements
made domain sensible readable.
Consider brief advantages modeling (over all) effects adding progressive
predicates state.
1. method realized without extending standard strip/adl semantics.
2. actions preconditions still encapsulates interactions actions. presence (over all) conditions, one would examine every
action see (over all) conditions interfered one
actions effects. Put another way, actions activation condition continues
Markovian, i.e., dependent current state. current state continues
carry information needed determine action applied;
(over all) conditions, one needs examine currently active actionsthe
state longer encapsulates necessary information.
3. Finally, seems resulting domain models natural easier
understand.
2.1.1 Modularity
One concern approach avoiding (over all) conditions, appears
make adding new actions domain non-modular.4 Non-modularity potentially arises
adding new actions could interfered previous actions,
adding new actions could interfere previous actions.
first case arises add new actions refuel, repair, change-tire, etc.,
interfered existing action move-truck. solution
adding non-interference preconditions would seem require modifying description
4. Thanks David Smith Martha Pollock pointing needed address issue
modularity.

127

fiBacchus

move-truck add (not (refueling)), (not (repairing)), (not (changing-tire)),
etc., preconditionsa new precondition every new action added.
second case arises add new action tow-truck changes
location truck. would ensure add preconditions
progressives required block interfering previously defined actions.
second case perhaps problematic, since require modifying
old actions. However, first case issue since one might want modify
definition previous actions already debugged.
using (over all) conditions need make changes old actions
worry effects new actions old. However, would argue
modularity exists syntactic levelit syntactically easy modify domain
description accommodate new actions. corresponding modularity
semantic level: interferences new action old still exists.
cases cannot simply ignore interactions, leaving planner (over
all) conditions resolve. found developing domains, many cases
new action added domain bug domain specification appears.
example, plans one would expect find longer found planner. Often bug
lies new action, often bug found specification old actions.
domain longer operates expected, one still left task unraveling
interactions specification. general, specifying rich domain requires understanding
possible interactions domain, task (over all) conditions
help.
could argued job planner unravel interactions
domain. argument, believe, trivializes job specifying planning domain.
planners job compute interactions actions sequence (or
complex composition) actions. Getting domain correctly specified difficult task,
requires least understanding actions interact statically, even one leave
dynamic interactions planner.
Fortunately, systems interactions actions relatively local:
typically relatively structured way actions interfere other.
makes specifying planning domains feasible.
One take advantage structure build robust domain models provide
advantages semantic well syntactic modularity. critical component building
good domain models ability use definitions (axioms), feature provided
pddl2.1. Tlplan, e.g., one define new predicate symbol using first-order
formula previous defined symbols. defining right high level constructs one
typically provide explicit representation structure interactions
domain. advantage one obtains declarative representation
structure, thus achieving natural easier understand domain specification.
example above, one could define new predicate (must-be-stationary ?t)
disjunction
(or (loading ?t) (changing-tire ?t) (repairing ?t) (refueling ?t)).
(move-truck ?t ?l1 ?l2) action need single precondition (not
(must-be-stationary ?t)), new action requires truck station128

fiA Response pddl2.1

(:durative-action load-truck
:parameters (?t - truck)
(?l - location)
(?o - cargo)
(?c - crane)
:duration (= ?duration 5)
:precondition (and (at ?t ?l)
(at ?o ?l)
(empty ?c))
:effect
(and (loading ?t)
(at end (not loading ?t))
(holding ?c ?o)
(not (at ?o ?l))
(at end (when (holding ?c ?o) (in ?o ?t)))
(at end (when (holding ?c ?o) (not (holding ?c ?o))))
(at end (when (not (holding ?c ?o)) (load-failed))))
)

Figure 2: Converting (at end) conditions
ary accommodated simply adding new disjunct definition must-bestationary. approach advantage explicitly introducing new concept
must-be-stationary, helps understanding structuring domain. contrast, (over all) conditions one concept changing at.
simple example difference appears trivial, key idea
new concept must-be-stationary domain, use build
complicated concepts.
Using explicit progressive preconditions allows coordination far complex shared uses resource. example, specify refueling driving
require exclusive use truck, changing tire done concurrently
repairing truck concurrently loading. conditions accommodated action explicitly mention excluded activities precondition,
axioms grouping structuring activities complex conditions
using conditions action preconditions. either case result
explicit description domain easier understand, debug modify.
2.2 (at end):
(at end) strange condition. fact, appear competition
domains. would argue needed; easily captured
constructs, rather unnatural would never appear reasonable
domain model. (at end) intended support flexibility whereby action
release condition actions might delete condition, long
condition subsequently restored time. (over all) condition effect
breaking Markovian nature normal action specifications. natural way
model situation, would claim, simply use conditional (at end) effects:
required condition holds end, desired effect created, otherwise bad
effect occur. modified load-truck action given Figure 2.

129

fiBacchus

(:durative-action burnMatch
:parameters (?m - match ?l - location)
:duration (= ?duration 5)
:precondition (and (have ?m)
(at ?l))
:effect
(and (when (no-other-light-source ?l)
(and (not (dark ?l)) (light ?l)))
(not (have ?m))
(burning ?m)
(at end (when (burning ?m) (not (burning ?m))))
(at end (when (and (no-other-light-source ?l)
(burning ?m))
(and (not (light ?l))
(dark ?l))))))
)
(:action blowOutMatch
:parameters (?m - match ?l - location)
:precondition (and (at ?l)
(burning ?m))
:effect
(and (not (burning ?m))
(when (no-other-light-source ?l)
(and (not (light ?l))
(dark ?l)))))
)

Figure 3: Alternate model burn-match
modification, instead (at end (holding ?c ?o)) condition, simply
changed effects action. (holding ?c ?o) holds end action,
action normal effects. Otherwise, adds state marker indicating
load failed. add (not (load-failed)) goal, planner would search
ways falsifying antecedent effect (assuming (load-failed) cannot
undone), i.e., planner would search ways ensuring (holding ?c ?o) true
end action. Note exactly planner would ensure
ordinary precondition holds. is, reduce construct
standard features.

3. Unspecified Durations
Another feature pddl2.1 ability specify ranges durations actions.
intent actual duration action might affected actions.
burnMatch heat-water actions (Figures 10 12 pddl2.1 document)
examples range utilized duration.
find flexible durations strange, make action dependent future
actions. Furthermore, convinced necessary. Rather think
natural way model situations would introduce two actions, one start
action (light match, start heating liquid), one end action (blow
match, take liquid heat). Figures 3 4 present alternate models.
burnMatch starts match burning (toggling lighting status location
light location). posts default completion

130

fiA Response pddl2.1

(:durative-action heat-water
:parameters (?p - pan)
:duration (= ?duration (/ (- 100 (temperature ?p)) (heat-rate)))
:precondition (and (full ?p)
(onHeatSource ?p)
(byPan))
:effect (and (heating ?p)
(heating-start ?p (current-time))
(at end (when (and (byPan) (heating ?p)) (not (heating ?p))))
(at end (when (heating ?p)) (assign (temperature ?p) 100))
(at end (when (and (not (byPan)) (heating ?p)) (burn-pot ?p)))))
(:action take-off-heat
:parameters (?p - pan)
(?startt - time)
:precondition (and (heating ?p)
(heating-start ?p ?startt)
(byPan))
:effect (and (not (heating ?p))
(when (not (burn-pot ?p))
(increase (temperature ?p)
(* (- (current-time) ?startt) (heat-rate))))))

Figure 4: Alternate model heat-water
match burning maximum duration. match still burning end
maximum duration extinguished lighting status toggled (if match
source light). hand, match extinguished earlier
blowOutMatch action.
heat-water action starts water heating, burn-match default
maximum duration. pan still heated end time raises
temperature pan 100 degrees, and, agent pan, takes pan
heat, otherwise pan continues heated causing become burnt (this
keeping previous discussion wanting (at end) preconditions). Note
pans temperature never rises 100 (we assuming water keeps boiling).
marks time heating started ((current-time) time action
executed). take-off-heat action take pan heat time.
uses start time heating calculate temperature water (if pot
burnt, temperature remains 100, set heat-water).
suggesting alternate action specifications right models
(e.g., heat-water cannot account putting pot back heat taking
off). suggesting case variable durations made.
really necessary even natural domain modeling?

4. Conclusions
could list components pddl2.1 seem unnecessary,
believe point made. pddl2.1 essential planning competition,
certainly strong supporter usefulness competition furthering
planning research. However, would suggest outside context competition,
131

fiBacchus

issue features included planning domain specification language
needs grounded application languages. Planning domains, even
simplified ones designed research, modeled many different ways, believe
better produce robust models simpler languages develop
languages features really needed.
think many ideas contained pddl2.1 useful, e.g., way
continuous change treated. Nevertheless, would encourage anyone try
construct planning algorithms dealing features. Rather would encourage
development planning algorithms inspired issues arise interesting
domains. is, think incorporation new features planning languages
needs motivated compelling examples.

References
Bacchus, F., & Ady, M. (2001). Planning resources concurrency, forward chaining
approach. Proceedings International Joint Conference Artificial Intelligence (IJCAI), pp. 417424.

132


