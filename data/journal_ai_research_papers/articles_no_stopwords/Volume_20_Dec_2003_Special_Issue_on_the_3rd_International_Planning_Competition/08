journal artificial intelligence

submitted published

taming numbers durations model checking
integrated system
stefan edelkamp

stefan edelkamp cs uni dortmund de

baroper strae
fachbereich informatik gb iv
universitat dortmund
dortmund
germany

abstract
model checking integrated system mips temporal least commitment heuristic search planner flexible object oriented workbench architecture
design clearly separates explicit symbolic directed exploration
set line line computed estimates associated data structures
mips shown distinguished performance last two international competitions last event description language extended pure propositional
include numerical state variables action durations plan quality objective
functions plans longer sequences actions time stamped schedules
participant fully automated track competition mips proven
general system track every benchmark domain efficiently computed plans
remarkable quality article introduces analyzes important algorithmic
novelties necessary tackle layers expressiveness benchmark
achieve high level performance
extensions include critical path analysis sequentially generated plans generate
corresponding optimal parallel plans linear time compute parallel
plan bypasses known np hardness partial ordering scheduling plans
respect set actions imposed precedence relations efficiency
allows us improve exploration guidance encountered
state corresponding approximate sequential plan scheduled
one major strength mips static analysis phase grounds simplifies
parameterized predicates functions operators infers knowledge minimize
state description length detects domain object symmetries latter aspect
analyzed detail
mips developed serve complete optimal state space planner
admissible estimates exploration engines branching cuts competition
version however certain performance compromises made including floating point
arithmetic weighted heuristic search exploration according inadmissible estimate
parameterized optimization

introduction
practical action model checking appear closely related mips
project targets integration model checking techniques domain independent
action planner hsf spin experimental model checker edelkamp leue lluchlafuente looking towards integration technology
c

ai access foundation rights reserved

fiedelkamp

existing model checker additional synergies exploited automated compilation
protocol software model checking planner inputs edelkamp
model checking clarke grumberg peled automated process verify
formal model system satisfies specified temporal property illustrative
example take elevator control system together correctness property requires
elevator eventually stop every call passenger guarantees door
closed elevator moving although success checking correctness limited
model checkers found many errors current hardware software designs
often consist many concurrent sub systems combination synchronous
often seen hardware design verification asynchronous frequently given communication security protocols multi threaded programming languages java
model checking requires exploration large state spaces containing reachable system states known state explosion occurs even
sets generated states much smaller set reachable states
error shows safety property violation deadlock failed assertion
corresponds one set target nodes state space graph roughly speaking
something bad occured liveness property violation refers seeded cycle
graph roughly speaking something good never occur case elevator
example eventually reaching target state request button pressed liveness
property certifying closed doors refers safety property
two main validation processes model checking explicit symbolic search
explicit state model checking state refers fixed memory location state
space graph implicitly generated successive expansions state
symbolic model checking mcmillan clarke mcmillan dill hwang
fixed length binary encodings system states used state represented characteristic function representation function evaluates true
boolean state variables assigned bit values respect binary
encoding system state subsequently characteristic function conjunction
literals plain variable encoding negated variable sets
states expressed disjunction individual characteristic functions
unique symbolic representation sets states boolean formulae binary
decision diagrams bdds bryant often much smaller explicit one bdds
ordered read branching programs nodes corresponding variables edges
corresponding variable outcomes path corresponding assignment
variables resulting evaluation leaves one reason succinctness
bdds directed acyclic graphs may express exponentially many paths transition
relation defined two state variable sets evaluates true operator
exists transforms state valid successor sense bdds exploit regularities
state set often appear well suited regular hardware systems contrast many
software systems inherit highly asynchronous irregular structure use
bdds fixed variable ordering generally flexible enough
symbolic exploration set states combined transition relation
compute set possible successor states e image starting initial
state iteration image computations eventually explores entire reachable state space


fitaming numbers durations mips

improve efficiency image computations transition relations often provided
partitioned form
correspondence action model checking giunchiglia traverso
roughly characterized follows similar model checkers action planners implicitly generate large state spaces exploration approaches applying
operators current state states spaces model checking
often modelled kripke structures e state space graphs states labelled propositional predicates satisfaction specified property one side corresponds
complete exploration unsolvable side respect
goal action cast error corresponding trail interpreted
plan elevator example goal task reach state
doors open elevator moving action refers safety properties
since goal achievement traditional competition yet
extended temporal properties however temporally extended goals increasing
interest kabanza barbeau st denis pistore traverso lago
pistore traverso
contrast model checkers perform symbolic explicit exploration mips
features moreover combines symbolic explicit search form
symbolic pattern databases edelkamp b planner mips implements heuristic
search pearl ida korf exploration include
state goal approximation search process rank states expanded next
heuristic search brought considerable gains bonet geffner
refanidis vlahavas hoffmann nebel bertoli cimatti roveri
jensen bryant veloso feng hansen model checking yang dill
edelkamp et al groce visser bloem ravi somenzi ruys

including resource variables fuel level vehicle distance two
different locations well action duration relatively aspects competitive
fox long input format pddl restricted variables
finite domain includes rational floating point variables precondition
effects similar set atoms described propositional predicate set numerical
quantities described set parameters notation pddl
refer parameterized numerical quantities functions example fuel level might
parameterized vehicle present instance file description
competition domains provided different tracks according different layers language expressiveness pure propositional ii numerical
resources iii numerical resources constant action duration iv
numerical resources variable action duration cases v complex usually combining time numbers interesting ways mips competed
fully automated system performed remarkably well five tracks solved large
number fully automated planner produced solutions
track every benchmark domain
main algorithmic techniques taming rational numbers objective
functions action duration described article structured follows first
review development mips system assert main contributions


fiedelkamp

address object oriented heuristic search framework system subsequently
introduce terminology allows us give formal definition syntax
semantics grounded mixed numerical propositional instance
introduce core contributions critical path scheduling concurrent plans
efficient methods detecting symmetry cuts pert scheduling produces
optimal parallel plans linear time given sequence operators precedence relation
among discusses pruning anomalies effect different optimization
criteria analyze correctness efficiency symmetry detection detail
article closes related work concluding remarks

development mips
competition version mips refers initial work edelkamp reffel
heuristic symbolic exploration domains cke model checker biere
effective sample puzzle solving edelkamp reffel
hardware verification reffel edelkamp
implementing propositional planner first used bdd library called
staticbdd large node tables allocated prior use implementation process changed bdd representation mainly improve performance
small selected public domain c bdd package buddy lindnielsen flexible process semi automated edelkamp
reffel b variable encodings provided hand representations
operators established enumerating possible parameter instances
state space encoding action transition relation fixed exploration form
symbolic breadth first search state space could executed time
aware work bdd work cimatti et al
likely first link via symbolic model checking team used
model checker nu smv basis atom variable state encoding
scheme top
later developed parser static analyzer automate inference state
encodings generation transition relations extraction solution paths
order minimize length state encoding analyzer clustered atoms
groups edelkamp helmert confirmed attempts weismuller
started experimenting pddl specification cke state minimization fact
crucial simple encoding one variable atom appears competitive
respect graphplan blum furst sat plan planners kautz
selman subsequently mips first fully automated system
symbolic model checking technology could deal large domain descriptions
second international competition mips edelkamp helmert
could handle strips fikes nilsson subset pddl language mcdermott additional features adl pednault namely negative
preconditions universal conditional effects mips one five systems
awarded distinguished performance fully automated track competition
version edelkamp helmert already included explicit heuristic search
bit vector state representation relaxed heuristic rph hoff

fitaming numbers durations mips

mann nebel well symbolic heuristic search hsp heuristic bonet
geffner one one atom derivative rph competition used
breadth first bi directional symbolic search whenever single state heuristic search engine
got stuck exploration
competitions explicit edelkamp c symbolic pattern
databases edelkamp b proposed line estimators completely explored
abstractions roughly speaking pattern database abstractions slice state vector fluents pieces adjust operators accordingly completely explored
subspaces serve admissible estimates overall search competitive
relaxed heuristic several benchmark domains
third competition levels domain description language pddl designed level considers pure propositional level
includes numerical resources objective functions minimized level additionally
allows specification actions durations consequently mips extended
cope forms expressiveness
first mips pddl presented edelkamp
b preliminary treatment illustrates parsing process two simple benchmark domains moreover propositional heuristics manual branching cuts applied
accelerate sequential plan generation work extended edelkamp
presented two approximate exploration techniques bound fix numerical
domains first symmetry detection fact groups critical path scheduling
time wrapper produce optimal plans numerical extension rph

architecture mips
figure shows main components mips data flow input definition
domain instance resulting temporal plan output
shown shaded light gray mips divided four parts pre compilation heuristics
search post compilation scheduling henceforth process
coarsely grouped three stages pre compilation heuristic search
construction temporal plans domain description files fed
system analyzed grounded fixes state space solved
intermediate implicit saved file use planners model
checkers basics pre compilation covered section
next stage defines process object oriented workbench design
planner allows different heuristic estimates combined different search
strategies access data structures possible choices listed sections
temporal pert scheduling issue rearranging sequential
relaxed plans addressed detail section
system developed spirit heuristic search framework
hsf short edelkamp allows attachment newly implemented
puzzle domains already compiled system similar took
model checking within hsf spin kept extensible general design fact
characterized action protocol validation single agent challenges
contrast model checking devised hierarchy system


fiedelkamp

domain pddl

pddl

precompiler
static analyzer
ground

symmetry

cluster

intermediate representation
heuristics
explicit pdbs

symbolic pdbs

numerical
rph

search

relaxed plan

symbolic search

explicit search
rph

bdda bdd bfs

ida ehc
scheduling
rph

sequential plan

relaxed
temporal plan

scheduler
critical path

temporal plan

pert

figure architecture mips

states implementation numerical states derived class one propositional
states
similarily heuristic search abstract search class
main procedures provided search state expansion
procedure heuristic search evaluation function located one hierarchically organized heuristic estimator classes sense mips general
node expanding schemes adapted different additional data
structures horizon list open visited list closed constructed parameters appropriate search implementations heuristic
search associated data structures planner mips almost match
model checker
example
running example instance rather simple pddl
zeno travel illustrated figure initial configuration drawn left


fitaming numbers durations mips



scott

b

dan

c





c





b









ernie







scott
ernie

dan

figure instance zeno travel domain initial state left goal state
right

figure goal configuration right global local numeric variable
assignments shown
figures provide domain specifications instance asks
temporal plan fly passengers dan scott ernie located somewhere small
map including cities city city b city c city aircraft plane
respective target destinations boarding debarking take constant amount
time plane fixed fuel capacity fuel time consumed according
distances cities travel speed fuel restored refueling
aircraft total amount fuel maintained numerical quantity
precompiler
static analyzer takes domain instance input grounds propositional state information infers different forms planner independent static information
parsing simple lisp parser generates tree lisp entities reads input files
recognizes domain name cope variable typing temporarily assert constant typed predicates removed together constant
predicates pre compilation step thereby infer type hierarchy
associated mapping objects types
indexing number counted objects indices grounded predicates
functions actions devised since example eight objects predicates two parameters reserve
index positions similarly function distance consumes indices fuel
denotes source fragments omitted sake brevity given example
action definitions passenger debarking flying airplane



fiedelkamp

define domain zeno travel
requirements durative actions typing fluents
types aircraft person city
predicates x person aircraft c city
p person aircraft
functions fuel aircraft distance c city c city
slow speed aircraft fast speed aircraft
slow burn aircraft fast burn aircraft
capacity aircraft
refuel rate aircraft
total fuel used boarding time debarking time
durative action board
parameters p person aircraft c city
duration duration boarding time
condition start p c
c
effect start p c
end p

durative action zoom
parameters aircraft c c city
duration duration distance c c fast speed
condition start c
start fuel distance c c fast burn
effect start c
end c
end increase total fuel used
distance c c fast burn
end decrease fuel
distance c c fast burn
durative action refuel
parameters aircraft c city
duration duration capacity fuel refuel rate
condition start fuel capacity
c
effect end assign fuel capacity


figure zeno travel domain description pddl

slow speed fast speed slow burn fast burn capacity refuel rate
reserve eight index positions quantities total fuel used boarding time
debarking time single fact identifier needed last least model
duration additional quantity total time special variable one
overwritten least commitment scheduling plans
described section


fitaming numbers durations mips

define zeno travel
domain zeno travel
objects plane aircraft
ernie scott dan person
city city b city c city city
init total fuel used debarking time boarding time
distance city city b distance city b city
distance city b city c distance city c city b
distance city city c distance city c city
distance city c city distance city city c
fast speed plane slow speed plane
fuel plane
capacity plane
fast burn plane
slow burn plane
refuel rate plane
plane city scott city dan city c ernie city c
goal dan city ernie city scott city
metric minimize total time


figure zeno travel instance
flattening temporal identifiers interpret action integral entity
timed propositional numerical preconditions merged similarly
effects merged independent time happen invariant conditions
c action board added precondition set
discuss rationale step section
grounding propositions fact space exploration relaxed enumeration
determine superset reachable facts algorithmically fifo fact
queue compiled successively extracted facts front queue matched
operators time preconditions operator fulfilled resulting
atoms according positive effect add list determined enqueued
allows us separate constant facts fluents since latter reached
exploration
clustering atoms concise encoding propositional part separate fluents
groups state space expressed conjunction possibly trivial facts drawn fact group edelkamp helmert
precisely let pi oi oi number objects oi
fact p true establish single valued invariant
pi oi oi allow better encoding predicates
merged example three groups determine unique position
persons one five one group determines position plane one
four therefore dlog e dlog e bits suffice encode total
fluents


fiedelkamp

grounding actions fact space exploration determines grounded operators
preconditions met grounded symbolic effect lists instantiated
case determine instantiated operators simplifications
eliminate duplicates trivial operators ops reduced
grounding functions simultanous fact space exploration propositional part
heads numerical formulae effect lists grounded
example case three instantiated formulae fluent vary time fuel
plane initial value well total fuel used total time initialized zero numerical predicates fact constants
substituted formula bodies example effect board dan city
reduces increase total time zoom plane city city b
numerical effects increase total time increase total fuel used
decrease fuel plane refuelling however reduce
single rational number example effects refuel plane city
simplify increase total time fuel plane
assign fuel plane evaluate former assignment especially forward chaining planner variable total time instantiated fly
due fact value quantity fuel plane constant
changes time
symmetry detection regularities respect transposition domain objects partially determined static analyzer addressed
detail section
intermediate textual format static analyzer annotated grounded pddllike representation serves interface planners model checkers
additional resource plan visualization figures parts intermediate
representation inferred zeno travel example
heuristics
mips incorporates following heuristic estimates
relaxed heuristic rph approximation number steps
needed solve propositional delete effects removed hoffmann nebel heuristic constructive returns set
operators appear relaxed plan
numerical relaxed heuristic numerical rph extension rph
deal numbers combined propositional numerical approximation
scheme allowing multiple operator application
pattern database heuristic explicit pdb different space abstractions
found greedy manner yielding selection pattern databases fit main
memory contrast rph pattern database designed disjoint yielding
admissible estimate needed optimal edelkamp c


fitaming numbers durations mips

define grounded zeno travel zeno travel
fluents
dan city
dan city b
dan city c
dan city
ernie city ernie city b ernie city c ernie city
plane city plane city b plane city c plane city
scott city scott city b scott city c scott city
dan plane
ernie plane scott plane
variables fuel plane total fuel used total time
init
dan city c
ernie city c plane city scott city
fuel plane total fuel used total time
goal dan city
ernie city scott city
metric minimize total time
group dan
dan city
dan city b
dan city c
dan city
dan plane
group ernie
ernie city ernie city b ernie city c ernie city
ernie plane
group plane
plane city plane city b plane city c plane city
group scott
scott city scott city b scott city c scott city
scott plane

figure grounded representation zeno travel domain
symbolic pattern database heuristic symbolic pdb symbolic pdbs apply explicit symbolic heuristic search engines edelkamp b due succinct
bdd representation sets states symbolic pdbs often orders magnitudes
larger explicit ones
scheduling relaxed plan heuristic scheduling rph critical path analysis
scheduling guide plan finding phase rph computes length
greedily extracted sequential plan scheduling rph takes relaxed sequence
operators account searches suitable parallel arrangement
turn defines estimator function
exploration
portfolio includes three main explicit heuristic search
hart nilsson raphael variant dijkstras singlesource shortest path exploration scheme executed weighted state space graph
lower bound heuristics shown generate optimal plans pearl
weighting influence heuristic estimate may accelerate solution finding
affects optimality pohl


fiedelkamp

action board dan plane city
condition
dan city plane city
effect
dan plane dan city
increase total time

action zoom plane city city b
condition

plane city
fuel plane
effect
plane city b plane city
increase total time
increase total fuel used
decrease fuel plane

action refuel plane city
condition

plane city
fuel plane
effect

increase total time fuel plane
assign fuel plane



figure grounded representation zeno travel domain cont

iterative deepening ida memory limited variant suited large
exploration evaluation functions small integer range low time
complexity korf ida extended bit state hashing edelkamp
meyer improve duplicate detection respect ordinary transposition
tables reinefeld marsland
enforced hill climbing hc another compromise exploration exploitation enforced hc searches improved evaluation
breadth first manner commits established action selections final hoffmann
enforced hc complete undirected graphs
mips features following two symbolic search
non deterministic domains started implementing weak strong strong cyclic exploration cimatti roveri traverso



fitaming numbers durations mips

bidirectional symbolic breadth first search bdd bfs implementation performs bidirectional blind symbolic search choosing next search direction favor
faster execution previous iterations edelkamp helmert
symbolic bdda edelkamp reffel performs guided symbolic search takes possibly partitioned symbolic representation heuristic
additional input
composition competition version
figure shaded parts actually used competition version
mips dark gray used relaxed heuristic sequential plan generation
scheduling relaxed heuristic used temporal domains level
use numerically extended rph since added system
final weeks competition experimented symbolic pattern databases
mixed since pattern databases purely propositional implementation
provide retrieval operators optimal abstract plan include
competition version
extend relaxed heuristic numerical information helps
plans challenging numerical domains settlers influenced hoffmanns work competing planner metric hoffmann builds relaxed
graph computing fixed point state vector restricted monotonically
increasing propositional numerical variables version integrating numbers
relaxed heuristic general hoffmanns contribution restricted
variable constant comparisons lacks ability simplify linear constraints
therefore omit algorithmic details
decided employ enforced hill climbing explicit plan generation done
metric probably lpg instead applied weight merit
states fixed f g h conservative plan generation
engine chosen avoid unrecognized dead ends expected present
benchmark objective least completeness preserved
avoided known incomplete pruning rules action relevance cuts hoffmann
nebel goal ordering cuts koehler hoffmann
mips weighted accesses dial weak heap priority queue data
structure former used propositional latter applies
general scheduling estimates dial priority queue dial linear
run time behavior maximal value w u v h v h u edges u v
weighted state space graph labelled heuristic h bounded constant weakheaps edelkamp stiegeler simple efficient relaxations ordinary heaps
priority queues implemented dynamic tables double sizes
become filled moreover mips stores generated expanded states hash table
chaining compression state space variables
appear objective function neglected hash address calculations state
alternative storage structure collection persistent trees bacchus kabanza one
predicate best case queries update times structure logarithmic number
represented atoms



fiedelkamp

comparisons general may lead sub optimal pruning duplicates however
benchmark domains destroy optimality since variables addressed
objective function frequently monotonic synonyms found later search
refer worse solutions
price paid selecting especially large branching factors storing frontier nodes space consuming recent techniques
partial expansion horizon list yoshizumi miura ishida reduced storage
visited list korf zhang zhou hansen included
system cases number expanded nodes often large
computing relaxed estimate appeared computational bottleneck
retrospect domains chosen dead ends central hill
climbers appeared effective finding solutions
temporal domains introduced additional parameter scale influence
propositional estimates fp gp hp scheduled ones fs
gs hs precisely altered comparison function priority queue
comparison parallel length priorities invoked propositional difference
values larger higher value refers higher influence
scheduling rph indicates scheduling competition produced
data pure mips optimized mips comparisons mips
planners plain version used since produces solutions
edelkamp experimented enumeration fix numerical
variables finite domain time wrapper optimization objective
functions options excluded competition version
unpredictable impact planners performance
visualization
visualization important ease plan understanding quickly detect inefficiencies
plan generation module visualization plans mips extended
animation system vega hipke client server architecture runs annotated
server side visualized client side java frontend
main purpose server make accessible tcp ip able
receive commands multiple clients time extended vega two
ways cf figures
gannt chart visualization gannt charts representations schedules
horizontal bars drawn activity indicating estimated duration cost
user selects planner executed domain file
interpreted command line options alternatively established plans sent
directly visualizer void planner merely mirrors solution file
benchmark visualization second extension program suite visualize competition domains moment sequential plans shown temporal
plans refined simulation required one produced pddl plan
validator fortunately mips temporal plan rescheduling sequential
one


fitaming numbers durations mips

figure visualization plan gannt chart format
images represent domain objects collected image web search
engine generalize specific instances advised mips planner export
propositional numeric state infomation established plan c syntax
turn included header domain visualizer

pddl
section elaborate metric temporal mips give formal
description grounded instances introduce temporal model
used google cf www google de searched small gifs



fiedelkamp

figure visualization instance settlers

chosen next look operator dependency resulting action precedence relation
discuss optimality anomalies occur state
space pruning last least turn treatment arbitrary plan objective
functions
table displays basic terminology sets used currently
successful system mips grounds parameterized information present domain
description set infer suitable index set indicated bijective mapping
set finite domain embedding important deal unique identifiers
entities instead textual internal representation arrays containing
corresponding information accessed constant time


fitaming numbers durations mips

set
obj
ype
pred
fun c
act

f
v

descriptor
objects
object types
predicates
functions
actions
operators
fluents atoms
variables

example
dan city plane
aircraft person
c p
fuel total time
board p refuel
board plane scott
plane city b
fuel plane total time

table basic set definitions

consequently several systems mips refers grounded
representations
definition grounded instance grounded instance quadruple
p hs gi set states initial state g
set goal states mixed propositional numerical state
space given
f ir v
f power set f therefore state pair sp sn propositional
part sp f numerical part sn ir v
sake brevity assume operators normal form means
propositional parts preconditions effects satisfy standard strips notation fikes
nilsson numerical parts given form arithmetic trees taken
set trees arithmetic operations nodes numerical variables
evaluated constants leaves however fundamental difference
general representation preconditions effects current implementation mips
simplifies adl expressions preconditions takes generic precondition trees
numerical parts thereby including comparison symbols logical operators arithmetic
subtrees
definition syntax grounded operators operator normal form
propositional preconditions f propositional effects
f add list delete list numerical preconditions numerical effects
numerical precondition c triple c hc tc hc v
tc arithmetic tree numerical effect triple
hm tm hm v tm case call hm head
numerical effect
newer versions mips mixing numerical logical preconditions form p f
p f f v fact feasible boolean expressions put negational normal form
disjunction precondition produce different action instantiations



fiedelkamp

obviously represents associated comparison relation denotes assignment variable indicate respective increase decrease
operation
definition constraint satisfaction modifier update let index mapping
variables vector sn v numerical variables satisfies numerical
constraint c hc tc hc eval sn tc true eval sn tc ir
obtained substituting v v tc hc followed simplification tc
modifier
vector sn v updated vector sn v
hm tm

h
eval sn tm


h
hm eval sn tm


h
hm eval sn tm


next formalize application operators given state
definition semantics grounded operator application operator
applied state sp sn sp f sn ir v yields successor
state sp sn f ir v follows
sp sn satisfies c sp sp vector sn updated

propositional update sp sd defined standard strips
example take state sp sn
sp ernie city plane city scott city dan plane
sn fuel plane total fuel used total time
successor sn sp sn due action debark dan plane city
sp dan city ernie city plane city scott city
sn fuel plane total fuel used total time
effect lists order update operations important example
refuelling aircraft zenotravel cf figure fuel level reset variable
total time updated
set goal states g often given g gp gn partial propositional state
description gp f gn set numerical conditions c hc tc moreover
arithmetic trees tc usually collapses simple leaves labelled numerical constants
hence sake simplifying complexity analysis object symmetry
might assume gn v complex goal description limitation planner
since easily transformed preconditions goal enabling opererator


fitaming numbers durations mips

temporal model
simplest solving temporal generate sequential
plan course option assumes temporal structure contributes
value plan correctness assumes necessary
concurrency valid plan cases actions achieve conditions start
points delete end points example concurrency necessary
part structure valid plan
definition sequential plan solution p hs gi
form sequential plan ordered sequence operators oi k
transforms initial state one goal states g g e exists
sequence states si k sk g si outcome
applying oi si k
time stamp ti durational operator oi k starting time
pi
oj
oi duration operator oi ti j
sequential plans time stamps calculated mips extra variable
total time variable updated scheduling operators example sequential plan time stamps shown figure
minimizing sequential plan length objective first second competitions since graphplan planners blum furst ipp koehler
nebel dimopoulos stan long fox already produced parallel plans
assuming action duration indeed limiting factor evaluating plan quality
important reason artificial restriction total ordered plans
easier automatically validate necessity checking correctness competition
pddl domain descriptions include temporal modifiers start end
label start denotes preconditions effects invocation time
action refers invariance condition end finalization conditions
consequences action
figure two different options flattening information simple
preconditions effects order derive semantic sequential plans first
case top right compound operator split three smaller parts one action
invocation one invariance maintenance one action termination
semantics suggested fox long
pddl effects invariance pattern e b action
board quite natural code invariance form conditions b perform
actual status change person boards aircraft city aircraft required
remain city throughout action moving corridor status
corridor could encoded invariant would change starting
time action execution
moreover found benchmarks uncommon effects start
preconditioned termination control invariance maintenance e b c
even though intersection conditions effects formally defined yet
interpreted executing one construct interfere one reflects


fiedelkamp

pre eff pre eff pre eff
start



end

cond



b

c

eff



b

c



pre

b b

c c

eff

abc

b c

figure compiling temporal modifiers operators
possible partition operator sub operators b c b c dependence
transposition separated conditions effects considered section
consider example observe action board
consists person airplane predicate seen b requires plane stay
city boarding c empty action zoom contains effect
plane longer location flight started b c empty
cases b c
b b c sequential execution sequence
sub operators b b c c equal execution sequence b c b c
reasoning follows since b b b c c b c c
conditions b c allows us exchange order corresponding
items b c c b c c apply b derive
b c c b c b c consequence remains valid condition
b weakened b c
mips operator representation bottom right figure chosen note
intermediate format example figures implicitly assumed
temporal model sequential competition benchmark domains
observed many deficiencies model
however applicability model exploiting parallelism limited example
consider two people lift table two sides could done
one person alone case parallel execution set actions
cannot totally ordered allowed mips may argued defining
action requires two different persons certain place would require
equality construct pddl form numerical maintenance number
people room found another artificial example
total order consider simple strips domain b
g c b b b c b obviously operators
needed goal achievement sequential plan length since b
deleted operators however parallel plan could devised since precondition
fulfilled first time step
current versions mips refined model start end information
preserved grounding process attached action allow
dependent operators overlap minimizes number gaps start start start end
end end exclusions domains improvement yields much better solutions



fitaming numbers durations mips

operator dependency
definition operator dependency enables computing optimal schedules sequential
plans respect generated action sequence causal operator dependency
structure operators dependent void respect optimizer function
inherently sequential schedule leads improvement
definition dependency mutex relation let l denote set leaf variables
tree two grounded operators
dependent mutex one following three conflicts hold
propositional conflict propositional precondition set one operator nonempty intersection add delete list e

direct numerical conflict head numerical modifier one operator contained
condition one e exists c h c c
hm tm hm l c h c exists c hc tc
h h l tc hc
indirect numerical conflict head numerical modifier one operator contained formula body modifier one e exists
hm tm h hm l h l tm
example operators board scott plan city fly plane city
city c propositional conflict fluent plane city refuel
plane city fly plane city city c direct numerical conflict
variable fuel plane indirect conflicts subtle appear
example
use dependency optimal concurrent arrangement operators
sequential plan dependent appears sequential
plan invoked starts dependence relation reflexive e
conflict conflict moreover appears restrictive
compared pddl guidelines mutual exclusion fox long
allows operators partially overlapping even dependent
however possible generalize according model fox
long two actions oi represented ai bi bi ci ci
dependency violation located identifying sub operators
interact fact may identify eight possible refined conflicts
interacts interacts b b interacts
c c b b interacts b b interacts c c c c
interacts c c interacts c c interacts
asserting duration zero pair ai bi bi zero
pair ci ci one fix earliest start end time respect
competition version mips stick simplified temporal model
competition domains improving sequential plans according dependency relation
turned produce plans sufficient quality


fiedelkamp

implementation dependence relation computed beforehand tabulated
constant time access improve efficiency pre computation set leaf
variables maintained array grounded operator constructed
original graphplan definition propositional mutex relation close
fixes interference
lemma operator inference graphplan model implied
propositional mips model dependence
proof two independent operators
implies turn yields condition
inferred analogously
notion dependency related partial order reduction explicit state model
checking clarke et al two operators independent
state following two properties hold
neither disable execution
commutative e
next indicates state space enumeration approaches refer
property
theorem commutativity two independent strips operators
commutative preserve enabled property e
enabled enabled enabled
proof since lemma let
state let state since
enabled since enabled moreover









consequence operator independence indicates possible transpositions two operators prune exploration sequential plan generation less restrictive
notion independence several actions may occur time even one
deletes add effect another provided knoblock detect domains
parallelization leads improvement utilize following sufficient criterion


fitaming numbers durations mips

definition inherent sequential domains domain said inherently
sequential operator sequential plan instantaneous e zero
duration dependent immediate predecessor
static analyzer checks testing operator pair benchmark domains desertrats jugs water inherently sequential others zenotravel
taxi
definition parallel plan solution p hs gi
form parallel plan c ok tk arrangement operators oi
k transforms initial state one goal states g g
oi executed time ti ir
example parallel plan zenotravel depicted figure
backstom clearly distinguishes partially ordered plans ok
relation ok partial order reflexive transitive antisymmetric parallel plans ok irreflexive symmetric
expressing actions must executed parallel
definition precedence ordering ordering induced operators ok
defined
oi oj oi oj dependent j k
precedence partial ordering since neither reflexive transitive computing
transitive closure relation however precedence could extended partial
ordering sequential plan ok produces acyclic set precedence constraints
oi oj j k set operators important observe
constraints already topologically sorted according index order k
definition respecting precedence ordering parallel plan let
ir duration operator sequential plan parallel plan c
ok tk respects ti oi tj oi oj j k
optimizing plans backstrom defines parallel execution time max ti
oi oi ok oi oj ti oi tj oi oj
ti oi tj tj oj ti two possible choices actually
apparent since already precedence relation hand
seek optimal arrangement operators consequently assert one option
namely ti oi tj true reducing order optimal schedules
sequential plans similar backstrom would necessary
would dramatically increase computational complexity since optimal scheduling
set fixed timed operators np hard therefore decided restrict dependency
relation
definition optimal parallel plan optimal parallel plan respect sequence
operators ok precedence ordering plan ok tk
minimal parallel execution time op max ti oi oi ok among
parallel plans c ok k respect


fiedelkamp

procedure critical path
input sequence operators ok precedence ordering
output optimal parallel plan length max ti oi oi ok
k
e oi oi
j
oj oi
e oi e oj oi
e oi e oj oi
return max ik e oi

figure compute critical path costs
many suggested convert sequential plans partially ordered
ones pednault regnier fade veloso perez carbonell
interpret totally ordered plan maximal constrained partial ordering
oi oj j k search less constrained plans however
minimum constraint deordering proven np hard unless called
validity check polynomial backstrom deordering maintains validity
plan lessening constrainedness e ordering
since explicit model dependency time optimal parallel plans
change ordering relation
critical path analysis
project evaluation review technique pert critical path analysis
usually applied project management critical path sequence activities
total time activities path greater equal
path operators delay tasks critical path leads delay project
heart pert network tasks needed complete project showing order
tasks need completed dependencies
shown figure pert scheduling reduces variant dijkstras shortest
path acyclic graphs cormen leiserson rivest matter fact
returns length critical path inferred partially ordered
plan however obtaining temporal plan easy e oi tentative
earliest end time operator oi k earliest starting times ti
operators optimal plan given ti e oi oi
theorem pert scheduling given sequence operators ok precedence ordering optimal parallel plan ok tk computed
optimal time k
proof proof induction k induction hypothesis
iteration value e oi correct e g e oi earliest end time operator


fitaming numbers durations mips

oi clearly true since e assume hypothesis
true j look iteration two choices j
oj oi case inner loop completed e oi
set max e oj oj oj oi j hand e oi
optimal since oi cannot start earlier max e oj oj oi j since
values e oj already smallest possible induction hypothesis
j oj oi e oi oi base case therefore
end max ik e oi optimal parallel path length
time space complexity critical path clearly k
k length sequential plan adjacency list representation
efforts reduced time space proportional number vertices edges
dependence graph size k bound optimal since
input consists k operators dependencies among
apply critical path scheduling even consider temporal model fox
long allowing overlapping operator execution dependent operators answer
yes already seen considering two dependent operators oi oj
fox long model determine earliest start end time oj respect
fixed start time oi need proof theorem shows
determine earliest end time operators sequentially
optimality mips
since mips optimally schedules sequential plans question remains system
eventually optimal plan competition system terminates
first sequential plan found since relaxed heuristic admissible
variants cannot guarantee optimal sequential parallel plans however computing
optimal plans desirable even due limited computational resources finding optimal
plans hard
according temporal model optimal parallel plan operator starts
ends start end time another operator therefore least finite number
actions optimal plan possibly exponential finite number possible
parallel plans
immediately leads following naive plan enumeration
operator sequences length generate possible parallel plans check
individual schedule transforms initial state one goals take
sequence smallest parallel plan length since parallel plans computed yields
complete optimal seen example two persons lifting table
expressive applying finds sequential
plans first however inefficient
practice natural assumption parallel plan corresponds least one
possible many sequential one conversely partially ordered plan established
generating totally ordered plan first applying scheduling
best partial order
figure indicates wrap forward chaining planner
time performance gradually improves plan quality general state


fiedelkamp

procedure time
input hs gi
output optimal parallel plan length

open
open
extract open
expand
g
cp critical path path
cp
cp
else
change open
return
figure general time search
expanding scheme maintains search horizon list open simplicity maintenance stored nodes list closed shown current best
critical path cost bounds upcoming exploration process turn updated
time plan found shorter critical path
criticalpath procedure returns execution time
established plan compute plan meets returned value
store schedule generating sequence path global record cases
storing sufficient since path pert scheduling restored calling
procedure criticalpath end procedure
assuming optimal parallel plan schedule sequential plan state
space finite time extension cycle avoiding enumeration strategy indeed
complete optimal reason completeness finite graphs number
acyclic paths g finite every node expansion adds
links traversal tree newly added link represents acyclic path
eventually reservoir paths must exhausted
valid parallel plans cannot produced pert scheduling
sequential plan answer partial ordering terminates
optimal schedule generate corresponding sequential plan preserving
dependency structure optimal pert scheduling plan respect set
operators imposed precedence relation yield optimal parallel plan
sequential plans eventually generated optimal parallel plan found
pert scheduling
enumeration infinite state spaces infinite plateaus
plan objective function constant value normally increasing length
plan increases cost however true benchmark since


fitaming numbers durations mips

may infinite sequence events contribute plan objective
example loading unloading tanks pre competition test domain desertrats
affect total fuel consumption minimized one instances
enumeration schemes contradict known undecidability numerical helmert additional information bound maximal
number actions plan number actions executed parallel
cannot decide whether cycle free enumeration terminate hand
solution time eventually
pruning anomalies
acceleration techniques duplicate detection sequential plan generation
chosen carefully maintain parallel plan length optimality affect
parallel optimality following example shows zenotravel consider
sequences
zoom city city c plane board dan plane city c
refuel plane city c zoom city c city plane
board scott plane city debark dan plane city refuel plane city

board scott plane city zoom city city c plane
board dan plane city c refuel plane city c
zoom city c city plane debark dan plane city refuel plane city
two sets operators resulting sequentially generated
states however pert schedule first sequence shorter schedule
second one boarding scott done parallel final two actions
plan
small anomalies avoided omitting duplicate pruning
example figure depicts sequential plan example instance
pert schedule turns overall optimal parallel plan another option
store resulting parallel plan state caching instead sequential one note
order ease generation sequential solutions large instances
competition version mips used sequential state pruning
heuristic search
main drawback blind path enumeration seemingly slow practical
heuristic search ida reorder traversal states
assuming state caching affect completeness optimality anytime wrapper efficiency wrapper directly depends quality path
enumeration competition version mips omitted time wrapping since
optimal solutions required practical run time behavior poor
instead used search engine terminates first established solution
question remains still hope finding near optimal parallel plans general
applicable infinite graphs established pearl cost every


fiedelkamp















zoom plane city city c
board dan plane city c

board ernie plane city c
refuel plane city c

zoom plane city c city
debark dan plane city

board scott plane city
refuel plane city

zoom plane city city c
refuel plane city c

zoom plane city c city
debark ernie plane city
debark scott plane city

zoom plane city city c
board dan plane city c

board ernie plane city c
refuel plane city c

zoom plane city c city
debark dan plane city

board scott plane city
refuel plane city

zoom plane city city c
refuel plane city c

zoom plane city c city
debark ernie plane city
debark scott plane city

figure sequential plan zeno travel left pert schedule right

infinite path unbounded cost function f g h preserve optimality
additional rationale choosing exploration mips instead hill climbing
best first breadth first search rising influence g value crucial
adequate heuristic estimate parallel plans easy fact
established competitive admissible heuristic required optimal plan
finding choice scheduling extension rph contrast rph
heuristic takes relaxed sequence operators searches suitable parallel
arrangement turn defines estimator function
found adding pert schedules path state sequence
actions relaxed plan accurate pert schedule combined paths
therefore classical merit function search engines f g h generating path
length g heuristic estimate h immediate correspondence parallel
consequently define heuristic value scheduling rph parallel plan length
combined path minus parallel plan length generating path
arbitrary plan objectives
pddl plan metrics minimizing total parallel execution time
specified influences inferred solutions figure depict two plans found
mips objective functions minimizing total fuel used minimizing
compound total time total fuel used
first case computed optimal value second case
established optimized merit optimizing time ordering board
zoom actions important optimizing total fuel reduce speed save fuel
consumption per flight may board first passenger immediately
save two refuel actions respect first case
increasing importance time trade refueling actions time
zooming flight actions chosen complex minimization criterion
first attempt include arbitrary plan objectives alter pert scheduling
process however match ones produced validator long


fitaming numbers durations mips

zoom plane city city c
board dan plane city c

board ernie plane city c
refuel plane city c

zoom plane city c city
debark dan plane city

board scott plane city
refuel plane city

fly plane city city c
fly plane city c city
debark ernie plane city
debark scott plane city

board scott plane city
fly plane city city c
board ernie plane city c
board dan plane city c

fly plane city c city
debark dan plane city
refuel plane city

fly plane city city c
fly plane city c city
debark ernie plane city
debark scott plane city

figure optimized plans zeno travel according different plan objectives
fox final time substituted objective function plan
built
way mips evaluates objective functions time follows first schedules
relaxed final sequential plan variable total time temporarily substituted
critical path value objective formula evaluated avoid conflicts subsequent
expansions afterwards value total time set back optimal one sequential
plan

object symmetries
important feature parameterized predicates functions action descriptions
domain specification file actions transparent different bindings parameters
objects disambiguating information present instance file
case typed domains many planners including mips compile type information additional predicates attach additional preconditions actions enrich
initial states suitable object type atoms
consequence symmetry viewed permutation objects present
current state goal representation transparent set operators
n n obj possible permutations set objects taking
account type information reduces number possible permutation
n
k





n

tk

ti number objects type k moderate sized logistic
domain cities trucks airplanes packages
permutations
reduce number potential symmetries tractable size restrict symmetries
object transpositions n n n candidates
type information number reduces
k
x
ti








k
x

ti ti





fiedelkamp

following set typed object transpositions denoted symm
logistics example symm
generating object symmetries
section compute subset symm includes object pairs
entire symmetric start object transpositions smallest
entities
definition object transpositions fluents variables operators transposition objects symm applied fluent f p ok p f written
f defined p k p oi oi
oi oi
oi oi k p object transpositions applied variable
v f ok f v operator ok defined analogously
example zenotravel scott city scott dan
dan city
lemma f f v v symm f f
v v well f f
v v
brute force time complexity computing f f order k p
k p number object parameters p however pre computing symm
f sized lookup table containing index f f symm
time complexity reduced
definition object transpositions states let mapping set
object transposition applied state sp sn
sn v vk k v written equal sp sn
sp f f f sp f f
sn v vk vi vj j j k
initial state example dan ernie definition
variables slightly difficult predicates since case variable
contents availability must match
time complexity compute sn k since testing
j available time building another symm v sized pre computed
look table note times worst case terminate computation
object symmetry fluent variable contradictory summarize complexity
follows
lemma worst case time complexity compute state sp sn
symm sp v symm f v space
next step lift concept object transposition


fitaming numbers durations mips

definition object transpositions domains p hs gi
symmetric respect object transposition abbreviated p
g g g g
since goal descriptions partial prefer writing g g instead g g
g g moreover assume goal description complexity g bounded
gp v
zenotravel goal descriptor purely propositional containing three
facts target location dan ernie scott initial state running
example contains object symmetry since scott ernie
g dan ernie g
applying lemma symm yields time complexity needed establish object symmetries
theorem time complexity object symmetry detection worst case run time
determine set object transpositions p hs gi
symmetric symm gp ip v
including goal symmetry conditions
symmetries present initial state may vanish reappear exploration
forward chaining planner mips desertrats domain example initial set
supply tanks indistinguishable one loaded truck
fuel levels supply tanks decrease tanks transported another location
previously existing symmetries broken however two tanks one location become
empty considered symmetric
goal conditions however change time initial state transforms
current state c therefore pre compiling phase refine set symm
symm symm g g




usually symm much smaller symm zenotravel instance
object symmetry left symm transposition scott ernie
therefore efficiently compute set
symm c symm c c
symmetries present current state initial state example
zeno travel symm scott ernie share
location state c object pair would included symm c
definition requires c c include symmetric paths
different states let c ernie city c scott city possible
symmetric plan ernie city scott city c common
goal viewed differently complex object symmetries form
detected example observe c scott ernie city c city c
respect theorem additional restriction reduces time complexity
detect remaining object symmetries symm cp v


fiedelkamp

pruning operators
current state c symmetric respect operator
transposition application operator application
operator neglected significantly reducing branching factor lemma
indicates symmetry used reduce exploration
lemma operator applicable applicable


proof applicable applicable since
applicable


pre computing symm sized table index operator
determined time symm
definition pruning set let index mapping set let
c set operators applicable state c pruning set c c
defined set operators symmetric counterpart
minimal index symmetry reduction c c defined c c
theorem correctness operator pruning reducing operator set c c
exploration p hs gi preserves completeness
proof suppose expanded state c reducing operator set c c
exploration p hs gi preserve completeness
furthermore let c state property maximal exploration order
sequential plan ok pc hs c gi associated
state sequence c sk g obviously oi si k
choice c definition pruning set
exists minimal index applicable
since pc hs c gi pc hs c c g gi
sequential plan ok state sequence
sk sk reaches goal g contradicts assumption
reducing operator set c c preserve completeness c
since plan objective refers instantiated predicates objects similar
initial goal state symmetry breaking order preserve optimality one
additionally check see object exchange influence plan objective
practice objective functions often non parameterized predicates
case optimal affected symmetry cuts
generally completeness means planner legal plan intended
use completeness terms discarding legal plans favor equally good symmetric plans



fitaming numbers durations mips

symmetry reduction mips
main purpose restricted implementation mips reduce run
time object symmetry detection losing effectiveness especially
impact quantity symm cp running time considerable
key observation symmetries present fact groups according
group representatives shown figure fact group dan consists facts
dan city dan city b dan city c dan city dan
plane similarily ernies group facts ernie city ernie city b
ernie city c ernie city ernie plane ordering facts
groups chosen way except change group representative
corresponding facts match together facts groups operators change
facts groups stored efficient dictionary
therefore restrict object transpositions group representatives reduces
set objects obj mips considers considerably smaller subset obj
example obj obj many objects e g objects
type city zenotravel selected representatives single attribute invariance
build group
idea obtain possible transposition fact group representatives followed
looking respective fact positions current goal state may happen
one group fixed representative obj case link groups
representative common symmetry detection test group chains
objects matching current goal position
symmetries non matching goal predicates excluded beforehand let rsymm number remaining symmetries object representatives
assume one representative per group yields running time propositional object
symmetry detection state c rsymm cp remaining comparisons variables v v implemented described previous section performed
object pairs pass propositional check
pruning operators mips marks groups correspond object symmetry
larger index visited guarantees operator least one
group executed expanded state matching operator
checks whether applied operator present visited group case
pruned time complexity since operator group containment
preprocessed checked constant time
figure shows effectiveness symmetry reduction planner mips desertrats domain scales respect total distance
passed x axis direction number expanded states
search mips object symmetry reduction right bars without symmetry reduction left bars shown logarithmic scale expected larger symmetry
reduction yields performance gains one order magnitude
yields solutions without symmetry reduction fail due
memory restrictions
memory bound used example set gbyte



fiedelkamp

figure symmetry pruning desert rats bars number states
expanded without symmetry detection

related work
strips tackled different techniques notably
sat kautz selman ip kautz walser cspplanning rintanen jungholt graph relaxation blum furst heuristic
search bonet geffner
solving numerical preconditions effects allowed level
level undecidable general helmert however structures
provided benchmark simpler general class
fact solvable
temporal approaches
system metric hoffmann extends hoffmann nebel
forward chaining heuristic state space planner level although mips plan
generator shares several ideas metric hoffmanns system yet extended
deal temporal domains
planner tp haslum geffner fact scheduling system grounded
instances cases formula trees numerical conditions assignments
reduce constants utilizing admissible heuristics tp minimizes plan objective
optimal parallel plan length planner distinctive advantages handles
numerical preconditions instantiates numerical conditions fly cope
complex objective functions besides input restriction competition tp
somewhat limited focus producing optimal solutions
sapa system kambhampati domain independent time resource planner cope metrics concurrent actions sapas general expressivity judged close mips adapts forward chaining
bacchus ady approaches instantiate actions fly


fitaming numbers durations mips

therefore principle adapted handle flexible mixed propositional numerical search sapa extends partial concurrent plans
instead parallelizing sequential plans uses relaxed temporal graph
yet unplanned events different heuristic evaluation functions additional feature
sapa provides option specifying deadlines
planner lpg gerevini serina local search graphs
uses variant planner grounding initial plans generated random walk subsequent search space lpg consists called action graphs gerevini
serina temporal module performs action graph modifications transforming
action graph another one fast plan generation lpg seems
best explanation speed advantage lpg respect mips
higher number lpg solved domains optimization lpg governed
lagrange multipliers temporal domains actions ordered precedence graph
maintained search uses refined dependency relation
may partly explain plan quality fact consistently better mips
ixtet laborie ghallab general constraint system
input format planner searches space partial plans allows general
resource temporal constraints posed internal representation consists
chronicles time linearly ordered discrete set instants multi valued state
variables rigid flexible contingent controllable resources predicates
temporally qualified expressions events assertions resources temporal atemporal
constraints clear compare expressivity chronicles pddl
constructs makes difficult link different temporal determine
technique critical path scheduling applicable ixtet opinion
unlikely since ixtet partial order note ixtet allows conjunction
predicates subtasks constraints conditional expressions available
pddl analysis partial plans drives process divided
three different modules feasibility satisfiability resource conflict resolution
competition domains ixtet able compete local search heuristic search
planners
hsts muscettola constraint system temporal activity networks written lisp crl nasa used many projects
deep space one already represent reason metric resources parallel
activities general constraints ixtet input format significantly different
pddl hsts yet adapted represent reason conditional
branches however experiences hsts planner showed partial order
attractive metric temporal need better search control
although pddl guidelines fact allow infinite branching competition consisted finite branching indicated earlier
concentrates finite branching finite branching execution time
action fixed infinite branching continous range actions available
confronted real time model checking long time
subclasses infinite branching timed automata exhibit finite partitioning symbolic representation states pettersson technique
shortest path reduction unique reduced normal form obtained


fiedelkamp

implemented temporal network structure since main data structure
exploring timed automata done model checker uppaal pettersson
work constraints must form xi xj c xi c example
set constraints x x x x x x x x x x
x x x x x x x x x x shortest path
reduction x x x x x x x x x x x x
x x constraint set constrained determine
unsolvability otherwise feasible solution returned
critical path analysis timed precedence networks one simpler cases
scheduling achieved simplification solving sequential path first
note many scheduling techniques apply presented critical path analysis
subcomponent syslo deo kowalik
symmetry detection model checkers
previous symmetry reduction e g guere alami
neglect combinatorial explosion possible symmetries least assume
information existing symmetries domain supplied user
contrast work shares similarities fox long
inferring object symmetry information fully automatically fox longs work
similarities established tim inference module fox long search
additional information current symmetry level form object transposition
matrix stored updated together state different sense
efficiently computes object symmetries state scratch consumes
extra space per node expansion
model checking long tradition symmetry reduction clarke et al
recent work rintanen connects symmetry detection model checking
approaches transition systems sat solving experiments provided sat
encodings gripper domain prototypical example symmetry detection lluchlafuente model checker hsf spin extended effectively combine heuristic
search symmetry detection reflects fact hsf spins exploration
modelled labelled transition systems positive empirical given
non trivial examples petersons mutual exclusion database manager
protocol
briefly review fundamental difference object symmetries considered
state space symmetries considered model checking
latter constructs quotient state space p congruence relation equivalence relation called congruence
operator
operator
operator mapping
bijection said symmetry g g g g
transition exist transition
set symmetries generates subgroup g called symmetry group
subgroup g induces equivalence relation states defined


fitaming numbers durations mips

g equivalence relation called symmetry relation
p induced equivalence class called orbit denoted
symmetry relation p congruence p moreover reachable
reachable reduces search goal g g finding state g
explore state space respect state space symmetry function canonicalize needed time successor node generated determines representative
element equivalence class fixing canonical element trivial many
systems approximate normal form automatically finding symmetries setting
difficult cast computationally hard graph isomorphism
therefore approaches expect information kind symmetry present
state space graph one example rotational symmetry defined right shift
variables state vector
model checking planners
competition two symbolic planners took part propplan fourman
bddplan holldobler stor although receive awards
performance interesting properties propplan performs symbolic forward
breadth first search explore propositional propositions generalized action preconditions generalized action effects performed well full
adl miconic elevator domain koehler probplan written poly ml
implementation sml bdd plan solving entailment fluent calculus bdds time authors acknowledged concise domain
encoding symbolic heuristic search used mips improvements
model planner mbp paradigm symbolic model checking giunchiglia traverso implemented non deterministic
domains cimatti et al classified weak strong strong cyclic
plans represented state action tables partially observable
system faced exploring space belief states power set
original space therefore contrast successor set generation action application observations introduce nodes search tree bertoli cimatti
roveri traverso b since hybrid symbolic representation
belief states explicit search within search tree simple heuristics
applied guide search need heuristics trade information gain
exploration effort apparent conformant bertoli et al recent
work bertoli cimatti proposes improved heuristics belief space
umop system parses non deterministic agent domain language explicitly
defines controllable system uncontrollable environment jensen veloso
planner applies bdd refinement techniques automated transition function
partitioning umop system extend weak strong strong cyclic
adversarial environment actively influences outcome
actions fact proposed combines aspects symbolic search
game playing umop yet participated competition
recent developments symbolic exploration expected influence automated
near future seta jensen et al provide improved imple

fiedelkamp

mentation symbolic heuristic search bdda edelkamp reffel
weighted bdda edelkamp one improvement seta maintains finer
grained sets states search horizon kept matrix according matching g h values contrasts plain bucket representation priority
queue f values heuristic function implicitly encoded value differences
grounded actions since sets states evaluated heuristics state
rather operator dependent remains shown general
benchmarks considered seemingly simple single state heuristic search exploration hoffmann b helmert hansen zhou feng
implemented bdda suggest symbolic search heuristics exploration
probably better implemented algebraic decision diagrams adds although authors achieved improvement edelkamp reffel solving
n puzzle established generalization guide symbolic version lao exploration hansen zilberstein probabilistic mdp
remarkable improvement state art feng hansen

conclusions
competition system mips contributed flexible system
heuristic forward chaining explicit symbolic search planner finds plans finitebranching numerical planner parses pre compiles solves schedules
instances including complex ones duration resource variables different
objective functions main contributions planner
object oriented workbench architecture choose combine different heuristics different search storage structures design includes
static analyzer applies efficient fact space exploration distinguish constant
fluent quantities clusters facts groups infers static object
symmetries static analyzer produces intermediate format grounded
simplified domain instances
optimal temporal enumeration precedence relation
pert scheduling sequentially generated plans together concise analysis
correctness optimality well integration pert scheduling mips
computing refined heuristic estimate guides search phase favoring
states smaller parallel plan length mips instantiates numerical pre postconditions fly produces optimized parallel plans
detection dynamic object symmetries integration different pruning
methods hash transposition cuts well different strategies optimizing objective functions implementation tricks made system
efficient
analyzes theoretical properties contributions sometimes slightly
abstracting actual implementation
essentially numerical quantities durative actions
resources time given framework mixed propositional numerical


fitaming numbers durations mips

presented intermediate format seen normal form temporal
metric presents novel temporal scheme generates
sequential totally ordered plans efficiently schedules respect set
actions imposed causal structure without falling known np hardness traps
optimized partial ordering sequentially generated plans smaller complete enumeration guarantees optimal solutions improve solution quality
approximate enumeration numerical estimate number operators replaced
scheduling relaxed plan state addressed completeness optimality
different forms exploration novel study time space complexity dynamic
object symmetry detection given
model checking influenced development mips e g static analysis minimize state description length symbolic exploration plan extraction
dependence relation pert schedules according given partial order bit state
hashing ida importance symmetry detection forth moreover
successes mips exported back model checking development heuristic search state model checkers parsing promela protocol specifications
indicate

acknowledgments
author would thank derek long maria fox helpful discussions concerning
malte helmert cooperation second competition
list editors anonymous reviewers comments helped lot improve text
work supported deutsche forschungsgemeinschaft dfg projects
heuristic search ed directed model checking ed

references
bacchus f ady resources concurrency forward chaning
proceedings ijcai pp
bacchus f kabanza f temporal logics express search control knowledge artificial intelligence
backstrom c computational aspects reordering plans journal artificial
intelligence
bertoli p cimatti improving heuristics search belief space
proceedings aips pp
bertoli p cimatti roveri heuristic search symbolic model checking
efficient conformant proceedings ijcai pp
bertoli p cimatti roveri traverso p b nondeterministic
domains partial observability via symbolic model checking proceedings
ijcai pp
biere cke efficient calculus model checking proceedings cav pp



fiedelkamp

bloem r ravi k somenzi f symbolic guided search ctl model checking
proceedings dac pp
blum furst l fast graph analysis
proceedings ijcai pp
bonet b geffner h heuristic search artificial intelligence
bryant r e symbolic boolean manipulation ordered binary decision diagrams acm computing surveys
cimatti giunchiglia e giunchiglia f traverso p via model
checking decision procedure ar proceedings ecp pp
cimatti roveri traverso p automatic obdd generation
universal plans non deterministic domains proceedings aaai pp

clarke e grumberg peled model checking mit press
clarke e mcmillan k l dill l hwang l j symbolic model checking
states beyond information computation
cormen h leiserson c e rivest r l introduction
mit press
dial r b shortest path forest topological ordering communication
acm
b kambhampati sapa domain independent heuristic metric temporal planner proceedings ecp pp
edelkamp datenstrukturen und lernverfahren der zustandsraumsuche ph
thesis university freiburg diski infix
edelkamp directed symbolic exploration application ai
proceedings aaai spring symposium model validation intelligence
pp
edelkamp b first solutions pddl proceedings
plansig pp
edelkamp c pattern databases proceedings ecp pp

edelkamp mixed propositional numerical model checking integrated system proceeding aips workshop temporal
pp
edelkamp b symbolic pattern databases heuristic search proceedings aips pp
edelkamp promela proceedings spin pp
edelkamp helmert exhibiting knowledge minimize state encoding length proceeding ecp pp


fitaming numbers durations mips

edelkamp helmert implementation mips proceedings
aips workshop model theoretic approaches pp
edelkamp helmert model checking integrated system mips
ai magazine
edelkamp leue lluch lafuente directed explicit state model checking
validation communication protocols international journal software tools
technology sttt appear
edelkamp meyer u theory practice time space trade offs memory
limited search proceedings ki lecture notes computer science pp
springer
edelkamp reffel f obdds heuristic search proceedings ki pp

edelkamp reffel f deterministic state space bdds
proceedings ecp preprint pp
edelkamp reffel f b deterministic state space bdds tech
rep university freiburg
edelkamp stiegeler p implementing heapsort n log n n
quicksort n log n n comparisons acm journal experimental
feng z hansen e symbolic heuristic search factored markov decision
processes proceedings aaai
fikes r nilsson n strips application theorem
proving solving artificial intelligence
fourman p propositional proceedings aips workshop
model theoretic approaches pp
fox long automatic inference state invariants tim journal
artificial intelligence
fox long detection exploration symmetry
proceedings ijcai pp
fox long extending exploitation symmetries
proceedings aips
fox long pddl extension pddl expressing temporal
domains journal artificial intelligence issue
gerevini serina fast greedy action graphs proceedings
aaai
gerevini serina lpg planner local search graphs
action costs proceedings aips
giunchiglia f traverso p model checking proceedings
ecp pp


fiedelkamp

groce visser w model checking java programs structural heuristics
proceedings issta
guere e alami r one action enough plan proceedings ijcai
hansen e zilberstein lao heuristic search finds solutions
loops artificial intelligence
hansen e zhou r feng z symbolic heuristic search decision
diagrams proceedings sara
hart p e nilsson n j raphael b formal basis heuristic determination
minimum path cost ieee transactions systems science cybernetics

haslum p geffner h heuristic time resources proceedings
ecp pp
helmert complexity transportation domains proceedings ecp pp
helmert decidability undecidability numerical
state variables proceedings aips pp
hipke c verteilte visualisierung von geometrischen algorithmen ph thesis
university freiburg
hoffmann j heuristic domain independent use enforced
hill climbing proceedings ismis pp
hoffmann j extending numerical state variables proceedings ecai
hoffmann j b local search topology benchmarks theoretical analysis
proceedings aips pp
hoffmann j nebel b fast plan generation heuristic search journal
artificial intelligence
holldobler stor h p solving entailment fluent calculus binary decision diagrams proceedings aips workshop modeltheoretic approaches pp
jensen r bryant r e veloso seta efficient bdd
heuristic search proceedings aaai
jensen r veloso obdd universal synchronized
agents non deterministic domains journal artificial intelligence

kabanza f barbeau st denis r control rules reactive agents
artificial intelligence
kautz h selman b pushing envelope propositional logic
stochastic search proceedings aaai pp
kautz h walser j state space integer optimization proceedings
aaai


fitaming numbers durations mips

knoblock c generating parallel execution plans partial order planner
proceedings aips pp
koehler j elevator control proceedings aips pp

koehler j hoffmann j reasonable forced goal orderings use
agenda driven journal artificial intelligence

koehler j nebel b dimopoulos extending graphs adl
subset proceedings ecp pp
korf r e depth first iterative deepening optimal admissible tree search
artificial intelligence
korf r e zhang w divide conquer frontier search applied optimal
sequence alignment proceedings aaai pp
laborie p ghallab sharable resources constraints proceedings ijcai pp
lago u pistore traverso p language extended
goals proceedings aaai
lind nielsen j buddy binary decision diagram package release technical
univeristy denmark available jln itu dk
lluch lafuente symmetry reduction heuristic search error detection
model checking proceedings workshop model checking artificial
intelligence mochart
long fox efficient implementation plan graph stan journal
artificial intelligence
long fox encoding temporal domains validating temporal plans workshop uk scheduling special interest group
plansig
mcdermott ai competition ai magazine
mcmillan k l symbolic model checking kluwer academic press
muscettola n hsts integrating scheduling zweben fox
eds intelligent scheduling pp morgan kaufmann
pearl j heuristics addison wesley
pednault e formulating multiagend dynamic world classical
framework reasoning action plans pp morgan kaufmann
pednault e adl exploring middleground strips situation calculus proceedings kr pp morgan kaufman
pettersson p modelling verification real time systems timed automata theory practice ph thesis department computer systems uppsala university


fiedelkamp

pistore traverso p model checking extended goals nondeterministic domains proceedings ijcai
pohl practical theoretical considerations heuristic search
machine intelligence
refanidis vlahavas heuristic ressources proceedings
ecai pp
reffel f edelkamp error detection directed symbolic model checking
proceedings fm pp
regnier p fade b determination du parallelisme maximal et optimisation
temporelle dans les plans dactions lineaires revue dintelligence artificielle

reinefeld marsland enhanced iterative deepening search ieee transactions pattern analysis machine intelligence
rintanen j symmetry reduction sat representations transition systems
proceedings icaps
rintanen j jungholt h numeric state variables constraint
proceedings ecp pp
ruys c optimal scheduling branch bound spin proceedings spin pp
syslo deo n kowalik j discrete optimization
pascal programs prentice hall
veloso perez carbonell j g nonlinear parallel
resource allocation innovative approaches scheduling control
pp
weismuller planen mit einem modellprufer im kalkul masters thesis
universitat ulm
yang c h dill l validation guided search state space
proceedings dac pp
yoshizumi miura ishida partial expansion large branching
factor proceedings aaai pp
zhou r hansen e sparse memory graph search proceedings ijcai




