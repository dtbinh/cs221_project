Journal Artificial Intelligence Research 20 (2003) 343377

Submitted 12/02; published 12/03

TALplanner Third International Planning
Competition: Extensions Control Rules
Jonas Kvarnstrom
Martin Magnusson

jonkv@ida.liu.se
marma@ida.liu.se

Department Computer Information Science
Linkoping University
SE-581 83 Linkoping, Sweden

Abstract
TALplanner forward-chaining planner relies domain knowledge shape
temporal logic formulas order prune irrelevant parts search space. TALplanner recently participated third International Planning Competition,
clear emphasis increasing complexity problem domains used benchmark tests expressivity required represent domains planning system.
many planners, TALplanner support aspects increase expressivity, number changes planner required. short
introduction TALplanner, article describes changes made
competition. describe process introducing suitable
domain knowledge several competition domains.

1. Introduction
planners, TALplanner (Kvarnstrom & Doherty, 2000; Doherty & Kvarnstrom,
1999; Kvarnstrom, Doherty, & Haslum, 2000; Doherty & Kvarnstrom, 2001; Kvarnstrom &
Doherty, 2003; Kvarnstrom, 2002) allows user specify goal shape set
atemporal logic formulas must satisfied final state results executing
plan. Unlike planners TALplanner allows specification set temporal
logic formulas must satisfied entire state sequence generated plan.
Obviously, formulas used specify temporally extended goals,
safety maintenance goals must upheld throughout execution plan.
However, possible specify constraints related traditional measures plan
quality, constraints forbid certain stupid actions taking place,
Blockhead blocks world planner Kibler Morris (1981) TLplan Bacchus
Kabanza (2000), initially inspired development TALplanner. example,
logistics domain one may specify temporally extended goal stating package
destination, never picked again, goal stating trucks driving
two locations always use shortest path. constraints processed
TALplanner order automatically extract control knowledge used
forward-chaining search process, opposed used filter candidate plan
generated. Given sufficiently strong constraints, planner efficiently prune
search tree, making easier find plan among remaining nodes. Often
(as article) search control aspect fact primary reason introducing
temporally extended goal, case goal usually referred control rule.
c
2003
AI Access Foundation. rights reserved.

fiKvarnstrom & Magnusson

Although forward-chaining planners may sometimes suffer lack goal-directedness
compared types planners, use explicitly represented domain-dependent
knowledge one way compensating deficiency. significantly, forward
chaining planner always complete description past current states,
facilitates use complex operator types complex preconditions conditional
effects. expressivity useful TALplanner participated third International Planning Competition (IPC-20021 ), clear emphasis increasing
complexity problem domains used benchmark tests expressivity required
represent domains planning system. fact, TALplanner already support
several new features present IPC-20002 , use numeric
state variables temporally extended actions variable duration.
Nevertheless, several extensions changes implemented
competition order accommodate semantics PDDL2.1, new version
PDDL (Planning Domain Definition Language, Fox & Long, 2003) used specify
problem domains problem instances. extensions changes first topic
article, introduction TALplanner (Sections 2 3), extensions
discussed Section 4. second topic describing domain-dependent
control rules used six benchmark problem domains hand-tailored
track competition, importantly, process generating rules
reasoning behind (Section 5). describe new changes
made TALplanner competition (Section 6). Finally, conclude
discussion positive negative sides using search control knowledge
TALplanner together pointers towards possible future research topics.
Please see Long Fox (2003) information basic setup
competition, detailed descriptions planning domains used, timing plan
quality results.

2. Representation: Using TAL TALplanner
semantics TALplanner based extended version TAL-C (Karlsson &
Gustafsson, 1999; Doherty, Gustafsson, Karlsson, & Kvarnstrom, 1998), member
TAL (Temporal Action Logics) family narrative-based non-monotonic linear discrete
metric time logics reasoning action change. TAL-C developed
modeling domains may include use incomplete information, delayed effects
actions, finite infinite chains indirect effects, interacting concurrent actions, independent processes directly triggered action invocations. Consequently, seen
ideal choice initial version TALplanner extensions
could conceivably implemented foreseeable future.
TAL narrative consists set labeled statements high-level macro language
L(ND), basic language number statement classes observations fluent
values (labeled obs), action descriptions (acs), action occurrences (occ), domain constraints
(dom), dependency constraints modeling causal relations indirect effects (dep).
formal semantics L(ND) defined translation order-sorted first-order
base language L(FL) circumscription policy providing solution frame
ramification problems (Doherty, 1994; Gustafsson & Doherty, 1996; Doherty et al., 1998).
1. http://www.dur.ac.uk/d.p.long/competition.html
2. http://www.cs.toronto.edu/aips2000/

344

fiTALplanner IPC-2002: Extensions Control Rules

L(ND) language designed easily extended different tasks, planning. extension may take shape new specialized macro new type
statement. illustrated Figure 1, TALplanner goal narrative uses version L(ND)
called L(ND) , contains standard classes L(ND) statements together
several new types planning-related statements. extensions accompanied
extensions translation function, new variation TAL still share
base language L(FL).
However, TALplanner use
L(ND)*
L(ND)

translation directly planTALPlanner
TAL
TAL
ning
process. Instead, makes direct use
Plan Narrative
Goal Narrative
higher level L(ND) goal narrative
forward-chaining search process
L(FL)
L(FL)
generates plan narrative set
1storder
1storder
timed action occurrences (corresponding
theory
theory
plan) added,
+ Circ(T)
+ Circ(T)
goal entailed final state.
L(FL)
+ Quantifier Elimination
L(FL)
+ Q.E.
section, attempt
1storder
1storder
provide intuitive understanding TAL
theory
theory Goal
used domain specifications using concrete examples
Figure 1: TAL/TALplanner relation
standard logistics planning domain,
set objects (packages) transported truck locations city
airplane airports different cities. next section contains information search process use control rules. See Doherty et al. (1998)
detailed description TAL, see Kvarnstrom Doherty (2000)
information TALplanner.
Notation. formulas L(ND) statements shown using input syntax
TALplanner, exception connectives quantifiers may written
using ordinary logical symbols increased clarity. free variables implicitly
universally quantified.
2.1 Types, Objects State Variables
Although planners restricted declaring unstructured set objects
representing types unary predicates, TAL order-sorted allows user specify
hierarchy object types (sorts). logistics domain modeled using standard
sort boolean = {true, false} together seven user-specified types: loc (location)
subtypes airport city, thing subtypes obj vehicle, latter
subtypes truck plane.
TALplanner allows use numeric types. order keep semantics
types clear, integers fixed point numbers (that is, numbers fixed number
decimals) allowed, lower upper bounds must declared numeric
type. standard arithmetic operators available numeric types
given interpretation semantic attachment.
State variables represented using TAL fluents, restricted

345

fiKvarnstrom & Magnusson

predicates take values arbitrary user-specified sort. logistics domain,
one could use two boolean fluents, at(thing, loc) in(obj, vehicle), together cityvalued fluent city of(loc) denoting city containing location loc.
2.2 Initial State
Given fluents defined above, initial state logistics problem instance
specified using L(ND) observation statements:
#obs [0] city of(pos1) =
city1 city of(pos2) =
city2 . . .
#obs [0] at(obj11, pos1) at(truck1, pos1) . . .
observations consist TAL-C fixed fluent formulas, formulas form [ ] denoting fact fluent formula holds time . fluent formula boolean
combination elementary fluent formulas form f =
v (f==v input notation),
denoting fact fluent f takes value v. boolean fluents,
second observation, shorthand notation f f (!f input notation) allowed.
notation extended open, closed, semi-open temporal intervals. addition
formulas, function value(, f ) denotes value f time .
2.3 Goal: Goal Statements Goal Expressions
statement class goals (labeled goal) added L(ND) . goal statement
consists fluent formula must hold goal state:
#goal at(obj11, airport1) at(obj23, pos1) . . .
ability test whether formula entailed (state-based) goal useful
temporally extended goals domain-dependent control rules. Therefore, new macro
added: goal expression goal() holds iff goal problem instance (the conjunction goal statements) entails fluent formula . Stated differently, goal() true
must true every goal state. translation L(FL) somewhat complex;
see Kvarnstrom Doherty (2000) information.
Note valid plan must end goal state. sufficient visit goal state
temporarily, could case operator effects multiple timepoints
first satisfying goal destroying concurrent plans
created. (If plans desired reason, would course easy modify
definition planner accordingly.)
2.4 Operator Definitions
Since TAL-C logic reasoning action change, notion actions
used modeling planning operators. Although TALplanner use
semantics, extended planning language L(ND) contains new operator macro
providing syntax facilitates use resource constraints planningoriented concepts present standard TAL-C. line standard
TAL practice preserving logical base language L(FL) semantics providing
different variations high-level macro language L(ND) adapted special
tasks.
346

fiTALplanner IPC-2002: Extensions Control Rules

examples demonstrate operator definition syntax using three six
logistics operators. examples shown IPC-2002 benchmark domains
discussed.
#operator load-truck(obj, truck, loc) :at
:precond [s] at(obj, loc) at(truck, loc)
:effects
[s+1] at(obj, loc) := false, [s+1] in(obj, truck) := true
#operator unload-truck(obj, truck, loc) :at
:precond [s] in(obj, truck) at(truck, loc)
:effects
[s+1] in(obj, truck) := false, [s+1] at(obj, loc) := true
#operator drive(truck, loc1 , loc2 ) :at
:precond [s] at(truck, loc1 ) city of(loc1 ) =
city of(loc2 ) loc1 6= loc2
:effects
[s+1] at(truck, loc1 ) := false, [s+1] at(truck, loc2 ) := true
Although used simple logistics operators above, TALplanner allows
use context-dependent quantified effects well prevail conditions. Unlike pure
preconditions, prevail conditions limited invocation state operator
refer entire interval operator executed. interval
prevail condition must hold explicitly specified, provides additional flexibility
compared requiring precondition must always hold throughout execution
action.
2.5 Resources
TALplanner limited generating sequential plans, resource consumption production could handled using plain operator effects. example, loading truck
requires one unit space, amount available space could decreased follows:
#operator load-truck(obj, truck, loc) :at
:precond [s] at(obj, loc) at(truck, loc)
:effects
[s+1] space(truck) := value(s, space(truck)) 1, . . .
concurrent planning, clearly sufficient, since multiple parallel invocations
load-truck would still consume one unit space. reason, TALplanner
explicit support resources (Kvarnstrom et al., 2000).
Resources declared manner similar ordinary fluents:
parameters take values arbitrary integer fixed point domain. Unlike
planners, TALplanner provides one type resource, provides several types
resource effects. Resources produced consumed. borrowed
(and automatically returned), either exclusively, meaning borrower exclusive
use resource specified interval, non-exclusively, multiple actions
borrow units certain resource concurrently. latter case may appear
strange, useful one wants use resource semaphore mutex.
Finally, resources assigned completely new value.

347

fiKvarnstrom & Magnusson

following example, loading truck always consumes one unit space.
#operator load-truck(obj, truck, loc) :at
:precond [s] at(obj, loc) at(truck, loc)
:effects
[s+1] at(obj, loc) := false, [s+1] in(obj, truck) := true
:resources [s+1] :consume space(truck) :amount 1
Unlike ordinary fluents, resource res multiple aspects queried used
formulas operator preconditions control rules. timepoint, initial amount available, $init(res). certain amount may consumed time
step ($consumed(res)), produced ($produced(res)), borrowed exclusively ($borrowed(res))
borrowed non-exclusively ($borrowed-nonex(res)). results remaining amount
available ($available(res)), must minimum ($minimum(res))
maximum ($maximum(res)) allowed. ability refer aspects directly allows
user specify complex resource constraints simple minimum maximum value resource, control rule defining maximum amount may
consumed per time step.
concludes description planning domain definitions TAL. following
sections show structure TALplanners forward-chaining search tree
search process constrained using control rules.

3. Search Control Rules
forward-chaining planner, TALplanner searches plan tree root
corresponds initial state outgoing edge corresponds one
operators applicable source node. Two trivial examples shown Figure 2,
notation [s,t] means action executed time time t.
sequential planning (Figure 2a), new action always added time step
previous action ended. concurrent planning (Figure 2b), TALplanner still adds single
action time plan, constraint time action executed
relaxed: action must start start existing action current
plan prefix end existing action. searching tree, preference
given actions invoked earlier timepoints. words, TALplanner tries add
many applicable actions possible timepoint stepping next
timepoint, Figure 2b subtree starting [0,4] A3, executing action A3
time 0 time 4, would explored backtracking subtree starting
[2,5] A3, A3 happens take slightly less time execute due differences
state action invoked. search process ends soon planner
found plan ending state satisfying goal. exact definition search tree
available Kvarnstrom Doherty (2000) sequential TALplanner Kvarnstrom
et al. (2000) concurrent TALplanner.
Although common view node search tree consisting single state,
operator function states states, sufficient TALplanner,
several reasons: single operator may generate multiple new states, evaluation
temporally extended goal domain-dependent control rule may require access
entire state history beginning initial state, concurrent planning future

348

fiTALplanner IPC-2002: Extensions Control Rules

Initial
node

[0,1] A1

[3,4] A1
[4,7] A3

[0,3] A2
[0,2] A3

0

1

Initial
node

[0,3] A2

3

4

[3,4] A1

[0,1] A1

[0,3] A2

[1,12] A4

[0,4] A3
[2,5] A3

[0,2] A3

Goal
node

2

[0,1] A1

0

5

Goal
node

1

2

3

4

5

[0,3] A2

[4,7] A3

[0,1] A1

[0,3] A2

(a) Sequential

[2,5] A3

(b) Concurrent

Figure 2: Forward-Chaining Search Space
state may modified several operators reaches final configuration.
reasons, convenient view node consisting state sequence,
(equivalently) logical model, indicated figure.
simple forward-chaining planner implemented searching tree using
standard search algorithm, iterative deepening depth first search. although
using complete search algorithm clearly enough make planner complete,
equally clear certain degree goal-directedness required make search process
efficient. achieved using domain-dependent control rules.
3.1 Using Domain-Dependent Control Rules
fully automated planning, planner generally supplied initial state,
set acceptable goal states (often specified using propositional first-order formulas
must hold goal state), set operators used plan.
planner determine search plan efficiently, possible exception
various command line options fine-tuned user.
However, cases user additional information planning domain
could use planner, information may difficult extract mechanically
simple domain specification. case, would make sense allow user
supply information planner. Although entails somewhat work
user, may lead finding plans quickly finding plans higher quality.
course many different kinds additional information could given
planner. TALplanner (inspired TLplan, Bacchus & Kabanza, 2000) allows
user specify set first-order TAL formulas must entailed final plan.
serves two separate purposes. First, allows specification complex temporally
extended goals safety conditions must upheld throughout execution
plan, second, additional constraints final plan often allow planner
prune entire branches search tree, since proven leaf branch
violate least one goal. many cases pruning main reason
use formula, case often called control rule. (Allowing planner
prune branches efficiently requires additional analysis, described Kvarnstrom,
2002.)
349

fiKvarnstrom & Magnusson

3.2 Control Rules Logistics Domain
following control rules use logistics domain. control
rule examples given IPC-2002 benchmark domains discussed.
First, package loaded onto plane plane required move it,
i.e., goal requires location another city. Second, unloaded
package plane, package must arrived correct city satisfying goal.
Third, package destination, moved.
#control :name only-load-when-necessary
[t] in(obj, plane) at(obj, loc)
loc [ goal (at(obj, loc)) [t] city of(loc) =
6 city of(loc) ]
[t+1] in(obj, plane)
#control :name only-unload-when-necessary
[t] in(obj, plane) at(plane, loc)
loc [ goal (at(obj, loc)) [t] city of(loc) =
city of(loc) ]
[t+1] in(obj, plane)
#control :name objects-remain-at-destinations
[t] at(obj, loc) goal (at(obj, loc)) [t+1] at(obj, loc)
Note rules could course expressed various logically equivalent
forms. variations would identical performance, since TALplanner internally
normalizes many aspects control formulas domain analysis phase.

4. Third International Planning Competition
second international planning competition (IPC-2000), planning domains used
mainly STRIPS expressivity. Support typed objects required,
domains could use ADL-style quantified conditional effects, restricted STRIPS
versions provided.
Although expect increase expressivity third competition (IPC2002), quite surprised extent changes. Fortunately, TALplanner
already supported many new requirements, others easily implemented. Despite make rather significant changes order handle
combination extensions efficiently. discuss
new requirements affected TALplanner together improvements
prompted domains used competition.
4.1 ADL-style Operator Definitions
Though STRIPS versions planning domains IPC-2002,
complex versions domains required use quantified conditional effects.
current planners, TALplanner limited STRIPS expressivity already
support this.

350

fiTALplanner IPC-2002: Extensions Control Rules

4.2 Numeric Types Arithmetic
IPC-2000 domains required numeric values emulated values using ordinary
objects. Miconic-10 elevator domain, example, floor numbers emulated using
objects named f0, f1, on. next floor calculated f + 1 using
explicitly defined predicate above(floor, floor).
approach taken simplest versions IPC-2002 domains,
Numeric versions domains numeric types required
arithmetic operators used. already supported TALplanner,
unfortunately enough time write control rules domains.
4.3 Concurrency
Despite fact IPC-2000 domains provided potential using concurrent
actions, driving several trucks concurrently logistics domain,
reward exploiting potential. Plan quality measured terms number
operators plan, terms amount time required execute plan.
Consequently, several planners (including TALplanner) generated sequential plans,
even highly concurrent domains.
IPC-2002, plan quality mainly measured terms timepoint
last operator finished executing (the makespan plan, scheduling terms),
planner generating sequential plans would severely handicapped. Fortunately
concurrent version TALplanner already implemented, together support
resources (Kvarnstrom et al., 2000), could used competition.
Although concurrent TALplanner already applied number domains,
competition provided us varied set domains sometimes exploited
concurrency slightly different ways. provided us new ideas improvements
TALplanner, several minor enhancements TALplanners formula analysis algorithms
implemented first phase competition, allowing handle certain
types control formulas efficiently concurrent planning.
4.4 Operators Non-Unit Context-Dependent Duration
IPC-2000, plan operator used single time step. SimpleTime Timed
versions IPC-2002 planning domains, operators could non-unit duration,
(for example) walking requires time driving. already supported
TALplanner, changes required.
Timed versions IPC-2002 planning domains, durations operators could context-dependent, could specified using arithmetic expressions,
requiring support numeric types already discussed above. example, time
required drive truck two locations could specified distance
locations divided speed particular truck. already supported
TALplanner.
TALplanner permits effects take place multiple timepoints within duration
action, although used competition.

351

fiKvarnstrom & Magnusson

4.5 Non-Integer Time
IPC-2002 contest domains required operator durations calculated
precision least three decimals, posed problem us. underlying TAL-C
logic based integer time, therefore true TALplanner. Introducing
non-integer time properly would required changes underlying TAL semantics,
could done time available, therefore simply multiplied
durations thousand. printing plan, time values divided thousand.
4.6 Operators Extended Duration
initial implementation TALplanner (in 19981999), assumed although
operators might extended durations, something interesting would happening
significant proportion discrete time steps within duration. example,
operator invoked might duration 5 time steps, effects take place
time + 1, time + 4, time + 5. assumption influenced
algorithms data structures TALplanner, appeared reasonable time,
since planning domains literature used single-step operators.
Nevertheless, always intention extend algorithms structures
handling plans sparse effects, discrete time steps contain effects all.
would difficult, partly reason
interesting research issues tackled instead continuously postponed.
IPC-2002 finally provided us compelling reason change data structures,
together number example domains could used test changes.
example, operator timed domain IPC-2002 might duration (say)
89.237, requiring 89237 discrete time steps, effects take place beginning
end action. led us implement new sparse state structure
change algorithms whose time complexity accidentally depended duration
operator rather number time steps something actually happened.
current version TALplanner allows state structures used depending
characteristics planning domain.
4.7 Moving Targets Rule
already mentioned, TALplanners semantics based use TAL, planning competition uses PDDL2.1. semantic differences two approaches usually major problem, trouble way
effects durative actions modeled PDDL2.1. essence, PDDL2.1 predicates
numerical fluents affected effects action considered moving
targets, preconditions another action allowed refer
timepoint. Instead, certain intermediate interval (arbitrarily chosen 0.001
units time) required assertion fact subsequent use
fact, even beginning plan actions cannot begin exactly time 0.
TAL, effects taking place time assumed give fluents new values exactly
timepoint, values immediately used. uncertainty
exact time effect takes place, one example explicitly state

352

fiTALplanner IPC-2002: Extensions Control Rules

value unknown inner part certain interval known end
interval (though yet implemented TALplanner).
Changing TALplanner use exact PDDL2.1 semantics question,
since would change fundamental assumptions planner. Instead
necessary come workaround let us simulate semantics.
several ways could done. One method would involve making minor changes
action definitions order assert final effects action slightly later (0.001
units time later, exact). competition instead implemented trivial
modification way plan printed: timepoint something happens
plan (for example, operator invoked), additional delay 0.001 inserted.
ensures plans safe according PDDL2.1 semantics sometimes leads
generating slightly worse plans necessary.
4.8 Finding Shortest Paths
Rover DriverLog domains, vehicles and/or people must travel along road networks, different roads may different costs (lengths) essential
take shortest path two points.
Although possible define shortest path algorithm using TALplanners input
language, formulas become somewhat complicated. Finding shortest path
two locations weighted graph places roads seems useful many domains,
therefore algorithm implemented directly planner.
fact, two algorithms implemented: One finding cost shortest
path two given locations, one finding distance closest location
satisfying given formula (for example closest location reasonable destination
certain truck DriverLog domain). functions called control
rules order ensure step one takes leads location shortest
path current destination.

5. Modeling Competition Domains
eight planning domains third International Planning Competition, six intended hand-tailored planners. Except final domain, UMTranslog-2, domains
exist least four different variations: STRIPS, Numeric (where numeric quantities
involved), SimpleTime (where operators take constant non-unit time), Timed (where
operator durations may depend actual parameters specific operator invocation).
TALplanner participated six domains, due lack time creating control
rules, limited participation STRIPS, SimpleTime, Timed versions
domains.
section describe domains translated PDDL2.1
TALplanner, discuss control rules created handle domains
efficiently. main focus two domains: ZenoTravel Satellite.
domains describe control rules used competition well
incremental process creating rules, omitting technical details
couple complex rules turned minimal impact planner performance
plan quality. remaining domains (Depots, DriverLog, Rovers, UMTranslog-2)
353

fiKvarnstrom & Magnusson

describe general intuitions behind control rules, omitting actual formulas
due space restrictions. First, though, begin comments process
formalizing planning domains.
5.1 Using Pre-defined PDDL Domains: Half Work Twice Time?
order create formal description real-world planning domain, course always
necessary thorough understanding domain plans
domain eventually going used. several reasons required,
reasons equally valid regardless whether formalization
eventually used input fully automated planner hand-tailored planner
TALplanner.
First, understanding domain required order determine aspects
domain truly need modeled (as types, predicates functions) aspects
abstracted away. example, standard formalization logistics domain
model distances locations, allows trucks move two
locations one time step. sufficient purposes, plan optimal
given abstraction may extremely suboptimal actually carried real trucks,
usually lack teleportation abilities. Similarly, model package sizes
weights, cargo capacities trucks airplanes. Neither model truck drivers,
acceptable working hours drivers, additional costs incurred overtime pay, time
required maintenance activities changing winter tires year.
aspects need modeled depends much particular application one
mind.
Second, detailed understanding domain required order determine
operators available planner exactly preconditions effects
represented within abstract logical model domain.
finally, hand-tailored planners, domain must understood order
able guide search algorithm using domain-dependent heuristics control rules.
Usually aspects domain modeled time, much
information knowledge domain gathered order find suitable
set predicates operators needed even fully automated planner
reused development control rules heuristics hand-tailored planner.
planning competition, however, task divided two parts: organizers
define set domains using PDDL2.1, competitors handtailored track find suitable ways guiding planners. one way, one could say
competitors need half work, since formalization already done
task finding control rules remains. Unfortunately still necessary
understand domain thoroughly order write control rules.
complex domains, half work isolation might easily take twice time,
since constraints involved domain understood PDDL2.1
formalization rather talking domain experts. especially true
complex UMTranslog-2 logistics domain, significant amount time spent
trying determine exactly packages allowed move
loaded unloaded various kinds vehicle.

354

fiTALplanner IPC-2002: Extensions Control Rules

Figure 3: ZenoTravel problem instance (STRIPS problem 6)
Another problem caused use predefined formalization planning
domain degree detail used model determined advance. real
world would likely minimum level detail required, anything
level would acceptable. may seem problem intuitively,
adding new details planning problem ought make harder, would best
remain minimum level detail. always true, especially
control rules involved. seen timed ZenoTravel domain, example,
control rules would simpler effective possible refuel
specific level, real world, rather simple abstract refuel
operator unconditionally fills tank completely.
taken complaint organization competition
allowing different planners use different formalizations would course completely
infeasible. Nevertheless, present additional problems encountered
degree real-world domains deserve mentioned here.
5.2 ZenoTravel Domain
ZenoTravel domain, number aircraft fly people cities.
five actions available: Persons may board debark aircraft, aircraft may fly,
zoom (fly quickly, using fuel), refuel. restrictions many people
aircraft carry. Flying zooming equivalent except zooming generally
faster uses fuel. Figure 3 shows example problem, arrows pointing
goal locations.
5.2.1 ZenoTravel: STRIPS
show operator definitions STRIPS version ZenoTravel domain.
operators less directly translated PDDL representation.
main difference PDDL representation uses PDDL2.1 level 1, single-

355

fiKvarnstrom & Magnusson

step actions, stricter concept mutual exclusion TALplanner
automatically enforces certain invariants, fact aircraft leave
person boarding, location aircraft modified fly used
precondition board. TAL-C semantics used TALplanner similar
PDDL2.1 level 3 (with durative actions), invariant conditions must stated
explicitly. done using prevail conditions, considered separate
true pre-conditions. Note STRIPS formalization fly zoom take
amount time, since single-step actions possible.
#operator
:precond
:prevail
:effects

board(person, aircraft, city ) :at
[t] at(person, city ) at(aircraft, city )
[t+1] at(aircraft, city )
[t+1] at(person, city ) := false, [t+1] in(person, aircraft) := true

#operator
:precond
:prevail
:effects

debark(person, aircraft, city ) :at
[t] in(person, aircraft) at(aircraft, city )
[t+1] at(aircraft, city )
[t+1] in(person, aircraft) := false, [t+1] at(person, city ) := true

#operator fly(aircraft, city1 , city2 , flevel1 , flevel2 ) :at
:precond [t] at(aircraft, city1 ) fuel-level(aircraft, flevel1 ) next(flevel2 , flevel1 )
:effects
[t+1] at(aircraft, city1 ) := false, [t+1] fuel-level(aircraft, flevel1 ) := false,
[t+1] at(aircraft, city2 ) := true, [t+1] fuel-level(aircraft, flevel2 ) := true
#operator zoom(aircraft, city1 , city2 , flevel1 , flevel2 , flevel3 ) :at
:precond [t] at(aircraft, city1 ) fuel-level(aircraft, flevel1 )
next(flevel2 , flevel1 ) next(flevel3 , flevel2 )
:effects
[t+1] at(aircraft, city1 ) := false, [t+1] fuel-level(aircraft, flevel1 ) := false,
[t+1] at(aircraft, city2 ) := true, [t+1] fuel-level(aircraft, flevel3 ) := true
#operator
:precond
:prevail
:effects

refuel(aircraft, city , flevel, flevel1 ) :at
[t] fuel-level(aircraft, flevel) next(flevel, flevel1 ) at(aircraft, city )
[t+1] at(aircraft, city )
[t+1] fuel-level(aircraft, flevel) := false, [t+1] fuel-level(aircraft, flevel1 ) := true

translating operator definitions, time create set control rules.
basically two ways this: First, one sit think suitable
properties plan, write control rules ensure properties
hold. Second, one instruct planner show branch explored
search tree, observing output one identify obviously stupid choices made
planner, choosing action instance inevitably leads backtracking
performing actions useless given goals. Control rules written
prevent branches tree explored. approaches
covered here.
begin first method, attempting find number reasonable control rules
simply thinking properties ZenoTravel domain. Given experience
planning domains, fact quite easy. example, many domains
certain goals satisfied, one never allow
356

fiTALplanner IPC-2002: Extensions Control Rules

destroyed. ZenoTravel domain, people destinations never need
board aircraft, gives rise following control rule:
#control :name only-board-when-necessary
[t] in(person, aircraft) [t+1] in(person, aircraft)
city , city2 [ [t] at(person, city ) goal(at(person, city2 )) city 6= city2 ]
TAL formula states state transition person
aircraft time person aircraft time + 1, (that is, person
boarded aircraft), must reason allowed: person must
certain city must goal person another city.
noted previously control formulas usually written many different forms.
example, would equally valid state person city (and
therefore aircraft), required somewhere else, next
timepoint person still board aircraft:
#control :name only-board-when-necessary
[t] at(person, city ) city2 [ goal(at(person, city2 )) city 6= city2 ]
[t+1] in(person, aircraft)
Note although may first glance appear planner would extraordinarily stupid destroy goals already satisfied, many cases
temporarily destroying goal necessary order satisfy goals. example, goal certain aircraft certain location already
reached destination, might still fly number people destinations
return destination.
Another natural idea (since aircraft follow predetermined routes ZenoTravel,
usually real life) would say people debark
reached final destination:
#control :name only-debark-when-in-goal-city
[t] in(person, aircraft) [t+1] in(person, aircraft)
city [ [t] at(aircraft, city ) goal(at(person, city )) ]
potential problem rule: cases optimal plan might require
number people debark one plane board number planes, could
fly destination concurrently, strictly forbidden only-debark-whenin-goal-city. common problem occurs many planning domains,
user determine depending requirements application
planner used.
number possible choices: could ignore problem accept suboptimal plans, skip rule completely let planner search vastly greater
search space order find plan guaranteed optimal, compromise,
attempt create weaker rule cut search space degree
gives optimal closer-to-optimal plans. planning competition conditions
somewhat artificial clearly stated would beneficial planner
spend ten times much effort finding plan plan five percent better,
average? guessed would case, consequently chose include
control rule stated above.
357

fiKvarnstrom & Magnusson

future, better solution would likely prefer plans person
debark reaching destination still allow plans. alternative
discussed detail conclusions.
Given two rules, might continue second approach finding
control rules. run TALplanner simple problem instance consider operator
sequences planner examines depth-first search process. beginning
sequence problem instance Figure 3. complete plan generated
planner contains 123 operators requires 60 time steps. shown IPC-2002
STRIPS result format timepoint action invoked followed
action instance.
0:
0:
1:
1:
2:
2:
3:
3:

(board person4 plane2 city1)
(board person5 plane1 city2)
(fly plane1 city2 city0 fl5 fl4)
(fly plane2 city1 city0 fl3 fl2)
(board person1 plane1 city0)
(board person2 plane2 city0)
(fly plane1 city0 city1 fl4 fl3)
(fly plane2 city0 city1 fl2 fl1)

4:
4:
5:
5:
6:
6:
7:
7:

(debark person2 plane2 city1)
(debark person5 plane1 city1)
(fly plane1 city1 city0 fl3 fl2)
(fly plane2 city1 city0 fl1 fl0)
(fly plane1 city0 city1 fl2 fl1)
(refuel plane2 city0 fl0 fl1)
(fly plane1 city1 city0 fl1 fl0)
(fly plane2 city0 city1 fl1 fl0)

8: (refuel plane1 city0 fl0 fl1)
8: (refuel plane2 city1 fl0 fl1)
9: (fly plane1 city0 city1 fl1 fl0)
9: (fly plane2 city1 city0 fl1 fl0)
10: (refuel plane1 city1 fl0 fl1)
11: (fly plane1 city1 city0 fl1 fl0)
11 : (refuel plane2 city0 fl0 fl1)
...

beginning operator sequence appears reasonable, time 4, airplanes
seem flying around randomly. control rules guiding them, apparently
mainly luck caused planes find reasonable cities fly time 1 3.
make airplanes goal-directed, identify three important reasons airplane
move city city2: goal asserts aircraft must end city2
plan complete, one passengers wants go city2,
person waiting picked airplane city2. following rule formalizes
three intuitions:
#control :name planes-always-fly-to-goal
[t] at(aircraft, city ) [t+1] at(aircraft, city )
city2 [ [t+1] at(aircraft, city2 )
(goal(at(aircraft, city2 ))
person [ [t] in(person, aircraft) goal(at(person, city2 )) ]
person [ [t] at(person, city2 ) goal(at(person, city2 )) ]) ]
control rules, TALplanner quickly produce set plans 20 handcoded problems IPC-2002 competition, although plans optimal, nearly bad example given above. Together, plans require
total 7164 operators 618 time steps. plan example Figure 3 requires
20 operators 7 time steps.
Nevertheless, still improvements made. first criterion
admissible: allows plane visit destination even still needs pick
drop passengers. One way preventing would add condition
passengers must reached destinations:
#define [t] all-persons-arrived:
person, city [ goal(at(person, city )) [t] at(person, city ) ]

358

fiTALplanner IPC-2002: Extensions Control Rules

#control :name planes-always-fly-to-goal
[t] at(aircraft, city ) [t+1] at(aircraft, city )
city2 [ [t+1] at(aircraft, city2 )
([t] all-persons-arrived goal(at(aircraft, city2 ))
person [ [t] in(person, aircraft) goal(at(person, city2 )) ]
person [ [t] at(person, city2 ) goal(at(person, city2 )) ]) ]
improves plan quality slightly, TALplanner requires 7006 operators 575
time steps. new control rule fact strict, seen following
plan tail handcoded STRIPS problem number 3:
14:
14:
14:
14:
15:
15:
15:

(fly plane2 city4 city7 fl2 fl1)
(fly plane4 city8 city9 fl3 fl2)
(refuel plane1 city6 fl2 fl3)
(refuel plane3 city9 fl4 fl5)
(debark person24 plane4 city9)
(debark person28 plane4 city9)
(debark person34 plane2 city7)

15:
15:
15:
15:
16:
16:

(refuel plane1 city6 fl3 fl4)
(refuel plane2 city7 fl1 fl2)
(refuel plane3 city9 fl5 fl6)
(refuel plane4 city9 fl2 fl3)
(fly plane1 city6 city8 fl4 fl3)
(fly plane3 city9 city4 fl6 fl5)

example, plane1 plane3 wait passengers debarked
several planes could go final destinations, even though
clearly see real reason wait, potential passengers
already picked plane1 plane3 already enough fuel.
alter control rule according new insight: plane go final destination
passengers board plane headed towards destination
person left picked (that is, persons already arrived currently
board planes).
#define [t] all-persons-arrived-or-in-planes:
person, city [ goal(at(person, city )) [t] at(person, city ) aircraft [ in(person, aircraft) ] ]
#control :name planes-always-fly-to-goal
[t] at(aircraft, city ) [t+1] at(aircraft, city )
[t+1] at(aircraft, city2 )
((goal(at(aircraft, city2 )) [t] all-persons-arrived-or-in-planes
person [ [t] in(person, aircraft) goal(at(person, city2)) ])
person [ [t] in(person, aircraft) goal(at(person, city2 )) ]
person [ [t] at(person, city2 ) goal(at(person, city2 )) ])]
yields another minor improvement, TALplanner requires 6918 operators
564 time steps. example used above, end plan looks follows:
14:
14:
14:
14:

(fly plane1 city6 city8 fl2 fl1)
(fly plane2 city4 city7 fl2 fl1)
(fly plane4 city8 city9 fl3 fl2)
(refuel plane3 city9 fl4 fl5)

15:
15:
15:
15:

(debark person24 plane4 city9)
(debark person28 plane4 city9)
(debark person34 plane2 city7)
(fly plane3 city9 city4 fl5 fl4)

study plans generated current set rules quickly identify
another obvious problem: number airplanes may fly location pick
person. again, necessary find reasonable balance finding
optimal plans finding plans quickly. contest, attempted find high quality
359

fiKvarnstrom & Magnusson

(but probably non-optimal) plan quickly possible. done ensuring
one airplane may go given place time, sole purpose
going pick person waiting:
#control :name planes-always-fly-to-goal
[t] at(aircraft, city ) [t+1] at(aircraft, city )
city2 [ [t+1] at(aircraft, city2 )
((goal(at(aircraft, city2 )) [t] all-persons-arrived-or-in-planes
person [ [t] in(person, aircraft) goal(at(person, city2 )) ])
person [ [t] in(person, aircraft) goal(at(person, city2 )) ]
person [ [t] at(person, city2 ) goal(at(person, city2 )) ]
aircraft2 [ [t+1] at(aircraft2, city2) aircraft2 6= aircraft ])]
rule provides major improvement, complete set plans requires 5075
operators 434 time steps.
far, controlled airplanes fly, people board airplane,
debark. rules governing refueling, quick look plan one
larger problem instances reveals whenever aircraft nothing else do,
refuel. seems little bit wasteful, satisfied adding rule stating
airplanes must refuel tanks empty. rule perfect, since
airplane may miss opportunity pre-emptively refuel still refuel one fuel
level even going fly, provide significant improvement, bringing
number operators 4234. number time steps still 434.
minor adjustments made rules used competition. adjustments include modification only-board-when-necessary ensure
person must travel city city2 choose plane already needs
visit city city2 , possible, since less likely increase total
number flights.
One final change prompted fact intended differences timing
fly zoom cannot modelled correctly STRIPS version domain. Since
operators must take amount time, difference two
operators zoom uses twice much fuel. Although would possible
add control rule ensuring zoom used, easier simply remove
zoom operator domain definition.
5.2.2 ZenoTravel: SimpleTime
SimpleTime version ZenoTravel quite similar STRIPS version,
difference actions may non-unit duration certain preconditions
must hold throughout execution action. TALplanner operator definitions
changed accordingly. example, board fly operators changed follows:
#operator board(person, aircraft, city ) :at
:precond [t] at(person, city ) at(aircraft, city )
:prevail
[t+1, t+20] at(aircraft, city )
:duration 20
:effects
[t+1] at(person, city ) := false, [t+20] in(person, aircraft) := true

360

fiTALplanner IPC-2002: Extensions Control Rules

Figure 4: ZenoTravel problem instance (SimpleTime problem 3)
#operator fly(aircraft, city1 , city2 , flevel1 , flevel2 ) :at
:precond [t] at(aircraft, city1 ) fuel-level(aircraft, flevel1 ) next(flevel2 , flevel1 )
:duration 180
:effects
[t+1] at(aircraft, city1 ) := false, [t+1] fuel-level(aircraft, flevel1 ) := false,
[t+180] at(aircraft, city2 ) := true, [t+180] fuel-level(aircraft, flevel2 ) := true
run planner set SimpleTime problem instances, get almost immediate
results: planner claims plan instances. reason
is, course, control rules must satisfied valid plan, rules
designed underlying assumption actions unit duration. example,
consider planes-always-fly-to-goal, states plane leaves city time t,
meaningful destination t+1. fly action invoked plane must
city city1 , beginning next time step interval
aircraft present city all, finally arrives city2 180 time steps later.
words, planes-always-fly-to-goal ensures fly operator cannot used
all, quite originally intended.
One way solving problem would alter planes-always-fly-to-goal say
plane leaves city time t, meaningful destination t+180. Unfortunately, duration flight would encoded directly control rule instead
operator, would work Timed version, operators
variable durations fact, would even work SimpleTime, zoom
operator must taken account.
Instead, domain model augmented new fluent flying-to(aircraft, city)
keeps track whether plane flying, so, destination is. ensure
fluent kept up-to-date, following added effects fly zoom operators:
[t+1] flying-to(aircraft, city2 ) := true, [t+180] flying-to(aircraft, city2 ) := false // fly
[t+1] flying-to(aircraft, city2 ) := true, [t+100] flying-to(aircraft, city2 ) := false // zoom
planes-always-fly-to-goal rule changed follows, stating
aircraft ceases city , must flying reasonable destination:
#control :name planes-always-fly-to-goal
[t] at(aircraft, city ) [t+1] at(aircraft, city )
city2 [ [t+1] flying-to(aircraft, city2 ) . . . ]
problem arises boarding, new fluent boarding(person, aircraft) added
used whenever necessary. Given changes, following first steps
361

fiKvarnstrom & Magnusson

plan generated TALplanner problem instance Figure 4, shown IPC-2002
timed result format timepoint action invoked followed
action instance duration action:
0: (board person1 plane1 city0) [20]
20: (fly plane1 city0 city1 fl4 fl3) [180]
20: (zoom plane1 city0 city1 fl4 fl3 fl2) [100]
Intuitively, flying zooming plane1 time impossible,
forgotten specify planner. actions preconditions satisfied
time 20, prevail conditions, effects actions contradict
since take place different timepoints: fly ends time 200, zoom
ends time 120.
several ways specifying fly zoom mutually exclusive.
example, would possible introduce interval effect stating flying-to(aircraft,
city2 ) must hold throughout inner execution intervals actions, become false
end action:
[t+1,t+179] flying-to(aircraft, city2 ) := true, [t+180] flying-to(aircraft, city2 ) := false // fly
[t+1,t+ 99] flying-to(aircraft, city2 ) := true, [t+100] flying-to(aircraft, city2 ) := false // zoom
would possible use semaphore resource: aircraft-specific resource
initial value 1, borrowed exclusively fly zoom actions.
one solutions used, TALplanner finally rewards us short correct plan:
0: (board person1 plane1 city0) [20]
20: (fly plane1 city0 city1 fl4 fl3) [180]
200: (board person3 plane1 city1) [20]
200: (debark person1 plane1 city1) [30]
230: (fly plane1 city1 city0 fl3 fl2) [180]
410: (debark person3 plane1 city0) [30]
;; Plan length 6, maxtime 440
improved? Remember STRIPS version never made use zoom
operator. SimpleTime version, flying takes 180 time steps uses one unit
fuel, zooming takes 100 time steps uses two units fuel, refueling one unit
takes 73 time steps. 180 + 73 100 + 2 73 therefore opposite
situation: zoom always better fly. Commenting unwanted fly operator yields
following plan:
0: (board person1 plane1 city0) [20]
20: (zoom plane1 city0 city1 fl4 fl3 fl2) [100]
120: (board person3 plane1 city1) [20]
120: (debark person1 plane1 city1) [30]
150: (zoom plane1 city1 city0 fl2 fl1 fl0) [100]
250: (debark person3 plane1 city0) [30]
;; Plan length 6, maxtime 280

362

fiTALplanner IPC-2002: Extensions Control Rules

5.2.3 ZenoTravel: Timed
Timed version complicates timing actions. Boarding disembarking times constant problem-specific defined respective problem
definition two new functions, boarding-time debarking-time. Refueling always fills
plane maximum capacity, consumes time relative amount fuel received
refuel-rate aircraft. aircraft fast-speed slow-speed
corresponding fast-burn slow-burn fuel consumption. distances cities
specified using distance(city1, city2 ) function.
Timed version, operator durations correctly calculated precision
three decimals, prompting TALplanner changes discussed Sections 4.5 4.6.
extensions TALplanner implemented, changes needed
transform SimpleTime domain Timed version.
important difference perhaps fact depending speed fuel
consumption values defined problem situation operator used,
sometimes better use fly operator sometimes better use zoom operator,
unlike STRIPS version fly always better SimpleTime domain
zoom always better.
zooming better flying? may seem would easy answer
question, given interested minimizing time: check whether
refueling aircraft sufficiently able zoom, followed zooming destination,
would faster refueling enough able fly flying slowly
destination. handled first clause use-fly-instead-of-zoom below.
precondition fly altered require use-fly-instead-of-zoom true,
precondition zoom requires use-fly-instead-of-zoom false. interested
minimizing combination time fuel usage, could taken
account.
quite sufficient handle problems, though. airplane maximum
fuel capacity, destination distant, may able zoom. handled
second clause use-fly-instead-of-zoom.
Yet another problem possible tie one refueling action flight,
one would expect real world. two reasons problem.
First, airplanes may already fuel initial state, situations
plane might zoom destination without incurring additional cost, assuming
time required executing plan metric used plane
already enough fuel anyway never refuel.
Second, unlike SimpleTime version, airplane cannot refuel enough
refuel operator always fills tank completely. change likely introduced
order make planning task easier reducing number possible actions choose
(for example, planner needs create ground instances operator
might trouble refuel operator would take amount fuel floating
point argument). despite probable intention behind change, introduces new
problems control formulas. planes tank half full enough fuel
zoom B, might fill entire tank continuing C,
used fly operator, might able continue C without refueling all.

363

fiKvarnstrom & Magnusson

means one would take possible future flights account determining
whether fly zoom. domain modeled detail, problem would
existed.
Given two complications, guaranteeing optimal near-optimal plan using
control rule easy, indeed expected. competition decided
satisfied heuristic compromise, adding third clause use-fly-instead-of-zoom
ensuring zooming would require refueling immediately flying would not, fly
operator would used.
// Fly (probably) better zoom if:
#define [t] use-fly-instead-of-zoom(aircraft, city1, city2):
// fly faster wrt speed refueling.
([t] (10000 / slow-speed(aircraft) + 10000 * slow-burn(aircraft) / refuel-rate(aircraft)) <
(10000 / fast-speed(aircraft) +10000 * fast-burn(aircraft) / refuel-rate(aircraft)))
// zoom impossible across given distance.
([t] distance(city1 , city2 ) * fast-burn(aircraft) > capacity(aircraft))
// zoom refuel immediately fly not.
([t] fuel(aircraft) >= distance(city1 , city2 ) * slow-burn(aircraft)
fuel(aircraft) < distance(city1 , city2 ) * fast-burn(aircraft))
5.2.4 ZenoTravel: Discussion
Finding control rules yield good (but usually suboptimal) plans difficult
ZenoTravel domain. risks involved flying plane pick passengers
since passengers always fit plane refueling possible city.
words, really possible get stuck looking solution. Also, since
graph cities fully connected, route planning necessary.
fourth version ZenoTravel, called Numeric, available contest due
lack time decided compete domain.
Among things, numeric version contains additional constraint number passengers aircraft carry. first glance, constraint may seem
introduce new problems. However, enforced zoom operator, since
numeric domain make use durational operators, suffers problem
STRIPS domain: zoom operator consumes fuel limits number
passengers, deliver advantages faster flying.
real difficulty Numeric version comes use problem-specific metrics
measure quality solution. example, one problem planner may
required minimize total-time + 3 * total-fuel-used, another problem may
required minimize total-time only. now, usually satisfied finding
plans good optimal quality, done tuning control rules,
example introducing use-fly-instead-of-zoom function determine whether fly
zoom used, discussed above. tuning naturally done domain level
rather problem level. optimizing version TALplanner development.

364

fiTALplanner IPC-2002: Extensions Control Rules

Figure 5: Depots problem instance (STRIPS problem 7)
5.3 Depots Domain
Depots domain (illustrated Figure 5) contains locations, trucks, hoists, movable
crates, pallets whose locations fixed. Trucks move crates two locations
carry number crates time. Hoists distributed among
locations load crates trucks stack crates surfaces (pallets crates).
goal always bring crates certain configuration stacks,
stack placed specific pallet.
STRIPS. Depots domain combination two well-known planning domains,
logistics domain blocks world. Therefore seems natural start taking
look existing control rules two domains, see whether rules
combined easily whether complex rules required due interactions
moving stacking blocks.
begin blocks world part problem. unbounded blocks world
used benchmark domain IPC-2000, TALplanner used modified version
rules Bacchus Kabanza (2000) ensure planner adds blocks
good towers, stacks already final position
dismantled later order remove block lower level. rules reused
Depots domain? One prerequisite availability temporary storage crates,
since worst case every single stack crates must torn completely
possible start stacking crates top other. Fortunately, although
limited number pallets, trucks (somewhat counter-intuitively) contain number
crates, planner use storage. minor changes required
order handle two separate types surfaces: Pallets crates.
Continuing logistics part, one simple rule reused standard
logistics domain: unload crate goal location. dual rule, load crate
needs moved, required. blocks world rules ensure hoist
lift block unless needs moved, therefore already impossible load
blocks truck.
remains ensure vehicles drive locations use.
standard logistics domain, truck drive another location package
365

fiKvarnstrom & Magnusson

Figure 6: DriverLog problem instance (STRIPS problem 5)
needs picked delivered there, due use stacks crates
depots domain, rule must modified: vehicle may drive location (1)
crate must moved another location, (2) crate must
stacked differently, (3) crate truck needs location,
destination ready, crate location
truck yet picked up.
SimpleTime. SimpleTime version, lifting dropping crates still takes one unit
time, loading takes three units, unloading four, driving ten. changes made
ensure mutual exclusion. example, hoists lift one crate time. Also,
driving-to fluent introduced keep track trucks headed, similar flying-to
ZenoTravel.
Timed. Timed domain, time required loading unloading crate depends powerful hoist weight crate. time required
driving two locations depends speed truck distance
locations. Again, minor changes required handle domains, although
higher quality plans could certainly produced taking timing account
determining hoists trucks use.
5.4 DriverLog Domain
DriverLog (illustrated Figure 6) yet another logistics domain, time introducing
concept truck drivers road maps. number packages transported
locations trucks. two sets routes connecting locations: Links,
trucks travel, paths, drivers walk along driving truck. truck
one driver time load many packages needed.
STRIPS. Several control rules used previous logistics domains useful DriverLog
minor modifications. example, packages loaded trucks
need moved, unloaded reached final destination.
hand, number changes necessary due use road maps.
importantly, vehicles previously allowed drive locations immediately useful packages picked delivered. DriverLog
366

fiTALplanner IPC-2002: Extensions Control Rules

domain may direct roads locations (specified predicate
link(from, to)), truck may move several intermediate locations
order reach destination. Consequently control rules must relaxed allow
trucks visit locations useful themselves. Nevertheless, degree
goal-directedness still required. One possible method identify vehicle
set locations vehicle might useful, require chooses one
location takes shortest path chosen destination. method used
competition help built-in shortest path algorithm discussed Section 4.8 control rule stating step (each invocation drive walk) must
decrease distance current destination. following definitions explained
below:
#define [t] reasonable-truck-location(truck, location):
// Omitted due space constraints
#distfeature driving-distance-between(from, to) :domain integer :link link
#mindistfeature driving-distance-to-location-satisfying-formula
:distfeature driving-distance-between :domain integer
#define [t] driving-distance-to-reasonable-destination(truck, location):
driving-distance-to-location-satisfying-formula(location, to,
[t] reasonable-truck-location(truck, to))
boolean fluent reasonable-truck-location(truck, loc) defined terms logic formula,
specifies whether given location reasonable destination given truck
timepoint evaluated. driving-distance-between function accesses shortest
path algorithm find length shortest path to, given
road links specified link predicate. driving-distance-to-location-satisfyingformula function accesses another version shortest path algorithm used
driving-distance-to-reasonable-destination order find shortest distance location
location satisfies reasonable-truck-location. Since links cost,
sufficient require whenever truck moves, driving-distance-to-reasonabledestination decreases.
changes required due use drivers. may drivers
trucks, packages loaded truck planner knows truck
driver. Drivers disembark still packages truck,
goal truck must somewhere else. Drivers may walk along
paths order reach truck, trucks, drivers must select one useful destination
take shortest path chosen destinations.
Additional control rules ensure multiple trucks choose destination
unnecessarily, multiple drivers choose walk location.
SimpleTime. SimpleTime version, loading unloading objects takes two units
time, driving takes ten units, walking takes twenty units. operators changed
accordingly, going-to fluent introduced keep track drivers trucks
moving towards new location yet arrived. minor adjustments must
made control rules.
Timed. Timed version, time required walk drive two locations
367

fiKvarnstrom & Magnusson

determined pair functions specified problem instance. Since individual road
segments different lengths, method used ensure drivers trucks used
shortest path current destination longer sufficient, must modified
slightly. this, major changes Timed version.
5.5 Rovers Domain
Rovers domain simulates simplified planetary exploration expedition. lander vessel
carries number rovers planet surface provides communication link back
Earth. rover subset general capabilities, retrieving soil samples, retrieving
rock samples capturing images using cameras support different imaging modes.
cameras mounted rovers, storage compartments, one rover,
hold one soil sample one rock sample. Data sample must sent
lander communication link. missions revolve around navigating waypoints
planets surface collect samples take images specified objectives
visible certain waypoints. terrain may prevent rovers going directly
two waypoints different rovers handle different terrain list routes rover
use provided.
STRIPS. Following control scheme similar one used DriverLog, limit
movements rovers locations perform useful action collecting
rock sample capturing image. problem finding path one waypoint
another solved way DriverLog, except rover
set routes waypoints.
SimpleTime. changes SimpleTime version trivial: Operator durations
changed, mutual exclusion relations need enforced, new fluent calibrating(camera) keeps track whether certain camera calibrated.
Timed. Timed version introduces concept energy, rover limited
amount energy action consumes energy. similar
use fuel ZenoTravel domain, major difference: rovers
equipped solar panels recharge rover, waypoints
rover go directly exposed sun, requirement solar
panels work. airplanes ZenoTravel domain refuel anywhere, fuel
usage relevant terms minimization resource usage, whereas rover uses
energy unwisely get stuck shade, unable anything go anywhere.
prevent either let planner backtrack search better plan,
introduce stricter rules keep energy levels mind deciding rover
allowed do. latter approach taken below.
critical point rover enough energy reach waypoint
sun recharge. Using shortest path algorithm possible control rule
determine distance closest waypoint exposed sun. addition
waypoints previously allowed, reasonable rover go waypoint
exposed sun rover enough energy perform action
go recharge, exist waypoints affordable
reasonable visit.

368

fiTALplanner IPC-2002: Extensions Control Rules

Figure 7: Satellite problem instance (STRIPS problem 4)
5.6 Satellite Domain
Satellite domain number satellites orbit Earth, equipped set
scientific imaging instruments. satellites turn space, targeting stars, planets interesting phenomena capture images using different instrument operation modes.
modes include regular infrared imaging spectrographic thermographic
readings different problem. planners task schedule series observations satellites used efficiently. Figure 7 shows small example problem
instance, arrows showing directions satellites pointing.
Directions represented explicit coordinates. Instead, satellites turn
new direction giving turn operator argument specifying star, planet
phenomenon satellite point to. Instruments first need activated using
switch on, calibrated calibration target calibrate operator
capture images using take image. satellite enough power operate one
instrument time, switching active instruments always initiated switch
operator deactivate first instrument.
5.6.1 Satellite: STRIPS
Since task consists collecting number images, begin restricting use
take image images mentioned goal.
#control :name only-take-pictures-of-goals
[t] image(direction, mode) [t+1] image(direction, mode)
goal(have image(direction, mode))
next step restrict directions satellites turn may actually help collecting images. task split control rule, only-point-ingoal-directions, definition goal directions. satellite allowed turn towards
direction take picture, calibrate instrument goal specifies satellite

369

fiKvarnstrom & Magnusson

point direction work left do.
#define [t] goal direction(satellite, direction):
[t] take image possible(satellite, direction)
instrument [
[t] power on(instrument) calibrated(instrument)
[t] calibration target(instrument, direction) board(instrument, satellite) ]
goal(pointing(satellite, direction)) [t] images collected
take image possible function checks image collected
already taken satellite necessary instrumentation
ready. active instrument calibrated, satellite may first turn towards
another direction calibrate it.
#define [t] take image possible(satellite, direction):
mode [ goal (have image(direction, mode))
[t] image(direction, mode)
instrument [
[t] power on(instrument) calibrated(instrument)
[t] board(instrument, satellite) supports(instrument, mode) ]]
switch switch operators still regulated control rules
planner quickly takes habit repeatedly flipping power different instruments
off. instrument powered calibrated, using much
possible switching another instrument seems reasonable. usefulness function,
putting value usefulness particular instrument, helps decide instrument
power first.
#define [t] usefulness(instrument):
value(t, $sum(<mode>, [t] supports(instrument, mode) mode needed goal(mode), 1))
#define [t] mode needed goal(mode):
direction [ goal(have image(direction, mode)) [t] image(direction, mode) ]
Add one usefulness score instrument imaging mode supports
needed goal. score used control rule chooses
satellites useful instrument, any.
#control :name use-the-most-useful-instrument
[t] power on(instrument) [t+1] power on(instrument)
[t] usefulness(instrument) > 0
satellite, instrument2 [
[t] usefulness(instrument2 ) > usefulness(instrument)
[t] board(instrument, satellite) board(instrument2 , satellite) ]
Switching instrument allowed instrument longer required.
#control :name dont-switch-instrument-off-if-you-dont-have-to
[t] power on(instrument) [t+1] power on(instrument))
[t] mode [ supports(instrument, mode) mode needed goal(mode) ]

370

fiTALplanner IPC-2002: Extensions Control Rules

run less obvious improvements, analyzing planner output
reveals one remaining inefficiency: satellites often simultaneously decide turn
direction picture needs taken direction, despite fact
one satellite needs take picture. similar situation ZenoTravel
domain number aircraft may concurrently choose pick passenger,
differences due fact reason satellite point
certain direction order calibrate take image, makes task
somewhat easier.
Therefore problem solved different way, using resource mutual
exclusion. resource, called point towards(direction) capacity 1,
borrowed temporarily turn duration turn. one satellite turns towards
specific direction d, satellite turn towards without causing resource conflict.
still leaves one problem: first satellite finished turning, longer
owns point towards(d) resource therefore another satellite immediately start
turning towards d. longer possible one satellite turn towards
direction once, first satellite taking pictures, satellites
turn direction one one, finally desired pictures taken
direction goal direction sees longer valid reason point
towards d. solved either changing definition goal direction letting
take image borrow resource.
Clearly, type swarming problem occurs quite often concurrent domains
principled solution investigated future.
5.6.2 Satellite: SimpleTime
SimpleTime version changes duration operators. Turning takes five time
units, switching instrument takes two units, calibrating takes five units taking picture takes seven units. couple helper fluents, turning towards, calibrating,
image generalized (an image exists taken) power generalized (power
switch action executed) keep track actions begun
completed. affected control rules updated accordingly.
5.6.3 Satellite: Timed
Timed version Satellite domain includes two new functions. calibration time
specifies time required calibrate, slew time function represents time
required satellite turn two directions. Neither changes prompts
significant changes SimpleTime control.
5.6.4 Satellite: Discussion
Satellite domain provide real challenge long planner trying
find correct plan. Finding short plan harder, especially Timed version,
would require additional analysis determine order images collected
satellites used image. using control rules seemed
bit overkill, especially since yet created control rules complex
UMTranslog-2 domain. reason, decided satisfied done
371

fiKvarnstrom & Magnusson

far, surprised plans generated turned considerably
lower quality produced planners.
contest, informed reason, least main reason:
automatic problem generator created problem instances randomized slew times
every pair directions check geometrical consistency would
present real world situation. subconsciously assumed problem instances
satisfied triangle inequality, case, planning teams
discovered this. example, handcoded problem 14, turning satellite directly
phenomenon86 groundstation4 takes 82.860 units time, turning two
carefully selected intermediate directions requires 1.183 units time.
Initial testing shows taking consideration using built-in
shortest path algorithm yields significantly shorter plans plan length measured
time point goals satisfied.
Another potential improvement would change last clause goal direction
allow satellites turn towards direction specified goals soon one started
taking last picture, rather waiting one finished taking last picture.
5.7 UMTranslog-2 Domain
UMTranslog-2 domain another logistics domain, 14 types, 38 predicates,
24 functions 38 operators, size complexity incomparable previously
encountered logistics domains contest.
Since formal domain definition information provided domain
high-level description, work information
domain PDDL definition. major problem previous
domains, since generally quite simple easy understand, give
us problems UMTranslog-2. significant amount time spent trying
determine exactly packages allowed move loaded
unloaded various kinds vehicles. retrospect, would probably better
teams did: Skip UMTranslog-2 domain completely spend
time Numeric Complex versions domains.
domain. Trucks, trains aircraft transport packages locations
must follow strict movement patterns. locations transportation hubs,
transportation centers rest ordinary locations. package allowed
move hierarchy move two locations
layer once. longest possible route package thus ordinary location
transportation center hub another hub transportation center finally
another ordinary location.
domain groups locations cities, grouped regions. Trucks
travel two locations city existing road route
two cities. Trains planes always use predefined routes transportation centers
hubs. great number restrictions complicate movements. Packages must
compatible vehicle loaded into, vehicle must enough free space,
loaded heavily wider, longer higher route destination
location accepts. Finally, locations, vehicles routes must available use.
372

fiTALplanner IPC-2002: Extensions Control Rules

Control rules. previous domains, specify reasonable location limit
vehicle movements destinations reasonable. truck might want pick
deliver package location or, truck cannot reach goal location
package, unload package transportation center picked another vehicle.
control rules allow trucks pick several packages. makes finding
optimal solutions impossible general case simplifies search acceptable
solutions great deal. imminent risk packages truck
carrying end wrong location allowed travel about, picking
packages along way. Since packages must move according specified pattern
transportation centers hubs, moving package arrived location
transportation center allowed package stuck there. Restricting
trucks picking one package time avoids problem.
large group loading unloading rules controlling, among
things, opening closing valves doors loading unloading packages.
Finally, packages loaded vehicles actually able take useful
location.
Creating control rules meeting contest deadline left time get domain
working concurrent planning. Instead, make sequential planning.
Given time, set control rules could definitely improved. planning speed
less issue, search allowed higher quality plans generated.
better problem instances would needed guidelines developing better control
rules since contest problems make full use intended transportation scheme
transportation centers hubs.

6. Improvements Competition
Though planning competition ended AIPS-2002 conference April, 2002,
work TALplanner naturally cease there. still many improvements
made, couple related development new domains
control rules implemented summer 2002.
6.1 Domain Visualization
discussed description ZenoTravel domain, process creating control
rules planning domain often involves incremental improvements. TALplanner run
number problem instances using one set control rules, possibly without control
rules all, beginning resulting search tree analyzed order determine
bad choices made avoided using new improved control
rules. repeated planner consistently finds plans good quality.
process, one must study output planner
structure particular problem instance solved. example, DriverLog
problem may necessary draw road network used problem instance
using pen paper, study paths taken trucks, people, packages
road network, order discover whether improvements would possible.
often particular inefficiency appears one large set problem
instances, tracing execution plan hand obviously tedious time
373

fiKvarnstrom & Magnusson

consuming task ought automated far possible.
led development TPVis, generic graphical visualization framework
TALplanner. TPVis framework used generate domain images article,
provides animated display consisting set nodes, node
container atomic object. Containers may represent vehicles (which contain
packages), locations (since vehicles, packages objects location)
similar concepts, atomic nodes may used packages, instruments
satellite, type object displayed. Edges nodes
indicate form relationship objects, obvious interpretation
two location nodes connected transportation route. built-in layout engine
generate layout automatically, manually adjust visual coordinates
node.
visualization framework used concrete plugins adapted specific planning domains. DriverLog plugin, example, displays locations container nodes,
linked paths drivers walk links trucks drive. Trucks
containers, contained within specific location, shown Figure 6 page 366.
plan generated, TPVis animates actual movements objects
locations. creates better instinctive feel domain, two-dimensional
graph display gives overview difficult provide using text output.
addition animating graph, TPVis simultaneously lists partial plan leading
current state problem goals planner tries satisfy. TPVis provides
limited form interactive planning since it, point planning process, allows
user force planner backtrack explore different search branch.
development TPVis initiated planning contest.
graphical visualization available work contest domains, would
saved lot time, possibly tree two.
6.2 Automatic translation PDDL TALplanner
Although obvious automatic translator PDDL TALplanners input format, always urgent features implemented,
instead decided translate IPC-2002 domains hand. retrospect mistake. risk making error somewhere translation becomes imminent
dealing complex domains UMTranslog-2, 38 operators,
highly complex preconditions. Also, translating long formulas hand quite time
consuming. semi-automatic translator therefore implemented decrease amount
work involved translation process reduce risk introducing errors
definition.

7. Discussion Conclusions
third International Planning Competition major step forward terms
expressibility required represent benchmark domains, provided number
interesting challenges planner wanted participate competition.
article described challenges affected TALplanner shown number
extensions made order meet challenges. article includes
374

fiTALplanner IPC-2002: Extensions Control Rules

number domain-dependent control rules competition domains, rather
presenting exhaustive list pre-packaged control rules, attempted place
emphasis explaining incremental analysis process eventually leads final
formulas, going particular detail ZenoTravel domain.
could seen examples shown paper, control rules often simple,
natural common-sense rules, difficult generate given basic knowledge planning domain. rules complex, still difficult
understand verify someone spent effort generate them. then, unfortunately, rules quite unintuitive, rules complex
easily understood, rules occasionally forbid optimal plans.
extent, rules might avoided gaining experience good practices
writing control rules, extending expressivity language control
rules written complex conditions expressed succinctly
natural manner, simply spending little bit time control rules
available planning competition much time spent teaching
working planner implementation. However, another important cause
complexity certain rules probably attempting express search control
knowledge way: control rules prune search tree great
extent even simple depth-first search algorithm sufficient efficiently finding good
plans remainder tree.
search control knowledge easily expressed manner, certainly mean control rules abandoned altogether. Instead,
learn experience control rules might one multi-purpose
planning tool efficiently easily solve planning problems. Instead,
one would expect, one useful tool deserves place toolbox
combined approaches planning. mention one rather obvious
example, would possible devise heuristic forward-chaining planner whose search
tree would pre-pruned using control rule techniques TALplanner. Control rules
could written exclude plans heuristic gives suboptimal result, potentially
providing plans closer optimal, even domains heuristic search
function provides good plans may often efficient state number constraints
explicit control rules.
extensions TALplanner considered least since time
second planning competition 2000, long clear us approach eventually examined explored. could start working this,
though, strengths weaknesses control rules explored depth.
now, work therefore focused mostly investigating far possible
take TALplanner current shape, explicit control rules means
controlling search process. work proved rather fruitful itself, TALplanner well IPC-2000 well IPC-2002. planner becoming reasonably
mature, improvements made planner
released general use, might time take step back consider relation
approaches depth done previously order investigate
possible advantages hybrid approaches.
course, mean nothing done within pure
375

fiKvarnstrom & Magnusson

TALplanner framework. contrary, many additional topics pursued,
including investigating application TALplanner plan optimization problems (where
simplest approaches might involve applying standard optimal graph search algorithms pruned search tree generated TALplanner) extending planner
handle incomplete knowledge non-deterministic operators. many topics
next focus research yet determined.

Acknowledgements
research supported part WITAS Project Wallenberg Foundation.

References
Bacchus, F., & Kabanza, F. (2000). Using temporal logics express search control knowledge planning. Artificial Intelligence, 116 (12), 123191.
Doherty, P. (1994). Reasoning action change using occlusion. Cohn, A. G.
(Ed.), Proceedings 11th European Conference Artificial Intelligence (ECAI94), pp. 401405. John Wiley Sons. Available ftp://ftp.ida.liu.se/pub/labs/
kplab/people/patdo/ecai94.ps.gz.
Doherty, P., Gustafsson, J., Karlsson, L., & Kvarnstrom, J. (1998). TAL: Temporal Action
Logics language specification tutorial. Electronic Transactions Artificial
Intelligence, 2 (34), 273306. Available http://www.ep.liu.se/ej/etai/1998/009/.
Doherty, P., & Kvarnstrom, J. (1999). TALplanner: empirical investigation temporal
logic-based forward chaining planner. Dixon, C., & Fisher, M. (Eds.), Proceedings
6th International Workshop Temporal Representation Reasoning, pp. 47
54. IEEE Computer Society. Available ftp://ftp.ida.liu.se/pub/labs/kplab/people/
patdo/time99-final.ps.gz.
Doherty, P., & Kvarnstrom, J. (2001). TALplanner: temporal logic-based planner. AI
Magazine, 22 (3), 95102.
Fox, M., & Long, D. (2003). PDDL2.1: extension PDDL expressing temporal
planning domains. Journal Artificial Intelligence Research, issue.
Gustafsson, J., & Doherty, P. (1996). Embracing occlusion specifying indirect effects
actions. Aiello, L. C., Doyle, J., & Shapiro, S. C. (Eds.), Proceedings 5th
International Conference Principles Knowledge Representation Reasoning
(KR-96), pp. 8798, San Francisco. Morgan Kaufmann Publishers. Available ftp:
//ftp.ida.liu.se/pub/labs/kplab/people/patdo/final-kr96.ps.gz.
Karlsson, L., & Gustafsson, J. (1999). Reasoning concurrent interaction. Journal
Logic Computation, 9 (5), 623650.
Kibler, D., & Morris, P. (1981). Dont stupid. Hayes, P. J. (Ed.), Proceedings
7th International Joint Conference Artificial Intelligence (IJCAI-81), pp. 345347.
Kvarnstrom, J., & Doherty, P. (2003). TALplanner project page. http://www.ida.liu.se/
patdo/aiicssite1/kplab/projects/talplanner/.

376

fiTALplanner IPC-2002: Extensions Control Rules

Kvarnstrom, J., & Doherty, P. (2000). TALplanner: temporal logic based forward chaining
planner. Annals Mathematics Artificial Intelligence, 30, 119169.
Kvarnstrom, J., Doherty, P., & Haslum, P. (2000). Extending TALplanner concurrency
resources. Horn, W. (Ed.), Proceedings 14th European Conference
Artificial Intelligence (ECAI-2000), Vol. 54 Frontiers Artificial Intelligence
Applications, pp. 501505, Amsterdam. IOS Press. Available ftp://ftp.ida.liu.se/
pub/labs/kplab/people/patdo/www-ecai.ps.gz.
Kvarnstrom, J. (2002). Applying domain analysis techniques domain-dependent control
TALplanner. Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Proceedings
Sixth International Conference Artificial Intelligence Planning Scheduling
(AIPS-2002), pp. 101110. AAAI Press, Menlo Park, California.
Long, D., & Fox, M. (2003). 3rd international planning competition: Results
analysis. Journal Artificial Intelligence Research, issue.

377


