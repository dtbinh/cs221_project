journal artificial intelligence

submitted published

pddl extension pddl expressing temporal
domains
maria fox
derek long

maria fox cis strath ac uk
derek long cis strath ac uk

department computer information sciences
university strathclyde glasgow uk

abstract
recent years community moved increasingly towards
application planners realistic involving time many types resources example interest demonstrated space community
inspired work observation scheduling planetary rover exploration spacecraft
control domains temporal resource intensive domains including logistics plant control manufacturing helped focus community
modelling reasoning issues must confronted make technology meet
challenges application
international competitions acted important motivating force
behind progress made since third competition
held set community challenge handling time numeric
resources necessitated development modelling language capable expressing
temporal numeric properties domains describe
language pddl used competition describe syntax
language formal semantics validation concurrent plans observe
pddl considerable modelling power exceeding capabilities current
technology presents number important challenges community

introduction
drew mcdermott released domain description language pddl mcdermott mcdermott aips competition committee
since become community standard representation exchange
domain despite dissatisfaction community features
pddl language enabled considerable progress made
ease systems sharing standard compared
enormous increase availability shared resources introduction pddl
facilitated scientific development
since decisive movement community towards application technology realistic propositional puzzle domains
old longer considered adequate demonstrating utility system modern planners must able reason time numeric quantities although several members community working applications
real domains nature time laborie ghallab ghallab laruelle
muscettola drabble tate wilkins gap
c

ai access foundation morgan kaufmann publishers rights reserved

fifox long

modelling requirements domains expressed pddl
application driven planners come equipped modelling conventions black
arts consequence difficult reproduce make empirical
comparisons approaches essential scientific progress
made
pddl language provides foundation expressive standard
constructed enabling domain applications driven community shared
motivating development field towards realistic application
third international competition took place objective
closing gap application organisers third
competition authors therefore took first step defining expressive language
capable modelling certain class temporal resource intensive domains
done eye future awareness current
capabilities planners possible language used members
community would competitors describe resulting
language pddl terms syntax semantics modelling capabilities
pddl designed backward compatible fragment pddl
common usage since compatibility supports development
resources help establish scientific foundation field ai
furthermore mcdermotts original pddl provides clean well understood basis
development embodies number design principles considered important
retain pddl extends pddl principled ways achieve additional expressive
power following far possible mcdermotts maxim physics advice mcdermott
take maxim mean language focus expressing physical
properties world advice planner search associated
solution spaces course model physical systems makes simplifying assumptions
abstracts behaviours level model claimed purely physics
free decisions could influence use model attempt
make strong judgements constitutes advice try implement maxim
keeping language simple possible make following two guarantees
backward compatibility
existing pddl domains common usage valid pddl domains
important enable existing libraries benchmark remain valid
valid pddl plans valid pddl plans
important contribution made development pddl means
domain designers provide alternative objective functions used judge
value plan use numbers domain provides platform measuring
consumption critical resources parameters example metric
modelled energy consumption must minimized important many
practical applications plan quality might dependent number
interacting domain dependent factors
organisation follows section introduce non specialist
readers pddl domain description language used community


fipddl expressing temporal domains

background given order provide foundations numeric durative
extensions made developing pddl focusses specific extensions
introduced numeric expressions durative actions section start explaining
syntax numeric expressions use action descriptions explain
section metrics provided part description
quality plan involving numeric change evaluated terms appropriate
domain present syntax metrics expressed give examples
section introduces notion durative action way modelling
temporal properties domain discretised continuous durative actions
considered syntax described examples modelling power limitations
presented cases given examples syntactic representation durative
actions present formal semantics discretised continuous actions
plans sections provide details semantics gives us way tackling
confirming plan validity something becomes important issue
face concurrent activity section describe process plans
validated competition discuss complexity validation question
pddl finally section describes related work temporal reasoning
community order put contributions made pddl wider context full
bnf description pddl found appendix
pddl developed use third international competition
competing planners demonstrated many discretized temporal metric
efficiently handled domain independent planners handtailored control rules ease reference competition identified features
pddl series levels increasing expressive power thus strips fragment
pddl referred level numeric extensions comprised level addition
discretised durative actions resulted level continuous durative actions resulted
level final level level comprised extensions pddl additional
components support modelling spontaneous events physical processes level
discussed details found earlier work fox long
competition focussed use levels use levels
technology stage sufficiently advanced handle additional
complexities despite fact level used competition devote
discussion feel level presents important immediate
challenges community affect extent
applied real
purpose provide overview features introduced
pddl discuss rationale language choices explain issues arisen trying extend pddl although provided bnf
pddl appendix intended language manual tutorial use language examples use language
relevant materials readers consult archived resources currently held
http www dur ac uk p long competition html


fifox long

pddl background
pddl action centred language inspired well known strips formulations
core simple standardisation syntax expressing
familiar semantics actions pre post conditions describe applicability
effects actions syntax inspired lisp much structure domain
description lisp list parenthesised expressions early design decision
language separate descriptions parameterised actions characterise
domain behaviours description specific objects initial conditions goals
characterise instance thus created pairing
domain description description domain description
paired many different descriptions yield different
domain parameterisation actions depends use variables
stand terms instance instantiated objects specific
instance action grounded application pre post conditions
actions expressed logical propositions constructed predicates argument
terms objects instance logical connectives
although core pddl strips formalism language extends beyond
extended expressive power includes ability express type structure objects
domain typing parameters appear actions constraining types
arguments predicates actions negative preconditions conditional effects
use quantification expressing pre post conditions extensions
essentially proposed adl pednault
although original definition pddl syntax accompanied formal semantics language really proposal standard syntax commonly accepted
semantics little scope disagreement meaning language
constructs two parts original language proposal claim fails
attempt offer standard syntax describing hierarchical domain descriptions suitable
htn planners subset language concerned expressing numeric valued
fluents former ambitious project construct syntax entire structure domains hierarchical action decompositions could expressed contrast
strips differences planners hierarchical decomposition
appear deeper domain descriptions often containing structures go beyond
description domain behaviours example shop nau cao lotem munozavila often uses mechanisms represent goal agendas solution oriented
structures domain encoding diversity undermined efforts standardisation
hierarchical domain descriptions part language never successfully
explored
syntax proposed expressing numeric valued fluents tested first
use language competition indeed underwent revision early
development language second competition avoided use numericvalued fluents general agreement syntax semantics numericexpressivity language remained unnecessary mcdermotts original pddl provides
support numbers allowing numeric quantities assigned updated syntax
numeric valued fluents changed pddl manuals mcdermott


fipddl expressing temporal domains

define domain jug pouring
requirements typing fluents
types jug
functors
amount j jug
capacity j jug
fluent number
action empty
parameters jug jug jug
precondition fluent test
capacity jug amount jug
amount jug
effect change amount jug
change amount jug
amount jug amount jug


figure pouring water jugs described ai magazine article mcdermott


aips competition committee later ai magazine article
pddl mcdermott mcdermott presented version numeric fluents used
pddl article ai magazine could taken definitive statement
syntax example numeric fluents presented mcdermott shown
figure action action well known jugs water
allowing water one jug emptied second jug provided space
second jug large enough hold water first effect discrete update
values current contents jugs assignment denoted
change token
even without numeric extensions pddl expressive language capable capturing wide variety interesting challenging behaviours figure illustrates
pddl used capture domain vehicle move locations
consuming fuel
seen example pddl includes syntactic representation level
expressivity required particular domain descriptions use requirements
flags gives opportunity system gracefully reject attempts
plan domains make use advanced features language
planner handle syntax checking tools used confirm requirements
flags correctly set domain types features language
correctly employed example description accompany vehicle
domain shown figure example illustrates description initial
state requires exhaustive listing atomic propositions hold symmetric
transitive relations must modelled exhaustive explicit listing propositions
hold use domain axioms simplify description domains use
relationships considered remains untested part pddl therefore


fifox long

define domain vehicle
requirements strips typing
types vehicle location fuel level
predicates v vehicle p location
fuel v vehicle f fuel level
accessible v vehicle p p location
next f f fuel level
action drive
parameters v vehicle location
fbefore fafter fuel level
precondition v
accessible v
fuel v fbefore
next fbefore fafter
effect v
v
fuel v fbefore
fuel v fafter



figure domain description pddl
unstable part syntax pddl domains case sensitive somewhat
anachronistic light standard practice modern programming languages
following sections review extensions made pddl development
pddl version language used third international competition

numeric expressions conditions effects
one first decisions made development pddl propose definitive
syntax expression numeric fluents syntax version described
ai magazine article mcdermott minor revisions discussed
numeric expressions constructed arithmetic operators primitive numeric
expressions values associated tuples domain objects domain functions proposed syntax expressing numeric assignments updates
express jug pouring operator originally described pddl manual ai
magazine article see figure pddl presented figure example
functions capacity amount associate jug objects numeric values corresponding capacity current contents respectively seen example
used prefix syntax arithmetic operators including comparison predicates
order simplify parsing conditions numeric expressions comparisons
pairs numeric expressions effects make use selection assignment
operations order update values primitive numeric expressions include
direct assignment relative assignments increase decrease numbers
distinguished possible roles values represent example quantities
resources accumulating utility indices counters


fipddl expressing temporal domains

define vehicle example
domain vehicle
objects
truck car vehicle
full half empty fuel level
paris berlin rome madrid location
init
truck rome
car paris
fuel truck half
fuel car full
next full half
next half empty
accessible car paris berlin
accessible car berlin rome
accessible car rome madrid
acessible truck rome paris
accessible truck rome berlin
accessible truck berlin paris

goal truck paris
car rome



figure instance associated vehicle domain

define domain jug pouring
requirements typing fluents
types jug
functions
amount j jug
capacity j jug
action pour
parameters jug jug jug
precondition capacity jug amount jug amount jug
effect assign amount jug
increase amount jug amount jug


figure pouring water jugs pddl style



fifox long

differences pddl syntax ai magazine syntax
declaration functions use assign instead change decided
allow numeric valued functions making declaration function return types
superfluous therefore simplified language requiring declaration
function names argument types required predicates felt change
ambiguous used alongside operations increase decrease assign
would clearer
numeric expressions allowed appear terms language
arguments predicates values action parameters two justifications
decision philosophical one pragmatic one philosophically take
view finite number objects world numbers exist
unique independent objects world values attributes objects
object oriented sense actions seen methods
apply objects given parameters object oriented view directly
inform syntax representations reflected way numbers
manipulated relationships objects identified named
initial state pragmatically many current approaches rely able
instantiate action schemas prior feasible finite
number action instances branching planners search space choice points
corresponding action selection therefore finite ranges use numeric
fluent variables conflicts could occur arguments predicate
would define finite ranges
decision allow numbers used arguments actions rules
actions might seem intuitively reasonable example action fly certain
altitude might expected take altitude number valued argument
possible pddl range numbers used finite practical
point view think unlikely arduous constraint benefits
keeping logical state space finite compensates modelling awkwardness

functions pddl restricted type objectn r finite collection objects instance object finite function arity n later extensions
pddl might introduce functions type objectn object allowing object extended application functions objects advantage would
allow objects referred relationships known objects example
ontopof x could used refer object currently top object instantiating x unfortunately functions present semantic particular
interpretation quantified preconditions becomes significantly harder since collection objects longer necessarily finite extensional interpretations possible
difficulty identity objects manipulated actions
functional expressions refer affected implicitly example
objects moved ontopof change without action manipulating explicitly
managing way functional terms map specific objects domain
might might specific names appears introduce considerable
complication semantics believe important avoid extending pddl
elements still poorly understood


fipddl expressing temporal domains

plan metrics
adoption stable numeric extension pddl core allowed us introduce
extension pddl namely optional field within specification
plan metric plan metrics specify benefit planner basis
plan evaluated particular initial goal
states might yield entirely different optimal plans given different plan metrics course
planner might choose use metric guide development solution
evaluate solution post hoc might lead sub optimal possibly
even poor quality plans pragmatic handling metrics
quite widely used competition issue discussed companion
analysing rd ipc issue long fox b
value total time used refer temporal span entire plan
values must built primitive numeric expressions defined within domain
manipulated actions domain consequence plan metrics
express non temporal metrics pddl domains numeric expressions arithmetic expression used specification metric requirement
expression linear domain designers responsibility ensure plan
metrics well defined example involve divisions zero example use
plan metric shown figure
implications introduced extension far reaching already
helped demonstrate important challenges systems particularly
fully automated systems enriched descriptive power evaluation plans
crucial extension practical use planners since almost never case real
plans evaluated solely number actions contain
metrics described description allowing modeller easily explore
effect different metrics construction solutions
domain order define metric terms specific quantity necessary
instrument quantity domain description example metric defined
terms overall fuel use fuel use quantity initialised zero initial state
updated every time fuel consumed domain shown figure possible
minimise linear combination fuel used vehicles
metric minimize fuel used car fuel used truck

however possible minimise distance covered since distance instrumented
would straightforward instrument desired simply adding appropriate initial
value incrementing effects domain description since actions cause quantities
change instrumenting value requires modification domain description
file
use plan metrics subtle dramatic impact plans
sought perhaps simplest case actions increase metric must
minimised decrease one must maximised case example shown
figure use drive action worsen value plan metric
whether use metric shown figure maximising metric described
last paragraph situation might appear relatively straightforward planner


fifox long

define domain metricvehicle
requirements strips typing fluents
types vehicle location
predicates v vehicle p location
accessible v vehicle p p location
functions fuel level v vehicle
fuel used v vehicle
fuel required p p location
total fuel used
action drive
parameters v vehicle location
precondition v
accessible v
fuel level v fuel required
effect v
v
decrease fuel level v fuel required
increase total fuel used fuel required
increase fuel used v fuel required


define metricvehicle example
domain metricvehicle
objects
truck car vehicle
paris berlin rome madrid location
init
truck rome
car paris
fuel level truck
fuel level car
accessible car paris berlin
accessible car berlin rome
accessible car rome madrid
accessible truck rome paris
accessible truck rome berlin
accessible truck berlin paris
fuel required paris berlin
fuel required berlin rome
fuel required rome madrid
fuel required rome paris
fuel required rome berlin
fuel required berlin paris
total fuel used
fuel used car
fuel used truck

goal truck paris
car rome

metric minimize total fuel used


figure example domain instance describing plan metric


fipddl expressing temporal domains

must attempt use actions solve possible fact even case
little complex appears rival plans one uses
actions lower overall cost complex case arises
actions improve quality metric others degrade example use
maximising metric add refuel action domain driving degrade plan
quality reducing fuel level vehicle refuelling improve plan quality
increasing fuel level vehicle case planner attempt use actions
improve plan quality without actions actually contributing achieving goals
example refuelling might necessary get vehicles destinations
adding refuelling actions would improve quality solution process could
involve trading finite irreplaceable resources increased value plan
would case example refuelling vehicle took fuel finite reservoir
alternatively domain could allow plans arbitrarily high value constructed
actions would occur metric vehicles domain
maximising vehicles fuel level metric refuelling constrained since domain
impose limit fuel capacities vehicles
case plans constrained finite availability resources important
interesting form case plans arbitrarily
high utility constructed obviously ill defined since optimal plan
exist non trivial determine whether provided
metric ill defined fact helmert shows helmert introduction numeric
expressions even constrained way adopted pddl makes
undecidable finding collection actions
consume irreplaceable resources overall beneficial impact plan metric
least hard therefore clear determining whether
even well defined undecidable make worthless
consider metrics course demonstrates modelling
well becomes even complex metrics introduced
one strategy available planners working subject plan metrics
ignore metric simply produce plan satisfy logical goals
specifies case plan quality simply value according metric
plan happens constructed strategy unsophisticated obviously
better planner construct plan guided specified metric best use
metric expedite search process fully automated planner still issue

durative actions
recent work temporal smith weld bacchus kabanza
kambhampati forms durative action order
facilitate participation competition therefore developed two forms durative
action allowing specification restricted forms timed conditions effects
description although constrained certain ways durative actions
nevertheless expressive many proposals previously explored particularly
way allow concurrency exploited two forms discretised
durative actions continuous durative actions


fifox long

durative action load truck
parameters truck
l location
cargo
c crane
duration duration
condition start l
start l
start empty c
l
end holding c
effect end
start holding c
start l
end holding c


figure durative action loading truck assume capacity constraints

forms rely basic durative action structure consisting logical changes
caused application action consider logical change instantaneous
therefore continuous aspects continuous durative action refer numeric
values change interval action figure depicts basic durative action
load truck numeric change
modelling temporal relationships discretised durative action done means
temporally annotated conditions effects conditions effects durative actions
must temporally annotated annotation condition makes explicit whether
associated proposition must hold start interval point action
applied end interval point final effects action
asserted interval start end invariant duration
action annotation effect makes explicit whether effect immediate
happens start interval delayed happens end interval
time points accessible discrete activity takes place identified start
end points actions plan
invariant conditions durative action required hold interval
open ends starting ending end points action expressed
construct seen figures one wants specify fact p
holds closed interval duration durative action three conditions
required start p p end p
considered adopting convention constraints apply
start end points well open interval inside durative action decided
would impossible express conditions actually
required hold open interval examples actions conditions
invariant open interval include action loading truck truck must
remain loading location throughout loading interval start move
away simultaneously loading completed reason start


fipddl expressing temporal domains

drive action non mutex end load reasonable interpretation
plan driving starts instant loading completed actions affect
invariant condition location truck executed simultaneously
end point durative action invariant constrained hold true
end point highlights important difference
end condition required end precondition well invariant
condition meaning action affects invariant must start end
action requiring invariant example make truck location end
precondition load operator well invariant consequence truck
cannot drive away instant load completed
note definition load truck action figure chosen make
condition holding c start effect end precondition invariant
condition means crane could temporarily cease hold cargo
time interval long holding cargo time deposit end
loading interval makes action quite flexible enabling exploitation
concurrent uses crane applicable
load truck example shows logical change wrapped durative
actions encapsulate much detail involved achieving effect sequence
connected activities naturally would useful able combine actions
concurrently within plan next section consider extent concurrency
allowed ways concurrent plans interpreted
interpretation concurrent plans
time introduced modelling domain possible concurrent activity
occur plan prior introduction time pddl plans interpreted
sequential even graphplan concurrent plans sequenced validated
concurrency never issue pddl plan validity depend exploiting
concurrency correctly actions overlap co occur giving rise questions
interpretation synchronous behaviour discuss arising precise
synchronization section explain constraints actions occur
concurrently within plan involving durative actions numeric conditions effects
key difference durative actions pddl used planners prior
competition distinguish conditions effects start
end points durative interval invariant conditions might specified
hold interval actions pre postconditions local
two end points action planner choose exploit durative action
effects start end conditions invariant distinguished
pre conditions enabling exploitation higher degree concurrency
possible preconditions distinguished invariants tgp smith weld
tpsys garrido onainda barber tp haslum geffner
discuss consequences design decisions together several examples
durative actions following sections
important observe view time point rather interval
see period activity terms intervals state separated time points


fifox long

state changing activities occur logical state change occurs instantaneously
start end point durative action propositions true half open intervals
closed left open right activities might change logical state
might update values numeric variables discretised view time
allow finite number activities call happenings two time
points although time considered continuous actions scheduled begin
time point
plan considered valid logical condition asserted negated
instant impose constraint logical condition
required hold asserted instant although might seem overly
strong claim plan cannot guaranteed valid instant
proposition required exactly instant asserted require
action precondition p start time must half open interval immediately
preceding p holds mathematically inconsistent p asserted
instant required conservative view validity
simultaneous update access state proposition example two
instantaneous actions b precondition p effects p q
b precondition p q effect r consider attempt apply
b simultaneously state p holds ill defined reason although
switches state one p holds one q holds one might
suppose precondition b secure abstraction model
values p q changing argue reliance values point
change unstable adopt rule call moving targets mean
two actions simultaneously make use value one two accessing value
update value moving target action access rule creates
behaviour propositions state much behaviour
variables shared memory protected mutex lock posix threads
difference read write access variable
validity requires numeric value accessed updated simultaneously
start end point durative action case discretised durative actions
numeric change modelled terms step functions numeric values accessed
updated interval another durative action acting value provide
examples following section provided updates consistent invariant
properties dependent value case continuous durative actions values
simultaneously accessed updated continuous process change occurring
interval action discretised continuous cases allow multiple
simultaneous updates provided update operations commutative
order implement mutual exclusion relation require non zero separation
mutually exclusive action end points view end points nonconflicting treated though possible execute simultaneously
even though precise synchronicity cannot achieved world however end
points mutually exclusive planner buffer co occurrence points
explicitly separating way ensure concurrency plan
least plausible world


fipddl expressing temporal domains

durative action heat water
parameters p pan
duration duration temperature p heat rate
condition start full p
start onheatsource p
start bypan
full p
onheatsource p
heating p
end bypan
effect
start heating p
end heating p
end assign temperature p


figure simple durative action boiling pan water

planners exploit considerable concurrency domain ensuring conflicting start end points actions separated non zero amount detailed
specification mutual exclusion relation pddl given section
discuss implications non zero separation section
numeric change within discretised durative actions
section explains continuous change sometimes modelled pddl
durative actions discrete effects achieved step functions describe
instantaneous changes beginnings ends durations actions appendix
details language constructs involved
example durative action illustrating use numeric update operations
shown figure example showing water heating action conditions full p
onheatsource p must hold start interval well interval
model enter conditions start constraints
action achieves start effect water heating condition maintained
invariant whole interval action example operator
achieves invariant condition draws attention fact conditions
hold interval open left well right
noted actions figures use fixed duration specifications
case water boiling example means impossible adjust length
time pan heated impact context
action used particular assign construct used update numeric
value possible concurrent activity affect value else model
flawed water heating example uses assign construct concurrent
activity affect temperature water responsibility modeller
ensure temperature neither accessed updated interval
action executing


fifox long

durative action navigate
parameters x rover waypoint z waypoint
duration duration travel time z
condition start available x
start x
start energy x
travel time z use rate x
visible z
traverse x z
effect start decrease energy x
travel time z use rate x
start x
end x z
durative action recharge
parameters x rover w waypoint
duration duration recharge period x
condition start x w
start sun w
start energy x capacity x
x w
effect end increase energy x duration recharge rate x

figure discretised durative actions rover move locations recharge

decided leave modeller ensure correct behaviour assign construct want forbid modelling truly discontinuous updates
example durative action deposit cheque bank account might
duration three days discontinuous update account balance
end interval would inappropriate prevent actions accessing
balance three day period general modelling continuous change discrete
effects open pitfalls price paid convenience
specify details continuous processes
use discretised durative actions combination numeric step function
updates requires care modelling particular relies notion conservative
resource updating updating resource levels conservative consumption
resource modelled happens start durative action even though
actually happens continuously duration action production resource
modelled happens end durative action even though might
actually produced continuously interval
example discretised durative action figure shows action
rover navigating two points modelled local precondition start
period rover start location local effects include rover
consumes appropriate amount energy destination first
conservative therefore immediate second logical effect occurs
end point organisation ensures parallel activities consume energy
already committed navigation activity similarly recharge action


fipddl expressing temporal domains

projected energy production
actual energy profile
initial energy

energy changing
production
consumption

step function model
energy consumption
dig action

final stage digging action
final energy
step function model
energy produced
recharge action

zero energy
recharge action
dig action

figure discrete actions model production consumption resource
reality recharge activity produces energy continuously concurrent dig
activity continuously consumes conservative model step functions
requires energy consumed digging must available start
action despite yet updated model additional
energy accumulated part recharge action far executed
final energy level consistent used continuous model

makes charge available conclusion action charge gained
cannot exploited recharging complete use conservative updates
ensures model support invalid concurrency
figure illustrates recharging digging action consumes energy would
interact conservative energy consumption model model would allow concurrent actions consume energy provided consume energy left
conservative assumption dig action consumed demands
start recharge action produced nothing end note example
assumes energy constraints capacity constraint
use conservative updates subtle capacity constraint
energy level rover one would need consider two separate resources energy
space available storage energy dig action would consume energy
start produce space end recharge action would consume space
start produce charge end combination would possible
ensure plans consume resource available
durative actions conditional effects antecedents consequents
conditional effect temporally annotated possible specify condition
checked start end effect asserted points


fifox long

durativeaction burnmatch
parameters match l location
duration duration duration
condition start
start l
effect start dark l
start dark l
start light l
start
start burning
end burning
start dark l
end light l
end dark l
actions

action pickup
parameters l location object
precondition l
onfloor l
light l
effect onfloor l


initial state onfloor coin amatch basement dark basement
goal coin

plan burnmatch amatch basement
pickup basement coin
pickup coin

start burnmatch
dark basement

end burnmatch
light basement





dark basement



plan

figure example durative action useful start effects
burning match produces light necessary pick coin

semantics makes clear well formed durative action conditional effects cannot
require condition checked effect asserted conditional effects
arise pddl variants discuss occurrence discretized durative actions
interpreted section
pddl allows specification duration inequalities enabling actions described
external factors involved determining temporal extent
match burning example shown figure seen effect start point
one interest planner would exploit action start rather
end effect duration inequality specifies match burn longer
specified upper bound model shows match put early planner
considers appropriate discuss use duration inequalities section


fipddl expressing temporal domains

durative actions continuous effects
objective discrete durative actions abstract continuous change concentrate end points period change takes place syntax allows
precise specification discrete changes end points durative actions however
plan needs manage continuously changing values well discretely changing
ones durative action language semantics need powerful general durative actions continuous well discrete effects increase decrease
numeric variable according specified rate change time variable
determining achieve goal planner must able access values
continuous quantities arbitrary points time line plan use refer
continuously changing time start durative action execution
example express fact fuel level plane p decreases continuously
function consumption rate p write
decrease fuel level p consumption rate p

distinctly different
end decrease

fuel level p
flight time b consumption rate p

latter single update happening end point flight action whilst
former allows correct calculation fuel level plane point
interval former continuous effect whilst latter discrete one continuous
effects temporally annotated evaluated time
interval action local durative action durative action
access purely local clock another way interpret expression representing
continuous change differential equation

fuel level p consumption rate p
dt
chose use symbol instead differential equation possible two
concurrent actions simultaneously modifying quantity case use
differential equations would actually form inconsistent pair simultaneous equations
rather intended effect combined contribution changing value
quantity although expressions describing continuous change take form
product quantity possible express complex change
interdependent concurrent effects example acceleration arises simply increasing
distance quantity describing velocity time increasing velocity
quantity describing acceleration dependencies changing terms
include mutual dependencies terms differential equations arise
lead continuous change dictated exponential logarithmic exponential functions
plan containing continuous durative actions assign consult continuously
modify numeric variables concurrently see example
figures discrete continuous actions heating pan water
presented simple model ignores heat loss discrete action presented figure
modifies version presented figure use duration inequality constraint


fifox long

example flying refuelling example shown figure seen
invariant condition fuel level greater equal zero
flight maintained whilst fuel continuously decreasing
could expressed discrete durative actions abstracting continuous
decrease making final value available end point flight however
refuel operation happens flight time mid air fuel level
flight need calculated taking account continuous
rate consumption refuel operation discrete action could calculate
fuel level correctly would access distance
source destination flight together rate consumption
determine final fuel level order calculate fuel level correctly
necessary determine time refuel takes place use
remaining flight time calculate fuel consumed discrete durative actions
give access time points start end points
discrete durative actions used express desired combinations flying
refuelling providing additional durative actions fly refuel
encapsulate interactions described end calculating fuel level
correctly however requires domain designer
planner domain designer must anticipate every useful combination
behaviours ensure appropriate encapsulations provided
contrast discrete form continuous action fuel consumption effect given terms powerful enough express fact
mid flight refuelling plane affects final fuel level way consistent
maintaining invariant fly action

durative action fly
parameters p airplane b airport
duration duration flight time b
condition start p
inflight p
fuel level p
effect start p
start inflight p
end inflight p
end p b
decrease fuel level p
fuel consumption rate p
action midair refuel
parameters p
precondition inflight p
effect assign fuel level p fuel capacity p

figure continuous durative action flying



fipddl expressing temporal domains

durative action heat water
parameters p pan
duration end duration temperature p
heat rate
condition start full p
start onheatsource p
start bypan
full p
onheatsource p
heating p
end bypan
effect
start heating p
end heating p
end increase temperature p
duration heat rate


figure discrete durative action heating pan water variable duration

duration inequalities add significant expressive power duration equalities duration
constraints express inequalities associated additional requirements flag
extended expressiveness fixed duration discrete durative actions
actions logical post condition start period pan
heating conditions pan heating full heat source invariant
although presence agent pan local precondition two
end points invariant first action duration modelled expressing
following duration inequality constraint
end duration temperature p heat rate

effect end point discrete durative action temperature
pan increased duration heat rate heat rate domain
constant continuous action figure duration constraint unnecessary
since invariant
temperature p

added ensure pan never exceeds boiling
durative action figure heating pan face possible concurrent activities affecting temperature duration inequality allows planner
adapt duration take account temperature affecting activity way
possible duration specified equality constraint duration
constraint ensures temperature never exceeds boiling checking precondition updating activity computed temperature increase executed
without exceeding boiling point temperature increase would exceed boiling
plan invalid temperature end interval execution computed
current temperature heating rate together duration
heating action active see discussion example


fifox long

example plan attempts heat pan say applying blowtorch
pan heat water interval provided concurrent action
ends end heat water action duration constraint seen
violated duration chosen overall increase
temperature would exceed boiling concurrent activity ends simultaneously
heat water action moving targets rule would violated
duration constraint would attempt access temperature time
point concurrent action attempted update
figure depicts two situations figure apply blowtorch durative
action applies heat object case pan part figure
duration constraint violated duration heat water action
sufficient cause temperature increase beyond boiling combined
heat increase caused blowtorch case plan invalid
planner choose value duration avoids violation part b
plan determined invalid regardless duration action
moving targets rule notice model attempt model
consequences continued heating pan boiling point plans
actions cause occur simply invalid however pddl used
model physical situation consequences explicit
planner choose exploit avoid accordingly



b

heatwater

applyblowtorch

heatwater
check duration
constraint

applyblowtorch

increase temperature
pan

simultaneous change
consultation
temperature

figure heating pan discrete durative action concurrently another heating
activity



fipddl expressing temporal domains

durative action heat water
parameters p pan
duration
condition start full p
start onheatsource p
start bypan
full p
onheatsource p
heating p
temperature p
end bypan
effect
start heating p
end heating p
increase temperature p heat rate


figure continuous durative action heating pan water
use duration inequalities adds significant expressive power even discrete durative actions example plan depicted part figure
illustrates use water heating action shown figure concurrently heating pan blowtorch considered valid provided duration
value satisfies duration constraint water heating action brings us
close expressive power available continuous durative actions gives
planner power exploit concurrent interacting activities enacting changes
numeric valued variable see example attempting express continuous change
duration inequalities give precisely equivalent behaviour
discretisation forces actions access changing numeric values separated
small temporal interval actions change values order resolve
mutual exclusion continuous model necessary true value
numeric variable available consultation time continuous process
change
discrete semantics presented section exploit fact changes
occur plan executed points corresponding times happenings plan checked looking activity focussed finite happening
sequence fact provided continuous effects restricted linear functions time
first order effects requires continuous effects affect numeric
expressions contributing rate change another numeric valued variable invariants restricted linear functions changing quantities still possible restrict
attention happening sequence even continuous actions
non linear effects higher order rates change create difficulties since possible
invariant satisfied end points interval without necessarily
satisfied throughout interval cases longer sufficient insert
invariant checking actions fixed mid points happening sequence plan order
validate behaviour however provided effects first order linear
invariants linear continuously changing values despite fact arbitrary


fifox long

example possible discrete durative actions duration inequalities
model effects adding egg heating water water say
degrees applying two heat water actions around add egg action way overall duration two heat water actions exactly
duration required boil water original temperature however
way heat water action currently modelled means heat turned
egg added turned complete heating since
temperature updated durative action terminates continuous durative actions egg added whilst single heat water action
progress since temperature pan continuously updated discrete durative actions duration inequalities allow us approximate continuous activity
appending finite sequence discrete intervals appropriate way
moving targets rule means end points intervals separated
non zero arbitrarily small time gaps required continuous
actions contrast step function effects discrete actions continuous effects localised single point

time points within action intervals accessible planner necessary gain
access numeric values start end points actions plan refer
together finitely many mid points invariant checking actions values
required points continuous durative actions
support modelling exogenous events necessary take account
exogenous activity environment determining validity plan
related approaches
time important numerically varying quantity simplest way reason time
adopt black box durative action model change happens ends
durative intervals taken language used tgp smith
weld example durative actions encapsulate continuous change
correct values affected variables guaranteed end points
implied intervals logical numeric effects durative action enacted
end action undefined interval execution undeleted
preconditions must remain true throughout interval syntactic distinction
preconditions invariant conditions action representation simplistic
way ensuring correct action application prevent concurrent actions refer
facts excludes many intuitively valid plans
sophisticated allows preconditions annotated time points
intervals requirement condition true point
interval within duration action expressed taken
sapa kambhampati example annotated precondition
would possible express requirement chemical additive added within
two minutes start tank filling action effects specified occur
arbitrary points within duration action possible express effects


fipddl expressing temporal domains

occur end specified duration possible distinguish
conditions local specific points duration action
invariant throughout action
allowing reference finitely many time points start end actions
makes language complex without adding expressive power time
points strictly scheduled relative start action effect achieved
use sequence linked durative actions decided keep pddl
simple restricting access end points actions
tlplan bacchus ady similar constrained adopted
actions applied instantaneously delayed effects delays
effects arbitrary different effect however invariants cannot specified
preconditions checked instant application subsequent delayed
effects separated action initiated
several planners developed use networks temporal constraints ghallab
laruelle jonsson morris muscettola rajan el kholy richards
handle temporal structure efficient exist handling
constraints dechter meiri pearl make practical managing
large networks domain constructed pddl certainly lend
treatment similar techniques constrained handled way

introduction semantics pddl
sections provide formal semantics numeric extension temporal
extension pddl together sections contain definitions lengthy treatment
necessary semantics developed adds four significant extensions
classical semantics lifschitz developed strips lifschitz

introduction time plans describe behaviour relative real time line
related first extension treatment concurrency actions executed
parallel lead plans contain concurrent interacting processes
although processes encapsulated durative actions pddl
extension handle numeric valued fluents
use conditional effects alone conjunction
extensions
semantics built familiar state transition model requirements semantics reduced four essential elements
define state introduction time numeric values complicate
usual definition state set atoms
define state satisfies propositional formula representing goal condition
precondition action extension usual interpretation state
valuation atom true atom state closed
world assumption required order handle numeric values state


fifox long

define state transition induced application action update rule
logical state must supplemented explanation consequences
numeric part state
define two actions applied concurrently concurrent
application affects application actions individually
structure definitions follows definitions given section
define means plan valid plan consists non durative
actions definitions set basic terminology foundational structures
framework handling conditional effects primitive numeric expressions definition meets first requirement identified defining states definition meets
second requirement defining goal description satisfied state definition
defines simple plan extending classical notion sequence actions adding
time definitions meets fourth requirement defining two actions cannot
executed concurrently definition meets third requirement defining mean
execution actions including concurrent execution actions definitions
define execution plan means plan valid given basis laid
previous definitions
section semantics extended give meaning durative actions begin
definition defines ground durative actions analogously definition
simple non durative actions similarly definition parallels definition
simple plan definition definitions parallel execution
validity simple plans definitions definition critical definition
semantics plans durative actions supplying transformation temporal plans
simple plans whose validity according semantics purely simple plans
used determine validity original temporally structured plans

semantics simple plans
semantics define section extends essential core lifschitz strips semantics handle temporally situated actions possibly occurring simultaneously
numeric conditional effects
definition simple instance simple instance defined
pair
dom p rob
dom f rs arity tuple consisting finite sets function symbols
relation symbols actions non durative function arity mapping symbols
respective arities p rob os init g triple consisting objects
domain initial state specification goal state specification
primitive numeric expressions instance p n es terms constructed function symbols domain applied appropriate number
objects drawn os dimension instance dim number
distinct primitive numeric expressions constructed instance


fipddl expressing temporal domains

atoms instance atms finitely many expressions formed
applying relation symbols rs objects os respecting arities
init consists two parts initlogical set literals formed atoms atms
initnumeric set propositions asserting initial values subset primitive
numeric expressions domain assertions assign single primitive
numeric expression constant real value goal condition proposition
include atoms formed relation symbols objects instance
numeric propositions primitive numeric expressions numbers
collection action schemas non durative actions expressed syntax
pddl primitive numeric expression schemas atom schemas used action
schemas formed function symbols relation symbols used appropriate
arities defined domain applied objects os schema variables
semantics shows instantiated action schemas interpreted state transitions similar way familiar state transition semantics defined lifschitz
important difference states longer seen simply sets propositions
must account numeric expressions appearing instance
time state holds achieved extending notion state
definition logical states states given finite collection atoms instance atmsi logical state subset atmsi instance
dimension dim state tuple r p atmsi rdim
r r
denotes undefined value first value time state second
logical state third value vector dim values dim primitive numeric
expressions instance
initial state instance initlogical x x vector values
r corresponding initial assignments given initnumeric treating unspecified
values
undefined values included numeric ranges domains
terms start undefined nevertheless initialised exploited actions
interpret actions state transition functions necessary achieve two steps
firstly since pddl plans ever constructed fully instantiated action
schemas process instantiation affects constructs action schema must
defined secondly machinery links primitive numeric expressions elements
vector real values state allows interpretation numeric updating
behaviours action effects must defined since mechanisms support second
steps affect process first treatment numeric effects described
first
definition assignment proposition syntactic form numeric effect consists
assignment operator assign increase decrease scale scale one
primitive numeric expression referred lvalue numeric expression
arithmetic expression whose terms numbers primitive numeric expressions
referred rvalue


fifox long

assignment proposition corresponding numeric effect formed replacing
assignment operator equivalent arithmetic operation increase p q
becomes p p q annotating lvalue prime
numeric effect assignment operator increase decrease
called additive assignment effect one operator scale
scale called scaling assignment effect others called simple assignment
effects
numeric effect defines function numeric values state action
applied determining value primitive numeric expression resulting state
convenience uniform treatment numeric expressions appearing pre
post conditions transform functions propositions assert equality
post condition value expression intended define rather
writing effect increase p q function f p p q write proposition
p p q priming distinguishes postcondition value primitive numeric
expression precondition value convention commonly adopted describing state
transition effects numeric values binding primitive numeric expressions
values states defined following definition
definition normalisation let instance dimension dimi let
indexi p n esi dim
instance dependent correspondence primitive numeric expressions


integer indices elements vector dimi real values rdim

normalised form ground proposition p defined substituting primitive numeric expression f p literal xindexi f normalised
form p referred n p numeric effects normalised first converting
assignment propositions primed primitive numeric expressions replaced
corresponding primed literals x used represent vector hx xn
definition replacement primitive numeric expressions indexed literals
allows convenient consistent substitution vector actual parameters
vector literals x appearing state
machinery supporting treatment numeric expressions complete
possible consider process instantiating action schemas process managed
two steps first step remove constructs treat syntactic sugar
definition domain conditional effects quantified formulae handle
direct syntactic transformations action schema set action
schemas considered equivalent transformation similar described
gazen knoblock although would possible give semantic interpretation
application conditional effects directly transformation allows us significantly
simplify question actions performed concurrently
definition flattening actions given instance containing action
schema asi set action schemas f latten defined set initially
containing constructed follows


fipddl expressing temporal domains

contains action schema x conditional effect p q create
two schemas copies x without conditional effect conjoin
condition p precondition one copy q effects copy
conjoin p precondition copy add modified copies
contains action schema x formula containing quantifier replace
x version quantified formula q var vark p x
replaced conjunction quantifier q forall disjunction q
exists propositions formed substituting objects variable
var vark p possible ways
steps repeated neither step applicable
flattened actions grounded usual substitution objects parameters
definition ground action given instance containing action schema
asi set ground actions gaa defined set structures
formed substituting objects schema variables schema x
f latten components
name name action schema x together values substituted
parameters x forming
prea precondition propositional precondition set ground
atoms appear prea referred gprea
adda positive postcondition set ground atoms asserted
positive literals effect
dela negative postcondition set ground atoms asserted
negative literals effect
npa numeric postcondition set assignment propositions corresponding numeric effects
following sets primitive numeric expressions defined ground action
gaa
la f f appears lvalue
ra f f primitive numeric expression rvalue appears p rea
la f f appears lvalue additive assignment effect
comment appropriate last definition action precondition might
considered two parts logical part numeric expression dependent part
unfortunately interdependent example
clear x room space z


fifox long

might precondition action order handle conditions need check
whether satisfied given current logical state current
values domain numeric expressions inclusion numeric component
state makes necessary ensure correct substitution numeric values
expressions used action precondition achieved normalisation process
definition definition contrast postcondition action cannot contain
interlocked numeric logical effects possible separate effects
distinct numeric logical components
definition valid ground action let ground action valid primitive
numeric expression appears lvalue one simple assignment effect
one different type assignment effect
definition ensures action attempt inconsistent updates numeric
value unlike logical effects action cannot conflict possible write
syntactic definition action effects inconsistent example
assigning two different values primitive numeric expression
definition updating function let valid ground action updating function
composition set functions
dim
npfp rdim
r p n p

npfp x x primitive numeric expression x appear
lvalue n p x xi n p x x x x satisfied
notation n p x x x x read normalising p
substituting vector actual values x parameters x actual values x
formal parameters x
definition defines function describing update effects action function
ensures reals vector describing numeric state remain unchanged
affected action numeric state equivalent persistence
achieved propositions strips assumption values vector
normalisation process used substitute correctly indexed vector elements
primitive numeric expressions appearing lvalues primed vector elements
corresponding values post action state rvalues unprimed values appearing
pre action state tests must satisfied order ensure correct behaviour
functions composition simply confirm arithmetic rvalues
correctly applied arrive lvalues requirement action valid ensures
composition functions definition well defined since functions
set commute composition carried order
sets primitive numeric expressions defined definition allow us
conveniently express conditions two concurrent actions might interfere
one another particular concerned allow concurrent assignment
primitive numeric expression concurrent assignment inspection allow
concurrent increase decrease primitive numeric expression allow


fipddl expressing temporal domains

apply collections concurrent updating functions primitive numeric expressions allowed provided functions commute additive assignments
commute updating operations cannot guaranteed except
affect primitive numeric expressions rely primitive numeric expressions
affected concurrent assignment propositions would possible make
similar exception scaling effects additive assignment effects particularly
important role durative actions shared scaling effects simplicity
allow concurrent updates effects use three sets primitive
numeric expressions determine whether safe situation within single
action possible rvalues lvalues intersect action update
primitive numeric expressions current values primitive numeric expressions
updated action rvalues values take state
prior execution lvalues supply values state follows
definition satisfaction propositions given logical state ground propositional formula pddl p defines predicate rdim
num p follows
num p x

iff

n p x x

q means q true interpretation atom
numeric comparison assigned true iff numeric comparison interpreted
standard equality ordering reals logical connectives given usual
interpretations p satisfied state x num p x
comparisons involving including direct equality two values undefined enclosing propositions undefined satisfied state
definition applicability action let ground action applicable
state p rea satisfied
semantics simple plan
simple plan pddl sequence timed actions timed action
following syntactic form
action p pn
notation positive rational number floating point syntax expression
action p pn name actual parameters action executed
point time complex plans simple durative actions without numericvalued effects preconditions co occur semantics plans discussed
section special separators required separate timed actions sequence
actions required presented time sorted order possible
multiple actions given time stamp indicating executed
concurrently emphasised earliest point activity occurs within
plan must strictly time constraint follows decision make
initial state state existing time together decision semantics
actions effects interval closed left starting time
action applied preconditions tested interval open
right precedes action


fifox long

order retain compatibility output current planners following concession made plan presented sequence actions time points
inferred first action applied time succeeding actions apply
sequence integral time points one unit apart
simple plan slight generalisation familiar strips style classical plan
since actions labelled time executed
definition simple plan simple plan sp instance consists
finite collection timed simple actions pairs rational valued
time action name
happening sequence ti k sp ordered sequence times set
times appearing timed simple actions sp ti must greater
possible sequence empty empty plan
happening time et happening sequence sp set
simple action names appear timed simple actions associated time sp
plan thus consists sequence happenings set action names applied
concurrently specific time sequence ordered time times
happenings occur forms happening sequence noted action names
ambiguous action schemas contain conditional effects consequence flattening
split actions multiple actions identical names differentiated
preconditions however one set actions identical names
applicable given logical state since precondition action set
necessarily inconsistent precondition action set due
way conditional effects distributed pairs action schemas
induce
order handle concurrent actions need define situations
effects actions consistent one another issue first discussed
section mutual exclusion rule pddl extension idea action
mutex conditions graphplan blum furst extension handles two extra
features extended expressive power language include arbitrary propositional
connectives introduction numeric expressions make conservative
condition actions executed concurrently ensures possibility
interaction rules cases intuition might suppose concurrency
possible example actions
action
precondition p q
effect r
action b
precondition p
effect p

could one might suppose executed simultaneously state p q hold
following definition asserts however two actions mutex reason
chosen constrained definition checking mutex actions must


fipddl expressing temporal domains

tractable handling case implied example would appear require checking
consequence interleaving preconditions effects possible orderings
condition primitive numeric expressions already discussed determines
update effects executed concurrently affect values
tested preconditions regardless whether tests
matter satisfaction enclosing proposition rule moving
targets concurrent actions affect parts state relevant precondition
tests actions set regardless whether effects might harmful
might considered odd preconditions one action cannot refer literals
add effects concurrent action require preconditions
negative case interaction add effects analogous interaction
positive preconditions delete effects moving targets rule makes
cost determining whether set actions applied concurrently polynomial
size set actions pre post conditions
definition mutex actions two grounded actions b non interfering
gp rea addb delb gp reb adda dela
adda delb addb dela
la rb ra lb
la lb la lb
two actions non interfering mutex
last clause definition asserts concurrent actions update
values additive assignment effects
ready define conditions simple plan valid
separate executability plan whether actually achieves intended goal
say plan valid executable achieves final goal executability
defined terms sequence states plan induces sequentially executing
happenings defines
definition happening execution given state x happening h
activity h set grounded actions
ah name h valid p rea satisfied x
executing happening h associated time th state x
undefined ah
h pair actions ah mutex otherwise state


th x



dela
adda
aah



x

aah

applying composition functions npfa ah x

since functions npfa ah must affect different primitive numeric expressions
except represent additive assignment effects functions commute


fifox long

therefore order functions applied irrelevant therefore value
x well defined last definition requirement activity happening
must number elements happening simply constraint
ensures action name happening leads valid action applicable
appropriate state already seen conditional effects induce construction
families grounded actions one family applicable
state none applicable given name must mean
precondition unsatisfied regardless conditional effects case asserting
attempt apply action undefined interpretation
definition executability simple plan sp instance executable
defines happening sequence ti k sequence states si k
initial state instance k si
executing happening time ti sp
state sk called final state produced sp state sequence si k
called trace sp note executable plan produces unique trace
definition validity simple plan simple plan instance
valid executable produces final state goal specification
satisfied

semantics durative actions
plans durative actions discrete effects given semantics terms
semantics simple plans handling durative actions continuous effects
complex discuss section
durative actions appearing plan must given additional field indicating
duration given syntax
action p pn
rational valued duration written floating point syntax
durative actions introduced framework defined far generalising
definition include durative action schemas definition grounded action must
extended define form grounded durative actions however definition
given way associate durative action two simple nondurative actions corresponding end points durative action simple
actions together simulate almost behaviour durative action
aspects captured pair simple actions duration durative
action invariants must hold duration two elements
however simply handled minor extension semantics simple plans
adopt taking route avoid difficulties establishing
effects interactions durative actions handled semantics
concurrent activity within simple plan see one difficulty account
handling durative actions conditional effects contain conditions effects
associated different times conditions must hold entire duration


fipddl expressing temporal domains

action since cases complicate semantics postpone treatment
next section begin durative actions without conditional effects
mapping durative actions non durative actions important consequence mutex relation implied non durative actions advantageously
weaker strong mutex relation used example tgp smith weld
two durative actions applied concurrently provided end points one action
interact end points simultaneous invariants
action
definition grounded durative actions durative actions grounded
way simple actions see definition replacing formal parameters constants instance expanding quantified propositions definition
durative actions requires condition conjunction temporally annotated propositions temporally annotated proposition form start p end p
p p unannotated proposition similarly effects durative action without continuous conditional effects conjunction temporally
annotated simple effects
duration field da defines conjunction propositions separated
da dc da duration conditions start end da terms
dcstart
end
arithmetic expressions duration separation conducted obvious way
da end conditions dc da
placing start conditions dcstart
end
grounded durative action da continuous effects conditional effects
defines two parameterised simple actions dastart daend parameter
duration value single additional simple action dainv follows
dastart daend precondition equal conjunction set propositions p start p end p condition da together
da dc da effect equal conjunction simple effects e
dcstart
end
start e end e effect da respectively
dainv defined simple action precondition equal conjunction
propositions p p condition da empty effect
every conjunct condition da contributes precondition precisely one
dastart daend dainv every conjunct effect da contributes effect
precisely one dastart daend convenience dastart daend dainv used
refer entire respective simple action name
actions dastart daend parameterised duration parameter
must substituted correct duration value order arrive two simple
actions corresponding start end durative action
definition plans plan p durative actions instance consists
finite collection timed actions pairs form
rational valued time simple action name action schema name together
constants instantiating arguments schema form
rational valued time durative action name non negative rational valued
duration


fifox long

definition induced simple plan p plan happening sequence p
ti k ordered sequence time points formed set times
p p p
induced simple plan plan p simplify p set pairs defined follows
p simple non durative action name
astart duration aend duration expressions
simple timed actions square brackets denote substitution duration
case pairs p durative action name
ti ti ainv pair p ti
ti ti happening sequence p
process transforming plan simple plan involves introducing actions
represent end points intervals durative actions plan
applicable duration constraints convert simple preconditions start end actions
requiring substitution numeric value duration field complete conversion simple actions complication process invariants cannot
associated end points must checked throughout interval
achieved adding simple plan collection special actions responsible checking invariants actions added pair happenings original
plan lying start end point durative action semantics
simple plans requires preconditions actions plan satisfied even though
might effects consequence putting monitoring actions
simple plan ensure original plan judged valid invariants remain
true firstly start durative action subsequently happening
occurs throughout duration durative action one possibility make
monitoring actions occur times updating actions would require
values accessed time might updated violating
moving targets rule order avoid monitoring actions interleaved
updating actions inserting midway pairs successive happenings
interval durative action executed happenings original plan need considered carrying insertion since invariant checking
actions cannot effect states checked
alternative treatments invariants possible important advantage
taken semantics rests finally state transition model
form familiar community plans seen recipes
state transition sequences state transition function current
state world next however durative actions complicate picture
rely commitment durative action started follow
completion commitment involves sort communication across duration
plan communication managed structures outside plan examine
care taken reading definition last disjunct allows time corresponding
end execution durative action included happening time



fipddl expressing temporal domains

trace artificial modification plan ensure states carry extra
information start end durative action latter
disadvantage durative actions become complex artificial components
must added plan become intrusive particularly apparent
treatment conditional effects require conditions tested start durative
action across duration effects triggered end since cases
require sort memory state remember status tested conditions
start durative action end point memory conditions allow
us avoid embedding entire execution history state substituting ad hoc
memory history propositions times required
management conditional effects form mapping durative actions
simple actions discussed section
conclude definitions supporting validity plan durative
actions
definition executability plan plan p instance executable induced simple plan p simplify p executable producing trace
si ti si vi k
definition validity plan plan p instance valid
executable goal specification satisfied final state produced induced
simple plan
durative actions conditional effects
explain mapping described previous section extended deal
durative actions containing conditional effects
first observe temporally annotated conditions effects accumulated
temporal annotation distributes logical conjunction therefore
convert conditional effects conditions simple conjunctions
one start condition one end condition one condition
noted allow logical connectives conjunction combining temporally annotated propositions allowing connectives would create significant
complexity semantics create potentially paradoxical opportunities
communication future states earlier states similarly conditions durative action
effects reduced conjunction one start effect one end
effect treatment conditional effects divides three cases first case
straightforward effect durative action form p q
condition effect bear single temporal annotation transformed simple conditional effect form p q attached start end
simple action according whether start end since case straightforward
explicitly extend previous definitions cope second case one
condition condition effect start conditions effect end
effects
note consider conditional effects effects occur start
conditions dependent state end duration action


fifox long

meaningless reverse expected behaviour causality cause
precedes effect attempt validate plan constructing trace reversed
causality would huge since could determine initial effects applying durative action seen conditions held subsequent interval
conclusion activity equally could see effects activity interval would without seeing initial effects applying durative action
paradox created opportunity action change past
handle second case need modify state start durative action remember whether start conditions satisfied communicate
end durative action simply looked current state
determine whether conditional effect applied apply transformation
conditional effects form start ps end pe end q
conditional effect added start simple action ps mps conditional effect added end simple action pe mps q mps
special proposition unique particular conditional effect particular application durative action transformed ensuring proposition unique
way possibility action plan interfering
represents isolated memory fact ps held state durative
action started conditional effect end conditions transformation applied simply ignoring pe previous discussion figure depicts
transformation single durative action conditional effect collection
level actions complete appropriate memory proposition case called
p
importance memory introduced transformation explained figures figure shows ambiguity remembering
state trajectory plan reached figure illustrates one
state p q r point durative action described figure ends
impossible determine state alone whether r added
possible reached state p q r least two different paths
least one path seen started state p held least one path
seen started state p hold action achieve p p
effect state p q r contain information disambiguate
path used reach hence cannot determine correct value r
ends
third final case durative action conditional effects form
start ps pi end pe end q

effect start end conditions following transformation
applied simply ignoring ps pe appropriate case need construct transformation remembers whether ps held state durative
action first applied whether pi holds throughout interval start
end durative action unlike invariants durative actions conditions
required hold plan valid determine effects occur
end durative action idea use intervening monitoring actions rather
invariants definition achieved adding effect start


fipddl expressing temporal domains

initial durative action
durative action
parameters
duration duration
condition
effect start p end q
end r

transformation simple actions
action start
parameters
precondition
effect p p

action end
parameters
precondition
effect p q r

expansion conditional effects
action start
parameters
precondition p
effect p

action start
parameters
precondition p
effect

action end
parameters
precondition p q
effect r

action end
parameters
precondition p q
effect

transformation plan simple plan
plan

plan



start
end

figure conversion durative action non durative actions grounded
forms



fifox long

p q r

start
end
p q r

p q
r

start
p q

achieve p

p q
r

r

figure flawed state space resulting failure record path traversed conditional effects span interval durative action arc labelled achieve p
indicates possible application action achieves proposition
p
start
p q
r p

p p
q r

end

achieve p
p q
r p

start

p q
r p

p q
r p
end
p q
r p

p q
r p

figure correct state space showing use memory proposition p arc labelled
achieve p indicates possible application action achieves
proposition p

action mpi monitoring simple actions required precondition single conditional effect mpi pi mpi
mpi special proposition unique conditional effect application
instance durative action transformed monitoring actions added
intermediate points used monitoring actions definition
transformation used second case required start condition
ps ps mps added conditional effect start simple action finally
add conditional effect end simple action mps mpi pe q
effect machinery ensure proposition pi becomes false time
start end durative action mpi deleted otherwise
end durative action mps hold precisely ps held start action
mpi hold precisely pi held entire duration durative action
therefore conditional effect end action achieves intuitively correct behaviour
asserting conditional effect precisely start condition held start
durative action end condition holds end durative action
condition held throughout duration action
addition memory checking actions means longer true
claim added actions cannot change state however memory propositions
unique task communication single action instance effects
memory checking actions might implications invariants


fipddl expressing temporal domains

semantics continuous durative actions
introduction continuous durative actions complicates semantics longer
possible handle invariants insertion simple actions happenings
plan test continued satisfaction fact continuous effects principle cause
invariant satisfied parts interval others ignoring
invariants moment updates numeric values caused continuous effects
applied discrete updates time points within interval apply
updates behave slightly differently discrete updates seen durative actions
discrete effects since possible continuous update affect variable
concurrently affected discrete update examined precondition without creating
inconsistency example water heating action figure applied
concurrent addition egg pan precondition temperature
water degrees value temperature examined
moment application action adding egg temperature
change actually happening interval start heating
point egg added rather discrete update point egg
added temperature actually changed instant addition egg
section summarise semantics continuous actions semantics
discrete durative actions defined terms familiar state transition semantics
continuous semantics introduces different formulation
definition continuous durative action continuous effect effect expression includes symbol continuous durative action durative action
least one continuous effect
definition continuous update function let c set ground continuous effects
instance st x state continuous update function
defined c state st function fc r rn n dimi
dfc
g
dt

fc x
g update function generated action
n pa op p q op p q c
definition shows continuous effects several continuous durative actions
combined create single system simultaneous differential equations whose solution
given appropriate starting point defines evolution continuously varying values
definition induced continuous plan let instance includes
continuous durative actions p plan induced continuous plan p
triple invs cts simplif p invs set invariant constraints
invs q p q invariant


fifox long

let ti ti two consecutive times happening sequence simplif p
set active continuous effects ti ti
q p ti ti q continuous effect
cts set systems continuous effects
cts c ti ti c set active continuous effects ti ti
components continuous plan separate invariant conditions continuous effects rest simple plan order allow correct application
continuous updates allow confirmation invariants hold face
continuous effects
definition trace let instance includes continuous durative actions p plan sp inv cts induced continuous plan p ti k
happening sequence initial state trace p
sequence states si k defined follows
element c ti ti cts si state resulting applying
happening ti simple plan sp state si
c ti ti cts let ti state formed substituting f ti ti
numeric part state si f continuous update function defined c
state si si state resulting applying happening ti
simple plan sp state ti f undefined element cts
trace
definition defines trace similar fashion traces simple plans plans
durative actions key difference need apply continuous updates
handled solving systems simultaneous differential equations across interval
active applying update numeric values across
interval course easier describe since solving arbitrary
simultaneous differential equations algorithmically generally possible certain
constraints semantics implemented order confirm validity plan
automatically
definition invariant safe let instance includes continuous durative actions p plan inv cts induced continuous plan p
si k trace p c ti ti cts let continuous update
function defined c si p invariant safe defined
q u inv ti ti u x num q x
logical state si
definition symbols used mean interval closed
open end


fipddl expressing temporal domains

semantic point view invariants must checked every point interval apply interval contains finitely many discrete changes
obligation met considering finite number points
change occurs fact exploited discrete durative action plan semantics definition continuous change obligation much harder meet
practice invariants checked examining possible roots function describing continuous change finding roots difficult general
suitable constraints forms differential equations expressed domain make
validation tractable
last two definitions simply assemble components arrive analogous definitions executability validity simple plans plans durative actions
definition executability plan plan p containing continuous durative actions
instance induced continuous plan invs cts p executable
trace p defined si k invariant safe
definition plan validity plan p containing durative actions instance
valid executable trace si k sk satisfies goal

plan validation
plan validation important part use pddl particularly role
competition approximately plans consider competition
seen automation essential validation tractable propositional
versions pddl plans finite validated simply simulation
execution issue complicated pddl potential concurrent
activity possibly face numeric change makes necessary ensure invariant
properties protected concurrent activity non interfering
durative actions used question whether plan
considered valid contain end points actions initiated
plan action exploited plan effect end duration
clear end point present plan action selected
start effect less clear match striking action performed start effect
order burned match end brief interval could argued
obtained desired start effect end action irrelevant
plan terminate soon goals achieved without ensuring initiated
actions end safely indeed plan search process sapa kambhampati
terminate whilst still queued events awaiting advancement time however
possible conceive situations end point action incorporated
start effect introduces inconsistencies plan inclusion would
make plan invalid cases seems plan validity could compromised
ignoring end effects
order avoid resolve complexities taken view
pddl plan valid action start end points explicit within plan
identified case proceed confirm happenings within
plan mutex free


fifox long

plan validation decidable domains including discretized certain constraints continuous durative actions activity encapsulated durative
actions explicitly identified plan makes trace induced plan finite
hence checkable therefore observe validation pddl decidable
even actions contain duration inequalities work determining
duration inequalities solved already completed finished
plan validation plan proceed simulation execution case
pddl plans tractable domains without continuous effects
introduction continuous effects principle allow expression domains
complex functions describing numeric change howey long assumption
continuous effects restricted description terms simple linear quadratic
functions without interactions concurrent continuous effects plan validity
tractable cost practice increased however since may necessary solve
polynomials order check invariants validation plans containing complex
expressions change explored
although plan validity checking tractable subtlety arises
need represent plans syntactically difficulties involved expressing numbers arbitrary precision principle values required describe
valid plans algebraic assuming constrain continuous effects indicated
therefore finitely representable practice expecting planners handle numbers
algebraic expressions seems unnecessarily complicated far reasonable assume numbers represented finite precision floating point values indeed
syntax adopted expression plans restricts planners expressing times
finite precision floating point values constraint limitations
precision floating point computations implementations plan validation systems
necessary take pragmatic view validation process accept
numeric conditions evaluated certain tolerance otherwise occur
way report plan necessary degree accuracy
valid interpretation semantics defined section cases plan
specifies time points example four significant digits reasonable abstraction
execution time activity needed control flow system plan specify
time points absolutely precisely abstraction forced upon planner fact
working world physical world
one relationship theoretical semantics pragmatic concerns
automated validation
figure relationship depicted terms kinds plans automatically validated left side picture describes theoretical semantics
arrow indicating link plans interpretation theoretical
semantics example possible construct
domain plan

requires action happen time meaningful semantic object
plan specifies theaction happen time meaningful semantic object
equal two plans distinct one correct
assumed constraints right side picture depicts pragmatic validation
syntactic plan objects two control plans though distinct semantics map
syntactic object assume validation subject tolerance


fipddl expressing temporal domains

semantic interpretation plans

validation plans

mapping semantics pragmatic
realisation automated validation process

semantic plan objects




fifffi


















mapping semantic plans syntactic
counterparts



syntactic plan objects

specific pair mappings

figure pragmatic mapping semantics plans validation
automated computational processes shaded area contains plans cannot
interpreted within theoretical semantics seen plan
collection indistinguishable meaningful plan mapped
syntactic side picture

plans map syntactic object approximates value
syntactic plan validated pragmatic validation processes necessary
automatic validation describable syntactic plans check validity subject
tolerance pragmatic constraints representations plans
expectations representations numeric values planners validators
consequences reasonable assumptions given check
validity case abstractions non zero tolerance world practice
accept plans specified tolerance levels pathological cases
arithmetic precision computer representations floats immediate negative
impact one tries take stronger line plans accepted
strictly valid according formally precise evaluation expressions
finally interesting philosophical issue arises discussed henzinger co authors fact possible achieve exact precision
measurement time continuous numeric quantities henzinger et al
considered development robust automata robust automata
accept trace exists tube traces within distance original
trace acceptable original acceptance criteria called fuzzy
tubes indicating time fuzzily rather precisely detectable idea offers path
formal semantics closer defining plans robust imprecision
executives ability measure time unfortunately checking fuzzy tubes intractable
currently compromise adopting value used tolerance checking
numeric values fulfil numeric constraints plan execution represent minimum separation conflicting end points within plans consistent idea
planner assumes executive willing abstract indicated tolerance
level checking preconditions actions unreasonable suppose
plan make use finer grained measurements determining actions


fifox long

applied moment value set validation process communicated informally planner engineers might better allow domain designer
define appropriate use particular domain remain several issues
concerning correct management buffers validation particularly usual
concerning transitivity fuzzy closeness important issues
temporal reasoning whole restricted context
yet solutions

related work representing reasoning time
representation reasoning statements time temporal extent
propositions long subject ai including allen
mcdermott sandewall kowalski sergot laborie ghallab
muscettola bacchus kabanza important issues raised
extension pddl handle temporal features course already examined
researchers example shanahans work continuous change within
event calculus shohams work reichgelts work temporal reasoning work non reified temporal systems bacchus tenenberg koomen
vila provides excellent survey work temporal reasoning ai section
briefly review central issues addressed treatment
literature set pddl context temporal logics
several researchers temporal logics considered reasoning
concurrency continuous change temporal extent works focussed
reasoning change world described arbitrary logical
formulae concerned making meta level statements
effect cannot precede cause need handle complex logical formulae makes
frame difficult resolve circumscription mccarthy
default reasoning reiter typical strips assumption provides
simple solution frame states described atomic formulae
classical assumption states described atomically
general view modelling change although simplifying assumption
surprisingly expressive bench mark domains introduced third international
competition suggest atomic modelling powerful enough capture
complex domains closely approximate real temporal reasoning issues
confront simplified consequence made simplifying assumption
states updated remain concerned major issues temporal
reasoning concurrency continuous change temporal extent
development pddl made basic decision consider end points
durative actions instantaneous state transitions allows us concentrate
truth propositions points instead intervals decision consider actions
way similar made many temporal reasoning researchers shanahan
mccarthy hayes mcdermott context pddl
advantage smoothly integrating classical view actions state
transitions nevertheless allen shown temporal ontology intervals
basis allen several systems


fipddl expressing temporal domains

strongly influenced intervals muscettola rabideau knight chien
fukunaga govindjee allen later moved away initial position instants
required introducing notion moments hayes allen
concept attempts reconcile stance nothing instantaneous
intervals observation changes values discrete valued variables
propositional variables apparently cannot avoid changing instants view
consistent take modelling continuous durative actions
view change consisting discrete continuous aspects henzinger

remainder section compare pddl extensions propose
previous work temporal reasoning considering three central issues identified
objective claim extensions improve previous work instead
demonstrate implementation solutions three within pddl
framework makes exploitation directly accessible way
embedded within logic accompanying proof theory
continuous change
several temporal reasoning frameworks began consideration discrete change
later extended handle continuous change example shanahan extended
event calculus kowalski sergot enable modelling continuous
change process extension mirrors situation faced extending pddl
system modelling discrete change already existed therefore interesting compare
use pddl use systems extended event calculus
sink filling example shanahan discusses issues termination events
self termination termination events identification level water
sink filling process effect rate change level water
sink filled two sources simultaneously behaviour filling
process effects state sink time modelled axioms would
allow inference engine predict state sink points execution
process
pddl allows representation complex interactions arise sink
filled multiple independently controlled water sources means concurrent durative
actions continuous effects encapsulate initiation filling process
single water source change level water sink termination
process water source turned model robust since easily
accommodates multiple water sources simply modifying rate flow appropriately
commutative updates since actions additive effects model provides
rate water enters tank source possible compute level
water sink point filling interval concurrent action might
consult level contrast shanahans extension event calculus
require filling process least point view logical
axiomatisation terminated restarted rate water source opened
closed since process simply remains active throughout change rate filling


fifox long

reflected piecewise linear profile depth water sink
shanahans model
possible model multiple water sources situation filling process
completely encapsulated within discretized durative action discretized action
true level water accessible filling process end start
step function behaviour coarsely approximates true behaviour consequence
complex interactions cannot properly modelled
one important consequences continuous behaviour triggering events
shanahans extensions achieved axiomatisation causal relationships
events distinguished syntactically actions fact
happening axiomatically consequence certain conditions pddl events
flooding sink filling continues capacity reached
modelled combination conditional effects duration inequalities
however events modelled way since possible predict
spontaneous events occur pddl could extended allow expression
causal axioms alternative modify language enable
representation events within action oriented tradition achieved
breaking continuous durative actions instantaneous start end points
processes encapsulate would enable execution process initiated
start action ended instantaneous state transition action
control planner event simple extension language needed
distinguish actions events prevent planner deliberately selecting
event refer start process stop model extended
pddl support fox long resulting language pddl difficult
plan pddl still open questions concerning complexity
plan validation language remain topics future work
concurrency
opportunity concurrent activities complicates several aspects temporal reasoning
firstly necessary account actions concurrent secondly
necessary describe concurrent activities interact effects world
formalisms first points achieved relying underlying logic
deliver inconsistency attempt made apply two incompatible actions simultaneously example axioms event calculus yield simultaneous
truth falsity fluent incompatible actions applied simultaneously consequently yield inconsistency unfortunately recognising inconsistency general
undecidable sufficiently expressive language pddl adopt solution
exploits restricted form action centred formalism defining circumstances
two actions could lead inconsistency rejecting simultaneous application
actions favour conservative restriction compatibility actions
moving targets rule order support efficient determination incompatibility rather
permissive elusive ruling alternative adopted bacchus
tlplan example allow multiple actions occur instant
nevertheless executed sequence solution counter intuitive


fipddl expressing temporal domains

importantly consider would impossible use plan sort instruction
executive executive could equipped execute actions simultaneously yet
specified order view order execution matters executive
must ensure actions sequenced within limitations
capability measure time react passing
shanahan discusses gelfonds example soup bowl
concerns raising soup bowl without spilling soup two actions lift left
lift right applied bowl applied soup spill
argued applied simultaneously bowl raised table
soup spills shanahan considers example within event calculus uses
explicit assertion interaction lift left lift right actions ensure
spillage effect cancelled pair executed together assumption
two actions executed precisely moment reasoner
rely successful simultaneity order exploit effect
pddl take view precise simultaneity outside control
physical executive plan interpreted instruction executive system
hold executive system capable measuring time controlling activity
arbitrarily fine degrees accuracy particular possible executive
ensure two actions must independently initiated executed simultaneously
plan rely precision measurement claim could
executed reliable expectation success therefore considered
valid plan
pddl supports modelling soup bowl situation following way two
durative actions lift left lift right independently initiate tilting intervals
complete spillage soup effects counteracted
provided two lift actions start within appropriate tolerance one another
tilting corrected spillage avoided without need model cancellation
effects argue executive execute two actions within fine
non zero tolerance one another therefore successfully lift bowl event
calculus model presented shanahan insists precise synchronization two actions
incorrectly allowing inferred soup spilled even time
elapses two lifts actually small enough allow correction tilting
bowl worse shanahans axioms would allow lack precise synchronization
exploited achieve spillage amount time smaller correctly describing
physical situation modelled
one considers unnecessary model precise interaction two lifts
one alternative pddl abstract interaction see soup bowl
lifting action single discretized action achieves successful raising bowl
temporal extent
common concern temporal reasoning frameworks discussed detail vila
others vila van bentham divided instant
apparent considering happens moment transition say
truth falsity propositional variable question must addressed whether


fifox long

proposition true false undefined inconsistently true false instant
transition clearly last possibilities undesirable solution adopt
combination pragmatic philosophically principled pragmatic element
choose model actions instantaneous transitions effects beginning
instant application thus actions mark end points intervals persistence
state closed left open right ensures intervals nest
together without inconsistency truth values propositions defined
half open half closed solution adopted elsewhere example shanahan
observes similar used event calculus although intervals
closed right although two choices effectively equivalent slightly
prefer closed left choice since allows validation plan conclude
state point execution final action making determination
temporal span plan unambiguous
philosophical point view truth value proposition instant
application action cannot exploited action virtue
moving targets rule position outlined valid plan cannot depend
precise synchronisation actions forces actions require proposition
precondition sit open end half open interval proposition holds
time
classical time treated relative temporal structuring plan reasoning plan ordering actions
clearly emphasised issues dominated late
early classical mainly characterised exploration partial
plan spaces planners tweak chapman snlp mcallester rosenblitt
ucpop penberthy weld partial plans include collection actions
representing activity thus far determined part possible plan set
temporal constraints actions temporal constraints used partial plan
form b b time points corresponding application
actions
classical linear planners fikes nilsson russell norvig rely
simple fact total ordering points actions applied trivially
embedded time line duration actions considered role
time becomes far significant metric time introduced metric
time possible associate specific durations actions set deadlines windows
opportunity associated relative time still resolved
metric time framework introduced particular durations become
explicit necessary decide durations attach actions states
explicit temporal extents make important confront issue concurrency
order best exploit measured temporal resources available planner
contrast simple ordering constraints required relative time metric time
requires powerful constraint management metric time constraint handlers
built around foundations laid dechter meiri pearl example ixtet
uses extensions temporal constraint networks laborie ghallab language


fipddl expressing temporal domains

ixtet uses represent domains similar pddl described
expressive allows access time points within interval
durative action added expressive power obtained cost increased semantic
complexity consequently increased difficulty validation plans however
many similarities modelling discretised durative actions pddl
ixtet similar modelling conventions found languages sapa
kambhampati oplan drabble tate
one earliest planners consider use metric time deviser vere
developed nonlin tate deviser metric constraints times
actions could applied deadlines achievements goals
expressible planner could construct plans respecting metric temporal constraints
interactions actions cesta oddi explored developments temporal constraint network achieve efficient implementation
galipienso sanchis consider extensions manage disjunctive
temporal constraints efficiently particularly valuable expressive element plan
construction observed since constraints preventing overlap intervals translate disjunctive constraints time points hsts muscettola relies
temporal constraint manager
systems use continuous real valued time possible make use linear
constraint solvers handle temporal constraints particular constraints dictated
relative placement actions durations timeline approached
way long fox alternative timeline often used discretised line
integers advantage possible advance time
next value considering activity given time point next modality
interpreted continuous time framework taking mean state following
next logical change regardless time occurs bacchus kabanza
events occur actions dictated
planner continuous change modelled plans finite structures therefore
change occur finite number time points execution makes
possible embed execution plan integer valued discrete time line
without loss expressiveness
researchers considered modelling continuous change pednault proposes explicit description functions govern continuous change
metric parameters attached actions effect instantaneous change initiate
processes however easy use describing interacting continuous
processes example water filling tank constant rate additional
water source added increase rate filling action initiating second
process must combine effects two water sources means second
action cannot described simply terms direct effect world increase
rate flow tank reference effects actions
already affected rate change parameter shanahan uses
consequence processes modelled stopping restarting
trajectories interacting action applied
zeno penberthy weld actions effects described terms
derivatives makes easier describe interacting processes complicates


fifox long

management processes making necessary solve differential equations
complication deterred authors taking mcdermott
takes process planner
introduction continuous processes represents considerable complication even model includes temporal features supports
concurrency area active community yet agreed
matters representation let alone semantics remain many open
community address development languages development plan verification tools embody widely
accepted semantics

conclusions
recent developments ai leading community closer
application technology realistic necessitated
development representation language capable modelling domains temporal
metric features taken towards development language
extend mcdermotts pddl domain representation standard support temporal
metric
development pddl sequence towards greater expressive power important
community pddl provided common foundation great
deal recent effort involved modelling behaviour domains
discrete continuous behaviours well explored temporal logic
model checking communities widely adopted within
community work pddl provides way making relevant
developments communities accessible furthermore pddl begins
bridge gap basic applications oriented providing
expressive power necessary capture real
pddl expressive power represent class deterministic mixed discretecontinuous domains domains language introduces form durative action
three connected parts initiation interval numeric change
might occur explicit termination means action produces state
corresponding end durative interval form action allows modelling
discrete continuous behaviours discretized change represented
means step functions whilst continuous change modelled variable
language provides solutions critical issues concurrency continuous change
temporal extent semantics language derived familiar state
transition semantics strips extended interpret invariants holding intervals
continuous functions might active semantics allows us interpret
plans efficiently validate describe criteria plan must satisfy
order practically verifiable
focussed primarily discussion numeric discretised temporal features pddl however modelling capability discretized durative actions
respects limited important community address
challenges presented continuous change indeed even continuous actions


fipddl expressing temporal domains

pddl possible model episodes change terminated spontaneous
events world rather deliberate choice planner future goals
community include addressing domains require continuous actions
pddl confronting challenges within dynamic environments
intervals change terminated world well deliberate action
planner constitute important step towards within dynamic
unpredictable environments

acknowledgements
would thank members committee third international
competition particular discussions drew mcdermott fahiem bacchus david
smith hector geffner turns infuriated intrigued delighted us contributed
immeasurably strengths many others offered comments
insights allowed us develop work present would thank
jorg hoffmann malte helmert antonio garrido stefan edelkamp nicola muscettola
mark boddy keith golden jeremy frank ari jonsson julie porteous alex coddington
stephen cresswell luke murray keith halsey richard howey many helpful
discussions shared



fifox long

appendix bnf specification pddl
appendix contains complete bnf specification pddl language
strict superset pddl x example use local variables within action schemas
left specification widely used part language
used competition domains interpretation local variables
proposed mcdermott subtle since demands confirmation unique instantiation
exists variable non trivial confirm case plan
validation domains significant expressive power fact largely
ignored suggests poorly understood changes discussed following
sections
domains
domain structures remain essentially specified pddl x main alterations
introduce slightly modified syntax numeric fluent expressions remove
syntax hierarchical expansions latter necessarily abandoned
best knowledge used publicly available systems even
domains original pddl specification distinction drawn strict pddl
non strict pddl strict pddl must follow ordering fields specified
non strict pddl restricted way practice relatively fields
intuitive accept arbitrary orders natural expect declarations
precede use symbols preconditions precede effects however declarations
constants predicates function symbols naturally ordered current
definition pddl ordering fields must follow specification
exception three fields legal order respect one another
although group must follow types precede action specifications
domain

define domain name
require def
types def typing
constants def
predicates def
functions def fluents
structure def
require def
requirements require key
require key
see section
types def
types typed list name
constants def
constants typed list name
predicates def
predicates atomic formula skeleton
atomic formula skeleton
predicate typed list variable
predicate
name
variable
name
atomic function skeleton
function symbol typed list variable
function symbol
name
functions def
fluents functions function typed list
atomic function skeleton
structure def
action def
structure def
durativeactions durative action def



fipddl expressing temporal domains

slight modification made type syntax longer possible
nest expressions possibility never exploited complicates parsing
numbers longer considered implicit type extension numbers
handled functional expressions ensures finitely many
ground action instances desirable consequence action selection choice points need
never include choice arbitrary numeric ranges use finite ranges integers
specifying actions useful see mystery freecell example extension
standard syntax allow convenient representation cases could
useful syntax function declarations allows functions declared types
present syntax restricted number types since semantics
functions syntax offers scope possible extension types given
function assumed numbers
typed list x
typed list x
primitive type
type
type

x
typing x type typed list x
name
primitive type
primitive type

function typed list x x
function typed list x typing x function type
function typed list x
function type
number

actions
bnf action definition given simplified removing
generally unused constructs mainly hierarchical expansions emphasised
removal intended permanent exclusion hierarchical expansion syntax
proved difficult element language agree exploit
levels language stabilise hope return layer redevelop
action def

action action symbol
parameters typed list variable
action def body
action symbol
name
action def body precondition gd
effect effect

goal descriptions extended include fluent expressions
gd
gd
gd
gd


atomic formula term
negativepreconditions literal term
gd



fifox long

gd
gd
gd
gd
gd
gd
f comp
literal
literal
atomic formula
term
term
f exp
f exp
f exp
f exp
f head
f head
binary op
binary op
binary op
binary op
binary comp
binary comp
binary comp
binary comp
binary comp
number

disjunctivepreconditions gd
disjunctivepreconditions gd
disjunctivepreconditions imply gd gd
existentialpreconditions
exists typed list variable gd
universalpreconditions

forall typed list variable gd
fluents

f comp
binary comp f exp f exp
atomic formula
atomic formula
predicate
name
variable
number
binary op f exp f exp
f exp
f head
function symbol term
function symbol









numeric literal
integers floats form n n

effects extended include functional expression updates syntax proposed little different syntax proposed earlier version pddl
syntax conditional effects proposed fahiem bacchus aips adopted
nesting conditional effects supported assignment operators
prefix forms simple assignment called assign previously change operators corresponding c update assignments given names
increase decrease scale scale respectively prefix form
adopted preference infix form order preserve consistency lisp
syntax non c names help c c programmers remember
operators used prefix form prefer assign original change
introduction increase makes nature change ambiguous
effect
effect
effect
c effect
c effect
c effect
p effect
p effect
p effect


c effect
c effect
conditionaleffects forall variable effect
conditionaleffects gd cond effect
p effect
assign op f head f exp
atomic formula term
atomic formula term



fipddl expressing temporal domains

p effect
cond effect
cond effect
assign op
assign op
assign op
assign op
assign op

fluents assign op f head f exp
p effect
p effect
assign
scale
scale
increase
decrease

durative actions
durative action syntax built relatively conservative extension existing action
syntax
durative action def durative action da symbol
parameters typed list variable
da def body
da symbol
name
da def body
duration duration constraint
condition da gd
effect da effect

conditions durative action executed complex
standard actions specify conditions must hold point
execution specify conditions must hold throughout duration
durative action termination distinguish components introduce
simple temporal qualifier preconditions use name precondition would
somewhat misleading given conditions described include constraints
must hold action begun motivated adoption condition
describe collection constraints must hold order successfully apply
durative action logical form conditions durative actions restricted
conjunctions temporally annotated expressions clearly scope future
extension allow complex formulae
da gd
da gd
da gd
timed gd
timed gd
time specifier
time specifier
interval











timed gd
timed gd
time specifier gd
interval gd
start
end


duration duration durative action specified equal given
expression function numeric expressions else constrained
inequalities latter allows actions conclusion action
freely determined executive without necessarily side effects
example walk two locations could made take long executive


fifox long

considered convenient provided least long time taken walk
locations fastest walking speed possible constraints specify
exact duration durative action might prove harder handle introduced
label duration inequalities signal domain makes use duration
constraint supplied dictate limit temporal extent durative action
duration implicit parameter durative action must supplied plan
uses durative actions denote durative action denoted plan
name arg argn non negative rational valued duration
floating point format n n duration constraints explicitly temporally annotated
indicate evaluated context start end point action
else left unannotated case default evaluated
context start action indicated definition
duration constraint
duration constraint
duration constraint
simple duration constraint
simple duration constraint
op
op
op
value
value



durationinequalities

simple duration constraint

simple duration constraint
op duration value
time specifier
simple duration constraint
durationinequalities
durationinequalities

number
fluents f exp





addition logical effects occur start end durative action
durative actions numeric effects refer literal duration sophisticated durative actions make use functional expressions describing effects
occur duration action allows functional expressions updated
continuous function time rather step functions
da effect
da effect
da effect
da effect
da effect
da effect
timed effect
timed effect
timed effect
f assign da
f exp da
f exp da
f exp da
f exp da


da effect
timed effect
conditionaleffects forall variable da effect
conditionaleffects da gd timed effect
fluents assign op f head f exp da
time specifier effect
time specifier f assign da
continuouseffects assign op f head f exp
assign op f head f exp da
binary op f exp da f exp da
f exp da
durationinequalities duration
f exp

note duration term used define functional expression updating
effects duration constraints requirement set cases
duration value available expression whereas duration constraints provided
duration sometimes freely selected within constrained boundaries


fipddl expressing temporal domains

assign op
assign op
f exp
f exp
f exp







increase
decrease
f exp
f exp


symbol used represent period time given durative action
active therefore local clock value duration independent similar
clocks duration discussion members committee
use expression proposed expression declaring
rate change alone could used decided grounds
assertion rate change suggests rate change determined one process
effect alone fact intended multiple active processes affect fluent
effects accumulated expression directly defines amount
process contributes change fluent value time appear
assert inconsistently fluent multiple simultaneous rates change

specifications modified exclude several generally unused
constructs named initial situations expansion information removed
length specification odds intention supply physics advice
furthermore advice field offers emphasises coarse plan metric instead
introduced optional metric field used supply expression
optimized construction plan field states whether metric
minimized maximized course planner free ignore field make
assumption plans fewest steps considered good plans however
consider extension crucial one development widely applicable
language provided variable total time takes value
total execution time plan allows us conveniently express intention
minimize total execution time
anticipate extensions plan metric syntax prove necessary
longer term believe version already provides significant challenge
community specifications still somewhat impoverished terms
ability easily specify temporal constraints goals non standard features
initial goal states anticipate need extension chosen leave
clean sheet future developments


define name
domain name
require def
object declaration
init
goal
metric spec
length spec
object declaration objects typed list name
init
init init el
init el
literal name



fifox long

init el
goal
metric spec
optimization
optimization
ground f exp
ground f exp
ground f exp
ground f exp
ground f exp
ground f exp
length spec

fluents f head number
goal gd
metric optimization ground f exp
minimize
maximize
binary op ground f exp ground f exp
ground f exp
number
function symbol name
total time
function symbol
length serial integer
parallel integer
length spec deprecated

requirements
table requirements pddl requirements imply others
abbreviations common sets requirements domain stipulates requirements
assumed declare requirement strips
requirement
strips
typing
negative preconditions
disjunctive preconditions
equality
existential preconditions
universal preconditions
quantified preconditions
conditional effects
fluents
adl

durative actions
duration inequalities
continuous effects

description
basic strips style adds deletes
allow type names declarations variables
allow goal descriptions
allow goal descriptions
support built predicate
allow exists goal descriptions
allow forall goal descriptions
existential preconditions
universal preconditions
allow action effects
allow function definitions use effects
assignment operators arithmetic preconditions
strips typing
negative preconditions
disjunctive preconditions
equality
quantified preconditions
conditional effects
allows durative actions
note imply fluents
allows duration constraints durative
actions inequalities
allows durative actions affect fluents
continuously duration actions



fipddl expressing temporal domains

references
allen j towards general theory action time artificial intelligence

allen j temporal reasoning proceedings kr pp
bacchus f ady resources concurrency forward chaining proceedings ijcai pp
bacchus f kabanza f temporally extended goals annals
mathematics artificial intelligence
bacchus f kabanza f temporal logic express search control knowledge
artificial intelligence
bacchus f tenenberg j koomen j non reified temporal logic ai
artificial intelligence
blum furst fast plan graph analysis proceedings
ijcai
cesta oddi gaining efficiency flexibility simple temporal chittaro l goodwin hamilton h montanari eds proceedings
time
chapman conjunctive goals artificial intelligence
dechter r meiri pearl j temporal constraint networks artificial intelligence
b kambhampati sapa domain independent heuristic metric temporal planner proceedings ecp
drabble b tate use optimistic pessimistic resource profiles
inform search activity planner proceedings aips aaai press
el kholy richards b temporal resource reasoning
parcplan proceedings ecai
fikes r nilsson n strips application theoremproving solving artificial intelligence
fox long pddl time metric resources tech
rep department computer science university durham uk available
http www dur ac uk p long competition html
galipienso sanchis f representation reasoning disjunction temporal constraints proceedings time
garrido onainda e barber f time optimal temporal proceedings ecp
gazen b knoblock c combining expressivity ucpop efficiency
graphplan proceedings ecp pp
gelfond lifschitz v rabinov limitations situation
calculus boyer r ed essays honor woody bledsoe pp kluwer
academic


fifox long

ghallab laruelle h representation control ixtet temporal
planner proceedings aips
gupta v henziner jagadeesan r robust timed automata hart
hybrid real time systems lncs pp springer verlag
haslum p geffner h heuristic time resources proceedings
ecp toledo
hayes p allen j short time periods proceedings ijcai pp
helmert decidability undecidability numerical
state variables proceedings aips
henzinger theory hybrid automata proceedings th annual symposium logic computer science invited tutorial pp ieee
computer society press
henzinger raskin j f robust undecidability timed hybrid systems
proceedings rd international workshop hybrid systems computation
control lncs pp springer verlag
howey r long validating plans continuous effects tech rep dept
computer science university durham
jonsson morris p muscettola n rajan k interplanetary
space theory practice proceedings aips
kowalski r sergot logic calculus events generation
computing
laborie p ghallab sharable resource constraints proceedings ijcai morgan kaufmann
lifschitz e semantics strips proceedings workshop
reasoning actions plans
long fox exploiting graphplan framework temporal
proceedings icaps
long fox b overview analysis rd international
competition journal artifical intelligence issue
mcallester rosenblitt systematic nonlinear proceedings
aaai vol pp anaheim california usa aaai press mit press
mccarthy j circumscription form non monotonic reasoning artificial
intelligence
mccarthy j hayes p philosophical standpoint
artificial intelligence meltzer b michie eds machine intelligence pp
edinburgh university press
mcdermott temporal logic reasoning processes plans cognitive
science
mcdermott ai systems competition ai magazine


fipddl expressing temporal domains

mcdermott reasoning autonomous processes estimated regression
planner proceedings icaps
mcdermott aips competition committee
pddlthe domain definition language
tech rep available
www cs yale edu homes dvm
muscettola n hsts integrating scheduling zweben fox
eds intelligent scheduling pp morgan kaufmann san mateo ca
nau cao lotem munoz avila h shop simple hierarchical ordered
planner proceedings ijcai
pednault e formulating multiagent dynamic world classical framework georgeff lansky eds proceedings timberline
oregon workshop reasoning actions plans
pednault e adl exploring middle ground strips situation
calculus proceedings kr pp
penberthy j weld temporal continuous change proceedings
aaai aaai mit press
penberthy j weld ucpop sound complete partial order planner
adl proceedings kr pp los altos ca kaufmann
rabideau g knight r chien fukunaga govindjee iterative repair
spacecraft operations aspen system international symposium
artificial intelligence robotics automation space sairas
reichgelt h comparison first order modal theories time jackson
p reichgelt h van harmelen f eds logic knowledge representation
pp mit press
reiter r logic default reasoning artificial intelligence
russell norvig p artificial intelligence modern prentice hall
sandewall e features fluents representation knowledge dynamical
systems oxford university press
shanahan representing continuous change event calculus proceedings
ecai pp
shanahan event calculus explained wooldridge veloso
eds artificial intelligence today pp springer lecture notes artificial
intelligence
shoham ten requirements theory change generation computing

smith weld temporal mutual exclusion reasoning
proceedings ijcai stockholm pp
tate generating project networks proceedings ijcai
van bentham j logic time kluwer academic press dordrecht


fifox long

vere time windows durations activities goals ieee
transactions pattern analysis machine intelligence
vila l survey temporal reasoning artificial intelligence ai communications
wilkins practical extending classical ai paradigm
morgan kaufmann publishers inc san francisco ca




