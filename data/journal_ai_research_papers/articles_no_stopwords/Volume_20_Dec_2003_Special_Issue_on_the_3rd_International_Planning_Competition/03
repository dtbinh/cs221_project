Journal Artificial Intelligence Research 20 (2003) 379-404

Submitted 10/02; published 12/03

SHOP2: HTN Planning System
Dana Nau

nau@cs.umd.edu

Dept. Computer Science, Institute Systems Research
University Maryland, College Park, MD 20742 USA

Tsz-Chiu Au

chiu@cs.umd.edu

Dept. Computer Science
University Maryland, College Park, MD 20742 USA

Okhtay Ilghami

okhtay@cs.umd.edu

Dept. Computer Science
University Maryland, College Park, MD 20742 USA

Ugur Kuter

ukuter@cs.umd.edu

Dept. Computer Science
University Maryland, College Park, MD 20742 USA

J. William Murdock

murdockj@us.ibm.com

IBM Watson Research Center
19 Skyline Dr.
Hawthorne, NY 10532 USA

Dan Wu

dandan@cs.umd.edu

Dept. Computer Science
University Maryland, College Park, MD 20742 USA

Fusun Yaman

fusun@cs.umd.edu

Dept. Computer Science
University Maryland, College Park, MD 20742 USA

Abstract
SHOP2 planning system received one awards distinguished performance
2002 International Planning Competition. paper describes features
SHOP2 enabled excel competition, especially aspects SHOP2
deal temporal metric planning domains.

1. Introduction
SHOP2, Simple Hierarchical Ordered Planner 2 (Nau, Munoz-Avila, Cao, Lotem, & Mitchell,
2001), domain-independent planning system based Hierarchical Task Network (HTN)
planning. 2002 International Planning Competition, SHOP2 received one top
four awards, one two awards distinguished performance. paper describes
characteristics SHOP2 enabled excel competition.
predecessor SHOP (Nau, Cao, & Munoz-Avila, 1999), SHOP2 generates
steps plan order steps later executed, knows
current state step planning process. reduces complexity
reasoning eliminating great deal uncertainty world, thereby making
easy incorporate substantial expressive power planning system. SHOP,
c
2003
AI Access Foundation. rights reserved.

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

SHOP2 axiomatic inference, mixed symbolic/numeric computations, calls
external programs.
SHOP2 capabilities go significantly beyond SHOP:
SHOP2 allows tasks subtasks partially ordered; thus plans may interleave
subtasks different tasks. often makes possible specify domain knowledge intuitive manner possible SHOP.
SHOP2 incorporates many features PDDL, quantifiers conditional
effects.
alternative ways satisfy methods precondition, SHOP2 sort
alternatives according criterion specified definition method.
gives convenient way author planning domain tell SHOP2 parts
search space explore first. principle, technique could used
planner plans forward initial state.
SHOP2 handle temporal planning domains, way translate
temporal PDDL operators SHOP2 operators maintain bookkeeping information multiple timelines within current state. principle, technique
could used non-temporal planner sufficient expressive power.
rest paper organized follows. Section 2 gives background HTN
planning, Section 3 describes SHOP2s features planning algorithm. Section 4
describes write domain descriptions SHOP2: particular, Section 4.1 discusses
basic problem-solving strategies, Sections 4.2 4.3 describe aspects SHOP2
specific handling temporal metric domain features. Section 5 discusses SHOP2s
performance competition, Section 6 discusses related work, Section 7 gives
summary conclusion. Appendix contains SHOP2 domain description one
problem domains planning competition.

2. HTN Planning
HTN planning classical AI planning state world represented
set atoms, action corresponds deterministic state transition. However,
HTN planners differ classical AI planners plan for, plan
it.
objective HTN planner produce sequence actions perform
activity task. description planning domain includes set operators similar
classical planning, set methods, prescription
decompose task subtasks (smaller tasks). Figure 1 gives simple example.
Given planning domain, description planning problem contain initial state
classical planningbut instead goal formula, problem specification
contain partially ordered set tasks accomplish.
Planning proceeds using methods decompose tasks recursively smaller
smaller subtasks, planner reaches primitive tasks performed directly using planning operators. nonprimitive task, planner chooses
380

fiSHOP2: HTN Planning System

task:
preconditions:

task:

(transport ?p)

(at ?p ?x)
(destination p ?y)
(available-truck ?t)

(transport-two ?p ?q)

preconditions:

subtasks:

(package ?p)
(package ?q)

subtasks:

(dispatch ?t ?x) (load ?t ?p) (move ?t ?x ?y) (return ?t ?x)

task:

(transport ?p) (transport ?q)

task:

(dispatch ?t ?x)

subtasks: (reserve ?t) (move ?t home ?x)

(return ?t ?x)

subtasks: (move ?t ?x home)

(free ?t)

Figure 1: Methods transporting package ?p, transporting two packages ?p ?q,
dispatching truck ?t, returning truck. Arrows ordering constraints.
shaded subtasks primitive tasks accomplished following
planning operators: (load ?t ?p) loads ?p onto ?t; (move ?t ?x ?y) moves ?t
?x ?y; (reserve ?t) deletes (available-truck ?t) signal truck use;
(free ?t) adds (available-truck ?t) signal truck longer use.

(transport-two p1 p2)
(package p1)
(package p2)

(transport p1)

(transport p1)
(at p1 l1)
(destination p1 l3)
(available-truck t1)

(dispatch t1 l1)

(dispatch t2 l2)

(load t1 p1)
(reserve t1)

(at p2 l2)
(destination p2 l4)
(available-truck t2)

(return t1 l1)
(load t2,p2)

(move t1 l1 l3)

(reserve t2)

(move t1 home l1)

(move t2 home l2)

(return t2 l2)

(move t2 l2 l4)
(free t1)

(move t1 l3 home)

(free t2)
(move t2 l4 home)

Figure 2: plan accomplishing (transport-two p1 p2) following initial state:
{(package p1), (at p1 l1), (destination p1 l3), (available-truck t1), (at t1 home),
(package p2), (at p2 l2), (destination p2 l4), (available-truck t2), (at t2 home)}.
381

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

applicable method, instantiates decompose task subtasks, chooses
instantiates methods decompose subtasks even further, illustrated Figure 2.
plan later turns infeasible, planning system need backtrack
try methods.
HTN methods generally describe standard operating procedures one would
normally use perform tasks domain (e.g., see Figure 1) HTN practitioners
would argue representations appropriate many real-world domains
classical planning operators, better characterize way users think
problems.
HTN planners, SHOP2 hand-tailorable: planning engine
domain-independent, HTN methods may domain-specific, planner
customized work different problem domains giving different sets HTN
methods. ability use domain-specific problem-solving knowledge dramatically
improve planners performance, sometimes make difference solving
problem exponential time solving polynomial time (e.g., Gupta & Nau, 1992;
Slaney & Thiebaux, 2001). experimental studies (e.g., Nau et al., 1999, 2001; Bacchus
& Kabanza, 2000), hand-tailorable planners quickly solved planning problems orders
magnitude complicated typically solved fully automated planning
systems domain-specific knowledge consists planning operators.

3. Features SHOP2
section describes SHOP2s planning algorithm SHOP2s distinctive features.
3.1 Basic Elements Domain Description
domain description description planning domain, consisting set methods,
operators, axioms. describe briefly; additional details appear
Section 4.
3.1.1 Tasks
task represents activity perform. Syntactically, task consists task symbol
followed list arguments. task may either primitive compound. primitive
task one supposed accomplished planning operator: task symbol
name planning operator use, tasks arguments parameters
operator. compound task one needs decomposed smaller tasks
using method; method whose head unifies task symbol arguments
may potentially applicable decomposing task. details discussed
following subsections.
3.1.2 Operators
operator indicates primitive task performed. operators
similar PDDL operators: operator head head(o) consisting operators
name list parameters, precondition expression pre(o) indicating
382

fiSHOP2: HTN Planning System

(:method
; head
(transport-person ?p ?c2)
; precondition
(and
(at ?p ?c1)
(aircraft ?a)
(at ?a ?c3)
(different ?c1 ?c3))
; subtasks
(:ordered
(move-aircraft ?a ?c1)
(board ?p ?a ?c1)
(move-aircraft ?a ?c2)
(debark ?p ?a ?c2)))
Figure 3: SHOP2 method simplified version ZenoTravel domain.
true current state order operator applicable, delete list del(o)
add list add(o) giving operators negative positive effects. PDDL,
preconditions effects may include logical connectives quantifiers. operators
numeric computations assignments local variables (an example appears
later Figure 11). PDDL, two operators name; thus
primitive task, applicable actions instances operator.
operator optional cost expression (the default value 1). expression arbitrarily complicated use variables appear
operators head precondition. cost plan sum costs operator
instances.
3.1.3 Methods
method indicates decompose compound task partially ordered set
subtasks, compound primitive. simplest version method
three parts: task method used, precondition
current state must satisfy order method applicable, subtasks
need accomplished order accomplish task.
example, Figure 3 simplified version SHOP2 method one
domains AIPS-2002 Planning Competition, ZenoTravel domain. method
gives way transport person ?p aircraft one location ?c1 another location
?c2 aircraft already ?c1.1 :ordered keyword specifies subtasks
totally ordered: first move aircraft ?c1, board person, move
aircraft ?c2, debark person.2 specify unordered set subtasks, would
1. symbol begins question mark variable name.
2. method figure would meaning :ordered omitted. list subtasks
begin :ordered :unordered, SHOP2 assumes :ordered.

383

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

(:; head
(enough-fuel ?plane ?current-position ?destination ?speed)
; tail
(and (distance ?current-position ?destination ?dist)
(fuel ?plane ?fuel-level)
(fuel-burn ?speed ?rate)
(eval (>= ?fuel-level (* ?rate ?dist)))))
Figure 4: SHOP2 axiom simplified version ZenoTravel domain.
use keyword :unordered rather :ordered; complicated partial orderings
specified using nested combinations :ordered :unordered.3
generally, method may form
(:method head(m) p1 t1 p2 t2 . . .),
head(m) task called head m, pi precondition expression
ti partially ordered set subtasks. meaning analogous if-then-else:
tells SHOP2 p1 satisfied t1 used, otherwise p2 satisfied
t2 used, forth. keep descriptions paper simple,
assume without loss generality one precondition expression pre(m)
one set subtasks sub(m).
general, may several alternative ways accomplishing head(m). may
one method whose head head(m), one set variable bindings
satisfy pre(m), one ordering consistent sub(m), one
possible way accomplish subtasks sub(m). alternatives produce
branches SHOP2s search space.
3.1.4 Axioms
precondition method operator may include conjunctions, disjunctions, negations, universal existential quantifiers, implications, numerical computations, external function calls. Furthermore, axioms used infer preconditions
explicitly asserted current state. axioms generalized versions Horn clauses,
written Lisp-like syntax: example, (:- head tail) says head true tail true.
tail clause may contain anything may appear precondition
operator method.
example, axiom shown Figure 4 says plane enough fuel reach
?destination following conditions satisfied: distance travel ?dist, fuel
level ?fuel-level, burn rate ?rate, ?fuel-level less product ?rate
?distance. last conditions handled using external function call,
described below.
3. notation allow every possible possible partial ordering, problem
practice; notation less clumsy allow every possible partial ordering.

384

fiSHOP2: HTN Planning System

procedure SHOP2(s, T, D)
P = empty plan
T0 {t : task constrained precede t}
loop
= return P
nondeterministically choose T0
primitive task
{(a, ) : ground instance operator D, substitution unifies {head(a), t}, satisfies preconditions}
= return failure
nondeterministically choose pair (a, )
modify deleting del(a) adding add(a)
append P
modify removing applying
T0 {t : task constrained precede t}
else
{(m, ) : instance method D, unifies {head(m), t},
pre(m) true s, general possible}
= return failure
nondeterministically choose pair (m, )
modify removing t, adding sub(m), constraining task
sub(m) precede tasks preceded, applying
sub(m) 6=
T0 {t sub(m) : task constrained precede t}
else T0 {t : task constrained precede t}
repeat
end SHOP2
Figure 5: simplified version SHOP2 planning procedure.

tail clause (or precondition operator method) contains negation,
handled way Prolog: theorem prover takes (not a) true
cannot prove a.

3.1.5 External Function Calls
External function calls useful, example, numeric evaluations (e.g.,
ZenoTravel domain, check requirement available fuel must greater
equal product burn rate distance traveled). example,
competition, SHOP2 used graph-algorithm library compute shortest paths
graph. principle, would possible implement graph algorithms set
methods. However, writing external functions allows run faster,
makes possible access predefined code libraries.
385

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

3.2 SHOP2 Algorithm
Figure 5 shows simplified version SHOP2 planning procedure. arguments
include initial state s, partially ordered set tasks , domain description D.
mentioned earlier, SHOP2 plans tasks order
executed. order this, nondeterministically chooses task
predecessors; first task SHOP2 start working on. point,
two cases.
first case primitive, i.e., accomplished directly using action
(i.e., instance planning operator). case, SHOP2 finds action
matches whose preconditions satisfied s, applies (if action
exists, branch search space fails).
second case compound, i.e., method needs applied
decompose subtasks. case, SHOP2 nondeterministically chooses method
instance decompose subtasks (if method instance exists,
branch search space fails).
solution plan involves m, actions P leaf nodes
decomposition tree DP tree shown Figure 2. precondition formula
pre(m) must true state immediately precedes first action DP
descendant m. order ensure pre(m) true correct state, SHOP2 needs
generate leftmost branch way bottom, evaluate pre(m)
state a. last three lines loop ensure happen,
telling SHOP2 current method subtasks, SHOP2 generate one
subtasks generating subtasks task network.
example, SHOP2 could begin generating plan Figure 2 first decomposing
(transport-two p1 p2) (transport p1) (transport p2), nondeterministically
choosing decompose (transport p1) {(dispatch t1 l1), (pickup t1 p1), (move t1 l1
l3)}. done that, SHOP2 would required decompose (dispatch t1 l11)
decomposing (transport p2), order guarantee (dispatch t1 l1) (reserve t1)
occur state world (available t1) evaluated. operator
(reserve t1) makes t1 unavailable, thus ensuring (transport p2) decomposed
later, decomposition use truck t2 rather t1.
3.3 Additional Features
SHOP2 several additional features addition basic ones described earlier.
section describes significant ones.
3.3.1 Sorting Variable Bindings
SHOP2 evaluates methods precondition, gets list possible sets
variable bindings satisfy expression current state. set variable
bindings lead different branch SHOP2s search tree. nondeterministic choice
implemented SHOP2 via depth-first backtracking. SHOP2 find good solution
find quickly, important decide set variable bindings try first.
purpose, SHOP2 sort-by construct sorts list variable bindings specified criterion. especially useful planning problem
386

fiSHOP2: HTN Planning System

(:method
; head
(transport-person ?p ?c2)
; precondition
(:sort-by ?cost #<
(and (at ?p ?c1)
(aircraft ?a)
(at ?a ?c3)
(different ?c1 ?c3)
(cost-of ?a ?c3 ?c1 ?cost)))
; subtasks
((move-aircraft ?a ?c1)
(board ?p ?a ?c1)
(move-aircraft ?a ?c2)
(debark ?p ?a ?c2)))
Figure 6: Using sort-by SHOP2 method simplified ZenoTravel domain.
optimization problem, e.g., problem objective find plan
least possible cost. sort-by construct, write heuristic function estimate
anticipated cost set variable bindings, sort sets variable bindings
according heuristic-function values SHOP2 try promising one first.
example, precondition
(and (at ?here) (distance ?here ?there ?d))
may several different combinations ?here, ?there, ?d satisfy
precondition. expression
(:sort-by ?d #> (and (at ?here) (distance ?here ?there ?d)))
cause SHOP2 consider variable bindings decreasing order value ?d.
complicated example, recall precondition method Figure 3.
may several sets variable bindings satisfy precondition current
state. reformulation precondition Figure 6 tells SHOP2 sort sets
variable bindings increasing order ?cost variable. way, SHOP2 look first
alternative lowest ?cost value.
3.3.2 Branch-and-Bound Optimization
SHOP2 allows option using branch-and-bound optimization search leastcost plan. option generally results spending additional planning time order
search plans superior quality. using branch-and-bound option, one
specify time limit search. search takes longer time limit, SHOP2
terminates search returns best plan found far; functionality
partly inspired anytime algorithms (Boddy & Dean, 1989).
387

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

3.3.3 PDDL Operator Translation
SHOP2s planning procedure proved sound complete across large set
planning problems, sense set methods operators capable generating solution problem, planning procedure guaranteed generate
correct plan (Nau et al., 2001). However, proof tells us planning
algorithm work correctly domain description correct, tell us
whether domain description represents planning domain given set
PDDL planning operators.
AIPS-2000 planning competition, problem caused difficulty SHOP2s
predecessor SHOP. SHOP team developing domain descriptions SHOP purely
hand, made mistakes writing two domains. Thus SHOP found
incorrect solutions problems domains, judges disqualified
SHOP domains.
developing SHOP2, wrote translator program translate PDDL operators
SHOP2 domain descriptions. domain descriptions produced translator
program sufficient efficient planning SHOP2: need modified
hand order put domain knowledge, described Section 4. However,
translator program least provide correct starting point.

3.3.4 Debugging Facilities
SHOP2 includes several debugging facilities. important tracing
mechanism: one tell SHOP2 trace set operators, methods, axioms.
example, Figure 8, given names (namely Case1 Case2) two different
clauses method. tell SHOP2 trace either clauses them;
SHOP2 print messages time enters exits clause traced.
Depending particular tracing options one selects, messages may include
things argument list, current state world, information
whether operator, method axiom succeeds fails.

3.3.5 Protected Conditions Anti-Interleaving
SHOP2s planning operators include way specify protected conditions. feature
described briefly Nau et al. (2001), bother describe
use planning competition. cases wanted protect
conditions possible threats, found convenient either make use flags
similar available-truck flag Figure 1, use following anti-interleaving
feature SHOP2.
method subtasks t1 , . . . , tk , ti begins keyword :immediate,
tells SHOP2 plan ti immediately ti1 finishes, without trying
interleave tasks ti1 ti . Several examples appear appendix.
388

fiSHOP2: HTN Planning System

task person: transport person his/her destination
(these tasks unordered; thus subtasks may interleaved)
task plane: transport plane destination
(these tasks unordered; thus subtasks may interleaved)
method transporting person:
person already desired destination nothing
else
select plane
plane persons current position move
hold plane current position
board person onto plane
move plane destination
debark person destination
method transporting plane:
plane already desired destination nothing
else move plane destination
Figure 7: Abstract tasks methods simplified version ZenoTravel domain.

4. Developing Domain Descriptions SHOP2
4.1 Basics
first step developing domain description SHOP2 formulate abstract
tasks methods constitute reasonable problem-solving strategy. example,
use simplified version ZenoTravel (one domains planning competition).
problem transport people current locations destination,
use available airplanes. Figure 7 shows set abstract tasks methods
transporting people moving airplanes.
abstract strategy one Figure 7, implement
SHOP2 domain description consisting methods, operators axioms. example,
method transporting person shown Figure 8. may one
value ?p satisfies precondition (plane ?p). so, plane use
nondeterministic branching point SHOP2. nondeterministic branching points,
domain description may include heuristics guide SHOP2s search; Section 4.3
discusses ways write heuristics.
method transport-with-plane task, one preconditions whether
planes fuel level enough get plane current position destination.
Figure 4 shows axiom precondition.
Actions, boarding people onto planes, debarking planes, refueling
planes, modeled operators SHOP2. example, SHOP2 operator
boarding given Figure 9.
389

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

(:method
; head
(transport-person ?person ?destination)
Case1 ; label use debugging
; preconditions
(and (at ?person ?current-position)
(same ?current-position ?destination))
; subtasks
()
Case2 ; label use debugging
; preconditions
(and (at ?person ?current-position)
(plane ?p))
; subtasks
((transport-with-plane ?person ?p ?destination)))
Figure 8: SHOP2 implementation one methods Figure 7.
(:operator
; head
(board ?person ?plane)
; preconditions
(and (at ?person ?place) (at ?plane ?place))
; delete list
((at ?person ?place))
; add list
((in ?person ?plane)))
Figure 9: SHOP2 operator simplified ZenoTravel domain.

4.2 Writing Temporal Domains
SHOP2s operators least expressive Level 2 actions PDDL, SHOP2
explicitly support durative actions Level 3 PDDL, SHOP2
explicit mechanism reasoning durative concurrent actions.
However, SHOP2 still enough expressive power represent durative concurrent
actions, knows current state step planning process since
operators assign values variables numeric calculations. allowed
us develop preprocessing technique call Multi-Timeline Preprocessing (MTP).
MTP technique translating PDDL operators SHOP2 operators keep track
temporal information current state.
pseudocode Figure 10 algorithmic description MTP does.
principle, MTP could automatedbut practice, always done hand,
needs done planning domain.
390

fiSHOP2: HTN Planning System

every operator planning domain
add two parameters ?start ?duration
os precondition
add assignment ?duration
formula calculating os duration
add assignment ?start
formula takes maximum write times
dynamic properties os precondition read times
dynamic properties os effects
dynamic property p os effects
add effects change value write-time(p) ?start +?duration
dynamic property appears
add effects change read-time(p) maximum
read-time(p) ?start +?duration
Figure 10: Multi-timeline preprocessing (MTP).
keep description MTP simple, let us suppose state s, every atom
(p c1 . . . cn ) represents single-valued property, i.e., one cn (p c1
. . . cn1 cn ) true s. property dynamic operator may change value cn .
example, initial state contains (at plane1 city1) operator
moves plane1 different location, location plane1 dynamic.
property p changes time, MTP modifies operators keep track,
within current state, times property changes times
various preconditions depend property. idea dynamic property
p, current state contain two time-stamps: read-time(p), last time
action read value p, write-time(p), last time action
modified value p. MTP modifies operators way whenever
operator reads (i.e., accesses) dynamic property, operator update propertys
read-time, operator writes (i.e., modifies) dynamic property, update
propertys write-time. Thus, instead single global time, current state contain
many local times, namely read-time write-time dynamic property.
MTP inserts preconditions action ensure action begins
read-time property writes write-time property
reads. prevents two actions overlapping time one writes
property reads it. example, boarding operator fly operator
plane may overlap, boarding operator requires plane
located particular city fly operator changes location plane.
Figure 11 shows one SHOP2 operators produced MTP ZenoTravel
domain. operator involves two dynamic properties: vehicles fuel level location.
operator reads properties, may start write times.
However, writes one (the fuel level), may start read time
vehicles location. Thus refueling may performed concurrently
actions depend vehicles location, cannot performed concurrently
actions modify fuel level modify vehicles location.
391

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

(:operator (!refuel ?plane ?city ?start ?duration)
; preconditions
((aircraft ?plane)
(city ?city)
(at ?plane ?city)
(fuel ?plane ?fuel-level)
(capacity ?plane ?fuel-cap)
(refuel-rate ?plane ?rate)
(assign ?duration (/ (- ?fuel-cap ?fuel-level) ?rate))
(write-time fuel ?plane ?t1)
(write-time ?plane ?t2)
(read-time fuel ?plane ?t3)
(assign ?start (eval (max ?t1 ?t2 ?t3)))
(assign ?end (eval (+ ?start ?duration)))
(read-time ?plane ?t4)
(assign ?new-value (eval (max ?t4 ?end))))
; delete list
((fuel ?plane ?fuel-level)
(write-time fuel ?plane ?t1)
(read-time fuel ?plane ?t3)
(read-time ?plane ?t4))
; add list
((fuel ?plane ?fuel-cap)
(write-time fuel ?plane ?end)
(read-time fuel ?plane ?end)
(read-time ?plane ?new-value)))
Figure 11: sample SHOP2 operator produced MTP.
4.3 Writing Domains Include Optimization
previous planning competitions, planning benchmarks compared speed
planners length output plans, domain designers concentrated trying
find reasonably short plan quickly possible. contrast, problems
years competition included linear objective function needed optimized:
best plan longer one minimizes number steps, instead
one minimized objective-function value. tried three approaches searching
optimal plans:
1. Structure SHOP2 methods way take SHOP2 more-or-less directly
toward plan minimizes objective function.
2. Write methods, operators, axioms generate plans quickly, use sort-by
feature tell SHOP2 sort alternatives try promising ones first.
3. Assign costs operators, use branch-and-bound search find best
plan within execution time limit.
392

fiSHOP2: HTN Planning System

first approach works well easy tell alternative best
node search space. example, know problem instances
objective minimize total fuel used, perfect heuristic ZenoTravel
domain always use fly action instead zoom action. However, approach
doesnt work well isnt immediately obvious alternative best. example,
objective minimize total time, naive approach would always use
zoom action rather fly action, since zoom action faster. However,
zoom action always best choice, requires fuel thus cause
delays refueling.
second approach extension first approach. Consider example
ZenoTravel domain objective minimize total fuel used. addition
making planes fly instead zoom; using closer plane transport person
reduces total fuel used. set preference using sort-by feature SHOP2.
precondition method transporting person sort available planes
according fuel use order pick person. greedy approach.
decision point sort alternatives cost, go alternative
lowest objective-function value. Thus, approach guaranteed find
optimal solution. However, combined suitable heuristics, approach results
near-optimal plans. competition used technique extensively, produced
satisfactory plans even largest problems.
third approach makes use branch-and-bound optimization, explained Section
3.3.2. main idea quickly define methods let find plan may
poor quality let SHOP2 perform branch-and-bound search plan space
find least cost plan best plan find within execution time limit.
third approach, challenge setting cost operator.
example, objective function requires minimizing total time, order take
concurrency account, cost action always equal duration.
example, suppose latest event current partial plan plane arrive
airport time t, two passengers need board plane. need
add two boarding actions plan. Recall ZenoTravel domain, boarding
actions take amount time, tb , performed concurrently. However,
SHOP2 needs add actions plan one time. first boarding action
increase total time tb , cost tb . However, second boarding action
increase total time plan, cost 0. Now, suppose add refuel action
plan. action done concurrently boarding actions, cost
max(0, tr tb ), tr time needed refuel.
possible combine two approaches. However, experience, using optimization (the third approach) provide much benefit domain
descriptions already included two approaches. situations, SHOP2
would frequently find optimal nearly optimal plan even without optimization,
meant additional amount time needed branch-and-bound optimization would
produce little benefit. Branch-and-bound optimization would perhaps useful
planning domains cost plan something sum costs
operators; however, domains occur planning competition.
393

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

International Planning Competition, use optimization approach
official competition trial. competition domains, preliminary
testing SHOP2 optimization time limits, SHOP2 unable find solutions
within amount time willing let run, except smallest
problems. One way overcome difficulty would use time limits,
preliminary tests, never provided significant improvements cost across entire
problem set. One reason lack improvement spent great deal
effort crafting methods used competition. think third approach would
useful cases immediately clear implement first two
approaches, one want spend much time devising sophisticated domain
description.

5. Competition Results
Fourteen planning systems competed 2002 International Planning Competition.
SHOP2 received distinguished performance award, one top four awards.
SHOP2 (along TLPlan TALPlanner) one three planners solved
problems hand-tailored fully automated tracks. SHOP2 able
solve problems Strips, Numeric, HardNumeric, SimpleTime, Time, Complex
domains. SHOP2 solved problems planner competition:
solved 899 904 problems, 99% success ratio.
two hand-tailorable planners, TLPlan solved 894 problems, nearly many
SHOP2. Since TALPlanner didnt numeric domains, solved 610 problems,
still several hundred problems fully-automated planners solved.
general, SHOP2 tended slower TALPlanner TLPlanner, although
one domain (Satellite-HardNumeric) SHOP2 consistently fastest.
speeds three hand-tailorable planners generally appeared polynomially
related other, probably planners domain knowledge enabled
find solutions without much backtracking. three hand-tailorable planners
generally much faster fully-automated planners.
None three hand-tailorable planners dominated two terms plan
quality. them, situations solutions significantly better
significantly worse two.

6. Related Work
following subsections discuss HTN planning, ordered task decomposition,
hand-tailorable planners participated competition.
6.1 HTN Planning
HTN planning first developed 25 years ago (Sacerdoti, 1990; Tate, 1977).
Historically, HTN-planning researchers focused practical applications.
Examples include production-line scheduling (Wilkins, 1988), crisis management logistics (Currie & Tate, 1991; Tate, Drabble, & Kirby, 1994; Biundo & Schattenberg, 2001),
planning scheduling spacecraft (Aarup, Arentoft, Parrod, Stader, & Stokes, 1994;
394

fiSHOP2: HTN Planning System

Estlin, Chien, & Wang, 1997), equipment configuration (Agosta, 1995), manufacturability
analysis (Hebbar, Smith, Minis, & Nau, 1996; Smith, Hebbar, Nau, & Minis, 1997), evacuation planning (Munoz-Avila, Aha, Nau, Weber, Breslow, & Yaman, 2001), game
bridge (Smith, Nau, & Throop, 1998a, 1998b).
development formal semantics HTN planning (Erol, Nau, & Hendler, 1994;
Erol, Hendler, & Nau, 1996) shown strictly expressive classical
AI planning: problems expressed HTN planning problems
classical planning problems.4 Even one places restrictions HTN planning
restrict expressive power classical planning, generally much easier
translate classical planning problems HTN planning problems vice versa (Lotem,
Nau, & Hendler, 1999).
6.2 Ordered Task Decomposition
Ordered task decomposition (Nau, Smith, & Erol, 1998) special case HTN planning
planning algorithm always builds plans forward initial state world.
words, ordered-task-decomposition planner plans tasks order
tasks later performed. first applications ordered task decomposition
tailor-made specific application domains. best known example code
declarer play helped Bridge Baron win 1997 world championship computer
bridge (Smith et al., 1998b).
SHOP2 based SHOP (Nau et al., 1999), previous domain-independent orderedtask-decomposition planner requires subtasks method, initial
set tasks planning problem, totally ordered rather partially ordered.
Thus SHOP, subtasks different tasks cannot interleaved. SHOP2 extends SHOP
allowing subtasks method partially ordered. Experiments shown
allow SHOP2 create plans efficiently SHOP, using domain descriptions
simpler needed SHOP (Nau et al., 2001). SHOP SHOP2
available open-source software hhttp://www.cs.umd.edu/projects/shopi.
6.3 TLPlan TALPlanner
SHOP2, TLPlan (Bacchus & Kabanza, 2000) TALPlanner (Doherty & Kvarnstrom, 2001) competed hand-tailored track AIPS-2002 planning competition.
TLPlan TALPlanner similar many respects. forward-chaining
search apply planning operators current state generate successors. Thus, SHOP2, know current state world every step
planning process. control search, planners use control rules written
declaratively temporal logic. rules provide domain-specific knowledge tell
planner states bad states, planner backtrack try
4. specifically, HTN planning Turing-complete: even undecidable problems expressed
HTN planning problems. remains Turing-complete even restrict tasks logical atoms
purely propositional (i.e., arguments all). contrast, classical planning
represents planning problems solutions regular sets. Planners TLPlan (Bacchus
& Kabanza, 2000) TALPlanner (Doherty & Kvarnstrom, 2001) overcome limitation classical
planning extending formalism include function symbols.

395

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

paths search space. One difference TLPlan TALPlanner TLPlan
uses linear modal tense logic, TALPlanner use TAL, narrative-based linear temporal logic used reasoning action change incompletely specified dynamic
environments.
main difference planners SHOP2 kind control
knowledge use: TLPlan TALPlanner use temporal formulas tell
part search space avoided, whereas SHOP2 uses HTN methods tell
parts search space explored. SHOP2s search space consists
nodes reachable using HTN methods, whereas TLPlan TALPlanner
explore part search space avoids bad states successors.
hard say type control knowledge effective. Bacchus Kabanza
(2000) argue two types useful different situations combining
useful topic future research.

7. Summary Conclusions
primary difference SHOP2 HTN planners SHOP2 plans
tasks order executed, thus knows current state
step planning process. reduces complexity reasoning removing
great deal uncertainty world, made easy us incorporate substantial expressive power SHOP2. addition usual HTN methods
operators, SHOP2s domain descriptions may include axioms, mixed symbolic/numeric
conditions, external function calls. planning procedure Turing-complete,
sound complete large class planning problems (Nau et al., 2001).
HTN planning systems, SHOP2 plans decomposing tasks subtasks.
key idea using HTN planner design set methods encode something
akin standard operating procedures capture multi-step techniques refining
task. kinds domain characteristics much natural express HTN
formalism action-based formalism; see Lotem et al. (1999) description
issued involved.
example, consider UM-Translog-2 domain, wrote use problem
domain AIPS-2002 planning competition (Wu & Nau, 2002). UM-Translog-2
straightforward generalization UM Translog domain (Andrews, Kettler, Erol, &
Hendler, 1995); generalizations include numeric information distances, fuel
usage, forth. relatively straightforward formulate UM-Translog-2
HTN planning domain. However, much difficult figure formulate
UM-Translog-2 PDDL domain use competitors planning competition;
task took several months accomplish.
HTN planning systems, SHOP2s development originally motivated planning competition instead try solve practical planning
problems. example, JSHOP (a Java implementation SHOP2s predecessor SHOP)
generative-planning component HICAP system planning evacuation operations (Munoz-Avila et al., 2001), currently incorporating SHOP2 HICAP
replacement JSHOP. pleased SHOP2s capabilities gave
ability excel International Planning Competition!
396

fiSHOP2: HTN Planning System

Acknowledgments
work supported part following grants, contracts, awards: Air Force
Research Laboratory F30602-00-2-0505, Army Research Laboratory DAAL0197K0135, Naval
Research Laboratory N00173021G005, University Maryland General Research
Board. opinions expressed paper authors necessarily
reflect opinions funders.
wish thank anonymous reviewers, whose comments helped us make
significant improvements paper.

Appendix A. SHOP2 Domain Description ZenoTravel Domain
(Numeric Version)
AIPS-2002 Planning Competition, four different versions ZenoTravel
domain: Strips version, Numeric version, Simple Time version, Time
version. developed SHOP2 domain descriptions four versions.
follows domain description Numeric version ZenoTravel domain. operators domain description translated original PDDL
coding using rough approximation MTP process Figure 10.
(defdomain ZENOTRAVEL
(
(:- (same ?x ?x) ())
(:- (different ?x ?y) ((not (same ?x ?y))))
(:-(possible-person-in ?city)
((person ?p) (at ?p ?city) (goal ?p ?city2)
(different ?city2 ?city)))
(:operator (!!cost ?end)
((maxtime ?max)
(assign ?newmax (eval (if (< ?max ?end) ?end ?max))))
((maxtime ?max))
((maxtime ?newmax))
(- ?newmax ?max))
(:method (board ?p ?a ?c)
((write-time ?a ?start))
((!board ?p ?a ?c ?start 1)
(:immediate !!cost (call + ?start 1))))
(:operator (!board ?p ?a ?c ?start ?duration)
((person ?p) (aircraft ?a) (city ?c)
(at ?a ?c) (at ?p ?c) (onboard ?a ?num)
(read-time ?a ?pmax) (assign ?new-num (+ ?num 1))
(assign ?newpmax (max ?pmax (+ ?start ?duration 0.01L0))))
((onboard ?a ?num) (read-time ?a ?pmax) (at ?p ?c) (dest ?a ?c))
((onboard ?a ?new-num) (read-time ?a ?newpmax) (in ?p ?a))
397

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

0.001)
(:method (debark ?p ?a ?c)
((write-time ?a ?start))
((!debark ?p ?a ?c ?start 1)
(:immediate !!cost (call + ?start 1))))
(:operator (!debark ?p ?a ?c ?start ?duration)
((person ?p) (aircraft ?a) (city ?c)
(at ?a ?c) (in ?p ?a) (onboard ?a ?num)
(read-time ?a ?pmax) (assign ?new-num (- ?num 1))
(assign ?newpmax (max ?pmax (+ ?start ?duration 0.01L0))))
((onboard ?a ?num) (read-time ?a ?pmax) (in ?p ?a) (dest ?a ?c))
((onboard ?a ?new-num) (read-time ?a ?newpmax) (at ?p ?c))
0.001)
(:method (refuel ?a ?c)
((write-time ?a ?start) (read-time ?a ?pmax)
(capacity ?a ?cap) (fuel ?a ?fuel)
(eval (> ?cap ?fuel))
(assign ?duration 1)
(assign ?end (+ ?start ?duration 0.01L0))
(assign ?newpmax (max ?pmax ?end)))
((!!ra ((read-time ?a ?pmax))
((read-time ?a ?newpmax)))
(:immediate !refuel ?a ?c ?start ?duration)
(:immediate !!cost ?end)))
(:operator (!refuel ?a ?c ?start ?duration)
((aircraft ?a) (city ?c) (at ?a ?c)
(fuel ?a ?fuel) (capacity ?a ?cap))
((fuel ?a ?fuel))
((fuel ?a ?cap))
0.001)
(:method (zoom ?a ?c1 ?c2)
((write-time ?a ?astart) (read-time ?a ?pmax)
(distance ?c1 ?c2 ?dist)
(fuel ?a ?fuel) (fast-burn ?a ?burn)
(eval (>= ?fuel (* ?dist ?burn)))
(assign ?duration 1)
(assign ?start (max ?pmax ?astart))
(assign ?end (+ ?start ?duration 0.01L0)))
((!!ra ((write-time ?a ?astart) (read-time ?a ?pmax))
((read-time ?a 0) (write-time ?a ?end)))
(:immediate !zoom ?a ?c1 ?c2 ?start ?duration)
(:immediate !!cost ?end)))
(:operator (!zoom ?a ?c1 ?c2 ?start ?duration)
((aircraft ?a) (city ?c1) (city ?c2) (onboard ?a ?num)
(zoom-limit ?a ?limit) (eval (<= ?num ?limit))
398

fiSHOP2: HTN Planning System

(at ?a ?c1) (distance ?c1 ?c2 ?dist) (fast-burn ?a ?burn)
(total-fuel-used ?total-fuel)
(assign ?new-total (+ ?total-fuel (* ?dist ?burn)))
(fuel ?a ?fuel)
(assign ?new-fuel (- ?fuel (* ?dist ?burn))))
((at ?a ?c1) (total-fuel-used ?total-fuel) (fuel ?a ?fuel) )
((at ?a ?c2) (total-fuel-used ?new-total) (fuel ?a ?new-fuel))
0.001)
(:method (fly ?a ?c1 ?c2)
((write-time ?a ?astart) (read-time ?a ?pmax)
(distance ?c1 ?c2 ?dist)
(fuel ?a ?fuel) (slow-burn ?a ?burn)
(eval (>= ?fuel (* ?dist ?burn)))
(assign ?duration 1)
(assign ?start (max ?pmax ?astart))
(assign ?end (+ ?start ?duration 0.01L0)))
((!!ra ((write-time ?a ?astart) (read-time ?a ?pmax))
((read-time ?a 0) (write-time ?a ?end)))
(:immediate !fly ?a ?c1 ?c2 ?start ?duration)
(:immediate !!cost ?end)))
(:operator (!fly ?a ?c1 ?c2 ?start ?duration)
((aircraft ?a) (city ?c1) (city ?c2)
(at ?a ?c1) (distance ?c1 ?c2 ?dist) (slow-burn ?a ?burn)
(total-fuel-used ?total-fuel)
(assign ?new-total (+ ?total-fuel (* ?dist ?burn)))
(fuel ?a ?fuel)
(assign ?new-fuel (- ?fuel (* ?dist ?burn))))
((at ?a ?c1)(total-fuel-used ?total-fuel)(fuel ?a ?fuel))
((at ?a ?c2)(total-fuel-used ?new-total)(fuel ?a ?new-fuel))
0.001)
(:operator (!!preprocessing ?problem-name)
((totaltime-coeff ?tc) (fuelused-coeff ?fc)
(eval (setf *tc* ?tc))
(eval (setf *fc* ?fc)))
()
()
0)
(:operator (!!assert ?g )
()
()
?g
0)
(:operator (!!ra ?D ?A )
()
?D
?A
0)
399

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

;;;;
;;;;; Main Methods
;;;;;
(:method (transport-person ?p ?c)
Case1 ((at ?p ?c))
())
(:method (transport-person ?p ?c2)
Case2 (:sort-by ?num #>
((at ?p ?c1)
(at ?a ?c1)
(aircraft ?a)
(onboard ?a ?num)))
((!!assert ((dest ?a ?c1)))
(:immediate board ?p ?a ?c1)
(!!assert ((dest ?a ?c2)))
(:immediate upper-move-aircraft-no-style ?a ?c2)
(:immediate debark ?p ?a ?c2)))
(:method (transport-person ?p ?c2)
Case3 (:sort-by ?cost #<
((at ?p ?c1)
(aircraft ?a)
(at ?a ?c3)
(different ?c1 ?c3)
(forall (?c) ((dest ?a ?c)) ((same ?c ?c1)))
(imply ((different ?c3 ?c1))
(not (possible-person-in ?c3)))
(travel-cost-info ?a ?c3 ?c1 ?cost ?style)))
((!!assert ((dest ?a ?c1)))
(:immediate upper-move-aircraft ?a ?c1 ?style)
(:immediate board ?p ?a ?c1)
(!!assert ((dest ?a ?c2)))
(:immediate upper-move-aircraft-no-style ?a ?c2)
(:immediate debark ?p ?a ?c2)))
(:method (upper-move-aircraft ?a ?c ?style)
Case1 ((at ?a ?c))
()
Case2 ((at ?a ?somecity))
((move-aircraft ?a ?somecity ?c ?style)))
(:method (upper-move-aircraft-no-style ?a ?c)
Case1 ((at ?a ?c))
()
Case2 (:sort-by ?cost #<
((at ?a ?somecity)
(travel-cost-info ?a ?somecity ?c ?cost ?style)))
((move-aircraft ?a ?somecity ?c ?style)))
400

fiSHOP2: HTN Planning System

(:- (travel-cost-info ?a ?from ?to ?cost slow)
CASE1
((capacity ?a ?cap) (distance ?from ?to ?dist)
(slow-burn ?a ?burn) (eval (< ?cap (* ?dist ?burn)))
(assign ?cost most-positive-fixnum))
CASE2
((distance ?from ?to ?dist) (fuel ?a ?fuel)
(slow-burn ?a ?burn)
(eval (>= ?fuel (* ?dist ?burn)))
(assign ?cost (float (/
(+ *tc*
(* *fc*
(* ?dist ?burn)))
1))))
CASE3
((capacity ?a ?cap)(distance ?from ?to ?dist)
(slow-burn ?a ?burn)
(assign ?cost (float (/
(+ (* *tc* 2)
(* *fc*
(* ?dist ?burn)))
1)))))
(:- (travel-cost-info ?a ?from ?to ?cost fast)
CASE1
((capacity ?a ?cap) (distance ?from ?to ?dist)
(fast-burn ?a ?burn) (eval (< ?cap (* ?dist ?burn)))
(assign ?cost most-positive-fixnum))
CASE2
((distance ?from ?to ?dist) (fuel ?a ?fuel)
(zoom-limit ?a ?limit) (onboard ?a ?num) (eval (< ?num ?limit))
(fast-burn ?a ?burn)
(eval (>= ?fuel (* ?dist ?burn)))
(assign ?cost (float (/
(+ *tc*
(* *fc*
(* ?dist ?burn)))
1))))
CASE3
((capacity ?a ?cap)(distance ?from ?to ?dist)
(fast-burn ?a ?burn)
(zoom-limit ?a ?limit) (onboard ?a ?num) (eval (< ?num ?limit))
(assign ?cost (float (/
(+ (* *tc* 2)
(* *fc*
(* ?dist ?burn)))
1)))))

401

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

(:method (move-aircraft ?a ?c1 ?c2 slow)
((fuel ?a ?fuel) (distance ?c1 ?c2 ?dist)
(slow-burn ?a ?burn)
(eval (> ?fuel (* ?dist ?burn))))
((fly ?a ?c1 ?c2))
()
((refuel ?a ?c1)
(:immediate fly ?a ?c1 ?c2)))
(:method (move-aircraft ?a ?c1 ?c2 fast)
((fuel ?a ?fuel) (distance ?c1 ?c2 ?dist)
(fast-burn ?a ?burn)
(eval (> ?fuel (* ?dist ?burn))))
((zoom ?a ?c1 ?c2))
()
((refuel ?a ?c1)
(:immediate zoom ?a ?c1 ?c2)))
(:method (transport-aircraft ?a ?c)
((not (no-use ?a)))
((!!assert ((no-use ?a)))
(:immediate upper-move-aircraft-no-style ?a ?c)
(:immediate !!ra ((no-use ?a)) ())))

References
Aarup, M., Arentoft, M. M., Parrod, Y., Stader, J., & Stokes, I. (1994). OPTIMUM-AIV:
knowledge-based planning scheduling system spacecraft AIV. Intelligent
Scheduling, pp. 451469. Morgan Kaufmann.
Agosta, J. M. (1995). Formulation implementation equipment configuration
problem SIPE-2 generative planner. Proc. AAAI-95 Spring Symposium
Integrated Planning Applications, pp. 110.
Andrews, S., Kettler, B., Erol, K., & Hendler, J. (1995). UM Translog: planning domain
development benchmarking planning systems. Tech. rep. CS-TR-3487,
Dept. Computer Science, University Maryland.
Bacchus, F., & Kabanza, F. (2000). Using temporal logics express search control knowledge planning. Artificial Intelligence, 116.
Biundo, S., & Schattenberg, B. (2001). abstract crisis concrete relief. preliminary
report flexible integration nonlinear hierarchical planning. Proceedings
European Conference Planning.
Boddy, M., & Dean, T. (1989). Solving time-dependent planning problems. Sridharan,
N. S. (Ed.), Proceedings Eleventh International Joint Conference Artificial
Intelligence, pp. 979984, Detroit, MI, USA. Morgan Kaufmann.
Currie, K., & Tate, A. (1991). O-Plan: open planning architecture. Artificial Intelligence, 52 (1), 4986.
402

fiSHOP2: HTN Planning System

Doherty, P., & Kvarnstrom, J. (2001). TALplanner: temporal logic based planner. AI
Magazine, 22 (3), 95102.
Erol, K., Hendler, J., & Nau, D. (1996). Complexity results Hierarchical Task-Network
planning. Annals Mathematics Artificial Intelligence, 18, 6993.
Erol, K., Nau, D., & Hendler, J. (1994). HTN planning: Complexity expressivity.
AAAI-94.
Estlin, T. A., Chien, S. A., & Wang, X. (1997). argument hybrid HTN/operatorbased approach planning. Proc. Fourth European Conference Planning (ECP97), pp. 184196.
Gupta, N., & Nau, D. S. (1992). complexity blocks-world planning. Artificial
Intelligence, 56 (2-3), 223254.
Hebbar, K., Smith, S., Minis, I., & Nau, D. (1996). Plan-based evaluation designs
microwave modules. Proc. ASME Design Technical Conference.
Lotem, A., Nau, D., & Hendler, J. (1999). Using planning graphs solving HTN problems.
AAAI-99, pp. 534540.
Munoz-Avila, H., Aha, D., Nau, D., Weber, R., Breslow, L., & Yaman, F. (2001). SiN:
Integrating case-based reasoning task decomposition. IJCAI-2001.
Nau, D., Cao, Y., & Munoz-Avila, H. (1999). SHOP: Simple Hierarchical Ordered Planner.
IJCAI-99, pp. 968973.
Nau, D., Munoz-Avila, H., Cao, Y., Lotem, A., & Mitchell, S. (2001). Total-order planning
partially ordered subtasks. IJCAI-2001, Seattle.
Nau, D. S., Smith, S. J. J., & Erol, K. (1998). Control strategies HTN planning: Theory
versus practice. AAAI-98/IAAI-98 Proceedings, pp. 11271133.
Sacerdoti, E. D. (1990). nonlinear nature plans. Allen, J., Hendler, J., & Tate, A.
(Eds.), Readings Planning, pp. 162170. Morgan Kaufmann. Originally appeared
Proc. IJCAI-75, pp. 206-214.
Slaney, J., & Thiebaux, S. (2001). Blocks world revisited. Artificial Intelligence, 125 (1-2),
119153.
Smith, S. J., Hebbar, K., Nau, D., & Minis, I. (1997). Integrating electrical mechanical
design process planning. Mantyla, M., Finger, S., & Tomiyama, T. (Eds.),
Knowledge Intensive CAD, Vol. 2, pp. 269288.
Smith, S. J., Nau, D. S., & Throop, T. (1998a). Success spades: Using AI planning
techniques win world championship computer bridge. AAAI-98/IAAI-98,
pp. 10791086.
Smith, S. J. J., Nau, D. S., & Throop, T. (1998b). Computer bridge: big win AI
planning. AI Magazine, 19 (2), 93105.
Tate, A. (1977). Generating project networks. IJCAI-77, pp. 888893.
Tate, A., Drabble, B., & Kirby, R. (1994). O-Plan2: Architecture Command, Planning Control. Morgan Kaufmann.
403

fiNau, Au, Ilghami, Kuter, Murdock, Wu, & Yaman

Wilkins, D. E. (1988). Practical Planning: Extending Classical AI Planning Paradigm.
Morgan Kaufmann, San Mateo, CA.
Wu, D., & Nau, D. (2002). UM-Translog-2: planning domain designed AIPS-2002.
Tech. rep. CS-TR-4402, UMIACS-TR-2002-82, University Maryland.

404


