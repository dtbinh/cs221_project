journal artificial intelligence

submitted published

shop htn system
dana nau

nau cs umd edu

dept computer science institute systems
university maryland college park md usa

tsz chiu au

chiu cs umd edu

dept computer science
university maryland college park md usa

okhtay ilghami

okhtay cs umd edu

dept computer science
university maryland college park md usa

ugur kuter

ukuter cs umd edu

dept computer science
university maryland college park md usa

j william murdock

murdockj us ibm com

ibm watson center
skyline dr
hawthorne ny usa

dan wu

dandan cs umd edu

dept computer science
university maryland college park md usa

fusun yaman

fusun cs umd edu

dept computer science
university maryland college park md usa

abstract
shop system received one awards distinguished performance
international competition describes features
shop enabled excel competition especially aspects shop
deal temporal metric domains

introduction
shop simple hierarchical ordered planner nau munoz avila cao lotem mitchell
domain independent system hierarchical task network htn
international competition shop received one top
four awards one two awards distinguished performance describes
characteristics shop enabled excel competition
predecessor shop nau cao munoz avila shop generates
steps plan order steps later executed knows
current state step process reduces complexity
reasoning eliminating great deal uncertainty world thereby making
easy incorporate substantial expressive power system shop
c

ai access foundation rights reserved

finau au ilghami kuter murdock wu yaman

shop axiomatic inference mixed symbolic numeric computations calls
external programs
shop capabilities go significantly beyond shop
shop allows tasks subtasks partially ordered thus plans may interleave
subtasks different tasks often makes possible specify domain knowledge intuitive manner possible shop
shop incorporates many features pddl quantifiers conditional
effects
alternative ways satisfy methods precondition shop sort
alternatives according criterion specified definition method
gives convenient way author domain tell shop parts
search space explore first principle technique could used
planner plans forward initial state
shop handle temporal domains way translate
temporal pddl operators shop operators maintain bookkeeping information multiple timelines within current state principle technique
could used non temporal planner sufficient expressive power
rest organized follows section gives background htn
section describes shop features section
describes write domain descriptions shop particular section discusses
basic solving strategies sections describe aspects shop
specific handling temporal metric domain features section discusses shop
performance competition section discusses related work section gives
summary conclusion appendix contains shop domain description one
domains competition

htn
htn classical ai state world represented
set atoms action corresponds deterministic state transition however
htn planners differ classical ai planners plan plan

objective htn planner produce sequence actions perform
activity task description domain includes set operators similar
classical set methods prescription
decompose task subtasks smaller tasks figure gives simple example
given domain description contain initial state
classical planningbut instead goal formula specification
contain partially ordered set tasks accomplish
proceeds methods decompose tasks recursively smaller
smaller subtasks planner reaches primitive tasks performed directly operators nonprimitive task planner chooses


fishop htn system

task
preconditions

task

transport p

p x
destination p
available truck

transport two p q

preconditions

subtasks

package p
package q

subtasks

dispatch x load p move x return x

task

transport p transport q

task

dispatch x

subtasks reserve move home x

return x

subtasks move x home

free

figure methods transporting package p transporting two packages p q
dispatching truck returning truck arrows ordering constraints
shaded subtasks primitive tasks accomplished following
operators load p loads p onto move x moves
x reserve deletes available truck signal truck use
free adds available truck signal truck longer use

transport two p p
package p
package p

transport p

transport p
p l
destination p l
available truck

dispatch l

dispatch l

load p
reserve

p l
destination p l
available truck

return l
load p

move l l

reserve

move home l

move home l

return l

move l l
free

move l home

free
move l home

figure plan accomplishing transport two p p following initial state
package p p l destination p l available truck home
package p p l destination p l available truck home


finau au ilghami kuter murdock wu yaman

applicable method instantiates decompose task subtasks chooses
instantiates methods decompose subtasks even illustrated figure
plan later turns infeasible system need backtrack
try methods
htn methods generally describe standard operating procedures one would
normally use perform tasks domain e g see figure htn practitioners
would argue representations appropriate many real world domains
classical operators better characterize way users think

htn planners shop hand tailorable engine
domain independent htn methods may domain specific planner
customized work different domains giving different sets htn
methods ability use domain specific solving knowledge dramatically
improve planners performance sometimes make difference solving
exponential time solving polynomial time e g gupta nau
slaney thiebaux experimental studies e g nau et al bacchus
kabanza hand tailorable planners quickly solved orders
magnitude complicated typically solved fully automated
systems domain specific knowledge consists operators

features shop
section describes shop shop distinctive features
basic elements domain description
domain description description domain consisting set methods
operators axioms describe briefly additional details appear
section
tasks
task represents activity perform syntactically task consists task symbol
followed list arguments task may primitive compound primitive
task one supposed accomplished operator task symbol
name operator use tasks arguments parameters
operator compound task one needs decomposed smaller tasks
method method whose head unifies task symbol arguments
may potentially applicable decomposing task details discussed
following subsections
operators
operator indicates primitive task performed operators
similar pddl operators operator head head consisting operators
name list parameters precondition expression pre indicating


fishop htn system

method
head
transport person p c
precondition

p c
aircraft
c
different c c
subtasks
ordered
move aircraft c
board p c
move aircraft c
debark p c
figure shop method simplified version zenotravel domain
true current state order operator applicable delete list del
add list add giving operators negative positive effects pddl
preconditions effects may include logical connectives quantifiers operators
numeric computations assignments local variables example appears
later figure pddl two operators name thus
primitive task applicable actions instances operator
operator optional cost expression default value expression arbitrarily complicated use variables appear
operators head precondition cost plan sum costs operator
instances
methods
method indicates decompose compound task partially ordered set
subtasks compound primitive simplest version method
three parts task method used precondition
current state must satisfy order method applicable subtasks
need accomplished order accomplish task
example figure simplified version shop method one
domains aips competition zenotravel domain method
gives way transport person p aircraft one location c another location
c aircraft already c ordered keyword specifies subtasks
totally ordered first move aircraft c board person move
aircraft c debark person specify unordered set subtasks would
symbol begins question mark variable name
method figure would meaning ordered omitted list subtasks
begin ordered unordered shop assumes ordered



finau au ilghami kuter murdock wu yaman

head
enough fuel plane current position destination speed
tail
distance current position destination dist
fuel plane fuel level
fuel burn speed rate
eval fuel level rate dist
figure shop axiom simplified version zenotravel domain
use keyword unordered rather ordered complicated partial orderings
specified nested combinations ordered unordered
generally method may form
method head p p
head task called head pi precondition expression
ti partially ordered set subtasks meaning analogous else
tells shop p satisfied used otherwise p satisfied
used forth keep descriptions simple
assume without loss generality one precondition expression pre
one set subtasks sub
general may several alternative ways accomplishing head may
one method whose head head one set variable bindings
satisfy pre one ordering consistent sub one
possible way accomplish subtasks sub alternatives produce
branches shop search space
axioms
precondition method operator may include conjunctions disjunctions negations universal existential quantifiers implications numerical computations external function calls furthermore axioms used infer preconditions
explicitly asserted current state axioms generalized versions horn clauses
written lisp syntax example head tail says head true tail true
tail clause may contain anything may appear precondition
operator method
example axiom shown figure says plane enough fuel reach
destination following conditions satisfied distance travel dist fuel
level fuel level burn rate rate fuel level less product rate
distance last conditions handled external function call
described
notation allow every possible possible partial ordering
practice notation less clumsy allow every possible partial ordering



fishop htn system

procedure shop
p empty plan
task constrained precede
loop
return p
nondeterministically choose
primitive task
ground instance operator substitution unifies head satisfies preconditions
return failure
nondeterministically choose pair
modify deleting del adding add
append p
modify removing applying
task constrained precede
else
instance method unifies head
pre true general possible
return failure
nondeterministically choose pair
modify removing adding sub constraining task
sub precede tasks preceded applying
sub
sub task constrained precede
else task constrained precede
repeat
end shop
figure simplified version shop procedure

tail clause precondition operator method contains negation
handled way prolog theorem prover takes true
cannot prove

external function calls
external function calls useful example numeric evaluations e g
zenotravel domain check requirement available fuel must greater
equal product burn rate distance traveled example
competition shop used graph library compute shortest paths
graph principle would possible implement graph set
methods however writing external functions allows run faster
makes possible access predefined code libraries


finau au ilghami kuter murdock wu yaman

shop
figure shows simplified version shop procedure arguments
include initial state partially ordered set tasks domain description
mentioned earlier shop plans tasks order
executed order nondeterministically chooses task
predecessors first task shop start working point
two cases
first case primitive e accomplished directly action
e instance operator case shop finds action
matches whose preconditions satisfied applies action
exists branch search space fails
second case compound e method needs applied
decompose subtasks case shop nondeterministically chooses method
instance decompose subtasks method instance exists
branch search space fails
solution plan involves actions p leaf nodes
decomposition tree dp tree shown figure precondition formula
pre must true state immediately precedes first action dp
descendant order ensure pre true correct state shop needs
generate leftmost branch way bottom evaluate pre
state last three lines loop ensure happen
telling shop current method subtasks shop generate one
subtasks generating subtasks task network
example shop could begin generating plan figure first decomposing
transport two p p transport p transport p nondeterministically
choosing decompose transport p dispatch l pickup p move l
l done shop would required decompose dispatch l
decomposing transport p order guarantee dispatch l reserve
occur state world available evaluated operator
reserve makes unavailable thus ensuring transport p decomposed
later decomposition use truck rather
additional features
shop several additional features addition basic ones described earlier
section describes significant ones
sorting variable bindings
shop evaluates methods precondition gets list possible sets
variable bindings satisfy expression current state set variable
bindings lead different branch shop search tree nondeterministic choice
implemented shop via depth first backtracking shop good solution
quickly important decide set variable bindings try first
purpose shop sort construct sorts list variable bindings specified criterion especially useful


fishop htn system

method
head
transport person p c
precondition
sort cost
p c
aircraft
c
different c c
cost c c cost
subtasks
move aircraft c
board p c
move aircraft c
debark p c
figure sort shop method simplified zenotravel domain
optimization e g objective plan
least possible cost sort construct write heuristic function estimate
anticipated cost set variable bindings sort sets variable bindings
according heuristic function values shop try promising one first
example precondition
distance
may several different combinations satisfy
precondition expression
sort distance
cause shop consider variable bindings decreasing order value
complicated example recall precondition method figure
may several sets variable bindings satisfy precondition current
state reformulation precondition figure tells shop sort sets
variable bindings increasing order cost variable way shop look first
alternative lowest cost value
branch bound optimization
shop allows option branch bound optimization search leastcost plan option generally spending additional time order
search plans superior quality branch bound option one
specify time limit search search takes longer time limit shop
terminates search returns best plan found far functionality
partly inspired anytime boddy dean


finau au ilghami kuter murdock wu yaman

pddl operator translation
shop procedure proved sound complete across large set
sense set methods operators capable generating solution procedure guaranteed generate
correct plan nau et al however proof tells us
work correctly domain description correct tell us
whether domain description represents domain given set
pddl operators
aips competition caused difficulty shop
predecessor shop shop team developing domain descriptions shop purely
hand made mistakes writing two domains thus shop found
incorrect solutions domains judges disqualified
shop domains
developing shop wrote translator program translate pddl operators
shop domain descriptions domain descriptions produced translator
program sufficient efficient shop need modified
hand order put domain knowledge described section however
translator program least provide correct starting point

debugging facilities
shop includes several debugging facilities important tracing
mechanism one tell shop trace set operators methods axioms
example figure given names namely case case two different
clauses method tell shop trace clauses
shop print messages time enters exits clause traced
depending particular tracing options one selects messages may include
things argument list current state world information
whether operator method axiom succeeds fails

protected conditions anti interleaving
shop operators include way specify protected conditions feature
described briefly nau et al bother describe
use competition cases wanted protect
conditions possible threats found convenient make use flags
similar available truck flag figure use following anti interleaving
feature shop
method subtasks tk ti begins keyword immediate
tells shop plan ti immediately ti finishes without trying
interleave tasks ti ti several examples appear appendix


fishop htn system

task person transport person destination
tasks unordered thus subtasks may interleaved
task plane transport plane destination
tasks unordered thus subtasks may interleaved
method transporting person
person already desired destination nothing
else
select plane
plane persons current position move
hold plane current position
board person onto plane
move plane destination
debark person destination
method transporting plane
plane already desired destination nothing
else move plane destination
figure abstract tasks methods simplified version zenotravel domain

developing domain descriptions shop
basics
first step developing domain description shop formulate abstract
tasks methods constitute reasonable solving strategy example
use simplified version zenotravel one domains competition
transport people current locations destination
use available airplanes figure shows set abstract tasks methods
transporting people moving airplanes
abstract strategy one figure implement
shop domain description consisting methods operators axioms example
method transporting person shown figure may one
value p satisfies precondition plane p plane use
nondeterministic branching point shop nondeterministic branching points
domain description may include heuristics guide shop search section
discusses ways write heuristics
method transport plane task one preconditions whether
planes fuel level enough get plane current position destination
figure shows axiom precondition
actions boarding people onto planes debarking planes refueling
planes modeled operators shop example shop operator
boarding given figure


finau au ilghami kuter murdock wu yaman

method
head
transport person person destination
case label use debugging
preconditions
person current position
current position destination
subtasks

case label use debugging
preconditions
person current position
plane p
subtasks
transport plane person p destination
figure shop implementation one methods figure
operator
head
board person plane
preconditions
person place plane place
delete list
person place
add list
person plane
figure shop operator simplified zenotravel domain

writing temporal domains
shop operators least expressive level actions pddl shop
explicitly support durative actions level pddl shop
explicit mechanism reasoning durative concurrent actions
however shop still enough expressive power represent durative concurrent
actions knows current state step process since
operators assign values variables numeric calculations allowed
us develop preprocessing technique call multi timeline preprocessing mtp
mtp technique translating pddl operators shop operators keep track
temporal information current state
pseudocode figure algorithmic description mtp
principle mtp could automatedbut practice done hand
needs done domain


fishop htn system

every operator domain
add two parameters start duration
os precondition
add assignment duration
formula calculating os duration
add assignment start
formula takes maximum write times
dynamic properties os precondition read times
dynamic properties os effects
dynamic property p os effects
add effects change value write time p start duration
dynamic property appears
add effects change read time p maximum
read time p start duration
figure multi timeline preprocessing mtp
keep description mtp simple let us suppose state every atom
p c cn represents single valued property e one cn p c
cn cn true property dynamic operator may change value cn
example initial state contains plane city operator
moves plane different location location plane dynamic
property p changes time mtp modifies operators keep track
within current state times property changes times
preconditions depend property idea dynamic property
p current state contain two time stamps read time p last time
action read value p write time p last time action
modified value p mtp modifies operators way whenever
operator reads e accesses dynamic property operator update propertys
read time operator writes e modifies dynamic property update
propertys write time thus instead single global time current state contain
many local times namely read time write time dynamic property
mtp inserts preconditions action ensure action begins
read time property writes write time property
reads prevents two actions overlapping time one writes
property reads example boarding operator fly operator
plane may overlap boarding operator requires plane
located particular city fly operator changes location plane
figure shows one shop operators produced mtp zenotravel
domain operator involves two dynamic properties vehicles fuel level location
operator reads properties may start write times
however writes one fuel level may start read time
vehicles location thus refueling may performed concurrently
actions depend vehicles location cannot performed concurrently
actions modify fuel level modify vehicles location


finau au ilghami kuter murdock wu yaman

operator refuel plane city start duration
preconditions
aircraft plane
city city
plane city
fuel plane fuel level
capacity plane fuel cap
refuel rate plane rate
assign duration fuel cap fuel level rate
write time fuel plane
write time plane
read time fuel plane
assign start eval max
assign end eval start duration
read time plane
assign value eval max end
delete list
fuel plane fuel level
write time fuel plane
read time fuel plane
read time plane
add list
fuel plane fuel cap
write time fuel plane end
read time fuel plane end
read time plane value
figure sample shop operator produced mtp
writing domains include optimization
previous competitions benchmarks compared speed
planners length output plans domain designers concentrated trying
reasonably short plan quickly possible contrast
years competition included linear objective function needed optimized
best plan longer one minimizes number steps instead
one minimized objective function value tried three approaches searching
optimal plans
structure shop methods way take shop less directly
toward plan minimizes objective function
write methods operators axioms generate plans quickly use sort
feature tell shop sort alternatives try promising ones first
assign costs operators use branch bound search best
plan within execution time limit


fishop htn system

first works well easy tell alternative best
node search space example know instances
objective minimize total fuel used perfect heuristic zenotravel
domain use fly action instead zoom action however
doesnt work well isnt immediately obvious alternative best example
objective minimize total time naive would use
zoom action rather fly action since zoom action faster however
zoom action best choice requires fuel thus cause
delays refueling
second extension first consider example
zenotravel domain objective minimize total fuel used addition
making planes fly instead zoom closer plane transport person
reduces total fuel used set preference sort feature shop
precondition method transporting person sort available planes
according fuel use order pick person greedy
decision point sort alternatives cost go alternative
lowest objective function value thus guaranteed
optimal solution however combined suitable heuristics
near optimal plans competition used technique extensively produced
satisfactory plans even largest
third makes use branch bound optimization explained section
main idea quickly define methods let plan may
poor quality let shop perform branch bound search plan space
least cost plan best plan within execution time limit
third challenge setting cost operator
example objective function requires minimizing total time order take
concurrency account cost action equal duration
example suppose latest event current partial plan plane arrive
airport time two passengers need board plane need
add two boarding actions plan recall zenotravel domain boarding
actions take amount time tb performed concurrently however
shop needs add actions plan one time first boarding action
increase total time tb cost tb however second boarding action
increase total time plan cost suppose add refuel action
plan action done concurrently boarding actions cost
max tr tb tr time needed refuel
possible combine two approaches however experience optimization third provide much benefit domain
descriptions already included two approaches situations shop
would frequently optimal nearly optimal plan even without optimization
meant additional amount time needed branch bound optimization would
produce little benefit branch bound optimization would perhaps useful
domains cost plan something sum costs
operators however domains occur competition


finau au ilghami kuter murdock wu yaman

international competition use optimization
official competition trial competition domains preliminary
testing shop optimization time limits shop unable solutions
within amount time willing let run except smallest
one way overcome difficulty would use time limits
preliminary tests never provided significant improvements cost across entire
set one reason lack improvement spent great deal
effort crafting methods used competition think third would
useful cases immediately clear implement first two
approaches one want spend much time devising sophisticated domain
description

competition
fourteen systems competed international competition
shop received distinguished performance award one top four awards
shop along tlplan talplanner one three planners solved
hand tailored fully automated tracks shop able
solve strips numeric hardnumeric simpletime time complex
domains shop solved planner competition
solved success ratio
two hand tailorable planners tlplan solved nearly many
shop since talplanner didnt numeric domains solved
still several hundred fully automated planners solved
general shop tended slower talplanner tlplanner although
one domain satellite hardnumeric shop consistently fastest
speeds three hand tailorable planners generally appeared polynomially
related probably planners domain knowledge enabled
solutions without much backtracking three hand tailorable planners
generally much faster fully automated planners
none three hand tailorable planners dominated two terms plan
quality situations solutions significantly better
significantly worse two

related work
following subsections discuss htn ordered task decomposition
hand tailorable planners participated competition
htn
htn first developed years ago sacerdoti tate
historically htn researchers focused practical applications
examples include production line scheduling wilkins crisis management logistics currie tate tate drabble kirby biundo schattenberg
scheduling spacecraft aarup arentoft parrod stader stokes


fishop htn system

estlin chien wang equipment configuration agosta manufacturability
analysis hebbar smith minis nau smith hebbar nau minis evacuation munoz avila aha nau weber breslow yaman game
bridge smith nau throop b
development formal semantics htn erol nau hendler
erol hendler nau shown strictly expressive classical
ai expressed htn
classical even one places restrictions htn
restrict expressive power classical generally much easier
translate classical htn vice versa lotem
nau hendler
ordered task decomposition
ordered task decomposition nau smith erol special case htn
builds plans forward initial state world
words ordered task decomposition planner plans tasks order
tasks later performed first applications ordered task decomposition
tailor made specific application domains best known example code
declarer play helped bridge baron win world championship computer
bridge smith et al b
shop shop nau et al previous domain independent orderedtask decomposition planner requires subtasks method initial
set tasks totally ordered rather partially ordered
thus shop subtasks different tasks cannot interleaved shop extends shop
allowing subtasks method partially ordered experiments shown
allow shop create plans efficiently shop domain descriptions
simpler needed shop nau et al shop shop
available open source software hhttp www cs umd edu projects shopi
tlplan talplanner
shop tlplan bacchus kabanza talplanner doherty kvarnstrom competed hand tailored track aips competition
tlplan talplanner similar many respects forward chaining
search apply operators current state generate successors thus shop know current state world every step
process control search planners use control rules written
declaratively temporal logic rules provide domain specific knowledge tell
planner states bad states planner backtrack try
specifically htn turing complete even undecidable expressed
htn remains turing complete even restrict tasks logical atoms
purely propositional e arguments contrast classical
represents solutions regular sets planners tlplan bacchus
kabanza talplanner doherty kvarnstrom overcome limitation classical
extending formalism include function symbols



finau au ilghami kuter murdock wu yaman

paths search space one difference tlplan talplanner tlplan
uses linear modal tense logic talplanner use tal narrative linear temporal logic used reasoning action change incompletely specified dynamic
environments
main difference planners shop kind control
knowledge use tlplan talplanner use temporal formulas tell
part search space avoided whereas shop uses htn methods tell
parts search space explored shop search space consists
nodes reachable htn methods whereas tlplan talplanner
explore part search space avoids bad states successors
hard say type control knowledge effective bacchus kabanza
argue two types useful different situations combining
useful topic future

summary conclusions
primary difference shop htn planners shop plans
tasks order executed thus knows current state
step process reduces complexity reasoning removing
great deal uncertainty world made easy us incorporate substantial expressive power shop addition usual htn methods
operators shop domain descriptions may include axioms mixed symbolic numeric
conditions external function calls procedure turing complete
sound complete large class nau et al
htn systems shop plans decomposing tasks subtasks
key idea htn planner design set methods encode something
akin standard operating procedures capture multi step techniques refining
task kinds domain characteristics much natural express htn
formalism action formalism see lotem et al description
issued involved
example consider um translog domain wrote use
domain aips competition wu nau um translog
straightforward generalization um translog domain andrews kettler erol
hendler generalizations include numeric information distances fuel
usage forth relatively straightforward formulate um translog
htn domain however much difficult figure formulate
um translog pddl domain use competitors competition
task took several months accomplish
htn systems shop development originally motivated competition instead try solve practical
example jshop java implementation shop predecessor shop
generative component hicap system evacuation operations munoz avila et al currently incorporating shop hicap
replacement jshop pleased shop capabilities gave
ability excel international competition


fishop htn system

acknowledgments
work supported part following grants contracts awards air force
laboratory f army laboratory daal k naval
laboratory n g university maryland general
board opinions expressed authors necessarily
reflect opinions funders
wish thank anonymous reviewers whose comments helped us make
significant improvements

appendix shop domain description zenotravel domain
numeric version
aips competition four different versions zenotravel
domain strips version numeric version simple time version time
version developed shop domain descriptions four versions
follows domain description numeric version zenotravel domain operators domain description translated original pddl
coding rough approximation mtp process figure
defdomain zenotravel

x x
different x x
possible person city
person p p city goal p city
different city city
operator cost end
maxtime max
assign newmax eval max end end max
maxtime max
maxtime newmax
newmax max
method board p c
write time start
board p c start
immediate cost call start
operator board p c start duration
person p aircraft city c
c p c onboard num
read time pmax assign num num
assign newpmax max pmax start duration l
onboard num read time pmax p c dest c
onboard num read time newpmax p


finau au ilghami kuter murdock wu yaman


method debark p c
write time start
debark p c start
immediate cost call start
operator debark p c start duration
person p aircraft city c
c p onboard num
read time pmax assign num num
assign newpmax max pmax start duration l
onboard num read time pmax p dest c
onboard num read time newpmax p c

method refuel c
write time start read time pmax
capacity cap fuel fuel
eval cap fuel
assign duration
assign end start duration l
assign newpmax max pmax end
ra read time pmax
read time newpmax
immediate refuel c start duration
immediate cost end
operator refuel c start duration
aircraft city c c
fuel fuel capacity cap
fuel fuel
fuel cap

method zoom c c
write time astart read time pmax
distance c c dist
fuel fuel fast burn burn
eval fuel dist burn
assign duration
assign start max pmax astart
assign end start duration l
ra write time astart read time pmax
read time write time end
immediate zoom c c start duration
immediate cost end
operator zoom c c start duration
aircraft city c city c onboard num
zoom limit limit eval num limit


fishop htn system

c distance c c dist fast burn burn
total fuel used total fuel
assign total total fuel dist burn
fuel fuel
assign fuel fuel dist burn
c total fuel used total fuel fuel fuel
c total fuel used total fuel fuel

method fly c c
write time astart read time pmax
distance c c dist
fuel fuel slow burn burn
eval fuel dist burn
assign duration
assign start max pmax astart
assign end start duration l
ra write time astart read time pmax
read time write time end
immediate fly c c start duration
immediate cost end
operator fly c c start duration
aircraft city c city c
c distance c c dist slow burn burn
total fuel used total fuel
assign total total fuel dist burn
fuel fuel
assign fuel fuel dist burn
c total fuel used total fuel fuel fuel
c total fuel used total fuel fuel

operator preprocessing name
totaltime coeff tc fuelused coeff fc
eval setf tc tc
eval setf fc fc



operator assert g


g

operator ra






finau au ilghami kuter murdock wu yaman


main methods

method transport person p c
case p c

method transport person p c
case sort num
p c
c
aircraft
onboard num
assert dest c
immediate board p c
assert dest c
immediate upper move aircraft style c
immediate debark p c
method transport person p c
case sort cost
p c
aircraft
c
different c c
forall c dest c c c
imply different c c
possible person c
travel cost info c c cost style
assert dest c
immediate upper move aircraft c style
immediate board p c
assert dest c
immediate upper move aircraft style c
immediate debark p c
method upper move aircraft c style
case c

case somecity
move aircraft somecity c style
method upper move aircraft style c
case c

case sort cost
somecity
travel cost info somecity c cost style
move aircraft somecity c style


fishop htn system

travel cost info cost slow
case
capacity cap distance dist
slow burn burn eval cap dist burn
assign cost positive fixnum
case
distance dist fuel fuel
slow burn burn
eval fuel dist burn
assign cost float
tc
fc
dist burn

case
capacity cap distance dist
slow burn burn
assign cost float
tc
fc
dist burn

travel cost info cost fast
case
capacity cap distance dist
fast burn burn eval cap dist burn
assign cost positive fixnum
case
distance dist fuel fuel
zoom limit limit onboard num eval num limit
fast burn burn
eval fuel dist burn
assign cost float
tc
fc
dist burn

case
capacity cap distance dist
fast burn burn
zoom limit limit onboard num eval num limit
assign cost float
tc
fc
dist burn




finau au ilghami kuter murdock wu yaman

method move aircraft c c slow
fuel fuel distance c c dist
slow burn burn
eval fuel dist burn
fly c c

refuel c
immediate fly c c
method move aircraft c c fast
fuel fuel distance c c dist
fast burn burn
eval fuel dist burn
zoom c c

refuel c
immediate zoom c c
method transport aircraft c
use
assert use
immediate upper move aircraft style c
immediate ra use

references
aarup arentoft parrod stader j stokes optimum aiv
knowledge scheduling system spacecraft aiv intelligent
scheduling pp morgan kaufmann
agosta j formulation implementation equipment configuration
sipe generative planner proc aaai spring symposium
integrated applications pp
andrews kettler b erol k hendler j um translog domain
development benchmarking systems tech rep cs tr
dept computer science university maryland
bacchus f kabanza f temporal logics express search control knowledge artificial intelligence
biundo schattenberg b abstract crisis concrete relief preliminary
report flexible integration nonlinear hierarchical proceedings
european conference
boddy dean solving time dependent sridharan
n ed proceedings eleventh international joint conference artificial
intelligence pp detroit mi usa morgan kaufmann
currie k tate plan open architecture artificial intelligence


fishop htn system

doherty p kvarnstrom j talplanner temporal logic planner ai
magazine
erol k hendler j nau complexity hierarchical task network
annals mathematics artificial intelligence
erol k nau hendler j htn complexity expressivity
aaai
estlin chien wang x argument hybrid htn operatorbased proc fourth european conference ecp pp
gupta n nau complexity blocks world artificial
intelligence
hebbar k smith minis nau plan evaluation designs
microwave modules proc asme design technical conference
lotem nau hendler j graphs solving htn
aaai pp
munoz avila h aha nau weber r breslow l yaman f sin
integrating case reasoning task decomposition ijcai
nau cao munoz avila h shop simple hierarchical ordered planner
ijcai pp
nau munoz avila h cao lotem mitchell total order
partially ordered subtasks ijcai seattle
nau smith j j erol k control strategies htn theory
versus practice aaai iaai proceedings pp
sacerdoti e nonlinear nature plans allen j hendler j tate
eds readings pp morgan kaufmann originally appeared
proc ijcai pp
slaney j thiebaux blocks world revisited artificial intelligence

smith j hebbar k nau minis integrating electrical mechanical
design process mantyla finger tomiyama eds
knowledge intensive cad vol pp
smith j nau throop success spades ai
techniques win world championship computer bridge aaai iaai
pp
smith j j nau throop b computer bridge big win ai
ai magazine
tate generating project networks ijcai pp
tate drabble b kirby r plan architecture command control morgan kaufmann


finau au ilghami kuter murdock wu yaman

wilkins e practical extending classical ai paradigm
morgan kaufmann san mateo ca
wu nau um translog domain designed aips
tech rep cs tr umiacs tr university maryland




