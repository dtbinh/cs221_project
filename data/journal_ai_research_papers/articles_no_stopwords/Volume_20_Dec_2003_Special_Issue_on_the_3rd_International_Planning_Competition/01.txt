Journal Artificial Intelligence Research 20 (2003) 61-124

Submitted 09/02; published 12/03

pddl2.1 : Extension pddl Expressing Temporal
Planning Domains
Maria Fox
Derek Long

maria.fox@cis.strath.ac.uk
derek.long@cis.strath.ac.uk

Department Computer Information Sciences
University Strathclyde, Glasgow, UK

Abstract
recent years research planning community moved increasingly towards
application planners realistic problems involving time many types resources. example, interest planning demonstrated space research community
inspired work observation scheduling, planetary rover exploration spacecraft
control domains. temporal resource-intensive domains including logistics planning, plant control manufacturing helped focus community
modelling reasoning issues must confronted make planning technology meet
challenges application.
International Planning Competitions acted important motivating force
behind progress made planning since 1998. third competition
(held 2002) set planning community challenge handling time numeric
resources. necessitated development modelling language capable expressing
temporal numeric properties planning domains. paper describe
language, pddl2.1, used competition. describe syntax
language, formal semantics validation concurrent plans. observe
pddl2.1 considerable modelling power exceeding capabilities current planning
technology presents number important challenges research community.

1. Introduction
1998 Drew McDermott released Planning Domain Description Language, pddl (McDermott, 2000; McDermott & AIPS-98 Planning Competition Committee, 1998),
since become community standard representation exchange planning
domain models. Despite dissatisfaction community features
pddl language enabled considerable progress made planning research
ease systems sharing standard compared
enormous increase availability shared planning resources. introduction pddl
facilitated scientific development planning.
Since 1998 decisive movement research community towards application planning technology realistic problems. propositional puzzle domains
old longer considered adequate demonstrating utility planning system modern planners must able reason time numeric quantities. Although several members community working applications planning
real domains nature time (Laborie & Ghallab, 1995; Ghallab & Laruelle,
1994; Muscettola, 1994; Drabble & Tate, 1994; Wilkins, 1988) always gap
c
2003
AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiFox & Long

modelling requirements domains expressed pddl.
Application-driven planners come equipped modelling conventions black
arts and, consequence, difficult reproduce results make empirical
comparisons approaches, essential scientific progress
made.
pddl language provides foundation expressive standard
constructed, enabling domain models applications-driven community shared
motivating development planning field towards realistic application.
third International Planning Competition, took place 2002, objective
closing gap planning research application. organisers third
competition authors therefore took first step defining expressive language
capable modelling certain class temporal resource-intensive planning domains.
done eye future awareness current
capabilities planners (it possible language used members
community, would competitors). paper describe resulting
language, pddl2.1, terms syntax, semantics modelling capabilities.
pddl2.1 designed backward compatible fragment pddl
common usage since 1998. compatibility supports development
resources help establish scientific foundation field AI planning.
Furthermore, McDermotts original pddl provides clean well-understood basis
development embodies number design principles considered important
retain. pddl2.1 extends pddl principled ways achieve additional expressive
power following, far possible, McDermotts maxim physics, advice (McDermott,
2000). take maxim mean language focus expressing physical
properties world, advice planner search associated
solution spaces. course, model physical systems makes simplifying assumptions
abstracts behaviours level, model claimed purely physics
free decisions could influence use model. attempt
make strong judgements constitutes advice try implement maxim
keeping language simple possible. make following two guarantees
backward compatibility:
1. existing pddl domains (in common usage) valid pddl2.1 domains.
important enable existing libraries benchmark problems remain valid.
2. Valid pddl plans valid pddl2.1 plans.
important contribution made development pddl2.1 means
domain designers provide alternative objective functions used judge
value plan. use numbers domain provides platform measuring
consumption critical resources parameters. example metric
modelled energy consumption must minimized. important many
practical applications planning plan quality might dependent number
interacting domain-dependent factors.
organisation paper follows. Section 2 introduce non-specialist
readers pddl domain description language used planning research community.
62

fipddl2.1: Expressing Temporal Planning Domains

background given order provide foundations numeric durative
extensions made developing pddl2.1. paper focusses specific extensions
introduced: numeric expressions durative actions. Section 3 start explaining
syntax numeric expressions use action descriptions. explain,
Section 4, metrics provided part problem description
quality plan involving numeric change evaluated terms appropriate
problem domain. present syntax metrics expressed give examples.
Section 5 paper introduces notion durative action way modelling
temporal properties planning domain. discretised continuous durative actions
considered. syntax described examples modelling power limitations
presented cases. given examples syntactic representation durative
actions present formal semantics discretised continuous actions
plans. Sections 6, 7, 8 9 provide details. semantics gives us way tackling
problem confirming plan validity something becomes important issue
face concurrent activity. Section 10 describe process plans
validated competition discuss complexity validation question
pddl2.1. Finally, Section 11 describes related work temporal reasoning
community, order put contributions made pddl2.1 wider context. full
bnf description pddl2.1 found appendix.
pddl2.1 developed use third International Planning Competition
competing planners demonstrated many discretized temporal metric models
efficiently handled domain-independent planners using handtailored control rules. ease reference competition identified features
pddl2.1 series levels increasing expressive power. Thus, strips fragment
pddl2.1 referred level 1, numeric extensions comprised level 2, addition
discretised durative actions resulted level 3, continuous durative actions resulted
level 4 final level, level 5, comprised extensions pddl2.1 additional
components support modelling spontaneous events physical processes. Level 5
discussed paper details found earlier work Fox Long (2002).
competition focussed use levels 1, 2 3 use levels 4 5
planning technology stage sufficiently advanced handle additional
complexities. Despite fact level 4 used competition devote
discussion paper. feel level 4 presents important immediate
challenges planning community affect extent planning
applied real problems.
purpose paper provide overview new features introduced
pddl2.1, discuss rationale language choices explain issues arisen trying extend pddl. Although provided bnf
pddl2.1 appendix, paper intended either language manual tutorial use language. examples use language
relevant materials, readers consult archived resources currently held
http://www.dur.ac.uk/d.p.long/competition.html.
63

fiFox & Long

2. pddl Background
pddl action-centred language, inspired well-known strips formulations
planning problems. core simple standardisation syntax expressing
familiar semantics actions, using pre- post-conditions describe applicability
effects actions. syntax inspired Lisp, much structure domain
description Lisp-like list parenthesised expressions. early design decision
language separate descriptions parameterised actions characterise
domain behaviours description specific objects, initial conditions goals
characterise problem instance. Thus, planning problem created pairing
domain description problem description. domain description
paired many different problem descriptions yield different planning problems
domain. parameterisation actions depends use variables
stand terms problem instance instantiated objects specific
problem instance action grounded application. pre- post-conditions
actions expressed logical propositions constructed predicates argument
terms (objects problem instance) logical connectives.
Although core pddl strips formalism, language extends beyond that.
extended expressive power includes ability express type structure objects
domain, typing parameters appear actions constraining types
arguments predicates, actions negative preconditions conditional effects
use quantification expressing pre- post-conditions. extensions
essentially proposed adl (Pednault, 1989).
Although original definition pddl syntax accompanied formal semantics, language really proposal standard syntax commonly accepted
semantics little scope disagreement meaning language
constructs. Two parts original language proposal claim fails
attempt offer standard syntax describing hierarchical domain descriptions, suitable
htn planners subset language concerned expressing numeric-valued
fluents. former ambitious project construct syntax entire structure domains using hierarchical action decompositions could expressed. contrast
strips-based planning, differences planners using hierarchical decomposition
appear deeper, domain descriptions often containing structures go beyond
description domain behaviours (for example, shop (Nau, Cao, Lotem, & MunozAvila, 1999) often uses mechanisms represent goal agendas solution-oriented
structures domain encoding). diversity undermined efforts standardisation
hierarchical domain descriptions part language never successfully
explored.
syntax proposed expressing numeric-valued fluents tested first
use language (in 1998 competition) and, indeed, underwent revision early
development language. second competition 2000 avoided use numericvalued fluents, general agreement syntax semantics numericexpressivity language remained unnecessary. McDermotts original pddl provides
support numbers allowing numeric quantities assigned updated. syntax
numeric-valued fluents changed pddl manuals 1.1 1.2 (McDermott &
64

fipddl2.1: Expressing Temporal Planning Domains

(define (domain jug-pouring)
(:requirements :typing :fluents)
(:types jug)
(:functors
(amount ?j -jug)
(capacity ?j -jug)
- (fluent number))
(:action empty
:parameters (?jug1 ?jug2 - jug)
:precondition (fluent-test
(>= (- (capacity ?jug2) (amount ?jug2))
(amount ?jug1)))
:effect (and (change (amount ?jug1) 0)
(change (amount ?jug2)
(+ (amount ?jug1) (amount ?jug2)))))
)

Figure 1: Pouring water jugs described AI Magazine article (McDermott,
2000).

AIPS-98 Planning Competition Committee, 1998) later AI Magazine article
pddl (McDermott, 2000). McDermott presented version numeric fluents used
pddl article AI Magazine (2000) could taken definitive statement
syntax. example using numeric fluents, presented McDermott (2000), shown
Figure 1. action models action well-known jugs-and-water problem,
allowing water one jug emptied second jug provided space
second jug large enough hold water first. effect discrete update
values current contents jugs assignment (denoted
change token).
Even without numeric extensions, pddl expressive language, capable capturing wide variety interesting challenging behaviours. Figure 2 illustrates
pddl used capture domain vehicle move locations,
consuming fuel so.
seen example pddl includes syntactic representation level
expressivity required particular domain descriptions use requirements
flags. gives opportunity planning system gracefully reject attempts
plan domains make use advanced features language
planner handle. Syntax checking tools used confirm requirements
flags correctly set domain types features language
correctly employed. example problem description accompany vehicle
domain shown Figure 3. example illustrates description initial
state requires exhaustive listing (atomic) propositions hold. Symmetric
transitive relations must modelled exhaustive explicit listing propositions
hold. use domain axioms simplify description domains use
relationships considered, remains untested part pddl therefore
65

fiFox & Long

(define (domain vehicle)
(:requirements :strips :typing)
(:types vehicle location fuel-level)
(:predicates (at ?v - vehicle ?p - location)
(fuel ?v - vehicle ?f - fuel-level)
(accessible ?v - vehicle ?p1 ?p2 - location)
(next ?f1 ?f2 - fuel-level))
(:action drive
:parameters (?v - vehicle ?from ?to - location
?fbefore ?fafter - fuel-level)
:precondition (and (at ?v ?from)
(accessible ?v ?from ?to)
(fuel ?v ?fbefore)
(next ?fbefore ?fafter))
:effect (and (not (at ?v ?from))
(at ?v ?to)
(not (fuel ?v ?fbefore))
(fuel ?v ?fafter))
)
)

Figure 2: domain description pddl.
unstable part syntax. pddl domains case-sensitive, somewhat
anachronistic light standard practice modern programming languages.
following sections review extensions made pddl development
pddl2.1, version language used third International Planning Competition.

3. Numeric Expressions, Conditions Effects
One first decisions made development pddl2.1 propose definitive
syntax expression numeric fluents. based syntax version described
AI Magazine article (McDermott, 2000), minor revisions (discussed below).
Numeric expressions constructed, using arithmetic operators, primitive numeric
expressions, values associated tuples domain objects domain functions. Using proposed syntax expressing numeric assignments updates
express jug-pouring operator originally described pddl1.2 manual AI
Magazine article (see Figure 1), pddl2.1, presented Figure 4. example
functions capacity amount associate jug objects numeric values corresponding capacity current contents respectively. seen example,
used prefix syntax arithmetic operators, including comparison predicates,
order simplify parsing. Conditions numeric expressions always comparisons
pairs numeric expressions. Effects make use selection assignment
operations order update values primitive numeric expressions. include
direct assignment relative assignments (such increase decrease). Numbers
distinguished possible roles, values represent, example, quantities
resources, accumulating utility, indices counters.
66

fipddl2.1: Expressing Temporal Planning Domains

(define (problem vehicle-example)
(:domain vehicle)
(:objects
truck car - vehicle
full half empty - fuel-level
Paris Berlin Rome Madrid - location)
(:init
(at truck Rome)
(at car Paris)
(fuel truck half)
(fuel car full)
(next full half)
(next half empty)
(accessible car Paris Berlin)
(accessible car Berlin Rome)
(accessible car Rome Madrid)
(acessible truck Rome Paris)
(accessible truck Rome Berlin)
(accessible truck Berlin Paris)
)
(:goal (and (at truck Paris)
(at car Rome))
)
)

Figure 3: problem instance associated vehicle domain.

(define (domain jug-pouring)
(:requirements :typing :fluents)
(:types jug)
(:functions
(amount ?j - jug)
(capacity ?j - jug))
(:action pour
:parameters (?jug1 ?jug2 - jug)
:precondition (>= (- (capacity ?jug2) (amount ?jug2)) (amount ?jug1))
:effect (and (assign (amount ?jug1) 0)
(increase (amount ?jug2) (amount ?jug1)))
)

Figure 4: Pouring water jugs, pddl2.1 style.

67

fiFox & Long

differences pddl2.1 syntax AI Magazine syntax
declaration functions use assign instead change. decided
allow numeric-valued functions, making declaration function return types
superfluous. therefore simplified language requiring declaration
function names argument types, required predicates. felt change
ambiguous used alongside operations increase decrease assign
would clearer.
Numeric expressions allowed appear terms language (that is,
arguments predicates values action parameters). two justifications
decision philosophical one pragmatic one. Philosophically take
view finite number objects world. Numbers exist
unique independent objects world, values attributes objects.
models object-oriented sense actions seen methods
apply objects given parameters. object-oriented view directly
inform syntax representations, reflected way numbers
manipulated relationships objects identified named
initial state. Pragmatically, many current planning approaches rely able
instantiate action schemas prior planning, feasible finite
number action instances. branching planners search space, choice points
corresponding action selection, therefore always finite ranges. use numeric
fluent variables conflicts could occur arguments predicate
would define finite ranges.
decision allow numbers used arguments actions rules
actions might seem intuitively reasonable. example, action fly certain
altitude might expected take altitude number-valued argument.
possible pddl2.1 range numbers used finite. practical
point view think unlikely arduous constraint benefits
keeping logical state space finite compensates modelling awkwardness
results.
Functions pddl2.1 restricted type Objectn R, (finite) collection objects planning instance, Object finite function arity n. Later extensions
pddl might introduce functions type Objectn Object, allowing Object extended application functions objects. advantage would
allow objects referred relationships known objects. (For example,
(onTopOf ?x) could used refer object currently top object instantiating ?x). Unfortunately, functions present various semantic problems. particular,
interpretation quantified preconditions becomes significantly harder, since collection objects longer necessarily finite, extensional interpretations possible.
difficulty identity problem objects manipulated actions,
functional expressions refer affected, implicitly. example,
objects moved, (onTopOf A) change without action manipulating explicitly.
Managing way functional terms map specific objects domain (which
might might specific names own) appears introduce considerable
complication semantics. believe important avoid extending pddl
elements still poorly understood.
68

fipddl2.1: Expressing Temporal Planning Domains

4. Plan Metrics
adoption stable numeric extension pddl core allowed us introduce
extension pddl2.1, namely new (optional) field within specification
problems: plan metric. Plan metrics specify, benefit planner, basis
plan evaluated particular problem. initial goal
states might yield entirely different optimal plans given different plan metrics. course,
planner might choose use metric guide development solution
evaluate solution post hoc. approach might lead sub-optimal, possibly
even poor quality plans, pragmatic approach handling metrics
quite widely used competition. issue discussed companion
paper analysing results 3rd IPC issue (Long & Fox, 2003b).
value total-time used refer temporal span entire plan.
values must built primitive numeric expressions defined within domain
manipulated actions domain. consequence, plan metrics
express non-temporal metrics pddl2.1 domains using numeric expressions. arithmetic expression used specification metric requirement
expression linear. domain designers responsibility ensure plan
metrics well-defined (for example, involve divisions zero). example use
plan metric shown Figure 5.
implications introduced extension far-reaching already
helped demonstrate important new challenges planning systems particularly
fully-automated systems. enriched descriptive power evaluation plans
crucial extension practical use planners, since almost never case real
plans evaluated solely number actions contain.
Metrics described problem description, allowing modeller easily explore
effect different metrics construction solutions problems
domain. order define metric terms specific quantity necessary
instrument quantity domain description. example, metric defined
terms overall fuel use fuel-use quantity initialised zero initial state
updated every time fuel consumed. domain shown Figure 5 possible
minimise linear combination fuel used vehicles as:
(:metric minimize (+ (* 2 (fuel-used car)) (fuel-used truck)))

However possible minimise distance covered since distance instrumented.
would straightforward instrument desired, simply adding appropriate initial
value incrementing effects domain description. Since actions cause quantities
change, instrumenting value requires modification domain description itself,
problem file.
use plan metrics subtle dramatic impact plans
sought. Perhaps simplest case actions increase metric must
minimised, decrease one must maximised. case example shown
Figure 5, use drive action worsen value plan metric
(whether use metric shown figure maximising metric described
last paragraph). situation might appear relatively straightforward: planner
69

fiFox & Long

(define (domain metricVehicle)
(:requirements :strips :typing :fluents)
(:types vehicle location)
(:predicates (at ?v - vehicle ?p - location)
(accessible ?v - vehicle ?p1 ?p2 - location))
(:functions (fuel-level ?v - vehicle)
(fuel-used ?v - vehicle)
(fuel-required ?p1 ?p2 - location)
(total-fuel-used))
(:action drive
:parameters (?v - vehicle ?from ?to - location)
:precondition (and (at ?v ?from)
(accessible ?v ?from ?to)
(>= (fuel-level ?v) (fuel-required ?from ?to)))
:effect (and (not (at ?v ?from))
(at ?v ?to)
(decrease (fuel-level ?v) (fuel-required ?from ?to))
(increase (total-fuel-used) (fuel-required ?from ?to))
(increase (fuel-used ?v) (fuel-required ?from ?to)))
)
)
(define (problem metricVehicle-example)
(:domain metricVehicle)
(:objects
truck car - vehicle
Paris Berlin Rome Madrid - location)
(:init
(at truck Rome)
(at car Paris)
(= (fuel-level truck) 100)
(= (fuel-level car) 100)
(accessible car Paris Berlin)
(accessible car Berlin Rome)
(accessible car Rome Madrid)
(accessible truck Rome Paris)
(accessible truck Rome Berlin)
(accessible truck Berlin Paris)
(= (fuel-required Paris Berlin) 40)
(= (fuel-required Berlin Rome) 30)
(= (fuel-required Rome Madrid) 50)
(= (fuel-required Rome Paris) 35)
(= (fuel-required Rome Berlin) 40)
(= (fuel-required Berlin Paris) 40)
(= (total-fuel-used) 0)
(= (fuel-used car) 0)
(= (fuel-used truck) 0)
)
(:goal (and (at truck Paris)
(at car Rome))
)
(:metric minimize (total-fuel-used))
)

Figure 5: example domain problem instance describing plan metric.
70

fipddl2.1: Expressing Temporal Planning Domains

must attempt use actions solve problem possible. fact, even case
little complex appears rival plans one uses
actions lower overall cost other. complex case arises
actions improve quality metric others degrade it. example, use
maximising metric add refuel action domain driving degrade plan
quality (by reducing fuel level vehicle) refuelling improve plan quality (by
increasing fuel level vehicle). case, planner attempt use actions
improve plan quality without actions actually contributing achieving goals.
example, refuelling might necessary get vehicles destinations,
adding refuelling actions would improve quality solution. process could
involve trading finite irreplaceable resources increased value plan.
would case if, example, refuelling vehicle took fuel finite reservoir.
Alternatively domain could allow plans arbitrarily high value constructed
using actions. would occur metric vehicles domain using
maximising vehicles fuel level metric refuelling constrained, since domain
impose limit fuel capacities vehicles.
case plans constrained finite availability resources, important
interesting form planning problem, case plans arbitrarily
high utility constructed, obviously ill-defined problem, since optimal plan
exist. non-trivial determine whether planning problem provided
metric ill-defined. fact, Helmert shows (Helmert, 2002), introduction numeric
expressions, even constrained way adopted pddl2.1, makes
planning problem undecidable. problem finding collection actions
consume irreplaceable resources overall beneficial impact plan metric
least hard planning problem. Therefore clear determining whether
planning problem even well-defined undecidable. make worthless
consider planning metrics, course, demonstrates modelling problem,
well planning problem, becomes even complex metrics introduced.
One strategy available planners working problems subject plan metrics
ignore metric simply produce plan satisfy logical goals problem
specifies. case, plan quality simply value, according metric,
plan happens constructed. strategy unsophisticated obviously
better planner construct plan guided specified metric. best use
metric expedite search process fully-automated planner still research issue.

5. Durative Actions
recent work temporal planning (Smith & Weld, 1999; Bacchus & Kabanza, 2000;
& Kambhampati, 2001) based various forms durative action. order
facilitate participation competition therefore developed two forms durative
action allowing specification restricted forms timed conditions effects
description. Although constrained certain ways, durative actions are,
nevertheless, expressive many proposals previously explored, particularly
way allow concurrency exploited. two forms discretised
durative actions continuous durative actions.
71

fiFox & Long

(:durative-action load-truck
:parameters (?t - truck)
(?l - location)
(?o - cargo)
(?c - crane)
:duration (= ?duration 5)
:condition (and (at start (at ?t ?l))
(at start (at ?o ?l))
(at start (empty ?c)
(over (at ?t ?l))
(at end (holding ?c ?o))
:effect (and (at end (in ?o ?t))
(at start (holding ?c ?o))
(at start (not (at ?o ?l)))
(at end (not (holding ?c ?o)))
)

Figure 6: durative action loading truck. assume capacity constraints.

forms rely basic durative action structure consisting logical changes
caused application action. always consider logical change instantaneous,
therefore continuous aspects continuous durative action refer numeric
values change interval action. Figure 6 depicts basic durative action,
load-truck, numeric change.
modelling temporal relationships discretised durative action done means
temporally annotated conditions effects. conditions effects durative actions
must temporally annotated. annotation condition makes explicit whether
associated proposition must hold start interval (the point action
applied), end interval (the point final effects action
asserted) interval start end (invariant duration
action). annotation effect makes explicit whether effect immediate (it
happens start interval) delayed (it happens end interval).
time points accessible, discrete activity takes place identified start
end points actions plan.
Invariant conditions durative action required hold interval
open ends (starting ending end points action). expressed
using construct seen Figures 6 8. one wants specify fact p
holds closed interval duration durative action, three conditions
required: (at start p), (over p) (at end p).
considered adopting convention constraints apply
start end points well open interval inside durative action, decided
would impossible express conditions actually
required hold open interval. Examples actions conditions
invariant open interval include action loading truck. truck must
remain loading location throughout loading interval, start move
away simultaneously loading completed. reason start
72

fipddl2.1: Expressing Temporal Planning Domains

drive action non-mutex end load reasonable interpretation
plan driving starts instant loading completed. Actions affect
invariant condition (such location truck) executed simultaneously
end point durative action invariant constrained hold true
end point itself. highlights important difference (over all) (over
end). condition required end precondition well invariant
condition meaning action affects invariant must start end
action requiring invariant. example, make (at truck location) end
precondition load operator well invariant, consequence truck
cannot drive away instant load completed.
Note that, definition load-truck action Figure 6, chosen make
condition (holding ?c ?o) start effect end precondition invariant
condition. means crane could temporarily cease hold cargo
time interval, long holding cargo time deposit end
loading interval. makes action quite flexible, enabling exploitation
concurrent uses crane applicable.
load-truck example shows logical change wrapped durative
actions encapsulate much detail involved achieving effect sequence
connected activities. Naturally would useful able combine actions
concurrently within plan. next section consider extent concurrency
allowed ways concurrent plans interpreted.
5.1 Interpretation Concurrent plans
time introduced modelling domain possible concurrent activity
occur plan. Prior introduction time pddl plans interpreted
sequential even Graphplan-concurrent plans sequenced validated
concurrency never issue. pddl2.1 plan validity depend exploiting
concurrency correctly. Actions overlap co-occur, giving rise questions
interpretation synchronous behaviour. discuss problems arising precise
synchronization Section 10. explain constraints actions occur
concurrently within plan involving durative actions numeric conditions effects.
key difference, durative actions pddl2.1 used planners prior
competition, distinguish conditions effects start
end points durative interval invariant conditions might specified
hold interval. is, actions pre- postconditions local
two end-points action, planner choose exploit durative action
effects start end. Conditions invariant distinguished
pre-conditions, enabling exploitation higher degree concurrency
possible preconditions distinguished invariants, tgp (Smith & Weld,
1999), tpsys (Garrido, Onainda, & Barber, 2001) tp4 (Haslum & Geffner, 2001).
discuss consequences design decisions, together several examples
durative actions, following sections.
important observe view time point-based rather interval-based.
is, see period activity terms intervals state separated time points
73

fiFox & Long

state-changing activities occur. logical state change occurs instantaneously,
start end point durative action. Propositions true half-open intervals
closed left open right. Activities might change logical state
might update values numeric variables. discretised view time
allow finite number activities (which call happenings) two time
points, although time considered continuous actions scheduled begin
time point.
plan considered valid, logical condition asserted negated
instant. impose constraint logical condition
required hold asserted instant. Although might seem overly
strong claim plan cannot guaranteed valid instant
proposition required exactly instant asserted. require that,
action precondition P start time t, must half open interval immediately
preceding P holds. mathematically inconsistent P asserted
instant required. conservative view validity
simultaneous update access state proposition. example, two
instantaneous actions, B, precondition P effects (not P ) Q,
B precondition P Q effect R, consider attempt apply
B simultaneously state P holds ill-defined. reason that, although
switches state one P holds one Q holds one might
suppose precondition B secure, abstraction model
values P Q changing and, argue, reliance values point
change unstable. adopt rule call moving targets, mean
two actions simultaneously make use value one two accessing value
update value moving target action access. rule creates
behaviour propositions planning state much behaviour
variables shared memory protected mutex lock (such POSIX threads),
difference read write access variable.
Validity requires numeric value accessed updated simultaneously
start end point durative action. case discretised durative actions,
numeric change modelled terms step functions numeric values accessed,
updated, interval another durative action acting value (we provide
examples following section) provided updates consistent invariant
properties dependent value. case continuous durative actions, values
simultaneously accessed updated continuous process change occurring
interval action. discretised continuous cases allow multiple
simultaneous updates provided update operations commutative.
order implement mutual exclusion relation require non-zero-separation
mutually exclusive action end points. view, end points nonconflicting treated though possible execute simultaneously
even though precise synchronicity cannot achieved world. However, end
points mutually exclusive planner buffer co-occurrence points
explicitly separating them. way ensure concurrency plan
least plausible world.
74

fipddl2.1: Expressing Temporal Planning Domains

(:durative-action heat-water
:parameters (?p - pan)
:duration (= ?duration (/ (- 100 (temperature ?p)) (heat-rate)))
:condition (and (at start (full ?p))
(at start (onHeatSource ?p))
(at start (byPan))
(over (full ?p))
(over (onHeatSource ?p))
(over (heating ?p))
(at end (byPan)))
:effect (and
(at start (heating ?p))
(at end (not (heating ?p)))
(at end (assign (temperature ?p) 100)))
)

Figure 7: simple durative action boiling pan water.

Planners exploit considerable concurrency domain ensuring conflicting start end points actions separated non-zero amount. detailed
specification mutual exclusion relation pddl2.1 given Section 8.
discuss implications non-zero separation Section 10.
5.2 Numeric Change within Discretised Durative Actions
section explains continuous change sometimes modelled pddl2.1 using
durative actions discrete effects. achieved using step functions describe
instantaneous changes beginnings ends durations actions. Appendix
details language constructs involved.
example durative action, illustrating use numeric update operations,
shown Figure 7. example showing water heating action, conditions (full ?p)
(onHeatSource ?p) must hold start interval well interval.
model enter conditions start constraints.
action achieves start effect water heating, condition maintained
invariant whole interval action. example operator
achieves invariant condition, draws attention fact conditions
hold interval open left (as well right).
noted actions Figures 7 8 use fixed duration specifications.
case water-boiling example means impossible adjust length
time pan heated impact context
action used. particular, assign construct used update numeric
value, possible concurrent activity affect value else model
flawed. water heating example uses assign construct concurrent
activity affect temperature water. responsibility modeller
ensure temperature neither accessed updated interval
action executing.
75

fiFox & Long

(:durative-action navigate
:parameters (?x - rover ?y - waypoint ?z - waypoint)
:duration (= ?duration (travel-time ?y ?z))
:condition (and (at start (available ?x))
(at start (at ?x ?y))
(at start (>= (energy ?x)
(* (travel-time ?y ?z) (use-rate ?x))))
(over (visible ?y ?z))
(over (can_traverse ?x ?y ?z)))
:effect (and (at start (decrease (energy ?x)
(* (travel-time ?y ?z) (use-rate ?x))))
(at start (not (at ?x ?y)))
(at end (at ?x ?z))))
(:durative-action recharge
:parameters (?x - rover ?w - waypoint)
:duration (= ?duration (recharge-period ?x))
:condition (and (at start (at ?x ?w))
(at start (in-sun ?w))
(at start (<= (energy ?x) (capacity ?x)))
(over (at ?x ?w)))
:effect (at end (increase (energy ?x) (* ?duration (recharge-rate ?x)))))

Figure 8: Discretised durative actions rover move locations recharge.

decided leave modeller ensure correct behaviour assign construct want forbid modelling truly discontinuous updates.
example, durative action models deposit cheque bank account might
duration three days, discontinuous update account balance
end interval would inappropriate prevent actions accessing
balance three day period. general, modelling continuous change discrete
effects open various pitfalls. price paid convenience
specify details continuous processes.
use discretised durative actions combination numeric (step-function)
updates requires care modelling. particular, relies notion conservative
resource updating. updating resource levels conservative consumption
resource modelled happens start durative action, even though
actually happens continuously duration action, production resource
modelled happens end durative action even though, again, might
actually produced continuously interval.
example discretised durative action, Figure 8 shows action
rover navigating two points modelled. local precondition start
period rover start location. Local effects include rover
consumes appropriate amount energy destination. first
conservative therefore immediate, second logical effect occurs
end point. organisation ensures parallel activities consume energy
already committed navigation activity. Similarly, recharge action
76

fipddl2.1: Expressing Temporal Planning Domains

Projected energy production
Actual energy profile
Initial Energy

Energy changing
production
consumption

Step function model
energy consumption
dig action

Final stage digging action
Final Energy
Step function model
energy produced
recharge action

Zero Energy
Recharge Action
Dig Action

Figure 9: Using discrete actions model production consumption resource.
reality, recharge activity produces energy continuously concurrent dig
activity continuously consumes it. conservative model using step functions
requires energy consumed digging must available start
action, despite yet updated model show additional
energy accumulated part recharge action far executed.
final energy level consistent used continuous model.

makes new charge available conclusion action, charge gained
cannot exploited recharging complete. use conservative updates
ensures model support invalid concurrency.
Figure 9 illustrates recharging digging action (that consumes energy) would
interact conservative energy consumption model. model would allow concurrent actions consume energy provided consume energy left
conservative assumption dig action consumed demands
start recharge action produced nothing end. Note example
assumes energy constraints capacity constraint.
use conservative updates subtle. capacity constraint
energy level rover one would need consider two separate resources: energy
space available storage energy. dig action would consume energy
start produce space end, recharge action would consume space
start produce charge end. Using combination would possible
ensure plans consume either resource available.
Durative actions conditional effects. antecedents consequents
conditional effect temporally annotated possible specify condition
checked start end, effect asserted either points.
77

fiFox & Long

(:durativeaction burnMatch
:parameters (?m match ?l location)
:duration (and (< ?duration 5) (> ?duration 0))
:condition (and (at start (have ?m))
(at start (at ?l)))
:effect (and (when (at start (dark ?l))
(and (at start (not (dark ?l)))
(at start (light ?l))))
(at start (not (have ?m)))
(at start (burning ?m))
(at end (not (burning ?m)))
(when (at start (dark ?l))
(and (at end (not (light ?l)))
(at end (dark ?l))))))
Actions

(:action pickUp
:parameters (?l location ?o object)
:precondition (and (at ?l)
(onFloor ?o ?l)
(light ?l))
:effect (and (not (onFloor ?o ?l))
(have ?o)))

Initial state: (onFloor coin) (have aMatch) (at basement) (dark basement)
Goal: (have coin)
Problem
Plan: 0.1 (burnMatch aMatch basement) [0.2]
0.2 (pickUp basement coin)
pickUp coin

Start burnMatch
dark basement

End burnMatch
light basement

0.1

0.2

dark basement

0.3

Plan

Figure 10: example problem durative action useful start effects.
burning match produces light necessary pick coin.

semantics makes clear well-formed durative action conditional effects cannot
require condition checked effect asserted. Conditional effects
arise pddl2.1 variants. discuss occurrence discretized durative actions
interpreted Section 8.1.
pddl2.1 allows specification duration inequalities enabling actions described
external factors involved determining temporal extent.
match-burning example shown Figure 10 seen effect start point
one interest, planner would exploit action start rather
end effect. duration inequality specifies match burn longer
specified upper bound. model shows match put early planner
considers appropriate. discuss use duration inequalities Section 5.3.
78

fipddl2.1: Expressing Temporal Planning Domains

5.3 Durative Actions Continuous Effects
objective discrete durative actions abstract continuous change concentrate end points period change takes place. syntax allows
precise specification discrete changes end points durative actions. However,
plan needs manage continuously changing values, well discretely changing
ones, durative action language semantics need powerful. General durative actions continuous well discrete effects. increase, decrease,
numeric variable according specified rate change time variable.
determining achieve goal planner must able access values
continuous quantities arbitrary points time-line plan. use #t refer
continuously changing time start durative action execution.
example, express fact fuel level plane, ?p, decreases continuously,
function consumption rate ?p, write:
(decrease (fuel-level ?p) (* #t (consumption-rate ?p)))

distinctly different from:
(at end (decrease

(fuel-level ?p)
(* (flight-time ?a ?b) (consumption-rate ?p))))

latter single update happening end point flight action, whilst
former allows correct calculation fuel level plane point
interval. former continuous effect, whilst latter discrete one. Continuous
effects temporally annotated evaluated time
interval action. #t local durative action, durative action
access purely local clock. Another way interpret expression representing
continuous change differential equation:

(fuel-level ?p) = (consumption-rate ?p)
dt
chose use #t symbol instead differential equation possible two
concurrent actions simultaneously modifying quantity. case, use
differential equations would actually form inconsistent pair simultaneous equations,
rather intended effect combined contribution changing value
quantity. Although expressions describing continuous change take form
product #t quantity, possible express complex change using
interdependent concurrent effects. example, acceleration arises simply increasing
distance using quantity describing velocity, time increasing velocity
using quantity describing acceleration. dependencies changing terms
include mutual dependencies terms differential equations arise
lead continuous change dictated exponential, logarithmic exponential functions.
plan containing continuous durative actions assign to, consult, continuously
modify numeric variables concurrently (see Example 1).
Figures 12 14 discrete continuous actions heating pan water
presented (this simple model ignores heat loss). discrete action presented Figure 12
modifies version presented Figure 7 use duration inequality constraint.
79

fiFox & Long

Example 1 flying refuelling example shown Figure 11 seen
invariant condition, fuel-level greater (or equal to) zero
flight, maintained whilst fuel continuously decreasing.
could expressed discrete durative actions abstracting continuous
decrease making final value available end point flight. However,
refuel operation happens flight time (in mid-air) fuel level
flight need calculated taking account continuous
rate consumption refuel operation. discrete action could calculate
fuel-level correctly would access distance
source destination flight, together rate consumption,
determine final fuel level. order calculate fuel level correctly
necessary determine time refuel takes place, use
remaining flight-time calculate fuel consumed. Discrete durative actions
give access time points start end points.
Discrete durative actions used express desired combinations flying
refuelling providing additional durative actions, fly-and-refuel,
encapsulate interactions described end calculating fuel level
correctly. However, approach requires domain designer
planner domain designer must anticipate every useful combination
behaviours ensure appropriate encapsulations provided.
contrast discrete form, continuous action, fuel consumption effect given terms #t, powerful enough express fact
mid-flight refuelling plane affects final fuel level way consistent
maintaining invariant fly action.

(:durative-action fly
:parameters (?p - airplane ?a ?b - airport)
:duration (= ?duration (flight-time ?a ?b))
:condition (and (at start (at ?p ?a))
(over (inflight ?p))
(over (>= (fuel-level ?p) 0)))
:effect (and (at start (not (at ?p ?a)))
(at start (inflight ?p))
(at end (not (inflight ?p)))
(at end (at ?p ?b))
(decrease (fuel-level ?p)
(* #t (fuel-consumption-rate ?p)))))
(:action midair-refuel
:parameters (?p)
:precondition (inflight ?p)
:effect (assign (fuel-level ?p) (fuel-capacity ?p)))

Figure 11: continuous durative action flying.

80

fipddl2.1: Expressing Temporal Planning Domains

(:durative-action heat-water
:parameters (?p - pan)
:duration (at end (<= ?duration (/ (- 100 (temperature ?p))
(heat-rate))))
:condition (and (at start (full ?p))
(at start (onHeatSource ?p))
(at start (byPan))
(over (full ?p))
(over (onHeatSource ?p))
(over (heating ?p))
(at end (byPan)))
:effect (and
(at start (heating ?p))
(at end (not (heating ?p)))
(at end (increase (temperature ?p)
(* ?duration (heat-rate)))))
)

Figure 12: discrete durative action heating pan water, using variable duration.

Duration inequalities add significant expressive power duration equalities. Duration
constraints express inequalities associated additional requirements flag
extended expressiveness fixed-duration discrete durative actions.
actions, logical post-condition start period pan
heating. conditions pan heating, full heat source invariant,
although presence agent (by pan) local precondition two
end-points invariant. first action duration modelled expressing
following duration inequality constraint:
(at end (<= ?duration (/ (- 100 (temperature ?p)) (heat-rate))))

effect end-point discrete durative action temperature
pan increased (* ?duration (heat-rate)) (where heat-rate domain
constant). continuous action Figure 14 duration constraint unnecessary
since invariant
(over (<= (temperature ?p) 100))

added ensure pan never exceeds boiling.
durative action Figure 12 models heating pan face possible concurrent activities affecting temperature. duration inequality allows planner
adapt duration take account temperature-affecting activity way
possible duration specified using equality constraint. duration
constraint ensures temperature never exceeds boiling checking, precondition updating activity, computed temperature increase executed
without exceeding boiling point. temperature increase would exceed boiling
plan invalid. temperature end interval execution computed
current temperature heating rate, together duration
heating action active (see discussion Example 2).
81

fiFox & Long

Example 2 plan attempts heat pan (say applying blowtorch
pan), heat-water interval then, provided concurrent action
ends end heat-water action, duration constraint seen
violated duration chosen overall increase
temperature would exceed boiling. concurrent activity ends simultaneously
heat-water action no-moving-targets rule would violated
duration constraint would attempt access temperature time
point concurrent action attempted update it.
Figure 13 depicts two situations. figure, apply-blowtorch durative
action applies heat object (in case, pan). part (a) figure
duration constraint violated duration heat-water action
sufficient cause temperature increase beyond boiling combined
heat increase caused blowtorch case plan invalid.
planner choose value duration avoids violation. part (b)
plan determined invalid regardless duration action
no-moving-targets rule. Notice model attempt model
consequences continued heating pan boiling point, plans
actions cause occur simply invalid. However, pddl2.1 used
model physical situation, consequences explicit
planner choose exploit avoid accordingly.

(a)

(b)

heatwater

applyblowtorch

heatwater
check duration
constraint

applyblowtorch

increase temperature
pan

Simultaneous change
consultation
temperature

Figure 13: Heating pan discrete durative action, concurrently another heating
activity.

82

fipddl2.1: Expressing Temporal Planning Domains

(:durative-action heat-water
:parameters (?p - pan)
:duration ()
:condition (and (at start (full ?p))
(at start (onHeatSource ?p))
(at start (byPan))
(over (full ?p))
(over (onHeatSource ?p))
(over (heating ?p))
(over (<= (temperature ?p) 100))
(at end (byPan)))
:effect (and
(at start (heating ?p))
(at end (not (heating ?p)))
(increase (temperature ?p) (* #t (heat-rate))))
)

Figure 14: continuous durative action heating pan water.
use duration inequalities adds significant expressive power even using discrete durative actions. example, plan depicted part (a) Figure 13,
illustrates use water-heating action shown Figure 12 concurrently heating pan blowtorch, considered valid provided duration
value satisfies duration constraint water-heating action. brings us
close expressive power available continuous durative actions gives
planner power exploit concurrent interacting activities enacting changes
numeric valued variable (see Example 3). Attempting express continuous change
using duration inequalities give precisely equivalent behaviour,
discretisation forces actions access changing numeric values separated,
small temporal interval, actions change values order resolve
mutual exclusion. continuous model necessary true value
numeric variable available consultation time continuous process
change.
discrete semantics presented Section 8 exploit fact changes
occur plan executed points corresponding times happenings, plan checked looking activity focussed finite happening
sequence. fact, provided continuous effects restricted linear functions time
first order effects (which requires continuous effects affect numeric
expressions contributing rate change another numeric valued variable), invariants restricted linear functions changing quantities, still possible restrict
attention happening sequence even using continuous actions.
Non-linear effects higher-order rates change create difficulties since possible
invariant satisfied end points interval, without necessarily
satisfied throughout interval. cases longer sufficient insert
invariant checking actions fixed mid-points happening sequence plan order
validate behaviour. However, provided effects first-order linear,
invariants linear continuously changing values, then, despite fact arbitrary
83

fiFox & Long

Example 3 possible discrete durative actions, duration inequalities,
model effects adding egg heating water water at, say,
90 degrees. applying two heat-water actions, around add-egg action, way overall duration two heat-water actions exactly
duration required boil water original temperature. However,
way heat-water action currently modelled means heat turned
egg added, turned complete heating, since
temperature updated durative action terminates. continuous durative actions egg added whilst single heat-water action
progress since temperature pan continuously updated. So, discrete durative actions duration inequalities allow us approximate continuous activity
appending finite sequence discrete intervals appropriate way.
moving targets rule means end points intervals separated
non-zero, arbitrarily small, time gaps. required using continuous
actions because, contrast step-function effects discrete actions, continuous effects localised single point.

time points within action intervals accessible planner, necessary gain
access numeric values start- end-points actions plan refer
them, together finitely many mid-points invariant-checking actions. values
required points. continuous durative actions
support modelling exogenous events, necessary take account
exogenous activity environment determining validity plan.
5.4 Related Approaches
Time important numerically varying quantity. simplest way reason time
adopt black box durative action model change happens ends
durative intervals. approach taken language used TGP (Smith &
Weld, 1999), example, durative actions encapsulate continuous change
correct values affected variables guaranteed end points
implied intervals. logical numeric effects durative action enacted
end action undefined interval execution. undeleted
preconditions must remain true throughout interval. syntactic distinction
preconditions invariant conditions action representation. simplistic
way ensuring correct action application prevent concurrent actions refer
facts, excludes many intuitively valid plans.
sophisticated approach allows preconditions annotated time points,
intervals, requirement condition true point,
interval, within duration action expressed. approach taken
Sapa (Do & Kambhampati, 2001). example, using annotated precondition
would possible express requirement chemical additive added within
two minutes start tank-filling action. effects specified occur
arbitrary points within duration action possible express effects
84

fipddl2.1: Expressing Temporal Planning Domains

occur end specified duration. possible distinguish
conditions local specific points duration action
invariant throughout action.
Allowing reference finitely many time points start end actions
makes language complex without adding expressive power. time
points strictly scheduled relative start action effect achieved
use sequence linked durative actions. decided keep pddl2.1
simple restricting access end points actions.
TLPlan (Bacchus & Ady, 2001) similar, constrained, approach adopted
actions applied instantaneously delayed effects. delays
effects arbitrary different effect. However, invariants cannot specified
preconditions checked instant application subsequent delayed
effects separated action initiated them.
Several planners developed use networks temporal constraints (Ghallab
& Laruelle, 1994; Jonsson, Morris, Muscettola, & Rajan, 2000; El-Kholy & Richards, 1996)
handle temporal structure planning problems. Efficient algorithms exist handling
constraints (Dechter, Meiri, & Pearl, 1991) make practical managing
large networks. domain models constructed using pddl2.1 certainly lend
treatment similar techniques, constrained handled way.

6. Introduction Semantics pddl2.1
Sections 7 8 provide formal semantics numeric extension temporal
extension pddl2.1. Together sections contain 20 definitions. lengthy treatment
necessary semantics developed adds four significant extensions
classical planning semantics Lifschitz developed strips (Lifschitz, 1986).
are:
introduction time, plans describe behaviour relative real time line;
related first extension, treatment concurrency actions executed
parallel, lead plans contain concurrent interacting processes
(although processes encapsulated durative actions pddl2.1);
extension handle numeric-valued fluents;
use conditional effects, alone conjunction
extensions.
semantics built familiar state-transition model. requirements semantics reduced four essential elements.
1. define state. introduction time numeric values complicate
usual definition state set atoms.
2. define state satisfies propositional formula representing goal condition
precondition action. extension usual interpretation state
valuation atom true atom state (the Closed
World Assumption) required order handle numeric values state.
85

fiFox & Long

3. define state transition induced application action. update rule
logical state must supplemented explanation consequences
numeric part state.
4. define two actions applied concurrently concurrent
application affects application actions individually.
structure definitions follows. Definitions 1 15, given Section 7,
define means plan valid plan consists non-durative
actions. Definitions 1 6 set basic terminology, foundational structures
framework handling conditional effects primitive numeric expressions. Definition 2 meets first requirement identified above, defining states. Definition 9 meets
second requirement, defining goal description satisfied state. Definition 11
defines simple plan, extending classical notion sequence actions adding
time. Definitions 12 meets fourth requirement, defining two actions cannot
executed concurrently. Definition 13 meets third requirement, defining mean
execution actions, including concurrent execution actions. Definitions 14 15
define execution plan means plan valid, given basis laid
previous definitions.
Section 8 semantics extended give meaning durative actions. begin
Definition 16, defines ground durative actions analogously Definition 6
simple (that is, non-durative) actions. Similarly, Definition 17 parallels definition
simple plan (Definition 11) Definitions 19 20 parallel execution
validity simple plans (Definitions 14 15). Definition 18 critical definition
semantics plans durative actions, supplying transformation temporal plans
simple plans, whose validity according semantics purely simple plans,
used determine validity original temporally structured plans.

7. Semantics Simple Plans
semantics define section extends essential core Lifschitz strips semantics (1986) handle temporally situated actions, possibly occurring simultaneously,
numeric conditional effects.
Definition 1 Simple Planning Instance simple planning instance defined
pair
= (Dom, P rob)
Dom = (F s, Rs, As, arity) 4-tuple consisting (finite sets ) function symbols,
relation symbols, actions (non-durative), function arity mapping symbols
respective arities. P rob = (Os, Init, G) triple consisting objects
domain, initial state specification goal state specification.
primitive numeric expressions planning instance, P N Es, terms constructed function symbols domain applied (an appropriate number )
objects drawn Os. dimension planning instance, dim, number
distinct primitive numeric expressions constructed instance.
86

fipddl2.1: Expressing Temporal Planning Domains

atoms planning instance, Atms, (finitely many) expressions formed
applying relation symbols Rs objects Os (respecting arities).
Init consists two parts: Initlogical set literals formed atoms Atms.
Initnumeric set propositions asserting initial values subset primitive
numeric expressions domain. assertions assign single primitive
numeric expression constant real value. goal condition proposition
include atoms formed relation symbols objects planning instance
numeric propositions primitive numeric expressions numbers.
collection action schemas (non-durative actions) expressed syntax
pddl. primitive numeric expression schemas atom schemas used action
schemas formed function symbols relation symbols (used appropriate
arities) defined domain applied objects Os schema variables.
semantics shows instantiated action schemas interpreted state transitions, similar way familiar state transition semantics defined Lifschitz.
important difference states longer seen simply sets propositions,
must account numeric expressions appearing planning instance
time state holds. achieved extending notion state.
Definition 2 Logical States States Given finite collection atoms planning instance I, AtmsI , logical state subset AtmsI . planning instance
dimension dim, state tuple (R, P(AtmsI ), Rdim
) R = R {}
denotes undefined value. first value time state, second
logical state third value vector dim values dim primitive numeric
expressions planning instance.
initial state planning instance (0, Initlogical , x) x vector values
R corresponding initial assignments given Initnumeric (treating unspecified
values ).
Undefined values included numeric ranges domains
terms start undefined nevertheless initialised exploited actions.
interpret actions state transition functions necessary achieve two steps.
Firstly, since (in pddl2.1) plans ever constructed fully instantiated action
schemas, process instantiation affects constructs action schema must
defined and, secondly, machinery links primitive numeric expressions elements
vector real values state allows interpretation numeric updating
behaviours action effects must defined. Since mechanisms support second
steps affect process first, treatment numeric effects described
first.
Definition 3 Assignment Proposition syntactic form numeric effect consists
assignment operator (assign, increase, decrease, scale-up scale-down), one
primitive numeric expression, referred lvalue, numeric expression (which
arithmetic expression whose terms numbers primitive numeric expressions),
referred rvalue.
87

fiFox & Long

assignment proposition corresponding numeric effect formed replacing
assignment operator equivalent arithmetic operation (that (increase p q)
becomes (= p (+ p q)) on) annotating lvalue prime.
numeric effect assignment operator either increase decrease
called additive assignment effect, one operator either scale-up
scale-down called scaling assignment effect others called simple assignment
effects.
numeric effect defines function numeric values state action
applied determining value primitive numeric expression resulting state.
convenience uniform treatment numeric expressions appearing pre-
post-conditions, transform functions propositions assert equality
post-condition value expression intended define it. is, rather
writing effect (increase p q) function f (p) = p + q, write proposition
(= p0 (+ p q)). priming distinguishes postcondition value primitive numeric
expression precondition value (a convention commonly adopted describing state
transition effects numeric values). binding primitive numeric expressions
values states defined following definition.
Definition 4 Normalisation Let planning instance dimension dimI let
indexI : P N EsI {1, . . . , dim}
(instance-dependent) correspondence primitive numeric expressions

.
integer indices elements vector dimI real values, Rdim

normalised form ground proposition, p, defined result substituting primitive numeric expression f p, literal XindexI (f ) . normalised
form p referred N (p). Numeric effects normalised first converting
assignment propositions. Primed primitive numeric expressions replaced
corresponding primed literals. X used represent vector hX1 . . . Xn i.
Definition 4, replacement primitive numeric expressions indexed literals
allows convenient consistent substitution vector actual parameters
vector literals X appearing state.
machinery supporting treatment numeric expressions complete,
possible consider process instantiating action schemas. process managed
two steps. first step remove constructs treat syntactic sugar
definition domain. conditional effects quantified formulae. handle
direct syntactic transformations action schema set action
schemas considered equivalent. transformation similar described
Gazen Knoblock (1997). Although would possible give semantic interpretation
application conditional effects directly, transformation allows us significantly
simplify question actions performed concurrently.
Definition 5 Flattening Actions Given planning instance, I, containing action
schema AsI , set action schemas f latten(A), defined set S, initially
containing constructed follows:
88

fipddl2.1: Expressing Temporal Planning Domains

contains action schema, X, conditional effect, (when P Q), create
two new schemas copies X, without conditional effect, conjoin
condition P precondition one copy Q effects copy,
conjoin (not P) precondition copy. Add modified copies S.
contains action schema, X, formula containing quantifier, replace
X version quantified formula ( Q ( var1 . . . vark ) P) X
replaced conjunction (if quantifier, Q, forall) disjunction (if Q
exists) propositions formed substituting objects variable
var1 . . . vark P possible ways.
steps repeated neither step applicable.
flattened, actions grounded usual substitution objects parameters:
Definition 6 Ground Action Given planning instance, I, containing action schema
AsI , set ground actions A, GAA , defined set structures,
a, formed substituting objects schema variables schema, X,
f latten(A) components are:
Name name action schema, X, together values substituted
parameters X forming a.
Prea , precondition a, propositional precondition a. set ground
atoms appear Prea referred GPrea .
Adda , positive postcondition a, set ground atoms asserted
positive literals effect a.
Dela , negative postcondition a,is set ground atoms asserted
negative literals effect a.
NPa , numeric postcondition a, set assignment propositions corresponding numeric effects a.
following sets primitive numeric expressions defined ground action,
GAA :
La = {f |f appears lvalue a}
Ra = {f |f primitive numeric expression rvalue appears P rea }
La = {f |f appears lvalue additive assignment effect a}
comment appropriate last definition: action precondition might
considered two parts logical part numeric expression-dependent part.
Unfortunately, interdependent. example:
(or (clear ?x) (>= (room-in ?y) (space-for ?z)))
89

fiFox & Long

might precondition action. order handle conditions, need check
whether satisfied given current logical state, current
values domain numeric expressions. inclusion numeric component
state makes necessary ensure correct substitution numeric values
expressions used action precondition. achieved using normalisation process
Definition 4 Definition 9. contrast, postcondition action cannot contain
interlocked numeric logical effects, possible separate effects
distinct numeric logical components.
Definition 7 Valid Ground Action Let ground action. valid primitive
numeric expression appears lvalue one simple assignment effect,
one different type assignment effect.
Definition 7 ensures action attempt inconsistent updates numeric
value. Unlike logical effects action cannot conflict, possible write
syntactic definition action effects inconsistent, example
assigning two different values primitive numeric expression.
Definition 8 Updating Function Let valid ground action. updating function
composition set functions:
dim
{NPFp : Rdim
R | p N P }

NPFp (x) = x0 primitive numeric expression x0i appear
lvalue N (p), x0i = xi N (p)[X0 := x0 , X := x] satisfied.
notation N (p)[X0 := x0 , X := x] read result normalising p
substituting vector actual values x0 parameters X0 actual values x
formal parameters X.
Definition 8 defines function describing update effects action. function
ensures reals vector describing numeric state remain unchanged
affected action (this numeric-state equivalent persistence
achieved propositions strips assumption). values vector,
normalisation process used substitute correctly indexed vector elements
primitive numeric expressions appearing lvalues (which primed vector elements
corresponding values post-action state) rvalues (the unprimed values appearing
pre-action state). tests must satisfied order ensure correct behaviour
functions composition simply confirm arithmetic rvalues
correctly applied arrive lvalues. requirement action valid ensures
composition functions Definition 8 well-defined, since functions
set commute, composition carried order.
various sets primitive numeric expressions defined Definition 6 allow us
conveniently express conditions two concurrent actions might interfere
one another. particular, concerned allow concurrent assignment
primitive numeric expression, concurrent assignment inspection. allow
concurrent increase decrease primitive numeric expression. allow
90

fipddl2.1: Expressing Temporal Planning Domains

apply collections concurrent updating functions primitive numeric expressions. allowed provided functions commute. Additive assignments
commute, updating operations cannot guaranteed so, except
affect primitive numeric expressions rely primitive numeric expressions
affected concurrent assignment propositions. would possible make
similar exception scaling effects, additive assignment effects particularly
important role durative actions shared scaling effects, simplicity
allow concurrent updates effects. use three sets primitive
numeric expressions determine whether safe situation not. Within single
action possible rvalues lvalues intersect. is, action update
primitive numeric expressions using current values primitive numeric expressions
updated action. rvalues values take state
prior execution lvalues supply new values state follows.
Definition 9 Satisfaction Propositions Given logical state, s, ground propositional formula pddl2.1, p, defines predicate Rdim
, Num(s, p), follows:
Num(s, p)(x)

iff

|= N (p)[X := x]

|= q means q true interpretation atom, a,
numeric comparison, assigned true iff s, numeric comparison interpreted
using standard equality ordering reals logical connectives given usual
interpretations. p satisfied state (t, s, X) Num(s, p)(X).
Comparisons involving , including direct equality two values undefined, enclosing propositions undefined satisfied state.
Definition 10 Applicability Action Let ground action. applicable
state P rea satisfied s.
7.1 Semantics Simple Plan
simple plan, pddl2.1, sequence timed actions, timed action
following syntactic form:
: (action p1 . . . pn )
notation positive rational number floating point syntax expression
(action p1 . . . pn ) name actual parameters action executed
point time. complex plans simple durative actions, without numericvalued effects preconditions, co-occur semantics plans discussed
Section 8. special separators required separate timed actions sequence
actions required presented time-sorted order. possible
multiple actions given time stamp, indicating executed
concurrently. emphasised earliest point activity occurs within
plan must strictly time 0. constraint follows decision make
initial state state existing time 0, together decision, semantics,
actions effects interval closed left, starting time
action applied, preconditions tested interval open
right precedes action.
91

fiFox & Long

order retain compatibility output current planners following concession made: plan presented sequence actions time points,
inferred first action applied time 1 succeeding actions apply
sequence integral time points one unit apart.
simple plan slight generalisation familiar strips-style classical plan,
since actions labelled time executed.
Definition 11 Simple Plan simple plan, SP , planning instance, I, consists
finite collection timed simple actions pairs (t, a), rational-valued
time action name.
happening sequence, {ti }i=0...k SP ordered sequence times set
times appearing timed simple actions SP . ti must greater 0.
possible sequence empty (an empty plan).
happening time t, Et , happening sequence SP , set
(simple) action names appear timed simple actions associated time SP .
plan thus consists sequence happenings, set action names applied
concurrently specific time, sequence ordered time. times
happenings occur forms happening sequence. noted action names
ambiguous action schemas contain conditional effects consequence flattening
split actions multiple actions identical names, differentiated
preconditions. However, one set actions identical names
applicable given logical state, since precondition action set
necessarily inconsistent precondition action set, due
way conditional effects distributed pairs action schemas
induce.
order handle concurrent actions need define situations
effects actions consistent one another. issue first discussed
Section 5.1. mutual exclusion rule pddl2.1 extension idea action
mutex conditions GraphPlan (Blum & Furst, 1995). extension handles two extra
features: extended expressive power language (to include arbitrary propositional
connectives) introduction numeric expressions. make conservative
condition actions executed concurrently, ensures possibility
interaction. rules cases intuition might suppose concurrency
possible. example, actions:
(:action
:precondition (or p q)
:effect (r))
(:action b
:precondition (p)
:effect (and (not p) (s)))

could, one might suppose, executed simultaneously state p q hold.
following definition asserts, however, two actions mutex. reason
chosen constrained definition checking mutex actions must
92

fipddl2.1: Expressing Temporal Planning Domains

tractable handling case implied example would appear require checking
consequence interleaving preconditions effects possible orderings.
condition primitive numeric expressions already discussed determines
update effects executed concurrently affect values
tested preconditions (regardless whether results tests
matter satisfaction enclosing proposition). rule moving
targets: concurrent actions affect parts state relevant precondition
tests actions set, regardless whether effects might harmful
not. might considered odd preconditions one action cannot refer literals
add effects concurrent action. require preconditions
negative, case interaction add effects analogous interaction
positive preconditions delete effects. moving targets rule makes
cost determining whether set actions applied concurrently polynomial
size set actions pre- post-conditions.
Definition 12 Mutex Actions Two grounded actions, b non-interfering
GP rea (Addb Delb ) = GP reb (Adda Dela ) =
Adda Delb = Addb Dela =
La Rb = Ra Lb =
La Lb La Lb
two actions non-interfering mutex.
last clause definition asserts concurrent actions update
values additive assignment effects.
ready define conditions simple plan valid.
separate executability plan whether actually achieves intended goal.
say plan valid executable achieves final goal. Executability
defined terms sequence states plan induces sequentially executing
happenings defines.
Definition 13 Happening Execution Given state, (t, s, x) happening, H,
activity H set grounded actions
AH = {a|the name H, valid P rea satisfied (t, s, x)}
result executing happening, H, associated time tH , state (t, s, x)
undefined |AH | =
6 |H| pair actions AH mutex. Otherwise, state
0
0
(tH , , x )
[
[
s0 = (s \
Dela )
Adda
aAH



x0

aAH

result applying composition functions {NPFa | AH } x.

Since functions {NPFa | AH } must affect different primitive numeric expressions,
except represent additive assignment effects, functions commute
93

fiFox & Long

therefore order functions applied irrelevant. Therefore, value
x0 well-defined last definition. requirement activity happening
must number elements happening simply constraint
ensures action name happening leads valid action applicable
appropriate state. already seen conditional effects induce construction
families grounded actions, one family applicable
state. none applicable given name, must mean
precondition unsatisfied, regardless conditional effects. case, asserting
attempt apply action undefined interpretation.
Definition 14 Executability simple plan, SP , planning instance, I, executable
defines happening sequence, {ti }i=0...k , sequence states, {Si }i=0...k+1
S0 initial state planning instance = 0 . . . k, Si+1
result executing happening time ti SP .
state Sk+1 called final state produced SP state sequence {Si }i=0...k+1
called trace SP . Note executable plan produces unique trace.
Definition 15 Validity Simple Plan simple plan (for planning instance, I)
valid executable produces final state S, goal specification
satisfied S.

8. Semantics Durative Actions
Plans durative actions discrete effects given semantics terms
semantics simple plans. Handling durative actions continuous effects
complex discuss Section 9.
Durative actions appearing plan must given additional field indicating
duration. given syntax:
: (action p1 . . . pn ) [d]
rational valued duration, written floating point syntax.
Durative actions introduced framework defined far generalising
Definition 1 include durative action schemas. definition grounded action must
extended define form grounded durative actions. However, definition
given way associate durative action two simple (nondurative) actions, corresponding end points durative action. simple
actions can, together, simulate almost behaviour durative action.
aspects captured pair simple actions duration durative
action invariants must hold duration. two elements can,
however, simply handled minor extension semantics simple plans,
approach adopt. taking route avoid difficulties establishing
effects interactions durative actions handled semantics
concurrent activity within simple plan. see, one difficulty account
handling durative actions conditional effects contain conditions effects
associated different times conditions must hold entire duration
94

fipddl2.1: Expressing Temporal Planning Domains

action. Since cases complicate semantics postpone treatment
next section begin durative actions without conditional effects.
mapping durative actions non-durative actions important consequence mutex relation implied non-durative actions (advantageously)
weaker strong mutex relation used in, example, TGP (Smith & Weld, 1999).
Two durative actions applied concurrently provided end-points one action
interact either end-points (if simultaneous) invariants
action.
Definition 16 Grounded Durative Actions Durative actions grounded
way simple actions (see Definition 6), replacing formal parameters constants planning instance expanding quantified propositions. definition
durative actions requires condition conjunction temporally annotated propositions. temporally annotated proposition form (at start p), (at end p)
(over p), p unannotated proposition. Similarly, effects durative action (without continuous conditional effects) conjunction temporally
annotated simple effects.
duration field DA defines conjunction propositions separated
DA DC DA , duration conditions start end DA, terms
DCstart
end
arithmetic expressions ?duration. separation conducted obvious way,
DA end conditions DC DA .
placing start conditions DCstart
end
grounded durative action, DA, continuous effects conditional effects
defines two parameterised simple actions DAstart DAend , parameter
?duration value, single additional simple action DAinv , follows.
DAstart (DAend ) precondition equal conjunction set propositions, p, (at start p) ((at end p)) condition DA, together
DA (DC DA ), effect equal conjunction simple effects, e,
DCstart
end
(at start e) ((at end e)) effect DA (respectively).
DAinv , defined simple action precondition equal conjunction
propositions, p, (over p) condition DA. empty effect.
Every conjunct condition DA contributes precondition precisely one
DAstart , DAend DAinv . Every conjunct effect DA contributes effect
precisely one DAstart DAend . convenience, DAstart (DAend , DAinv ) used
refer entire (respective) simple action name.
actions DAstart DAend parameterised ?duration parameter
must substituted correct duration value order arrive two simple
actions corresponding start end durative action.
Definition 17 Plans plan, P , durative actions, planning instance, I, consists
finite collection timed actions pairs, either form (t, a),
rational-valued time simple action name action schema name together
constants instantiating arguments schema, form (t, a[t0 ]),
rational-valued time, durative action name t0 non-negative rational-valued
duration.
95

fiFox & Long

Definition 18 Induced Simple Plan P plan happening sequence P
{ti }i=0...k , ordered sequence time points formed set times1
{t | (t, a) P (t, a[t0 ]) P (t t0 , a[t0 ]) P }
induced simple plan plan P , simplify(P ), set pairs defined follows:
(t, a) (t, a) P simple (non-durative) action name.
(t, astart [?duration := t0 ]) (t + t0 , aend [?duration := t0 ]) (these expressions
simple timed actions square brackets denote substitution t0 ?duration
case) pairs (t, a[t0 ]) P , durative action name.
((ti + ti+1 )/2, ainv ) pair (t, a[t0 ]) P ti < + t0 ,
ti ti+1 happening sequence P .
process transforming plan simple plan involves introducing actions
represent end points intervals durative actions plan
applicable. Duration constraints convert simple preconditions start end actions,
requiring substitution numeric value ?duration field complete conversion simple actions. complication process invariants cannot
associated end points, must checked throughout interval.
achieved adding simple plan collection special actions responsible checking invariants. actions added pair happenings original
plan lying start end point durative action. semantics
simple plans requires preconditions actions plan satisfied, even though
might effects, consequence putting monitoring actions
simple plan ensure original plan judged valid invariants remain
true, firstly, start durative action and, subsequently, happening
occurs throughout duration durative action. One possibility make
monitoring actions occur times updating actions, would require
values accessed time might updated, violating
moving targets rule. order avoid problem monitoring actions interleaved
updating actions inserting midway pairs successive happenings
interval durative action executed. happenings original plan need considered carrying insertion, since invariant-checking
actions cannot effect states checked.
Alternative treatments invariants possible, important advantage
approach taken semantics rests, finally, state-transition model
form familiar planning community. is, plans seen recipes
state-transition sequences, state-transition function current
state world next. However, durative actions complicate picture
rely commitment, durative action started, follow
completion. commitment involves sort communication across duration
plan. communication managed structures outside plan, examine
1. Care taken reading definition last disjunct allows time corresponding
end execution durative action included happening time.

96

fipddl2.1: Expressing Temporal Planning Domains

trace, artificial modification plan ensure states carry extra
information start end durative action. latter approach
disadvantage durative actions become complex artificial components
must added plan become intrusive. particularly apparent
treatment conditional effects require conditions tested start durative
action, across duration, effects triggered end, since cases
require sort memory state remember status tested conditions
start durative action end point. memory conditions allow
us avoid embedding entire execution history state substituting ad hoc
memory history propositions times required.
management conditional effects form, mapping durative actions
simple actions, discussed Section 8.1.
conclude definitions supporting validity plan durative
actions.
Definition 19 Executability Plan plan, P (for planning instance), executable induced simple plan P , simplify(P ) executable, producing trace
{Si = (ti , si , vi )}i=0...k .
Definition 20 Validity Plan plan, P (for planning instance), valid
executable goal specification satisfied final state produced induced
simple plan.
8.1 Durative Actions Conditional Effects
explain mapping described previous section extended deal
durative actions containing conditional effects.
First, observe temporally annotated conditions effects accumulated,
temporal annotation distributes logical conjunction. Therefore,
convert conditional effects conditions simple conjunctions
one start condition, one end condition one condition.
noted allow logical connectives conjunction combining temporally annotated propositions. Allowing connectives would create significant
complexity semantics create potentially paradoxical opportunities
communication future states earlier states. Similarly conditions, durative action
effects reduced conjunction one start effect one end
effect. Treatment conditional effects divides three cases. first case
straightforward: effect durative action form (when (at p) (at q)),
condition effect bear single temporal annotation, transformed simple conditional effect form (when p q) attached start end
simple action according whether start end. Since case straightforward
explicitly extend previous definitions cope it. second case one
condition condition effect start conditions effect end
effects.
Note consider conditional effects effects occur start,
conditions dependent state end duration action,
97

fiFox & Long

meaningless. reverse expected behaviour causality, cause
precedes effect. attempt validate plan constructing trace reversed
causality would huge problem, since could determine initial effects applying durative action seen conditions held subsequent interval
conclusion activity, but, equally, could see effects activity interval would without seeing initial effects applying durative action.
paradox created opportunity action change past.
handle second case need modify state start durative action remember whether start conditions satisfied communicate
end durative action simply looked (then) current state
determine whether conditional effect applied. apply transformation
conditional effects form (when (and (at start ps) (at end pe)) (at end q))
conditional effect added start simple action, (when ps (Mps )), conditional effect added end simple action, (when (and pe (Mps )) q), Mps
special new proposition, unique particular conditional effect particular application durative action transformed. ensuring proposition unique
way, possibility action plan interfering it,
represents isolated memory fact ps held state durative
action started. conditional effect end conditions, transformation applied, simply ignoring pe previous discussion. Figure 15 depicts
transformation single durative action, A, conditional effect, collection
level 2 actions, complete appropriate memory proposition (in case called
P ).
importance memory introduced transformation explained Figures 16 17. Figure 16 shows ambiguity results remembering
state, trajectory plan, reached. figure illustrates one
state (P, Q, R) point durative action (as described Figure 15) ends,
impossible determine state alone whether R added not.
possible reached state (P, Q, R) least two different paths,
least one path seen started state P held least one path
seen started state P hold (using action, achieve-P , P
effect). state (P, Q, R) contain information disambiguate
path used reach it, hence cannot determine correct value R
ends.
third, final, case durative action conditional effects form:
(when (and (at start ps) (over pi) (at end pe)) (at end q)).

Again, effect start end conditions following transformation
applied simply ignoring ps pe appropriate. case need construct transformation remembers whether ps held state durative
action first applied, whether pi holds throughout interval start
end durative action. Unlike invariants durative actions, conditions
required hold plan valid, determine effects occur
end durative action. idea use intervening monitoring actions, rather
invariants definition 18. achieved adding effect start
98

fipddl2.1: Expressing Temporal Planning Domains

Initial Durative Action
(:durative-action
:parameters ()
:duration (= ?duration 2)
:condition ()
:effect (when (and (at start P) (at end Q))
(at end R)))

Transformation simple actions
(:action A-start
:parameters ()
:precondition ()
:effect (when P P*))

(:action A-end
:parameters ()
:precondition ()
:effect (when (and P* Q) R))

Expansion conditional effects
(:action A-start
:parameters ()
:precondition (P)
:effect (P*))

(:action A-start
:parameters ()
:precondition (not P)
:effect ())

(:action A-end
:parameters ()
:precondition (and P* Q)
:effect (R))

(:action A-end
:parameters ()
:precondition (or (not P*) (not Q))
:effect ())

Transformation Plan Simple Plan
Plan

Plan

1:A[2]

1:A-start
3:A-end

Figure 15: Conversion durative action non-durative actions grounded
forms.

99

fiFox & Long

P,Q,~R

1:A-start
3:A-end
P,Q,~R

P,Q
R?

1:A-start
~P,Q

2:achieve-P

~P,Q
~R

~R

Figure 16: Flawed state space resulting failure record path traversed conditional effects span interval durative action. arc labelled achieve-P
indicates possible application action achieves proposition
P.
1:A-start
P,Q
~R,~P*

P*,P
Q,~R

3:A-end

2:achieve P
~P,Q
~R,~P*

1:A-start

~P,Q
~R,~P*

P,Q
R,P*
3:A-end
P,Q,
~R,~P*

P,Q
~R,~P*

Figure 17: Correct state space showing use memory proposition P*. arc labelled
achieve P indicates possible application action achieves
proposition P.

action: (Mpi ). Then, monitoring (simple) actions required precondition, single conditional effect: (when (and (Mpi ) (not pi)) (not (Mpi ))).
again, Mpi special new proposition unique conditional effect application
instance durative action transformed. monitoring actions added
intermediate points used monitoring actions Definition 18.
transformation used second case required start condition,
ps, (when ps (Mps )) added conditional effect start simple action. Finally,
add conditional effect end (simple) action: (when (and (Mps ) (Mpi ) pe) q).
effect machinery ensure proposition pi becomes false time
start end durative action Mpi deleted, otherwise
end durative action Mps hold precisely ps held start action
Mpi hold precisely pi held entire duration durative action.
Therefore, conditional effect end action achieves intuitively correct behaviour
asserting conditional effect precisely start condition held start
durative action, end condition holds end durative action
condition held throughout duration action.
addition new memory-checking actions means longer true
claim added actions cannot change state. However, memory propositions
unique task communication single action instance, effects
memory-checking actions might implications invariants.
100

fipddl2.1: Expressing Temporal Planning Domains

9. Semantics Continuous Durative Actions
introduction continuous durative actions complicates semantics. longer
possible handle invariants insertion simple actions happenings
plan test continued satisfaction. fact, continuous effects can, principle, cause
invariant satisfied parts interval others. Ignoring
invariants moment, updates numeric values caused continuous effects
applied discrete updates time points within interval apply.
updates behave slightly differently discrete updates seen durative actions
discrete effects, since possible continuous update affect variable
concurrently affected discrete update, examined precondition, without creating
inconsistency. example, water heating action Figure 14 applied
concurrent addition egg pan precondition temperature
water 90 95 degrees value temperature examined
moment application action adding egg. temperature
change actually happening interval start heating
point egg added, rather discrete update point egg
added. temperature actually changed instant addition egg.
section summarise semantics continuous actions. semantics
discrete durative actions defined terms familiar state-transition semantics,
continuous semantics introduces different formulation.
Definition 21 Continuous Durative Action continuous effect effect expression includes symbol #t. continuous durative action durative action
least one continuous effect.
Definition 22 Continuous Update Function Let C set ground continuous effects
planning instance, I, St = (t, S, X) state. continuous update function
defined C state St function fC : R Rn , n dimI , that:
dfC
=g
dt

fC (0) = X
g update function generated action with:
N Pa = { (<op> P Q) | (<op> P (* #t Q)) C}
Definition 22 shows continuous effects several continuous durative actions
combined create single system simultaneous differential equations whose solution,
given appropriate starting point, defines evolution continuously varying values.
Definition 23 Induced Continuous Plan Let planning instance includes
continuous durative actions P plan I. induced continuous plan P
triple, (S, Invs, Cts), simplif y(P ), Invs set invariant constraints:
Invs = {(Q, t, + d) | (t, a[d]) P (over Q) invariant A}
101

fiFox & Long

Let ti ti+1 two consecutive times happening sequence simplif y(P ).
set active continuous effects (ti , ti+1 ) is:
{Q | (t, a[d]) P, (ti , ti+1 ) [t, + d] Q continuous effect a}
Cts set systems continuous effects:
Cts = {(C, ti , ti+1 ) | C set active continuous effects (ti , ti+1 )}
components continuous plan separate invariant conditions continuous effects rest simple plan order allow correct application
continuous updates allow confirmation invariants hold face
continuous effects.
Definition 24 Trace Let planning instance includes continuous durative actions, P plan I, (SP, Inv, Cts) induced continuous plan P , {ti }i=0...k
happening sequence S0 initial state I. trace P
sequence states {Si }i=0...k+1 defined follows:
element (C, ti , ti+1 ) Cts Si+1 state resulting applying
happening ti simple plan SP state Si .
(C, ti , ti+1 ) Cts let Ti state formed substituting f (ti+1 ti )
numeric part state Si , f continuous update function defined C
state Si . Si+1 state resulting applying happening ti
simple plan SP state Ti . f undefined element Cts
trace.
Definition 24 defines trace similar fashion traces simple plans plans
durative actions. key difference need apply continuous updates.
handled solving systems simultaneous differential equations across interval
active applying result update numeric values across
interval. course, easier describe do, since solving arbitrary
simultaneous differential equations algorithmically generally possible. certain
constraints semantics implemented order confirm validity plan
automatically.
Definition 25 Invariant Safe Let planning instance includes continuous durative actions, P plan I, (S, Inv, Cts) induced continuous plan P
{Si }i=0...k+1 trace P . (C, ti , ti+1 ) Cts let continuous update
function defined C Si . P invariant safe if, defined
(Q, t, u) Inv [(ti , ti+1 )] = (t, u), x I, Num(s, Q)(fi (x))
logical state Si .
definition, symbols [(..)] used mean interval closed
open either end.
102

fipddl2.1: Expressing Temporal Planning Domains

semantic point view, invariants must checked every point interval apply. interval contains finitely many discrete changes
obligation met considering finite number points
change occurs (a fact exploited discrete durative action plan semantics Definition 18). continuous change obligation much harder meet.
practice, invariants checked examining possible roots function describing continuous change, finding roots difficult general. Again,
suitable constraints forms differential equations expressed domain make
validation problem tractable.
last two definitions simply assemble components arrive analogous definitions executability validity simple plans plans durative actions.
Definition 26 Executability Plan plan P containing continuous durative actions,
planning instance I, induced continuous plan (S, Invs, Cts). P executable
trace P defined, {Si }i=0...k+1 , invariant safe.
Definition 27 Plan Validity plan P containing durative actions, planning instance
valid executable, trace {Si }i=0...k+1 Sk+1 satisfies goal I.

10. Plan Validation
Plan validation important part use pddl, particularly role
competition. approximately 5000 plans consider competition 2002,
seen automation essential. validation problem tractable propositional
versions pddl plans finite validated simply simulation
execution. issue complicated pddl2.1 potential concurrent
activity, possibly face numeric change, makes necessary ensure invariant
properties protected concurrent activity non-interfering.
durative actions used question whether plan
considered valid contain end points actions initiated
plan. action exploited plan effect end duration
clear end point present plan, action selected
start effect less clear. match-striking action performed start effect,
order burned match end brief interval. could argued
that, obtained desired start effect end action irrelevant
plan terminate (as soon goals achieved) without ensuring initiated
actions end safely. Indeed, plan search process Sapa (Do & Kambhampati, 2001)
terminate whilst still queued events awaiting advancement time. However,
possible conceive situations end point action, incorporated
start effect, introduces inconsistencies plan inclusion would
make plan invalid. cases seems plan validity could compromised
ignoring end effects.
order avoid resolve complexities, taken view
pddl2.1 plan valid action start end points explicit within plan.
identified case proceed confirm happenings within
plan mutex-free.
103

fiFox & Long

Plan validation decidable domains including discretized and, certain constraints, continuous durative actions activity encapsulated durative
actions explicitly identified plan. makes trace induced plan finite
hence checkable. therefore observe validation problem pddl2.1 decidable
even actions contain duration inequalities. work determining
duration inequalities solved already completed finished
plan validation plan proceed simulation execution, case
pddl plans. problem tractable domains without continuous effects,
introduction continuous effects can, principle, allow expression domains
complex functions describing numeric change (Howey & Long, 2002). assumption
continuous effects restricted description terms simple linear quadratic
functions, without interactions concurrent continuous effects, plan validity
tractable. cost practice increased however, since may necessary solve
polynomials order check invariants. Validation plans containing complex
expressions change explored.
Although plan validity checking tractable, subtlety arises
need represent plans syntactically difficulties involved expressing numbers arbitrary precision. principle, values required describe
valid plans algebraic (assuming constrain continuous effects indicated above),
therefore finitely representable. practice, expecting planners handle numbers
algebraic expressions seems unnecessarily complicated far reasonable assume numbers represented finite precision floating point values. Indeed,
syntax adopted expression plans restricts planners expressing times
finite precision floating point values. constraint, limitations
precision floating point computations implementations plan validation systems,
necessary take pragmatic view validation process accept
numeric conditions evaluated certain tolerance. Otherwise, occur
way report plan necessary degree accuracy
valid interpretation semantics defined Section 8. cases, plan
specifies time points to, example, four significant digits, reasonable abstraction
execution time activity needed control flow system. plan specify
time points absolutely precisely, abstraction forced upon planner fact
working models world physical world itself. problem, then,
one relationship theoretical semantics pragmatic concerns
automated validation.
Figure 18 relationship depicted terms kinds plans automatically validated. left side picture describes theoretical semantics,
arrow indicating link plans interpretation theoretical
semantics. example, possible construct
domain problem plan

requires action happen time 2 meaningful semantic object,
plan specifies theaction happen time 1.41 meaningful semantic object
1.41 equal 2. two plans distinct, one correct (under
assumed constraints). right side picture depicts pragmatic validation
syntactic plan objects. two control plans, though distinct semantics, map
syntactic object assume validation subject tolerance 0.01.
104

fipddl2.1: Expressing Temporal Planning Domains

Semantic interpretation plans

Validation plans

mapping semantics pragmatic
realisation automated validation process

Semantic plan objects




fifffi


















mapping semantic plans syntactic
counterparts.



Syntactic plan objects

specific pair mappings

Figure 18: pragmatic mapping semantics plans validation
automated computational processes. shaded area contains plans cannot
interpreted within theoretical semantics. seen plan
collection indistinguishable meaningful plan mapped
syntactic side picture.

plans map syntactic object 1.41 approximates value 2.
syntactic plan validated using pragmatic validation processes necessary
automatic validation describable syntactic plans, check validity subject
tolerance 0.01. pragmatic constraints representations plans,
expectations representations numeric values planners validators
consequences reasonable assumptions given models check
validity are, case, abstractions, non-zero tolerance, world. practice,
problem accept plans specified tolerance levels pathological cases,
arithmetic precision computer representations floats immediate negative
impact one tries take stronger line plans accepted
strictly valid according formally precise evaluation expressions.
Finally, interesting philosophical issue arises discussed Henzinger co-authors (1997, 2000). is, fact, possible achieve exact precision
measurement time continuous numeric quantities. Henzinger et al.
considered problem development robust automata. Robust automata
accept trace exists tube traces within distance > 0 original
trace, acceptable original acceptance criteria. called fuzzy
tubes indicating time fuzzily, rather precisely, detectable. idea offers path
formal semantics closer defining plans robust imprecision
executives ability measure time. Unfortunately, checking fuzzy tubes intractable.
currently compromise adopting value, used tolerance checking
numeric values fulfil numeric constraints plan execution, represent minimum separation conflicting end points within plans. consistent idea
planner assumes executive willing abstract indicated tolerance
level checking preconditions actions unreasonable suppose
plan make use finer grained measurements determining actions
105

fiFox & Long

applied. moment value set validation process, communicated informally planner-engineers, might better allow domain designer
define appropriate use particular domain. remain several issues
concerning correct management buffers validation (particularly usual
problem concerning transitivity fuzzy closeness) important issues
temporal reasoning whole restricted planning context.
yet solutions problems.

11. Related Work: Representing Reasoning Time
Representation of, reasoning with, statements time temporal extent
propositions long subject research AI including planning research (Allen,
1984; McDermott, 1982; Sandewall, 1994; Kowalski & Sergot, 1986; Laborie & Ghallab,
1995; Muscettola, 1994; Bacchus & Kabanza, 2000). Important issues raised
extension pddl handle temporal features have, course, already examined
researchers, example Shanahans work (1990) continuous change within
event calculus, Shohams work (1985) Reichgelts work (1989) temporal reasoning work non-reified temporal systems (Bacchus, Tenenberg, & Koomen, 1991).
Vila (1994) provides excellent survey work temporal reasoning AI. section
briefly review central issues addressed, treatment
literature, set pddl2.1 context research temporal logics.
Several researchers temporal logics considered problems reasoning
concurrency, continuous change temporal extent. works focussed
problem reasoning change world described using arbitrary logical
formulae, concerned making meta-level statements (such
effect cannot precede cause). need handle complex logical formulae makes
frame problem difficult resolve, approach based circumscription (McCarthy,
1980) default reasoning (Reiter, 1980) typical. strips assumption provides
simple solution frame problem states described using atomic formulae.
classical planning assumption states described atomically
general view modelling change. Although simplifying, assumption
surprisingly expressive. bench mark domains introduced third International
Planning Competition suggest atomic modelling powerful enough capture
complex domains closely approximate real problems. temporal reasoning issues
confront simplified consequence made simplifying assumption
states updated. remain concerned major issues temporal
reasoning: concurrency, continuous change temporal extent.
development pddl2.1 made basic decision consider end points
durative actions instantaneous state transitions. allows us concentrate
truth propositions points instead intervals. decision consider actions
way similar made many temporal reasoning researchers (Shanahan, 1990;
McCarthy & Hayes, 1969; McDermott, 1982). context pddl2.1 approach
advantage smoothly integrating classical planning view actions state
transitions. Nevertheless, Allen shown temporal ontology based intervals
basis planning (Allen, 1984, 1991) several planning systems
106

fipddl2.1: Expressing Temporal Planning Domains

strongly influenced intervals approach (Muscettola, 1994; Rabideau, Knight, Chien,
Fukunaga, & Govindjee, 1999). Allen later moved away initial position instants
required, introducing notion moments (Hayes & Allen, 1987),
concept attempts reconcile stance nothing instantaneous (so
intervals) observation changes values discrete-valued variables,
propositional variables, apparently cannot avoid changing instants. view
consistent approach take modelling continuous durative actions,
view change consisting discrete continuous aspects (Henzinger,
1996).
remainder section compare pddl extensions propose
previous work temporal reasoning considering three central issues identified above.
objective claim extensions improve previous work, instead
demonstrate implementation solutions three problems within pddl
framework makes exploitation directly accessible planning way
embedded within logic accompanying proof theory.
11.1 Continuous change
Several temporal reasoning frameworks began consideration discrete change and,
later, extended handle continuous change. example, Shanahan (1990) extended
event calculus Kowalski Sergot (1986) enable modelling continuous
change. process extension mirrors situation faced extending pddl,
system modelling discrete change already existed. is, therefore, interesting compare
use pddl2.1 use systems extended event calculus.
sink-filling example Shanahan (1990) discusses issues termination events
(self-termination termination events), identification level water
sink filling process effect rate change level water
sink filled two sources simultaneously. behaviour filling
process effects state sink time modelled axioms would
allow inference engine predict state sink points execution
process.
pddl2.1 allows representation complex interactions arise sink
filled multiple independently controlled water sources means concurrent durative
actions continuous effects encapsulate initiation filling process,
single water source, change level water sink termination
process water source turned off. model robust, since easily
accommodates multiple water sources, simply modifying rate flow appropriately
commutative updates. Since actions additive effects model provides
rate water enters tank source, possible compute level
water sink point filling interval concurrent action might
consult level. contrast Shanahans extension event calculus, approach
require filling process (at least point view logical
axiomatisation) terminated restarted new rate water source opened
closed, since process simply remains active throughout. change rate filling
107

fiFox & Long

reflected piecewise-linear profile depth water sink,
Shanahans model.
possible model multiple water sources situation filling process
completely encapsulated within discretized durative action. discretized action
true level water accessible filling process end start.
Step-function behaviour coarsely approximates true behaviour, consequence
complex interactions cannot properly modelled.
One important consequences continuous behaviour triggering events.
Shanahans extensions achieved axiomatisation causal relationships
events distinguished syntactically actions, fact
happening axiomatically consequence certain conditions. pddl2.1 events
(such flooding sink filling continues capacity reached)
modelled using combination conditional effects duration inequalities.
However, events modelled way, since always possible predict
spontaneous events occur. pddl2.1 could extended allow expression
causal axioms, alternative approach modify language enable
representation events within action-oriented tradition. achieved
breaking continuous durative actions instantaneous start end points
processes encapsulate. would enable execution process initiated
start action ended instantaneous state transition either action
control planner event. simple extension language needed
distinguish actions events prevent planner deliberately selecting
event. refer approach start-process-stop model, extended
pddl2.1 support (Fox & Long, 2002). resulting language, pddl+, difficult
plan pddl2.1, still open questions, concerning complexity
plan validation problem language, remain topics future work.
11.2 Concurrency
opportunity concurrent activities complicates several aspects temporal reasoning.
Firstly, necessary account actions concurrent secondly
necessary describe concurrent activities interact effects world.
formalisms first points achieved relying underlying logic
deliver inconsistency attempt made apply two incompatible actions simultaneously. example, axioms event calculus yield simultaneous
truth falsity fluent incompatible actions applied simultaneously consequently yield inconsistency. Unfortunately, recognising inconsistency is, general,
undecidable, sufficiently expressive language. pddl2.1 adopt solution
exploits restricted form action-centred formalism, defining circumstances
two actions could lead inconsistency rejecting simultaneous application
actions. favour conservative restriction compatibility actions (the
moving targets rule), order support efficient determination incompatibility, rather
permissive elusive ruling. alternative approach, adopted Bacchus
TLplan (2001), example, allow multiple actions occur instant,
nevertheless executed sequence. find solution counter-intuitive and,
108

fipddl2.1: Expressing Temporal Planning Domains

importantly, consider would impossible use plan sort instruction
executive executive could equipped execute actions simultaneously yet
specified order. view order execution matters executive
must ensure actions sequenced within limitations
capability measure time react passing.
Shanahan (1999) discusses Gelfonds (1991) example soup bowl
problem concerns raising soup bowl without spilling soup. Two actions, lift left
lift right, applied bowl. either applied soup spill, but,
argued, applied simultaneously bowl raised table
soup spills. Shanahan considers example within event calculus, uses
explicit assertion interaction lift left lift right actions ensure
spillage effect cancelled pair executed together. assumption
two actions executed precisely moment reasoner
rely successful simultaneity order exploit effect.
pddl2.1 take view precise simultaneity outside control
physical executive. plan interpreted instruction executive system
hold executive system capable measuring time controlling activity
arbitrarily fine degrees accuracy. particular, possible executive
ensure two actions must independently initiated executed simultaneously.
plan rely precision measurement then, claim, could
executed reliable expectation success not, therefore, considered
valid plan.
pddl2.1 supports modelling soup bowl situation following way. Two
durative actions, lift left lift right, independently initiate tilting intervals which,
complete, result spillage soup effects counteracted.
Provided two lift actions start within appropriate tolerance one another
tilting corrected spillage avoided without need model cancellation
effects. argue executive execute two actions within fine
non-zero tolerance one another, therefore successfully lift bowl. event
calculus model presented Shanahan insists precise synchronization two actions,
incorrectly allowing inferred soup spilled even time
elapses two lifts actually small enough allow correction tilting
bowl. Worse, Shanahans axioms would allow lack precise synchronization
exploited achieve spillage, using amount time smaller correctly describing
physical situation modelled.
one considers unnecessary model precise interaction two lifts,
one alternative pddl2.1 abstract interaction see soup-bowl
lifting action single discretized action achieves successful raising bowl.
11.3 Temporal extent
common concern temporal reasoning frameworks, discussed detail Vila
others (Vila, 1994; van Bentham, 1983), divided instant problem. problem
apparent considering happens moment transition from, say,
truth falsity propositional variable. question must addressed whether
109

fiFox & Long

proposition true, false, undefined inconsistently true false instant
transition. Clearly last possibilities undesirable. solution adopt
combination pragmatic philosophically principled. pragmatic element
choose model actions instantaneous transitions effects beginning
instant application. Thus, actions mark end-points intervals persistence
state closed left open right. ensures intervals nest
together without inconsistency truth values propositions always defined.
half-open-half-closed solution adopted elsewhere. example, Shanahan (1999)
observes similar approach used event calculus, although intervals
closed right. Although two choices effectively equivalent, slightly
prefer closed-on-the-left choice since allows validation plan conclude
state point execution final action, making determination
temporal span plan unambiguous.
philosophical point view truth value proposition instant
application action cannot exploited action, virtue
moving targets rule position, outlined above, valid plan cannot depend
precise synchronisation actions. forces actions require proposition
precondition sit open end half-open interval proposition holds.
11.4 Planning Time
classical planning models, time treated relative. is, temporal structuring plan, reasoning plan, ordering actions.
clearly emphasised issues dominated planning research late 1980s
early 1990s, classical planning mainly characterised exploration partial
plan spaces, planners tweak (Chapman, 1987), snlp (McAllester & Rosenblitt,
1991) ucpop (Penberthy & Weld, 1992). Partial plans include collection actions
representing activity thus far determined part possible plan set
temporal constraints actions. temporal constraints used partial plan
form < B B time points corresponding application
actions.
Classical linear planners (Fikes & Nilsson, 1971; Russell & Norvig, 1995) rely
simple fact total ordering points actions applied trivially
embedded time line. Again, duration actions considered. role
time planning becomes far significant metric time introduced. metric
time possible associate specific durations actions, set deadlines windows
opportunity. problems associated relative time still resolved
metric time framework, new problems introduced. particular, durations become
explicit, necessary decide durations attach to: actions states. Further,
explicit temporal extents make important confront issue concurrency
order best exploit measured temporal resources available planner.
contrast simple ordering constraints required relative time, metric time
requires powerful constraint management. metric time constraint handlers
built around foundations laid Dechter, Meiri Pearl (1991). example, IxTeT
uses extensions temporal constraint networks (Laborie & Ghallab, 1995). language
110

fipddl2.1: Expressing Temporal Planning Domains

IxTeT uses represent planning domains similar pddl2.1 described
paper, expressive allows access time points within interval
durative action. added expressive power obtained cost increased semantic
complexity and, consequently, increased difficulty validation plans. However,
many similarities modelling discretised durative actions pddl2.1
IxTeT, similar modelling conventions found languages Sapa (Do &
Kambhampati, 2001) Oplan (Drabble & Tate, 1994).
One earliest planners consider use metric time Deviser (Vere, 1983),
developed nonlin (Tate, 1977). Deviser, metric constraints times
actions could applied deadlines achievements goals
expressible planner could construct plans respecting metric temporal constraints
interactions actions. Cesta Oddi (1996) explored various developments temporal constraint network algorithms achieve efficient implementation
planning Galipienso Sanchis (2002) consider extensions manage disjunctive
temporal constraints efficiently, particularly valuable expressive element plan
construction observed above, since constraints preventing overlap intervals translate disjunctive constraints time points. hsts (Muscettola, 1994) relies
temporal constraint manager.
systems use continuous real-valued time possible make use linear
constraint solvers handle temporal constraints. particular, constraints dictated
relative placement actions durations timeline approached
way (Long & Fox, 2003a). alternative timeline often used discretised line
based integers. advantage approach possible advance time
next value considering activity given time point. next modality
interpreted continuous time framework taking mean state following
next logical change, regardless time occurs (Bacchus & Kabanza, 1998).
planning problems events occur actions dictated
planner continuous change modelled, plans finite structures therefore
change occur finite number time points execution. makes
possible embed execution plan integer-valued discrete time line
without loss expressiveness.
Various researchers considered problem modelling continuous change. Pednault (1986) proposes explicit description functions govern continuous change
metric parameters, attached actions effect instantaneous change initiate
processes. However, approach easy use describing interacting continuous
processes. example, water filling tank constant rate additional
water source added increase rate filling action initiating second
process must combine effects two water sources. means second
action cannot described simply terms direct effect world increase
rate flow tank reference effects actions
already affected rate change parameter. Shanahan (1990) uses
approach, consequence processes modelled stopping restarting
new trajectories interacting action applied.
Zeno (Penberthy & Weld, 1994), actions effects described terms
derivatives. approach makes easier describe interacting processes, complicates
111

fiFox & Long

management processes making necessary solve differential equations.
complication deterred authors taking approach: McDermott (2003)
takes approach process planner.
introduction continuous processes planning problem represents considerable complication, even model includes temporal features supports
concurrency. area active research community yet agreed
matters representation, let alone semantics. remain many open problems
planning community address, development languages planning algorithms development plan verification tools embody widely
accepted semantics.

12. Conclusions
Recent developments AI planning research leading community closer
application planning technology realistic problems. necessitated
development representation language capable modelling domains temporal
metric features. approach taken towards development language
extend McDermotts pddl domain representation standard support temporal
metric models.
development pddl sequence towards greater expressive power important
planning community pddl provided common foundation great
deal recent research effort. problems involved modelling behaviour domains
discrete continuous behaviours well explored temporal logic
model checking communities widely adopted models within
planning community. work pddl2.1 provides way making relevant
developments communities accessible planning. Furthermore, pddl2.1 begins
bridge gap basic research applications-oriented planning providing
expressive power necessary capture real problems.
pddl2.1 expressive power represent class deterministic mixed discretecontinuous domains planning domains. language introduces form durative action
based three connected parts: initiation interval numeric change
might occur explicit termination means action produces state
corresponding end durative interval. form action allows modelling
discrete continuous behaviours discretized change represented
means step functions, whilst continuous change modelled using #t variable.
language provides solutions critical issues concurrency, continuous change
temporal extent. semantics language derived familiar state
transition semantics strips, extended interpret invariants holding intervals
continuous functions might active. semantics allows us interpret
plans efficiently validate. describe criteria plan must satisfy
order practically verifiable.
paper focussed primarily discussion numeric discretised temporal features pddl2.1. However, modelling capability discretized durative actions
respects limited important planning community address
challenges presented continuous change. Indeed, even using continuous actions
112

fipddl2.1: Expressing Temporal Planning Domains

pddl2.1 possible model episodes change terminated spontaneous
events world rather deliberate choice planner. future goals
community include addressing domains require continuous actions
pddl2.1, confronting challenges planning within dynamic environments
intervals change terminated world well deliberate action
planner. constitute important step towards planning within dynamic
unpredictable environments.

Acknowledgements
would thank members committee third International Planning
Competition. particular, discussions Drew McDermott, Fahiem Bacchus, David
Smith Hector Geffner turns infuriated, intrigued delighted us contributed
immeasurably strengths paper. Many others offered comments
insights allowed us develop work present here. would thank
Jorg Hoffmann, Malte Helmert, Antonio Garrido, Stefan Edelkamp, Nicola Muscettola,
Mark Boddy, Keith Golden, Jeremy Frank, Ari Jonsson, Julie Porteous, Alex Coddington,
Stephen Cresswell, Luke Murray, Keith Halsey Richard Howey many helpful
discussions shared.

113

fiFox & Long

Appendix A. BNF Specification pddl2.1
appendix contains complete BNF specification pddl2.1 language.
strict superset pddl1.x. example, use local variables within action schemas
left specification. widely used part language
used competition domains. interpretation local variables
proposed McDermott subtle, since demands confirmation unique instantiation
exists variable. non-trivial confirm case plan
validation domains significant expressive power fact largely
ignored suggests poorly understood. changes discussed following
sections.
A.1 Domains
Domain structures remain essentially specified pddl1.x. main alterations
introduce slightly modified syntax numeric fluent expressions remove
syntax hierarchical expansions. latter necessarily abandoned, not,
best knowledge, used publicly available planning systems even
domains. original pddl specification, distinction drawn strict pddl
non-strict pddl, strict pddl must follow ordering fields specified below,
non-strict pddl restricted way. practice, relatively fields
intuitive accept arbitrary orders natural expect declarations
precede use symbols preconditions precede effects. However, declarations
constants, predicates function symbols naturally ordered, current
definition pddl ordering fields must follow specification below,
exception three fields legal order respect one another,
although group must follow types (if any) precede action specifications.
<domain>

::= (define (domain <name>)
[<require-def>]
[<types-def>]:typing
[<constants-def>]
[<predicates-def>]
[<functions-def>]:fluents
<structure-def> )
<require-def>
::= (:requirements <require-key>+ )
<require-key>
::= See Section A.5
<types-def>
::= (:types <typed list (name)>)
<constants-def>
::= (:constants <typed list (name)>)
<predicates-def>
::= (:predicates <atomic formula skeleton>+ )
<atomic formula skeleton>
::= (<predicate> <typed list (variable)>)
<predicate>
::= <name>
<variable>
::= ?<name>
<atomic function skeleton>
::= (<function-symbol> <typed list (variable)>)
<function-symbol>
::= <name>
<functions-def>
::=:fluents (:functions <function typed list
(atomic function skeleton)>)
<structure-def>
::= <action-def>
<structure-def>
::=:durativeactions <durative-action-def>

114

fipddl2.1: Expressing Temporal Planning Domains

slight modification made type syntax longer possible
nest either expressions (a possibility never exploited, complicates parsing).
Numbers longer considered implicit type extension numbers
handled functional expressions. ensures finitely many
ground action instances. desirable consequence action selection choice points need
never include choice arbitrary numeric ranges. use finite ranges integers
specifying actions useful (see Mystery FreeCell example) extension
standard syntax allow convenient representation cases could
useful. syntax function declarations allows functions declared types.
present syntax restricted number types, since semantics
functions, syntax offers scope possible extension. types given
function results assumed numbers.
<typed list (x)>
<typed list (x)>
<primitive-type>
<type>
<type>

::= x
::=:typing x+ - <type> <typed list(x)>
::= <name>
::= (either <primitive-type>+ )
::= <primitive-type>

<function typed list (x)> ::= x
<function typed list (x)> ::=:typing x+ - <function type>
<function typed list(x)>
<function type>
::= number

A.2 Actions
BNF action definition given below. Again, simplified removing
generally unused constructs (mainly hierarchical expansions). emphasised
removal intended permanent exclusion hierarchical expansion syntax
proved difficult element language agree exploit.
levels language stabilise hope return layer redevelop it.
<action-def>

::= (:action <action-symbol>
:parameters ( <typed list (variable)> )
<action-def body>)
<action-symbol>
::= <name>
<action-def body> ::= [:precondition <GD>]
[:effect <effect>]

Goal descriptions extended include fluent expressions.
<GD>
<GD>
<GD>
<GD>

::= ()
::= <atomic formula(term)>
::=:negativepreconditions <literal(term)>
::= (and <GD> )

115

fiFox & Long

<GD>
<GD>
<GD>
<GD>
<GD>
<GD>
<f-comp>
<literal(t)>
<literal(t)>
<atomic formula(t)>
<term>
<term>
<f-exp>
<f-exp>
<f-exp>
<f-exp>
<f-head>
<f-head>
<binary-op>
<binary-op>
<binary-op>
<binary-op>
<binary-comp>
<binary-comp>
<binary-comp>
<binary-comp>
<binary-comp>
<number>

::=:disjunctivepreconditions (or <GD> )
::=:disjunctivepreconditions (not <GD>)
::=:disjunctivepreconditions (imply <GD> <GD>)
::=:existentialpreconditions
(exists (<typed list(variable)> ) <GD> )
:universalpreconditions
::=
(forall (<typed list(variable)> ) <GD> )
:fluents
::=
<f-comp>
::= (<binary-comp> <f-exp> <f-exp>)
::= <atomic formula(t)>
::= (not <atomic formula(t)>)
::= (<predicate> )
::= <name>
::= <variable>
::= <number>
::= (<binary-op> <f-exp> <f-exp>)
::= (- <f-exp>)
::= <f-head>
::= (<function-symbol> <term> )
::= <function-symbol>
::= +
::=
::=
::= /
::= >
::= <
::= =
::= >=
::= <=
::= numeric literal
(integers floats form n.n).

Effects extended include functional expression updates. syntax proposed little different syntax proposed earlier version pddl.
syntax conditional effects proposed Fahiem Bacchus AIPS 2000 adopted,
nesting conditional effects supported. assignment operators
prefix forms. Simple assignment called assign (previously change) operators corresponding C update assignments, + =, =, = / = given names
increase, decrease, scale-up scale-down respectively. prefix form
adopted preference infix form order preserve consistency Lisp-like
syntax non-C names help C C++ programmers remember
operators used prefix form). prefer assign original change
introduction increase makes nature change ambiguous.
<effect>
<effect>
<effect>
<c-effect>
<c-effect>
<c-effect>
<p-effect>
<p-effect>
<p-effect>

::= ()
::= (and <c-effect> )
::= <c-effect>
::=:conditionaleffects (forall (<variable> ) <effect>)
::=:conditionaleffects (when <GD> <cond-effect>)
::= <p-effect>
::= (<assign-op> <f-head> <f-exp>)
::= (not <atomic formula(term)>)
::= <atomic formula(term)>

116

fipddl2.1: Expressing Temporal Planning Domains

<p-effect>
<cond-effect>
<cond-effect>
<assign-op>
<assign-op>
<assign-op>
<assign-op>
<assign-op>

::=:fluents (<assign-op> <f-head> <f-exp>)
::= (and <p-effect> )
::= <p-effect>
::= assign
::= scale-up
::= scale-down
::= increase
::= decrease

A.3 Durative Actions
Durative action syntax built relatively conservative extension existing action
syntax.
<durative-action-def> ::= (:durative-action <da-symbol>
:parameters ( <typed list (variable)> )
<da-def body>)
<da-symbol>
::= <name>
<da-def body>
::= :duration <duration-constraint>
:condition <da-GD>
:effect <da-effect>

conditions durative action executed complex
standard actions, specify conditions must hold point
execution. specify conditions must hold throughout duration
durative action termination. distinguish components introduce
simple temporal qualifier preconditions. use name precondition would
somewhat misleading given conditions described include constraints
must hold action begun. motivated adoption :condition
describe collection constraints must hold order successfully apply
durative action. logical form conditions durative actions restricted
conjunctions temporally annotated expressions, clearly scope future
extension allow complex formulae.
<da-GD>
<da-GD>
<da-GD>
<timed-GD>
<timed-GD>
<time-specifier>
<time-specifier>
<interval>

::=
::=
::=
::=
::=
::=
::=
::=

()
<timed-GD>
(and <timed-GD>+ )
(at <time-specifier> <GD>)
(over <interval> <GD>)
start
end


duration (?duration) durative action specified equal given
expression (which function numeric expressions), else constrained
inequalities. latter allows actions conclusion action
freely determined executive without necessarily side-effects.
example, walk two locations could made take long executive
117

fiFox & Long

considered convenient, provided least long time taken walk
locations fastest walking speed possible. Constraints specify
exact duration durative action might prove harder handle, introduced
label (:duration-inequalities) signal domain makes use them. duration
constraint supplied dictate limit temporal extent durative action.
duration implicit parameter durative action must supplied plan
uses durative actions. denote this, durative action denoted plan
t:(name arg1...argn)[d] (non-negative, rational valued) duration
floating point format (n.n). Duration constraints explicitly temporally annotated
indicate evaluated context start end point action,
else left unannotated, case default evaluated
context start action (as indicated Definition 16).
<duration-constraint>
<duration-constraint>
<duration-constraint>
<simple-duration-constraint>
<simple-duration-constraint>
<d-op>
<d-op>
<d-op>
<d-value>
<d-value>

::=

:durationinequalities

(and <simple-duration-constraint>+ )
()
<simple-duration-constraint>
(<d-op> ?duration <d-value>)
(at <time-specifier>
<simple-duration-constraint>)
::=:durationinequalities <=
::=:durationinequalities >=
::= =
::= <number>
::=:fluents <f-exp>
::=
::=
::=
::=

addition logical effects, occur start end durative action,
durative actions numeric effects refer literal ?duration. sophisticated durative actions make use functional expressions describing effects
occur duration action. allows functional expressions updated
continuous function time, rather step functions.
<da-effect>
<da-effect>
<da-effect>
<da-effect>
<da-effect>
<da-effect>
<timed-effect>
<timed-effect>
<timed-effect>
<f-assign-da>
<f-exp-da>
<f-exp-da>
<f-exp-da>
<f-exp-da>

::= ()
::= (and <da-effect> )
::= <timed-effect>
::=:conditionaleffects (forall (<variable> ) <da-effect>)
::=:conditionaleffects (when <da-GD> <timed-effect>)
::=:fluents (<assign-op> <f-head> <f-exp-da>)
::= (at <time-specifier> <a-effect>)
::= (at <time-specifier> <f-assign-da>)
::=:continuouseffects (<assign-op-t> <f-head> <f-exp-t>)
::= (<assign-op> <f-head> <f-exp-da>)
::= (<binary-op> <f-exp-da> <f-exp-da>)
::= (- <f-exp-da>)
::=:durationinequalities ?duration
::= <f-exp>

Note ?duration term used define functional expression updating
effects duration constraints requirement set. cases
duration value available expression, whereas duration constraints provided
duration can, sometimes, freely selected within constrained boundaries.
118

fipddl2.1: Expressing Temporal Planning Domains

<assign-op-t>
<assign-op-t>
<f-exp-t>
<f-exp-t>
<f-exp-t>

::=
::=
::=
::=
::=

increase
decrease
(* <f-exp> #t)
(* #t <f-exp>)
#t

symbol #t used represent period time given durative action
active. therefore local clock value duration, independent similar
clocks duration. discussion members committee
use expression using #t: proposed expression declaring
rate change alone could used. decided grounds
assertion rate change suggests rate change determined one process
effect alone. fact, intended multiple active processes affect fluent
effects accumulated. Using expression directly defines amount
process contributes change fluent value time appear
assert (inconsistently) fluent multiple simultaneous rates change.
A.4 Problems
Planning problems specifications modified exclude several generally unused
constructs (named initial situations expansion information). removed
length specification odds intention supply physics, advice.
Furthermore, advice field offers over-emphasises coarse plan metric. Instead,
introduced optional metric field, used supply expression
optimized construction plan. field states whether metric
minimized maximized. course, planner free ignore field make
assumption plans fewest steps considered good plans. However,
consider extension crucial one development widely applicable
planning language. provided variable total-time takes value
total execution time plan. allows us conveniently express intention
minimize total execution time.
anticipate extensions plan metric syntax prove necessary
longer term, believe version already provides significant new challenge
community. Problem specifications still somewhat impoverished terms
ability easily specify temporal constraints goals non-standard features
initial goal states. Again, anticipate need extension, chosen leave
clean sheet future developments.
<problem>

::= (define (problem <name>)
(:domain <name>)
[<require-def>]
[<object declaration> ]
<init>
<goal>
[<metric-spec>]
[<length-spec> ])
<object declaration> ::= (:objects <typed list (name)>)
<init>
::= (:init <init-el> )
<init-el>
::= <literal(name)>

119

fiFox & Long

<init-el>
<goal>
<metric-spec>
<optimization>
<optimization>
<ground-f-exp>
<ground-f-exp>
<ground-f-exp>
<ground-f-exp>
<ground-f-exp>
<ground-f-exp>
<length-spec>

::=:fluents (= <f-head> <number>)
::= (:goal <GD>)
::= (:metric <optimization> <ground-f-exp>)
::= minimize
::= maximize
::= (<binary-op> <ground-f-exp> <ground-f-exp>)
::= (- <ground-f-exp>)
::= <number>
::= (<function-symbol> <name> )
::= total-time
::= <function-symbol>
::= (:length [(:serial <integer>)]
[(:parallel <integer>)])
length-spec deprecated.

A.5 Requirements
table requirements pddl2.1. requirements imply others;
abbreviations common sets requirements. domain stipulates requirements,
assumed declare requirement :strips.
Requirement
:strips
:typing
:negative-preconditions
:disjunctive-preconditions
:equality
:existential-preconditions
:universal-preconditions
:quantified-preconditions
:conditional-effects
:fluents
:adl

:durative-actions
:duration-inequalities
:continuous-effects

Description
Basic STRIPS-style adds deletes
Allow type names declarations variables
Allow goal descriptions
Allow goal descriptions
Support = built-in predicate
Allow exists goal descriptions
Allow forall goal descriptions
= :existential-preconditions
+ :universal-preconditions
Allow action effects
Allow function definitions use effects using
assignment operators arithmetic preconditions.
= :strips + :typing
+ :negative-preconditions
+ :disjunctive-preconditions
+ :equality
+ :quantified-preconditions
+ :conditional-effects
Allows durative actions.
Note imply :fluents.
Allows duration constraints durative
actions using inequalities.
Allows durative actions affect fluents
continuously duration actions.

120

fipddl2.1: Expressing Temporal Planning Domains

References
Allen, J. (1984). Towards general theory action time. Artificial Intelligence, 23,
123154.
Allen, J. (1991). Planning temporal reasoning. Proceedings KR-91, pp. 314.
Bacchus, F., & Ady, M. (2001). Planning resources concurrency: forward chaining approach. Proceedings IJCAI01, pp. 417424.
Bacchus, F., & Kabanza, F. (1998). Planning temporally extended goals. Annals
Mathematics Artificial Intelligence, 22, 527.
Bacchus, F., & Kabanza, F. (2000). Using temporal logic express search control knowledge
planning. Artificial Intelligence, 116(1-2), 123191.
Bacchus, F., Tenenberg, J., & Koomen, J. (1991). non-reified temporal logic AI.
Artificial Intelligence, 52, 87108.
Blum, A., & Furst, M. (1995). Fast Planning Plan-graph Analysis. Proceedings
IJCAI-95.
Cesta, A., & Oddi, A. (1996). Gaining efficiency flexibility simple temporal problem. Chittaro, L., Goodwin, S., Hamilton, H., & Montanari, A. (Eds.), Proceedings
TIME96.
Chapman, D. (1987). Planning conjunctive goals. Artificial Intelligence, 29, 333377.
Dechter, R., Meiri, I., & Pearl, J. (1991). Temporal constraint networks. Artificial Intelligence, 49.
Do, M. B., & Kambhampati, S. (2001). Sapa: domain-independent heuristic metric temporal planner. Proceedings ECP-01.
Drabble, B., & Tate, A. (1994). use optimistic pessimistic resource profiles
inform search activity based planner. Proceedings AIPS-94. AAAI Press.
El-Kholy, A., & Richards, B. (1996). Temporal resource reasoning planning:
ParcPlan approach. Proceedings ECAI96.
Fikes, R., & Nilsson, N. (1971). STRIPS: new approach application theoremproving problem-solving. Artificial Intelligence, 2 (3), 189208.
Fox, M., & Long, D. (2002). PDDL+ : Planning time metric resources. Tech.
rep. Department Computer Science, 21/02, University Durham, UK. Available
at: http://www.dur.ac.uk/d.p.long/competition.html.
Galipienso, M., & Sanchis, F. (2002). Representation reasoning disjunction temporal constraints. Proceedings TIME02.
Garrido, A., Onainda, E., & Barber, F. (2001). Time-optimal planning temporal problems. Proceedings ECP01.
Gazen, B., & Knoblock, C. (1997). Combining expressivity UCPOP efficiency
Graphplan. Proceedings ECP-97, pp. 221233.
Gelfond, M., Lifschitz, V., & Rabinov, A. (1991). limitations situation
calculus?. Boyer, R. (Ed.), Essays honor Woody Bledsoe, pp. 167179. Kluwer
Academic.
121

fiFox & Long

Ghallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporal
planner. Proceedings AIPS94.
Gupta, V., Henziner, T., & Jagadeesan, R. (1997). Robust timed automata. HART-97:
Hybrid Real-time Systems, LNCS 1201, pp. 331345. Springer-Verlag.
Haslum, P., & Geffner, H. (2001). Heuristic planning time resources. Proceedings
ECP01, Toledo.
Hayes, P., & Allen, J. (1987). Short time periods. Proceedings IJCAI-87, pp. 981983.
Helmert, M. (2002). Decidability undecidability results planning numerical
state variables. Proceedings AIPS-02.
Henzinger, T. (1996). theory hybrid automata. Proceedings 11th Annual Symposium Logic Computer Science. Invited tutorial., pp. 278292. IEEE
Computer Society Press.
Henzinger, T., & Raskin, J.-F. (2000). Robust undecidability timed hybrid systems.
Proceedings 3rd International Workshop Hybrid Systems: Computation
Control. LNCS 1790., pp. 145159. Springer-Verlag.
Howey, R., & Long, D. (2002). Validating plans continuous effects. Tech. rep., Dept.
Computer Science, University Durham.
Jonsson, A., Morris, P., Muscettola, N., & Rajan, K. (2000). Planning interplanetary
space: theory practice. Proceedings AIPS-00.
Kowalski, R., & Sergot, M. (1986). logic-based calculus events. New Generation
Computing, 4, 6795.
Laborie, P., & Ghallab, M. (1995). Planning sharable resource constraints. Proceedings IJCAI-95. Morgan Kaufmann.
Lifschitz, E. (1986). semantics STRIPS. Proceedings 1986 Workshop:
Reasoning Actions Plans.
Long, D., & Fox, M. (2003a). Exploiting graphplan framework temporal planning.
Proceedings ICAPS03.
Long, D., & Fox, M. (2003b). overview analysis results 3rd International
Planning Competition. Journal Artifical Intelligence Research, issue.
McAllester, D., & Rosenblitt, D. (1991). Systematic nonlinear planning. Proceedings
AAAI91, Vol. 2, pp. 634639, Anaheim, California, USA. AAAI Press/MIT Press.
McCarthy, J. (1980). Circumscription form non-monotonic reasoning. Artificial
Intelligence, 13, 2739.
McCarthy, J., & Hayes, P. (1969). philosophical problems standpoint
artificial intelligence. Meltzer, B., & Michie, D. (Eds.), Machine Intelligence 4, pp.
463502. Edinburgh University Press.
McDermott, D. (1982). temporal logic reasoning processes plans. Cognitive
Science, 6, 101155.
McDermott, D. (2000). 1998 AI planning systems competition. AI Magazine, 21 (2).
122

fipddl2.1: Expressing Temporal Planning Domains

McDermott, D. (2003). Reasoning autonomous processes estimated-regression
planner. Proceedings ICAPS-03.
McDermott, D., & AIPS-98 Planning Competition Committee (1998).
PDDLthe planning domain definition language.
Tech. rep., Available at:
www.cs.yale.edu/homes/dvm.
Muscettola, N. (1994). HSTS: Integrating planning scheduling. Zweben, M., & Fox,
M. (Eds.), Intelligent Scheduling, pp. 169212. Morgan Kaufmann, San Mateo, CA.
Nau, D., Cao, Y., Lotem, A., & Munoz-Avila, H. (1999). SHOP: Simple hierarchical ordered
planner. Proceedings IJCAI99.
Pednault, E. (1986). Formulating multiagent, dynamic-world problems classical planning framework. Georgeff, M., & Lansky, A. (Eds.), Proceedings Timberline
Oregon Workshop Reasoning Actions Plans.
Pednault, E. (1989). ADL: Exploring middle ground STRIPS situation
calculus. Proceedings KR-89, pp. 324332.
Penberthy, J., & Weld, D. (1994). Temporal planning continuous change. Proceedings
AAAI-94. AAAI/MIT Press.
Penberthy, J., & Weld, D. (1992). UCPOP: sound, complete, partial-order planner
ADL. Proceedings KR92, pp. 103114, Los Altos, CA. Kaufmann.
Rabideau, G., Knight, R., Chien, S., Fukunaga, A., & Govindjee, A. (1999). Iterative repair
planning spacecraft operations ASPEN system. International Symposium
Artificial Intelligence Robotics Automation Space (i-SAIRAS).
Reichgelt, H. (1989). comparison first order modal theories time. Jackson,
P., Reichgelt, H., & van Harmelen, F. (Eds.), Logic-based knowledge representation,
pp. 143176. MIT Press.
Reiter, R. (1980). logic default reasoning. Artificial Intelligence, 13, 81132.
Russell, S., & Norvig, P. (1995). Artificial Intelligence: Modern Approach. Prentice Hall.
Sandewall, E. (1994). Features fluents: representation knowledge dynamical
systems, volume I. Oxford University Press.
Shanahan, M. (1990). Representing continuous change event calculus. Proceedings
ECAI90, pp. 598603.
Shanahan, M. (1999). event calculus explained. Wooldridge, M., & Veloso, M.
(Eds.), Artificial Intelligence Today, pp. 409430. Springer Lecture Notes Artificial
Intelligence no. 1600.
Shoham, Y. (1985). Ten requirements theory change. New Generation Computing,
3, 467477.
Smith, D., & Weld, D. (1999). Temporal planning mutual exclusion reasoning.
Proceedings IJCAI-99, Stockholm, pp. 326337.
Tate, A. (1977). Generating project networks. Proceedings IJCAI77.
van Bentham, J. (1983). logic time. Kluwer Academic Press, Dordrecht.
123

fiFox & Long

Vere, S. (1983). Planning time: Windows durations activities goals. IEEE
Transactions Pattern Analysis Machine Intelligence, 5.
Vila, L. (1994). survey temporal reasoning artificial intelligence. AI Communications, 7, 428.
Wilkins, D. (1988). Practical Planning: Extending Classical AI Planning Paradigm.
Morgan Kaufmann Publishers Inc., San Francisco, CA.

124


