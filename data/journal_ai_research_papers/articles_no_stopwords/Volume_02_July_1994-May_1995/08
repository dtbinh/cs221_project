journal artificial intelligence

submitted published

provably bounded optimal agents
stuart j russell

computer science division university california
berkeley ca usa

devika subramanian

computer science department cornell university
ithaca ny usa

russell cs berkeley edu
devika cs cornell edu

abstract

since inception artificial intelligence relied upon theoretical foundation centred around perfect rationality desired property intelligent systems argue
others done foundation inadequate imposes fundamentally
unsatisfiable requirements arisen wide gap theory
practice ai hindering progress field propose instead property called bounded
optimality roughly speaking agent bounded optimal program solution
constrained optimization presented architecture task environment construct agents property simple class machine
architectures broad class real time environments illustrate
simple model automated mail sorting facility define weaker property
asymptotic bounded optimality abo generalizes notion optimality classical
complexity theory construct universal abo programs e programs
abo matter real time constraints applied universal abo programs
used building blocks complex systems conclude discussion
prospects bounded optimality theoretical basis ai relate similar trends
philosophy economics game theory

introduction

since beginning artificial intelligence philosophers control theorists
economists looked satisfactory definition rational behaviour needed
underpin theories ethics inductive learning reasoning optimal control decision making
economic modelling doyle proposed ai defined computational study rational behaviour effectively equating rational behaviour intelligence role definitions ai ensure theory practice correctly
aligned define property p hope able design system
provably possesses property p theory meets practice systems exhibit p reality furthermore exhibit p reality something actually care
sense choice p study determines nature field
number possible choices p
perfect rationality classical notion rationality economics philosophy
perfectly rational agent acts every instant way maximize
expected utility given information acquired environment since
action selection requires computation computation takes time perfectly rational
agents exist non trivial environments
c ai access foundation morgan kaufmann publishers rights reserved

firussell subramanian

calculative rationality notion rationality studied ai calculatively rational

agent eventually returns would rational choice beginning
deliberation exist systems uence diagram evaluators exhibit
property decision theoretic definition rational choice systems
nonlinear planners exhibit logical definition rational choice
assumed interesting property system exhibit since constitutes
principle capacity right thing calculative rationality limited
value practice actual behaviour exhibited systems absurdly
far rational example calculatively rational chess program choose
right move may take times long ai systembuilders often ignore theoretical developments forced rely trial error
engineering achieve goals even simple domains chess little
theory designing analysing high performance programs
metalevel rationality natural response calculative rationality
metalevel rational system optimizes object level computations performed service selecting actions words decision finds
optimal combination computation sequence plus action constraint
action must selected computation full metalevel rationality
seldom useful metalevel computations take time metalevel decision often dicult object level simple
approximations metalevel rationality proved useful practice example metalevel policies limit lookahead chess programs engineering
expedients merely serve illustrate lack theoretical basis agent design
bounded optimality bounded optimal agent behaves well possible given
computational resources bounded optimality specifies optimal programs rather
optimal actions optimal computation sequences former
avoid placing constraints intelligent agents cannot met
program actions computations generated programs
programs designers control
make three claims
system exhibits bounded optimality desirable reality
possible construct provably bounded optimal programs
artificial intelligence usefully characterized study bounded optimality
particularly context complex task environments reasonably powerful
computing devices
first claim unlikely controversial supports second claim
detail third claim may may stand test time
begin section necessarily brief discussion relationship
bounded optimality earlier notions rationality note particular important distinctions missed without precise definitions terms thus section
provide formal definitions agents programs behaviour rationality


fiprovably bounded optimal agents

together formal descriptions task environments elements allow us prove
given agent exhibits bounded optimality section examines class agent architectures generating bounded optimal configurations eciently
soluble solution involves class interesting practically relevant optimization
appear addressed scheduling literature illustrate showing throughput automated mail sorting facility
might improved section initiates discussion bounded optimal configurations
might learned experience environment section define weaker property asymptotic bounded optimality abo may robust tractable
strict version bounded optimality particular construct universal abo
programs program universally abo abo regardless specific form
time dependence utility function universal abo programs therefore used
building blocks complex systems conclude assessment prospects
development artificial intelligence

historical perspective
classical idea perfect rationality developed aristotle theories ethics
work arnauld others choice uncertainty mill utilitarianism put
formal footing decision theory ramsey vonneumann morgernstern
stipulates rational agent act maximize expected utility
expectation taken according agent beliefs thus perfect rationality
require omniscience
artificial intelligence logical definition rationality known philosophy
practical syllogism put forward mccarthy reiterated strongly
newell definition agent take action believes
guaranteed achieve goals ai said theoretical foundation definition rationality provided mccarthy believed probably
correctly early stages field important concentrate epistemological adequacy heuristic adequacy capability principle rather
practice methodology resulted involves designing programs exhibit
calculative rationality speedup techniques approximations
hope getting close possible perfect rationality belief albeit unproven
simple agent designs fulfill specification calculative rationality may
provide good starting points bounded optimality moreover theoretical foundation calculative rationality cannot provide necessary guidance
search
clear ai would embarked quest calculative rationality
operating halcyon days formal intractability discovered
one response spectre complexity rule bounds levesque
brachman suggest limiting complexity environment calculative
perfect rationality coincide doyle patil argue strongly position
usage term universal derives use scheduling randomized
luby sinclair zuckerman



firussell subramanian

economists used perfect rationality abstract model economic entities
purposes economic forecasting designing market mechanisms makes
possible prove theorems properties markets equilibrium unfortunately
simon pointed real economic entities limited time limited powers
deliberation proposed study bounded rationality investigating shape
system effectiveness computation one important weapons
survival simon work focussed mainly satisficing designs deliberate
reaching solution satisfying preset aspiration level descriptive value modelling actual entities policies general prescriptive
framework bounded rationality developed although proved possible calculate
optimal aspiration levels certain structural variation allowed
agent design
theory games bounds complexity players become topic
intense interest example troubling fact defection equilibrium
strategy unbounded agents playing fixed number rounds prisoners dilemma
game neyman theorem neyman recently proved papadimitriou yannakakis shows essentially cooperative equilibrium exists agent
finite automaton number states less exponential number
rounds essentially bounded optimality bound space rather
speed computation type made possible shift
selecting actions selecting programs
j good distinguished perfect type rationality metalevel
type ii rationality defines maximization expected utility taking
account deliberation costs simon says global optimization
least cost best return decision net computational costs although type ii
rationality seems step right direction entirely clear whether
made precise way respects desirable intuition computation important
try one interpretation although may others key issue space
maximization optimization occurs good simon seem
referring space possible deliberations associated particular decision
conceptually object level machine executes sequence computations
control meta level machine outcome sequence selection
external action agent exhibits type ii rationality end deliberation
subsequent action utility maximized compared possible deliberate act pairs
could engaged example good discusses one possible application type
ii rationality chess programs case object level steps node expansions
game tree followed backing leaf node evaluations best move
simplicity assume per move time limit type ii rational agent execute
whichever sequence node expansions chooses best move finish
example conceivable good simon really intended refer finding agent design
minimizes deliberation costs general discussions however seem couched terms
finding right deliberation decision thus type ii metalevel rationality coincides
bounded optimality bounded optimal agent designed single decision single
situation



fiprovably bounded optimal agents

time limit unfortunately computations required metalevel machine
select object level deliberation may extremely expensive good actually proposes
fairly simple nearly practical metalevel decision procedure chess far
optimal hard see type ii rational agent could justify executing suboptimal
object level computation sequence limit scope optimization
single decision diculty resolved thinking design
agent program generates unbounded set possible deliberations response
unbounded set circumstances may arise life agent
philosophy seen gradual evolution definition rationality
shift consideration act utilitarianism rationality individual acts
rule utilitarianism rationality general policies acting shift caused
diculties individual versus societal rationality rather consideration
diculty computing rational acts consideration given recently
tractability general moral policies view making understandable
usable persons average intelligence brandt cherniak suggested
definition minimal rationality specifying lower bounds reasoning powers
rational agent instead upper bounds philosophical proposal generally consistent
notion bounded optimality found dennett moral first aid manual
dennett explicitly discusses idea reaching equilibrium within space
decision procedures uses example phd admissions procedure philosophy
department concludes best procedure may neither elegant
illuminating existence procedure process reaching
main points interest
many researchers ai whose work discussed worked
designing agents limited computational resources aaai symposium ai limited rationality fehling russell contains interesting
variety work topic much work concerned metalevel rationality
metareasoning reasoning reasoning important technique area
since enables agent control deliberations according costs benefits
combined idea anytime dean boddy exible horvitz
return better time goes simple form metareasoning allows
agent behave well real time environment simple example provided
iterative deepening used game playing breese fehling apply similar ideas controlling multiple decision procedures russell wefald give
general method precompiling certain aspects metareasoning system eciently estimate effects individual computations intentions giving fine grained
control reasoning techniques seen approximating metalevel rationality provide useful insights general control reasoning
reason suppose approximations used optimal sense
intuitive notion bounded optimality seems become current ai
community mid horvitz uses term bounded optimality refer
optimization computational utility given set assumptions expected
one would imagine cases move selected move selected type
agent sense accidental deliberation might cause program
abandon



firussell subramanian

constraints reasoning resources russell wefald say
agent exhibits bounded optimality given task environment program solution
constrained optimization presented architecture recent work
etzioni russell zilberstein seen optimizing welldefined set agent designs thereby making notion bounded optimality precise
next section build suitable set general definitions ground
begin demonstrate examples provably bounded optimal agents

agents architectures programs
intuitively agent physical entity wish view terms perceptions
actions counts first instance necessarily thinks
even whether thinks initial refusal consider constraints
internal workings agent reason logically example helps
three ways first allows us view cognitive faculties reasoning
occurring service finding right thing second makes room
among us agre chapman brooks take position systems
right thing without cognitive faculties third allows freedom consider
specifications boundaries interconnections subsystems
begin defining agents environments terms actions percepts
exchange sequence states go agent described
agent function percept sequences actions treatment fairly standard
see e g genesereth nilsson go inside agent look agent
program generates actions define implementation relationship
program corresponding agent function consider performance measures
agents designing agents optimize performance measure

specifying agents environments

agent described abstractly mapping agent function percept
sequences actions let set percepts agent receive instant
set possible actions agent carry external world since
interested behaviour agent time introduce set time points
instants set totally ordered relation unique least element
without loss generality let set non negative integers
percept history agent sequence percepts indexed time define
set percept histories ot fot og prefix history ot ot
till time denoted ot projection ot define set
percept history prefixes ot fot j ot otg similarly define set
action histories fat ag set action history prefixes defined
set projections histories

definition agent function mapping
f ot


fiprovably bounded optimal agents



f ot
note agent function entirely abstract entity unlike agent program
implements note output agent function given percept sequence
may null action example agent still thinking agent
function specifies agent time step crucial distinction
perfect rationality calculative rationality
agents live environments states environment e drawn set x
set possible state trajectories defined xt fx xg agent
necessarily full access current state x percept received agent
depend current state perceptual filtering function fp effects
agent actions represented environment transition function fe
specifies next state given current state agent action environment
therefore defined follows

definition environment e set states x distinguished initial state x
transition function fe perceptual filter function fp

x x
x fe x
ot fp x
state history x thus determined environment agent function
use notation effects f e denote state history generated agent function
f operating environment e use notation e denote
state history generated applying action sequence starting initial state
environment e
notice environment discrete deterministic formulation
extend definitions cover non deterministic continuous environments
cost additional complexity exposition none depend significant
way discreteness determinism

specifying agent implementations

consider physical agent consisting architecture program
architecture responsible interfacing program environment
running program architecture associate finite programming
language lm set programs runnable architecture agent
program program l lm takes percept input internal state drawn
set initial state initial internal state depends program l
usually suppress argument set possible internal state histories
ig prefix internal state history till time denoted
projection


firussell subramanian

definition architecture fixed interpreter agent program runs

program single time step updating internal state generating action
lm

hi l ot
thus architecture generates stream actions according dictates program
physical properties architecture running program single
time step execution finite number instructions program may
often fail reach decision time step action produced
architecture may null previous action depending program
design

relating agent specifications implementations

relate agent programs corresponding agent functions say
agent program l running machine implements agent function agent l
agent function constructed following definition specifying action sequences
produced l running possible percept sequences note importance
markovian construction internal state agent ensure actions
past future

definition program l running implements agent function f agent l
defined follows environment e x fe fp f ot
hi l ot
ot
x
x







fp x
fe x
x


although every program l induces corresponding agent function agent l
action follows given percept necessarily agent response percept
delay incurred deliberation may ect percepts occurring much
earlier sequence furthermore possible map every agent function
implementation l lm define subset set agent functions f
implementable given architecture language lm
feasible j l lm f agent l g
feasibility related clearly distinct notion computability computability refers existence program eventually returns output specified
function whereas feasibility refers production output appropriate
point time set feasible agent functions therefore much smaller set
computable agent functions


fiprovably bounded optimal agents

performance measures agents

evaluate agent performance world define real valued utility function u
state histories
u xt
utility function seen external agent environment defines
solved designer agent agent designs may incorporate
explicit representation utility function means required
use term task environment denote combination environment utility
function
recall agent actions drive environment e particular sequence
states accordance function effects f e define value agent
function f environment e utility state history generates
v f e u effects f e
designer set e environments probability distribution p
instead single environment e value agent e defined
expected value elements e slight abuse notation

v f e

x

e e

p e v f e

assign value v l e program l executed architecture
environment e simply looking effect agent function implemented
program
v l e v agent l e u effects agent l e
extend set possible environments follows

v l e

x

e e

p e v l e

perfect rationality bounded optimality

discussed section perfectly rational agent selects action maximizes
expected utility given percepts far framework amounts agent
function maximizes v f e possible agent functions
definition perfectly rational agent set e environments agent function
fopt
fopt argmaxf v f e
definition persuasive specification optimal agent function given
set environments underlies several recent projects intelligent agent design dean
wellman doyle hansson mayer direct implementation
specification ignores delay incurred deliberation yield reasonable


firussell subramanian

solution calculation expected utilities takes time real agent
terms simple formal description agents introduced easy see
diculty arisen designing agent program logicists decision theorists
concentrated specifying optimal agent function fopt order guarantee
selection best action history function fopt independent architecture
unfortunately real program lm implements function non trivial environment
optimal actions cannot usually computed next percept arrives
quite frequently fopt feasible
suppose environment consists games chess tournament rules
population human grandmasters suppose standard personal computer
fopt describes agent plays way maximize total
expected points opposition maximization moves makes
claim possible program play way quite possible depth first
alpha beta search termination execute program chooses say optimal
minimax move situation agent function induced program
fopt particular ignores percepts dropping ag indicating
loss time
trouble perfect rationality definition arose unconstrained optimization space f determination fopt without regard feasibility
similarly metalevel rationality assumes unconstrained optimization space deliberations escape quandary propose machine dependent standard rationality maximize v implementable set agent functions feasible
impose optimality constraints programs rather agent functions
deliberations

definition bounded optimal agent architecture set e environments
agent program lopt
lopt argmaxl lm v l e

see immediately specification avoids obvious
type type ii rationality consider chess example
suppose computer


total program memory megabytes possible programs
represented machine much smaller number play legal chess
tournament conditions one programs best expected performance suitable candidate lopt thus bounded optimality definition
feasible specification moreover program achieves highly desirable
yet ready announce identity lopt chess eight megabyte pc
begin restricted

provably bounded optimal agents

order construct provably bounded optimal agent must carry following
steps
specify properties environment actions taken
utility function behaviours


fiprovably bounded optimal agents

specify class machines programs run
propose construction method
prove construction method succeeds building bounded optimal agents
methodology similar formal analysis used field optimal control
studies design controllers agents plants environments optimal control
theory controller viewed essentially instantaneous implementation optimal
agent function contrast focus computation time required agent
relation computation time dynamics environment

episodic real time task environments

section consider restricted class task environments call episodic
environments episodic task environment state history generated actions
agent considered divided series episodes terminated
action let distinguished set actions terminate episode
utility complete history given sum utilities episode
determined turn state sequence environment
resets state chosen random stationary probability distribution pinit
order include effects choice utility episode notionally
divide environment state configuration part value part
configuration part determines state transitions value part determines
utility state sequence actions reset configuration part value
recorded value part restrictions mean episode treated
separate decision translate following property agent program l
higher expected utility individual episodes agent l higher expected
utility corresponding episodic task environment
real time task environment one utility action depends
time executed usually dependence suciently strong make
calculative rationality unacceptably bad approximation perfect rationality
automated mail sorter provides illustrative example episodic task environment see figure machine scans handwritten printed addresses zipcodes
mail pieces dispatches appropriate bins episode starts arrival
mail piece terminates execution physical action recommended
sorter routing piece specific bin configuration part environment corresponds letter feeder side provides randomly selected letter
previous letter sorted value part state corresponds state
receiving bins determines utility process aim maximize
accuracy sorting minimizing reject percentage avoiding jams jam occurs
current piece routed appropriate bin rejected arrival
next piece
provide formal definitions three varieties real time task environments
fixed deadlines fixed time cost stochastic deadlines
see sackinger et al boser et al details actual system application
suggested us bernhard boser early presentation work nec symposium



firussell subramanian

camera
sacks mail

zipcode
buckets

reject

figure automated mail sorting facility provides simple example episodic
real time task environment
fixed deadlines

simplest commonly studied kind real time task environment contains
deadline known time work real time systems deadlines described
informally systems built meet deadline need formal specification
order connect description deadline properties agents running
deadline task environments one might think deadlines part environment
description fact mainly realized constraints utility function one
see considering opposite deadline starter pistol two
distinguished differing constraints utilities acting specific
time
definition fixed deadline task environment u fixed deadline time td
following conditions hold
taking action time deadline utility

u e u e td
denotes sequence concatenation td td
contain action
actions taken td effect utility

u e u e u e u e td
fixed time cost

task environments approximately fixed time cost common examples
include consultations lawyers keeping taxi waiting dithering invest
one money define task environment fixed time cost c comparing
utilities actions taken different times


fiprovably bounded optimal agents

definition fixed time cost
task environment u fixed time cost


action history prefixes satisfying

contain action
utilities differ difference time cost
u e u e c

strictly speaking task environments fixed time cost utility values
finite range one cannot continue incurring time costs indefinitely reasonably short
times reasonably small costs linear utility penalty useful approximation
stochastic deadlines

fixed deadline fixed cost task environments occur frequently design
real time systems uncertainty time dependence utility function
common turns interesting see
stochastic deadline represented uncertainty concerning time occurrence
fixed deadline words agent probability distributionppd deadline
time td assume deadline must come eventually pd
define cumulative deadline distribution pd
deadline occur known time need distinguish
two cases
agent receives percept called herald dean boddy announces
impending deadline model distinguished percept od

ot td od
agent responds immediately meets deadline
percept available case agent walking blindfolded towards
utility cliff deliberating agent risks missing deadline may
improve decision quality example familiar readers deciding
whether current form embellish risk
scooped treat case current
formally stochastic deadline case similar fixed deadline case except td
drawn distribution pd utility executing action history prefix e
expectation utilities state history prefix possible deadline times
definition stochastic deadline task environment class u fixed deadline task
environments stochastic deadline distributed according pd action history
prefix
x
u e pd u et






het u task environment u fixed deadline




firussell subramanian

mail sorter example well described stochastic deadline time
arrival mail pieces image processing station distributed according density
function pd usually poisson

agent programs agent architecture

consider simple agent programs episodic task environments constructed elements set r fr rn g decision procedures rules decision procedure
recommends execute action ai agent program fixed
sequence decision procedures purposes decision procedure black box
two parameters

run time ti integer represents time taken procedure
compute action

quality qi real number gives expected reward resulting
executing action ai start episode

qi u e ai



let mj denote agent architecture executes decision procedures language j
let tm denote maximum runtime decision procedures accommodated
example runtime feedforward neural network proportional
size tm runtime largest neural network fits
architecture executes agent program sm running decision
procedure turn providing input obtained initial percept
deadline arrives fixed time td heralded percept od
entire sequence completed agent selects action recommended
highest quality procedure executed

td ot td hi action td
ts ot ts hi action ts ts psi ti
od hi action



updates agent internal state history action
action recommended completed decision procedure highest quality
action executed internal state agent initialized agent
design works three task environment categories described
next derive value v e agent program environment e running
three real time regimes construct bounded optimal agents
task environments

bounded optimality fixed deadlines

equation know agent picks action recommended
decision procedure r highest quality executed deadline td arrives


fiprovably bounded optimal agents

p

let sj longest prefix program ji ti td definition
equation follows
v e qj

qi maxfq qi g given expression value agent program
easily following
theorem let r arg maxri r titd qi singleton sequence r bounded optimal
program episodic task environment known deadline td
best program single decision procedure maximum quality whose runtime
less deadline

bounded optimality fixed time cost

equation know agent picks action recommended best
decision procedure sequence since runs entire sequence sm
deadline definition equation

v e qm c


x


ti



given expression value agent program easily following
theorem let r arg maxri r qi cti singleton sequence r bounded optimal
program episodic task environment fixed time cost c
optimal program single decision procedure whose quality net time
cost highest

bounded optimality stochastic deadlines

stochastic deadline distributed according pd value agent program
sm expectation definition calculate
p ps v
et het u task environment fixed deadline aft
ter substituting v et equation expression simplifies summation
procedures sequence probability interruption ith procedure
sequence multiplied quality best completed decision procedure

x
pi
v v e pd pij

tj pd j tj qi

rt
pd
pd dt pd pmi ti
simple example serves illustrate value function consider r fr r r g
rule r quality needs seconds run represent r
rules r r deadline distribution function pd
uniform distribution seconds value sequence r r r
v r r r
geometric intuition given notion performance profile shown figure



firussell subramanian

q





p








figure performance profile r r r pd superimposed

definition performance profile sequence performance profile qs gives
quality action returned agent interrupted

qs maxfqi


x

j

tj tg

uniform deadline density function value sequence proportional
area performance profile last possible interrupt time note
height profile interval length ti rule running quality
best previous rules
definition following obvious property
lemma performance profile sequence monotonically nondecreasing
case sequence higher quality decisions times better
sequence
lemma qs qs v v
case say qs dominates qs
use idea performance profiles establish useful properties optimal
sequences
lemma exists optimal sequence sorted increasing order q

p

without lemma ni possible sequences consider ordering constraint eliminates n sequences means proofs properties sequences need consider ordered sequences addition replace qi
equation qi
following lemma establishes sequence improved addition
better rule end
lemma every sequence sm sorted increasing order quality single
step z qz qsm v sz v


fiprovably bounded optimal agents

corollary exists optimal sequence ending highest quality rule r
following lemma ects obvious intuition one get better
less time point spending time get worse
lemma exists optimal sequence whose rules nondecreasing order ti
apply preparatory derive construct bounded
optimal programs deadline distributions
general distributions

general deadline distribution dynamic programming method used obtain
optimal sequence decision rules pseudo polynomial time construct optimal
sequence definition v e equation optimal sequences generated
methods ordered qi accordance lemma
construct table entry table highest value
sequence ends rule ri time assume rule indices arranged

p
increasing order quality ranges start time end time l ri r ti
update rule

maxk k ti qi qk pd
boundary condition
rule time
corollary read best sequence highest value row n
matrix
theorem dp computes optimal sequence time n l n
number decision procedures r

dependence l time complexity dp means polynomial input size standard rounding scaling methods
however fully polynomial approximation scheme constructed although
hardness proof john binder shown deadline
distribution used constant time oracle finding values p
require exponential number calls oracle worst case
long uniform distributions

deadline uniformly distributed time interval greater sum
running times rules call distribution long uniform distribution consider
rule sequence sm drawn rule set r long uniform distribution
probability deadline arrives rule si sequence independent
time si starts permits simpler form equation

v e pmi pd ti qi qm pmi pd ti




firussell subramanian

derive optimal sequence long uniform distribution obtain recursive
specification value sequence r sm sequence
r

v e v e qapd qmpd ta



allows us define dynamic programming scheme calculating optimal sequence
state function j denoting highest value rule sequence starts
rule ends rule j lemma equation update rule

j maxi kj k j pd tk qi pd ti qj



boundary condition

pd ti qi



corollary know optimal sequence long uniform distribution ends
rn rule highest quality r thus need examine n
n entry requires n computation n entries compute thus
optimal sequence long uniform case calculated n

theorem optimal sequence decision procedures long uniform deadline distribution determined n time n number decision procedures
r
short uniform distributions

p

ni pd ti uniform deadline distribution pd call short means
sequences longer last possible deadline time therefore rules
sequences possibility executing deadline sequences
cannot use equation calculate v however sequence truncated
removing rules would complete execution last possible deadline
value sequence unaffected truncation truncated sequences use
equation justified furthermore optimal sequence truncated
sequence
since update rule correctly computes j truncated sequences use
short uniform distributions provided add check ensure sequences
considered truncated unlike long uniform case however identity last rule
optimal sequence unknown need compute n entries j table
entry computation takes n time thus time compute optimal sequence
n

theorem optimal sequence decision procedures short uniform deadline distribution determined n time n number decision procedures
r


fiprovably bounded optimal agents

exponential distributions

exponential distribution pd e fit exponential distributions allow optimal
sequence computed polynomial time let pi stand probability rule
interrupted assuming starts pi pd ti e fiti exponential
distribution v e simplifies

v e



h
ij pj pi qi mj pj qm

mx
h


yields simple recursive specification value v e sequence
begins rule

v e pa p qa pa v e
use state function j represents highest value rule sequence
starting ending j

j maxi kj pi pk qi pi k j
boundary condition qi pi given j j calculated
n corollary know optimal sequence whose last element
highest valued rule r

theorem optimal sequence decision procedures exponentially distributed
stochastic deadline determined n time n number decision
procedures r

proof similar long uniform distribution case

simulation mail sorter

preceding provide set optimizing construction agent
program variety general task environment classes section illustrate
possible gains realized specific task environment namely
simulated mail sorter
first let us precise utility function u episodes four
possible outcomes utility outcome ui
zipcode successfully read letter sent correct bin delivery
zipcode misread letter goes wrong bin
letter sent reject bin
next letter arrives recognizer finished jam since
letter arrival heralded jams cannot occur machine architecture given
equation


firussell subramanian




mu








p

accuracy

lambda


















computation time sec











time sec





figure accuracy profile e x b poisson arrival distribution
mean sec
without loss generality set u u probability rule
recommending correct destination bin pi qi piu pi u pi assume
u u hence threshold probability letter sent
reject bin instead therefore include rule set r rule rreject
zero runtime recommends rejection sequence construction
automatically exclude rules quality lower qreject u overall utility
episode chosen linear combination quality sorting qi probability
rejection rejection rate given p runtime first non reject
rule executed speed sorting measured arrival time mean
agent program boser et al uses single neural network chip
variety conditions optimized sequence networks
significantly better single network terms throughput accuracy examine
following experimental conditions
assume network executes time recognition accuracy p
depends consider p e particular choice irrelevant
scale chosen arbitrary choose convenience figure
include rreject qreject u treject
consider arrival time distributions poisson varying means figure b shows three example distributions means seconds
create optimized sequences sets networks execution times taken
equal intervals
compare
bo sequence bounded optimal sequence
b best singleton best single rule
c rule rule whose execution time mean distribution e
complete cases


fiprovably bounded optimal agents


bo sequence
best singleton
rule
rule

average utility per second


















mean arrival time







figure graph showing achievable utility per second function average time
per letter four program types
rule rule whose execution time guarantees complete
cases
last three cases add rreject initial step bo sequence include
automatically
measure utility per second function mean arrival rate figure
shows optimal setting sorting machinery letters per
minute inter arrival time seconds bounded optimal program given
fixed
finally investigate effect variance arrival time relative
performance four program types purpose use uniform distribution
centered around seconds different widths vary variance without
affecting mean figure
notice several interesting things
policy choosing rule probability completion performs poorly
rapid arrival rates catches performance best single
rule slower arrival rates artifact exponential accuracy
profile difference quality rules run times
greater seconds quite small
policy choosing rule probability completion fares well
best single rule high arrival rates rapidly diverges
thereafter performing far worse arrival time means greater seconds


firussell subramanian


bo sequence
best singleton
rule
rule

average utility per second


















variance arrival time





figure graphs showing utility gain per second function arrival time
variance four program types uniform distribution mean
seconds

best sequence best single rule give best overall performance
arrival rate around letters per minute performance advantage
optimal sequence best single rule arrival rate
noted significant performance advantage obtainable
extra computational resources slower arrival rates difference
performance best rule best sequence arises decreased
rejection rate best sequence exponential accuracy profile
advantage running rule shorter completion time ahead longer rule
ability reduce probability rejecting letter high arrival rates
inter arrival times seconds useful short rules instead
longer single rule

figure shows best sequence performs better best single rule

variance arrival time increases performance optimal sequence
appears largely unaffected variance exactly behaviour expect
observe ability run sequence rules instead committing single
one gives robustness face increasing variance since realistic environments
involve unexpected demands many kinds possession variety default
behaviours graded sophistication would seem optimal design choice
bounded agent

performance rule uniform distributions used experiment
fixed mean symmetric rule rule runs seconds
rule changes variance curve exhibits discretization effects could
eliminated finer grained set rules



fiprovably bounded optimal agents

learning approximately bounded optimal programs

derivations assume suitable rule set r available ab initio correct
qualities qi runtimes ti deadline distribution known section
study ways information learned implications
bounded optimality resulting system concentrate learning rules
qualities leaving runtimes deadline distributions future work
basic idea learning converge time set
optimal components accurate rules accurate quality estimates
happens value agent constructed rules quality
estimates converges value lopt thus two sources suboptimality
learned agent
rules r may best possible rules may recommend actions
lower utility would recommended rules
may errors estimating expected utility rule cause
given construct suboptimal sequences even best rules
available
notional method constructing bounded optimal agents learns sets individual decision procedures episodic interactions arranges sequence
one described earlier performance agent
sequence least good agent assume parameterized learning lj k used learn one rule possible runtime
k f tm g since never need include two rules runtime
r obviates need consider entire rule language j optimization
process
setting places somewhat unusual requirements learning
learning lj k works observing collection training episodes e
including utility obtained episode however make assumptions
form correct decision rule instead make assumptions
hypotheses namely come finite language jk set programs
j complexity k setting called agnostic learning setting
kearns schapire sellie assumptions made environment
shown theorems kearns schapire sellie
languages j error learned approximation bounded within
best rule jk fits examples probability sample size needed
guarantee bounds polynomial complexity parameter k well
addition constructing decision procedures lj k outputs estimates
quality qi standard chernoff hoeffding bounds used limit error quality
estimate within q probability q sample size estimation quality
polynomial q q
thus error agnostically learned rule bounded within best rule
complexity class probability error quality estimation
rules bounded q probability q bounds calculate bound
utility deficit agent program construct comparison lopt


firussell subramanian

theorem assume architecture mj executes sequences decision procedures
agnostically learnable language j whose runtimes range tm real time task

environments fixed time cost fixed deadline stochastic deadline construct
program l
v lopt e v l e q
probability greater q number decision procedures
lopt

proof prove theorem stochastic deadline regime bounded

optimal program sequence decision procedures proofs fixed cost
fixed deadline regimes bounded optimal program singleton follow
special case let best decision procedures e set r fr rn g
let lopt sm optimal sequence constructed r let r fr rng
set decision procedures returned learning probability greater
qi qi qi refers true quality ri error
estimated quality q decision procedure ri bounded probability greater
mq jq qi j q
let sm rules r come runtime classes
rules sm r equation
v lopt e v e
error v weighted average errors individual qi similarly

jv e v e j q
suppose sequence construction applied r produces sequence
l sl definition sequence appears optimal according estimated
value function v hence
v l e v e
bound error estimated value
jv l e v l e j q
combining inequalities
v lopt e v l e q






although theorem practical applications mainly intended illustration
learning procedure converge bounded optimal configuration
additional work general error bounds derived case rule
execution times ti real time utility variation time cost fixed deadline deadline
distribution estimated training episodes obtain error bounds
case rule language j divided smaller number coarser
runtime classes rather potentially huge number currently use


fiprovably bounded optimal agents

asymptotic bounded optimality

strict notion bounded optimality may useful philosophical landmark
explore artificial intelligence may strong allow many interesting general
obtained observation made ordinary complexity theory
although absolute eciency aim asymptotic eciency game sorting
n log n rather n considered significant replacing multiply
shift left bit considered real advance slack allowed
definitions complexity classes essential building earlier obtaining robust
restricted specific implementations analysing complexity
use subroutines section begin reviewing
classical complexity propose definitions asymptotic bounded optimality
advantages classical optimality special case
asymptotic bounded optimality lastly report preliminary investigations
use asymptotic bounded optimality theoretical tool constructing universal
real time systems

classical complexity

classical sense defined pair predicates output
z solution input x x x z hold instance
input satisfying class terminates output
z satisfying x z given input x satisfying x asymptotic complexity describes
growth rate worst case runtime function input size
define formally follows let ta x runtime input x
let ta n maximum runtime input size n
complexity f n
k n n n n ta n kf n
intuitively classically optimal one lowest possible complexity
purposes constructing asymptotic notion bounded optimality
useful definition classical optimality mention complexity
directly done follows
definition classically optimal classically optimal

k n n n n ta n kta n
relate classical complexity framework need define special case task
environments traditional programs appropriate task environments
input provided program initial percept utility function
environment histories obeys following constraint
definition classical task environment hep u classical task environment
p

l outputs correct solution p
v l ep u l ep ifotherwise




firussell subramanian

l ep running time l ep universal turing machine
u positive decreasing function
notion class classical complexity theory thus corresponds class
classical task environments unbounded complexity example traveling salesperson contains instances arbitrarily large numbers cities

varieties asymptotic bounded optimality

first thing need complexity measure environments let n e suitable
measure complexity environment assume existence environment
classes unbounded complexity analogy definition classical
optimality define worst case notion asymptotic bounded optimality abo
letting v l n e minimum value v l e e e complexity n

definition worst case asymptotic bounded optimality agent program l timewise
spacewise worst case asymptotically bounded optimal e iff
k n l n n n v l km n e v l n e
km denotes version machine speeded factor k k times
memory
english means program basically along right lines needs
faster larger machine worst case behaviour good program
environments
probability distribution associated environment class e use
expected value v l e define average case notion abo
definition average case asymptotic bounded optimality agent program l timewise
spacewise average case asymptotically bounded optimal e iff
k l v l km e v l e
worst case average case definitions abo would happy
program abo nontrivial environment nontrivial architecture unless
k enormous rest use worst case definition abo
almost identical obtained average case definition
first observation made abo programs classically optimal
programs special case abo programs
classical definitions allow optimality constant factor k runtime
one might wonder chose use constant factor expand machine capabilities rather
increase time available program context ordinary complexity theory
two alternatives exactly equivalent context general time dependent utilities
former appropriate would possible simply let l run k times longer programs
wish consider control execution time trading solution quality one could
imagine slowing entire environment factor k merely less realistic version
propose
connection suggested bart selman



fiprovably bounded optimal agents

theorem program classically optimal given p
timewise worst case abo corresponding classical task environment class hep u
observation follows directly definitions
summary notion abo provide degree theoretical robustness
machine independence study bounded systems asymptotic complexity
classical programs set basic framework begin exercise
definitions

universal asymptotic bounded optimality

asymptotic bounded optimality defined respect specific value function v
constructing real time systems would prefer certain degree independence
temporal variation value function achieve defining family v value
functions differing temporal variation mean value function
preserves preference ordering external actions time value functions
family preference ordering
example fixed cost regime vary time cost c generate family
value functions stochastic deadline case vary deadline distribution pd
generate another family since three regimes uses quality measure
actions union three corresponding families family
single program call universal program asymptotically
bounded optimal regardless value function chosen within particular family
definition universal asymptotic bounded optimality uabo agent program l
uabo environment class e family value functions v iff l abo e
every vi v
uabo program must compete abo programs every individual value function
family uabo program therefore universal real time solution given task
uabo programs exist construct
turns use scheduling construction russell zilberstein
design uabo programs construction designed reduce task environments unknown interrupt times case known deadlines insight
applies construction requires architecture provide program concatenation e g lisp prog construct conditional return construct null program
universal program lu form concatenation individual programs
increasing runtime appropriate termination test written
lu l l lj
lj consists program termination test program part lj
program lm abo e value function vj corresponds fixed deadline
td j time increment smaller execution time non null
program lm
value function must therefore separable russell wefald since preservation rank
order allows separate time cost defined see chapter keeney raiffa thorough
discussion time dependent utility



firussell subramanian

q

l u



l opt




p






figure performance profiles lu running lopt running
proceeding statement lu indeed uabo let us look example
consider simple sequential machine architecture described earlier suppose
select rules three rule set r r r since
shortest runtime rules seconds let look optimal
programs l l l l fixed deadline task environments td


l l r l r l r
hence sequence programs lu r r r
consider task environment class value function vi specifies stochastic
deadline uniformly distributed range class lopt r r
bounded optimal sequence turns lu higher utility lopt provided
run machine four times faster see plotting two performance
profiles qu lu qopt lopt qu dominates qopt shown figure
establish lu construction yields uabo programs general need
define notion worst case performance profile let q l n e minimum
value obtained interrupting l e e complexity n know
lj lu satisfies following

l n n nj vj lj kj n e vj l n e
constants kj nj aim prove

vi v k n l n n n vi lu km n e vi l n e
given definition worst case performance profile fairly easy following
lemma proof essentially identical proof theorem russell zilberstein

notice simple model output quality rule depends execution time
input complexity means worst case average case behaviour



fiprovably bounded optimal agents


bo sequence
abo sequence

average utility per second


















mean arrival time







function mean
figure throughput accuracy improvement lu lopt
arrival time poisson arrivals

lemma lu universal program e v li abo e vi v
q lu km n e dominates q li n e k maxj kj n maxj nj
lemma establishes small constant penalty ignore specific realtime nature task environment constructing bounded optimal programs however
still need deal issue termination possible general lu
terminate appropriate time without access information concerning timedependence utility function example fixed time cost task environment
appropriate termination time depends value time cost c
general case deterministic time dependence help lu supplying vi aspiration level qi ti li n e ti time
li acts lu terminates completed lj qj qi ti li n e
construction happen later ti lemma

theorem task environments deterministic time dependence lu suitable
aspiration level uabo e
deadline heralds termination test somewhat simpler require
additional input lu
theorem task environment stochastic deadlines lu uabo e
terminates herald arrives
returning mail sorting example fairly easy see lu consists
sequence networks optimal programs stochastic deadline case
abo fixed deadline regime obvious abo particular


firussell subramanian

stochastic deadline case recall regimes considered single family
programmed constructor function universal programs applied
mail sorter environment class varying letter arrival distribution gives us different value
functions vi v figure shows lu higher throughput accuracy
across entire range arrival distributions
lopt
given existence uabo programs possible consider behaviour compositions thereof simplest form composition functional composition
output one program used input another complex nested compositional structures entertained including loops conditionals zilberstein
main issue constructing uabo compositions allocate time among
components provided solve time allocation know
total runtime allowed use construction technique used generate composite uabo programs optimality among possible compositions
components zilberstein russell allocation
solved linear time size composite system provided composition tree
bounded degree

conclusions work
examined three possible formal bases artificial intelligence concluded
bounded optimality provides appropriate goal constructing intelligent systems
noted similar notions arisen philosophy game theory
less reason mismatch classically optimal actions
called feasible behaviours generated agent program running
computing device finite speed size
showed careful specification task environment computing
device one design provably bounded optimal agents exhibited simple
agents likely bounded optimality strict sense dicult goal
achieve larger space agent programs considered relaxed notions
asymptotic bounded optimality abo may provide theoretically robust tools
progress particular abo promises yield useful composite agent
designs allowing us separate designing complex abo agents discrete
structural continuous temporal optimization tractable
many cases hence reason optimistic artificial intelligence
usefully characterized study bounded optimality may speculate provided
computing device neither small small changes speed size cause
significant changes optimal program design powerful classically
optimal decisions computed feasibly abo designs stable reasonably
wide variations machine speed size environmental complexity details
optimal designs may rather arcane learning processes play large part
discovery expect focus type questions
convergence optimality structural classes end
perhaps important implication beyond conceptual foundations field
bounded optimality applies design practice artificial
intelligence way idealized infinite resource may given


fiprovably bounded optimal agents

way illustrating definition bounded optimal agent design simple system
consisting sequences decision procedures provably better program
class theorem exhibits bounded optimal design translates definition
agent whose actual behaviour desirable
appear plenty worthwhile directions continue exploration
bounded optimality foundational point view one interesting
questions concept applies agents incorporate learning component
note section learning external agent
case necessarily largely stable bounded optimal configuration
agent program large enough instead agent adapt shorter term
horizon rewrite becomes obsolete
preservation abo composition start examine
much interesting architectures simple production system studied
example look optimal search constrained
apply metalevel decision procedure step decide node expand
russell wefald extend work asymptotic bounded optimality
provide utility analogue big notation describing performance
agent designs including suboptimal
context computational learning theory obvious stationarity
requirement environment necessary satisfy preconditions pac
restrictive fact agent learns may effect
distribution future episodes little known learning cases aldous
vazirani could relax deterministic episodic requirement allow
non immediate rewards thereby making connections current reinforcement
learning
computation scheduling examined interesting
appear studied operations combinatorial optimization literature scheduling usually deal physical rather computational tasks
hence objective function usually involves summation outputs rather picking
best would resolve formal question tractability general case
look cases solution qualities individual processes interdependent
one use another practical extensions include computation
scheduling parallel machines multiple agents scheduling combinations computational physical e g job shop ow shop processes objective functions
combination summation maximization latter extension broadens scope
applications considerably industrial process designing manufacturing
car consists computational steps design logistics factory scheduling inspection
etc physical processes stamping assembling painting etc one easily imagine
many applications real time financial industrial military contexts
may turn bounded optimality found wanting theoretical framework
case hope refuted interesting way better framework
created process


firussell subramanian

appendix additional proofs
appendix contains formal proofs three subsidiary lemmata main body


lemma exists optimal sequence sorted increasing order q
proof suppose case optimal sequence must

two adjacent rules qi qi see figure removal rule yields
sequence qs qs lemma fact ti ti ti
lemma must optimal repeat removal process ordered
qi proving theorem reductio ad absurdum


lemma every sequence sm sorted increasing order quality single
step z qz qsm v sz v
proof calculate v sz v equation non negative
v sz v qz pd pmj tj tz qm pd pmj tj tz
p
qz qm pd mj tj tz

non negative since qz qm
q



qi
qi
qi
qi



ti



figure proof ordering qi lower dotted line indicates original profile upper dotted
line indicates profile removal rule

lemma exists optimal sequence whose rules nondecreasing order ti
proof suppose case optimal sequence must
two adjacent rules qi qi ti ti see figure removal rule
yields sequence qs qs lemma lemma must


optimal repeat removal process ordered ti proving theorem
reductio ad absurdum


fiprovably bounded optimal agents

q

qi
qi



qi





ti

figure proof ordering ti dotted line indicates profile removal rule

acknowledgements

would acknowledge stimulating discussions michael fehling michael genesereth russ greiner eric horvitz henry kautz daphne koller bart selman
subject bounded optimality dorit hochbaum nimrod megiddo kevin glazebrook subject dynamic programming scheduling nick
littlestone michael kearns subject agnostic learning would
thank reviewers many constructive suggestions many early ideas
work arose discussions late eric wefald thanks
ron parr work uniform distribution case rhonda righter extending
exponential distribution patrick zieske help implementing dynamic programming first author supported nsf grants iri
iri iri visiting fellowship serc sabbatical
uk nec institute second author supported nsf
grant iri

references

agre p chapman pengi implementation theory activity
proc th national conference artificial intelligence seattle wa morghan kaufmann
aldous vazirani u markovian extension valiant learning model
proc st annual symposium foundations computer science st louis mo
ieee comput soc press
binder j complexity deliberation scheduling stochastic deadlines
boser b e sackinger e bromley j lecun hardware requirements
neural network pattern classifiers case study implementation ieee micro

brandt r search credible form rule utilitarianism nakhnikian g
castaneda h eds morality language conduct


firussell subramanian

breese j fehling r control solving principles architecture shachter r levitt kanal l lemmer j eds uncertainty
artificial intelligence north holland amsterdam
brooks r robust layered control system mobile robot ieee journal
robotics automation
cherniak c minimal rationality mit press cambridge
dean boddy analysis time dependent proc aaai pp
dean l wellman p control morgan kaufmann san
mateo ca
dennett moral first aid manual tanner lectures human values university
michigan
doyle j rational psychology toward modern mental philosophy ai
magazine
doyle j artificial intelligence rational self government tech rep technical
report cmu cs
doyle j patil r two theses knowledge representation language restrictions taxonomic classification utility representation services artificial
intelligence
etzioni tractable decision analytic control proc st international conference knowledge representation reasoning pp
fehling russell j proceedings aaai spring symposium limited
rationality aaai
genesereth r nilsson n j logical foundations artificial intelligence
morgan kaufmann mateo ca
good j twenty seven principles rationality godambe v p sprott
eds foundations statistical inference pp holt rinehart winston toronto
hansson mayer heuristic search evidential reasoning proceedings
fifth workshop uncertainty artificial intelligence windsor ontario
horvitz e j reasoning beliefs actions computational resource
constraints levitt lemmer j kanal l eds uncertainty artificial
intelligence north holland amsterdam
kearns schapire r sellie l toward ecient agnostic learning proc th
ann workshop computational learning theory pittsburgh pa morgan kaufmann


fiprovably bounded optimal agents

keeney r raiffa h decisions multiple objectives preferences value
tradeoffs wiley york
levesque h brachman r expressiveness tractability knowledge representation reasoning computational intelligence
luby sinclair zuckerman optimal speedup las vegas
information processing letters
mccarthy j programs common sense proceedings symposium
mechanization thought processes teddington england hmso
newell knowledge level ai magazine
neyman bounded complexity justifies cooperation finitely repeated prisoners dilemma economics letters
papadimitriou c yannakakis complexity bounded rationality
proc acm symposium theory computation
ramsey f p truth probability braithwaite r ed foundations
mathematics logical essays harcourt brace jovanovich york
russell j wefald e h optimal game tree search rational metareasoning proc ijcai
russell j wefald e h b principles metareasoning proc kr
russell j wefald e h right thing studies limited rationality
mit press cambridge
russell j zilberstein composing real time systems proc ijcai
sydney
sackinger e boser b e bromley j lecun application anna
neural network chip high speed character recognition ieee transactions neural
networks
simon h decide bounded rationality

simon h bounded rationality mit press cambridge
von neumann j morgenstern theory games economic behavior
princeton university press princeton
zilberstein operational rationality compilation anytime
ph thesis computer science division university california berkeley
zilberstein russell optimal composition real time systems submitted
artificial intelligence



