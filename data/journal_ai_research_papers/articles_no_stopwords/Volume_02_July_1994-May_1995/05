journal artificial intelligence

submitted published

pac learning recursive logic programs
negative
william w cohen

bell laboratories
mountain avenue murray hill nj usa

wcohen att com

abstract

companion shown class constant depth determinate k ary
recursive clauses eciently learnable present negative showing
natural generalization class hard learn valiant model paclearnability particular following program classes cryptographically
hard learn programs unbounded number constant depth linear recursive
clauses programs one constant depth determinate clause containing unbounded
number recursive calls programs one linear recursive clause constant locality
immediately imply non learnability general class programs
learning constant depth determinate program two linear
recursive clauses one linear recursive clause one non recursive clause hard
learning boolean dnf together positive companion
negative establish boundary ecient learnability recursive function free
clauses

introduction
inductive logic programming ilp muggleton muggleton de raedt
active area machine learning hypotheses learning system
expressed logic programming language many different learning
considered ilp including great practical interest muggleton king
sternberg king muggleton lewis sternberg zelle mooney
cohen b class frequently considered reconstruct simple
list processing arithmetic functions examples prototypical sort
might learning append two lists often sort task attempted
randomly selected positive negative examples target concept
similarity studied field automatic programming
examples summers biermann informally call class
learning tasks automatic logic programming number experimental
systems built quinlan cameron jones aha lapointe ling matwin
experimental success automatic logic programming systems limited
one common property automatic logic programming presence recursion goal explore analytic methods computational limitations
learning recursive programs valiant model pac learnability brief
model requires accurate approximation target concept found polynomial time polynomial sized set labeled examples chosen stochastically
surprise nobody limitations exist far obvious previous
c ai access foundation morgan kaufmann publishers rights reserved

ficohen

limits lie provably fast methods learning recursive
logic programs even fewer meaningful negative
starting point investigation series positive learnability appearing companion cohen single constant depth
determinate clause constant number closed recursive calls pac learnable
two clause constant depth determinate program consisting one nonrecursive clause one recursive clause type described pac learnable
additional hints target concept provided
analyze number generalizations learnable languages
relaxing restrictions leads dicult learning particular learning hard learning dnf open
computational learning theory hard cracking certain presumably secure cryptographic schemes main contribution therefore delineation
boundaries learnability recursive logic programs
organized follows section define classes logic programs
learnability used section present cryptographic
hardness two classes constant depth determinate recursive programs programs
n linear recursive clauses programs one n ary recursive clause
analyze learnability clauses constant locality another class clauses paclearnable nonrecursive case even single linearly recursive local
clause cryptographically hard learn turn section analysis
even restricted classes recursive programs two different classes
constant depth determinate programs prediction equivalent boolean dnf class
programs containing single linear recursive clause single nonrecursive clause
class programs containing two linearly recursive clauses finally summarize
companion discuss related work conclude
although read independently companion suggest
readers read papers begin companion cohen

background

completeness present technical background needed state
however aside sections introduce polynomial predictability
prediction preserving reducibilities respectively background closely follows presented companion cohen readers encouraged skip section
already familiar material

logic programs

assume reader familiarity logic programming
obtained reading one standard texts lloyd treatment logic
programs differs usually consider body clause ordered
set literals consider logic programs without function symbols e
programs written datalog
semantics datalog program p defined relative database db
set ground atomic facts convenient think db


fipac learning recursive logic programs negative

conjunction ground unit clauses particular interpret p db subset
set extended instances extended instance pair f
instance fact f ground fact description set ground unit clauses
extended instance f covered p db iff
db p f
extended instances allowed function free programs encode many computations usually represented function symbols example function free
program tests see list append two lists written follows

program p

append xs ys ys
null xs
append xs ys zs
components xs x xs
components zs x zs
append xs ys zs

database db

null nil
predicate components b c means list head b tail c thus
extended instance equivalent append would instance fact
f append list list list description containing atoms
components list list components list nil
components list list components list list
components list nil
use extended instances function free programs closely related attening
rouveirol de raedt dzeroski experimental learning systems
impose similar restriction quinlan pazzani kibler another motivation
extended instances technical sometimes quite severe syntactic
restrictions considered often polynomial number possible
ground facts e herbrand base polynomial hence programs interpreted
usual model theoretic way would possible learn program equivalent
given target simply memorizing appropriate subset herbrand base however
programs interpreted sets extended instances trivial learning
become impossible even extremely restricted program classes still exponential number extended instances size n discussion found
companion cohen
define terminology logic programs used

input output variables

b br ordered definite clause input variables literal bi
variables appear clause b bi variables
appearing bi called output variables


ficohen

types recursion

literal body clause recursive literal predicate symbol
arity head clause every clause program one recursive
literal program linear recursive every clause program k recursive
literals program k ary recursive every recursive literal program contains
output variables program closed recursive
depth

depth variable appearing ordered clause b br defined follows
variables appearing head clause depth zero otherwise let bi first
literal containing variable v let maximal depth input variables
bi depth v depth clause maximal depth variable
clause
determinacy

literal bi clause b br determinate iff every possible substitution
unifies fact e
db b bi

one maximal substitution db bi clause determinate
literals determinate informally determinate clauses
evaluated without backtracking prolog interpreter
term ij determinate muggleton feng sometimes used programs
depth determinate contain literals arity j less number experimental systems exploit restrictions associated limited depth determinacy muggleton
feng quinlan lavrac dzeroski cohen c learnability constant depth determinate clauses received formal study dzeroski
muggleton russell cohen
mode constraints declarations

mode declarations commonly used analyzing prolog code describing prolog code
instance mode declaration components indicates predicate components used first argument input second third arguments
outputs formally define mode literal l appearing clause c
string initial character predicate symbol l j
j th character j th argument l input variable
j th argument l output variable definition assumes
arguments head clause inputs justified since considering
clauses behave classifying extended instances ground mode constraint
set mode strings r fs sk g clause c said satisfy mode constraint
r p every literal l body c mode l r
define declaration tuple p r p predicate symbol
integer r mode constraint say clause c satisfies declaration


fipac learning recursive logic programs negative

head c arity predicate symbol p every literal l body
c mode l appears r
determinate modes

typical setting facts database db extended instances arbitrary
instead representative real predicate may obey certain restrictions let us assume database extended instance facts drawn
possibly infinite set f informally mode determinate input positions
facts f functionally determine output positions formally f p tk
fact predicate symbol p pff mode define inputs f pff hti ti
ik indices containing define outputs f pff
htj tj j jl indices containing define mode
string pff predicate p determinate f iff
k

l

fhinputs f pff outputs f pff f fg
function clause satisfies declaration dec detdec must determinate
set declarations containing modes determinate f denoted
detdec f since set f assumed fixed generally omit
subscript
bounds predicate arity

use notation db set databases contain facts arity
less dec set declarations p r every string r
length less
size measures

learning presented following section require learner use resources polynomial size inputs assuming predicates arity
less constant allows simple size measures used
measure size database db cardinality size extended instance f
cardinality size declaration p r cardinality r
size clause b br number literals body

model learnability
preliminaries

let x set call x domain call elements x instances define
concept c x representation subset x define language lang
set concepts rather casual distinction
concept set represents risk confusion refer
set represented concept c extension c two sets c c
extension said equivalent define example c pair e b b
e c b otherwise probability distribution function sample c


ficohen

x drawn according pair multisets drawn domain x according
containing positive examples c containing negative ones
associated x lang two size complexity measures use
following notation

size complexity concept c lang written j c j
size complexity instance e x written j ej
set sn stands set elements size complexity greater
n instance xn fe x j ej ng langn fc lang j c j ng
assume size measures polynomially related number bits needed
represent c e holds example size measures logic programs
databases defined
polynomial predictability

define polynomial predictability follows language lang polynomially
predictable iff pacpredict polynomial function ne nt
every nt every ne every c langn every every
every probability distribution function pacpredict following
behavior


given sample c xn drawn according containing least
ne nt examples pacpredict outputs hypothesis h
e

prob h c c h
probability taken possible samples pacpredict
randomized coin ips made pacpredict
pacpredict runs time polynomial ne nt number examples

hypothesis h evaluated polynomial time
pacpredict called prediction lang function ne nt called sample complexity pacpredict sometimes
abbreviate polynomial predictability predictability
first condition definition merely states error rate hypothesis
must usually low measured probability distribution
training examples drawn second condition together stipulation
sample size polynomial ensures total running time learner polynomial
final condition simply requires hypothesis usable weak sense
used make predictions polynomial time notice worst case
learning model definition allows adversarial choice inputs learner


fipac learning recursive logic programs negative

relation

model polynomial predictability well studied pitt warmuth
weaker version valiant criterion pac learnability language lang
pac learnable iff paclearn
paclearn satisfies requirements definition polynomial predictability

inputs paclearn outputs hypothesis h lang
thus language pac learnable predictable
companion cohen positive expressed model
identifiability equivalence queries strictly stronger pac learnability
anything learnable equivalence queries necessarily pac learnable
since contains negative use relatively weak model
predictability negative model immediately translate negative
stronger language predictable cannot pac learnable
identifiable equivalence queries
background knowledge learning

typical ilp system setting slightly different user usually provides clues
target concept addition examples form database db
background knowledge set declarations account additional inputs
necessary extend framework described setting learner accepts
inputs training examples following formalization used companion
cohen adopt notion language family
lang set clauses db database dec declaration define
lang db dec set pairs c db c lang c satisfies dec
semantically pair denote set extended instances f covered
c db next db set databases dec set declarations define
lang db dec flang db dec db

db dec decg

set languages called language family
extend definition predictability queries language families follows
language family lang db dec polynomially predictable iff every language set
predictable language family lang db dec polynomially predictable iff
single identify db dec predicts every lang db dec family
given db dec
usual model polynomial predictability worst case choices target
concept distribution examples notion polynomial predictability
language family extends model natural way extended model worstcase possible choices database db db dec dec worst case
equivalence query question form h equivalent target concept answered
yes counterexample identification equivalence queries essentially means
target concept exactly identified polynomial time polynomial queries



ficohen

model may seem unintuitive since one typically assumes database db provided
helpful user rather adversary however worst case model reasonable
learning allowed take time polynomial size smallest target concept
set lang db dec means database given user
target concept cannot encoded succinctly learning allowed take
time
notice language family lang db dec polynomially predictable every
language family must polynomially predictable thus family
polynomially predictable sucient construct one language family
learning hard proofs form

prediction preserving reducibilities

principle technical tool used negative notion prediction preserving
reducibility introduced pitt warmuth prediction preserving reducibilities
method showing one language harder predict another formally
let lang language domain x lang language domain x
say predicting lang reduces predicting lang denoted lang lang
function x x henceforth called instance mapping function
fc lang lang henceforth called concept mapping following hold
x c x fc c e concept membership preserved
mappings
size complexity fc c polynomial size complexity c e size
concept representations preserved within polynomial factor
x computed polynomial time
note fc need computable since computed polynomial time
x must preserve size within polynomial factor
intuitively fc c returns concept c lang emulate c e make
decisions concept membership examples preprocessed
function predicting lang reduces predicting lang learning
lang exists one possible scheme learning concepts lang
would following first convert examples unknown concept c
domain x examples domain x instance mapping
conditions definition hold since c consistent original examples
concept fc c consistent image thus running learning
lang produce hypothesis h good approximation
fc c course may possible map h back original language lang
computing fc may dicult impossible however h still used predict
membership c given example x original domain x one simply predict
x c true whenever x h
pitt warmuth give rigorous argument leads
prediction lang leading following theorem


fipac learning recursive logic programs negative

theorem pitt warmuth assume lang lang lang polynomially predictable lang polynomially predictable

cryptographic limitations learning recursive programs

theorem allows one transfer hardness one language another
useful number languages known prediction hard breaking
cryptographic schemes widely assumed secure example known
predicting class languages accepted deterministic finite state automata
cryptographically hard class languages accepted log space bounded turing
machines
section make use theorem previous cryptographic hardness
certain restricted classes recursive logic programs hard learn

programs n linear recursive clauses

companion cohen showed single linear closed recursive clause
identifiable equivalence queries section program
polynomial number clauses identifiable equivalence queries even
polynomially predictable
specifically let us extend notion family languages slightly let
dlog n represent language log space bounded deterministic turing machines
states accepting inputs size n less usual semantics complexity
measure let depthlinrecprog denote family logic programs containing
depth linear closed recursive clauses containing number clauses
following
theorem every n exists database db n db declaration
dec n detdec sizes polynomial n
dlog n depthlinrecprog db n dec n
hence depthlinrecprog db detdec uniformly polynomially predictable cryptographic assumptions
proof recall log space bounded turing machine tm input tape length
n work tape length log n initially contains zeros finite state control
state set q simplify proof assume without loss generality tape
input alphabets binary single accepting state qf q
machine erase work tape position work tape head far left
decides accept input
time step machine read tape squares input tape head
work tape head values current state q
e machine represents set inputs accepts complexity number states
specifically language uniformly polynomially predictable unless following cryptographic solved polynomial time solving quadratic residue inverting
rsa encryption function factoring blum integers holds cryptographic reduced learning dlog turing machines kearns valiant



ficohen






write work tape
shift input tape head left right
shift work tape head left right
transition internal state q
deterministic machine thus specified transition function

f g f g q f g fl rg fl rg q
let us define internal configuration tm consist string symbols
written worktape position tape heads internal state q
machine thus configuration element set
con f glog n f log ng f ng q

simplified specification machine transition function

f g con con
component f g represents contents input tape square
input tape head
notice machine whose worktape size bounded log n cardinality
con p jqjn log n polynomial n jqj use fact
constructions
background database db n follows first p atom
form coni ci present constant ci represent different internal configuration
turing machine arbitrarily select c represent unique accepting
configuration add db n atom accepting c thus
db n fcon ci gpi faccepting c g

next define instance mapping instance turing machine domain
binary string x b bn mapped extended instance f

f accepting c
ftruei gb x b ffalsei gb x b








description atoms effect defining predicate truei true iff th
bit x defining predicate falsei true iff th bit x
constant c represent start configuration turing machine
predicate accepting c defined true iff turing machine accepts input
x starting state c
let dec n accepting r r contains modes coni coni
p truej falsej j n
finally concept mapping fc let us assume arbitrary one one mapping
internal configurations turing machine predicate names


fipac learning recursive logic programs negative

con conp start configuration log n q maps con accepting configuration log n qf maps con construct program fc
follows transition c c c c con construct
clause form

accepting c

conj c truei conj c accepting c

position input tape head encoded c con j c
con j c transition c c construct analogous clause
truei replaced falsei
claim program p machine accept started
configuration ci iff
db n p accepting ci
hence construction preserves concept membership perhaps easiest see considering action top theorem prover given goal
accepting c sequence subgoals accepting ci accepting ci generated
theorem prover precisely parallel sequence configurations ci entered turing
machine
easily verified size program polynomial n
clauses linear recursive determinate depth one completing proof
number ways strengthened precisely
construction used used reduce class nondeterministic log space
bounded turing machines constant depth determinate linear recursive programs
slight modification construction used reduce class log space
bounded alternating turing machines chandra kozen stockmeyer constantdepth determinate ary recursive programs modification emulate configurations
corresponding universal states turing machine clauses form
accepting c
conj c truei
conj c accepting c
conj c accepting c
conj conj two successors universal configuration conj
strong since log space bounded alternating turing machines known
able perform every polynomial time computation

programs one n ary recursive clause

consider learning single recursive clause arbitrary closed recursion
key section observation expressive power
background database allows every log space deterministic turing machine
emulated single recursive constant depth determinate clause leads
following negative predictability


ficohen

theorem every n exists database db n db declaration
dec n detdec sizes polynomial n
dlog n depthrec db n dec n
hence depthrec db n detdec uniformly polynomially
predictable cryptographic assumptions

proof consider dlog machine proof theorem assume without
loss generality tape alphabet f g unique starting configura

tion c unique accepting configuration c assume without
loss generality unique failing configuration cf ail exactly
one transition form
b cj c j
every combination f ng b f g cj con fc cf ailg thus
input x x xn machine starts config c executes transitions
reaches config c config cf ail point x accepted rejected
respectively use p number configurations recall p polynomial
n
emulate convert example x b bn extended instance
x f

f accepting c
fbit bi gni
thus predicate bit x binds x th bit tm input tape
define following predicates background database db n

every possible b f g j j p n predicate statusb j b c
defined given bindings variables b c statusb j b c fail
c cf ail otherwise succeed binding active b b c cj
binding inactive otherwise
j j p n predicate nextj c succeed iff bound
active inactive c bound cj otherwise c
bound accepting configuration c
database contains fact accepting c
easy size database polynomial n
declaration dec n defined accepting r r includes modes
status bj next j bit b f g j p n
consider transition rule b cj c j corresponding conjunction
transibj biti bibj statusb j c bibj yibj nextj yibj c ibj accepting c ibj


fipac learning recursive logic programs negative

given db n assuming c bound configuration c conjunction
fail c cf ail succeed xi b c cj case yibj bound
inactive c ibj bound c recursive call succeeds accepting c
db n finally xi b c cj transibj succeed atom accepting cj
provable case yibj bound active c ibj bound cj
clear clause fc

accepting c
transibj


f ng b f g
j f pg

correctly emulate machine examples preprocessed
function described hence construction preserves concept membership
easily verified size program polynomial n
clause determinate depth three

one k local linear closed recursive clause

far considered one class extensions positive given
companion cohen namely relaxing restrictions imposed recursive
structure target program another reasonable question ask linear closed
recursive programs learned without restriction constant depth determinacy
earlier papers cohen b studied conditions
constant depth determinacy restriction relaxed still allowing learnability nonrecursive clauses turns generalizations constant depth
determinate clauses predictable even without recursion however language
nonrecursive clauses constant locality pac learnable generalization constant depth
determinate clauses define language summarize relevant previous
address question learnability recursive local clauses
define variable v appearing clause c free appears body c
head c let v v two free variables appearing clause v touches v
appear literal v uences v touches v touches
variable v uences v locale free variable v set literals
contain v contain free variable uenced v informally variable
v uences variable v choice binding v affect possible choices
bindings v
locality clause size largest locale let k localnonrec denote
language nonrecursive clauses locality k less k localnonrec
set logic programs containing single nonrecursive k local clause following facts
known cohen b
fixed k language family k localnonrec db dec uniformly
pac learnable
every constant every constant every database db db every declaration
dec detdec every clause c depthnonrec db dec


ficohen

equivalent clause c k localnonrec db dec size bounded kj c j k
function hence constant constants
hence
k localnonrec db dec
pac learnable generalization

depthnonrec db detdec
thus plausible ask recursive programs k local clauses pac learnable
facts learnability k local programs follow immediately previous
example immediate consequence construction theorem programs
polynomial number linear recursive k local clauses predictable k
similarly theorem shows single recursive k local clause predictable k
still reasonable ask however positive bounded depth determinate
recursive clauses cohen extended k ary closed recursive k local clauses
unfortunately following negative shows even linear closed
recursive clauses learnable

theorem let dfa denote language deterministic finite automata states

let k locallinrec set linear closed recursive k local clauses constant exists database db db declaration dec dec size
polynomial
dfa locallinrec db dec

hence k k locallinrec db dec uniformly polynomially
predictable cryptographic assumptions

proof following hopcroft ullman represent dfa alphabet

tuple q q f q initial state q set states f set
accepting states q q transition function sometimes
think subset q q prove theorem need construct database
db size polynomial every state dfa emulated linear
recursive k local clause db
rather directly emulating convenient emulate instead modification let dfa state set q q fq qe qf g q qe qf
states found q initial state q final state
qf transition function

f q q qe c qf g
f qi b qe g


qi f

b c letters note dfa alphabet
fa b cg described need complete dfa alphabet
may pairs qi qi undefined however easily


fipac learning recursive logic programs negative






q














q



















q
q
q
q
q



























b c
















b



b c




c

e


q



r

b c



f

b c
b c




b








q
q
q
q
q








































b



e

c



f

figure dfa modified emulation local clause



ficohen

made complete introducing additional rejecting state qr making every undefined
transition lead qr precisely let defined
f qi x qr j qi q x fa b cg qj qi x qj g
thus q q fqr g fqf g completed version q q fqr g
use construction let q q fqr g fa b cg
examples shown figure notice aside arcs
rejecting state qr state diagram nearly identical
differences initial state q single outgoing arc
labeled old initial state q every final state outgoing arc
labeled b state qe turn single outgoing arc labeled c final
state qf easy

x l iff axbc l
given set states q define database db contains following
predicates
arcq q x true q q x unless qi
x qj
state true q
accept c nil qe qf true
motivation arc predicates observe emulating clearly useful
able represent transition function usefulness arc predicates
transition function represented conjunction arc literals particular
conjunction

arc q q x


j



q q


j

j

succeeds x fails otherwise
let us define instance mapping x f

f accept xbc q q
set facts defines components relation list corresponds
string xbc words x n set facts
components n bc n bc
components n bc n bc


components c c nil
declaration dec n dec n accept r r contains modes
components state arc q q qi qj q
finally define concept mapping fc machine clause


j



fipac learning recursive logic programs negative

accept x ys
v
q q arcq q x
components ys x ys state u accept x ys u
transition function corresponding machine defined
easy construction polynomial
clause x letter ys list letters states
q intent construction predicate accept succeed exactly
string xys accepted started state b first action
taken string xys go state state
since initial transitions q q input
predicate accept claimed behavior clearly proposed mapping satisfies requirements theorem complete proof therefore must verify
predicate accept succeeds iff xys accepted state initial transition

definition dfas string xys accepted state initial
transition iff one following two conditions holds
x ys empty string final state
x ys nonempty string hence head x tail
ys ys accepted state initial transition
base fact accept c nil qe qf succeeds precisely first case holds since
transition one final state second case conjunction
arc conditions fc clause succeeds exactly x noted
second conjunction clause succeeds ys nonempty string
head x tail ys x ys accepted state initial transition
state u corresponds exactly second case
thus concept membership preserved mapping completes proof


j



j

dnf hardness recursive programs

summarize previous determinate clauses shown single
k ary closed recursive depth clause pac learnable cohen set n linear closed
recursive depth clauses even single n ary closed recursive depth clauses
pac learnable still large gap positive negative
however particular learnability recursive programs containing constant number
k ary recursive clauses yet established
section investigate learnability classes programs
programs two linear closed recursive clauses one linear closed recursive clause one base case hard learn boolean functions disjunctive
normal form dnf pac learnability dnf long standing open computational learning theory import therefore establishing
learnability classes require substantial advance computational learning
theory


ficohen

linear recursive clause plus base clause

previous work established two clause constant depth determinate programs consisting one linear recursive clause one nonrecursive clause identified given
two types oracles standard equivalence query oracle basecase oracle cohen
basecase oracle determines example covered nonrecursive clause
alone section absence basecase oracle learning
hard learning boolean dnf
discussion dnf n r denotes language r term boolean functions
disjunctive normal form n variables

theorem let depth clause set clause programs consisting one

clause depthlinrec one clause depthnonrec n
r exists database db n r db declaration dec n r dec sizes
polynomial n r
dnf n r depth clause db n r dec n r

hence language family depth clause db detdec
uniformly polynomially predictable dnf polynomially predictable

proof produce db n r db dec n r detdec predicting
dnf reduced predicting depth clause db n r dec n r construction
makes use trick first used theorem cohen dnf formula
emulated conjunction containing single variable existentially quantified
restricted range
begin instance mapping assignment b bn converted
extended instance f
f p
fbit bi gni
next define database db n r contain binary predicates true false truer
falser behave follows

truei x succeeds x f rg fig
falsei x succeeds x f rg fig
db n r contains facts define predicate succ z true whenever
z z numbers r clearly size db n r
polynomial r
let dec n r p r r contains modes bit n true j
false j j r succ
let r term dnf formula ri sj lij variables v vn
may assume without loss generality contains exactly r terms since dnf
formula fewer r terms padded exactly r terms adding terms




fipac learning recursive logic programs negative

background database

r
truei b b b f rg
falsei b b b f rg
succ z
z f rg z f rg

dnf formula v v v v v v v
equivalent program
p succ z p z
p bit x bit x bit x bit x
true x false x true x
false x false x
true x false x
instance mapping p fbit bit bit bit g
figure reducing dnf recursive program
form v v define concept mapping fc program cr cb cr
linear recursive depth determinate clause

p succ z p z
cb nonrecursive depth determinate clause

n

r
p
bit k xk
bij


j

k

bij defined follows

bij



truei xk lij vk
falsei xk lij vk

example construction shown figure suggest reader refer
figure point basic idea behind construction first clause
cb succeed variable bound th term succeeds
definitions truei falsei designed ensure property holds second
recursive clause cr constructed program fc succeeds iff cb succeeds
bound one values n
argue rigorously correctness construction clearly
fc size respectively since db n r polynomial
size reduction polynomial
figure shows possible proofs constructed program fc
notice program fc succeeds exactly clause cb succeeds value


ficohen

p



aa

b





succ p









aa

b

succ p









aa

b


p n

b v bit x v v b




ij









aa
b n


succ n n p n
b n

figure space proofs possible program fc
vs l must true



r





true


term


j ij
v
v


case j bij succeeds bound value j bi j every
succeeds bound hand false assignment ti
fails hence every possible binding generated repeated use recursive
clause cr base clause cb fail thus concept membership preserved
mapping
concludes proof






two linear recursive clauses

recall single linear closed recursive clause identifiable equivalence
queries cohen construction similar used theorem used
cannot extended programs two linear recursive clauses
theorem let depth clause set clause programs consisting two
clauses depthlinrec thus assume base case recursion given
background knowledge constants n r exists database db n r
db declaration dec n r dec sizes polynomial n
dnf n r depth clause db n r dec n r
hence constants language family
depth clause db detdec


fipac learning recursive logic programs negative

uniformly polynomially predictable dnf polynomially predictable

proof proof makes use prediction preserving reducibility dnf

depth clause db dec specific db dec let us assume dnf
r terms assume r k assumption made without
loss generality since number terms increased padding vacuous
terms consider complete binary tree depth k k th level tree
exactly r nodes let us label nodes r give nodes arbitrary labels

construct database db n r theorem except following changes
predicates truei b falsei b succeed label node
level k
rather predicate succ database contains two predicates leftson
rightson encode relationship nodes binary tree
database includes facts p p r r leaves
binary tree used base cases recursive program
learned
let label root binary tree define instance mapping

b b p fbit b bit n bn g
note except use rather identical instance mapping
used theorem let dec n r p r r contains modes bit
n true j false j j r leftson rightson
concept mapping fc pair clauses r r r clause

n

r
p
bit k xk
bij leftson z p z


k

r clause

p

n

k

bit k xk

j


r


j

bij rightson z p z

note clause linear recursive determinate depth
construction clearly polynomial remains membership preserved
figure shows space proofs
v constructed
v v program fc
figure b abbreviates conjunction bit xi bij notice program
succeed recursive calls manage finally recurse one base cases
p p r correspond leaves binary tree clauses
succeed first k levels tree however reach base cases
recursion leaves tree recursion must pass k th level tree
one clauses must succeed node binary tree
k th level tree hence label number r
program thus succeeds precisely number


ficohen

p


b
b


h

h

bb


b

bb


b



b



b

b


b p l
b
p r
z
z


z
x
z

x


z

z

z

z


z

z


e
x
x
x
ex


e


e


e







b
b
b




b
b





b p l b p r

p





j
j

j


j

j

b
b
b

b

b

b n p rr lr b n p rr r

p

p
r

p
r

figure proofs possible program fc

r conjunction b succeeds argument given theorem
happen satisfied assignment thus mappings preserve

concept membership completes proof

notice programs fc used proof property depth
every proof logarithmic size instances means hardness
holds even one additionally restricts class programs logarithmic
depth bound

upper bounds diculty learning

previous sections showed several highly restricted classes recursive programs
least hard predict dnf section restricted
classes harder predict dnf
wish restrict depth proof constructed target program thus let
h n function use langh n set programs class lang
proofs extended instance f depth bounded h j dj


fipac learning recursive logic programs negative

theorem let dnf n language dnf boolean functions number

terms recall depth clause language clause programs consisting one clause depthlinrec one clause depthnonrec
depth clause language clause programs consisting two clauses
depthlinrec
constants databases db db declarations dec detdec
polynomial function poly n

depth clause db dec dnf poly j db j
depth clause h n db dec dnf poly j db j h n bounded c log n
constant c
hence language families uniformly polynomially predictable dnf n
polynomially predictable

proof proof relies several facts established companion cohen
every declaration dec clause bottom dec every nonrecursive depth determinate clause c equivalent subclause bottom
size bottom polynomial dec means language subclauses bottom normal form nonrecursive constant depth
determinate clauses

every linear closed recursive clause cr constant depth determinate equivalent subclause bottom plus recursive literal lr
polynomial number possible recursive literals lr
constants database db db declaration dec
p r database db db program p depth clause db dec
depth terminating proof constructing p hmax
hmax polynomial size db dec
assumed without loss generality database db decsriptions
contain equality predicate equality predicate simply predicate
equal x true exactly x
idea proof contruct prediction preserving reduction two
classes recursive programs listed dnf begin two lemmas

lemma let dec detdec let c nonrecursive depth determinate clause

consistent dec let subclausec denote language subclauses c let
monomial u denote language monomials u variables polynomial poly database db db
subclausec db dec monomial poly j db j



ficohen

proof lemma follows immediately construction used theorem

dzeroski muggleton russell dzeroski et al basic idea construction introduce propositional variable representing success connected
chain literals c subclause c represented conjunction
propositions
lemma extended follows

lemma let dec detdec let fc crg set r nonrecursive depth

determinate clauses consistent dec length n less let subclauses denote
set programs form p ds di subclause
cj
polynomial poly database db db
subclauses db dec dnf poly j db j r

proof lemma lemma ci set variables vi size
polynomial j db j
every clause subclausec emulated monomial
sr

v
v

clearly
jv j polynomial n r every clause
let v







subclausec emulated monomial v every disjunction

r clauses represented disjunction monomials
since ci satisfy single declaration dec p r heads
principle function arity may assume without loss generality since
equality predicate assumed variables appearing heads clauses
distinct since ci nonrecursive every program
p subclauses

represented disjunction dr di subclausec hence
every p subclauses represented r term dnf set variables v




let us introduce additional notation c clauses use
c u denote resolving c together c denote
resolving c times note c u unique c linear recursive c
predicate heads since one pair complementary
literals
consider target program

p cr cb depth clause db dec
cr recursive clause cb base proof extended instance
f must use clause cr repeatedly h times use clause cb resolve away
final subgoal hence nonrecursive clause crh u cb could used cover
instance f
since depth proof class programs bounded number hmax
polynomial j db j ne nonrecursive program

p fcrh u cb h hmax g


fipac learning recursive logic programs negative

equivalent p extended instances size ne less
finally recall assume cb subclause bottom
polynomial sized set lr lr lr closed recursive literals
lr lr clause cr subclause bottom lr means let
polynomial sized set
f bottom lr h u bottom j h hmax lr lr g
p subclauses thus lemma depth clause dnf concludes
proof first statement theorem

depth clause h n db dec dnf poly j db j
similar argument applies let us introduce notation define
meshh n cr cr set clauses form
p









cr u cr u u cr
j cr cr cr cr h h n notice functions
h n c log n number clauses polynomial n
let p predicate appearing heads cr cr let c respectively
version c db every instance predicate p replaced
db
predicate p p recursive program p fcr cr g depth clause

database db p db equivalent nonrecursive program p db


ij





h

ij

p fc j c meshh n cr cr g
e

recall polynomial number recursive literals lr hence
polynomial number pairs recursive literals lr lr means set clauses


fc j c meshh n bottom lr bottom lr g




l

ri

e



lrj lr lr

j



j

polynomial sized furthermore program p language depth clause
p subclauses second part theorem follows application lemma
immediate corollary theorems strengthened
follows
corollary constants language family
depth clause db detdec
uniformly polynomially predictable dnf polynomially predictable
constants language family
depth clause db detdec
uniformly polynomially predictable dnf polynomially predictable
extended instances size n less
e



ficohen

thus important sense learning equivalent learning boolean
dnf resolve questions learnability languages
learnability dicult formal predictability boolean dnf
long standing open computational learning theory

related work
work described differs previous formal work learning logic programs simultaneously allowing background knowledge function free programs recursion focused exclusively computational limitations ecient learnability
associated recursion considered languages known paclearnable nonrecursive case since negative
concentrated model polynomial predictability negative model immediately imply negative stronger model pac learnability imply
negative strictly expressive languages
among closely related prior negative previously
obtained certain classes nonrecursive function free logic programs cohen b
similar character described apply nonrecursive
languages similar cryptographic obtained frazier page
certain classes programs recursive nonrecursive contain function symbols
disallow background knowledge
prior negative obtained learnability firstorder languages proof technique consistency hardness pitt valiant
haussler showed language existential conjunction concepts paclearnable showing hard concept language consistent
given set examples similar obtained two restricted languages
horn clauses kietz simple description logic cohen hirsh
language sorted first order terms page frisch however
specific model pac learnability none easily extended polynomial
predictability model considered extend languages
expressive specific constrained languages finally none languages allow
recursion
knowledge negative learnability first order languages discussion prior positive learnability first order languages
found companion cohen

summary
companion cohen considered large number different
subsets datalog aim comprehensive systematic particular wished precisely boundaries learnability lie syntactic
restrictions imposed relaxed since easy reader miss forest
trees brie summarize contained together
positive companion cohen


fipac learning recursive logic programs negative

local
clauses

constant depth determinate
clauses

ncr

ncr

ncr jcb

ncr cb

k ncr

n ncr

kcr

kcr

kcrjcb

kcr cbdnf

k k crdnf

n kcr

cr

cr

crjcb

cr cb dnf

cr dnf

n cr

table summary learnability
throughout papers assumed polynomial amount background
knowledge exists programs learned contain function symbols
literals body clause small arity assumed recursion
closed meaning output variables appear recursive clause however believe
restriction relaxed without fundamentally changing
companion cohen showed single nonrecursive constantdepth determinate clause learnable strong model identification equivalence
queries learning model one given access oracle counterexamples
oracle unit time example current hypothesis
incorrect must reconstruct target program exactly polynomial number
counterexamples implies single nonrecursive constant depth determinate clause pac learnable counterexample oracle emulated drawing
random examples pac setting novel dzeroski et al however
proof given independent independent interest notably somewhat
rigorous earlier proofs proves directly rather via reduction propositional learning proof introduces simple version
forced simulation technique variants used positive
showed learning nonrecursive clauses extended
case single linear recursive constant depth determinate clause leading
restricted class recursive programs identifiable equivalence
queries bit effort extended learn single
k ary recursive constant depth determinate clause
considered extended learning learn recursive programs consisting one constant depth determinate clauses interesting extension
simultaneously learn recursive clause cr base clause cb equivalence
queries basecase oracle indicates counterexamples covered
base clause cb model possible simultaneously learn recursive clause
nonrecursive base case situations recursive clause learned


ficohen

language family
depthnonrec db detdec
depthlinrec db detdec
depth k rec db detdec
depth clause db detdec
kd maxreclang db detdec
depth clause db detdec
depth clause db detdec
depthlinrecprog db detdec
depthrec db detdec
k locallinrec db dec


b











r








l r oracles
eq

eq
k
eq

eq base
k
eq base

eq

eq
n
eq
n
eq

eq

notation learnable
cb
yes
cr
yes
kcr
yes
crjcb yes
kcrjcb
yes
cr cb dnf
cr dnf
n cr
ncr

cr


table summary language learnability column b indicates number
base nonrecursive clauses allowed program column r indicates number recursive clauses l r indicates number recursive literals allowed
single recursive clause eq indicates oracle equivalence queries base
indicates basecase oracle languages except k locallinrec clauses
must determinate depth
alone instance one learn k ary recursive clause together nonrecursive
base case strongest positive
summarized tables table program one rary recursive clause denoted rcr program one r ary recursive clause one
nonrecursive basecase denoted rcr cb rcrjcb basecase oracle
program different r ary recursive clauses denoted rcr boxed
associated one theorems companion
unmarked corollaries program class indicates
identifiable equivalence queries thus positive described
summarized four entries lower left hand corner section table
concerned constant depth determinate clauses
table presents information slightly different format relates
notation table terminology used elsewhere
considered learnability natural generalizations
languages shown learnable companion consider moment single
clauses companion showed fixed k single k ary recursive constantdepth determinate clause learnable showed restrictions
necessary particular program n constant depth linear recursive clauses
polynomially predictable hence restriction single clause necessary single
clause n recursive calls hard learn hence restriction k ary recursion
necessary showed restriction constant depth determinate clauses
necessary considering learnability constant locality clauses constant locality
clauses known generalization constant depth determinate clauses
pac learnable nonrecursive case however showed recursion allowed


fipac learning recursive logic programs negative

language learnable even single linear recursive clause polynomially
predictable
summarized table program class means
polynomially predictable cryptographic assumptions hence neither
pac learnable identifiable equivalence queries
negative cryptographic hardness give upper bound expressiveness learnable recursive languages still leave open learnability programs
constant number k ary recursive clauses absence basecase oracle
final section showed following model
polynomial predictability equivalent predicting boolean dnf
predicting two clause constant depth determinate recursive programs containing one
linear recursive clause one base case
predicting two clause recursive constant depth determinate programs containing two
linear recursive clauses even base case known
note program classes nearly simplest classes multi clause
recursive programs one imagine pac learnability dnf longstanding open computational learning theory suggest therefore
pac learning multi clause recursive logic programs dicult least
finding provably correct pac learning require substantial advances
computational learning theory table dnf respectively dnf means
corresponding language prediction equivalent dnf respectively least hard
dnf
summarize table sort recursion programs containing
constant depth determinate clauses learnable constant depth determinate
recursive programs learnable contain single k ary recursive clause
standard equivalence query model single k ary recursive clause plus base
case basecase oracle allowed classes recursive programs
cryptographically hard hard boolean dnf

conclusions

inductive logic programming active area one broad class learning
considered area class automatic logic programming
prototypical examples genre learning append two lists
multiply two numbers target concepts automatic logic programming recursive
programs often training data learning system simply examples
target concept together suitable background knowledge
topic pac learnability recursive logic programs random
examples background knowledge specifically wished establish computational
limitations inherit performing task began positive established
companion one constant depth determinate closed k ary
recursive clause pac learnable program consisting one recursive
clause one constant depth determinate nonrecursive clause pac learnable given
additional basecase oracle


ficohen

showed positive likely improved
particular showed eliminating basecase oracle learning two recursive clauses simultaneously prediction equivalent learning dnf even case
linear recursion showed following hard breaking presumably secure cryptographic codes pac learning n linear recursive determinate clauses
pac learning one n ary recursive determinate clause pac learning one linear recursive
k local clause
contribute machine learning several ways point view
computational learning theory several technically interesting one
prediction equivalence several classes restricted logic programs boolean dnf
together others cohen b reinforces importance learnability dnf gives dramatic example adding recursion
widely differing effects learnability constant depth determinate clauses
remain pac learnable linear recursion added constant locality clauses become cryptographically hard
negative systems apparently learn larger class recursive
programs must taking advantage special properties target concepts
learn distribution examples provided believe
likely opportunity obtaining positive formal area
identify analyze special properties example many examples
foil learned recursive logic programs made use complete example sets
datasets containing examples certain size rather sets randomly
selected examples quinlan cameron jones possible complete datasets
allow expressive class programs learned random datasets fact
progress recently made toward formalizing conjecture de raedt dzeroski

finally importantly established boundaries learnability
determinate recursive programs pac learnability model many plausible automatic programming contexts would highly desirable system offered
formal guarantees correctness provide upper bounds
one hope achieve ecient formally justified system learns recursive
programs random examples alone

acknowledgements
author wishes thank three anonymous jair reviewers number useful suggestions presentation technical content

references
aha lapointe ling c x matwin inverting implication small
training sets machine learning ecml catania italy springer verlag lecture
notes computer science


fipac learning recursive logic programs negative

biermann inference regular lisp programs examples ieee transactions systems man cybernetics
chandra k kozen c stockmeyer l j alternation journal
acm
cohen w w cryptographic limitations learning one clause logic programs
proceedings tenth national conference artificial intelligence washington
c
cohen w w b pac learning non recursive prolog clauses appear artificial
intelligence
cohen w w c rapid prototyping ilp systems explicit bias proceedings
ijcai workshop inductive logic programming chambery france
cohen w w pac learning nondeterminate clauses proceedings eleventh
national conference artificial intelligence seattle wa
cohen w w b recovering software specifications inductive logic programming proceedings eleventh national conference artificial intelligence
seattle wa
cohen w w pac learning recursive logic programs ecient journal
ai
cohen w w hirsh h learnability description logics equality
constraints machine learning
de raedt l dzeroski first order jk clausal theories pac learnable
wrobel ed proceedings fourth international workshop inductive
logic programming bad honnef bonn germany
dzeroski muggleton russell pac learnability determinate logic
programs proceedings workshop computational learning theory
pittsburgh pennsylvania
frazier page c learnability recursive non determinate theories
basic techniques proceedings third international workshop
inductive logic programming bled slovenia
haussler learning conjunctive concepts structural domains machine learning
hopcroft j e ullman j introduction automata theory languages
computation addison wesley
kearns valiant l cryptographic limitations learning boolean formulae
finite automata th annual symposium theory computing acm
press


ficohen

kietz j u computational lower bounds computational complexity
inductive logic programming proceedings european conference
machine learning vienna austria
king r muggleton lewis r sternberg j e drug design
machine learning use inductive logic programming model structureactivity relationships trimethoprim analogues binding dihydrofolate reductase
proceedings national academy science
lavrac n dzeroski background knowledge declarative bias inductive
concept learning jantke k p ed analogical inductive inference international workshop aii springer verlag daghstuhl castle germany lectures
artificial intelligence series
lloyd j w foundations logic programming second edition springer verlag
muggleton de raedt l inductive logic programming theory methods
journal logic programming
muggleton feng c ecient induction logic programs inductive logic
programming academic press
muggleton king r sternberg j e protein secondary structure
prediction logic machine learning protein engineering
muggleton h ed inductive logic programming academic press
page c frisch generalization learnability study constrained
atoms inductive logic programming academic press
pazzani kibler utility knowledge inductive learning machine
learning
pitt l warmuth k reductions among prediction difficulty predicting automata proceedings rd annual ieee conference
structure complexity theory washington c computer society press
ieee
pitt l valiant l computational limitations learning examples journal
acm
pitt l warmuth prediction preserving reducibility journal computer
system sciences
quinlan j r cameron jones r foil midterm report brazdil p b
ed machine learning ecml vienna austria springer verlag lecture notes
computer science
quinlan j r learning logical definitions relations machine learning


fipac learning recursive logic programs negative

quinlan j r determinate literals inductive logic programming proceedings
eighth international workshop machine learning ithaca york morgan
kaufmann
rouveirol c flattening saturation two representation changes generalization machine learning
summers p methodology lisp program construction examples
journal association computing machinery
valiant l g theory learnable communications acm
zelle j mooney r j inducing deterministic prolog parsers treebanks
machine learning proceedings twelfth national conference
artificial intelligence seattle washington mit press




