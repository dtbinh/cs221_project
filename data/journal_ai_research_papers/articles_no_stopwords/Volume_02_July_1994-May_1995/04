journal artificial intelligence

submitted published

pac learning recursive logic programs
ecient
william w cohen

bell laboratories
mountain avenue murray hill nj usa

wcohen att com

abstract

present learn certain classes function free recursive logic programs polynomial time equivalence queries particular single
k ary recursive constant depth determinate clause learnable two clause programs consisting one learnable recursive clause one constant depth determinate non recursive
clause learnable additional basecase oracle assumed immediately imply pac learnability classes although classes learnable
recursive programs constrained shown companion
maximally general generalizing class natural way leads computationally dicult learning thus taken together companion
establishes boundary ecient learnability recursive logic programs

introduction
one active area machine learning learning concepts expressed firstorder logic since researchers used variant prolog represent learned
concepts subarea sometimes called inductive logic programming ilp muggleton
muggleton de raedt
within ilp researchers considered two broad classes learning
first class call logic relational learning
first order variants sorts classification typically considered within
ai machine learning community prototypical examples include muggleton et al
formulation helix prediction king et al formulation predicting drug activity zelle mooney use ilp techniques learn control heuristics
deterministic parsers logic relational learning often involves noisy examples ect relatively complex underlying relationship natural extension propositional
machine learning already enjoyed number experimental successes
second class studied ilp researchers target concept prolog
program implements common list processing arithmetic function prototypical
class might learning append two lists multiply two numbers
learning similar character studied area automatic
programming examples summers biermann hence might appropriately called automatic logic programming automatic logic programming
characterized noise free training data recursive target concepts thus
central enterprise automatic logic programming perhaps
logic relational learning learning recursive logic programs
c ai access foundation morgan kaufmann publishers rights reserved

ficohen

goal formally analyze learnability recursive logic programs
valiant model pac learnability thus hopefully shedding light
task automatic logic programming summarize
simple recursive programs pac learnable examples alone examples plus
small number additional hints largest learnable class identify standard
learning model class one clause constant depth determinate programs
constant number closed recursive literals largest learnable class identify
requires extra hints class constant depth determinate programs consisting
single nonrecursive base clause single recursive clause class described
proved model identification equivalence queries
angluin somewhat stronger pac learnability identification
equivalence queries requires target concept exactly identified polynomial
time polynomial number equivalence queries equivalence query
asks hypothesis program h equivalent target program c answer
query yes adversarily chosen example h c differ
model learnability arguably appropriate automatic logic programming tasks
weaker model pac learnability unclear often approximately
correct recursive program useful
interestingly learning analyzed different existing ilp
learning methods employ unusual method generalizing examples called forced
simulation forced simulation simple analytically tractable alternative
methods generalizing recursive programs examples n th root finding
muggleton sub unification aha lapointe ling matwin recursive
anti unification idestam almquist rarely used experimental
ilp systems ling
organized follows presenting preliminary definitions
begin presenting primarily pedagogical reasons procedure identifying
equivalence queries single non recursive constant depth determinate clause
section extend learning corresponding proof correctness
simple class recursive clauses class closed linear recursive constant depth
determinate clauses section relax assumptions made make analysis
easier present several extensions extend linear
recursion k ary recursion k ary recursive clause non recursive
clause learned simultaneously given additional basecase oracle discuss
related work conclude
although learnable class programs large enough include well known
automatic logic programming benchmarks extremely restricted companion
cohen provide number negative showing relaxing
restrictions leads dicult learning particular learning
hard learning dnf open computational learning theory
hard cracking certain presumably secure cryptographic schemes thus taken together
companion delineate boundary learnability
recursive logic programs
although two papers independent suggest readers wishing read
companion read first


fipac learning recursive logic programs efficient

background

section present technical background necessary state
assume however reader familiar basic elements logic programming readers without background referred one standard texts example
lloyd

logic programs

treatment logic programs standard except usually consider body
clause ordered set literals
consider logic programs without function symbols
e programs written datalog purpose logic program answer
certain questions relative database db set ground atomic facts
convenient think db conjunction ground unit clauses simplest
use datalog program check status simple instance simple instance
program p database db fact f pair p db said cover f iff
db p f set simple instances covered p db precisely minimal model
logic program p db
primarily consider extended instances consist two parts
instance fact f simply ground fact description finite set
ground unit clauses extended instance e f covered p db iff
db p f

extended instances allowed function free programs expressive enough
encode surprisingly interesting programs particular many programs usually
written function symbols written function free programs example
illustrates

example consider usual program appending two lists
append ys ys
append xjxs ys xjzs

append xs ys zs

one could use program classify atomic facts containing function symbols
append program rewritten datalog
program classifies extended instances follows

program p

append xs ys ys
null xs
append xs ys zs
components xs x xs
components zs x zs
assumption made primarily convenience section describe assumption
relaxed



ficohen

append xs ys zs

database db
null nil

predicate components b c means list head b tail
c thus extended instance equivalent append would

instance fact f

append list list list

description

components list list
components list nil
components list list
components list list
components list nil
note extended instances examples closely related ground
clauses entailed target clause examples specifically instance e f
covered p db iff p db f example shows close
relationship extended instances literals function symbols
removed attening rouveirol de raedt dzeroski elected
use datalog programs model extended instances several
reasons datalog relatively easy analyze close connection datalog
restrictions imposed certain practical learning systems foil quinlan
quinlan cameron jones focl pazzani kibler golem
muggleton feng
finally extended instances addresses following technical learning considered involve restricted classes logic programs often
restrictions imply number simple instances polynomial note
polynomial size domain questions pac learnability usually trivial requiring
learning work domain extended instances precludes trivial learning
techniques however number extended instances size n exponential n even
highly restricted programs

restrictions logic programs

consider learnability restricted classes logic programs define restrictions however first introduce
terminology
b br ordered definite clause input variables literal
bi variables appearing bi appear clause b bi
variables appearing bi called output variables b br
definite clause bi said recursive literal predicate symbol
arity head clause


fipac learning recursive logic programs efficient

types recursion

first set restrictions concern type recursion allowed program
every clause program one recursive literal program linear
recursive every clause program k recursive literals program
k ary recursive finally every recursive literal program contains output variables
say program closed recursive
determinacy depth

second set restrictions variants restrictions originally introduced muggleton
feng b br ordered definite clause literal bi
determinate iff every possible substitution unifies fact e
db b bi

one maximal substitution db bi clause determinate
literals determinate informally determinate clauses
evaluated without backtracking prolog interpreter
define depth variable appearing clause b br follows
variables appearing head clause depth zero otherwise let bi first
literal containing variable v let maximal depth input variables
bi depth v depth clause maximal depth variable
clause
muggleton feng define logic program ij determinate determinate
constant depth contains literals arity j less use phrase
constant depth determinate instead denote class programs
examples constant depth determinate programs taken dzeroski muggleton
russell

example assuming successor functional following program determinate maximum depth variable one variable c second
clause hence program depth one
less b
less b

successor b
successor c less c b


following program computes c determinate depth
two
choose b c
zero b
one c
choose b c
decrement b
decrement e


ficohen

multiply b c g
divide g f
choose e f
program golem muggleton feng learns constant depth determinate
programs related restrictions adopted several practical learning
systems quinlan lavrac dzeroski cohen c learnability
constant depth determinate clauses received formal study
review section
mode constraints declarations

define mode literal l appearing clause c string initial
character predicate symbol l j j th character
j th argument l input variable j th argument l
output variable definition coincides usual definition prolog modes
arguments head clause inputs simplification justified
however considering clauses behave classifying extended instances
ground mode constraint simply set mode strings r fs sk g
clause c said satisfy mode constraint r p every literal l body
c mode l r

example following append program every literal annotated
mode

append xs ys ys
null xs
append xs ys zs
components xs x xs
components zs x zs
append xs ys zs

mode null
mode components
mode components
mode append

clauses program satisfy following mode constraint
f components components components
components components null
append
append
append
append
g
mode constraints commonly used analyzing prolog code instance
used many prolog compilers sometimes use alternative syntax mode
constraints parallels syntax used prolog systems instance may
write mode constraint components components
define declaration tuple p r p predicate symbol
integer r mode constraint say clause c satisfies declaration
head c arity predicate symbol p every literal l body
c mode l appears r


fipac learning recursive logic programs efficient

model learnability

section present model learnability first review necessary
definitions standard learning model model learning equivalence queries
angluin discuss relationship learning
introduce extension model necessary analyzing ilp
identification equivalence queries

let x set call x domain call elements x instances define
concept c x representation subset x define language lang
set concepts rather casual distinction
concept set represents risk confusion refer set
represented concept c extension c two concepts c c
extension said semantically equivalent
associated x lang two size complexity measures use
following notation

size complexity concept c lang written j c j
size complexity instance e x written j ej
set sn stands set elements size complexity greater
n instance xn fe x j ej ng langn fc lang j c j ng
assume size measures polynomially related number bits needed
represent c e
first learning model consider model identification equivalence
queries goal learner identify unknown target concept c lang
construct hypothesis h lang h c information
target concept gathered equivalence queries input equivalence
query c hypothesis h lang h c response query
yes otherwise response query arbitrarily chosen counterexample
instance e symmetric difference c h
deterministic identify identifies lang equivalence queries iff
every c lang whenever identify run oracle answering equivalence queries
c eventually halts outputs h lang h c identify
polynomially identifies lang equivalence queries iff polynomial poly nt ne
point execution identify total running time bounded
poly nt ne nt j c j ne size largest counterexample seen far
equivalence queries made
relation pac learnability

model identification equivalence queries well studied angluin
known language learnable model learnable
valiant model pac learnability basic idea behind
equivalence query hypothesis h emulated drawing set random


ficohen

examples certain size counterexample h one returns
found counterexample answer equivalence query counterexamples
found one assume high confidence h approximately equivalent
target concept thus identification equivalence queries strictly stronger model
pac learnability
existing positive pac learnability logic programs rely showing
every concept target language emulated boolean concept
pac learnable class dzeroski et al cohen
illuminating disappointing since one motivations considering firstorder representations first place allow one express concepts cannot
easily expressed boolean logic one advantage studying exact identification
model considering recursive programs essentially precludes use sort
proof technique many recursive programs approximated boolean functions
fixed set attributes exactly emulated boolean functions
background knowledge learning

framework described standard one possible formalization usual
situation inductive concept learning user provides set examples
case counterexamples queries learning system attempts useful
hypothesis however typical ilp system setting slightly different usually
user provides clues target concept addition examples ilp
systems user provides database db background knowledge addition set
examples assume user provides declaration
account additional inputs necessary extend framework described
setting learner accepts inputs training examples
formalize introduce following notion language family lang
set clauses db database dec declaration define lang db dec
set pairs c db c lang c satisfies dec semantically
pair denote set extended instances f covered c db next
db set databases dec set declarations define
lang db dec flang db dec db

db dec decg

set languages called language family
extend definition identification equivalence queries language families follows language family lang db dec identifiable equivalence
queries iff every language set identifiable equivalence queries language
family lang db dec uniformly identifiable equivalence queries iff single
identify db dec identifies language lang db dec family
given db dec
uniform polynomial identifiability language family defined analogously
lang db dec uniformly polynomially identifiable equivalence queries iff
polynomial time identify db dec identifies language lang db dec
family given db dec note identify must run time polynomial
size inputs dec db well target concept


fipac learning recursive logic programs efficient

restricted types background knowledge

describe number restricted classes databases declarations
one restriction make throughout assume
predicates interest bounded arity use notation db set
databases contain facts arity less notation dec set
declarations p r every string r length less
technical reasons often convenient assume database contains
equality predicate predicate symbol equal equal ti ti db every
constant ti appearing db equal ti tj db ti tj similarly
often wish assume declaration allows literals form equal x x
input variables db respectively dec set databases declarations
use db dec denote corresponding set additional restriction
database declaration must contain equality predicate respectively mode
equal
sometimes convenient assume declaration p r allows
single valid mode predicate e predicate q r
single mode constraint form qff declaration called unique mode
declaration dec set declarations use dec denote corresponding
set declarations additional restriction declaration unique mode
finally note typical setting facts appear database db
descriptions extended instances arbitrary instead representative
real predicate e g relationship list components example
one way formalizing assume facts drawn restricted set f
assumption one define notion determinate mode f p tk
fact predicate symbol p pff mode define inputs f pff
tuple hti tik ik indices containing define
outputs f pff tuple htj tjl j jl indices containing
mode string pff predicate p determinate f iff relation

fhinputs f pff outputs f pff f fg
function informally mode determinate input positions facts f
functionally determine output positions
set declarations containing modes determinate f denoted
detdec f however set f assumed fixed thus
generally omit subscript
program consistent determinate declaration dec detdec must determinate defined words consistency determinate declaration
sucient condition semantic determinacy condition verified
simple syntactic test
size measures logic programs

assuming predicates arity less constant allows simple
size measures used measure size database db
cardinality size extended instance f cardinality size


ficohen

declaration p r cardinality r size clause b br
number literals body

learning nonrecursive clause

learning presented use generalization technique
call forced simulation way introduction technique consider
learning non recursive constant depth clauses presented
primarily pedagogical reasons may interest independent
previous proofs pac learnability class dzeroski et al
somewhat rigorous previous proofs
although details analysis non recursive clauses somewhat involved basic idea behind quite simple first highlyspecific bottom clause constructed two operations call deepen
constrain second bottom clause generalized deleting literals covers positive examples generalizing clause cover example
roughly simulate clause example delete literals would cause
clause fail remainder section describe analyze learning
detail

constructing bottom clause

let dec p r declaration let b br definite clause
define

deepen dec b br b br
li
li ld

ld maximal set literals li satisfy following conditions
clause b br li satisfies mode constraints given r
li ld mode predicate symbol lj ld
input variables li different input variables lj
every li least one output variable output variables li
different difference output variables
lj ld
extension notation define deepen idec c applying
function deepen dec repeatedly times c e



deepen dec c c


deepen dec deepen dec c otherwise
define function constrain dec

constrain dec b br b br
li
li lc

lc set literals li b br li satisfies mode
constraints given r li contains output variables


fipac learning recursive logic programs efficient

example let declaration p r r contains mode
constraints mother father male female equal



deepen p x
p x mother x xm father x xf mother ym father yf
deepen p x deepen deepen p x
p x
mother x xm father x xf mother ym father yf
mother xm xmm father xm xmf mother xf xfm father xf xff
mother ym ymm father ym ymf mother yf yfm father yf yff
constrain deepen p x
p x
mother x xm father x xf mother ym father yf
male x female x male female
male xm female xm male xf female xf
male ym female ym male yf female yf
equal x x equal x xm equal x xf
equal x equal x ym equal x yf
equal xm x equal xm xm equal xm xf
equal xm equal xm ym equal xm yf
equal xf x equal xf xm equal xf xf
equal xf equal xf ym equal xf yf
equal x equal xm equal xf
equal equal ym equal yf
equal ym x equal ym xm equal ym xf
equal ym equal ym ym equal ym yf
equal yf x equal yf xm equal yf xf
equal yf equal yf ym equal yf yf

let us say clause c subclause clause c heads c c
identical every literal body c appears c literals
body c appear order c functions deepen
constrain allow one easily describe clause interesting property
theorem let dec p r declaration detdec let x xa distinct
variables define clause bottom follows
bottom dec constrain dec deepen ddec p x xa
constants following true
size bottom dec polynomial j decj
every depth clause satisfies dec hence determinate semantically
equivalent subclause bottom dec






ficohen

begin force nr dec db

bottom specific possible clause
let h bottom dec

repeat

ans answer query h correct
ans yes return h
elseif ans negative example
return consistent hypothesis
elseif ans positive example e
generalize h minimally cover e
let f components extended instance e
h forcesimnr h f dec db
h failure
return consistent hypothesis

end

endif
endif
endrepeat

figure learning nonrecursive depth determinate clauses

proof see appendix related appears muggleton feng
example c equivalent c notice
subclauses bottom

c p b mother c father mother b c father b male
p x mother x xm father x xf mother ym father yf
male x equal xm ym equal xf yf
c p b father b female
p x father x xf female x equal xf
c p x true x brother c p x
true x daughter x father

learning

theorem suggests may possible learn non recursive constant depth determinate clauses searching space subclauses bottom ecient
manner figures present called force nr dec
unique mode declaration
figure presents top level learning force nr force nr takes
input database db declaration dec begins hypothesizing clause
bottom dec positive counterexample e current hypothesis generalized little possible order cover e strategy means hypothesis


fipac learning recursive logic programs efficient

begin subroutine forcesimnr h f dec db

forcibly simulate h fact f
f db return h
elseif head h f cannot unified
return failure

else

let h h
let mgu f head h
literal l body h
substitution l db
general substitution
else
delete l body h together
literals l supported directly indirectly l

end

endif
endfor
return h
endif

figure forced simulation nonrecursive depth determinate clauses
least general hypothesis covers positive examples hence negative
counterexample e ever seen abort message consistent
hypothesis exists
minimally generalize hypothesis h function forcesimnr used subroutine shown figure figure following terminology used
output variable l input variable l say l directly supports l
say l supports l iff l directly supports l l directly supports literal
l supports l thus supports transitive closure directly supports
forcesim nr deletes h minimal number literals necessary let h cover e
forcesim nr simulates action prolog interpreter evaluating h except
whenever literal l body h would fail literal deleted along
literals l supported l
idea learning repeated generalization old one particular previous
methods exist learning definite clause generalizing highly specific one example clint de raedt bruynooghe generalizes starting clause guided
queries made user progol srinivasan muggleton king sternberg
guides top generalization process known bottom clause rouveirol
describes method generalizing bottom clauses created saturation force nr thus interest novelty provably correct ecient
noted theorem


ficohen

particular let depthnonrec language nonrecursive clauses depth
less hence depthnonrec db j detdec language nonrecursive ij determinate clauses following

theorem constants language family
depthnonrec db detdec
uniformly identifiable equivalence queries

proof force nr uniformly identifies language family polyno

mial number queries begin following important lemma characterizes
behavior forcesimnr

lemma let dec declaration detdec let db database let f fact let

h determinate nonrecursive clause satisfies dec one following conditions

must hold
forcesimnr h f dec db returns failure subclause h h satisfies
dec constraint h db f
forcesimnr h f dec db returns clause h h unique syntactically
largest subclause h satisfies dec constraint h db f

proof lemma avoid repetition refer syntactically maximal subclauses
h h satisfy dec constraint h db f admissible subclauses

proof
clearly lemma true h failure returned forcesim nr remaining
cases loop executed must establish two claims
assumptions f unify f db
claim l retained every admissible subclause contains l
claim l deleted admissible subclause contains l
first however observe deleting literal l may cause mode
literals violate mode declarations dec easy see l deleted
clause c mode literals l directly supported l change thus c
satisfies unique mode declaration prior deletion l deletion l
literals l directly supported l invalid modes
see claim true suppose instead false must
maximal subclause c h satisfies dec covers fact f
contain l argument c contain l satisfied dec c
contains literals l h supported l hence output variables l
disjoint variables appearing c means l added
c resulting clause would still satisfy dec cover f leads contradiction
since c assumed maximal
verify claim let us introduce following terminology c b br
clause db database say substitution db f witness


fipac learning recursive logic programs efficient

c iff associated proof c db f precisely iff f
r bi db claim following condition invariant
loop forcesim nr
invariant let c admissible subclause contains literals h preceding l e contains literals h retained previous
iterations every db f witness c superset
easily established induction number iterations loop
condition true loop first entered since initially general unifier
f condition remains true iteration l deleted since
unchanged finally condition remains true iteration l retained
maximally general may assign values output variables l
determinacy one assignment output variables l make l true hence
every db f witness c must contain bindings
next inductive argument claim one every admissible
subclause c must contain literals retained previous iterations
loop leading following strengthening invariant
invariant let c admissible subclause every db f witness c
superset
notice two types literals deleted literals l superset
make l true b literals l supported literal l preceding
type case clearly l cannot part admissible subclause since superset
makes l succeed supersets witnesses admissible clauses
case b l cannot part admissible subclause since declaration invalid
unless l present clause argument l cannot clause
concludes proof lemma
prove theorem must establish following properties identification

correctness theorem target program depthnonrec db dec
clause ct equivalent target subclause
bottom dec h initially bottom hence superclause ct consider
invoking forcesim nr positive counterexample e lemma invocation
successful h replaced h longest subclause h covers e since
ct subclause h covers e means h superclause
ct inductively hypothesis superclause target
since counterexample e instance covered
current hypothesis h every time hypothesis updated hypothesis proper
subclause old means force nr eventually identify target clause
eciency number queries made polynomial j decj j db j since h
initially size polynomial j dec j reduced size time counterexample
provided see counterexample processed time polynomial nr ne
nt notice since length h polynomial number repetitions
loop forcesim nr polynomial since arity literals l bounded


ficohen

anb ane constants exist db hence anb ane
substitutions check inside loop polynomial thus execution

forcesim nr requires polynomial time
concludes proof

learning linear closed recursive clause

recall clause one recursive literal clause linear recursive
recursive literal contains output variables clause closed linear
recursive section describe force extended
learn single linear closed recursive clause presenting extension however
would first discuss reasonable sounding closer examination turns
incorrect

remark recursive clauses

one plausible first step toward extending force recursive clauses allow recursive
literals hypotheses treat way literals include
recursive literals initial clause bottom delete literals gradually
positives examples received simple
way check recursive literal clause succeeds fails particular example
makes impossible simply run forcesimnr clauses containing recursive literals
straightforward apparent solution assume oracle exists
queried success failure recursive literal closed recursive
clauses sucient assume oracle memberct db f answers
question
db p f
ct unknown target concept f ground fact db database given
oracle one determine closed recursive literal lr retained
checking memberct db lr true oracle close notion
membership query used computational learning theory
natural extension force nr learning recursive clauses
fact similar ideas previously conjectured pac learn
closed recursive constant depth determinate clauses dzeroski et al unfortunately
fail return clause consistent positive counterexample
illustrate consider following example

example consider extension force nr described learn
following target program
append xs ys zs
reader may object useful recursive programs least two clauses recursive
clause nonrecursive base case posing learning single recursive clause
thus assuming non recursive base case target program provided background knowledge
background database db description atoms extended instances



fipac learning recursive logic programs efficient

components xs x xs
components zs z zs
x z
append xs ys zs
program determinate depth satisfies following set
declarations
components
null
equal
odd
append
assume database db defines predicate null true
empty lists odd true constants
see forced simulation fail consider following positive instance
e f

f append l l l
f cons l l cons l l cons l nil
cons l l cons l nil
append nil l l g

simply attened form append together
appropriate base case append consider beginning clause
bottom generalizing forcesimnr cover positive instance
process illustrated figure clause left figure
bottom dec clause right output forcibly simulating
clause f forcesimnr clarity assumed
single correct recursive call remains forced simulation
resulting clause incorrect cover given example e
easily seen stepping actions prolog interpreter
generalized clause figure nonrecursive literals succeed leading subgoal append l l l usual prolog notation
append subgoal fail literal odd x x
bound subgoal fact odd true db
example illustrates pitfall policy treating recursive non recursive
literals uniform manner discussion see bergadano gunetti de
raedt lavrac dzeroski unlike nonrecursive literals truth fact lr
corresponding recursive literal lr imply clause containing lr
succeed may first subgoal lr succeeds deeper subgoals fail


ficohen

bottom dec
forcesimnr bottom dec f dec db
append xs ys zs
append xs ys zs
components xs x xs
components xs x xs
components ys ys
components ys ys
components zs z zs
components zs z zs
null xs
null ys
null ys
equal x z

odd x

odd
null ys
odd z
null zs
append xs ys zs
equal xs xs


equal x z


equal zs zs
odd xs


odd x
odd
odd z


odd zs
append xs xs xs


append zs zs zs

figure recursive clause generalization forcesimnr

forced simulation recursive clauses
solution replace calls membership oracle
sketched call routine forcibly simulates actions top
theorem prover recursive clause particular following suggested
first build nonrecursive bottom clause done forcesimnr second
recursive literal lr appending lr bottom clause yields recursive clause
generalized cover positive examples
nonrecursive case clause generalized deleting literals straightforward generalization procedure forced simulation nonrecursive clauses
forced simulation failing nonrecursive subgoals simply deleted however
recursive literal lr encountered one forcibly simulates hypothesis clause recursively


fipac learning recursive logic programs efficient

begin subroutine forcesim h f dec db h

forcibly simulate recursive clause h f
check infinite loops
h return failure
check see f already covered
elseif f db return h
check see f cannot covered
elseif head h f cannot unified
return failure

else

let lr recursive literal h
let h h flrg

delete failing non recursive literals forcesimnr
let head h
let mgu e
literal l body h
substitution l db
general substitution

else

delete l body h together
literals l supported directly indirectly l

endif
endfor

generalize h recursive subgoal lr
lr ground return forcesim h flr g lr dec db h
else return failure

end

endif
endif

figure forced simulation linear closed recursive clauses



ficohen

corresponding recursive subgoal implementation forced simulation linear
closed recursive clauses shown figure
extended similar forcesimnr differs recursive
literal lr reached simulation h corresponding subgoal lr created
hypothesized clause recursively forcibly simulated subgoal ensures
generalized clause succeed subgoal reasons become clear
shortly would terminate even original clause h enters
infinite loop used top interpreter order ensure termination extra
argument h passed forcesim argument h represents depth bound forced
simulation
summarize basic idea behind figure simulate hypothesized clause h f generalize h deleting literals whenever h would fail
f subgoal f

example

consider forcesim forcibly simulate following recursive clause
bottom dec lr
append xs ys zs
components xs x xs components ys ys components zs z zs
null xs null zs
odd xs odd zs
equal xs xs equal zs zs
append xs ys zs
recursive literal lr append xs ys zs assume f
taken extended query e f attened version
instance append used previous example dec
set declarations previous example database db
null nul
executing steps forcesim number failing literals deleted
leading substitution fxs ys zs x
xs ys z zs g following reduced
clause
append xs ys zs
components xs x xs components ys ys components zs z zs
null ys odd x odd odd z equal x z
append xs ys zs
hence recursive subgoal

lr append xs ys zs append
note readability term notation rather attened notation xs l
ys l etc



fipac learning recursive logic programs efficient

recursively applying forcesim goal produces substitution fxs
ys zs x xs ys z zs g
deleting additional literals odd x odd z
next recursive subgoal lr append since clause included
database db forcesim terminate final clause returned
forcesim case following
append xs ys zs
components xs x xs components ys ys components zs z zs
null ys odd equal x z
append xs ys zs
notice clause cover e
section begin analysis showing correctness forced simulation
e showing forced simulation indeed produce unique maximally
specific generalization input clause covers example
proof correctness uses induction depth proof let us introduce
additional notation write p db h f prolog program p db
used prove fact f proof depth h less notion depth proof
usual one define looking f database db proof depth zero
following concerning forcesim

theorem let dec declaration detdec let db database let f fact

let h determinate closed linear recursive clause satisfies dec one
following conditions must hold

forcesim h f dec db h returns failure recursive subclause h h
satisfies dec constraint h db h f
forcesim h f dec db h returns clause h h unique syntactically
largest recursive subclause h satisfies dec constraint h db h f

proof avoid repetition refer syntactically maximal recursive nonrecursive subclauses h h satisfy dec constraint h db h f

admissible recursive nonrecursive subclauses respectively
proof largely parallels proof lemma particular similar arguments
clause returned forcesim satisfies conditions theorem whenever
failure returned whenever h returned note correctness forcesim
h returned establishes base case theorem h
case depth h let us assume theorem holds depth h
proceed mathematical induction arguments lemma following
condition true loop terminates

invariant h unique maximal nonrecursive admissible subclause h every
db f witness h superset


ficohen

begin force dec db

bottom specific possible clause
let lr lrp possible closed recursive literals bottom dec
choose unmarked recursive literal lri
let h bottom dec flri g

repeat

answer query h correct

ans

ans yes return h
elseif ans negative example e
h

failure

elseif ans positive example e

generalize h minimally cover e
let f components e
h forcesim h f dec db j dj j dbj
arity clause head given dec


endif
h failure
recursive literals marked
return consistent hypothesis
else

mark lri
choose unmarked recursive literal lrj
let h bottom dec flrj g

end

endif
endif
endrepeat

figure learning nonrecursive depth determinate clauses
let us assume admissible recursive subclause h clearly h must
contain recursive literal lr h since lr recursive literal h
nonrecursive clause h h flr g must certainly satisfy dec h db f
must maximality h subclause h hence h must subclause
h flr g finally lr ground e lr closed clause h lr
invariant clause h must satisfy h db lr proof depth h
simply equivalent saying recursive subgoal lr generated proof
must succeed
inductive hypothesis recursive call must return unique maximal
admissible recursive subclause h lr argument must
unique maximal admissible recursive subclause h
thus induction theorem holds


fipac learning recursive logic programs efficient

learning linear recursive clauses

given method generalizing recursive clauses one construct learning recursive clauses follows first guess recursive literal lr make
h bottom lr initial hypothesis learner ask series equivalence
queries positive counterexample e use forced simulation minimally generalize
h cover e negative example choose another recursive literal l r reset
hypothesis h bottom l r
figure presents operates along lines let depthlinrec
denote language linear closed recursive clauses depth less
following
theorem constants language family
depthlinrec db detdec
uniformly identifiable equivalence queries
proof force uniformly identifies language family polynomial number queries
correctness query eciency aj dj aj dbj constants
set db aj dj aj db j tuples constants hence
aj dj aj db j distinct recursive subgoals lr might produced proving
linear recursive clause c covers extended instance f thus every terminating proof
fact f linear recursive clause c must depth aj dj aj db j less e
h aj dj aj db j
c db h f iff c db f
thus theorem strengthened value h used force subroutine
forcesim returns syntactically largest subclause h covers example f
whenever subclause exists returns failure otherwise
argue correctness follows assume hypothesized recursive literal correct e target clause ct subclause
bottom lr case easy see force identify ct argument parallels one made force nr analogy force nr easy
see polynomial number equivalence queries made involving correct
recursive literal
next assume lr correct recursive literal ct need subclause
bottom lr response equivalence query may positive
negative counterexample positive counterexample e received forcesim
called may failure may proper subclause h covers
e thus choosing incorrect lr possibly empty sequence
positive counterexamples followed negative counterexample failure since
equivalence queries involving correct recursive literal answered
positive counterexample yes negative counterexample failure
obtained must lr incorrect








recall answer yes equivalence query means hypothesis correct



ficohen

number variables bottom bounded aj bottom dec j
closed recursive literal completely defined tuple variables number
possible closed recursive literals lr bounded

p aj bottom dec j



since j bottom dec j polynomial j dec j p polynomial j dec j means
polynomial number incorrect lr need discarded since
successive hypothesis single incorrect lr proper subclause previous hypothesis polynomial number equivalence queries needed discard incorrect
lr thus polynomial number equivalence queries made involving incorrect
recursive literals
thus force needs polynomial number queries identify ct
eciency forcesim runs time polynomial arguments h f dec db
h forcesim called force h polynomial ne j db j
h larger j bottom dec j turn polynomial size
dec hence every invocation forcesim requires time polynomial ne dec db
hence force processes query polynomial time
completes proof
somewhat surprising shows recursive clauses learned
even given adversarial choice training examples contrast implemented ilp
systems require well choosen examples learn recursive clauses
formal strengthened number technical ways one
interesting strengthenings consider variant force maintains
fixed set positive negative examples constructs set least general
clauses consistent examples could done taking
clauses bottom lr bottom lrp forcibly simulating
positive examples turn discarding clauses cover one negative
examples set clauses could used tractably encode version space
consistent programs n representation version spaces hirsh

extending learning

consider number ways theorem extended

equality predicate unique mode assumptions
theorem shows language family

depthlinrec db detdec
identifiable equivalence queries natural ask extended
dropping assumptions equality predicate present declaration
contains unique legal mode predicate extended
language family
depthlinrec db detdec


fipac learning recursive logic programs efficient

extension fact straightforward given database db declaration dec
p r satisfy equality predicate unique mode assumptions one
modify follows
every constant c appearing db add fact equal c c db
every predicate q k valid modes qs qsk r
remove mode declarations q replace k mode strings
k predicates qs qsk letting qsi si unique legal mode
predicate qsi
b remove every fact q ta predicate q db replace
k facts qs ta qsk ta
note arity predicates bounded constant number modes
k predicate q bounded constant hence transformations
performed polynomial time polynomial increase size dec
db
clearly target clause ct depthlinrec db dec equivalent clause
ct depthlinrec db dec db dec modified versions db
dec constructed force possible identify ct learning ct one
must perform steps b description part every counterexample
f finally one convert ct equivalent clause depthlinrec db dec
repeatedly resolving clause equal x x replacing every predicate
symbol qsi q
leads following strengthening theorem

proposition constants language family
depthlinrec db detdec
uniformly identifiable equivalence queries

datalog assumption

far assumed target program contains function symbols
background knowledge provided user database ground facts convenient
formal analysis assumptions relaxed
examination learning shows database db used two
ways

forcibly simulating hypothesis extended instance f necessary
substitution makes literal l true database db
done algorithmically db sets ground facts plausible
assume user provided oracle answers polynomial time
mode correct query l database db specifically answer oracle



ficohen

unique general substitution db l l
ground
exists

oracle would presumably take form ecient theorem prover db

calling forcesim top level learning uses db determine

depth bound length proof made hypothesis program
reasonable assume user provide information directly
form oracle specifically oracle would provide fact f polynomial
upper bound depth proof f target program

finally note ecient non ground background knowledge allowed
function symbols removed via attening rouveirol transformation preserves determinacy although may increase depth general depth
attened clause depends term depth original clause thus assumption
target program datalog replaced assumptions term depth
bounded constant two oracles available oracle answers queries
background knowledge depth bound oracle types oracles
frequently assumed literature shapiro page frisch dzeroski et al


learning k ary recursive clauses

natural ask theorem extended clauses linear recursive
one interesting case case closed k ary recursive clauses constant k
straightforward extend force guess tuple k recursive literals lr lrk
extend forcesim recursively generalize hypothesis clause facts
lr lrk arguments theorems modified
extension identify target clause polynomial number equivalence queries
unfortunately however longer case forcesim runs polynomial time
easily seen one considers tree recursive calls made forcesim
general tree branching factor k polynomial depth hence exponential
size unsurprising implementation forcesim described forcibly
simulates depth bounded top interpreter k ary recursive program take
exponential time interpret interpreter
least two possible solutions one possible solution
retain simple top forced simulation procedure require user provide
depth bound tighter aj dj aj db j maximal possible depth tree
example learning ary recursive sort quicksort user might specify logarithmic depth bound thus guaranteeing forcesim polynomial time requires
additional input user would easy implement advantage
shared described hypothesized program executed simple depth bounded prolog interpreter shallow proof
trees seems plausible bias impose learning k ary recursive prolog
programs many tend shallow proof trees




fipac learning recursive logic programs efficient

second solution possible high cost forced simulation k ary recursive
programs forcibly simulate smarter type interpreter one execute
k ary recursive program polynomial time one sound complete theorem prover
closed k ary recursive programs implemented follows
construct top proof tree usual fashion e depth first left right
strategy maintain list ancestors current subgoal list visited
records previously visited node tree subgoal associated
node suppose course constructing proof tree one generates subgoal
f visited list since traversal tree depth first left right
node associated f ancestor current node descendant
left sibling ancestor current node former case proof tree contains
loop cannot produce successful proof case theorem prover exit
failure latter case proof must already exist f hence nodes
current node tree need visited instead theorem prover simply assume
f true
top interpreter easily extended forced simulation procedure
one simply traverses tree order generalizing current hypothesis h
needed justify inference step tree additional point note
one performing forced simulation revisits previously proved subgoal f node
n current clause h need generalized order prove f hence
permissible simply skip portion tree n thus following


theorem let depth k rec set k ary closed recursive clauses depth
constants k language family
depth k rec db detdec
uniformly identifiable equivalence queries

proof omitted following informal argument made
note give without restrictions database contains
equality relation declaration unique mode since tricks used relax
restrictions proposition still applicable

learning recursive base cases simultaneously

far analyzed learning single clauses first single nonrecursive
clause single recursive clause however every useful recursive program contains
least two clauses recursive clause nonrecursive base case natural ask
possible learn complete recursive program simultaneously learning
recursive clause associated nonrecursive base case
general possible demonstrated elsewhere cohen however
several cases positive extended two clause programs
note plausible believe theorem prover exists polynomial
number possible theorem proving goals namely aj dj aj db j possible recursive subgoals




ficohen

begin force dec db
let lr lrp possible recursive literals bottom dec
choose unmarked recursive literal lri
let hr bottom dec flri g
let hb bottom dec
let p hr hb

repeat

ans answer query hr hb correct
ans yes return hr hb
elseif ans negative example e
p failure
elseif ans positive example e
let f components e
p forcesim hr hb f dec db j dj j dbj


endif
p failure
recursive literals lrj marked
return consistent hypothesis
else

mark lri
choose unmarked recursive literal lrj
let hr bottom dec flrj g
let hb bottom dec
let p hr hb

end

endif
endif
endrepeat

figure learning two clause recursive programs



fipac learning recursive logic programs efficient

begin subroutine forcesim hr hb f dec db h

forcibly simulate program hr hb f
h return failure
check see f covered hb
elseif basecase f
return current hr generalized hb
return hr forcesimnr hb f dec db
elseif head hr f cannot unified
return failure

else

let lr recursive literal hr
let h h flrg
let head h
let mgu e
literal l body h
substitution l db
general substitution
else
delete l body h together
literals l supported directly indirectly l

endif
endfor

generalize h hb recursive subgoal lr
lr ground
continue simulation program
return forcesim h flr g hb lr dec db h
else return failure

end

endif
endif

figure forced simulation two clause recursive programs



ficohen

section first discuss learning recursive clause base clause simultaneously assuming determinate base clause possible assuming
additional hint available form special basecase oracle
discuss alternative types hints
let p target program base clause cb recursive clause cr basecase
oracle p takes input extended instance f returns yes cb db f
otherwise words oracle determines f covered nonrecursive
base clause alone example append program basecase oracle return
yes instance append xs ys zs xs empty list otherwise
given existence basecase oracle learning extended
follows possible recursive literals lri clause bottom generated
however case learner test two clause hypotheses initially
form bottom lri bottom forcibly simulate hypothesis fact f
following procedure used checking usual termination conditions forced
simulator checks see basecase f true calls forcesimnr appropriate
arguments generalize current hypothesis base case basecase f
false recursive clause hr forcibly simulated f subgoal lr generated
generalized program recursively forcibly simulated subgoal
figures present learning force two clause programs consisting
one linear recursive clause cr one nonrecursive clause cb assumption
equivalence basecase oracles available
straightforward extend arguments theorem case leading
following

theorem let depth clause set clause programs consisting one

clause depthlinrec one clause depthnonrec constants
language family

depth clause db detdec
uniformly identifiable equivalence basecase queries

proof omitted
companion cohen shows something basecase oracle
necessary particular without hints base clause learning two clause
linear recursive program hard learning boolean dnf however several
situations basecase oracle dispensed
case basecase oracle replaced polynomial sized set possible base
clauses learning case enumerate pairs base clauses cbi
starting clauses bottom lrj generalize starting clause forced
simulation mark pair incorrect overgeneralization detected
case basecase oracle replaced fixed rule determines base
clause applicable example consider rule says base clause
applicable atom p x xa xi non null list adopting


fipac learning recursive logic programs efficient

rule leads immediately learning procedure pac learns exactly
two clause linear recursive programs rule correct
case basecase oracle replaced polynomial sized set rules
determining base clause applicable learning case
pick unmarked decision rule run force rule basecase oracle
force returns consistent hypothesis decision rule marked incorrect
one choosen learn two clause linear recursive
programs given decision rules correct
even though general determining basecase decision rule arbitrary
datalog program may dicult may small number decision procedures
apply large number common prolog programs example recursion
list manipulation programs halts argument reduced null list
singleton list thus case seems likely cover large fraction automatic
logic programming programs practical interest
note heuristics proposed finding basecase decision rules
automatically typing restrictions stahl tausend wirth

combining

finally note extensions described compatible means
let kd maxreclang language two clause programs consisting one
clause cr k ary closed recursive depth determinate one clause cb
nonrecursive depth determinate following holds

proposition constants k language family
kd maxreclang db detdec
uniformly identifiable equivalence basecase queries
extensions
notation kd maxreclang may seem point unjustified although

expressive language recursive clauses proven learnable
numerous extensions may eciently learnable example one might generalize
language allow arbitrary number recursive clauses include clauses
determinate generalizations might well pac learnable given
presented far
however companion cohen presents series negative showing
natural generalizations kd maxreclang eciently learnable
kd maxreclang eciently learnable without basecase oracle specifically companion shows eliminating basecase oracle leads
hard learning boolean dnf open computational
learning theory similarly learning two linear recursive clauses simultaneously hard
learning dnf even base case known finally following learning
hard breaking certain presumably secure cryptographic codes learning n


ficohen

linear recursive determinate clauses learning one n ary recursive determinate clause
learning one linear recursive k local clause negative hold
model identification equivalence queries weaker
pac learnability pac predictability

related work
discussing related work concentrate previous formal analyses employ
learning model similar considered namely require computation polynomial natural parameters b assume neutral
source adversarial source examples equivalence queries stochastically presented examples note however much previous formal work exists relies
different assumptions instance much work member subset
queries allowed shapiro de raedt bruynooghe examples
choosen non random manner helpful learner ling de raedt
dzeroski work eciency requirements
imposed pac learnability model relaxed nienhuys cheng polman
requirement eciency relaxed far enough general positive obtained simple learning example model learnability
limit gold language recursively enumerable decidable
includes datalog learned simple enumeration procedure model
u learnability muggleton page language polynomially enumerable
polynomially decidable learned enumeration
similar previous work frazier page b analyze
learnability equivalence queries recursive programs function symbols
without background knowledge positive provide program classes
satisfy following property given set positive examples requires
clauses target program prove instances polynomial number
recursive clauses possible base clause must certain highly constrained
form thus concept class almost bounded size polynomial learning
program class interleave series equivalence queries
test every possible target program contrast positive exponentially
large classes recursive clauses frazier page present series negative
suggesting learnable languages analyzed dicult generalize without
sacrificing ecient learnability
previous exist pac learnability nonrecursive constant depth determinate programs pac learnability recursive constant depth determinate
programs model allows membership subset queries dzeroski et al

basis intelligent search used learning technique
forced simulation method finds least implicant clause c covers
extended instance e although developed method believed
original subsequently discovered case identical technique
previously proposed ling since extended instance e converted
via saturation ground horn clause close connection forced


fipac learning recursive logic programs efficient

simulation recent work inverting implication recursive anti unification
instance muggleton describes nondeterministic procedure finding clauses
imply clause c idestam almquist describes means constraining
implicant generating procedure produce least common implicant two clauses
however techniques obvious applications learning
extremely expensive worst case
crustacean system aha et al uses inverting implication constrained
settings learn certain restricted classes recursive programs class programs
eciently learned system formally well understood appears
similar classes analyzed frazier page experimental
systems perform well inferring recursive programs use function symbols certain
restricted ways system cannot however make use background knowledge
finally wish direct reader several pieces relevant noted companion exists presents negative learnability
several natural generalizations language kd maxreclang cohen another related investigates learnability non recursive prolog programs cohen
b contains number negative strongly motivate
restriction constant depth determinacy final prior may interest
presents experimental prolog implementation variant force
cohen shows forced simulation basis
learning program outperforms state art heuristic methods foil quinlan quinlan cameron jones learning randomly chosen examples

conclusions
often desirable guarantees correctness program many
plausible contexts would highly desirable automatic programming system
offer formal guarantees correctness topic learnability
recursive logic programs formally well justified specifically
concerned development provably sound ecient
learning recursive logic programs equivalence queries showed one constantdepth determinate closed k ary recursive clause identifiable equivalent queries
implies immediately language learnable valiant model paclearnability showed program consisting one recursive clause
one constant depth determinate nonrecursive clause identifiable equivalence queries
given additional basecase oracle determines positive example covered
non recursive base clause target program alone
obtaining introduced several formal techniques analyzing learnability recursive programs shown soundness
eciency several instances generalization forced simulation method may
applications practical learning systems force compares quite well experimentally modern ilp systems learning restricted class
identify cohen thus sound learning methods force might useful
filter general ilp system foil quinlan quinlan cameronjones alternatively forced simulation could used heuristic programs


ficohen

example although forced simulation programs many recursive clauses nondeterministic hence potentially inecient one could introduce heuristics would make
forced simulation ecient cost completeness
companion cohen shows positive
likely improved eliminating basecase oracle language
learning two recursive clauses simultaneously hard learning dnf learning n
linear recursive determinate clauses one n ary recursive determinate clause one linear
recursive k local clause hard breaking certain cryptographic codes positive negative establish boundaries learnability
recursive programs function free pac learnability model thus
give prescription building formally justified system learning recursive programs
taken together provide upper bounds one hope achieve
ecient formally justified system learns recursive programs random examples
alone

appendix additional proofs

theorem states let dec p r declaration detdec let nr j rj let
x xa distinct variables define clause bottom follows


bottom dec constrain dec deepen ddec p x xa


constants following true

size bottom dec polynomial nr
every depth clause satisfies dec equivalent subclause
bottom dec

proof let us first establish polynomial bound size bottom let c
clause size n number variables c bounded size set ld

bounded

thus clause c
similar argument

nr
z

z

modes tuples input variables

j deepen dec c j n nr



j constrain dec c j n anr



since functions deepen dec constrain dec give outputs polynomially larger size inputs follows composing functions constant
number times done computing bottom constant produce
polynomial increase size
next wish every depth determinate clause c satisfies dec
equivalent subclause bottom let c depth determinate clause


fipac learning recursive logic programs efficient

without loss generality let us assume pair literals li lj body
c mode predicate symbol sequence input variables
given c let us define substitution c follows
initially set
c fx x xa xa g
x xa arguments head bottom x xa
arguments head c
notice variables head bottom distinct mapping
well defined
next examine literals body c left right order
literal l let variables tk input variables literal l
body bottom mode predicate symbol whose input variables
tk r tjc tj modify c follows








c fu u ul ul g
u ul output variables l u ul output variables
l
notice assume c contains one literal l given predc

icate symbol sequence input variables output variables
literals l bottom distinct mapping well defined
easy verify induction length c executing procedure
variable bottom mapped input variable ti least
one l meeting requirements exists thus mapping c onto
variables appearing c
let head bottom consider clause c defined follows
head c
body c contains literals l body bottom
lc body c
l literal equal xi xj xic xjc
claim c subclause bottom equivalent c certainly c
subclause bottom one way see equivalent c consider
clause c substitution c generated follows initially let c c
let c c every literal l equal xi xj body c delete l
ij replace c c ij ij
c finally replace c c
substitution fxi xij xj xij g xij variable previously appearing
assumption made without loss generality since determinate clause c output
variables li lj necessarily bound values hence li lj could unified
together one deleted without changing semantics c
recall function f x onto range x x f x



ficohen

c note c ij refer substitution formed replacing every occurrence
xi xj appearing c xij c semantically equivalent c
operation described equivalent simply resolving possible l body
c clause equal x x
following straightforward verify
c one one mapping
see true notice every pair assignments xi xj
c must literal equal xi xj c hence following process
described assignments xi xj c would eventually
replaced xij xij

c onto variables c
notice c onto variables c every assignment xi c
assignment c right hand side assignment
form xi xij thus c onto variables c
literal l body c iff l c body c
follows definition c fact every literal l
c form equal xi xj corresponding literal c
thus c alphabetic variant c hence equivalent c since c equivalent
c must c equivalent c proves claim

acknowledgements
author wishes thank three anonymous jair reviewers number useful suggestions presentation technical content

references
aha lapointe ling c x matwin inverting implication small
training sets machine learning ecml catania italy springer verlag lecture
notes computer science
angluin queries concept learning machine learning
angluin equivalence queries approximate fingerprints proceedings
workshop computational learning theory santa cruz california
bergadano f gunetti interactive system learn functional logic programs proceedings th international joint conference artificial intelligence chambery france


fipac learning recursive logic programs efficient

biermann inference regular lisp programs examples ieee transactions systems man cybernetics
cohen w w pac learning restricted class recursive logic
programs proceedings tenth national conference artificial intelligence
washington c
cohen w w b pac learning non recursive prolog clauses appear artificial
intelligence
cohen w w c rapid prototyping ilp systems explicit bias proceedings
ijcai workshop inductive logic programming chambery france
cohen w w pac learning nondeterminate clauses proceedings eleventh
national conference artificial intelligence seattle wa
cohen w w pac learning recursive logic programs negative journal
ai
de raedt l bruynooghe interactive concept learning constructive
induction analogy machine learning
de raedt l dzeroski first order jk clausal theories pac learnable
wrobel ed proceedings fourth international workshop inductive
logic programming bad honnef bonn germany
de raedt l lavrac n dzeroski multiple predicate learning proceedings
third international workshop inductive logic programming bled slovenia
dzeroski muggleton russell pac learnability determinate logic
programs proceedings workshop computational learning theory
pittsburgh pennsylvania
frazier page c learnability inductive logic programming
basic techniques proceedings tenth national conference
artificial intelligence washington c
frazier page c b learnability recursive non determinate theories
basic techniques proceedings third international workshop
inductive logic programming bled slovenia
gold language identification limit information control
hirsh h polynomial time learning version spaces proceedings tenth
national conference artificial intelligence san jose california mit press
idestam almquist p generalization implication recursive anti unification
proceedings ninth international conference machine learning amherst
massachusetts morgan kaufmann


ficohen

king r muggleton lewis r sternberg j e drug design
machine learning use inductive logic programming model structureactivity relationships trimethoprim analogues binding dihydrofolate reductase
proceedings national academy science
lavrac n dzeroski background knowledge declarative bias inductive
concept learning jantke k p ed analogical inductive inference international workshop aii springer verlag daghstuhl castle germany lectures
artificial intelligence series
ling c inventing necessary theoretical terms scientific discovery inductive
logic programming tech rep university western ontario
ling c logic program synthesis good examples inductive logic programming academic press
lloyd j w foundations logic programming second edition springer verlag
muggleton inverting implication appear artificial intelligence
muggleton de raedt l inductive logic programming theory methods
journal logic programming
muggleton feng c ecient induction logic programs inductive logic
programming academic press
muggleton king r sternberg j e protein secondary structure
prediction logic machine learning protein engineering
muggleton page c learnability model universal representations
wrobel ed proceedings fourth international workshop inductive
logic programming bad honnef bonn germany
muggleton h ed inductive logic programming academic press
nienhuys cheng polman sample pac learnability model inference
machine learning ecml catania italy springer verlag lecture notes
computer science
page c frisch generalization learnability study constrained
atoms inductive logic programming academic press
pazzani kibler utility knowledge inductive learning machine
learning
quinlan j r cameron jones r foil midterm report brazdil p b
ed machine learning ecml vienna austria springer verlag lecture notes
computer science
quinlan j r learning logical definitions relations machine learning


fipac learning recursive logic programs efficient

quinlan j r determinate literals inductive logic programming proceedings
eighth international workshop machine learning ithaca york morgan
kaufmann
rouveirol c flattening saturation two representation changes generalization machine learning
shapiro e algorithmic program debugging mit press
srinivasan muggleton h king r sternberg j e mutagenesis
ilp experiments non determinate biological domain wrobel ed proceedings fourth international workshop inductive logic programming bad
honnef bonn germany
stahl tausend b wirth r two methods improving inductive logic
programming proceedings european conference machine learning
vienna austria
summers p methodology lisp program construction examples
journal association computing machinery
valiant l g theory learnable communications acm
zelle j mooney r j inducing deterministic prolog parsers treebanks
machine learning proceedings twelfth national conference
artificial intelligence seattle washington mit press




