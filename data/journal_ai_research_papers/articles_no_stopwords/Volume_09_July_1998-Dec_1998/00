journal artificial intelligence

submitted published

computational complexity probabilistic
michael l littman

mlittman cs duke edu

department computer science duke university
durham nc usa

judy goldsmith

goldsmit cs engr uky edu

martin mundhenk

mundhenk ti uni trier de

department computer science university kentucky
lexington ky usa
fb theoretische informatik universitat trier
trier germany

abstract
examine computational complexity testing finding small plans probabilistic domains propositional representations complexity
plan evaluation existence varies plan type sought examine totally
ordered plans acyclic plans looping plans partially ordered plans three
natural definitions plan value interest complete
variety complexity classes pl p np co np pp nppp co nppp pspace
process proving certain complete nppp introduce
basic nppp complete e majsat generalizes standard boolean
satisfiability computations involving probabilistic quantities suggest
development good heuristics e majsat could important creation
ecient wide variety

introduction
recent work artificial intelligence addressed finding effective plans domains operators probabilistic effects drummond bresina
mansell draper hanks weld koenig simmons goldman
boddy kushmerick hanks weld boutilier dearden goldszmidt
dearden boutilier kaelbling littman cassandra boutilier dean
hanks effective successful plan one reaches goal state
sucient probability probabilistic propositional operators specified
bayes network extended strips notation planner seeks recipe
choosing operators achieve goal configuration user specified probability
closely related solving markov decision process puterman
expressed compact representation
previous work goldsmith lusena mundhenk littman examined complexity determining whether effective plan exists completely observable
domains exp complete general form pspace complete limited polynomial depth plans polynomial depth polynomial horizon plan one
takes polynomial number actions terminating
c ai access foundation morgan kaufmann publishers rights reserved

filittman goldsmith mundhenk

plans permitted arbitrarily large objects restriction valid plan
need sort compact polynomial size representation
place restrictions size valid plans earlier
directly applicable finding valid plans possible example
given domain valid plans require exponential space exponential
time write knowing whether plans exist simply important
intractable express
present consider complexity practical realistic
determining whether plan exists given restricted form
given restricted size plans consider take several possible forms used
previous work totally ordered plans partially ordered plans totally ordered
conditional plans totally order looping plans cases limit attention
plans expressed size bounded polynomial size specification
way determine plan exists use information
try write reasonable amount time space
deterministic literature several authors addressed computational complexity determining whether valid plan exists determining whether plan
exists given cost finding valid plans variety assumptions chapman bylander erol nau subrahmanian backstrom
backstrom nebel provide lower bounds hardness
analogous probabilistic since deterministic special case
deterministic optimal plans represented simple sequence operators
totally ordered plan probabilistic good conditional plan often perform better totally ordered unconditional plan therefore need consider
complexity process richer set plan structures
ease discussion explicitly describe case completely
observable domains means state world known times
plan execution spite uncertainty state transitions know state
system sucient information choosing actions optimally puterman however
representing universal plan often impractical propositional domains
size state space exponential size domain representation
reason consider types plan structures simple finite state machines
type plans consider necessarily use full state system
make every decision carry partially observable domains although
explore fact detail present work
computational look complete variety complexity classes
ranging pl probabilistic logspace pspace two deserving special
mention concern closely related ones actively addressed
artificial intelligence researchers first evaluating totally ordered plan
compactly represented domain pp complete compactly represented
class pp closely related somewhat familiar p toda showed p p ppp
roughly speaking means p pp equally powerful used oracles counting
class p already recognized artificial intelligence community important complexity
class computations involving probabilistic quantities belief network inference roth



ficomplexity probabilistic

domain one described two stage temporal bayes network boutilier
et al similar notation
second determining whether valid totally ordered plan exists
compactly represented domain nppp complete whereas class np
thought set solvable guessing answer checking polynomial time class nppp thought set solvable guessing
answer checking probabilistic polynomial time pp computation likely
nppp characterizes many interest area uncertainty artificial
intelligence earlier work goldsmith et al mundhenk goldsmith
allender mundhenk goldsmith lusena allender b give initial evidence


domain representations
probabilistic domain hs gi characterized finite set states
initial state finite set operators actions set goal states
g application action state probabilistic transition

state according probability transition function
probability state reached state action taken objective
choose actions one another move initial state one goal states
probability threshold state system known times
fully observable used choose action apply
concerned two main representations domains representations enumerate states explicitly propositional representations sometimes
called compact structured factored representations view states assignments
set boolean state variables propositions propositional representations represent many domains exponentially compactly representations
representation transition function represented collection
jsj jsj matrices one action propositional representation type
jsj jsj matrix would huge transition function must expressed another way
probabilistic literature two popular representations propositional domains probabilistic state space operators psos kushmerick et al
two stage temporal bayes networks tbns boutilier et al although representations differ type domains express naturally boutilier et al
computationally equivalent domain expressed one representation converted polynomial time equivalent domain expressed
polynomial increase representation size littman
work focus propositional representation called sequential effectstree representation st littman syntactic variant tbns
conditional probability tables represented trees boutilier et al representation equivalent tbns psos simplifies presentation
possible formulate objective one maximizing expected total discounted reward boutilier et al two formulations essentially polynomially equivalent condon diculty compactly represented domains may require discount factors
exponentially close one equivalence hold discussed section
assume number bits used represent individual probability values large



filittman goldsmith mundhenk

st effect action proposition represented separate decision
tree given action set decision trees different propositions ordered
decision tree one proposition refer old values previous propositions allows st represent probability distribution leaves
decision tree describe associated proposition changes function state
action perhaps probabilistically section gives simple example representation
propositional representations states set goal states g
explicitly enumerated st instead define goal set set propositions
state goal set propositions true considered goal state
set actions explicitly enumerated st representation
st representation domain hs gi defined
formally hp g use blackboard bold font stand st representation domain p finite set distinct propositions set states
power set p propositions said true set p
initial state set g goal set set goal states g set states
g
transition function represented function maps action
ordered sequence jpj binary decision trees decision trees
distinct label proposition decision propositions nodes optionally labeled
sux probabilities leaves ith decision tree action
defines transition probabilities follows ith decision tree let pi
label proposition define value leaf node found traversing decision
tree taking left branch decision proposition decision
proposition sux right branch otherwise finally let

pi



otherwise


definition constitutes well defined probability distribution

insure validity representation allow p appear
decision proposition p label proposition decision tree j
j reason order decision trees significant put
another way proposition value value defined
decision tree
complexity derive st apply psos tbns computationally equivalent representations hold succinct representation
propositional representation popular complexity theory literature captures
set transition matrices function commonly represented boolean circuit
computes function st straightforwardly represented boolean circuit
proof theorem represent particular boolean circuits
st thus although shown succinct representation formally equivalent st two representations closely related proofs give st need
changed slightly work succinct representation goldsmith littman
mundhenk b mundhenk et al b require restrict
succinct representation generate transition probabilities polynomial


ficomplexity probabilistic

number bits may different circuit representations
represent probabilities exponential number bits mundhenk et al

example domain

help make domain representation ideas concrete present following
simple probabilistic domain building sand castle
beach total four states domain described combinations two
boolean propositions moat castle propositions appear boldface proposition
moat signifies moat dug sand proposition castle signifies
castle built initial state moat castle false
goal set fcastleg
two actions dig moat erect castle actions appear sans serif figure
illustrates actions st executing dig moat moat false causes moat
become true probability moat already true dig moat leaves unchanged
castle proposition affected dig moat action depicted left half
figure
second action erect castle appears right half figure decision
trees numbered allow sequential dependencies effects expressed
first decision tree castle change value already true
erect castle executed otherwise probability becomes true dependent
whether moat true castle built probability moat true
probability idea building moat first protects castle
destroyed prematurely ocean waves
second decision tree proposition moat erect castle cannot make
moat become true effect moat false hand moat
exists may collapse trying erect castle label castle
diagram refers value castle proposition first decision tree evaluated
castle already built erect castle selected moat remains built
probability castle built erect castle successfully builds moat
remains true finally erect castle fails make castle true moat becomes false
probability everything destroyed
note given st representation domain perform number useful
operations eciently first given state action generate next state
proper probabilities accomplished calculating value propositions
one time order given representation ipping coins
probabilities given leaves decision trees second given state action
state compute probability state reached state
action taken via equation

plan types representations

consider four classes plans probabilistic domains totally ordered plans
basic type finite sequence actions must executed order
type plan ignores state system acyclic plans generalize totally ordered plans
include conditional execution actions partially ordered plans different way


filittman goldsmith mundhenk

dig moat
moat

castle

moat



erect castle
castle

castle
f






moat

castle
f







moat
f



moat

f

castle



f









f



castle


f





figure sequential effects tree st representation sand castle domain
generalizing totally ordered plans precise sequence left exible mcallester
rosenblitt looping plans generalize acyclic plans case plan steps
repeated smith williamson lin dean type plan
referred plan graph policy graph kaelbling et al
following sections prove computational complexity concerning
plan types remainder section provides formal definitions plan
types illustrated figure examples sand castle domain
general form plan policy controller transducer program
outputs actions takes input information outcome actions
work consider particularly restricted finite state controller plan representation
plan p domain hs gi represented structure
v v e consisting directed multi graph v e initial node v v
labeling v plan nodes called plan steps domain actions labeling
edges state sets e p every v v outgoing edges


v v v v e v v v v v v v v v v v plan
steps outgoing edges terminal steps actions terminal
steps executed note function represented direct manner
domains propositional domains compact representation needed
assume propositional domains edge labels given conjunctions literals
behavior plan p domain follows initial time step time
step domain state st plan step vt defined
domain v plan action vt executed resulting transition domain state
st probability st vt st plan step vt chosen st vt vt
function tells plan go next point time step index
incremented process repeats continues terminal step reached
plan
one understand behavior domain plan p several different ways
possible sequences states viewed tree node tree
depth state reachable initial state time step alternatively one view
state time step plan p probability distribution time






ficomplexity probabilistic

step probability process state probability state
time step pr sum probabilities length paths
e

x




st st j

sj aj sj



aj action selected plan p time j given observed sequence state
transitions sj view useful later proofs
next formalize probability domain reaches goal state plan p
need introduce several notions legal sequence states steps applied
called trajectory e p sequence h si vi iki pairs

si vi si k
si vi vi k
v vk terminal steps
goal trajectory trajectory ends goal state sk g note
goal trajectory finite q thus calculate probability goal trajectory
v given g probability
h si vi iki pr ki


k
reaches goal state plan p sum probabilities goal trajectories

x
pr reaches goal state p
pr
goal trajectory

call value plan
characterize plan p v v e basis size structure
underlying graph v e graph v e contains cycles call acyclic plan
otherwise looping plan follows acyclic plan terminal step
terminal step reached jv j actions taken plans
used finite horizon control totally ordered plan sometimes called linear
plan straight line plan acyclic plan one outgoing edge
node v plan simple path
work consider partially ordered plans sometimes called nonlinear
plans express entire family totally ordered plans representation steps
plan given partial order specified example directed acyclic graph
partial order represents set totally ordered plans totally ordered sequences
plan steps consistent partial order consist steps partially ordered
plan totally ordered plans value values need
choice defining value partially ordered plan
work consider optimistic pessimistic average interpretations let
p
set totally ordered sequences consistent partial order plan p optimistic
interpretation
value p max pr reaches goal state p
p
p



filittman goldsmith mundhenk

pessimistic interpretation
value p min pr reaches goal state p
p
p

average interpretation
x
pr reaches goal state p
value p j
p j
p
p
illustrate notions figure gives plans type sand castle domain
described earlier initial nodes marked incoming arrow terminal steps
represented filled circles step totally ordered plan figure successfully
builds sand castle probability acyclic plan given figure b
succeeds probability executes dig moat average times note
succeeds often fewer actions average totally ordered plan
figure
figure c illustrates partially ordered plan sand castle domain
plan bears superficial resemblance acyclic plan figure b different
interpretation particular plan figure c represents set totally ordered plans
five non terminal plan steps dig moat steps erect castle steps contrast
solid arrows figure b indicate ow control dashed arrows
figure c represent ordering constraints erect castle step must preceded
least two dig moat steps example
although distinct ways arranging five plan steps figure c totally ordered plan two distinct totally ordered plans consistent
ordering constraints
dig moat dig moat dig moat erect castle erect castle

success probability

dig moat dig moat erect castle dig moat erect castle

success probability thus optimistic success probability partially
ordered plan pessimistic note pessimistic interpretation closely related standard interpretation deterministic partial order mcallester rosenblitt partially ordered plan considered successful consistent totally ordered plans successful average success
probability orderings yield poorer plan
described yield better one
looping plan figure terminate succeeds building sand
castle probability eventually course looping plans
succeed probability totally ordered plan figure acyclic plan
figure b special cases looping plans instance
define jp j size plan p number steps contains define jm j
size domain sum number actions states domain
sum sizes st decision trees propositional domain


ficomplexity probabilistic

dig moat

dig moat

erect castle

dig moat

erect castle

dig moat

erect castle

dig moat

totally ordered plan

c partially ordered plan
moat
dig moat

moat
dig moat

moat

dig moat

erect castle

moat

moat castle

moat

moat
dig moat

castle
erect castle

b acyclic conditional plan
moat castle
looping plan

figure example plans sand castle domain
consider following decision plan evaluation asks given
domain plan p size jp j jm j threshold whether value greater
e whether
pr reaches goal state p
note condition jp j jm j technical one simply want use jm j
represent size given instance jp j larger jm j
simply imagine padding jm j make larger important thing
considering plans roughly size description domain
size number states might considerably larger
plan existence asks given domain threshold size bound z jm j
whether exists plan p size z value greater note
bound size target plan complexity plan generation
plan existence technique self reduction used construct valid plan
polynomially many calls oracle decision
decision different version type domain
propositional type plan category looping acyclic totally ordered
partially ordered three interpretations address
succeeding sections

complexity classes

definitions complexity classes reductions standard complexity
theory refer reader papadimitriou
brie looking complexity decision yes
answers class p consists decided polynomial time
given instance program deciding whether answer yes
runs polynomial time class np contains polynomialtime checkable polynomial size certificates given instance certificate
checked time polynomial size instance whether certificate proves
instance np set means answer instance yes


filittman goldsmith mundhenk

shown polynomial time given right key class co np opposite
answer shown polynomial time given right key
x c hard complexity class c every c reduced
put another way fast x used subroutine solve
c quickly c complete c hard c
hardest class
interest complete next give detailed descriptions less
familiar probabilistic counting complexity classes use work
class l lvarez jenner class functions f
nondeterministic logarithmically space bounded machine n number accepting paths
n x equals f x class p defined analogously class functions f
nondeterministic polynomial time bounded machine n number
accepting paths n x equals f x typical complete computing
determinant l computing permanent p
function f defined gapl difference f g h l functions g
h l functions nonnegative integer values definition gapl functions
may negative integer values example g returns zero
probabilistic logspace gill pl class sets exists
nondeterministic logarithmically space bounded machine n x
number accepting paths n x greater number rejecting paths
original definition pl time bound computations borodin cook
pippenger later showed pl p jung proved set computable
probabilistic logspace computable probabilistic logspace pl machine
simultaneous polynomial time bound apparent contrast p complete sets sets pl
decidable fast parallel computations borodin et al
probabilistic polynomial time pp defined analogously classic pp complete majsat given boolean formula conjunctive normal form cnf
majority assignments satisfy according balcazar daz gabarro
pp completeness majsat shown combination gill
simon
polynomial space bounded computations pspace equals probabilistic pspace
pspace class polynomial space computable functions ladner

note l nl l pl gapl logarithmic space p np p pp
gapp polynomial time notion completeness use relies
many one reductions case pl reduction functions logarithmic space
case np polynomial time
complexity classes c c class c c consists sets c turing
reducible sets c e sets accepted resource bounds specified c
c subroutine oracle instantaneous output class
c pspace case npc pspace therefore nppspace pspace
primary oracle defined class consider nppp equals np
closure
pp toran seen closure pp polynomial time disjunctive reducibility exponential number queries queries computable
polynomial time index list queries simplify completeness




ficomplexity probabilistic

class introduce decision call e majsat exists majsat
generalizes standard np complete satisfiability pp complete majsat
e majsat instance defined cnf boolean formula n boolean variables
x xn number k n task decide whether
initial partial assignment variables x xk majority assignments
extend partial assignment satisfies prove nppp complete
appendix
complexity classes consider satisfy following containment properties
relations well known classes
np pp nppp pspace exp
l nl pl p co np
co nppp
p properly contained exp exp complete provably intractable
classes may equal p although generally believed case
several observations worth making known ph nppp
ph represents polynomial hierarchy crude sense ph close pspace
thus nppp completeness place important close pspace
however early empirical littman b random instances pp similar properties random instances np suggesting
pp might close enough np np type heuristics effective

summary

tables summarize explained detail later sections
general avor main techniques conveyed follows
plan evaluation particular complexity class c take
cross product steps plan states domain look
complexity evaluating absorption probability resulting markov chain e
directed graph probability labeled edges complexity corresponding planexistence bounded npc solved guessing
correct plan non deterministically evaluating many cases npc complete appropriate complexity class c depends primarily representation
cross product markov chain
exceptions basic pattern partially ordered plans section
appear require distinct set techniques
worth noting although propositional domains exponentially
compact domains computational complexity solving propositional domains exponentially greater one instance evaluating partially
ordered plans average interpretation complexity actually
propositional domains
prove concerning plan evaluation existence compactly represented
plans pp complete nppp complete corollary plan existence large enough
looping plans domains p complete theorem plan evaluation existence
looping plans deterministic propositional domains pspace complete theorems
plan existence polynomial size looping plans partially observable domains
np complete section


filittman goldsmith mundhenk

plan type
plan evaluation plan existence
unrestricted

p complete
polynomial depth

p complete
looping
pl complete
np complete
acyclic
pl complete
np complete
totally ordered
pl complete
np complete
partially ordered optimistic
np complete
np complete
partially ordered average
pp complete
np complete
partially ordered pessimistic co np complete
np complete

reference
p
p
section
section
section
section
section
section

table complexity representations p papadimitriou
tsitsiklis

plan type
plan evaluation plan existence reference
unrestricted

exp complete littman
polynomial depth

pspace complete littman
looping
pspace complete pspace complete section
acyclic
pp complete
nppp complete section
totally ordered
pp complete
nppp complete section
pp
partially ordered optimistic
np complete
nppp complete section
partially ordered average
pp complete
nppp complete section
pp
partially ordered pessimistic co np complete nppp complete section
table complexity propositional representations



ficomplexity probabilistic

acyclic plans

section treat complexity generating evaluating acyclic totally
ordered plans

theorem plan evaluation acyclic totally ordered plans domains pl complete

proof first pl hardness totally ordered plans jung proved
set pl exists logarithmically space bounded polynomially
time bounded nondeterministic turing machine n following property every
input x machine n must least half computations input x accepting
x machine n transformed probabilistic turing
machine r input x probability r x accepts x equals
fraction computations n x accepted given r domain
described follows state set set configurations r input x note
configuration consists contents logarithmically space bounded tape
state location read write heads one symbol input output
tapes thus configuration represented logarithmically many bits
polynomially many configurations state transition probabilities
unique action configuration transition probabilities r states
obtained accepting configurations goal states totally ordered plan consists
step counter r input x plan steps takes action
probability domain plan reaches goal state exactly
probability r x reaches accepting configuration thus evaluating totally
ordered plan pl hard
since totally ordered plans acyclic plans proves pl hardness planevaluation acyclic plans
next plan evaluation pl acyclic plans let
hs gi domain let p hv v e acyclic plan let
threshold given question whether probability p
reaches goal state probability greater equivalently transformed
question whether gapl function greater transformation done
logarithmic space shown allender ogihara follows question
pl
first construct markov chain c p simulates execution
evaluation p note markov chain seen probabilistic
domain one action set actions since choice actions
mention construction state space c v initial state
v set goal states g v transition probabilities tc c

v v v

tc v v
v terminal step node v v

otherwise
let number plan steps p e jv j number nodes graph
representing p since states c contain terminal step p sinks c follows


filittman goldsmith mundhenk


pr reaches goal state p pr c reaches goal state exactly steps
let
pc pr c reaches goal state exactly steps initial state
pc v probability want calculate standard inductive definition pc used evaluate plans dynamic programming

goal state c
pc ifotherwise
x
pc k
tc pc k k
sv


let h maximum length representation state transition probability tc


goal state c
ph otherwise
x h
ph k
tc ph k k
sv


follows pc v ph v hm note ph v integer
value therefore pc v ph v b hm c order
pc v decidable pl suces ph v
gapl therefore unwind inductive definition ph let integer
matrix obtained tc tc h introduce integer valued
ph composed gapl functions compositions gapl
closed tc integer valued cannot used write


ph

x

sv

ph




argue ph gapl entry logspace computable domain plan p therefore powers matrix gapl shown
vinay gapl closed multiplication summation polynomially
many summands follows ph gapl finally use closure properties gapl
allender ogihara since gapl closed subtraction follows
plan evaluation acyclic plans pl
totally ordered plans acyclic plans plan evaluation totally
ordered plans pl


technique forming markov chain taking cross product domain
plan useful later plan existence require different set techniques

theorem plan existence acyclic totally ordered plans domains np complete



ficomplexity probabilistic

proof first containment np given domain threshold
size bound z jm j guess plan correct form size z accept

reaches goal state probability greater plan note
checking whether plan correct form done polynomial time
plan evaluation pl theorem follows plan existence
np e nppl np
np hardness plan existence give reduction
np complete satisfiability boolean formulae conjunctive normal form
construct domain evaluates boolean formula n variables
n step plan describes assignment values variables first step
clause chosen randomly step domain checks whether plan
satisfies appearance variable clause clause marked satisfied
n steps literal satisfied clause goal state reached
clause otherwise transition made goal state therefore goal
state reached probability greater clauses
satisfied plan describes satisfying assignment
formally define reduction similar one presented papadimitriou
tsitsiklis let cnf formula n variables x xn clauses
c cm let sign appearance variable clause variable
negated otherwise define domain hs gi



g

fsat j unsat j j n j mg fs sacc srejg
fassign b j n b f gg fstart endg
fsacc g



start unsat j j



start srej





unsat j assign b sat j n




xi appears cj sign b








unsat j assign b unsat j n




xi appear cj sign b








unsat j assign b start end




srej n b f g
ss
unsat n j srej




sat j assign b sat j n




sat j assign b start end




srej n




sat n j end sacc




sat n j end srej




srej sacc


ifotherwise
meaning states domain follows domain state
sat j n j means formula satisfied
currently checking variable clause j state sat n j j means
finished verifying clause j satisfied meanings similar


filittman goldsmith mundhenk



start



unsat

assign

assign

sat

assign x





start

assign



sat

assign

sat

assign x

sat

unsat

end

end

sacc

unsat

assign x

unsat

assign x

assign

sat

unsat

assign

unsat



unsat

assign
sat

end

assign



unsat

end

srej

figure domain generated boolean formula x x x x
unsat states course initial state sacc srej accepting
rejecting states respectively
actions domain start end mark beginning end
assignment assign b n b f g assign truth value b
variable figure gives domain generated reduction simple boolean
formula description reduction computed time
polynomial jj
construction z n step plan p reach goal state sacc
p form
start assign b assign b assign n bn end
p reaches sacc probability b bn satisfying assignment
n variables shows boolean satisfiability polynomial time reduces
plan existence totally ordered acyclic plans showing np hard
note bound plan depth horizon instead plan size planexistence acyclic plans domains p complete goldsmith et al
papadimitriou tsitsiklis limiting plan size makes dicult
possible force planner take action different states
figuring without sacrificing plan quality challenging
propositional domains plan evaluation harder large number states

theorem plan evaluation acyclic totally ordered plans propositional domains pp complete

proof pp hardness totally ordered plans give reduction

pp complete majsat given cnf boolean formula majority
assignments satisfy


ficomplexity probabilistic

evaluate
xi


xi







n clause
xa


f

xb




















xbm

clause





xcm






f

f





n done

done


f



f

n satisfied

xam



xc

xd



n clausem

f



n xi





f


f

clause






f




clausem

f







f




figure sequential effects tree representation evaluate
given construct domain step plan plan
achieves goal probability greater majority
assignments satisfies domain consists single action evaluate
step plan evaluated n propositions
x xn correspond n variables clause clausem
correspond clauses satisfied sole element goal set
done insures evaluate executed important
domain used later theorem complexity plan existence initial
state propositions false
evaluate action generates random assignment variables evaluates
clauses clausei true literals ith clause true evaluates entire
formula satisfied true clauses true figure gives st representation
evaluate xa xb represent variables clause
construction majsat reaches goal state probability
greater plan consisting single action evaluate
next membership pp acyclic plans showing
domain acyclic plan p induce computation tree consisting
paths p evaluating computation tree accomplished pp
machine
let b bound number bits used specify probabilities leaves
decision trees representing consider computation tree defined follows root
labeled hs v domain probability reaching state




represent numbers polynomial precision binary representation principle could introduce
round errors specified form



filittman goldsmith mundhenk

given action v equal hs v b children labeled hs v
identically labeled child nodes independent defined identically
others thus number paths given set labels corresponds probability
trajectory domain plan multiplied b h h depth
plan
number accepting computations therefore b h
probability achieving goal note b inherent
domain rather h pp machine accepts half final states
accepting necessary pad computation tree introducing
dummy branches accept reject right proportions
plan existence essentially equivalent guessing evaluating valid
plan

theorem plan existence acyclic totally ordered plans propositional domains nppp complete

proof containment nppp totally ordered acyclic plans follows

fact polynomial size plan guessed polynomial time checked pp
theorem
hardness nppp totally ordered acyclic plans shown
reduction e majsat shown nppp hard appendix reduction echoes
one used pp hardness argument proof theorem
given cnf boolean formula variables x xn number k construct
domain k plan exists reach goal probability
greater assignment variables x xk
majority assignments remaining variables satisfies domain
k consists action evaluate theorem one action set xi
first k variables proof theorem n propositions
k initially false x xn correspond n variables clause
clausem correspond clauses satisfied done
insures evaluate executed goal set contains satisfied done
k action set xi makes proposition xi true analogously theorem
evaluate action generates random assignment remaining variables evaluates
clauses clausei true literals clause true evaluates
entire formula satisfied true clauses true sets done true done
true action make satisfied true
pair k e majsat exists assignment b bk first k
variables majority assignments rest variables satisfies
therefore plan applying steps set xi bi followed evaluate action
reaches goal state probability greater
conversely assume k totally ordered plan p reaches goal state
probability greater since evaluate action action setting done
true since action reaches goal done set true assume without
loss generality p consists sequence steps set xi ends evaluate
construction assignment x xk assigning exactly variables set p


ficomplexity probabilistic

assignment majority assignments rest variables
satisfies therefore k e majsat
since every totally ordered plan acyclic hardness holds acyclic plans
consider compactly represented propositional
domains plans compactly represented plans quite useful
compact acyclic plan acyclic plan names plan steps
encoded set propositional variables step transition function
plan steps represented set decision trees st
require plan depth polynomial size representation
even though total number steps plan might exponential due
logarithmic succinctness encodings
plan domain cross product technique used proof theorem generalizes compact acyclic plans complexity apply holds true
probabilistic acyclic plan acyclic plan make random transitions
plan steps e step transition function stochastic insights
combined yield following corollary theorems

corollary plan evaluation compact probabilistic acyclic plans propositional domains pp complete plan existence compact probabilistic
acyclic plans propositional domains nppp complete

mention probabilistic plans two reasons first behavior structures partially ordered plan evaluation average interpretation
discussed section thought generating probabilistic plans second
many instances simple probabilistic plans perform nearly well much larger
complicated deterministic plans notion often exploited field randomized work platzman described lovejoy shows
idea randomized plans come handy partially observable domains

looping plans

looping plans applied infinite horizon control complexity plan existence
plan evaluation domains theorems depend presence
absence loops plan

theorem plan evaluation looping plans domains pl complete
proof given domain looping plan p construct product markov

chain c proof theorem proof theorem allender
ogihara chain constructed exactly one accepting
exactly one rejecting state states absorbing probability
reaches goal state p equals probability c reaches accepting state
started initial state product initial states p


filittman goldsmith mundhenk

proof theorem allender ogihara shown construction
markov chain computation whether reaches final state probability
greater performed pl
pl hardness implied theorem since acyclic plans special case looping
plans

theorem plan existence looping plans domains np complete

general p complete size desired plan least size state
action space e z min jsj jaj

proof sketch np completeness follows proof theorem containment

hardness still hold plans permitted looping
however true forced specify plan whose size small
respect size domain looping plan allowed number states
least large number states actions domain
solved polynomial time
known markov decision processes maximum probability
reaching goal state equals maximum probability reaching goal state
infinite horizon stationary policy stationary policy mapping states
actions used repeatedly choose actions time step known
optimal stationary policy computed polynomial time via linear programming condon stationary policy domain hs g ti
written looping plan although course looping plans correspond stationary
policies
fixed stationary policy p two simple ways
looping plan p v v e represented first let v v p v v
v v fs j p v g follows whenever reaches state
action applied according looping plan according p
second let v v v p v v v fv g follows whenever
reaches state plan node corresponding state therefore
appropriate action state applied looping plan therefore
maximum probability reaching goal state obtained looping
plans
since best stationary policy computed polynomial time best looping
plan computed polynomial time p hardness follows theorem
papadimitriou tsitsiklis
propositional domains complexity plan existence plan evaluation looping
plans quite different acyclic case looping plan evaluation hard

theorem plan evaluation looping plans deterministic stochastic propositional domains pspace complete

proof recall plan evaluation domains pl theorem

domain cn states representation size n looping plan


ficomplexity probabilistic

evaluated probabilistic space log cn theorem say probabilistic
space polynomial size input follows st representation
domain used compute entries transition function polynomial space
since probabilistic pspace equals pspace shows plan evaluation
looping plans stochastic propositional domains pspace
remains pspace hardness deterministic propositional domains let n
deterministic polynomial space bounded turing machine moment moment
computation state configuration n expressed polynomial length bit string
encodes contents turing machine tape location read write head
state n finite state controller whether machine accepting
state
input x describe construct polynomial time deterministic domain x single action looping plan reaches goal state x
x accepted turing machine n
given description n x one time polynomial size descriptions
n x produce description turing machine computes transition
function n words input c configuration n outputs next
configuration n fact even check whether c valid configuration
computation n x simulating computation argument similar
used cook theorem modeled polynomial size circuit circuit takes
input bit string describing current configuration n outputs next
configuration
next argue computation circuit expressed action compute st representation one proposition x bit configuration
plus one gate circuit three standard gates
easily represented decision trees ordering decision trees compute according topological sort gates circuit single compute action compute
precisely output circuit figure illustrates conversion simple
circuit gives form gates
describe complete reduction domain x consists
single action compute set propositions described previous paragraph
initial state initial configuration turing machine n goal set
proposition corresponding whether configuration accepting state n
transitions deterministic one action chosen follows
goal state reached probability greater example
plan repeatedly chooses compute accepting state reached
polynomial space machine n input x accepts
similar argument shows looping plan existence actually harder
looping plan evaluation

theorem plan existence looping plans deterministic stochastic propositional domains pspace complete


filittman goldsmith mundhenk

compute




c
c

c








c







c

f

c









f

c



f





f







c
c






c


f





c


c

c


f





c






f





f







f




f


figure circuit representation sequential effects tree

proof hardness pspace follows construction proof

theorem one step looping plan successful plan yields
better
recall interested determining whether plan size z
z bounded size domain reaches goal given probability
pspace plan guessed polynomial time checked
pspace theorem nppspace pspace follows
mentioned earlier unrestricted infinite horizon plan existence
exp complete littman shows determining unrestricted plan
existence exp hard domains require plans larger polynomialsize looping plans
theorem shows pspace completeness determining plan existence deterministic domains closely related pspace completeness bylander main difference two theorem applies
compact plans polynomial instead exponential complex operator descriptions conditional effects instead preconditions add delete lists
include loops proofs pspace hardness retained even domains one action looping makes looping plans hard
work

partially ordered plans
partially ordered plans popular representation allow
defer precise commitment ordering plan steps becomes necessary


ficomplexity probabilistic

process k step partially ordered plan corresponds set k step totally
ordered plans consistent given partial order evaluation
partially ordered plan defined evaluation best worst average
member set consistent totally ordered plans optimistic pessimistic
average interpretations respectively
plan evaluation partially ordered plans different totally
ordered plans single partial order encode totally ordered plans
hence evaluating partially ordered plan involves figuring best case optimistic
interpretation worst pessimistic interpretation member average
average interpretation combinatorial set

theorem plan evaluation partially ordered plans domains
np complete optimistic interpretation
proof sketch membership np follows fact guess totally

ordered plan consistent given partial order accept domain
reaches goal state probability remember evaluation
performed pl theorem therefore deterministically polynomial time
hardness proof variation construction used theorem partiallyordered plan evaluate form given figure consistent total orders
form
start assign b assign b assign b assign b

assign n bn assign n bn end
bi possible plans interpreted assignment

n boolean variables ignoring every second assignment action construction
theorem shows turn cnf formula domain
easily modified ignore every second action thus best totally ordered plan
consistent given partially ordered plan reaches goal probability
reaches goal probability greater satisfies
clauses satisfiable

theorem plan evaluation partially ordered plans domains
co np complete pessimistic interpretation

proof sketch proof membership co np proof hardness

similar proof theorem reduction co np complete set
unsatisfiable formulae cnf plan evaluate form given figure
interpreted proof theorem construct domain
take g fsrejg goal states state srej reached probability
greater assignment satisfy one clauses formula
formula unsatisfiable every assignment least one clauses
satisfied therefore probability reaches goal state given
totally ordered plan greater plan corresponds unsatisfying
sat



filittman goldsmith mundhenk

start

assign

assign

assign

assign

assign

assign


assign n

assign n

end

figure partially ordered plan hard evaluate
assignment finally minimum probability consistent partially ordered
plans greater unsatisfiable

theorem plan evaluation partially ordered plans domains

pp complete average interpretation
proof average interpretation must decide whether average evaluation
consistent totally ordered plans greater threshold decided
pp guessing uniformly totally ordered plan checking consistency given
partially ordered plan polynomial time guessed totally ordered plan consistent
evaluated polynomial time theorem accepted rejected appropriate
guessed plan inconsistent computation accepts probability rejects
probability leaving average consistent orderings unchanged
respect threshold
pp hardness shown reduction pp complete majsat let
formula cnf construct domain partially ordered plan
p majsat average performance totally
ordered plan consistent p greater
let consist clauses c cm contain n variables x xn domain
hs gi actions
fassign b j f ng b f gg fstart check endg
action assign b interpreted assign sign b xi partially ordered plan
p plan steps
v f b h j f ng b f g h f mgg fstart check endg
mapping v
fstart check endg b h assign b


ficomplexity probabilistic

order e requires consistent plan start first end last step
steps arbitrarily ordered formally
e f start q j q v fstart endgg f q end j q v fstart endgg
define domain acts given totally ordered plan p consistent
p domain consists cross product following polynomial size
deterministic domains ms final probabilistic transition added
describe ms precisely intuitive definitions domain
ms satisfied plans form assignment n boolean variables
restriction assignment repeated times easy checking domain
satisfied plans correspond satisfying assignments composite
two domains satisfied plans correspond satisfying assignments
define domains formally
first ms checks whether totally ordered plan matches regular expression
start assign jassign
assign n jassign n
check assign jassign assign n jassign n
note constant let good state reached ms plan
matches expression otherwise state reached bad clarify actions check simply use extra steps used specifying assignment
partially ordered plan
next checks whether sequence actions following check action satisfies
clauses following sense let ak sequence interprets
subsequence j n j n al j assign x bl assignment b bn
variables x xn checks whether assignment satisfies clause cj
single clauses satisfied way reaches state satisfied
note ms defined deal final end action
consists product domain ms transitions action end
follows state bad q state q action end lets go
probabilistically state accept state reject probability
state good satisfied action end goes state accept probability
otherwise action end goes state reject probability set goal
states consists state accept
analyze behavior plan p consistent p ms
p reaches state bad p reaches goal state probability
consider plan p ms reaches state good called good plan
p matches regular expression therefore every f mg exists
bi f g steps bi h start check thus steps
check end
n n
consequently sequence actions defined labeling plan steps
assign assign assign n


filittman goldsmith mundhenk

means checks whether clauses satisfied assignment
e checks whether satisfies therefore accepts plan p
probability plan represents satisfying assignment probability otherwise
note assignment corresponds exactly one good plan therefore average
good plans accepts equals fraction satisfying assignments
since accepts bad plans probability yields average
plans consistent p acceptance probabilities greater
majsat
complexity plan existence partially ordered plans identical
totally ordered plans

theorem plan existence partially ordered plans domains npcomplete pessimistic optimistic average interpretations plan existence
partially ordered plans propositional domains nppp complete
pessimistic optimistic average interpretations

proof first note totally ordered plan special type partially ordered plan

evaluation unchanged pessimistic optimistic average interpretation
particular one ordering consistent given totally ordered
plan best worst average orderings therefore exists
totally ordered plan value greater partially ordered plan
value greater plan three interpretations
conversely partially ordered plan value greater
three interpretations totally ordered plan value greater
value best worst average ordering partially ordered
plan lower bound value best consistent totally ordered plan
given strong equivalence complexity plan existence partially ordered
plans direct corollary theorems
pattern partially ordered plan evaluation domains average
interpretation easier decide optimistic pessimistic interpretations
propositional domains pattern opposite average interpretation harder
decide optimistic pessimistic interpretations

theorem plan evaluation partially ordered plans propositional

mains nppp complete optimistic interpretation co nppp complete
pessimistic interpretation pp complete average interpretation

proof sketch optimistic interpretation membership nppp follows

fact guess single suciently good consistent total order evaluate
pp theorem hardness nppp shown straightforward reduction
e majsat proof theorem
pessimistic interpretation membership co nppp follows fact
guess worst consistent total order evaluate pp theorem hardness


ficomplexity probabilistic

co nppp shown reducing co nppp version e majsat e majsat
proof simple adaptation techniques used example theorem
average interpretation shown pp combining
argument proof theorem showing average consistent totally
ordered plans argument proof theorem showing evaluate
plan propositional domain pp alternatively could express evaluation
partially ordered plan average interpretation compact probabilistic acyclic
plan corollary states plans evaluated pp pp hardness follows directly
theorem totally ordered plans special case partially ordered plans
evaluating totally ordered plans pp hard

applications
help illustrate utility section cites several planners
literature analyzes computational complexity attack
give detailed explanations planners refer reader
original papers focus three systems witness brown university
buridan university washington treeplan university british columbia
process making connections planners describe work relates
discounted reward criterion partial observability domain representations partial
order conditional policy approximate

witness

witness cassandra kaelbling littman kaelbling et al
solves partially observable markov decision processes dynamic programming basic finds optimal unrestricted solutions finite horizon
papadimitriou tsitsiklis showed plan existence polynomialhorizon partially observable markov decision processes pspace complete
extension finite horizon kaelbling et al sketch method
finding optimal looping plans domains although presented
formal unreasonable say pure form
extended version witness attacks one finding valid polynomial size looping plan
partially observable domain similarities described
section domains plans identical form
apparent differences witness optimizes reward function instead probability
goal satisfaction witness works partially observable domains whereas
defined terms completely observable domains apparent
differences insignificant however computational complexity point view
first witness attempts maximize expected total discounted reward
infinite horizon sometimes called optimizing time separable value function argued
condon defined terms sum discounted rewards
recast one goal satisfaction argument proceeds roughly follows let
discount factor r immediate reward received taking action
state


filittman goldsmith mundhenk

define

r
r max r ra amin
min r















r value plan
respect revised reward function simple linear transformation true value
introduce auxiliary state g goal state create transition
function g r r
g well defined transition function probability goal satisfaction
plan transition function precisely expected total discounted
reward reward function r transition function thus stated
one optimizing expected total discounted immediate rewards turned
equivalent optimizing goal satisfaction slight change transition
function one additional state means fundamental computational
complexity difference two different types objectives
second apparent difference solved extended witness
described section partial versus complete observability
fact address partial observability albeit indirectly formulation
plan existence plans constrained make conditional branches
totally ordered partially ordered cases branch distinctions made
step transition function acyclic looping cases two choices correspond
unobservable partially observable domains respectively partially observable
domain plan existence becomes one finding valid polynomial size finitestate controller subject given observability constraints nothing complexity
proofs depends presence absence additional observability constraints therefore
direct corollary theorem plan existence polynomial horizon
plans unobservable domains np complete papadimitriou tsitsiklis
theorem plan existence polynomial size looping plans partially
observable domains np complete
interesting note computational complexity searching size bounded
plans partially observable domains generally substantially less solving
corresponding unconstrained partially observable markov decision process example
found plan existence acyclic plans propositional domains
nppp complete theorem corresponding unconstrained determining existence history dependent policy polynomial horizon compactly
represented partially observable markov decision process expspace complete
theorem goldsmith et al theorem mundhenk et al b
gap enormous expspace exp pspace p exp already
provably intractable worst case contrast expspace complete
conceivable good heuristics nppp complete created extensions
recent advances heuristics np complete therefore hope
devising effective building observations
searching optimal size bounded plans instead optimal unrestricted plans fact recent planners propositional domains majercik littman b
domains hansen motivated


ficomplexity probabilistic

domain type

propositional

propositional

horizon type
polynomial
polynomial
infinite
infinite

size bounded plan unrestricted plan
np complete
nppp complete
np complete
pspace complete

pspace complete
expspace complete
undecidable
undecidable

table complexity plan existence partially observable domains
table summarizes complexity partially observable domains
size bounded plans corollaries theorems unrestricted plans due papadimitriou tsitsiklis
polynomial goldsmith et al propositional polynomial hanks
infinite horizon last derived noting isomorphism infinitehorizon emptiness probabilistic finite state automata
undecidable rabin

buridan

buridan planner kushmerick et al finds partially ordered plans propositional domains pso representation two identifiable differences
solved buridan analyzed section representation
fact buridan restricted polynomial size
plans address differences
although surface pso different st converted
polynomial time polynomial increase domain size particular
effect action pso represented single decision tree consisting proposition
nodes st random nodes easily simulated st auxiliary propositions
leaves list propositions become true another list propositions
become false leaf reached type correlated effect easily
represented st chain rule probability theory decompose probability
distribution separate probabilities proposition careful use
sux thus pso domain converted similar size st domain quickly
similarly domain st converted pso polynomial expansion
conversion complex sketch follows proof equivalence st simplified representation called littman given polynomial
equivalence st pso complexity st carry pso
described concern bound given
size plan sought although kushmerick et al explicitly describe
planner one prefers small plans large plans design planner
one searches space plans makes notion plan size central
indeed public domain buridan implementation uses plan size part
best first search procedure identifying suciently successful plan means
things equal shorter plans found larger plans furthermore
assure termination planner considers fixed number plans halting thus
precise true complexity classes closed log space reductions



filittman goldsmith mundhenk

putting limit indirectly maximum allowable plan size although buridan
attempt solve precisely considered fair say
consider idealization attacked buridan regardless
lower bounds complexity apply buridan
kushmerick et al looked generating suciently successful plans
optimistic interpretation pessimistic interpretation explicitly examined plan evaluation partially ordered plans interpretations
therefore theorems apply buridan
sophisticated c buridan planner draper et al extends buridan
plan partially observable domains produce plans conditional execution
work shed light computational complexity addressed
c buridan draper et al devised representation partially ordered acyclic
conditional plans representation plan step generates observation label
function probabilistic outcome step step associated set
context labels dictating circumstances step must executed plan
step executed context labels consistent observation labels produced
earlier steps totally ordered form type plan expressed compact
acyclic plan corollary used plan evaluation plan existence
totally ordered version c buridan conditional plan representation
propositional domains pp complete nppp complete respectively
consider evaluating searching plans partially
ordered plans conditional execution nonetheless
sorts techniques presented applied analyzing
attacked c buridan example consider plan existence c buridan
partially ordered conditional plans optimistic interpretation asks
whether partially ordered conditional plan total order reaches
goal sucient probability equivalent asking whether totally
ordered conditional plan reaches goal sucient probability therefore
nppp complete argument previous paragraph
spite many superficial differences analyzed
studied creators buridan planners quite relevant
understanding work

treeplan
family planners designed generate decision tree representation
stationary policies mappings state action boutilier et al boutilier
poole boutilier dearden probabilistic propositional domains refer
planners collectively treeplan planners planners solve
identical addressed closely
related
planner described boutilier et al finds solutions maximize expected
total discounted reward compactly represented markov decision processes domain
representation used expressively equivalent st mentioned earlier difference
maximizing goal satisfaction maximizing expected total discounted reward


ficomplexity probabilistic

superficial one addressed planner exp complete littman
although policies used boutilier et al appears quite dissimilar finitestate controllers described work policies converted type similarly
sized compact looping plan extension type plan described corollary
conversion stationary policies looping plans described proof
theorem except resulting plans represented compactly
later work boutilier dearden possible limit size
representation policy treeplan still obtain approximately optimal
performance necessary general size decision trees needed
represent optimal policies exponentially large keeping decision trees
getting large resulting planner becomes subject extension theorem
therefore attacks pspace complete
one emphasis boutilier dearden finding approximately optimal
solutions hope easier finding optimal solutions
explore worst case complexity approximation although lusena
goldsmith mundhenk produced strong negative area
related issue one simulation random sampling approximately optimal
solutions probabilistic empirical successes obtained
related reinforcement learning tesauro crites barto
worst case complexity probabilistic known
lower approximation simulation

conclusions
explored computational complexity plan evaluation plan existence probabilistic domains found compactly represented propositional
domains restricting size form policies consideration reduced
computational complexity plan existence exp complete unrestricted plans
pspace complete polynomial size looping plans nppp complete polynomialsize acyclic plans contrast domains restricting form policies
consideration increased computational complexity plan existence p complete
unrestricted plans np complete totally ordered plans plan
smaller domain operates often unable exploit important markov
properties domain able characterize precisely complexity
examined regard current state knowledge complexity theory
several studied turned nppp complete class nppp promises
useful researchers uncertainty artificial intelligence captures
type resulting choosing guessing solution evaluating
probabilistic behavior precisely type faced
probabilistic domains captures important domains well
constructing explanations belief networks designing robust communication networks
provide conceptually simple nppp complete e majsat may
useful explorations direction
basic structure plan evaluation complete class c
plan existence typically npc complete basic structure holds determin

filittman goldsmith mundhenk

istic domains evaluating totally ordered plan propositional domain p complete
suciently powerful domain representations determining existence polynomialsize totally ordered plan npp np complete
pragmatic standpoint intuition searching small plans efficient searching arbitrary size plans suggests exact dynamic programming
successful domains may effective propositional
domains focus efforts set small plans development
energy therefore might fruitfully spent devising heuristics class nppp
class captures essence searching small plans probabilistic domains
early direction appearing majercik littman b complexity theorists recently begun explore classes nppp lie
polynomial hierarchy pspace designers come classes even
recently marks beginning exploration class much work still done probing algorithmic implications hope
heuristics nppp could lead powerful methods solving range important
uncertainty sensitive combinatorial

acknowledgements
work supported part grants nsf iri career littman
nsf ccr goldsmith gratefully acknowledge andrew klapper anne condon matthew levy steve majercik chris lusena mark peot reviewers helpful
feedback conversations topic

appendix complexity e majsat
e majsat given pair k consisting boolean formula n
variables x xn number k n assignment first k variables
x xk majority assignments remaining n k variables xk xn
satisfies
k n precisely boolean satisfiability classic np complete
asking whether exists assignment variables makes
true k e majsat precisely majsat well known pp complete
asking whether majority total assignments makes true
deciding instance e majsat intermediate values k different character
involves np type calculation pick good setting first k variables
pp type calculation see majority assignments remaining variables makes
true akin searching good answer plan schedule coloring belief network
explanation etc combinatorial space good determined computation
probabilistic quantities type computation described class
nppp next e majsat nppp complete

theorem

e majsat

nppp complete


ficomplexity probabilistic

proof membership nppp follows directly definitions completeness
e majsat first observe tor
nppp np
closure pp complete

set majsat thus nppp computation modeled nondeterministic machine
n possible computation first guesses sequence bits controls
nondeterministic moves deterministically performs computation input x
writes formula qx variables z zl query majsat
finally n x oracle majsat accepts qx majsat
given input x cook theorem construct formula x variables
yk z zl every assignment ak b bl holds
x ak b bl qx b bl thus x k e majsat
assignment yk qx majsat n x accepts
k

references

allender e ogihara relationships among pl l determinant
theoretical informatics applications
lvarez c jenner b hard log space counting class theoretical computer
science
backstrom c expressive equivalence formalisms artificial intelligence

backstrom c nebel b complexity sas computational
intelligence
balcazar j daz j gabarro j structural complexity ii eatcs
monographs theoretical computer science springer verlag
borodin cook pippenger n parallel computation well endowed
rings space bounded probabilistic machines information control

boutilier c dean hanks decision theoretic structural assumptions computational leverage preparation
boutilier c dearden r approximating value trees structured dynamic programming saitta l ed proceedings thirteenth international conference
machine learning
boutilier c dearden r goldszmidt exploiting structure policy construction proceedings fourteenth international joint conference artificial
intelligence pp
boutilier c poole computing optimal policies partially observable
decision processes compact representations proceedings thirteenth
national conference artificial intelligence pp aaai press mit
press


filittman goldsmith mundhenk

bylander computational complexity propositional strips
artificial intelligence
cassandra r kaelbling l p littman l acting optimally partially
observable stochastic domains proceedings twelfth national conference
artificial intelligence pp seattle wa
chapman conjunctive goals artificial intelligence
condon complexity stochastic games information computation

crites r h barto g improving elevator performance reinforcement
learning touretzky mozer c hasselmo e eds advances
neural information processing systems cambridge mit press
dearden r boutilier c abstraction approximate decision theoretic artificial intelligence
draper hanks weld probabilistic information gathering
contingent execution proceedings aaai spring symposium decision
theoretic pp
drummond bresina j anytime synthetic projection maximizing
probability goal satisfaction proceedings eighth national conference
artificial intelligence pp morgan kaufmann
erol k nau subrahmanian v complexity decidability undecidability domain independent artificial intelligence
gill j computational complexity probabilistic turing machines siam journal
computing
goldman r p boddy epsilon safe proceedings th
conference uncertainty artificial intelligence uai pp seattle
wa
goldsmith j littman mundhenk complexity plan existence
evaluation probabilistic domains tech rep cs department computer
science duke university
goldsmith j littman l mundhenk b complexity plan existence
evaluation probabilistic domains proceedings thirteenth annual conference uncertainty artificial intelligence uai pp san francisco
ca morgan kaufmann publishers
goldsmith j lusena c mundhenk complexity deterministically
observable finite horizon markov decision processes tech rep department
computer science university kentucky


ficomplexity probabilistic

hanks decision theoretic unobservable domains undecidable
personal communication
hansen e finite memory control partially observable systems ph thesis
university massachusetts
jung h probabilistic time space proceedings th icalp pp
lecture notes computer science springer verlag
kaelbling l p littman l cassandra r acting
partially observable stochastic domains artificial intelligence
koenig simmons r g risk sensitive probabilistic decision
graphs proceedings th international conference principles knowledge
representation reasoning pp
kushmerick n hanks weld probabilistic
artificial intelligence
ladner r polynomial space counting siam journal computing

lin h dean generating optimal policies high level plans conditional branches loops proceedings third european workshop
pp
littman l probabilistic propositional representations complexity proceedings fourteenth national conference artificial intelligence
pp aaai press mit press
littman l b solving large pomdps lessons complexity theory talk
presented darpa ai workshop providence ri slides available url
http www cs duke edu mlittman talks darpa pomdp ps
lovejoy w survey algorithmic methods partially observable markov
decision processes annals operations
lusena c goldsmith j mundhenk nonapproximability markov
decision processes tech rep uk cs dept tr university kentucky
majercik littman l maxplan probabilistic
simmons r veloso smith eds proceedings fourth
international conference artificial intelligence pp aaai press
majercik littman l b caching solve larger probabilistic
proceedings fifteenth national conference artificial
intelligence pp aaai press mit press
mansell method given uncertain incomplete information
proceedings th conference uncertainty artificial intelligence pp
morgan kaufmann publishers


filittman goldsmith mundhenk

mcallester rosenblitt systematic nonlinear proceedings
th national conference artificial intelligence pp
mundhenk goldsmith j allender e complexity policy evaluation
finite horizon partially observable markov decision processes proceedings
nd symposium mathematical foundations computer science published
lecture notes computer science springer verlag
mundhenk goldsmith j lusena c allender e b encyclopaedia complexity finite horizon markov decision process tech rep uk cs
dept tr university kentucky
papadimitriou c h computational complexity addison wesley reading
papadimitriou c h tsitsiklis j n complexity markov decision processes mathematics operations
platzman l k feasible computational infinite horizon partiallyobserved markov decision tech rep j georgia institute technology
atlanta ga
puterman l markov decision processes discrete stochastic dynamic programming john wiley sons inc york ny
rabin probabilistic automata information control
roth hardness approximate reasoning artificial intelligence

simon j central computational complexity ph thesis
cornell university cornell department computer science technical report
tr
smith e williamson representation evaluation plans loops
working notes stanford spring symposium extended theories
action
tesauro g td gammon self teaching backgammon program achieves masterlevel play neural computation
toda pp hard polynomial time hierarchy siam journal computing
toran j complexity classes defined counting quantifiers journal acm

vinay v counting auxiliary pushdown automata semi unbounded arithmetic
circuits proc th structure complexity theory conference pp ieee




