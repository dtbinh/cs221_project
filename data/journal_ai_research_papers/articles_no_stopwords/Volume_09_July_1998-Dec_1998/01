journal artificial intelligence

submitted published

divide conquer subgoal ordering
speeding logic inference
oleg ledeniov
shaul markovitch

olleg cs technion ac il
shaulm cs technion ac il

computer science department
technion israel institute technology
haifa israel

abstract

common view programs combination logic control logic part
defines program must control part logic programming paradigm developed intention separating logic control
recently extensive conducted automatic generation control
logic programs works considered issue automatic generation
control improving eciency logic programs present novel automatic finding lowest cost subgoal orderings works
divide conquer strategy given set subgoals partitioned smaller sets
co occurrence free variables subsets ordered recursively merged
yielding provably optimal order experimentally demonstrate utility testing several domains discuss possibilities cooperation
existing methods

introduction
common view programs combination logic control kowalski
logic part defines program must control part traditional
programming languages require programmers supply components logic
programming paradigm developed intention separating logic
control lloyd goal paradigm programmer specifies logic
without bothering control supplied interpreter
initially practical logic programming languages prolog clocksin mellish sterling shapiro include means automatic generation
control prolog programmer implicitly define control order
clauses subgoals within clauses recently extensive conducted
automatic generation control logic programs major part concerned control affects correctness termination logic programs de schreye
decorte somogyi henderson conway b cortesi le charlier rossi
works consider issue automatic generation control
improving eciency logic programs finding good ordering leads ecient
execution requires deep understanding logic inference mechanism hence many
cases expert programmers able generate ecient programs intensifies recent development field inductive logic programming muggleton
c ai access foundation morgan kaufmann publishers rights reserved

filedeniov markovitch

de raedt logic programs automatically induced learning
learning commonly built aim speeding induction process
without considering eciency resulting programs
goal described design automatically ecient orderings subgoal sequences several researchers explored
automatic reordering subgoals logic programs warren naish b
smith genesereth natarajan markovitch scott general subgoal ordering known np hard ullman ullman vardi
smith genesereth markovitch scott present search
finding optimal orderings general carry exponential costs
non trivial sets subgoals natarajan describes ecient special
case subgoals set share free variables
present novel subgoal ordering call two subgoals
share free variable dependent unlike natarajan handle
subgoal sets completely independent deal subgoal
set making maximal use existing dependencies acceleration ordering
process worst case smith genesereth exponential
still practical cases exploits subgoal dependencies finds optimal
orderings polynomial time
start analysis ordering demonstrate importance
examples compute cost given ordering
cost number solutions individual subgoals describe
natarajan smith genesereth two
combined ecient general two
drawbacks combined introduce avoids
drawbacks call divide conquer dac prove
correctness discuss complexity compare combined
dac assumes knowledge cost number solutions
subgoals knowledge obtained machine learning techniques
employed markovitch scott finally test utility
running set experiments artificial real domains
dac subgoal ordering combined many existing methods
logic programming program transformation compilation termination control
correctness verification others discuss possibilities combinations
concluding section
section states ordering section describes existing ordering
combination section presents section discusses
acquisition control knowledge section contains experimental section
contains discussion practical issues comparison works conclusions

background automatic ordering subgoals
start describing conventions assumptions accepted
demonstrate importance subgoal ordering discuss validity finally present
classification ordering methods discuss related work


fithe divide conquer subgoal ordering

conventions assumptions

constant function predicate symbols programs begin lower case letters
capital letters reserved variables braces used denote unordered sets
e g fa b cg angle brackets used ordered sequences e g ha b ci parallel
lines k denote concatenations ordered sequences subgoals speaking
abstract subgoals named predicates concrete programs denote separate
subgoals capital letters b ordered sequences subgoals capitalized vectors
sets subgoals calligraphic capitals b denotes set
b
permutations
assume programs work written pure prolog e without cut
operators meta logical extra logical predicates alternatively assume
pure prolog sub sequences subgoals subject ordering example given rule
form
b b b b b b
final part fb b b g ordered without affecting solution set
work focus upon task finding solutions set subgoals

ordering subgoals logic programs
logic program set clauses



b b bn

n

b bn literals predicates arguments use clause
proving goal matches must prove b hold simultaneously
consistent bindings free variables solution set variable bindings
solution set goal bag solutions created program
computation rule defines subgoal proved next prolog computation rule selects leftmost subgoal goal subgoal fails backtracking
performed proof previous subgoal entered generate another solution
detailed definition logic inference process see lloyd

theorem solution set set subgoals depend order

execution

proof looking solutions solution set depend

computation rule chosen theorems lloyd since transposition
subgoals ordered sequence regarded change computation rule
subgoals selected different order transposition change solution
set

theorem implies may reorder subgoals proof derivation yet
eciency derivation strongly depends chosen order subgoals following
example illustrates two different orders lead large difference execution
eciency


filedeniov markovitch

parent abraham isaac
parent sarah isaac
parent abraham ishmael
parent isaac esav
parent isaac jakov

parent clauses

male abraham
male isaac
male ishmael
male jakov
male esav

male clauses

brother x
male x parent w x parent w x
father x
male x parent x
uncle x
parent z brother x z

rules relations

figure small fragment biblical database describing family relationships

example
consider biblical family database one listed figure similar database
appears book sterling shapiro body rule defining
uncle nephew uncle niece relation ordered two ways
uncle x brother x z parent z
uncle x parent z brother x z
prove goal uncle ishmael first version rule interpreter
first look ishmael siblings isaac siblings children esav
jacov left part figure shows associated proof tree total
nodes use second version rule interpreter create parentchild pairs available database test parent whether
ishmael sibling right part figure shows associated proof tree total
n n nodes n number parent child pairs
database tree contains two success branches n failure branches figure
one example two versions rule yield identical solution
sets first version leads much smaller tree faster execution
note true given mode bound free head literal
mode free bound uncle x jacov outcome contrary second
version rule yields smaller tree

categories subgoal ordering methods

assume current conjunctive goal current resolvent fa g assume
use rule reduce according theorem produced
resolvent fa g executed order call ordering methods
allow permutation resolvent interleaving ordering methods since permit


fithe divide conquer subgoal ordering

uncle x

brother x z parent z uncle x

uncle ishmael

uncle ishmael

parent z brother ishmael z

brother ishmael z parent z

z adam
cain

male ishmael parent w ishmael parent w z
ishmael z parent z

brother ishmael adam
parent w ishmael parent w z
ishmael z parent z
w abraham
parent abraham z ishmael z parent z
z ishmael
z isaac
ishmael ishmael
parent ishmael

isaac ishmael
parent isaac

parent z brother x z

z isaac
jacov


parent child
pairs

male ishmael parent w ishmael
parent w adam ishmael adam
parent w ishmael parent w adam
ishmael adam
w abraham
parent abraham adam ishmael adam

parent isaac
esav
jacov

brother ishmael isaac

male ishmael parent w ishmael
parent w isaac ishmael isaac
parent w ishmael parent w isaac
ishmael isaac
w abraham
parent abraham isaac ishmael isaac
ishmael isaac

figure two proof trees obtained different orderings single rule example
interleaving subgoals different rule bodies ordering performed
rule bodies reduction method non interleaving
example interleaving methods consider permutations resolvent noninterleaving methods consider two orderings ha ha
interleaving ordering methods deal significantly possible orderings noninterleaving methods means ecient orderings
hand space possible orderings may become prohibitively large requiring
many computational resources
subgoal ordering take place stages proof process divide
subgoal ordering methods static semi dynamic dynamic

static ordering rule bodies ordered execution starts ordering takes place execution

semi dynamic ordering whenever rule selected reduction body
ordered order subgoals change reduction takes place

dynamic ordering ordering decision made inference step
static methods add overhead execution time however optimal ordering
rule often depends particular binding variable known
run time instance example saw first ordering rule better
proving goal uncle ishmael yet goal uncle x jacov
second ordering yields ecient execution handle cases statically
must compute optimal ordering possible binding


filedeniov markovitch

obviously static ordering non interleaving dynamic method
exible since use updated knowledge variable bindings carries
largest runtime overhead since invoked several times use rule body
semi dynamic method compromise two powerful
static method dynamically propose different orderings different instances
rule carries less overhead dynamic method invoked
use rule body
total time proving goal sum ordering time inference time
interleaving dynamic methods best potential reducing inference time
may significantly augment ordering time static methods devote time
ordering done line limited potential reducing inference time
described used categories ordering methods
although experiments described section implemented semi dynamic
non interleaving ordering methods reduction rule body ordered added
left end resolvent leftmost literal resolvent selected
next reduction step

related work

computational ineciency logic inference subject extensive
obvious aspect ineciency possible non termination
proof several researchers developed compile time run time techniques detect
avoid infinite computations de schreye decorte certain success
achieved providing advanced control employment co routining interpredicate synchronization purposes clark mccabe porto naish
infinite computations avoided pruning infinite branches contain
solutions vasak potter smith genesereth ginsberg bol apt klop
nail system morris subgoals automatically reordered avoid
nontermination
still even proof finite desirable make ecient several
researchers studied clause ordering smith cohen etzioni
laird mooney zelle greiner orponen looking
solutions goal eciency depend clause order assuming
cuts indeed predicate clauses argument bindings
clauses produce solutions times tm solutions predicate
bindings obtained time tm regardless order
clauses applied different clause orderings correspond different orders
branches selected proof tree traverse entire tree number
traversal steps depend order branch selection though order
solutions found depend
subgoal ordering demonstrated example significantly affect eciency proving goal two major approaches subgoal ordering first
uses heuristics order subgoals example

choose subgoal whose predicate smallest number matching clauses minker




fithe divide conquer subgoal ordering

prefer subgoal constants minker
choose subgoal largest size size defined number
occurrences predicate symbols function symbols variables nie plaisted


choose subgoal largest mass mass subgoal depends
frequency arguments sub arguments entire goal nie plaisted


choose subgoal least number solutions warren nie plaisted


apply tests generators naish
prefer calls fail quickly naish b
heuristic methods usually execute quickly may yield suboptimal orderings
second adopted aims finding optimal orderings smith genesereth natarajan markovitch scott natarajan
proposed ecient way order special sort subgoal set subgoals independent smith genesereth proposed general inecient
following section build unifying framework dealing subgoal ordering
describe variations natarajan smith genesereth
two combined increased eciency

subgoal ordering logic programs
goal work presented order subgoals speeding logic programs
section starts analysis cost executing sequence subgoals resulting
formula basis subsequent ordering discuss dependence
subgoals present existing ordering independent dependent sets
subgoals finally combine general ecient one

cost executing sequence subgoals

subsection analyze cost executing sequence subgoals analysis
builds mainly work smith genesereth
let fa ak g set subgoals b binding denote sols
solution set define sols f g denote ai jb ai whose variables
bound according b ai j ai finally denote cost ai jb amount
resources needed proving ai jb cost ai jb ect time complexity proving
ai binding b example number unification steps natural measure
complexity logic programs itai makowsky
obtain cost finding solutions ordered sequence subgoals

ha ani




filedeniov markovitch

note proof tree traversed tree traversed
solution generated tree solution fa g etc
consequently total cost proving equation

cost ha cost


x

cost jb

b sols fa g

n
x

x

cost jb

b sols fa g

x

cost aijb
b sols fa ai g



compute equation one must know cost solution set subgoal
binding reduce amount information needed derive equivalent
formula uses average cost average number solutions

definition let b set subgoals subgoal define cost jb average
cost solutions b nsols jb average number solutions
solutions b


p cost ajb b
cost
b
cost jb b sols
b
sols b
j
sols b j
undefined
b sols b




j
b
jpsols fagj sols

f

j
g

j
b
b
nsols jb b solsjsols
b
sols b
undefined b j
b sols b


first definition follows

x

cost aijb jsols fa ai g j cost ai jfa ai g


b sols fa ai g





apply second definition recursively obtain

jsols fa aig j



x

jsols faijbg j
b sols fa ai g
jsols fa ai g j nsols ai jfa ai g
yi
nsols aj jfa aj g
j



note defined sols f g thus equations hold incorporation
equations equation yields

cost ha


n
x



j



nsols aj jfa aj ga cost ai jfa ai g












fithe divide conquer subgoal ordering

subgoal ai average cost multiplied total number solutions
preceding subgoals define average cost number solutions every
continuous sub sequence equation k k k k n
cost ha ak j cost ha ak j

cost hak ak jfa ak g
nsols ha ak j

















k

x



k

j k



nsols aj jfa aj g cost ai jfa ai g








k

nsols ha ak j
nsols hak ak jfa ak g

nsols ai jfa ai g
nsols ha ak j k
























values cost ai nsols ai depend position ai ordered sequence example assume want abraham sons domain
example unordered conjunctive goal fmale parent abraham g let
n males database two isaac ishmael abraham sons
nsols male j n
nsols parent abraham j
nsols male jfparent abraham g nsols parent abraham jfmale g n
note nsols hmale parent abraham nsols hparent abraham male
exactly theorem predicts
defined cost sequence subgoals define objective
ordering

definition let set subgoals define set permutations
minimal ordering denoted min cost according
equation minimal possible permutations
min os cost cost os
total execution time sum time spent ordering
inference time spent interpreter ordered sequence focus
upon developing minimizing inference time elsewhere ledeniov
markovitch b present attempt reduce total execution
time
values cost number solutions obtained ways exact
computation estimation bounds learning let us assume moment
exists mechanism returns average cost number solutions
subgoal time section control knowledge obtained
inductive learning

ordering independent sets subgoals

general subgoal ordering np hard ullman vardi however
special case ordering performed eciently subgoals


filedeniov markovitch

given set independent e share free variables section begins
definition subgoal dependence related concepts ordering
independent sets prove correctness
dependence subgoals

definition let b sets subgoals b called binding set pair
subgoals directly dependent b share free variable bound
subgoal b
pair subgoals indirectly dependent respect b exists third
subgoal directly dependent one b dependent directly
indirectly one b pair subgoals independent b
dependent b directly indirectly subgoal independent
b independent members b
two subsets mutually independent binding set b
every pair subgoals independent b
entire set called independent binding set b subgoal pairs
independent b called dependent otherwise dependent set subgoals
called indivisible subgoal pairs dependent b divisible otherwise
divisibility partition b dpart b partition subsets
mutually independent indivisible b except one subset contains
subgoals independent b easy dpart b unique
example let fa b x c x e z f z v h w g respect
empty binding set pair fb x x g directly dependent fb x c g
indirectly dependent fb x e z g independent represent set subgoals

graph subgoals vertices directly dependent subgoals connected
edges dependence equivalent connectivity indivisible subsets equivalent
connected components size greater divisibility partition partition
graph connected components lonely vertices collected together
special component figure shows example graph set
empty binding set whole set divisible four mutually independent subsets
subsets fe z f z v g fb x c x g indivisible elements
divisibility partition dpart shown dotted lines
subgoal independent set average cost number solutions
depend position within ordered sequence
p
cost ajb jsols b j cost

cost
cost jb b sols b
jsols b j
jsols b j

p

b sols b jsols fajbg j

jsols b j jsols fag j jsols fag j
jsols b j
case omit binding information write cost ai instead cost ai jfa ai g
nsols ai instead nsols ai jfa ai g
practice program rule bodies rarely feature independent sets literals example
following clause states children candy
nsols jb

jsols b j











fithe divide conquer subgoal ordering

fa

b x c x e z f z v h w


h w

b x

e z
f z v

g

c

x

figure example graph representing set subgoals directly dependent subgoals

connected edges independent subgoals indivisible subsets equivalent
connected components surrounded dashed lines divisibility partition
empty binding set shown dotted lines
likes x

child x candy

often independent rule bodies appear written
program text variables bound initially dependent rule bodies
clause head unification example rule
father x

male x parent x

used reduce father abraham w x bound abraham rule body
becomes independent rule bodies often become independent substitutions performed course inference process
ordering independent sets sorting

let ordered sub sequence subgoals b set subgoals denote

cn jb nsols jb
cost jb
name cn ects participation cost nsols definition subsequence independent subgoals binding information jb omitted
together average cost average number solutions cn value subgoal
called control values subgoal
independent sets exists ecient ordering listed figure
complexity n log n n obtain control values n
subgoals n log n perform sorting knuth enable division
must define cost cost ai positive define cost number
unifications performed cost ai reasonable assumption
predicates rule body subgoals defined program case least one
unification performed subgoal similar proposed simon
kadane natarajan
example let set independent subgoals fp q rg following control values


filedeniov markovitch


let fa g set subgoals
ai
sort cn ai nsols
cost ai key ai return
figure ordering subgoals sorting
p q
r
cost

nsols

cn

compute costs possible orderings equation

cost hp q ri
cost hp r q
cost hq p ri
cost hq r pi
cost hr p q
cost hr q pi
minimal ordering hr p q exactly ordering found much
quickly set fp q rg r smallest cn value
goes p cn p finally q cn q
note sorting ects well known principle best implementations generate test programs obtained tests placed early possible
rule body generations late possible naish course
cheap tests come first expensive ones come last one looks
cn measure one quickly realizes tests put front nsols
cn generator subgoals move towards end nsols cn
weakness test first principle fact every subgoal easily
tagged test generator one subgoal nsols another one nsols
order obvious even without looking costs cn values
different signs subgoals nsols nsols
decision simple sorting cn correctly handle possible cases
correctness proof sorting independent sets

saw found minimal ordering example going
prove finds minimal ordering independent sets first
important lemma used discussion lemma states


fithe divide conquer subgoal ordering

substitution sub sequence cheaper permutation makes entire sequence
cheaper

lemma
let kb kc kb kc b b permutations one another
empty nsols

cost cost cost b ja cost b ja
cost cost cost b ja cost b ja

proof c empty
cost cost cost kb kc cost kb kc



cost j nsols j cost b ja nsols kb j cost c ja kb


cost j nsols j cost b ja nsols kb j cost c ja kb

theorem b b produce solution sets hence third terms
parentheses equal





cost cost nsols j cost b ja cost b ja
since nsols sign cost cost coincides sign cost b ja
cost b ja
c empty proof similar

definition let kb kc kb kd ordered sequence subgoals c may
empty sequences respect pair hb b

cn ordered cn b ja cn b ja b c


cn inverted cn b ja cn b ja b c


two adjacent mutually independent sequences subgoals minimal
ordering must cn ordered

lemma
let kb kb kc kb kb kc b b mutually independent
let empty nsols

cost cost cn b ja cn b ja
cost cost cn b ja cn b ja


filedeniov markovitch

proof
cost cost lemma
cost b kb ja cost b kb ja
cost b ja nsols b ja cost b ja b
cost b ja nsols b ja cost b ja b
indep fb b g

cost b ja nsols b ja cost b ja
cost b ja nsols b ja cost b ja
nsols b ja cost b ja cost b ja
nsols b ja cost b ja cost b ja
cost b ja nsols b ja nsols b ja


cost b ja
cost b ja
cn b ja cn b ja



cost cost



cn b ja cn b ja similar



independent set subgoal pairs independent particular adjacent pairs
minimal ordering independent set adjacent subgoal pairs must cnordered otherwise cost sequence reduced transposition pair
conclusion expressed following theorem

theorem
let independent set let ordering minimal iff subgoals
sorted non decreasing order cn values

proof

let minimal ordering contains cn inverted adjacent pair subgoals
transposition pair reduces cost lemma contradicting
minimality

let ordering whose subgoals sorted non decreasing order
cn let minimal ordering according item sorted
cn possible difference two sequences internal ordering
sub sequences equal cn values ordering sub sequence
transformed ordering counterpart sub sequence
finite number transpositions adjacent subgoals lemma transpositions
adjacent independent subgoals equal cn values cannot change cost
sequence therefore cost cost minimal ordering since
minimal


corollary finds minimal ordering independent set subgoals


fithe divide conquer subgoal ordering

ordering dependent sets subgoals

guarantee finding minimal ordering given set subgoals
dependent following proposition shows

proposition given set subgoals dependent
defined
even defined minimal ordering set

proof claims proved counter examples
set subgoals cannot ordered sorting
program
control values
x j x jfb x g b x j b x jfa x g
c
b c
cost




c
b c
nsols






cn





set fa x b x g two possible orderings ha x b x hb x x
orderings minimal cost though neither one sorted cn ordering
cn first subgoal cn second one sorting cn
impossible transpose subgoals cn values changed
pair becomes cn inverted
set subgoals ordered sorting sorted ordering
minimal
program
control values
x j x jfb x g b x j b x jfa x g
c
cost




c




nsols
b c


cn


b c
c c


let unordered set subgoals fa x b x g ordering hb x x sorted
cn ha x b x ha x b x cheaper hb x x
cost ha x b x

cost hb x x


since sorting cannot guarantee minimal ordering dependent subgoals consider alternative ordering simplest checks every possible permutation set returns one minimal cost listing
shown figure
runs n time time takes compute control
values one subgoal n number subgoals
following observation help reduce ordering time expense additional space ordered sequences constructed incrementally adding subgoals


filedeniov markovitch


permutation subgoals cost according equation
store currently cheapest permutation update cheaper
one found
finally return cheapest permutation

figure subgoal ordering exhaustive check permutations


order
let p f g n jsj
loop kn tofi n

pk np kb fifi p pk b h n p
io
p cost p cost p
pk p pk fifi p pk permutation p
return single member pn
figure ordering checks permutations ordered prefixes
right ends ordered prefixes lemma cheaper permutation prefix exists
prefix cannot belong minimal ordering ordering build
prefixes increasing lengths step adding right end prefix one
subgoals appear already subset keeping cheapest
permutation several permutations equal cost one chosen
listing shown figure step k pk stores set prefixes
step k extended every subgoal appearing already pk pk
pk subset subgoals represented cheapest permutation obviously
jpk j nk one prefix kept every subset size k prefix length k
n k possible continuations length k size pk follows

k
n
n
jpk j k n n k n k n
k n k k n k k k k
prefix compute cost time permutation test completed
n time example trie structure aho et al subgoals
prefixes sorted lexicographically step k takes n k nk time


fithe divide conquer subgoal ordering

whole runs
n
x

k

n k nk n n

n
x
n
k

k n n n

n makes n n
smith genesereth natarajan point minimal ordered
sequence every adjacent pair subgoals must satisfy adjacency restriction
general form restriction notation says two adjacent subgoals ak
ak minimal ordering ha ani must satisfy
cost hak ak jfa ak g cost hak ak jfa ak g










restriction follows immediately lemma however help
locally minimal ordering e ordering cannot improved transpositions
adjacent subgoals possible adjacent subgoal pairs satisfy equation
ordering still minimal following example illustrates statement

example let unordered set fp x q x r x g predicates defined
following program

p c
q c
r c
p c f q c
r c
q c f
f fails unifications
ordering hp x q x r x satisfies adjacency restriction equation
cost q x r x jp x
cost p x q x j
cost q x p x j
cost r x q x jp x
minimal

cost hp x q x r x
cost hr x p x q x

globally minimal ordering seems beneficial combine prefix
adjacency restriction prefix satisfy adjacency restriction
cheaper permutation prefix adjacency test performed faster
permutation test since must consider two last subgoals prefix nevertheless number prefixes remaining step
reduced prefix rejected due violation adjacency restriction would
rejected permutation test furthermore adjacency restriction test
fail still perform permutation test avoid local minima
example adjacency test succeeds least half cases examine
prefix ha ak b b shall examine ha ak b b adjacency test
cannot fail consequently addition adjacency test halve total
running time ordering leaving n n worst case


filedeniov markovitch

smith genesereth propose performing best first search space ordered
prefixes preferring prefixes lower cost best first search combined
permutation test adjacency restriction addition subgoals
prefix independent binding sorted sorted
concatenated prefix lemma corollary produces cheapest
completion prefix perform completion need perform
adjacency permutation test complete sequence minimal never chosen
cheapest prefix even added list prefixes never extracted
therefrom resulting shown figure


order

let prefix list prefix rest
loop empty rest
independent restjprefix

let completion prefixksort cn restjprefix
insert cost completion prefix list
else
loop subgoal rest
let extension prefixksubgoal
adjacency restriction test extension
permutation test extension

insert cost extension prefix list
prefix cheapest prefix list
remove list prefix prefix list
rest snprefix
return prefix

figure subgoal ordering incorporating ideas earlier researchers
advantage best first search avoids expanding prefixes whose cost
higher cost minimal ordering policy used may
however suboptimal even harmful often happens best completion
cheaper prefix much expensive best completion expensive prefix
number solutions large better place subgoals high costs closer
beginning ordering reduce number times cost multiplied
example let set fa x b x g cost x cost b x nsols x
nsols b x minimal ordering starts expensive prefix
cost ha x b x


fithe divide conquer subgoal ordering

cost hb x x
many prefixes whose cost higher cost minimal ordering
best first search saves time number prefixes small best first
search increase total time due need perform insertion prefix
priority queue according cost
sample run shown later section

divide conquer subgoal ordering

presented section ecient applicable entire
set subgoals independent handle dependent set subgoals
inecient combination two exploit independence subgoals better eciency however obtained benefit quite limited section
present divide conquer dac able exploit subgoal independence elaborate way divides set subgoals smaller
subsets orders subsets recursively combines

divisibility trees subgoal sets

subsection define structure represents ways breaking subgoal
set independent parts work traversing structure
definition let b sets subgoals divisibility tree b dtree b
tree defined follows
leaf b
independent b





dtree b b fdtree n fbi g b fbi g j bi sg indivisible b

b fdtree si b j si dpart b g divisible b

node n tree dtree b associated set subgoals n
associated binding set b n b root node n b n b
binding set root specified explicitly assume empty nodes
nodes define sets children

n independent b n n leaf
n indivisible b n n node subgoal bi n
defines child node whose set subgoals n n fbi g binding set
b n fbi g call bi binder generated child note binding
set every node divisibility tree union binders indivisible
ancestors root binding set

n divisible b n n node subset si
divisibility partition dpart n b n defines child node associated set
subgoals si binding set b n divisibility partition defined section


filedeniov markovitch

b c x x e x
n n
b n

n b
b n

n

n c x x e x

n b n

n x e x
n c x x
n
n b n e x
b n c x n
n c x e x
b n x

figure divisibility tree fa b c x x e x g empty initial binding set set
associated node n divisible represented node children
correspond divisibility subsets one independent n fa bg one indivisible n fc x x e x g n node whose children correspond
three subgoals subgoal serves binder one children sets n
n n n independent respective binding sets
nodes leaves assumed subgoals c x x e x bind x
proof

easy divisibility tree set subgoals unique order
children node figure shows divisibility tree set fa b c x x e x g
empty initial binding set associated sets binding sets written next
nodes
following lemma expresses important property divisibility trees subgoals
node independent rest subgoals binding set node

lemma let set subgoals every node n dtree every
subgoal n every subgoal n n b n independent
b n
proof induction depth n divisibility tree
inductive base n root node n n empty exists
inductive hypothesis lemma holds parent node n
inductive step let n n n b n
lemma holds thus independent b
independent b independent b n
since b b n otherwise dependent b


fithe divide conquer subgoal ordering

node dependent b
belong element dpart b n

contradiction
node n n must binder n
b n b fy g b n contradiction

lemma relates subgoal independence inside divisibility trees shall sometimes
need argue independence inside ordered sequences subgoals following
corollary provides necessary connecting link

corollary let set subgoals n node divisibility tree
ordering ks b n n n mutually
independent n n
proof let n n n independent b n
preceding lemma since b n independent every subgoal
n independent every subgoal ns n therefore n ns n
mutually independent



valid orderings divisibility trees

aim ordering minimal ordering given set subgoals
construct orderings following divide conquer policy larger sets split
smaller ones orderings smaller sets combined produce ordering
larger set implement policy perform post order traversal divisibility
tree corresponding given set subgoals empty initial binding set
orderings child nodes combined produce ordering parent node inner
order subgoals changed smaller orderings consistent larger orderings

definition let g sets subgoals ordering g g ordering
consistent denoted cons g order subgoals g g


divide conquer process described seems analogous merge sort knuth
set numbers split two subsets subset independently ordered sequence consistent global order sequences
merged possible use similar method subgoal ordering assume set
subgoals partitioned two mutually independent subsets b build
given produces ordering consistent minimal ordering
b independently b unfortunately answer negative ordering may
consistent minimal ordering b time consistent
minimal ordering b b b
example let fa x x g b fbg b fdg control values
specified figure single minimal ordering b ha x b x
single minimal ordering b hd x x ordering consistent
minimal global orderings


filedeniov markovitch

program
c
c
c
c
c

b
b


x


c

control values
x j x jfa x g x j x jfa x g b
cost





nsols






cost b x x
cost b x x
cost x b x
cost x x b
cost x b x
cost x x b

cost x x
cost x x
cost x x
cost x x
cost x x
cost x x

figure small program control values defines compute costs
permutations sets fb x x g fd x x g different orderings
fa x x g consistent minimal orderings sets
since unlike case merge sort cannot identify single ordering
subset consistent minimal ordering whole set deal
sets candidate orderings requirement set contain least
one local ordering consistent global minimal ordering local ordering exists
local ordering ordering set node global ordering ordering
set root set called valid following definition defines valid
sets formally together several concepts
definition let set subgoals n node divisibility tree
recall denotes set permutations
binder consistent n n denoted bcn n
consistent subgoals b n appear subgoals n
bcn n b b n cons b ko n
binder consistent node n denoted bcn binderconsistent ordering n
bcn n n bcn n
n n min consistent denoted mcn n
binder consistent minimal
mcn n bcn n min
n n min consistent denoted mcn n min consistent
ordering
mcn n mcn n












fithe divide conquer subgoal ordering

ordering n n mc contradicting min consistent
mccn n mcn n




two orderings n mc equivalent one min consistent
iff one
mcen mcn mcn






set orderings cn n valid cn contains min consistent ordering
least one min consistent ordering n exists

v alidn cn n n mcn n n cn mcn n






important property valid sets valid set orderings root

dtree must contain minimal ordering indeed root n
consistency becomes identity b n binder consistency becomes

consistency min consistency becomes minimality since exists minimal
ordering valid set orderings root must contain minimal ordering

outline divide conquer

propose producing valid sets orderings node
divisibility tree produces valid set associated set subgoals passes
parent node valid set root node found compare costs
members return cheapest one
set orderings produced node n called candidate set
n members called candidate orderings n simply candidates
candidate set n first consider set possible orderings n
consistent candidates n children set called consistency set n
given candidate sets n children consistency set n defined uniquely
candidate set n usually unique
definition let n node divisibility tree consistency set n denoted
consset n candidate set n denoted candset n defined recursively

n leaf consistency set contains permutations n
consset n n

n node child nodes n n nk define consistency
set n set possible orderings n consistent candidates
n n nk


n

consset n n n fifi k candset ni cons n


filedeniov markovitch

n node child node corresponding every binder n

na consistency set n obtained adding binders first elements
candidates children

n

consset n ako fifi n candset na

candidate set n set orderings produced removing mc contradicting

mc equivalent orderings consistency set n keeping least
one representative group mc equivalent orderings
candset n consset n
consset n n candset n mccn n
h

n candset n mcen n n




words ordering rejected mc contradicting mcequivalent ordering rejected
two kinds orderings removed consset n retaining validity mc contradicting mc equivalent orderings removal mccontradicting ordering cannot change number min consistent orderings set
remove mc equivalent ordering even min consistent minconsistent ordering retained set exists min consistent ordering set
node candidate set must contain min consistent ordering therefore
candidate set valid
note treats node binder child
placed first subgoal produced ordering node higher levels inner
order subgoals ordering change consistency preserved therefore
produce binder consistent orderings explains choice
names binder binding set subgoals b n bind common variables
n since stand left global ordering
produces particular n independent b n subgoals b n
bind shared free variables n
implement dpart function use union data structure cormen
leiserson rivest chapter subgoals elements indivisible sets
groups beginning every subgoal constitutes group whenever
discover two subgoals share free variable bound subgoals binding set
unite groups one complete procedure need way determine
variables bound given binding set section contains discussion
proposes practical solutions finally collect indivisible
subgoals separate group operations implemented nff n n amortized time n n inverse ackermann function considered
values n appear realistic logic programs thus whole process
finding divisibility partition n subgoals performed n average time
formal listing ordering discussed shown figure
specify explicitly candidate sets created consistency sets complete must provide three filtering procedures


fithe divide conquer subgoal ordering


order

rootcandset

candidateset

return cheapest member rootcandset

candidateset b
case b

independent
let conssetn
let candsetn validleaffilter conssetn
divisible
let fs sk g dpart b
loop k
let ci candidateset
si b
n

let conssetn
n j k ci cons n
let candsetn validandfilter conssetn fs sk g fc ck g
indivisible
loop
let c candidateset
n n foag b fag

let c
askoa j oa c

let conssetn
c
let candsetn validorfilter conssetn
return candsetn

figure skeleton dac ordering type node divisibility tree

consistency set created refined validity filters produced candidate
set root valid hence cheapest member minimal ordering given
set

validleaffilter validandfilter validorfilter trivially define
null filters return sets receive unchanged case candidate
set every node contain permutations subgoals surely valid
however greatly increase ordering time intention reduce sizes
candidate sets far possible keeping valid
following two subsections discuss filtering procedures section discusses detection mc contradicting orderings section discusses detection mcequivalent orderings finally section present complete ordering
incorporating filters skeleton


filedeniov markovitch

detection mc contradicting orderings

subsection sucient conditions ordering mc contradicting
orderings safely discarded leaving set orderings valid reducing
size subsection divided three parts one type node divisibility
tree
detection mc contradicting orderings leaves

following lemma shows subgoals min consistent ordering leaf node must
sorted cn

lemma
let set subgoals n leaf divisibility tree let n ordering
n subgoals n sorted cn b n n mc contradicting
proof let ordering binder consistent n cannot
minimal ordering thus n min consistent
n sorted cn e contains adjacent cn inverted pair subgoals ha

recall pair cn inverted first element larger cn value second
one section since consistent n write x ka ky ka kz
x z possibly empty sequences subgoals since binder consistent
n b n x
empty adjacent since b n x
independent x therefore cost whole ordered sequence reduced
transposing according lemma adjacent independent
cn inverted
empty subgoal belongs n since otherwise would appear
n corollary mutually independent
x

cn jx cn jx lemma transposition produces
ordering lower cost
otherwise cn jx cn jx since pair ha cn inverted cn jx
cn jx hence cn jx cn jx transposition reduces
cost lemma
case way reduce cost therefore cannot minimal
n mc contradicting

detection mc contradicting orderings nodes

every member consistency set node consistent combination
candidates child nodes k child nodes child ni sizes
subgoal candidate sets js ni j ni jcandset ni j ci total
number possible consistent orderings c c ck nn nn nnk k fortunately
orderings mc contradicting discarded candidate set










fithe divide conquer subgoal ordering

following lemma states forbidden insert subgoals two cn inverted
sub sequences insertion takes place ordering mc contradicting
safely discarded

lemma
let set subgoals n node divisibility tree ordering
binder consistent ordering n n
n contains adjacent cn inverted pair sub sequences ha appear

mixed subgoals adjacent
minimal

proof let ordering binder consistent n
x ka ky ka kz
empty subgoal belongs n since otherwise would stand
n binder consistent n therefore b n x
corollary must mutually independent x lemma
transposition reduces cost exactly proof
lemma


pair adjacent subgoals hai ai cn inverted previous lemma
attempt insert subgoals inside non minimal global ordering thereupon
may join ai ai block ai participate larger block
formal recursive definition block follows convenience consider separate
subgoals blocks length

definition

sub sequence ordered sequence subgoals block single
subgoal ka ha cn inverted pair blocks
block maximal max block sub sequence larger block
let n node divisibility tree descendant n n n
two consistent orderings nodes block
violated n two adjacent subgoals adjacent n
words alien subgoals inserted subgoals block
let n node descendant n n two
consistent orderings nodes called projection n
shall usually speak projection ordering child node
concept max block similar maximal indivisible block introduced simon
kadane context satisficing search following corollary presents
lemma convenient way

corollary let n node divisibility tree one children n

ordering n projection n contains block
violated n n mc contradicting


filedeniov markovitch

proof let smallest block violated n according definition
block ka violated n pair ha

cn inverted let ordering root node binder consistent n
violates since n violates n mc contradicting must prove
minimal
violated adjacent
minimal lemma
otherwise violated without loss generality let let
smallest sub block violated according definition block
ka pair ha cn inverted violated
adjacent lemma minimal

example control values subgoals shown figure ha x x
block since cn x j cn x jfa x g one see
figure insertion b inside block non minimal ordering
already noted consistency set node large
many orderings however blocks projections violated discard
orderings mc contradicting remaining orderings block projection
violated ordering represented sequence max blocks
projections projection max blocks stand cn ascending order otherwise
adjacent cn inverted pair blocks larger block formed contradicts
maximality following lemma states parent node blocks
must ordered cn values otherwise ordering mc contradicting
lemma ordering node contains adjacent cn inverted pair maxblocks projections children ordering mc contradicting
proof blocks violated binder consistent global ordering global
ordering minimal corollary blocks violated proof similar
proof lemma

two sucient conditions detection mc contradicting orderings expressed
corollary lemma allow us reduce size candidate set significantly
assume example set current node n split two mutually independent subsets whose candidates ha hb b one candidate child
six possible orderings n shown figure assume ha
hb b blocks cn ha jb n cn hb b jb n six consistent orderings
four rejected due block violation one remaining two number
puts blocks wrong order one ordering number left candidate set n even neither ha hb b blocks lemma dictates unique
interleaving elements max blocks assuming cn jb n cn jb n fa g
cn b jb n cn b jb n fb g




detection mc contradicting orderings nodes

following lemma states block cheaper permutation ordering
mc contradicting discarded candidate set


fithe divide conquer subgoal ordering





b b





b b







b b



b b





b b





b b

figure possible ways combine ha hb b

lemma let n node divisibility tree n n let leading
block n n kr permutation cost jb n
cost jb n n mc contradicting
proof let binder consistent n violated cannot

minimal corollary otherwise occupies continuous segment
replacement cheaper permutation reduces cost global ordering lemma
thus cannot minimal

check done leading blocks nodes

every ordering leaf node rejected due lemma must

sorted cn consequently contains cn inverted adjacent pair subgoals
block size formed

every ordering node rejected due corollary
lemma must blocks unbroken cn ascending order consequently
blocks cannot formed

nodes blocks formed add binder first element
ordering cn value binder greater subsequent block
blocks start binder must perform permutation test
leading max block ordering

detection mc equivalent orderings

previous subsection presented sucient conditions detecting mc contradicting
orderings subsection specify sucient conditions identifying mc equivalent
orderings recall two orderings node mc equivalent minimal consistency
one implies minimal consistency finding sucient conditions
allow us eliminate orderings without loss validity candidate set start
defining specialization mc equivalence relation blockwise equivalence
orderings whose max blocks sorted cn blockwise equivalent
therefore mc equivalent


filedeniov markovitch

definition let set subgoals n node divisibility tree let
two orderings n equal number max blocks let
ordering binder consistent blocks violated
joo ordering obtained replacing every max block max

block preserving order max blocks th max block replaced
th max block
blockwise equivalent following condition holds min consistent
iff min consistent joo
easily seen two orderings blockwise equivalent mcequivalent transposition adjacent mutually independent cn equal
max blocks ordering node produces blockwise equivalent ordering proof
following lemma found appendix





lemma
let set subgoals n node divisibility tree n q ka ka kr
ordering n max blocks mutually independent cn equal
bindings b n q n blockwise equivalent n q ka ka kr
corollary sorted cn orderings leaf node blockwise equivalent
example n fa b c dg cn jb n cn b jb n cn c jb n
cn jb n orderings ha b c di ha c b di blockwise equivalent
remove candidate set one

corollary orderings node blocks projections violated

adjacent max blocks different children projections cn ordered blockwiseequivalent

b
c
example candidates children kb c kd
max blocks cn jb n cn b jb n cn c jb n cn jb n c
orderings kb kc kd kc kb kd blockwise equivalent remove
candidate set one
prove corollaries note case one mentioned
orderings obtained finite number transpositions adjacent
mutually independent cn equal max blocks according lemma transposition yields blockwise equivalent ordering easy blockwise equivalence
transitive
following corollary states subgoals within block permuted provided
cost block changed

corollary orderings node identical cost preserving permutations subgoals inside blocks blockwise equivalent

proof corollary follows immediately lemma example set
fa x b x g control values first counter example proposition


fithe divide conquer subgoal ordering

node set
mc contradicting
leaf independent subgoals sorted cn
lemma
contains violated blocks
divisible
corollary
max blocks sorted cn
lemma
leading max block
indivisible cheaper permutation
lemma

blockwise equivalent
subgoals sorted cn
corollary
max blocks violated
sorted cn
corollary
cost preserving permutations
blocks
corollary

table summary sucient conditions detection mc contradicting blockwiseequivalent orderings

e cn x j cn b x j cn x jfb x g cn b x jfa x g
possible orderings ha x b x hb x x two subgoals united block
blocks equal cost global ordering containing block ha x b x
replace block hb x x without changing total cost therefore
ha x b x blockwise equivalent hb x x
sucient condition expressed corollary checked nodes
since leaves nodes blocks created argued section

revised ordering

two preceding subsections saw several sucient conditions mc contradiction
mc equivalence summarized table permit us close gaps
providing necessary validity filters filter tests sucient
conditions mc contradiction mc equivalence every ordering consistency
set sucient conditions hold ordering rejected formal listing
procedures shown figure
generate test described served us well methodological
purposes obviously practical computational limitations example
independent set size n creates n orderings rejects n
keeps one process takes n n time produces ordering
sorted cn could obtained n log n time single
sorting instead uncontrolled creation orderings selective rejection want
perform selective creation orderings words want revise
deal directly candidate sets instead generating large consistency sets revised
produces candidate set node n follows
n leaf subgoals n sorted cn bindings b n
produced ordering sole candidate n
n node combination children candidates candidate n created max blocks children candidates ordered


filedeniov markovitch

validleaffilter conssetn
let candsetn
loop n conssetn

n sorted cn
n candsetn sorted cn
candsetn candsetn fo n g
return candsetn

validandfilter conssetn fs sk g fc ck g
let candsetn
loop n conssetn

loop k
let projection n si
ci
max blocks violated n
max blocks ordered cn n
n candsetn consistent
candsetn candsetn fo n g
return candsetn

validorfilter conssetn
let candsetn
loop n conssetn

n start block cheaper permutation
n candsetn identical n
cost preserving permutations blocks
candsetn candsetn fo n g
return candsetn

figure three filter procedures convert consistency set candidate set together
form complete ordering eciency
improved shall see

cn candidate produced merging moving parallel candidates
children extracting max blocks minimal cn

n node candidate child ordering n created
adding binder left end child candidate creation
block cheaper permutation ordering rejected otherwise
added candidate set suces check leading max block


fithe divide conquer subgoal ordering

note revised include test cost preserving permutations
blocks different orderings expressed corollary high expense
test
revised described contains manipulations blocks purpose need easy ecient way detect blocks orderings since
permit block violation corollary unite subgoals max block
one entity treat ordinary subgoal procedure joining subgoals
blocks called folding resulting sequence max blocks folded sequence
subgoals folded block need unfold block back separate
subgoals upper levels tree subgoals joined block unless
block violated unfolding operation carried returning
cheapest ordering set root node candidate sets nodes
defined sets folded orderings
already stated blocks created candidates nodes
binder added first element ordering cn value binder
greater cn value first max block child projection therefore
revised build blocks start binder max blocks
rest ordering remain child candidate first try make block
binder first max block child candidate cn ordered
stop folding cn inverted unite larger block try
unite second max block child candidate produced
folded ordering contains maximal blocks first block maximal since could
expand right blocks maximal since maximal
child candidate
lemma states ordering whose leading max block cheaper permutation
mc contradicting one way detect block exhaustively test permutations computing comparing costs procedure expensive instead
revised employ adjacency restriction test equation test
applied every pair adjacent subgoals block adjacent pair cheaper
transposition whole block cheaper permutation lemma since blocks
created concatenation smaller blocks suces test adjacency restriction
points blocks joined adjacent pairs subgoals tests
performed lower levels smaller blocks formed adjacency restriction test guarantee detection cheapest permutations shown
example detects blocks many cases works linear time
final version dac subgoal ordering presented figure
complete correctness proof found appendix b

sample run comparison ordering
illustrate work dac subgoal set shown figure
fa b c x x e x g proving c x x e x assume x
bound let control values subgoals shown table column c free
contains control values subgoal c x x yet bound preceding
subgoals e binding set contain x e x column c bound


filedeniov markovitch

divide conquer
order
let rootcandset candidateset
return unfold cheapest element rootcandset
candidateset b
let fs sk g dpart b
case

k shared vars independent b
return fsort cn b g
k shared vars indivisible b
loop
let c candidateset
fin fag b faog
n


let c
fold
akoa b fifi c

return c
k divisible b
loop k
let cin candidateset si b
return merge fo k g b

fifi

c c k ck

merge fo k g b

let min cn candidate minimizes cn first max block jb k
let min cn block first max block min cn candidate
remove first max block min cn candidate
return min cn blockkmerge fo k g b min cn block

fold ha ak b
k cn jb cn jbka
return ha ak



else
last subgoal first subgoal satisfy adjacency restriction

let block
return fold ha ak b
else return

figure revised version dac candidate sets built selectively

without explicit creation consistency sets candidate sets contain folded orderings
unfolding performed returned global ordering code
unfold sort cn procedures listed due straightforwardness
merging procedure recursively extracts given folded orderings max blocks
minimal cn folding procedure joins two leading blocks larger one
long cn inverted


fithe divide conquer subgoal ordering


b c free c bound free bound e free e bound
cost







nsols






cn






table control values sample runs ordering
contains cost values c x x e x already bound x example
cost c x jfa x g cost c bound dac traverses divisibility tree
follows names nodes figure
root divisibility tree n empty binding set b n
associated subgoal set n fa b c x x e x g set n partitioned two subsets b n one independent fa bg one indivisible
fc x x e x g two subsets correspond two child nodes andnode n n n empty binding sets
n independent b n therefore n leaf sole candidate
ordering obtained sorting subgoals cn b n cn j
cn b j thus candset n fha big
n indivisible b n therefore n node three children
created one subgoal n serving binder

binder c x yields child node n associated set n fd x e x g
binding set b n fc x g n independent b n

fore n leaf sole candidate obtained sorting subgoals
cn
cn x jfc x g cn e x jfc x g
thus candidate n x x
binder x yields child node n associated set n fc x e x g
binding set b n fd x g n independent b n
sorting cn produces candidate hc x e x
binder e x yields child node n associated set n fc x x g
binding set b n fe x g n independent b n
sorting cn produces candidate hc x x
add binder corresponding child candidate obtain three orderings node n hc x e x x hd x c x e x x c x x
perform folding orderings check violations adjacency
restriction order determine whether block cheaper permutation


filedeniov markovitch

first perform folding hc x e x x pair hc x e x
cn inverted cn c x j cn e x jfc x g thus unite
block block pass adjacency restriction test equation
cost hc x e x j
cost x c x j

therefore ordering mc contradicting discarded
perform folding hd x c x e x cn x j cn c x jfd x g
pair cn inverted unite block block
pass adjacency restriction test
cost hd x c x j
cost hc x x j

ordering rejected even folding finished continue
folding process shall see subgoal e x must added
block since cn hd x c x j cn e x jhd x c x

perform folding x c x x cn e x j cn c x jfe x g
pair cn inverted form block ec x x c x
passes adjacency restriction test
cost x c x j
cost hc x e x j

compute control values block
cost ec x j
nsols ec x j
cn ec x j
cn x jfec x g thus pair hec x x cn ordered folding
needed add folded candidate hec x x candidate set
n

perform merging candidate set n fha big candidate set
n fhec x x ig resulting sequence max blocks must sorted cn

cn cn b cn ec x j cn x jfec x g
merged ordering hec x x bi added candidate set n
compare costs candidates n output cheapest one case
one candidate hec x x bi returns candidate
unfolded x c x x bi


fithe divide conquer subgoal ordering

extension completion
cost
h ai

hbi

hc x

hd x

x

hbi
hb ai
adjacency restriction test fails
hb c x

hb x

hb e x
adjacency restriction test fails
hc x
hc x e x x bi

hai
ha bi

ha c x

ha x

ha e x
adjacency restriction test fails
hd x
hd x c x e x bi
ha bi
ha b c x

ha b x

ha b e x
adjacency restriction test fails
ha c x
ha c x e x x bi

hb c x
hb c x e x x

ha x
ha x c x e x bi

x
x c x x bi
ha b c x
ha b c x e x x

hb x
hb x c x e x ai

x c x x bi complete ordering



cheapest prefix

table trace sample run set figure left column shows
cheapest prefix extracted list step middle column extensions
completions added list right column associated costs

comparison task performed
maintains list prefixes sorted cost values initially contains
empty sequence step extracts list cheapest element
adds list extensions completions prefix extensions created
set remaining subgoals dependent appending remaining subgoals
end prefix completions created set remaining subgoals
independent sorting appending entire resulting sequence prefix
extension added list adjacency restriction test succeeds two
last subgoals make list operations faster implement heap structure
cormen et al
trace set shown table left column shows
cheapest prefix extracted list step middle column extensions
completions added list right column associated costs
looks dac orders given set eciently
compare several discrete measurements example


filedeniov markovitch

p x x x x
p x x x x
p x x x x
p x x x x
p x x x x

figure example worst case ordering variables initially free every

subset subgoals indivisible binding rest subgoals overall
complexity ordering n

performs sorting sessions one elements performs sortings
elements sortings elements adjacency restriction tested
times times creates totally different
ordered sub sequences total length creates ordered prefixes
total length

complexity analysis

minimal ordering sort independent
subsets subgoals whenever possible however offers several advantages due
divide conquer strategy
let n number subgoals initial set convenience assume
time computing control values one subgoal otherwise time
complexities must multiplied worst case complexity
n figure shows example case n set
every two subgoals share variable appear subgoals thus
subgoals cannot bind set root indivisible matter binder
chosen sets children indivisible child root must select
every remaining subgoal binder overall complexity execution
n indeed worst case complexity presence nodes tree
reduce
note even n small complex rule body n free variables
improbable practical programs worst case complexity reduced
n n move divisibility trees divisibility graphs dags
identical nodes divisibility tree subgoal set binding set represented
single vertex equivalence test tree nodes performed eciently
help trie structures aho et al subgoals sorted lexicographically
let n subgoals v shared variables appearing subgoals
already noted section partition subgoals subsets performed


fithe divide conquer subgoal ordering

n average time union data structure cormen et al chapter

worst possible case nodes divisibility tree apart
root node whose set divisible dependent set size independent set
size n overall complexity dac case
n v n
divisibility partition
nq log n
ordering independent subgoals
k

ordering dependent subgoals
q mi log k
q ki
folding

n ki
merging
k maximal possible number bindings performed remaining subset
independent assume every subgoal binds free variables happens
frequently practical logic programs k minfv g otherwise k
k equal maximal number nodes path root leaf
divisibility tree therefore height divisibility tree limited k actually
tree shallower since binders bind one shared variable
means number shared variables decrease ornode simplify formula several common cases k small
abovementioned assumption holds every subgoal binds free variables
proof terminates
v n n v n mv n log n
v n n v n mm n log n
v n n v nv log n
v n n v n n log n
generally small number v shared variables complexity
roughly bounded nv log n particular subgoals independent v
complexity n log n practical cases number shared free variables
rule body relatively small every subgoal binds free variables therefore
polynomial complexity note even rule body program
text contains many free variables usually become bound rule head
unification performed e start ordering instantiated body

learning control knowledge ordering

ordering described previous sections assume availability correct
values average cost number solutions predicates argument
bindings section discuss control knowledge obtained learning
instead static exploration program text debray lin etzioni
adopt markovitch scott learn control knowledge
collecting statistics literals proved past learning
performed line line latter case ordering system first works
training set queries collecting statistics training set built


filedeniov markovitch

distribution user queries seen past assume distribution queries
received system change significantly time hence past distribution
directs system learn relevant knowledge future queries
proving queries learning component accumulates information control values average cost number solutions literals storing separate
value literal practical two reasons first large space required
second lack generalization ordering quite
likely encounter literals seen whose control values
unknown recall transformed equation equation moved
control values single literals average control values sets literals obtain
precise averages sets still needed control values individual literals
take different learning control values general
classes literals estimated cost nsols value class defined average
real cost nsols value examples class proved past
refined classes smaller variance real control values inside
class precise cost nsols estimations classes assign members better orderings obtain one easy way define classes modes
binding patterns debray warren ullman vardi argument denote whether free bound example predicate father
possible classes father free free father bound free father free bound
father bound bound receive literal example father abraham x
easily determine binding pattern case father bound free retrieve control information stored class course binding pattern
subgoal given binding set need method determine variables
bound subgoals binding set arose dpart computation
section shall discuss practical ways solve section
purpose class definition use regression trees type decision tree
classifies continuous numeric values discrete classes breiman et al
quinlan two separate regression trees stored every program predicate
one cost values one nsols tests tree nodes defined
ways use test argument bound classes literals
defined regression trees coincide classes defined binding patterns
apply sophisticated tests syntactic e g third argument term
functor f semantic e g third argument female leads
refined classes better estimations possible regression tree estimating
number solutions predicate father shown figure
semantic tests arguments require logic inference example figure
invoking predicate female first argument literal therefore must
ecient possible otherwise retrieval control values take much time
ecient learning control values considered elsewhere ledeniov
markovitch
several researchers applied machine learning techniques accelerating logic inference
cohen dejong mooney langley markovitch scott minton
mitchell keller kedar cabelli mooney zelle prieditis mostow
works used explanation learning generalized caching tech

fithe divide conquer subgoal ordering

average
test bound arg

yes



average
test female arg

yes
average

average
test bound arg



yes

average
test bound arg

average

yes



average

average


average

figure regression tree estimates number solutions father arg arg
niques avoid repeated computation others utilized acquired knowledge clause selection none works however dealt subgoal
reordering

experimentation
test effectiveness ordering experimented
domains compared performance ordering experiments
performed randomly created artificial domains tested performance
system several real domains

experimental methodology
experiments described consist training session followed testing session
training testing sets queries randomly drawn fixed distribution
training session collect control knowledge literal classes testing session
prove queries testing set different ordering compare
performance measurements
goal ordering reduce time spent prolog interpreter
proves queries testing set time sum time spent ordering
procedure ordering time time spent interpreter inference time since
cpu time known sensitive irrelevant factors hardware software
programming quality two alternative discrete measurements total
number clause unifications total number clause reductions performed
number reductions ects size proof tree
experimentation used version lassy system markovitch scott
regression trees learning ordering discussed



filedeniov markovitch

experiments artificial domains

order ensure statistical significance comparing different ordering
experimented many different domains purpose created
set artificial domains small fixed set predicates random
number clauses predicate random rule lengths predicates
rule bodies arguments rule heads bodies randomly drawn fixed
distributions domain training testing sets two sets
intersect
training examples fed system learning phase better
estimations control values produces hand learning time must limited seeing certain number training examples examples bring
much information additional learning becomes wasteful experimentally
built learning curve shows dependence quality control knowledge
amount training curve suggests control values learned
approximately literals significant improvement quality ordering
training examples therefore subsequent experiments stopped training
cost values learned training time small one learned cost
value corresponds complete proof literal thus every predicate program
four clauses define cost values learned unifications
small time
control values learned means regression trees section simple
syntactic tests checked whether argument bound whether argument term certain functor list functors created automatically
domain loaded however shall see even simple tests succeeded
making good estimations control values
tested following ordering methods
random subgoals permuted randomly control knowledge
used
building ordered prefixes prefixes permutation
one another cheapest one retained
best first search method used define
next processed prefix similar used lassy system markovitch
scott
b adjacency restriction test added
similar described smith genesereth
b whenever subgoals
prefix independent binding prefix sorted
appended prefix one unit
dac
experiments used bubble sort sort literals independent sets easy implement known ecient small


fithe divide conquer subgoal ordering

ordering
method
random


b



unifications reductions ordering inference total ord time
time
time time reductions






















table effect ordering tree sizes cpu time mean artificial
domains

sets elements already ordered nearly ordered practice programmers
order program rules optimally sorting stops early
since non deterministic nature random method introduces additional noise
performed artificial domain experiments method table
presents average values measurements
table shows obtained domains rows correspond ordering
methods used columns measurements taken rightmost column shows
ratio ordering time number reductions performed ects
average ordering time one rule body inference time measured separately
set difference total time ordering time
several observations made
dac ordering helps reduce total time proving testing
set queries factor compared random ordering inference time
reduced factor
deterministic ordering methods similar number unifications reductions
similar inference time predictable since minimal orderings
small uctuations values explained fact rules
several minimal orderings existing control knowledge different ordering
select different minimal orderings since control knowledge
absolutely precise real execution costs orderings may different
leads differences random ordering method builds much larger trees
larger inference time
compare performance deterministic see
dac performs much better build ordered
prefixes latter ones ordering expensive smaller inference time
cannot compensate increase ordering time combination
several ideas previous researchers total time comparable time
random method though still greater


filedeniov markovitch

may seem strange simple random ordering method larger ordering time
sophisticated explain note random method
creates much larger proof trees average therefore number ordered rules
increases even cheap operations random ordering rule sum
considerable time average time spent ordering one rule shown
last column table value small random method

experiments real domains

tested ordering real domains obtained sources
domains allow us compare orderings performed orderings performed human programmers
following domains used
moral reasoner taken machine learning repository university
california irvine domain qualitatively simulates moral reasoning whether
person considered guilty given aspects character
crime performed
depth first planner program book art prolog sterling
shapiro program implements simple planner blocks world
biblical family database database similar described example
appletalk domain describing physical layout local computer network
markovitch
benchmark prolog benchmark taken cmu artificial intelligence repository predicate names informative example program
manual ordering dicult
slow reverse another benchmark program source
geography benchmark program cmu repository domain
contains many geographical facts countries
table shows obtained ordering used dac literal
classes defined binding patterns seen dac able speed
logic inference real domains well note slow reverse domain
programmer ordering already optimal thus applying ordering
reduce tree sizes still overhead ordering significant

discussion

concluding section discuss several issues concerning practical implementation
dac several ways increase eciency survey
related areas logic programming propose use dac
url http www ics uci edu mlearn mlrepository html
url http www cs cmu edu afs cs cmu edu project ai repository ai html air html



fithe divide conquer subgoal ordering

domain

without ordering
ordering
gain ratio
unifications seconds unifications seconds time time
moral reasoner



depth first planner



biblical family



appletalk



benchmark



slow reverse



geography



table experiments real domains

practical issues

subsection would address several issues related implementation
applications dac
computation dpart function section requires procedure computing set variables bound given binding set subgoals procedure
needed computing control values section several possible ways
implement procedure example
easiest way assume every subgoal binds variables appearing
arguments simplistic assumption sucient many domains especially
database oriented ones however appropriate logic programs used
manipulate complex data structures containing free variables difference
lists assumption used experiments described section
dialects prolog logic languages support mode declarations provided
user somogyi et al b declarations available easy
infer binding status variable upon exiting subgoal
even user supply enough mode declarations often
inferred structure program means static analysis debray
warren note however pointed somogyi et al b
one yet demonstrated mode inference guaranteed
accurate mode information every predicate program
learn sets variables bound classes subgoals methods similar
described section learning control values
several researchers advocate user declarations available permitted modes
declarations elegantly incorporated prune branches violate
available modes fix binder node compute set variables
become bound violation available mode one
subgoals corresponding child whole subtree child pruned note
detect violations even mode subgoal partially unknown


filedeniov markovitch

candidateset b
let fs sk g dpart b
case


k shared vars indivisible b
loop
b fag violate available modes
subgoal n fag

let c candidateset
fin fag b faog
n

let c
fold ako b fifi c
else let
c enter branch

return c

figure changes make use available mode declarations
rest remains unchanged

moment example available modes require first argument
unbound binding argument node binder trigger pruning
even binding status arguments yet known figure shows
changed order incorporate declarations available modes
correctness requirement treated similar manner candidate ordering
rejected whenever see violates requirement
experiments described section performed prolog interpreter
possible combine dac prolog compiler several ways
achieve goal one way allow compiler insert code line learning
compiled code contain procedures accumulating control values dac
alternatively line learning implemented training part
compilation process
another method combining existing prolog compilers use
program transformation process transformed program standard
compiler elsewhere ledeniov markovitch describe method classifying
orderings produced dac rule build classification tree
classes different orderings rule body tests applied
rule head arguments type tests described section learning
control values figure shows two examples trees
given classification tree write set prolog rules rule
head original rule body built tests path
tree root leaf node followed ordering leaf example second
tree figure yields following set rules


fithe divide conquer subgoal ordering

classification tree rule
uncle x example

nonvar
yes



parent z brother z x
brother z x parent z
nonvar x
yes

possible classification tree rule
head x

male x

p x p p x

yes
p x p x p



nonvar



yes



p p x p x

p x p p x

p x p x p

figure examples classification trees learn rule body orderings

head x
head x
head x
head x

nonvar x male x p x p x p
nonvar x male x p x p p x
var x nonvar p p x p x
var x var p x p x p

table see dac helped reduce inference
time factor total time reduced factor difference
caused additional computation ordering procedure danger
benefit obtained ordering outweighed cost ordering process
manifestation called utility minton markovitch scott
systems strongly moded mercury somogyi et al b
employ dac statically compilation time one available modes
thus reducing run time ordering time zero mode performs
syntactic tests subgoal arguments classification tree method described
generalization mode allowing semantic tests well
due insucient learning experience lack meaningful semantic tests quite
possible classification trees contain leaves large degrees error cases
still need perform ordering dynamically reduce harmfulness utility
case dynamic ordering use cost sensitive variation dac
ledeniov markovitch b modified deals
explicit reasoning economy control process
anytime stopped moment return currently best ordering
boddy dean learn resource investment function compute expected
return speedup time additional control time function used determine
stopping condition anytime procedure implemented framework
found indeed succeeded reducing ordering time without significant increase
inference time


filedeniov markovitch

relationship works

work described continuation line initiated smith
genesereth continued natarajan markovitch scott
line aims finding ecient ordering set subgoals
search minimal cost ordering cost analysis utilizes available information
cost number solutions individual subgoals
smith genesereth performed exhaustive search space
permutations given set subgoals adjacency restriction reduce
size search space equation restriction applied pairs adjacent
subgoals global ordering entire set applied independent set
subgoals adjacency restriction easily transformed sorting restriction
subgoals minimal ordering must sorted cn values natarajan arrived
conclusion presented ecient ordering independent sets
dac uses subgoal dependence break set smaller subsets independent subsets sorted dependent subsets recursively ordered resulting
orderings merged generalization adjacency restriction manipulates
blocks subgoals therefore dac generalization
last decade significant effort went static analysis sa
logic programs three types sa exploited dac
reduce ordering time
major part sa deals program termination de schreye decorte
dac solves termination special case eciency
finds terminating ordering orderings exist learning
set limits computation resources available subgoal execution subgoal
non terminating certain mode learning module associate high cost
particular mode consequently dac allow orderings
mode subgoal nevertheless use static termination analysis
mandatory proper operation dac exploit analysis
increase eciency learning process ordering process
learning limit set computation resources devoted execution
subgoal must high increase reliability cost estimation however
high limit lead significant increase learning time many subgoals
non terminating termination information obtained sa available use
avoid entering infinite branches proof trees ordering termination information
serve reduce size space orderings searched termination
information comes form allowed modes somogyi et al b orderings
violate modes filtered modified shown figure
termination information comes form partial order subgoals orderings
violate partial order filtered similar manner
second type sa combined dac correctness analysis program tested specifications given user
folon environment henrard le charlier designed support
methodology logic program construction aims reconciling declarative semantics ecient implementation deville construction process starts


fithe divide conquer subgoal ordering

specification converts logic description finally prolog program
rules program correct respect initial specification system performs transformations reordering literals clause adding type checking
literals de boeck le charlier mention reordering
specify ordering different simple generate test method cortesi
le charlier rossi present analyzer verifying correctness prolog
program relative specification provides list input output annotations
arguments parameters used establish program termination
ordering given explicitly purpose dac complementary
purpose folon could serve auxiliary aid make resulting prolog
program ecient
recently mercury language developed university melbourne somogyi
et al b mercury strongly typed strongly moded language type
mode declarations supplied programmer though recent releases
mercury system already support partial inference types modes somogyi et al
compiler checks mode declarations predicates satisfied
necessary reorders subgoals rule body ensure mode correctness rejects
program neither ordering satisfies mode declaration constraints compiler
performs reordering consider eciency issue often happens
several orderings rule body satisfy mode declaration constraints cases
mercury compiler could call static version dac select
ecient ordering another alternative augment dac mode declaration
checks shown figure
note mercury purely declarative logic programming language therefore
suitable subgoal reordering prolog non logical constructs
could destroy declarative semantics give logic programs power mercury
even declarative
third type relevant sa cost analysis logic programs debray lin
braem et al debray et al cortesi et al describe cost formula
similar equation select lowest cost ordering however used generate andtest sometimes prohibitively expensive static analysis cost
number solutions used obtain control values instead learning
eciency logic programs increased methods program transformation pettorossi proietti one popular approaches
rules strategies consists starting initial program
applying one elementary transformation rules transformation strategies metarules prescribe suitable sequences applications transformation rules
one possible transformation rules goal rearrangement rule transforms
program transposing two adjacent subgoals rule body obviously ordering
rule body transformed ordering finite number
transpositions thus static subgoal ordering considered special case program
transformation goal rearrangement rule used hand dynamic
semi dynamic ordering methods cannot represented simple transformation rules
since make use run time information expressed bindings rule body subgoals


filedeniov markovitch

obtain unifications rule heads may order rule body differently
different circumstances
program transformation technique called compiling control bruynooghe de schreye
krekels pettorossi proietti follows different
trying improve control strategy logic programs instead enhancing naive
prolog evaluator better often complex computation rule program
transformed derived program behaves naive evaluator exactly
initial program would behave enhanced evaluator forms compiling control
first translate initial program standard representation example
unfolding tree complex computation rule used program
constructed representation naive computation rule mind
reordering rule body subgoals regarded moving complex computation
rule selects subgoals order dictated ordering case
dac computation rule may complex simple use compiling
control methods nevertheless easily incorporated special compiling control
method section described method program rewriting first builds
classification trees orderings performed past uses
classification trees constructing clauses derived program derived program
eciently executed naive computation rule prolog technique
fact kind compiling control important property use knowledge collected
experience orderings made past
one transformation method significantly benefit dac
unfolding tamaki sato unfolding process subgoals replaced
associated rule bodies even initial rules ordered optimally human
programmer static ordering procedure resulting combined sequence may far
optimal therefore could advantageous use dac reordering
unfolded rule rules become longer potential benefit ordering grows
danger high complexity ordering procedure overcome
cost sensitive version dac section

conclusions
work study subgoal ordering logic programs present
theoretical base practical implementation ideas empirical
confirm theoretical predictions combine ideas smith genesereth
simon kadane natarajan novel ordering
conjunctive goals aimed minimizing time logic interpreter
spends proof given conjunctive goal
main described dac section works dividing sets subgoals smaller sets producing candidate
sets orderings smaller sets combining candidate sets obtain orderings
larger sets prove finds minimal ordering given set
subgoals eciency practical assumptions
employed statically reorder rule bodies program text execution


fithe divide conquer subgoal ordering

starts semi dynamically reorder rule body reduction performed
dynamically reorder resolvent every reduction subgoal rule body
several researchers minker warren naish b nie plaisted
proposed heuristics subgoal ordering though fast methods
guarantee finding minimal cost orderings provably finds minimal cost
ordering though ordering may take time heuristic methods
future seems promising incorporate heuristics dac example
heuristics used grade binders nodes rather exhaustively trying
subgoals binders could try one several binders thus reducing ordering
time current version ordering suitable finding
solutions conjunctive goal would extend finding one
solution fixed number solutions
another interesting issue adaptation dac
interleaving ordering methods section subgoals rule body added
ordered resolvent seems wasteful start complete ordering process
use information stored existing ordering resolvent perhaps whole
divisibility tree resolvent stored nodes updated subgoals
rule body added resolvent
ordering needs control knowledge work control knowledge
average cost number solutions literals learned training
collecting statistics make assumption distribution queries received
system change time thus training set distribution
seen past system learns relevant knowledge future queries consider
issue learning control values thoroughly another ledeniov markovitch
together issues concerning dac minimizing
total time instead minimizing inference time
ullman vardi showed ordering subgoals obtain termination inherently exponential time work substantially
harder must order whose execution terminates finite time one
terminates minimal finite time impossible ecient
cases dac however ecient practical cases graph
representing subgoal dependence figure sparsely connected
implemented dac tested artificial real domains
experiments speedup factor compared random ordering
compared alternative ordering
dac useful many practical applications formal hardware
verification become extremely important semiconductor industry model
checking currently widely used technique generally agreed coping
increasing complexity vlsi design requires methods theorem proving
main obstacle preventing use automatic theorem proving high computational
demands dac may used speeding logic inference making use
automatic theorem provers practical
logic gained increasing popularity representation common sense knowledge
several advantages including exibility well understood semantics indeed
cyc project lenat recently moved frame representation logic

filedeniov markovitch

representation however large scale knowledge bases likely present
significant eciency inference engines automatic subgoal ordering
techniques described may help solve
issue subgoal ordering obtains significance development inductive logic programming lavrac dzeroski muggleton de raedt systems
foil quinlan cameron jones try build correct
programs fast possible without considering eciency produced programs
combining dac inductive logic programming techniques
synthesis logic programs deductive constructive approaches
looks promising direction

appendix proof lemma

appendix present proof lemma omitted main text
reasons compactness prove two auxiliary lemmas

lemma

let two ordered sequences subgoals b set subgoals value
cn ka jb lies values cn jb cn jb


proof

denote c cost jb
n nsols jb
cn cn jb
c cost jb n nsols jb cn cn jb
c cost ka jb n nsols ka jb cn cn ka jb
cn n n n n n n








c

c
c
n
n


c
n c
c c c c cn c n c cn cc cn nc c cn




n
c
c

cn lies cn cn c c positive
exactly point cn divides segment cn cn ratio

sum

cn cn cn cn n c c

words cn weighted average cn cn note c amount
resources spent proof tree b n c resources spent tree b
c sum time relatively dedicate proof b closer
cn cn conclusion generalized larger number components
concatenation proof induction
cost jb
cn ka k k jb
cn jb
cost ka k k jb
nsols jb cost jb

cn jb
cost ka k k jb
nsols ka k k jb cost k jb k

cn k jb k
cost ka k k jb


fithe divide conquer subgoal ordering



lemma
let set subgoals n node divisibility tree let n
q ka ka kr ordering n cn equal max blocks cn jb n q
cn jb n q
let ancestor n ordering consistent n


violated max blocks
max blocks stand cn equal belong
max block mc contradicting
proof induction distance n n
max blocks lemma holds let n let child whose

descendant n inductive hypothesis lemma holds n let






projection om violated om since violated

max blocks inductive hypothesis maxblocks stand cn equal node
subgoals enter node insertion

subgoals possible violates blocks places max blocks ordered cn
mc contradicting corollary lemma mccontradicting max blocks inserted must cn equal

assume max blocks without loss generality
let member larger max block must participate
max block
since joined larger block must exist another block b adjacent
pair cn inverted let b stand left opposite case
cn inverted e
proof similar x kb ka ky ka kz pair hb




cn b jb x cn jb x b lemma cn b ka jb x cn jb x b
must add block b ka blocks cn equal
cn jb x b cn jb x b must added
block thus belong max block
belong max block block violated
former case mc contradicting corollary
latter case belong max block
mc contradicting mc contradicting proof easy


prove lemma

lemma
let set subgoals n node divisibility tree n q ka ka kr


filedeniov markovitch

ordering n max blocks mutually independent
cn equal bindings b n q n blockwise equivalent n
q ka ka kr

proof

let minimal ordering binder consistent n corollary

violate blocks n particular x ka ky ka kz let joo nn
x ka ky ka kz must minimal implies blockwise equivalence
n n
empty cost cost lemma adjacent mutually
independent cn equal thus transposition change cost
empty corollary mutually independent
binder consistent n therefore b n x consequently b n
divided several blocks one cn equal since
minimal n cannot mc contradicting claim follows lemma
lemma cn jx cn jx cn jx lemma

cost cost x ka ky ka kz
cost x ka ka ky kz
cost x ka ka ky kz
cost x ka ky ka kz






swap
swap
swap
cost

minimality implies blockwise equivalence n n



appendix b correctness dac

section dac correct e given set subgoals
returns minimal ordering suces candidate set root node
dtree valid case follows definition valid sets must
contain minimal ordering returns one cheapest candidates
root therefore candidate set root valid dac must return
minimal ordering
start defining strong validity sets orderings prove strong
validity implies validity finally use induction prove theorem showing
candidate set produced node divisibility tree strongly valid
definition let set subgoals n node divisibility tree set
cn n strongly valid every ordering n ncn mc contradicting
blockwise equivalent member cn unless ordering n min consistent

stronglyv alidn cn
n n mcn n n n n cn mccn n
n cn mcen n n








lemma strongly valid set orderings valid


fithe divide conquer subgoal ordering

proof let set subgoals n node divisibility tree c n
strongly valid set orderings n
min consistent ordering n c n valid definition
valid set section
otherwise exists least one minimal ordering binder consistent n
every ordering n n c n mc contradicting blockwise equivalent
member c n prove c n valid must contains
ordering n binder consistent minimal ordering
let minimal ordering binder consistent n let n projection
n n c n done n n otherwise n n n
c n n cannot mc contradicting min consistent therefore must
blockwise equivalent n c n blocks n violated since

minimal corollary therefore substitution joo n well defined minimal
n
since minimal n n blockwise equivalent binder consistent
n since binder consistent n thereupon n satisfy requirements
validity n n

theorem
let set subgoals node n divisibility tree
creates strongly valid candidate set orderings

proof induction height n subtree
inductive base n leaf node means n independent b n

candidate set n contains one element whose subgoals sorted cn
orderings belong n n candset n sorted cn
hence mc contradicting lemma sorted cn hence blockwiseequivalent candidate corollary consequently candset n strongly
valid
inductive hypothesis children n produces strongly valid candidate sets
inductive step internal node divisibility tree node ornode
n node let n n nk children n first
consset n strongly valid
let n n n consset n k let projection
n ni set projections fo k g belong one three
following types regard n
sets first type contain least one mc contradicting projection
case n mc contradicting assume contrary exists
minimal ordering binder consistent n let mccontradicting projection since consistent n consistent


filedeniov markovitch

since b ni b n subgoals b ni appear
subgoals ni therefore binder consistent since
minimal min consistent mc contradicting contradiction
b sets second type contain mc contradicting projections
n block projection violated max blocks different
projections ordered cn case n mc contradicting
corollary lemma
c sets third type contain mc contradicting projections
max blocks projections violated n sorted cn
every projection belongs candset ni candset ni
exists candset ni blockwise equivalent
candset ni strongly valid inductive hypothesis
mc contradicting candset ni set


let n n joo joo joo kk substitution well defined since
number max blocks max blocks projections
violated n let minimal ordering binder consistent
n since minimal blocks violated since

blockwise equivalent ordering joo well defined
minimal positions subgoals b n change
thus min consistent blockwise equivalence


entails minimality ordering joo joo joo continue


finally obtain joo joo joo kk minimal

definition n joo nn note introduced blockwise equivalence
strong validity able perform transition minimal
therefore n blockwise equivalent n n consset n since
projections candidates child nodes thereupon n blockwiseequivalent member consset n
consset n strongly valid prove candset n strongly valid
suces members consset n included
candset n mc contradicting blockwise equivalent
members candset n orderings three types
orderings violate blocks children projections mccontradicting corollary
b orderings violate blocks max blocks children projections ordered cn mc contradicting lemma
c orderings violate blocks sorted cn
combination projections one consistent ordering n retained
candidate set rejected corollary rejected
orderings blockwise equivalent retained candidate
consequently candset n strongly valid

































fithe divide conquer subgoal ordering

n node start showing consset n strongly
valid
let n n n consset n n constructed binder h
tail sequence n h kt let nh child n corresponds
binder h inductive hypothesis candset nh strongly valid
candset nh since otherwise n consset n therefore mc contradicting blockwise equivalent candset nh
mc contradicting n mc contradicting proof contradiction nodes blockwise equivalent n h kt
blockwise equivalent h kt consset n proof easy hence
consset n strongly valid orderings consset n included candset n dac cheaper permutations
leading max blocks therefore mc contradicting lemma hence
candset n strongly valid


corollary candidate set found root node valid
corollary finds minimal ordering given set subgoals

references

aho v hopcroft j e ullman j data structures
addison wesley
boddy dean solving time dependent sridharan n ed proceedings th international joint conference artificial
intelligence pp detroit mi usa morgan kaufmann
bol r n apt k r klop j w analysis loop checking mechanisms
logic programs theoretical computer science
braem c le charlier b modar van hentenryck p cardinality analysis
prolog bruynooghe ed logic programming proceedings
international symposium pp massachusetts institute technology
mit press
breiman l friedman j h olshen r stone c j classification
regression trees wadsworth international group belmont ca
bruynooghe de schreye krekels b compiling control journal
logic programming
clark k l mccabe f control facilities ic prolog michie ed
expert systems microelectronic age pp university edinburgh
scotland
clocksin w f mellish c programming prolog third edition springerverlag york


filedeniov markovitch

cohen w w learning approximate control rules high utility proceedings
seventh international machine learning workshop pp austin texas
morgan kaufmann
cormen h leiserson c e rivest r l introduction mit
press cambridge mass
cortesi le charlier b rossi specification automatic verification
prolog programs gallagher j ed proceedings th international workshop logic program synthesis transformation vol lncs pp
stockholm sweden springer verlag
de boeck p le charlier b static type analysis prolog procedures ensuring
correctness deransart p maluszynski j eds programming languages
implementation logic programming vol lncs pp linkoping
sweden springer verlag
de schreye decorte termination logic programs never ending
story journal logic programming
debray lopez garca p hermenegildo lin n w lower bound cost
estimation logic programs maluszynski j ed proceedings international symposium logic programming ilps pp cambridge mit
press
debray k lin n w cost analysis logic programs acm transactions
programming languages systems
debray k warren automatic mode inference logic programs
journal logic programming
dejong g mooney r explanation learning alternative view machine learning
deville logic programming systematic program development international
series logic programming addison wesley
etzioni static space compiler prodigy dean thomas
l mckeown k ed proceedings th national conference artificial
intelligence pp anaheim california mit press
etzioni acquiring search control knowledge via static analysis artificial intelligence
greiner r orponen p probably approximately optimal satisficing strategies
artificial intelligence
henrard j le charlier b folon environment declarative construction
logic programs bruynooghe wirsing eds proceedings fourth
international symposium programming language implementation logic programming vol lncs pp leuven belgium springer verlag


fithe divide conquer subgoal ordering

itai makowsky j unification complexity measure logic programming journal logic programming
knuth e art computer programming vol addison wesley reading
mass
kowalski r logic control communications acm

laird p ecient dynamic optimization logic programs proceedings
ml workshop knowledge compilation speedup learning aberdeen
scotland
langley p learning search weak methods domain specific heuristics
cognitive science
lavrac n dzeroski inductive logic programming techniques applications artificial intelligence ellis harwood york
ledeniov markovitch controlled utilization control knowledge
speeding logic inference tech rep cis technion haifa israel
ledeniov markovitch b learning investment functions controlling
utility control knowledge proceedings fifteenth national conference
artificial intelligence pp madison wisconsin morgan kaufmann
lenat b cyc large scale investment knowledge infrastructure communications acm
lloyd j w foundations logic programming second edition springer verlag
berlin
markovitch scott p automatic ordering subgoals machine learning
lusk e l overbeek r eds proceedings north american
conference logic programming pp cleveland ohio mit press
markovitch information filtering selection mechanisms learning systems
ph thesis eecs department university michigan
markovitch scott p information filtering selection mechanisms
learning systems machine learning
minker j search strategy selection function inferential relational system
acm transactions database systems vol pp
minton learning search control knowledge explanation
kluwer boston
mitchell keller r kedar cabelli explanation generalization unifying view machine learning


filedeniov markovitch

mooney r j zelle j combining foil ebg speed logic programs
bajcsy r ed proceedings thirteenth international joint conference
artificial intelligence pp chambery france morgan kaufmann
morris k ordering subgoals nail proceedings
seventh acm sigact sigmod symposium principles database systems pp
austin tx acm press york
muggleton de raedt l inductive logic programming theory methods
journal logic programming
naish l mu prolog db reference manual dept computer science univ
melbourne
naish l automatic control logic programs journal logic programming

naish l b prolog control rules joshi ed proceedings th international joint conference artificial intelligence pp los angeles ca
morgan kaufmann
natarajan k optimizing backtrack search solutions conjunctive mcdermott j ed proceedings th international joint conference
artificial intelligence pp milan italy morgan kaufmann
nie x plaisted experimental subgoal ordering ieee
transactions computers vol pp
pettorossi proietti transformation logic programs foundations
techniques journal logic programming
pettorossi proietti rules strategies transforming functional
logic programs acm computing surveys
porto epilog language extended programming campbell j ed
implementations prolog ellis harwood
prieditis e mostow j prolearn towards prolog interpreter
learns forbus kenneth shrobe h ed proceedings th national conference artificial intelligence pp seattle wa morgan kaufmann
quinlan j r induction decision trees machine learning
quinlan j r cameron jones r induction logic programs foil
related systems generation computing special issue inductive logic programming
simon h kadane j b optimal solving search none solutions artificial intelligence
smith e controlling backward inference artificial intelligence


fithe divide conquer subgoal ordering

smith e genesereth r ordering conjunctive queries artificial intelligence
smith e genesereth r ginsberg l controlling recursive inference
artificial intelligence
somogyi z henderson f conway bromage dowd jeffery al
status mercury system proc jicslp workshop parallelism
implementation technology constraint logic programming languages pp
bonn germany
somogyi z henderson f conway b execution mercury
ecient purely declarative logic programming language journal logic programming
sterling l shapiro e art prolog second edition mit press cambridge
tamaki h sato unfold fold transformation logic programs tarnlund

ed proceedings second international conference logic programming pp uppsala sweden
ullman j vardi complexity ordering subgoals proceedings
seventh acm sigact sigmod symposium principles database systems
pp austin tx acm press york
ullman j principles database systems computer science press rockville
md
vasak potter j metalogical control logic programs journal logic
programming
warren h ecient processing interactive relational database queries
expressed logic zaniola delobel eds proceedings th international
conference large data bases pp cannes france ieee computer
society press




