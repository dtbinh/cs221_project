Journal Artificial Intelligence Research 9 (1998) 99{137

Submitted 10/97; published 9/98

Computational Aspects Reordering Plans
Christer Backstrom

Department Computer Information Science
Linkopings universitet, S-581 83 Linkoping, Sweden

cba@ida.liu.se

Abstract

article studies problem modifying action ordering plan order
optimise plan according various criteria. One criteria make plan
less constrained minimize parallel execution time. Three candidate
definitions proposed first criteria, constituting sequence increasing
optimality guarantees. Two based deordering plans, means ordering relations may removed, added, third one uses reordering,
arbitrary modifications ordering allowed. shown weakest one
three criteria tractable achieve, two NP-hard even dicult
approximate. Similarly, optimising parallel execution time plan studied
deordering reordering plans. general case, computations
NP-hard. However, shown optimal deorderings computed polynomial
time class planning languages based notions producers, consumers
threats, includes commonly used planning languages. Computing optimal reorderings potentially lead even faster parallel executions, problem
remains NP-hard dicult approximate even quite severe restrictions.

1. Introduction
many applications plans, made man computer, executed, important find plans optimal respect cost measure, typically execution
time. Examples applications manufacturing error-recovery industrial
processes, production planning, logistics robotics. Many different kinds computations made improve cost plan|only extensively
studied literature. well-known frequently used scheduling. plan tells actions (or tasks) order them,
schedule assigns exact release times actions. schedule must obey action
order prescribed plan must often satisfy metric constraints
deadlines earliest release times certain actions. schedule feasible satisfies
metric constraints. usually interesting find schedule optimal
respect, eg feasible schedule shortest total execution time, schedule
missing deadlines actions possible.
principle, planning scheduling follow sequence scheduling
viewed post-processing step planning|where planning concerned causal
relations qualitative temporal relations actions, scheduling concerned
metric constraints actions. planning systems, eg O-Plan (Currie & Tate,
1991) Sipe (Wilkins, 1988), planning scheduling integrated one
single system. Similarly, temporal planners, eg Deviser (Vere, 1983) IxTeT (Ghallab
& Laruelle, 1994), often reason metric constraints. make
c 1998 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiBackstro

irrelevant study planning scheduling separate problems, though, seen
vast literature topics. two problems quite different character
studying separately gives important insight integrated systems
discussed. instance, Drabble1 says often dicult see
O-Plan plans schedules; easy see O-Plan works, dicult
see why.
complication understanding difference planning scheduling,
integrated systems systems separated planning scheduling,
certain types computations fall grey zone planning scheduling.
Planners good reasoning effects actions causal relationships
actions, usually poor reasoning time temporal relationships
actions. Schedulers, hand, primarily designed reason
time resource con icts, capabilities reasoning causal dependencies
actions. problems grey zone require reasoning kinds, neither
planners schedulers handle problems properly. problems
solved, scheduler get sucient information planner
best situation|the planner scheduler may fail cooperation find
plan feasible schedule, even plan exists.
article focusses one grey-zone problems, namely problem optimising action order plan allow better schedules. Whenever two actions con ict
cannot allowed execute parallel, planner must order
actions. However, usually enough information reasoning capabilities
decide two possible orders best one, makes arbitrary choice.
One choices typically allows better schedule one, planner
makes wrong choice may prevent scheduler finding good, even feasible,
schedule. situation arises plans made human expert, since difficult see choice ordering best one large complex plan. Planning
systems today usually cannot anything better asking planner new plan
scheduler fails find feasible schedule. expensive unsatisfactory
solution, especially feedback scheduler help planner making
intelligent choice next time. Another solution appears literature
use filter planner scheduler attempts modify plan order
put scheduler better position. filters could remove certain over-commitments
ordering, referred deordering plan, even change order
certain actions, referred reordering plan.
article intended provide first formal foundation studying type
problems. defines number different optimality criteria plan order modifications,
respect degree over-committment ordering respect
parallel execution time, provides computational results computing
modifications. article analyses filtering algorithms suggested literature
order modifications.
remainder article structured follows. Section 2 introduces concepts
computations studied article means example. Section 3 starts
1. Brian Drabble, personal communication, Aug. 1997.

100

fiComputational Aspects Reordering Plans

theoretical content article, defining two planning formalisms used following
sections. problems making plan least-constrained studied Section 4
candidate definitions concept introduced computational properties investigated. Section 5 defines concepts parallel plans parallel executions
plans. followed Section 6 optimal deorderings reorderings parallel
plans introduced complexity achieving optimality analysed. Section 7
studies complexity problems affected restricting language.
includes positive result algorithm literature finds optimal deorderings class plans common planning languages. filtering
algorithms literature well planners incorporating ordering optimisation discussed Section 8. Finally, Section 9 discusses aspects article
related work, Section 10 concludes brief recapitulation results.

2. Example
order illustrate concepts operations studied article simple example
assembling toy car used. example variation example used
Backstrom Klein (1991), much simplified version existing assembly line
toy cars used undergraduate laborations digital control Linkoping University
(for description assembly line, see eg. Klein, Jonsson, & Backstrom, 1995, 1998;
Stromberg, 1991). problem assemble LEGO2 car pre-assembled parts
shown Figure 1. chassis, top set wheels, two latter mounted
onto chassis.
Top

Chassis

Car

Wheels

Figure 1: Schematic assembly process toy car
workpiece ow factory shown Figure 2. three storages, one
type preassembled part, two workstations, number 1 mounting top
number 2 mounting wheels, car storage assembled cars. Tops
moved top storage workstation 1 sets wheels moved
2. LEGO trade mark LEGO company

101

fiBackstro

wheels storage workstation 2. Chassis moved chassis storage either
workstation also, possibly parts mounted, two workstations
either workstation car storage. Furthermore, mounting wheels
chassis, tyres must ated, workstation 2 incorporates compressed-air container
must pressurized ating tyres (this shown figure).

Top
Storage

Workstation 1

Chassis
Storage
Wheels
Storage

Car
Storage
Workstation 2

Figure 2: Schematic lay-out toy-car factory
article concerned modifying order actions given plan,
consider modifying set actions. Hence, example assume
plan assembling toy car given|whether plan produced hand
planning algorithm important. assumed assembly plan
contains exactly actions listed Table 1, order. Since results
article independent particular planning language used, assumptions
planning language made example either. make things simple,
obvious common-sense constraints plans valid used. instance,
part must moved workstation mounted there, wheels must ated
mounted air container must pressurized ating tyres.
Furthermore, since chassis one single place time, top cannot
mounted parallel mounting wheels, neither mounting operations
done parallel moving either chassis part mounted.
purpose modifying action order given plan usually optimize
plan aspect, instance, make plan least constrained. Consider totally
ordered plan Figure 3a, producing chassis wheels, subplan
plan assembling car. Note since plan totally ordered, pairs actions
ordered, implicit transitive arcs shown figure. plan clearly
over-constrained. instance, necessary move set wheels workstation
2 pressurizing air container, removing ordering constraint results
plan Figure 3b. Note orderings removed|the arc MvW2
existed already original plan, implicit transitivity. plan
orderings removed referred deordering original plan.
102

fiComputational Aspects Reordering Plans

Action
MvT1
MvW2
MvC1
MvC2
MvS
MtT
MtW
PAC


Description
Move top workstation 1
Move wheels workstation 2
Move chassis workstation 1
Move chassis workstation 2
Move chassis car storage
Mount top chassis
Mount wheels chassis
Pressurize air container
ate tyres

Duration
1
1
2
2
3
7
4
5
4

Table 1: Actions assembly plan
new plan less constrained original plan, since possible move
wheels pressurize air container either order or, perhaps, even parallel.
However, orderings removed; necessary ate wheels
moving chassis workstation. Removing ordering results plan
Figure 3c, least constrained deordering original plan sense
possible remove ordering constraints still valid plan.
is, removing ordering constraint, possible sequence
actions way plan longer intended result. addition
deorderings, one may consider arbitrary modifications ordering relation, is,
removing adding relations. modifications referred reorderings.
Three differents least-constrainment criteria plans based deorderings reorderings
studied Section 4, plan Figure 3c happens optimal according
three criteria.

MvW2 - PAC

-

- MvC2 -MtW

a) total order plan
MvW2PPPP
q

1


PAC

- MvC2 -MtW

b) less constrained version

MvW2PPPP
q1IT PPPPq

PAC
*MtW

MvC2
c) least constrained
version

Figure 3: Three plans mounting wheels
103

fiBackstro

Making plan least constrained clearly useful certain actions executed
parallel. However, even case parallel execution possible, may still
worth making plan least constrained. Although partial order least constrained
plan must strengthened total order execution purposes, need
total order original plan. Suppose actions temporal constaints
deadlines earliest release times scheduler post-process plan
try finding feasible schedule. may case original plan feasible
schedule, less constrained version sequenced feasible schedule.
idea least constrained plan scheduler many alternative execution
sequences possible choose from.
important reason modifying action ordering plan, however,
execute plan faster executing actions parallel whenever possible. purpose
better use length optimal schedule plan measure, rather
measure ordering itself. Suppose following car-assembly plan given
hMvW 2; PAC; IT; MvC 2; MtW; MvT 1; MvC 1; MtT; MvS i:
actions executed sequentially given order, minimum execution time
sum durations actions, 29 time units. However,
previous example plan over-constrained, since several actions could executed
either order, parallel.
possible remove orderings far shown Figure 4a, further,
still valid plan (the implicit transitive orderings shown figure).
deordered version original assembly plan scheduled execute 25 time units
exploiting parallelism whenever possible. example schedule shown
Figure 3b. However, faster execution possible, since plan contains subsequence
actions cannot parallelized total execution time 25 time
units.
obvious schedule Figure 4b many actions executed
parallel, gain deordering plan quite small. much better performance
possible arbitrary modifications action ordering allowed, is,
reorderings considered. instance, assembly plan particular reason
wheels mounted top mounted, seen shortly
much time saved reversing order two operations. deordering
cannot this, however, since removing ordering wheel-mounting action
(MtW) top-mounting action (MtT) would make unordered. would
interpreted two actions could executed parallel, possible.
reason actions must ordered original plan. However,
allowing arbitrary modifications, order two actions reversed,
Figure 5a shows reordering original plan. plan scheduled
execute 16 time units, considerable improvement original
plan optimal deordered version it. example optimal schedule shown
Figure 5b. fact, plan optimal reordering sense ordering
actions results valid plan scheduled execute faster. problems
finding optimal deorderings reorderings plan respect parallel execution
main topic article, studied Sections 5 7.
104

fiComputational Aspects Reordering Plans

PAC
MvW2

MvT1



MtW

MvC2

MtT

MvC1

MvS

a) deordering assembly plan admitting shortest
parallel execution time
PAC



MvW2

MtW

MvC1

MtT

MvS

MvC2
MvT1
0

5

10

15

20

25

b) optimal schedule plan

Figure 4: optimal deordering assembly plan
obvious reordering powerful operation deordering, since
reordered plan Figure 5a allows shorter schedule optimal deordering
Figure 4a. hand, original plan

hMvT 1; MvC 1; MtT; MvS; MvW 2; PAC; IT; MvC 2; MtW i;
deordering would sucient arriving optimal plan Figure 5a.

3. Planning Formalisms
section defines actions, plans related concepts, basically appear two
different guises article. Definitions tractability results mostly cast
general, axiomatic framework order general independent formalism
possible. Hardness results, hand, mostly cast specific formalism,
Ground Tweak, often subject restrictions, order strengthen
results. formalisms defined below. addition these, third formalism
used, definition deferred used, Section 7.
105

fiBackstro

PAC



MvW2

MvT1

MtT

MvC1

MvC2

MvS

MtW

a) reordering assembly plan admitting shortest
parallel execution time
PAC
MvC1



MvW2

MvT1 MtT
0

5

MtW

MvS

MvC2
10

15

b) optimal schedule plan

Figure 5: optimal reordering assembly plan

3.1 Axiomatic Planning Framework

axiomatic framework makes minimum assumptions underlying formalism. may instantiated planning formalism defines concept
planning problem domain entities called actions validity test. planning
problem assumed consist planning problem instances (ppis),3 assumptions inner structure these. validity test truth-valued function
taking ppi sequence actions arguments. validity test true ppi
action sequence ha1 ; : : : ; i, action sequence ha1 ; : : : ; said solve
. inner structure ppis exact definition validity test crucial specific planning formalism, many results article proven without
making assumptions. Results computational complexity certain
problems make assumption complexity validity test, though. Based
concepts, notion plans defined usual way.

Definition 3.1 total-order plan (t.o. plan) sequence P = ha1 ; : : : ; ani actions,
alternatively denoted tuple hfa1 ; : : : ; g; 1 k; l n,
ak al iff k < l. Given ppi , P said -valid iff validity test true

P .

3. complexity-theoretic terminology problems. Planning problem instances sense
article sometimes referred planning problems planning literature.

106

fiComputational Aspects Reordering Plans

partial-order plan (p.o. plan) tuple P = hA; set actions
strict ( ie. irre exive) partial order A. validity test extended p.o. plans
s.t. given ppi , P -valid iff hA; 0 valid every topological sorting 0 .

actions t.o. plan must executed specified order, unordered
actions p.o. plan may executed either order. is, p.o. plan viewed
compact representation set t.o. plans. implicit assumption
unordered actions executed parallel; parallel plans defined Section 5.
p.o. plans viewed directed acyclic graphs figures transitive arcs often
tacitly omitted enhance readability. Furthermore, proofs algorithms article
based definition, ie assuming order plan transitively closed,
many practical planners bother transitive closures. difference
affect results presented here.

3.2 Ground TWEAK Formalism

Ground TWEAK (GT) formalism TWEAK language (Chapman, 1987) restricted
ground actions. formalism variation propositional STRIPS known
equivalent polynomial transformation common variants propositional STRIPS (Backstrom, 1995). brief, action precondition postcondition, sets ground literals.
order define GT formalism, following two definitions required. Given
set , notion Seqs (S ) denotes set sequences formed members ,
allowing repetition elements including empty sequence. symbol `;'
used denote sequence concatenation operator. Further, given set P propositional
atoms, set LP literals P defined LP = P [ f:p j p 2 Pg. Since
formulae allowed atoms negated atoms, double negation ::p
treated identical unnegated atom p. Finally, given set literals L, negation
Neg(L) L defined Neg(L) = f:p j p 2 Lg[fp j :p 2 Lg L said consistent
iff atom p s.t. p 2 L :p 2 L.

Definition 3.2 instance GT planning problem quadruple = hP ; O; I; Gi



P finite set atoms;
finite set operators form hpre; posti pre; post LP consistent
denote pre post condition respectively;

I; G LP consistent denote initial goal state respectively.
= hpre; posti O, write pre(o) post(o) denote pre post respectively.
sequence ho1 ; : : : ; 2 Seqs (O) operators called GT plan (or simply plan) .
Definition 3.3 ternary relation valid Seqs (O) 2L 2L defined s.t. arbitrary ho1 ; : : : ; 2 Seqs (O) S; LP , valid(ho1 ; : : : ; i; S; ) holds iff either
1. n = 0
P

107

P

fiBackstro

2. n > 0, pre(o1 )
valid(ho2 ; : : : ; i; (S , Neg(post(o1 )) [ post(o1 ); ).
t.o. plan ho1 ; : : : ; 2 Seqs (O) solves iff valid(ho1 ; : : : ; i; I; G).

action unique instance operator, ie set actions may contain several
instances operator, inherits pre- post-conditions operator
instantiates. Since problems article consider fixed set actions,
atom operator sets frequently tacitly omitted GT ppis. figures,
GT actions shown boxes, precondition literals left postcondition
literals right.

4. Least Constrained Plans

seems generally assumed planning community difference t.o. plans p.o. plans sense t.o. plan easily converted
p.o. plan vice versa. However, p.o. plan trivially converted
t.o. plan low-order polynomial time topological sorting, less obvious
converse holds. least three algorithms converting t.o. plans p.o. plans
presented literature (Pednault, 1986; Regnier & Fade, 1991a; Veloso, Perez, &
Carbonell, 1990) (all algorithms analyzed later article). claim
t.o. plan easily converted p.o. plan vacuously true since t.o. plan
already p.o. plan, definition. Hence, computation needs done.
hardly algorithms intended compute, however. order useful,
algorithm must output p.o. plan satisfying interesting criterion, ideally
optimality criterion. fact, two algorithms mentioned claimed produce
optimal plans according certain criteria. instance, Veloso et al. (1990, p. 207) claim
algorithm produce least constrained plans. define mean
term, however, hardly paper literature using term
without definition.
Unfortunately, means obvious constitutes intuitive good criterion
p.o. plan least constrained and, extent, depends
purpose achieving least-constrainment. major motivation producing p.o. plans
instead t.o. plans (see instance Tate, 1975) p.o. plan post-processed
scheduler according criteria, release times deadlines resource
limits. Either actions ordered (ideally) optimal sequence or, given criteria
parallel execution, parallel plan executed faster actions
executed sequence. cases, less constrained original plan is, greater
chance arriving optimal schedule optimal parallel execution respectively.
algorithms mentioned motivated goal exploiting possible
parallelism decrease execution time.
interesting make t.o. plans partially ordered, make partially
ordered plans partially ordered, is, generalise ordering. algorithm
task presented literature context case-based planning
(Kambhampati & Kedar, 1994). Since t.o. plan special case p.o. plans,
section study general problem making partially ordered plans less constrained.
108

fiComputational Aspects Reordering Plans

4.1 Least-constrainment Criteria

is, naturally, infinitude possible definitions least-constrainment. seem
reasonable others, however. Three intuitively reasonable candidates defined
analyzed below. Although definitions possible, questionable whether
considerably better natural definitions, respect purposes mentioned
above, defined without using information usually present t.o.
p.o. plan.

Definition 4.1 Let P = hA; Q = hA; 0i two p.o. plans ppi. Then,
1. Q reordering P wrt. iff P Q -valid.
2. Q deordering P wrt. iff Q reordering P 0

3. Q proper deordering P wrt. iff Q reordering P 0

Definition 4.2 Given ppi two p.o. plans P = hA; Q = hA; 0i,
1. Q minimal-constrained deordering P wrt. iff
(a) Q deordering P wrt.
(b) proper deordering Q wrt. ;
2. Q minimum-constrained deordering P wrt. iff
(a) Q deordering P wrt.
(b) deordering hA; 00 iof Q wrt. s.t. j 00 j < j j;
3. Q minimum-constrained reordering P wrt. iff
(a) Q reordering P wrt.
(b) reordering hA; 00 iof Q wrt. s.t. j 00 j < j j;

Note previous publication (Backstrom, 1993) used terms LC1-minimality
minimal-constrained deordering LC2-minimality minimum-constrained reordering.
change terminology done hope gained clarity
lost confusion.
easy see minimum-constrainment stronger criterion minimalconstrainment|any minimum-constrained deordering plan P minimal-constrained
deordering P , opposite true. example, consider plan Figure 6a.
removing ordering constraints action C, result plan Figure 6b,
still valid. plan order size 3 (there one implicit transitive order)
minimal-constrained deordering since deordering made.
minimum-constrained deordering, however, since instead breaking ordering constraints
subsequences AB CB, result plan Figure 6c, valid.
plan ordering size 2 easily seen minimum-constrained
deordering, happens coincide minimum-constrained reordering
case. coincidence always case, however, since reordering allowed
109

fiBackstro

modifications deordering; minimum deordering obviously never
smaller ordering relation minimum reordering. Examples difference
shown already Section 2, Figure 4a shows minimum-constrained deordering
Figure 4b shows minimum-constrained reordering.


-p

p

B

-

q

C

q

-q



a) total-order plan
C


p

-p

B

q

-q

q

C





b) minimal deordering

q

-q



p

-p

B

q

b) minimum deordering

Figure 6: difference minimal minimum constrained deorderings.
alternative definitions least-constrainment could be, instance, maximize
unorderdness minimize length longest chain modified plan. However, find de-/reordering many pairs unordered actions possible
dual computing minimum de-/reordering is, thus, already covered. Minimizing
length longest chain condition may relevant actions
executed parallel overall execution time minimized. However, since
number ordering constraints quadratic length chain (because transitive
arcs), minimizing size relation often reasonable approximation minimizing chain length. Furthermore, minimizing longest chain still rather weak
condition purpose, better study directly problem finding shortest
parallel executions plans, done later article.
Another issue whether minimize size ordering relation given,
reduce transitive reductive closure it. Since plans may super uous orderings
particular purpose, reasonable standardize matters either add possible
transitive arcs, getting transitive closure, remove transitive arcs, getting
reductive closure. choice two important results
proven. However, minimizing transitive closure give preference plans
many unordered short chains actions plans long chains, seems
coincide better term 'least constrained'.

4.2 Computing Least-constrained Plans
Minimal deordering weaker two least-constrainment criteria considered,
least costly achieve|it one three criteria
satisfied polynomial-time modification plan.
110

fiComputational Aspects Reordering Plans

Definition 4.3 search problem

Minimal-Constrained Deordering (MlCD)

defined follows:
Given: ppi -valid plan P .
Output: minimal-constrained deordering P wrt. .

Theorem 4.4

MlCD solved polynomial time validity p.o. plans

tested polynomial time.

Proof: Consider algorithm MLD Figure 7 let Q = hA; 0 plan output
algorithm input P = hA; i. plan Q obviously valid deordering P wrt.

. obvious termination condition loop
ordering 00 0 s.t. hA; 00 -valid. follows Q minimal-constrained
deordering. Since algorithm obviously runs polynomial time, theorem follows.

2

Furthermore, validity testing expensive, dominating cost MLD
algorithm.

Corollary 4.5 validity testing p.o. plans solved time O(f (n))
function f (n), MlCD solved O(maxfn7=2 ; n2 f (n)g) time.
1 procedure MLD
2
Input: valid p.o. plan P = hA; ppi
3
Output: minimal deordering P
4 e 2 s.t. hA; ( ,feg)+i -valid
5
remove e
6 return hA; + i;

Figure 7: minimal-deordering algorithm MLD
particular, note plan validation polynomial usual variant propositional STRIPS without conditional actions (Nebel & Backstrom, 1994, Theorem 5.9).
precisely, proof pertains Common Propositional STRIPS formalism (CPS)
and, thus, holds common variants propositional STRIPS, Ground
TWEAK (Backstrom, 1995). Furthermore, note practice may necessary
compute transitive closure either output plan validating plan
algorithm.
minimum de-/reordering stronger criteria minimal deordering,
costly achieve.

Definition 4.6 decision problem

Minimum-Constrained Deordering (MmCD)

defined follows:
Given: ppi , -valid plan P integer k 0.
Question: deordering hA; P s.t. j j k?
111

fiBackstro

Definition 4.7 decision problem

Minimum-Constrained Reordering (MmCR)

defined follows:
Given: ppi , -valid plan P integer k 0.
Question: reordering hA; P s.t. j j k?

Theorem 4.8

Minimum-Constrained Deordering NP-hard.

Proof: Proof reduction Minimum Cover (Garey & Johnson, 1979, p. 222),
NP-complete. Let = fp1 ; : : : ; pn g set atoms, C = fC1 ; : : : ; Cm g set
subsets k jC j positive integer. cover size k subset C 0 C s.t.
jC 0j k [T 2C . Construct, polynomial time, GT ppi = h;; frgi
-valid t.o. plan P = ha1 ; : : : ; ; pre(ai ) = ; post(ai ) = Ci 1 m,
pre(aS ) = post(aS ) = frg. Obviously, minimum cover size k
iff exists -valid p.o. plan Q = hfa1 ; : : : ; ; g; s.t. j j k, since
0

actions contributing cover need remain ordered wrt.

Corollary 4.9

2

Minimum-Constrained Reordering NP-hard.

Corollary 4.10

Minimum-Constrained Deordering Minimum-Constrained

Reordering remain NP-hard even restricted GT plans actions

positive pre- post-conditions.

Theorem 4.11 validity p.o. plans complexity class C,

MinimumConstrained Deordering Minimum-Constrained Reordering NP C.

Proof: Guess solution, verify de-/reordering validate using

2

oracle C.

common planning formalisms without conditional actions context-dependent
effects, minimal de-/reordering NP-complete.

Theorem 4.12 validity p.o. plans tested polynomial time, Minimum-

Constrained Deordering Minimum-Constrained Reordering NP-complete.

Proof: Immediate Theorems 4.8 4.11 Corollary 4.9.

2

follows immediately corresponding search problems, is, problems
generating minimum-constrained de-/reordering NP-hard (and even NP-equivalent
validity testing tractable).
Furthermore, MmCD MmCR hard solve optimally, even
approximate. Neither problems approximation class APX (Crescenzi
& Panconesi, 1991), ie neither problem approximated within constant factor.
(Both elsewhere article term approximation used constructive
sense, results refer existence/non-existence algorithms producing
approximate solution polynomial time).
112

fiComputational Aspects Reordering Plans

Theorem 4.13

Minimum-Constrained Deordering Minimum- Constrained
Reordering cannot approximated within constant unless NP 2 DTIME (npoly log n ).

Proof: Suppose polynomial-time algorithm approximating MmCD within
constant. Since reduction proof Theorem 4.8 preserves solutions exactly,
approximations preserved. Hence, Minimum Cover could approximated within
constant, impossible unless NP 2 DTIME (npoly log n ) (Lund & Yannakakis,
1994), contradicts assumption. case MmCR trivial consequence. 2
using number propositional atoms plan measure size,
bound strengthened (1 , ") ln jPj arbitrary " unless NP 2 DTIME (nlog log n )
substituting result Minimum Cover (Feige, 1996) proof above.

5. Parallel Plans

order study problem finding shortest parallel execution plan, formalisms used far quite sucient. Since lack capability modelling
actions executed parallel not, impossible say reasonable precision certain action ordering affect parallel execution time. Partial-order
plans sometimes referred parallel plans literature. misleading, however.
two actions left unordered plan means executed
either order, without affecting validity plan, general case
guarantee plan remain valid executions actions overlap
temporally. cases, unorderedness means parallel overlapping execution
allowed, cases mean that, depending action modelling
underlying domain assumptions. first case, plan must stronger ordering
committment, two actions must overlapping executions must ordered,
thus making plan over-committed.
order distinguish two cases, concept parallel plans introduced below.
parallel plan partial-order plan extra relation, non-concurrency relation,
tells actions must executed parallel. article two actions
considered parallel executions temporal overlap all. Plans
unordered actions executed parallel constitute special case definite parallel
plans.

Definition 5.1 parallel plan triple P = hA; ; #i, hA; p.o. plan
# irre exive, symmetric relation A. definite parallel p.o plan parallel plan
P = hA; ; #i s.t. # ( [ ,1 ).
Intuitively, parallel plan p.o. plan extended extra relation, # (a nonconcurrency relation), expressing actions must executed parallel.
relation primarily intended convey information actions unordered
relation, although allowed relate actions. is, #
relation intended capture information whether two actions executed
parallel not, general. two actions ordered plan forbids executing
parallel particular plan, necessarily mean actions could
113

fiBackstro

executed parallel different circumstances. Planning algorithms frequently produce overcommitted orderings plans, whole purpose article study
problem optimizing plans finding removing overcommitted orderings. Hence,
restrictions general relation # addition Definition 5.1.
instance, b imply a#b. However, non-concurrency relation
frequently constrained satisfy post-exclusion principle.
Definition 5.2 parallel GT plan P = hA; ; #i satisfies post-exclusion principle
iff actions a; b 2 A, a#b whenever atom p s.t. p 2 post(a)
:p 2 post(b).
definition plan validity directly inherited p.o. plans.
Definition 5.3 Given ppi , parallel plan hA; ; #i -valid iff p.o. plan hA;
-valid.
non-concurrency relation is, thus, relevant deciding whether plan valid
not. Instead, used constraining parallel plans may executed
core concept behind definition parallel executions.
Consider, instance, GT plan hfA; B; C g; fhA; B ig; fhB; C igi shown
Figure 8 (arrows denote ordering relations dashed lines denote nonconcurrency relations). plan valid wrt. ppi = h;; fr; sgi, final value atom q
matter. Since B #C holds actions B C constrained executed
parallel, may executed either order, is, plan definite. could
post-exclusion principle employed, reason. Although
A#B hold actions B clearly cannot executed parallel, since B
holds. four ways execute plan, either three sequences A,B,C;
A,C,B C,A,B, executing C parallel, followed B (unit length assumed). note plan would longer valid goal contained either q
:q, since final truth value q depends actual execution order. Furthermore,
reordering plan would keep ordering constraint B satisfy
validity criterion, necessary constraint A#B . would harm
include restriction, complex plans may over-constrainment,
several producers atom p choose between, instance. sum up,
non-concurrency relation primarily used mark actions must
parallel addition already forbidden parallel validity.
framework parallel plans admits expressing possible parallelism only; necessary
parallelism scope article requires planner access
able make use additional information, perhaps temporal algebra.
Furthermore, set non-concurrent actions easily expressed making actions
set pairwise non-concurrent, formalism sucient say k
actions, more, set may executed parallel. Similarly, possible
express action must executed interval, two sets
actions must non-overlapping executions.
Definition 5.4 Let P = hA; ; #i parallel plan let function : 7! N denote
duration action. parallel execution P function r : 7! N , denoting
release times actions A, satisfying a; b 2 A,
114

fiComputational Aspects Reordering Plans



p

q
r

B
#

C :s q
Figure 8: parallel plan
1. b, r(a) + d(a) r(b)
2. a#b, either
(a) r(a) + d(a) r(b)
(b) r(b) + d(b) r(a).
length parallel execution defined maxa2A fr(a) + d(a)g, ie, latest finishing time action. minimum parallel execution plan parallel execution
minimum length among parallel executions plan. length parallel plan P ,
denoted length(P ), length minimum parallel execution(s) P .

P

Obviously, every parallel plan parallel execution length a2A d(a) (which
trivial case sequential execution). Furthermore, certain cases, hardness results
strengthened restricting duration function.
Definition 5.5 special case d(a) = 1 2 referred unit
time assumption.
Deciding whether release-time function parallel execution tractable.
Theorem 5.6 Given parallel plan P = hA; ; #i, duration function : 7! N
release-time function r : 7! N , decided polynomial time whether r parallel
execution P and, case is, length execution is.
Proof: Trivial.
2
Consider plan Figure 8 three release-time functions r1 , r2 r3 , defined
follows
r1(A) = 1 r1 (B ) = 2 r1 (C ) = 3
r2(A) = 1 r2 (B ) = 2 r2 (C ) = 1
r3(A) = 1 r3 (B ) = 2 r3 (C ) = 2:
r1 r2 parallel executions plan, r3 not. Furthermore, r2
minimum parallel execution plan, length 2. However, computing
minimum parallel execution parallel plan dicult general case.
115

fiBackstro

Definition 5.7 decision problem Parallel Plan Length (PPL) defined follows:
Given: parallel plan P = hA; ; #i, duration function integer k.
Question: P parallel execution length k shorter?

Theorem 5.8

Parallel Plan Length NP-hard.

Proof: Hardness proven transformation Graph K-Colourability (Garey
& Johnson, 1979, p. 191), NP-complete. Let G = hV; E arbitrary undirected graph, V = fv1 ; : : : ; vn g. Construct, polynomial time, GT ppi follows. Define ppi = h;; fp1 ; : : : ; pn gi. define parallel plan P = hA; ;; #i,
contains one action ai vertex vi 2 V , s.t. pre(ai ) = ; post(ai ) =
fpi; qi g [ f:qj j fvi; vj g 2 E g. Finally, let ai#aj iff fvi ; vj g 2 E , satisfies post-

exclusion principle. plan P constructed obviously -valid. easy see
G k-colourable iff P parallel execution length k wrt. since colour G
correspond unique release time parallel execution P .
2

Corollary 5.9

Parallel Plan Length remains NP-hard even restricted GT ac-

Theorem 5.10

Parallel Plan Length NP.

tions empty preconditions assumption unit time post-exclusion
principle.

Proof: Guess parallel execution. verify it, done polynomial time
2

according Theorem 5.6.

Computing minimum parallel execution plan tractable special case definite
plans, however.

Theorem 5.11
parallel plans.

Parallel Plan Length solved polynomial time definite

Proof: Use algorithm DPPL (Figure 9), straightforward stratification
2

algorithm directed DAGs.

6. Reordering Parallel Plans
defined concept parallel plan, possible define concepts similar
previous least-constrainment criteria appropriate minimizing
execution time parallel plans.

Definition 6.1 Let P = hA; ; #i Q = hA; 0 ; #i two parallel plans ppi.
Then,

1. Q parallel reordering P wrt. iff P Q -valid;
116

fiComputational Aspects Reordering Plans

1
2
3
4
5
6
7
8
9
10
11
12

procedure DPPL

Input: definite parallel plan P = hA; ; #i
Output: minimum parallel execution r P
Construct directed graph G = hA;
2
r(a) 0
6= ;
Select node 2 without predecessors
b 2 s.t. b
r(b) max(r(b); r(a) + d(a))



return r

, fag

Figure 9: Algorithm computing minimum parallel execution definite parallel plans.
2. Q parallel deordering P wrt. iff Q parallel reordering P 0 ;
3. Q minimum parallel reordering P wrt. iff
(a) Q parallel reordering P wrt.
(b) parallel reordering P wrt. shorter length Q;
4. Q minimum parallel deordering P wrt. iff
(a) Q parallel deordering P wrt.
(b) parallel deordering P wrt. shorter length Q.

Modifying plans satisfy either latter two criteria dicult general case,
however.

Definition 6.2 decision problem Minimum Parallel Deordering (MmPD) defined follows.
Given: ppi , parallel plan P , duration function integer k.
Question: P deordering parallel execution length k wrt. ?

Definition 6.3 decision problem Minimum Parallel Reordering (MmPR) defined follows.
Given: ppi , parallel plan P , duration function integer k.
Question: P reordering parallel execution length k wrt. ?

Theorem 6.4 Minimum Parallel Deordering NP-hard.
Proof: Similar proof Theorem 6.4. Given graph G integer k, construct
ppi plan P = hA; ; #i way proof Theorem 5.8,
let arbitrary total order A. Obviously, P -valid Q = hA; ;; #i

deordering P s.t. deordering P shorter Q. Hence, Q, thus P ,
deordering parallel execution length k iff G k-colourable.
2
117

fiBackstro

Corollary 6.5
Corollary 6.6

Minimum Parallel Reordering NP-hard.

Minimum Parallel Deordering Minimum Parallel Reordering remain NP-hard even restricted totally ordered GT plans as-

sumptions unit time simple concurrency.

Note restriction definite input plans covered corollary. output
plans required definite, reordering case remains NP-hard.

Theorem 6.7

Minimum Parallel Reordering remains NP-hard output

plan restricted definite.

Proof: Reuse proof Theorem 6.4 follows. Let r shortest parallel execution
plan Q assume execution length n. Construct order 0 s.t.
actions a; b 2 A, 0 b iff r(a) < r(b). Obviously plan hA; 0 ; #i definite

minimum parallel reordering P . follows P definite parallel reordering
length k iff G k-colourable.
2

open question whether minimum deordering remains NP-hard output
plans must definite, important special case polynomial, proven
next section.

Theorem 6.8

Minimum Parallel Deordering Minimum Parallel Reorder-

ing NP C validation p.o. plans complexity class

C.

Proof:

Given plan hA; ; #i, duration function parameter k, guess
de/reordering 0 release-time function r. verify, using oracle C ,
hA; 0 ; #i valid. Finally, verify r parallel execution length k,
polynomial according Theorem 5.6.
2

Theorem 6.9 Minimum parallel de-/reordering NP-complete p.o. plans vali-

dated polynomial time.

Proof: Immediate Theorems 6.4 6.8 Corollary 6.5.

2

problems MmPD MmPR hard solve optimally,
approximate.

Theorem 6.10

Minimum Parallel Deordering Minimum Parallel Reordering cannot approximated within jAj1=7," " > 0, unless P=NP.

Proof:
Suppose polynomial-time algorithm approximating MmCD within
jAj1=7," " > 0. immediate proof Theorem 6.4
Graph K-Colourability could approximated within jAj1=7," , impossible
unless P=NP (Bellare, Goldreich, & Sudan, 1995).

2

reasoning, bound strengthened jAj1," , assumption
co-RP6=NP (Feige & Kilian, 1996).
118

fiComputational Aspects Reordering Plans

7. Restricted Cases
Since problems computing minimum de-/reorderings dicult, even
dicult approximate, alternative way tackling could study restricted
cases. One special case already considered restriction definite plans only.
problem MmPR still NP-complete restriction, open question whether
MmPD NP-complete. positive result proven, though, effect
MmPD polynomial definite plans large class planning languages, including
commonly used ones. result proven generalising algorithm
literature deordering total-order plans.
Based (not necessarily true) argument easier generate t.o. plan
p.o. plan using complex action representations, Regnier Fade (1991a, 1991b)
presented algorithm converting t.o. plan p.o. plan. resulting plan
property unordered actions executed parallel, is, plan
definite. authors algorithm claim algorithm finds pairs
actions executed parallel and, hence, plan post-processed
find optimal parallel execution. define mean criterion,
however.
Incidentally, algorithm proposed Regnier Fade special case algorithm earlier proposed problem Pednault (1986), make
claims optimality. removing Regnier Fade's algorithm details relevant
particular implementation planning language, two algorithms coincide
thus presented one single algorithm, PRF algorithm4 (Figure 10).
PRF slightly modified original algorithms. First, assume input plan totally ordered, since turns sucient definite partial-order
plan. Second, PRF returns parallel plan, rather p.o. plan|a harmless modification since additional piece information non-concurrency relation,
already given input, either explicitly implicitly. Third, PRF returns transitive
closure ordering relation. means necessary, motivated, usual,
conforming definitions article.
1 procedure PRF;
2
Input: ppi , -valid definite p.o. plan hA; non-concurrency
relation #
3
Output: -valid parallel plan
4 a; b 2 s.t. b
5
a#b
6
Order 0 b;
7 return hA; 0+ ; #i;

Figure 10: PRF algorithm
Obviously, PRF computes deordering input, unclear whether possible compute minimal definite deordering polynomial time. However, algorithm
4. afterwards, algorithms literature referred acronyms consisting
initials authors, case Pednault, Regnier Fade.

119

fiBackstro

abstracted general formalism, analysis restricted formalisms reveals performance. language used Regnier Fade
unnecessarily restricted algorithm shown work considerably
general formalism, based generalising abstracting concepts producers, consumers threats used common planners planning languages, eg STRIPS
TWEAK. formalism referred Producer-Consumer-Threat formalism
(PCT).
Let prod(a; ) denote produces condition , cons(a; ) consumes
threat(a; ) threat . simplify definitions, standard transformation
used simulating initial goal states actions. is, every PCT plan
contains action ordered actions consumes nothing produces
initial state. Similarly, action ordered actions consumes
goal state produces nothing. means ppi contained within plan
itself, references ppis omitted following. Validity plans
defined follows.

Definition 7.1 t.o. PCT plan ha1 ; : : : ; valid iff i, 1 n
conditions s.t. cons(ai ; ), j , 1 j < s.t. prod(aj ; ) k,
j k s.t. threat(ak ; ). p.o. PCT plan valid iff topological sortings

valid.

Chapman's Modal-truth Criterion (MTC) (Chapman, 1987) abstracted
PCT formalism analogously used validating p.o. plans.

Definition 7.2 modal truth criterion (MTC) PCT plan hA; is:
8aC 8(cons(aC ; ) !
9aP (prod(aP ; ) ^ aP aC ^
8aT (threat(aT ; ) !
aC _
9aW (prod(aW ; ) ^ aW ^ aW aC ))))
Theorem 7.3 MTC holds PCT plan P iff valid.
Proof: Trivial generalization proofs leading Theorem 5.9 Nebel Backstrom

2

(1994).

minimum constraints two actions may executed parallel
required. constraints obeyed planners AI literature.

Definition 7.4 Simple concurrency holds actions a, b s.t. 6= b, nonconcurrency relation satisfies following three conditions
1. prod(a; ) ^ cons(b; ) ! a#b
2. prod(a; ) ^ threat(b; ) ! a#b
3. cons(a; ) ^ threat(b; ) ! a#b
120

fiComputational Aspects Reordering Plans

Note required two producers, two consumers two threats
condition non-concurrent, thus allowing, instance, plans multiple producers, eg
Nebel Backstrom (1994, Fig. 4) Kambhampati (1994). axioms prevent
adding restrictions, though. Furthermore, note definition states necessary condition non-concurrency|it perfectly legal add non-concurrency
constraints actions plan. may worth noting MTC requires
producers threats ordered correpsonding consumer,
definite plan satisfying simple concurrency criterion always require ordered.
following observation PRF immediate algorithm used
proofs below.

Observation 7.5 hA; ; #i input PRF hA; 0 ; #i corresponding
output, holds 0 b iff b a#b.
Based lemma, proven PRF preserves validity.

Lemma 7.6 plan input PRF valid PCT plan # satisfies simple
concurrency criterion, output plan valid.

Proof: Let P = hA; ; #i input plan Q = hA; 0 ; #i output plan. Since

P valid, follows Theorem 7.3 MTC holds P . Adding implied
simple-concurrency constraints MTC yields following condition:

8aC 8(cons(aC ; ) !
9aP (prod(aP ; ) ^ aP aC ^ aP #aC ^
8aT (threat(aT ; ) !
(aC ^ aC #aT )_
9aW (prod(aW ; )^aT aW ^ #aW ^
aW aC ^ aW #aC )))).
applying Observation 7.5 simplified to:

8aC 8(cons(aC ; ) !
9aP (prod(aP ; ) ^ aP 0 aC ^
8aT (threat(aT ; ) !
aC 0 _
9aW (prod(aW ; ) ^ 0 aW ^ aW 0 aC )))),
MTC plan Q. using Theorem 7.3, follows Q valid.

2

allows proving PRF produces definite minimum deorderings definite PCT
plans simple concurrency.

Theorem 7.7 using PCT formalism simple concurrency, PRF produces
minimum-deordered definite version input.
121

fiBackstro

Proof: Let P = hA; ; #i input plan, assumed valid definite,
Q = hA; 0 ; #i output plan. obvious 0 follows Lemma 7.6

Q valid, Q deordering P . remains prove Q minimum deordering
P .
Suppose P deordering R = hA; 00 ; #i s.t. j 00 j < j 0 j. Then, must
a; b 2 s.t. 0 b, 00 b. assumed 0 b

transitive arc 0 , since transitive closure anyway computed end
algorithm. Since order 0 produced PRF, follows Observation 7.5
b a#b. latter constraint, necessary either, 00 b
b 00 holds, former possible since b R deordering P .
contradicts assumption, Q must minimum deordering P .
2
Since PRF polynomial algorithm, follows definite minimum deorderings
definite PCT plans computed polynomial time simple concurrency. Furthermore, since PRF produces definite plans possible actually compute shortest
parallel execution eciently.

Theorem 7.8 plan input PRF valid definite PCT plan satisfying
simple concurrency criterion, PRF outputs definite minimum deordering plan.

Proof: PRF runs polynomial time obviously produces definite parallel plans.
Hence, follows Theorem 5.11 minimum parallel execution output plan
found polynomial time, proves theorem.
2

seems likely Regnier Fade meant optimality claim, although special instance PCT formalism. result says nothing
diculty finding minimum reordering plan, since PRF considers deorderings.
Since minimum deorderings approximate minimum reorderings well, suspected dicult compute latter. following theorem confirms
suspicion, showing latter problem remains NP-hard quite severe restrictions,
including following two.

Definition 7.9 GT action toggling iff literals l 2 post(a), case
:l 2 pre(a). GT action unary iff jpost(a)j = 1.
Theorem 7.10 Minimum Parallel Reordering remains NP-hard even restricted

total-order GT plans toggling unary actions assumption unit
time, simple concurrency actions redundant.

proof theorem appears Appendix A.
minimum reorderings dicult compute minimum deorderings,
produce arbitrarily better results.

Theorem 7.11

Minimum Parallel Deordering cannot approximate Minimum Parallel Reordering within jAjk constant k 0.

proof theorem appears Appendix A.
122

fiComputational Aspects Reordering Plans

Corollary 7.12 Minimum Parallel Deordering cannot approximate Minimum Parallel Reordering within jAjk constant k 0 even problems restricted GT plans positive preconditions assumption simple
concurrency.

may, thus, appear though minimum reordering preferable, albeit costly,
operation minimum deordering. However, plan modification followed
scheduling, longer obvious reordering prefer. Since scheduling may
take information constraints account, eg upper lower bounds
release time limited resources, feasible schedule original plan may longer
feasible schedule reordering plan. is, feasible solutions
may lost reordering plan. contrast this, deordering plan harmless
since previously feasible schedules preserved deordering. course, de/reordered plan may new better schedules old plan,
problems studied article interesting all. However, minimum deordering
safe and, usually cheap, operation, minimum reordering neither must thus
applied care. find reordering plan optimum schedule would
require combining minimum reordering scheduling one single computation,
scope article study combinations. Suce observe
computation never cheaper either constituent computations.

8. Related work
section analyses discusses algorithms suggested literature generalising ordering plan, addition PRF algorithm already analysed
preceeding section. planners generate plans optimality avour
ordering discussed.
algorithms analysed use common trick simulating initial
state goal planning instance two extra operators, following way. Let
P = hA; plan = hI; Gi ppi, GT language. Introduce two extra
actions aI , pre(aI ) = ; post(aI ) = , aG , pre(aG ) = G post(aG ) = ;.
Define plan Q = hA [ faI ; aG g; 0 0 = [faI a; aG j 2 Ag[faI aG g,
aI ordered actions aG ordered actions.
plan Q representation plan P ppi . combined representation
referred self-contained plan. self-contained plan valid iff valid wrt.
ppi h;; ;i. trivial convert plan ppi corresponding self-contained
plan vice versa. Hence, ways representing plan used alternately
without notice.

8.1 VPC Algorithm

Veloso et al. (1990) presented algorithm (here referred VPC5 ) converting
t.o. plans `least-constrained' p.o. plans. use algorithm following context.
First total-order planner (NoLimit) used produce t.o. plan. VPC converts plan
5. original publication algorithm named Build Partial Order.

123

fiBackstro

1 procedure VPC;
2
Input: valid self-contained t.o. plan ha1 ; : : : ;
a1 = aI = aG
3
Output: self-contained valid p.o. plan
4 1 n
5
p 2 pre(ai )
6
Find max k < s.t. p 2 post(ak );
7
k exists
8
Order ak ai
9
:p 2 post(ai )
10
1 k < s.t. p 2 pre(ak )
11
Order ak ai
12
primary effect p 2 post(ai )
13
1 k s.t. :p 2 post(ak )
14
Order ai ak
15
1 < < n
16
Order aI ai ai aG
17
return hfa1; : : : ; ang; +i;

Figure 11: VPC algorithm
p.o. plan post-processed determine actions executed
parallel. action language used STRIPS-style language allowing quantifiers
context-dependent effects. However, plans produced planner, thus input
VPC, ground without context-dependent effects. is, ordinary
propositional STRIPS plans. VPC algorithm presented Figure 11, minor
differences presentation compared original appearance: First, algorithm
presented GT formalism, order minimize number formalisms article,
preconditions assumed positive, thus coinciding original algorithm.
Second, original algorithm returns transitive reduction computed order
instead returns transitive closure here, unimportant difference order coincide
definition plans article. Furthermore, Veloso6 pointed
published version VPC algorithm incorrect corrected version exists.
version presented Figure 11 corrected version. proposition primary
effect appears either goal subgoaling chain goal proposition.
VPC greedy algorithm constructs entirely new partial order analysing
action conditions, using original total order guide greedy strategy.
algorithm claimed (Veloso et al., 1990, p. 207) produce `least-constrained' p.o. plan,
although definition given means. Veloso7 confirmed term `least
constrained plan' used `loose sense' optimality claim intended. However,
term defined, impossible know problem algorithm
intended solve judge whether makes improvement using algorithm
all. absence definition authors, algorithm analysed
respect least-constrainment criteria defined Section 4. admittedly
6. Personal communication, oct. 1993.
7. Veloso, ibid.

124

fiComputational Aspects Reordering Plans

p
q
1

b r


p

Pq
PPP
PP
qc
P1

pq

q

-p b qr

-q c

P2

Figure 12: p.o. plans failure example VPC.
somewhat unfair analysis, reveals interesting facts algorithm,
problems solve. immediate Theorem 4.8 Corollary 4.9
VPC cannot expected produce minimum-constrained de-/reorderings. Perhaps
surprisingly, VPC even guarantee output minimal -constrained
deordering input, problem already proven trivially polynomial (Theorem 4.4).
illustrated following example.
Suppose total-order planner given ppi = h;; fr; sgi input. may
return either -valid t.o. plans ha; b; ci ha; c; bi, action conditions shown
Figure 12. used input VPC, two t.o. plans give quite different results|the plan ha; c; bi converted p.o. plan P1 Figure 12,
plan ha; b; ci converted p.o. plan P2 Figure 12. is, first
case VPC produces plan minimal-constrained deordering even
minimum-constrained deordering, second case even produce
minimal-constrained deordering.8
reason VPC may fail produce minimal-constrained deordering
uses non-admissible greedy strategy. Whenever needs find operator achieving
effect required precondition another operator b, chooses last action
ordered b input t.o. plan. However, may actions earlier
plan effect better choice.

8.2 KK algorithm

Kambhampati Kedar (1994) presented algorithm generalising ordering p.o. plan, using explanation-based generalisation. algorithm based first
constructing validation structure plan use guide generalisation phase. original paper, computations divided two separate
algorithms (EXP-MTC EXP-ORD-GEN), compacted one single algorithm, KK (Figure 13). Furthermore, version presented restricted ground
GT plans, original algorithm handle partially instantiated plans.
restriction results shown below.
first part KK algorithm constructs validation structure V plan,
is, explanation precondition every action plan. validity criterion
underlying phase simplified version Chapmans modal-truth criterion (Chapman,
8. Note transitive arcs omitted figures, P2 really ordering relation size three.
Although example would work plans defined equally reasonable way
ordering relations intransitive, possible construe similar examples case.

125

fiBackstro

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20

procedure KK

Input: valid self-contained p.o. plan hA;
Output: deordering input plan
comment Build validation structure V plan

V

;

Let ha1 ; : : : ; topologically sorted version hA;
1 n
p 2 pre(ai )
Find min k < s.t.
1. p 2 post(ak )
2. j s.t. k < j < :p 2 post(aj )
Add hak ; p; ai V
comment Construct generalised ordering 0 plan
ha; bi 2
Add ha; bi 0 either following holds
1. = aI = aG
2. ha; p; bi 2 V p
3. hc; p; ai 2 V :p 2 post(b)
4. hb; p; ci 2 V :p 2 post(a)

return hA; 0i

Figure 13: KK algorithm
1987) without white knights. Since algorithm simplified handle ground plans
here, explanation causal link haP ; p; aC i, meaning action aP produces
condition p consumed action aC . algorithm constructs exactly one
causal link precondition, chooses earliest producer p preceeding aC
intervening action producing :p producer aC . second phase
algorithm builds generalised ordering 0 plan based validation
structure. put things simply, orderings original plan kept
either correspond causal link validation structure required prevent
threatening action unordered wrt. actions causal link.
turns KK algorithm fails generating plans guaranteed even minimal-constrained deorderings. Consider t.o. plan hA; B; C; Di
action conditions indicated Figure 14. t.o. plan valid ppi
h;; fr; s; t; ugi. Since KK algorithm always chooses earliest possible producer
precondition validation structure, build validation structure
fhA; p; Di; hA; s; aG i; hB; q; Di; hB; t; aG i; hC; r; aG i; hD; u; aG ig. Hence, final ordering
produced KK shown Figure 14a. However, plan minimalconstrained deordering original plan, since deordered shown
Figure 14b remain valid. example, input plan totally ordered.
case partially ordered input plans, behaviour algorithm depends particular topological order choosen. algorithm may may find minimal-constrained
deordering, impossible guarantee succeed plans. Similarly,
authors mention one may consider different ways constructing validation struc126

fiComputational Aspects Reordering Plans

ture. would clearly modify behaviour remains open question whether
possible generate, polynomial time, validation structure guarantees
minimal-constrained deordering constructed second phase algorithm. Finding validation structure guarantees minimum-constrained deordering obviously
NP-hard problem since second phase algorithm polynomial.
ps

ps

ZZ

B qt

ZZ~-p
q

p
r

u

C q

a) Plan produced KK

q

u

B qt

C pq

r

-p

b) Minimal deordered version

Figure 14: Failure example KK algorithm

8.3 Planners Optimality Guarantees
planning algorithm Graphplan (Blum & Furst, 1997) notion time steps
tries pack many non-interacting actions possible one single time step. Furthermore, Graphplan finds shortest plan, using number time steps measure.
assuming unit time actions considered non-interacting Graphplan
executed parallel, plan shorter parallel execution
plan produced Graphplan. is, Graphplan produces minimum reordered
parallel plans assumptions. second assumption limitation practice,
since non-concurrency relation encoded introducing new atom letting
one interacting actions add one deletes it. unit time assumption serious, however, especially since assumption likely hold
applications. car-assembly scenario Section 2, instance, Graphplan would
produce plan corresponds plan Figure 5. Hence, plan produced
unit-time assumption happens coincide optimal plan taking actual
execution times account. fortunate coincidence, however, depending
particular durations actions example. Suppose instead durations
actions slightly different PAC duration 2 MvT1 duration 8.
plan produced Graphplan, corresponds plan Figure 5,
faster schedule 19 time units. optimal since plan Figure 4
scheduled execute 17 time units particular duration times. Furthermore, must remembered Graphplan anyway restricted cases
GT-equivalent planning language sucient, although recent improvements extend
127

fiBackstro

somewhat expressive languages (Gazen & Knoblock, 1997; Kohler, Nebel, Hoffman,
& Dimopoulos, 1997).
Knoblock (1994) modified UCPOP planner resource concept makes
avoid unordered interacting actions. means resulting planner produces
definite parallel plans. Knoblock modified evaluation heuristic search
take parallel execution time account. thus seems planner might able
produce minimum reordered parallel plans, paper provide sucient details
determine whether case. unclear whether heuristic handle
actions different duration times.
Yet another example polynomial-time planner SAS+-IAO planning language (Jonsson & Backstrom, 1998) produces plans minimum-constrained
reordered. is, restricted formalism clearly possible optimise ordering
polynomial time.

9. Discussion
previous section listed planning algorithms literature produce
attempt produce plans least constrained minimum parallel reordered.
certain restrictions, though. Furthermore, plans always generated
`from scratch', generated modifying already existing plan, referred
case-based planning, repairing plan failed execution phase.
cases, old plan may contain many ordering relations obsolete
modified/repaired plan. fact, KK algorithm (Kambhampati & Kedar, 1994)
motivated context case-based planning. important remember
today, probably long time future, plans generated entirely
computer programs. vast majority plans various applications designed
humans, possibly computer support. Already quite small plans, dicult
human see whether ordering constraints optimal not, computer support
analyses vital designing optimal plans. reason, hierarchicaltask-network planners, eg O-Plan (Currie & Tate, 1991) Sipe (Wilkins, 1988), produce
plans reordering actions could lead better schedules. planner often commits
one two possible orderings pair actions based expert-knowledge rules.
However, hardly possible human expert design rules situations
guarantee optimal ordering choice made.
coarseness level complexity analysis matter whether tasks
planning, plan optimization scheduling integrated separated since total
resulting complexity cases|the latter two computations
NP-complete will, thus, dominated planning, PSPACE-complete
worse. However, good reasons prevented research community
studying planning scheduling separate problems, since understanding problem
isolation helps understanding overall process. reason, important
study separately problems discussed analysed article. Furthermore,
fine-grained, practical level might considerable differences eciency
integrating three computations separately. instance, even
three computations take exponential time, problems considered isolation
128

fiComputational Aspects Reordering Plans

may fewer parameters, case may much ecient solve
isolation. hand, solving whole problem may make easier
global optimisation. better depend methods used
various properties actual application, seems unlikely one
methods always better.
shown article, minimum reordering much better optimality
criterion minimum deordering, considering overall parallel execution time.
However, necessarily true considering metric constraints subsequent scheduling. Deordering plan add number feasible schedules,
reordering may remove or, worst case, feasible schedules.
hand, reordering may lead new better schedules reachable via deordering.
Deordering thus viewed safe and, sometimes, cheap way allow better
schedules, reordering expensive method potential generating
considerably better plans, may make things worse. using reordering
practice cases metric scheduling constraints involved, seems necessary
use feedback scheduler control reordering process, try reorderings. One could imagine reordering algorithm uses either heuristic search
randomized local-search methods la GSAT (Selman, Levesque, & Mitchell, 1992) find
reorderings use scheduler evaluation function proposed reorderings.
plan modifications studied article may add considerably optimizations possible traditional scheduling only, still potential
optimization left study|modifying action order, set actions. modification already done plan adaptation, generating
new plan old cases, optimizations sense article considered.
preliminary studies action-set modifications appear literature, though. Fink
Yang (1992) study problem removing redundant actions total-order plans,
defining spectrum redundancy criteria analysing complexity achieving these.
less clear interesting study action addition; adding actions plan could
obviously improve execution time executed sequentially. However,
case parallel execution plans shown adding actions plan
sometimes allow faster execution (Backstrom, 1994). Finally, allowing removal
addition actions, even greater potential optimising plans seems available,
problems seems yet studied literature.

10. Conclusions
article studies problem modifying action ordering plan order
optimise plan according various criteria. One criteria make plan
less constrained minimize parallel execution time. Three candidate
definitions proposed first criteria, constituting spectrum increasing
optimality guarantees. Two based deordering plans, means ordering relations may removed, added, last one builds reordering,
arbitrary modifications ordering allowed. first three candidates,
subset-minimal deordering, tractable achieve, two, deordering re129

fiBackstro

ordering plan minimize size ordering, NP-hard even dicult
approximate.
Similarly, optimising parallel execution time plan studied deordering
reordering plans. general case, computations NP-hard
dicult approximate. However, based algorithm literature shown
optimal deorderings computed polynomial time definite plans class
planning languages based notions producers, consumers threats,
includes commonly used planning languages. Computing optimal reorderings
potentially lead even faster parallel executions, problem remains NP-hard
dicult approximate even quite severe restrictions. Furthermore, deordering
plan safe respect subsequent scheduling, reordering plan may remove
feasible schedules, making deordering good, often suboptimal, approach practice.

Acknowledgements

Tom Bylander, Thomas Drakengren, Mark Drummond, Alexander Horz, Peter Jonsson,
Bernhard Nebel, Erik Sandewall, Sylvie Thibeaux anonymous referees provided
helpful comments article previous versions it. research supported
Swedish Research Council Engineering Sciences (TFR) grants Dnr. 92-143
95-731.

Appendix

Theorem 7.10 Minimum Parallel Reordering remains NP-hard even restricted

total-order GT plans toggling unary actions assumption unit
time, simple concurrency actions redundant.

Proof: Proof reduction 3SAT (Garey & Johnson, 1979, p. 259). Let P =
fp1 ; : : : ; png set atoms C = fC1 ; : : : ; Cm g set clauses P s.t.
1 m, Ci = fli;1 ; li;2 ; li;3 g set three literals P .
First define set atoms

Q = fpFi ; pTi ; qi j 1 ng [ fci;j ; ri;j j 1 n; 1 j 3g:
define GT ppi = hI; Gi initial goal states defined
= Neg(Q)
G = fpFi ; pTi ; :qi j 1 ng [ fci;j ; :ri;j j 1 n; 1 j 3g
Also, atom pi 2 P , define four actions according Table 2.
Further, clause Ci 2 C , define nine actions according Table 3
( F

l = pk li;j = :pk
i;j

pTk

li;j = pk :

Let set 4n + 9m actions thus defined. Clearly total order
s.t. plan P = hA; -valid. obvious none actions redundant.
130

fiComputational Aspects Reordering Plans

trivial observation parallel execution r -valid reordering P
must satisfy i, 1 n, either

r(AFi ) < r(A+i ) < r(ATi ) < r(A,i )

i, 1 m,

r (C +

i;k1

r(A+i ) < r(ATi ) < r(A,i ) < r(AFi );

( , )
, ))
r
(Ci;k
r(Ci;k2 )
+
+
,
1
i;k1 ) < r(C + ) < r(Bi;k2 ) < r(C + ) < r(Bi;k3 ) < r(Ci;k3 );
i;k2
i;k3

) < r(B +

(

k1 ; k2 ; k3 permutation numbers 1; 2; 3. (This interpreted s.t.
, C + released either order, simultaneously, analogously
actions Ci;k
i;k2
1
,
+ ).
actions Ci;k
Ci;k
2
3
remainder proof shall show P reordered parallel
execution length 8 iff set C clauses satisfiable.
if: Suppose C satisfiable. Let truth assignment atoms P satisfies
C . Wlg. assume (pi ) = i. Further, clause Cj , let lj literal Cj
satisfied . Disregarding action order moment, choose release-time
function r actions follows. 1 n, let

r(A+i ) = 0; r(ATi ) = 1; r(A,i ) = 2; r(AFi ) = 3:
Further, j , 1 j m, choose k1 s.t. lj;k1 2 Cj satisfied (at least one
choice must exist assumption). Let lj;k2 lj;k3 remaining two literals Cj .
Assign release times s.t. 1 h 3,
+ ) = 2h , 1; r (B + ) = 2h ; r (C , ) = 2h + 1:
r(Cj;k
j;kh
j;kh
h

define partial order 0 s.t. actions a; b 2 A, 0 b iff r(a) < r(b).
Clearly, plan hA; 0 -valid reordering P r parallel execution length
8 hA; 0 i. (Note choice could force longer execution,
execution length 7 case C satisfied setting atoms false.)
operator precond. postcond.

AFi
ATi
A+i
A,i

:pFi ; :qi pFi
:pTi ; qi pTi
:qi
qi
qi
:qi

Table 2: Generic actions atom pi proof Theorem 7.10.
131

fiBackstro

operator precond.

Bi;+1
Bi;+2
Bi;+3
Ci;+1
Ci;,1
Ci;+2
Ci;,2
Ci;+3
Ci;,3

li; 1; ri;1 ; :ri;2 ; :r1;3 ; :ci;1
li; 2; :ri;1; ri;2 ; :r1;3 ; :ci;2
li; 3; :ri;1; :ri;2; r1;3 ; :ci;3
:ri;1
ri;1
:ri;2
ri;2
:ri;3
ri;3

postcond.

ci;1
ci;2
ci;3
ri;1
:ri;1
ri;2
:ri;2
ri;3
:ri;3

Table 3: Generic atoms clause Ci proof Theorem 7.10.
if: Suppose C satisfiable. suppose Q minimum reordering
P r parallel execution length 8 shorter Q. Wlg. assume every
action released early possible r. Then, according observation
must hold i, 1 n, either
r(AFi ) = 0; r(A+i ) = 1; r(ATi ) = 2; r(A,i ) = 3

r(A+i ) = 0; r(ATi ) = 1; r(A,i ) = 2; r(AFi ) = 3:
Hence, exactly one atoms pFi pTi true time 2. Let pi denote atom. Since
+)2
r length 8, follows earlier observation j , 1 j m, r(Bj;k
k, 1 k 3. Hence, lj;k = pi i, since Q -valid r parallel
execution Q. Define interpretation s.t. i, 1 n,
(
pi = pFi
(pi ) = F;
T; otherwise :
However, interpretation obviously model C , contradicts assumption.
follows r must length 9 longer.
concludes proof shows C satisfiable iff P reordering
parallel execution length 8 not.
2

Theorem 7.11

Minimum Parallel Deordering cannot approximate Minimum
Parallel Reordering within jAjk constant k 0.

Proof: proof assumes GT plans simple concurrency. First, define generic

actions aki (m), bki cki (m) according Table 10. Further, define recursively generic
plans
( 1
ha
(1); b0
; c1
(1); : : : ; a1im (1); b0im ; c1im (1)i;
k = 1
k
Pi (m) = ha(ki,1)m+1 (m); P(i,k1),1m+1 ((mi,);1)cmk+1
k
,
1
k
k
1 (m); : : : ; aim (m); Pim (m); cim (m)i; k > 1:
(i,1)m+1
(i,1)m+1
132

fiComputational Aspects Reordering Plans

Furthermore, arbitrary k; n > 0 define ppi kn = hfpk1 ; : : : ; pkn g; fq1k ; : : : ; qnk gi.
Now, prove claim arbitrary k; n > 0, plan P1k (n)
1. kn -valid,
P ,1 2ni
2. deordering length less 3nk + ki=1
3. reordering length 2k + 1.
Proof induction k.
Base case (k=1): Choose arbitrary n > 0. plan P11 (n) obviously kn -valid
deordering itself, length 3n. Consider reordering Q11 (n)
P11 (n) actions ordering relation defined s.t. i, 1 n,
a1i (1) b0i c1i (1) i, 1 < n, a1i (1) b0i,1 . reordering k (n)-valid
parallel execution r11 (n) length 3, defined s.t. i, 1 n, r11 (n)(a1i (1)) = 1,
r11(n)(b0i ) = 2 r11 (n)(c1i (1)) = 3. (This plan shown Figure 15.) claim thus
satisfied base case.
Induction: Suppose claim satisfied l < k, k 1 prove
claim holds l = k. Choose arbitrary n > 0. follows induction
hypothesis none subplans P1k,1 (n) : : : ; Pnk,1 (n) deordered,
remain totally ordered. Furthermore, i, 1 n, necessary action
aki (n) ordered subplan Pik,1(n) action cki (n) ordered it.
clear i, 1 n order cki (n) aki+1 (n) removed without
making plan invalid. Hence, P1k (n) deordering itself,
length
n
X
i=1

(2 + length(Pik,1 (n)) = n(2 + length(P1k,1 (n)))

= 2n + n(3nk,1 +

kX
,2
i=1

2ni ) = 3nk +

kX
,1
i=1

2ni ;

proves deordering case claim.
reordering case, define reordering Qk1 (n) P1k (n) actions
ordering relation defined follows. subplan Pik,1 (n) P1k (n), reorder
actions length 2(k , 1)+1, possible according induction hypothesis.
Further, i, 1 n, j , (i , 1)n + 1 j order aki (n) akj ,1 (n)
ckj ,1 (n) cki (n) (or aki+1 (n) akj ,1 (1) ckj ,1 (1) cki (n) case k = 2). Hence,
action pre-condition

post-condition

aki (m) fpki g
fpk(i,,11)m+1 ; : : : ; pkim,1; :q(ki,,11)m g
bki
fpki g
fqik g
k,1 g post(ck (m)) = fqk g:
cki (m) fq(ki,,11)m+1 ; : : : ; qim


Table 4: Generic actions proof Theorem 7.11.
133

fiBackstro

P11 (n)
a11 (1)

a21 (n)


,
@


,,
1
,
p1
, : a1(1)
1
,
2
p
2

@
p1n@@

...
.
:. q0

p01

:q10
p02
:q20

(n,1)

@@
R a1n(1)



p0n



b01

-

b02

-

b0n

...
..

q10

- c11(1)

@

@@q11
q20 - 1
c2 (1) XXXq21@
X@XXz@R c21(n)
...
,,
,
.
,qn1
,
0
qn - 1 ,
1 cn(1)





:qn1
..
:



.

2

.
a2 (n) XXXX..
z
X
:


.
..
...
...
.
1
:q(1n,1)
:
.

X
a2n (n)
XXX...X
z

P21 (n)

Pn1 (n)

X..XXXXz 2
..: c2(n)
...
..

X..XXXXz 2
.
.: cn(n)

Figure 15: reordering Q21 (n) plan P12 (n) example induction case
proof Theorem 7.11 (solid arrows denote orderings required producerconsumer relationships labelled atom produced/consumed,
dashed arrows denote ordering constraints avoid threats labelled possibly con icting atom).
segment type aki (n); Pik,1 (n); cki (n) reordered length 2k + 1. Finally,
i, 1 n, order aki (n) ak(i,,11)n (n) (or aki (n) ak(i,,11)n (1) case k = 2).
plan Qk1 (n) k (n)-valid since subplans P1k,1 (n); : : : ; Pnk,1 (n) atoms
common and, thus, # relation hold two actions belonging
different subplans. reordered plan executed parallel execution
rik (n) defined s.t. rik (n)(aki (n)) = 1, rik (n)(cki (n)) = 2k + 1 i, 1 n
actions a0 2 Qki ,1 (n), rik (n)(a0 ) = rik,1(n)(a0 ) + 1. Since parallel execution
length 2k + 1 reordered plan, claim holds k.
concludes induction, claim holds k > 0. Since
P ,1 2ni
3nk + ki=1
1
k

2k + 1
(2k + 1)3k,1 jAj
k > 0, theorem holds.
2
134

fiComputational Aspects Reordering Plans

References

Backstrom, C. (1993). Finding least constrained plans optimal parallel executions
harder thought. Backstrom, C., & Sandewall, E. (Eds.), Current Trends
AI Planning: EWSP'93|2nd European Workshop Planning, pp. 46{59 Vadstena,
Sweden. IOS Press.
Backstrom, C. (1994). Executing parallel plans faster adding actions. Cohn,
A. G. (Ed.), Proceedings 11th European Conference Artificial Intelligence
(ECAI'94), pp. 615{619 Amsterdam, Netherlands. Wiley.
Backstrom, C. (1995). Expressive equivalence planning formalisms. Artificial Intelligence,
76 (1{2), 17{34.
Backstrom, C., & Klein, I. (1991). Parallel non-binary planning polynomial time.
Reiter, R., & Mylopoulos, J. (Eds.), Proceedings 12th International Joint Conference Artificial Intelligence (IJCAI'91), pp. 268{273 Sydney, Australia. Morgan
Kaufmann.
Bellare, M., Goldreich, O., & Sudan, M. (1995). Free bits, PCPs non-approximability|
towards tighter results. Proceedings 36th Annual IEEE Symposium
Foundations Computer Science (FOCS'95), pp. 422{431 Milwaukee, WI, USA.
IEEE Computer Society.
Blum, A. L., & Furst, M. L. (1997). Fast planning planning graph analysis. Artificial
Intelligence, 90 (1{2), 281{300.
Chapman, D. (1987). Planning conjunctive goals. Artificial Intelligence, 32 (3), 333{377.
Crescenzi, P., & Panconesi, A. (1991). Completeness approximation classes. Information
Computation, 93 (2), 241{262.
Currie, K., & Tate, A. (1991). O-Plan: open planning architecture. Artificial Intelligence, 52 (1), 49{86.
Feige, U., & Kilian, J. (1996). Zero knowledge chromatic number. 11th Annual
IEEE Conference Computational Compelxity (CCC'96) Philadelphia, PA, USA.
IEEE Computer Society.
Feige, U. (1996). threshold ln n approximating set cover (preliminary version).
Proceedings 28th Annual ACM Symposium Theory Computing (STOC'96),
pp. 314{318 Philadelphia, PA, USA. ACM.
Fink, E., & Yang, Q. (1992). Formalizing plan justifications. Proceedings 9th Conference Canadian Society Computational Studies Intelligence (CSCSI'92),
pp. 9{14 Vancouver, BC, Canada.
Garey, M., & Johnson, D. (1979). Computers Intractability: Guide Theory
NP-Completeness. Freeman, New York.
135

fiBackstro

Gazen, C., & Knoblock, C. (1997). Combining expressivity UCPOP eciency
Graphplan. Steel, & Alami (1997), pp. 221{233.
Ghallab, M., & Laruelle, H. (1994). Representation control IxTeT, temporal
planner. Hammond (1994), pp. 61{67.
Hammond, K. (Ed.). (1994). Proceedings 2nd International Conference Artificial
Intelligence Planning Systems (AIPS'94), Chicago, IL, USA. AAAI Press.
Jonsson, P., & Backstrom, C. (1998). State-variable planning structural restrictions:
Algorithms complexity. Artificial Intelligence, 100 (1{2), 125{176.
Kambhampati, S. (1994). Multi-contributor causal structures planning: formalization
evaluation. Artificial Intelligence, 69 (1{2), 235{278.
Kambhampati, S., & Kedar, S. (1994). unified framework explanation-based generalization partially ordered partially instantiated plans. Artificial Intelligence,
67 (1), 29{70.
Klein, I., Jonsson, P., & Backstrom, C. (1995). Tractable planning assembly line.
Ghallab, M., & Milani, A. (Eds.), New Directions AI Planning: EWSP'95|
3rd European Workshop Planning, Frontiers AI Applications, pp. 313{324
Assisi, Italy. IOS Press.
Klein, I., Jonsson, P., & Backstrom, C. (1998). Ecient planning miniature assembly
line. Artificial Intelligence Engineering, 13 (1), 69{81.
Knoblock, C. (1994). Generating parallel execution plans partial-order planner.
Hammond (1994).
Kohler, J., Nebel, B., Hoffman, J., & Dimopoulos, Y. (1997). Extending planning graphs
ADL subset. Steel, & Alami (1997), pp. 273{285.
Lund, C., & Yannakakis, M. (1994). hardness approximating minimization problems. Journal ACM, 41 (5), 960{981.
Nebel, B., & Backstrom, C. (1994). computational complexity temporal projection, planning plan validation. Artificial Intelligence, 66 (1), 125{160.
Pednault, E. P. D. (1986). Formulating multiagent, dynamic-world problems classical
planning framework. Georgeff, M., & Lansky, A. L. (Eds.), Reasoning Actions Plans, Proceedings 1986 Workshop, pp. 47{82 Timberline, OR, USA.
Morgan Kaufmann.
Regnier, P., & Fade, B. (1991a). Complete determination parallel actions temporal
optimization linear plans action. Hertzberg, J. (Ed.), European Workshop
Planning, Vol. 522 Lecture Notes Artificial Intelligence, pp. 100{111 Sankt
Augustin, Germany. Springer.
136

fiComputational Aspects Reordering Plans

Regnier, P., & Fade, B. (1991b). Determination du parallelisme maximal et optimisation
temporelle dans les plans d'actions lineaires. Revue d'intelligence artificielle, 5 (2),
67{88.
Selman, B., Levesque, H., & Mitchell, D. (1992). new method solving hard satisfiability problems. Proceedings 10th (US) National Conference Artificial
Intelligence (AAAI'92), pp. 440{446 San Jose, CA, USA. American Association
Artificial Intelligence.
Steel, S., & Alami, R. (Eds.). (1997). 4th European Conference Planning, ECP'97, Vol.
1348 Lecture Notes Artificial Intelligence, Toulouse, France. Springer.
Stromberg, J.-E. (1991). Styrning av LEGO-bilfabrik. Andra omarbetade upplagan. Department Electrical Engineering, Linkoping University.
Tate, A. (1975). Interacting goals use. Proceedings 4th International
Joint Conference Artificial Intelligence (IJCAI'75), pp. 215{218 Tbilisi, USSR.
IJCAI, William Kaufmann.
Veloso, M. M., Perez, M. A., & Carbonell, J. G. (1990). Nonlinear planning parallel
resource allocation. Sycara, K. P. (Ed.), Workshop Innovative Approaches
Planning, Scheduling Control, pp. 207{212 San Diego, CA, USA. Morgan
Kaufmann.
Vere, S. A. (1983). Planning time: Windows durations activities goals. IEEE
Transactions Pattern Analysis Machine Intelligence, PAMI-5 (3), 246{267.
Wilkins, D. E. (1988). Practical Planning. Morgan Kaufmann, San Mateo, CA.

137


