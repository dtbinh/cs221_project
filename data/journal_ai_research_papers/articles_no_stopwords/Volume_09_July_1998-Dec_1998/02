journal artificial intelligence

submitted published

computational aspects reordering plans
christer backstrom

department computer information science
linkopings universitet linkoping sweden

cba ida liu se

abstract

article studies modifying action ordering plan order
optimise plan according criteria one criteria make plan
less constrained minimize parallel execution time three candidate
definitions proposed first criteria constituting sequence increasing
optimality guarantees two deordering plans means ordering relations may removed added third one uses reordering
arbitrary modifications ordering allowed shown weakest one
three criteria tractable achieve two np hard even dicult
approximate similarly optimising parallel execution time plan studied
deordering reordering plans general case computations
np hard however shown optimal deorderings computed polynomial
time class languages notions producers consumers
threats includes commonly used languages computing optimal reorderings potentially lead even faster parallel executions
remains np hard dicult approximate even quite severe restrictions

introduction
many applications plans made man computer executed important plans optimal respect cost measure typically execution
time examples applications manufacturing error recovery industrial
processes production logistics robotics many different kinds computations made improve cost plan extensively
studied literature well known frequently used scheduling plan tells actions tasks order
schedule assigns exact release times actions schedule must obey action
order prescribed plan must often satisfy metric constraints
deadlines earliest release times certain actions schedule feasible satisfies
metric constraints usually interesting schedule optimal
respect eg feasible schedule shortest total execution time schedule
missing deadlines actions possible
principle scheduling follow sequence scheduling
viewed post processing step concerned causal
relations qualitative temporal relations actions scheduling concerned
metric constraints actions systems eg plan currie tate
sipe wilkins scheduling integrated one
single system similarly temporal planners eg deviser vere ixtet ghallab
laruelle often reason metric constraints make
c ai access foundation morgan kaufmann publishers rights reserved

fibackstro

irrelevant study scheduling separate though seen
vast literature topics two quite different character
studying separately gives important insight integrated systems
discussed instance drabble says often dicult see
plan plans schedules easy see plan works dicult
see
complication understanding difference scheduling
integrated systems systems separated scheduling
certain types computations fall grey zone scheduling
planners good reasoning effects actions causal relationships
actions usually poor reasoning time temporal relationships
actions schedulers hand primarily designed reason
time resource con icts capabilities reasoning causal dependencies
actions grey zone require reasoning kinds neither
planners schedulers handle properly
solved scheduler get sucient information planner
best situation planner scheduler may fail cooperation
plan feasible schedule even plan exists
article focusses one grey zone namely optimising action order plan allow better schedules whenever two actions con ict
cannot allowed execute parallel planner must order
actions however usually enough information reasoning capabilities
decide two possible orders best one makes arbitrary choice
one choices typically allows better schedule one planner
makes wrong choice may prevent scheduler finding good even feasible
schedule situation arises plans made human expert since difficult see choice ordering best one large complex plan
systems today usually cannot anything better asking planner plan
scheduler fails feasible schedule expensive unsatisfactory
solution especially feedback scheduler help planner making
intelligent choice next time another solution appears literature
use filter planner scheduler attempts modify plan order
put scheduler better position filters could remove certain commitments
ordering referred deordering plan even change order
certain actions referred reordering plan
article intended provide first formal foundation studying type
defines number different optimality criteria plan order modifications
respect degree committment ordering respect
parallel execution time provides computational computing
modifications article analyses filtering suggested literature
order modifications
remainder article structured follows section introduces concepts
computations studied article means example section starts
brian drabble personal communication aug



ficomputational aspects reordering plans

theoretical content article defining two formalisms used following
sections making plan least constrained studied section
candidate definitions concept introduced computational properties investigated section defines concepts parallel plans parallel executions
plans followed section optimal deorderings reorderings parallel
plans introduced complexity achieving optimality analysed section
studies complexity affected restricting language
includes positive literature finds optimal deorderings class plans common languages filtering
literature well planners incorporating ordering optimisation discussed section finally section discusses aspects article
related work section concludes brief recapitulation

example
order illustrate concepts operations studied article simple example
assembling toy car used example variation example used
backstrom klein much simplified version existing assembly line
toy cars used undergraduate laborations digital control linkoping university
description assembly line see eg klein jonsson backstrom
stromberg assemble lego car pre assembled parts
shown figure chassis top set wheels two latter mounted
onto chassis
top

chassis

car

wheels

figure schematic assembly process toy car
workpiece ow factory shown figure three storages one
type preassembled part two workstations number mounting top
number mounting wheels car storage assembled cars tops
moved top storage workstation sets wheels moved
lego trade mark lego company



fibackstro

wheels storage workstation chassis moved chassis storage
workstation possibly parts mounted two workstations
workstation car storage furthermore mounting wheels
chassis tyres must ated workstation incorporates compressed air container
must pressurized ating tyres shown figure

top
storage

workstation

chassis
storage
wheels
storage

car
storage
workstation

figure schematic lay toy car factory
article concerned modifying order actions given plan
consider modifying set actions hence example assume
plan assembling toy car given whether plan produced hand
important assumed assembly plan
contains exactly actions listed table order since
article independent particular language used assumptions
language made example make things simple
obvious common sense constraints plans valid used instance
part must moved workstation mounted wheels must ated
mounted air container must pressurized ating tyres
furthermore since chassis one single place time top cannot
mounted parallel mounting wheels neither mounting operations
done parallel moving chassis part mounted
purpose modifying action order given plan usually optimize
plan aspect instance make plan least constrained consider totally
ordered plan figure producing chassis wheels subplan
plan assembling car note since plan totally ordered pairs actions
ordered implicit transitive arcs shown figure plan clearly
constrained instance necessary move set wheels workstation
pressurizing air container removing ordering constraint
plan figure b note orderings removed arc mvw
existed already original plan implicit transitivity plan
orderings removed referred deordering original plan


ficomputational aspects reordering plans

action
mvt
mvw
mvc
mvc
mvs
mtt
mtw
pac


description
move top workstation
move wheels workstation
move chassis workstation
move chassis workstation
move chassis car storage
mount top chassis
mount wheels chassis
pressurize air container
ate tyres

duration










table actions assembly plan
plan less constrained original plan since possible move
wheels pressurize air container order perhaps even parallel
however orderings removed necessary ate wheels
moving chassis workstation removing ordering plan
figure c least constrained deordering original plan sense
possible remove ordering constraints still valid plan
removing ordering constraint possible sequence
actions way plan longer intended addition
deorderings one may consider arbitrary modifications ordering relation
removing adding relations modifications referred reorderings
three differents least constrainment criteria plans deorderings reorderings
studied section plan figure c happens optimal according
three criteria

mvw pac



mvc mtw

total order plan
mvw pppp
q




pac

mvc mtw

b less constrained version

mvw pppp
q ppppq

pac
mtw

mvc
c least constrained
version

figure three plans mounting wheels


fibackstro

making plan least constrained clearly useful certain actions executed
parallel however even case parallel execution possible may still
worth making plan least constrained although partial order least constrained
plan must strengthened total order execution purposes need
total order original plan suppose actions temporal constaints
deadlines earliest release times scheduler post process plan
try finding feasible schedule may case original plan feasible
schedule less constrained version sequenced feasible schedule
idea least constrained plan scheduler many alternative execution
sequences possible choose
important reason modifying action ordering plan however
execute plan faster executing actions parallel whenever possible purpose
better use length optimal schedule plan measure rather
measure ordering suppose following car assembly plan given
hmvw pac mvc mtw mvt mvc mtt mvs
actions executed sequentially given order minimum execution time
sum durations actions time units however
previous example plan constrained since several actions could executed
order parallel
possible remove orderings far shown figure
still valid plan implicit transitive orderings shown figure
deordered version original assembly plan scheduled execute time units
exploiting parallelism whenever possible example schedule shown
figure b however faster execution possible since plan contains subsequence
actions cannot parallelized total execution time time
units
obvious schedule figure b many actions executed
parallel gain deordering plan quite small much better performance
possible arbitrary modifications action ordering allowed
reorderings considered instance assembly plan particular reason
wheels mounted top mounted seen shortly
much time saved reversing order two operations deordering
cannot however since removing ordering wheel mounting action
mtw top mounting action mtt would make unordered would
interpreted two actions could executed parallel possible
reason actions must ordered original plan however
allowing arbitrary modifications order two actions reversed
figure shows reordering original plan plan scheduled
execute time units considerable improvement original
plan optimal deordered version example optimal schedule shown
figure b fact plan optimal reordering sense ordering
actions valid plan scheduled execute faster
finding optimal deorderings reorderings plan respect parallel execution
main topic article studied sections


ficomputational aspects reordering plans

pac
mvw

mvt



mtw

mvc

mtt

mvc

mvs

deordering assembly plan admitting shortest
parallel execution time
pac



mvw

mtw

mvc

mtt

mvs

mvc
mvt












b optimal schedule plan

figure optimal deordering assembly plan
obvious reordering powerful operation deordering since
reordered plan figure allows shorter schedule optimal deordering
figure hand original plan

hmvt mvc mtt mvs mvw pac mvc mtw
deordering would sucient arriving optimal plan figure

formalisms
section defines actions plans related concepts basically appear two
different guises article definitions tractability mostly cast
general axiomatic framework order general independent formalism
possible hardness hand mostly cast specific formalism
ground tweak often subject restrictions order strengthen
formalisms defined addition third formalism
used definition deferred used section


fibackstro

pac



mvw

mvt

mtt

mvc

mvc

mvs

mtw

reordering assembly plan admitting shortest
parallel execution time
pac
mvc



mvw

mvt mtt




mtw

mvs

mvc




b optimal schedule plan

figure optimal reordering assembly plan

axiomatic framework

axiomatic framework makes minimum assumptions underlying formalism may instantiated formalism defines concept
domain entities called actions validity test
assumed consist instances ppis assumptions inner structure validity test truth valued function
taking ppi sequence actions arguments validity test true ppi
action sequence ha action sequence ha said solve
inner structure ppis exact definition validity test crucial specific formalism many article proven without
making assumptions computational complexity certain
make assumption complexity validity test though
concepts notion plans defined usual way

definition total order plan plan sequence p ha ani actions
alternatively denoted tuple hfa g k l n
ak al iff k l given ppi p said valid iff validity test true

p

complexity theoretic terminology instances sense
article sometimes referred literature



ficomputational aspects reordering plans

partial order plan p plan tuple p ha set actions
strict ie irre exive partial order validity test extended p plans
given ppi p valid iff ha valid every topological sorting

actions plan must executed specified order unordered
actions p plan may executed order p plan viewed
compact representation set plans implicit assumption
unordered actions executed parallel parallel plans defined section
p plans viewed directed acyclic graphs figures transitive arcs often
tacitly omitted enhance readability furthermore proofs article
definition ie assuming order plan transitively closed
many practical planners bother transitive closures difference
affect presented

ground tweak formalism

ground tweak gt formalism tweak language chapman restricted
ground actions formalism variation propositional strips known
equivalent polynomial transformation common variants propositional strips backstrom brief action precondition postcondition sets ground literals
order define gt formalism following two definitions required given
set notion seqs denotes set sequences formed members
allowing repetition elements including empty sequence symbol
used denote sequence concatenation operator given set p propositional
atoms set lp literals p defined lp p f p j p pg since
formulae allowed atoms negated atoms double negation p
treated identical unnegated atom p finally given set literals l negation
neg l l defined neg l f p j p lg fp j p lg l said consistent
iff atom p p l p l

definition instance gt quadruple hp gi



p finite set atoms
finite set operators form hpre posti pre post lp consistent
denote pre post condition respectively

g lp consistent denote initial goal state respectively
hpre posti write pre post denote pre post respectively
sequence ho seqs operators called gt plan simply plan
definition ternary relation valid seqs l l defined arbitrary ho seqs lp valid ho holds iff
n
p



p

fibackstro

n pre
valid ho neg post post
plan ho seqs solves iff valid ho g

action unique instance operator ie set actions may contain several
instances operator inherits pre post conditions operator
instantiates since article consider fixed set actions
atom operator sets frequently tacitly omitted gt ppis figures
gt actions shown boxes precondition literals left postcondition
literals right

least constrained plans

seems generally assumed community difference plans p plans sense plan easily converted
p plan vice versa however p plan trivially converted
plan low order polynomial time topological sorting less obvious
converse holds least three converting plans p plans
presented literature pednault regnier fade veloso perez
carbonell analyzed later article claim
plan easily converted p plan vacuously true since plan
already p plan definition hence computation needs done
hardly intended compute however order useful
must output p plan satisfying interesting criterion ideally
optimality criterion fact two mentioned claimed produce
optimal plans according certain criteria instance veloso et al p claim
produce least constrained plans define mean
term however hardly literature term
without definition
unfortunately means obvious constitutes intuitive good criterion
p plan least constrained extent depends
purpose achieving least constrainment major motivation producing p plans
instead plans see instance tate p plan post processed
scheduler according criteria release times deadlines resource
limits actions ordered ideally optimal sequence given criteria
parallel execution parallel plan executed faster actions
executed sequence cases less constrained original plan greater
chance arriving optimal schedule optimal parallel execution respectively
mentioned motivated goal exploiting possible
parallelism decrease execution time
interesting make plans partially ordered make partially
ordered plans partially ordered generalise ordering
task presented literature context case
kambhampati kedar since plan special case p plans
section study general making partially ordered plans less constrained


ficomputational aspects reordering plans

least constrainment criteria

naturally infinitude possible definitions least constrainment seem
reasonable others however three intuitively reasonable candidates defined
analyzed although definitions possible questionable whether
considerably better natural definitions respect purposes mentioned
defined without information usually present
p plan

definition let p ha q ha two p plans ppi
q reordering p wrt iff p q valid
q deordering p wrt iff q reordering p

q proper deordering p wrt iff q reordering p

definition given ppi two p plans p ha q ha
q minimal constrained deordering p wrt iff
q deordering p wrt
b proper deordering q wrt
q minimum constrained deordering p wrt iff
q deordering p wrt
b deordering ha iof q wrt j j j j
q minimum constrained reordering p wrt iff
q reordering p wrt
b reordering ha iof q wrt j j j j

note previous publication backstrom used terms lc minimality
minimal constrained deordering lc minimality minimum constrained reordering
change terminology done hope gained clarity
lost confusion
easy see minimum constrainment stronger criterion minimalconstrainment minimum constrained deordering plan p minimal constrained
deordering p opposite true example consider plan figure
removing ordering constraints action c plan figure b
still valid plan order size one implicit transitive order
minimal constrained deordering since deordering made
minimum constrained deordering however since instead breaking ordering constraints
subsequences ab cb plan figure c valid
plan ordering size easily seen minimum constrained
deordering happens coincide minimum constrained reordering
case coincidence case however since reordering allowed


fibackstro

modifications deordering minimum deordering obviously never
smaller ordering relation minimum reordering examples difference
shown already section figure shows minimum constrained deordering
figure b shows minimum constrained reordering


p

p

b



q

c

q

q



total order plan
c


p

p

b

q

q

q

c





b minimal deordering

q

q



p

p

b

q

b minimum deordering

figure difference minimal minimum constrained deorderings
alternative definitions least constrainment could instance maximize
unorderdness minimize length longest chain modified plan however de reordering many pairs unordered actions possible
dual computing minimum de reordering thus already covered minimizing
length longest chain condition may relevant actions
executed parallel overall execution time minimized however since
number ordering constraints quadratic length chain transitive
arcs minimizing size relation often reasonable approximation minimizing chain length furthermore minimizing longest chain still rather weak
condition purpose better study directly finding shortest
parallel executions plans done later article
another issue whether minimize size ordering relation given
reduce transitive reductive closure since plans may super uous orderings
particular purpose reasonable standardize matters add possible
transitive arcs getting transitive closure remove transitive arcs getting
reductive closure choice two important
proven however minimizing transitive closure give preference plans
many unordered short chains actions plans long chains seems
coincide better term least constrained

computing least constrained plans
minimal deordering weaker two least constrainment criteria considered
least costly achieve one three criteria
satisfied polynomial time modification plan


ficomputational aspects reordering plans

definition search

minimal constrained deordering mlcd

defined follows
given ppi valid plan p
output minimal constrained deordering p wrt

theorem

mlcd solved polynomial time validity p plans

tested polynomial time

proof consider mld figure let q ha plan output
input p ha plan q obviously valid deordering p wrt

obvious termination condition loop
ordering ha valid follows q minimal constrained
deordering since obviously runs polynomial time theorem follows



furthermore validity testing expensive dominating cost mld


corollary validity testing p plans solved time f n
function f n mlcd solved maxfn n f n g time
procedure mld

input valid p plan p ha ppi

output minimal deordering p
e ha feg valid

remove e
return ha

figure minimal deordering mld
particular note plan validation polynomial usual variant propositional strips without conditional actions nebel backstrom theorem
precisely proof pertains common propositional strips formalism cps
thus holds common variants propositional strips ground
tweak backstrom furthermore note practice may necessary
compute transitive closure output plan validating plan

minimum de reordering stronger criteria minimal deordering
costly achieve

definition decision

minimum constrained deordering mmcd

defined follows
given ppi valid plan p integer k
question deordering ha p j j k


fibackstro

definition decision

minimum constrained reordering mmcr

defined follows
given ppi valid plan p integer k
question reordering ha p j j k

theorem

minimum constrained deordering np hard

proof proof reduction minimum cover garey johnson p
np complete let fp pn g set atoms c fc cm g set
subsets k jc j positive integer cover size k subset c c
jc j k c construct polynomial time gt ppi h frgi
valid plan p ha pre ai post ai ci
pre post frg obviously minimum cover size k
iff exists valid p plan q hfa g j j k since


actions contributing cover need remain ordered wrt

corollary



minimum constrained reordering np hard

corollary

minimum constrained deordering minimum constrained

reordering remain np hard even restricted gt plans actions

positive pre post conditions

theorem validity p plans complexity class c

minimumconstrained deordering minimum constrained reordering np c

proof guess solution verify de reordering validate



oracle c

common formalisms without conditional actions context dependent
effects minimal de reordering np complete

theorem validity p plans tested polynomial time minimum

constrained deordering minimum constrained reordering np complete

proof immediate theorems corollary



follows immediately corresponding search
generating minimum constrained de reordering np hard even np equivalent
validity testing tractable
furthermore mmcd mmcr hard solve optimally even
approximate neither approximation class apx crescenzi
panconesi ie neither approximated within constant factor
elsewhere article term approximation used constructive
sense refer existence non existence producing
approximate solution polynomial time


ficomputational aspects reordering plans

theorem

minimum constrained deordering minimum constrained
reordering cannot approximated within constant unless np dtime npoly log n

proof suppose polynomial time approximating mmcd within
constant since reduction proof theorem preserves solutions exactly
approximations preserved hence minimum cover could approximated within
constant impossible unless np dtime npoly log n lund yannakakis
contradicts assumption case mmcr trivial consequence
number propositional atoms plan measure size
bound strengthened ln jpj arbitrary unless np dtime nlog log n
substituting minimum cover feige proof

parallel plans

order study finding shortest parallel execution plan formalisms used far quite sucient since lack capability modelling
actions executed parallel impossible say reasonable precision certain action ordering affect parallel execution time partial order
plans sometimes referred parallel plans literature misleading however
two actions left unordered plan means executed
order without affecting validity plan general case
guarantee plan remain valid executions actions overlap
temporally cases unorderedness means parallel overlapping execution
allowed cases mean depending action modelling
underlying domain assumptions first case plan must stronger ordering
committment two actions must overlapping executions must ordered
thus making plan committed
order distinguish two cases concept parallel plans introduced
parallel plan partial order plan extra relation non concurrency relation
tells actions must executed parallel article two actions
considered parallel executions temporal overlap plans
unordered actions executed parallel constitute special case definite parallel
plans

definition parallel plan triple p ha ha p plan
irre exive symmetric relation definite parallel p plan parallel plan
p ha
intuitively parallel plan p plan extended extra relation nonconcurrency relation expressing actions must executed parallel
relation primarily intended convey information actions unordered
relation although allowed relate actions
relation intended capture information whether two actions executed
parallel general two actions ordered plan forbids executing
parallel particular plan necessarily mean actions could


fibackstro

executed parallel different circumstances frequently produce overcommitted orderings plans whole purpose article study
optimizing plans finding removing overcommitted orderings hence
restrictions general relation addition definition
instance b imply b however non concurrency relation
frequently constrained satisfy post exclusion principle
definition parallel gt plan p ha satisfies post exclusion principle
iff actions b b whenever atom p p post
p post b
definition plan validity directly inherited p plans
definition given ppi parallel plan ha valid iff p plan ha
valid
non concurrency relation thus relevant deciding whether plan valid
instead used constraining parallel plans may executed
core concept behind definition parallel executions
consider instance gt plan hfa b c g fha b ig fhb c igi shown
figure arrows denote ordering relations dashed lines denote nonconcurrency relations plan valid wrt ppi h fr sgi final value atom q
matter since b c holds actions b c constrained executed
parallel may executed order plan definite could
post exclusion principle employed reason although
b hold actions b clearly cannot executed parallel since b
holds four ways execute plan three sequences b c
c b c b executing c parallel followed b unit length assumed note plan would longer valid goal contained q
q since final truth value q depends actual execution order furthermore
reordering plan would keep ordering constraint b satisfy
validity criterion necessary constraint b would harm
include restriction complex plans may constrainment
several producers atom p choose instance sum
non concurrency relation primarily used mark actions must
parallel addition already forbidden parallel validity
framework parallel plans admits expressing possible parallelism necessary
parallelism scope article requires planner access
able make use additional information perhaps temporal algebra
furthermore set non concurrent actions easily expressed making actions
set pairwise non concurrent formalism sucient say k
actions set may executed parallel similarly possible
express action must executed interval two sets
actions must non overlapping executions
definition let p ha parallel plan let function n denote
duration action parallel execution p function r n denoting
release times actions satisfying b


ficomputational aspects reordering plans



p

q
r

b


c q
figure parallel plan
b r r b
b
r r b
b r b b r
length parallel execution defined maxa fr g ie latest finishing time action minimum parallel execution plan parallel execution
minimum length among parallel executions plan length parallel plan p
denoted length p length minimum parallel execution p

p

obviously every parallel plan parallel execution length
trivial case sequential execution furthermore certain cases hardness
strengthened restricting duration function
definition special case referred unit
time assumption
deciding whether release time function parallel execution tractable
theorem given parallel plan p ha duration function n
release time function r n decided polynomial time whether r parallel
execution p case length execution
proof trivial

consider plan figure three release time functions r r r defined
follows
r r b r c
r r b r c
r r b r c
r r parallel executions plan r furthermore r
minimum parallel execution plan length however computing
minimum parallel execution parallel plan dicult general case


fibackstro

definition decision parallel plan length ppl defined follows
given parallel plan p ha duration function integer k
question p parallel execution length k shorter

theorem

parallel plan length np hard

proof hardness proven transformation graph k colourability garey
johnson p np complete let g hv e arbitrary undirected graph v fv vn g construct polynomial time gt ppi follows define ppi h fp pn gi define parallel plan p ha
contains one action ai vertex vi v pre ai post ai
fpi qi g f qj j fvi vj g e g finally let ai aj iff fvi vj g e satisfies post

exclusion principle plan p constructed obviously valid easy see
g k colourable iff p parallel execution length k wrt since colour g
correspond unique release time parallel execution p


corollary

parallel plan length remains np hard even restricted gt ac

theorem

parallel plan length np

tions empty preconditions assumption unit time post exclusion
principle

proof guess parallel execution verify done polynomial time


according theorem

computing minimum parallel execution plan tractable special case definite
plans however

theorem
parallel plans

parallel plan length solved polynomial time definite

proof use dppl figure straightforward stratification


directed dags

reordering parallel plans
defined concept parallel plan possible define concepts similar
previous least constrainment criteria appropriate minimizing
execution time parallel plans

definition let p ha q ha two parallel plans ppi


q parallel reordering p wrt iff p q valid


ficomputational aspects reordering plans














procedure dppl

input definite parallel plan p ha
output minimum parallel execution r p
construct directed graph g ha

r

select node without predecessors
b b
r b max r b r



return r

fag

figure computing minimum parallel execution definite parallel plans
q parallel deordering p wrt iff q parallel reordering p
q minimum parallel reordering p wrt iff
q parallel reordering p wrt
b parallel reordering p wrt shorter length q
q minimum parallel deordering p wrt iff
q parallel deordering p wrt
b parallel deordering p wrt shorter length q

modifying plans satisfy latter two criteria dicult general case
however

definition decision minimum parallel deordering mmpd defined follows
given ppi parallel plan p duration function integer k
question p deordering parallel execution length k wrt

definition decision minimum parallel reordering mmpr defined follows
given ppi parallel plan p duration function integer k
question p reordering parallel execution length k wrt

theorem minimum parallel deordering np hard
proof similar proof theorem given graph g integer k construct
ppi plan p ha way proof theorem
let arbitrary total order obviously p valid q ha

deordering p deordering p shorter q hence q thus p
deordering parallel execution length k iff g k colourable



fibackstro

corollary
corollary

minimum parallel reordering np hard

minimum parallel deordering minimum parallel reordering remain np hard even restricted totally ordered gt plans

sumptions unit time simple concurrency

note restriction definite input plans covered corollary output
plans required definite reordering case remains np hard

theorem

minimum parallel reordering remains np hard output

plan restricted definite

proof reuse proof theorem follows let r shortest parallel execution
plan q assume execution length n construct order
actions b b iff r r b obviously plan ha definite

minimum parallel reordering p follows p definite parallel reordering
length k iff g k colourable


open question whether minimum deordering remains np hard output
plans must definite important special case polynomial proven
next section

theorem

minimum parallel deordering minimum parallel reorder

ing np c validation p plans complexity class

c

proof

given plan ha duration function parameter k guess
de reordering release time function r verify oracle c
ha valid finally verify r parallel execution length k
polynomial according theorem


theorem minimum parallel de reordering np complete p plans vali

dated polynomial time

proof immediate theorems corollary



mmpd mmpr hard solve optimally
approximate

theorem

minimum parallel deordering minimum parallel reordering cannot approximated within jaj unless p np

proof
suppose polynomial time approximating mmcd within
jaj immediate proof theorem
graph k colourability could approximated within jaj impossible
unless p np bellare goldreich sudan



reasoning bound strengthened jaj assumption
co rp np feige kilian


ficomputational aspects reordering plans

restricted cases
since computing minimum de reorderings dicult even
dicult approximate alternative way tackling could study restricted
cases one special case already considered restriction definite plans
mmpr still np complete restriction open question whether
mmpd np complete positive proven though effect
mmpd polynomial definite plans large class languages including
commonly used ones proven generalising
literature deordering total order plans
necessarily true argument easier generate plan
p plan complex action representations regnier fade b
presented converting plan p plan resulting plan
property unordered actions executed parallel plan
definite authors claim finds pairs
actions executed parallel hence plan post processed
optimal parallel execution define mean criterion
however
incidentally proposed regnier fade special case earlier proposed pednault make
claims optimality removing regnier fade details relevant
particular implementation language two coincide
thus presented one single prf figure
prf slightly modified original first assume input plan totally ordered since turns sucient definite partial order
plan second prf returns parallel plan rather p plan harmless modification since additional piece information non concurrency relation
already given input explicitly implicitly third prf returns transitive
closure ordering relation means necessary motivated usual
conforming definitions article
procedure prf

input ppi valid definite p plan ha non concurrency
relation

output valid parallel plan
b b

b

order b
return ha

figure prf
obviously prf computes deordering input unclear whether possible compute minimal definite deordering polynomial time however
afterwards literature referred acronyms consisting
initials authors case pednault regnier fade



fibackstro

abstracted general formalism analysis restricted formalisms reveals performance language used regnier fade
unnecessarily restricted shown work considerably
general formalism generalising abstracting concepts producers consumers threats used common planners languages eg strips
tweak formalism referred producer consumer threat formalism
pct
let prod denote produces condition cons consumes
threat threat simplify definitions standard transformation
used simulating initial goal states actions every pct plan
contains action ordered actions consumes nothing produces
initial state similarly action ordered actions consumes
goal state produces nothing means ppi contained within plan
references ppis omitted following validity plans
defined follows

definition pct plan ha valid iff n
conditions cons ai j j prod aj k
j k threat ak p pct plan valid iff topological sortings

valid

chapman modal truth criterion mtc chapman abstracted
pct formalism analogously used validating p plans

definition modal truth criterion mtc pct plan ha
ac cons ac
ap prod ap ap ac
threat
ac
aw prod aw aw aw ac
theorem mtc holds pct plan p iff valid
proof trivial generalization proofs leading theorem nebel backstrom





minimum constraints two actions may executed parallel
required constraints obeyed planners ai literature

definition simple concurrency holds actions b b nonconcurrency relation satisfies following three conditions
prod cons b b
prod threat b b
cons threat b b


ficomputational aspects reordering plans

note required two producers two consumers two threats
condition non concurrent thus allowing instance plans multiple producers eg
nebel backstrom fig kambhampati axioms prevent
adding restrictions though furthermore note definition states necessary condition non concurrency perfectly legal add non concurrency
constraints actions plan may worth noting mtc requires
producers threats ordered correpsonding consumer
definite plan satisfying simple concurrency criterion require ordered
following observation prf immediate used
proofs

observation ha input prf ha corresponding
output holds b iff b b
lemma proven prf preserves validity

lemma plan input prf valid pct plan satisfies simple
concurrency criterion output plan valid

proof let p ha input plan q ha output plan since

p valid follows theorem mtc holds p adding implied
simple concurrency constraints mtc yields following condition

ac cons ac
ap prod ap ap ac ap ac
threat
ac ac
aw prod aw aw aw
aw ac aw ac
applying observation simplified

ac cons ac
ap prod ap ap ac
threat
ac
aw prod aw aw aw ac
mtc plan q theorem follows q valid



allows proving prf produces definite minimum deorderings definite pct
plans simple concurrency

theorem pct formalism simple concurrency prf produces
minimum deordered definite version input


fibackstro

proof let p ha input plan assumed valid definite
q ha output plan obvious follows lemma

q valid q deordering p remains prove q minimum deordering
p
suppose p deordering r ha j j j j must
b b b assumed b

transitive arc since transitive closure anyway computed end
since order produced prf follows observation
b b latter constraint necessary b
b holds former possible since b r deordering p
contradicts assumption q must minimum deordering p

since prf polynomial follows definite minimum deorderings
definite pct plans computed polynomial time simple concurrency furthermore since prf produces definite plans possible actually compute shortest
parallel execution eciently

theorem plan input prf valid definite pct plan satisfying
simple concurrency criterion prf outputs definite minimum deordering plan

proof prf runs polynomial time obviously produces definite parallel plans
hence follows theorem minimum parallel execution output plan
found polynomial time proves theorem


seems likely regnier fade meant optimality claim although special instance pct formalism says nothing
diculty finding minimum reordering plan since prf considers deorderings
since minimum deorderings approximate minimum reorderings well suspected dicult compute latter following theorem confirms
suspicion showing latter remains np hard quite severe restrictions
including following two

definition gt action toggling iff literals l post case
l pre gt action unary iff jpost j
theorem minimum parallel reordering remains np hard even restricted

total order gt plans toggling unary actions assumption unit
time simple concurrency actions redundant

proof theorem appears appendix
minimum reorderings dicult compute minimum deorderings
produce arbitrarily better

theorem

minimum parallel deordering cannot approximate minimum parallel reordering within jajk constant k

proof theorem appears appendix


ficomputational aspects reordering plans

corollary minimum parallel deordering cannot approximate minimum parallel reordering within jajk constant k even restricted gt plans positive preconditions assumption simple
concurrency

may thus appear though minimum reordering preferable albeit costly
operation minimum deordering however plan modification followed
scheduling longer obvious reordering prefer since scheduling may
take information constraints account eg upper lower bounds
release time limited resources feasible schedule original plan may longer
feasible schedule reordering plan feasible solutions
may lost reordering plan contrast deordering plan harmless
since previously feasible schedules preserved deordering course de reordered plan may better schedules old plan
studied article interesting however minimum deordering
safe usually cheap operation minimum reordering neither must thus
applied care reordering plan optimum schedule would
require combining minimum reordering scheduling one single computation
scope article study combinations suce observe
computation never cheaper constituent computations

related work
section analyses discusses suggested literature generalising ordering plan addition prf already analysed
preceeding section planners generate plans optimality avour
ordering discussed
analysed use common trick simulating initial
state goal instance two extra operators following way let
p ha plan hi gi ppi gt language introduce two extra
actions ai pre ai post ai ag pre ag g post ag
define plan q ha fai ag g fai ag j ag fai ag g
ai ordered actions ag ordered actions
plan q representation plan p ppi combined representation
referred self contained plan self contained plan valid iff valid wrt
ppi h trivial convert plan ppi corresponding self contained
plan vice versa hence ways representing plan used alternately
without notice

vpc

veloso et al presented referred vpc converting
plans least constrained p plans use following context
first total order planner nolimit used produce plan vpc converts plan
original publication named build partial order



fibackstro

procedure vpc

input valid self contained plan ha
ai ag

output self contained valid p plan
n

p pre ai

max k p post ak

k exists

order ak ai

p post ai

k p pre ak

order ak ai

primary effect p post ai

k p post ak

order ai ak

n

order ai ai ai ag

return hfa ang

figure vpc
p plan post processed determine actions executed
parallel action language used strips style language allowing quantifiers
context dependent effects however plans produced planner thus input
vpc ground without context dependent effects ordinary
propositional strips plans vpc presented figure minor
differences presentation compared original appearance first
presented gt formalism order minimize number formalisms article
preconditions assumed positive thus coinciding original
second original returns transitive reduction computed order
instead returns transitive closure unimportant difference order coincide
definition plans article furthermore veloso pointed
published version vpc incorrect corrected version exists
version presented figure corrected version proposition primary
effect appears goal subgoaling chain goal proposition
vpc greedy constructs entirely partial order analysing
action conditions original total order guide greedy strategy
claimed veloso et al p produce least constrained p plan
although definition given means veloso confirmed term least
constrained plan used loose sense optimality claim intended however
term defined impossible know
intended solve judge whether makes improvement
absence definition authors analysed
respect least constrainment criteria defined section admittedly
personal communication oct
veloso ibid



ficomputational aspects reordering plans

p
q


b r


p

pq
ppp
pp
qc
p

pq

q

p b qr

q c

p

figure p plans failure example vpc
somewhat unfair analysis reveals interesting facts
solve immediate theorem corollary
vpc cannot expected produce minimum constrained de reorderings perhaps
surprisingly vpc even guarantee output minimal constrained
deordering input already proven trivially polynomial theorem
illustrated following example
suppose total order planner given ppi h fr sgi input may
return valid plans ha b ci ha c bi action conditions shown
figure used input vpc two plans give quite different plan ha c bi converted p plan p figure
plan ha b ci converted p plan p figure first
case vpc produces plan minimal constrained deordering even
minimum constrained deordering second case even produce
minimal constrained deordering
reason vpc may fail produce minimal constrained deordering
uses non admissible greedy strategy whenever needs operator achieving
effect required precondition another operator b chooses last action
ordered b input plan however may actions earlier
plan effect better choice

kk

kambhampati kedar presented generalising ordering p plan explanation generalisation first
constructing validation structure plan use guide generalisation phase original computations divided two separate
exp mtc exp ord gen compacted one single kk figure furthermore version presented restricted ground
gt plans original handle partially instantiated plans
restriction shown
first part kk constructs validation structure v plan
explanation precondition every action plan validity criterion
underlying phase simplified version chapmans modal truth criterion chapman
note transitive arcs omitted figures p really ordering relation size three
although example would work plans defined equally reasonable way
ordering relations intransitive possible construe similar examples case



fibackstro






















procedure kk

input valid self contained p plan ha
output deordering input plan
comment build validation structure v plan

v



let ha topologically sorted version ha
n
p pre ai
min k
p post ak
j k j p post aj
add hak p ai v
comment construct generalised ordering plan
ha bi
add ha bi following holds
ai ag
ha p bi v p
hc p ai v p post b
hb p ci v p post

return ha

figure kk
without white knights since simplified handle ground plans
explanation causal link hap p ac meaning action ap produces
condition p consumed action ac constructs exactly one
causal link precondition chooses earliest producer p preceeding ac
intervening action producing p producer ac second phase
builds generalised ordering plan validation
structure put things simply orderings original plan kept
correspond causal link validation structure required prevent
threatening action unordered wrt actions causal link
turns kk fails generating plans guaranteed even minimal constrained deorderings consider plan ha b c di
action conditions indicated figure plan valid ppi
h fr ugi since kk chooses earliest possible producer
precondition validation structure build validation structure
fha p di ha ag hb q di hb ag hc r ag hd u ag ig hence final ordering
produced kk shown figure however plan minimalconstrained deordering original plan since deordered shown
figure b remain valid example input plan totally ordered
case partially ordered input plans behaviour depends particular topological order choosen may may minimal constrained
deordering impossible guarantee succeed plans similarly
authors mention one may consider different ways constructing validation struc

ficomputational aspects reordering plans

ture would clearly modify behaviour remains open question whether
possible generate polynomial time validation structure guarantees
minimal constrained deordering constructed second phase finding validation structure guarantees minimum constrained deordering obviously
np hard since second phase polynomial
ps

ps

zz

b qt

zz p
q

p
r

u

c q

plan produced kk

q

u

b qt

c pq

r

p

b minimal deordered version

figure failure example kk

planners optimality guarantees
graphplan blum furst notion time steps
tries pack many non interacting actions possible one single time step furthermore graphplan finds shortest plan number time steps measure
assuming unit time actions considered non interacting graphplan
executed parallel plan shorter parallel execution
plan produced graphplan graphplan produces minimum reordered
parallel plans assumptions second assumption limitation practice
since non concurrency relation encoded introducing atom letting
one interacting actions add one deletes unit time assumption serious however especially since assumption likely hold
applications car assembly scenario section instance graphplan would
produce plan corresponds plan figure hence plan produced
unit time assumption happens coincide optimal plan taking actual
execution times account fortunate coincidence however depending
particular durations actions example suppose instead durations
actions slightly different pac duration mvt duration
plan produced graphplan corresponds plan figure
faster schedule time units optimal since plan figure
scheduled execute time units particular duration times furthermore must remembered graphplan anyway restricted cases
gt equivalent language sucient although recent improvements extend


fibackstro

somewhat expressive languages gazen knoblock kohler nebel hoffman
dimopoulos
knoblock modified ucpop planner resource concept makes
avoid unordered interacting actions means resulting planner produces
definite parallel plans knoblock modified evaluation heuristic search
take parallel execution time account thus seems planner might able
produce minimum reordered parallel plans provide sucient details
determine whether case unclear whether heuristic handle
actions different duration times
yet another example polynomial time planner sas iao language jonsson backstrom produces plans minimum constrained
reordered restricted formalism clearly possible optimise ordering
polynomial time

discussion
previous section listed literature produce
attempt produce plans least constrained minimum parallel reordered
certain restrictions though furthermore plans generated
scratch generated modifying already existing plan referred
case repairing plan failed execution phase
cases old plan may contain many ordering relations obsolete
modified repaired plan fact kk kambhampati kedar
motivated context case important remember
today probably long time future plans generated entirely
computer programs vast majority plans applications designed
humans possibly computer support already quite small plans dicult
human see whether ordering constraints optimal computer support
analyses vital designing optimal plans reason hierarchicaltask network planners eg plan currie tate sipe wilkins produce
plans reordering actions could lead better schedules planner often commits
one two possible orderings pair actions expert knowledge rules
however hardly possible human expert design rules situations
guarantee optimal ordering choice made
coarseness level complexity analysis matter whether tasks
plan optimization scheduling integrated separated since total
resulting complexity cases latter two computations
np complete thus dominated pspace complete
worse however good reasons prevented community
studying scheduling separate since understanding
isolation helps understanding overall process reason important
study separately discussed analysed article furthermore
fine grained practical level might considerable differences eciency
integrating three computations separately instance even
three computations take exponential time considered isolation


ficomputational aspects reordering plans

may fewer parameters case may much ecient solve
isolation hand solving whole may make easier
global optimisation better depend methods used
properties actual application seems unlikely one
methods better
shown article minimum reordering much better optimality
criterion minimum deordering considering overall parallel execution time
however necessarily true considering metric constraints subsequent scheduling deordering plan add number feasible schedules
reordering may remove worst case feasible schedules
hand reordering may lead better schedules reachable via deordering
deordering thus viewed safe sometimes cheap way allow better
schedules reordering expensive method potential generating
considerably better plans may make things worse reordering
practice cases metric scheduling constraints involved seems necessary
use feedback scheduler control reordering process try reorderings one could imagine reordering uses heuristic search
randomized local search methods la gsat selman levesque mitchell
reorderings use scheduler evaluation function proposed reorderings
plan modifications studied article may add considerably optimizations possible traditional scheduling still potential
optimization left study modifying action order set actions modification already done plan adaptation generating
plan old cases optimizations sense article considered
preliminary studies action set modifications appear literature though fink
yang study removing redundant actions total order plans
defining spectrum redundancy criteria analysing complexity achieving
less clear interesting study action addition adding actions plan could
obviously improve execution time executed sequentially however
case parallel execution plans shown adding actions plan
sometimes allow faster execution backstrom finally allowing removal
addition actions even greater potential optimising plans seems available
seems yet studied literature

conclusions
article studies modifying action ordering plan order
optimise plan according criteria one criteria make plan
less constrained minimize parallel execution time three candidate
definitions proposed first criteria constituting spectrum increasing
optimality guarantees two deordering plans means ordering relations may removed added last one builds reordering
arbitrary modifications ordering allowed first three candidates
subset minimal deordering tractable achieve two deordering

fibackstro

ordering plan minimize size ordering np hard even dicult
approximate
similarly optimising parallel execution time plan studied deordering
reordering plans general case computations np hard
dicult approximate however literature shown
optimal deorderings computed polynomial time definite plans class
languages notions producers consumers threats
includes commonly used languages computing optimal reorderings
potentially lead even faster parallel executions remains np hard
dicult approximate even quite severe restrictions furthermore deordering
plan safe respect subsequent scheduling reordering plan may remove
feasible schedules making deordering good often suboptimal practice

acknowledgements

tom bylander thomas drakengren mark drummond alexander horz peter jonsson
bernhard nebel erik sandewall sylvie thibeaux anonymous referees provided
helpful comments article previous versions supported
swedish council engineering sciences tfr grants dnr


appendix

theorem minimum parallel reordering remains np hard even restricted

total order gt plans toggling unary actions assumption unit
time simple concurrency actions redundant

proof proof reduction sat garey johnson p let p
fp png set atoms c fc cm g set clauses p
ci fli li li g set three literals p
first define set atoms

q fpfi pti qi j ng fci j ri j j n j g
define gt ppi hi gi initial goal states defined
neg q
g fpfi pti qi j ng fci j ri j j n j g
atom pi p define four actions according table
clause ci c define nine actions according table
f

l pk li j pk
j

ptk

li j pk

let set n actions thus defined clearly total order
plan p ha valid obvious none actions redundant


ficomputational aspects reordering plans

trivial observation parallel execution r valid reordering p
must satisfy n

r afi r r ati r



r c

k

r r ati r r afi



r
ci k
r ci k




k r c r bi k r c r bi k r ci k
k
k

r b



k k k permutation numbers interpreted
c released order simultaneously analogously
actions ci k
k



actions ci k
ci k


remainder proof shall p reordered parallel
execution length iff set c clauses satisfiable
suppose c satisfiable let truth assignment atoms p satisfies
c wlg assume pi clause cj let lj literal cj
satisfied disregarding action order moment choose release time
function r actions follows n let

r r ati r r afi
j j choose k lj k cj satisfied least one
choice must exist assumption let lj k lj k remaining two literals cj
assign release times h
h r b h r c h
r cj k
j kh
j kh
h

define partial order actions b b iff r r b
clearly plan ha valid reordering p r parallel execution length
ha note choice could force longer execution
execution length case c satisfied setting atoms false
operator precond postcond

afi
ati



pfi qi pfi
pti qi pti
qi
qi
qi
qi

table generic actions atom pi proof theorem


fibackstro

operator precond

bi
bi
bi
ci
ci
ci
ci
ci
ci

li ri ri r ci
li ri ri r ci
li ri ri r ci
ri
ri
ri
ri
ri
ri

postcond

ci
ci
ci
ri
ri
ri
ri
ri
ri

table generic atoms clause ci proof theorem
suppose c satisfiable suppose q minimum reordering
p r parallel execution length shorter q wlg assume every
action released early possible r according observation
must hold n
r afi r r ati r

r r ati r r afi
hence exactly one atoms pfi pti true time let pi denote atom since

r length follows earlier observation j j r bj k
k k hence lj k pi since q valid r parallel
execution q define interpretation n

pi pfi
pi f
otherwise
however interpretation obviously model c contradicts assumption
follows r must length longer
concludes proof shows c satisfiable iff p reordering
parallel execution length


theorem

minimum parallel deordering cannot approximate minimum
parallel reordering within jajk constant k

proof proof assumes gt plans simple concurrency first define generic

actions aki bki cki according table define recursively generic
plans

ha
b
c
im b im c im
k
k
pi ha ki p k mi cmk
k


k
k
aim pim cim k




ficomputational aspects reordering plans

furthermore arbitrary k n define ppi kn hfpk pkn g fq k qnk gi
prove claim arbitrary k n plan p k n
kn valid
p ni
deordering length less nk ki
reordering length k
proof induction k
base case k choose arbitrary n plan p n obviously kn valid
deordering length n consider reordering q n
p n actions ordering relation defined n
b c n b reordering k n valid
parallel execution r n length defined n r n
r n b r n c plan shown figure claim thus
satisfied base case
induction suppose claim satisfied l k k prove
claim holds l k choose arbitrary n follows induction
hypothesis none subplans p k n pnk n deordered
remain totally ordered furthermore n necessary action
aki n ordered subplan pik n action cki n ordered
clear n order cki n aki n removed without
making plan invalid hence p k n deordering
length
n
x


length pik n n length p k n

n n nk

kx



ni nk

kx



ni

proves deordering case claim
reordering case define reordering qk n p k n actions
ordering relation defined follows subplan pik n p k n reorder
actions length k possible according induction hypothesis
n j n j order aki n akj n
ckj n cki n aki n akj ckj cki n case k hence
action pre condition

post condition

aki fpki g
fpk pkim q ki g
bki
fpki g
fqik g
k g post ck fqk g
cki fq ki qim


table generic actions proof theorem


fibackstro

p n


n









p




p



p n



q

p

q
p
q

n


r n



p n



b



b



b n




q

c



q
q
c xxxq
x xxz r c n




qn


qn
cn





qn










n xxxx
z
x









q n



x
n n
xxx x
z

p n

pn n

x xxxxz
c n



x xxxxz

cn n

figure reordering q n plan p n example induction case
proof theorem solid arrows denote orderings required producerconsumer relationships labelled atom produced consumed
dashed arrows denote ordering constraints avoid threats labelled possibly con icting atom
segment type aki n pik n cki n reordered length k finally
n order aki n ak n n aki n ak n case k
plan qk n k n valid since subplans p k n pnk n atoms
common thus relation hold two actions belonging
different subplans reordered plan executed parallel execution
rik n defined rik n aki n rik n cki n k n
actions qki n rik n rik n since parallel execution
length k reordered plan claim holds k
concludes induction claim holds k since
p ni
nk ki

k

k
k k jaj
k theorem holds



ficomputational aspects reordering plans

references

backstrom c finding least constrained plans optimal parallel executions
harder thought backstrom c sandewall e eds current trends
ai ewsp nd european workshop pp vadstena
sweden ios press
backstrom c executing parallel plans faster adding actions cohn
g ed proceedings th european conference artificial intelligence
ecai pp amsterdam netherlands wiley
backstrom c expressive equivalence formalisms artificial intelligence

backstrom c klein parallel non binary polynomial time
reiter r mylopoulos j eds proceedings th international joint conference artificial intelligence ijcai pp sydney australia morgan
kaufmann
bellare goldreich sudan free bits pcps non approximability
towards tighter proceedings th annual ieee symposium
foundations computer science focs pp milwaukee wi usa
ieee computer society
blum l furst l fast graph analysis artificial
intelligence
chapman conjunctive goals artificial intelligence
crescenzi p panconesi completeness approximation classes information
computation
currie k tate plan open architecture artificial intelligence
feige u kilian j zero knowledge chromatic number th annual
ieee conference computational compelxity ccc philadelphia pa usa
ieee computer society
feige u threshold ln n approximating set cover preliminary version
proceedings th annual acm symposium theory computing stoc
pp philadelphia pa usa acm
fink e yang q formalizing plan justifications proceedings th conference canadian society computational studies intelligence cscsi
pp vancouver bc canada
garey johnson computers intractability guide theory
np completeness freeman york


fibackstro

gazen c knoblock c combining expressivity ucpop eciency
graphplan steel alami pp
ghallab laruelle h representation control ixtet temporal
planner hammond pp
hammond k ed proceedings nd international conference artificial
intelligence systems aips chicago il usa aaai press
jonsson p backstrom c state variable structural restrictions
complexity artificial intelligence
kambhampati multi contributor causal structures formalization
evaluation artificial intelligence
kambhampati kedar unified framework explanation generalization partially ordered partially instantiated plans artificial intelligence

klein jonsson p backstrom c tractable assembly line
ghallab milani eds directions ai ewsp
rd european workshop frontiers ai applications pp
assisi italy ios press
klein jonsson p backstrom c ecient miniature assembly
line artificial intelligence engineering
knoblock c generating parallel execution plans partial order planner
hammond
kohler j nebel b hoffman j dimopoulos extending graphs
adl subset steel alami pp
lund c yannakakis hardness approximating minimization journal acm
nebel b backstrom c computational complexity temporal projection plan validation artificial intelligence
pednault e p formulating multiagent dynamic world classical
framework georgeff lansky l eds reasoning actions plans proceedings workshop pp timberline usa
morgan kaufmann
regnier p fade b complete determination parallel actions temporal
optimization linear plans action hertzberg j ed european workshop
vol lecture notes artificial intelligence pp sankt
augustin germany springer


ficomputational aspects reordering plans

regnier p fade b b determination du parallelisme maximal et optimisation
temporelle dans les plans actions lineaires revue intelligence artificielle

selman b levesque h mitchell method solving hard satisfiability proceedings th us national conference artificial
intelligence aaai pp san jose ca usa american association
artificial intelligence
steel alami r eds th european conference ecp vol
lecture notes artificial intelligence toulouse france springer
stromberg j e styrning av lego bilfabrik andra omarbetade upplagan department electrical engineering linkoping university
tate interacting goals use proceedings th international
joint conference artificial intelligence ijcai pp tbilisi ussr
ijcai william kaufmann
veloso perez carbonell j g nonlinear parallel
resource allocation sycara k p ed workshop innovative approaches
scheduling control pp san diego ca usa morgan
kaufmann
vere time windows durations activities goals ieee
transactions pattern analysis machine intelligence pami
wilkins e practical morgan kaufmann san mateo ca




