Journal Artificial Intelligence Research 9 (1998) 1{36

Submitted 1/98; published 8/98

Computational Complexity Probabilistic Planning
Michael L. Littman

mlittman@cs.duke.edu

Department Computer Science, Duke University
Durham, NC 27708-0129 USA

Judy Goldsmith

goldsmit@cs.engr.uky.edu

Martin Mundhenk

mundhenk@ti.uni-trier.de

Department Computer Science, University Kentucky
Lexington, KY 40506-0046 USA
FB4 - Theoretische Informatik, Universitat Trier
D-54286 Trier, GERMANY

Abstract
examine computational complexity testing finding small plans probabilistic planning domains propositional representations. complexity
plan evaluation existence varies plan type sought; examine totally
ordered plans, acyclic plans, looping plans, partially ordered plans three
natural definitions plan value. show problems interest complete
variety complexity classes: PL, P, NP, co-NP, PP, NPPP, co-NPPP, PSPACE.
process proving certain planning problems complete NPPP, introduce
new basic NPPP-complete problem, E-Majsat, generalizes standard Boolean
satisfiability problem computations involving probabilistic quantities; results suggest
development good heuristics E-Majsat could important creation
ecient algorithms wide variety problems.

1. Introduction
Recent work artificial-intelligence planning addressed problem finding effective plans domains operators probabilistic effects (Drummond & Bresina,
1990; Mansell, 1993; Draper, Hanks, & Weld, 1994; Koenig & Simmons, 1994; Goldman &
Boddy, 1994; Kushmerick, Hanks, & Weld, 1995; Boutilier, Dearden, & Goldszmidt, 1995;
Dearden & Boutilier, 1997; Kaelbling, Littman, & Cassandra, 1998; Boutilier, Dean, &
Hanks, 1998). Here, \effective" \successful" plan one reaches goal state
sucient probability. probabilistic propositional planning , operators specified
Bayes network extended STRIPS-like notation, planner seeks recipe
choosing operators achieve goal configuration user-specified probability.
problem closely related solving Markov decision process (Puterman,
1994) expressed compact representation.
previous work (Goldsmith, Lusena, & Mundhenk, 1996; Littman, 1997a), examined complexity determining whether effective plan exists completely observable
domains; problem EXP-complete general form PSPACE-complete limited polynomial-depth plans. (A polynomial-depth, polynomial-horizon, plan one
takes polynomial number actions terminating.) results,
c 1998 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiLittman, Goldsmith & Mundhenk

plans permitted arbitrarily large objects|there restriction valid plan
need sort compact (polynomial-size) representation.
place restrictions size valid plans, earlier results
directly applicable problem finding valid plans. possible, example,
given planning domain, valid plans require exponential space (and exponential
time) write down. Knowing whether plans exist simply important
intractable express.
present paper, consider complexity practical realistic
problem|that determining whether plan exists given restricted form
given restricted size. plans consider take several possible forms used
previous planning work: totally ordered plans, partially ordered plans, (totally ordered)
conditional plans, (totally order) looping plans. cases, limit attention
plans expressed size bounded polynomial size specification
problem. way, determine plan exists, use information
try write reasonable amount time space.
deterministic planning literature, several authors addressed computational complexity determining whether valid plan exists, determining whether plan
exists given cost, finding valid plans variety assumptions (Chapman, 1987; Bylander, 1994; Erol, Nau, & Subrahmanian, 1995; Backstrom,
1995; Backstrom & Nebel, 1995). results provide lower bounds (hardness results)
analogous probabilistic planning problems since deterministic planning special case.
deterministic planning, optimal plans represented simple sequence operators
(a totally ordered plan). probabilistic planning, good conditional plan often perform better totally ordered (unconditional) plan; therefore, need consider
complexity planning process richer set plan structures.
ease discussion, explicitly describe case planning completely
observable domains. means state world known times
plan execution, spite uncertainty state transitions. know state
system sucient information choosing actions optimally (Puterman, 1994), however,
representing universal plan often impractical propositional domains
size state space exponential size domain representation.
reason, consider types plan structures based simple finite-state machines.
type plans consider necessarily use full state system
make every decision, results carry partially observable domains, although
explore fact detail present work.
computational problems look complete variety complexity classes
ranging PL (probabilistic logspace) PSPACE. Two results deserving special
mention concern problems closely related ones actively addressed
artificial-intelligence researchers; first, problem evaluating totally ordered plan
compactly represented planning domain PP-complete.1 compactly represented
1. class PP closely related somewhat familiar #P; Toda (1991) showed P#P = PPP .
Roughly speaking, means #P PP equally powerful used oracles. counting
class #P already recognized artificial-intelligence community important complexity
class computations involving probabilistic quantities, belief-network inference (Roth, 1996).

2

fiComplexity Probabilistic Planning

planning domain one described two-stage temporal Bayes network (Boutilier
et al., 1998) similar notation.
Second, problem determining whether valid totally ordered plan exists
compactly represented planning domain NPPP -complete. Whereas class NP
thought set problems solvable guessing answer checking polynomial time, class NPPP thought set problems solvable guessing
answer checking using probabilistic polynomial-time (PP) computation. likely
NPPP characterizes many problems interest area uncertainty artificial
intelligence; paper earlier work (Goldsmith et al., 1996; Mundhenk, Goldsmith, &
Allender, 1997a; Mundhenk, Goldsmith, Lusena, & Allender, 1997b) give initial evidence
this.

1.1 Planning-Domain Representations
probabilistic planning domain = hS ; s0 ; A; t; Gi characterized finite set states
, initial state s0 2 , finite set operators actions A, set goal states
G . application action state results probabilistic transition

new state s0 according probability transition function t, t(s; a; s0 )
probability state s0 reached state action taken. objective
choose actions, one another, move initial state s0 one goal states
probability threshold .2 state system known times
(fully observable) used choose action apply.
concerned two main representations planning domains: representations, enumerate states explicitly, propositional representations (sometimes
called compact, structured, factored representations), view states assignments
set Boolean state variables propositions. Propositional representations represent many domains exponentially compactly representations.
representation, transition function represented collection
jSj jSj matrices,3 one action. propositional representation, type
jSj jSj matrix would huge, transition function must expressed another way.
probabilistic planning literature, two popular representations propositional planning domains probabilistic state-space operators (PSOs) (Kushmerick et al., 1995)
two-stage temporal Bayes networks (2TBNs) (Boutilier et al., 1995). Although representations differ type planning domains express naturally (Boutilier et al.,
1998), computationally equivalent; planning domain expressed one representation converted polynomial time equivalent planning domain expressed
polynomial increase representation size (Littman, 1997a).
work, focus propositional representation called sequential-effectstree representation (ST) (Littman, 1997a), syntactic variant 2TBNs
conditional probability tables represented trees (Boutilier et al., 1995, 1998). representation equivalent 2TBNs PSOs simplifies presentation results.
2. possible formulate objective one maximizing expected total discounted reward (Boutilier et al., 1995), two formulations essentially polynomially equivalent (Condon, 1992). diculty compactly represented domains may require discount factors
exponentially close one equivalence hold. discussed Section 5.
3. assume number bits used represent individual probability values isn't large.

3

fiLittman, Goldsmith & Mundhenk

ST, effect action proposition represented separate decision
tree. given action a, set decision trees different propositions ordered,
decision tree one proposition refer new old values previous propositions; allows ST represent probability distribution. leaves
decision tree describe associated proposition changes function state
action, perhaps probabilistically. Section 1.2 gives simple example representation.
propositional representations, states set goal states G
explicitly enumerated ST. Instead, define goal set , set propositions
state goal-set propositions true considered goal state.
set actions explicitly enumerated ST, representation.
ST representation planning domain = hS ; s0 ; A; t; Gi defined
formally = hP; I; A; T; G (we use blackboard-bold font stand ST representation domain). Here, P finite set distinct propositions. set states
power set P; propositions 2 said \true" s. set P
initial state. set G goal set, set goal states G set states
G s.
transition function represented function T, maps action
ordered sequence jPj binary decision trees. decision trees
distinct label proposition, decision propositions nodes (optionally labeled
sux \:new"), probabilities leaves. ith decision tree T(a)i action
defines transition probabilities t(s; a; s0 ) follows. ith decision tree, let pi
label proposition. Define value leaf node found traversing decision
tree T(a)i , taking left branch decision proposition (or s0 decision
proposition \:new" sux) right branch otherwise. Finally, let
i;
pi 2 s0 ,
0
t(s; a; ) =
(1)
1 , ; otherwise.


definition constitutes well-defined probability distribution s0
s.
insure validity representation, allow \p:new" appear
decision proposition T(a)i p label proposition decision tree T(a)j
j < i. reason, order decision trees T(a) significant. put
another way, proposition new value new value defined
decision tree.
complexity results derive ST apply PSOs, 2TBNs, computationally equivalent representations. hold \succinct representation,"
propositional representation popular complexity-theory literature, captures
set transition matrices function, commonly represented Boolean circuit
computes function. ST straightforwardly represented Boolean circuit,
and, proof Theorem 6, show represent particular Boolean circuits
ST. Thus, although shown succinct representation formally equivalent ST, two representations closely related; proofs give ST need
changed slightly work succinct representation (Goldsmith, Littman, &
Mundhenk, 1997a, 1997b; Mundhenk et al., 1997b). results require restrict
succinct representation generate transition probabilities polynomial
4

fiComplexity Probabilistic Planning

number bits; results may different circuit-based representations
represent probabilities exponential number bits (Mundhenk et al., 1997a).

1.2 Example Domain

help make domain-representation ideas concrete, present following
simple probabilistic planning domain based problem building sand castle
beach. total four states domain, described combinations two
Boolean propositions, moat castle (propositions appear boldface). proposition
moat signifies moat dug sand, proposition castle signifies
castle built. initial state, moat castle false,
goal set fcastleg.
two actions: dig-moat erect-castle (actions appear sans serif). Figure 1
illustrates actions ST. Executing dig-moat moat false causes moat
become true probability 1=2; moat already true, dig-moat leaves unchanged.
castle proposition affected. dig-moat action depicted left half
Figure 1.
second action erect-castle, appears right half Figure 1. decision
trees numbered allow sequential dependencies effects expressed.
first decision tree castle, change value already true
erect-castle executed. Otherwise, probability becomes true dependent
whether moat true; castle built probability 1=2 moat true
probability 1=4 not. idea building moat first protects castle
destroyed prematurely ocean waves.
second decision tree proposition moat. erect-castle cannot make
moat become true, effect moat false. hand, moat
exists, may collapse result trying erect castle. label castle:new
diagram refers value castle proposition first decision tree evaluated.
castle already built erect-castle selected, moat remains built
probability 3=4. castle built, erect-castle successfully builds it, moat
remains true. Finally, erect-castle fails make castle true, moat becomes false
probability 1=2 everything destroyed.
Note given ST representation domain, perform number useful
operations eciently. First, given state action a, generate next state s0
proper probabilities. accomplished calculating value propositions
s0 one time order given representation a, ipping coins
probabilities given leaves decision trees. Second, given state s, action a,
state s0 , compute t(s; a; s0 ), probability state s0 reached state
action taken, via Equation 1.

1.3 Plan Types Representations

consider four classes plans probabilistic domains. Totally ordered plans
basic type, finite sequence actions must executed order;
type plan ignores state system. Acyclic plans generalize totally ordered plans
include conditional execution actions. Partially ordered plans different way
5

fiLittman, Goldsmith & Mundhenk

dig-moat
1: moat

2: castle

moat

1T

erect-castle
1: castle

castle
F

1/2


1T

2: moat

castle
F



0T

1T

moat
F



moat

F

castle



F

1/2

1/4

3/4

0T

F



castle: new


F

1T

1/2

Figure 1: Sequential-effects-tree (ST) representation sand-castle domain
generalizing totally ordered plans precise sequence left exible (McAllester
& Rosenblitt, 1991). Looping plans generalize acyclic plans case plan steps
repeated (Smith & Williamson, 1995; Lin & Dean, 1995). type plan
referred plan graph policy graph (Kaelbling et al., 1998).
following sections, prove computational complexity results concerning
plan types. remainder section provides formal definitions plan
types, illustrated Figure 2 examples sand-castle domain.
general form, plan (or policy, controller transducer) program
outputs actions takes input information outcome actions.
work, consider particularly restricted finite-state-controller-based plan representation.
plan P planning domain = hS ; s0 ; A; t; Gi represented structure
(V; v0 ; E; ; ) consisting directed (multi) graph (V; E ) initial node v0 2 V ,
labeling : V ! plan nodes|called plan steps |to domain actions, labeling
edges state sets : E ! P (S ) every v 2 V outgoing edges,

0
v 2V :(v;v )2E (v; v ) = (v; v1 ) \ (v; v2 ) = ; v1 ; v2 2 V , v1 6= v2 . plan
steps outgoing edges all|these terminal steps . Actions terminal
steps executed. Note function represented direct manner
domains, propositional domains, compact representation needed.
assume propositional domains, edge labels given conjunctions literals.
behavior plan P domain follows. initial time step = 0. time
step 0, domain state st plan step vt (s0 defined planning
domain, v0 plan). Action (vt ) executed, resulting transition domain state
st+1 probability t(st ; (vt ); st+1 ). Plan step vt+1 chosen st+1 2 (vt ; vt+1 );
function tells plan \go" next. point, time-step index
incremented process repeats. continues terminal step reached
plan.
One understand behavior domain plan P several different ways.
possible sequences states viewed tree: node tree
depth state reachable initial state time step t. Alternatively, one view
state time step plan P probability distribution . time
0

0

6

fiComplexity Probabilistic Planning

step 0, probability 1 process state s0 . probability state s0
time step + 1, Pr(s0 ; + 1), sum probabilities length + 1 paths
s0 s0, i.e.,

X




s0 ;s1 ;s2 ;:::;st;st+1=s j =1

t(sj ; aj ; sj+1 );

0

aj action selected plan P time j given observed sequence state
transitions s0 ; : : : ; sj . view useful later proofs.
Next, formalize probability domain reaches goal state plan P .
need introduce several notions. \legal" sequence states steps applied
called trajectory , i.e., P sequence = h(si ; vi )iki=0 pairs

t(si; (vi ); si+1 ) > 0 0 k , 1,
si+1 2 (vi ; vi+1 ) 0 k , 1,
v0 ; : : : ; vk,1 terminal steps.
goal trajectory trajectory ends goal state , sk 2 G . Note
goal trajectory finite.Q Thus, calculate probability goal trajectory
,1 t(s ; (v ); ), given 2 G . probability
= h(si ; vi )iki=0 Pr(ff) = ki=0

i+1
k
reaches goal state plan P sum probabilities goal trajectories
M,
X
Pr(M reaches goal state P ) :=
Pr(ff);
goal trajectory

call value plan.
characterize plan P = (V; v0 ; E; ; ) basis size structure
underlying graph (V; E ). graph (V; E ) contains cycles, call acyclic plan ,
otherwise looping plan . follows acyclic plan terminal step,
terminal step reached jV j actions taken; plans
used finite-horizon control. totally ordered plan (sometimes called \linear
plan" \straight line" plan) acyclic plan one outgoing edge
node V . plan simple path.
work, consider partially ordered plans (sometimes called \nonlinear"
plans) express entire family totally ordered plans. representation, steps
plan given partial order (specified, example, directed acyclic graph).
partial order represents set totally ordered plans: totally ordered sequences
plan steps consistent partial order consist steps partially ordered
plan. totally ordered plans value, values need
same. such, choice defining value partially ordered plan.
work, consider optimistic, pessimistic, average interpretations. Let
(P )
set totally ordered sequences consistent partial order plan P . optimistic
interpretation,
value P := max Pr(M reaches goal state p):
p2
(P )

7

fiLittman, Goldsmith & Mundhenk

pessimistic interpretation,
value P := min Pr(M reaches goal state p):
p2
(P )

average interpretation,
X
Pr(M reaches goal state p):
value P := j
(1P )j
p2
(P )
illustrate notions, Figure 2 gives plans type sand-castle domain
described earlier. Initial nodes marked incoming arrow, terminal steps
represented filled circles. 3-step totally ordered plan Figure 2(a) successfully
builds sand castle probability 0:4375. acyclic plan given Figure 2(b),
succeeds probability 0:46875 executes dig-moat average 1:75 times. Note
succeeds often fewer actions average totally ordered plan
Figure 2(a).
Figure 2(c) illustrates partially ordered plan sand-castle domain.
plan bears superficial resemblance acyclic plan Figure 2(b), different
interpretation. particular, plan Figure 2(c) represents set totally ordered plans
five (non-terminal) plan steps (3 dig-moat steps 2 erect-castle steps). contrast
solid arrows Figure 2(b), indicate ow control, dashed arrows
Figure 2(c) represent ordering constraints: erect-castle step must preceded
least two dig-moat steps,for example.
Although 52 = 10 distinct ways arranging five plan steps Figure 2(c) totally ordered plan, two distinct totally ordered plans consistent
ordering constraints:
dig-moat ! dig-moat ! dig-moat ! erect-castle ! erect-castle !

(success probability 0:65625)

dig-moat ! dig-moat ! erect-castle ! dig-moat ! erect-castle !

(success probability 0:671875). Thus, optimistic success probability partially
ordered plan 0:671875, pessimistic 0:65625. Note pessimistic interpretation closely related standard interpretation deterministic partial order planning (McAllester & Rosenblitt, 1991), partially ordered plan considered successful consistent totally ordered plans successful. average success
probability 0:6614583, here, 4 orderings yield poorer plan
described above, 2 yield better one.
looping plan Figure 2(d) terminate succeeds building sand
castle, probability 1:0 eventually. course, looping plans
succeed probability 1; totally ordered plan Figure 2(a) acyclic plan
Figure 2(b) special cases looping plans, instance.
define jP j size plan P number steps contains. define jM j
size domain sum number actions states domain
sum sizes ST decision trees propositional domain.
8

fiComplexity Probabilistic Planning

dig-moat

dig-moat

erect-castle

dig-moat

erect-castle

dig-moat

erect-castle

dig-moat

(a) totally ordered plan.

(c) partially ordered plan.
not(moat)
dig-moat

not(moat)
dig-moat

moat

dig-moat

erect-castle

not(moat)

moat not(castle)

moat

moat
dig-moat

castle
erect-castle

(b) acyclic (conditional) plan.
not(moat) not(castle)
(d) looping plan.

Figure 2: Example plans sand-castle domain
consider following decision problems. plan-evaluation problem asks, given
domain , plan P size jP j jM j, threshold , whether value greater
, i.e., whether
Pr(M reaches goal state P ) > :
Note condition jP j jM j technical one|we simply want use jM j
represent size problem. Given instance jP j larger jM j,
simply imagine \padding out" jM j make larger. important thing
considering plans roughly size description domain,
size number states (which might considerably larger).
plan-existence problem asks, given domain , threshold , size bound z jM j,
whether exists plan P size z value greater . Note
bound size target plan, complexity plan generation
plan existence; technique self-reduction used construct valid plan using
polynomially many calls oracle decision problem.
decision problems different version type domain (
propositional) type plan category (looping, acyclic, totally ordered,
partially ordered three interpretations). address problems
succeeding sections.

1.4 Complexity Classes

definitions complexity classes, reductions, standard results complexity
theory, refer reader Papadimitriou (1994).
Brie y, looking complexity decision problems (those yes/no
answers). class P consists problems decided polynomial time; is,
given instance problem, program deciding whether answer yes
runs polynomial time. class NP contains problems polynomialtime checkable polynomial-size certificates: given instance certificate,
checked time polynomial size instance whether certificate proves
instance NP set. means that, answer instance \yes,"
9

fiLittman, Goldsmith & Mundhenk

shown polynomial time given right key. class co-NP opposite|if
answer \no," shown polynomial time given right key.
problem X C -hard complexity class C every problem C reduced
it; put another way, fast algorithm X used subroutine solve
problem C quickly. problem C -complete C -hard C ;
hardest problems class.
interest complete, next give detailed descriptions less
familiar probabilistic counting complexity classes use work.
class #L (A lvarez & Jenner, 1993) class functions f that,
nondeterministic logarithmically space-bounded machine N , number accepting paths
N x equals f (x). class #P defined analogously class functions f
that, nondeterministic polynomial-time -bounded machine N , number
accepting paths N x equals f (x). Typical complete problems computing
determinant #L computing permanent #P.
function f defined GapL difference f = g , h #L functions g
h. #L functions nonnegative integer values definition, GapL functions
may negative integer values (for example, g always returns zero).
Probabilistic logspace (Gill, 1977), PL, class sets exists
nondeterministic logarithmically space-bounded machine N x 2
number accepting paths N x greater number rejecting paths.
original definition PL, time bound computations; Borodin, Cook,
Pippenger (1983) later showed PL P. Jung (1985) proved set computable
probabilistic logspace computable probabilistic logspace PL machine
simultaneous polynomial-time bound. apparent contrast P-complete sets, sets PL
decidable using fast parallel computations (Borodin et al., 1983).
Probabilistic polynomial time, PP, defined analogously. classic PP-complete problem Majsat: given Boolean formula conjunctive normal form (CNF),
majority assignments satisfy it? According Balcazar, Daz, Gabarro (1990),
PP-completeness Majsat shown combination results Gill (1977)
Simon (1975).
polynomial-space-bounded computations, PSPACE equals probabilistic PSPACE,
#PSPACE class polynomial-space-computable functions (Ladner,
1989).
Note L, NL, #L, PL GapL logarithmic space P, NP, #P, PP,
GapP polynomial time. Also, notion completeness use paper relies
many-one reductions. case PL, reduction functions logarithmic space;
case NP above, polynomial time.
complexity classes C C 0 class C C consists sets C -Turing
reducible sets C 0 , i.e., sets accepted resource bounds specified C ,
using problem C 0 subroutine (oracle) instantaneous output. class
C PSPACE, case NPC PSPACE, therefore NPPSPACE = PSPACE.
primary oracle-defined class consider NPPP . equals \NP
" closure
PP (Toran, 1991), seen closure PP polynomial-time disjunctive reducibility exponential number queries (each queries computable
polynomial time index list queries). simplify completeness results
0

10

fiComplexity Probabilistic Planning

class, introduce decision problem call E-Majsat (\exists" Majsat),
generalizes standard NP-complete satisfiability problem PP-complete Majsat.
E-Majsat instance defined CNF Boolean formula n Boolean variables
x1 ; : : : ; xn number k 1 n. task decide whether
initial partial assignment variables x1 ; : : : ; xk majority assignments
extend partial assignment satisfies . prove problem NPPP -complete
Appendix.
complexity classes consider satisfy following containment properties
relations well-known classes:
NP PP NPPP PSPACE EXP:
L NL PL P co-NP
co-NPPP
P properly contained EXP, EXP-complete problems provably intractable;
classes may equal P, although generally believed case.
Several observations worth making here. known PH NPPP ,
PH represents polynomial hierarchy. crude sense, PH close PSPACE,
and, thus, NPPP {completeness results place important problems close PSPACE.
However, early empirical results (Littman, 1997b) show random problem instances PP similar properties random problem instances NP, suggesting
PP might close enough NP NP-type heuristics effective.

1.5 Results Summary

Tables 1 2 summarize results, explained detail later sections.
general avor main results techniques conveyed follows.
show plan-evaluation problem particular complexity class C , take
cross product steps plan states domain look
complexity evaluating absorption probability resulting Markov chain (i.e.,
directed graph probability-labeled edges). complexity corresponding planexistence problem bounded NPC , problem solved guessing
correct plan non-deterministically evaluating it; many cases, NPC complete. appropriate complexity class C depends primarily representation
cross-product Markov chain.
Exceptions basic pattern results partially ordered plans Section 4.
appear require distinct set techniques.
worth noting that, although propositional domains exponentially
compact domains, computational complexity solving problems propositional domains always exponentially greater; one instance, evaluating partially
ordered plans average interpretation, complexity actually
propositional domains!
prove results concerning plan evaluation existence compactly represented
plans (PP-complete NPPP -complete, Corollary 5), plan existence \large enough"
looping plans domains (P-complete, Theorem 7), plan evaluation existence
looping plans deterministic propositional domains (PSPACE-complete, Theorems 8
9), plan existence polynomial-size looping plans partially observable domains
(NP-complete, Section 5.1).
11

fiLittman, Goldsmith & Mundhenk

Plan Type
Plan Evaluation Plan Existence
unrestricted
|
P-complete
polynomial-depth
|
P-complete
looping
PL-complete
NP-complete
acyclic
PL-complete
NP-complete
totally ordered
PL-complete
NP-complete
partially ordered, optimistic
NP-complete
NP-complete
partially ordered, average
PP-complete
NP-complete
partially ordered, pessimistic co-NP-complete
NP-complete

Reference
P & (1987)
P & (1987)
Section 3
Section 2
Section 2
Section 4
Section 4
Section 4

Table 1: Complexity results representations (P & (1987) Papadimitriou
Tsitsiklis (1987))

Plan Type
Plan Evaluation Plan Existence Reference
unrestricted
|
EXP-complete Littman (1997a)
polynomial-depth
|
PSPACE-complete Littman (1997a)
looping
PSPACE-complete PSPACE-complete Section 3
acyclic
PP-complete
NPPP -complete Section 2
totally ordered
PP-complete
NPPP -complete Section 2
PP
partially ordered, optimistic
NP -complete
NPPP -complete Section 4
partially ordered, average
PP-complete
NPPP -complete Section 4
PP
partially ordered, pessimistic co-NP -complete NPPP -complete Section 4
Table 2: Complexity results propositional representations

12

fiComplexity Probabilistic Planning

2. Acyclic Plans

section, treat complexity generating evaluating acyclic totally
ordered plans.

Theorem 1 plan-evaluation problem acyclic totally ordered plans domains PL-complete.

Proof: First, show PL-hardness totally ordered plans. Jung (1985) proved
set PL exists logarithmically space-bounded polynomially
time-bounded nondeterministic Turing machine N following property: every
input x, machine N must least half computations input x accepting
x A. machine N transformed probabilistic Turing
machine R input x, probability R(x) accepts x equals
fraction computations N (x) accepted. Given R, planning domain
described follows. state set set configurations R input x. Note
configuration consists contents logarithmically space-bounded tape,
state, location read/write heads, one symbol input output
tapes. Thus, configuration represented logarithmically many bits,
polynomially many configurations. state-transition probabilities
unique action configuration transition probabilities R. states
obtained accepting configurations goal states. totally ordered plan consists
\step counter" R input x, plan steps takes action a.
probability planning domain plan reaches goal state exactly
probability R(x) reaches accepting configuration. Thus, evaluating totally
ordered plan PL-hard.
Since totally ordered plans acyclic plans, proves PL-hardness planevaluation problem acyclic plans.
Next, show plan-evaluation problem PL acyclic plans. Let =
hS ; s0 ; A; t; Gi planning domain, let P = hV; v0 ; E; ; acyclic plan, let
threshold given. show question, whether probability P
reaches goal state probability greater , equivalently transformed
question whether GapL function greater 0. transformation done
logarithmic space. shown Allender Ogihara (1996), follows question
PL.
first, construct Markov chain C P , simulates execution
\evaluation" P . Note Markov chain seen probabilistic
domain one action set actions. Since choice actions,
mention construction. state space C V , initial state
(s0 ; v0 ), set goal states G V , transition probabilities tC C
8
t(s; (v); s0 ); s0 2 (v; v0 );
<
tC ((s; v); (s0 ; v0 )) = : 1;
v terminal step node, (s; v) = (s0 ; v0 );
0;
otherwise.
Let number plan steps P (i.e., jV j, number nodes graph
representing P ). Since states C contain terminal step P sinks C , follows
13

fiLittman, Goldsmith & Mundhenk


Pr(M reaches goal state P ) = Pr(C reaches goal state exactly steps):
Let
pC (s; m) := Pr(C reaches goal state exactly steps initial state s):
Then, pC ((s0 ; v0 ); m) probability want calculate. standard inductive definition pC used evaluate plans dynamic programming

goal state C ,
pC (s; 0) = 10;; ifotherwise,
X
pC (s; k + 1) =
tC (s; s0) pC (s0 ; k); 0 k , 1:
2SV
0

Let h maximum length representation state-transition probability tC .
Then,

goal state C ,
ph (s; 0) = 10;; otherwise,
X h
ph(s; k + 1) =
2 tC (s; s0 ) ph (s0 ; k); 0 k , 1;
2SV
0

follows pC ((s0 ; v0 ); m) = ph((s0 ; v0 ); m) 2,hm . Note ph((s0 ; v0 ); m) integer
value. Therefore, pC ((s0 ; v0 ); m) > ph ((s0 ; v0 ); m) , b2hm c > 0. order
show pC ((s0 ; v0 ); m) > decidable PL, suces show ph((s0 ; v0 ); m)
GapL. Therefore, \unwind" inductive definition ph. Let integer
matrix obtained tC T(s;s ) = tC (s; s0 ) 2h . introduce integer-valued
show ph composed GapL functions using compositions GapL
closed; tC integer valued, cannot used show this. write
0

ph(s; m) =

X

2SV

(T )(s;s ) ph(s0 ; 0):
0

0

argue ph GapL. entry T(s;s ) logspace computable domain plan P . Therefore, powers matrix GapL, shown
Vinay (1991). GapL closed multiplication summation polynomially
many summands, follows ph 2 GapL. Finally, use closure properties GapL
Allender Ogihara (1996); since GapL closed subtraction, follows
plan-evaluation acyclic plans PL.
totally ordered plans acyclic plans, plan-evaluation problem totally
ordered plans PL.
0

technique forming Markov chain taking cross product domain
plan useful later. Plan-existence problems require different set techniques.

Theorem 2 plan-existence problem acyclic totally ordered plans domains NP-complete.

14

fiComplexity Probabilistic Planning

Proof: First, show containment NP. Given planning domain , threshold ,
size bound z jM j, guess plan correct form size z accept

reaches goal state probability greater plan. Note
checking whether plan correct form done polynomial time.
plan-evaluation problem PL (Theorem 1), follows plan-existence problem
NP (i.e., NPPL = NP).
show NP-hardness plan-existence problem, give reduction
NP-complete satisfiability problem Boolean formulae conjunctive normal form.
construct planning domain evaluates Boolean formula n variables,
(n + 2)-step plan describes assignment values variables. first step,
clause chosen randomly. step + 1, planning domain \checks" whether plan
satisfies appearance variable clause. so, clause marked satisfied.
n + 1 steps, literal satisfied clause, goal state reached
clause, otherwise, transition made goal state. Therefore, goal
state reached probability 1 (greater 1 , 1=m) clauses
satisfied|the plan describes satisfying assignment.
formally define reduction, similar one presented Papadimitriou
Tsitsiklis (1987). Let CNF formula n variables x1 ; : : : ; xn clauses
C1 ; : : : ; Cm . Let sign appearance variable clause ,1 variable
negated, 1 otherwise. Define planning domain () = hS ; s0 ; A; t; Gi



G

= fsat(i; j ); unsat(i; j ) j 1 n + 1; 1 j mg [ fs0 ; sacc ; srejg;
= fassign(i; b) j 1 n; b 2 f,1; 1gg [ fstart; endg;
= fsacc g;
8 1
0
>
; = s0 ; = start; s0 = unsat(1; j ); 1 j m;
>
>
>
1; = s0 ; 6= start; = srej;
>
>
>
>
>
1; = unsat(i; j ); = assign(i; b); s0 = sat(i + 1; j ); n;
>
>
>
>
xi appears Cj sign b;
>
>
>
>
1
;


= unsat(i; j ); = assign(i; b); s0 = unsat(i + 1; j ); n;
>
>
>
>
xi appear Cj sign b;
>
>
>
>
1
;


= unsat(i; j ); = assign(i0 ; b) = start = end;
>
>
<
0
srej; i0 6= n; b 2 f,1; 1g;
t(s; a; s0) = > 1; ss =
= unsat(n + 1; j ); s0 = srej;
>
>
>
>
1; = sat(i; j ); = assign(i; b); s0 = sat(i + 1; j ); n;
>
>
>
>
1; = sat(i; j ); = assign(i0 ; b) = start = end;
>
>
>
>
s0 = srej; i0 6= n;
>
>
>
>
1; = sat(n + 1; j ); = end; s0 = sacc ;
>
>
>
>
1; = sat(n + 1; j ); 6= end; s0 = srej;
>
>
>
>
= s0 = srej = s0 = sacc ;
>
>
: 10;; ifotherwise.
meaning states domain follows. domain state
sat(i; j ) 1 n, 1 j m, means formula satisfied,
currently checking variable clause j . State sat(n + 1; j ) 1 j means
we've finished verifying clause j satisfied. meanings similar
15

fiLittman, Goldsmith & Mundhenk

s0

start

1=2

unsat(1; 1)

assign(1; 1)

assign(1;

sat(2; 1)

assign(2; x)

1=2

,1)

start

assign(1;

,1)

sat(3; 1)

assign(2; 1)

sat(3; 2)

assign(3; x)

sat(4; 1)

unsat(4; 1)

end

end

sacc

unsat(2; 2)

assign(2; x)

unsat(3; 1)

assign(3; x)

assign(1; 1)

sat(2; 2)

unsat(2; 1)

assign(2;

unsat(1; 2)

,1)

unsat(3; 2)

assign(3; 1)
sat(4; 2)

end

assign(3;

,1)

unsat(4; 2)

end

srej

Figure 3: domain generated Boolean formula (x1 _ :x2 ) ^ (:x1 _ x3 )
\unsat" states. course, s0 initial state sacc srej accepting
rejecting states, respectively.
actions domain start end, mark beginning end
assignment, assign(i; b) 1 n, b 2 f,1; 1g, assign truth value b
variable i. Figure 3 gives domain generated reduction simple Boolean
formula. description reduction, () computed time
polynomial jj.
construction, () z = (n + 2)-step plan P reach goal state sacc
P form
start ! assign(1; b1 ) ! assign(2; b2 ) ! ! assign(n; bn ) ! end ! :
P reaches sacc probability 1 b1 ; : : : ; bn satisfying assignment
n variables . shows Boolean satisfiability polynomial-time reduces
plan-existence problem totally ordered acyclic plans, showing NP-hard.
Note bound plan depth (horizon) instead plan size, planexistence problem acyclic plans domains P-complete (Goldsmith et al., 1997a;
Papadimitriou & Tsitsiklis, 1987). Limiting plan size makes problem dicult
possible force planner take action different states;
figuring without sacrificing plan quality challenging.
propositional domains, plan evaluation harder large number states.

Theorem 3 plan-evaluation problem acyclic totally ordered plans propositional domains PP-complete.

Proof: show PP-hardness totally ordered plans, give reduction

PP-complete problem Majsat: given CNF Boolean formula , majority
assignments satisfy it?
16

fiComplexity Probabilistic Planning

evaluate
1: xi
1/2

2: xi



1/2



n+1: clause1
xa1:new


F

xb1:new

1T


1




0




1



1T

xbm:new

clause1:new





xcm:new


1T

0

F

F

1T

1T

n+m+2: done

done


F



F

n+m+1: satisfied

xam:new

...

xc1:new

xd1:new

1/2

n+m: clausem

F



n: xi

...



F
0

F

clause2:new
...



0T

F
0



clausem:new

F



1T

1

F


0T

Figure 4: Sequential-effects-tree representation evaluate
Given , construct planning domain () 1-step plan plan
achieves goal probability greater = 1=2 majority
assignments satisfies . planning domain () consists single action evaluate,
1-step plan evaluated. n + + 2 propositions ();
x1 xn, correspond n variables ; clause1 clausem ,
correspond clauses ; satisfied, sole element goal set;
done, insures evaluate executed (this important
domain used later Theorem 4 show complexity plan existence). initial
state, propositions false.
evaluate action generates random assignment variables , evaluates
clauses (clausei true literals ith clause true), evaluates entire
formula (satisfied true clauses true). Figure 4 gives ST representation
evaluate, xa ; xb ; : : : represent variables clause i.
construction, Majsat () reaches goal state probability
greater = 1=2 plan consisting single action evaluate.
next show membership PP acyclic plans. showing
planning domain acyclic plan P induce computation tree consisting
paths P . Evaluating computation tree accomplished PP
machine.
Let b bound number bits used specify probabilities leaves
decision trees representing .4 Consider computation tree defined follows. root
labeled hs0 ; v0 i. If, planning domain , probability reaching state s0




4. represent numbers polynomial-precision binary representation. principle, could introduce
round-off errors planning problems specified form.

17

fiLittman, Goldsmith & Mundhenk

given action (v) equal , hs; (v)i 2b children labeled hs0 ; (v; s0 )i.
identically labeled child nodes independent defined identically
others. Thus, number paths given set labels corresponds probability
trajectory domain plan multiplied (2b )h , h depth
plan.
number accepting computations is, therefore, (2b )h
probability achieving goal . Note b inherent planning
domain, rather h. PP machine accepts half final states
accepting, 6= 1=2, necessary pad computation tree introducing
\dummy" branches accept reject right proportions.
plan-existence problem essentially equivalent guessing evaluating valid
plan.

Theorem 4 plan-existence problem acyclic totally ordered plans propositional domains NPPP -complete.

Proof: Containment NPPP totally ordered acyclic plans follows

fact polynomial-size plan guessed polynomial time checked PP
(Theorem 3).
Hardness NPPP totally ordered acyclic plans shown using
reduction E-Majsat, shown NPPP -hard Appendix. reduction echoes
one used PP-hardness argument proof Theorem 3.
Given CNF Boolean formula variables x1 ; : : : ; xn , number k, construct
planning domain (; k) plan exists reach goal probability
greater = 1=2 assignment variables x1 ; : : : ; xk
majority assignments remaining variables satisfies . planning domain
(; k ) consists action evaluate Theorem 3 one action, set-xi ,
first k variables. proof Theorem 3, n + + 2 propositions
(; k ), initially false: x1 xn , correspond n variables ; clause1
clausem , correspond clauses ; satisfied; done,
insures evaluate executed once. goal set contains satisfied done.
1 k, action set-xi makes proposition xi true. Analogously Theorem 3,
evaluate action generates random assignment remaining variables , evaluates
clauses (clausei true literals clause true), evaluates
entire formula (satisfied true clauses true), sets done true. done
true, action make satisfied true.
pair ; k E-Majsat, exists assignment b1 : : : bk first k
variables majority assignments rest variables satisfies .
Therefore, plan applying steps set-xi bi = 1 followed evaluate action
reaches goal state probability greater = 1=2.
Conversely, assume (; k) totally ordered plan P reaches goal state
probability greater 1=2. Since evaluate action action setting done
true, since action reaches goal done set true, assume without
loss generality P consists sequence steps set-xi ends evaluate.
construction, assignment x1 ; : : : ; xk assigning 1 exactly variables set P
18

fiComplexity Probabilistic Planning

assignment majority assignments rest variables
satisfies , therefore ; k E-Majsat.
Since every totally ordered plan acyclic, hardness holds acyclic plans.
results, consider compactly represented (propositional)
planning domains plans. Compactly represented plans quite useful.
compact acyclic plan acyclic plan names plan steps
encoded set propositional variables step-transition function
plan steps represented set decision trees, ST.
require plan depth polynomial size representation,
even though total number steps plan might exponential due
logarithmic succinctness encodings.
plan-domain cross-product technique used proof Theorem 3 generalizes compact acyclic plans, complexity results apply. holds true
probabilistic acyclic plan , acyclic plan make random transitions
plan steps (i.e., step-transition function stochastic). insights
combined yield following corollary Theorems 3 4.

Corollary 5 plan-evaluation problem compact probabilistic acyclic plans propositional domains PP-complete plan-existence problem compact probabilistic
acyclic plans propositional domains NPPP -complete.

mention probabilistic plans two reasons. First, behavior planning structures (such partially ordered plan evaluation average interpretation,
discussed Section 4) thought generating probabilistic plans. Second,
many instances simple probabilistic plans perform nearly well much larger
complicated deterministic plans; notion often exploited field randomized algorithms. Work Platzman (1981) (described Lovejoy, 1991) shows
idea randomized plans come handy planning partially observable domains.

3. Looping Plans

Looping plans applied infinite-horizon control. complexity plan existence
plan evaluation domains (Theorems 1 2) depend presence
absence loops plan.

Theorem 6 plan-evaluation problem looping plans domains PL-complete.
Proof: Given domain looping plan P , construct product Markov

chain C proof Theorem 1. proof Theorem 6 Allender
Ogihara (1996), chain constructed exactly one accepting
exactly one rejecting state; states absorbing. probability
reaches goal state P equals probability C reaches accepting state
started initial state, product initial states P .
19

fiLittman, Goldsmith & Mundhenk

proof Theorem 6 Allender Ogihara (1996), shown construction
Markov chain computation whether reaches final state probability
greater performed PL.
PL-hardness implied Theorem 1, since acyclic plans special case looping
plans.

Theorem 7 plan-existence problem looping plans domains NP-complete

general, P-complete size desired plan least size state
action space (i.e., z min(jSj; jAj)).

Proof sketch: NP-completeness follows proof Theorem 2; containment

hardness still hold plans permitted looping.
However, true forced specify plan whose size small
respect size domain. looping plan allowed number states
least large number states actions domain, problem
solved polynomial time.
known Markov decision processes maximum probability
reaching goal state equals maximum probability reaching goal state
infinite-horizon stationary policy , stationary policy mapping states
actions used repeatedly choose actions time step. known
optimal stationary policy computed polynomial time via linear programming (Condon, 1992). stationary policy domain = hS ; s0 ; A; G ; ti
written looping plan, although, course, looping plans correspond stationary
policies.
show fixed stationary policy p : ! A, two simple ways
looping plan P = (V; v0 ; E; ; ) represented. First, let V = A, v0 = p(s0 ), (v) = v,
(v; v0 ) = fs 2 j p(s) = v0 g. follows whenever reaches state s,
action applied according looping plan according P .
Second, let V = , v0 = s0 , (v) = p(v), (v; v0 ) = fv0 g. follows whenever
reaches state s, plan node corresponding state and, therefore,
appropriate action state applied looping plan. Therefore,
maximum probability reaching goal state obtained either looping
plans.
Since best stationary policy computed polynomial time, best looping
plan computed polynomial time, too. P-hardness follows theorem
Papadimitriou Tsitsiklis (1987).
propositional domains, complexity plan existence plan evaluation looping
plans quite different acyclic case. Looping plan evaluation hard.

Theorem 8 plan-evaluation problem looping plans deterministic stochastic propositional domains PSPACE-complete.

Proof: Recall plan-evaluation problem domains PL (Theorem 1).

planning domain cn states representation size n, looping plan
20

fiComplexity Probabilistic Planning

evaluated probabilistic space O(log(cn )) (Theorem 6), say probabilistic
space polynomial size input. follows ST representation
domain used compute entries transition function polynomial space.
Since probabilistic PSPACE equals PSPACE, shows plan-evaluation problem
looping plans stochastic propositional domains PSPACE.
remains show PSPACE-hardness deterministic propositional domains. Let N
deterministic polynomial-space-bounded Turing machine. moment-to-moment
computation state (configuration) N expressed polynomial-length bit string
encodes contents Turing machine's tape, location read/write head,
state N 's finite-state controller, whether machine accepting
state.
input x, describe construct polynomial time deterministic planning domain (x) single-action looping plan reaches goal state (x)
x accepted Turing machine N .
Given description N x, one can, time polynomial size descriptions
N x, produce description Turing machine computes transition
function N . words, input c, configuration N , outputs next
configuration N . (In fact, even check whether c valid configuration
computation N (x) simulating computation.) argument similar
used Cook's theorem, modeled polynomial-size circuit. circuit takes
input bit string describing current configuration N outputs next
configuration.
Next, argue computation circuit expressed action compute ST representation. one proposition (x) bit configuration,
plus one gate circuit. three standard gates, \and," \or," \not"
easily represented decision trees. ordering decision trees compute according topological sort gates circuit, single compute action compute
precisely output circuit. Figure 5 illustrates conversion simple
circuit, gives form \not" (i1 ), \and" (i2 ), \or" (i3 ) gates.
describe complete reduction. planning domain (x) consists
single action compute set propositions described previous paragraph.
initial state initial configuration Turing machine N , goal set
proposition corresponding whether configuration accepting state N .
transitions deterministic one action chosen, follows
goal state reached probability 1 (greater 1=2, example)
plan repeatedly chooses compute accepting state reached
polynomial-space machine N input x accepts.
similar argument shows looping plan existence actually harder
looping plan evaluation.

Theorem 9 plan-existence problem looping plans deterministic stochastic propositional domains PSPACE-complete.
21

fiLittman, Goldsmith & Mundhenk

compute
1: i1

2: i2

c2
c1

c2


i1


i3


c3





i2

c2

F

c3

1T

1T

0T



F

c2

1T

F



0T

F

1T

0T



4: c1
c1






c1

i1:new
F

0T

3: i3

5: c2
i2:new

c1

c3


F

i2:new

1T

6: c3

0T


0T

F
1T

i3:new


F

i2:new

1T



F
0T

1T

F
0T

Figure 5: circuit representation sequential-effects tree

Proof: Hardness PSPACE follows construction proof

Theorem 8: either one-step looping plan successful, not. plan yields
better result.
Recall interested determining whether plan size z ,
z bounded size domain, reaches goal given probability.
problem PSPACE plan guessed polynomial time checked
PSPACE (Theorem 8). NPPSPACE = PSPACE, result follows.
mentioned earlier, unrestricted infinite-horizon plan-existence problem
EXP-complete (Littman, 1997a); shows problem determining unrestricted plan
existence EXP-hard domains require plans larger polynomialsize looping plans.
Theorem 9 shows PSPACE-completeness determining plan existence deterministic domains, closely related PSPACE-completeness result Bylander (1994). main difference two results theorem applies
compact plans (polynomial instead exponential) complex operator descriptions (conditional effects instead preconditions add delete lists)
include loops. Also, proofs show, PSPACE-hardness retained even planning domains one action, looping makes looping plans hard
work with.

4. Partially Ordered Plans
Partially ordered plans popular representation allow planning algorithms
defer precise commitment ordering plan steps becomes necessary
22

fiComplexity Probabilistic Planning

planning process. k-step partially ordered plan corresponds set k-step totally
ordered plans|all consistent given partial order. evaluation
partially ordered plan defined evaluation best, worst, average
member set consistent totally ordered plans; optimistic, pessimistic,
average interpretations, respectively.
plan-evaluation problem partially ordered plans different totally
ordered plans. single partial order encode totally ordered plans.
Hence, evaluating partially ordered plan involves figuring best (in case optimistic
interpretation) worst (for pessimistic interpretation) member, average (for
average interpretation) combinatorial set.

Theorem 10 plan-evaluation problem partially ordered plans domains
NP-complete optimistic interpretation.
Proof sketch: Membership NP follows fact guess totally

ordered plan consistent given partial order accept domain
reaches goal state probability . Remember evaluation
performed PL (Theorem 1), therefore deterministically polynomial time.
hardness proof variation construction used Theorem 2. partiallyordered plan evaluate form given Figure 6; consistent total orders
form
start ! assign(1; b1 ) ! assign(1; ,b1 ) ! assign(2; b2 ) ! assign(2; ,b2 ) !

! assign(n; bn) ! assign(n; ,bn) ! end ! ;
bi either 1 ,1. possible plans interpreted assignment

n Boolean variables ignoring every second assignment action. construction
Theorem 2 shows turn CNF formula planning domain (),
easily modified ignore every second action. Thus, best totally ordered plan
consistent given partially ordered plan reaches goal probability 1
reaches goal probability greater 1 , 2,m satisfies
clauses satisfiable.

Theorem 11 plan-evaluation problem partially ordered plans domains
co-NP-complete pessimistic interpretation.

Proof sketch: proof membership co-NP proof hardness

similar proof Theorem 10. show reduction co-NP-complete set
unsatisfiable formulae CNF. plan evaluate form given Figure 6
interpreted above. proof Theorem 2, construct planning domain
0(), take G = fsrejg goal states, state srej reached probability
greater 0 assignment satisfy one clauses formula .
formula unsatisfiable every assignment least one clauses
satisfied. Therefore, probability 0 () reaches goal state given
totally ordered plan greater 0 plan corresponds unsatisfying
Sat

23

fiLittman, Goldsmith & Mundhenk

start

assign(1,1)

assign(1,-1)

assign(2,1)

assign(2,-1)

assign(3,1)

assign(3,-1)

...
assign(n,1)

assign(n,-1)

end

Figure 6: partially ordered plan hard evaluate
assignment. Finally, minimum probability consistent partially ordered
plans greater 0 unsatisfiable.

Theorem 12 plan-evaluation problem partially ordered plans domains

PP-complete average interpretation.
Proof: average interpretation, must decide whether average evaluation
consistent totally ordered plans greater threshold . decided
PP guessing uniformly totally ordered plan checking consistency given
partially ordered plan polynomial time. guessed totally ordered plan consistent,
evaluated polynomial time (Theorem 1) accepted rejected appropriate.
guessed plan inconsistent, computation accepts probability rejects
probability 1 , , leaving average consistent orderings unchanged
respect threshold .
PP-hardness shown reduction PP-complete Majsat. Let
formula CNF. show construct domain () partially ordered plan
P () 2 Majsat average performance () totally
ordered plan consistent P () greater 1=2.
Let consist clauses C1 ; : : : ; Cm , contain n variables x1 ; : : : ; xn . Domain
() = hS ; s0 ; A; t; Gi actions
= fassign(i; b) j 2 f1; : : : ; ng; b 2 f,1; 1gg [ fstart; check; endg:
Action assign(i; b) interpreted \assign sign b xi ." partially ordered plan
P () plan steps
V = f(i; b; h) j 2 f1; : : : ; ng; b 2 f,1; 1g; h 2 f1; : : : ; mgg [ fstart; check; endg
mapping : V !
() = 2 fstart; check; endg, ((i; b; h)) = assign(i; b):
24

fiComplexity Probabilistic Planning

order E requires consistent plan start first end last step.
steps arbitrarily ordered. formally,
E = f(start; q) j q 2 V , fstart; endgg [ f(q; end) j q 2 V , fstart; endgg:
Now, define domain () acts given totally ordered plan P consistent
P (). Domain () consists cross product following polynomial-size
deterministic domains Ms , final probabilistic transition added.
describe Ms precisely, intuitive definitions. domain
Ms satisfied plans form assignment n Boolean variables
restriction assignment repeated times (for easy checking). domain
satisfied plans correspond satisfying assignments. composite
two domains satisfied plans correspond satisfying assignments.
define domains formally.
First, Ms checks whether totally ordered plan matches regular expression
start (assign(1; 0)m jassign(1; 1)m )
(assign(n; 0)m jassign(n; 1)m )
check ((assign(1; 0)jassign(1; 1)) (assign(n; 0)jassign(n; 1)))m :
Note constant. Let \good" state reached Ms plan
matches expression. Otherwise, state reached \bad". clarify, actions check simply \use up" extra steps used specifying assignment
partially ordered plan.
Next, checks whether sequence actions following check action satisfies
clauses following sense. Let a1 ak sequence. interprets
subsequence a1+(j ,1)n an+(j ,1)n al+(j ,1)m = assign(x; bl ) assignment b1 ; : : : ; bn
variables x1 ; : : : ; xn , checks whether assignment satisfies clause Cj .
single clauses satisfied way, reaches state \satisfied".
Note Ms defined deal final end action.
() consists product domain Ms transitions action end
follows. state (bad; q) state q , action end lets go
probabilistically state \accept" state \reject", probability 1=2 each;
state (good; satisfied), action end goes state \accept" (with probability
1); otherwise, action end goes state reject (with probability 1). set goal
states consists state \accept".
analyze behavior () plan P consistent P (). Ms
P reaches state \bad", () P reaches goal state probability 1=2. Now,
consider plan P Ms reaches state \good"|called good plan.
P matches regular expression. Therefore, every 2 f1; : : : ; mg exists
bi 2 f,1; 1g steps s(i; bi ; h) start check. Thus, steps
check end
s(1; 1 , i1 ; 1) s(n; 1 , ; 1)s(1; 1 , i1 ; 2) s(n; 1 , in; m)
Consequently, sequence actions defined labeling plan steps
(assign(1; i1 )assign(2; i2 ) assign(n; ))m :
25

fiLittman, Goldsmith & Mundhenk

means, checks whether clauses satisfied assignment i1 ,
i.e., checks whether i1 satisfies . Therefore, () accepts plan P
probability 1, plan represents satisfying assignment, probability 0 otherwise.
Note assignment corresponds exactly one good plan. Therefore, average
good plans () accepts equals fraction satisfying assignments .
Since () accepts \bad" plans probability 1=2, yields average
plans consistent P () acceptance probabilities () greater
1=2 2 Majsat.
complexity plan-existence problem partially ordered plans identical
totally ordered plans.

Theorem 13 plan-existence problem partially ordered plans domains NPcomplete pessimistic, optimistic average interpretations. plan-existence
problem partially ordered plans propositional domains NPPP -complete
pessimistic, optimistic average interpretations.

Proof: First, note totally ordered plan special type partially ordered plan

evaluation unchanged pessimistic, optimistic, average interpretation.
particular, one ordering consistent given totally ordered
plan, best, worst, average orderings same. Therefore, exists
totally ordered plan value greater , partially ordered plan
value greater (the plan), three interpretations.
Conversely, partially ordered plan value greater
three interpretations, totally ordered plan value greater .
value best, worst, average ordering partially ordered
plan always lower bound value best consistent totally ordered plan.
Given strong equivalence, complexity plan existence partially ordered
plans direct corollary Theorems 2 4.
pattern partially ordered plan evaluation domains average
interpretation easier decide either optimistic pessimistic interpretations.
propositional domains, pattern opposite: average interpretation harder
decide either optimistic pessimistic interpretations.

Theorem 14 plan-evaluation problem partially ordered plans propositional do-

mains NPPP -complete optimistic interpretation, co-NPPP -complete
pessimistic interpretation, PP-complete average interpretation.

Proof sketch: optimistic interpretation, membership NPPP follows

fact guess single suciently good consistent total order evaluate
PP (Theorem 3). Hardness NPPP shown using straightforward reduction
E-Majsat (as proof Theorem 4).
pessimistic interpretation, membership co-NPPP follows fact
guess worst consistent total order evaluate PP (Theorem 3). Hardness
26

fiComplexity Probabilistic Planning

co-NPPP shown reducing co-NPPP version E-Majsat (E-Majsat);
proof simple adaptation techniques used, example, Theorem 4 above.
average interpretation, problem shown PP combining
argument proof Theorem 12 showing average consistent totally
ordered plans argument proof Theorem 3 showing evaluate
plan propositional domain PP. Alternatively, could express evaluation
partially ordered plan average interpretation compact probabilistic acyclic
plan; Corollary 5 states plans evaluated PP. PP-hardness follows directly
Theorem 3, totally ordered plans special case partially ordered plans
evaluating totally ordered plans PP-hard.

5. Applications
help illustrate utility results, section cites several planners
literature analyzes computational complexity problems attack.
give detailed explanations planners themselves; this, refer reader
original papers. focus three planning systems: witness (Brown University),
buridan (University Washington), treeplan (University British Columbia).
process making connections planners, describe work relates
discounted-reward criterion, partial observability, domain representations, partial
order conditional planning, policy-based planning, approximate planning.

5.1 Witness

witness algorithm (Cassandra, Kaelbling, & Littman, 1994; Kaelbling et al., 1998)
solves partially observable Markov decision processes using dynamic-programming approach. basic algorithm finds optimal unrestricted solutions finite-horizon problems.
Papadimitriou Tsitsiklis (1987) showed plan-existence problem polynomialhorizon partially observable Markov decision processes PSPACE-complete.
extension finite-horizon algorithm, Kaelbling et al. (1998) sketch method
finding optimal looping plans domains. Although presented
formal algorithm, unreasonable say pure form problem
extended version witness attacks one finding valid polynomial-size looping plan
partially observable domain. similarities problem described
Section 3 domains plans identical form.
apparent differences witness optimizes reward function instead probability
goal satisfaction witness works partially observable domains whereas
results defined terms completely observable domains. apparent
differences insignificant, however, computational complexity point view.
First, witness attempts maximize expected total discounted reward
infinite horizon (sometimes called optimizing time-separable value function). argued
Condon (1992), problem defined terms sum discounted rewards
recast one goal satisfaction. argument proceeds roughly follows. Let 0 < < 1
discount factor R(s; a) immediate reward received taking action
state s.
27

fiLittman, Goldsmith & Mundhenk

Define

;a R(s0 ; a0 )
R0(s; a) = max R(s;Ra()s0,; amin
0 ) , min R(s0 ; a0 ) :
0

;a
0

0

;a

0

0

0

this, 0 R0 (s; a) 1 value plan
respect revised reward function simple linear transformation true value.
Now, introduce auxiliary state g goal state create new transition
function t0 t0 (s; a; g) = (1 , )R0 (s; a) t0 (s; a; s0 ) = (1 , (1 , )R0 (s; a))t(s; a; s0 )
s0 6= g; t0 well-defined transition function probability goal satisfaction
plan transition function t0 precisely expected total discounted
reward reward function R0 transition function t. Thus, problem stated
one optimizing expected total discounted immediate rewards turned
equivalent problem optimizing goal satisfaction slight change transition
function one additional state. means fundamental computational
complexity difference two different types planning objectives.
second apparent difference problem solved extended witness
algorithm described Section 3 partial versus complete observability.
fact, results address partial observability, albeit indirectly. formulation
plan-existence problem, plans constrained make conditional branches (in
totally ordered partially ordered cases), branch distinctions made
step-transition function (in acyclic looping cases); two choices correspond
unobservable partially observable domains, respectively. partially observable
domain, plan-existence problem becomes one finding valid polynomial-size finitestate controller subject given observability constraints. Nothing complexity
proofs depends presence absence additional observability constraints. Therefore,
direct corollary Theorem 2 plan-existence problem polynomial-horizon
plans unobservable domains NP-complete (Papadimitriou & Tsitsiklis, 1987)
Theorem 7 plan-existence problem polynomial-size looping plans partially
observable domains NP-complete (this new result).
interesting note computational complexity searching size-bounded
plans partially observable domains generally substantially less solving
corresponding unconstrained partially observable Markov decision process. example,
found plan-existence problem acyclic plans propositional domains
NPPP -complete (Theorem 4). corresponding unconstrained problem determining existence history-dependent policy polynomial-horizon, compactly
represented partially observable Markov decision process, EXPSPACE-complete
(Theorem 4.15 Goldsmith et al., 1996, Theorem 6.8 Mundhenk et al., 1997b).
gap enormous: EXPSPACE EXP PSPACE P, EXP already
provably intractable worst case. contrast EXPSPACE-complete problems,
conceivable good heuristics NPPP -complete problems created extensions
recent advances heuristics NP-complete problems. Therefore, hope
devising effective planning algorithms building observations paper
searching optimal size-bounded plans instead optimal unrestricted plans; fact, recent planners propositional domains (Majercik & Littman, 1998a, 1998b)
domains (Hansen, 1998) motivated results.
28

fiComplexity Probabilistic Planning

Domain Type

propositional

propositional

Horizon Type
polynomial
polynomial
infinite
infinite

Size-Bounded Plan Unrestricted Plan
NP-complete
NPPP -complete
NP-complete
PSPACE-complete

PSPACE-complete
EXPSPACE-complete
undecidable
undecidable

Table 3: Complexity results plan existence partially observable domains
Table 3 summarizes complexity results planning partially observable domains.
results size-bounded plans corollaries Theorems 2, 4, 7, 9 paper. results unrestricted plans due Papadimitriou Tsitsiklis (1987)
( at, polynomial), Goldsmith et al. (1996) (propositional, polynomial), Hanks (1996)
(infinite-horizon). last result derived noting isomorphism infinitehorizon problem emptiness problem probabilistic finite-state automata,
undecidable (Rabin, 1963).

5.2 Buridan

buridan planner (Kushmerick et al., 1995) finds partially ordered plans propositional domains PSO representation. two identifiable differences
problem solved buridan problem analyzed Section 4: representation
planning problems fact buridan restricted find polynomial-size
plans. address differences below.
Although, surface, PSO different ST, either converted
polynomial time polynomial increase domain size. particular,
effect action PSO represented single decision tree consisting proposition
nodes (like ST) random nodes (easily simulated ST using auxiliary propositions).
leaves list propositions become true another list propositions
become false leaf reached. type correlated effect easily
represented ST using chain rule probability theory decompose probability
distribution separate probabilities proposition careful use \:new"
sux. Thus, PSO domain converted similar size ST domain quickly.
Similarly, domain ST converted PSO polynomial expansion.
conversion complex sketch here, follows proof equivalence ST simplified representation called (Littman, 1997a). Given polynomial
equivalence ST PSO, complexity results ST carry PSO.5
results described paper concern planning problems bound given
size plan sought. Although Kushmerick et al. (1995) explicitly describe
planner one prefers small plans large plans, design planner
one searches space plans makes notion plan size central
algorithm. Indeed, public-domain buridan implementation uses plan size part
best-first search procedure identifying suciently successful plan. means that,
things equal, shorter plans found larger plans. Furthermore,
assure termination, planner considers fixed number plans halting, thus
5. precise, true complexity classes closed log-space reductions.

29

fiLittman, Goldsmith & Mundhenk

putting limit indirectly maximum allowable plan size. So, although buridan
attempt solve precisely problem considered, fair say
problem consider idealization problem attacked buridan. Regardless,
lower bounds complexity apply buridan.
Kushmerick et al. (1995) looked generating suciently successful plans
optimistic interpretation pessimistic interpretation. explicitly examined plan-evaluation problem partially ordered plans interpretations.
Therefore, Theorems 13 14 apply buridan.
sophisticated c-buridan planner (Draper et al., 1994) extends buridan
plan partially observable domains produce plans conditional execution.
results work shed light computational complexity problem addressed
c-buridan. Draper et al. (1994) devised representation partially ordered acyclic
(conditional) plans. representation, plan step generates observation label
function probabilistic outcome step. step associated set
context labels dictating circumstances step must executed. plan
step executed context labels consistent observation labels produced
earlier steps. totally ordered form, type plan expressed compact
acyclic plan; Corollary 5 used show plan-evaluation plan-existence
problems totally ordered version c-buridan's conditional plan representation
propositional domains PP-complete NPPP -complete, respectively.
results above, consider evaluating searching plans partially
ordered plans conditional execution, once. Nonetheless,
sorts techniques presented paper applied analyzing problems
attacked c-buridan. example, consider plan-existence problem c-buridan's
partially ordered conditional plans optimistic interpretation. problem asks
whether partially ordered conditional plan total order reaches
goal sucient probability. equivalent asking whether totally
ordered conditional plan reaches goal sucient probability. Therefore,
problem NPPP -complete, argument previous paragraph.
spite many superficial differences problems analyzed paper
studied creators buridan planners, results quite relevant
understanding work.

5.3 Treeplan
family planners designed generate decision-tree-based representation
stationary policies (mappings state action) (Boutilier et al., 1995; Boutilier &
Poole, 1996; Boutilier & Dearden, 1996) probabilistic propositional domains; refer
planners collectively treeplan planners. again, planners solve
problems identical problems addressed paper closely
related.
planner described Boutilier et al. (1995) finds solutions maximize expected
total discounted reward compactly represented Markov decision processes (the domain
representation used expressively equivalent ST). mentioned earlier, difference
maximizing goal satisfaction maximizing expected total discounted reward
30

fiComplexity Probabilistic Planning

superficial one, problem addressed planner EXP-complete (Littman, 1997a).
Although policies used Boutilier et al. (1995) appears quite dissimilar finitestate controllers described work, policies converted type similarly
sized compact looping plan (an extension type plan described Corollary 5).
conversion stationary policies looping plans described proof
Theorem 7, except resulting plans represented compactly.
later work, Boutilier Dearden (1996) show possible limit size
representation policy treeplan still obtain approximately optimal
performance. necessary because, general, size decision trees needed
represent optimal policies exponentially large. keeping decision trees
getting large, resulting planner becomes subject extension Theorem 9
and, therefore, attacks PSPACE-complete problem.
One emphasis Boutilier Dearden (1996) finding approximately optimal
solutions, hope easier finding optimal solutions.
explore worst-case complexity approximation paper, although Lusena,
Goldsmith, Mundhenk (1998) produced strong negative results area.
related issue one using simulation (random sampling) find approximately optimal
solutions probabilistic planning problems. empirical successes obtained
related approach reinforcement learning (Tesauro, 1994; Crites & Barto, 1996),
but, again, worst-case complexity probabilistic planning known
lower approximation simulation.

6. Conclusions
paper, explored computational complexity plan evaluation plan existence probabilistic domains. found that, compactly represented propositional
domains, restricting size form policies consideration reduced
computational complexity plan existence EXP-complete unrestricted plans
PSPACE-complete polynomial-size looping plans NPPP -complete polynomialsize acyclic plans. contrast, domains, restricting form policies
consideration increased computational complexity plan existence P-complete
unrestricted plans NP-complete totally ordered plans; plan
smaller domain operates often unable exploit important Markov
properties domain. able characterize precisely complexity
problems examined regard current state knowledge complexity theory.
Several problems studied turned NPPP -complete. class NPPP promises
useful researchers uncertainty artificial intelligence captures
type problems resulting choosing (\guessing") solution evaluating
probabilistic behavior. precisely type problem faced planning algorithms
probabilistic domains, captures important problems domains well,
constructing explanations belief networks designing robust communication networks.
provide new conceptually simple NPPP -complete problem, E-Majsat, may
useful explorations direction.
basic structure results plan evaluation complete class C ,
plan existence typically NPC -complete. basic structure holds determin31

fiLittman, Goldsmith & Mundhenk

istic domains: evaluating totally ordered plan propositional domain P-complete (for
suciently powerful domain representations) determining existence polynomialsize totally ordered plan NPP = NP-complete.
pragmatic standpoint, intuition searching small plans efficient searching arbitrary size plans suggests exact dynamic-programming
algorithms, successful domains, may effective propositional
domains; focus efforts set small plans. Algorithm-development
energy, therefore, might fruitfully spent devising heuristics problems class NPPP
class captures essence searching small plans probabilistic domains|some
early results direction appearing (Majercik & Littman, 1998a, 1998b). Complexity theorists recently begun explore classes NPPP lie
polynomial hierarchy PSPACE algorithm designers come classes even
recently. paper marks beginning exploration class problems, much work still done probing algorithmic implications, hope
heuristics NPPP could lead powerful methods solving range important
uncertainty-sensitive combinatorial problems.

Acknowledgements
work supported part grants NSF-IRI-97-02576-CAREER (Littman),
NSF CCR-9315354 (Goldsmith). gratefully acknowledge Andrew Klapper, Anne Condon, Matthew Levy, Steve Majercik, Chris Lusena, Mark Peot, reviewers helpful
feedback conversations topic.

Appendix A. Complexity E-Majsat
E-Majsat problem is: given pair (; k) consisting Boolean formula n
variables x1 ; : : : ; xn number 1 k n, assignment first k variables
x1 ; : : : ; xk majority assignments remaining n,k variables xk+1 ; : : : ; xn
satisfies ?
k = n, precisely Boolean satisfiability, classic NP-complete problem.
asking whether exists assignment variables makes
true. k = 0, E-Majsat precisely Majsat, well-known PP-complete problem.
asking whether majority total assignments makes true.
Deciding instance E-Majsat intermediate values k different character.
involves NP-type calculation pick good setting first k variables
PP-type calculation see majority assignments remaining variables makes
true. akin searching good answer (plan, schedule, coloring, belief network
explanation, etc.) combinatorial space \good" determined computation
probabilistic quantities. type computation described class
NPPP , show next E-Majsat NPPP -complete.

Theorem 15

E-Majsat

NPPP -complete.
32

fiComplexity Probabilistic Planning

Proof: Membership NPPP follows directly definitions. show completeness
E-Majsat, first observe (Tor
an, 1991) NPPP NP
-closure PP-complete

set Majsat. Thus, NPPP computation modeled nondeterministic machine
N that, possible computation, first guesses sequence bits controls
nondeterministic moves, deterministically performs computation input x s,
writes formula qx;s variables z1 ; : : : ; zl query Majsat.
Finally, N (x) oracle Majsat accepts s, qx;s 2 Majsat.
Given input x, Cook's Theorem, construct formula x variables
y1; : : : ; yk z1; : : : ; zl every assignment a1; : : : ; ak ; b1 ; : : : ; bl holds
x (a1 ; : : : ; ak ; b1 ; : : : ; bl ) = qx;a1a (b1 ; : : : ; bl ). Thus, (x ; k) 2 E-Majsat
assignment y1 ; : : : ; yk , qx;s 2 Majsat N (x) accepts.
k

References

Allender, E., & Ogihara, M. (1996). Relationships among PL, #L, determinant.
Theoretical Informatics Applications, 30 (1), 1{21.
lvarez, C., & Jenner, B. (1993). hard log-space counting class. Theoretical Computer
Science, 107, 3{30.
Backstrom, C. (1995). Expressive equivalence planning formalisms. Artificial Intelligence,
76 (1{2), 17{34.
Backstrom, C., & Nebel, B. (1995). Complexity results SAS+ planning. Computational
Intelligence, 11 (4), 625{655.
Balcazar, J., Daz, J., & Gabarro, J. (1988/1990). Structural Complexity I/II. EATCS
Monographs Theoretical Computer Science. Springer Verlag.
Borodin, A., Cook, S., & Pippenger, N. (1983). Parallel computation well-endowed
rings space-bounded probabilistic machines. Information Control, 58 (1{3),
113{136.
Boutilier, C., Dean, T., & Hanks, S. (1998). Decision theoretic planning: Structural assumptions computational leverage. preparation.
Boutilier, C., & Dearden, R. (1996). Approximating value trees structured dynamic programming. Saitta, L. (Ed.), Proceedings Thirteenth International Conference
Machine Learning.
Boutilier, C., Dearden, R., & Goldszmidt, M. (1995). Exploiting structure policy construction. Proceedings Fourteenth International Joint Conference Artificial
Intelligence, pp. 1104{1113.
Boutilier, C., & Poole, D. (1996). Computing optimal policies partially observable
decision processes using compact representations. Proceedings Thirteenth
National Conference Artificial Intelligence, pp. 1168{1175. AAAI Press/The MIT
Press.
33

fiLittman, Goldsmith & Mundhenk

Bylander, T. (1994). computational complexity propositional STRIPS planning.
Artificial Intelligence, 69, 161{204.
Cassandra, A. R., Kaelbling, L. P., & Littman, M. L. (1994). Acting optimally partially
observable stochastic domains. Proceedings Twelfth National Conference
Artificial Intelligence, pp. 1023{1028 Seattle, WA.
Chapman, D. (1987). Planning conjunctive goals. Artificial Intelligence, 32, 333{379.
Condon, A. (1992). complexity stochastic games. Information Computation,
96 (2), 203{224.
Crites, R. H., & Barto, A. G. (1996). Improving elevator performance using reinforcement
learning. Touretzky, D. S., Mozer, M. C., & Hasselmo, M. E. (Eds.), Advances
Neural Information Processing Systems 8 Cambridge, MA. MIT Press.
Dearden, R., & Boutilier, C. (1997). Abstraction approximate decision-theoretic planning. Artificial Intelligence, 89 (1{2), 219{283.
Draper, D., Hanks, S., & Weld, D. (1994). Probabilistic planning information gathering
contingent execution. Proceedings AAAI Spring Symposium Decision
Theoretic Planning, pp. 76{82.
Drummond, M., & Bresina, J. (1990). Anytime synthetic projection: Maximizing
probability goal satisfaction. Proceedings Eighth National Conference
Artificial Intelligence, pp. 138{144. Morgan Kaufmann.
Erol, K., Nau, D. S., & Subrahmanian, V. S. (1995). Complexity, decidability undecidability results domain-independent planning. Artificial Intelligence, 76, 75{88.
Gill, J. (1977). Computational complexity probabilistic Turing machines. SIAM Journal
Computing, 6 (4), 675{695.
Goldman, R. P., & Boddy, M. S. (1994). Epsilon-safe planning. Proceedings 10th
Conference Uncertainty Artificial Intelligence (UAI94), pp. 253{261 Seattle,
WA.
Goldsmith, J., Littman, M., & Mundhenk, M. (1997a). complexity plan existence
evaluation probabilistic domains. Tech. rep. CS-1997-07, Department Computer
Science, Duke University.
Goldsmith, J., Littman, M. L., & Mundhenk, M. (1997b). complexity plan existence
evaluation probabilistic domains. Proceedings Thirteenth Annual Conference Uncertainty Artificial Intelligence (UAI{97), pp. 182{189 San Francisco,
CA. Morgan Kaufmann Publishers.
Goldsmith, J., Lusena, C., & Mundhenk, M. (1996). complexity deterministically
observable finite-horizon Markov decision processes. Tech. rep. 268-96, Department
Computer Science, University Kentucky.
34

fiComplexity Probabilistic Planning

Hanks, S. (1996). Decision-theoretic planning unobservable domains undecidable.
Personal communication.
Hansen, E. A. (1998). Finite-Memory Control Partially Observable Systems. Ph.D. thesis,
University Massachusetts.
Jung, H. (1985). probabilistic time space. Proceedings 12th ICALP, pp. 281{291.
Lecture Notes Computer Science, Springer-Verlag.
Kaelbling, L. P., Littman, M. L., & Cassandra, A. R. (1998). Planning acting
partially observable stochastic domains. Artificial Intelligence, 101 (1{2), 99{134.
Koenig, S., & Simmons, R. G. (1994). Risk-sensitive planning probabilistic decision
graphs. Proceedings 4th International Conference Principles Knowledge
Representation Reasoning, pp. 363{373.
Kushmerick, N., Hanks, S., & Weld, D. S. (1995). algorithm probabilistic planning.
Artificial Intelligence, 76 (1-2), 239{286.
Ladner, R. (1989). Polynomial space counting problems. SIAM Journal Computing, 18,
1087{1097.
Lin, S.-H., & Dean, T. (1995). Generating optimal policies high-level plans conditional branches loops. Proceedings Third European Workshop
Planning, pp. 205{218.
Littman, M. L. (1997a). Probabilistic propositional planning: Representations complexity. Proceedings Fourteenth National Conference Artificial Intelligence,
pp. 748{754. AAAI Press/The MIT Press.
Littman, M. L. (1997b). Solving large POMDPs: Lessons complexity theory. Talk
presented DARPA AI Workshop Providence, RI. Slides available URL
http://www.cs.duke.edu/mlittman/talks/darpa97-pomdp.ps.
Lovejoy, W. S. (1991). survey algorithmic methods partially observable Markov
decision processes. Annals Operations Research, 28 (1), 47{65.
Lusena, C., Goldsmith, J., & Mundhenk, M. (1998). Nonapproximability results Markov
decision processes. Tech. rep. UK CS Dept TR 275-98, University Kentucky.
Majercik, S. M., & Littman, M. L. (1998a). MAXPLAN: new approach probabilistic
planning. Simmons, R., Veloso, M., & Smith, S. (Eds.), Proceedings Fourth
International Conference Artificial Intelligence Planning, pp. 86{93. AAAI Press.
Majercik, S. M., & Littman, M. L. (1998b). Using caching solve larger probabilistic
planning problems. Proceedings Fifteenth National Conference Artificial
Intelligence, pp. 954{959. AAAI Press/The MIT Press.
Mansell, T. M. (1993). method planning given uncertain incomplete information.
Proceedings 9th Conference Uncertainty Artificial Intelligence, pp.
350{358. Morgan Kaufmann Publishers.
35

fiLittman, Goldsmith & Mundhenk

McAllester, D., & Rosenblitt, D. (1991). Systematic nonlinear planning. Proceedings
9th National Conference Artificial Intelligence, pp. 634{639.
Mundhenk, M., Goldsmith, J., & Allender, E. (1997a). complexity policy-evaluation
finite-horizon partially-observable Markov decision processes. Proceedings
22nd Symposium Mathematical Foundations Computer Science (published
Lecture Notes Computer Science). Springer-Verlag.
Mundhenk, M., Goldsmith, J., Lusena, C., & Allender, E. (1997b). Encyclopaedia complexity results finite-horizon Markov decision process problems. Tech. rep. UK CS
Dept TR 273-97, University Kentucky.
Papadimitriou, C. H. (1994). Computational Complexity. Addison-Wesley, Reading, MA.
Papadimitriou, C. H., & Tsitsiklis, J. N. (1987). complexity Markov decision processes. Mathematics Operations Research, 12 (3), 441{450.
Platzman, L. K. (1981). feasible computational approach infinite-horizon partiallyobserved Markov decision problems. Tech. rep. J-81-2, Georgia Institute Technology,
Atlanta, GA.
Puterman, M. L. (1994). Markov Decision Processes|Discrete Stochastic Dynamic Programming. John Wiley & Sons, Inc., New York, NY.
Rabin, M. O. (1963). Probabilistic automata. Information Control, 6 (3), 230{245.
Roth, D. (1996). hardness approximate reasoning. Artificial Intelligence, 82 (1{2),
273{302.
Simon, J. (1975). central problems computational complexity. Ph.D. thesis,
Cornell University. Cornell Department Computer Science Technical Report
TR75-224.
Smith, D. E., & Williamson, M. (1995). Representation evaluation plans loops.
Working notes 1995 Stanford Spring Symposium Extended Theories
Action.
Tesauro, G. (1994). TD-Gammon, self-teaching backgammon program, achieves masterlevel play. Neural Computation, 6 (2), 215{219.
Toda, S. (1991). PP hard polynomial-time hierarchy. SIAM Journal Computing, 20, 865{877.
Toran, J. (1991). Complexity classes defined counting quantifiers. Journal ACM,
38 (3), 753{774.
Vinay, V. (1991). Counting auxiliary pushdown automata semi-unbounded arithmetic
circuits. Proc. 6th Structure Complexity Theory Conference, pp. 270{284. IEEE.

36


