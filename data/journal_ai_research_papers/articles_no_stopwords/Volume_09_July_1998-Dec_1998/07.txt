Journal Artificial Intelligence Research 9 (1998) 463-506

Submitted 4/98; published 12/98

Temporal Description Logic
Reasoning Actions Plans
Alessandro Artale

artale@irst.itc.it

ITC-IRST, Cognitive Communication Technologies Division
I-38050 Povo TN, Italy

Enrico Franconi

Department Computer Science, University Manchester
Manchester M13 9PL, UK

franconi@cs.man.ac.uk

Abstract

class interval-based temporal languages uniformly representing reasoning
actions plans presented. Actions represented describing true
action occurring, plans constructed temporally relating actions
world states. temporal languages members family Description Logics,
characterized high expressivity combined good computational properties.
subsumption problem class temporal Description Logics investigated
sound complete decision procedures given. basic language TL-F considered
first: composition temporal logic TL { able express interval temporal
networks { together non-temporal logic F { Feature Description Logic.
proven subsumption language NP-complete problem. shown
reason expressive languages TLU -FU TL-ALCF . former
adds disjunction temporal non-temporal sides language, latter
extends non-temporal side set-valued features (i.e., roles) propositionally
complete language.

1. Introduction
representation temporal knowledge received considerable attention Artificial Intelligence community attempt extend existing knowledge representation
systems deal actions change. time, many logic-based formalisms
developed analyzed logicians philosophers purposes.
class logical formalisms, properties expressive power computability
studied regards typical problems involving events actions.
paper analyzes theoretical point view logical computational
properties knowledge representation system allows us deal time, actions
plans uniform way. common approaches model actions based
notion state change { e.g., formal models based original situation
calculus (McCarthy & Hayes, 1969; Sandewall & Shoham, 1994) Strips-like planning
systems (Fikes & Nilsson, 1971; Lifschitz, 1987) { actions generally considered
instantaneous defined functions one state another means pre-
post-conditions. Here, explicit notion time introduced modeling language
actions defined occurring time intervals, following Allen proposal (Allen,
c 1998 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiArtale & Franconi

1991). formalism action represented describing time course
world action occurs. Concurrent overlapping actions allowed: effects
overlapping actions different sum individual effects; effects may
directly follow action complex temporal relations may hold. instance,
consider motion pointer screen driven mouse: pointer moves
movement device pad { cause-effect relation { two
events contemporary, common-sense notion word.
class interval temporal logics studied based Description Logics inspired
works Schmiedel (1990) Weida Litman (1992). class formalisms
state describes collection properties world holding certain time. Actions
represented temporal constraints world states, pertain action itself.
Plans built temporally relating actions states. represent temporal dimension classical Description Logics extended temporal constructors; thus uniform
representation states, actions plans provided. Furthermore, distinction made
Description Logics terminological assertional aspects knowledge
allows us describe actions plans abstract level (action/plan types)
instance level (individual actions plans). environment, subsumption
calculus main inference tool managing collections action plan types. Action
plan types organized subsumption-based taxonomy, plays role
action/plan library used tasks known literature plan retrieval
individual plan recognition (Kautz, 1991). refinement plan recognition notion proposed, splitting different tasks plan description classification {
involving plan type { specific plan recognition respect plan description {
involving individual plan. According latter reasoning task, system able
recognize type action/plan taken place certain time interval, given set
observations world.
Advantages using Description Logics high expressivity combined desirable computational properties { decidability, soundness completeness deduction procedures (Buchheit, Donini, & Schaerf, 1993; Schaerf, 1994; Donini, Lenzerini,
Nardi, & Schaerf, 1994; Donini, Lenzerini, Nardi, & Nutt, 1995). main purpose
work investigate class decidable temporal Description Logics, provide complete algorithms computing subsumption. aim, start TL-F , language
composition temporal logic TL { able express interval temporal networks {
together non-temporal Description Logic F { Feature Description Logic (Smolka,
1992). turns subsumption TL-F NP-complete problem. Then, show
reason expressive languages: TLU -FU , adds disjunction
temporal non-temporal sides language, TL-ALCF , extends
non-temporal side set-valued features (i.e., roles) propositionally complete Description Logic (Hollunder & Nutt, 1990). cases show reasoning decidable
supply sound complete procedures computing subsumption.
paper organized follows. introducing main features Description
Logics Section 2, Section 3 organizes intuitions underlying proposal. technical
bases introduced brie overviewing temporal extensions Description Logics
relevant approach { together inter-relationships interval temporal
modal logic { specifically intended time action representation reasoning.
464

fiA Temporal Description Logic Reasoning Actions Plans

basic feature temporal language (TL-F ) introduced Section 4. language syntax
first described Section 4.1, together worked example illustrating informal
meaning temporal expressions. Section 4.2 reveals model theoretic semantics TL-F ,
together formal definition subsumption instance recognition problems.
Section 5 shows temporal language suitable action plan representation
reasoning: well known cooking domain blocks world domain taken
consideration. sound complete calculus feature temporal language TL-F
presented details Section 6. proof subsumption TL-F NP-complete
problem included. calculus TL-F forms basic reasoning procedure
adapted deal logics extended propositional part. algorithm
checking subsumption presence disjunction (TLU -FU ) devised Section 7.1;
Section 7.2 non-temporal part language extended roles
full propositional calculus (TL-ALCF ). cases, subsumption problem still
decidable. Operators homogeneity persistence presented Section 8
adequate representation world states. particular, possible solution frame
problem, i.e., problem compute remains unchanged action, suggested.
Section 9 surveys whole spectrum extensions Description Logics representing
reasoning time action. Section concluded comparison State
Change based approaches brie illustrating effort made situation calculus
area temporally extend class formalisms. Section 10 concludes paper.

2. Description Logics

Description Logics1 formalisms designed logical reconstruction representation tools frames, semantic networks, object-oriented semantic data models
{ see (Calvanese, Lenzerini, & Nardi, 1994) survey. Nowadays, Description Logics
considered important unifying formalism many object-centered
representation languages used areas Knowledge Representation. Important
characteristics Description Logics high expressivity together decidability,
guarantee existence reasoning algorithms always terminate correct
answers.
Section gives brief introduction basic Description Logic, serve
basic representation language proposal. formal apparatus, formalism introduced (Schmidt-Schau & Smolka, 1991) elaborated (Donini,
Hollunder, Lenzerini, Spaccamela, Nardi, & Nutt, 1992; Donini et al., 1994, 1995; Buchheit
et al., 1993; De Giacomo & Lenzerini, 1995, 1996) followed: way, Description
Logics considered structured fragment predicate logic. ALC (Schmidt-Schau &
Smolka, 1991) minimal Description Logic including full negation disjunction {
i.e., propositional calculus, notational variant propositional modal logic
K(m) (Halpern & Moses, 1985; Schild, 1991).
basic types Description Logic concepts, roles, features, individuals.
concept description gathering common properties among collection individuals;
logical point view unary predicate ranging domain individu1. Description Logics called Frame-Based Description Languages, Term Subsumption Languages, Terminological Logics, Taxonomic Logics, Concept Languages KL-One-like languages.

465

fiArtale & Franconi

C; ! j

>j
?j
:C j
C uD j
C tD j
8P .C j
9P .C j
p:Cj
p#qj
p"qj
p"
p; q ! f j
pq

(atomic concept)
(top)
(bottom)
(complement)
(conjunction)
(disjunction)
(universal quantifier)
(existential quantifier)
(selection)
(agreement)
(disagreement)
(undefinedness)
(atomic feature)
(path)

Figure 1: Syntax rules ALCF Description Logic.
als. Properties represented either means roles { interpreted binary
relations associating individuals given class values property { means
features { interpreted functions associating individuals given class
single value property. language ALCF , extending ALC features (i.e.,
functional roles) considered. syntax rules Figure 1, ALCF concepts (denoted
letters C D) built atomic concepts (denoted letter A), atomic roles
(denoted letter P ), atomic features (denoted letter f ). syntax rules
expressed following tradition Description Logics (Baader, Burckert, Heinsohn,
Hollunder, Muller, Nebel, Nutt, & Profitlich, 1990).
meaning concept expressions defined sets individuals, unary predicates, meaning roles sets pairs individuals, binary predicates.
Formally, interpretation pair = (I ; ) consisting set individuals (the
domain ) function (the interpretation function ) mapping every concept
subset , every role subset , every feature partial function
, every individual different element { i.e., aI 6= bI 6= b
(Unique Name Assumption) { equations left column Figure 2
satisfied.
ALCF semantics identifies concept expressions fragments first-order predicate
logic. Since interpretation assigns every atomic concept, role feature unary
binary (functional) relation , respectively, one think atomic concepts, roles
features unary binary (functional) predicates. seen follows:
atomic concept A, atomic role P , atomic feature f , mapped respectively
open formulas FA ( ), P (ff; ), (ff; ) satisfying functionality axiom
8y; z.Ff (x; y) ^ (x; z) ! = z { i.e., functional relation.
rightmost column Figure 2 gives transformational semantics ALCF expressions terms FOL well-formed formul, left column gives standard
extensional semantics. far transformational semantics concerned, concept C ,
role P path p correspond FOL open formulae FC ( ), FP (ff; ), Fp (ff; ),
466

fiA Temporal Description Logic Reasoning Actions Plans

>I =
?I = ;

(:C )I =
(C u D)I =
(C D)I =
(9P .C )I =
(8P .C )I =
(p : C )I =
p # qI =
p " qI =

true
false

n C

C \ DI
C [ DI
fa 2 j 9b.(a; b) 2 P ^ b 2 C g
fa 2 j 8b.(a; b) 2 P ) b 2 C g
fa 2 dom pI j pI (a) 2 C g
fa 2 dom pI \ dom qI j pI (a) = qI (a)g
fa 2 dom pI \ dom qI j pI (a) 6= qI (a)g

(p ")I = n dom pI
(p q)I = pI qI

:FC ( )
FC ( ) ^ FD ( )
FC ( ) _ FD ( )
9x.FP ( ; x) ^ FC (x)
8x.FP ( ; x) ) FC (x)
9x.Fp ( ; x) ^ FC (x)
(9x.Fp ( ; x) ^ Fq ( ; x))
(9x; .Fp ( ; x) ^ Fq ( ; ))^
(8x; .Fp ( ; x) ^ Fq ( ; ) ! x 6= )
:9x.Fp ( ; x)
9x.Fp (ff; x) ^ Fq (x; )

Figure 2: extensional transformational semantics ALCF .
respectively. worth noting extensional semantics left column gives
interpretation formulas right column following proposition
holds.

Proposition 2.1 (Concepts vs. fol formul) Let C ALCF concept expression.

transformational semantics Figure 2 maps C logically equivalent first
order formula.

terminology TBox finite set terminological axioms. atomic concept A,
called defined
concept, (possibly complex) concept C , terminological axiom
:
form = C . atomic concept appearing left-hand side terminological
axiom called primitive concept. Acyclic simple TBoxes considered: defined
concept may appear left-hand side axiom, terminological
cycles allowed, i.e., defined concept may occur { neither directly indirectly {
within definition (Nebel, 1991). interpretation satisfies =: C
AI = C .
example, consider unary relation (i.e., concept) denoting class happy
fathers, defined using atomic predicates Man, Doctor, Rich, Famous (concepts)
CHILD, FRIEND (roles):
:
HappyFather = Man u (9CHILD.>) u 8CHILD.(Doctor u 9FRIEND.(Rich Famous))
i.e., men whose children doctors rich famous friend.
ABox finite set assertional axioms, i.e. predications individual objects. Let
alphabet symbols denoting individuals; assertion axiom form
C (a), R(a; b) p(a; b), b denote individuals O. C (a) satisfied
interpretation iff aI 2 C , P (a; b) satisfied iff (aI ; bI ) 2 P , p(a; b) satisfied
iff pI (aI ) = bI .
467

fiArtale & Franconi

knowledge base finite set terminological assertional axioms. interpretation model knowledge base iff every axiom satisfied . logically
implies v C (written j= v C ) AI C every model : say
subsumed C . reasoning problem checking whether subsumed C
called subsumption checking. logically implies C (a) (written j= C (a)) aI 2 C
every model : say instance C . reasoning problem
checking whether instance C called instance recognition.
acyclic simple TBox transformed expanded TBox
models, defined concept makes use definition defined concept.
way, interpretation defined concept expanded TBox depend
defined concept. easy see subsumed C acyclic simple
TBox expansion respect subsumed expansion
C respect empty TBox. expansion procedure recursively substitutes
every defined concept occurring definition defining expression; procedure
may generate TBox exponential size, proved (Nebel, 1990) works
polynomial time reasonable restrictions. following interchangeably refers either
reasoning respect TBox reasoning involving expanded concepts
empty TBox. particular, devising subsumption calculus logics considered
here, always assumed defined concepts expanded.

3. Towards Temporal Description Logics
Schmiedel (1990) proposed extend Description Logics interval{based temporal
logic. temporal variant Description Logic equipped model-theoretic
semantics. underlying Description Logic FLENR, (Donini et al., 1995): differs
ALCF contain > ? concepts, neither
negation disjunction, cardinality restrictions conjunction roles.
new temporal term-forming operators temporal qualifier at, existential
universal temporal quantifiers sometime alltime. qualifier operator specifies
time concept holds. temporal quantifiers introduce temporal variables
constrained means temporal relationships based Allen's interval algebra extended
metric constraints deal durations, absolute times, granularities intervals.
give example temporal Description Logic, concept Mortal defined
by:
:
Mortal = LivingBeing u (sometime(x) (after x NOW) (at x (:LivingBeing)))
meaning LivingBeing reference interval NOW, alive
interval x sometime reference interval NOW. Schmiedel propose
algorithm computing subsumption, gives preliminary hints. Actually,
Schmiedel's logic argued undecidable (Bettini, 1997), sacrificing main benefit
Description Logics: possibility decidable inference techniques.
Schmiedel's temporal Description Logic, closed complementation, contains
proper fragment temporal logic HS proposed Halpern Shoham (1991).
logic HS propositional modal logic extends propositional logic modal
formul kind hRi. [R]. { R basic Allen's temporal relation hi
468

fiA Temporal Description Logic Reasoning Actions Plans

[] possibility necessity modal operators. example, modal formula
LivingBeing ^ hafteri.:LivingBeing corresponds abovementioned Mortal concept.
Unfortunately, HS logic shown undecidable, least interesting classes
temporal structures: \One gets decidability restricted cases,
set temporal models considered finite collection structures, consisting
finite set natural numbers." (Halpern & Shoham, 1991)
Weida Litman (1992, 1994) propose T-Rex, loose hybrid integration
Description Logics constraint networks. Plans defined collections steps together
temporal constraints duration. step associated action
type, represented generic concept K-Rep { non-temporal Description Logic. Thus
plan seen plan network, temporal constraint network whose nodes, corresponding
time intervals, labeled action types associated steps plan
itself. example plan T-Rex show plan preparing spaghetti marinara:
(

defplan Assemble-Spaghetti-Marinara
((step1 Boil-Spaghetti)
(step2 Make-Marinara)
(step3 Put-Together-SM))
((step1 (before meets) step3)
(step2 (before meets) step3)))

plan composed three actions, i.e., boiling spaghetti, preparing marinara sauce,
assembling things end. Temporal constraints steps establish
temporal order corresponding actions. structural plan subsumption
algorithm defined, characterized terms graph matching, based two separate
notions subsumption: pure terminological subsumption action types labeling
nodes, pure temporal subsumption interval relationships labeling arcs.
plan library used guide plan recognition (Weida, 1996) way similar
proposed Kautz (1991). Even work strong motivations, formal semantics
provided language reasoning problems.
Starting assumption action duration time, proposal considers interval-based modal temporal logic { spirit Halpern Shoham (1991)
{ reduces expressivity (Schmiedel, 1990) direction (Weida & Litman,
1992). Schmiedel's work lacks computational machinery, Halpern Shoham's
logic undecidable, expressive decidable logic obtained, providing sound
complete reasoning algorithms. Differently T-Rex uses two different languages
represent actions plans { non temporal Description Logic describing actions
second language compose plans adding temporal information { extension Description Logic chosen time operators available directly term
constructors. view implies integration temporal domain semantic structure terms interpreted, giving formal way well-founded
notion subsumption proving soundness completeness corresponding
procedure. example formalism, plan preparing spaghetti marinara
introduced represented follows:
469

fiArtale & Franconi

: 3(y z w) (y (before; meets) w)(z (before; meets) w).
(Boil-Spaghetti@y u
Make-Marinara@z u
Put-Together-SM@w)

Assemble-Spaghetti-Marinara =

Moreover, possible build temporal structured actions { opposed atomic
actions proposed T-Rex { describing world state changes occurrence action: fact, language allows feature representation order relate
actions states world (see Section 5.2). kind expressivity captured
T-Rex, since uses non-temporal Description Logic represent actions. main
application T-Rex plan recognition; according ideas Kautz (1991) Closed
World Assumption (CWA) (Weida, 1996) made, assuming plan library complete observed plan fully accounted single plan. CWA relied
here, following Open World Semantics characterizing Description Logics. Weaker,
monotonic, deductions allowed plan recognition process. However, procedures recognizing necessary, optional impossible individual plan respect
plan description still applicable, plan library given closed world semantics.

4. Feature Temporal Language TL-F
feature temporal language TL-F basic logic considered here. language
composed temporal Logic TL { able express interval temporal networks {
non-temporal Feature Description Logic F . Note that, logic family Temporal
Description Logics introduced paper identified composed string
first part refers temporal part language one refers
non-temporal part.

4.1 Syntax
Basic types language concepts , individuals, temporal variables intervals.
Concepts describe entities world, states events. Temporal variables denote
intervals bound temporal constraints, means abstract temporal patterns
form constraint networks expressed. Concepts (resp. individuals) specified
hold certain temporal variable (resp. interval). way, action types (resp.
individual actions) represented uniform way temporally related concepts
(resp. individuals).
basic temporal interval relations Allen notation (Allen, 1991) (Figure 3)
used: (b), meets (m), (d), overlaps (o), starts (s), finishes (f), equal (=),
(a), met-by (mi), contains (di), overlapped-by (oi), started-by (si), finished-by (fi). Concept
expressions (denoted C; D) syntactically built atomic concepts (denoted A),
atomic features (denoted f ), atomic parametric features (denoted ?g) temporal
variables (denoted X; ). Temporal concepts (C; D) distinguished non-temporal
concepts (E; F ), following syntax rules Figure 4. Names atomic features
atomic parametric features alphabet symbols; ? symbol
intended operator, differentiating two syntactic types.
470

fiA Temporal Description Logic Reasoning Actions Plans

Relation

Abbr.

Inverse

before(i; j )

b



meets(i; j )



mi

overlaps(i; j )



oi

starts(i; j )



si

during(i; j )



di

finishes(i; j )

f





j

Figure 3: Allen's interval relationships.
Temporal variables introduced temporal existential quantifier \3" { excluding
special temporal variable ], usually called NOW, intended reference interval.
Variables appearing temporal constraints (Tc) must declared within temporal
quantifier, exception special variable ]. Temporal variables appearing
right hand side \@" operator called bindable. Concepts must include unbound
(a.k.a. free) bindable variables. Informally, bindable variable said bound
concept declared nearest temporal quantifier body occurs;
avoid usual formal inductive definition bound variable. Moreover, chained
constructs form ((C [Y1 ]@X1 )[Y2 ]@X2 : : :) non bindable variables { i.e., ones
left hand side \@" operator { cannot appear once. Note that, since
Description Logics fragment FOL one free variable, mentioned
restrictions force temporal side language one free temporal variable,
i.e., reference time ].
usual, terminological axioms building simple acyclic TL-F TBoxes allowed.
using concept expression name referring defined concept, possible
use substitutive qualifier construct, impose coreference variable appearing
definition associated defined concept. statement C [Y ]@X constrains
variable , appear definition defined concept C , corefer X
(see Section 5.2 example). drawback use operator requirement
know internal syntactical form defined concept, namely, names
temporal variables.
Let OT two alphabets symbols denoting individuals temporal intervals,
respectively. assertion { i.e., predication temporally qualified individual entities {
statement one forms C (i; a); p(i; a; b); ?g(a; b); R(i; j ), C concept, p
feature, ?g parametric feature, R temporal relation, b denote individuals
O, j denote temporal intervals OT .
471

fiArtale & Franconi

TL

F

C; ! E j
CuD j
C @X j
C [Y ]@X j
3(X ) Tc.C
Tc ! (X (R) ) j
(X (R) ]) j
(] (R) )
Tc ! Tc j Tc Tc
R; ! R , j
j mi j f j : : :
X; ! x j j z j : : :
X ! XjX X
E; F ! j

>j
EuF j
p#qj

p:E
p; q ! f j
?g j
pq

(non-temporal concept)
(conjunction)
(qualifier)
(substitutive qualifier)
(existential quantifier)
(temporal constraint)

(disjunction)
(Allen's relations)
(temporal variables)
(atomic concept)
(top)
(conjunction)
(agreement)
(selection)
(atomic feature)
(atomic parametric feature)
(path)

Figure 4: Syntax rules interval Description Logic TL-F
4.1.1 clarifying Example

Let us informally see intended meaning terms language TL-F (for
formal details see Section 4.2). Concept expressions interpreted pairs temporal
intervals individuals hi; ai, meaning individual extension concept interval i. concept intended describe action, interpretation
seen set individual actions type occurring interval.
Within concept expression, special \]" variable denotes current interval
evaluation; case actions, thought refers temporal interval
action occurs. temporal existential quantifier introduces interval
variables, related possibly ] variable way defined set
temporal constraints. evaluate concept interval X , different current one,
necessary temporally qualify X { written C @X ; way, every occurrence
472

fiA Temporal Description Logic Reasoning Actions Plans

]

-

Basic-Stack(BLOCK)

x

-

OnTable(BLOCK)



OnBlock(BLOCK)

-

Figure 5: Temporal dependencies definition Basic-Stack action.

] embedded within concept expression C interpreted X variable2. informal

meaning concept temporal existential quantification understood
following examples action domain.
:
Basic-Stack = 3(x ) (x ])(] ). ((?BLOCK : OnTable)@x u (?BLOCK : OnBlock)@y )

Figure 5 shows temporal dependencies intervals concept Basic-Stack
holds. Basic-Stack denotes, according definition (a terminological axiom),
action occurring interval involving ?BLOCK OnTable
OnBlock. ] interval could understood occurring time action type
defined: referring within definition explicit way temporally relate states
actions occurring world respect occurrence action itself.
temporal constraints (x ]) (] y) state interval denoted x meet
interval denoted ] { occurrence interval action type Basic-Stack {
] meet y. parametric feature ?BLOCK plays role formal parameter
action, mapping individual action type Basic-Stack block stacked,
independently time. Please note that, whereas existence identity ?BLOCK
action time invariant, qualified differently different intervals time,
e.g., ?BLOCK necessarily OnTable interval denoted x.
Let us comment introduction explicit temporal variables. absence
explicit temporal variables would weaken temporal structure concept since arbitrary
relationships two intervals could represented anymore.
example, implicit intervals possible describe situation
two concept expressions, say C D, hold two meeting intervals (say x, y) first
interval starting second finishing reference interval (i.e., temporal pattern
(x meets y)(x starts ])(y finishes ]) cannot represented). precisely, possible
represent temporal relations two intervals derivable
temporal propagation constraints imposed pairs variables. explicit
variables go general thrust Description Logics, gained expressive power
together observation variables limited temporal part
language main motivations using them. However, easy drop
limiting temporal expressiveness proposed Bettini (1997) (see Section 9).
assertion type Basic-Stack(i; a) states individual action
type Basic-Stack occurred interval i. Moreover, assertion implies
related ?BLOCK , say b, type OnTable interval j , meeting i,
type OnBlock another interval l, met i.
2. Since concept implicitly temporally qualified special ] variable, necessary
explicitly qualify concepts ].

473

fiArtale & Franconi

(s)E = fh[u; v]; [u1 ; v1 ]i 2 T<? T<? j u = u1 ^ v < v1 g
(f )E = fh[u; v]; [u1 ; v1 ]i 2 T<? T<? j v = v1 ^ u1 < ug
(mi)E = fh[u; v]; [u1 ; v1 ]i 2 T<? T<? j u = v1 g
: : : (meaning Allen temporal relations)
E
(R , ) = R E [ E
hX; TciE = fV : X 7! T<? j 8(X (R) ) 2 Tc. hV (X ); V (Y )i 2 g:
Figure 6: temporal interpretation function.

i; a) =) 9b. ?BLOCK(a; b) ^ 9j; l. (OnTable(j; b) ^ OnBlock(l; b) ^
m(j; i) ^ m(i; l))

Basic-Stack(

individual action object conceptual domain associated relevant
properties { states { world affected individual action via bunch
features; moreover, temporal relations constrain time intervals imposing ordering
change states world.

4.2 Semantics

Section, Tarski-style extensional semantics TL-F language given,
formal definition subsumption recognition reasoning tasks devised.
Assume linear, unbounded, dense temporal structure = (P ; <), P
set time points < strict partial order P . structure, given
interval X temporal relation R, always possible find interval
(X (R) ). assumption linear time { means two points t1
t2 t1 t2 set points ft j t1 t2 g totally ordered { fits intuition
nature time, pair [t1 ; t2 ] thought closed interval
points t1 and: t2 . interval set structure defined set T<?
closed intervals [u; v] = fx 2 P j u x v; u 6= vg .
primitive interpretation =: hT<? ; ; consists set T<? (the interval set
selected temporal structure ), set (the domain ), function (the
primitive interpretation function ) gives meaning atomic concepts, features
parametric features:

AI T<? ;

f : (T<? ) partial
7,! ;

?gI : partial
7,!

Atomic parametric features interpreted partial functions; differ atomic
features independent time.
order give meaning temporal expressions present generic concept expressions, Figure 6 defines temporal interpretation function. temporal interpretation
function E depends temporal structure . labeled directed graph hX; Tci
{ X set variables representing nodes, Tc set temporal constraints representing arcs { called temporal constraint network. interpretation
474

fiA Temporal Description Logic Reasoning Actions Plans

AIV ;t;H = fa 2 j ht; ai 2 AI g = AIt

>IV ;t;H = = >I
(C u D)IV ;t;H = CVI ;t;H \ DVI ;t;H
(p # q)IV ;t;H = fa 2 dom pIt \ dom qtI j pIt (a) = qtI (a)g = (p # q)It
(p : C )IV ;t;H = fa 2 dom pIt j pIt (a) 2 CVI ;t;Hg

(C @X )IV ;t;H = CVI ;V (X );H
(C [Y ]@X )IV ;t;H = CVI ;t;H[fY 7!V (X )g
(3(X ) Tc. C )IV ;t;H = fa 2 j 9W . W 2 hX; TciEH[f]7!tg ^ 2 CWI ;t;; g
ftI = f^t : partial
7,! j 8a. (a 2 dom f^t $ ht; ai 2 dom f ) ^
f^t (a) = f (t; a)
(p q)It = pIt qtI
?gtI = ?gI
Figure 7: interpretation function.
temporal constraint network set variable assignments satisfy temporal
constraints. variable assignment function V : X 7! T<? associating interval value
temporal variable. temporal constraint network consistent admits non empty
interpretation. notation, hX; TciEfx1 7!t1 ;x2 7!t2 ;:::g , used interpret concept expressions,
denotes subset hX; TciE variable xi mapped interval value ti .
possible interpret generic concept expressions. Consider equations
introduced Figure 7. interpretation function IV ;t;H, based variable assignment
V , interval set constraints H = fx1 7! t1; : : :g assignments inner
variables, extends primitive interpretation function way equations
Figure 7 satisfied. Intuitively, interpretation concept CVI ;t;H set
entities domain type C time interval t, assignment
free temporal variables C given V { see (C @X )IV ;t;H { constraints
assignment variables scope outermost temporal quantifiers given H.
Note that, H interprets variable renaming due temporal substitutive qualifier {
see (C [Y ]@X )IV ;t;H { takes effect choice variable assignment,
equation (3(X ) Tc. C )IV ;t;H shows.
absence free variables concept expression { exception ]{
notational simplification natural interpretation function CtI ; equivalent
interpretation function CVI ;t;H V V (]) = H = ; introduced.
set interpretations fCVI ;t;Hg obtained varying ; V ; fixed H maximal wrt set
inclusion H = ;, i.e., set natural interpretations includes set interpretations
fixed H. fact, since H represents constraint assignment variables,
unconstrained set larger one. Note that, feature interpretation natural
one used since admitted temporally qualify them.
475

fiArtale & Franconi

]
]

Boil-Spaghetti

x

Make-Spaghetti

-

Boil

-

Figure 8: Temporal dependencies definition Boil-Spaghetti plan.
interpretation satisfies terminological axiom =: C iff AIt = CtI , every t.
concept C subsumed concept (C v D) CtI DtI every interpretation
every interval t. interpretation model concept C CtI 6= ; t.
concept model, satisfiable, otherwise unsatisfiable.
TL-F concept expression always satisfiable, proviso temporal
constraints introduced existential quantifiers consistent. latter condition
easily checked reduction concept normal form
minimal temporal network (see Section 11, definition 6.5) computed.
interesting note relations s, f, mi really necessary,
possible express temporal relationship two distinct intervals using
three relations transpositions si, fi, (Halpern & Shoham, 1991). following
equivalences hold:

3x (x ]). C @x 3xy (y mi ])(x mi y). C @x
3x (x ]). C @x 3xy (y ])(x f y). C @x
3x (x ]). C @x 3xy (y ])(x y). C @x
assign meaning ABox axioms, temporal interpretation function E extended
temporal intervals iE element T<? 2 OT . semantics
assertions following: C (i; a) satisfied interpretation iff aI 2 CiIE ; p(i; a; b)
satisfied iff pIiE (aI ) = bI ; ?g(a; b) satisfied iff ?gI (aI ) = bI ; R(i; j )
satisfied iff hiE ; j E 2 . Given knowledge base , individual said
instance concept C interval j= C (i; a).
able give semantic definition reasoning task already called
specific plan recognition respect plan description. inference service
computes individual action/plan instance action/plan type certain
interval, i.e., task known instance recognition Description Logic community.
Given knowledge base , interval i, individual concept C , instance
recognition problem test whether j= C (i; a).

5. Action plan representation: two examples
action description represents world state may evolve relation possible
occurrence action itself. plan complex action: described means
temporally related world states simpler actions. following introduces examples
action plan representations two well known domains, cooking domain (Kautz,
476

fiA Temporal Description Logic Reasoning Actions Plans

z

Make-Marinara

x


-

Make-Spaghetti

-

-

Boil-Spaghetti
Boil

w

-

Put-Together-SM

Figure 9: Temporal dependencies definition Assemble-Spaghetti-Marinara.
1991; Weida & Litman, 1992) block world (Allen, 1991), aim showing
applicability framework.

5.1 Cooking Domain
Let us introduce plan Boil-Spaghetti:
:
Boil-Spaghetti = 3x (x b ]). (Make-Spaghetti@x u Boil)
Figure 8 shows temporal dependencies intervals concept Boil-Spaghetti holds. definition employs ] interval denote occurrence time
plan itself; way, possible describe different actions states world
concurring definition plan related it. variable ]
explicitly present definition Boil-Spaghetti, instead generic variable:
Boil action take place time plan itself, Make-Spaghetti
occurs it.
definition plan reused within definition plans exploiting
full compositionality language. plan defined Boil-Spaghetti used
definition Assemble-Spaghetti-Marinara:
:
Assemble-Spaghetti-Marinara = 3(y z w) (y b w)(z b w).
(Boil-Spaghetti@y u
Make-Marinara@z u
Put-Together-SM@w)
case, precise temporal relations nodes two corresponding temporal
constraint networks asserted: e.g., action Put-Together-SM takes place strictly
Boil action (Figure 9). Observe occurrence interval plan Assemble-Spaghetti-Marinara appear Figure temporally related
interval.
plan subsuming Assemble-Spaghetti-Marinara general plan defined below, Prepare-Spaghetti, supposing action Make-Sauce subsumes Make-Marinara.
means among individual actions type Prepare-Spaghetti
individual actions type Assemble-Spaghetti-Marinara:
:
Prepare-Spaghetti = 3 (y z ) (). (Boil-Spaghetti@y u Make-Sauce@z )
477

fiArtale & Franconi

]
- w

Stack(OBJ1, OBJ2)

Clear-Block(OBJ1)

v

- z
-

Holding-Block(OBJ1) Clear-Block(OBJ1)

Clear-Block(OBJ2)

ON(OBJ1, OBJ2)

x

Figure 10: Temporal dependencies definition Stack action.
However, note Boil-Spaghetti subsume Prepare-Spaghetti, even
conjunct definition latter. could better explained observing
definition Prepare-Spaghetti plan expanded:
:
Prepare-Spaghetti = 3 (x z ) (x b ). (Make-Spaghetti@x u Boil@y u
Make-Sauce@z )
Then, Boil action occurs interval { different occurring
time Prepare-Spaghetti { effect binding Boil-Spaghetti temporal variable y. contrary, definition Boil-Spaghetti Boil action takes place necessarily time. Subsumption Prepare-Spaghetti Boil-Spaghetti
fails since different temporal relations actions describing two plans
plans specified. particular, observe Boil-Spaghetti plan denotes
narrower class plan expression
3(x y) (x b y). (Make-Spaghetti@x u Boil@y)
subsumes Prepare-Spaghetti Boil-Spaghetti itself.

5.2 Blocks World Domain

example expressive power temporal language, shown
represent Stack action blocks world, detailed way
previous simple Basic-Stack action used clarifying example. Thus stacking action
involves two blocks, clear beginning; central part
action consists grasping one block; end, blocks one top another,
bottom one longer clear (Figure 10).
representation borrows Rat Description Logic (Heinsohn, Kudenko, Nebel,
& Profitlich, 1992) intuition representing action parameters means partial
functions mapping action involved action parameter (see Section 9).
language, functions called parametric features. example, action Stack
parameters ?OBJECT1 ?OBJECT2, representing sense objects
involved action independently time. So, assertion \?OBJECT1(a; block-a)",
block-a denotes first object involved action interval. hand,
assertion involving (non-parametric) feature, e.g., \ON(i; block-a; block-b)",
imply anything truth value intervals i.
concept expression, defines Stack action, makes use temporal qualified
concept expressions, including feature selections agreements: expression (?OBJECT2 :
Clear-Block)@x means second parameter action Clear-Block
478

fiA Temporal Description Logic Reasoning Actions Plans

interval denoted x; (?OBJECT1 # ?OBJECT2)@y indicates
interval object ?OBJECT1 placed ?OBJECT2. formal definition
action Stack is:
:
Stack = 3(x z v w) (x ])(y mi ])(z mi ])(v ])(w f ])(w mi v ).
((?OBJECT2 : Clear-Block)@x u (?OBJECT1 # ?OBJECT2)@y u
(?OBJECT1 : Clear-Block)@v u (?OBJECT1 : Holding-Block)@w u
(?OBJECT1 : Clear-Block)@z )
defined concept state properties prerequisites
stacking action properties must true whenever action succeeds.
action intuitively states ?OBJECT1 ?OBJECT2 situation
objects clear start action. Note world states described
intervals denoted v; w; z result action grasping previously clear block:
:
Grasp = 3(x w z ) (x ])(w f ])(w mi x)(z mi ]).
((?OBJECT1 : Clear-Block)@x u (?OBJECT1 : Holding-Block)@w u
(?OBJECT1 : Clear-Block)@z )
Stack action redefined making use Grasp action:
:
Stack = 3(x u v ) (x ])(y mi ])(u f ])(v ]).
((?OBJECT2 : Clear-Block)@x u (?OBJECT1 # ?OBJECT2)@y u
(Grasp[x]@v)@u)
temporal substitutive qualifier (Grasp[x]@v) renames within defined Grasp action
variable x v way making coreference two temporal variables,
temporal constraints peculiar renamed variable x inherited
substituting interval v. Furthermore, effect temporally qualifying grasping action
u ] variable associated grasping action { referring occurrence
time action { bound interval denoted u. binding
occurrence time grasping action, ] variable grasping action ]
variable stacking action denote different time intervals, grasping action
occurs interval finishing occurrence time stacking action.
shown series outside observations action recognition
performed { i.e., task called specific plan recognition respect plan description.
following ABox describes situation blocks clear, grasped and/or
other, generic individual action taking place time interval ia
blocks block-a block-b parameters:

?OBJECT1(a; block-a); ?OBJECT2(a; block-b);
o(i1 ; ia ); Clear-Block(i1 ; block-a); fi(i2 ; ia ); Clear-Block(i2 ; block-b);
mi(i3 ; i1 ); f (i3 ; ia ); Holding-Block(i3 ; block-a);
mi(i4 ; ia ); Clear-Block(i4 ; block-a); mi(i5 ; ia ); ON(i5 ; block-a; block-b)
system deduces that, context knowledge base composed
ABox definition Stack concept TBox, individual action
type Stack time interval ia , i.e., j= Stack(ia ; a).
479

fiArtale & Franconi

C @X u D@X
(C @X1 )@X2
(C @X1 u D)@X2
C u 3(X ) Tc.

!
!
!
!

(C u D)@X
C @X1
C @X1 u D@X2
3(X ) Tc. (C u D)
C doesn't contain free variables

3(X )Tc1 .(C u


3(Y ) Tc2 . [Y1 ]@X1 : : : [Yp ]@Xq @X ) ! 3(X ][Y1 =X1 ]:::[Yp=Xq ] )Tc1 [ Tc2+[]=X] .(C u D+ @X )
doesn't contain existential temporal quantifiers
p : (q : C ) ! (p q) : C
p : (C u ) ! p : C u p :
p : (q1 # q2 ) ! p q1 # p q2

,

Prescriptions: X ][Y1 =X1 ]:::[Yp=Xq ] returns union two sets variables X ,
occurrence Y1 ; : : : ; Yp substituted X1 ; : : : ; Xq , respectively, elements occurring
X renamed fresh new identifiers. Z+ intended expression Z
substitution renaming taken place. condition last rule forces application start
last nested existential temporal qualified concept.

Figure 11: Rewrite rules transform arbitrary concept existential concept.

6. Calculus TL-F
Section presents calculus deciding subsumption temporal concepts
Description Logic TL-F . calculus based idea separating inference
temporal part inference Description Logic part. achieved first
looking normal form concepts. Concept subsumption temporal language
reduced concept subsumption non-temporal concepts subsumption
temporal constraint networks.

6.1 Normal Form
Every TL-F concept expression reduced equivalent existential concept
form: 3(X ) Tc. (Q0 u Q1 @X1 u : : : u Qn@Xn ), Q non-temporal concept, i.e.,
element language F . concept existential form seen conceptual
temporal constraint network, i.e., labeled directed graph hX; Tc; Q@X arcs

labeled set arbitrary temporal relationships { representing disjunction {
nodes labeled non-temporal concepts and, node X , temporal relation
(X = X ) implicitly true. Moreover, since normalized concepts contain free
variables substitutive qualifiers, following natural interpretation function (see
Section 4.2) used.

Proposition 6.1 (Equivalence EF) Every concept C reduced linear time
equivalent existential concept (ef C ), exhaustively applying set rewrite
rules Figure 11.
480

fiA Temporal Description Logic Reasoning Actions Plans

Procedure

hX; Tci; y):

Covering(

, ;;
, ;;
Z = fz 2 X j (z (=; : : :) y) 2 Tcg;
8s 2 }(Z )

j j 2 graph hX; Tc obtained deleting \=" temporal relation

mid
result

node nodes inconsistent
mid
, mid [ fsg;

8s 2 mid
:9t 2 mid.
result
, result [ fsg;
return

result.

Figure 12: Procedure computes covering.
Note (ef C ) makes explicit possible chains features reducing nontemporal concept Q conjunction atomic concepts, feature selections restricted
atomic concepts feature agreements { i.e., Q feature term expression (Smolka,
1992).
normalization proceeds discovering possibles interactions nodes
intention making explicit implicit information. crucial temporal interaction occurs node always coincident set nodes every possible
interpretation temporal network.
Definition 6.2 (Covering) Given temporal constraint network hX; Tci, let 2 X
Z = fz1 ; z2 ; : : : ; zp g X , p 1, 62 Z . Z Covering 8V 2 hX; TciE ,
V (y) 2 fV (z1 ); V (z2 ); : : : ; V (zp)g W Z , W covering y. Z = ;,
called uncovered, otherwise said covered Z .
Proposition 6.3 (Covering procedure) Given temporal constraint network hX; Tci
minimal form (see, e.g., (van Beek & Manchak, 1996)) node 2 X procedure
described Figure 12 returns possible coverings size 2.
idea behind covering whenever set nodes fz1 ; z2 ; : : : ; zp g covering
disjunctive concept expression (Qz1 : : : Qzp ) conjunctively added
concept expression Qy . Actually, since TL-F concept disjunction allowed
sucient add node Least Commom Subsumer (lcs) (Qz1 : : : Qzp )
defined below.
Definition 6.4 (lcs) Let Q1; : : : ; Qn; Q; C F concept expressions. Then, concept
Q = lcsfQ1 ; : : : ; Qn g that: Q1 v Q ^ : : : ^ Qn v Q C
Q1 v C ^ : : : ^ Qn v C ^ C < Q.
Given concept existential form, temporal completion constraint network
computed described below.
Definition 6.5 (Completed existential form) temporal completion concept
existential form { Completed Existential Form, CEF { obtained sequentially applying following steps:
481

fiArtale & Franconi

(closure) transitive closure Allen temporal relations conceptual

temporal constraint network computed, obtaining minimal temporal network (see,
e.g., (van Beek & Manchak, 1996)).

(= collapsing) equality temporal constraint, collapse equal nodes
applying following rewrite(rule:
3(X n fxj g) Tc[xj =xi]. Q[xj =xi ] xi 6= xj xj 6= ].
3(X ) Tc (xi = xj ). Q ! 3
(X n fxi g) Tc[xi=]] . Q[xi =]] xi 6= xj xj = ].
apply exhaustively first rule Figure 11.

(covering) 2 X let compute covering = fZ 1; : : : ; Z ng following
procedure showed proposition 6.3. Whenever covering empty, translate
Qy applying following rewrite rule: Qy ! Qy ui=1:::n lcsfQi1 ; : : : ; Qim g Z =
fzi1 ; : : : ; zim g, Qij @zij 2 hX; Tc; Q@X i.

(parameter introduction) New information added node pres-

ence parameters, following rules show. ; symbol intended that,
time concept expression left hand side appears node
temporal constraint network, possibly conjoined concepts, right
hand side represents concept expression must conjunctively added
nodes; square brackets point optional parts; letters f (?f ) g (?g),
possibly subscripts, denote atomic (parametric) features p q stand
generic features.
?g1 : : : ?gn [ f [ p]] : C
?g1 : : : ?gn [ f [ p]] # g [ q]
?g1 : : : ?gn # ?f1 : : : ?fm
?g1 : : : ?gn g [ p] # ?f1 : : : ?fm [ f [ q]]

;
;
;
;

?g1 : : : ?gn : >.
?g1 : : : ?gn : >.
?g1 : : : ?gn # ?f1 : : : ?fm .
?g1 : : : ?gn : > u
?f1 : : : ?fm : >.

Proposition 6.6 (Equivalence CEF) Every concept existential form reduced equivalent completed existential concept.

covering parameter introduction steps computed independently
=-collapsing step conjoining resulting concept expressions. Observe
that, obtain completed existential concept, steps normalization procedure
require linear time exception computation transitive closure
temporal relations, covering step. steps involve NP-complete temporal
constraint problems (van Beek & Cohen, 1990). However, possible devise reasonable
subsets Allen's algebra problem polynomial (Renz & Nebel, 1997).
relevant properties concept CEF admissible interval temporal
relations explicit concept expression node refinable without
changing overall concept meaning; stated following proposition.
Proposition 6.7 (Node independence CEF) Let hX; Tc; Q@X conceptual temporal constraint network completed form (CEF); then, Q 2 Q
482

fiA Temporal Description Logic Reasoning Actions Plans

F concept expressions C C 6w Q, exists interpretation
hX; Tc; (Q u C )@X iIt 6= hX; Tc; Q@X iIt , interval t.

Proof. proposition states information node CEF independent
information nodes. fact, hX; Tc; (Q u C )@X iIt = hX; Tc; Q@X iIt
concept expression one node implies new information node. Two cases
distinguished.
i) Covered Nodes. (= collapsing) rule (covering) rule provide restrict
covered node specific F concept expression. Indeed, (= collapsing) rule
provides collapsing two contemporary nodes conjoining concept expressions
them. hand, (covering) rule adds covered node specific
F concept expression subsumes disjunctive concept expression implicitly
true covered node. Note that, thanks (Closure) rule, possible equal
temporal relations made explicit. two normalization rules cover possible
cases temporal interactions nodes.
ii) coincident nodes. Every time-invariant information spread nodes.
parametric features > concept time-invariant semantics: timeinvariant concept expressions >, ?g1 : : : ?gn : >, ?g1 : : : ?gn # ?f1 : : : ?fm ,
n; 1, arbitrary conjunction terms. (parameter introduction) rule
captures possible syntactical cases completion concerning time-invariant concept
expressions. induction syntax, proven adding node
concept expression changes overall interpretation.
2
last normalization procedure eliminates nodes redundant information.
final normalization step ends concept essential graph form,
normal form used checking concept subsumption.
Definition 6.8 (Essential graph) subgraph CEF conceptual temporal constraint network = hX; Tc; Q@X obtained deleting nodes labeled timeinvariant concept expressions { exception ] node { called essential graph
: (ess ).
Proposition 6.9 (Equivalence essential graph) Every concept completed existential form reduced linear time equivalent essential graph form.

Theorem 6.10 (Equivalence normal form) Every concept expression reduced

equivalent essential graph form. polynomial fragment Allen's algebra
adopted, reduction takes polynomial time.
example, normal form shown { i.e., essential graph { previously
introduced Stack action (see Section 5.2):
:
Stack = 3(x v w z )(x ])(y mi ])(z mi ])(w f ])(v ])(y mi x)(z mi x)(w f x)
(v (o; d; s) x)(z (=; s; si) y)(w y)(v b y)(w z )(v b z )(w mi v).
((?OBJECT2 : Clear-Block u ?OBJECT1 : >)@x u
(?OBJECT1 # ?OBJECT2)@y u
(?OBJECT1 : Clear-Block u ?OBJECT2 : >)@v u
(?OBJECT1 : Hold-Block u ?OBJECT2 : >)@w u
(?OBJECT1 : Clear-Block u ?OBJECT2 : >)@z )
483

fiArtale & Franconi

example, essential graph CEF Stack since redundant
nodes.

6.2 Computing Subsumption

concept subsumes another one case every possible instance second
instance first, every time interval. Thanks normal form, concept subsumption temporal language reduced concept subsumption non-temporal
concepts subsumption temporal constraint networks. similar general procedure first presented (Weida & Litman, 1992), language non-temporal
concepts less expressive { include features parametric features.
compute subsumption non-temporal concepts { may possibly include
lcs concepts { refer (Cohen, Borgida, & Hirsh, 1992). following, write
\wF " subsumption non-temporal F concepts taking account lcs concepts.
Definition 6.11 (Variable mapping) variable mapping total function :
X 1 7! X 2 M(]) = ]. write M(X ) intend fM(X ) j X 2 X g, M(Tc)
intend f(M(X ) (R) M(Y )) j (X (R) ) 2 Tcg.

Definition 6.12 (Temporal constraint subsumption) temporal constraint (X1 (R1 )Y1)
said subsume temporal constraint (X2 (R2 )Y2 ) generic variable mapping M,
written (X1 (R1 )Y1 ) wM (X2 (R2 ) Y2 ), M(X1 ) = X2 , M(Y1 ) = Y2 (R1 )E (R2 )E
every temporal interpretation E .
Proposition 6.13 (TC subsumption algorithm) (X1 (R1 )Y1) wM (X2 (R2 )Y2)
M(X1 ) = X2 , M(Y1 ) = Y2 disjuncts R1 superset disjuncts
R2 .

Proof. Follows observation 13 temporal relations mutually disjoint
union covers whole interval pairs space.
2

Definition 6.14 (Temporal constraint network subsumption) temporal constraint
network hX 1 ; Tc1 subsumes temporal constraint network hX 2 ; Tc2 variable mapping : X 1 7! X 2 , written hX 1 ; Tc1 wM hX 2 ; Tc2 i, hM(X 1 ); M(Tc1 )iE hX 2 ; Tc2 iE
every temporal interpretation E .
Proposition 6.15 (TCN subsumption algorithm) hX 1; Tc1 wM hX 2 ; Tc2i iff,
computing temporal transitive closure, exists variable mapping : X 1 7! X 2
X1i ; Y1j 2 X 1 exist X2m ; Y2n 2 X 2 satisfy (X1i (R1i;j ) Y1j ) wM
(X2m (R2m;n ) Y2n ).

Proof. \( " Since definition 6.12 (X1i (R1i;j ) Y1j ) wM (X2m (R2m;n ) Y2n ) implies
(R1i;j )E (R2m;n )E every E , then, definition interpretation temporal
constraint network, easy see assignment variables V interpretation
hX 2 ; Tc2 assignment interpretation hM(X 1 ); M(Tc1 )i.
\) " Suppose one able find mapping; then, hypothesis,
possible variable mapping exists i; j R1i;j superset R2m;n .
484

fiA Temporal Description Logic Reasoning Actions Plans

Since, assumption, temporal constraint networks minimal, temporal relation
R2m;n cannot restricted. So, variable mapping temporal interpretation E , build assignment V hV (X2m ); V (X2n )i 2 (R2m;n )E
hV (X1i ); V (X1j )i 62 (R1i;j )E . Now, extend assignment V way
V 2 (hX 2; Tc2 i)E V 62 (hM(X 1 ); M(Tc1)i)E . contradicts assumption
2
hX 1; Tc1 wM hX 2; Tc2 i.

Definition 6.16 (S-mapping) s-mapping conceptual temporal constraint network hX 1 ; Tc1 ; Q@X 1 conceptual temporal constraint network hX 2 ; Tc2 ; Q@X 2
variable mapping : X 1 7! X 2 non-temporal concept labeling node
X 1 subsumes non-temporal concept labeling corresponding node (X 1 ),
hX 1; Tc1 wS hX 2; Tc2i.
algorithm checking subsumption temporal concept expressions reduces
subsumer subsumee essential graph form, looks s-mapping essential graphs exhaustive search. prove completeness overall
subsumption procedure showed introduction lcs's preserves subsumption. model-theoretic characterization lcs given showing
property. Let's start build Herbrand model F concept. Let C 0(x) denote
first order formula corresponding concept C (see proposition 2.1), functionality features expressed set formul F . syntax induction easy
show C 0 (x) existentially quantified formula one free variable. Moreover,
matrices formula conjunction positive predicates. F [ fC 0 (x)g logically
equivalent
F [ fC 00 (x)g functionality axioms allow map every subformula
V
00
9y.Ff (x; y) 9!y.Ff (x; y). C (x) existential quantifiers
C 0 (x) (which come first order conversion features) replaced 9! quantifiers.
Now, F [ fC 000 (a)g { constant substituting free variable x C 000 (a)
obtained skolemizing 9! quantified variables { set definite Horn clauses.

Definition 6.17 (Herbrand model) Let C F concept expression. define
Minimal Herbrand Model HC Minimal Herbrand Model mentioned
set definite Horn clauses F [ fC 000 (a)g.
Lemma 6.18 (F concept subsumption) Let C; F concept expressions, HC ; HD
minimal Herbrand models obtained skolemizing first order set F [fC 000 (a); D000 (a)g.
Then, C v iff HD HC .
Proof. C v iff F [ fC 0 (x)g j= D0 (x), iff F [ fC 00 (x)g j= D00 (x), C 00 D00
obtained applying functionality axioms set fC 0 (x); D0 (x)g (i.e., uni-

fying variables functional predicates) replacing existential
quantifiers 9! quantifiers. Now, C 000 (x) D000 (x) obtained skolemizing
9! quantified variables following way: let C 00(x) = 9!y1; : : : ; yn(x; y1 ; : : : ; yn) let
D00 (x) = 9!y1 ; : : : ; yk ; z1 ; : : : ; zm (x; y1 ; : : : ; yk ; z1 ; : : : ; zm ), 0 k n, skolemize
formula: = 9!y1 ; : : : ; yn ; z1 ; : : : ; zm (x; y1 ; : : : ; yn ) ^ (x; y1 ; : : : ; yk ; z1 ; : : : ; zm ),
let 0 (x) indicate skolemized form. Then, C 000 (x) = 0 (x) D000 (x) = 0 (x). Now,
since every existential quantification C 00 (x); D00 (x) type 89! thesis true
485

fiArtale & Franconi

iff F [ fC 000 (a)g j= D000 (a), constant substituting free variable x (see (van
Dalen, 1994)). Now, showed lemma 6.17, C 000 (a) D000 (a) minimal Herbrand models HC ; HD verify lemma hypothesis. Then, F [ fC 000 (a)g j= D000 (a) iff
HD HC .
2
able give model-theoretic characterization lcs crucial
prove subsumption-preserving property.
Lemma 6.19 (lcs model property) Let Q1; : : : ; Qn F concept expressions, HQ1 ;
: : : ; HQn minimal Herbrand models obtained skolemizing first order set F [
fQ0001 (a); : : : ; Q000n (a)g. Then, Q = lcsfQ1 ; : : : ; Qn g iff HQ = HQ1 \ : : : \ HQn .
Proof. First all, let show HQ minimal Herbrand model concept Q
language F . Every HQi seen rooted directed acyclic graph nodes
labelled (possible empty) set atomic concepts arcs atomic features
equality constraints nodes correspond features agreement. Whithout loss
generality let us consider case HQ = HQ1 \ HQ2 . sucient show
HQ rooted directed acyclic graph. Let root HQ1 ; HQ2 ,
proved induction (ai,1 ; ai ) 2 HQ (where first order translation
feature, ai,1 ; ai obtained result skolemization process, a0 = a)
fF1 (a; a1 ); : : : ; (ai,1; ai )g HQ. case = 1 trivial. Let > 1. Now, (ai,1 ; ai) 2
HQ iff Fi(ai,1 ; ai ) 2 HQ1 \ HQ2 . ai,1 uniquely defined skolem function
fFi,1 (where, function symbols fFi newly generated feature
skolemization process). Then, (ai,1 ; ai ) 2 HQ1 \ HQ2 iff (ai,1 ; fFi,1 (ai )) 2 HQ1 \ HQ2
iff Fi,1 (ai,2 ; fFi,1 (ai )) 2 HQ1 \ HQ2 . thesis true induction.
Let us prove \(" direction. Suppose absurd F concept C
that: Q1 v C ^ Q2 v C ^ C < Q. Then, Q1 v C iff HC HQ1 , Q2 v C , iff
HC HQ2 . HC HQ1 \ HQ2 , i.e., HC HQ. Q v C contradicts
hypothesis.
\)" direction proved analogous considerations.
2

Proposition 6.20 (lcs subsumption-preserving property) Let A; B; C; F concepts, u (B C ) v iff u lcsfB; C g v D.
Proof. u (B C ) v iff u B v u C v D. Now, u B v iff F [
fA000 (a); B 000 (a)g j= D000(a) iff HA [ HB j= D000 (a) iff HD HA [ HB . reasons,
u C v iff HD HA [ HC . then, HD HA [ HB HD HA [ HC , i.e.,
HD HA [ (HB \ HC ), i.e., HD HA [ HlcsfB;C g . But, HD HA [ HlcsfB;C g iff
u lcsfB; C g v D.
2

following theorem provides sound complete procedure compute subsumption. completeness proof takes account temporal structure dense
unbounded. allows us introduce new node conceptual temporal constraint
network without changing meaning. Remember that, redundant nodes,
time-invariant information holds.
Theorem 6.21 (TL-F concept subsumption) concept C1 subsumes concept C2 iff
exists s-mapping essential graph C1 essential graph C2 .
486

fiA Temporal Description Logic Reasoning Actions Plans

Proof. Let T1 = hX 1 ; Tc1 ; Q@X 1 essential graph C1 , T2 = hX 2 ; Tc2 ; Q@X 2
essential graph C2 .
\( " (Soundness). Follows fact essential graph form logically equivalent starting concept, soundness procedures computing
TCN subsumption (proposition 6.15) subsumption non-temporal
concepts (Cohen et al., 1992).
\) " (Completeness). Suppose s-mapping exist. Two main cases
distinguished.
i) mapping hX 1 ; Tc1 wM hX 2 ; Tc2 i. adding redundant
nodes T2 , equivalent conceptual temporal constraint network T2 = hX 2 ; Tc2 ; Q@X 2
may obtained. Let us consider extended network
way exists


variable mapping hX 1 ; Tc1 wM hX 2 ; Tc2 i. Now, possible ,
node X1i 2 X 1 (X1i ) = X2j X2j 62 X 2 . Now, Q1i 6wF Q2j , since X2j
cannot coincide nodes X 2 neither covering otherwise hypothesis
mapping exist would contradicted. proposition 6.7 Q2j
time-invariant node, whereas Q1i since T1 essential graph. Then, although
construction allows existence unique V 3 networks (follows
proposition 6.15), possible build instance T2 instance T1 .
ii) possible mapping hX 1 ; Tc1 wM hX 2 ; Tc2 always
two nodes X1i X2j M(X1i ) = X2j Q1i 6wF Q2j . Now, concept expression Q2j cannot refined (looking subsumption relationship Q1i ) adding
F concept since proposition 6.7 would change overall interpretation.
hand, lcs introduction { would substitute specific concept disjunction implicitly presents node covering { subsumption-invariant
concept substitution, showed lemma 6.20.
cases contradict assumption T1 subsumes T2 .
2
6.2.1 Complexity Subsumption

shown checking subsumption TL-F concept expressions essential graph form NP-complete problem. Therefore, polynomial reduction
NP-complete problem deciding whether graph contains isomorphic subgraph presented. shown subsumption computation, proposed theorem 6.21,
done non-deterministic algorithm takes polynomial time size
concepts involved. First let us consider complexity computing subsumption
non-temporal concepts.

Lemma 6.22 (F subsumpion complexity) Let C; F concept expressions
contain lcs's. Then, checking whether C vF takes polynomial time.
Proof. See (Cohen et al., 1992).
2
problem subgraph isomorphism brie recalled. Given two graphs, G1 =
(V1 ; E1 ) G2 = (V2 ; E2 ), G1 contains subgraph isomorphic G2 exists
3. Since subsumption computed respect fixed evaluation time, V maps different occurrences
] interval; justifies choice M(]) = ].
487

fiArtale & Franconi

subset vertices V 0 V1 subset edges E 0 E1 j V 0 j=j V2 j,
j E 0 j=j E2 j, exists one-to-one function f : V2 7! V 0 satisfying fu; vg 2 E2 iff
(u); f (v)g 2 E 0.
Given
graph G = (V; E ), V = fv1 ; : : : ; vn g associate temporal concept expression:
:
C = 3(v1 ; : : : ; vn ) : : : (vi (b; a) vj ) : : : . (A@v1 u : : : u A@vn), atomic concept
fvi ; vj g 2 E . transformation allows us prove problem subgraph
isomorphism reduced subsumption temporal concepts.
Proposition 6.23 Given two graphs G1 G2, G1 contains subgraph isomorphic G2
iff C2 w C1 , C1 C2 corresponding temporal concepts expressions.
Proof. temporal network edges labeled (before _ after) relation always
consistent, minimal non-directed4 (Gerevini & Schubert, 1994). Then, temporal
concept essential graph form. proof easily follows since, every time G2
isomorphic subgraph G1 one-to-one function f s-mapping C2
C1 , true C2 w C1 . hand, s-mapping gives rise
subsumption one-to-one isomorphism G2 G1 .
2

Theorem 6.24 (NP-hardness) Concept subsumption TL-F concept expressions
normal form NP-hard problem.

Proof. Follows proposition 6.23 reduction clearly polynomial.
NP-completeness proven.

2

Theorem 6.25 (NP-completeness) Concept subsumption TL-F concept expressions normal form NP-complete problem.

Proof. prove NP-completeness necessary show proposed calculus
solved nondeterministic algorithm takes polynomial time. Now, given two
temporal concepts, T1 T2 , essential graph form, let j X 1 j= N1 j X 2 j= N2 .
Then, check whether T1 w T2 , algorithm guesses one N2N1 variable mapping
T1 T2 verifies whether s-mapping, too. last step done
deterministic polynomial time since, given mapping M, possible determine whether
hX 1; Tc1 wM hX 2; Tc2i checking N1(N1 , 1)=2 edges looking subsumption
corresponding temporal relations (solved set inclusion procedure);
N1 non-temporal concept subsumptions computed polynomial time.
2

7. Extending Propositional Part Language

propositional part temporal language extended powerful,
still decidable, Description Logic. possible either add full disjunction,
temporal non-temporal levels (TLU -FU ), propositionally complete
language non-temporal level (TL-ALCF ).
Please note languages possible express full negation,
particular negation existential temporal quantifier. crucial,
4. (vi (b; a) vj ) (vj (b; a) vi ), too.

488

fiA Temporal Description Logic Reasoning Actions Plans

(C D)@X
p : (C )
(C1 C2 ) u
3(X ) Tc. (C D)

!
!
!
!

C @X D@X
p:Ctp:D
(C1 u D) (C2 u D)
3(X ) Tc. C 3(X ) Tc.

Figure 13: Rewrite rules computing disjunctive form.
makes difference logic-based approaches (Schmiedel, 1990; Bettini, 1997;
Halpern & Shoham, 1991). dual 3 (i.e., universal temporal quantifier 2) makes
satisfiability problem { subsumption { propositionally complete languages
undecidable interesting temporal structures (Halpern & Shoham, 1991; Venema,
1990; Bettini, 1993). representation actions plans context plan
recognition, universal temporal quantifier strictly necessary. limitation makes
languages decidable, nice computational properties, capable supporting
kinds useful extensions. examples shown throughout paper may serve
partial validation claim. Section 8.1 proposes introduction limited universal
temporal quantification maintains decidability subsumption.

7.1 Disjunctive Concepts: TLU -FU
language TLU -FU adds basic language TL-F disjunction operator {
usual semantics { temporal non-temporal levels:

C; ! TL j C
E; F ! F j E F

(TLU )
(FU )
showing modify calculus check subsumption, let us begin
clarifying example. gain expressivity allows us describe alternative realizations
given plan may have. Let us consider scenario robot moving empty
room move either horizontally vertically. Let's call Rect-Move
involves simple sequence two basic moving actions. Then, describe Rect-Move
plan make use disjunction operator:
:
Rect-Move = 3(x ) (] x)(x ). (Hor-Move@x u Ver-Move@y )
3(x y) (] x)(x y). (Ver-Move@x u Hor-Move@y)
7.1.1 Calculus TLU -FU
Normal Form

computing subsumption, normal form concepts needed. normalization procedure similar reported Section 6.1. Let us start reducing concept
expression equivalent disjunctive concept form:

3(X 1 ) Tc1 . G1) (3(X n) Tcn. Gn) Q1 Qm

(

489

fiArtale & Franconi

Gi conjunctions concepts form Qik @Xik , Q contain
neither temporal information, disjunctions, i.e., element language F .
Proposition 7.1 (Equivalence disjunctive form) Every concept C reduced
equivalent disjunctive form (df C ), exhaustively applying set rewrite rules
Figure 13 addition rules introduced Figure 11.
possible compute completed disjunctive normal form (cdnf C ). disjunct normal form interesting properties, crucial proof
theorem 7.4 concept subsumption: temporal constraints always explicit, i.e.,
two intervals related basic temporal relation; disjunction, either
implicit explicit, neither conceptual part temporal part, i.e.,
TL-F concept; information node independent information
nodes contain time-invariant (i.e., redundant) nodes.
Definition 7.2 (Completed disjunctive normal form) Given concept disjunctive
form, completed disjunctive normal form obtained applying following rewrite
rules disjunct:
(Temporal completion) rules definition 6.5 applied disjunct
exclusion covering step, replaced t-introduction step.
disjunct unsatisfiable { i.e., temporal constraint network associated
inconsistent { eliminate it.
(Essential form) rules definition 6.8 applied disjunct.
(t introduction) Reduce concepts containing basic temporal relationships:
3(X ) (X1 (R,S ) X2 ) Tc.C ! 3(X )(X1 R X2 )Tc.C 3(X )(X1 X2 )Tc.C
Proposition 7.3 (Equivalence CDNF) Every concept expression reduced
equivalent completed disjunctive normal concept.
Subsumption

theorem 7.4 reduces subsumption CDNF concepts subsumption disjunction-free concepts, results theorem 6.21 applied. following
theorem gives terminating, sound, complete subsumption calculus TLU -FU .
Theorem 7.4 (TLU -FU concept subsumption) Let C = C1 Cm = D1
Dn TLU -FU concepts CDNF. Then, C v 8i9j . Ci v Dj .
Proof. Since easy show C1 : : : Cn v iff 8i.Ci v need prove
restricted thesis: Ci v D1 Dn iff Ci v D1 _ : : : _ Ci v Dn . Every concept expression
CDNF corresponds existential quantified formula two free variables. Moreover,
matrices formul conjunctions positive predicates. Let us denote
formula corresponding concept C C 0 (t; x). Now, restricted thesis holds iff
true F [ fCi000 (a; b)g j= D1000 (a; b) _ D2000 (a; b). Now, let HB minimal Herbrand model
F [fCi000 (a; b)g. Then, F [fCi000 (a; b)g j= D1000 (a; b) _ D2000 (a; b) iff HB j= D1000 (a; b) _ D2000 (a; b).
Since talking single model, D1000 (a; b) _ D2000 (a; b) valid HB either
D1000 (a; b) D2000 (a; b) valid HB . proves theorem.5
2
5. proof theorem comes idea Werner Nutt.

490

fiA Temporal Description Logic Reasoning Actions Plans

consequence theorems 6.25, 7.4 following complexity result holds.

Theorem 7.5 (TLU -FU subsumption complexity) Concept subsumption TLU -FU
concept expressions normal form NP-complete problem.

7.2 Propositionally Complete Language: TL-ALCF
TL-ALCF uses propositionally complete Description Logic ALCF (Hollunder & Nutt,
1990) non-temporal concepts changing syntax rules TL-F following
way:

E; F ! FU j ? j :E j p " q j p "j 8P .E j 9P .E (ALCF )

interpretation functions extended take account roles:
P T<?
PtI = P^t j 8a; b. ha; bi 2 P^t $ ht; a; bi 2 P
seen Section 2, ALCF adds F full negation { thus introducing disagreement (p " q)
undefinedness (p ") features, role quantification (8P .E; 9P .E ).
example expressive power gained, let us refine description world
states involved Stack action (see Section 5.2). Suppose block described
saying LATERAL-SIDEs (role) BOTTOM- TOP-SIDEs (features). Then,
property clear could represented follows:
:
Clear-Block = Block u 8LATERAL-SIDE.Clear u TOP-SIDE : HAS-ABOVE "
says that, order clear, LATERAL-SIDE clear nothing
TOP-SIDE. Now, situation block involved Stack action
top another one reformulated following concept expression:
(?OBJECT1 TOP-SIDE HAS-ABOVE # ?OBJECT2)
Furthermore, given definition Clear-Blocks, derived that:
(?OBJECT1 TOP-SIDE HAS-ABOVE # ?OBJECT2) v (?OBJECT1 : :Clear-Block)
i.e., object, another object top it, clear object.
TL-ALCF possible describe states form incomplete knowledge
exploiting disjunction among non-temporal concepts. example, let us say
agent action either human machine: ?AGENT:(Person Robot).
7.2.1 Calculus TL-ALCF

Section presents calculus deciding subsumption temporal concepts
Description Logic TL-ALCF . Again, calculus based idea separating
inference temporal part inference Description Logic part (\vALCF "),
adopting standard procedures developed two areas.
Normal Form

more, subsumption calculus based normalization procedure. first
step reduces concept expression equivalent existential form { 3(X ) Tc. (Q0 u
Q1 @X1 u : : : u Qn@Xn) { applying rewrite rules Figure 11 augmented
491

fiArtale & Franconi

:>
:?
:(C u D)
:(C D)
: :C
:8P .C
:9P .C
:f : C
:p : C
:p # q
:p " q
(f p) "

!
!
!
!
!
!
!
!
!
!
!
!

?
>
:C :D
:C u :D
C
9P .:C
8P .:C
f " f : :C
f " f : (:q : C ) p = f q
p"tq"tp"q
p"tq"tp#q
f " f : (p ")

Note: f denote atomic feature atomic parametric feature.

Figure 14: Rewrite rules transform arbitrary concept simple concept.
rule: p : (q1 " q2 ) ! p q1 " p q2 . Q non-temporal concept, i.e., element
language ALCF .
following normalization step need verify concept satisfiability
non-temporal concept expressions. ALCF concept E unsatisfiable iff E vALCF ?.
Algorithms checking satisfiability subsumption concepts terms ALCF well
known (Hollunder & Nutt, 1990).
Definition 7.6 (Completed existential form) temporal completion concept
existential form { Completed Existential Form, CEF { obtained sequentially
applying following steps:
(closure, collapsing, covering) reported definition 6.5. covering,
translate concept expression Qy applying rewrite rule: Qy ! Qy ui=1:::n (Qi1
: : : Qim ).
(parameter introduction) requires two phases.
1. Q translated disjunctive normal form. First simple form6 obtained transforming Q following rewrite rules reported Figure 14.
disjunctive normal form obtained rewriting Q {
simple form { using following rules, correspond first order
rules computing disjunctive normal form logical formul:
(C1 C2 ) u ! (C1 u D) (C2 u D)
p : (C D) ! p : C p :
6. simple concept contains complements form :A, primitive concept,
sub-concepts form p ", p atomic (parametric) feature { corresponds first
order logical formula negation normal form.

492

fiA Temporal Description Logic Reasoning Actions Plans

?g1 : : : ?gn [ f [ p]] : C
?g1 : : : ?gn [ f [ p]] # g [ q]
?g1 : : : ?gn # ?f1 : : : ?fm
?g1 : : : ?gn g [ p] # ?f1 : : : ?fm [ f [ q]]

!
!
!
!

?g1 : : : ?gn " ?f1 : : : ?fm
?g "
?g1 : : : ?gn : (?gn+1 ")
?g1 : : : ?gn [ f [ p]] " g [ q]
?g1 : : : ?gn g [ p] " ?f1 : : : ?fm [ f [ q]]

!
!
!
!
!

?g1 : : : ?gn : >.
?g1 : : : ?gn : >.
?g1 : : : ?gn # ?f1 : : : ?fm .
?g1 : : : ?gn : > u
?f1 : : : ?fm : >.
?g1 : : : ?gn " ?f1 : : : ?fm .
?g " .
?g1 : : : ?gn : (?gn+1 ").
?g1 : : : ?gn : >.
?g1 : : : ?gn : > u
?f1 : : : ?fm : >.

Figure 15: Rewrite rules compute parameter introduction step.
2. Qj = Ej1 : : : Ejn , compute time-invariant part (let us indicate
particular concept expression Q~ j ). gives Q~ j computing
disjunct Eji Qj time-invariant information E~ji . Eji vALCF ?,
E~ji = ?. Otherwise, rewrite every conjunct Eji showed Figure 15,
conjuncts considered rewrote >. Now, unless
E~ji = >, Q~ j = E~j1 : : : E~jn must conjunctively added nodes.

Proposition 7.7 (Equivalence CEF) Every concept existential form reduced equivalent completed existential concept.

TL-F case, covering parameter introduction computed independently. consequence normalization phase, proposition 6.7 (node
independence) true TL-ALCF concepts CEF. Observe that, obtain CEF
concept, steps normalization procedure require computation transitive
closure temporal relations { NP-complete problem (van Beek & Cohen, 1990) { computation ALCF subsumption { PSPACE-complete
problem (Hollunder & Nutt, 1990).
presentation last normalization phase, eliminate redundant
nodes, possible check whether concept expression satisfiable.
Proposition 7.8 (Concept satisfiability) TL-ALCF concept CEF, hX; Tc; Q@X i,
satisfiable (with proviso temporal constraints satisfiable)
non-temporal concepts labeling node X satisfiable. Checking satisfiability
TL-ALCF concept CEF PSPACE-complete problem.
Proof. direct consequence node independence established proposition 6.7,
true TL-ALCF concepts CEF.
2
normalization procedure goes rewriting unsatisfiable concepts ?
computing essential graph form satisfiable concepts. last phase
493

fiArtale & Franconi

complex temporal languages considered paper essentially
ALCF express > concept means concept expression (e.g., > = :A).
consideration follows TL-ALCF redundant node derived
complex concept expression (e.g., t:A, ?g : ?g : :A redundant nodes).
key idea time-invariant information present ] node thanks
CEF. Thus needed extract information ] node computing
disjunctive normal form Q] , applying ~ translation, testing whether
Q~ ] vALCF Qi, given node xi .

Definition 7.9 (Essential graph) subgraph CEF TL-ALCF conceptual
temporal constraint network = hX; Tc; Q@X obtained deleting nodes xi
Q~ ] vALCF Qi { exception ] node { called essential graph : (ess ).

Proposition 7.10 (Equivalence essential graph) Every CEF concept reduced
equivalent essential graph form (and, obviously, every concept reduced
equivalent essential graph form).
Subsumption

overall normalization procedure reduces subsumption problem TL-ALCF
subsumption ALCF concepts.

Theorem 7.11 (TL-ALCF concept subsumption) concept C1 subsumes concept
C2 exists s-mapping essential graph C1 essential
graph C2 .

theorem gives sound complete algorithm computing subsumption TL-ALCF concepts (the proof one theorem 6.21). subsumption problem PSPACE-hard, since satisfiability subsumption ALCF
concepts proven PSPACE-complete (Hollunder & Nutt, 1990).

8. Extending Expressivity States
following suggests extend basic language cope important issues
representation states. (i) Homogeneity allows us consider properties world {
peculiar states { remain true subinterval interval hold.
(ii) Persistence guarantees state holding effect action continues hold
unless evidence falsity time. approach frame problem
presented, showing possible solution one (in)famous problems AI
literature. following subsections shall interested semantically characterizing
actions states computational properties. extensions proposed
temporal languages full edged Description Logic time action.

8.1 Homogeneity

temporal literature homogeneity characterizes temporal behavior world states:
state holds interval time t, holds subintervals t. Thus,
494

fiA Temporal Description Logic Reasoning Actions Plans

]

-

Simple-Stack(BLOCK)

r
OnTable(BLOCK)
-

r
OnBlock(BLOCK)

x



-

Figure 16: Temporal dependencies definition Simple-Stack action.
block table whole day, one conclude table
morning. hand, actions necessarily homogeneous. linguistic
literature difference made activity performance verbs. distinction
comes fact activity verbs sub-events denoted
verb, whereas performance verbs not. Generally, activity verbs represent ongoing events,
example eat run, described homogeneous predicates; whereas
performance verbs represent events well defined granularity time, prepare
spaghetti. Performance verbs example anti-homogeneous events: occur
interval time t, occur subinterval t, would yet
completed.
language extended introducing Homogeneity operator:

C; ! rC

(homogeneous concept)

semantics homogeneous concepts easily given terms semantics
temporal universal quantifier: rC 2x (x (=; s; d; f ) ]). C @x. means rC
homogeneous concept holds interval remains true
subinterval. particular, 2x universally qualifies temporal variable x,
temporal constraint (x (=; s; d; f ) ]) imposes x generic interval contained ].
Moreover, always true rC v C , i.e., rC specific concept C .
Let us consider example accurate definition Basic-Stack action
(see Section 4.1.1):
:
Simple-Stack = 3(x )(x ])(] ). ((?BLOCK : rOnTable)@x u
(?BLOCK : rOnBlock)@y)
Figure 16 shows temporal dependencies intervals Simple-Stack
holds. difference Basic-Stack action use homogeneity operator.
fact, since predicates OnTable OnBlock denote states, homogeneity
explicitly declared. assertion Simple-Stack(i; a) says individual action
type Simple-Stack occurred interval i. Moreover, assertion implies
related ?BLOCK, say b, type OnTable interval j { meeting {
intervals included j , type OnBlock another interval l { met {
intervals included l:
Simple-Stack(i; a) =) 9b. ?BLOCK(a; b) ^9 j; l. m(j; i) ^ m(i; l) ^
8 ^; ^l. (=; s; d; f )(^; j ) ^ (=; s; d; f )(^l; l) !
OnTable(^; b) ^ OnBlock(^
l; b):
495

fiArtale & Franconi

]

-r

Instant-Stack(BLOCK)

r
OnTable(BLOCK)
z

OnBlock(BLOCK)

-

Figure 17: Temporal dependencies definition Instant-Stack action.
Note Simple-Stack action subsumes Instant-Stack action, whose temporal
dependencies depicted Figure 17:
:
Instant-Stack = 3(z )(] f z )(] ). ((?BLOCK : rOnTable)@z u
(?BLOCK : rOnBlock)@y)
Subsumption holds class intervals { obtained homogeneity state
OnTable defined Simple-Stack action { including x subintervals
subset class intervals block known table, according
definition Instant-Stack { latter class includes subintervals z .
Instant-Stack action defined without r operator, would
specialize Simple-Stack action. fact, according weaker definition
Instant-Stack, specifying object table z imply
object table subintervals z ; particular, possible deduce
object table x subintervals, specified definition
Simple-Stack action. Moreover, weak Instant-Stack action type would specialize
weak Simple-Stack action type { i.e., Basic-Stack { too. Thus, homogeneity helps
us define states actions accurate way, important inferences
captured.
seen above, definition homogeneity makes use universal temporal quantification. Remember subsumption propositionally complete Description Logic
existential universal temporal quantification undecidable still
open problem becomes decidable absence negation (Bettini, 1993). homogeneity operator restricted form universal quantification. even restricted
form interests us here, concept C rC contain temporal
operator (called simple homogeneous concept). expressiveness resulting logic
enough, example, correctly represent homogeneous nature states. (Artale,
Bettini, & Franconi, 1994) algorithm compute subsumption TL-F augmented
homogeneity operator proposed. Even formal proof still available, good
arguments discussed conjecture completeness. would prove decidability
logic corresponding modal logics.

8.2 Persistence
Section shows framework successfully extended general way
cope inertial properties. basic temporal language, property holding, say,
post-condition action certain interval, guaranteed hold anymore
included subsequent intervals. reason propose extended
496

fiA Temporal Description Logic Reasoning Actions Plans

]

- x

Load(GUN)

Loaded(GUN)

]



-:
-

Fire(GUN,TARGET)

:= Loaded(GUN)
x


Loaded(GUN)

z

Dead(TARGET)



Figure 18: Definitions actions Load Fire.
formalism, states represented homogeneous persistent concepts.
motivation introducing possibility representing persistent properties
language, Section considers solve frame problem, particular
famous example Yale Turkey Shooting Scenario (Sandewall, 1994; Allen & Ferguson,
1994), formerly known Yale Shooting Problem.
inertia operator \= " introduced here. Intuitively, = C currently true
true preceding interval { say { evidence falsity C
interval current one i. Thus, property individual type
C persists time, unless contradiction arises.
formalization inertia operator makes use epistemic operator K (Donini,
Lenzerini, Nardi, Schaerf, & Nutt, 1992), KC denotes set individuals known
instances concept C 7 .

Definition 8.1 (Inertia) = C (j; a) iff
9i. start(i) start(j ) ^ C (i; a) ^
8h. start(h) end(i) ^ end(h) end(j ) ! :K:C (h; a).
start end two functions giving respectively starting ending point
interval { conditions endpoints simpler readable equivalents
interval relations; :K:C (h; a) means known type C
interval h. Furthermore, following relation holds: 8a; j . C (j; a) ! = C (j; a); i.e., = C
subsumes C . definition captured temporal language equipped
epistemic operator { K { homogeneity operator { r:
= C C 3(x y) (x (b; m; o; fi; di) ])(x (s; si) y)(y ]).(C @x u r(:K:C )@y)
Two action types defined, Load { parameter ?GUN { Fire {
parameters ?GUN ?TARGET (Figure 18):
=: 3x (] x). ?GUN : Loaded@x
:
Fire = 3(x z ) (] f x)(] )(] z ).
(?GUN : := Loaded@x ?TARGET : Dead@y) u ?GUN : :Loaded@z
action Load describes loading gun. action Fire describes firing gun
target: effects firing gun becomes unloaded either target dead
Load

7. epistemic interpretation
pair (I ,W ) interpretation W set interpretations (KC )I;W = J 2W (C J ;W ).

497

fiArtale & Franconi



- i1

gun)

Load(

fred :
gun
- j1
j
gun -
j0
j2

gun)

Loaded(

Fire(

= Loaded(

,

)

)

gun)

Loaded(

fred)

Dead(

Figure 19: Actions instances Yale Shooting Problem.
gun loaded { possibly inertia { firing. Yale Shooting Problem
considers situation described following set assertions (ABox):
Load(i; load-action ); ?GUN(load-action ; gun ); a(j; i); Fire(j; fire-action );
?GUN(fire-action ; gun ); ?TARGET(fire-action ; fred ):
i.e., beginning gun loaded; then, action firing gun target
fred performed. According semantics language, logical consequences
knowledge base are:
j= 9i1 . m(i; i1 ) ^ Loaded(i1 ; gun )
j= 9j1 . m(j; j1 ) ^ :Loaded(j1 ; gun )
j= 9j0 . f (j; j0 ) ^ = Loaded(j0 ; gun )
j= 9j2 . m(j; j2 ) ^ Dead(j1 ; fred ):
i.e., (see Figure 19) (i) Load action makes gun loaded; (ii) Fire action
makes gun unloaded end; (iii) since evidence contrary, gun
still loaded j0 inertia; (iv) since gun unloaded j0 , target fred must
dead.
Since inertia operator useful describe behavior properties,
characterized homogeneous concepts, simple way representing persistence
context homogeneous concepts proposed.
Proposition 8.2 Let P property { i.e., P =: rP 0 homogeneous concept {
knowledge base 6j= P (j; a). = P (j; a) true { i.e., j= = P (j; a) {
two intervals i; k exist that: j= (start(i) start(j ) ^ P (i; a))
[ fs(i; k); f (j; k); P (k; a)g satisfiable.
Proof. entailment test verifies first part definition inertia,
satisfiability test verifies that, interval system knows
individual belongs P { { interval P (a) deduced inertia { j
{ exist interval h system knows P (a) false. Indeed,
interval h would related interval k relation since supposed
P homogeneous, knowledge base :P (h; a) ^ P (k; a) ^ in(h; k) would
inconsistent.
2
deduction P (j; a) ! = P (j; a) obtained particular case stated
proposition.
498

fiA Temporal Description Logic Reasoning Actions Plans

9. Related Works
original formalism devised Allen (1991) forms, basis, foundation
work. predicate logic interval temporal networks introduced,
properties asserted hold intervals, events said occur intervals. approach general, suffers problems related semantic
formalization predicates hold occur (Blackburn, 1992). Moreover, computational properties formalism analyzed. study latter aspect was,
contrary, main concern.
Description Logic literature, approaches representing reasoning
time action proposed. beginning approaches based explicit notion
time surveyed, Strips-like approaches considered. Section ends
illustrating approaches devoted temporally extend situation calculus.
Bettini (1997) suggests variable-free extension existential universal
temporal quantification. gives undecidability results class temporal languages
{ resorting undecidability results Halpern Shoham's temporal logic { investigates approximated reasoning algorithms. Basically, extends ALCN description
logics existential universal temporal quantifiers, but, unlike formalism,
explicit interval variables allowed. temporal quantification makes use set
temporal constraints two implicit intervals: reference interval current one.
framework, concept Mortal defined as:
:
Mortal = LivingBeing u 3(after). (not LivingBeing)
Schild (1993) proposes embedding point-based tense operators propositionally
closed Description Logic. proved satisfiability ALCT , point-based temporal
extension ALC , interpreted linear, unbounded discrete temporal structure,
PSPACE-complete. ideas applied (Fischer, 1992; Neuwirth, 1993) Back
system. Note point-based temporal ontology unable express variety
relations intervals.
Baader Laux (1995) integrate modal operators time belief terminological
system looking adequate semantics resulting combined language. major
point paper possibility using modal operators inside concept
expressions front concept definitions assertions. following example
shows notion Happy-father, different modalities interact:
[BEL-JOHN](Happy-father =: 9MARRIED-TO.(Woman u [BEL-JOHN]Pretty) u
hfuturei8CHILD.Graduate)
case, John's belief Happy-father someone married woman believed
pretty John, whose children graduates sometime future.
semantics Kripke-style: modal operator interpreted accessibility relation
set possible worlds, domain objects split (possible) different
domain objects, one depending given world. latter:choice captures case of:
different definitions concept { [BEL-JOHN](A = B ) [BEL-PETER](A =
C ) { since two formul evaluated different worlds. main restriction
modal operators satisfy specific axioms belief time.
hand, language provided complete terminating algorithm
499

fiArtale & Franconi

serve, authors propose, \...as basis satisfiability algorithms complex
languages".
Description Logics intended represent reasoning actions following
Strips tradition. Heinsohn, Kudenko, Nebel Profitlich (1992) describe Rat
system, used Wip project German Research Center AI (DFKI). use
Description Logic represent world states atomic actions. second formalism
added compose actions plans reason simple temporal relationships.
explicit temporal constraints expressed language. Rat actions defined
change world state cause, instantaneous Strips-like
systems, plans linear sequences actions. important service offered
Rat simulated execution part plan, checking given plan feasible
and, so, computing global pre- post-conditions. feasibility test similar
usual consistency check concept description: temporally project preand post-conditions individual actions composing plan, respectively backward
forward. lead inconsistent initial, final intermediate state, plan
feasible global pre- post-conditions determined side effect.
Devanbu Litman (1991, 1996) describe Clasp system, plan-based knowledge
representation system extending notion subsumption classification plans,
build ecient information retrieval system. particular, Clasp used represent plan-like knowledge domain telephone switching software extending
use software information system lassie (Devanbu, Brachman, Selfridge, & Ballard,
1991). Clasp designed representing reasoning large collections plan
descriptions, using language able express temporal, conditional looping operators.
Following Strips tradition, plan descriptions built starting states actions,
represented using Classic (Brachman, McGuiness, Patel-Schneider, Resnick,
& Borgida, 1991) terminological language. Since plans constructing operators correspond
regular expressions, algorithms subsumption integrate work automata theory
work concept subsumption. temporal expressive power system capture
sequences, disjunction iterations actions action instantaneous. Furthermore, state descriptions restricted simple conjunction primitive Classic
concepts. Rat, Clasp checks instantiated plan well formed, i.e., specified
sequence individual actions able transform given initial state goal state
using Strips rules.
end reporting efforts made researchers situation calculus
field overcome strict sequential perspective inherent framework. Recent works
enrich original framework represent properties actions different truth
values depending situation time. work Reiter (1996),
moving results showed Pinto (1994) Ternovskaia (1994), provides
new axiomatization situation calculus able capture concurrent actions, properties
continuous changes, natural exogenous actions { nature's control.
notion uent { models properties world { situation maintained.
action instantaneous responsible changing actual situation subsequent
one. Concurrent actions simply sets instantaneous actions must coherent,
i.e., action's collection must non empty actions occur time.
Pinto (1994) Reiter (1996) introduce time dimension essentially capture
500

fiA Temporal Description Logic Reasoning Actions Plans

occurrence natural actions, due known laws physics { i.e., ball bouncing
times prescribed motion's equations { dynamic behavior physical objects
{ i.e., position falling ball. realized introducing time argument
action function, properties world divided two different classes:
classical uents hold hold throughout situations, continuous parameters
may change value time spanned given situation.
devoted situation calculus time interval ontology work
Ternovskaia (1994). order describe processes { i.e., actions extended time {
introduces durationless actions initiate terminate processes. matter
fact, processes become uents, instantaneous events { Start(Fluent) Finish(Fluent)
{ respectively make true false corresponding uent, persistence
assumptions make uent true interval. example, blocks world
picking-up process treated uent Start(picking-up(x)) Finish(pickingup(x)) instantaneous actions enable falsify picking-up uent.

10. Conclusions
main objective paper design class logical formalisms uniformly representing time, actions plans. According framework, action
duration time, parameters, ties temporal evolution
world, possibly associated time actions. model-theoretic
semantics including temporal object domain developed, giving
meaning language formul well founded definition various reasoning
services, allowing us prove soundness completeness corresponding algorithms.
peculiar computational properties logic make effective representation
reasoning tool plan recognition purposes. action taxonomy based subsumption
set up, play role plan library plan retrieval tasks.
paper contributes exploration decidable realm interval-based temporal
extensions Description Logics. presented complete procedures subsumption reasoning TL-F , TLU -FU TL-ALCF . addition, subsumption problem
TL-F proven NP-complete problem. subsumption procedures based
interpretation preserving transformation operates separation temporal non-temporal parts formalism. Thus, calculus adopt distinct
standard procedures developed Description Logics community temporal
constraints community. obtain decidable languages key idea restrict temporal expressivity eliminating universal quantification temporal variables.
propositionally complete Description Logic existential universal temporal
quantification undecidable, still open problem becomes decidable absence
negation. introduction homogeneity operator investigation impact
restricted form temporal universal quantification language TL-F begun.
Several extensions proposed basic temporal language. possibility
specify homogeneous predicates temporal behavior world states described
natural way, introduction non-monotonic inertial operator gives
rise forms temporal prediction. Another extension { considered paper
{ deals possibility relating action elementary actions, decomposing
501

fiArtale & Franconi

partially ordered steps (Artale & Franconi, 1995). kind reasoning found
hierarchical planners Nonlin (Tate, 1977), Sipe (Wilkins, 1988) Forbin (Dean,
Firby, & Miller, 1990).

Acknowledgements
paper substantial extension revision (Artale & Franconi, 1994). work
partially supported Italian National Research Council (CNR) project \Ontologic
Linguistic Tools Conceptual Modeling", \Foundations Data Warehouse
Quality" (DWQ ) European ESPRIT IV Long Term Research (LTR) Project 22469.
first author wishes acknowledge LADSEB-CNR Padova University
Firenze supported part work. work carried paper
done second author working ITC-irst, Trento. work owes lot
colleagues Claudio Bettini Alfonso Gerevini, introduced us many years
ago temporal maze. Special thanks Achille C. Varzi, taking time review
technical details paper insightful comments philosophy events,
Fausto Giunchiglia, useful discussions feedback. Thanks Paolo Bresciani,
Nicola Guarino, Eugenia Ternovskaia Andrea Schaerf enlightening comments
earlier drafts paper. Werner Nutt Luciano Serafini helped us deeper
insight logic. would thank Carsten Lutz helpful discussions
temporal representations. Many anonymous referees checked many
errors previous versions paper. errors paper are, course, own.

References

Allen, J. F. (1991). Temporal reasoning planning. Allen, J. F., Kautz, H. A., Pelavin,
R. N., & Tenenberg, J. D. (Eds.), Reasoning Plans, chap. 1, pp. 2{68. Morgan
Kaufmann.
Allen, J. F., & Ferguson, G. (1994). Actions events interval temporal logic. Journal
Logic Computation, 4 (5). Special Issue Actions Processes.
Artale, A., Bettini, C., & Franconi, E. (1994). Homogeneous concepts temporal description logic. F.Baader, M.Lenzerini, W.Nutt, & P.F.Patel-Schneider (Eds.),
Workshop Notes Int. Workshop Description Logics, DL-94, pp. 36{41 Bonn,
Germany. DFKI, Saarbrucken. Tech. Rep. DFKI-D-94-10.
Artale, A., & Franconi, E. (1994). computational account description logic
time action. J.Doyle, E.Sandewall, & P.Torasso (Eds.), Proc. 4 th
International Conference Principles Knowledge Representation Reasoning,
pp. 3{14 Bonn, Germany. Morgan Kaufmann.
Artale, A., & Franconi, E. (1995). Hierarchical plans description logic time
action. A.Borgida, M.Lenzerini, D.Nardi, & B.Nebel (Eds.), Workshop Notes
Int. Workshop Description Logics. DL-95, pp. 1{5 Roma, Italy. Tech. Rep. 07.95.
Workshop Notes IJCAI-95 Workshop \The Next Generation
502

fiA Temporal Description Logic Reasoning Actions Plans

Plan Recognition Systems: Challanges Insight Related Areas AI",
Montreal, 1995.
Baader, F., Burckert, H.-J., Heinsohn, J., Hollunder, B., Muller, J., Nebel, B., Nutt, W.,
& Profitlich, H.-J. (1990). Terminological knowledge representation: proposal
terminological logic. Technical memo TM-90-04, DFKI, Saarbrucken, Germany.
Baader, F., & Laux, A. (1995). Terminological logics modal operator. Proc.
13 th IJCAI, pp. 808{814 Montreal, Canada.
Bettini, C. (1993). Temporal Extensions Terminological Languages. Ph.D. thesis, Computer Science Department, University Milan, Italy.
Bettini, C. (1997). Time dependent concepts: Representation reasoning using temporal
description logics. Data & Knowledge Engineering, 22 (1), 1{38.
Blackburn, P. (1992). Fine grained theories time. Working Papers 4th Intl.
Workshop Semantics Time, Space, Movement, Spatio-Temporal Reasoning,
pp. 299{320.
Brachman, R. J., McGuiness, D. L., Patel-Schneider, P. F., Resnick, L. A., & Borgida, A.
(1991). Living classic: use kl-one-like language. Sowa,
J. (Ed.), Principles Semantic Networks. Morgan Kaufmann.
Buchheit, M., Donini, F. M., & Schaerf, A. (1993). Decidable reasoning terminological
knowledge representation systems. Information Systems, 1, 109{138.
Calvanese, D., Lenzerini, M., & Nardi, D. (1994). unified framework class-based
representation formalisms. Proc. 4 th International Conference Principles
Knowledge Representation Reasoning Bonn, Germany.
Cohen, W., Borgida, A., & Hirsh, H. (1992). Computing least common subsumers
description logics.. pp. 754{760 San Jose, CA.
De Giacomo, G., & Lenzerini, M. (1996). Tbox abox reasoning expressive description
logics. Proc. 5 th International Conference Principles Knowledge
Representation Reasoning, pp. 316{327 Boston, MA. Morgan Kaufmann.
De Giacomo, G., & Lenzerini, M. (1995). What's aggregate: Foundations description logics tuples sets. Proc. 13 th IJCAI Montreal, Canada.
Dean, T., Firby, J., & Miller, D. (1990). Hierarchical planning involving deadlines, travel
time resources. Computational Intelligence, 6 (1).
Devanbu, P. T., & Litman, D. J. (1991). Plan-based terminological reasoning. Proc.
2 nd International Conference Principles Knowledge Representation
Reasoning, pp. 128{138 Cambridge, MA.
Devanbu, P. T., & Litman, D. J. (1996). Taxonomic plan reasoning. Artificial Intelligence,
84, 1{35.
503

fiArtale & Franconi

Devanbu, P., Brachman, R., Selfridge, P., & Ballard, B. (1991). LASSIE { knowledgebased software information system. Communication ACM, 34 (5).
Donini, F. M., Hollunder, B., Lenzerini, M., Spaccamela, A. M., Nardi, D., & Nutt, W.
(1992). complexity existential quantification concept languages. Artificial
Intelligence, 53, 309{327.
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1995). complexity concept
languages. Tech. rep. RR-95-07, DFKI, Germany. preliminary version appears
Proc. 2nd International Conference Principles Knowledge Representation
Reasoning (KR-91).
Donini, F. M., Lenzerini, M., Nardi, D., & Schaerf, A. (1994). Deduction concept
languages: subsumption instance checking. Journal Logic Computation,
4 (4), 423{452.
Donini, F. M., Lenzerini, M., Nardi, D., Schaerf, A., & Nutt, W. (1992). Adding epistemic
operators concept languages. Proc. 3 rd International Conference
Principles Knowledge Representation Reasoning, pp. 342{353 Cambridge, MA.
Fikes, R. E., & Nilsson, N. (1971). STRIPS: new approach application theorem
proving problem solving. Artificial Intelligence, 2, 198{208.
Fischer, M. (1992). integration temporal operators terminological representation system. Kit-report 99, Technische Universtitat Berlin, Germany.
Gerevini, A., & Schubert, L. (1994). point-based temporal disjointness. Artificial
Intelligence, 70, 347{361.
Halpern, J. Y., & Moses, Y. (1985). guide modal logic knowledge belief:
Preliminary draft. Proc. 9 th IJCAI, pp. 480{490 Los Angeles, CA.
Halpern, J. Y., & Shoham, Y. (1991). propositional modal logic time intervals. Journal
ACM, 38 (4), 935{962.
Heinsohn, J., Kudenko, D., Nebel, B., & Profitlich, H. (1992). RAT: representation
actions using terminological logics. Tech. rep., DFKI, Saarbrucken, Germany.
Hollunder, B., & Nutt, W. (1990). Subsumption algorithms concept languages. Tech.
rep. RR-90-04, DFKI, Germany.
Kautz, H. A. (1991). formal theory plan recognition implementation. Allen,
J. F., Kautz, H. A., Pelavin, R. N., & Tenenberg, J. D. (Eds.), Reasoning Plans,
chap. 2, pp. 69{126. Morgan Kaufmann.
Lifschitz, V. (1987). semantics strips. 1986 Workshop Reasoning
Actions Plans, pp. 1{10. Morgan Kaufman.
McCarthy, J., & Hayes, P. J. (1969). philosophical problems standpoint
Artificial Intelligence. Meltzer, B., & Michie, D. (Eds.), Machine Intelligence,
Vol. 4, pp. 463{502 Edinburgh, UK. Edinburgh University Press.
504

fiA Temporal Description Logic Reasoning Actions Plans

Nebel, B. (1990). Terminological reasoning inherently intractable. Artificial Intelligence,
43, 235{249.
Nebel, B. (1991). Terminological cycles: Semantics computational properties. Sowa,
J. F. (Ed.), Principles Semantic Networks, chap. 11, pp. 331{362. Morgan Kaufmann.
Neuwirth, A. (1993). Inferences temporal object descriptions terminological representation system: Design implementation. Kit-report 107, Technische Universtitat
Berlin, Germany.
Pinto, J. A. (1994). Temporal Reasoning Situation Calculus. Ph.D. thesis, Department
Computer Science, University Toronto.
Reiter, R. (1996). Natural actions, concurrency continuous time situation calculs.
Proc. 5 th International Conference Principles Knowledge Representation Reasoning Boston, MA.
Renz, J., & Nebel, B. (1997). complexity qualitative spatial reasoning: maximal
tractable fragment region connection calculus. Proc. 14 th IJCAI, pp.
522{527 Nagoya, Japan.
Sandewall, E. (1994). Features Fluents. Representation Knowledge Dynamical Systems, Vol. I. Oxford University Press.
Sandewall, E., & Shoham, Y. (1994). Non-monotonic temporal reasoning. Gabbay, D.
(Ed.), Handbook Artificial Intelligence Logic programming. Oxford University
Press.
Schaerf, A. (1994). Reasoning individuals concept languages. Data & Knowledge
Engineering, 13 (2), 141{176.
Schild, K. D. (1991). correspondence theory terminological logics: Preliminary report.
Proc. 12 th IJCAI, pp. 466{471 Sidney, Australia.
Schild, K. D. (1993). Combining terminological logics tense logic. Proceedings
6th Portuguese Conference Artificial Intelligence, EPIA'93.
Schmidt-Schau, M., & Smolka, G. (1991). Attributive concept descriptions complements. Artificial Intelligence, 48 (1), 1{26.
Schmiedel, A. (1990). temporal terminological logic. Proc. AAAI-90, pp. 640{645
Boston, MA.
Smolka, G. (1992). Feature constraint logics unification grammar. Journal Logic
Programming, 12, 51{87.
Tate, A. (1977). Generating project networks. Proc. 5 th IJCAI, pp. 888{893
Cambridge, MA.
505

fiArtale & Franconi

Ternovskaia, E. (1994). Interval situation calculus. Workshop Notes ECAI-94
Workshop \Logic Change", pp. 153{164 Amsterdam.
van Beek, P., & Cohen, R. (1990). Exact approximate reasoning temporal
relations. Computational Intelligence, 6, 132{144.
van Beek, P., & Manchak, D. W. (1996). design experimental analysis algorithms
temporal reasoning. Journal Artificial Intelligence Research, 4, 1{18.
van Dalen, D. (1994). Logic Structure. Springer-Verlag.
Venema, Y. (1990). Expressiveness completeness interval tense logic. Notre Dame
Journal Formal Logic, 31 (4), 529{547.
Weida, R. (1996). Closed Terminologies Temporal reasoning Descriptions Plan
Recognition. Ph.D. thesis, Department Computer Science, Columbia University,
New York, NY.
Weida, R., & Litman, D. (1992). Terminological reasoning constraint networks
application plan recognition. Proc. 3 rd International Conference
Principles Knowledge Representation Reasoning, pp. 282{293 Cambridge, MA.
Weida, R., & Litman, D. (1994). Subsumption recognition heterogeneous constraint
networks. Proceedings CAIA-94.
Wilkins, D. (1988). Practical planning. Morgan Kaufmann, San Mateo CA.

506


