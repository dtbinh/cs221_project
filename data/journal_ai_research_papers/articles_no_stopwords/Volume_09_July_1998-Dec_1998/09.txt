Journal Artificial Intelligence Research 9 (1998) 367-421

Submitted 7/98; published 12/98

Automatic Inference State Invariants TIM
Maria Fox
Derek Long

maria.fox@dur.ac.uk
d.p.long@dur.ac.uk

Department Computer Science
University Durham, UK

Abstract
planning applied larger richer domains effort involved constructing
domain descriptions increases becomes significant burden human application
designer. general planners applied successfully large complex domains
necessary provide domain designer assistance building correctly
encoded domains. One way provide domain-independent techniques
extracting, domain description, knowledge implicit description
assist domain designers debugging domain descriptions. knowledge
exploited improve performance planners: several researchers explored
potential state invariants speeding performance domain-independent
planners. paper describe process state invariants extracted
automatically inferred type structure domain. techniques
developed exploitation stan, Graphplan based planner employs state analysis
techniques enhance performance.

1. Introduction
Stan (Long & Fox, press) domain-independent planner based constraint
satisfaction technology Graphplan (Blum & Furst, 1995). name derived
fact performs variety pre-processing analyses (STate ANalyses) domain
description applied, assist planning eciently domain. Stan
took part aips-98 planning competition, first international competition
domain-independent planners compared terms performance well-known
benchmark domains. four planners competed strips track, three
based Graphplan (Blum & Furst, 1995) architecture. important difference stan Graphplan-based planners use state analysis
techniques. Although techniques not, stage, fully integrated
planning algorithm stan gave impressive performance determined examination competition results. description competition, objectives
results, aips-98 planning competition FTP site (see Appendix A).
One important analyses performed stan automatic inference
state invariants. described paper, state invariants inferred
type structure domain automatically inferred, enriched, stan.
techniques used completely independent planning architecture, isolated
pre-processing module call tim (Type Inference Module). Tim used
planner, regardless whether based Graphplan underlying
c 1998 AI Access Foundation Morgan Kaufmann Publishers. rights reserved.

fiFox & Long

architecture. Tim implemented c++ executables examples output
available web site (see Appendix A) Online Appendix 1.
Tim takes domain description type information need supplied infers
rich type structure functional relationships objects domain. type
information supplied tim exploit foundation type structure
often infer enriched type structure basis. State invariants extracted
way inferred types partitioned. consequence domain
designer relieved considerable overhead description domain. Whilst
easy hand-code types state invariants simple domains containing objects
relations, becomes progressively dicult ensure cross-consistency handcoded invariants domains become increasingly complex. Similarly, exploitable type
structure domain may much richer easily provided hand.
observed tim often infers unexpected type partitions increase discrimination
type structure provide corresponding benefits stan's performance. therefore
see tim domain engineering tool, helping shift burden domain design
human automatic system.
usefulness types state invariants well-documented. Types
provided hand since first observed reduce number operator instantiations considered traversal planner's search space.
elimination meaningless instantiations particularly helpful system Graphplan, structure traversed explicitly constructed prior search.
believe benefits obtained type inference planning similar
obtained programing language design: type inference powerful type checking
assist identification semantic errors specification relational
structure domain. Indeed, found tim useful domain debugging
tool, allowing us identify aws published benchmark domains. used
tim reveal underlying structure Mystery domain, disguised transportation
problem domain, used planning competition. Mystery domain described
Appendix C.2.
use domain knowledge significantly improve performance planners,
shown number researchers. Gerevini Schubert (1996a, 1996b) considered automatic inference state constraints demonstrated significant
empirical advantage obtained use. Kautz Selman (1998) handcoded invariants provided part domain description used Blackbox.
demonstrate performance advantages obtained acknowledge importance
inferring invariants automatically. McCluskey Porteous (1997) demonstrated important role hand-coded state invariants play domain compilation
ecient planning. Earlier work Kelleher Cohn (1992) Morris Feldman
(1989) explores automatic generation restricted invariant forms. discuss
these, other, related approaches section 5.
paper describe type inference process employed tim explain
four different forms state invariant extracted inferred type structure.
argue tim correct since never infers sentences state invariants.
provide experimental results demonstrating performance advantages
obtained use types.
368

fiAutomatic Inference State Invariants

drive

unfuelled 1
fuelled

1

drive

1

load

1


1

unload

Figure 1: simple transportation domain seen collection FSMs.

2. Type Inference Module
One way viewing strips (Fikes & Nilsson, 1971) domains collection finite-state
machines (FSMs) domain constants traversing states within them. example,
simple transportation domain rockets packages, rockets capable
locations moving, driving, one location
another, fuelled unfuelled, moving two states.
seen forming one-node FSM, fuelled unfuelled forming two-node FSM.
view depicted Figure 1.
369

fiFox & Long

Packages locations rockets, move states
resulting two-node FSM. example, rockets states involve
one FSM, since fuelled, unfuelled. STRIPS domains
seen way earlier work (McCluskey & Porteous, 1997; Grant, 1996),
discussed Section 5.

2.1 Types TIM

two objects participate identical FSMs functionally equivalent
seen type. notion type similar sorts work
McCluskey Porteous (1997). primary objective tim module automatically
identify equivalence classes form primitive types domain description
infer hierarchical type structure domain basis primitive types.
way done discussed Section 2.3. primitive types functional equivalence
classes, objects domain partitioned classes. identified
types domain objects tim infers types parameters operators.
State invariants inferred final stage.
early parts process rely three key abstract data types, property space,
attribute space transition rule. Formal definitions components
provided Section 2.3, provide informal descriptions support following
definitions. Transition rules represent state transformations comprise FSMs
traversed objects domain. Property spaces FSMs, together objects
participate them, properties objects transition rules
acquire properties. Attribute spaces contain collections objects
have, acquire, associated attributes. Attributes differ properties
acquired, lost, without associated loss, acquisition (respectively),
another attribute. Attribute spaces contain transition rules enable
acquisition (or loss) attributes. state attribute spaces
constructed assign types domain objects according membership
property attribute spaces. two objects belong identical property
attribute spaces assigned type. therefore important ensure
property attribute spaces adequately discriminating, otherwise important
type distinctions lost. Much subtlety algorithm described Section 2.2
concerned maintaining adequate discrimination construction spaces.
present following definitions support informal characterisation
roles types strips tim. definitions used Sections 2.4 2.6,
discuss types assigned objects operator parameters.

Definition 1 type vector bit vector bit corresponds membership,
otherwise, unique state attribute space. number bits vector always
equal number distinct state attribute spaces.

Definition 2 type set domain objects associated type vector.
Definition 3 type vector, V1, two distinct bits, si sj , set corresponds

sub-type type associated vector, V2, si set (all settings
370

fiAutomatic Inference State Invariants

equal). type associated V2 seen super-type type
associated V1 .

Definition 4 type structure hierarchy types organised sub-type relationships
component types.

Definition 5 type structure adequately discriminating objects assigned
state (and attribute) spaces characterize state transitions (and attributes).

Definition 6 type structure under-discriminating fails distinguish types
functionally distinct.

Definition 7 type structure over-discriminating functionally identical objects
assigned different types.

two distinct ways types play role specification domain.
restrict set possible operator instances eliminate
meaningless domain hence improve eciency reducing size search
space, eliminate unsound plans could constructed
provided. following examples clarify difference two roles.
untyped schema:

drive(X,Y,Z)
Pre:
Add:
Del:

at(X,Y), fuelled(X), location(Z)
at(X,Z), unfuelled(X)
at(X,Y), fuelled(X)

permits instances typed schema:

drive(X,Y,Z)
params:
Pre:
Add:
Del:

X:rocket,Y:package,Z:location
at(X,Y), fuelled(X), location(Z)
at(X,Z), unfuelled(X)
at(X,Y), fuelled(X)

meaningless instances eliminated search preconditions
satisfiable. hand, typed schema:

y(X,Y,Z)
params:
Pre:
Add:
Del:

X:aircraft,Y,Z:location
at(X,Y)
at(X,Z)
at(X,Y)

ensures aircraft own, whilst untyped schema:
371

fiFox & Long

y(X,Y,Z)
Pre:
Add:
Del:

at(X,Y)
at(X,Z)
at(X,Y)

allows ying means travel object location, including packages,
objects, well aircraft. Tim capable automatically inferring types
playing restrictive role indicated typed drive operator. However, tim cannot infer
type information implicit domain description. Thus, given untyped fly
schema, grounds tim infer type restrictions. Tim draw attention
unintended under-discrimination making packages aircraft indistinguishable
type level, unless distinguishing information provided schemas.
least tim make explicit fact packages amongst objects
y. assists domain designer tracking errors omissions domain
description, unstated intended distinctions cannot enforced tim.

2.2 Overview TIM Algorithm

Figure 2 gives broad outline tim algorithm. detailed description given
Appendix B. role component algorithm described, together
commentary discussing related issues justifications, Sections 2.3, 2.4 2.7.
Broadly, tim begins analysis domain operators, extracting transition rules
form foundations property attribute spaces described previously.
rules used separate properties equivalence classes property
attribute spaces constructed. Tim analyses initial state order assign
domain objects appropriate spaces. analysis identifies initial properties
individual objects uses form states objects property spaces.
initial states property space extended application transition rules
space form complete sets states accounting states objects
property space possibly inhabit. described Section 2.4, attribute spaces
behave FSMs, property spaces do, extension carried
different procedure: one add new objects spaces, rather new states.
Tim assigns types objects using pattern membership spaces
constructed. Finally, tim uses spaces determine invariants govern behaviour
domain objects it.

2.3 Constructing Transition Rules

begin describing process transition rules constructed.
following definitions required.

Definition 8 property predicate subscripted number 1 arity
predicate. Every predicate arity n defines n properties.

Definition 9 transition rule expression form:
property ) property ! property
372

fiAutomatic Inference State Invariants

Construct base PRSs (Section 2.3)
Split PRSs (Section 2.3)
Construct transition rules (Section 2.3)
Seed property attribute spaces (Section 2.3)
Assign transition rules (Section 2.4)
Analyse initial state (Section 2.4)
Extend property spaces (Section 2.4)
Extend attribute spaces (Section 2.4)
Identify types (Section 2.6)
Construct invariants (Section 2.7)
Figure 2: Outline tim algorithm.
three components bags zero properties called enablers, start
finish, respectively.

double arrow, ), read enables single arrow, !, read transition
from. So:

E)S!F

read: E enables transition F. properties given result
transition. properties F acquired result transition. properties
E given up.
enablers empty write:

start ! finish
start empty write:

Transition rule 1

enablers ) null ! finish
finish empty write:

Transition rule 2

enablers ) start ! null
bag null empty bag properties. role emphasise that, transition
rule 1, nothing given result transition and, transition rule 2, nothing
acquired. Rules null start null finish discarded describe
null transitions.
property bags contain one element separated commas.
collection:

pk ; qm ; ::: rn
373

fiFox & Long

interpreted mean properties collection satisfied
many times appear collection. comma therefore used separate
elements bag. use denote bag union, denote bag difference,
denote
bag intersection v denote bag inclusion.

Definition 10 Property Relating Structure (PRS) triple bags properties.
first stage algorithm constructs set transition rules set operator
schemas. operator schema analysed respect parameter turn and,
parameter, PRS built. first bag properties formed preconditions
schema, number used form property argument position
parameter considered. example, precondition on(X; ),
parameter considered X , property formed on1 . bag, called precs,
contains enablers used formation transition rules. second
bag, called deleted precs, properties formed preconditions appear
delete list schema (with respect parameter). third bag, called
add elements, contains properties formed add list schema.
PRS contains deleted elements component { assumed every element
delete list strips operator appears precondition list. reasonable
restriction given strips operators allow use conditional effects.
assumed every pair atoms delete list schema distinct
legal instantiations schema. constitute significant restriction since
operator schemas always easily rephrased whenever condition violated.
consider process PRSs constructed. Given schema:

drive(X,Y,Z)
Pre:
Add:
Del:

at(X,Y), fuelled(X), location(Z)
at(X,Z), unfuelled(X)
at(X,Y), fuelled(X)

considering parameter X , following PRS built:

PRS 1

precs :
at1 ; fuelled1
deleted precs : at1 ; fuelled1
add elements : at1 ; unfuelled1
considering parameter obtain:

PRS 2
precs :
at2
deleted precs : at2
add elements :
considering parameter Z obtain:
374

fiAutomatic Inference State Invariants

PRS 3

precs :
location1
deleted precs :
add elements : at2

constructing structures identifying state transformations
objects, instantiating operator parameters, progress. Note objects instantiate X go fuelled somewhere unfuelled somewhere; objects
instantiate lose property anything gain nothing result application operator, objects instantiate Z continue locations
gain property something them. convert structures
transition rules order correctly capture state transformations.
standard formula construction rules PRSs is:

precs deleted precs ) deleted precs ! add elements
Thus, using PRS 1 above, could build rule:

at1 ; fuelled1 ! at1 ; unfuelled1
potential problem rule causes at1 fuelled1 linked state
transformations, at1 fuelled1 become associated property space
and, consequence, objects places, cannot fuelled, may

indistinguishable objects require fuelling moved. fact,
wish transition rules express fact fuelled enables things go
one place another place, whilst excluding possibility
may enablers transition.
therefore begin second phase PRS construction identifying, special treatment, PRSs property appears deleted precs add elements.
property exchanged application operator. is, relation
continues hold identified argument object objects (not
necessarily object objects application operator). example, PRS 1, vehicle new location application operator,
longer old location. observe vehicle must fuelled make transition. separate transition condition split PRS. Splitting identifies
exchanged properties PRS creates one new PRS exchange one
unexchanged properties. Therefore, splitting PRS always results k + 1
(and least k) new PRSs, k number exchanges PRS represents.
splitting PRS 1 construct two new PRSs: one characterizing exchange
property, one characterising fuelled unfuelled transition.
first new PRSs is:

PRS 4

precs :
at1 ; fuelled1
deleted precs : at1
add elements : at1
375

fiFox & Long

rule

fuelled1 ) at1 ! at1
constructed. noted property fuelled longer seen
part state transformation enabler, appear
deleted precs bag resulting PRS.
second new PRS captures fact at1 seen enabler
transition fuelled1 unfuelled1:

PRS 5

precs :
at1 ; fuelled1
deleted precs : fuelled1
add elements : unfuelled1

PRS splits required since properties exchanged
it. general example follows:

PRS 6

precs :
p1; p2 pn
deleted precs : p1 pi pi+k pm
add elements : p1 pi q1 qk

PRSs would constructed deal exchanged pairs
final PRS, PRS 7, would constructed describe remainder transition making
+ 1 PRSs total.

PRS 7

precs :
p1 ; p2 pn
deleted precs : pi+k pm
add elements : q1 qk

need consider additional pairings add delete-list elements, since
would correspond exchanges properties. splitting process justified Section 3.1. standard rule construction formula applied PRS 5, yielding
rule
at1 ) fuelled1 ! unfuelled1
observed that, even add elements bag contains multiple properties,
single rule always built standard construction formula applied.
considering remaining PRSs, 2 3, observed contain
empty field: 2 add elements field empty 3 deleted precs field empty.
PRS empty field special treatment required. PRS 2 build
rule

at2 ! null

represent fact object instantiates gives property
something it, gains nothing return. 3 build rule

location1 ) null ! at2
376

fiAutomatic Inference State Invariants

represent fact object instantiates Z gains property something virtue location, gives nothing return. rules
somewhat different status ones characterize exchange properties.
cases properties lost gained, without exchange, seen resources
accumulated spent domain objects rather states
domain objects pass. example, location acquire property something it, without relinquishing anything return, whereas object requires fuel
become fuelled relinquishing property unfuelled, vice versa.
Increasing decreasing resources identified attributes distinguished
states. distinction later prove important, since generation true
state invariants depends upon made correctly. Properties increase
decrease without exchange invariant, false assertions would proposed
invariants treated way state-valued properties.
rule form constructed PRS 3 must constructed separately every
property add elements bag properties must individually characterized increasing resources. Rules constructed using null distinguished attribute
transition rules. null left side ! rule increasing attribute
transition rule. null right hand side rule decreasing attribute
transition rule.
final case consider rule construction case PRS empty
precs field. happens parameter, respect PRS constructed,
appear preconditions operator schema. case set
rules constructed, one property, a, add elements bag, form

null !
ecting fact increasing resource (the deleted precs field necessarily
empty case).

Definition 11 state bag properties.
necessary distinguish bag set, square brackets used denote
bag.
Definition 12 property space tuple four components: set properties, set
transition rules, set states set domain constants.

Definition 13 attribute space tuple three components: set properties, set

transition rules set domain constants.

helpful observe state attribute spaces represent disjoint collections properties, disjoint collections formed transition
rules putting start finish properties rule collection.
example, given two rules:
E1 ) [p1; p2; p3] ! [q1 ; q2]

E2 ) [r1; r2] ! [s1 ]
377

fiFox & Long

collections [p1; p2; p3; q1; q2] [r1; r2; s1] would formed. property appears
start finish rules single collection formed two rules.
last stage rule construction phase identify basis construction
property attribute spaces. done uniting left right hand sides
rules. Uniting forms collections properties seed unique property attribute
space. yet possible decide seeds form attribute spaces,
treatment kinds space identical stage. enablers rules
ignored process. wish make enablers automatically fall
property spaces states transformations enable. could result
incorrect assignment properties property attribute spaces since enablers
facilitate, participate in, state transformations. output phase
collection rules, properties marked attributes, property space seeds
formed uniting process. properties remain unassigned stage
used seed separate attribute spaces, one property.
role played second phase PRS construction postpone commitment
uniting collections properties possibility objects,
properties, associated different property spaces left open long
possible. may consideration schemas provides enough information
possibility eliminated, following abstract example, support
much type discrimination possible earlier phases analysis. consider
simple example illustrate problem.
2.3.1 Postponing Property Space Amalgamation

Given domain description containing following operator schema:

op1(X,Y,Z)
Pre:
Add:
Del:

p(X,Y), q(X,Y)
p(X,Z), q(X,Z)
p(X,Y), q(X,Y)

PRS:

precs :
p1 ; q1
deleted precs : p1 ; q1
add elements : p1; q1
constructed, first phase, X . properties p1 q1 bound
together PRS, resulting rule would be:

p1; q1 ! p1 ; q1
forces objects property p1 occupy property space objects
property q1 . Since PRS models exchange p1 split it,
replace two new PRSs:

precs :
p1 ; q1
deleted precs : p1
add elements : p1
378

fiAutomatic Inference State Invariants

precs :
p1 ; q1
deleted precs : q1
add elements : q1
consider pairings p1 q1 , since found PRSs
operator schemas domain allows them. two PRSs generated lead
generation rules:

q1 ) p1 ! p1



p1 ) q1 ! q1

two rules indicate p1 q1 used form different property spaces since
could, principle, independent one another. objects assigned two
spaces turn distinct types. However, add following two schemas:

op2(X,Y)
Pre:
Add:
Del:

op3(X,Y,Z)

q(X,Y)
p(X,Y)
q(X,Y)

Pre:
Add:
Del:

p(X,Y)
q(X,Y)
p(X,Y)

generate, X , PRSs:

precs :
q1
deleted precs : q1
add elements : p1


precs :
p1
deleted precs : p1
add elements : q1
rules:


q1 ! p1
p1 ! q1

indicating p1 q1 united set hence form single property
space, objects properties really type.
uniting overrides potential separate property spaces formed but, absence
two schemas, would insucient information available determine
nature relationship two properties.
379

fiFox & Long

2.4 Constructing Property Spaces Synthesising Types

objective stage construct type structure domain identifying
domain objects distinct property spaces. Objects appear one property
space, giving us basis deriving hierarchical type structure.
first part process involves completing seeded property spaces. first
task associate transition rules appropriate property space seeds.
easily done picking arbitrary property start finish component rule
identifying property space seed property belongs. never
ambiguity every property belongs one seed uniting ensures
properties referred rule belong seed. point distinction
states attributes becomes important. property space seed
attribute transition rule associated becomes attribute space dealt
differently property spaces certain respects explained below.
next step identify domain objects associated property space
attribute space.
object referred initial state construct type vector bit
set corresponding space inhabited object. object inhabit
one space. Habitation checked identifying properties hold,
initial state, object considered allocating states, rather
properties, appropriate state attribute spaces. every domain object
considered unique type identifier associated different bit patterns.
next task populate property spaces states. following definitions
required support explanation process.

Definition 14 world-state collection propositions characterising configuration
objects given planning domain description.

Definition 15 Given world-state, W , property space, P = (Ps; TRs; Ss; Os),
attribute space, P = (Ps; TRs; Os), object 2 Os, P -projection St
bag properties, possessed W , belongs Ps.

collection properties object, o, initial state divided set
bags properties, bag corresponding P -projection initial state o,
property attribute space P . bag added state set corresponding
property space, discarded corresponding space attribute space. need
extend spaces by, property space, adding states inferred
reachable objects within space along transitions within space. done
every state space, including states newly added process,
new states reachable. ordering properties within states irrelevant,
two states considered equal contain properties, regardless ordering
(they considered order-equivalent). Since, come use information
parts process invariant generation, require knowledge inclusion
relations pairs states, convenient mark stage. addition
reachable states important inference state invariants, use
discussed Section 2.7. attribute spaces receive different treatment point.
380

fiAutomatic Inference State Invariants

important difference observe that, since property spaces characterize exchange
properties, objects property space must start initial state members
property space. However, since attributes acquired without exchange,
possible objects particular attributes initial state acquire
attributes later. possible attribute space increasing attribute
transition rule associated it. now, therefore, consider attribute space see
whether objects added application corresponding increasing rule.
object added attribute space potentiates enablers
increasing rule attribute space. object potentiates enabling property
member state attribute space property belongs. Membership
spaces indicates object could enter state satisfies
enabling properties, would justify application increasing rule.
enabling property associated state attribute space static condition,
initial state checked confirm property true object
considered.
complication arises enabling property used seed attribute space
(in case attribute), necessary identify
objects attribute space consider addition current attribute space.
course could, principle, initiate loop process avoid marking
attribute spaces considered ensuring, iterating convergence,
attribute spaces loop completely assigned. correctness part
procedure discussed Section 3.
done state attribute spaces complete types
domain objects extracted. completeness construction phase discussed
Section 3.1.

2.5 Worked Example

fully worked example stages process help clarify involved.
Consider simplified version Rocket domain two operator schemas:

drive(X,Y,Z)
Pre:
Add:
Del:

load(X,Y,Z)

at(X,Y), fuelled(X), location(Z)
at(X,Z), unfuelled(X)
at(X,Y), fuelled(X)

Pre:
at(X,Y), at(Z,Y)
Add:
in(X,Z)
Del:
at(X,Y)
initial state containing four constants: rocket, package, London Paris,
relations: at(rocket,Paris), fuelled(rocket) at(package,London). observed
simplified Rocket domain rather odd feature load schema
restricted loading packages rockets. oddity highlighted analysis
constructed, showing analysis performed tim help understanding
(and debugging) behaviour domain. drive operator schema following
PRSs constructed variables X , Z respectively:
381

fiFox & Long

precs:
at1 , fuelled1
deleted precs: at1 , fuelled1
add elements: at1 , unfuelled1
precs:
at2
deleted precs: at2
add elements:
precs:
location1
deleted precs:
add elements: at2
load operator schema following PRSs constructed variables X ,
Z respectively:
precs:
at1
deleted precs: at1
add elements: in1
precs:
at2 , at2
deleted precs: at2
add elements:
precs:
at1
deleted precs:
add elements: in2
following rules built. first PRS generates first two rules subsequent
PRSs generate one rule.
fuelled1 ) at1 ! at1
at1 ) fuelled1 ! unfuelled1

at2 ! null
location1 ) null ! at2
at1 ! in1
at2 ) at2 ! null
at1 ) null ! in2

construct following united sets properties:

fat1; in1g
ffuelled1; unfuelled1g
fat2g
fin2g
382

fiAutomatic Inference State Invariants

used seed property spaces. first associate rules property
space seeds, resulting following assignment:

fat1; in1g
at1 ! in1 ; fuelled1 ) at1 ! at1
ffuelled1; unfuelled1g at1 ) fuelled1 ! unfuelled1
fat2g
location1 ) null ! at2 ; at2 ) at2 ! null;
at2 ! null
fin2g
at1 ) null ! in2
last two spaces converted attribute spaces association
attribute transition rules. resulting spaces supplemented domain
constants legal states. first identify subset legal states
domain objects identifiable initial state. use goal state
provide information properties objects. goal state might
unachievable objects cannot obtain required properties. would invalidate
tim's analysis domain. initial state rocket properties at1 fuelled1,
package property at1 , London property at2 Paris property at2 . Using
information associate domain constants developing state attribute
spaces obtain:

fat1; in1g
at1 ! in1; fuelled1 ) at1 ! at1
frocket; packageg
ffuelled1; unfuelled1g at1 ) fuelled1 ! unfuelled1
frocketg
fat2g
location1 ) null ! at2 ; at2 ) at2 ! null; fLondon; Parisg
at2 ! null
fin2g
at1 ) null ! in2
next step add legal states objects, identifiable far,
property spaces. results following structures, first two
extended inference (as explained) completed property spaces. last
two extended completed attribute spaces addition objects
potentially acquire associated attributes (also described below).

fat1; in1g

at1 ! in1; fuelled1 ) at1 ! at1

ffuelled1; unfuelled1g at1 ) fuelled1 ! unfuelled1
fat2g
fin2g

frocket; packageg
[at1 ]
frocketg
[fuelled1]

location1 ) null ! at2 ; at2 ) at2 ! null; fLondon; Parisg
at2 ! null
at1 ) null ! in2

last stage construction two property spaces add states
inferred reachable, via transition rules, objects property spaces.
example, packages go at1 in1, application rule at1 ! in1,
since rule available property space package belongs, at1
one legal states property space, add in1 legal state.
general, construct extension by, state space, identifying applicable
rules and, rule, creating new state removing properties start
383

fiFox & Long

rule adding properties finish rule. done states
order-equivalent already generated. enablers rules ignored,
consequence new states generated might unreachable.
process completed current example finished property spaces follows:

Property space 1
fat1; in1g at1 ! in1; fuelled1 ) at1 ! at1 frocket; packageg
[at1]; [in1]

Property space 2
ffuelled1; unfuelled1g at1 ) fuelled1 ! unfuelled1 frocketg

[fuelled1 ]; [unfuelled1 ]

consider attribute space turn add domain objects (not already
members) potentiate increasing rules. new domain objects added
first attribute space since London Paris potentiate increasing rule,
already present. However, second attribute space considered
observed rocket package potentiate increasing rule therefore
added new members. resulting attribute spaces are:

fat2g location1 ) null ! at2; at2 ) at2 ! null; fLondon; Parisg
at2 ! null
fin2g at1 ) null ! in2
frocket; packageg
oddity load operator revealed stage, since package rocket
assigned members in2 attribute space (meaning
attribute things them).

number distinct bit patterns constructed, indicating object membership
state attribute spaces, determines number distinct types exist
domain. Hence, simplified encoding Rocket domain, three distinct
types. rocket type [1101], package type [1001] Paris London
type [0010]. types given abstract identifiers, T0; T1 T2, might
meaningfully interpreted types of: movable object requiring fuel, movable object
location respectively. expected, London Paris type location, whilst
package type movable object rocket type movable object requiring fuel,
sub-type movable object.
distinction made state attribute spaces exploited
process inferring state invariants, discussed Section 2.7.

2.6 Assignment Types Operator Parameters

Types assigned parameters operators following way. Given
operator schema collection property spaces attribute spaces allocate type
vector variables schema. membership state attribute
spaces properties given variable recorded setting appropriate bits
vector variable. properties appear preconditions
384

fiAutomatic Inference State Invariants

schema considered, object satisfy preconditions operator
properties represented postconditions therefore right type
instantiation operator. type associated vector union
sub-types taken. union type assigned variable. domain
object, type sub-type type associated variable,
used instantiate variable. see process works, consider variable X
drive schema above. precondition properties X are: at1 , fuelled1.
members two property spaces 1 2. Therefore, type vector associated X
[1100]. observed type vector associated rocket [1101],
type rocket sub-type type X . sub-type, union
sub-types contains T0, type rocket. means X instantiated
rocket, domain constant, since domain constant type
appropriate sub-type relation. type operator parameters introduce new type
variables, Tk ::Tn unused values k n, k number existing types
n k plus number variables schema considered. type vector
variable [0010] Z type vector location static
relation Z appear argument predicate preconditions.
Z therefore acquires type London Paris, two objects
location true initial state. T4 super-type T2. taking unions
sub-types specify drive schema following way:

drive(X,Y,Z)

Params:
X:T0 Y:T2 Z:T2
Pre:
at(X,Y), fuelled(X), location(Z)
Add:
at(X,Z), unfuelled(X)
Del:
at(X,Y), fuelled(X)
stan exploits sub-typing relations inferred constructing instances drive operator. variable appears schema appear
preconditions instantiated objects type. domain
description contains basis inferring type restrictions case. variable
appear delete list without appearing precondition list, since assume
delete list elements appear preconditions. variable would occur
add list. would mean that, regardless properties holding object used
instantiate variable, initial state, acquire add list property freely.
Since acquisition would occur irrespective type object, variables
essentially polymorphic.

2.7 Inference State Invariants

final phase computation tim inference state invariants
property spaces. attribute spaces used inference invariants:
incorrect invariants would proposed tim attribute spaces inadvertantly used.
explains importance identifying attribute spaces earlier stages
algorithm.
current version tim capable inferring four kinds invariant, three
inferred property spaces (identity invariants, state membership invariants
385

fiFox & Long

invariants characterizing uniqueness state membership) one inferred
operator schemas initial state directly (fixed resource invariants). simplified
Rocket domain, considered above, example identity invariant is:

8x : Tk :8y:8z:(at(x; y) ^ at(x; z) ! x = z)
state membership invariant is:

8x : Tk:(9y : Tn:at(x; y) _ 9y : Tm:in(x; y))
uniqueness invariant is:

8x : Tk ::(9y : Tn:at(x; y) ^ 9y : Tm:in(x; y))
infer identity invariants property space considered turn, respect
properties states. property, example Pk P arity n > 1, occurs
state invariant following form, z vectors
containing n , 1 values, constructed:

8x:8y:8z:(P (y1::k,1; x; yk::n,1) ^ P (z1::k,1; x; zk::n,1) ! = z)
form invariant generalised deal case
> 1 occurrences Pk state space. case build following
expression, assumed k = 1, simplicity.

8x:8y1:::ym:(P (x; y1) ^ ::: ^ P (x; ym) ! (y1 = y2 _ y1 = y3 _ ::: _ ym,1 = ym ))
state membership invariants form:

8x:(Disjunct1 _ :: _ Disjunctn)
disjunct constructed single state. Thus, property space contains k
states k disjuncts invariant constructed property space.
one state membership invariant constructed property space.
Given collection states property space first identify supersets
states collection. supersets discarded, since invariants would
built would logically equivalent built subset states.
remaining state used build single disjunct. state considered contains
single property, Pk P arity n, expression

9y:P (y1::k,1; x; yk::n,1)
constructed. course, n = 1 existential quantifier disjunct
P (x). state contains one property, say denoted P 1 ::P ,
build (again, assuming k = 1 simplicity):

9y1 :::ym:(P 1(x; y1) ^ P 2(x; y2) ^ ::: ^ P (x; ym))
uniqueness invariants constructed similar way. property space
begin analysing superset states identify non-exclusive pairs subset states.
386

fiAutomatic Inference State Invariants

example, given subset states fat1 g fin1g superset state fat1 ; in1g,
observed two subset states mutually exclusive since at1 in1
simultaneously held. done analysis identified mutually exclusive pairs
states mark subset states unusable generation invariants. remaining
states considered possible pairings. every pair states, P; Q, generate
invariant following form assuming, simplicity, x first position
P 1 ::P n Q1 ::Qm. form invariant easily generalised, before.

8x::(9y1:::yn:(P 1(x; y1) ^ P 2(x; y2) ^ ::: ^ P n (x; yn))
^(9y1:::ym:(Q1(x; y1) ^ Q2(x; y2) ^ ::: ^ Qm (x; ym))))
fourth kind invariant inferred structure operator schemas
without reference property spaces domain type structure. call invariants
fixed resource invariants since capture physical limitations domain. Fixed
resource invariants cannot inferred state attribute spaces describe properties domain rather objects within it. following schema
Gripper domain provides example fixed resource invariants distinguished
three kinds:

move(X,Y)

Pre:
Add:
Del:

robot(X), room(Y)
robot(Y)
robot(X)

PRSs would built operator are:

precs :
robot1
deleted precs : robot1
add elements :
precs :
room1
deleted precs :
add elements : robot1
rules constructed are:

robot1 ! null


room1 ) null ! robot1

observed rules attribute transition rules robot1
attribute rather state-valued. means invariants first three kinds
discussed would constructed.
reason lack invariants first three forms encoding
robot embedded predicate, robot cannot participate directly state transitions.
obvious invariant robot, would naturally true domain,
387

fiFox & Long

robot always exactly one room cannot inferred using techniques far
described. fact, axiom world, domain, rather specific objects
within it, obtained information state transformations
objects.
seen operator schemas Gripper domain robot1 balanced. is, always deleted whenever added added whenever deleted.
means number occurrences robot initial state determines
number occurrences possible subsequent state. leads construction, domain, invariant

jfx : robot(x)gj = 1
since one robot relation initial state. form fixed resource
invariants always equational. invariant states size set combinations objects satisfying certain predicate equal (or, cases, less equal)
certain positive integer. integer large convenient
write equation would write logical expression. information encoded
fixed resource invariants useful identifying unsolvable goal sets without attempting plan them. example, ICPARC version three-blocks Blocks
world (Liatsos & Richards, 1997), three table positions, must
always exactly three clear surfaces. goal specifying three clear relationships identified unachievable fixed-resource invariants domain.
fixed-resource uniqueness invariants produced tim seen providing
form multi-mutex relations, contrast binary mutex relations inferred
construction plan graph Graphplan-based planners (Blum & Furst, 1995). Binary
mutex relations indicate two actions facts mutually incompatible, whilst multimutex relations indicate larger groups actions facts collectively incompatible.
Binary mutex relations, preventing fact true one object holding
two different objects simultaneously, extracted identity invariants
tim infers. Multi-mutex relations powerful binary ones. Stan detect
unsolvable goal-sets using fixed-resource uniqueness invariants even
binary mutex relations corresponding level indicate problem exists.
infer invariants examine predicates language see whether
exchanged add delete lists operator schemas. predicate
exchanged equally schemas (it always appears number times add
list delete list schema) predicate corresponds fixed resource.
single schema upsets balance predicate treated fixed. Given
fixed resource predicate, inferred never combinations
objects satisfying predicate initial state. slightly
odd encoding rocket world considered paper, location fixed resource.
fixed equally exchanged load schema. Examples fixed
resource invariants inferred various standard domains provided Appendix C.
certain circumstances necessary infer weaker invariant

jfx : P (x)gj k
388

fiAutomatic Inference State Invariants

positive integer k. P holds multiple objects initial state
possible subsequent state transformations, attribute acquisitions, result states
two instances P collapse one. P holds multiply often initial
state (or reachable state) necessary build invariant using
instead =. P state-valued, multiple instances never occur state
property space, safe assert equality construction invariant.
Automatic inference first three kinds invariants relies construction
property spaces discussed Section 2.4. discussed, distinction
state attribute spaces critical inference correct invariants. However,
using techniques described far, tim would lose information could
construct useful invariants. give example could occur consider
following simple encoding standard Blocks world:

move(X,Y,Z)
Pre:
Add:
Del:

on(X,Y), clear(X), clear(Z)
on(X,Z), clear(Y), clear(table)
on(X,Y), clear(Z)

operator, used Bundy et al. (1980), add list element clear(table) makes
reference constant. operator schema submitted analysis
current form PRS would built constant, rules would constructed,
hence state attribute spaces constructed, would fail record fact every
application move results state table clear. resulting analysis
would result incorrect invariants types. Grant (1996) identifies version
move operator awed, need maintain state correctness addition
invariant clear(table) add list. However, analyse schema correctly
first abstract remove constant, yielding following new schema:

move(X,Y,Z,T)
Pre:
Add:
Del:

on(X,Y), clear(X), clear(Z), table(T)
on(X,Z), clear(Y), clear(T)
on(X,Y), clear(Z)

Now, given initial state blockC blockA blockB table,
add proposition table(table) (so new precondition satisfied)
property attribute spaces constructed follows:

fon1g

clear1 ) on1 ! on1

fblockA; blockB; blockC g
[on1 ]
fon2; clear1g on2 ! clear1; clear1 ! on2; fblockA; blockB; blockC; tableg
table1 ) null ! clear1

second attribute space, invariant extraction algorithm
applied it. Consequently, invariants infer characterize
positions blocks (every block exactly one surface). pity,
information available attribute space could yield useful extra invariants.
particular, would infer invariant every block either clear
389

fiFox & Long

something it, cannot clear something it. reason
cannot infer invariant would asserted hold every object
attribute space, including table, even though actually true table (the
table things still clear).
2.7.1 Sub-space Analysis Property Attribute Spaces

solution problem loss invariants decompose property attribute
space contains k > 1 object types k sub-spaces. property sub-space structurally identical property space. Attribute sub-spaces identified used,
invariants obtained them. Property sub-spaces obtained analysis attribute spaces, following example show. reason distinguishing
sub-spaces property attribute spaces properties partitioned
sub-spaces property attribute spaces. original property
attribute space discarded sub-spaces used determining types
objects. role sub-space analysis enable construction additional
invariants.
consider Blocks domain described previous section example
benefits sub-space analysis. point invariant construction types
domain objects identified property attribute space membership,
table already known different type blocks. table
member property space on1 . Therefore, two sub-spaces constructed
attribute space, one type [11], blocks, one type [01],
tables. sub-spaces constructed property space contains
one type object. rules associated sub-spaces rules
original attribute space enabled objects appropriate type. second
two sub-spaces attribute sub-space inclusion increasing
attribute transition rule. stage two sub-spaces follows:

fon2; clear1g on2 ! clear1; clear1 ! on2
fblockA; blockB; blockC g
fon2; clear1g table1 ) null ! clear1; on2 ! clear1; ftableg
clear1 ! on2
attribute sub-space used invariant construction contains
attribute transition rule would result incorrect invariants (as case attribute
spaces), nothing gained developing further. However, state
sub-space completed addition states associated objects
space, initial state extension. resulting sub-spaces are:

fon2; clear1g on2 ! clear1; clear1 ! on2

fblockA; blockB; blockC g
[on2 ]; [clear1]
fon2; clear1g table1 ) null ! clear1; on2 ! clear1; ftableg
clear1 ! on2
new state sub-space infer following invariants, using type name
Block stand type vector [11]. infer identity invariant:
8x : Block (8y 8z (on(y; x) ^ on(z; x) ! = z))
390

fiAutomatic Inference State Invariants

state membership invariant:

8x : Block (9y : Block on(y; x) _ clear(x))
unique state invariant:

8x : Block :(9y : Block (on(y; x) ^ clear(x)))
Although additional invariant, table always clear, cannot infer
present.

2.8 Problem Mixed Spaces

happen encoding domain conceals presence attributes within
schemas point property space extension occurs. prevent
property space extension process terminating. example, simple lightswitch domain contains following two schemas:

switchon(X)
Pre:
Add:
Del:

switchoff(X)
Pre:
Add:
Del:

off(X)
on(X), touched(X)
off(X)
on(X)
off(X), touched(X)
on(X)

initial state switchA on. Two PRSs constructed:
precs :
off1
deleted precs : off1
add elements : on1 ; touched1

precs :
on1
deleted precs : on1
add elements : off1 ; touched1
giving rise two rules:


off1 ! on1 ; touched1

on1 ! off1; touched1

Uniting seeds one property space containing three properties. addition
rules property space follows:

fon1; off1; touched1g off1 ! on1; touched1; fswitchAg
on1 ! off1 ; touched1 [on1 ]
391

fiFox & Long

point extension space problem arises. following states
added: [off1; touched1], [on1; touched1; touched1 ], [off1; touched1; touched1; touched1 ]
on. cannot simply avoid adding properties already state extended two, apparently identical, properties might general refer different
arguments.
problem due fact touched1 actually increasing attribute
become apparent PRSs. consequence mixed spaces
constructed. mixed space property space containing hidden attributes. Tim detects
hidden attributes checking, extension, new state contains state already
generated initial state starting point. Thus, extension mixed space
above, tim would detect hidden attribute state [on1 ; touched1; touched1]
constructed, state contains state [on1 ] initiated extension.
detected hidden attribute two possibilities: either tim convert
mixed space attribute space, case invariants constructed,
attempt identify attribute split mixed space attribute space
property space containing state-valued components mixed space. take
option split state. allows us infer invariants concerning state-valued
properties.
tim takes difference including included states and, distinct
property difference, processes rules cutting rule containing property
two rules, least one attribute rule. following method
used cut rules. following, attr+ indicates one occurrences
attribute-valued property comma overloaded mean bag conjunction
bag union. rule form:

enablers ) start ! adds; attr+
two new rules forms:

enablers; start ) null ! attr+

rule form:

enablers ) start ! adds
enablers ) attr+ ; precs ! adds

two new rules forms:

enablers; precs ) attr ! null


enablers; attr ) precs ! adds

rule cutting separates attribute-valued properties state-valued properties.
pure attribute property spaces constructed. However discard
original mixed space used determining type structure
392

fiAutomatic Inference State Invariants

domain. additional type information could extracted state
attribute spaces built following analysis currently exploited.
analysis applied lightswitch domain, following new property
space attribute space built:
fon1; off1g off1 ! on1; on1 ! off1
fswitchAg
[on1 ]; [off1]
ftouched1g off1 ) null ! touched1; on1 ) null ! touched1 fswitchAg
Using Lightswitch stand type [11], following state membership invariant
constructed property space:
8x : Lightswitch (on(x) _ off(x))
tim constructs uniqueness invariant:
8x : Lightswitch :(on(x) ^ off(x))

3. Properties TIM

correctness tim relies constructing necessarily true invariants. demonstration true invariants constructed guarantees construction adequately discriminating type structure. cannot guarantee under-discrimination
argue over-discrimination occur type structures generated
tim. properties defined Section 2.1.
Over-discrimination would result distinguishing functionally identical objects
type level. would occur tim placed objects participate identical
state transitions different property spaces but, underlying partitioning
properties property spaces, cannot happen. Further, membership different
property spaces requires distinguishing state transformations,
functionally identical objects. Flawed assignment (assigning object
property space without corresponding state transformations), simply seen
erroneous, rather over-discrimination. possibility occurring
excluded property attribute space construction extension shown
correct Section 3.1.
failure detect type differences (under-discrimination) domain result
weak invariants, over-discrimination, could occur, would lead over-targeted
invariants would still true, subset objects ought
cover. Flawed assignment would clearly lead construction false invariants. Underdiscrimination, arise, therefore affects completeness state-invariant
inference procedure. lead over-generalisation operators since types
assigned operator parameters equally under-discriminating. enable meaningless instances formed, needlessly increasing size search space
must explored planner. clearly raises eciency issues
undermine formal properties planner exploits tim.
observed, consequence under-discrimination construction weak (but
valid) invariants. following example illustrates under-discrimination occur.
Given schema:
393

fiFox & Long

op(X,Y)
Pre:
Add:
Del:
initial state

p(X,Y)
q(X,Y)
p(X,Y)

p(a; c); p(b; c); q(b; d)

hold, following two property spaces constructed:

fp1; q1g p1 ! q1 fa; bg
[p1]; [q1]; [p1; q1 ]; [q1; q1 ]
fp2; q2g p2 ! q2 fc; dg
[q2 ]; [p2; p2 ]; [q2; p2 ]; [q2; q2 ]
Given property spaces impossible distinguish b c d, even
though analysis operator schema initial state reveal functionally distinct
b c d. seen that, although must always exchange p1 q1 ,
b p1 q1 simultaneously. similar observation made c
d. However, process invariants constructed cannot gain access
information. identity invariant constructed first property space is:

8x : 8y 8z 8u (q(x; y) ^ q(x; z) ^ q(x; u) ! = z _ = u _ z = u)
invariant weaker ideal, participate one q relation (b
participate two simultaneously). state membership invariant property space
is:
8x : ((9y : T1 p(x; y)) _ 9y : T1 q(x; y))
understates case b, p1 q1 simultaneously. unique
state invariant constructed property space, p1 q1 mutually
exclusive.

3.1 Correctness Completeness Transition Rule Construction Phase

correctness algorithm used tim depends two elements. Firstly, property
spaces identified algorithm must correctly populated. is, objects
assigned property spaces belong every achievable state must
included appropriate property space. Secondly, property spaces must
support generation correct invariants. second element examined Section 3.2.
interesting relationship exists states property space invariants generated space. Incorrect invariants contructed property space
missing achievable states. state membership invariants assert
object property space must one states property space. states
missing invariant false. prove achievable states
appropriate property space.

Theorem 1 Given initial state, , collection operator schemas, O, property space,
P = (Ps; TRs; Ss; Os), generated tim applied O, state, St,
394

fiAutomatic Inference State Invariants

reachable application valid linearised plan formed ground instances
operator schemas O, 2 Os, P -projection St o, StoP , Ss.

Proof:

proof induction length plan yields state St. base
case plan contains operator instances St = . P -projection
Ss, definition first phase property space construction process described
Section 2.4.
Suppose St generated plan length k + 1, last step penultimate
state pre-St. Let P -projection pre-St pre-StoP . inductive hypothesis,
state Ss. affect state o, P -projection St
pre-StoP , therefore Ss trivially. Otherwise, consider operator schema,
Op 2 O, formed. described Section 2.7, constants appear Op
variables body Op parameters Op. Let initial collection PRSs
constructed Op, parameters instantiated creation a,
set PRS1 :::PRSn every PRSi form:
precs :
Pi
deleted precs : Di
add elements : Ai
initial collection collection formed prior splitting.
value ith PRS lead construction k + 1 transition rules,
k size bag intersection, Xi , Di Ai . k rules
following form:
8c 2 Xi (Pi fcg ) c ! c)
remaining rule form:

Pi (Di Xi ) ) (Di Xi) ! (Ai Xi )
refer latter rule PRSi ith complex rule. subset n complex
rules contain property Ps either start finish will, therefore,
relevant transition pre-St St. observed complex
rules (PRS1 :::PRSm without loss generality) must P uniting process
described 2.3.
define pres(a)oP P -projection preconditions o. Similarly,
adds(a)oP dels(a)oP defined P -projections add delete lists
respectively. construction PRSs, defined Section 3.1,


= Pi
Mm
adds(a)oP = Ai
Mm
dels(a)oP = Di

pres(a)oP

1
1

1

395

fiFox & Long

restriction delete lists must subset preconditions,
fact applicable pre-St, follows dels(a)oP v pres(a)oP v pre-StoP . Since
v represents bag inclusion seen separate bags Di included
pre-StoP without overlap.
extension process involves iterated application rules explained
Section 2.4 indicated pseudo-code algorithm presented Appendix B.
rule applicable state start must included state. Therefore
complex rules applicable, regardless sequence application, pre-StoP .
follows state
(pre-StoP

Mm (Di Xi)) Mm (Ai Xi)
1

1

generated extension process. definition Xi , fact Di v pre-StoP ,
state written as:
(pre-StoP

Mm Di) Ai
1

which, observed above, just:
(pre-StoP dels(a)oP ) adds(a)oP
equals StoP standard semantics operator application strips.

2

proof demonstrates splitting, discussed 2.3, result generation
invalid invariants. However, splitting compromise completeness invariantgeneration process. result inclusion unreachable states property spaces,
consequence identity state membership invariants generated
weaker would otherwise case. discussed Section 3.2.
explain role splitting PRS construction phases. domain
object strips domain associated finite automaton states consist
properties (for example, at1 ) have, either initially result application
arbitrary length sequence operators. Objects observed
type identical automata property level. PRSs capture ways
operator applications modify configurations individual objects hence
provide encoding automata.
PRSs built two phases. first phase, parameters
schemas considered, possible object state transitions captured. However,
transitions conceal functional distinctions inherent domain description
would lead premature amalgamation property spaces, observed
discussion Rocket domain Section 2.5. example observed use
standard formula construction rules PRSs alone would result
failure detect type distinction rockets packages.
second phase assists type inference processes avoiding under-discrimination
distinguishing enablers state transformation properties exchanged
396

fiAutomatic Inference State Invariants

transformation. PRS characterizing exchange k properties split
form k + 1 new PRSs. PRSs 4 5, given Section 2.3, show two
PRSs constructed single PRS containing single exchanged property.
simple example, one split required remove exchanges. general might
necessary split repeatedly exchanges removed, shown example given
PRS 6 Section 2.3. non-exchange combinations properties deleted precs
add elements considered splitting. resulting PRSs lead
construction transition rules allow generic state transformations, movement
one location another, separated specific nature objects
make transformations.
observed rules result splitting process general
rules would obtained PRS prior splitting.
distinguish precisely properties take part state transitions
properties simply enable transitions, allowing finer type distinctions
inferred basis functionalities objects domain. Finer distinctions
made process seeding property attribute spaces uniting.
uniting merges, single equivalence classes, properties appear
start finish rule.
argue state transformations accounted end second
phase. result second phase automata formed first phase
separated collections simpler automata possible, transitions
lost finer grained encoding possible transitions made
objects appropriate properties. PRSs constructed phase support
construction rules allow objects making transitions occupy different property
spaces. second phase PRSs may under-constraining, sense
analysis subsequent schemas might eliminate possibilities keeping open,
example 2.3.1, set PRSs obtained end second phase cannot
over-constraining first phase PRSs considered splitting.
subtlety concerns consequence, type level, assigning two functionally
distinct objects state attribute space. example, example 2.5, rocket
package assigned property space fin1; at1 g attribute space
fin2g. However, rocket fuelled unfuelled, package cannot,
distinction emerges property attribute membership vectors
associated rocket package objects. Membership additional property space
ffuelled1; unfuelled1g means rocket assigned type sub-type type
package functional distinctness rocket package recognised. discussed,
oddity encoding results package assigned membership
fin2g attribute space. Furthermore, at1 in1 united, effect
rockets make at1 ! in1 transition used instantiate variables type
movable object, even variables type intended instantiated
package. nothing domain description prevent interpretation.
conventional encoding load schema would prevent rocket loaded
object, would cause refinement type structure would
identify loadable objects, would prohibit use rocket forming instances
operators restricted operating objects.
397

fiFox & Long

construction transition rules follows simple rule whereby undeleted preconditions used enable transformation state deleted preconditions
PRS hold one added elements PRS hold. Given assumption
deleted atoms operator schema must appear preconditions schema,
rules correctly characterize strips-style state transformations. possible transformations captured second phase PRS construction. complete set
correct transition rules therefore constructed.
Given correctness completeness transition rule construction phase, correct
initial allocation objects spaces depends simply correctly checking membership
initial properties object property sets, formed uniting rules,
used seed spaces. Extension property spaces done straightforward
application transition rules, configurations properties occupied
objects property space added end extension phase.
Extension attribute spaces unproblematic cases potential enabler
attribute. one is, process attribute space enabler
completed could, appears, initiate loop attribute space extension process.
fact, happen tim able detect loop occurred avoid
repeatedly iterating it.
following example illustrates problem way solved tim. Suppose
three attribute spaces:

Attribute space 1

fq1g p1 ) null ! q1 fa; bg

Attribute space 2
fr1g q1 ) null ! r1 fcg

Attribute space 3
fp1g r1 ) null ! p1 fdg
spaces extended addition objects potentiate increasing rules,
discussed Section 2.4. problem arises enablers rules states,
attributes, extension attribute space 1 enabler, p1 , attribute.
attribute space p1 yet extended, necessary complete
space using complete 1. Extension 3 requires extension 2,
reason, requires extension 1 requires extension 3, on.
way tim avoids re-entering loop marking space, considered,
seen iteration. marked space encountered extended
used already complete. second iteration required extend
spaces still require completion. Subsequent iterations required
process converges. experiments suggest unusual
two iterations required. worst case upper bound As, number
domain constants number attribute spaces (which limited number
properties), hence quadratic size domain description.
398

fiAutomatic Inference State Invariants

extension process starts attribute space 1, example, attribute
space 1 marked seen first iteration. Tim goes
extend space 3 extension space 1 depends upon space 3 complete.
Space 3 marked seen iteration space 2 considered. Space 2
marked space 1 revisited. space 1 marked tim infers loop
entered. objects added space 2 without extension objects space 2
added space 3. Finally, objects space 3 added space 1
first iteration complete.

fq1g p1 ) null ! q1 fa; bg [ fc; dg
fr1g q1 ) null ! r1 fcg [ fa; bg
fp1g r1 ) null ! p1 fdg [ fc; a; bg
However, space 2 yet complete, second iteration required. iteration
starts place first process repeated, except
iterations required example.

3.2 Correctness State Invariants

argue correctness invariant inference procedure considering
four kinds invariant turn. following arguments rely upon correctly distinguishing property spaces attribute spaces, since invariant analysis cannot
performed attribute spaces. scope confusing distinction extension mixed spaces, extract attributes mixed spaces checking inclusion
existing states new states generated extension. process discussed
Section 2.8.

Definition 16 Given property space P = (Ps; TRs; Ss; Os), Ss partitioned
three disjoint sets: Sssubs Sssups contain states Ss included
(as bags) include (as bags), respectively, least one state Ss Ssind
contains independent states Ss neither Sssubs Sssups .
Theorem 2 Given property space P = (Ps; TRs; Ss; Os), set states Ss

union three disjoint sets states Ssind , Sssubs Sssups , object, o,
Os following families invariants hold:
1. identity invariants;
2. state membership invariants;
3. unique state invariants.
defined Section 3.2.

Proof:

address kind invariant turn. Theorem 1 every object Os must
state Ss. Furthermore, states object Os, respect property
Ps, Ss. follows properties partitioned spaces
399

fiFox & Long

seeding process. Therefore, maximum number occurrences property
p Ps, possessed object Os state world, bounded
maximum number instances property state Ss (these maximum values
might equal since Ss contain inaccessible states). identity invariants simply
express bound properties objects Os.
Every object Os must state Ssind [Sssubs . follows definition
sets Definition 16 Theorem 1. state membership invariants assert
every object Os must least one states, disjunct invariant
corresponding assertion membership one states.
argue correctness unique state invariants, observe proposed
invariants would false paired states mutually exclusive.
case, either state extension process would put properties could simultaneously held bag, properties would simultaneously held
initial state hence would appear bag initial construction property
space. either case, state exist property space superset
non-exclusive states. However, uniqueness invariants generated pairs states
drawn Ssind [ Sssups non-exclusive pairs states lead
generation incorrect invariants.

2
fixed resource invariants always associated particular predicate. atoms
built predicate balanced add delete lists operator
schemas number occurrences atoms initial state fixed
subsequent states. invariant expresses. invariant constructed
every predicate forms balanced atoms.
Since new techniques required infer invariants sub-spaces,
argument required support correctness invariants formed following sub-space
analysis.
Although Theorem 2 demonstrates correctness invariants inferred tim
possible weak invariants inferred presence unreachable states Ss.
Weak identity invariants inferred unreachable state generated, extension,
containing instances property contained reachable state.
happens identity invariant generated weaker would ideal,
still valid. Further, property space contains unreachable states cause
inclusion additional false disjuncts state membership invariants, since
false disjuncts exclude satisfying assignments presence invalidate
invariants. Unreachable states cause additional tautologous uniqueness invariants
generated affect strength invariants refer reachable states.
Clearly cannot hope identify unreachable states, analysis would
hard planning itself.
invariants generated attribute spaces tim cannot claimed
complete. Sub-space analysis rectifies extent identifying property spaces
exist within attribute spaces allowing invariants generated.
analysis could refined.
400

fiAutomatic Inference State Invariants

3.3 Effects TIM Properties Planner

Tim sound, planner uses tim danger losing soundness result.
Tim certainly complete domain axioms invariant properties

kinds cannot extracted current version. example, Kautz Selman
(1998) identify optimality conditions simplifying assumptions amongst different
kinds axioms might inferred domain. optimality condition
Logistics domain might be: package returned location
removed from. simplifying assumption domain might be: truck
loaded immediately move (assuming necessary loads done parallel).
constraints require deeper analysis domain currently performed
tim, intend characterise infer future work.
cannot guarantee type structure inferred tim always fully discriminating, although guarantee over-discriminating. However, failure
tim's part infer structure inferred impact
completeness planner using tim because, cases, tim return unstructured
domain planner therefore default reasoning unstructured domain
necessary.

4. Experimental Results

examination tim's performance carried several dimensions. consider
three specific dimensions here: viability analysis typical benchmark domains;
scalability analysis utility performing analysis prior planning.
general performance standard benchmark problems provides indication scale
overhead involved using tim preprocessing tool. experiments performed
Linux 300MHz PC 128 Mb RAM. Figure 3 shows that, even large
problem instances, overhead entirely acceptable. Mystery problems listed
table large (involving initial states containing hundreds facts) could
solved stan, ipp (Koehler, Nebel, & Dimopoulos, 1997) Blackbox (Kautz &
Selman, 1998) aips-98 competition. nature Mystery domain described
Appendix C. emphasises relative costs preprocessing planning efforts.
selection problems used construct table 3 justified follows. Blocks
world used representative example three encodings supplied
pddl release. are: simple encoding (prob12), att encoding (prob18)
snlp encoding (prob23). Hanoi set contains collection reasonably sized problems.
representative group relatively large Mystery instances chosen pddl
release. two Tyre world instances two strips instances available
release. three Logistics problems three largest simple strips encoding
included pddl release.
second dimension scalability analysis. analytic examination
algorithm determine upper bound performance polynomial
key domain problem components, including number operator schemas, number
literals operators, numbers objects facts initial state number
arities predicates language. Figure 4 shows performance tim roughly
quadratic size problem specification. graph, size crudely equated
401

fiFox & Long

Domain problem
Blocks
prob12.pddl
prob18.pddl
prob23.pddl
Hanoi
3-disc
4-disc
5-disc
6-disc
7-disc
Mystery
prob060.pddl
prob061.pddl
prob062.pddl
prob063.pddl
prob064.pddl
Tyre-World prob01.pddl
prob02.pddl
Logistics
prob04.pddl
prob05.pddl
prob06.pddl

Parse time
2
3
2
2
2
3
3
4
17
48
26
11
21
5
6
4
4
4

Analysis time
0
1
1
1
1
1
1
2
15
82
37
7
21
2
2
2
2
2

Output time Total
2
5
2
7
1
5
4
7
4
7
4
8
4
9
4
11
9
43
29
160
10
74
8
27
10
52
28
36
28
37
5
12
6
12
6
13

Figure 3: Table showing tim's performance milliseconds standard domains problems. timings elapsed times minor discrepancies totals arise
rounding.

402

fiAutomatic Inference State Invariants

Tim Analysis Mystery Domain

12000
10000



8000
Millisecs 6000



4000
2000










0
0





10000 20000 30000 40000 50000 60000 70000 80000
Size file

Figure 4: Graph showing tim's performance Mystery problems, plotting time
size (in characters) problem file. solid line plot quadratic function.
number characters specification file. graph constructed running
tim strips Mystery domain problems pddl release. increasing
sizes problem specifications ect increases various categories
objects domain corresponding facts describe initial states.
Figure 5 shows effect tim's performance number operator schemas
increases. graph constructed using artificial domain new operator
causes two new state transitions described two new literals. Thus, number
operators number properties increasing whilst number objects stays constant.
domain described detail Appendix E. graph indicates linear growth
cost analysis.
final dimension evaluating tim effect exploitation output
planner. Gerevini Schubert (1998) Kautz Selman (1998) provide convincing
evidence supporting powerful role state invariants enhancing performance
SAT-based planning. Figure 6 demonstrate power inferred types showing
advantage stan tim obtains stan without tim untyped Rocket domain
problems. Figure 6 shows effect performance increasing number packages
transported. time taken stan tim grows linearly, whilst stan without
tim follows cubic curve. p packages problem instance stan tim
constructs 4(p +1) operator instances stan without tim constructs (p +3)2(p +5)+2p
instances. demonstrates type information significant factor
advantage depicted graph. Figure 7 demonstrates similar improvement
obtained Logistics domain. graph series sub-problems considered
403

fiFox & Long

70
65
60
55
50
Millisecs 45
40
35
30
25
20

Tim Performance Increasing Number Operators

3
0

3
2

3

3
4

3

3

3

3

3

3

3

6
8
10
Number operators

3

3

3

12

33

14

16

Figure 5: Graph showing consequences increasing number schemas inferrable property spaces.
Effect Tim Performance Stan

12000

3

STAN without TIM 3
STAN TIM +

10000
8000

3

Millisecs6000
4000

3

3

3

3

3

3

33
3
333
33
+ + ++ + + + ++ + + + ++ +
+ 3
++
+ 3
0 3

2000

0

5

10

15
20
25
Number packages

30

35

40

Figure 6: Graph showing comparison stan stan without tim Rocket
domain problems generated Rocket domain provided Appendix D.
404

fiAutomatic Inference State Invariants

Effect Tim Performance Stan

12000
10000

STAN without TIM
STAN TIM

8000
Millisecs6000
4000
2000
0

1

1.5

2

2.5
3
3.5
Number sub-problems

4

4.5

5

Figure 7: Graph showing comparison stan stan without tim Logistics
domain problems.
sub-problem involves independent transportation single package
two cities.
simple domains, overhead carrying analysis outweigh
advantages offered. example, Movie domain used competition stan gained
benefits using tim paid overhead detriment performance
instances domain. However, general observe benefits analysis
increase increasing complexity domains.

5. Related Work
Although importance state invariants ecient planning observed
relatively little work automatic inference invariants. published work
closely resembles research described paper state constraint inference
system discoplan, Gerevini Schubert (1998). Discoplan enables inference
sv-constraints correspond subset identity invariants. reason
discoplan restricted subset generates sv-constraints pairs literals
(one addlist schema delete list) arguments
vary one place. Tim infer identity invariants vectors arguments vary,
shown Section 2.7. Discoplan cannot currently infer singly varying constraints
(although techniques described Gerevini Schubert (1996a) yet fully
implemented discoplan). example, discoplan cannot infer blocks
405

fiFox & Long

one surface, analysis Blocks world domain cited paper. Tim
infer invariants sub-space analysis.
Gerevini Schubert (1996a, 1996b) examined potential inferring
parameter domains similar operator parameter types inferred tim.
domains inferred iterative process accretion similar attribute
space extension process tim. However, accretion process describe synthetic,
parameter domains synthesised directly operator descriptions
initial state. Tim analytic system constructs types analysis functional properties domain objects. analytic approach provides rich information
source structures, including domain invariants, derived.
implicative constraints inferred discoplan correspond implicit
type assignment would arise type structure built tim. implicative
constraint generated discoplan refers separation functional roles objects.
particular, irre exivity on, in:
8x 8y (on(x; y) ! :(x = y))
captured using kind constraint. Tim cannot currently infer invariants.
tim uses analysis based state view objects domain able
generate broader collection invariants, including state membership unique state
invariants currently produced discoplan.
Although discoplan deal negative preconditions tim cannot yet manage
them, invariants produce overall currently less powerful inferred
tim.
Apart work Gerevini Schubert, older work inference
invariants relies generation candidate invariants
confirmed inductive process domain operators. Two examples
work Kelleher Cohn (1992) Morris Feldman (1989). former work
concentrates identifying directed mutual persistence relations, hold pairs
facts domain when, established, second continues hold
first does. use relations leads inference collection constraints
fall uniqueness invariants inferred tim. work described (Morris
& Feldman, 1989) authors build invariants using truth counts counts
number propositions particular identified sets must true state
domain. Sets count 1 used build invariants
subset state membership uniqueness invariants. authors describe methods
attempting identify sets facts work. work, common
Kelleher Cohn Gerevini Schubert, builds invariants first hypothesising
possible seed invariants determining validity analysing effects
operators seeds. contrast generate-and-test strategy, tim produces
correct invariants infers deep, structural analysis domain.
inference invariants exhaust possibilities analysis. example,
type structure inferred automatically analysis, shown
dramatic potential eciency planning. relationship enablers,
state transitions enable, determines ordering satisfaction goals,
significance eciency. Further, state-based view behaviour
406

fiAutomatic Inference State Invariants

domain objects would allow techniques described McCluskey Porteous (1997)
automated.
McCluskey Porteous (1997) proposed explored object-centred approach
planning. approach based provision, domain engineer, rich
collection state invariants object sorts participating functional relationships
domain. invariants exploited domain compilation phase facilitate
ecient planning application domain. Tim infers precisely sorts collections
state invariants McCluskey Porteous provide hand.
Grant (1996) generates state invariants state descriptions, provided hand,
uses invariants build operator schemas. approach clearly related even
though objectives analysis different. Grant concerned automatic
synthesis domain descriptions rich requirements specification provided
expert user. concern reverse-engineering domain description obtain information help increase eciency planners applied domain. Although
primary objectives use tim enhance performance planning within
domain, tim provides valuable tool construction domain descriptions
revealing underlying behaviours domain engineer implicitly imposed,
helping debugging domain descriptions.

6. Conclusion
Tim planner-independent set techniques identifying underlying structure

domain, revealing type structure collection four different kinds invariant conditions. One important application techniques domain debugging aid
construction large complex domains. Using tim revealed many anomalies
domains encoded us others, greatly assisted us understanding
stan's performance many domains problems. Another important application
increasing eciency planners making explicit planner information
domain would otherwise infer, domain representation,
planning.
Tim generates rich collection invariants containing many inferrable
related systems, discussed previous section. results presented Gerevini
Schubert (1998) suggest marked improvement obtained use
invariants performance planners based SAT-solving techniques. analysis
yet done determine advantages might obtainable using invariants
planners based architectures. Stan yet exploit invariants produced tim planning. uses type structure fixed resource invariants
currently developing extension stan fully exploit kinds
invariant. expect able use uniqueness identity invariants shortcut
effort involved deducing significant subset necessary mutex relations
graph construction.
analysis performed tim ecient, growing slowly quadratic function
size initial state analysed. empirical analysis consider
effect tim's performance increasing numbers operator schemas. However,
argument presented Section 4 shows tim's analysis grows linearly number
407

fiFox & Long

operator schemas, linearly number domain constants linearly
size initial state. factors take account, confirms
polynomial performance size (and related structure) domain increases.
type analysis performed tim differs, important respects, various
forms type analysis performed compilation programs written strongly
typed languages. latter context type-correctness program judged
respect imposed context basic types. Tim infers basic types domain
description impossible domain specification well-typed. Consequently
attempt type-check domain descriptions using tim. direction
hope move near future, type-checking enable unsolvable
problems detected unsolvable statically rather planning time. currently
focus type inference exploitation inferred type structure
management search space planner.

7. Acknowledgements

would thank Alfonso Gerevini, Gerry Kelleher anonymous referees
useful discussions helpful comments earlier drafts paper.

Appendix A. FTP Web Sites

aips-98 Planning Competition FTP site at:

http://ftp.cs.yale.edu/pub/mcdermott/aipscomp-results.html.

web site, stan tim executables found, at:



http://www.dur.ac.uk/ dcs0www/research/stanstuff/planpage.html

Appendix B. TIM Algorithm

following pseudo-code description tim algorithm.
fConstruct base PRSs (Section 2.3)g
Ps := fg;
operator schema, O,
variable O, x,
construct PRS x add Ps;

fSplit PRSsg

PRS Ps, P,
property, p, appears P adds deleted precs fields
split P p, P' Q replace P P' Q Ps,
split P p:
construct PRS Q precs P, deleted precs adds set fpg;
construct PRS P' P removing p deleted precs adds P;

fConstruct transition rules (Section 2.3)g
Ts := fg;

PRS Ps, P,
construct transition rule P add Ts;

fSeed property attribute spaces (Section 2.3)g

let property initially assigned separate equivalence class;
rule, r, Ts
merge together (unite) equivalence classes properties start finish r;

408

fiAutomatic Inference State Invariants

construct separate space equivalence class properties;

fAssign transition rules (Section 2.4)g

rule, r, Ts
place r space associated equivalence class containing properties
start (and finish) r, s;
r increasing decreasing rule
mark attribute space;

fAnalyse initial state (Section 2.4)g

object, o, domain
identify bag initial properties o, I(o);
space, s,
construct bag properties I(o) belong equivalence class
associated s, b;
b non-empty
add space s;
attribute space
add b state s;

fExtend property spaces (Section 2.4)g

property space, p,
unextended state p, s,
mark extended;
newgen := fg;
rule p, r,
start r included
add state snew = (s ominus start oplus end) newgen;
snewis superset state newgen
mark p attribute space exit analysis p;
add newgen states p;

fExtend attribute spaces (Section 2.4)g

changes := TRUE;
changes,
changes := FALSE;
unmarked attribute space, a,
extend extend a:
mark a;
rule a, r,
property enablers r, p,
p's equivalence class associated unmarked attribute space, a',
extend a';
add objects appear every space associated enabling property r a;
objects added
changes := TRUE;

fIdentify types (Section 2.6)g

object domain, o,
identify pattern membership spaces o, tt;
associate type pattern, tt, o;
operator schema, O,
argument O, x,
identify pattern membership spaces x implied properties x
preconditions O, tt;
associate type pattern, tt, x O;

fConstruct invariants (Section 2.7)g

property space, P,
property P, p,
construct identity invariant p;
construct state membership invariant P;
construct uniqueness invariant P;

409

fiFox & Long

Appendix C. Example Output

following output produced tim found, along examples,
stan webpage. examples show details analysis performed
three domains: Flat-tyre domain, Mystery domain Logistics domain.
analysis done respect initial state set operator schemas. operator
schemas used three domains provided pddl strips releases
domains. initial states taken pddl release. pddl release
found http://www.cs.yale.edu/HTML/YALE/CS/HyPlans/mcdermott.html.

C.1 Tyre World
TIM: Type Inference Mechanism - support STAN: State Analysis Planner
D. Long M. Fox, University Durham

Reading domain file: domain01.pddl
Reading problem file: prob01.pddl
TIM: Domain analysis complete flat-tire-strips
TIM: TYPES:
Type
Type
Type
Type
Type
Type
Type
Type

T0
T1
T2
T3
T4
T5
T6
T7

=
=
=
=
=
=
=
=

{wrench}
{wheel2}
{wheel1}
{trunk}
{the-hub}
{pump}
{nuts}
{jack}

noticed two wheels separated different types.
one wheel intact intact, operator repairing wheels
intact. tools given different types.
appear constants different operators therefore functionally distinct.
TIM: STATE INVARIANTS:
FORALL x:T4. (on-ground(x) lifted(x))
FORALL x:T4. (on-ground(x) lifted(x))
FORALL x:T3. (closed(x) open(x))
FORALL x:T3. (closed(x) open(x))

410

fiAutomatic Inference State Invariants

FORALL x:T1 U T2. (deflated(x) inflated(x))
FORALL x:T1 U T2. (deflated(x) inflated(x))

invariants hubs (below) suggest almost anything could hub. Since
case type structure under-discriminating. However, additional
invariants drawn sub-space analysis provide enough information, principle,
discriminate fully types. information yet fully exploited.
FORALL x:T4. FORALL y1. FORALL z1. on(y1,x) on(z1,x) => y1 = z1
FORALL x:T4. (Exists y1:T0 U T1 U T2 U T5 U T6 U T7. on(y1,x)
free(x))
FORALL x:T4. (Exists y1:T0 U T1 U T2 U T5 U T6 U T7. on(y1,x)
free(x))
FORALL x:T4. FORALL y1. FORALL z1. tight(y1,x) tight(z1,x) => y1 = z1
FORALL x:T4. FORALL y1. FORALL z1. loose(y1,x) loose(z1,x) => y1 = z1
FORALL x:T4. ((Exists y1:T0 U T1 U T2 U T5 U T6 U T7. tight(y1,x)
fastened(x))
(Exists y1:T0 U T1 U T2 U T5 U T6 U T7. loose(y1,x)
fastened(x)) unfastened(x))
FORALL x:T4. ((Exists y1:T0 U T1 U T2 U T5 U T6 U T7. tight(y1,x)
fastened(x))
(Exists y1:T0 U T1 U T2 U T5 U T6 U T7. loose(y1,x)
fastened(x)))
FORALL x:T4. ((Exists y1:T0 U T1 U T2 U T5 U T6 U T7. tight(y1,x)
fastened(x)) unfastened(x))
FORALL x:T4. ((Exists y1:T0 U T1 U T2 U T5 U T6 U T7. loose(y1,x)
fastened(x)) unfastened(x))

TIM: DOMAIN INVARIANTS:
|{x0:
|{x0:
|{x0:
|{x0:
|{x0:
|{x0:
|{x0:
|{x0:
|{x0:

container(x0)}| = 1
hub(x0)}| = 1
intact(x0)}| = 1
jack(x0)}| = 1
nut(x0)}| = 1
pump(x0)}| = 1
unlocked(x0)}| = 1
wheel(x0)}| = 2
wrench(x0)}| = 1

TIM: ATTRIBUTE SPACES:

411

fiFox & Long

attribute space properties first groups subjected much
rigorous analysis sub-space invariants below.
Objects, x, T0 U T1 U T2 U T5 U T6 U T7 property:
Exists y1:T3. in(x,y1);
Exists y1:T4. on(x,y1);
Exists y1:T4. tight(x,y1);
Exists y1:T4. loose(x,y1);
have(x);
Objects, x, T3 property:
Exists y1:T0 U T1 U T2 U T5 U T6 U T7. in(y1,x);
Objects, x, T3 property: container(x);
Objects, x, T4 property: hub(x);
Objects, x, T1 property: intact(x);
Objects, x, T7 property: jack(x);
Objects, x, T6 property: nut(x);
Objects, x, T5 property: pump(x);
Objects, x, T3 property: unlocked(x);
Objects, x, T1 U T2 property: wheel(x);
Objects, x, T0 property: wrench(x);

TIM: OPERATOR PARAMETER RESTRICTIONS:
inflate(x1:T1)
put-on-wheel(x1:T1 U T2,x2:T4)
remove-wheel(x1:T1 U T2,x2:T4)
put-on-nuts(x1:T6,x2:T4)
remove-nuts(x1:T6,x2:T4)
jack-down(x1:T4)
jack-up(x1:T4)
tighten(x1:T6,x2:T4)
loosen(x1:T6,x2:T4)
put-away(x1:T0 U T1 U T2 U T5 U T6 U T7,x2:T3)
fetch(x1:T0 U T1 U T2 U T5 U T6 U T7,x2:T3)
close-container(x1:T3)
open-container(x1:T3)
cuss()

TIM: ADDITIONAL STATE INVARIANTS, USING SUB-SPACE ANALYSIS:

report additional state invariants add information invariants
already listed. TIM currently reports invariants subsumed earlier collection.
observed first wheel intact second not, gives
rise following new invariant wheels second type.
412

fiAutomatic Inference State Invariants

FORALL x:T2. (deflated(x))

first attribute space, contains objects except trunk hub,
subjected sub-space analysis yielding rich new collection invariants.
FORALL x:T0. FORALL y1. FORALL z1. in(x,y1) in(x,z1) => y1 = z1
FORALL x:T0. (Exists y1:T3. in(x,y1) have(x))
FORALL x:T0. (Exists y1:T3. in(x,y1) have(x))
FORALL x:T1. FORALL y1. FORALL z1. in(x,y1) in(x,z1) => y1 = z1
FORALL x:T1. FORALL y1. FORALL z1. on(x,y1) on(x,z1) => y1 = z1
FORALL x:T1. (Exists y1:T3. in(x,y1) have(x)
Exists y1:T4. on(x,y1))
FORALL x:T1. (Exists y1:T3. in(x,y1) have(x))
FORALL x:T1. (Exists y1:T3. in(x,y1) Exists y1:T4. on(x,y1))
FORALL x:T1. (have(x) Exists y1:T4. on(x,y1))
FORALL x:T2. FORALL y1. FORALL z1. in(x,y1) in(x,z1) => y1 = z1
FORALL x:T2. FORALL y1. FORALL z1. on(x,y1) on(x,z1) => y1 = z1
FORALL x:T2. (Exists y1:T4. on(x,y1) have(x)
Exists y1:T3. in(x,y1))
FORALL x:T2. (Exists y1:T4. on(x,y1) have(x))
FORALL x:T2. (Exists y1:T4. on(x,y1) Exists y1:T3. in(x,y1))
FORALL x:T2. (have(x) Exists y1:T3. in(x,y1))
FORALL x:T5. FORALL y1. FORALL z1. in(x,y1) in(x,z1) => y1 = z1
FORALL x:T5. (Exists y1:T3. in(x,y1) have(x))
FORALL x:T5. (Exists y1:T3. in(x,y1) have(x))
FORALL x:T6. FORALL y1. FORALL z1. in(x,y1) in(x,z1) => y1 = z1
FORALL x:T6. FORALL y1. FORALL z1. tight(x,y1)
tight(x,z1) => y1 = z1
FORALL x:T6. FORALL y1. FORALL z1. loose(x,y1)
loose(x,z1) => y1 = z1
FORALL x:T6. (Exists y1:T4. tight(x,y1)
Exists y1:T4. loose(x,y1)
have(x) Exists y1:T3. in(x,y1))
FORALL x:T6. (Exists y1:T4. tight(x,y1)
Exists y1:T4. loose(x,y1))
FORALL x:T6. (Exists y1:T4. tight(x,y1) have(x))
FORALL x:T6. (Exists y1:T4. tight(x,y1)
Exists y1:T3. in(x,y1))
FORALL x:T6. (Exists y1:T4. loose(x,y1) have(x))
FORALL x:T6. (Exists y1:T4. loose(x,y1)
Exists y1:T3. in(x,y1))
FORALL x:T6. (have(x) Exists y1:T3. in(x,y1))

413

fiFox & Long

C.2 Mystery Domain

Mystery domain devised Drew McDermott aips-98 planning competition.
intention conceal structure problem domain employing obscure
encoding transportation domain. code replaces locations names foods
routes eats relations. transports pleasures cargos
pains. Cargos transports locations, relation encoded craves.
cargo either location transport encoded fears relation. Transports
restricted capacity encoded planets consume fuel travelling locations.
Fuel exists limited quantities locations measured provinces. Using TIM
able decode domain identify roles played components
encoding.
TIM: Domain analysis complete mystery-strips (prob048.pddl)
TIM: TYPES:

noted provinces (types T6, T7 T8) divided three separate
types form sequence, defined attacks relation, first
last slightly different functional role others. true planets
(types T1, T2 T3).
Type T0 = {beef,cantelope,chocolate,flounder,guava,mutton,onion,
pepper,rice,shrimp,sweetroll,tuna,yogurt}
Type T1 = {saturn}
Type T2 = {pluto}
Type T3 = {neptune}
Type T4 = {achievement,lubricity}
Type T5 = {abrasion,anger,angina,boils,depression,grief,hangover,
laceration}
Type T6 = {alsace,bosnia,guanabara,kentucky}
Type T7 = {goias}
Type T8 = {arizona}

TIM: STATE INVARIANTS:
FORALL x:T4. FORALL y1. FORALL z1. harmony(x,y1)
harmony(x,z1) => y1 = z1
FORALL x:T4. (Exists y1:T1 U T2 U T3. harmony(x,y1))
FORALL x:T0. FORALL y1. FORALL z1. locale(x,y1)
locale(x,z1) => y1 = z1
FORALL x:T0. (Exists y1:T6 U T7 U T8. locale(x,y1))
FORALL x:T4 U T5. FORALL y1. FORALL z1. fears(x,y1)

414

fiAutomatic Inference State Invariants

fears(x,z1) => y1 = z1
FORALL x:T4 U T5. FORALL y1. FORALL z1. craves(x,y1)
craves(x,z1) => y1 = z1
FORALL x:T4 U T5. (Exists y1:T0. craves(x,y1)
Exists y1:T4. fears(x,y1))
FORALL x:T4 U T5. (Exists y1:T0. craves(x,y1)
Exists y1:T4. fears(x,y1))

TIM: DOMAIN INVARIANTS:
|{(x0,x1): attacks(x0,x1)}| = 5
|{(x0,x1): eats(x0,x1)}| = 36
|{x0: food(x0)}| = 13
|{(x0,x1): harmony(x0,x1)}| = 2
|{(x0,x1): locale(x0,x1)}| = 13
|{(x0,x1): orbits(x0,x1)}| = 2
|{x0: pain(x0)}| = 8
|{x0: planet(x0)}| = 3
|{x0: pleasure(x0)}| = 2
|{x0: province(x0)}| = 6

TIM: ATTRIBUTE SPACES:
Objects, x, T1 U T2 U T3 property:
Exists y1:T4. harmony(y1,x);
Objects, x, T6 U T7 U T8 property:
Exists y1:T0. locale(y1,x);
Objects, x, T4 property:
Exists y1:T4. fears(y1,x);
Objects, x, T0 property:
Exists y1:T4 U T5. craves(y1,x);
Objects, x, T6 U T7 property:
Exists y1:T6 U T8. attacks(x,y1);
Objects, x, T6 U T8 property:
Exists y1:T6 U T7. attacks(y1,x);
Objects, x, T0 property:
Exists y1:T0. eats(x,y1);
Objects, x, T0 property:
Exists y1:T0. eats(y1,x);
Objects, x, T0 property: food(x);
Objects, x, T2 U T3 property:
Exists y1:T1 U T2. orbits(x,y1);

415

fiFox & Long

Objects, x,
Exists y1:T2 U
Objects, x,
Objects, x,
Objects, x,
Objects, x,

T1 U T2 property:
T3. orbits(y1,x);
T5 property: pain(x);
T1 U T2 U T3 property: planet(x);
T4 property: pleasure(x);
T6 U T7 U T8 property: province(x);

TIM: OPERATOR PARAMETER RESTRICTIONS:
succumb(x1:T5,x2:T4)
feast(x1:T4,x2:T0,x3:T0)
overcome(x1:T5,x2:T4)

TIM: ADDITIONAL STATE INVARIANTS, USING SUB-STATE ANALYSIS:

additional invariants show transports always location never
loaded transports.
FORALL x:T4. FORALL y1. FORALL z1. craves(x,y1)
craves(x,z1) => y1 = z1
FORALL x:T4. (Exists y1:T0. craves(x,y1))

C.3 Logistics Domain
TIM: Domain analysis complete logistics-strips (prob05.pddl)
TIM: TYPES:
Type T0 = {bos-truck,la-truck,pgh-truck}
Type T1 = {bos-po,la-po,pgh-po}
Type T2 = {bos-airport,la-airport,pgh-airport}
Type T3 = {bos,la,pgh}
Type T4 = {package1,package2,package3,package4,package5,package6,
package7,package8}
Type T5 = {airplane1,airplane2}

TIM: STATE INVARIANTS:
FORALL x:T0 U T4 U
at(x,z1) => y1
FORALL x:T0 U T4 U
in(x,z1) => y1
FORALL x:T0 U T4 U

T5. FORALL y1. FORALL z1. at(x,y1)
= z1
T5. FORALL y1. FORALL z1. in(x,y1)
= z1
T5. (Exists y1:T1 U T2. at(x,y1)

416

fiAutomatic Inference State Invariants

Exists y1:T0 U T5. in(x,y1))
FORALL x:T0 U T4 U T5. (Exists y1:T1 U T2. at(x,y1)
Exists y1:T0 U T5. in(x,y1))

TIM: DOMAIN INVARIANTS:
|{x0: airplane(x0)}| = 2
|{x0: airport(x0)}| = 3
|{x0: city(x0)}| = 3
|{(x0,x1): in-city(x0,x1)}| = 6
|{x0: location(x0)}| = 6
|{x0: obj(x0)}| = 8
|{x0: truck(x0)}| = 3

TIM: ATTRIBUTE SPACES:
Objects, x,
Exists y1:T0 U
Objects, x,
Exists y1:T0 U
Objects, x,
Objects, x,
Objects, x,
Objects, x,
Objects, x,
Objects, x,
Objects, x,
Objects, x,

T1
T4
T0
T4
T5
T2
T3
T1
T3
T1
T4
T0

U T2 property:
U T5. at(y1,x);
U T5 property:
U T5. in(y1,x);
property: airplane(x);
property: airport(x);
property: city(x);
U T2 property: Exists y1:T3. in-city(x,y1);
property: Exists y1:T1 U T2. in-city(y1,x);
U T2 property: location(x);
property: obj(x);
property: truck(x);

TIM: OPERATOR PARAMETER RESTRICTIONS:
drive(x1:T0,x2:T1 U T2,x3:T1
fly(x1:T5,x2:T2,x3:T2)
unload(x1:T0 U T4 U T5,x2:T0
load-plane(x1:T4,x2:T5,x3:T1
load-truck(x1:T4,x2:T0,x3:T1

U T2,x4:T3)
U T5,x3:T1 U T2)
U T2)
U T2)

TIM: ADDITIONAL STATE INVARIANTS, USING SUB-STATE ANALYSIS:

417

fiFox & Long

following invariants add constraints trucks airplanes must always
location never loaded one another.
FORALL x:T0. FORALL y1. FORALL z1. at(x,y1) at(x,z1) => y1 = z1
FORALL x:T0. (Exists y1:T1 U T2. at(x,y1))
FORALL x:T5. FORALL y1. FORALL z1. at(x,y1) at(x,z1) => y1 = z1
FORALL x:T5. (Exists y1:T1 U T2. at(x,y1))

Appendix D. Rocket Domain

Rocket domain used construction Figure 6 follows:
(define (domain rocket)
(:predicates
(at ?x ?y)
(in ?x ?y)
(fuelled ?x)
(unfuelled ?x)
(loc ?x)
(obj ?x)
(container ?x))
(:action fly
:parameters (?x ?y ?z)
:precondition (and (at ?x ?y) (loc ?z) (fuelled ?x))
:effect (and (not (at ?x ?y)) (at ?x ?z) (unfuelled ?x)
(not (fuelled ?x))))
(:action load
:parameters (?x ?y ?z)
:precondition (and (obj ?x) (container ?y) (at ?x ?z)
(at ?y ?z))
:effect (and (in ?x ?y) (not (at ?x ?z))))
(:action unload
:parameters (?x ?y ?z)
:precondition (and (at ?y ?z) (in ?x ?y))
:effect (and (at ?x ?z) (not (in ?x ?y)))))

Appendix E. Operator Test Domain

domain artificial domain used test effects increasing operators literals
domain encoding performance TIM. example third instance -
variation achieved adding operator schemas pattern included
here.
418

fiAutomatic Inference State Invariants

(define (domain od)
(:predicates
(p1 ?x ?y) (q1 ?x ?y)
(p2 ?x ?y) (q2 ?x ?y)
(p3 ?x ?y) (q3 ?x ?y)
(p4 ?x ?y) (q4 ?x ?y)
(p5 ?x ?y) (q5 ?x ?y)
(p6 ?x ?y) (q6 ?x ?y)
(p7 ?x ?y) (q7 ?x ?y)
(p8 ?x ?y) (q8 ?x ?y)
(p9 ?x ?y) (q9 ?x ?y)
(p10 ?x ?y) (q10 ?x ?y)
(p11 ?x ?y) (q11 ?x ?y)
(p12 ?x ?y) (q12 ?x ?y)
(p13 ?x ?y) (q13 ?x ?y)
(p14 ?x ?y) (q14 ?x ?y)
(p15 ?x ?y) (q15 ?x ?y)
(p16 ?x ?y) (q16 ?x ?y)
(p17 ?x ?y) (q17 ?x ?y)
(p18 ?x ?y) (q18 ?x ?y)
(p19 ?x ?y) (q19 ?x ?y)
(p20 ?x ?y) (q20 ?x ?y))
(:action o1
:parameters (?x ?y ?z)
:precondition (and (p1 ?x ?y) (q1 ?x ?z))
:effect (and (not (p1 ?x ?y)) (not (q1 ?x ?z))
(p1 ?x ?z) (q1 ?x ?y)))
(:action o2
:parameters (?x ?y ?z)
:precondition (and (p2 ?x ?y) (q2 ?x ?z))
:effect (and (not (p2 ?x ?y)) (not (q2 ?x ?z))
(p2 ?x ?z) (q2 ?x ?y)))
(:action o3
:parameters (?x ?y ?z)
:precondition (and (p3 ?x ?y) (q3 ?x ?z))
:effect (and (not (p3 ?x ?y)) (not (q3 ?x ?z))
(p3 ?x ?z) (q3 ?x ?y))))

problem instance fixed follows:
(define (problem op)
(:domain od)
(:objects b c)

419

fiFox & Long

(:init

(p1 b)
(q1 c)
(p2 b)
(q2 c)
(p3 b)
(q3 c)
(p4 b)
(q4 c)
(p5 b)
(q5 c)
(p6 b)
(q6 c)
(p7 b)
(q7 c)
(p8 b)
(q8 c)
(p9 b)
(q9 c)
(p10 b)
(q10 c)
(p11 b)
(q11 c)
(p12 b)
(q12 c)
(p13 b)
(q13 c)
(p14 b)
(q14 c)
(p15 b)
(q15 c)
(p16 b)
(q16 c)
(p17 b)
(q17 c)
(p18 b)
(q18 c)
(p19 b)
(q19 c)
(p20 b)
(q20 c))
(:goal (and (p1 c) (q1 b))))

References

Blum, A., & Furst, M. (1995). Fast Planning Plan-graph Analysis. IJCAI.
Bundy, A., Burstall, R., Weir, S., & Young, R. (1980). Artificial Intelligence: Introductory Course. Edinburgh University Press.
Fikes, R., & Nilsson, N. (1971). STRIPS: New Approach Application TheoremProving Problem-Solving. Artificial Intelligence, 2 (3).
Gerevini, A., & Schubert, L. (1996a). Accelerating Partial Order Planners: Techniques Effective Search Control Pruning. JAIR, 5, 95{137.
Gerevini, A., & Schubert, L. (1996b). Computing Parameter Domains Aid Planning.
AIPS-96.
Gerevini, A., & Schubert, L. (1998). Inferring State Constraints Domain-Independent
Planning. AAAI.
Grant, T. J. (1996). Inductive Learning Knowledge-based Planning Operators. Ph.D.
thesis, Rijksuniversiteit Limburg de Maastricht.
Kautz, H., & Selman, B. (1998). Role Domain Specific Knowledge Planning
Satisfiability Framework. Fourth International Conference Artificial
Intelligence Planning Systems.
420

fiAutomatic Inference State Invariants

Kelleher, G., & Cohn, A. (1992). Automatically Synthesising Domain Constraints
Operator Descriptions. Proceedings ECAI92.
Koehler, J., Nebel, B., & Dimopoulos, Y. (1997). Extending Planning Graphs ADL
Subset. Proceedings 4th European Conference Planning.
Liatsos, V., & Richards, B. (1997). Least Commitment: Optimal Planning Strategy.
Proceedings 16th Workshop UK Planning Scheduling Special Interest
Group.
Long, D., & Fox, M. (in press). Ecient Implementation Plangraph stan.
JAIR.
McCluskey, T. L., & Porteous, J. (1997). Engineering Compiling Planning Domain
Models Promote Validity Eciency. Artificial Intelligence, 95 (1).
Morris, P., & Feldman, R. (1989). Automatically Derived Heuristics Planning Search.
Proceedings 2nd Irish Conference Artificial Intelligence Cognitive
Science, School Computer Applications, Dublin City University.

421


