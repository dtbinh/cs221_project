journal artificial intelligence

submitted published

automatic inference state invariants tim
maria fox
derek long

maria fox dur ac uk
p long dur ac uk

department computer science
university durham uk

abstract
applied larger richer domains effort involved constructing
domain descriptions increases becomes significant burden human application
designer general planners applied successfully large complex domains
necessary provide domain designer assistance building correctly
encoded domains one way provide domain independent techniques
extracting domain description knowledge implicit description
assist domain designers debugging domain descriptions knowledge
exploited improve performance planners several researchers explored
potential state invariants speeding performance domain independent
planners describe process state invariants extracted
automatically inferred type structure domain techniques
developed exploitation stan graphplan planner employs state analysis
techniques enhance performance

introduction
stan long fox press domain independent planner constraint
satisfaction technology graphplan blum furst name derived
fact performs variety pre processing analyses state analyses domain
description applied assist eciently domain stan
took part aips competition first international competition
domain independent planners compared terms performance well known
benchmark domains four planners competed strips track three
graphplan blum furst architecture important difference stan graphplan planners use state analysis
techniques although techniques stage fully integrated
stan gave impressive performance determined examination competition description competition objectives
aips competition ftp site see appendix
one important analyses performed stan automatic inference
state invariants described state invariants inferred
type structure domain automatically inferred enriched stan
techniques used completely independent architecture isolated
pre processing module call tim type inference module tim used
planner regardless whether graphplan underlying
c ai access foundation morgan kaufmann publishers rights reserved

fifox long

architecture tim implemented c executables examples output
available web site see appendix online appendix
tim takes domain description type information need supplied infers
rich type structure functional relationships objects domain type
information supplied tim exploit foundation type structure
often infer enriched type structure basis state invariants extracted
way inferred types partitioned consequence domain
designer relieved considerable overhead description domain whilst
easy hand code types state invariants simple domains containing objects
relations becomes progressively dicult ensure cross consistency handcoded invariants domains become increasingly complex similarly exploitable type
structure domain may much richer easily provided hand
observed tim often infers unexpected type partitions increase discrimination
type structure provide corresponding benefits stan performance therefore
see tim domain engineering tool helping shift burden domain design
human automatic system
usefulness types state invariants well documented types
provided hand since first observed reduce number operator instantiations considered traversal planner search space
elimination meaningless instantiations particularly helpful system graphplan structure traversed explicitly constructed prior search
believe benefits obtained type inference similar
obtained programing language design type inference powerful type checking
assist identification semantic errors specification relational
structure domain indeed found tim useful domain debugging
tool allowing us identify aws published benchmark domains used
tim reveal underlying structure mystery domain disguised transportation
domain used competition mystery domain described
appendix c
use domain knowledge significantly improve performance planners
shown number researchers gerevini schubert b considered automatic inference state constraints demonstrated significant
empirical advantage obtained use kautz selman handcoded invariants provided part domain description used blackbox
demonstrate performance advantages obtained acknowledge importance
inferring invariants automatically mccluskey porteous demonstrated important role hand coded state invariants play domain compilation
ecient earlier work kelleher cohn morris feldman
explores automatic generation restricted invariant forms discuss
related approaches section
describe type inference process employed tim explain
four different forms state invariant extracted inferred type structure
argue tim correct since never infers sentences state invariants
provide experimental demonstrating performance advantages
obtained use types


fiautomatic inference state invariants

drive

unfuelled
fuelled



drive



load






unload

figure simple transportation domain seen collection fsms

type inference module
one way viewing strips fikes nilsson domains collection finite state
machines fsms domain constants traversing states within example
simple transportation domain rockets packages rockets capable
locations moving driving one location
another fuelled unfuelled moving two states
seen forming one node fsm fuelled unfuelled forming two node fsm
view depicted figure


fifox long

packages locations rockets move states
resulting two node fsm example rockets states involve
one fsm since fuelled unfuelled strips domains
seen way earlier work mccluskey porteous grant
discussed section

types tim

two objects participate identical fsms functionally equivalent
seen type notion type similar sorts work
mccluskey porteous primary objective tim module automatically
identify equivalence classes form primitive types domain description
infer hierarchical type structure domain basis primitive types
way done discussed section primitive types functional equivalence
classes objects domain partitioned classes identified
types domain objects tim infers types parameters operators
state invariants inferred final stage
early parts process rely three key abstract data types property space
attribute space transition rule formal definitions components
provided section provide informal descriptions support following
definitions transition rules represent state transformations comprise fsms
traversed objects domain property spaces fsms together objects
participate properties objects transition rules
acquire properties attribute spaces contain collections objects
acquire associated attributes attributes differ properties
acquired lost without associated loss acquisition respectively
another attribute attribute spaces contain transition rules enable
acquisition loss attributes state attribute spaces
constructed assign types domain objects according membership
property attribute spaces two objects belong identical property
attribute spaces assigned type therefore important ensure
property attribute spaces adequately discriminating otherwise important
type distinctions lost much subtlety described section
concerned maintaining adequate discrimination construction spaces
present following definitions support informal characterisation
roles types strips tim definitions used sections
discuss types assigned objects operator parameters

definition type vector bit vector bit corresponds membership
otherwise unique state attribute space number bits vector
equal number distinct state attribute spaces

definition type set domain objects associated type vector
definition type vector v two distinct bits si sj set corresponds

sub type type associated vector v si set settings


fiautomatic inference state invariants

equal type associated v seen super type type
associated v

definition type structure hierarchy types organised sub type relationships
component types

definition type structure adequately discriminating objects assigned
state attribute spaces characterize state transitions attributes

definition type structure discriminating fails distinguish types
functionally distinct

definition type structure discriminating functionally identical objects
assigned different types

two distinct ways types play role specification domain
restrict set possible operator instances eliminate
meaningless domain hence improve eciency reducing size search
space eliminate unsound plans could constructed
provided following examples clarify difference two roles
untyped schema

drive x z
pre
add
del

x fuelled x location z
x z unfuelled x
x fuelled x

permits instances typed schema

drive x z
params
pre
add
del

x rocket package z location
x fuelled x location z
x z unfuelled x
x fuelled x

meaningless instances eliminated search preconditions
satisfiable hand typed schema

x z
params
pre
add
del

x aircraft z location
x
x z
x

ensures aircraft whilst untyped schema


fifox long

x z
pre
add
del

x
x z
x

allows ying means travel object location including packages
objects well aircraft tim capable automatically inferring types
playing restrictive role indicated typed drive operator however tim cannot infer
type information implicit domain description thus given untyped fly
schema grounds tim infer type restrictions tim draw attention
unintended discrimination making packages aircraft indistinguishable
type level unless distinguishing information provided schemas
least tim make explicit fact packages amongst objects
assists domain designer tracking errors omissions domain
description unstated intended distinctions cannot enforced tim

overview tim

figure gives broad outline tim detailed description given
appendix b role component described together
commentary discussing related issues justifications sections
broadly tim begins analysis domain operators extracting transition rules
form foundations property attribute spaces described previously
rules used separate properties equivalence classes property
attribute spaces constructed tim analyses initial state order assign
domain objects appropriate spaces analysis identifies initial properties
individual objects uses form states objects property spaces
initial states property space extended application transition rules
space form complete sets states accounting states objects
property space possibly inhabit described section attribute spaces
behave fsms property spaces extension carried
different procedure one add objects spaces rather states
tim assigns types objects pattern membership spaces
constructed finally tim uses spaces determine invariants govern behaviour
domain objects

constructing transition rules

begin describing process transition rules constructed
following definitions required

definition property predicate subscripted number arity
predicate every predicate arity n defines n properties

definition transition rule expression form
property property property


fiautomatic inference state invariants

construct base prss section
split prss section
construct transition rules section
seed property attribute spaces section
assign transition rules section
analyse initial state section
extend property spaces section
extend attribute spaces section
identify types section
construct invariants section
figure outline tim
three components bags zero properties called enablers start
finish respectively

double arrow read enables single arrow read transition


e f

read e enables transition f properties given
transition properties f acquired transition properties
e given
enablers empty write

start finish
start empty write

transition rule

enablers null finish
finish empty write

transition rule

enablers start null
bag null empty bag properties role emphasise transition
rule nothing given transition transition rule nothing
acquired rules null start null finish discarded describe
null transitions
property bags contain one element separated commas
collection

pk qm rn


fifox long

interpreted mean properties collection satisfied
many times appear collection comma therefore used separate
elements bag use denote bag union denote bag difference
denote
bag intersection v denote bag inclusion

definition property relating structure prs triple bags properties
first stage constructs set transition rules set operator
schemas operator schema analysed respect parameter turn
parameter prs built first bag properties formed preconditions
schema number used form property argument position
parameter considered example precondition x
parameter considered x property formed bag called precs
contains enablers used formation transition rules second
bag called deleted precs properties formed preconditions appear
delete list schema respect parameter third bag called
add elements contains properties formed add list schema
prs contains deleted elements component assumed every element
delete list strips operator appears precondition list reasonable
restriction given strips operators allow use conditional effects
assumed every pair atoms delete list schema distinct
legal instantiations schema constitute significant restriction since
operator schemas easily rephrased whenever condition violated
consider process prss constructed given schema

drive x z
pre
add
del

x fuelled x location z
x z unfuelled x
x fuelled x

considering parameter x following prs built

prs

precs
fuelled
deleted precs fuelled
add elements unfuelled
considering parameter obtain

prs
precs

deleted precs
add elements
considering parameter z obtain


fiautomatic inference state invariants

prs

precs
location
deleted precs
add elements

constructing structures identifying state transformations
objects instantiating operator parameters progress note objects instantiate x go fuelled somewhere unfuelled somewhere objects
instantiate lose property anything gain nothing application operator objects instantiate z continue locations
gain property something convert structures
transition rules order correctly capture state transformations
standard formula construction rules prss

precs deleted precs deleted precs add elements
thus prs could build rule

fuelled unfuelled
potential rule causes fuelled linked state
transformations fuelled become associated property space
consequence objects places cannot fuelled may

indistinguishable objects require fuelling moved fact
wish transition rules express fact fuelled enables things go
one place another place whilst excluding possibility
may enablers transition
therefore begin second phase prs construction identifying special treatment prss property appears deleted precs add elements
property exchanged application operator relation
continues hold identified argument object objects
necessarily object objects application operator example prs vehicle location application operator
longer old location observe vehicle must fuelled make transition separate transition condition split prs splitting identifies
exchanged properties prs creates one prs exchange one
unexchanged properties therefore splitting prs k
least k prss k number exchanges prs represents
splitting prs construct two prss one characterizing exchange
property one characterising fuelled unfuelled transition
first prss

prs

precs
fuelled
deleted precs
add elements


fifox long

rule

fuelled
constructed noted property fuelled longer seen
part state transformation enabler appear
deleted precs bag resulting prs
second prs captures fact seen enabler
transition fuelled unfuelled

prs

precs
fuelled
deleted precs fuelled
add elements unfuelled

prs splits required since properties exchanged
general example follows

prs

precs
p p pn
deleted precs p pi pi k pm
add elements p pi q qk

prss would constructed deal exchanged pairs
final prs prs would constructed describe remainder transition making
prss total

prs

precs
p p pn
deleted precs pi k pm
add elements q qk

need consider additional pairings add delete list elements since
would correspond exchanges properties splitting process justified section standard rule construction formula applied prs yielding
rule
fuelled unfuelled
observed even add elements bag contains multiple properties
single rule built standard construction formula applied
considering remaining prss observed contain
empty field add elements field empty deleted precs field empty
prs empty field special treatment required prs build
rule

null

represent fact object instantiates gives property
something gains nothing return build rule

location null


fiautomatic inference state invariants

represent fact object instantiates z gains property something virtue location gives nothing return rules
somewhat different status ones characterize exchange properties
cases properties lost gained without exchange seen resources
accumulated spent domain objects rather states
domain objects pass example location acquire property something without relinquishing anything return whereas object requires fuel
become fuelled relinquishing property unfuelled vice versa
increasing decreasing resources identified attributes distinguished
states distinction later prove important since generation true
state invariants depends upon made correctly properties increase
decrease without exchange invariant false assertions would proposed
invariants treated way state valued properties
rule form constructed prs must constructed separately every
property add elements bag properties must individually characterized increasing resources rules constructed null distinguished attribute
transition rules null left side rule increasing attribute
transition rule null right hand side rule decreasing attribute
transition rule
final case consider rule construction case prs empty
precs field happens parameter respect prs constructed
appear preconditions operator schema case set
rules constructed one property add elements bag form

null
ecting fact increasing resource deleted precs field necessarily
empty case

definition state bag properties
necessary distinguish bag set square brackets used denote
bag
definition property space tuple four components set properties set
transition rules set states set domain constants

definition attribute space tuple three components set properties set

transition rules set domain constants

helpful observe state attribute spaces represent disjoint collections properties disjoint collections formed transition
rules putting start finish properties rule collection
example given two rules
e p p p q q

e r r


fifox long

collections p p p q q r r would formed property appears
start finish rules single collection formed two rules
last stage rule construction phase identify basis construction
property attribute spaces done uniting left right hand sides
rules uniting forms collections properties seed unique property attribute
space yet possible decide seeds form attribute spaces
treatment kinds space identical stage enablers rules
ignored process wish make enablers automatically fall
property spaces states transformations enable could
incorrect assignment properties property attribute spaces since enablers
facilitate participate state transformations output phase
collection rules properties marked attributes property space seeds
formed uniting process properties remain unassigned stage
used seed separate attribute spaces one property
role played second phase prs construction postpone commitment
uniting collections properties possibility objects
properties associated different property spaces left open long
possible may consideration schemas provides enough information
possibility eliminated following abstract example support
much type discrimination possible earlier phases analysis consider
simple example illustrate
postponing property space amalgamation

given domain description containing following operator schema

op x z
pre
add
del

p x q x
p x z q x z
p x q x

prs

precs
p q
deleted precs p q
add elements p q
constructed first phase x properties p q bound
together prs resulting rule would

p q p q
forces objects property p occupy property space objects
property q since prs exchange p split
replace two prss

precs
p q
deleted precs p
add elements p


fiautomatic inference state invariants

precs
p q
deleted precs q
add elements q
consider pairings p q since found prss
operator schemas domain allows two prss generated lead
generation rules

q p p



p q q

two rules indicate p q used form different property spaces since
could principle independent one another objects assigned two
spaces turn distinct types however add following two schemas

op x
pre
add
del

op x z

q x
p x
q x

pre
add
del

p x
q x
p x

generate x prss

precs
q
deleted precs q
add elements p


precs
p
deleted precs p
add elements q
rules


q p
p q

indicating p q united set hence form single property
space objects properties really type
uniting overrides potential separate property spaces formed absence
two schemas would insucient information available determine
nature relationship two properties


fifox long

constructing property spaces synthesising types

objective stage construct type structure domain identifying
domain objects distinct property spaces objects appear one property
space giving us basis deriving hierarchical type structure
first part process involves completing seeded property spaces first
task associate transition rules appropriate property space seeds
easily done picking arbitrary property start finish component rule
identifying property space seed property belongs never
ambiguity every property belongs one seed uniting ensures
properties referred rule belong seed point distinction
states attributes becomes important property space seed
attribute transition rule associated becomes attribute space dealt
differently property spaces certain respects explained
next step identify domain objects associated property space
attribute space
object referred initial state construct type vector bit
set corresponding space inhabited object object inhabit
one space habitation checked identifying properties hold
initial state object considered allocating states rather
properties appropriate state attribute spaces every domain object
considered unique type identifier associated different bit patterns
next task populate property spaces states following definitions
required support explanation process

definition world state collection propositions characterising configuration
objects given domain description

definition given world state w property space p ps trs ss os
attribute space p ps trs os object os p projection st
bag properties possessed w belongs ps

collection properties object initial state divided set
bags properties bag corresponding p projection initial state
property attribute space p bag added state set corresponding
property space discarded corresponding space attribute space need
extend spaces property space adding states inferred
reachable objects within space along transitions within space done
every state space including states newly added process
states reachable ordering properties within states irrelevant
two states considered equal contain properties regardless ordering
considered order equivalent since come use information
parts process invariant generation require knowledge inclusion
relations pairs states convenient mark stage addition
reachable states important inference state invariants use
discussed section attribute spaces receive different treatment point


fiautomatic inference state invariants

important difference observe since property spaces characterize exchange
properties objects property space must start initial state members
property space however since attributes acquired without exchange
possible objects particular attributes initial state acquire
attributes later possible attribute space increasing attribute
transition rule associated therefore consider attribute space see
whether objects added application corresponding increasing rule
object added attribute space potentiates enablers
increasing rule attribute space object potentiates enabling property
member state attribute space property belongs membership
spaces indicates object could enter state satisfies
enabling properties would justify application increasing rule
enabling property associated state attribute space static condition
initial state checked confirm property true object
considered
complication arises enabling property used seed attribute space
case attribute necessary identify
objects attribute space consider addition current attribute space
course could principle initiate loop process avoid marking
attribute spaces considered ensuring iterating convergence
attribute spaces loop completely assigned correctness part
procedure discussed section
done state attribute spaces complete types
domain objects extracted completeness construction phase discussed
section

worked example

fully worked example stages process help clarify involved
consider simplified version rocket domain two operator schemas

drive x z
pre
add
del

load x z

x fuelled x location z
x z unfuelled x
x fuelled x

pre
x z
add
x z
del
x
initial state containing four constants rocket package london paris
relations rocket paris fuelled rocket package london observed
simplified rocket domain rather odd feature load schema
restricted loading packages rockets oddity highlighted analysis
constructed showing analysis performed tim help understanding
debugging behaviour domain drive operator schema following
prss constructed variables x z respectively


fifox long

precs
fuelled
deleted precs fuelled
add elements unfuelled
precs

deleted precs
add elements
precs
location
deleted precs
add elements
load operator schema following prss constructed variables x
z respectively
precs

deleted precs
add elements
precs

deleted precs
add elements
precs

deleted precs
add elements
following rules built first prs generates first two rules subsequent
prss generate one rule
fuelled
fuelled unfuelled

null
location null

null
null

construct following united sets properties

fat g
ffuelled unfuelled g
fat g
fin g


fiautomatic inference state invariants

used seed property spaces first associate rules property
space seeds resulting following assignment

fat g
fuelled
ffuelled unfuelled g fuelled unfuelled
fat g
location null null
null
fin g
null
last two spaces converted attribute spaces association
attribute transition rules resulting spaces supplemented domain
constants legal states first identify subset legal states
domain objects identifiable initial state use goal state
provide information properties objects goal state might
unachievable objects cannot obtain required properties would invalidate
tim analysis domain initial state rocket properties fuelled
package property london property paris property
information associate domain constants developing state attribute
spaces obtain

fat g
fuelled
frocket packageg
ffuelled unfuelled g fuelled unfuelled
frocketg
fat g
location null null flondon parisg
null
fin g
null
next step add legal states objects identifiable far
property spaces following structures first two
extended inference explained completed property spaces last
two extended completed attribute spaces addition objects
potentially acquire associated attributes described

fat g

fuelled

ffuelled unfuelled g fuelled unfuelled
fat g
fin g

frocket packageg

frocketg
fuelled

location null null flondon parisg
null
null

last stage construction two property spaces add states
inferred reachable via transition rules objects property spaces
example packages go application rule
since rule available property space package belongs
one legal states property space add legal state
general construct extension state space identifying applicable
rules rule creating state removing properties start


fifox long

rule adding properties finish rule done states
order equivalent already generated enablers rules ignored
consequence states generated might unreachable
process completed current example finished property spaces follows

property space
fat g fuelled frocket packageg


property space
ffuelled unfuelled g fuelled unfuelled frocketg

fuelled unfuelled

consider attribute space turn add domain objects already
members potentiate increasing rules domain objects added
first attribute space since london paris potentiate increasing rule
already present however second attribute space considered
observed rocket package potentiate increasing rule therefore
added members resulting attribute spaces

fat g location null null flondon parisg
null
fin g null
frocket packageg
oddity load operator revealed stage since package rocket
assigned members attribute space meaning
attribute things

number distinct bit patterns constructed indicating object membership
state attribute spaces determines number distinct types exist
domain hence simplified encoding rocket domain three distinct
types rocket type package type paris london
type types given abstract identifiers might
meaningfully interpreted types movable object requiring fuel movable object
location respectively expected london paris type location whilst
package type movable object rocket type movable object requiring fuel
sub type movable object
distinction made state attribute spaces exploited
process inferring state invariants discussed section

assignment types operator parameters

types assigned parameters operators following way given
operator schema collection property spaces attribute spaces allocate type
vector variables schema membership state attribute
spaces properties given variable recorded setting appropriate bits
vector variable properties appear preconditions


fiautomatic inference state invariants

schema considered object satisfy preconditions operator
properties represented postconditions therefore right type
instantiation operator type associated vector union
sub types taken union type assigned variable domain
object type sub type type associated variable
used instantiate variable see process works consider variable x
drive schema precondition properties x fuelled
members two property spaces therefore type vector associated x
observed type vector associated rocket
type rocket sub type type x sub type union
sub types contains type rocket means x instantiated
rocket domain constant since domain constant type
appropriate sub type relation type operator parameters introduce type
variables tk tn unused values k n k number existing types
n k plus number variables schema considered type vector
variable z type vector location static
relation z appear argument predicate preconditions
z therefore acquires type london paris two objects
location true initial state super type taking unions
sub types specify drive schema following way

drive x z

params
x z
pre
x fuelled x location z
add
x z unfuelled x
del
x fuelled x
stan exploits sub typing relations inferred constructing instances drive operator variable appears schema appear
preconditions instantiated objects type domain
description contains basis inferring type restrictions case variable
appear delete list without appearing precondition list since assume
delete list elements appear preconditions variable would occur
add list would mean regardless properties holding object used
instantiate variable initial state acquire add list property freely
since acquisition would occur irrespective type object variables
essentially polymorphic

inference state invariants

final phase computation tim inference state invariants
property spaces attribute spaces used inference invariants
incorrect invariants would proposed tim attribute spaces inadvertantly used
explains importance identifying attribute spaces earlier stages

current version tim capable inferring four kinds invariant three
inferred property spaces identity invariants state membership invariants


fifox long

invariants characterizing uniqueness state membership one inferred
operator schemas initial state directly fixed resource invariants simplified
rocket domain considered example identity invariant

x tk z x x z x z
state membership invariant

x tk tn x tm x
uniqueness invariant

x tk tn x tm x
infer identity invariants property space considered turn respect
properties states property example pk p arity n occurs
state invariant following form z vectors
containing n values constructed

x z p k x yk n p z k x zk n z
form invariant generalised deal case
occurrences pk state space case build following
expression assumed k simplicity

x ym p x p x ym ym ym
state membership invariants form

x disjunct disjunctn
disjunct constructed single state thus property space contains k
states k disjuncts invariant constructed property space
one state membership invariant constructed property space
given collection states property space first identify supersets
states collection supersets discarded since invariants would
built would logically equivalent built subset states
remaining state used build single disjunct state considered contains
single property pk p arity n expression

p k x yk n
constructed course n existential quantifier disjunct
p x state contains one property say denoted p p
build assuming k simplicity

ym p x p x p x ym
uniqueness invariants constructed similar way property space
begin analysing superset states identify non exclusive pairs subset states


fiautomatic inference state invariants

example given subset states fat g fin g superset state fat g
observed two subset states mutually exclusive since
simultaneously held done analysis identified mutually exclusive pairs
states mark subset states unusable generation invariants remaining
states considered possible pairings every pair states p q generate
invariant following form assuming simplicity x first position
p p n q qm form invariant easily generalised

x yn p x p x p n x yn
ym q x q x qm x ym
fourth kind invariant inferred structure operator schemas
without reference property spaces domain type structure call invariants
fixed resource invariants since capture physical limitations domain fixed
resource invariants cannot inferred state attribute spaces describe properties domain rather objects within following schema
gripper domain provides example fixed resource invariants distinguished
three kinds

move x

pre
add
del

robot x room
robot
robot x

prss would built operator

precs
robot
deleted precs robot
add elements
precs
room
deleted precs
add elements robot
rules constructed

robot null


room null robot

observed rules attribute transition rules robot
attribute rather state valued means invariants first three kinds
discussed would constructed
reason lack invariants first three forms encoding
robot embedded predicate robot cannot participate directly state transitions
obvious invariant robot would naturally true domain


fifox long

robot exactly one room cannot inferred techniques far
described fact axiom world domain rather specific objects
within obtained information state transformations
objects
seen operator schemas gripper domain robot balanced deleted whenever added added whenever deleted
means number occurrences robot initial state determines
number occurrences possible subsequent state leads construction domain invariant

jfx robot x gj
since one robot relation initial state form fixed resource
invariants equational invariant states size set combinations objects satisfying certain predicate equal cases less equal
certain positive integer integer large convenient
write equation would write logical expression information encoded
fixed resource invariants useful identifying unsolvable goal sets without attempting plan example icparc version three blocks blocks
world liatsos richards three table positions must
exactly three clear surfaces goal specifying three clear relationships identified unachievable fixed resource invariants domain
fixed resource uniqueness invariants produced tim seen providing
form multi mutex relations contrast binary mutex relations inferred
construction plan graph graphplan planners blum furst binary
mutex relations indicate two actions facts mutually incompatible whilst multimutex relations indicate larger groups actions facts collectively incompatible
binary mutex relations preventing fact true one object holding
two different objects simultaneously extracted identity invariants
tim infers multi mutex relations powerful binary ones stan detect
unsolvable goal sets fixed resource uniqueness invariants even
binary mutex relations corresponding level indicate exists
infer invariants examine predicates language see whether
exchanged add delete lists operator schemas predicate
exchanged equally schemas appears number times add
list delete list schema predicate corresponds fixed resource
single schema upsets balance predicate treated fixed given
fixed resource predicate inferred never combinations
objects satisfying predicate initial state slightly
odd encoding rocket world considered location fixed resource
fixed equally exchanged load schema examples fixed
resource invariants inferred standard domains provided appendix c
certain circumstances necessary infer weaker invariant

jfx p x gj k


fiautomatic inference state invariants

positive integer k p holds multiple objects initial state
possible subsequent state transformations attribute acquisitions states
two instances p collapse one p holds multiply often initial
state reachable state necessary build invariant
instead p state valued multiple instances never occur state
property space safe assert equality construction invariant
automatic inference first three kinds invariants relies construction
property spaces discussed section discussed distinction
state attribute spaces critical inference correct invariants however
techniques described far tim would lose information could
construct useful invariants give example could occur consider
following simple encoding standard blocks world

move x z
pre
add
del

x clear x clear z
x z clear clear table
x clear z

operator used bundy et al add list element clear table makes
reference constant operator schema submitted analysis
current form prs would built constant rules would constructed
hence state attribute spaces constructed would fail record fact every
application move state table clear resulting analysis
would incorrect invariants types grant identifies version
move operator awed need maintain state correctness addition
invariant clear table add list however analyse schema correctly
first abstract remove constant yielding following schema

move x z
pre
add
del

x clear x clear z table
x z clear clear
x clear z

given initial state blockc blocka blockb table
add proposition table table precondition satisfied
property attribute spaces constructed follows

fon g

clear

fblocka blockb blockc g

fon clear g clear clear fblocka blockb blockc tableg
table null clear

second attribute space invariant extraction
applied consequently invariants infer characterize
positions blocks every block exactly one surface pity
information available attribute space could yield useful extra invariants
particular would infer invariant every block clear


fifox long

something cannot clear something reason
cannot infer invariant would asserted hold every object
attribute space including table even though actually true table
table things still clear
sub space analysis property attribute spaces

solution loss invariants decompose property attribute
space contains k object types k sub spaces property sub space structurally identical property space attribute sub spaces identified used
invariants obtained property sub spaces obtained analysis attribute spaces following example reason distinguishing
sub spaces property attribute spaces properties partitioned
sub spaces property attribute spaces original property
attribute space discarded sub spaces used determining types
objects role sub space analysis enable construction additional
invariants
consider blocks domain described previous section example
benefits sub space analysis point invariant construction types
domain objects identified property attribute space membership
table already known different type blocks table
member property space therefore two sub spaces constructed
attribute space one type blocks one type
tables sub spaces constructed property space contains
one type object rules associated sub spaces rules
original attribute space enabled objects appropriate type second
two sub spaces attribute sub space inclusion increasing
attribute transition rule stage two sub spaces follows

fon clear g clear clear
fblocka blockb blockc g
fon clear g table null clear clear ftableg
clear
attribute sub space used invariant construction contains
attribute transition rule would incorrect invariants case attribute
spaces nothing gained developing however state
sub space completed addition states associated objects
space initial state extension resulting sub spaces

fon clear g clear clear

fblocka blockb blockc g
clear
fon clear g table null clear clear ftableg
clear
state sub space infer following invariants type name
block stand type vector infer identity invariant
x block z x z x z


fiautomatic inference state invariants

state membership invariant

x block block x clear x
unique state invariant

x block block x clear x
although additional invariant table clear cannot infer
present

mixed spaces

happen encoding domain conceals presence attributes within
schemas point property space extension occurs prevent
property space extension process terminating example simple lightswitch domain contains following two schemas

switchon x
pre
add
del

switchoff x
pre
add
del

x
x touched x
x
x
x touched x
x

initial state switcha two prss constructed
precs

deleted precs
add elements touched

precs

deleted precs
add elements touched
giving rise two rules


touched

touched

uniting seeds one property space containing three properties addition
rules property space follows

fon touched g touched fswitchag
touched


fifox long

point extension space arises following states
added touched touched touched touched touched touched
cannot simply avoid adding properties already state extended two apparently identical properties might general refer different
arguments
due fact touched actually increasing attribute
become apparent prss consequence mixed spaces
constructed mixed space property space containing hidden attributes tim detects
hidden attributes checking extension state contains state already
generated initial state starting point thus extension mixed space
tim would detect hidden attribute state touched touched
constructed state contains state initiated extension
detected hidden attribute two possibilities tim convert
mixed space attribute space case invariants constructed
attempt identify attribute split mixed space attribute space
property space containing state valued components mixed space take
option split state allows us infer invariants concerning state valued
properties
tim takes difference including included states distinct
property difference processes rules cutting rule containing property
two rules least one attribute rule following method
used cut rules following attr indicates one occurrences
attribute valued property comma overloaded mean bag conjunction
bag union rule form

enablers start adds attr
two rules forms

enablers start null attr

rule form

enablers start adds
enablers attr precs adds

two rules forms

enablers precs attr null


enablers attr precs adds

rule cutting separates attribute valued properties state valued properties
pure attribute property spaces constructed however discard
original mixed space used determining type structure


fiautomatic inference state invariants

domain additional type information could extracted state
attribute spaces built following analysis currently exploited
analysis applied lightswitch domain following property
space attribute space built
fon g
fswitchag

ftouched g null touched null touched fswitchag
lightswitch stand type following state membership invariant
constructed property space
x lightswitch x x
tim constructs uniqueness invariant
x lightswitch x x

properties tim

correctness tim relies constructing necessarily true invariants demonstration true invariants constructed guarantees construction adequately discriminating type structure cannot guarantee discrimination
argue discrimination occur type structures generated
tim properties defined section
discrimination would distinguishing functionally identical objects
type level would occur tim placed objects participate identical
state transitions different property spaces underlying partitioning
properties property spaces cannot happen membership different
property spaces requires distinguishing state transformations
functionally identical objects flawed assignment assigning object
property space without corresponding state transformations simply seen
erroneous rather discrimination possibility occurring
excluded property attribute space construction extension shown
correct section
failure detect type differences discrimination domain
weak invariants discrimination could occur would lead targeted
invariants would still true subset objects ought
cover flawed assignment would clearly lead construction false invariants underdiscrimination arise therefore affects completeness state invariant
inference procedure lead generalisation operators since types
assigned operator parameters equally discriminating enable meaningless instances formed needlessly increasing size search space
must explored planner clearly raises eciency issues
undermine formal properties planner exploits tim
observed consequence discrimination construction weak
valid invariants following example illustrates discrimination occur
given schema


fifox long

op x
pre
add
del
initial state

p x
q x
p x

p c p b c q b

hold following two property spaces constructed

fp q g p q fa bg
p q p q q q
fp q g p q fc dg
q p p q p q q
given property spaces impossible distinguish b c even
though analysis operator schema initial state reveal functionally distinct
b c seen although must exchange p q
b p q simultaneously similar observation made c
however process invariants constructed cannot gain access
information identity invariant constructed first property space

x z u q x q x z q x u z u z u
invariant weaker ideal participate one q relation b
participate two simultaneously state membership invariant property space

x p x q x
understates case b p q simultaneously unique
state invariant constructed property space p q mutually
exclusive

correctness completeness transition rule construction phase

correctness used tim depends two elements firstly property
spaces identified must correctly populated objects
assigned property spaces belong every achievable state must
included appropriate property space secondly property spaces must
support generation correct invariants second element examined section
interesting relationship exists states property space invariants generated space incorrect invariants contructed property space
missing achievable states state membership invariants assert
object property space must one states property space states
missing invariant false prove achievable states
appropriate property space

theorem given initial state collection operator schemas property space
p ps trs ss os generated tim applied state st


fiautomatic inference state invariants

reachable application valid linearised plan formed ground instances
operator schemas os p projection st stop ss

proof

proof induction length plan yields state st base
case plan contains operator instances st p projection
ss definition first phase property space construction process described
section
suppose st generated plan length k last step penultimate
state pre st let p projection pre st pre stop inductive hypothesis
state ss affect state p projection st
pre stop therefore ss trivially otherwise consider operator schema
op formed described section constants appear op
variables body op parameters op let initial collection prss
constructed op parameters instantiated creation
set prs prsn every prsi form
precs
pi
deleted precs di
add elements ai
initial collection collection formed prior splitting
value ith prs lead construction k transition rules
k size bag intersection xi di ai k rules
following form
c xi pi fcg c c
remaining rule form

pi di xi di xi ai xi
refer latter rule prsi ith complex rule subset n complex
rules contain property ps start finish therefore
relevant transition pre st st observed complex
rules prs prsm without loss generality must p uniting process
described
define pres op p projection preconditions similarly
adds op dels op defined p projections add delete lists
respectively construction prss defined section


pi
mm
adds op ai
mm
dels op di

pres op








fifox long

restriction delete lists must subset preconditions
fact applicable pre st follows dels op v pres op v pre stop since
v represents bag inclusion seen separate bags di included
pre stop without overlap
extension process involves iterated application rules explained
section indicated pseudo code presented appendix b
rule applicable state start must included state therefore
complex rules applicable regardless sequence application pre stop
follows state
pre stop

mm di xi mm ai xi




generated extension process definition xi fact di v pre stop
state written
pre stop

mm di ai


observed
pre stop dels op adds op
equals stop standard semantics operator application strips



proof demonstrates splitting discussed generation
invalid invariants however splitting compromise completeness invariantgeneration process inclusion unreachable states property spaces
consequence identity state membership invariants generated
weaker would otherwise case discussed section
explain role splitting prs construction phases domain
object strips domain associated finite automaton states consist
properties example initially application
arbitrary length sequence operators objects observed
type identical automata property level prss capture ways
operator applications modify configurations individual objects hence
provide encoding automata
prss built two phases first phase parameters
schemas considered possible object state transitions captured however
transitions conceal functional distinctions inherent domain description
would lead premature amalgamation property spaces observed
discussion rocket domain section example observed use
standard formula construction rules prss alone would
failure detect type distinction rockets packages
second phase assists type inference processes avoiding discrimination
distinguishing enablers state transformation properties exchanged


fiautomatic inference state invariants

transformation prs characterizing exchange k properties split
form k prss prss given section two
prss constructed single prs containing single exchanged property
simple example one split required remove exchanges general might
necessary split repeatedly exchanges removed shown example given
prs section non exchange combinations properties deleted precs
add elements considered splitting resulting prss lead
construction transition rules allow generic state transformations movement
one location another separated specific nature objects
make transformations
observed rules splitting process general
rules would obtained prs prior splitting
distinguish precisely properties take part state transitions
properties simply enable transitions allowing finer type distinctions
inferred basis functionalities objects domain finer distinctions
made process seeding property attribute spaces uniting
uniting merges single equivalence classes properties appear
start finish rule
argue state transformations accounted end second
phase second phase automata formed first phase
separated collections simpler automata possible transitions
lost finer grained encoding possible transitions made
objects appropriate properties prss constructed phase support
construction rules allow objects making transitions occupy different property
spaces second phase prss may constraining sense
analysis subsequent schemas might eliminate possibilities keeping open
example set prss obtained end second phase cannot
constraining first phase prss considered splitting
subtlety concerns consequence type level assigning two functionally
distinct objects state attribute space example example rocket
package assigned property space fin g attribute space
fin g however rocket fuelled unfuelled package cannot
distinction emerges property attribute membership vectors
associated rocket package objects membership additional property space
ffuelled unfuelled g means rocket assigned type sub type type
package functional distinctness rocket package recognised discussed
oddity encoding package assigned membership
fin g attribute space furthermore united effect
rockets make transition used instantiate variables type
movable object even variables type intended instantiated
package nothing domain description prevent interpretation
conventional encoding load schema would prevent rocket loaded
object would cause refinement type structure would
identify loadable objects would prohibit use rocket forming instances
operators restricted operating objects


fifox long

construction transition rules follows simple rule whereby undeleted preconditions used enable transformation state deleted preconditions
prs hold one added elements prs hold given assumption
deleted atoms operator schema must appear preconditions schema
rules correctly characterize strips style state transformations possible transformations captured second phase prs construction complete set
correct transition rules therefore constructed
given correctness completeness transition rule construction phase correct
initial allocation objects spaces depends simply correctly checking membership
initial properties object property sets formed uniting rules
used seed spaces extension property spaces done straightforward
application transition rules configurations properties occupied
objects property space added end extension phase
extension attribute spaces unproblematic cases potential enabler
attribute one process attribute space enabler
completed could appears initiate loop attribute space extension process
fact happen tim able detect loop occurred avoid
repeatedly iterating
following example illustrates way solved tim suppose
three attribute spaces

attribute space

fq g p null q fa bg

attribute space
fr g q null r fcg

attribute space
fp g r null p fdg
spaces extended addition objects potentiate increasing rules
discussed section arises enablers rules states
attributes extension attribute space enabler p attribute
attribute space p yet extended necessary complete
space complete extension requires extension
reason requires extension requires extension
way tim avoids entering loop marking space considered
seen iteration marked space encountered extended
used already complete second iteration required extend
spaces still require completion subsequent iterations required
process converges experiments suggest unusual
two iterations required worst case upper bound number
domain constants number attribute spaces limited number
properties hence quadratic size domain description


fiautomatic inference state invariants

extension process starts attribute space example attribute
space marked seen first iteration tim goes
extend space extension space depends upon space complete
space marked seen iteration space considered space
marked space revisited space marked tim infers loop
entered objects added space without extension objects space
added space finally objects space added space
first iteration complete

fq g p null q fa bg fc dg
fr g q null r fcg fa bg
fp g r null p fdg fc bg
however space yet complete second iteration required iteration
starts place first process repeated except
iterations required example

correctness state invariants

argue correctness invariant inference procedure considering
four kinds invariant turn following arguments rely upon correctly distinguishing property spaces attribute spaces since invariant analysis cannot
performed attribute spaces scope confusing distinction extension mixed spaces extract attributes mixed spaces checking inclusion
existing states states generated extension process discussed
section

definition given property space p ps trs ss os ss partitioned
three disjoint sets sssubs sssups contain states ss included
bags include bags respectively least one state ss ssind
contains independent states ss neither sssubs sssups
theorem given property space p ps trs ss os set states ss

union three disjoint sets states ssind sssubs sssups object
os following families invariants hold
identity invariants
state membership invariants
unique state invariants
defined section

proof

address kind invariant turn theorem every object os must
state ss furthermore states object os respect property
ps ss follows properties partitioned spaces


fifox long

seeding process therefore maximum number occurrences property
p ps possessed object os state world bounded
maximum number instances property state ss maximum values
might equal since ss contain inaccessible states identity invariants simply
express bound properties objects os
every object os must state ssind sssubs follows definition
sets definition theorem state membership invariants assert
every object os must least one states disjunct invariant
corresponding assertion membership one states
argue correctness unique state invariants observe proposed
invariants would false paired states mutually exclusive
case state extension process would put properties could simultaneously held bag properties would simultaneously held
initial state hence would appear bag initial construction property
space case state exist property space superset
non exclusive states however uniqueness invariants generated pairs states
drawn ssind sssups non exclusive pairs states lead
generation incorrect invariants


fixed resource invariants associated particular predicate atoms
built predicate balanced add delete lists operator
schemas number occurrences atoms initial state fixed
subsequent states invariant expresses invariant constructed
every predicate forms balanced atoms
since techniques required infer invariants sub spaces
argument required support correctness invariants formed following sub space
analysis
although theorem demonstrates correctness invariants inferred tim
possible weak invariants inferred presence unreachable states ss
weak identity invariants inferred unreachable state generated extension
containing instances property contained reachable state
happens identity invariant generated weaker would ideal
still valid property space contains unreachable states cause
inclusion additional false disjuncts state membership invariants since
false disjuncts exclude satisfying assignments presence invalidate
invariants unreachable states cause additional tautologous uniqueness invariants
generated affect strength invariants refer reachable states
clearly cannot hope identify unreachable states analysis would
hard
invariants generated attribute spaces tim cannot claimed
complete sub space analysis rectifies extent identifying property spaces
exist within attribute spaces allowing invariants generated
analysis could refined


fiautomatic inference state invariants

effects tim properties planner

tim sound planner uses tim danger losing soundness
tim certainly complete domain axioms invariant properties

kinds cannot extracted current version example kautz selman
identify optimality conditions simplifying assumptions amongst different
kinds axioms might inferred domain optimality condition
logistics domain might package returned location
removed simplifying assumption domain might truck
loaded immediately move assuming necessary loads done parallel
constraints require deeper analysis domain currently performed
tim intend characterise infer future work
cannot guarantee type structure inferred tim fully discriminating although guarantee discriminating however failure
tim part infer structure inferred impact
completeness planner tim cases tim return unstructured
domain planner therefore default reasoning unstructured domain
necessary

experimental

examination tim performance carried several dimensions consider
three specific dimensions viability analysis typical benchmark domains
scalability analysis utility performing analysis prior
general performance standard benchmark provides indication scale
overhead involved tim preprocessing tool experiments performed
linux mhz pc mb ram figure shows even large
instances overhead entirely acceptable mystery listed
table large involving initial states containing hundreds facts could
solved stan ipp koehler nebel dimopoulos blackbox kautz
selman aips competition nature mystery domain described
appendix c emphasises relative costs preprocessing efforts
selection used construct table justified follows blocks
world used representative example three encodings supplied
pddl release simple encoding prob att encoding prob
snlp encoding prob hanoi set contains collection reasonably sized
representative group relatively large mystery instances chosen pddl
release two tyre world instances two strips instances available
release three logistics three largest simple strips encoding
included pddl release
second dimension scalability analysis analytic examination
determine upper bound performance polynomial
key domain components including number operator schemas number
literals operators numbers objects facts initial state number
arities predicates language figure shows performance tim roughly
quadratic size specification graph size crudely equated


fifox long

domain
blocks
prob pddl
prob pddl
prob pddl
hanoi
disc
disc
disc
disc
disc
mystery
prob pddl
prob pddl
prob pddl
prob pddl
prob pddl
tyre world prob pddl
prob pddl
logistics
prob pddl
prob pddl
prob pddl

parse time



















analysis time



















output time total





































figure table showing tim performance milliseconds standard domains timings elapsed times minor discrepancies totals arise
rounding



fiautomatic inference state invariants

tim analysis mystery domain







millisecs























size file

figure graph showing tim performance mystery plotting time
size characters file solid line plot quadratic function
number characters specification file graph constructed running
tim strips mystery domain pddl release increasing
sizes specifications ect increases categories
objects domain corresponding facts describe initial states
figure shows effect tim performance number operator schemas
increases graph constructed artificial domain operator
causes two state transitions described two literals thus number
operators number properties increasing whilst number objects stays constant
domain described detail appendix e graph indicates linear growth
cost analysis
final dimension evaluating tim effect exploitation output
planner gerevini schubert kautz selman provide convincing
evidence supporting powerful role state invariants enhancing performance
sat figure demonstrate power inferred types showing
advantage stan tim obtains stan without tim untyped rocket domain
figure shows effect performance increasing number packages
transported time taken stan tim grows linearly whilst stan without
tim follows cubic curve p packages instance stan tim
constructs p operator instances stan without tim constructs p p p
instances demonstrates type information significant factor
advantage depicted graph figure demonstrates similar improvement
obtained logistics domain graph series sub considered


fifox long






millisecs






tim performance increasing number operators





























number operators















figure graph showing consequences increasing number schemas inferrable property spaces
effect tim performance stan





stan without tim
stan tim






millisecs



































number packages







figure graph showing comparison stan stan without tim rocket
domain generated rocket domain provided appendix


fiautomatic inference state invariants

effect tim performance stan




stan without tim
stan tim


millisecs













number sub







figure graph showing comparison stan stan without tim logistics
domain
sub involves independent transportation single package
two cities
simple domains overhead carrying analysis outweigh
advantages offered example movie domain used competition stan gained
benefits tim paid overhead detriment performance
instances domain however general observe benefits analysis
increase increasing complexity domains

related work
although importance state invariants ecient observed
relatively little work automatic inference invariants published work
closely resembles described state constraint inference
system discoplan gerevini schubert discoplan enables inference
sv constraints correspond subset identity invariants reason
discoplan restricted subset generates sv constraints pairs literals
one addlist schema delete list arguments
vary one place tim infer identity invariants vectors arguments vary
shown section discoplan cannot currently infer singly varying constraints
although techniques described gerevini schubert yet fully
implemented discoplan example discoplan cannot infer blocks


fifox long

one surface analysis blocks world domain cited tim
infer invariants sub space analysis
gerevini schubert b examined potential inferring
parameter domains similar operator parameter types inferred tim
domains inferred iterative process accretion similar attribute
space extension process tim however accretion process describe synthetic
parameter domains synthesised directly operator descriptions
initial state tim analytic system constructs types analysis functional properties domain objects analytic provides rich information
source structures including domain invariants derived
implicative constraints inferred discoplan correspond implicit
type assignment would arise type structure built tim implicative
constraint generated discoplan refers separation functional roles objects
particular irre exivity
x x x
captured kind constraint tim cannot currently infer invariants
tim uses analysis state view objects domain able
generate broader collection invariants including state membership unique state
invariants currently produced discoplan
although discoplan deal negative preconditions tim cannot yet manage
invariants produce overall currently less powerful inferred
tim
apart work gerevini schubert older work inference
invariants relies generation candidate invariants
confirmed inductive process domain operators two examples
work kelleher cohn morris feldman former work
concentrates identifying directed mutual persistence relations hold pairs
facts domain established second continues hold
first use relations leads inference collection constraints
fall uniqueness invariants inferred tim work described morris
feldman authors build invariants truth counts counts
number propositions particular identified sets must true state
domain sets count used build invariants
subset state membership uniqueness invariants authors describe methods
attempting identify sets facts work work common
kelleher cohn gerevini schubert builds invariants first hypothesising
possible seed invariants determining validity analysing effects
operators seeds contrast generate test strategy tim produces
correct invariants infers deep structural analysis domain
inference invariants exhaust possibilities analysis example
type structure inferred automatically analysis shown
dramatic potential eciency relationship enablers
state transitions enable determines ordering satisfaction goals
significance eciency state view behaviour


fiautomatic inference state invariants

domain objects would allow techniques described mccluskey porteous
automated
mccluskey porteous proposed explored object centred
provision domain engineer rich
collection state invariants object sorts participating functional relationships
domain invariants exploited domain compilation phase facilitate
ecient application domain tim infers precisely sorts collections
state invariants mccluskey porteous provide hand
grant generates state invariants state descriptions provided hand
uses invariants build operator schemas clearly related even
though objectives analysis different grant concerned automatic
synthesis domain descriptions rich requirements specification provided
expert user concern reverse engineering domain description obtain information help increase eciency planners applied domain although
primary objectives use tim enhance performance within
domain tim provides valuable tool construction domain descriptions
revealing underlying behaviours domain engineer implicitly imposed
helping debugging domain descriptions

conclusion
tim planner independent set techniques identifying underlying structure

domain revealing type structure collection four different kinds invariant conditions one important application techniques domain debugging aid
construction large complex domains tim revealed many anomalies
domains encoded us others greatly assisted us understanding
stan performance many domains another important application
increasing eciency planners making explicit planner information
domain would otherwise infer domain representation

tim generates rich collection invariants containing many inferrable
related systems discussed previous section presented gerevini
schubert suggest marked improvement obtained use
invariants performance planners sat solving techniques analysis
yet done determine advantages might obtainable invariants
planners architectures stan yet exploit invariants produced tim uses type structure fixed resource invariants
currently developing extension stan fully exploit kinds
invariant expect able use uniqueness identity invariants shortcut
effort involved deducing significant subset necessary mutex relations
graph construction
analysis performed tim ecient growing slowly quadratic function
size initial state analysed empirical analysis consider
effect tim performance increasing numbers operator schemas however
argument presented section shows tim analysis grows linearly number


fifox long

operator schemas linearly number domain constants linearly
size initial state factors take account confirms
polynomial performance size related structure domain increases
type analysis performed tim differs important respects
forms type analysis performed compilation programs written strongly
typed languages latter context type correctness program judged
respect imposed context basic types tim infers basic types domain
description impossible domain specification well typed consequently
attempt type check domain descriptions tim direction
hope move near future type checking enable unsolvable
detected unsolvable statically rather time currently
focus type inference exploitation inferred type structure
management search space planner

acknowledgements

would thank alfonso gerevini gerry kelleher anonymous referees
useful discussions helpful comments earlier drafts

appendix ftp web sites

aips competition ftp site

http ftp cs yale edu pub mcdermott aipscomp html

web site stan tim executables found



http www dur ac uk dcs www stanstuff planpage html

appendix b tim

following pseudo code description tim
fconstruct base prss section g
ps fg
operator schema
variable x
construct prs x add ps

fsplit prssg

prs ps p
property p appears p adds deleted precs fields
split p p p q replace p p q ps
split p p
construct prs q precs p deleted precs adds set fpg
construct prs p p removing p deleted precs adds p

fconstruct transition rules section g
ts fg

prs ps p
construct transition rule p add ts

fseed property attribute spaces section g

let property initially assigned separate equivalence class
rule r ts
merge together unite equivalence classes properties start finish r



fiautomatic inference state invariants

construct separate space equivalence class properties

fassign transition rules section g

rule r ts
place r space associated equivalence class containing properties
start finish r
r increasing decreasing rule
mark attribute space

fanalyse initial state section g

object domain
identify bag initial properties
space
construct bag properties belong equivalence class
associated b
b non empty
add space
attribute space
add b state

fextend property spaces section g

property space p
unextended state p
mark extended
newgen fg
rule p r
start r included
add state snew ominus start oplus end newgen
snewis superset state newgen
mark p attribute space exit analysis p
add newgen states p

fextend attribute spaces section g

changes true
changes
changes false
unmarked attribute space
extend extend
mark
rule r
property enablers r p
p equivalence class associated unmarked attribute space
extend
add objects appear every space associated enabling property r
objects added
changes true

fidentify types section g

object domain
identify pattern membership spaces tt
associate type pattern tt
operator schema
argument x
identify pattern membership spaces x implied properties x
preconditions tt
associate type pattern tt x

fconstruct invariants section g

property space p
property p p
construct identity invariant p
construct state membership invariant p
construct uniqueness invariant p



fifox long

appendix c example output

following output produced tim found along examples
stan webpage examples details analysis performed
three domains flat tyre domain mystery domain logistics domain
analysis done respect initial state set operator schemas operator
schemas used three domains provided pddl strips releases
domains initial states taken pddl release pddl release
found http www cs yale edu html yale cs hyplans mcdermott html

c tyre world
tim type inference mechanism support stan state analysis planner
long fox university durham

reading domain file domain pddl
reading file prob pddl
tim domain analysis complete flat tire strips
tim types
type
type
type
type
type
type
type
type



















wrench
wheel
wheel
trunk
hub
pump
nuts
jack

noticed two wheels separated different types
one wheel intact intact operator repairing wheels
intact tools given different types
appear constants different operators therefore functionally distinct
tim state invariants
forall x ground x lifted x
forall x ground x lifted x
forall x closed x open x
forall x closed x open x



fiautomatic inference state invariants

forall x u deflated x inflated x
forall x u deflated x inflated x

invariants hubs suggest almost anything could hub since
case type structure discriminating however additional
invariants drawn sub space analysis provide enough information principle
discriminate fully types information yet fully exploited
forall x forall forall z x z x z
forall x exists u u u u u x
free x
forall x exists u u u u u x
free x
forall x forall forall z tight x tight z x z
forall x forall forall z loose x loose z x z
forall x exists u u u u u tight x
fastened x
exists u u u u u loose x
fastened x unfastened x
forall x exists u u u u u tight x
fastened x
exists u u u u u loose x
fastened x
forall x exists u u u u u tight x
fastened x unfastened x
forall x exists u u u u u loose x
fastened x unfastened x

tim domain invariants
x
x
x
x
x
x
x
x
x

container x
hub x
intact x
jack x
nut x
pump x
unlocked x
wheel x
wrench x

tim attribute spaces



fifox long

attribute space properties first groups subjected much
rigorous analysis sub space invariants
objects x u u u u u property
exists x
exists x
exists tight x
exists loose x
x
objects x property
exists u u u u u x
objects x property container x
objects x property hub x
objects x property intact x
objects x property jack x
objects x property nut x
objects x property pump x
objects x property unlocked x
objects x u property wheel x
objects x property wrench x

tim operator parameter restrictions
inflate x
put wheel x u x
remove wheel x u x
put nuts x x
remove nuts x x
jack x
jack x
tighten x x
loosen x x
put away x u u u u u x
fetch x u u u u u x
close container x
open container x
cuss

tim additional state invariants sub space analysis

report additional state invariants add information invariants
already listed tim currently reports invariants subsumed earlier collection
observed first wheel intact second gives
rise following invariant wheels second type


fiautomatic inference state invariants

forall x deflated x

first attribute space contains objects except trunk hub
subjected sub space analysis yielding rich collection invariants
forall x forall forall z x x z z
forall x exists x x
forall x exists x x
forall x forall forall z x x z z
forall x forall forall z x x z z
forall x exists x x
exists x
forall x exists x x
forall x exists x exists x
forall x x exists x
forall x forall forall z x x z z
forall x forall forall z x x z z
forall x exists x x
exists x
forall x exists x x
forall x exists x exists x
forall x x exists x
forall x forall forall z x x z z
forall x exists x x
forall x exists x x
forall x forall forall z x x z z
forall x forall forall z tight x
tight x z z
forall x forall forall z loose x
loose x z z
forall x exists tight x
exists loose x
x exists x
forall x exists tight x
exists loose x
forall x exists tight x x
forall x exists tight x
exists x
forall x exists loose x x
forall x exists loose x
exists x
forall x x exists x



fifox long

c mystery domain

mystery domain devised drew mcdermott aips competition
intention conceal structure domain employing obscure
encoding transportation domain code replaces locations names foods
routes eats relations transports pleasures cargos
pains cargos transports locations relation encoded craves
cargo location transport encoded fears relation transports
restricted capacity encoded planets consume fuel travelling locations
fuel exists limited quantities locations measured provinces tim
able decode domain identify roles played components
encoding
tim domain analysis complete mystery strips prob pddl
tim types

noted provinces types divided three separate
types form sequence defined attacks relation first
last slightly different functional role others true planets
types
type beef cantelope chocolate flounder guava mutton onion
pepper rice shrimp sweetroll tuna yogurt
type saturn
type pluto
type neptune
type achievement lubricity
type abrasion anger angina boils depression grief hangover
laceration
type alsace bosnia guanabara kentucky
type goias
type arizona

tim state invariants
forall x forall forall z harmony x
harmony x z z
forall x exists u u harmony x
forall x forall forall z locale x
locale x z z
forall x exists u u locale x
forall x u forall forall z fears x



fiautomatic inference state invariants

fears x z z
forall x u forall forall z craves x
craves x z z
forall x u exists craves x
exists fears x
forall x u exists craves x
exists fears x

tim domain invariants
x x attacks x x
x x eats x x
x food x
x x harmony x x
x x locale x x
x x orbits x x
x pain x
x planet x
x pleasure x
x province x

tim attribute spaces
objects x u u property
exists harmony x
objects x u u property
exists locale x
objects x property
exists fears x
objects x property
exists u craves x
objects x u property
exists u attacks x
objects x u property
exists u attacks x
objects x property
exists eats x
objects x property
exists eats x
objects x property food x
objects x u property
exists u orbits x



fifox long

objects x
exists u
objects x
objects x
objects x
objects x

u property
orbits x
property pain x
u u property planet x
property pleasure x
u u property province x

tim operator parameter restrictions
succumb x x
feast x x x
overcome x x

tim additional state invariants sub state analysis

additional invariants transports location never
loaded transports
forall x forall forall z craves x
craves x z z
forall x exists craves x

c logistics domain
tim domain analysis complete logistics strips prob pddl
tim types
type bos truck la truck pgh truck
type bos po la po pgh po
type bos airport la airport pgh airport
type bos la pgh
type package package package package package package
package package
type airplane airplane

tim state invariants
forall x u u
x z
forall x u u
x z
forall x u u

forall forall z x
z
forall forall z x
z
exists u x



fiautomatic inference state invariants

exists u x
forall x u u exists u x
exists u x

tim domain invariants
x airplane x
x airport x
x city x
x x city x x
x location x
x obj x
x truck x

tim attribute spaces
objects x
exists u
objects x
exists u
objects x
objects x
objects x
objects x
objects x
objects x
objects x
objects x














u property
u x
u property
u x
property airplane x
property airport x
property city x
u property exists city x
property exists u city x
u property location x
property obj x
property truck x

tim operator parameter restrictions
drive x x u x
fly x x x
unload x u u x
load plane x x x
load truck x x x

u x
u x u
u
u

tim additional state invariants sub state analysis



fifox long

following invariants add constraints trucks airplanes must
location never loaded one another
forall x forall forall z x x z z
forall x exists u x
forall x forall forall z x x z z
forall x exists u x

appendix rocket domain

rocket domain used construction figure follows
define domain rocket
predicates
x
x
fuelled x
unfuelled x
loc x
obj x
container x
action fly
parameters x z
precondition x loc z fuelled x
effect x x z unfuelled x
fuelled x
action load
parameters x z
precondition obj x container x z
z
effect x x z
action unload
parameters x z
precondition z x
effect x z x

appendix e operator test domain

domain artificial domain used test effects increasing operators literals
domain encoding performance tim example third instance
variation achieved adding operator schemas pattern included



fiautomatic inference state invariants

define domain od
predicates
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
p x q x
action
parameters x z
precondition p x q x z
effect p x q x z
p x z q x
action
parameters x z
precondition p x q x z
effect p x q x z
p x z q x
action
parameters x z
precondition p x q x z
effect p x q x z
p x z q x

instance fixed follows
define op
domain od
objects b c



fifox long

init

p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
p b
q c
goal p c q b

references

blum furst fast plan graph analysis ijcai
bundy burstall r weir young r artificial intelligence introductory course edinburgh university press
fikes r nilsson n strips application theoremproving solving artificial intelligence
gerevini schubert l accelerating partial order planners techniques effective search control pruning jair
gerevini schubert l b computing parameter domains aid
aips
gerevini schubert l inferring state constraints domain independent
aaai
grant j inductive learning knowledge operators ph
thesis rijksuniversiteit limburg de maastricht
kautz h selman b role domain specific knowledge
satisfiability framework fourth international conference artificial
intelligence systems


fiautomatic inference state invariants

kelleher g cohn automatically synthesising domain constraints
operator descriptions proceedings ecai
koehler j nebel b dimopoulos extending graphs adl
subset proceedings th european conference
liatsos v richards b least commitment optimal strategy
proceedings th workshop uk scheduling special interest
group
long fox press ecient implementation plangraph stan
jair
mccluskey l porteous j engineering compiling domain
promote validity eciency artificial intelligence
morris p feldman r automatically derived heuristics search
proceedings nd irish conference artificial intelligence cognitive
science school computer applications dublin city university




