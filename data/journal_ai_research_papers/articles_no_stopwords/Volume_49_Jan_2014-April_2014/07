Journal Artificial Intelligence Research 49 (2014) 403-449

Submitted 10/13; published 03/14

Mechanisms Fair Allocation Problems:
No-Punishment Payment Rules Verifiable Settings
Gianluigi Greco

ggreco@mat.unical.it

Dipartimento di Matematica e Informatica
Universita della Calabria
I-87036 Rende, Italy

Francesco Scarcello

scarcello@dimes.unical.it

DIMES
Universita della Calabria
I-87036 Rende, Italy

Abstract
Mechanism design considered context fair allocations indivisible goods
monetary compensation, focusing problems agents declarations allocated goods verified payments performed. setting considered
verification might subject errors, payments awarded presumption innocence, incorrect declared values necessarily mean manipulation
attempts agents. Within setting, mechanism designed shown
truthful, efficient, budget-balanced. Moreover, agents utilities fairly determined
Shapley value suitable coalitional games, enjoy highly desirable properties
equal treatment equals, envy-freeness, stronger one called individual-optimality.
particular, latter property guarantees that, every agent, her/his utility
maximum possible one alternative optimal allocation.
computational complexity proposed mechanism studied. turns
#P-complete that, deal applications many agents involved,
two polynomial-time randomized variants proposed: one still truthful
efficient, approximately budget-balanced high probability, another
one truthful expectation, still budget-balanced efficient.

1. Introduction
Whenever outcome social choice process depends information collected
number self-interested agents, strategic issues may come play. Indeed, agents
may find convenient misreport types, i.e., relevant information
private knowledge, (global) best possible solution missed.
cases, mechanism design techniques used solution approaches, augment
combinatorial algorithms appropriate monetary payments, aimed motivating
agents truthfully report private types (see, e.g., Nisan, Roughgarden, Tardos, &
Vazirani, 2007; Shoham & Leyton-Brown, 2009).
class social choice utilitarian problems, agent types encode (monetary) valuations set solutions goal compute solution maximizing social
welfare, i.e., sum agents true evaluations. prominent role mechanism design
problems class played Vickrey-Clarke-Grove (VCG) paradigm (Vick-

c
2014
AI Access Foundation. rights reserved.

fiGreco & Scarcello

ery, 1961; Clarke, 1971; Groves, 1973), general method designing truthful
mechanisms, i.e., mechanisms truth-telling dominant strategy agent.
particular, VCG mechanisms efficient. is, guarantee solution maximizing social welfare actually computed. However, budget-balanced, i.e.,
algebraic sum monetary transfers always zero mechanisms class
run deficit. fact, well-known drawback VCG mechanisms (see, e.g.,
Archer & Tardos, 2007), essentially best one hope do, given classical
impossibility theorems (Green & Laffont, 1977; Hurwicz, 1975) stating truthful
mechanism designed always efficient budget-balanced.
many practical applications, however, payments agents performed
final outcome known, kind verification reported types might
possible. additional power considered classical mechanism-design setting
and, fact, whenever verification allowed, impossibility results might longer
hold. Mechanisms verification introduced Nisan Ronen (2001),
considered verification task scheduling problem: agents declaring
amount time need solve task, goal tasks solved,
minimizing completion time last-solved one (hence, make-span).
context, payments computed actual task release times observed,
have, instance, ability punish agent whose declared ability
verified different actual performance process.
Compared standard mechanisms (see, e.g., Nisan et al., 2007), verification
received considerably less attention literature (see, e.g., Nisan & Ronen, 2001;
Auletta, De Prisco, Penna, & Persiano, 2009; Penna & Ventre, 2012a; Krysta & Ventre,
2010; Ferrante, Parlato, Sorrentino, & Ventre, 2009; Penna & Ventre, 2012b; Auletta,
De Prisco, Penna, Persiano, & Ventre, 2006; Auletta, Penna, Persiano, & Ventre, 2011).
particular, works consider verification ability partial, sense agents
reporting restricted true types plus certain specific kinds deviations (e.g., values
lower true ones) verification focused detecting lies only.
extension model recently proposed Caragiannis, Elkind,
Szegedy, Yu (2012), assume a-priori restrictions agents reported types,
within setting agent cheating her/his type caught probability may depend her/his true type, reported type, both. fact, despite
different facets verification power, mechanisms verification proposed
literature share idea providing incentives truthfully report private types
exploiting intimidation punishing agents caught lying. Moreover,
budget limits considered approaches (see, e.g., Nisan & Ronen,
2001), mechanism verification designed budget-balanced,
focus truthfulness efficiency.
paper, consider instead budget-balanced mechanism based model
verification restriction possible declarations (hence, arbitrary
deviations possible), nevertheless punishment used verification
process. design constraint guided real-world applications clearly
emerges punishing approach would hardly acceptable agents, unless clear
proof deliberate malevolent behavior exhibited. Moreover, even case
punishment proportional amount discrepancy declared
404

fiMechanisms Fair Allocation Problems

verified values attributed malevolent behavior. resulting setting shares
spirit work Feige Tennenholtz (2011), observed possible
discrepancies agents declarations third-party verified values often
due different reasons, particular fact agents, malevolent,
might still unable accurately collect and/or report information valuations.
detail, Feige Tennenholtz (2011) considered scheduling problem single
machine agent reports length her/his job scheduler needs finish
many jobs possible given deadline. Differently earlier literature, assumed
agents uncertain job lengths, instance, limited
computational resources. Moving observation mechanisms verification
often designed way performs well agents accurate information
private features, might perform arbitrarily bad agents uncertain
information, Feige Tennenholtz proposed use forgiving mechanisms,
punishments used enforce truthfulness. mechanisms applied
two models uncertainty: One probabilistic nature, another (called
qualitative private input) quantitative model explaining extent
agents trust estimate, preference agent various lotteries
might even inconsistent probability distribution.
paper follow work Feige Tennenholtz (2011) particular
qualitative model uncertainty. Moreover, addition subjective perspective
problem, uncertainty inherent private inputs, take account
dual (objective) perspective, discrepancies declared verified values
might due errors occur verification process. Indeed, verification
practically implemented sensing parameters become observable
mechanism performed, sensing clearly affected errors (it unrealistic assume
carried arbitrary precision).
fact, matter perspective (objective vs subjective) problem
discussed analyzed, intrinsic limit mechanisms verification clearly
emerged: Whenever agent misreports her/his type detected verifier,
punishing agent might effective mathematical studies, inappropriate
real life situations uncertainty inherent. Accordingly, therefore assume
limited use verification power given hand made. particular,
goal paper design mechanisms based punishments (while
nonetheless resulting truthful, efficient, budget-balanced) tolerant
measurement errors uncertain inputs, sense small errors determine
small deviations outcome would obtained errors all.
1.1 Mechanisms Fair Division Monetary Compensation
consider mechanisms verification context fair allocation problems (see,
e.g., Moulin, 2003; Young, 1994; Thomson, 2011). assume given set
indivisible goods allocated set agents. agent equipped private preference relation, encoded real-valued function (basically, monetary
valuation) possible goodsformal definitions Section 2. agent
allocated one good, case her/his evaluation additive them. More-

405

fiGreco & Scarcello

over, goods indivisible, i.e., good allocated one agent most. However,
monetary transfers allowed, terms payments charged agents monetary
compensations provided them. goal find efficient allocation, is, allocation maximizing total value allocated goods, designing rules guaranteeing
certain desirable properties achieved, truthfulness individual rationality, i.e., agent ever worse she/he would without participating
mechanism. Moreover, want obtain outcomes politically acceptable.
is, agents perceive designed mechanism fair one (see, e.g., Brandt, Conitzer,
& Endriss, 2012), independently rules leading honest. instance,
desirable agent envies allocation agent, selected
outcome Pareto efficient, i.e., must different allocation preferred
agents strictly preferred least one them.
model and, particular, properties fair allocations indivisible objects
monetary transfers studied, e.g., Svensson (1983), Bevia (1998), Maskin
(1987), Tadenuma Thomson (1993), Meertens, Potters, Reijnierse (2002), Tadenuma Thomson (1991), Alkan, Demange, Gale (1991), Willson (2003), Su (1999),
Yang (2001), Quinzii (1984), Sakai (2007). Moreover, procedures compute fair allocations proposed Aragones (1995), Klijn (2000), Haake, Raith, Su (2002),
Brams Kilgour (2001), Potthoff (2002), Abdulkadiroglu, Sonmez, Unver (2004).
None approaches listed above, however, guarantee elicitation honest
preferences agents. fact, question designing truthful fair mechanisms
recently considered well (Andersson & Svensson, 2008; Andersson, 2009; Svensson, 2009; Yengin, 2012; Ohseto, 2004; Porter, Shoham, & Tennenholtz, 2004; Shioura,
Sun, & Yang, 2006). approaches, budget limits sometimes enforced
mechanisms defined cannot run deficit, budget-balance never guaranteed.
Indeed, comes surprise, given truthful mechanism simultaneously fair (e.g., envy-free Pareto-efficient) budget-balanced (see, e.g., Tadenuma
& Thomson, 1995; Alcalde & Barbera, 1994; Andersson, Svensson, & Ehlers, 2010).
circumvent impossibility, approaches studied focus weaker
notions truthfulness. instance, Andersson et al. (2010) Pathak (2013) consider
notion degree manipulability used compare ease manipulation allocation mechanisms, whereas notion weak strategy-proofness considered
Lindner (2010), i.e., cheating agents always risking actual loss, never
guaranteed cheat successfully.
paper, depart settings studied earlier approaches,
interested applications form verification available mechanism
time deciding monetary compensations among agents. particular, assume
valuations well allocation scenarios determined objective properties
goods agents observed measured verifier, allocation
performed payments computed. Note information allocated
goods verified hence used mechanism. framework, classical
impossibility results longer hold. Indeed, propose mechanisms allocation problems
enjoy number highly desirable properties, particular truthful, efficient,
budget-balanced, individually rational, fair, even though agents verified incorrect
declarations punished. Observe kind a-posteriori knowledge
406

fiMechanisms Fair Allocation Problems

payment time quite common many applications. point
cases thorough verification could performed advance, order get best
performances independently agents declarations. However, practice done
either money time restrictions, convenient allocate goods
basis agents declarations (especially mechanism makes honest enough).
Anyway, results used even full information known mechanism,
provide fair division enjoying number desirable properties listed below.
Appendix reports number examples possible applications proposed
framework, including real-world case Italian research-assessment program,
first motivated work.
completeness, leave section recalling work, well
mentioned related literature, deals setting monetary transfers allowed.
fact, fair division indivisible goods without money transfers attracted attention
literature. instance, topic studied Bouveret Lang (2008)
points view compact representation (for expressing preference relations)
computational complexity (of reasoning efficiency fairness concepts
resulting framework), Lipton, Markakis, Mossel, Saberi (2004) point
view defining approximation schemes envy-freeness. Finally, relevant point
that, paper papers discussed above, allocations assumed computed
centralized way. However, might relevant cases adopt decentralized
approaches, based successive negotiations goods (and money) groups
agents. reader interested distributed negotiation frameworks referred work
Sandholm (1998), Dunne, Wooldridge, Laurence (2005), Dunne (2005), Endriss,
Maudet, Sadri, Toni (2006), references therein.
1.2 Contributions
paper, study allocation problems strategic setting agents misreport
private types, study mechanisms verification algorithmic
computational complexity viewpoint.
1.2.1 Algorithmic Issues
show given setting none classical impossibility theorems discussed
holds. particular, exhibit payment rule p turns optimal allocation
algorithm, i.e., algorithm computing optimal allocation given reported types,
mechanism verification that:
mechanism truthful. shown pointing number properties
allocation problems interest own.
mechanism efficient, budget-balanced, individually rational, envy-free, Pareto
efficient.
payment rule indifferent w.r.t. values (possibly misreports) declared goods
occur allocation selected (and hence verified).

407

fiGreco & Scarcello

agent, her/his utility (when truthtelling) maximum one possible
allocations. particular, utility indifferent w.r.t. specific choice allocated
goods optimal allocations. Note strong fairness property, immediately entails envy-freeness Pareto-efficiency.
Verification used force truthfulness punishing agents whose reported values found different verified ones, mechanism forgiving sense recently discussed Feige Tennenholtz (2011). Moreover,
mechanism shown tolerant discrepancies emerging declared types
verified/true ones. is, properties hold equilibrium agents
report true types, preserved approximatively case discrepancies,
guarantee within constant factor distance declared
types verified/true ones. Note generally possible mechanisms
based punishment approaches where, enforce truthfulness, punishment might
disproportional harm done misreporting (cf. Feige & Tennenholtz, 2011).
Agents utilities distributed according Shapley value two suitably-associated
coalitional gamessee, e.g., (Nisan et al., 2007), comprehensive introduction
sharing problems coalitional games. fact, Shapley value prototypical
solution concept fair division monetary compensations,1 desirable properties (games associated with) allocation problems extensively studied
literature (e.g., Moulin, 1992; Maniquet, 2003; Mishra & Rangarajan, 2007).
Note Shapely value studied mechanism-design contexts too,
emphasis given pricing problem service provider (Moulin & Shenker,
2001; Moulin, 1999; Jain & Vazirani, 2001): cost providing service function
sets customers, goal determining customers (and
price) receive it. model gives rise cross-monotonic cost-sharing
game, Shapley-value based sharing mechanisms defined truthful
budget-balanced, achieve lowest worst-case loss efficiency utility
profiles (Moulin & Shenker, 2001). respect, pricing rule p abstractly
viewed witness that, whenever (partial) verification possible, Shapley-valued based
mechanisms may implemented loss efficiency all.
1.2.2 Complexity Issues
Computing optimal allocation basis reported types easy task,
carried via adaptations classical matching algorithms. However, one might
suspect computing payments computationally-efficient, based
computation Shapley value. indeed challenging task involves iterating
possible subsets agents. analyze issues, provide following
contributions:
show computing Shapley value allocation problems inherently intractable, fact, #P-complete. Note #P-hardness results problems involving
1. Depending application, solutions concepts different Shapley value might appropriate. instance, bankruptcy problems, nucleolus considered appropriate
solution concept fair distribution (Aumann & Maschler, 1985).

408

fiMechanisms Fair Allocation Problems

Shapley value computation proven literature, instance, weighted
voting games (Deng & Papadimitriou, 1994), minimum spanning-tree games (Nagamochi, Zeng, Kabutoya, & Ibaraki, 1997), games associated normative systems (Agotnes, van der Hoek, Tennenholtz, & Wooldridge, 2009). Moreover, #Phardness results established Banzhaf power index, solution
concept closely related Shapley value (see, e.g., Bachrach & Rosenschein, 2009,
2008; Bachrach, Zuckerman, Wooldridge, & Rosenschein, 2013).
Therefore, order deal scenarios involving large number agents, two
modified rules, p p , presented, allow us employ fully polynomialtime randomized approximation scheme Shapley value computation. resulting polynomial-time mechanisms retain properties p . particular,
mechanism based p universally truthful, efficient, high-probability
approximately budget-balanced. Instead, mechanism based p truthful expectation, always efficient budget-balanced.
1.2.3 Organization
rest paper organized follows. Section 2 illustrates formal framework
basic concepts design mechanisms verification, whose desirable properties
illustrated Section 3. payment rule p defined Section 4, connections
coalitional games pointed Section 5. Rules p p defined Section 6,
computational issues dealt with. comparison related works reported
Section 7, concluding remarks discussed Section 8. Finally, Appendix
illustrates real-world case study application examples notions presented
paper.

2. Formal Framework
section, define formal framework studying allocation problems based
mechanism design tools. particular, focus mechanisms equipped verification
ability meets no-punishment perspective.
2.1 Allocation Scenarios
focus allocation problems goods set G allocated set
agents = {1, ..., n} way overall value allocated goods maximum
feasible allocations, is, social welfare maximized. precisely,
allocation function : 2G mapping agent non-empty set
goods (i) G (i) (j) = , j 6= i. Moreover, given vector
upper-bound constraints = (1 , ..., n ) specifies maximum number goods
assigned agent A. tuple = hA, G, called allocation
scenario. mapping : 2G feasible allocation scenario
allocation goods G agents that, agent A, |(i)| holds.
Observe required goods G allocated agents.
Note applications maximum number goods assigned
agent represents ability (e.g., maximum number tasks she/he
409

fiGreco & Scarcello

execute), hence next represent function = fu (i ), objective
property agent (e.g., her/his speed) fu public-knowledge computable function.
Note setting general earlier approaches literature
upper bounds fixed independent agents features.
Moreover, paper assume value good g agent determined
objective property g good, well property agent.
Formally, assume good valuations encoded valuation vector w = (w1 , ..., wn )
where, A, valuation function assigns good g G real value
wi (g) = fv (g , ), public-knowledge computable function fv .2
idea verifier, best described next section, able measure,
allocation goods agents performed, objective property g
every allocated good g objective property every agent. Therefore,
using (public) function fv , possible compute values goods
assigned agent. believe assumption valuations
functions objective properties goods agents holds many applications
allocation problems, particular social welfare maximized
(since typically measurable value). provide examples Appendix A,
including real-world application evaluation research activities Italy,
originally motivated present work.
Let us fix allocation scenario = hA,
PG, valuation vector w = (w1 , ..., wn ).
Let allocation. Define
wi () =
g(i) wi (g), A, denote
P
val(, w) overall value iA wi (). say optimal (for S) w.r.t. w
feasible allocation feasible allocation 0 val( 0 , w) >
val(, w). value optimal allocation w.r.t. w denoted opt(S, w).
allocation algorithm function mapping allocation scenario
vector w feasible allocation A(S, w) S. algorithm optimal A(S, w)
optimal allocation w.r.t. w, given pair (S, w).
2.2 Strategic Issues Verification
consider classical setting mechanism design optimal allocations
computed context neither agent-depending upper bounds valuation
vector w known allocation algorithm. Therefore, even optimal algorithm
hand, enough information find optimal allocation, general.
fact, assume usual agent privately knows certain features,
called type, determining maximum number goods allocated
her/him, well function wi encoding her/his preferences allocations. Note
that, setting, type agent naturally consists her/his characterizing property
plus property g , good g (s)he interested in. Section 3.2, consider
happens agent may subjective, possibly incorrect, perception
properties (including her/his characterizing property ).
2. Note that, sake simplicity, use two functions fu fv agents. However, nothing
changes paper consider slightly general version different agents may
different public functions.

410

fiMechanisms Fair Allocation Problems

Figure 1: Running example Section 2.
assume type agent taken set available types,
denote cartesian product 1 n possible agents types. Then,
consider direct revelation mechanisms agents asked report types let
mechanism compute allocation. so, agents self-interested, strategic
issues come play.
agent A, hereinafter assume ti always denotes true type
agent i, i.e., type owned private knowledge, di her/his declared
type. Then, = (t1 , ..., tn ) = (d1 , ..., dn ) vectors true declared types,
respectively. general, happen coincide t, agents find
convenient misreport types.
(true declared) type vector = (1 , ..., n ) , denote hereinafter
= hA, G, allocation scenario , is, scenario vector
= (1 , ..., n ) that, A, upper bound determined
type . Similarly, denote w = (w1 , ..., wn ) valuation vector wi
valuation function determined type , A.
Example 2.1. Let us consider two agents, a1 a2 , type vector = (t1 , t2 ),
allocation scenario St = hA, G, illustrated Figure 1(I) means intuitive
graphical notation, = {a1 , a2 }, G = {g1 , ..., g8 }, = (3, 3). Moreover, consider
valuation vector w wt = (wa1 , wa2 ) that, edge connecting
a1 (resp., a2 ) gj Figure 1(I), wa1 (gj ) (resp., wa2 (gj )) value associated
it. Otherwise, i.e., edge connecting a1 (resp., a2 ) gj , wa1 (gj )
(resp., wa2 (gj )) negative number, say 1. Given setting, easily seen
optimal allocation St w.r.t. wt allocation (a1 ) = {g1 , g2 , g4 }
(a2 ) = {g5 , g7 , g8 }see Figure 1(II). Note wa1 ( ) = 25 wa2 ( ) = 26.
Consider allocation Figure 1(III). Note another optimal allocation. However, wa1 ( ) = 26 > wa1 ( ) wa2 ( ) = 25 < wa2 ( ).


411

fiGreco & Scarcello

Figure 2: Strategic manipulation.
Example 2.2. Consider setting Example 2.1, type vector private
knowledge agents. Moreover, assume vector declared types
Sd = St (the allocation scenario correct one) vector wd one
illustrated Figure 2(I), negative edges omitted. Basically, agent a2 truthfully
reports her/his type, agent a1 reports type values goods g2
g3 underestimated. Therefore, wd 6= wt holds. optimal allocation
Sd w.r.t. wd shown Figure 2(II). emerges that, declarations agent
a1 , convenient include g2 g3 . fact, coincides optimal
allocation depicted Figure 1(III). Hence, misreporting type, agent a1
guarantee overall value goods assigned her/him 26. Instead,
truthfully reporting type, a1 might risk allocation selected,
overall value goods assigned her/him 25.
Finally, consider slight variant problem instance actual value good
g7 6 (instead 8) a2 . Then, egoistic behavior agent a1 leads
allocation longer optimal. Indeed, due low declared values g2 g3 ,
good g7 selected allocated a2 unique (wrong) optimal allocation, whose
total value 49 (instead 51).

paper, focus allocation problems kind verification reported types possible, objective properties agents goods observed
measured (we say verified, hereinafter) third-party verifier allocation
performed. Recall
Sin general subset goods actually assigned agent
. Denote set iA (i) G allocated goods img(). Thus, model,
good g img(), objective property g verified, nothing said
non-allocated hence non-observed goods. Moreover, agent participating mechanism, property determines upper-bound constraint
preferences good allocations verifiable, too. Thus, using verifier,
correct allocation scenario restriction img() valuation functions
determined, formalized next.
Definition 2.3. Let vector true types. Then, verifier v (for t) function
mapping allocation pair Sv() , wv() that:
(1) Sv() actual allocation scenario St (in particular, true upper bound fu (i )
computed verifier agent i);
(2) wv() = (wv1 , ..., wvn ) vector that, agent A, wvi : img() R
function assigning good g img() actual value fv (g , ) agent
412

fiMechanisms Fair Allocation Problems

i. Observe that, definition framework, wvi coincides restriction
img() valuation function wti : G R determined (true) type ti .
2
worthwhile noting verifier general unable discover whether
agent misreported her/his type, goods allocated undergo
measurement process. pinpoint actually case practical applications,
measurements non-allocated goods may technically unfeasible simply
expensive (in money time). refer reader Appendix A.1 (in particular, subsections A.1.1A.1.3) exemplification notions real-world case study
Italian research evaluation (VQR).
Example 2.4. Consider setting Example 2.2, recall agent a1 finds
convenient underestimate true values g2 g3 . However, since g2 g3
selected , see Figure 2(II), way discover a1
actually misreported her/his type.

cases, constraints allocation scenario depend specific
application agents types, item (1) immaterial. generally,
however, proposed setting allows us model classes problems types play
role even definitions upper-bound constraints.
completeness, remark results paper easily shown hold
even allocation problems every agent must get minimum number goods
greater one (defined specific application). However, sake presentation
prefer keep standard setting non-empty set goods assigned
agent, long her/his upper bound constraint met.
2.3 Payment Rules Mechanisms Verification
order encourage agents truthfully report private types, design mechanisms
monetary transfers performed, verification process.
sake presentation, let us assume St = hA, G, allocation scenario
(recall denotes vector true types), vector declared types
associated allocation scenario Sd = hA, G, i, v verifier (for t).
payment rule p defined vector functions (p1 , ..., pn ), pi (, wd , v)
amount money given agent i, basis given allocation ,
vector declared valuations wd , verifier v. Observe that, notation,
negative value pi (, wd , v) means amount money charged i. Let wt
vector (w1 , ..., wn ). Then, (quasi-linear) utility p, sometimes called individual
welfare, defined value ui,p (, wd , v) = wi () + pi (, wd , v). verifier v
always understood, ui,p (, wd , v) pi (, wd , v) simply denoted ui,p (, wd )
pi (, wd ), respectively. Moreover, whenever payment rule understood
context, utility simply denoted ui (, wd ).
payments computed verification process, define amount
money pi (, wd ) paid agent i, exploit verifier v. Accordingly, desirable
goods allocated, hence verified, play role definition
payments. latter property formalized below.

413

fiGreco & Scarcello

verifiability: Let d0 d00 two type vectors, let wd0 = (w10 , ..., wn0 ) wd00 =
(w100 , ..., wn00 ) associated valuations. Moreover, let mapping
feasible allocation scenarios Sd0 Sd00 . Then, A, pi (, wd0 ) =
pi (, wd00 ) whenever wi0 (g) = wi00 (g) holds every allocated good g img(). Therefore,
d0 d00 undistinguishable far computation payments concerned,
even differ unallocated goods. is, payment rule depends
goods subject verifier evaluation.
mechanism verification pair (A, p), allocation algorithm
p payment rule exploit verifier v. mechanism (A, p) viewed
consisting following two-phases: First, agents report declaration vector d,
feasible allocation = A(wd ) Sd computed. Second, v() made available,
payments given rule p calculated respect allocation
valuations wd , exploiting knowledge v(). goal design payment rule p
guaranteeing declared types lead allocation maximizing social welfare,
i.e., optimal allocation St w.r.t. wt . might problematic as,
setting, even fact feasible allocation St guaranteed,
allocation scenario depends types agents might St 6= Sd .
order accomplish goal, use optimal allocation algorithm A,
need p encourages agents truthfully report private types. Formally,
type vector = (1 , ..., n ) type , A, let (i , )
type vector (1 , ..., i1 , , i+1 , ..., n ) . Then, shall consider following concept
truthful mechanism.
Definition 2.5. Let (A, p) mechanism verification, let agent A.
say dominant strategy agent w.r.t. (A, p) if, type vector ,
ui (A(w(i ,i ) ), w(i ,i ) ) ui (A(w ), w ) holds. mechanism (A, p) truthful if,
A, ti dominant strategy.
2
Example 2.6. Consider setting discussed Example 2.2, trivial payment
rule p payment actually performed. Consider optimal allocation
(for St w.r.t. wt ) depicted Figure 1(II), note ua1 ( , wt ) = 25. Instead,
allocation depicted Figure 2(II), ua1 ( , wt ) = 26, unique
optimal allocation Sd = St w.r.t. wd , = (da1 , ta1 ).
Therefore, mechanism (A, p ), optimal allocation algorithm
A(wt ) = , truthful. generally, optimal allocation algorithm A,
example witnessing (A, p ) truthful easily defined suitably adapting
above. Hence, non-trivial payment rules necessary encourage agents truthfully
report types.

comparison approach verification existing ones reported Section 7.

3. Properties (Truthful) Mechanisms
section, discuss desiderata mechanisms lead fair allocations
tolerant uncertain inputs. Note design mechanisms able
deal two issues interest even settings strategic, i.e., even
414

fiMechanisms Fair Allocation Problems

granted agents truthfully report types. Exemplifications
proposed notions reported Appendix A.1.4, completes description case
study regarding Italian research evaluation (VQR). examples described
Appendix A.2 Appendix A.3.
3.1 Fairness Issues Desirable Properties
Let (A, p) truthful mechanism verification. paper, focus number
(ex-post) properties mechanism, checked equilibrium agents
truthfully report private types.
(allocative) efficiency: A(wt ) optimal allocation St w.r.t. wt . is, social
welfare maximized.
individual rationality: ui (A(w(ti ,i ) ), w(ti ,i ) ) 0, agent
type vector agents \ {i}. Hence, voluntary participation agent
take part allocation problem encouraged (independently whether
agents actually report true types not).
P
(strong) budget-balance: iA pi (A(wt ), wt ) = 0. words, transfer
money scenario.
envy-freeness: pair agents i, j A, feasible allocation St
(i) A(wt )(j) 6= , ui (A(wt ), wt ) ui (, wt ).
Pareto-efficiency: feasible allocation St that: (1) ui (, wt )
ui (A(wt ), wt ), agent A, (2) agent j uj (, wt ) >
uj (A(wt ), wt ). is, A(wt ) Pareto-dominated allocation.
equal treatment equals: pair agents i, j = j wi = wj ,
wt = (w1 , ..., wn ), must case ui (A(wt ), wt ) = uj (A(wt ), wt ).
individual optimality: ui (A(wt ), wt ) ui (, wt ), feasible allocation St .
Note properties make sense even settings strategic,
goal compute fair allocation. Indeed, setting strategic,
agents report true types, even without monetary incentive. However, without
payments, fairness cannot achieved general: think, instance, scenario
two agents, a1 a2 , one good g value agents.
case, matter optimal allocation considered (where g assigned either a1
a2 ), one two agents would envy other. makes clear payment rules
play role encourage agents reports true types,
crucial induce agents perceive given allocation fair one. fact,
properties, last, classically considered context fair allocation
problems, absence strategic issues.
Here, additionally considered individual optimality, readily seen
imply envy-freeness Pareto-efficiency. entails unique possible
415

fiGreco & Scarcello

vector utilities agents. particular, means agents utilities sensible
possible alternative allocations, hence independent specific set allocated
goods selected optimal algorithm A.
Example 3.1. Consider trivial payment rule p discussed Example 2.6. Consider
optimal allocation depicted Figure 1(II), compare allocation
Figure 1(III). Recall another optimal allocation (for St w.r.t. wt ). Moreover,
p , ua1 ( , wt ) = 25 ua1 ( , wt ) = 26 hold. Therefore, optimization perspective choice immaterial, a1 might good arguments
complain selected place . fact, p individually optimal.

Individual optimality definitely desirable requirement, still miss something. Indeed, notice property trivially satisfied fully uniform payment
rule, guarantees agent gets utility, matter her/his valuation
goods. course, desirable general. Rather, meritocracy somehow
addressed, true fair rule reflect actual contribution agent
overall value allocation.
Let allocation St , necessarily optimal one w.r.t. wt , define
marginal contribution non-empty set C agents w.r.t. wt value:
marg,wt (C) = opt(hA, img(), i, wt ) opt(hA \ C, img(), i, wt ).

(1)

words, marginal contribution marg,wt (C) agents C assesses loss
overall value would register agents C part problem.
Example 3.2. Consider setting Example 2.1 optimal allocation Figure 1(II). Note marg ,wt ({a1 }) = marg ,wt ({a2 }) = 51 26 = 25. Therefore, two
agents (viewed singletons) marginal contribution, defining payment
rule leads utilities equally sharing overall value 51 natural option.
Consider different setting, true types induce allocation scenario
St vector wt , valuation good g8 agent a2 ,
110 instead 10. case, would still remain optimal allocation, overall
value 151. Moreover, marginal contribution a1 affected modification,
marginal contribution a2 would become 151 26 = 125. witnesses a2
contributes a1 , payment rule leading equally sharing overall value
longer perceived fair one.

intuition conveyed example formalized via following
requirement.
P
marginality: non-empty set C agents,
iC ui (A(wt ), wt )
margA(wt ),wt (C). Hence, group agents gets least marginal contribution
given allocation.
3.2 Sensing Errors
conclude presentation (strategic) setting fair allocation problems illustrating subtle issues arising process verification. starting point
416

fiMechanisms Fair Allocation Problems

discussion observation verifiers practically implemented sensing
parameters (in setting parameters , agent i, g , allocated
good g) become observable allocation performed that, real-world
applications, sensing subject errors; instance, limited precision
measurement instruments. Therefore, unrealistic assume verifier
always able exactly discover (i.e., arbitrary precision) actual upper bounds
scenario St valuation vector wt , might problematic decide whether
observed discrepancy verified values declared ones due strategic
behavior sensing errors. fact, sensing troubles arise even settings
relevant information available public knowledge acquired via sensing
environment, i.e., even getting rid strategic consideration.
discussed Introduction, issue pointed recent work
Feige Tennenholtz (2011), though slightly different perspective. There, observed mechanisms verification often designed way performs well
agents accurate information private inputs, might perform arbitrarily
bad agents uncertain private features. Uncertainty might
result hardware measurement errors, due limited computational resources
employed agents identifying declared valuations. instance, setting,
type agent consists her/his characterizing property plus property g ,
good g (s)he interested in. According perspective Feige Tennenholtz
(2011), agent might estimate type. instance, agent might
enough computational resources precisely determine properties g
goods g, type actually represent subjective perception them.
light observations, clearly emerges punishing agents might
effective mathematical studies, inappropriate real life situations
uncertainty inherent due measurements errors uncertain inputs. Therefore, addition requirements discussed far, another desirable property mechanism
use punishment (or forgiving, sense Feige & Tennenholtz, 2011).
punishment: type vector , feasible allocation ,
agent A, case pi (, w ) = pi (, w(ti ,i ) ). is, discrepancies
given type (possibly declared) true/verified one
impact payment agent i. words, may think payments
always computed presumption innocence, incorrect declared values
mean manipulation attempts agents.
Moreover, admit sensing errors (or uncertain inputs) might occur,
relevant quantitatively assess impact, too. Ideally, would deal
mechanisms tolerate errors, sense small errors determine
small deviations outcome would obtained errors all. Note
generally possible mechanisms based punishment approaches where,
enforce truthfulness, punishment might disproportional harm done
misreporting (cf. Feige & Tennenholtz, 2011). next formalize final desideratum.
type vector , set C agents, set G0 G goods,
let us define hC, G0 , restriction scenario hA, G, agents C
417

fiGreco & Scarcello

goods G0 considered.3 Moreover, given two type vectors , denote
[, ] set type vectors form (X1 , ..., Xn ), Xi {i , },
A. Then, distance dist w (, ) valuation vector w
(or dist(, ), w understood context) defined looking worst
possible impact type vectors [, ] may optimal solutions computed
possible restrictions given setting:
dist w (, ) =

max

CA, G0 G, 0 , 00 [,]

|opt(hC, G0 , 0 i, w0 ) opt(hC, G0 , 00 i, w00 )|.

Now, recall truthful mechanism always convenient agents report
true types. Assume however agents declare type vector different
true type vector t.4 consequence, get revealed setting St valuation vector
wt = (w1 , ..., wn ), available verifier v discloses information scenario St
vector wt = (w1 , ..., wn ) (restricted allocated goods). standard mechanisms
design settings (and particular punishment approaches), guarantee
property could given case, mechanisms designed analyzed
reports truthful. Instead, would mechanisms tolerant sensing
errors, formalized below.
error tolerance: constant c 0 that, type vector
agent A, |ui (A(wt ), wt ) ui (A(wt ), wt )| c dist(t, t).
Intuitively, error tolerant mechanism, consequences errors good
allocation outcomes produce linear distorting effect agents utilities (and, turn
various properties mechanism). particular, property stated
without assumption sensing errors come play. Indeed, notion
dist(t, t) formalizes errors global perspective. instance, require
errors affect uniformly valuations agents, might well case
errors biased towards specific agent.

4. Mechanisms Verification Allocation Problems
section, introduce mechanism verification allocation problems start
analysis, preliminary proving properties hold optimal allocations.
4.1 General Properties Allocation Problems
Let given type vector, consider allocation scenario = hA, G, i,
= (1 , ..., n ), together valuations given w = (w1 , ..., wn ). start
3. Note little abuse notation: vector hC, G0 , fact restriction C. However,
keep notation simple, write , confusion may arise. Similarly, valuation vector
w transparently considered valuation vector subset agents C Awe
get rid unused components associated agents \ C.
4. property discussed perspective uncertain inputs. adaptation case
verification errors (or case types errors occur) easy task, mainly
matter different interpretation concepts.

418

fiMechanisms Fair Allocation Problems

Figure 3: One-good version allocation problem Example 4.1, two allocations
associated update graph, defined proof Theorem 4.4.
graphical representation, crossing lines represent edges bipartite cliques
connecting two groups virtual agents goods interested in.

observing optimization problem used allocate goods agents equivalently reformulated way precisely one good allocated agent.
Intuitively, may replace agent fresh agents valuations i.
remark equivalence used combinatorial optimization purposes,
i.e., without affecting game theoretic issue.
Let us formalize intuition. First, denote S1 one-good version
hA1 , G, 1i scenario , where:

A1 set agents iA clones(i) agent A, clones(i)
set fresh agents;
1 vector components 1.
Moreover, denote w1 vector agents A1 where, agent c A1 ,
component wc1 associated c wc1 = wi , agent
c clones(i) holds. Thus, allocation problem S1 considering
vector w1 , clone c clones(i) gets exactly one good, valuations
agent w .
Example 4.1. Consider scenario St = hA, {g1 , ..., g8 }, i, = {a1 , a2 },
vector wt = (wa1 , wa2 ) discussed Example 2.1. one-good version scenario
St1 = hA1 , {g1 , ..., g8 }, 1i shown Figure 3(I). Note set agents scenario
A1 = {(a1 )1 , (a1 )2 , (a1 )3 , (a2 )1 , (a2 )2 , (a2 )3 }, clones(ai ) = {(ai )1 , (ai )2 , (ai )3 },
1
{1, 2}. Indeed, recall = (3, 3). Finally, vector wt1 w(a
=
1 )h
1

wa1 (resp., w(a2 )h = wa2 ), h {1, 2, 3}.
419

fiGreco & Scarcello

Now, consider scenario hC, G0 , i, i.e., restriction hA, G, agents
C goods G0 considered, let C1 allocation
one-good version
0
0
1
G
hC, G , . Consider function C : C 2 C (i) = cclones(i) C1 (c),
A. Note |C (i)| , A. Therefore, C feasible allocation
hC, G0 , i, denoted -good(C1 ). Moreover, construction, val(C , w ) = val(C1 , w1 ).
Conversely, feasible allocation C hC, G0 , associated non-empty set
one-good(C ) allocations C1 hC, G0 , i1 C = -good(C1 ),
called one-good forms C . following immediate definition one-good
version forms.
Fact 4.2. Let given type vector, let S1 one-good version , let
C1 allocation S1 . Then, C1 optimal allocation S1 w.r.t. w1 if,
if, -good(C1 ) optimal allocation w.r.t. w .
Example 4.3. Consider setting Example 4.1, allocation
(a1 ) = {g1 , g2 , g3 } (a2 ) = {g5 , g7 , g8 }. Note optimal allocation
w.r.t. valuation vector wt (reported Figure 1(I)), val(, wt ) = 50
opt(St , wt ) = 51 (see, e.g., optimal allocation Figure 1(II)). Now, notice
allocation depicted Figure 3(II) indeed associated one-good form allocation,
actually optimal allocation St1 w.r.t. wt1 , Fact 4.2.

position stating property holds optimal allocation .
property fact interest own, i.e., independently application
study fair allocation problems. words, tells us that, whenever interested
allocating goods subset agents, may safely consider goods img(),
rather whole set G. case, basic technical ingredient showing
number key properties because, intuitively, allows us get rid alternative (optimal)
allocations, possibly based non-allocated goods G \ img().
Theorem 4.4. Let given type vector, let optimal allocation
hA, G, w.r.t. w , let C set agents. Then, every optimal allocation
hC, img(), w.r.t. w optimal allocation hC, G, w.r.t. w .
Proof. Let C set agents, assume C optimal allocation
hC, img(), w.r.t. w . shall show C optimal allocation unrestricted
problem hC, G, w.r.t. w , too.
end, consider optimal allocation C problem hC, G,
goods G available agents C. next prove val(C , w ) = val(C , w ).
clearly follows optimality C img(C ) img() holds. Therefore,
strictly better C , C must allocate good G \ img(). Assume thus
contradiction val(C , w ) < val(C , w ), hence img(C ) 6 img(), entails
img() G. Consider two allocations C1 one-good(C ) 1C one-good(C ),
observe first that: val(C1 , w1 ) = val(C , w ) < val(C , w ) = val(1C , w1 ).
Let L set agents whose good-assignment according
allocations, i.e., L = {c C 1 | 1C (c) = C1 (c)}. Then, define (C1 , 1C ) = (C 1 \ L {s, t}, E)
directed graph, called update graph C1 w.r.t. 1C , whose nodes agents
C 1 change goods two allocations plus two distinguished nodes t,
whose edges E defined follows:
420

fiMechanisms Fair Allocation Problems

edge agent c agent c0 1C (c0 ) = C1 (c) 6= ;
edge agent c0 agent c 1C (c0 ) = C1 (c) 6= ;
edge agent c agent c0 1C (c0 ) = C1 (c) 6= ;
edges E.
example construction, consider Figure 3(IV) showing update graph allocation shown Figure 3(II) w.r.t. allocation shown Figure 3(III).
agent gets one good C1 1C , node (C1 , 1C ) exactly
one incoming edge one outgoing edge. Moreover, construction, incoming
edge, outgoing edge. Thus, update graph consists number paths
number cycles, disjoint other.
Let {1 , ..., h } set possible paths cycles (C1 , 1C ),
path cycle = 1 , ..., , let agents(i ) set {1 , ..., } \ {s, t}.
addition, let us fix following notation: function : X 2G given
domain X, let [X 0 ] denote restriction (sub-)domain X 0 X. Moreover,
: X2 2G2 two domains X1 X2 ,
given two functions 1 : X1 2G1 2 U
respectively,
= , let 1 2 : X1 X2 2G1 G2 function
U X1 X2 U
(1 2 )[X1 ] = 1 (1 2 )[X2 ] = 2 .
construction update graph, note 1C expressed terms
disjoint paths/cycles 1 , ..., h following expression:
C1 [C 1 \

h
[

agents(i )]

h
]

1C [agents(i )].

i=1

i=1

Observe that, val(C1 , w1 ) < val(1C , w1 ), must exists set agents
agents(k ), associated disjoint path/cycle k , 1 k h, value
goods allocated agents according 1C greater corresponding
value theUsame agents obtained C1 . Then, consider function k = C1 [C 1 \
agents(k )] 1C [agents(k )], note first k allocation hC, G, i1 .
particular, note that, agent c C 1 , |k (c)| = 1 holds,
U constraint
actually holds C1 1C , definition operator . Moreover,
choice k , val(k , w1 ) > val(C1 , w1 ).
Note k either cycle path form s, 2 , . . . , m1 ,
1C (2 ) img(), img(k ) img() would hold. Indeed, definition edges
update graph, first node path (that is, 2 case k path) may
1C (2 ) \ img() 6= . However, observed above, impossible
val(k , w1 ) > val(C1 , w1 ) would contradict optimality C1 , hence optimality
C , Fact 4.2. Therefore, conclude k path form s, 2 , . . . , m1 ,
k (2 ) = 1C (2 ) = {g 0 } G \ img(). is, allocation k (over agents
C 1 ) img(k ) = {g 0 } img(C1 ) \ C1 (m1 ). particular, observe
C1 (m1 ) img() \ img(k ) holds, definition edges update graph
since edge m1 t.
Let us come back optimal allocation hA, G, w.r.t. w , let 1
(optimal) allocation one-good(). Let C 1 set agents 2
421

fiGreco & Scarcello

Input:
Assumption:
Notation:
1.
2.
3.
4.
5.
6.
7.
8.

type vector , feasible allocation ;
verifier v (for t) available, v() = (v1 , ..., vn );
= hA, G, i, w = (w1 , ..., wn ), wv() = (wv1 , ..., wvn );

Let C denote set possible subsets A;
C C,
b Compute optimal allocation C,i hC, img(), (vi ,i ) w.r.t. w(vi ,i ) ;
agent A,
| set C C P
C,
1
(=val(C,i , w(vi ,i ) ));
| | Let C,i (, ) := wvi (C,i ) + jC\{i} wj (C,i );
P
(=val(C\{i},i , w(vi ,i ) ));
| b Let 2C,i (, ) := jC\{i} wj (C\{i},i );
P
(1C,i (, ) 2C,i (, ));
| Let (, w ) := CC (|A||C|)!(|C|1)!
|A|!

9. b

Define pi (, w ) := (, w ) wvi ();

Figure 4: Payment rule p .


goods cA 1 (c) allocated agents according 1 equal
set
0
00
00
00
cA k (c)\{g }G , G img()\img(k ) |G | 1. Note set
property fact exists: start {2 } add agents agents(k )
c found 1 (c) img()
U 1 \1img(k ).
Consider = k [A] [A \ A] note well-defined,
construction set guarantees good allocated according k [A]
allocated 1 agents A1 \ A, vice-versa. Moreover, feasible allocation
hA, G, i1 . Indeed, agent c A1 , |(c)| = 1 holds, constraint actually
holds k 1 . Eventually, since 1 optimal allocation hA, G, i1 w.r.t. w1 ,
val( 1 , w1 ) val(, w1 ) holds. Thus, construction , get val( 1 [A], w1 )
val([A], w1 ) = val(k [A], w1 ). U
Finally, let C0 = k [C 1 \ A] 1 [A] note C0 feasible allocation
hC, G, i1 , arguments used show feasible allocation.
Moreover, observe val(C0 , w1 ) val(k , w1 ) > val(C1 , w1 ) img(C0 ) img().
latter, recall 2 agent C 1 k (2 )\img() 6= .
Again, entails C1 optimal w.r.t. w1 hence, Fact 4.2, C
optimal hC, img(), w.r.t. w . Contradiction.
result immediately entails following two corollaries.
Corollary 4.5. optimal allocation hA, G, w.r.t. w set
C agents, opt(hC, img(), i, w ) = opt(hC, G, i, w ).
Corollary 4.6. Let optimal allocation hA, G, w.r.t. w , let 0
feasible allocation hA, G, i, hence val(, w ) val( 0 , w ). Then, set
C agents, opt(hC, img(), i, w ) opt(hC, img( 0 ), i, w ).

422

fiMechanisms Fair Allocation Problems

4.2 Design Truthful Mechanism
Consider payment rule p defined Figure 4: given type vector ,
feasible allocation selects goods img() G agents
A. Moreover, use verifier v (for vector true types t) that, given , able
compute actual scenario Sv() valuation vector wv() = (wv1 , ..., wvn )
allocated goods img(). Note that, sake presentation, section
convenient look output verifier list equivalent types v() = (v1 , ..., vn )
vi , agent i, upper bound constraint goods valuation
img() computed verifier v. Then, usual, (vi , ) denotes
type vector obtained replacing type verified type vi . particular,
w(vi ,i ) denotes valuation vector (defined img()) function wvi used
place valuation function declared .
first three steps, payment rule associates optimal allocation C,i
hC, img(), (vi ,i ) w.r.t. w(vi ,i ) set C C agents agent A,
C powerset A, i.e., set possible subsets agents. Then,
agent A, rule computes value (, w ) step 8, means formula
depends valuations associated allocations C,i C\{i},i , C C.
particular, defines two terms (1C,i (, ) 2C,i (, )), evaluate allocations
C,i C\{i},i , respectively, w.r.t. valuation vector w(vi ,i ) . Actually, term
2C,i (, ), valuation immaterial C\{i},i allocation C \ {i}. Finally,
payment pi (, w) defined step 9 difference (, w ) wvi ().
Note payment rule depends values goods img(),
verifiable, according definition provided Section 2.3. Moreover note that,
far paying agent concerned, rule depends values given wvi
allocated goods, i.e., values returned verifier, rather wi . Thus,
declaration immaterial far computation payment concerned,
next fact easily follows.
Fact 4.7 (no punishment). type vector , feasible allocation
, agent A, case pi (, w ) = pi (, w(ti ,i ) ).
Moreover, note idea underlying definition p that, verification
performed, utility function precisely coincide bonus (, w ), hence
sharing spirit5 approach Nisan Ronen (2001).
Lemma 4.8. type vector feasible allocation ,
case ui (, w ) = (, w ).
exploiting characterization, show first crucial result payment rule p , i.e., mechanism (A, p ) truthful, provided arbitrary
optimal allocation algorithm.
get high-level intuition proof observe (, w ) depends two
groups terms, 2C,i (, ) basically independent given agent i. Thus,
5. say spirit, peculiar form (, w ) formally fit framework considered
Nisan Ronen (2001).

423

fiGreco & Scarcello

goal agent maximize terms form 1C,i (, ) defined step 6
valuations optimal allocations computed (in step 3) considering verified type,
focusing goods img() (so verified values coincide true ones),
considering subsets whole set agents. salient machinery provided
Corollary 4.5, according always convenient agent report
true type. Indeed, optimal allocation computed via based true type
agent i, Corollary 4.5 guarantees 1C,i (, ) get maximum possible
value possible allocations scenarios obtained considering subsets agents,
i.e., independently allocation actually selected. done without
strategically interacting agents. Therefore, designing payment rule
way depends values returned verifier, end
verifiable rule using punishment, obtain truthful mechanism based it.
Theorem 4.9 (truthfulness). Let optimal allocation algorithm. Then, mechanism verification (A, p ) truthful.
Proof. show that, agent reported type vector d,
following holds: ui (A(w(ti ,di ) ), w(ti ,di ) ) ui (A(wd ), wd ); hence, Lemma 4.8,
(A(w(ti ,di ) ), w(ti ,di ) ) (A(wd ), wd ).
Consider construction reported Figure 4 two cases = =
(ti , di ), let = A(wd ) 0 = A(w(ti ,di ) ) corresponding optimal allocations
(for scenarios Sd S(ti ,di ) , respectively) received input payment rule
0 )
Figure 4. set C C agents, agent A, let C,i (resp., C,i
allocation computed step 3. Note step well defined,
optimal allocation always exists. Indeed, note exist feasible allocations
scenario , e.g., allocation : C 2img() (j) = {g} good
g (j). is, allocation trivially satisfies every upper-bound constraint, since
assigns one good agent.
show following two properties hold, C C A:
(A) 1C,i ( 0 , (ti , di )) 1C,i (, d),
(B) 2C,i ( 0 , (ti , di )) = 2C,i (, d).
order prove (A), observe step 6, 1C,i ( 0 , (ti , di )) = val(C,i , w(vi ,di ) ) =
0
val(C,i , w(ti ,di ) ), last equality holds C,i
img( 0 ), true
0
optimal allocation
valuation disclosed verifier. Then, observe C,i
0
0
hC, img( ), (vi ,di ) = hC, img( ), (ti ,di ) w.r.t. w(vi ,di ) and, hence, w.r.t. w(ti ,di ) ,
0 = A(w(ti ,di ) ) optimal allocation S(ti ,di ) = hA, G, (ti ,di ) w.r.t. w(ti ,di ) .
Thus, Corollary 4.5, get following expression:
0
1C,i ( 0 , (ti , di )) = val(C,i
, w(ti ,di ) ) = opt(hC, G, (ti ,di ) i, w(ti ,di ) ).

(2)

Similarly, 1C,i (, d) = val(C,i , w(vi ,di ) ) = val(C,i , w(ti ,di ) ) holds. Thus,
use Equation 2, order get 1C,i ( 0 , (ti , di )) = opt(hC, G, (ti ,di ) i, w(ti ,di ) )
val(C,i , w(ti ,di ) ). shows (A) holds.

424

fiMechanisms Fair Allocation Problems

0
Let us focus (B). step 7, 2C,i ( 0 , (ti , di )) = val(C\{i},i
, w(vi ,di ) )
2
0
whereas C,i (, d) = val(C\{i},i , w(vi ,di ) ). Recall C\{i},i (resp., C\{i},i ) optimal allocation hC \{i}, img(), (vi ,di ) (resp., hC \{i}, img( 0 ), (vi ,di ) i) w.r.t. w(vi ,di ) .
Then, fact evaluation immaterial here, C\{i},i (resp.,
0
C\{i},i
) optimal allocation hC \ {i}, img(), (resp., hC \ {i}, img( 0 ), (ti ,di ) i)
w.r.t. wd (resp., w(ti ,di ) ). Then, recall (resp., 0 ) optimal allocation
Sd (resp., S(ti ,di ) ) w.r.t. wd (resp., w(ti ,di ) ). Thus, Corollary 4.5, 2C,i ( 0 , (ti , di )) =
opt(hC \ {i}, G, (ti ,di ) i, w(ti ,di ) ). Moreover, get:

2C,i (, d) = opt(hC \ {i}, G, i, wd ).

(3)

Eventually, 2C,i ( 0 , (ti , di )) = opt(hC \ {i}, G, (ti ,di ) i, w(ti ,di ) ) = opt(hC \
{i}, G, i, wd ) holds, valuation immaterial, get (B) Equation 3.
4.3 Properties Truthful Strategies
Let us analyze relevant properties hold whenever agents choose dominant strategy truthfully reporting private types. first property useful
characterization agents utilities.
Theorem 4.10. optimal allocation St = hA, G, w.r.t. wt ,
agent A, holds that:
ui (, wt ) =


X (|A| |C|)!(|C| 1)!
opt(hC, G, i, wt ) opt(hC \ {i}, G, i, wt ) .
|A|!

CC

Proof. Lemma 4.8, know ui (, wt ) = (, wt ). Then, set C C
agents, agent A, consider expressions 1C,i (, t) 2C,i (, t) defined
step 6 step 7, respectively, mechanism Figure 4. Note that,
properties verifier v stated Definition 2.3 fact payment rule consider goods allocated via , 1C,i (, t) = val(C,i , w(vi ,ti ) ) = val(C,i , wt )
2C,i (, t) = val(C,i , w(vi ,ti ) ) = val(C\{i},i , wt ) hold, C,i C\{i},i optimal
allocations hC, img(), w.r.t. wt hC \ {i}, img(), w.r.t. wt , respectively.
Thus, 1C,i (, t) = opt(hC, img(), i, wt ) 2C,i (, t) = opt(hC \ {i}, img(), i, wt ).
follows that:
ui (, wt ) =

X (|A| |C|)!(|C| 1)!
(opt(hC, img(), i, wt ) opt(hC \ {i}, img(), i, wt )) .
|A|!

CC

(4)

Recall Corollary 4.5 that, optimal allocation hA, G, w.r.t. wt
set C C agents, opt(hC, img(), i, wt ) = opt(hC, G, i, wt ). Therefore,
1C,i (, t) = opt(hC, G, i, wt ) 2C,i (, t) = opt(hC \ {i}, G, i, wt ). using
equalities, result follows Equation 4.
agents utilities completely independent particular optimal allocation ,
every agent gets precisely utility every optimal allocation.
425

fiGreco & Scarcello

Corollary 4.11. Let 0 two optimal allocations St w.r.t. wt . Then, ui (, wt ) =
ui ( 0 , wt ) holds, A.
Example 4.12. Consider scenario = hA, G, i, = {a1 , a2 } G =
{g1 , ..., g8 }, valuation vector wt = (wa1 , wa2 ) discussed Example 2.1, allocation illustrated Figure 1(I)). Then, have:
ua1 ( , wt ) =

1
2 (opt(h{a1 , a2 }, G, i, wt ) opt(h{a2 }, G, i, wt ))+
1
2 (opt(h{a1 }, G, i, wt ) opt(h{}, G, i, wt ))+
1
2 (opt(h{a2 }, G, i, wt ) opt(h{a2 }, G, i, wt ) =
1
1
1
51
2 (51 26) + 2 (26 0) + 2 (26 26) = 2 .

instance, note opt(h{a1 }, G, i, wt )) = 26, allocate g1 , g4 , g5
a1 , (s)he agent scenario.
Similarly, get ua2 ( , wt ) = 51
2 . is, two agents share precisely half
total value, based payment scheme. fact, looking allocation
Figure 1(II), one might navely suppose a2 contributed a1 overall
value associated . However, due specific allocation considered,
actual values goods two agents. Indeed, fairness utility
values resulting payment rule suddenly appears considering existence
alternative allocation Figure 1(II), symmetric w.r.t.
seems a1 contributed a2 overall value: matter fact, two
agents completely interchangeable optimal allocations, correctly reflected
payment scheme (without need actually looking ). particular,
Corollary 4.11, agents indifferent w.r.t. specific optimal allocation selected,
hence case equally divide available value themselves.

basic properties mechanism pointed next.
Theorem 4.13 (basic properties). Let optimal allocation algorithm. Then,
mechanism (A, p ) efficient guarantees equal treatment equals. Moreover,
valuations non-negative, (A, p ) individually rational.
Proof. clear (A, p ) satisfies efficiency equal treatment equals.
Let agent recall Lemma 4.8 that, type vector
allocation , ui (, w ) = (, w ) holds. Consider payment rule
p defined Figure 4, observe (, w ) defined weighted summation,
coalitions C C, terms form 1C,i (, ) 2C,i (, ). particular,
weights positive claim 1C,i (, ) 2C,i (, ) 0 holds. Indeed,
check that, definition, 1C,i (, ) = opt(hC, img(), i, w ) 2C,i (, ) = opt(hC \
{i}, img(), i, w ). So, hypothesis valuations non-negative,
opt(hC, img(), i, w ) opt(hC \ {i}, img(), i, w ) 0 holds, C
agent A. Thus, ui (, w ) 0, hence fact (A, p ) individually rational trivially
follows (even independently allocation , whether agent truthtelling).
Moreover, mechanism tolerant sensing errors (or uncertain inputs),
sense Section 3.2.
426

fiMechanisms Fair Allocation Problems

Theorem 4.14 (error tolerance). Let optimal allocation algorithm. Then,
mechanism (A, p ) type vector agent A, |ui (A(wt ), wt )
ui (A(wt ), wt )| 3 dist(t, t).
Proof. Consider construction reported Figure 4 two cases = = t,
let = A(wt ) = A(wt ) corresponding allocations received input
payment rule (optimal w.r.t. wt wt , respectively). Moreover, set C C
agents agent A, let C,i C,i corresponding allocations computed
step 3. Then, get:
1C,i (, t) = opt(hC, G, i, wt ), Equation 2 proof Theorem 4.9;
1C,i (, t) = opt(hC, img(), (ti ,ti )i, w(ti ,ti ) ), step 3 Figure 4 fact
true valuation agent disclosed verifier C,i img().
2C,i (, t) = opt(hC \ {i}, G, i, wt ), Equation 3 proof Theorem 4.9;
2C,i (, t) = opt(hC \ {i}, G, i, wt ), Equation 3;
Note |1C,i (, t) opt(hC, img(), i, wt )| dist(t, t). Moreover, since
optimal allocation w.r.t. wt , Corollary 4.5, opt(hC, img(), i, wt ) = opt(hC, G, i, wt )
and, hence, |1C,i (, t) opt(hC, G, i, wt )| dist(t, t) holds. Then, observe
|opt(hC, G, i, wt ) 1C,i (, t)| dist(t, t). Therefore, conclude |1C,i (, t)
1C,i (, t)| 2 dist(t, t).
Similarly, |2C,i (, t) 2C,i (, t)| dist(t, t) holds. Hence, putting together,
derive |(1C,i (, t) 2C,i (, t)) (1C,i (, t) 1C,i (, t))| 3 dist(t, t).
light expression step 7 Figure 4,
|i (, wt ) (, wt )|

X (|A| |C|)!(|C| 1)!
3 dist(t, t).
|A|!

CC

P
conclude proof, observe CC (|A||C|)!(|C|1)!
= 1 holds, |i (, wt )
|A|!
(, wt )| 3 dist(t, t).
Therefore, Lemma 4.8, get |ui (A(wt ), wt )
ui (A(wt ), wt )| = |i (, wt ) (, wt )| 3 dist(t, t).
fact, next show (A, p ), optimal allocation algorithm, satisfies
remaining properties discussed Section 3.1. end, first discuss
interpretation p context coalitional games.

5. Coalitional Game Theory Viewpoint
coalitional game modeled pair G = hN, i, N = {1, ..., n} finite
set agents, function associating coalition R N real-value
(R) R, ({}) = 0, meant encode worth agents C obtain
collaborating other. function supermodular (resp., submodular )
(R ) + (R ) (R) + (T ) (resp., (R ) + (R ) (R) + (T )) holds,
pair coalitions R, N .
427

fiGreco & Scarcello

fundamental problem coalitional games single desirable outcomes, usually called solution concepts, terms appropriate notions
worth distribuP
n
tions, i.e., vectors payoffs x = (x1 , ..., xn ) R xi = (N ).
question studied economics game theory aim providing arguments
counterarguments proposals reasonable mathematical renderings
intuitive concepts fairness stability. background coalitional
games, reader referred to, e.g., work Osborne Rubinstein (1994).
Here, consider Shapley value G = hN, i, well-known solution
concept that:
X (|N | |R|)!(|R| 1)!
(G) =
((R) (R \ {i})), N.
|N |!
RN

Indeed, shall show mechanism defined Section 4 nice interpretation
terms Shapley value suitable-defined coalitional games. correspondence
exploited prove properties mechanism, equilibrium
agents truthfully report types.
5.1 Shapley Value Allocation Games
consider two coalitional games defined top allocation problem.
marg
best
Definition 5.1. Given valuation vector w, define Gw
= hA, margw Gw
=
hA, bestw coalitional games such, set C agents,

margw (C) = opt(hA, G, i, wt ) opt(hA \ C, G, i, wt ); and,
bestw (C) = opt(hC, G, i, wt ).

2

Recall Section 3.1 defined concept marginal contribution
marg,w (C) coalition C respect given allocation (because sensible
set goods allocated ). definition, slight abuse notation,
defined similar concept margw (C), depend goods allocation.
turns two concepts actually coincide optimal allocations.
Theorem 5.2. Let optimal allocation St w.r.t. wt , let C
arbitrary set agents. Then, marg,w (C) = margw (C).
Proof. Let optimal allocation St = hA, G, w.r.t. wt , hence optimal
hA, img(), w.r.t. wt . is, opt(St , wt ) = opt(hA, img(), i, wt ). Moreover, set C agents, Corollary 4.5, opt(hA \ C, img(), i, wt ) =
opt(hA\C, G, i, wt ) holds. Therefore, margw (C) = opt(St , wt )opt(hA\C, G, i, wt ) =
opt(hA, img(), i, wt ) opt(hA \ C, img(), i, wt ), result follows value
equivalent definition marg,w (C) Equation 1 (on page 416).
Note bestw (C) best contribution C, computed assuming agents
best
already
C agents allocation problem. particular, game Gw
considered Moulin (1992), precisely setting fair division allocation
best
submodular.
problems. There, shown cost function associated Gw
428

fiMechanisms Fair Allocation Problems

Proposition 5.3. function bestw submodular.
marg
Since opt(hC, G, i, wt ) = bestw (C), turns Gw
called
best
literature dual game Gw , following result known hold. Nevertheless,
give direct proof, completeness.

Corollary 5.4. function margw supermodular.
Proof. Let St = hA, G, given scenario. result follows noticing
margw (C) = opt(hA, G, i, wt ) opt(hA \ C, G, i, wt ) = opt(hA, G, i, wt ) bestw (A \
C), set agents C A. Therefore, bestw (C) = opt(hA, G, i, wt )margw (A\C).
Thus, bestw (R ) + bestw (R ) bestw (R) + bestw (T ) holds R, A,
margw (A \ (R )) + margw (A \ (R )) margw (A \ R) + margw (A \ )
holds well, R, A. Eventually, letting R0 = \ R 0 = \ , get
margw (R0 0 ) + margw (R0 0 )) margw (R0 ) + margw (T 0 ), R0 , 0 A.
is, margw supermodular.
second relevant property payment rule Section 4 coincides
best
Shapley value game Gw
associated w. result follows comparing utility function Theorem 4.10 expression Shapley value coalitional
best
game Gw
. Moreover, show result established dual game
marg
Gt , Shapley values two games identicalfor similar correspondences
Shapley values different games, see works Maniquet (2003) Kalai
Samet (1983).
Theorem 5.5. optimal allocation St w.r.t. wt , agent A,
marg
best
).
) = (Gw
holds ui (, wt ) = (, wt ) = (Gw
Proof. comparing utility function Theorem 4.10 expression
best
associating coalition C agents
Shapley value coalitional game Gw
worth opt(hC, G, i, wt ), immediately get that, optimal allocation St
best
).
w.r.t. wt , agent A, holds ui (, wt ) = (, wt ) = (Gw
marg
best
order conclude proof, show agent A, (Gw ) = (Gw
)
holds. end, first note Shapley values written follows:
P
marg
(Gw
) = CA,iC (|A||C|)!(|C|1)!
TC0 ,
|A|!
best
(Gw
)=

P

CA,iC

(|A||C|)!(|C|1)!
TC ,
|A|!

TC0 = margw (C)margw (C\{i}) TC = opt(hC, G, i, wt )opt(hC\{i}, G, i, wt ).
Then, claim that:
(1) set C agents C, set C = (A \ C) {i} TC0 = TC,

set C = (A \ C)
{i} 0 = .
(2) set C agents C,
C
C

429

fiGreco & Scarcello

(1) Let C C, observe TC0 = margw (C) margw (C \ {i}) =
(opt(St , wt ) opt(hA \ C, G, i, wt )) (opt(St , wt ) opt(hA \ (C \ {i}), G, i, wt )) =
opt(hA \ (C \ {i}), G, i, wt ) opt(hA \ C, G, i, wt ) = opt(h(A \ C) {i}), G, i, wt )
opt(hA \ C, G, i, wt ). Thus, let C = (A \ C) {i}, note TC0 = TC.
G, i, wt )
observe = opt(hC,
(2) Let C C,
C


opt(hC \ {i}, G, i, wt ) = (opt(St , wt ) opt(hC \ {i}, G, i, wt )) (opt(St , wt )
G, i, wt )) = marg ((A \ C)
{i}) marg (A \ C).
Thus, let C = (A \ C)
{i}
opt(hC,
w
w
0
note TC = TC.
marg
best
(1) (2) hold, given two expressions (Gw
) (Gw
), conclude
two values coincide.

5.2 Marginality, Budget-Balancedness, Individual Optimality
established precise correspondence mechanism
Shapley value associated allocation games, show desirable properties p . fact, exploit following well-known properties (see, e.g., Osborne &
Rubinstein, 1994; Young, 1985) Shapley value game G = hN, i:
(I)

P



(G) = (N );

(II) P
supermodular (resp., submodular ),
iR (G) (R)), coalition R N .

P

iR (G)

(R) (resp.,

(III) G 0 = hN, 0 game 0 (R) (R), R N , (G 0 ) (G),
agent N .
particular, Property
(II) entails Shapley value supermodular game
P
marg
) margw (R). means Shapley value
Gw iR (Gw
game belongs another important solution concept coalitional games called core (Osborne & Rubinstein, 1994), highly desirable stability, every coalition
marg
gets least worth deserves according function margw .
agents Gw
context, easily entail utility every group (coalition) agents
C (i.e., sum utilities agents C), less actual marginal contribution best possible allocations. Note considering collective utility
particularly useful whenever reason terms fairness groups agents, rather
singletons. first pinpoint bestw (C) margw (C) provide upper bound
lower bound, respectively, utility C.
marg

Theorem 5.6. Let
Pan optimal allocation St w.r.t. wt . Then, set C
agents, bestw (C) iC ui (, wt ) margw (C).

marg
best
), agent
) = (Gw
Proof. Theorem 5.5, know ui (, wt ) = (Gw
optimal allocation . Then, simply recall function margw (resp.,
marg
best
bestw ) associated game Gw
(resp., Gw
) supermodular (resp.,
P submodular)

Corollary
5.4
(resp.,
Proposition
5.3).
Hence,

result
follows

iC ui (, wt ) =
P
P
marg
best

(G
)


property
(II).

(G
)
=
iC w
iC w

430

fiMechanisms Fair Allocation Problems

combining result Theorem 5.2, immediately get following.
Corollary 5.7 (marginality).
P Let optimal allocation algorithm. Then, mechanism (A, p ) iC ui (A(wt ), wt ) margA(wt ),w (C), set C A.
Hence, payment rule p optimal allocation algorithms, get mechanisms
accurately take care marginality property defined Section 3.1. next result
pertains budget-balance property mechanisms. Again, correspondence
Shapley value crucial establish result.
Theorem
5.8. Let optimal allocation St w.r.t. wt .
P

p
(,
w
) = 0.
iA

Then, holds

best
), agent optiProof. Theorem 5.5, know ui (, wt ) = (Gw
best
best
mal allocation ,

(G
)


Shapley
value

G
w . property (I)
Pof Shapley
P
P w best
best
)=
value, know iA (Gw ) = bestw (A). Thus, iA ui (, wt ) = iA (Gw
opt(hA, G, i, wt ). definition utility letting wt = (w1 , ..., wn ), folP
P
P


lows opt(hA, G, i, wt ) =
iA pi (, w). Hence,
iA wi ()
iA pi (, wt ) =
opt(hA, G, i, wt ) val(, wt ) = 0, indeed optimal allocation w.r.t. wt .

Corollary 5.9 (budget-balancedness). Let optimal allocation algorithm. Then,
mechanism (A, p ) budget-balanced.
Finally, complete picture analysis proving strong fairness property
proposed payment rule p : words, best outcome every agent always
determined (global) optimal allocation. Moreover, Corollary 4.11, agent
indifferent specific optimal allocation considered. is, chosen
optimal allocation leads best results agents.
Lemma 5.10. Let 0 two feasible allocations St optimal w.r.t. wt ,
hence val(, wt ) val( 0 , wt ). Then, ui (, wt ) ui ( 0 , wt ), A. Moreover, 0 optimal, exists agent ui (, wt ) > ui ( 0 , wt ).
Proof. allocation , consider coalitional game G = hA, v v (C) =
opt(hC, img(), i, wt ), C A. looking expression Shapley value
G , easy check ui (, wt ) = (G ) (just use reasoning proof
Theorem 4.10). Assume 0 allocation val(, wt ) val( 0 , wt ),
0
consider value v (C) = opt(hC, img( 0 ), i, wt ), C A. Corollary 4.6,
0
v (C) v (C), C A. Then, derive ui (, wt ) = (G )
0
(G ) = ui ( 0 , w) every A, property (III).
assume 0 optimal, thus val(, wt ) > val( 0 , wt ). Therefore,
0
grand-coalition A, v (A) > v (A). property (I) Shapley
0
value, (and all) total value v (A) distributed agents. follows
0
exists agent ui (, wt ) = (G ) > (G ) = ui ( 0 , wt ).
focusing optimal allocation algorithms, lemma immediately entails
following two fairness properties.

431

fiGreco & Scarcello

Theorem 5.11 (individual optimality). Let optimal allocation algorithm.
Then, agent feasible allocation St , ui (A(wt ), wt ) ui (, wt ).
Corollary 5.12 (Pareto-efficiency envy-freeness). Let optimal allocation
algorithm. Then, mechanism (A, p ) Pareto efficient envy-free.
Note individual optimality guarantees much classical Pareto efficiency
envy-freeness, entails mechanism leads unique evaluation,
independently chosen optimal allocation. particular, Pareto set singleton.

6. Complexity Issues
section, shall reconsider mechanism verification computational
perspective. Note first computing optimal allocation basis reported
types easy task, carried via adaptations classical matching algorithms. Indeed, light Fact 4.2, computing optimal allocation arbitrary
scenario (with agents goods G) reduces computing optimal allocation
scenario agent (in A1 ) gets one good. equivalent finding matching
maximum weight complete bipartite graph set disjoint nodes A1
G, edge weights encoded via function w1 . combinatorial problem
known feasible polynomial time (e.g., Schrijver, 2003).
6.1 Hardness Result
Despite fact optimal allocations computed polynomial time, mechanism computationally-efficient, since payments unlikely computable
polynomial time. Indeed, next show computation problem complete
complexity class #P (see Papadimitriou, 1993).
Let us recall counting Turing machine standard nondeterministic Turing
machine auxiliary output device prints binary notation number
accepting computations induced input. (worst-case) time complexity f (n)
longest accepting computation induced set inputs size n takes f (n) steps.
Then, #P class functions computed counting Turing machines
polynomial time complexity. prototypical #P-complete problem count number
truth variable assignments satisfy Boolean formula. course, NP#P,
polynomial-time algorithm solving #P-complete problem would imply P = NP.
Theorem 6.1. Computing Shapley value coalitional games associated allocation
problems (as Definition 5.1) #P-complete.
Proof. problem belongs #P, computing Shapley value known feasible #P class coalitional games polynomial-time value/cost functions (c.f.
Deng & Papadimitriou, 1994). show #P-hard, exhibit reduction
following problem: Let G = (A B, E) bipartite graph |A| = |B| = n, E B,
|E| = n. Recall matching set E 0 E edges pair
distinct edges (a, b) (a0 , b0 ) E 0 , 6= a0 b 6= b0 hold. matching E 0 perfect
|E 0 | = n. problem counting number perfect matchings bipartite
graphs #P-complete (Valiant, 1979a).
432

fiMechanisms Fair Allocation Problems

Given graph G = (A B, E) constant k 1 (which shall fix below),
build polynomial-time tuple S(G) = hA, G, vector wt that:

(1) = {} (a,b)E {(a, b)1 , ..., (a, b)k }, i.e., agents one-to-one associated k
distinct clones edge (a, b) E, plus distinguished agent . Note |A| > n,
considered bipartite graphs n holds.
(2) G = {g } B, i.e., goods correspond nodes, plus distinguished good g .
(3) = 1 (a,b)i = 2, (a, b) {1, ..., k}, components
associated agents (a, b)i , respectively.
(4) agent c A, associated component wc vector wt defined
follows. (a, b)i A, w(a,b)i (a) = 2, w(a,b)i (b) = 2, w(a,b)i (g ) = 1, w(a,b)i (x) = 0,
x (A B) \ {a, b}. Moreover, w (g ) = 1, w (x0 ) = 0, x0 (A B).
Let us fix notations. set E 0 E edges, let match(E 0 ) denote
size largest set E 00 E 0 edges matching. set C \ {}
agents, let A(C) = {a | (a, b)i C} B(C) = {b | (a, b)i C}. Finally, say
C \ {} tight contain two agents form (a, b)i (a, b)j ,
6= j, i.e., associated edge G.
Observe that, set C \ {} agents,
opt(hC {}, G, i, wt ) opt(hC, G, i, wt ) =



1
0

C tight, |C| = A(C) = B(C)
otherwise

(5)

Indeed, C0 optimal allocation hC {}, G, w.r.t. wt , always
val(C0 , t) = 2 |A(C)| + 2 |B(C)| + 1. Instead, C optimal allocation hC, G,
w.r.t. wt ,

2 |A(C)| + 2 |B(C)|
C tight, |C| = A(C) = B(C)
val(C ) =
2 |A(C)| + 2 |B(C)| + 1 otherwise
best

exploiting Equation 5, express Shapley value game GS(G),t
agent convenient way. Let Xh denote number sets C \ {} agents
tight |C| = |A(C)| = |B(C)| = h, let X0 = 1. Then,

|A|1
best
(Gw
)=

X (|A| h 1)!(h)!
Xh .
|A|!

(6)

h=0

particular, let us focus coefficient Xh . Denote Yh number matchings
G whose cardinality h. construction S(G) immediate check
matching cardinality h G, precisely k h sets agents C \ {}
tight |C| = |A(C)| = |B(C)| = h. Thus, rewrite expression:
|A|1
best
(Gw
)=

X

(Zh Yh ) k h , Zh =

h=0

433

(|A|h1)!(h)!
.
|A|!

(7)

fiGreco & Scarcello

best
expression one above, given value (Gw
), known
certain circumstances reconstruct polynomial time value single term
form Zh Yh (see Fact 6 work Valiant (1979b)): need integer constant
> 2 that, h {0, ..., |A| 1}, Zh Yh A, k A2 . case,
noticed that, h {0, ..., |A|1}, Zh Yh 1 holds, Yh |A|!/((h)!(|A| h)!).
best
), compute polynomial
Thus, k = 9, that, given value (Gw
time terms. particular, compute polynomial time term associated
h = |A| = |B| = n, recall |A| > n. term form Zn Yn , Yn
number perfect matchings G. Thus, putting together since Zn
computed polynomial time (as size numbers n |A| logarithmic
w.r.t. size G), number perfect matchings bipartite graphs counted
polynomial time too, concludes proof.

Lemma 4.8 Theorem 5.5, following immediate.
Corollary 6.2. Computing payments given rule p #P-complete.
6.2 Fully Polynomial-Time Randomized Approximation Scheme
approach circumvent intractability Shapley value based approximation:
game G = hN, i, vector -approximation Shapley value |i (G)|
(G) holds, N .
Recently, sampling method conceived Bachrach, Markakis, Resnick, Procaccia,
Rosenschein, Saberi (2010) special class simple coalitional games
extended deal arbitrary games supermodular monotone 6 (Liben-Nowell,
Sharp, Wexler, & Woods, 2012), assumption value (R) computed
oracle unitary cost, R N . result that, > 0
> 0, possible compute time poly(N, 1/, log(1/)) vector approximation Shapley value probability failure . method
properties called fully polynomial-time randomized approximation scheme.
Next, propose payment rule p founded sampling strategy described
work Liben-Nowell et al. (2012). payment rule, reported Figure 5, samples
subsets storing C (together subsets functionally determined
samples), computes value (, w ) Figure 4, C playing
role power-set C. process repeated (log(1/)) times, componentwise median vector payments computed. resulting payment eventually
defined step 9.
new rule p gives rise randomized mechanism course still verifiable
uses punishment. Moreover, mechanism truthful even realization
set C, sampled step 1, known beforehand.7 Formally, mechanism turns
universally truthful, i.e., probability distribution deterministic truthful
mechanisms (see, e.g., Dobzinski & Dughmi, 2009).
6. Monotonicity G = hN, means (R) (T ), R N .
7. evidences truthfulness desideratum, need implement payment
rule computing Shapley value coalitional game associated allocation problem (as
Definition 5.1), fact concept defined possible subsets shown
computationally hard Theorem 6.1.

434

fiMechanisms Fair Allocation Problems

Input:
type vector , feasible allocation , integer > 0;
Assumption: verifier v (for t) available, v() = (v1 , ..., vn );
Notation:
= hA, G, i, w = (w1 , ..., wn ), wv() = (wv1 , ..., wvn );
1.
2.
3.
4.
5.
6.
7.
8.
9.

Generate set C subsets A,
let C := C {(A \ C) {i} | C C, C} {A};
C C,
| Compute optimal allocation C,i hC, img(), (vi ,i ) w.r.t. w(vi ,i ) ;
b Compute optimal allocation C\{i},i hC \ {i}, img(), (vi ,i ) w.r.t. w(vi ,i ) ;
agent A,
b Compute (, w ) Figure 4 (steps 48), C := C;
Repeat (log(1/)) times steps 1, 2, 5,
w ) component-wise median vector vectors (, w );
Let (,
Define pi (, w ) := (, w ) wvi ();
Figure 5: Payment rule p .

Theorem 6.3. Let optimal allocation algorithm. Then, mechanism (A, p )
universally truthful.
Proof. result follows inspecting proof Theorem 4.9 rule p Section 4.
Indeed, immediately checked proof depend specific
subset coalitions C, thus smoothly applies set coalitions C used
Figure 5, instead possible subsets A. Note particular that, proof
Theorem 4.9, properties (A) (B) precisely guaranteeing truthfulness,
properties hold given coalition C. Therefore, still hold subset
coalitions randomly chosen mechanism.
Similarly, inspecting proofs Section 4, universally truthful mechanism,
following properties seen hold every realization random coin tosses.
Theorem 6.4 (basic properties). Let optimal allocation algorithm. Then,
mechanism (A, p ) efficient guarantees equal treatment equals. Moreover,
valuations non-negative, (A, p ) individually rational.
deeper analysis payment rule p , next point relationship
utility values approximations Shapley value, equilibrium agents
report true types.
Lemma 6.5. Let = {1, ..., |A|}, let = (|A|2 /2 ). optimal allocation
St w.r.t. wt , vector (u1,p (, wt ), ..., u|A|,p (, wt )) -approximation
marg
best
Shapley value Gw
(and Gw
) probability 1 , coincides expectation.
Proof. exploiting line reasoning proofs Section 4 p ,
see (, wt ) (at step 6 algorithm Figure 5) rewritten follows:
(, wt ) =

X (|A| |C|)!(|C| 1)!
(bestw (C) bestw (C \ {i})) .
|A|!

CC

435

fiGreco & Scarcello

Then, observe construction C step 1, set C C agent
A, set (A \ C) {i} C, too. Thus, apply line reasoning
proof Theorem 5.5, order conclude that:
(, wt ) =

X (|A| |C|)!(|C| 1)!
(margw (C) margw (C \ {i})) .
|A|!

CC

marg
= hA, margw supermodular Corollary 5.4. MoreNow, recall game Gw
marg
over, Gw clearly monotone. Thus, Liben-Nowell et al. (2012), expression
marg
, approximates value
coincides expectation Shapley value Gw
constant probability. Steps 7 8 serve amplify probability (c.f. Liben-Nowell
et al., 2012), get fully polynomial-time randomized approximation scheme.
result follows step 9 implements usual bonus compensation approach,
ui,p (, wt ) coincides expression, (cf. Lemma 4.8).

Note approach Liben-Nowell
P et al. (2012), final normalization step
carried would guarantee
iA u1,p (, wt ) = margw (A) = bestw (A).
Unfortunately, way truthfulness might lost, hence include normalization procedure payment rule. consequence, mechanism p
guarantee (for instance) budget-balancedness Pareto-efficiency. However,
Lemma 6.5, since expected utility profile coincides Shapley value, p enjoys
expectation properties p including two ones. particular,
still approximate counterparts Theorem 5.6 Theorem 5.8.
Theorem 6.6. Let optimal allocation St w.r.t. wt . Let = (|A|2 /2 ). Then,
probability 1 ,
P
(1 + ) bestw (C) iC ui,p (, wt ) (1 ) margw (C), C A;
val(, wt )

P


iA pi (, wt )

val(, wt ).

Proof. Here, observe
Lemma 6.5 TheoremP5.5, set
Pthat, light P
C A, (1) iC ui,p (, wt ) iC ui,p (, wt ) (1+) iC ui,p (, wt ).
result follows substituting bounds Theorem 5.6 Theorem 5.8,
respectively, simple algebraic manipulations.
Finally, propose randomized mechanism able guarantee economic efficiency budget-balancedness. price paid however truthfulness
holds expectation only. mechanism based payment rule call p .
Theorem 6.7. Let optimal allocation algorithm. Then, (randomized)
mechanism verification (A, p ) truthful expectation, (at truthful
equilibrium) efficient budget-balanced. Moreover, valuations non-negative,
(A, p ) individually rational.
Proof. payment rule p follows steps Figure 5, minor modifications
step 8 step 9: First, step 8, whenever compute median value (, w )
agent i, compute corresponding value (, wv() ) (evaluated revealed
436

fiMechanisms Fair Allocation Problems

types rather reported ones). Then, define normalization factor R =
P
opt(hA, img(), v() i, wv() )/( iA (, wv() )), that, step 9, pi (, w ) eventually
returned wvi () (, w ) R.
Concerning truthfulness, note expected value R 1. Indeed,
Lemma 6.5, expected value (, wv() ) (, wv() ); hence, sum
values coincides opt(hA, img(), v() i, wv() ) efficiency Shapley value
(as proof Theorem 5.8). Thus, expected utility agent payment
rule p coincides (actual, i.e., expectation) utility rule p .
Hence, truthfulness expectation follows Theorem 6.3. Now, check that,
truthful equilibrium, maximum social welfare achieved (equilibrium efficiency)
P
P
iA pi (, wt ) = opt(hA, img(), i, wv() ) iA (, wt ) R = 0. is,
mechanism budget-balanced, too. Finally, mechanism p seen individuallyrational, exploiting line reasoning one used mechanism based
p , since corresponding proof Section 4 affected sampling strategy.
Again, Lemma 6.5, remaining properties hold expectation.

7. Related approaches Mechanisms Verification
next review main approaches literature mechanisms verification,
point differences w.r.t. proposal.
First observe that, differently general setting types agents
determine vector upper bounds allocation problem, earlier approaches assumed agent types impact underlying combinatorial problem, type vector precisely coincides valuation vector. Instead,
deal explicitly allocation constraints goods valuations. instance,
scheduling problem formalized setting, private type agent/machine
speed, valuation function fully determined speed size
job processed. Then, verifier asked measure speed
agents/machinessee Appendix A. fact, immediate encode valuations
types well, price however hiding true complexity (or simplicity)
setting. instance, example, type agent vector
valuations, would miss information agent ultimately characterized
one (observable) parameter only.
substantial differences earlier approaches proposal come
definition utility agent. works Auletta et al. (2009), Penna
Ventre (2012a, 2012b), Krysta Ventre (2010), Auletta et al. (2006) Ferrante
et al. (2009), individual welfare agent i, given outcome vector
reported types, assumed following form:

0
caught lying
ui,p (, d) = ti ()
pi (, d) otherwise
pi (, ) payment depend vector true types.
papers, information assumed available payment time
whether reported type di agent differs actual true type ti .

437

fiGreco & Scarcello

role played verifier, fact pi (, d) exploit possibility partially
revealing ti . Moreover, payment scheme adopted punishes agents caught
lying. Hence, verification process provides smaller amount information
verification process approach, rules used discourage strategic behaviors
stronger based punishing agents. Also, works assume
agents misreporting restricted certain kinds lies (e.g., values lower
corresponding true ones), form one-sided verification suffices.
Recently, model (partial) verification extended Caragiannis
et al. (2012) setting agent cheating her/his type identified
probability may depend her/his true type, reported type, both. fact,
Caragiannis et al. showed cases verification help
one-sided. payment scheme exactly one discussed
and, hence, verification exploit (possibly partial) knowledge actual
true type punishment approach still used. main novelty, addition
probabilistic verification, constraint type agent report
cheating.
Finally, different kind verification model goes back seminal paper Nisan
Ronen (2001), actually closer no-punishment perspective,
agent principle paid mechanism even caught lying. Given
n agents, Nisan Ronen consider vector e = (e1 , ..., en ) observed agent types,
completely known verification process. Moreover, individual utility
agent form ui,p (, d) = ei () pi (, d), vector e
framework plays role verifiers output approach. first difference
work Nisan Ronen approach that, model, agents
misreporting restricted certain kinds lies. hand, consider
restriction form valuation functions, since verification model assumes
valuations determined objective observable properties goods agents
(encoded functions form g , defined Section 2). consequence,
payment time, valuation agent known every good img(). Instead,
setting Nisan Ronen, valuation agent goods img() \ (i)
remains unknown even verification performed. results presented
paper, turns difference two framework crucial overcome
classical impossibility results, meet desirable properties (without using
punishing power).

8. Conclusion
paper, proposed analyzed mechanisms fair allocation problems
setting agents declarations regard objective properties goods agents, thus
(partially) verified payments made. particular, considered
model verification able disclose true values allocated goods, contrast
previous approaches literature partial probabilistic verification
considered. However, use verification power fact quite limited,
payment rules designed punishment meted agents whose
declarations match output verification process. requirement crucial
438

fiMechanisms Fair Allocation Problems

practical applications framework, Italian research evaluation described
(Greco & Scarcello, 2013) (and summarized Appendix), discrepancy
declared verified values may due sensing errors subjective issues
cannot interpreted agents lies punished.
challenge show that, framework, truthfulness, efficiency, budgetbalancedness, fairness (as well desirable properties discussed Section 2)
achieved simultaneously, unlike classical setting. worthwhile noting that,
one guaranteed agents truthfully report true types (no strategic behaviors)
or, equivalently, types given public knowledge, problem quite easy.
instance, one use payments way agent gets her/his utility
Shapley value according either coalitional game defined Section 5. Moreover,
fairness issue, properties obtained even using simple
uniform payment rule. However, whenever agents may behave strategically, reporting
true type longer dominant strategy, approaches used. fact, truthfulness
might enforced equipping mechanism suitable punishment rules. However,
already argued would appropriate context, typically
resulting mechanism would error tolerant.
looking proposed framework abstract perspective, one may notice
based two fundamental ingredients: base combinatorial problem determines
feasible optimal allocations, game-theoretic notion describes considered fair, respect agents contributions expectations. Namely, application
domain allocation problems addressed paper, weighted matching basic
combinatorial problem Shapley value natural game-theoretic solution
concept. perspective, natural research direction study different instances
abstract framework mechanisms verification, combinatorial
problems (colorings, coverings, etc.) different solution concepts (Nucleolus, Banzhaf
index, etc.) may appropriate best describe problem hands.
Another interesting avenue research would study modification
framework agents preferences directly expressed terms real-valued
functions, rather formalized terms orderings/ranks available goods.
particularly interesting given that, strategic setting defined, agents
declarations contribute definition goods selected,
determine values.

Acknowledgments
thank anonymous referees Associate Editor useful comments.

Appendix A. Application Scenarios
Fair allocation monetary compensation intensively studied literature,
often settings parameters interest public knowledge (or, simply,
getting rid strategic issues). One example application discussed literature
parking space benefit allocation workplace, employee gets parking
space share fixed benefits package. House allocation problems another

439

fiGreco & Scarcello

classical example, agents collectively set houses, look systematic
way exclusively assigning house agent, possibly monetary compensations.
third example room assignment-rent division, group agents rent house,
getting room paying share rent.
following, illustrate applications fair allocation problems fit
general framework discussed Section 2. applications shall discuss, part
relevant information private knowledge agents, verification adopted
measure observable properties payment phase. Nonetheless, stress
that, even relevant information available public knowledge could
measured advance, applications would still remain interest, show
need defining allocation policies guarantee fair and/or error tolerant solutions.
A.1 Italian Research Assessment Program (VQR) 20042010
start overview possible application scenarios focusing real-world case
study first motivated investigation allocation problems. application
best described companion paper (Greco & Scarcello, 2013), applies results
presented specific case Italian research assessment program.
A.1.1 Setting
2012, National Agency Evaluation Universities Research Institutes
(ANVUR) promoted VQR assessment program devoted evaluate quality
whole Italian research production. first application, program focuses
period 2004-2010, evaluation repeated regular basis (the next one
cover years 20112014).
first phase program, every structure R (a university research institute)
selects submits ANVUR set P products, constraints (i)
product univocally associated author (even product co-authored)
(ii) three products associated author affiliated R.8
abstract terms, R computes phase allocation , img() = P ,
scenario R set agents/researchers affiliated R, P set
goods/products co-authored, r R, r = 3
associated constraint number goods/products allocated r. way
allocation performed described below.
second phase, ANVUR evaluates products P equipping
quality score, expressed number.9 Hence, phase defines official valuation
that, product p (r), w(p) quality score assigned ANVUR p.
overall score R sum values products P ,
used proportionally transfer R funds allocated Ministry support research
activities next years, data new evaluation subsequent period
available.
8. simplify here. Actually, number publications may less three, authors.
9. set possible scores defined VQR guidelines. ends, detail immaterial
scores viewed (arbitrary) real numbers.

440

fiMechanisms Fair Allocation Problems

A.1.2 Need Fair Division
VQR program actually assigns score structure R,
substructures (e.g., departments, R university). course, expected
impact funds redistribution inside every research structure, therefore
crucial problem define fair rule funds redistribution, is, rule capable
assign funds clearly reflecting true contribution researcher/substructure
performances structure whole. Moreover, recruitment policies
universities going evaluated well, looking (VQR) performances
researchers hired recently. However, redistribution rule specified
program, researchers believe evaluation
P (the contribution of)
r R coincide overall value wr () =
p(r) w(p) products
allocated r submission phase. course fair general,
product p P co-authored two researchers R, (and, turn,
structures) might claim contribution even product formally allocated
one them.10 Therefore, sophisticated approaches defined
proper evaluation individuals substructures.
A.1.3 Strategic Issues Verification VQR Program
Recall goal structure R submit ANVUR (in first phase program) products likely get highest possible scores (in second phase).
end, publicly available evaluation criteria allow one perform ranking products, ideally equipping quality score
assigned ANVUR subsequent phase. time economic
reasons, first evaluation phase based self-evaluations performed
authors products, clearly assumed best experts research
subjects. Moreover, structures, decide precise allocation products, hence
deal conflicts related co-authored products, researchers performed choices
decentralized way; structures set optimization framework compute
optimal allocation, based agents declarations. case, abstracting
specific method adopted end feasible allocation submitted VQR,
strategic issues emerged phase. particular, researchers r R
guided allocation products (e.g., cheating quality) supposed
personal interest maximizing value wr (). Clearly enough, way optimal product
selections hardly achieved structure.
Note VQR case perfectly fits framework allocation problems: research products indivisible goods allocated researchers/agents, initially
declare goods valuations. Moreover, social welfare total ANVUR score
research structure, distributed budget-balanced way researchers,
hence substructures, fair way. Note upper bound constraint
researcher (3 products, exceptions) depend type case,
10. problem occur products co-authored researchers belonging different structures.
Indeed, product submitted several structures (assigned different co-author
them). Thus, given research structure R, co-authors interest affiliated
R.

441

fiGreco & Scarcello

parameter fixed ANVUR. Therefore, private information agents
limited good valuations. Moreover, observe specific valuation functions occurring VQR fit verification model proposed paper. particular, every
research product objective value, measured verifier
allocated hence submitted product (while nothing said products
allocated researcher). Thus, ANVUR precisely acts verifier model.
A.1.4 Mechanisms VQR Program
basic approach assigning researcher r R value wr () precisely
(trivial no-payment) rule p Example 2.6. There, observed mechanisms
based rule truthful general. Moreover, Example 3.1 emerged
rule fair (in particular) combined optimal allocation algorithm
(in order guarantee efficiency). Therefore, rule highly undesirable, different
kinds mechanisms defined VQR setting.
fact, would end mechanism able able collect
correct self-evaluations (truthfulness) obtain maximum possible performance
(efficiency) research structures. two goals, however, accomplished
together fairness. Indeed, would guarantee every researcher group
researchers get least marginal contributions, resulting mechanism
individually optimal. latter property important application, since
guarantees that, researcher, her/his score maximum one possible
alternative allocations, including allocations using products submitted
structure hence verified. Moreover, relevant properties
guaranteed via mechanisms enjoying verifiability property, payment rule
uses certified valuations (it would unacceptable use product values
verified ANVUR).
Finally, worthwhile noting ANVUR guidelines defines range possible product values determined, e.g., publishing venues citation indices, pointing
peer-reviews used override basic classification (e.g., papers published good journal without many citations, explicit authors
request). Clearly enough, entails discrepancies authors declarations
ANVUR evaluations might well emerge even absence malicious behavior. Hence,
no-punishment (and error-tolerant) approach seems unavoidable concrete
politically acceptable application mechanism.
A.2 (Cooperative) Scheduling Task Allocation
Assume h jobs set J = {1 , ..., h } executed within deadline d,
n agents/machines, m1 , ..., mn , n h, available execute parallel
jobs. machine mi , {1..., n}, let J denote set jobs mi
principle execute. sets determined, instance, physical, technological,
accessibility constraints known scheduler, precise speed
machines guarantee process known scheduler, declared
agents. assumed machine mi always work speed independently
workload actually assigned (for considered jobs hand). sake
442

fiMechanisms Fair Allocation Problems

simplicity, assume job consists workload wl ,
executed job, fixed profit pr earned. Moreover, profit pr add earned
scheduler jobs correctly executed, (part it) distributed
agents. Every machine participating process execute least one job (i.e.,
assuming many jobs executed machine machines
comparable speeds convenient use them). Furthermore, every machine
dedicated process aims executing many jobs J possible,
cannot earn profit external jobs (not J ).
Therefore, allocation problem goods/jobs set {1 , ..., h }
allocated/scheduled agents/machines set {m1 , ..., mn }. Here,
private type agent mi speed si (devoted process), {1, ..., n}.
Moreover, vector upper bounds number goods allocated

agents defined (si ) = b ds
wl c, {1, ..., n}. Note, particular,
jobs completed within deadline, upper bound constraints
allocation scenario functions types/speeds agents/machines. Finally,
define valuation vector w = (w1 , ..., wh ) that, {1, ..., n}, wi (x ) = pr ,
x ; wi (x ) = 1, x 6 . Note case valuations independent
types agents (of course, assuming single job executed
within deadline d).
Given task carried different agents, sensible
allocations perceived fair ones (see, e.g., Porter et al., 2004). end,
mechanism monetary compensations described paper adopted. fact,
note strategic issues come play, egoistic behavior agents may lead
allocations optimal possibly miss extra-reward pr add . Observe
scheduler may act verifier model, end process. Indeed,
allocation computed jobs executed based it, immediately
verify truthfulness agents declarations looking amount time used
machine execute jobs assigned it.
Furthermore, practice, speed values given finite precision, well
physical verification subject measurement errors. reason, even mechanism
tolerant errors, based punishments.
example, consider following task allocation problem,
viewed variation previous one: Assume company select agents
e1 , ..., en perform given set tasks {t1 , ..., tm } within certain deadline, assume
company know precisely whether agents necessary
skills (experience, strength, speed, competence, etc.). instance, may happen
company starting new line production new tasks, tasks
executed means crowdsourcing, agents selected internet call.
Therefore, case agents types declarations comprise skills
number tasks able execute within required deadline. Valuation functions
encode profit earned agent executing given task (where value 0
means agent able execute task). Note upper
bound constraints allocation scenario valuations functions depend agents
types. Again, mechanism monetary compensations used, order provide
fair distribution company reward tasks, encourage agents truthfully
443

fiGreco & Scarcello

declare skills. Note framework verification proposed paper
used assumption agents skills necessary proposed set tasks
observed evaluated verifier, (at least) end process,
agents performed work (possibly failures).
A.3 Protocols Wireless Communication Networks
conclude overview possible applications considering cost problem where,
moreover, private information, hence strategic behavior. remark
proposal described paper used even mechanism design
necessary, one still needs policy fair division enjoys properties described
Section 3.1 (e.g., envy freeness, individual optimality, on). fact, fairness
issues currently attracting much attention design scheduling protocols
wireless communication networks, underlying problem bandwidth allocation;
instance, design protocols high-speed wide area wireless networks,
role monetary compensation played adjustments priorities users (see,
e.g., Jalali, Padovani, & Pankaj, 2000). Moreover, number network applications
emerging direct forms monetary compensation considered.
example, let us consider ad-hoc networks, self-organizing wireless infrastructures mobile nodes cooperatively act via multi-hop routing transmit data even
source destination nodes transmission ranges. Cooperation
achieved associating credit balance node, nodes use credits pay
sending traffic, earn credits forwarding traffic nodes compensate bandwidth power consumptionsee, instance, work Gobel, Krzesinski,
Mandjes (2009) references therein. Consider setting nodes s1 , ..., sn
willing transmit data ad-hoc network. given configuration
network, nodes r1 , ..., rm used forward data. particular, whenever
si rj , {1, ..., n} j {1, ..., m}, within transmission ranges,
denote ci,j credit paid si transfer data via rj large enough value ci,j
used state transmission possible. resulting cost problem
modeled via allocation scenario = 1, valuation vector
wi (rj ) = ci,j , {1, ..., n} j {1, ..., m}. Thus, maximizing social
welfare amounts minimizing overall credits paid source nodes.
easily seen that, even private information everything public,
fairness issues emerge context, too. Indeed, different sources may want use
routing node transfer data. instance, simple setting = 2
n = 2 r1 preferred routing node s1 s2 (i.e., c1,1 < c1,2
c2,1 < c2,2 ), node forced transfer data via r2 might perceive
given allocation unfair. suggests credits paid source nodes
adjusted via payment rules that, proposal, based Shapley value
coalitional games described Section 5.
setting similar one discussed emerges wireless cooperative file sharing
systems, mobile subscribers cluster together downloading (portions of) files
interest long-range cellular links, exchanging short-range radio communications wireless local area network. systems cooperative environments,

444

fiMechanisms Fair Allocation Problems

whose benefits appreciated terms increased throughput reduced
energy consumption, terms economic advantages users content
providers. order effective, however, fair allocation protocols designed,
whose goal encourage cooperation (see, e.g., Militano, Iera, & Scarcello, 2013).

References
Abdulkadiroglu, A., Sonmez, T., & Unver, M. U. (2004). Room assignment-rent division:
market approach. Social Choice Welfare, 22, 515538.
Agotnes, T., van der Hoek, W., Tennenholtz, M., & Wooldridge, M. (2009). Power
normative systems. Proc. AAMAS09, pp. 145152.
Alcalde, J., & Barbera, S. (1994). Top dominance possibility strategyproof stable
allocations matching problems. Economic Theory, 4, 417435.
Alkan, A., Demange, G., & Gale, D. (1991). Fair allocation indivisible goods criteria
justice. Econometrica, 59 (4), 102339.
Andersson, T. (2009). general strategy-proof fair allocation mechanism revisited. Economics Bulletin, 29 (3), 17171722.
Andersson, T., & Svensson, L.-G. (2008). Non-manipulable assignment individuals
positions revisited. Mathematical Social Sciences, 56 (3), 350354.
Andersson, T., Svensson, L.-G., & Ehlers, L. (2010). Budget-balance, fairness minimal
manipulability. Working papers 2010:16, Lund University, Department Economics.
Aragones, E. (1995). derivation money rawlsian solution. Social Choice
Welfare, 12, 267276.
Archer, A., & Tardos, E. (2007). Frugal path mechanisms. ACM Transactions Algorithms, 3, 122.
Auletta, V., De Prisco, R., Penna, P., & Persiano, G. (2009). power verification
one-parameter agents. Journal Computer System Sciences, 75, 190211.
Auletta, V., De Prisco, R., Penna, P., Persiano, G., & Ventre, C. (2006). New constructions
mechanisms verification. Proc. ICALP06, pp. 596607.
Auletta, V., Penna, P., Persiano, G., & Ventre, C. (2011). Alternatives truthfulness
hard recognize. Autonomous Agents Multi-Agent Systems, 22 (1), 200216.
Aumann, R. J., & Maschler, M. (1985). Game-theoretic analysis bankruptcy problem
talmud. Journal Economic Theory, 36 (2), 195213.
Bachrach, Y., Markakis, E., Resnick, E., Procaccia, A. D., Rosenschein, J. S., & Saberi, A.
(2010). Approximating power indices: theoretical empirical analysis. Autonomous
Agents Multi-Agent Systems, 20, 105122.
Bachrach, Y., & Rosenschein, J. S. (2008). Coalitional skill games. Proc. AAMAS08,
pp. 10231030.
Bachrach, Y., & Rosenschein, J. (2009). Power threshold network flow games. Autonomous Agents Multi-Agent Systems, 18 (1), 106132.

445

fiGreco & Scarcello

Bachrach, Y., Zuckerman, M., Wooldridge, M., & Rosenschein, J. (2013). Proof systems
transformation games. Annals Mathematics Artificial Intelligence, 67 (1),
130.
Bevia, C. (1998). Fair allocation general model indivisible goods. Review
Economic Design, 3, 195213.
Bouveret, S., & Lang, J. (2008). Efficiency envy-freeness fair division indivisible goods: Logical representation complexity. Journal Artificial Intelligence
Research, 32, 525564.
Brams, S. J., & Kilgour, D. M. (2001). Competitive fair division. Journal Political
Economy, 109 (2), 418443.
Brandt, F., Conitzer, V., & Endriss, U. (2012). Multiagent Systems, chap. Computational
Social Choices. MIT Press.
Caragiannis, I., Elkind, E., Szegedy, M., & Yu, L. (2012). Mechanism design: partial
probabilistic verification. Proc. EC12, pp. 266283.
Clarke, E. (1971). Multipart pricing public goods. Public Choice, 8, 1933.
Deng, X., & Papadimitriou, C. H. (1994). complexity cooperative solution concepts. Mathematics Operations Research, 19, 257266.
Dobzinski, S., & Dughmi, S. (2009). power randomization algorithmic mechanism design. Proc. FOCS09, pp. 505514.
Dunne, P. E. (2005). Extremal behaviour multiagent contract negotiation. Journal
Artificial Intelligence Research, 23, 4178.
Dunne, P. E., Wooldridge, M., & Laurence, M. (2005). complexity contract negotiation. Artificial Intelligence, 164 (1-2), 2346.
Endriss, U., Maudet, N., Sadri, F., & Toni, F. (2006). Negotiating socially optimal allocations resources. Journal Artificial Intelligence Research, 25, 315348.
Feige, U., & Tennenholtz, M. (2011). Mechanism design uncertain inputs: (to err
human, forgive divine). Proc. STOC11, pp. 549558.
Ferrante, A., Parlato, G., Sorrentino, F., & Ventre, C. (2009). Fast payment schemes
truthful mechanisms verification. Theoretical Computer Science, 410, 886899.
Gobel, J., Krzesinski, A., & Mandjes, M. (2009). Incentive-based control ad hoc networks:
performance study. Computer Networks, 53 (14), 24272443.
Greco, G., & Scarcello, F. (2013). Fair division rules funds distribution: case
italian research assessment program (vqr 2004-2010). Intelligenza Artificiale, 7 (1),
4556.
Green, J., & Laffont, J. (1977). Characterization satisfactory mechanisms revelation preferences public goods. Econometrica, 45 (2), 427438.
Groves, T. (1973). Incentives teams. Econometrica, 41, 617631.
Haake, C.-J., Raith, M. G., & Su, F. E. (2002). Bidding envy-freeness: procedural
approach n-player fair-division problems. Social Choice Welfare, 19 (4), 723
749.
446

fiMechanisms Fair Allocation Problems

Hurwicz, L. (1975). existence allocation systems whose manipulative nash equilibria pareto optimal. Unpublished paper, presented third World Congress
Economic Sosciety, Toronto.
Jain, K., & Vazirani, V. (2001). Applications approximation algorithms cooperative
games. Proc. STOC01, pp. 364372.
Jalali, A., Padovani, R., & Pankaj, R. (2000). Data throughput cdma-hdr high efficiencyhigh data rate personal communication wireless system. Proc. IEEE VTC00,
Vol. 3, pp. 18541858.
Kalai, E., & Samet, D. (1983). weighted Shapley values. Discussion papers 602, Northwestern University, Center Mathematical Studies Economics Management
Science.
Klijn, F. (2000). algorithm envy-free allocations economy indivisible
objects money. Social Choice Welfare, 17 (2), 201215.
Krysta, P., & Ventre, C. (2010). Combinatorial auctions verification tractable.
Proc. ESA10, pp. 3950.
Liben-Nowell, D., Sharp, A., Wexler, T., & Woods, K. (2012). Computing Shapley value
supermodular coalitional games. Proc. COCOON12, pp. 568579.
Lindner, C. (2010). market-affected sealed-bid auction protocol. Proc. SETN10,
pp. 193202.
Lipton, R. J., Markakis, E., Mossel, E., & Saberi, A. (2004). approximately fair allocations indivisible goods. Proc. EC04, pp. 125131.
Maniquet, F. (2003). characterization Shapley value queueing problems. Journal
Economic Theory, 109 (1), 90103.
Maskin, E. (1987). Fair Allocation Indivisible Goods, pp. 341349. MacMillan.
Meertens, M., Potters, J., & Reijnierse, H. (2002). Envy-free pareto efficient allocations
economies indivisible goods money. Mathematical Social Sciences, 44 (3),
223233.
Militano, L., Iera, A., & Scarcello, F. (2013). fair cooperative content-sharing service.
Computer Networks, 57 (9), 19551973.
Mishra, D., & Rangarajan, B. (2007). Cost sharing job scheduling problem. Social
Choice Welfare, 29 (3), 369382.
Moulin, H. (1992). application Shapley value fair division money. Econometrica, 60 (6), 133149.
Moulin, H. (1999). Incremental cost sharing: Characterization coalition strategyproofness. Social Choice Welfare, 16 (2), 279320.
Moulin, H. (2003). Fair Division Collective Welfare. MIT Press.
Moulin, H., & Shenker, S. (2001). Strategyproof sharing submodular costs: budget balance
versus effciency. Economic Theory, 18 (3), 511533.
Nagamochi, H., Zeng, D.-Z., Kabutoya, N., & Ibaraki, T. (1997). Complexity minimum base game matroids. Mathematics Operations Research, 22, 146164.
447

fiGreco & Scarcello

Nisan, N., & Ronen, A. (2001). Algorithmic mechanism design. Games Economic
Behavior, 35, 166196.
Nisan, N., Roughgarden, T., Tardos, E., & Vazirani, V. V. (2007). Algorithmic Game
Theory. Cambridge University Press, Cambridge, UK.
Ohseto, S. (2004). Implementing egalitarian-equivalent allocation indivisible goods
restricted domains. Economic Theory, 23, 659670 (2004).
Osborne, M. J., & Rubinstein, A. (1994). Course Game Theory. MIT Press,
Cambridge, MA, USA.
Papadimitriou, C. H. (1993). Computational Complexity. Addison-Wesley.
Pathak, A.P., S. T. (2013). Comparing mechanisms vulnerability manipulation.
American Economic Review, 103 (27), 80106.
Penna, P., & Ventre, C. (2012a). Collusion-resistant mechanisms verification yielding
optimal solutions. ACM Transaction Computation Theory, 4 (2), 117.
Penna, P., & Ventre, C. (2012b). Optimal collusion-resistant mechanisms verification. Games Economic Behavior, press, electronically available doi
10.1016/j.geb.2012.09.002.
Porter, R., Shoham, Y., & Tennenholtz, M. (2004). Fair imposition. Journal Economic
Theory, 118 (2), 209228.
Potthoff, R. F. (2002). Use linear programming find envy-free solution closest
bramskilgour gap solution housemates problem. Group Decision
Negotiation, 11, 405414.
Quinzii, M. (1984). Core competitive equilibria indivisibilities. International
Journal Game Theory, 13, 4160.
Sakai, T. (2007). Fairness implementability allocation indivisible objects
monetary compensations. Journal Mathematical Economics, 43 (5), 549563.
Sandholm, T. (1998). Contract types satisficing task allocation: theoretical results.
AAAI Spring Symposium: Satisficing Models.
Schrijver, A. (2003). Combinatorial Optimization: Polyhedra Efficiency. SpringerVerlag.
Shioura, A., Sun, N., & Yang, Z. (2006). Efficient strategy proof fair allocation algorithms.
Journal Operations Research Society Japan, 49 (2), 144150.
Shoham, Y., & Leyton-Brown, K. (2009). Multiagent Systems. Cambridge University Press.
Su, F. (1999). Rental harmony: Sperners lemma fair division. American Mathematical
Monthly, 106, 930942.
Svensson, L.-G. (1983). Large indivisibles: analysis respect price equilibrium
fairness. Econometrica, 51 (4), pp. 939954.
Svensson, L.-G. (2009). Coalitional strategy-proofness fairness. Economic Theory, 40,
227245.

448

fiMechanisms Fair Allocation Problems

Tadenuma, K., & Thomson, W. (1991). No-envy consistency economies indivisible goods. Econometrica, 59 (6), 175567.
Tadenuma, K., & Thomson, W. (1993). fair allocation indivisible good
monetary compensations possible. Mathematical Social Sciences, 25 (2), 117132.
Tadenuma, K., & Thomson, W. (1995). Games fair division. Games Economic
Behavior, 9 (2), 191204.
Thomson, W. (2011). Fair allocation rules. Kenneth J. Arrow, A. S., & Suzumura, K.
(Eds.), Handbook Social Choice Welfare, Vol. 2, pp. 393506. Elsevier.
Valiant, L. G. (1979a). complexity computing permanent. Theoretical Computer
Science, 8 (2), 189201.
Valiant, L. G. (1979b). complexity enumeration reliability problems. SIAM
Journal Computing, 8 (3), 410421.
Vickery, W. (1961). Counterspeculation, auctions competitive sealed tenders. Journal
Finance, 837.
Willson, S. J. (2003). Money-egalitarian-equivalent gain-maximin allocations indivisible items monetary compensation. Social Choice Welfare, 20, 247259.
Yang, Z. (2001). intersection theorem unbounded set application fair
allocation problem. Journal Optimization Theory Applications, 110, 429443.
Yengin, D. (2012). Egalitarian-equivalent groves mechanisms allocation heterogenous objects. Social Choice Welfare, 38 (1), 137160.
Young, H. P. (1985). Monotonic solutions cooperative games. International Journal
Game Theory, 14, 6572.
Young, H. P. (1994). Equity Theory Practice. Princeton University Press.

449


