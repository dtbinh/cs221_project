Journal Artificial Intelligence Research 49 (2014) 635-668

Submitted 01/14; published 04/14

Algorithms Argumentation Semantics: Labeling Attacks
Generalization Labeling Arguments
Samer Nofal

AMER .N OFAL @ GJU . EDU . JO

Dept. Computer Science, German-Jordanian University
P.O. Box 35247, Amman 11180, Jordan

Katie Atkinson
Paul E. Dunne

K.M.ATKINSON @ LIVERPOOL . AC . UK
P.E.D UNNE @ LIVERPOOL . AC . UK

Dept. Computer Science, University Liverpool
Ashton Street, Liverpool L69 3BX, United Kingdom

Abstract
Dung argumentation framework (AF) pair (A, R): set abstract arguments
R binary relation, so-called attack relation, capturing conflicting arguments. Labeling based algorithms enumerating extensions (i.e. sets acceptable arguments)
set arguments (i.e. elements A) subject labeling.
paper present implemented algorithms listing extensions labeling attacks (i.e. elements R) along arguments. Specifically, algorithms concerned enumerating
extensions AF number argumentation semantics: preferred, stable, complete,
semi stable, stage, ideal grounded. algorithms impact, particular, enumerating
extensions AF-extended models allow attacks attacks. demonstrate impact,
instantiate algorithms example models: namely argumentation frameworks
recursive attacks (AFRA), thereby end unified algorithms enumerate extensions
AF / AFRA.

1. Introduction
Computational argumentation, covering theory applications, attracted major attention
AI research community, notably last twenty years (e.g. Bench-Capon & Dunne, 2007;
Besnard & Hunter, 2008; Rahwan & Simari, 2009; Modgil, Toni, Bex, Bratko, Chesnevar, Dvorak,
Falappa, Fan, Gaggl, Garca, Gonzalez, Gordon, Leite, Mozina, Reed, Simari, Szeider, Torroni, &
Woltran, 2013). Dungs abstract argumentation frameworks (AFs) (Dung, 1995) widely studied
model AF described pair (A, R): set abstract arguments R AA
binary relation, so-called attack relation, represent conflicting arguments. central notion
AFs argumentation semantics: set criteria characterise acceptable arguments;
define criteria rigorously section 2. different reasons number argumentation
semantics proposed literature. Explaining reasons detail scope
paper; however, see work Baroni, Caminada, Giacomin (2011a) excellent
introduction argumentation semantics.
various argumentation semantics, one might find multiple distinct extensions (defined
section 2). Labeling based algorithms (e.g. Dimopoulos, Magirou, & Papadimitriou, 1997; Doutre
& Mengin, 2001; Modgil & Caminada, 2009) listing extensions developed
arguments (i.e. elements A) target labeled. paper illustrate
enumerate extensions several argumentation semantics labeling attacks (i.e. elements R)
c
2014
AI Access Foundation. rights reserved.

fiN OFAL , ATKINSON , & UNNE

along arguments, instead labeling arguments solely. particularly interest listing
extensions AF-extended formalisms allow attacks attacks (e.g. Modgil, 2009b; Gabbay,
2009; Baroni, Cerutti, Giacomin, & Guida, 2011b). show throughout paper, term
labeling based algorithms argumentation semantics distinguished common term
labeling based semantics, although concepts involve labeling mapping. former term
(i.e. labeling based algorithms) refers course actions extension enumeration
process classifies arguments: might extension excluded
respective extension. classification essential order construct concrete
extensions given AF. later term (i.e. labeling based semantics) refers approach
describing (i.e. constructing) extensions using labeling mapping.
section 2 provide necessary background materials. section 3 review explicit algorithms selection dominant argumentation semantics: preferred, stable, complete, semi
stable, stage, ideal grounded. algorithms list extensions labeling arguments only.
section 4 develop, respective argumentation semantics, definite algorithms
enumerating extensions argumentation framework recursive attacks (AFRA): AFextended model allows attacks attacks (Baroni et al., 2011b). algorithms construct
extensions labeling attacks together arguments. Since AF special case AFRA (Baroni et al., 2011b), developed algorithms AFRA list extensions AF. section 5
report experiments concerning practical efficiency algorithms. Section 6 concludes
paper summary review related work.

2. Preliminaries
start definition Dungs argumentation frameworks (Dung, 1995).
Definition 1. (Dungs Argumentation Frameworks)
argumentation framework (or AF) pair (A, R) set arguments R
binary relation.
refer (x, y) R x attacks (or attacked x). denote {x} respectively
subset containing arguments attack (resp. attacked by) argument x,
extending notation natural way sets arguments, A,
{x}+


S+

=
=

{ : x s.t. {x} }
{ : x s.t. {x}+ }

Given subset A,
x acceptable w.r.t. every (y, x) R, z
(z, y) R.
conflict free (x, y) S, (x, y)
/ R.
admissible conflict free every x acceptable w.r.t. S.
preferred extension maximal (w.r.t. ) admissible set.
stable extension conflict free S+ = \ S.
636

fiA LGORITHMS RGUMENTATION EMANTICS

Figure 1: argumentation framework.
complete extension admissible set x acceptable
w.r.t. S, x S.
stage extension conflict free S+ maximal (w.r.t. ).
semi stable extension admissible S+ maximal (w.r.t. ).
ideal extension maximal (w.r.t. ) admissible set contained every preferred extension.
grounded extension least fixed point F(T ) = {x |
x acceptable w.r.t. }.
Preferred, complete, stable grounded semantics introduced work Dung (1995),
whereas stage semantics, ideal semantics semi stable semantics presented papers
Verheij (1996), Dung, Mancarella, Toni (2007) Caminada, Carnielli, Dunne (2012)
respectively. give example, consider framework depicted figure 1 nodes represent
arguments edges correspond attacks (i.e. elements R). example {b, d}
preferred, grounded, stable, ideal, complete, semi stable stage extension. Note
intend example show differences semantics.
Offering explicit means weaken attacks, formalisms Modgil (2009b), Gabbay
(2009) Baroni et al. (2011b) extend AFs attacks (i.e. elements R) subject
attacks themselves. present extension enumeration algorithms instance formalisms: namely argumentation frameworks recursive attacks (AFRA) introduced Baroni et
al. (2011b).
Definition 2. argumentation framework recursive attacks (AFRA) pair (A, R)
set arguments R set pairs (x, y) x (y R).
Let x = (y, z) R say source x, denoted src(x) = y, z target
x, denoted trg(x) = z.
Let x R R say directly de f eats x x = trg(y).
Let x, R say indirectly de f eats x src(x) = trg(y).
Let x R R, say de f eats x directly indirectly defeats x.
Given subset R,
conflict free exist x, s.t. x defeats y.
element x R acceptable w.r.t. R : defeats x,
z z defeats y.
admissible conflict free x S, x acceptable w.r.t. S.
637

fiN OFAL , ATKINSON , & UNNE

Figure 2: argumentation framework recursive attacks.
preferred extension maximal (w.r.t. ) admissible set.
/ S,
stable extension conflict free x R : x
exists de f eats x.
complete extension admissible every element R,
acceptable w.r.t. S, belongs S.
stage (resp. semi stable) extension conflict free (resp. admissible)
{x | s.t. defeats x} maximal (w.r.t. ).
ideal extension maximal (w.r.t. ) admissible set contained every preferred extension.
grounded extension least fixed point F(T ) = {x R |
x acceptable w.r.t. }.
Referring figure 2, {b, d, h, e} grounded, stable, preferred, ideal, complete, stage
semi stable extension.
consider issue expressing AFRA AF. Let H = (A, R) AFRA,
corresponding AF H = (A , R ) defined = R R = {(x, y) | x,
R x de f eats y}. example, corresponding AF AFRA depicted figure 2
described = {b, c, d, e, f , g, h} R = {(e, g), ( f , e), (g, e), (g, d), (h, c), (h, f ), (h, g)}.

3. Algorithms Selection Argumentation Semantics
section review explicit algorithms list, number argumentation semantics,
extensions AF labeling arguments solely. Particularly, subsection 3.1 recall
algorithm Nofal, Atkinson Dunne (2014) preferred semantics. section 3.2 present
new implementation algorithm Dimopoulos et al. (1997) stable semantics.
modify algorithm Nofal, Atkinson Dunne (2014) produce specific algorithms
complete, stage, semi stable ideal semantics subsections 3.3, 3.4, 3.5 3.6 respectively.
subsection 3.7 present implementation building grounded extension.
3.1 Enumerating Preferred Extensions AF
Algorithm 1 lists preferred extensions AF. Algorithm 1 taken work Nofal,
Atkinson Dunne (2014) shown algorithm likely efficient
algorithms Doutre Mengin (2001), Modgil Caminada (2009). recall
638

fiA LGORITHMS RGUMENTATION EMANTICS

algorithm 1 implemented algorithms present paper seen extension
algorithm. algorithm backtracking procedure traverses abstract binary search
tree. core notion algorithm related use five labels: IN, OUT, MUST OUT,
BLANK UNDEC. Informally, label identifies arguments might preferred
extension. label identifies argument attacked argument. BLANK
label unprocessed argument whose final label decided yet. MUST label
identifies arguments attack arguments. UNDEC label designates arguments might
included preferred extension might defended argument.
enumerate preferred extensions algorithm 1 starts BLANK default label
arguments. initial state represents root node search tree. algorithm forks
left (resp. right) child (i.e. state) picking argument, BLANK, labeled (resp.
UNDEC). Every time argument, say x, labeled neighbour arguments labels
might change every {x}+ label becomes every z {x} \{x}+
label z becomes MUST OUT. process, i.e. forking new children, continues
every x label x BLANK. point, algorithm captures preferred extension
every x label x belongs {IN,OUT,UNDEC} {x | label x
IN} subset previously found preferred extension (if exists). algorithm
backtracks try find preferred extensions. important kinds algorithms
exploit properties whereby might bypass expanding child search tree, thus considerable
time might saved. Algorithm 1 uses two pruning properties:
1. Algorithm 1 (lines 12-17) skips labeling argument (i.e. skips expanding left child)
z {y} label z w {z}
BLANK label. words, z labeled later
w {z} label w OUT, MUST UNDEC. Thus, efficient skip
trying include argument attacked z preferred extension.
2. Algorithm 1 (lines 19-22) skips labeling argument UNDEC (i.e. skips expanding right
child) every z {y} current label z MUST OUT.
admissible set, say S, constructed UNDEC {y}
admissible also. Recall preferred extensions maximal admissible sets, hence
need label UNDEC.
Another fundamental issue take account selection BLANK arguments
labeled IN. point behind adopting selection strategy try achieve preferred extension efficiently. critical problem constructing one extension.
Therefore, algorithm 1 (line 8) applies following selection options:
1. Algorithm 1 tries select first BLANK argument, say y, attacked
attacked OUT/MUST arguments only. justification selection related
second pruning property used algorithm. Note earlier pick
labeled IN, bigger part search tree avoided. Recall lead
expanding right child according second pruning property.
2. Otherwise algorithm picks BLANK argument, say y, |{z : z {y}+
label z OUT}| maximal. intuition maximising number
arguments minimise number BLANK/MUST arguments. Thus,
639

fiN OFAL , ATKINSON , & UNNE

Figure 3: Enumerating preferred extensions AF using algorithm 1.
new generated state (i.e. child), due selecting y, much closer state
preferred extension captured. Recall preferred extension achieved
x label x IN, UNDEC.
Algorithm 1, algorithms paper, self-contained self-explanatory. Figure 3,
however, illustrates algorithm 1 running AF.
3.2 Enumerating Stable Extensions AF
Algorithm 2 lists stable extensions. Algorithm 2 seen new implementation
algorithm Dimopoulos et al. (1997). Algorithm 2 differs algorithm 1 two ways:
640

fiA LGORITHMS RGUMENTATION EMANTICS

Algorithm 1: Enumerating preferred extensions AF (A, R).
1
2
3
4
5

6
7
8

9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

Lab : {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab 0;
/
foreach x Lab Lab {(x, BLANK)};
E pre f erred 2A ; E pre f erred 0;
/
call find-preferred-extensions(Lab);
report E pre f erred set preferred extensions;
procedure find-preferred-extensions(Lab) begin
: Lab(y) = BLANK
select Lab(y) = BLANK z {y} Lab(z) {OUT, MUST },
otherwise select Lab(y) = BLANK s.t. z : Lab(z) = BLANK, |{x : x
{y}+ Lab(x) = }| |{x : x {z}+ Lab(x) = }|;
Lab Lab;
Lab (y) IN;
foreach z {y}+ Lab (z) ;
foreach z {y}
Lab (z) {UNDEC, BLANK}
Lab (z) MUST ;
w {z} : Lab (w) = BLANK
Lab(y) UNDEC;
goto line 7;
call find-preferred-extensions(Lab );
z {y} : Lab(z) {BLANK,UNDEC}
Lab(y) UNDEC;
else
Lab Lab ;
x : Lab(x) = MUST
{x | Lab(x) = IN};
E pre f erred : E pre f erred E pre f erred {S};
end procedure

641

fiN OFAL , ATKINSON , & UNNE

1. Algorithm 2 uses four labels: IN, OUT, BLANK MUST OUT. usage labels
outlined algorithm 1 one distinction: role UNDEC label used algorithm 1 overloaded MUST label. Meaning, algorithm 2 MUST
label used labeling argument, say x, trying build stable extension without x.
argument, say x, outside candidate stable extension attacked
argument extension, hence x labeled MUST (not UNDEC
case algorithm 1.)
2. algorithm 1, P = {w | label w IN} preferred extension
x A, label x BLANK MUST P subset previously
found preferred extension. algorithm 2 (line 24) set {w | label w IN} stable
extension every x A, label x BLANK MUST OUT.
Algorithm 2: Enumerating stable extensions AF (A, R).
1
2
3
4
5

6
7
8

9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26

Lab : {IN, OUT, MUST OUT, BLANK}; Lab 0;
/
foreach x Lab Lab {(x, BLANK)};
Estable 2A ; Estable 0;
/
call find-stable-extensions(Lab);
report Estable set stable extensions;
procedure find-stable-extensions(Lab) begin
: Lab(y) = BLANK
select Lab(y) = BLANK z {y} Lab(z) {OUT, MUST },
otherwise select Lab(y) = BLANK s.t. z : Lab(z) = BLANK, |{x : x
{y}+ Lab(x) = }| |{x : x {z}+ Lab(x) = }|;
Lab Lab;
Lab (y) IN;
foreach z {y}+ Lab (z) ;
foreach z {y}
Lab (z) = BLANK
Lab (z) MUST ;
w {z} Lab (w) = BLANK
Lab(y) MUST ;
goto line 7;
call find-stable-extensions(Lab );
z {y} : Lab(z) = BLANK
Lab(y) MUST ;
else
Lab Lab ;
x : Lab(x) = MUST
{x | Lab(x) = IN};
Estable Estable {S};
end procedure

642

fiA LGORITHMS RGUMENTATION EMANTICS

3.3 Enumerating Complete Extensions AF
Algorithm 3 lists complete extensions. Algorithm 3 modification algorithm 1 enumerates preferred extensions. algorithm 1, P = {w | label w IN} preferred extension
x A, label x BLANK MUST P subset
previously found preferred extension. algorithm 3 (line 10) set {w | label w IN}
complete extension
C1. every x A, label x MUST
C2. z UNDEC (or BLANK) label every {z} label
OUT.
Recall complete extension admissible set every x acceptable respect
S, x belongs S. Thus, condition C1 ensures admissibility C2 guarantees completeness.
3.4 Enumerating Stage Extensions AF
Algorithm 4 lists stage extensions. Algorithm 4 alteration algorithm 1 enumerates
preferred extensions. Algorithm 4 uses four labels: IN, OUT, UNDEC BLANK. usage
labels outlined algorithm 1 one distinction: role MUST label used
algorithm 1 overloaded UNDEC label. Meaning, algorithm 4 UNDEC label
used identifying arguments attack argument. argument attacks
argument stage extension necessarily attacked argument extension.
Algorithm 4 constructs conflict free subsets A. particular, algorithm 4 (line 26) keeps
record conflict free set {w | label w IN} x A, label
x BLANK. constructing conflict free subsets, algorithm 4 decides conflict
free subset, say S, stage extension S+ maximal, see lines 5-9. might
expected, argument selection pruning strategies used admissibility based semantics
applicable stage semantics, based conflict free sets. Therefore, pruning
strategy skip labeling argument, say y, UNDEC z {y}+ {y} ,
label z UNDEC. based following property: conflict free set, say S,
captured UNDEC {y} conflict free, hence,
need label UNDEC since {y} S; recall algorithm 4 labels argument UNDEC
trying build stage extension excluding argument. selecting next BLANK argument
labeled IN, consider rule:
R1. select BLANK argument s.t. z {y}+ {y} , label z UNDEC.
R2. otherwise select BLANK argument |{x : x {y}+ {y} label x
BLANK}| maximal.
Note correlation R1 applied pruning strategy: earlier label
argument selected R1 IN, bigger part search tree bypassed.
Regarding benefit R2, recall aim argument selection accelerate achieving
goal state, conflict free subset S+ maximal x
BLANK label. Indeed, R2 minimises number BLANK arguments maximising number
OUT/UNDEC arguments.
643

fiN OFAL , ATKINSON , & UNNE

Algorithm 3: Enumerating complete extensions AF (A, R).
1
2
3
4
5

6
7
8
9
10
11
12

13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

Lab : {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab 0;
/
foreach x Lab Lab {(x, BLANK)};
Ecomplete 2A ; Ecomplete 0;
/
call find-complete-extensions(Lab);
report Ecomplete set complete extensions;
procedure find-complete-extensions(Lab) begin
: Lab(y) = MUST
x : Lab(x) {UNDEC, BLANK} z {x} Lab(z) =
{w | Lab(w) = IN};
Ecomplete Ecomplete {S};
: Lab(y) = BLANK
select Lab(y) = BLANK z {y} Lab(z) {OUT, MUST },
otherwise select Lab(y) = BLANK s.t. z : Lab(z) = BLANK, |{x : x
{y}+ Lab(x) = }| |{x : x {z}+ Lab(x) = }|;
Lab Lab;
Lab (y) IN;
foreach z {y}+ Lab (z) ;
foreach z {y}
Lab (z) {UNDEC, BLANK}
Lab (z) MUST ;
w {z} : Lab (w) = BLANK
Lab(y) UNDEC;
goto line 11;
call find-complete-extensions(Lab );
z {y} : Lab(z) {BLANK,UNDEC}
Lab(y) UNDEC;
else
Lab Lab ;
end procedure

644

fiA LGORITHMS RGUMENTATION EMANTICS

Algorithm 4: Enumerating stage extensions AF (A, R).
1
2
3
4
5
6
7
8
9
10
11

12
13
14

15
16
17
18
19
20
21
22
23
24
25
26
27

Lab : {IN, OUT,UNDEC, BLANK}; Lab 0;
/
foreach x Lab Lab {(x, BLANK)};
Estage {Lab1 | Lab1 : {IN, OUT,UNDEC, BLANK}}; Estage 0;
/
call find-conflict-free-sets(Lab);
foreach Lab1 Estage
foreach Lab2 Estage
{x : Lab1 (x) {IN, }} ( {z : Lab2 (z) {IN, }}
Estage Estage \ {Lab1 };
continue next iteration line 5;
foreach Lab1 Estage
report {x : Lab1 (x) = IN} stage extension ;
procedure find-conflict-free-sets(Lab) begin
: Lab(y) = BLANK
select Lab(y) = BLANK z {y}+ {y} Lab(z) {OUT,UNDEC},
otherwise select Lab(y) = BLANK z : Lab(z) = BLANK, |{x : x
{y}+ {y} Lab(x) = BLANK}| |{x : x {z}+ {z} Lab(x) = BLANK}|;
Lab Lab;
Lab (y) IN;
foreach z {y}+ Lab (z) ;
foreach z {y}
Lab (z) {BLANK}
Lab (z) UNDEC;
call find-conflict-free-sets(Lab );
z {y}+ {y} Lab(z) = BLANK
Lab(y) UNDEC;
else
Lab Lab ;
Estage Estage {Lab};
end procedure

645

fiN OFAL , ATKINSON , & UNNE

3.5 Enumerating Semi Stable Extensions AF
Algorithm 5 enumerates semi stable extensions. Again, algorithm 5 reproduction algorithm 1. Actually, algorithm 5 firstly builds admissible sets. Then, algorithm decides
admissible set, say S, semi stable extension S+ maximal; see lines 6-10.

Algorithm 5: Enumerating semi stable extensions AF (A, R).
1
2
3
4
5
6
7
8
9
10
11
12

13
14
15

16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

Lab : {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab 0;
/
foreach x Lab Lab {(x, BLANK)};
Esemistable {Lab1 | Lab1 : {IN, OUT, MUST OUT,UNDEC, BLANK}};
Esemistable 0;
/
call find-admissible-sets(Lab);
foreach Lab1 Esemistable
foreach Lab2 Esemistable
{x : Lab1 (x) {IN, }} ( {z : Lab2 (z) {IN, }}
Esemistable Esemistable \ {Lab1 };
continue next iteration line 6;
foreach Lab1 Esemistable
report {x : Lab1 (x) = IN} semi stable extension ;
procedure find-admissible-sets(Lab) begin
: Lab(y) = BLANK
select Lab(y) = BLANK z {y} Lab(z) {OUT, MUST },
otherwise select Lab(y) = BLANK s.t. z : Lab(z) = BLANK, |{x : x
{y}+ Lab(x) = }| |{x : x {z}+ Lab(x) = }|;
Lab Lab;
Lab (y) IN;
foreach z {y}+ Lab (z) ;
foreach z {y}
Lab (z) {UNDEC, BLANK}
Lab (z) MUST ;
w {z} : Lab (w) = BLANK
Lab(y) UNDEC;
goto line 14;
call find-admissible-sets(Lab );
z {y} : Lab(z) {BLANK,UNDEC}
Lab(y) UNDEC;
else
Lab Lab ;
x : Lab(x) = MUST
Esemistable Esemistable {Lab};
end procedure

646

fiA LGORITHMS RGUMENTATION EMANTICS

3.6 Constructing Ideal Extension AF
Algorithm 6 builds ideal extension. algorithm modification algorithm 1. Algorithm 6
(line 28) records {w | label w IN} admissible set x A, label
x BLANK MUST OUT. However, algorithm constructs (line 27) = {x |
exists admissible set x + }. building set admissible sets
constructed, algorithm 6 considers admissible set ideal extension
= 0;
/ see lines 6-8. Recall ideal extension maximal (w.r.t. ) admissible
set contained every preferred extension. Satisfying condition = 0/ implies
arguments attacked admissible set (see definition above),
means contained every preferred extension. ensure maximal, algorithm 6 collects
admissible sets descending order: larger sets smaller ones. consequence, algorithm
checks collected admissible sets condition = 0/ starting larger admissible sets
smaller ones.
3.7 Constructing Grounded Extension AF
Algorithm 7 viewed another implementation algorithm described Modgil
Caminada (2009) building grounded extension.

4. Labeling Attacks Generalization Labeling Arguments
section illustrate enumerate extensions, number argumentation semantics, labeling attacks together arguments instead labeling arguments solely. end,
develop algorithms listing extensions AFRA (Baroni et al., 2011b) preferred,
stable, complete, stage, semi stable, ideal grounded semantics subsections 4.1, 4.2, 4.3, 4.4,
4.5, 4.6 4.7 respectively. algorithms basically generalization algorithms
presented previous section, hence algorithms list extensions AF / AFRA.
4.1 Enumerating Preferred Extensions AF / AFRA
Algorithm 8 enumerates preferred extensions AFRA. Algorithm 8 generalization
algorithm 1. idea based using five labels: IN, OUT, MUST OUT, BLANK UNDEC.
BLANK label initial label arguments attacks. BLANK attack R labeled
indicate might preferred extension. argument x labeled
R label trg(y) = x. attack z R labeled
R label trg(y) {z, src(z)}. BLANK argument x labeled IN,
implying x might preferred extension, R label
src(y) = x z R : trg(z) = x label z OUT. attack labeled UNDEC
try find preferred extension excluding y. attack z label BLANK/UNDEC labeled
MUST R label trg(z) {y, src(y)}. Every
time attack labeled labels attacks arguments might change accordingly, see
lines 10-20 algorithm 8. selection rule, line 8 represents strategy algorithm
selects next attack, BLANK, labeled IN. rule grounds parallel
selection rule applied algorithm 1 enumerating preferred extensions AF. Likewise,
algorithm 8 applies two pruning tactics:
647

fiN OFAL , ATKINSON , & UNNE

Algorithm 6: Constructing ideal extension AF (A, R).
1
2
3
4
5
6
7
8

9
10
11

12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

Lab : {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab 0;
/
foreach x Lab Lab {(x, BLANK)};
Eideal : Z 2A ; Eideal 0;
/
0;
/
call find-admissible-sets(Lab);
foreach = 1 .. |Eideal |
Eideal (i) = 0/
report Eideal (i) ideal extension; exit;
procedure find-admissible-sets(Lab) begin
: Lab(y) = BLANK
select Lab(y) = BLANK z {y} Lab(z) {OUT, MUST },
otherwise select Lab(y) = BLANK s.t. z : Lab(z) = BLANK, |{x : x
{y}+ Lab(x) = }| |{x : x {z}+ Lab(x) = }|;
Lab Lab;
Lab (y) IN;
foreach z {y}+ Lab (z) ;
foreach z {y}
Lab (z) {UNDEC, BLANK}
Lab (z) MUST ;
w {z} : Lab (w) = BLANK
Lab(y) UNDEC;
goto line 10;
call find-admissible-sets(Lab );
z {y} : Lab(z) {BLANK,UNDEC}
Lab(y) UNDEC;
else
Lab Lab ;
w : Lab(w) = MUST
{x | Lab(x) = };
Eideal Eideal {(|Eideal | + 1, {z | Lab(z) = IN})};
end procedure

Algorithm 7: Constructing grounded extension AF (A, R).
1
2
3
4
5
6
7

Lab : {IN, OUT,UNDEC}; Lab 0;
/
foreach w Lab Lab {(w,UNDEC)};
x Lab(x) = UNDEC : {x} Lab(y) =
foreach x Lab(x) = UNDEC : {x} Lab(y) =
Lab(x) IN;
foreach z {x}+ Lab(z) ;
report grounded extension {w | Lab(w) = IN};

648

fiA LGORITHMS RGUMENTATION EMANTICS

Figure 4: algorithm 8 works AFRA.
1. Algorithm 8 (lines 17- 20) skips labeling attack (i.e. skips expanding left child)

z : trg(z) {y, src(y)} label f z
w label BLANK : trg(w) {z, src(z)}.
2. Algorithm 8 (lines 22- 25) skips labeling attack UNDEC (i.e. skips expanding right
child) z R : trg(z) {y, src(y)}, label z MUST OUT.
get general idea algorithm 8 see figure 4 shows algorithm works
AFRA depicted figure 2.
4.2 Enumerating Stable Extensions AF / AFRA
Algorithm 9 enumerates stable extensions. Actually, algorithm 9 modification algorithm 8
lists preferred extensions. However two differences:
1. Algorithm 9 uses four labels: IN, OUT, BLANK MUST OUT. usage labels
outlined algorithm 8 one difference: role UNDEC label used algorithm 8 overloaded MUST label. is, algorithm 9 MUST
label used labeling attack, say x, trying build stable extension without x.
attack, say x, outside candidate stable extension defeated
attack extension, hence x labeled MUST OUT.
2. algorithm 8 find preferred extension, say P, x R, x
BLANK MUST P subset previously found preferred extension.
algorithm 9 encounter stable extension x R, x BLANK
MUST OUT.
649

fiN OFAL , ATKINSON , & UNNE

Algorithm 8: Enumerating preferred extensions AFRA (A, R).
1
2
3
4
5

6
7
8

9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

28
29
30
31

Lab : (A R) {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab 0;
/
foreach x R Lab Lab {(x, BLANK)};
E pre f erred 2AR ; E pre f erred 0;
/
call find-preferred-extensions(Lab);
report E pre f erred set preferred extensions;
procedure find-preferred-extensions(Lab) begin
R : Lab(y) = BLANK
select R Lab(y) = BLANK
z R : trg(z) {y, src(y)} Lab(z) {OUT, MUST }, otherwise select R
Lab(y) = BLANK z R : Lab(z) = BLANK
|{x : src(x) = trg(y) Lab(x) = }| |{x : src(x) = trg(z) Lab(x) = }|;
Lab Lab;
Lab (y) IN;
Lab (src(y)) IN;
Lab (trg(y)) ;
trg(y)
foreach z R : src(z) = trg(y)
Lab (z) ;
foreach z R : Lab (z) {BLANK,UNDEC} trg(z) {y, src(y)}
Lab (z) MUST ;
w R : Lab (w) = BLANK trg(w) {z, src(z)}
Lab(y) UNDEC;
goto line 7;
call find-preferred-extensions(Lab );
z R : Lab(z) {BLANK,UNDEC} trg(z) {y, src(y)}
Lab(y) UNDEC;
else
Lab Lab ;
w R : Lab(w) = MUST
foreach x Lab(x) = BLANK s.t. z R : trg(z) = x (Lab(z) = )
Lab(x) IN;
{x R | Lab(x) = IN};
E pre f erred (S )
E pre f erred E pre f erred {S};
end procedure

650

fiA LGORITHMS RGUMENTATION EMANTICS

Algorithm 9: Enumerating stable extensions AFRA (A, R).
1
2
3
4
5

6
7
8

9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

28
29

Lab : (A R) {IN, OUT, MUST OUT, BLANK}; Lab 0;
/
foreach x R Lab Lab {(x, BLANK)};
E stable 2AR ; E stable 0;
/
call find-stable-extensions(Lab);
report E stable set stable extensions;
procedure find-stable-extensions(Lab) begin
R : Lab(y) = BLANK
select R Lab(y) = BLANK
z R : trg(z) {y, src(y)} Lab(z) {OUT, MUST }, otherwise select R
Lab(y) = BLANK z R : Lab(z) = BLANK
|{x : src(x) = trg(y) Lab(x) = }| |{x : src(x) = trg(z) Lab(x) = }|;
Lab Lab;
Lab (y) IN;
Lab (src(y)) IN;
Lab (trg(y)) ;
trg(y)
foreach z R : src(z) = trg(y)
Lab (z) ;
foreach z R : Lab (z) = BLANK trg(z) {y, src(y)}
Lab (z) MUST ;
w R : Lab (w) = BLANK trg(w) {z, src(z)}
Lab(y) MUST ;
goto line 7;
call find-stable-extensions(Lab );
z R : Lab(z) = BLANK trg(z) {y, src(y)}
Lab(y) MUST ;
else
Lab Lab ;
w R : Lab(w) = MUST
foreach x Lab(x) = BLANK s.t. z R : trg(z) = x (Lab(z) = )
Lab(x) IN;
E stable E stable {{x R | Lab(x) = IN}};
end procedure

651

fiN OFAL , ATKINSON , & UNNE

4.3 Enumerating Complete Extensions AF / AFRA
Algorithm 10 enumerates complete extensions. Again, algorithm 10 modification algorithm 8 lists preferred extensions. algorithm 8 achieve preferred extension, say P,
x R, label x BLANK MUST P subset
previously found preferred extension. However, algorithm 10 (line 7) encounter complete
extension
C1. z R MUST label
C2. exist w R
(a) label w UNDEC BLANK
(b) R : trg(y) {w, src(w)}, label OUT.
Thus, C1 ensures admissibility C2 guarantees completeness.
4.4 Enumerating Stage Extensions AF / AFRA
Algorithm 11 lists stage extensions. algorithm rewrite algorithm 8. However, algorithm 11 uses four labels: IN, OUT, BLANK UNDEC. usage labels outlined
algorithm 8 one difference: role MUST label used algorithm 8
overloaded UNDEC label. is, algorithm 11 UNDEC label used identifying attacks attack argument/attack. attack defeats argument/attack
stage extension necessarily defeated attack extension.
Algorithm 11 (lines 14-29) finds set conflict free subsets R rather constructing
admissible subsets done algorithm 8. algorithm 8 set {w R | label w IN}
reported admissible set x R, label x BLANK
MUST OUT. algorithm 11 set {w R | label w IN} recorded conflict free
set (i.e. stage extension candidate) x R, label x BLANK,
see lines 14 & 31. building set conflict free subsets, algorithm 11 decides conflict
free subset R stage extension {x | : defeats x} maximal, see
lines 6-10. stated earlier, argument selection pruning strategies used semantics
based admissible sets applicable stage semantics, based conflict free
sets. Therefore, pruning strategy (line 29 algorithm 11) skip labeling attack UNDEC
(i.e. skip expanding right child)
z R : trg(z) {y, src(y)} trg(y) {z, src(z)},
label f z UNDEC.
based property conflict free set, say S, formed UNDEC
{y} conflict free, hence, need label UNDEC since {y} S.
selecting next BLANK attack labeled IN, apply following rule (see line 15):
R1. select BLANK attack s.t. z R : trg(z) {y, src(y)} trg(y) {z, src(z)},
label z UNDEC.
R2. otherwise select BLANK attack |{x : label x BLANK (src(x) =
trg(y) trg(x) {y, src(y)})}| maximal.
652

fiA LGORITHMS RGUMENTATION EMANTICS

Algorithm 10: Enumerating complete extensions AFRA (A, R).
1
2
3
4
5

6
7

8

9
10
11

12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

Lab : (A R) {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab 0;
/
foreach x R Lab Lab {(x, BLANK)};
E complete 2AR ; E complete 0;
/
call find-complete-extensions(Lab);
report E complete set complete extensions;
procedure find-complete-extensions(Lab) begin
v R Lab(v) = MUST w R : Lab(w) {UNDEC, BLANK}
R : trg(y) {w, src(w)} Lab(y) =
foreach x Lab(x) = BLANK s.t. z R : trg(z) = x (Lab(z) = )
Lab(x) IN;
E complete E complete {{x R | Lab(x) = IN)}};
R : Lab(y) = BLANK
select R Lab(y) = BLANK
z R : trg(z) {y, src(y)} Lab(z) {OUT, MUST }, otherwise select R
Lab(y) = BLANK z R : Lab(z) = BLANK
|{x : src(x) = trg(y) Lab(x) = }| |{x : src(x) = trg(z) Lab(x) = }|;
Lab Lab;
Lab (y) IN;
Lab (src(y)) IN;
Lab (trg(y)) ;
trg(y)
foreach z R : src(z) = trg(y)
Lab (z) ;
foreach z R : Lab (z) {BLANK,UNDEC} trg(z) {y, src(y)}
Lab (z) MUST ;
w R : Lab (w) = BLANK trg(w) {z, src(z)}
Lab(y) UNDEC;
goto line 10;
call find-complete-extensions(Lab );
z R : Lab(z) {BLANK,UNDEC} trg(z) {y, src(y)}
Lab(y) UNDEC;
else
Lab Lab ;
end procedure

653

fiN OFAL , ATKINSON , & UNNE

aim R1 maximise gain applied pruning strategy. Meaning, earlier
label selected argument R1 IN, greater saving terms part
search tree pruned. Regarding R2, note goal state (i.e. conflict free set) reached
x R, label x BLANK. Thus, R2 tries maximise
number OUT/UNDEC attacks/arguments, implies minimising number BLANK
attacks/arguments.
4.5 Enumerating Semi Stable Extensions AF / AFRA
Algorithm 12 lists semi stable extensions. Algorithm 12 variation algorithm 8
basically constructs admissible sets. Algorithm 12 (line 31) records set {w | label w IN}
admissible set (that semi stable extension candidate) x R,
label x BLANK MUST OUT. constructing set admissible sets, algorithm 12
decides admissible set semi stable extension {x | : defeats x}
maximal, see lines 6-10.
4.6 Constructing Ideal Extension AF / AFRA
Algorithm 13 builds ideal extension. particular, algorithm 13 finds admissible sets (lines 1028) way algorithm 8 does. However, enumerating admissible sets algorithm 13
(line 31) builds set
= {x R | admissible set trg(y) {x, src(x)}}
building set admissible sets constructed, algorithm 13 decides
admissible set ideal extension = 0,
/ see lines 6-8. Recall
ideal extension maximal (w.r.t. ) admissible set contained every preferred
extension. Satisfying condition = 0/ implies arguments/attacks defeated
admissible set (see definition above), means contained every preferred
extension. ensure maximal, algorithm 13 collects admissible sets descending order:
larger sets smaller ones. consequence, algorithm checks collected admissible sets
condition = 0/ starting larger admissible sets smaller ones.
4.7 Constructing Grounded Extension AF / AFRA
Algorithm 14 builds grounded extension. Algorithm 14 actually generalization algorithm 7.

5. Practical Efficiency
algorithms presented paper implemented C++ Fedora (release 13) based
machine 4 processors (Intel core i5-750 2.67GHz) 16GB memory. evaluation criterion, considered average elapsed time measured seconds; elapsed time obtained
using time command Linux. present experimental results two purposes. First,
explore efficiency algorithms section 3. second purpose, confirm
generalized algorithms section 4, enumerate extensions labeling attacks together
arguments, perform efficiently algorithms section 3, enumerate extensions
labeling arguments alone.
654

fiA LGORITHMS RGUMENTATION EMANTICS

Algorithm 11: Enumerating stage extensions AFRA (A, R).
1
2
3
4
5
6
7
8
9
10
11
12

13
14
15

16
17
18
19
20
21
22
23
24
25
26
27
28
29
30

31
32

Lab : (A R) {IN, OUT,UNDEC, BLANK}; Lab 0;
/
foreach x R Lab Lab {(x, BLANK)};
E stage {Lab1 | Lab1 : (A R) {IN, OUT,UNDEC, BLANK}};
E stage 0;
/
call find-conflict-free-sets(Lab);
foreach Lab1 E stage
foreach Lab2 E stage
{x : Lab1 (x) {IN, }} ( {z : Lab2 (z) {IN, }}
E stage E stage \ {Lab1 };
continue next iteration line 6;
foreach Lab1 E stage
report {x : Lab1 (x) = IN} stage extension ;
procedure find-conflict-free-sets(Lab) begin
R : Lab(y) = BLANK
select R Lab(y) = BLANK s.t.
z R : trg(z) {y, src(y)} trg(y) {z, src(z)} (Lab(z) {OUT,UNDEC}),
otherwise select R Lab(y) = BLANK s.t.
z R : Lab(z) = BLANK |{x : Lab(x) = BLANK (src(x) = trg(y) trg(x)
{y, src(y))}}| |{x : Lab(x) = BLANK (src(x) = trg(z) trg(x) {z, src(z))}}|;
Lab Lab;
Lab (y) IN;
Lab (src(y)) IN;
Lab (trg(y)) ;
trg(y)
foreach z R : src(z) = trg(y)
Lab (z) ;
foreach z R : Lab (z) = BLANK trg(z) {y, src(y)}
Lab (z) UNDEC;
call find-conflict-free-sets(Lab );
z R : Lab(z) = BLANK (trg(z) {y, src(y)} trg(y) {z, src(z)})
Lab(y) UNDEC;
else
Lab Lab ;
foreach x Lab(x) = BLANK s.t. z R : trg(z) = x (Lab(z) = )
Lab(x) IN;
E stage E stage {Lab};
end procedure

655

fiN OFAL , ATKINSON , & UNNE

Algorithm 12: Enumerating semi stable extensions AFRA (A, R).
1
2
3
4
5
6
7
8
9
10
11
12

13
14
15

16
17
18
19
20
21
22
23
24
25
26
27
28
29
30

31
32

Lab : (A R) {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab 0;
/
foreach x R Lab Lab {(x, BLANK)};
E semistable {Lab1 | Lab1 : (A R) {IN, OUT, MUST OUT,UNDEC, BLANK}};
E semistable 0;
/
call find-admissible-sets(Lab);
foreach Lab1 E semistable
foreach Lab2 E semistable
{x : Lab1 (x) {IN, }} ( {z : Lab2 (z) {IN, }}
E semistable E semistable \ {Lab1 };
continue next iteration line 6;
foreach Lab1 E semistable
report {x : Lab1 (x) = IN} semi stable extension ;
procedure find-admissible-sets(Lab) begin
R : Lab(y) = BLANK
select R Lab(y) = BLANK s.t.
z R : trg(z) {y, src(y)} Lab(z) {OUT, MUST }, otherwise select R
Lab(y) = BLANK s.t. z R : Lab(z) = BLANK |{x : src(x) = trg(y) Lab(x) =
}| |{x : src(x) = trg(z) Lab(x) = }|;
Lab Lab; Lab (y) IN; Lab (src(y)) IN;
Lab (trg(y)) ;
trg(y)
foreach z R : src(z) = trg(y) Lab (z) ;
foreach z R : Lab(z) {BLANK,UNDEC} trg(z) {y, src(y)}
Lab (z) MUST ;
w R : Lab (w) = BLANK trg(w) {z, src(z)}
Lab(y) UNDEC; goto line 14;
call find-admissible-sets(Lab );
z R : Lab(z) {BLANK,UNDEC} trg(z) {y, src(y)}
Lab(y) UNDEC;
else
Lab Lab ;
R : Lab(y) = MUST
foreach x Lab(x) = BLANK s.t. z R : trg(z) = x (Lab(z) = )
Lab(x) IN;
E semistable E semistable {Lab};
end procedure

656

fiA LGORITHMS RGUMENTATION EMANTICS

Algorithm 13: Constructing ideal extension AFRA (A, R).
1
2
3
4
5
6
7
8

9
10
11

12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30

31
32
33

Lab : (A R) {IN, OUT, MUST OUT,UNDEC, BLANK}; Lab 0;
/
foreach x R Lab Lab {(x, BLANK)};
E ideal : Z 2AR ; E ideal 0;
/
0;
/
call find-admissible-sets(Lab);
foreach : 1 |E ideal |
/ S)
x E ideal (i) (x
report E ideal (i) ideal extension; exit;
procedure find-admissible-sets(Lab) begin
R : Lab(y) = BLANK
select R Lab(y) = BLANK s.t.
z R : trg(z) {y, src(y)} Lab(z) {OUT, MUST }, otherwise select R
Lab(y) = BLANK z R : Lab(z) = BLANK
|{x : src(x) = trg(y) Lab(x) = }| |{x : src(x) = trg(z) Lab(x) = }|;
Lab Lab;
Lab (y) IN;
Lab (src(y)) IN;
Lab (trg(y)) ;
trg(y)
foreach z R : src(z) = trg(y)
Lab (z) ;
foreach z R : Lab (z) {BLANK,UNDEC} trg(z) {y, src(y)}
Lab (z) MUST ;
w R : Lab (w) = BLANK trg(w) {z, src(z)}
Lab(y) UNDEC;
goto line 10;
call find-admissible-sets(Lab );
z R : Lab(z) {BLANK,UNDEC} trg(z) {y, src(y)}
Lab(y) UNDEC;
else
Lab Lab ;
w R : Lab(w) = MUST
foreach x Lab(x) = BLANK s.t. z R : trg(z) = x (Lab(z) = )
Lab(x) IN;
{x R | Lab(x) = };
E ideal E ideal {(|E ideal | + 1, {z | Lab(z) = IN})};
end procedure

657

fiN OFAL , ATKINSON , & UNNE

Algorithm 14: Constructing grounded extension AFRA (A, R).
1
2
3
4

5
6
7
8
9
10
11

12

Lab : (A R) {IN, OUT,UNDEC}; Lab 0;
/
foreach w R Lab Lab {(w,UNDEC)};
x R Lab(x) = UNDEC s.t. R : trg(y) {x, src(x)} (Lab(y) = )
foreach x R Lab(x) = UNDEC s.t. R : trg(y) {x, src(x)} (Lab(y) = )

Lab(x) IN;
Lab(src(x)) IN;
Lab(trg(x)) ;
trg(x)
foreach z R : trg(x) = src(z)
Lab(z) ;
foreach x Lab(x) = UNDEC s.t. z R : trg(z) = x (Lab(z) = )
Lab(x) IN;
report grounded extension {w R | Lab(w) = IN};

compared algorithms dynPARTIX, implemented system based
dynamic programming algorithm Dvorak, Pichler, Woltran (2012b). Given AF, dynPARTIX basically computes tree decomposition AF extensions enumerated based
tree decomposition. algorithm used dynPARTIX fixed-parameter tractable
time complexity depends tree width given AF linear size
AF (Dvorak et al., 2012b). Since dynPARTIX computes extensions preferred, stable
complete semantics, figures 5, 6 & 7 depict respectively efficiency algorithms 1, 2 & 3 versus dynPARTIX. summary, figures show algorithms likely efficient
dynPARTIX. running experiments represented figures, set time
limit 120 seconds every execution. 1000 runs, dynPARTIX encountered 316 timeouts
enumerating preferred extensions 827 timeouts enumerating complete extensions.
timeouts plotted within figures 120 seconds. explains steady behavior dynPARTIX noted, particularly, figure 7. see performance algorithms 1-7
contrast behavior algorithms 8-14 present figures 8-14 respectively. profiling algorithms 1-7, reported running times including time needed get corresponding AF
AFRA. Note process (i.e. expressing AFRA AF) runs polynomial time:
worst quadratic time. figures 8-14 plot running times 1000 instances AFRA randomly
generated |A| = 5 R = R1 R2 s.t. R1 R2 R1 . instances |R|
grows 0 100 probability, used setting attacks random generation, goes {0.01,0.02,0.03,...,1}. Note instances |A| = 5 considered
quite small. example, randomly generated AFRA |A| = 5 |R| = 49 corresponding AF |A| = 54 |R| = 190. Again, emphasize aim experiments
compare performance algorithms 1-7 performance algorithms 8-14.
mean experiments check scalability algorithms, although important issue
examined. Said that, crucial evaluation consider large frameworks
higher level recursive attacks. Back results experiments, case involved
exceeding 120-second time limit occurred enumerating semi stable extensions. Referring
658

fiA LGORITHMS RGUMENTATION EMANTICS

Figure 5: Enumerating preferred extensions 1000 instances AF |A|=40, p
{0.01, 0.02, 0.03, ..., 1} tracked average elapsed time 10 instances generated
randomly probability p (i.e. probability x attacks x, A).

figure 12 note algorithm 5 (resp. 12) encountered 68 (resp. 66) timeouts. bottom
line conclusion figures is: enumerating extensions AFRA labeling attacks together
arguments seems efficient enumerating extensions corresponding AF via
labeling arguments alone.

6. Discussion Conclusion
started paper refining implemented algorithms1 enumerating extensions Dungs
argumentation frameworks (AFs) number argumentation semantics: preferred, stable,
complete, stage, semi stable, ideal grounded. Algorithms semantics, except stage
grounded semantics, share similar core structure: basically build admissible sets
order construct extensions. case stage semantics, algorithm actually constructs
conflict free sets purpose listing stage extensions, hence, algorithm applies
slightly different approach expanding search tree elaborated earlier. Concerning
grounded semantics, presented algorithm builds grounded extension polynomial time.
Furthermore, explored practical efficiency algorithms profiling performance
running wide spectrum AF instances: sparse instances dense ones. essence
algorithms construct extensions using total function maps arguments solely
set labels reflecting different states illustrated paper. Then, generalized
algorithms using total mapping labels attacks together arguments. implemented
generalized algorithms enumerate extensions AFRA, AF-extended model
1. C++ implementations found http://sourceforge.net/projects/argtools/files/

659

fiN OFAL , ATKINSON , & UNNE

Figure 6: Enumerating stable extensions 1000 instances AF |A|=60, p
{0.01, 0.02, 0.03, ..., 1} tracked average elapsed time 10 instances generated
randomly probability p.

Figure 7: Enumerating complete extensions 1000 instances AF |A|=30, p
{0.01, 0.02, 0.03, ..., 1} tracked average elapsed time 10 instances generated
randomly probability p.

660

fiA LGORITHMS RGUMENTATION EMANTICS

Figure 8: Enumerating preferred extensions 1000 instances AFRA, p
{0.01, 0.02, 0.03, ..., 1} tracked average elapsed time 10 instances generated
randomly probability p.

Figure 9: Enumerating stable extensions 1000 instances AFRA, p
{0.01, 0.02, 0.03, ..., 1} tracked average elapsed time 10 instances generated
randomly probability p.

661

fiN OFAL , ATKINSON , & UNNE

Figure 10: Enumerating complete extensions 1000 instances AFRA, p
{0.01, 0.02, 0.03, ..., 1} tracked average elapsed time 10 instances generated
randomly probability p.

Figure 11: Listing stage extensions 1000 instances AFRA, p
{0.01, 0.02, 0.03, ..., 1} tracked average elapsed time 10 instances generated randomly probability p.

662

fiA LGORITHMS RGUMENTATION EMANTICS

Figure 12: Listing semi stable extensions 1000 instances AFRA, p
{0.01, 0.02, 0.03, ..., 1} tracked average elapsed time 10 instances generated
randomly probability p.

Figure 13: Constructing ideal extension 1000 instances AFRA, p
{0.01, 0.02, 0.03, ..., 1} tracked average elapsed time 10 instances generated
randomly probability p.

663

fiN OFAL , ATKINSON , & UNNE

Figure 14: Constructing grounded extension 1000 instances AFRA, p
{0.01, 0.02, 0.03, ..., 1} tracked average elapsed time 10 instances generated
randomly probability p.

allows attacks attacks. words, offered unified approach enumerating extensions
AF/AFRA, given fact AF special case AFRA (Baroni et al., 2011b).
hand, showed labeling attacks alongside arguments potentially used
basis enumerating extensions related formalisms allow attacks attacks (e.g. Modgil,
2009b; Gabbay, 2009); nonetheless confirmed research. fact, extensions
instance formalisms listed working corresponding AF. However,
demonstrated enumerate extensions AFRA applying labeling directly native
form without compromising running time efficiency. omitted soundness/completeness
proof presented algorithms since follows immediately proof algorithm
Nofal, Atkinson Dunne (2014) preferred semantics. algorithms presented paper
handle frameworks self-attacking arguments perfectly. However, algorithms
easily modified initial label self-attacking argument UNDEC instead
BLANK. instance, change necessary made algorithm 1 modify line 2
follows
foreach x
(x, x) R Lab Lab {(x,UNDEC)};
else Lab Lab {(x, BLANK)};
general, UNDEC label (instead BLANK label) default label
argument/attack extension, self-attacking arguments outgoing
attacks simply arguments present conflict themselves. Recall BLANK
arguments/attacks tried label.
future work, plan study additional options argument selection. Also, intend
evaluate strategies pruning search space.
664

fiA LGORITHMS RGUMENTATION EMANTICS

discuss related work. existing algorithms Doutre Mengin (2001) Modgil
Caminada (2009) listing preferred extensions re-engineered towards enumerating
extensions argumentation semantics. example, papers Caminada (2007, 2010)
presented algorithms enumerating semi stable, respectively stage, extensions building
algorithm Modgil Caminada (2009). However, algorithms present paper based
algorithm Nofal, Atkinson Dunne (2014) enumerating preferred extensions,
likely efficient existing algorithms (Nofal et al., 2014). give
examples related work labeling-based semantics. theory Caminada Gabbay (2009)
defined argumentation semantics using total mapping : {IN, OUT,UNDEC} that,
broadly speaking, labeled arguments correspond extension, say S,
labeled arguments correspond S+ UNDEC labeled arguments correspond \ (S S+ ).
hard see connection algorithms theory Caminada Gabbay
(2009). example, algorithm 1 capture preferred extension arguments
mapped one labels: IN, UNDEC. Listing works present labelingbased semantics, paper Modgil (2009a) defined labeling-based semantics extended
AF Modgil (2009b) Villata, Boella, van der Torre (2011) described argumentation
semantics terms attacks arguments. Also, work Gabbay (2009) set argumentation
semantics AF-extended model Barringer, Gabbay, Woods (2005) among
features allow attacks attacks. topic extension computation general, study
Li, Oren, Norman (2012) examined approximation versus exact computations, whereas
experiments Baumann, Brewka, Wong (2012), Liao, Lei, Dai (2013) evaluated effect
splitting AF computation preferred extensions. work Dondio (2013) studied,
grounded semantics, acceptance status argument varies subgraphs
given AF. Computational complexity argumentation semantics widely studied (see e.g.
Dimopoulos, Nebel, & Toni, 2000; Dunne, 2007, 2009; Ordyniak & Szeider, 2011). Another line
research concerns encoding computational problems AFs formalisms solving
using respective solver (e.g. Besnard & Doutre, 2004; Nieves, Cortes, & Osorio, 2008;
Egly, Gaggl, & Woltran, 2010; Amgoud & Devred, 2011; Dvorak, Jarvisalo, Wallner, & Woltran,
2012a; Cerutti, Dunne, Giacomin, & Vallati, 2013; Charwat, Dvorak, Gaggl, Wallner, & Woltran,
2013), approaches called reduction based methods. stress focus paper
algorithmic based implementations argumentation semantics.

Acknowledgments
thank anonymous reviewers comments improved presentation work.

References
Amgoud, L., & Devred, C. (2011). Argumentation frameworks constraint satisfaction problems.
Benferhat, S., & Grant, J. (Eds.), SUM, Vol. 6929 Lecture Notes Computer Science,
pp. 110122. Springer.
Baroni, P., Caminada, M., & Giacomin, M. (2011a). introduction argumentation semantics.
Knowledge Engineering Review, 26(4), 365410.
665

fiN OFAL , ATKINSON , & UNNE

Baroni, P., Cerutti, F., Giacomin, M., & Guida, G. (2011b). Argumentation framework recursive attacks. International Journal Approximate Reasoning, 52(1), 1937.
Barringer, H., Gabbay, D., & Woods, J. (2005). Temporal dynamics support attack networks:
argumentation zoology. Hutter, D., & Stephan, W. (Eds.), Mechanizing Mathematical Reasoning, Vol. 2605 Lecture Notes Computer Science, pp. 5998. Springer.
Baumann, R., Brewka, G., & Wong, R. (2012). Splitting argumentation frameworks: empirical
evaluation. Modgil, S., Oren, N., & Toni, F. (Eds.), First International Workshop Theory
Applications Formal Argumentation 2011, Vol. 7132 Lecture Notes Computer
Science, pp. 1731. Springer.
Bench-Capon, T., & Dunne, P. (2007). Argumentation artificial intelligence. Artificial Intelligence, 171, 619641.
Besnard, P., & Doutre, S. (2004). Checking acceptability set arguments. Delgrande,
J., & Schaub, T. (Eds.), NMR, pp. 5964.
Besnard, P., & Hunter, A. (2008). Elements Argumentation. MIT press.
Caminada, M. (2007). algorithm computing semi-stable semantics. Mellouli, K. (Ed.),
ECSQARU, Vol. 4724 Lecture Notes Computer Science, pp. 222234. Springer.
Caminada, M. (2010). algorithm stage semantics. Baroni, P., Cerutti, F., Giacomin, M., &
Simari, G. (Eds.), COMMA, Vol. 216 Frontiers Artificial Intelligence Applications,
pp. 147158. IOS Press.
Caminada, M., Carnielli, W., & Dunne, P. (2012). Semi-stable semantics. J. Log. Comput., 22(5),
12071254.
Caminada, M., & Gabbay, D. (2009). logical account formal argumentation. Studia Logica,
93(2-3), 109145.
Cerutti, F., Dunne, P., Giacomin, M., & Vallati, M. (2013). sat-based approach computing
extensions abstract argumentation. TAFA, Second International Workshop Theory
Applications Formal Argumentation.
Charwat, G., Dvorak, W., Gaggl, S., Wallner, J., & Woltran, S. (2013). Implementing abstract argumentation - survey. Tech. rep. DBAI-TR-2013-82, Technische Universitat Wien, Database
Artificial Intelligence Group.
Dimopoulos, Y., Magirou, V., & Papadimitriou, C. (1997). kernels, defaults even graphs.
Annals Mathematics Artificial Intelligence, 20, 112.
Dimopoulos, Y., Nebel, B., & Toni, F. (2000). Finding admissible preferred arguments
hard. Cohn, A., Giunchiglia, F., & Selman, B. (Eds.), KR, pp. 5361. Morgan
Kaufmann.
Dondio, P. (2013). Computing grounded semantics subgraphs argumentation
framework: empirical evaluation. CLIMA, XIV Workshop Computational Logic
Multi-Agent Systems.
Doutre, S., & Mengin, J. (2001). Preferred extensions argumentation frameworks: Query answering computation. Gore, R., Leitsch, A., & Nipkow, T. (Eds.), IJCAR, Vol. 2083
Lecture Notes Computer Science, pp. 272288. Springer.
666

fiA LGORITHMS RGUMENTATION EMANTICS

Dung, P. (1995). acceptability arguments fundamental role non monotonic
reasoning, logic programming n-person games. Artificial Intelligence, 77(2), 321357.
Dung, P., Mancarella, P., & Toni, F. (2007). Computing ideal skeptical argumentation. Artificial
Intelligence, 171(10-15), 642674.
Dunne, P. (2007). Computational properties argument systems satisfying graph-theoretic constraints. Artificial Intelligence, 171, 701729.
Dunne, P. (2009). computational complexity ideal semantics. Artificial Intelligence, 173(18),
1559 1591.
Dvorak, W., Jarvisalo, M., Wallner, J. P., & Woltran, S. (2012a). Complexity-sensitive decision
procedures abstract argumentation. Brewka, G., Eiter, T., & McIlraith, S. (Eds.), KR.
AAAI Press.
Dvorak, W., Pichler, R., & Woltran, S. (2012b). Towards fixed-parameter tractable algorithms
abstract argumentation. Artificial Intelligence, 186, 137.
Egly, U., Gaggl, S., & Woltran, S. (2010). Answer-set programming encodings argumentation
frameworks. Argument Computation, 1(2), 147177.
Gabbay, D. (2009). Semantics higher level attacks extended argumentation frames part 1:
Overview. Studia Logica, 93(2-3), 357381.
Li, H., Oren, N., & Norman, T. (2012). Probabilistic argumentation frameworks. Modgil, S.,
Oren, N., & Toni, F. (Eds.), First International Workshop Theory Applications
Formal Argumentation 2011, Vol. 7132 Lecture Notes Computer Science, pp. 116.
Springer.
Liao, B., Lei, L., & Dai, J. (2013). Computing preferred labellings exploiting sccs
sceptically rejected arguments. TAFA, Second International Workshop Theory Applications Formal Argumentation.
Modgil, S. (2009a). Labellings games extended argumentation frameworks. Boutilier, C.
(Ed.), IJCAI, pp. 873878.
Modgil, S. (2009b). Reasoning preferences argumentation frameworks. Artificial Intelligence, 173, 901934.
Modgil, S., & Caminada, M. (2009). Proof theories algorithms abstract argumentation
frameworks. Rahwan, I., & Simari, G. (Eds.), Argumentation Artificial Intelligence, pp.
105129. Springer.
Modgil, S., Toni, F., Bex, F., Bratko, I., Chesnevar, C., Dvorak, W., Falappa, M., Fan, X., Gaggl, S.,
Garca, A., Gonzalez, M., Gordon, T., Leite, J., Mozina, M., Reed, C., Simari, G., Szeider, S.,
Torroni, P., & Woltran, S. (2013). added value argumentation. Ossowski, S. (Ed.),
Agreement Technologies, Vol. 8 Law, Governance Technology Series, pp. 357403.
Springer Netherlands.
Nieves, J., Cortes, U., & Osorio, M. (2008). Preferred extensions stable models. Theory
Practice Logic Programming, 8(4), 527543.
Nofal, S., Atkinson, K., & Dunne, P. (2014). Algorithms decision problems argument systems
preferred semantics. Artif. Intell., 207, 2351.
667

fiN OFAL , ATKINSON , & UNNE

Ordyniak, S., & Szeider, S. (2011). Augmenting tractable fragments abstract argumentation.
Walsh, T. (Ed.), Proceedings 22nd International Joint Conference Artificial Intelligence IJCAI 2011, pp. 10331038.
Rahwan, I., & Simari, G. (2009). Argumentation Artificial Intelligence. Springer.
Verheij, B. (1996). Two approaches dialectical argumentation: admissible sets argumentation
stages. Proceedings Eighth Dutch Conference AI, pp. 357368.
Villata, S., Boella, G., & van der Torre, L. (2011). Attack semantics abstract argumentation.
Walsh, T. (Ed.), Proceedings 22nd International Joint Conference Artificial Intelligence IJCAI 2011, pp. 406413.

668


