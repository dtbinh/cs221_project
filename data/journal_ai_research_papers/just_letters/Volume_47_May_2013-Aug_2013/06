journal artificial intelligence research                  

submitted        published      

refined view causal graphs component sizes 
sp closed graph classes beyond
christer backstrom
peter jonsson

christer backstrom liu se
peter jonsson liu se

department computer science
linkoping university
se        linkoping  sweden

abstract
causal graph planning instance important tool planning
practice theory  theoretical studies causal graphs largely analysed
computational complexity planning instances causal graph certain
structure  often combination parameters domain size variables 
chen gimenez ignored even structure considered size weakly
connected components  proved planning tractable components
bounded constant otherwise intractable  intractability result was  however 
conditioned assumption parameterised complexity theory known
useful relationship standard complexity classes  approach problem
perspective standard complexity classes  prove planning np hard
classes unbounded components additional restriction refer spclosed  argue np hardness theorems causal graphs difficult
apply and  thus  prove general result  even component sizes grow slowly
class densely populated graphs  planning still cannot tractable unless
polynomial hierachy collapses  results still hold restricted class
acyclic causal graphs  finally give partial characterization borderline
np hard np intermediate classes  giving insight problem 

   introduction
first briefly explain causal graph give short survey applications
well theoretical results reported literature  following that  give overview
new results presented article 
    background
causal graph planning instance explicit description variable dependencies implicitly defined operators  precisely  directed graph
arc variable x another variable either x appears
precondition operator effect operator effects x y 
standard definition causal graph traced back knoblock       
although give name  used causal graph alpine algorithm 
guidance partitioning ordering variables process automatically
deriving state abstraction hierarchies  actual name causal graph traced back
williams nayak         approach general restricted
c
    
ai access foundation  rights reserved 

fibackstrom   jonsson

knoblocks  one hand  generalized concept binary variables
multi valued variables  hand  considered acyclic causal graphs
implies operators unary  i e  every operator changes one variable 
context work reactive planner burton onboard space ship control 
causal model compiled transition system could efficiently exploited
reactive controller choose appropriate operators achieve given goals  compilation
done way operators unary  claimed often
possible real applications  resulting acyclicity causal graph exploited
burton  traversed graph bottom order issue operators order
consistent causal relationships 
jonsson backstrom      b  studied acyclic causal graphs  referred
dependency graphs  considered subclass graphs particular structure used implicitly define corresponding class planning instances   s
class  class property always possible decide polynomial time
solution not  solutions may exponential length  thus
necessarily taking exponential time generate  although one single restricted case 
 s class probably first example relating structural properties causal graph
computational complexity planning  general extensive analysis
done domshlak dinitz      a   analysed complexity planning
classes instances corresponding number different possible structures acyclic
causal graphs  however  work done context multi agent coordination
term causal graph never used 
first two papers may viewed early examples exploiting causal
graph practice  latter papers form starting point subsequent theoretical research relationships planning complexity structure
causal graphs 
important step forward usage causal graphs paper helmert
       demonstrated causal graph particularly useful context
multi valued variables  previous research complexity planning multi valued
variables focussed structure domain transition graphs variables
 jonsson   backstrom      a   rather causal graph  helmert realized power
using domain transition graphs causal graph heuristic planning 
exploited practice highly succesful fast downward planner  helmert 
    a   translates pddl planning instances binary variables representation
multi valued variables removes carefully chosen edges resulting causal
graph make acyclic  resulting causal graph used compute heuristic
hierarchically computing composing plan lengths subgraphs one
particular structures studied domshlak dinitz      a   somewhat similarly  katz
domshlak        identified subgraphs causal graph certain structures
make planning tractable  exploited able use larger variables
sets constructing pattern databases  example exploiting causal graph
make planning efficient paper factored planning brafman domshlak
        showed structure causal graph used guide
deciding planning instance solved efficiently dividing
loosely coupled subinstances use constraint processing  basic idea causal
   

fia refined view causal graphs component sizes

graph represent variable dependencies is  course  quite general necessarily
restricted planning  instance  wehrle helmert        transferred causal
graph concept context model checking 
previously mentioned  two papers jonsson backstrom      b 
domshlak dinitz      a  viewed starting point successful line
research studying relationships planning complexity structure
causal graph   s class jonsson backstrom limited
special case  domshlak dinitz studied classes planning instances corresponding
number general graph structures  in stars  aka  inverted forks   out stars  aka 
forks   directed path graphs  aka  directed chain graphs   polytrees singly connected
dags  results followed  instance  articles brafman domshlak        
gimenez jonsson         latter article additionally showed although  s
instances exponential length plans  possible generate macro representation
plan polynomial time  result extended classes defined
structure causal graph  many complexity results papers use
additional numerical parameters conjunction graph structure  examples
parameters maximum domain size variables maximum in degree
graph  increasing number possible cases analyse  allow
fine grained analysis many cases  consider instance case directed path
graphs  domshlak dinitz      a  proved tractable decide
plan case domains binary  gimenez jonsson        proved
domain size   sufficient make problem np hard  similarly  gimenez
jonsson        proved tractability planning instances binary variables  constant
number prevail conditions causal graph polytree  paper
brafman domshlak        fits line theoretical research  exhibiting
planning algorithm runs time exponential two parameters  tree width
undirected version causal graph maximum number times variable must
change value 
research based standard definition causal graphs
set already knoblock  although often generalisation multi valued variables 
important exceptions  one potential problem standard defintion
whenever two variables affected operator  causal graph must
necessarily contain cycles  major reason focus mainly
planning unary operators  attempt circumvent problem  jonsson       
defined relaxed variant causal graph always introduce cycles
non unary operators  sometimes allow fine grained complexity analysis 
previous results relate structure causal graph complexity satisficing planning  i e  deciding plan  corresponding branch
research relating structure causal graph complexity cost optimal
planning  cf   katz   domshlak                    katz   keyder        
    contributions
theoretical research studies complexity planning based structure causal graph  possibly parameters domain sizes  important
   

fibackstrom   jonsson

milestone deviates line research article chen gimenez
       even consider structure causal graph simple quantitative measure  size weakly connected components  proved deciding
plan done polynomial time size weakly connected components causal graph bounded constant  one sense 
sharp final result  however  intractability result unbounded components
conditional assumtion w      nu fpt  assumption relies theory
parameterised complexity theory neither complexity classes assumption
related ordinary complexity classes clear way  chen gimenez acknowledge problems prove conditionally intractable include np intermediate
problems  hence  take result take off point investigation
component sizes reflect standard complexity classes  since know chen
gimenez graph classes unbounded components np hard must
consider restrictions order find np hard classes  adding new
type closure property  sp closure  incomparable subset closure subset minor closure  prove planning np hard sp closed graph class
unbounded components  noted result still holds class
acyclic graphs  important considering practical relevance acyclicity
previously mentioned 
many graph classes studied literature indeed sp closed 
exists natural classes lack property  present one way handling
classes aid non uniform complexity theory  case  able
show np hardness show polynomial hierarchy collapses second
level  fairly general result applied even component sizes grow
slowly graph class densely populated graphs  result
holds even restricted acyclic graphs  result used demonstrate clearly
complexity results planning based class causal graphs necessarily connection complexity generic planning problem
class causal graphs  result raises question find  preferably natural  np intermediate planning problems  chen gimenez state np intermediate
problems obtained using methods similiar ones employed bodirsky
grohe         problems hard describe natural  though  based
ladners        diagonalization technique removes large fraction input strings
problem  apparently difficult connect graph classes constructed technique
simple conditions component growth  alternative  show graph classes
component sizes grow polylogarithmically np intermediate double
assumption w      nu fpt exponential time hypothesis  impagliazzo
  paturi        holds  show every k      exists class gk graphs
component size bounded  v  g    k g gk corresponding
planning problem np hard  results coarsely stake borderline
np hard np intermediate classes 
possible conclusion paper complexity analysis planning based
structure causal graph limited value  additional parameters
needed achieve useful results  may fair conclusion general 
cases graph structure sufficient  instance  katz  hoffmann  domsh   

fia refined view causal graphs component sizes

lak        applied result chen gimenez        context called
red black planning  variant delete relaxation computing heuristics  furthermore 
even structure causal graph combined parameters 
still important know behaviour parameter isolation 
remainder article structured follows  section   set notation
terminology used planning graphs  section   define causal graphs
structural planning general  section   contains number np hardness results
various special graph classes need main results  first two main
theorems article appears section    define concept sp closed graph
classes prove planning np hard classes component size
unbounded  section   discusses problems previous theorem
similar results literature  way around problems  second main
theorem shows even without closure requirements  planning likely hard
even components grow slowly graphs appear densely class 
section   contains observations concerning borderline np intermediate
np hard planning problems  article ends discussion section 

   preliminaries
section sets terminology notation planning graphs used article 
write  x  denote cardinality set x length sequence x  i e 
number elements x  write   x   denote size representation
object x 
    planning
since article many connections one chen gimenez       
follow notation terminology plannning  notational variant sas 
 backstrom   nebel        
instance planning problem tuple    v  init  goal  a  whose components
defined follows 
v finite set variables  variable v v associated finite domain
d v   note variables necessarily propositional  is  d v  may
finite set  state mapping defined variables v s v  d v 
v v   partial state mapping p defined subset vars p  variables v
v vars p   holds p v  d v   p otherwise undefined 
init state called initial state 
goal partial state 
set operators  operator consists precondition pre a 
postcondition post a  partial states  often use notation
hpre   posti define operator precondition pre postcondition post 
instance    hx            z    i defines operator applicable
state s x      s y       effect setting variable
z   
   

fibackstrom   jonsson

state partial state w subset variable set v   write
w denote partial state resulting restricting w   say state
goal state goal   vars goal  
define plan  for instance   sequence operators p   a             
starting state s  define state resulting applying plan p   denoted
s p    inductively follows  empty plan p     define s     s  non empty
plans p define s p   follows  last operator p p   prefix
p to  including  a 
pre a     s p     vars pre a    that is  preconditions satisfied
state s p       s p     a    s p     
otherwise  s p     a  state equal post a  variables v vars post a   
equal s p     variables v v   vars post a   
plan p solution plan init p   goal state 
concerned computational problem plan existence  planexist   given
instance    v  init  goal  a   decide exists solution plan 
    graphs
directed graph pair  v  e  v vertex set e v v edge set 
undirected graph pair  v  e  v vertex set e   u  v    u  v v  
edge set  often say graph edge clear context whether
directed undirected  notation v  g  refers vertex set graph g
e g  refers edge set  e    u  v  e    u  v  edge  vertices u
v incident e  furthermore  directed edge  u  v  outgoing edge u
incoming edge v  directed graph g    v  e   write u  g  denote
correspsonding undirected graph u  g     v  eu   eu     u  v     u  v  e  
is  u  g  undirected graph induced g ignoring orientation edges 
let g    v  e  directed graph let v            vk v v            vk
distinct  vi    vi   e    k   sequence v            vk directed
path length k g v     vk directed cycle length k g v    vk   paths
cycles undirected graphs defined analogously  except direction
consider  graph acyclic contains cycles 
let g    v  e  directed graph let v v vertex  then  v isolated
incoming outgoing edges  v source least one outgoing edge
incoming edge  v sink least one incoming edge outgoing edge
otherwise v intermediate 
let g    vg   eg   h    vh   eh   two directed graphs  g h
isomorphic  denoted g   h  exists bijective function f   vg vh
 u  v  eg  f  u   f  v   eh   furthermore  h subgraph g vh vg
eh eg  vh vh    eh   eg  vh vh   say subgraph h
induced vertex set vh   isomorphisms subgraphs analogously defined
undirected graphs 
let g undirected graph  g connected path every
pair vertices g  connected component g maximal subgraph g
   

fia refined view causal graphs component sizes

connected  let g directed graph  g weakly connected u  g  connected 
weakly connected component g maximal subgraph g weakly connected 
is  weakly connected component paths every pair vertices
ignore direction edges  let g    vg   eg   h    vh   eh   two directed
graphs vg vh disjoint   disjoint  union g h defined
g h    vg vh   eg eh   commutative operation  note graph g
consists  weakly  connected components g            gn   g   g  g        gn  
define numeric graph parameters  directed graph g vertex
v v  g   indegree v   u v  g     u  v  e g     i e  number incoming
edges incident v  outdegree v   u v  g     v  u  e g     i e  number
outgoing edges incident v  undirected graph g  degree v v  g 
  u v  g     v  u  e g     i e  number edges incident v  extend
graphs follows  g undirected graph  deg g  denotes largest degree
vertex v  g   similarly  g directed graph in deg g  denotes largest
indegree vertex v  g  out deg g  denotes largest outdegree vertex
v  g   furthermore  g undirected graph  path length g  denotes length
longest path g cc size g  denotes size largest connected component
g  g directed graph  path length g  denotes length longest directed path
g  define upath length g    path length u  g   cc size g    cc size u  g   
is  upath length g  length longest path g ignoring direction
edges cc size g  size largest weakly connected component g  note
g undirected connected graph  path length g  equals diameter g 
extend numeric graph properties  in deg  path length etc   sets graphs
c set graphs prop graph property  prop c    maxgc prop g  
    special graph types
literature causal graphs  well article  certain types graphs
particular interest thus useful refer names  distinguish
following types undirected graphs  tree undirected graph two
vertices connected exactly one path  i e  acyclic connected  path graph
tree vertices degree      i e  tree branch  star
graph tree vertices except one  centre vertex  degree   
directed graphs  distinguish following types  in star graph directed
graph g u  g  star graph edges directed towards centre 
out star graph directed graph g u  g  star graph edges
directed centre  directed path graph directed graph g u  g 
path graph  in deg g    out deg g     i e  g directed path
vertices contains edges  polytree directed graph g u  g 
tree  i e  g weakly connected directed graph constructed tree
giving unique direction every edge  polypath directed graph g u  g 
path graph  i e  g weakly connected directed graph constructed
path graph giving unique direction every edge  fence polypath every
vertex either source sink  i e  edges alternate direction every vertex 
   

fibackstrom   jonsson

noted out star graph usually called directed star graph
graph theory  in star graph appears standard name  hence deviate
sligthly standard terminology order logical names graph types 
polypath appears standard name  polypath logical term
analogy polytree  noted parallel terminology certain
graph types evolved literature causal graphs planning  instance  instars  out stars directed paths commonly referred inverted forks  forks
directed chains  respectively 
note number sinks sources polypath differ one  i e 
polypath sinks   c sources c            furthermore  every fence
polypath  every polypath fence 
define following graphs graphs classes 
skin denotes in star graph one centre vertex k sources  define
class sin    skin   k    
skout denotes out star one centre vertex k sinks  define class
sout    skout   k    
dpk denotes directed path k vertices  define class dp    dpk     k  
c   c            denotes fence sinks   c sources  define
fm
c     m   c            class f   f  f  f    
class fc    fm

examples graph types illustrated figure   

v 
v 

v 
v 

vc
v 

v 

v 

v 

vc
v 

v 

v 

v 

v 

v 
u 

v 
u 

f  

v 

v 
s out

s in

v 

dp 

v 
u 

v 
u 

v 
u 

v 
u 

f  

v 
u 

v 
u 

u 

f   

figure    examples important graph types 
following observation polypaths used later on 
proposition    let g polypath sinks     sources
path length g  k   v  g    mk     
   

fia refined view causal graphs component sizes

proof   m distinct paths source sink 
k   intermediate vertices  hence  v  g      m         m k       mk     
bound obviously tight case sinks     sources 
every path source sink contains exactly k   intermediate vertices 

   structurally restricted planning
topic study article causal graphs planning  discussing
concept first define concept domain transition graphs  jonsson   backstrom 
    a   although used explicitly results  useful explaining
proofs later article  let    v  init  goal  a  planning instance 
variable v v   define domain transition graph  dtg  v directed graph
 d v   e   x  d v   e contains edge  x  y  operator
post a  v    either pre a  v    x v   vars pre a   
causal graph planning instance describes variables instance
depends other  implicitly defined operators 
definition    causal graph planning instance    v  init  goal  a  directed
graph cg      v  e  e contains edge  u  v  every pair distinct vertices u  v v u vars pre a   vars post a   v vars post a  
operator a 
causal graph gives some  all  information operators  instance 
causal graph acyclic  operators must unary  i e   vars post  a      
operators  since non unary operator must necessarily introduce cycle according
definition  however  presence cycles necessarily mean
non unary operators  instance  edges  u  v   v  u  present
graph  mean operator u vars post a  
v vars post a    however  mean two operators a 
u vars pre a    v vars post a    v vars pre a     u vars post a      could
thus unary operators  similarly  degree vertices provides upper bound
number pre  postconditions operators  lower bound  suppose
vertex u indegree   incoming edges  v  u   w  u   could mean
operator u vars post a   v vars pre a  
w vars pre a    however  mean two different operators a 
v vars pre a    u vars post a    w vars pre a     u vars post a     
planexist problem extended planning instances causal graphs
following way  class c directed graphs  planexist c  problem deciding
arbitrary planning instance cg   c  whether solution
not  is  complexity planexist c  refers complexity set planning
instances whose causal graphs members c 
number results literature computational complexity
planning various classes causal graphs  however  results usually assume
graph class restricted structure  e g  containing in stars directed
paths  general abstract result following theorem 
   

fibackstrom   jonsson

theorem     chen   gimenez        thm       let c class directed graphs 
cc size c  bounded  planexist c  solvable polynomial time  cc size c 
unbounded  planexist c  polynomial time solvable  unless w    nu fpt  
theorem describes crisp borderline tractable intractable graph
classes  assumption w      nu fpt    complexity
classes theory parameterised complexity cannot immediately related
usual complexity classes  scope article treat parameterised
complexity refer reader standard textbooks  downey   fellows        flum
  grohe         result theorem parameterised result  however 
condition parameterised  suffices note intractability result holds
condition difficult relate common assumptions  p    np 
one reasons chen gimenez forced state theorem way
classification polynomial np hard classes would exhaustive 
since graph classes np intermediate   a problem np intermediate
neither p np complete  unless p   np  
theorem might viewed starting point research reported
article  investigate problem perspective standard complexity
classes  instance  np hardness proved case unbounded components
adding restrictions  section   

   basic constructions
section presents results necessary theorems later article 
first three results  planning np hard in stars  aka  inverted forks   out stars
 aka  forks  directed paths  aka  directed chains   known literature 
np hardness result fences new  will  however  provide new proofs
in star out star cases  major reason section   need refer
reductions certain precisely known properties  furthermore  original proofs
published technical report  domshlak   dinitz      b  may thus hard
access 
lemma     domshlak   dinitz      a  thm    iv  planexist sin   np hard  result
holds even restricted operators   preconditions   postcondition 
proof   new proof  proof reduction  sat class planning instances
causal graphs sin   reduction constructs planning instance source
causal graph corresponds one variables formula centre corresponds
clauses  construction illustrated figure   formally defined follows 
let f   c        cm arbitrary  sat formula variables x            xn clauses
c            cm   construct corresponding planning instance f    v  init  goal  a  follows 
v    vc   v            vn   
d vc                 m 
d vi      u  f  t      n  
   condition simplified w      fpt class c recursively enumerable 

   

fia refined view causal graphs component sizes

vc
 

 

 


u


u


u

f
v 



f
v 

f
vn

figure    in star causal graph dtgs construction proof
lemma   

init vi     u     n   init vc       
goal vc     goal otherwise undefined 
consists following operators 
   n   contains operators
set f i    hvi   u   vi   f
set t i    hvi   u   vi   ti 
clause ci      i   i   i   j    j     k
 ji   xk  ji   xk   let contain either operator
verify clause pos i  j    hvc      vk     vc   ii   ji   xk  
operator
verify clause neg i  j    hvc      vk   f   vc   ii   ji   xk  
clearly  instance f constructed polynomial time cg f     snin  
remains prove f solution f satisfiable 
source variable vi changed independently  starts undefined
value u set either f   corresponding true false  respectively 
corresponding variable xi f   set either f   cannot changed again 
is  variables v            vn used choose commit truth assignment
x            xn   centre variable vc one value  i  clause ci f   plus initial
value    possible reach goal value inital value   stepping
   

fibackstrom   jonsson

intermediate values numerical order  step    i 
three operators choose from  corresponding literals clause ci   step
possible one v            vn set value consistent one literals ci  
is  goal vc   achieved variables v            vn set values
corresponding truth assignment x            xn satisfies f  
restricted case  with respect pre  post conditions  immediate
construction above 
problem known tractable  though  domain size centre variable
bounded constant  katz   domshlak         furthermore  causal graph heuristic
helmert        based identifying in star subgraphs causal graph 
noted provided variant original proof due minor technical
differences problem formulations 
lemma     domshlak   dinitz      a  thm    iii  planexist sout   np hard  result
holds even restricted operators   precondition   postcondition 
proof   new proof  proof reduction  sat class planning instances
causal graphs sout   reduction constructs planning instance centre vertex
causal graph corresponds variables formula sink corresponds
one clauses  construction illustrated figure   formally defined
follows 
v 

u

v 

vm



u



u

t 

t 

t 

tn

f 

f 

f 

fn



vc

figure    out star causal graph dtgs construction proof
lemma   

let f   c        cm arbitrary  sat formula variables x            xn clauses
c            cm   construct corresponding planning instance f    v  init  goal  a  follows 
   

fia refined view causal graphs component sizes

v    vc   v            vm   
d vc      f            fn   t            tn  
d vi      u  s      m  
init vi     u     m   init vc     f   
goal vi     s     m   goal vc   undefined 
consists following operators 
   n   contains operators
step c fi        hvc   fi    vc   i 
step c fi    ti     hvc   fi    vc   ti i 
step c ti        hvc   ti    vc  
step c ti    ti     hvc   ti    vc   ti i 
clause ci      i   i   i   j    j     k
 ji   xk  ji   xk   let contain either operator
verify clause pos i  j    hvc   tk   vi   si   ji   xk  
operator
verify clause neg i  j    hvc   fk   vi   si   ji   xk  
clearly  instance f constructed polynomial time cg f     snout  
remains prove f solution f satisfiable 
variable vc changed independently two values  ti  
variable xi f   corresponding possible truth values xi   addition
initial value f   and dummy value t  order simplify formal definition  
values tn fn reachable initial value f    plan correspond
path f    z    z            zn zi either ti   is  vc must pass either value
ti   both  i  hence  path correspond truth assignment
variables x            xn f   clause ci f   corresponding variable
vi change value initial value u  unsatisfied  goal value s  satisfied 
vi three operators this  one literal ci   is  ci contains
literal xk  or xk   vi change value u vc value tk  or fk   
hence  goal v            vm   achieved path vc
corresponds truth assignment x            xn satisfies f    note  though 
vc must always follow path way fn tn since partial assignment may
sometimes sufficient prove satisfiability  
restricted case  with respect pre  post conditions  immediate
construction above 
problem known tractable  though  domain size centre variable
bounded constant  katz   keyder        
following result planning directed path causal graphs known
literature 
lemma     gimenez   jonsson        prop       planexist dp  np hard  even
variables domain size   operators   preconditions   postcondition 
   

fibackstrom   jonsson

refer gimenez jonsson proof  however  implicitly use
proof later article important observations make it 
reduction sat and  thus  works reduction  sat  furthermore 
reduction transforms formula n variables clauses planning instance
  m     n variables  final remark  problem known tractable variables
domain size    domshlak   dinitz      a  
three previous results known literature  following result new
best knowledge 
lemma    planexist f     np hard  result holds even restricted operators
  preconditions   postcondition 
proof  proof reduction  sat class planning instances causal graphs
f    
reduction constructs planning instance sink causal graph corresponds one clauses formula  source corresponds variables 
furthermore  source variables synchronized behaviour  construction illustrated figure   formally defined follows 
let f   c        cm arbitrary  sat formula variables x            xn clauses
c            cm   construct corresponding planning instance f follows 
v    u            um   v            vm   
d ui      f            fn   t            tn       m  
u   tu           tu   f         f   ts           ts   s      m  
d vi      f u           fm
 
 

 
init ui     f       m   init vi     f u      m  
goal vi     s     m   goal otherwise undefined 
let consist following operators 
i  j    n    j m   contains operators
step x j  fi        huj   fi    uj   i 
step x j  fi    ti     huj   fi    uj   ti i 
step x j  ti        huj   ti    uj  
step x j  ti    ti     huj   ti    uj   ti i 
i  j     n    j m   contains operators
u
u   f u     hv   f u   u
step clause u j  fi 
j
i  j      uj     vj   i 

u
u
u
u
step clause u j  fi    ti     hvj   fi    uj    ti   uj   ti   vj   ti i 
step clause u j  tui    fiu     hvj   tui    uj      uj     vj   fiu i 
step clause u j  tui    tui     hvj   tui    uj    ti   uj   ti   vj   tui i 
  f     hv   f   u

step clause s j  fi 
j

i  j      uj     vj   i 
  ts     hv   f   u

step clause s j  fi 
j

i  j    ti   uj   ti   vj   ti i 



step clause s j  ti        hvj   ti    uj      uj     vj   fis i 
step clause s j  tsi    tsi     hvj   tsi    uj    ti   uj   ti   vj   tsi i 
j    j m   contains operators
finalize clause f j    hvj   fns   vj   si
finalize clause t j    hvj   tsn   vj   si 
   

fia refined view causal graphs component sizes

vi 

vi  

vi
tu 

tu 

tu 

tun

f u

f u

f u

fnu

x  ci

x  ci

ts 

ts 

ts 

tsn

f s

f s

f s

fns



t 

t 

t 

tn

t 

t 

t 

tn

f 

f 

f 

fn

f 

f 

f 

fn

ui 

ui

figure    fence causal graph dtgs construction proof
lemma     this example assumes clause ci contains literals x  x    

clause ci      i   i   i   j    j     k
 ji   xk  ji   xk let contain either operator
verify pos i  j    hvi   tuk   vi   tsk i   ji   xk  
operator
verify neg i  j    hvi   fku   vi   fks i   ji   xk  
     hence 
clearly  instance f constructed polynomial time cg f     fm
remains prove f solution f satisfiable 
first consider variables ui vi   i  construction domain
operators ui identical one vc proof lemma    i e 
directed path value f  fn tn every possible truth assignment variables
x            xn f   variable vi   corresponds clause ci contains two copies dtg
ui   values differ extra superscript  u s  latter copy extended
additional value s  denoting clause satisfied  operators
allows vi mimic behaviour ui   follow corresponding path either
two copies  furthermore  three literals ci operator

   

fibackstrom   jonsson

makes possible move value zku value zks value zk ui consistent
ts order reach goal value
literal  since vi starts f u must reach either fm

s  necessary vi make transition one literals ci   is  ui
follows path f    z            zn vi must follow path f u   z u           zku   zks           zns   s 
k xk occurs literal ci zk satisfying truth value literal 
consider variable ui    since operator affects value vi either
precondition ui  ui precondition either  follows
ui  ui must choose path vi reach goal  since every variable vj
forces synchronization adjacent variables uj  uj manner  follows
u            um must choose exactly path plan solution  thus
follows argument ui vi goal v            vm  
achieved path u            um choose
path corresponds satisfying truth assignment f  
restriction  first note immediate construction operators
  preconditions   postcondition sufficient  see   preconditions
sufficient  consider following variation construction  step clause u stepclause t operator replaced two operators follows  example  consider
u   tu    first introduce extra value f tu d v    replace
operator step clause u j  fi 
j


operator two new operators
u   f tu     hv   f u   u
u
step clause u j  fi 
j

i  j    ti   vj   f ti
step clause u j  f tui   tui     hvj   f tui   uj   ti   vj   tui i 
u
consider step dtg vj fi 
tui   original construction 
u   tu    requires u
done single operator step clause u j  fi 
j  uj

u
value ti   modified construction instead requires two steps  first step fi 
u
u
new intermediate value f ti step value ti   previous
conjunctive constraint uj    uj   ti replaced sequential constraint first
uj    ti uj   ti   although technically possible uj  moved
new value second step taken  matter  uj  uj must
still choose exactly path respective dtgs 
corollary    planexist f     planexist f    planexist f  np hard 
proof  neither two outer source vertices  u  um   necessary construction
previous proof  hence  omitting either reduction works
f  f    finally  planexist f  np hard since f   f 
basic results necessary main theorems following
two sections 

   graph classes closure properties
results literature  results previous section classes
consisting particular graph type  class sin in stars class f
fences  section depart instead study graph classes certain
closure properties  first discuss standard concepts subgraph closure minor
closure  finding first contain graphs need latter results
   

fia refined view causal graphs component sizes

set many graphs  reason  define new concept  sp closure 
incomparable subgraph closure subset minor closure 
show closure concept defines borderline non np hard graph classes
large number useful np hard classes 
    subgraph closure minor closure
suppose c class graphs closed taking subgraphs  every graph
g c case every subgraph h g must c  subgraph closure
sufficient purposes  though  instance  subgraph polypath always
either polypath graph every weakly connected component polypath 
however  polypath need subgraphs fences trivial size 
need closure property guarantees c contains polypath sinks 
contains fence sinks  obvious candidate concept
minor closure  superset subgraph closure  concepts graph minors
minor closure rapidly evolved important useful research area
mathematical well computational graph theory  lovasz        mohar        
order define graph minors first need concept edge contraction 
commonly defined follows  although definitions occur literature 
definition    let g    v  e  directed graph let e    u  v  e edge
u    v  contraction e g results new graph g     v     e     
v      v    u  v    w 
e       f  x   f  y      x  y  e   x  y      u  v   x  y      v  u   
w new vertex  v   function f   v v   defined
f  u    f  v    w otherwise f  x    x 
is  edge  u  v  contracted  two vertices u v replaced
single new vertex w edges previously incident either u v
redirected incident w  figure   shows example edge contraction  say
graph h contraction another graph g h result contracting zero
edges g 
concept graph minors defined follows 
definition     directed graph h minor directed graph g h isomorphic
graph obtained zero edge contractions subgraph g 
example illustrated figure    graph g figure weakly connected
directed graph  happens polypath  vertex v  removed g 
restriction remaining vertices still weakly connected graph
subgraph g  removing v  results graph h  consists two weakly
connected components h  h    h  h  h  subgraphs g 
minors g  since subgraph minor  definition  contracting edge  v    v   
h  results graph m    w  new vertex replacing v  v    similarly 
contracting edge  v    v    h  results m    graph m  minor g since
   

fibackstrom   jonsson

v 

v 
v  

v 

v  
v 

v 
v 

v 

v 

v 

v 

v 

w

v 

v 

v 

a  graph g

v 

v 

b  result contracting edge  v    v    g 

figure    edge contraction 

result edge contraction subgraph h  g graph m  analogously
minor g too  graph   consisting two components m  m 
minor g  since result two contractions subgraph h g 
graphs h  h  h  subgraphs minors g  graphs   m  m 
minors g  subgraphs 

v 
v 
v 

v 
v 

v 
v 

v 
v 

v 

a  polypath

v 

v 
v 

g

v 

v 
v 

w 

v 
m 

v 
h 

v 
w 
m 

h 

b  subgraph h g
 where h   h  h   

c  minor g
 where   m  m   

figure    subgraphs minors 

trivial example minor closed class class graphs  minor closed
since contains graphs every minor graph graph  interestingly 
many commonly studied graph types result minor closed classes  instance  class
sin in stars minor closed  class sout out stars class dp
   

fia refined view causal graphs component sizes

directed paths  furthermore  weakly connected minor polypath polypath
weakly connected minor polytree polytree  illustration  consider
figure    graph g polypath  weakly connected graphs h    h    m 
m  minors g  polypaths  fact  m  m  fences 
note though  neither h polypath  since consist one
weakly connected component  worth noting  however  class f fences
minor closed although every fence polypath  weakly connected minor fence
must polypath  necessarily fence 
requiring minor closed graph classes is  however  overly strong  instance  would
sufficient require every graph g c  every weakly connected minor g
c  is  example figure   would require h    h    m  m 
c g c  would require h c 
reasonable desirable context causal graphs  causal graph planning
instance consists two weakly connected components  components
correspond entirely independent subinstances solved separately 
furthermore  certain natural restrictions mix well minor closed classes 
consider  instance  example figure    acyclic graph g    v  e  
v    v    v    v    v    e     v    v      v    v      v    v      v    v      contract edge
 v    v    new vertex w get cycle graph vertices w  v    v    is  class
acyclic graphs minor closed general  problematic considering importance acyclic causal graphs 

v 

v 

v 

v 

v 
w

a  acyclic graph g

v 
b  contraction  v    v    g 

figure    contracting edge acyclic graph result cycle 

    sp closed graph classes
order avoid problems acyclicity  and similar problems  avoid defining
special variants contraction minor concepts  instead identify set minimal
requirements closure must satisfy order imply np hardness planexist
problem  focus one set restrictions  defining concept refer
sp closure  where sp denotes set closed stars polypaths  
definition     let g h two directed graphs  h sp graph g h
weakly connected either following holds 
   h in star subgraph g 
   

fibackstrom   jonsson

   h out star subgraph g
   h obtained zero contractions polypath g  g 
subgraph g 
class c graphs sp closed contains every sp graph every graph g c 
sp closure number interesting properties  including following 
proposition     let g h directed graphs let c class directed graphs 
   g polypath  every sp graph g polypath 
   every sp graph g acyclic 
   h sp graph g  h minor g 
   c minor closed  c sp closed 
proof     suppose g polypath  obviously  g cannot contain in star out star
higher degree two  star polypath  hence  need
consider third case definition  note weakly connected subgraph g 
g must polypath  contractions polypath results polypath 
   immediate since in stars  out stars polypaths acyclic contracting edges
cannot introduce cycle cases 
   immediate definitions minors sp graphs 
   immediate   
proposition says makes sense talk sp closed classes polypaths
sp closed classes acyclic graphs  says sp closure minor closure
comparable concepts  sp closure class subset minor closure
class 
prove following result sp closed classes polypaths 
need main theorem 
lemma     let c sp closed class polypaths  cc size c  unbounded 
planexist c  np hard  result holds even restricted operators
  preconditions   postcondition 
proof  proof cases depending whether directed path length c bounded not 
case    suppose path length c  unbounded  let n     arbitrary integer 
must graph g c g contains subgraph h directed
path graph v  h    n  obviously  h sp graph g  since directed path
polypath  follows h c since c sp closed  furthermore  h   dpn
np hardness planexist c  follows lemma    since n choosen arbitrarily 
case    instead suppose path length c  k constant k    let n    
arbitrary integer  since graphs c polypaths cc size c  unbounded 
must polypath g c v  g  n  thus follows assumption
proposition   g must least sinks     sources 
   

fia refined view causal graphs component sizes

v  g   mk      must  thus  subgraph g  g polypath
exactly sinks     sources  i e  g  weakly connected  must  thus 
    
graph h obtained zero contractions g  h   fm
follows h c since c sp closed  np hardness planexist c  thus follows
lemma    since n choosen arbitrarily k constant 
see result holds even operators consideration  
preconditions   postcondition  simply note restriction holds reductions
used underlying np hardness proofs section   
chen gimenez        thm        proved similar result  c class polypaths 
unbounded components unbounded number sources  planexist c 
polynomial time solvable unless w    nu fpt 
order prove main result section  need moore bound  biggs 
      p        stated follows  arbitrary connected undirected graph g 
maximum number vertices
 v  g      

k 
x

 d   i  

   

i  

  deg g  k   path length g  
prove additional restriction graph classes spclosed  avoid np intermediate problems prove np hardness graph classes
unbounded components 
theorem     let c sp closed class directed graphs  cc size c  unbounded 
planexist c  np hard  result holds even restricted operators
  preconditions   postcondition graphs c acyclic 
proof  first suppose constant k in deg c  k  out deg c  k
upath length c  k  consider arbitrary graph g c  obviously  deg u  g    k
path length u  g   k  p
follows moore bound component u  g 

     k k 
i     k    vertices  however  since cc size g    cc size u  g  
g choosen arbitrarily  follows cc size c  bounded  contradicts
assumption least one in deg c   out deg c  upath length c  unbounded 
remainder proof three  possibly overlapping  cases 
case    suppose in deg c  unbounded  let n     arbitrary integer 
must graph g c containing vertex indegree n more  must
subgraph h g h   snin   hence  h c since c sp closed  thus
follows lemma   planexist c  np hard  since n choosen arbitrarily 
case    suppose out deg c  unbounded  case analogous previous
one  using lemma   instead lemma   
case    suppose upath length c  unbounded  let n     arbitrary integer 
must graph g c u  g  contains path length n 
must  thus  subgraph h g h polypath length n  obviously  h
   chen gimenez use term source sink configuration polypath 

   

fibackstrom   jonsson

sp graph g  doing zero contractions  h c since c sp closed  thus follows
lemma    planexist c  np hard  since n choosen arbitrarily 
see result holds even operators consideration  
preconditions   postcondition  simply note restriction holds reductions
used underlying np hardness proofs section    similarly  acyclicity restriction
holds since result based in stars  out stars polypaths 
acyclic graphs 
theorem somewhat restricted one chen gimenez since
requires additional constraint c sp closed  hand  demonstrates
sp closure sufficient condition avoid graph classes planexist npintermediate and  thus  sharpen result np hardness  noted  though 
exact characterization graph classes np hard planexist 
graph classes  sp closure captures large number interesting
graph classes  instance  class acyclic graphs sp closed  recall class
minor closed   although every subclass sp closed  opposite example 
non empty class contain single acyclic graph cannot sp closed 

   beyond sp closed graph classes
section divided three parts  first discuss previous results  well
similar np hardness results literature  problematic  motivates
us switch non uniform complexity theory  second part contains number
preparatory results required main theorem third part 
    np hardness enough
refer planning problem generic instances varying size  depending
one parameters  archetypical example blocks world  natural
parameter number blocks  particular encoding specified number
blocks  variables operators whatever inital state goal is 
is  fix encoding get planning frame n    vn     every number 
n  blocks  is  n instances n blocks thus function
n  instances  vn   init  goal    n blocks instantiations n different
init goal components vn components  instance thus
specified three unique parameters  n  init goal  first parameter 
n  affects size instance  furthermore  causal graph instance depends
variables operators  means instantiations frame n
causal graph  denote cg n    class causal graphs blocks
world instances    cg      cg      cg              although                   
thus d  differ depending encoding 
often possible analyse complexity particular generic planning problem 
examples complexity blocks world planning  gupta   nau       
complexity various problems international planning competitions  ipc 
 helmert            b   context article  though  rather interested
complexity class causal graphs corresponding generic problem 
   

fia refined view causal graphs component sizes

complexity specific problem itself  suppose class causal graphs
happens subset class c graphs know planexist c 
tractable  infer planexist d  tractable  thus
generic planning problems causal graphs tractable  however  order
prove planexist d  np hard  or hard complexity class  would
prove class c graphs planexist c  np hard c
subset d  finding class c may trivial  though 
one problem encoding large influence densely sparsely
causal graphs occur respect size  consider  instance  blocks world encodings
multi valued variables boolean variables respectively  typical encoding
multi valued variables use one variable status hand two variables
block  one position block one flag whether block clear
not  is  encodings use  n     variables n block frame  encoding
boolean variables  hand  typically represent block position
number boolean variables  one block block on  boolean
encoding thus use n      variables n block frame  contain graph
every odd number vertices first case  increasingly sparse second
case  class causal graphs generic planning problem will  thus  typically
sp closed  even closed taking subsets  furthermore  since typically
contain member every possible number vertices  cannot possibly contain
known np hard sets sin   sout   dp etc  subset  hence  order prove
class causal graphs hard np  or complexity class   often
necessary make dedicated proof d  often doable  however  generic
planning problem corresponding function f takes parameter value n  e g 
number blocks blocks world  f  n    n   f furthermore polynomialtime computable value n  often case  corresponding
causal graph  cg n    polynomial time computable  however  even done
many generic planning problems  specific proof every specific encoding
every particular generic planning problem  holds particular classes causal
graphs  every specific class typically require dedicated proof 
order get around problems able prove general result
depend specific planning problems causal graphs  switch nonuniform complexity  makes possible prove powerful results  retaining
natural connections ordinary complexity classes  basic vehicle proving nonuniform complexity results advice taking turing machine  defined follows 
definition     advice taking turing machine associated sequence advice
strings a    a    a           special advice tape advice function a  natural
numbers advice sequence  s t  a n      input x advice tape immediately
loaded a   x     continues ordinary turing machine  except
access advice written advice tape 
exists polynomial p s t    a n    p n   n      said use
polynomial advice  complexity class p poly set decision problems
solved advice taking tm runs polynomial time using polynomial advice 
   

fibackstrom   jonsson

note advice depends size input  content  need
even computable  somewhat simplistically  advice taking turing machine
machine infinite data base constant access time  however  input
size polynomial amount information might exponential
number instances sharing information  power polynomial advice thus still
somewhat limited useful relationships known non uniform complexity
classes relate standard ones known  one result following 
theorem      karp   lipton        thm       np p poly  polynomial
hierarchy collapses second level 
    preparatory results
carrying main theorem section  need auxiliary results 
first show planning instance causal graph g subgraph graph
h  instance extended equivalent instance h causal graph 
lemma     let planning instance let g directed graph cg  
subgraph g  planning instance g
g constructed polynomial time 
cg g     g
g solution solution 
furthermore  g maximum number pre  postconditions operators
 or one value zero   
proof  let    v  init  goal  a  planning instance let cg      v  e   let
g    vg   eg   directed graph cg   subgraph g  let u   vg   v  
construct planning instance g    vg   initg   goalg   ag   follows 
dg  u            u u  
dg  v    d v       v v    where   new value d v   
initg  v    init v   v v  
initg  u       u u  
goalg  v    goal v   v v  
goalg  u  undefined u u  
let ag consist following operators 
let ag contain a 
edge  x  v  eg   e x vg v v   let ag contain
operator star x  v    hx       v    i 
edge  x  u  eg x vg u u   let ag contain
operator set x  u    hx   init x    u    i 
   

fia refined view causal graphs component sizes

obviously g constructed polynomial time cg g     g  remains
prove g solution solution 
suppose p   a            plan   p plan g since goalg  u 
undefined u u a            ag   contrary  suppose p   a           
plan g   operator ai p   three cases      ai a      ai set
operator     ai star operator  case    operator ai serves purpose since
modifies variable u   undefined goal value  case    operator ai sets
variable v v   effect variables  goalg  v  undefined 
ai serves purpose  otherwise must operator aj   j   i  aj
change v   value d v   i e  ai serves purpose case either 
follows operator sequence p   obtained p removing operators
plan g   furthermore  since p   contains operators
plan   follows plan g plan 
construction increases maximum domain size one little effect
maximum number pre  postconditions  suitable purpose  since
consider influence domain sizes article  constructions
possible want balance various factors differently 
proof forthcoming theorem opposite taking graph
minors  is  starting minor g target graph h extend g h 
order so  need operation similar opposite edge contraction 
satisfied graph operation known edge subdivision 
definition     let g    v  e  directed graph let  u  v  e edge
u    v  subdivision  u  v  g graph g     v  w   e     w new
vertex e      e     u  v      u  w    w  v   
although one might consider definitions  e g  case  u  v 
 v  u  e  one sufficient purpose follows usual extension
directed graphs  cf   kuhn  osthus    young         usually operation called smoothing
considered inverse edge subdivision  however  smoothing viewed
restricted case edge contraction  reasonable think edge subdivision sort
inverse edge contraction  example edge subdivision illustrated figure   
note edge contraction polypath polypath  edge
subdivision polypath polypath 
need operation planning instances corresponding edge subdivision
causal graphs  purpose  need concept variable substitution
operators  denote substitution variable w variable v partial state
a v w   defined as 

x   w 
s v  
s x  
x vars s     v  w  
s v w  x   

undefined  otherwise 
operator  operator a    a v w  defined pre a      pre a  v w 
post a      post a  v w  
   

fibackstrom   jonsson

v 

v 
v  

v 

v  
v 

v 
v 

v 

v 

v 

v 
v 

a  graph g

v 

v 
v 

w

v 

v 
v 

v 

b  result subdividing edge  v    v    g 

figure    edge subdivision 

necessary concepts modifying arbitrary planning instance
result corresponds subdividing edge causal graph instance 
however  need instances causal graph polypath 
proving done  first need following lemma  states
certain reordering property plans causal graph polypath  choose
arbitrary vertex v polypath g remove v g  g falls apart two weakly
connected components c  c    words  vertices g partitioned
three sets c    c  c  c     v  edge directly
vertex c  vertex c    follows definition causal graphs
operator changes variable c  precondition variable
c  vice versa  following lemma utilises fact prove sequence
operators change variable v reordered operators
change variables c  come operators change variables c   
lemma     let    v  init  goal  a  planning instance g   cg  
polypath  let v arbitrary variable v   let c     v  let c    c  v two
 possibly empty  weakly connected components g result vertex v removed
g  define ai    a   vars post a   ci          let p plan  
let p    p  q operator sequences p   p    q  p  q contains operator
a    let q  subsequence q containing operators a  let q 
subsequence q containing operators a    p    q    q    p  plan
 
proof  assume c    c  c  defined lemma recall c     v   first
note g acyclic since polypath  operators unary  follows
 a    a    a    partition and  thus  a  a  a    a  let s    init p    
obviously   vars pre a  c     vars post a  c    q   vars pre a  c   
 vars post a   c    q    i e  state holds s a  c    c 
q  s a  c    c  q    furthermore  state holds
   

fia refined view causal graphs component sizes

s a  v    s v  q  since   a    follows s   q  c    s   q    c 
s   q  c    s   q    c    hence 
s   q    q    c    s   q  c   
s   q    q    c    s   q    c    s   q  c 
s   q    q    c    s   q    c    s   q  c   
is  s   q    q      s   q  follows p    q    q    p  plan  
prove planning instance cg   polypath 
subdivide edge cg   create planning instance   cg    
subdivision cg     solvable solvable 
lemma     let planning instance cg   polypath let e
edge cg    planning instance  
  constructed polynomial time 
cg     edge subdivision e cg  
  solution solution 
proof  let    v  init  goal  a  planning instance cg   polypath
let e    u  v  edge cg    construct new instance      v     init    goal    a   
follows 
v     v  w   d w    d u  w   v  
init   v    init v   v v  
init   w    init u  
goal    goal 
let a  consist following groups operators 
   let a  contain operators u   vars pre a   v   vars post a   
   let a  contain operator a u w  every operator
u vars pre a   v vars post a   
   let a  contain operator copy u  w  x    hu   x   w   xi every value
x d v  
operators group   original operators corresponding edges
cg   except  u  v   operators group   operators corresponding
edge  u  v  modified instead correspond new edge  w  v   operators
group   correspond new edge  u  w  defined variable w
mimic variable u  clearly  polynomial time construction cg     edge
subdivision cg    remains prove   plan plan 
if  suppose p   a            plan   construct new operator sequence p  
a  p follows  first  ai p u vars pre ai    v
vars post ai     replace ai ai  u w   then  ai p u vars post ai    
   

fibackstrom   jonsson

let x   post ai   u  add operator copy u  w  x  ai ai     resulting
sequence p   plan    
if  suppose p   a            plan     define corresponding state sequence
s            sn s    init  si   s   a            ai      n   without losing
generality  assume p shortest plan     implies ai applicable
si  every    n   define three variable sets c    c  c  lemma   
c     w   v c  u c    define corrsponding partition  a    a    a   
a    i e  ai    a a    vars post a   ci          a  contains copy
operators nothing else  proving main result direction  first prove
following auxiliary result 
according lemma    assume every longest subsequence ak           a 
contain operator a  form ak             am             a 
ak           a  am             a  a    since longest sequence  must
hold either     k         ak  a    case     sk    s    init   
sk   u    sk   w  since init   u    init   w   case     operator ak    copy u  w  x 
x sk   w    sk   u    x  hence  sk   u    sk   w    x since ak 
change u  is  either case sk   u    sk   w   furthermore 
 k m  holds si  c  c      sk   c  c    since ai a    follows
si  u    si  w   k m   now  every  k     w vars pre ai   
ai must form a u w   a  v vars pre ai    definition  hence 
ai a  follows si   u    si   w   since proof holds longest
subsequences containing operator a  conclude following 
used below 
    operator ai p ai   a u w  a  holds
si   u    si   w  
prove main result direction  plan since  
plan  constructing plan p    p two steps  first construct
intermediate operator sequence p   construct plan p    p     sequence
p   technically plan either     intermediate step makes proof
clearer  temporarily introduce virtual dummy operator dum precondition
postcondition  i e  applicable state effect  construct
new operator sequence p     b            bn  dum  follows 
ai a  bi   ai  
ai copy operator  bi   dum 
otherwise  ai   a u w  operator a  let bi operator a 
define corresponding state sequence t            tn t    init  ti   t   b            bi  
   n   claim ti v   si v    n   proof induction
i 
basis  t    s  definition 
induction  suppose ti  v   si  v    n   three cases 
    ai   bi ai a  w pre  postcondition either ai bi
bi applicable ti  since ai applicable si  ti  v   si  v assumption 
furthermore  ti v   ti   bi   v   si   ai   v   si v  
   

fia refined view causal graphs component sizes

    ai copy operator bi   dum  immediate definition bi
applicable ti  ti   ti    furthermore  vars post ai    v  
si v   si  v   since ti  v   si  v assumption thus follows ti v   si v  
    ai bi  u w  bi a  follows     si   w    si   u   si   w   
ti   u  since u v ti  v   si  v assumption  since ai applicable si   
pre ai   w    pre bi   u  pre ai   x    pre bi   x  variables v   u   follows
bi applicable ti    definition  vars post bi      vars post ai       v   since ai
bi must unary  thus follows definition post bi     post ai   
hence  follows ti v   si v   since ti  v   si  v assumption 
thus shown ti v   si v    n   furthermore  clearly
ti   ti  bi   dum  follows create plan p   
removing dummy operators p    
conclude solution   solution 
finally need following observations  sat instances  let f  sat
formula n variables clauses  contains repeated clauses 

n
 n  and  thus         n  m 
 
 
furthermore  f represented list  m literals requires  m     log n 
 m     log  m  bits  plus overhead  hence  f represented cm  bits 
constant c  later use upper bound   m    safe 
note reduction used proof lemma   transforms  sat
instance n variables clauses planning instance n     m     n
variables  however  n  m n   m       m    m      m  safely
overestimated n   m   
    main theorem
prepared state prove main theorem section  follows
proof theorem    in deg c   out deg c  upath length c  bounded
class c graphs  cc size c  bounded  case immediate theorem  
planning tractable c  begs question happens parameters
bounded constant  yet bounded slow growing function  consider
case allowed grow slowly  long polynomially related
instance size  since noted practical planning problems typically
causal graph every size  require every graph g c
must larger graph g  c size p  g    polynomial p 
define parameter  g    max upath length g   in deg g   out deg g    require
 g    g   polynomially related  turns planning still hard
restrictions  following theorem says 
theorem     let p q increasing polynomials natural numbers  let c
class directed graphs containing subset weakly connected graphs g    g    g         
that 
    v  g     p q     
 v  gi        v  gi    p  v  gi           
   

fibackstrom   jonsson

    v  gi    q   gi       
planexist c  polynomial time solvable  polynomial hierarchy collapses  result holds even restricted operators   preconditions   postcondition
graphs c acyclic 
proof  let g    g    g          sequence weakly connected graphs c assumed
theorem  let h    h    h          sequence graphs defined follows      
hi   gj smallest j q i   v  gj    
first prove underestimates  hi    combining requirement q i 
 v  gj    condition   theorem   v  gj    q   gj     get q i   v  gj   
q   gj     since hi   gj get q i   v  hi    q   hi     is   hi   
follows  v  hi    holds 
prove  v  hi    polynomially bounded p q i    since j choosen
smallest value satisfying q i   v  gj     must either j      v  gj      
q i   j      hi   gj   g   v  g     p q     condition   theorem 
hence   v  hi       v  g     p q     p q i    since p q increasing  otherwise 
j      condition   lemma says  v  gj    p  v  gj       combining
inequality  v  gj       q i  yields  v  gj    p  v  gj        p q i   
is   v  hi    p q i   since hi   gj   combining previous result
 v  hi    construction hi yields h    h    h  sequence graphs
non decreasing unbounded size 
now  define sequence a    a    a          tuples    either
following holds 
   in deg hi   ai    in deg  hi   xi   xi subgraph hi xi   siin  
   out deg hi   ai    out deg  hi   xi   xi subgraph hi
xi   siout  
   upath length hi   ai    upath length  hi   xi   xi subgraph hi
xi polypath length i 
every      least one three cases must hold since  hi   
define advice taking turing machine uses sequence a    a    a         
advice takes  sat formulae input  assume representation formula
f padded size   m  bits  number clauses  although somewhat
redundant  still reasonable encoding sense garey johnson        
let work follows  let f input formula n variables clauses
let     f        m    advice    x  ht   xt    first constructs planning
instance f   three cases depending x 
x   in deg  construction  xt subgraph ht ht   stin   since     m 
n  m  follows n t  xt contains subgraph h   h     snin  
construct f way proof lemma    using vertices h  
variables  then  cg f     h    
x   out deg  analogous previous case  constructing f according proof
lemma   instead 
   

fia refined view causal graphs component sizes

x   upath length  construction  xt subgraph ht polypath length
    m    suppose xt contains less sinks     sources
path length xt       m    follows proposition  
 v  xt       m   m          m          m    t 
however  contradicts construction xt must either contain directed path
length   m  least sinks     sources 
   xt contains subgraph h   directed path length   m   
construct planning instance f according proof lemma    using
vertices h   variables  then  cg f     h    
   xt contains subgraph h   polypath sinks m   sources 
construct planning instance
f according proof lemma    us 
  
ing variables h variables  then  cg 
f     fm   graph
fence  i e  polypath directed paths length    path
stretched directed path arbitrary length repeatedly applying
lemma     graph h   polypath used template
paths cg 
f   stretch much order get graph
 
isomorphic h   instance
f thus modified new instance f
cg f     h    
constructions done polynomial time  cases  f
solution f satisfiable  furthermore  cg f   isomorphic subgraph
ht four cases  according lemma    thus possible extend f new
 
 
planning instance  
f cg f     ht f solution
solution  extension done polynomial time according lemma 
since planexist c  solved polynomial time assumption theorem 
thus follows solve  sat polynomial time  however  implies
np p poly  impossible unless polynomial hierarchy collapses  theorem     
see result holds even operators consideration  
preconditions   postcondition  simply note restriction holds reductions
used underlying np hardness proofs section    similarly  acyclicity restriction
holds since result based in stars  out stars polypaths 
acyclic graphs 
recall generic blocks world encoding discussed beginning
section  class causal graphs blocks world instances satisfies requirements theorem     means planexist d  likely tractable  however 
finding non optimal plans blocks world tractable  plan length twice
length optimal plan found polynomial time  gupta   nau         is 
likely difficult problems blocks world happen exactly
causal graphs  illustrates complexity generic planning problem
cannot deduced corresponding class causal graphs alone 
   

fibackstrom   jonsson

   np hard np intermediate classes
theorem chen gimenez        states crisp complexity theoretic borderline 
component sizes bounded constant  planning polynomial time solvable
and  otherwise  planning polynomial time solvable  exploited extra
constraint  sp closure  able prove np hardness  leaves greyzone
polynomial cases np hard ones  longer require classes spclosed  longer obviously np hard even components unbounded 
natural question arises  say something middle ground 
instance  say something np intermediate cases may look
borderline np hard np intermediate is  although seem
likely could find results characterize borderline exactly 
least give partial answers questions  proving two theorems
related growth rate components  first shows planning still
np hard components grow o  v  g    k   integers k  second one shows
planning likely np intermediate components grow polylogarithmically 
theorem     every constant integer k      class gk graphs
cc size g   v  g    k g gk planexist gk   np hard 
proof  let k     arbitrary integer  construct graph class gk    g    g    g          
follows       let gm mk  components  isomorphic dpm  
i e   v  gm      mk components size    v  gm     k   prove np hardness
planexist gk   reduction planexist dp   let arbitrary planning instance
cg   dp  cg     dpm      construct new instance  
consists mk  renamed copies   clearly polynomial time construction
since k constant         furthermore  cg     isomorphic gm  
solution solution  hence  polynomial reduction follows
lemma   planexist gk   np hard 
obviously  size graphs exponential k 
second result must conditioned assumption exponential time
hypothesis  impagliazzo   paturi        impagliazzo  paturi    zane        holds 
hypothesis conjecture stated follows 
definition     constant integers k      let sk infimum real numbers
k sat solved o  n   time  n number variables
instance  exponential time hypothesis  eth  conjecture sk     k     
informally  eth says satisfiability cannot solved subexponential time  eth
arbitrarily choosen concept  quite strong assumption allows
defining theory similar one np completeness  concept called serf
 subexponential reduction family  reduction preserves subexponential time solvability  concept called serf completeness similar np completeness 
based serf reductions  is  subclass np complete problems
serf complete  meaning serf reduced other 
hence  one solved subexponential time  can 
   

fia refined view causal graphs component sizes

theorem     constant integers k     classes c directed graphs 
cc size g  logk  v  g   g c  planexist c  np hard unless eth
false 
proof  let k     arbitrary integer  let arbitrary planning instance n
variables maximum domain size cc size cg    c  components correspond independent subinstances  thus solved separately  component
state space size dc less  plan corresponding subinstance found
o d c   time  using dijkstras algorithm  since n components  whole
instance solved o nd c   time  however  follows standard assumptions
reasonable encodings n            looser bound
solved o x x c     o x   c   time  x        
suppose planexist c  np hard  polynomial reduction  sat
planexist c   furthermore  size  sat instance polynomially bounded
number variables  hence  must polynomial p  sat instance
n variables  corresponding planning instance size      p n  
since number variables upper bounded       follows assumption component size upper bounded logk      logk p n   hence 
k
solved o p n     log p n    time  according earlier observation 
p n     log

k

p n 

    log p n       log

k

p n 

       log

k

p n   logk p n 

     log

 k

 k

p n 

 

 k

furthermore  logk p n  o logk n   since p polynomial     log p n   o log n 
 k
follows solved  o log n  time  however  solved  n
time arbitrarily small   contradicts eth  follows planexist c  cannot
np hard unless eth false 
since components unbounded  problem likely solvable polynomial
time either  thus np intermediate problem double assumption
w      nu fpt eth holds 
theorems       together thus tell us something borderline
np intermediate np hard graph classes is  however  crisp distinction 
asymptotically  quite gap polylogarithmic functions root
functions  i e  functions form x  k    one may  instance  note function
 

f  n      log n 

 
 log log n c

lies within gap whenever     c     

   discussion
sp closed graph classes appealing properties fit well concept stronger
subgraph closed weaker minor closed  give partial characterization
borderline np hardness lies  however  noted earlier  possible define
types graph classes imply planning np hard  one example
family g    g    g          classes proof theorem     another specialized
and  perhaps  contrived class following  intended give contrast sp closure
concept gk classes 
   

fibackstrom   jonsson

tournament directed graph formed giving directions edge complete
graph  let denote set tournaments note sp closed  however 
tournaments hamiltonian graphs  redei        tournament n vertices 
path length t     n    furthermore  path length n   computed
polynomial time  bar noy   naor        
assume given  sat formula f n variables clauses  let    
  m     n  i e    polynomially bounded f   according lemma   thus
construct planning instance f polynomial time
   f contains   variables 
   cg f     dp   
   f solution f satisfiable 
choose arbitrary tournament   vertices t  find path length   
identify cg f    add dummy operators corresponding remaining
edges   thus shown polynomial time transformation  sat
planexist t   planexist t  np hard  one may note variations
technique used proving planexist t    np hard many different
t  t 
considered domain sizes tractable restrictions article 
note theorem    may give ideas look tractable cases  consider
case variable domains bounded size constant k
cc size g  log v  g   using first part proof  see planning solved
o n k   log n   time  however  k   log n     log k    log n     log n    log k   n  log k  
polynomial since k constant  is  planning tractable restricted case  even
though observation straightforward  interesting contrast theorem    
suggests even larger tractable subgraphs consider additional
restrictions planning instances 
explicitly commented sufficient number pre  postconditions
various results  alternative characterizations might relevant  would bear far list possibilities  let suffice one example 
concept prevail conditions  i e  preconditions variables changed
operator  originate sas  formalism  backstrom   nebel       
recently considered context causal graphs  gimenez jonsson       
refer operator k dependent precondition k variables
change  may note proofs lemmata       introduce
operators   dependent  most  since proof theorem    impose
restrictions original planning instance  follows theorem
holds operators   dependent  most 
final question  one might wonder practical use know
planning tractable  np intermediate  severely limited component sizes  all 
planning instances likely causal graph weakly connected 
is  whole graph one single component  answer question  first important
observation make complexity planning instances directly related
complexity planning components separately 
   

fia refined view causal graphs component sizes

linearly  in number variables  many components  planning solved
polynomial time components instance  solved polynomial time
whole instance  conversely  planning cannot solved polynomial time
whole instance  least one component polynomial time solvable 
is  complexity results instances components directly related
other  words  results relevant methods artificially split causal
graph components  one way another  examples causal graph heuristic
helmert      a   factored planning  brafman   domshlak        structural pattern
data bases  katz   domshlak        

acknowledgments
anonymous reviewers provided valuable comments suggestions improving
article 

references
backstrom  c     nebel  b          complexity results sas  planning  computational
intelligence             
bar noy  a     naor  j          sorting  minimal feedback sets  hamilton paths
tournaments  siam journal discrete mathematics             
biggs  n          algebraic graph theory  cambridge univ  press   nd ed 
bodirsky  m     grohe  m          non dichotomies constraint satisfaction complexity 
proceedings   th international colloquium automata  languages
programming  icalp        reykjavik  iceland  pp         
brafman  r  i     domshlak  c          structure complexity planning unary
operators  journal artificial intelligence research             
brafman  r  i     domshlak  c          factored planning  how  when  not 
proceedings   st national conference artificial intelligence  aaai       
boston  ma  usa  pp          aaai press 
chen  h     gimenez  o          causal graphs structurally restricted planning  journal computer systems science                 
domshlak  c     dinitz  y       a   multi agent off line coordination  structure complexity  proceedings  th european conference planning  ecp     toledo 
spain 
domshlak  c     dinitz  y       b   multi agent off line coordination  structure complexity  tech  rep   department computer science  ben gurion university  cs      
downey  r  g     fellows  m  r          parameterized complexity  monographs computer science  springer  new york 
flum  j     grohe  m          parameterized complexity theory  vol  xiv texts
theoretical computer science  eatcs series  springer  berlin 
   

fibackstrom   jonsson

garey  m  r     johnson  d  s          computers intractability  guide theory
np completeness  w  h  freeman  new york 
gimenez  o     jonsson  a          complexity planning problems simple
causal graphs  journal artificial intelligence research             
gimenez  o     jonsson  a          planning chain causal graphs variables
domains size   np hard  journal artificial intelligence research             
gimenez  o     jonsson  a          influence k dependence complexity
planning  artificial intelligence                
gupta  n     nau  d  s          complexity blocks world planning  artificial
intelligence                   
helmert  m          complexity results standard benchmark domains planning 
artificial intelligence                  
helmert  m          planning heuristic based causal graph analysis  proceedings
  th international conference automated planning scheduling  icaps
       whistler  bc  canada  pp          aaai press 
helmert  m       a   fast downward planning system  journal artificial intelligence
research             
helmert  m       b   new complexity results classical planning benchmarks  proceedings   th international conference automated planning scheduling
 icaps        cumbria  uk  pp        aaai press 
impagliazzo  r     paturi  r          complexity k sat  journal computer
system science                 
impagliazzo  r   paturi  r     zane  f          problems strongly exponential
complexity   journal computer system science                 
jonsson  a          role macros tractable planning  journal artificial intelligence research             
jonsson  p     backstrom  c       a   state variable planning structural restrictions 
algorithms complexity  artificial intelligence                    
jonsson  p     backstrom  c       b   tractable plan existence imply tractable
plan generation  annals mathematics artificial intelligence                   
karp  r  m     lipton  r  j          connections nonuniform uniform complexity classes  proceedings   th acm symposium theory
computing  stoc     los angeles  ca  usa  pp         
katz  m     domshlak  c          structural patterns tractable sequentially optimal
planning  proceedings   th international conference automated planning
scheduling  icaps        providence  ri  usa  pp          aaai press 
katz  m     domshlak  c          new islands tractability cost optimal planning 
journal artificial intelligence research             
katz  m     domshlak  c          implicit abstraction heuristics  journal artificial
intelligence research            
   

fia refined view causal graphs component sizes

katz  m   hoffmann  j     domshlak  c          said need relax variables   proceedings   rd international conference automated planning
scheduling  icaps        rome  italy          aaai press 
katz  m     keyder  e          structural patterns beyond forks  extending complexity
boundaries classical planning  proceedings   th aaai conference
artificial intelligence  aaai        toronto  on  canada  aaai press 
knoblock  c  a          automatically generating abstractions planning  artificial
intelligence                 
kuhn  d   osthus  d     young  a          note complete subdivisions digraphs
large outdegree  journal graph theory             
ladner  r  e          structure polynomial time reducibility  journal
acm                 
lovasz  l          graph minor theory  bulletin ams               
mohar  b              graph minor  notices ams                 
redei  l          ein kombinatorischer satz  acta litteraria szeged          
wehrle  m     helmert  m          causal graph revisited directed model checking 
proceedings static analysis    th international symposium  sas     los
angeles  ca  usa  vol       lncs  pp         springer 
williams  b     nayak  p  p          reactive planner model based executive 
proceedings   th international joint conference artificial intelligence
 ijcai     nagoya  japan  pp           

   


