journal of artificial intelligence research                  

submitted        published      

a refined view of causal graphs and component sizes 
sp closed graph classes and beyond
christer backstrom
peter jonsson

christer backstrom liu se
peter jonsson liu se

department of computer science
linkoping university
se        linkoping  sweden

abstract
the causal graph of a planning instance is an important tool for planning both in
practice and in theory  the theoretical studies of causal graphs have largely analysed the
computational complexity of planning for instances where the causal graph has a certain
structure  often in combination with other parameters like the domain size of the variables 
chen and gimenez ignored even the structure and considered only the size of the weakly
connected components  they proved that planning is tractable if the components are
bounded by a constant and otherwise intractable  their intractability result was  however 
conditioned by an assumption from parameterised complexity theory that has no known
useful relationship with the standard complexity classes  we approach the same problem
from the perspective of standard complexity classes  and prove that planning is np hard
for classes with unbounded components under an additional restriction we refer to as spclosed  we then argue that most np hardness theorems for causal graphs are difficult to
apply and  thus  prove a more general result  even if the component sizes grow slowly and
the class is not densely populated with graphs  planning still cannot be tractable unless the
polynomial hierachy collapses  both these results still hold when restricted to the class of
acyclic causal graphs  we finally give a partial characterization of the borderline between
np hard and np intermediate classes  giving further insight into the problem 

   introduction
we will first briefly explain what a causal graph is and give a short survey of applications
as well as theoretical results reported in the literature  following that  we give an overview
of the new results presented in this article 
    background
the causal graph for a planning instance is an explicit description of the variable dependencies that are implicitly defined by the operators  more precisely  it is a directed graph
such that there is an arc from a variable x to another variable y if either x appears in the
precondition of an operator with an effect on y or some operator has effects on both x and y 
this standard definition of the causal graph can be traced back to knoblock       
although he did not give it a name  he used the causal graph in the alpine algorithm 
as a guidance for partitioning and ordering the variables in the process of automatically
deriving state abstraction hierarchies  the actual name causal graph can be traced back
to williams and nayak         their approach was both more general and more restricted
c
    
ai access foundation  all rights reserved 

fibackstrom   jonsson

than knoblocks  on the one hand  they generalized the concept from binary variables to
multi valued variables  but on the other hand  they considered only acyclic causal graphs
which implies that all operators are unary  i e  every operator changes only one variable 
the context of their work was the reactive planner burton for onboard space ship control 
a causal model was compiled into a transition system that could be efficiently exploited by a
reactive controller to choose appropriate operators to achieve given goals  the compilation
was done in such a way that all operators were unary  and they claimed that this is often
possible in real applications  the resulting acyclicity of the causal graph was then exploited
by burton  which traversed the graph bottom up in order to issue operators in an order
consistent with their causal relationships 
jonsson and backstrom      b  also studied acyclic causal graphs  but referred to them
as dependency graphs  they considered a subclass of such graphs having a particular structure and used this to implicitly define a corresponding class of planning instances  the  s
class  this class has the property that it is always possible to decide in polynomial time if
there is a solution or not  but the solutions themselves may be of exponential length  thus
necessarily taking exponential time to generate  although only one single restricted case 
the  s class is probably the first example of relating structural properties of the causal graph
to the computational complexity of planning  a more general and extensive such analysis
was done by domshlak and dinitz      a   who analysed the complexity of planning for
classes of instances corresponding to a number of different possible structures of acyclic
causal graphs  however  their work was done in the context of multi agent coordination
and the term causal graph was never used 
the first two of these papers may be viewed as early examples of exploiting the causal
graph in practice  while the latter papers form the starting point of the subsequent theoretical research into the relationships between planning complexity and the structure of
causal graphs 
an important step forward in the usage of causal graphs was the paper by helmert
       where he demonstrated that the causal graph is particularly useful in the context of
multi valued variables  previous research on the complexity of planning with multi valued
variables had focussed on the structure of the domain transition graphs for the variables
 jonsson   backstrom      a   rather than the causal graph  helmert realized the power
of using both the domain transition graphs and the causal graph in heuristic planning 
this was exploited in practice in his highly succesful fast downward planner  helmert 
    a   it translates pddl planning instances with binary variables into a representation
with multi valued variables and then removes carefully chosen edges in the resulting causal
graph to make it acyclic  the resulting causal graph is then used to compute a heuristic
by hierarchically computing and composing plan lengths for subgraphs having one of the
particular structures studied by domshlak and dinitz      a   somewhat similarly  katz
and domshlak        identified subgraphs of the causal graph that have certain structures
that make planning for them tractable  they exploited this to be able to use larger variables
sets when constructing pattern databases  a further example of exploiting the causal graph
to make planning more efficient is the paper on factored planning by brafman and domshlak
        they showed that the structure of the causal graph can be used as a guide for
deciding if and how a planning instance can be solved more efficiently by dividing it into
loosely coupled subinstances and use constraint processing  the basic idea of the causal
   

fia refined view of causal graphs and component sizes

graph to represent variable dependencies is  of course  quite general and not necessarily
restricted to planning  for instance  wehrle and helmert        transferred the causal
graph concept to the context of model checking 
as previously mentioned  the two papers by jonsson and backstrom      b  and by
domshlak and dinitz      a  can be viewed as the starting point for a successful line of
research into studying the relationships between planning complexity and the structure
of the causal graph  while the  s class by jonsson and backstrom was a very limited
special case  domshlak and dinitz studied classes of planning instances corresponding to a
number of more general graph structures  like in stars  aka  inverted forks   out stars  aka 
forks   directed path graphs  aka  directed chain graphs   polytrees and singly connected
dags  further results followed  for instance  in articles by brafman and domshlak        
and gimenez and jonsson         the latter article additionally showed that although  s
instances can have exponential length plans  it is possible to generate a macro representation
of such a plan in polynomial time  a result they extended also to some other classes defined
by the structure of the causal graph  many of the complexity results in these papers use
additional numerical parameters in conjunction with the graph structure  examples of such
parameters are the maximum domain size of the variables and the maximum in degree of
the graph  while increasing the number of possible cases to analyse  it does allow for a
more fine grained analysis in many cases  consider for instance the case of directed path
graphs  domshlak and dinitz      a  proved that it is tractable to decide if there is a
plan for this case when the domains are binary  while gimenez and jonsson        proved
that a domain size of   is sufficient to make the problem np hard  similarly  gimenez and
jonsson        proved tractability for planning instances with binary variables  a constant
number of prevail conditions and where the causal graph is a polytree  also the paper
by brafman and domshlak        fits into this line of theoretical research  exhibiting a
planning algorithm that runs in time exponential in two parameters  the tree width of the
undirected version of the causal graph and the maximum number of times a variable must
change value 
while most research has been based on the standard definition of causal graphs that
was set already by knoblock  although often in the generalisation to multi valued variables 
there are important exceptions  one potential problem with the standard defintion is that
whenever two variables are both affected by the same operator  then the causal graph must
necessarily contain cycles  which is the major reason why the focus has mainly been on
planning with unary operators  in an attempt to circumvent this problem  jonsson       
defined a more relaxed variant of the causal graph that does not always introduce cycles for
non unary operators  which can sometimes allow for a more fine grained complexity analysis 
the previous results relate the structure of the causal graph to the complexity of satisficing planning  i e  deciding if there is a plan  there has also been a corresponding branch
of research relating the structure of the causal graph to the complexity of cost optimal
planning  cf   katz   domshlak                    katz   keyder        
    our contributions
all of the theoretical research above studies the complexity of planning based on the structure of the causal graph  and possibly other parameters like domain sizes  an important
   

fibackstrom   jonsson

milestone that deviates from this line of research was an article by chen and gimenez
       who did not even consider the structure of the causal graph but only a simple quantitative measure  the size of the weakly connected components  they proved that deciding
if there is a plan can be done in polynomial time if and only if the size of the weakly connected components in the causal graph is bounded by a constant  in one sense  this is a
very sharp and final result  however  the intractability result for unbounded components is
conditional on the assumtion that w      nu fpt  this assumption relies on the theory
of parameterised complexity theory and neither the complexity classes nor the assumption
itself can be related to ordinary complexity classes in a clear way  chen and gimenez acknowledge that the problems they prove conditionally intractable include np intermediate
problems  hence  we take their result as a take off point for further investigation of how
the component sizes reflect on the standard complexity classes  since we know from chen
and gimenez that not all graph classes with unbounded components are np hard we must
consider further restrictions in order to find np hard classes  we do so by adding a new
type of closure property  sp closure  which is incomparable to subset closure but is a subset of minor closure  and prove that planning is np hard for any sp closed graph class
with unbounded components  it should be noted that this result still holds for the class
of all acyclic graphs  which is important considering the practical relevance of acyclicity
previously mentioned 
while many graph classes that have been studied in the literature are indeed sp closed 
there also exists natural classes that lack this property  we present one way of handling
such classes with the aid of non uniform complexity theory  in this case  we are not able to
show np hardness but we can show that the polynomial hierarchy collapses to its second
level  this is a fairly general result that can be applied even when the component sizes grow
very slowly and the graph class is not very densely populated with graphs  also this result
holds even if restricted to acyclic graphs  this result can be used to demonstrate clearly
that complexity results for planning based only on the class of causal graphs does not necessarily have any connection to the complexity of a generic planning problem having the same
class of causal graphs  this result also raises the question of where to find  preferably natural  np intermediate planning problems  chen and gimenez state that np intermediate
problems can be obtained by using methods similiar to the ones employed by bodirsky and
grohe         such problems are hard to describe as natural  though  they are based on
ladners        diagonalization technique that removes a large fraction of input strings from
a problem  it is apparently difficult to connect graph classes constructed by this technique
with simple conditions on component growth  as an alternative  we show that graph classes
where the component sizes grow polylogarithmically are np intermediate under the double
assumption that w      nu fpt and that the exponential time hypothesis  impagliazzo
  paturi        holds  we also show that for every k      there exists a class gk of graphs
such that component size is bounded by  v  g    k for all g  gk and the corresponding
planning problem is np hard  these results coarsely stake out the borderline between
np hard and np intermediate classes 
a possible conclusion from this paper is that complexity analysis of planning based only
on the structure of the causal graph is of limited value  and that additional parameters are
needed to achieve more useful results  while this may be a fair conclusion in general  there
are cases where the graph structure is sufficient  for instance  katz  hoffmann  and domsh   

fia refined view of causal graphs and component sizes

lak        have applied the result by chen and gimenez        in the context of so called
red black planning  a variant of delete relaxation for computing heuristics  furthermore 
even when the structure of the causal graph has to be combined with other parameters  it
is still important to know the behaviour of each parameter in isolation 
the remainder of the article is structured as follows  in section   we set the notation
and terminology used for planning and for graphs  and in section   we define causal graphs
and structural planning in general  section   contains a number of np hardness results for
various special graph classes that we need for the main results  the first of the two main
theorems of the article appears in section    where we define the concept of sp closed graph
classes and prove that planning is np hard for such classes when the component size is
unbounded  section   discusses some of the problems with both the previous theorem and
other similar results in the literature  as a way around these problems  our second main
theorem shows that even without any closure requirements  planning is likely to be hard
even when the components grow slowly and the graphs do not appear densely in the class 
section   contains some observations concerning the borderline between np intermediate
and np hard planning problems  the article ends with a discussion section 

   preliminaries
this section sets the terminology and notation for planning and graphs used in this article 
we write  x  to denote the cardinality of a set x or the length of a sequence x  i e  the
number of elements in x  and we write   x   to denote the size of the representation of an
object x 
    planning
since this article has many connections with the one by chen and gimenez        we
follow their notation and terminology for plannning  which is a notational variant of sas 
 backstrom   nebel        
an instance of the planning problem is a tuple     v  init  goal  a  whose components
are defined as follows 
 v is a finite set of variables  where each variable v  v has an associated finite domain
d v   note that variables are not necessarily propositional  that is  d v  may be any
finite set  a state is a mapping s defined on the variables v such that s v   d v  for
all v  v   a partial state is a mapping p defined on a subset vars p  of the variables v
such that for all v  vars p   it holds that p v   d v   and p is otherwise undefined 
 init is a state called the initial state 
 goal is a partial state 
 a is a set of operators  each operator a  a consists of a precondition pre a  and
a postcondition post a  which are both partial states  we often use the notation
hpre   posti to define an operator with precondition pre and postcondition post  for
instance  a   hx      y       z    i defines an operator a which is applicable in any
state s such that s x      and s y       and which has the effect of setting variable
z to   
   

fibackstrom   jonsson

when s is a state or a partial state and w is a subset of the variable set v   we write
s  w to denote the partial state resulting from restricting s to w   we say that a state s is
a goal state if goal   s  vars goal  
we define a plan  for an instance   to be a sequence of operators p   a            an  
starting from a state s  we define the state resulting from s by applying a plan p   denoted
by s p    inductively as follows  for the empty plan p     we define s     s  for non empty
plans p we define s p   as follows  where a is the last operator in p and p   is the prefix of
p up to  but not including  a 
 if pre a     s p      vars pre a    that is  the preconditions of a are not satisfied in the
state s p       then s p     a    s p     
 otherwise  s p     a  is the state equal to post a  on variables v  vars post a    and
equal to s p     on variables v  v   vars post a   
a plan p is a solution plan if init p   is a goal state 
we are concerned with the computational problem plan existence  planexist   given an
instance     v  init  goal  a   decide if there exists a solution plan 
    graphs
a directed graph is a pair  v  e  where v is the vertex set and e  v  v is the edge set 
an undirected graph is a pair  v  e  where v is the vertex set and e    u  v    u  v  v  
is the edge set  we will often only say graph and edge if it is clear from the context whether
it is directed or undirected  the notation v  g  refers to the vertex set of a graph g and
e g  refers to its edge set  if e    u  v  or e    u  v  is an edge  then the vertices u and
v are incident with e  furthermore  the directed edge  u  v  is an outgoing edge of u and
an incoming edge of v  for a directed graph g    v  e   we write u  g  to denote the
correspsonding undirected graph u  g     v  eu   where eu     u  v     u  v   e   that
is  u  g  is the undirected graph induced by g by ignoring the orientation of edges 
let g    v  e  be a directed graph and let v            vk  v such that v            vk are
distinct and  vi    vi    e for all i     i  k   then the sequence v            vk is a directed
path of length k in g if v     vk and it is a directed cycle of length k in g if v    vk   paths
and cycles in undirected graphs are defined analogously  except that there is no direction
to consider  a graph is acyclic if it contains no cycles 
let g    v  e  be a directed graph and let v  v be a vertex  then  v is isolated if it
has no incoming or outgoing edges  v is a source if it has at least one outgoing edge but no
incoming edge  v is a sink if it has at least one incoming edge but no outgoing edge and
otherwise v is intermediate 
let g    vg   eg   and h    vh   eh   be two directed graphs  then g and h are
isomorphic  denoted g   h  if there exists a bijective function f   vg  vh such that
 u  v   eg if and only if  f  u   f  v    eh   furthermore  h is a subgraph of g if vh  vg
and eh  eg   vh  vh    when eh   eg   vh  vh   we say that the subgraph h
is induced by the vertex set vh   isomorphisms and subgraphs are analogously defined for
undirected graphs 
let g be an undirected graph  then g is connected if there is a path between every
pair of vertices in g  a connected component of g is a maximal subgraph of g that is
   

fia refined view of causal graphs and component sizes

connected  let g be a directed graph  then g is weakly connected if u  g  is connected 
a weakly connected component of g is a maximal subgraph of g that is weakly connected 
that is  in a weakly connected component there are paths between every pair of vertices
if we ignore the direction of edges  let g    vg   eg   and h    vh   eh   be two directed
graphs such that vg and vh are disjoint  then the  disjoint  union of g and h is defined
as g  h    vg  vh   eg  eh   and is a commutative operation  note that if a graph g
consists of the  weakly  connected components g            gn   then g   g   g          gn  
we further define some numeric graph parameters  for a directed graph g and a vertex
v  v  g   the indegree of v is   u  v  g     u  v   e g     i e  the number of incoming
edges incident with v  and the outdegree of v is   u  v  g     v  u   e g     i e  the number
of outgoing edges incident with v  for an undirected graph g  the degree of v  v  g  is
  u  v  g     v  u   e g     i e  the number of edges incident with v  we extend this to
graphs as follows  if g is an undirected graph  then deg g  denotes the largest degree of
any vertex in v  g   similarly  if g is a directed graph then in deg g  denotes the largest
indegree of any vertex in v  g  and out deg g  denotes the largest outdegree of any vertex in
v  g   furthermore  if g is an undirected graph  then path length g  denotes the length of
the longest path in g and cc size g  denotes the size of the largest connected component in
g  if g is a directed graph  then path length g  denotes the length of longest directed path
in g  we also define upath length g    path length u  g   and cc size g    cc size u  g   
that is  upath length g  is the length of the longest path in g if ignoring the direction of
edges and cc size g  is the size of the largest weakly connected component in g  note that
if g is an undirected connected graph  then path length g  equals the diameter of g  we
extend all such numeric graph properties  in deg  path length etc   to sets of graphs such
that if c is a set of graphs and prop is a graph property  then prop c    maxgc prop g  
    special graph types
in the literature on causal graphs  as well as in this article  there are certain types of graphs
that are of particular interest and that are thus useful to refer to by names  we distinguish
the following types of undirected graphs  a tree is an undirected graph in which any two
vertices are connected by exactly one path  i e  it is acyclic and connected  a path graph
is a tree where all vertices have degree   or    i e  it is a tree that does not branch  a star
graph is a tree where all vertices except one  the centre vertex  have degree   
for directed graphs  we distinguish the following types  an in star graph is a directed
graph g such that u  g  is a star graph and all edges are directed towards the centre 
an out star graph is a directed graph g such that u  g  is a star graph and all edges are
directed out from the centre  a directed path graph is a directed graph g such that u  g 
is a path graph  in deg g     and out deg g      i e  g is a directed path over all its
vertices and contains no other edges  a polytree is a directed graph g such that u  g  is
a tree  i e  g is a weakly connected directed graph that can be constructed from a tree by
giving a unique direction to every edge  a polypath is a directed graph g such that u  g 
is a path graph  i e  g is a weakly connected directed graph that can be constructed from
a path graph by giving a unique direction to every edge  a fence is a polypath where every
vertex is either a source or a sink  i e  the edges alternate in direction at every vertex 
   

fibackstrom   jonsson

it should be noted that the out star graph is usually called a directed star graph in
graph theory  while the in star graph appears to have no standard name  we hence deviate
sligthly from standard terminology in order to have logical names for both graph types 
also the polypath appears to have no standard name  but polypath is a logical term in
analogy with polytree  it should be further noted that a parallel terminology for certain
graph types has evolved in the literature on causal graphs in planning  for instance  instars  out stars and directed paths are commonly referred to as inverted forks  forks and
directed chains  respectively 
note that the number of sinks and sources in a polypath differ by at most one  i e  a
polypath with m sinks has m   c sources for some c             furthermore  every fence
is a polypath  but not every polypath is a fence 
we define the following graphs and graphs classes 
 skin denotes the in star graph with one centre vertex and k sources  also define the
class sin    skin   k     
 skout denotes the out star with one centre vertex and k sinks  also define the class
sout    skout   k     
 dpk denotes the directed path on k vertices  also define the class dp    dpk      k  
c   for c             denotes the fence with m sinks and m   c sources  also define
 fm
c      m   for each c             and the class f   f  f  f    
the class fc    fm

examples of these graph types are illustrated in figure   

v 
v 

v 
v 

vc
v 

v 

v 

v 

vc
v 

v 

v 

v 

v 

v 
u 

v 
u 

f  

v 

v 
s out

s in

v 

dp 

v 
u 

v 
u 

v 
u 

v 
u 

f  

v 
u 

v 
u 

u 

f   

figure    examples of some important graph types 
the following observation about polypaths will be used later on 
proposition    let g be a polypath with at most m sinks and m     sources such that
path length g   k  then  v  g     mk     
   

fia refined view of causal graphs and component sizes

proof  there are at most  m distinct paths from a source to a sink  each of these having at
most k    intermediate vertices  hence  v  g    m    m         m k        mk     
this bound is obviously tight in the case where there are m sinks and m     sources  and
every path from a source to a sink contains exactly k    intermediate vertices 

   structurally restricted planning
the topic of study in this article is causal graphs for planning  but before discussing this
concept we first define the concept of domain transition graphs  jonsson   backstrom 
    a   although not used explicitly in any of our results  it is useful for explaining some
of the proofs later in the article  let     v  init  goal  a  be a planning instance  for each
variable v  v   we define the domain transition graph  dtg  for v as a directed graph
 d v   e   where for all x  y  d v   e contains the edge  x  y  if there is some operator
a  a such that post a  v    y and either pre a  v    x or v   vars pre a   
the causal graph for a planning instance describes how the variables of the instance
depends on each other  as implicitly defined by the operators 
definition    the causal graph of a planning instance     v  init  goal  a  is the directed
graph cg      v  e  where e contains the edge  u  v  for every pair of distinct vertices u  v  v such that u  vars pre a    vars post a   and v  vars post a   for some
operator a  a 
the causal graph gives some  but not all  information about the operators  for instance 
if the causal graph is acyclic  then all operators must be unary  i e   vars post  a       for
all operators  since any non unary operator must necessarily introduce a cycle according
to the definition  however  the presence of cycles does not necessarily mean that there are
non unary operators  for instance  if both the edges  u  v  and  v  u  are present in the
graph  then this can mean that there is some operator a such that both u  vars post a  
and v  vars post a    however  it can also mean that there are two operators a and a  such
that u  vars pre a    v  vars post a    v  vars pre a     and u  vars post a      which could
thus both be unary operators  similarly  the degree of the vertices provides an upper bound
on the number of pre  and postconditions of the operators  but no lower bound  suppose
there is a vertex u with indegree   and incoming edges  v  u  and  w  u   this could mean
that there is some operator a such that u  vars post a   and both v  vars pre a   and
w  vars pre a    however  it can also mean that there are two different operators a and a 
such that v  vars pre a    u  vars post a    w  vars pre a     and u  vars post a     
the planexist problem is extended from planning instances to causal graphs in the
following way  for a class c of directed graphs  planexist c  is the problem of deciding
for an arbitrary planning instance  such that cg    c  whether  has a solution or
not  that is  the complexity of planexist c  refers to the complexity of the set of planning
instances whose causal graphs are members of c 
there are a number of results in the literature on the computational complexity of
planning for various classes of causal graphs  however  these results usually assume that
the graph class has a restricted structure  e g  containing only in stars or only directed
paths  a more general and abstract result is the following theorem 
   

fibackstrom   jonsson

theorem     chen   gimenez        thm       let c be a class of directed graphs 
if cc size c  is bounded  then planexist c  is solvable in polynomial time  if cc size c  is
unbounded  then planexist c  is not polynomial time solvable  unless w     nu fpt  
while the theorem describes a crisp borderline between tractable and intractable graph
classes  it does so under the assumption that w      nu fpt    both these complexity
classes are from the theory of parameterised complexity and cannot be immediately related
to the usual complexity classes  it is out of the scope of this article to treat parameterised
complexity and we refer the reader to standard textbooks  downey   fellows        flum
  grohe         the result in the theorem is not a parameterised result  however  it is only
the condition that is parameterised  so it suffices to note that the intractability result holds
under a condition that is difficult to relate to other common assumptions  such as p    np 
one of the reasons why chen and gimenez were forced to state the theorem in this way was
that a classification into polynomial and np hard classes would not have been exhaustive 
since there are graph classes that are np intermediate   a problem is np intermediate if
it is neither in p nor np complete  unless p   np  
this theorem might be viewed as the starting point for the research reported in this
article  where we investigate this problem from the perspective of standard complexity
classes  for instance  np hardness can be proved in the case of unbounded components if
adding further restrictions  which we will do in section   

   basic constructions
this section presents some results that are necessary for the theorems later in the article 
the first three results  that planning is np hard for in stars  aka  inverted forks   out stars
 aka  forks  and directed paths  aka  directed chains   are known from the literature  while
the np hardness result for fences is new  we will  however  provide new proofs also for the
in star and out star cases  the major reason is that in section   we will need to refer to
reductions that have certain precisely known properties  furthermore  the original proofs
are only published in a technical report  domshlak   dinitz      b  and may thus be hard
to access 
lemma     domshlak   dinitz      a  thm    iv  planexist sin   is np hard  this result
holds even when restricted to operators with at most   preconditions and   postcondition 
proof   new proof  proof by reduction from  sat to a class of planning instances with
causal graphs in sin   the reduction constructs a planning instance where each source in the
causal graph corresponds to one of the variables in the formula and the centre corresponds
to the clauses  the construction is illustrated in figure   and formally defined as follows 
let f   c          cm be an arbitrary  sat formula with variables x            xn and clauses
c            cm   construct a corresponding planning instance f    v  init  goal  a  as follows 
 v    vc   v            vn    where
d vc                 m  and
d vi      u  f  t   for all i     i  n  
   the condition can be simplified to w      fpt if the class c is recursively enumerable 

   

fia refined view of causal graphs and component sizes

vc
 

 

 

t
u

t
u

t
u

f
v 

m

f
v 

f
vn

figure    the in star causal graph and the dtgs for the construction in the proof of
lemma   

 init vi     u  for all i     i  n   and init vc       
 goal vc     m and goal is otherwise undefined 
 a consists of the following operators 
 for each i     i  n   a contains the operators
set f i    hvi   u   vi   f i and
set t i    hvi   u   vi   ti 
 for each clause ci      i    i    i   and each j     j      there is some k such
that  ji   xk or  ji   xk   so let a contain either the operator
verify clause pos i  j    hvc   i     vk   t   vc   ii  if  ji   xk  
or the operator
verify clause neg i  j    hvc   i     vk   f   vc   ii  if  ji   xk  
clearly  the instance f can be constructed in polynomial time and cg f     snin   so it
remains to prove that f has a solution if and only if f is satisfiable 
each source variable vi can be changed independently  it starts with the undefined
value u and can be set to either t or f   corresponding to true and false  respectively  for the
corresponding variable xi in f   once it is set to either t or f   it cannot be changed again 
that is  variables v            vn can be used to choose and commit to a truth assignment for
x            xn   the centre variable vc has one value  i  for each clause ci in f   plus the initial
value    it is possible to reach the goal value m from the inital value   by stepping through
   

fibackstrom   jonsson

all intermediate values in numerical order  for each such step  from i    to i  there are
three operators to choose from  corresponding to each of the literals in clause ci   the step
is possible only if one of v            vn is set to a value consistent with one of the literals in ci  
that is  the goal vc   m can be achieved if and only if variables v            vn are set to values
corresponding to a truth assignment for x            xn that satisfies f  
the restricted case  with respect to pre  and post conditions  is immediate from the
construction above 
the problem is known to be tractable  though  if the domain size of the centre variable is
bounded by a constant  katz   domshlak         furthermore  the causal graph heuristic
by helmert        is based on identifying in star subgraphs of the causal graph  and it
should be noted that he provided a variant of the original proof due to some minor technical
differences in the problem formulations 
lemma     domshlak   dinitz      a  thm    iii  planexist sout   is np hard  this result
holds even when restricted to operators with at most   precondition and   postcondition 
proof   new proof  proof by reduction from  sat to a class of planning instances with
causal graphs in sout   the reduction constructs a planning instance where the centre vertex
of the causal graph corresponds to the variables in the formula and each sink corresponds
to one of the clauses  the construction is illustrated in figure   and formally defined as
follows 
v 

u

v 

vm

s

u

s

u

t 

t 

t 

tn

f 

f 

f 

fn

s

vc

figure    the out star causal graph and the dtgs for the construction in the proof of
lemma   

let f   c          cm be an arbitrary  sat formula with variables x            xn and clauses
c            cm   construct a corresponding planning instance f    v  init  goal  a  as follows 
   

fia refined view of causal graphs and component sizes

 v    vc   v            vm    where
d vc      f            fn   t            tn   and
d vi      u  s   for all i     i  m  
 init vi     u  for all i     i  m   and init vc     f   
 goal vi     s  for all i     i  m   and goal vc   is undefined 
 a consists of the following operators 
 for each i     i  n   a contains the operators
step c fi    fi     hvc   fi    vc   fi i 
step c fi    ti     hvc   fi    vc   ti i 
step c ti    fi     hvc   ti    vc   fi i and
step c ti    ti     hvc   ti    vc   ti i 
 for each clause ci      i    i    i   and each j     j      there is a k such that
 ji   xk or  ji   xk   so let a contain either the operator
verify clause pos i  j    hvc   tk   vi   si  if  ji   xk  
or the operator
verify clause neg i  j    hvc   fk   vi   si  if  ji   xk  
clearly  the instance f can be constructed in polynomial time and cg f     snout   so it
remains to prove that f has a solution if and only if f is satisfiable 
variable vc can be changed independently and it has two values  ti and fi   for each
variable xi in f   corresponding to the possible truth values for xi   in addition there is an
initial value f   and a dummy value t  in order to simplify the formal definition   both the
values tn and fn are reachable from the initial value f    and each such plan will correspond
to a path f    z    z            zn where each zi is either ti or fi   that is  vc must pass either value
ti or fi   but not both  for each i  hence  any such path will correspond to a truth assignment
for the variables x            xn in f   for each clause ci in f   there is a corresponding variable
vi that can change value from the initial value u  unsatisfied  to the goal value s  satisfied 
each vi has three operators to do this  one for each literal in ci   that is  if ci contains
a literal xk  or xk   then vi can change value from u to s while vc has value tk  or fk   
hence  the goal v            vm   s can be achieved if and only if there is a path for vc
that corresponds to a truth assignment for x            xn that satisfies f    note  though  that
vc must not always follow a path all the way to fn or tn since a partial assignment may
sometimes be sufficient to prove satisfiability  
the restricted case  with respect to pre  and post conditions  is immediate from the
construction above 
the problem is known to be tractable  though  if the domain size of the centre variable is
bounded by a constant  katz   keyder        
the following result on planning with directed path causal graphs is also known from
the literature 
lemma     gimenez   jonsson        prop       planexist dp  is np hard  even when
all variables have domain size   and the operators have at most   preconditions and   postcondition 
   

fibackstrom   jonsson

we refer to gimenez and jonsson for the proof  however  we will implicitly use their
proof later in this article so there are a few important observations to make about it  the
reduction is from sat and  thus  works also as a reduction from  sat  furthermore  the
reduction transforms a formula with n variables and m clauses to a planning instance with
  m     n variables  as a final remark  this problem is known to be tractable if all variables
have a domain of size    domshlak   dinitz      a  
while the three previous results are known in the literature  the following result is new
to the best of our knowledge 
lemma    planexist f     is np hard  this result holds even when restricted to operators
with at most   preconditions and   postcondition 
proof  proof by reduction from  sat to a class of planning instances with causal graphs
in f    
the reduction constructs a planning instance where each sink of the causal graph corresponds to one of the clauses in the formula  while each source corresponds to all variables 
furthermore  the source variables are synchronized to have the same behaviour  the construction is illustrated in figure   and formally defined as follows 
let f   c          cm be an arbitrary  sat formula with variables x            xn and clauses
c            cm   construct a corresponding planning instance f as follows 
 v    u            um   v            vm    where
d ui      f            fn   t            tn    for all i     i  m   and
u   tu           tu   f s         f s   ts           ts   s   for all i     i  m  
d vi      f u           fm
m  
m  
m
 
 init ui     f    for all i     i  m   and init vi     f u   for all i     i  m  
 goal vi     s  for all i     i  m   and goal is otherwise undefined 
 let a consist of the following operators 
 for all i  j     i  n     j  m   a contains the operators
step x j  fi    fi     huj   fi    uj   fi i 
step x j  fi    ti     huj   fi    uj   ti i 
step x j  ti    fi     huj   ti    uj   fi i and
step x j  ti    ti     huj   ti    uj   ti i 
 for all i  j      i  n     j  m   a contains the operators
u
u   f u     hv   f u   u
step clause u j  fi 
j
i  j    fi   uj   fi   vj   fi i 
i
u
u
u
u
step clause u j  fi    ti     hvj   fi    uj    ti   uj   ti   vj   ti i 
step clause u j  tui    fiu     hvj   tui    uj    fi   uj   fi   vj   fiu i 
step clause u j  tui    tui     hvj   tui    uj    ti   uj   ti   vj   tui i 
s   f s     hv   f s   u
s
step clause s j  fi 
j
i
i  j    fi   uj   fi   vj   fi i 
s   ts     hv   f s   u
s
step clause s j  fi 
j
i
i  j    ti   uj   ti   vj   ti i 
s
s
s
step clause s j  ti    fi     hvj   ti    uj    fi   uj   fi   vj   fis i 
step clause s j  tsi    tsi     hvj   tsi    uj    ti   uj   ti   vj   tsi i 
 for each j     j  m   a contains the operators
finalize clause f j    hvj   fns   vj   si and
finalize clause t j    hvj   tsn   vj   si 
   

fia refined view of causal graphs and component sizes

vi 

vi  

vi
tu 

tu 

tu 

tun

f u

f u

f u

fnu

x   ci

x   ci

ts 

ts 

ts 

tsn

f s

f s

f s

fns

s

t 

t 

t 

tn

t 

t 

t 

tn

f 

f 

f 

fn

f 

f 

f 

fn

ui 

ui

figure    the fence causal graph and the dtgs for the construction in the proof of
lemma     this example assumes that clause ci contains the literals x  and x    

 for each clause ci      i    i    i   and for each j     j      there is a k such
that  ji   xk or  ji   xk so let a contain either the operator
verify pos i  j    hvi   tuk   vi   tsk i  if  ji   xk  
or the operator
verify neg i  j    hvi   fku   vi   fks i  if  ji   xk  
     hence 
clearly  the instance f can be constructed in polynomial time and cg f     fm
it remains to prove that f has a solution if and only if f is satisfiable 
first consider only variables ui and vi   for some i  the construction of the domain and
the operators for ui is identical to the one for vc in the proof of lemma    i e  there is a
directed path from value f  to fn or tn for every possible truth assignment for the variables
x            xn in f   variable vi   corresponds to clause ci and contains two copies of the dtg for
ui   where the values differ only in the extra superscript  u or s  the latter copy is extended
with the additional value s  denoting that the clause has been satisfied  there are operators
that allows vi to mimic the behaviour of ui   it can follow the corresponding path in either
of its two copies  furthermore  for each of the three literals in ci there is an operator that

   

fibackstrom   jonsson

makes it possible to move from value zku to value zks if value zk of ui is consistent with this
s or ts in order to reach the goal value
literal  since vi starts at f u and must reach either fm
m
s  it is necessary for vi to make such a transition for one of the literals in ci   that is  if ui
follows the path f    z            zn then vi must follow the path f u   z u           zku   zks           zns   s  for
some k such that xk occurs in a literal in ci and zk is a satisfying truth value for this literal 
now consider also variable ui    since each operator that affects the value of vi either
has the same precondition on both ui  and ui or no precondition on either  it follows that
ui  and ui must both choose the same path if vi is to reach its goal  since every variable vj
forces synchronization of its adjacent variables uj  and uj in this manner  it follows that
all of u            um must choose exactly the same path for any plan that is a solution  it thus
follows from this and from the argument for ui and vi that the goal v            vm   s can
be achieved if and only if there is a path that all of u            um can choose such that this
path corresponds to a satisfying truth assignment for f  
for the restriction  we first note that it is immediate from the construction that operators
with   preconditions and   postcondition are sufficient  to see that   preconditions are
sufficient  consider the following variation on the construction  each step clause u and stepclause t operator is replaced with two operators as follows  as an example  consider an
u   tu    first introduce an extra value f tu in d v    then replace
operator step clause u j  fi 
j
i
i
the operator with two new operators
u   f tu     hv   f u   u
u
step clause u j  fi 
j
i
i  j    ti   vj   f ti i and
step clause u j  f tui   tui     hvj   f tui   uj   ti   vj   tui i 
u
consider the step in the dtg for vj from fi 
to tui   in the original construction  this is
u   tu    which requires that both u
done by the single operator step clause u j  fi 
j  and uj
i
u
have value ti   the modified construction instead requires two steps  first a step from fi 
u
u
to the new intermediate value f ti and then a step from this value to ti   the previous
conjunctive constraint that uj    uj   ti is replaced by a sequential constraint that first
uj    ti and then uj   ti   although it is technically possible for uj  to have moved on
to a new value when the second step is taken  this does not matter  both uj  and uj must
still choose exactly the same path in their respective dtgs 
corollary    planexist f     planexist f    and planexist f  are np hard 
proof  neither of the two outer source vertices  u  and um   are necessary in the construction
in the previous proof  hence  by omitting either or both of these the reduction works also
for f  and f    finally  planexist f  is np hard since f    f 
we now have all the basic results necessary for the main theorems of the following
two sections 

   graph classes and closure properties
like most other results in the literature  the results in the previous section are about classes
consisting of some particular graph type  like the class sin of all in stars or the class f of
all fences  this section will depart from this and instead study graph classes with certain
closure properties  we will first discuss the standard concepts of subgraph closure and minor
closure  finding that the first does not contain all the graphs we need while the latter results
   

fia refined view of causal graphs and component sizes

in a set with too many graphs  for that reason  we will define a new concept  sp closure 
which is incomparable with subgraph closure but is a subset of minor closure  we will then
show that this closure concept defines a borderline between the non np hard graph classes
and large number of useful np hard classes 
    subgraph closure and minor closure
suppose c is a class of graphs which is closed under taking subgraphs  then for every graph
g in c it is the case that every subgraph h of g must also be in c  subgraph closure is
not sufficient for our purposes  though  for instance  a subgraph of a polypath will always
be either a polypath or a graph where every weakly connected component is a polypath 
however  a polypath need not have any subgraphs that are fences of more than trivial size 
we will need a closure property that guarantees that if c contains a polypath with m sinks 
then it also contains a fence with m sinks  an obvious candidate for this is the concept of
minor closure  which is a superset of the subgraph closure  the concepts of graph minors
and minor closure has rapidly evolved into a very important and useful research area in
mathematical as well as computational graph theory  lovasz        mohar        
in order to define graph minors we first need the concept of edge contraction  which is
commonly defined as follows  although other definitions occur in the literature 
definition    let g    v  e  be a directed graph and let e    u  v   e be an edge such
that u    v  then the contraction of e in g results in a new graph g     v     e      such that
 v      v    u  v     w  and
 e       f  x   f  y      x  y   e   x  y      u  v  and  x  y      v  u   
where w is a new vertex  not in v   and the function f   v  v   is defined such that
f  u    f  v    w and otherwise f  x    x 
that is  when an edge  u  v  is contracted  the two vertices u and v are replaced with
a single new vertex w and all edges that were previously incident with either u or v are
redirected to be incident with w  figure   shows an example of edge contraction  we say
that a graph h is a contraction of another graph g if h can result from contracting zero
or more edges in g 
the concept of graph minors can now be defined as follows 
definition     a directed graph h is a minor of a directed graph g if h is isomorphic to
a graph that can be obtained by zero or more edge contractions of a subgraph of g 
an example is illustrated in figure    the graph g in the figure is a weakly connected
directed graph  which also happens to be a polypath  if vertex v  is removed from g 
then the restriction to the remaining vertices is still a weakly connected graph which is a
subgraph of g  removing also v  results in the graph h  which consists of two weakly
connected components h  and h    all of h  h  and h  are subgraphs of g  but they are
also minors of g  since a subgraph is a minor  by definition  contracting the edge  v    v   
in h  results in the graph m    where w  is the new vertex replacing v  and v    similarly 
contracting the edge  v    v    in h  results in m    the graph m  is a minor of g since it is
   

fibackstrom   jonsson

v 

v 
v  

v 

v  
v 

v 
v 

v 

v 

v 

v 

v 

w

v 

v 

v 

a  a graph g

v 

v 

b  the result of contracting edge  v    v    in g 

figure    edge contraction 

the result of an edge contraction in the subgraph h  of g and the graph m  is analogously
a minor of g too  also the graph m   consisting of the two components m  and m  is a
minor of g  since it is the result of two contractions in the subgraph h of g  while the
graphs h  h  and h  are both subgraphs and minors of g  the graphs m   m  and m  are
only minors of g  not subgraphs 

v 
v 
v 

v 
v 

v 
v 

v 
v 

v 

a  a polypath

v 

v 
v 

g

v 

v 
v 

w 

v 
m 

v 
h 

v 
w 
m 

h 

b  a subgraph h of g
 where h   h   h   

c  a minor m of g
 where m   m   m   

figure    subgraphs and minors 

a trivial example of a minor closed class is the class of all graphs  which is minor closed
since it contains all graphs and every minor of a graph is itself a graph  more interestingly 
many commonly studied graph types result in minor closed classes  for instance  the class
sin of all in stars is minor closed  as is the class sout of all out stars and the class dp of all
   

fia refined view of causal graphs and component sizes

directed paths  furthermore  a weakly connected minor of a polypath is a polypath and a
weakly connected minor of a polytree is a polytree  as an illustration  once again consider
figure    the graph g is a polypath  and the weakly connected graphs h    h    m  and
m  are all minors of g  but they are also polypaths  in fact  m  and m  are also fences 
note though  that neither h nor m is a polypath  since they both consist of more than one
weakly connected component  it is worth noting  however  that the class f of all fences is
not minor closed although every fence is a polypath  a weakly connected minor of a fence
must be a polypath  but it is not necessarily a fence 
requiring minor closed graph classes is  however  overly strong  for instance  it would
be sufficient to require that for every graph g  c  also every weakly connected minor of g
is in c  that is  in the example in figure   we would require that h    h    m  and m  are
all in c if g is in c  but we would not require that also h and m are in c  this is both
reasonable and desirable in the context of causal graphs  if the causal graph of a planning
instance consists of two or more weakly connected components  then these components
correspond to entirely independent subinstances that can be solved separately 
furthermore  certain natural restrictions do not mix well with minor closed classes 
consider  for instance  the example in figure    with an acyclic graph g    v  e   where
v    v    v    v    v    and e     v    v      v    v      v    v      v    v      if we contract the edge
 v    v    to a new vertex w we get a cycle graph on the vertices w  v    v    that is  a class of
acyclic graphs is not minor closed in general  which is problematic considering the importance of acyclic causal graphs 

v 

v 

v 

v 

v 
w

a  an acyclic graph g

v 
b  the contraction of  v    v    in g 

figure    contracting an edge in an acyclic graph can result in a cycle 

    sp closed graph classes
in order to avoid problems with acyclicity  and other similar problems  and to avoid defining
special variants of the contraction and minor concepts  we instead identify a set of minimal
requirements that a closure must satisfy in order to imply np hardness for the planexist
problem  we will focus on one such set of restrictions  defining a concept we refer to as
sp closure  where sp denotes that the set is closed under stars and polypaths  
definition     let g and h be two directed graphs  then h is an sp graph of g if h is
weakly connected and either of the following holds 
   h is an in star that is a subgraph of g 
   

fibackstrom   jonsson

   h is an out star that is a subgraph of g or
   h can be obtained by zero or more contractions of some polypath g  such that g  is
a subgraph of g 
a class c of graphs is sp closed if it contains every sp graph of every graph g  c 
sp closure has a number of interesting properties  including the following 
proposition     let g and h be directed graphs and let c be a class of directed graphs 
   if g is a polypath  then every sp graph of g is a polypath 
   every sp graph of g is acyclic 
   if h is an sp graph of g  then h is a minor of g 
   if c is minor closed  then c is sp closed 
proof     suppose g is a polypath  obviously  g cannot contain an in star or out star
with higher degree than two  and any such star is also a polypath  hence  we only need to
consider the third case in the definition  we note that any weakly connected subgraph g  of
g must also be a polypath  and that doing contractions on a polypath results in a polypath 
   immediate since in stars  out stars and polypaths are all acyclic and contracting edges
cannot introduce a cycle in any of these cases 
   immediate from the definitions of minors and sp graphs 
   immediate from   
this proposition says that it makes sense to talk about sp closed classes of polypaths
and sp closed classes of acyclic graphs  it also says that sp closure and minor closure
are comparable concepts  the sp closure of a class is a subset of the minor closure of the
same class 
we can now prove the following result about sp closed classes of polypaths  which we
need for the main theorem 
lemma     let c be an sp closed class of polypaths  if cc size c  is unbounded  then
planexist c  is np hard  this result holds even when restricted to operators with at most
  preconditions and   postcondition 
proof  proof by cases depending on whether the directed path length of c is bounded or not 
case    suppose that path length c  is unbounded  let n     be an arbitrary integer 
then there must be some graph g  c such that g contains a subgraph h that is a directed
path graph and v  h    n  obviously  h is an sp graph of g  since a directed path is
also a polypath  it follows that h  c since c is sp closed  furthermore  h   dpn so
np hardness of planexist c  follows from lemma    since n was choosen arbitrarily 
case    instead suppose that path length c   k for some constant k     let n     be
an arbitrary integer  since all graphs in c are polypaths and cc size c  is unbounded  there
must be some polypath g  c such that v  g   n  it thus follows from the assumption
and proposition   that g must have at least m sinks and m     sources  for some m such
   

fia refined view of causal graphs and component sizes

that v  g    mk      there must  thus  be some subgraph g  of g that is a polypath with
exactly m sinks and m     sources  i e  g  is weakly connected  and there must  thus  also
    
be a graph h that can be obtained by zero or more contractions of g  such that h   fm
it follows that h  c since c is sp closed  np hardness of planexist c  thus follows from
lemma    since n was choosen arbitrarily and k is constant 
to see that the result holds even if the operators under consideration have at most  
preconditions and   postcondition  simply note that this restriction holds for all reductions
used in the underlying np hardness proofs in section   
chen and gimenez        thm        proved a similar result  if c is a class of polypaths 
with unbounded components and unbounded number of sources  then planexist c  is not
polynomial time solvable unless w     nu fpt 
in order to prove the main result of this section  we also need the moore bound  biggs 
      p        which is stated as follows  for an arbitrary connected undirected graph g 
the maximum number of vertices is
 v  g        d

k 
x

 d    i  

   

i  

where d   deg g  and k   path length g  
we can now prove that under the additional restriction that graph classes are spclosed  we can avoid np intermediate problems and prove np hardness for graph classes
with unbounded components 
theorem     let c be an sp closed class of directed graphs  if cc size c  is unbounded 
then planexist c  is np hard  this result holds even when restricted to operators with at
most   preconditions and   postcondition and all graphs in c are acyclic 
proof  first suppose there is some constant k such that in deg c   k  out deg c   k and
upath length c   k  consider an arbitrary graph g  c  obviously  deg u  g     k and
path length u  g    k  p
so it follows from the moore bound that no component in u  g  can
i
have more than      k k 
i     k     vertices  however  since cc size g    cc size u  g  
and g was choosen arbitrarily  it follows that cc size c  is bounded  this contradicts the
assumption so at least one of in deg c   out deg c  and upath length c  is unbounded  the
remainder of the proof is by these three  possibly overlapping  cases 
case    suppose that in deg c  is unbounded  let n     be an arbitrary integer  then
there must be some graph g  c containing a vertex with indegree n or more  so there must
also be a subgraph h of g such that h   snin   hence  h  c since c is sp closed  it thus
follows from lemma   that planexist c  is np hard  since n was choosen arbitrarily 
case    suppose that out deg c  is unbounded  this case is analogous to the previous
one  but using lemma   instead of lemma   
case    suppose that upath length c  is unbounded  let n     be an arbitrary integer 
then there must be some graph g  c such that u  g  contains a path of length n  and there
must  thus  also be a subgraph h of g such that h is a polypath of length n  obviously  h
   chen and gimenez use the term source sink configuration for polypath 

   

fibackstrom   jonsson

is an sp graph of g  doing zero contractions  so h  c since c is sp closed  it thus follows
from lemma    that planexist c  is np hard  since n was choosen arbitrarily 
to see that the result holds even if the operators under consideration have at most  
preconditions and   postcondition  simply note that this restriction holds for all reductions
used in the underlying np hardness proofs in section    similarly  the acyclicity restriction
holds since the result is based only on in stars  out stars and polypaths  which are all
acyclic graphs 
this theorem is somewhat more restricted than the one by chen and gimenez since it
requires the additional constraint that c is sp closed  on the other hand  it demonstrates
that sp closure is a sufficient condition to avoid graph classes such that planexist is npintermediate and  thus  sharpen the result to np hardness  it should be noted  though 
that this is not an exact characterization of all graph classes that are np hard for planexist 
there are other such graph classes  but sp closure captures a large number of interesting
graph classes  for instance  the class of all acyclic graphs is sp closed  recall that this class
is not minor closed   although not every subclass of it is sp closed  as an opposite example 
any non empty class that does not contain a single acyclic graph cannot be sp closed 

   beyond sp closed graph classes
this section is divided into three parts  we first discuss why the previous results  as well as
most other similar np hardness results in the literature  are problematic  which motivates
us to switch over to non uniform complexity theory  the second part contains a number of
preparatory results that are required for the main theorem in the third part 
    why np hardness is not enough
we refer to a planning problem as generic if it has instances of varying size  depending on
one or more parameters  an archetypical example is the blocks world  where the natural
parameter is the number of blocks  for a particular encoding and a specified number of
blocks  the variables and operators will be the same whatever the inital state and goal is 
that is  if we fix the encoding then we get a planning frame n    vn   an   for every number 
n  of blocks  that is  n is the same for all instances with n blocks and is thus a function of
n  all instances  vn   init  goal  an   with n blocks will be instantiations of n with different
init and goal components but with the same vn and an components  an instance can thus
be specified with three unique parameters  n  init and goal  where only the first parameter 
n  affects the size of the instance  furthermore  the causal graph for an instance depends
only on the variables and the operators  which means that all instantiations of a frame n
have the same causal graph  which we denote cg n    the class of causal graphs for blocks
world instances will be d    cg      cg      cg              although                    and
thus also d  will differ depending on the encoding 
it is often possible to analyse the complexity of a particular generic planning problem 
examples of this are the complexity of blocks world planning  gupta   nau        and
the complexity of various problems from the international planning competitions  ipc 
 helmert            b   in the context of this article  though  we are rather interested
in the complexity of the class of causal graphs corresponding to a generic problem  than
   

fia refined view of causal graphs and component sizes

the complexity of the specific problem itself  suppose that a class d of causal graphs
happens to be a subset of some class c of graphs such that we know that planexist c  is
tractable  then we can infer that also planexist d  is tractable  and thus also that all
generic planning problems with causal graphs in d are tractable  however  in order to
prove that planexist d  is np hard  or hard for some other complexity class  we would
have to prove that there is some class c of graphs such that planexist c  is np hard and c
is a subset of d  finding such a class c may not be trivial  though 
one problem is that the encoding can have a large influence on how densely or sparsely
the causal graphs occur with respect to size  consider  for instance  blocks world encodings
with multi valued variables and with boolean variables respectively  a typical encoding with
multi valued variables will use one variable for the status of the hand and two variables for
each block  one for the position of the block and one to flag whether the block is clear or
not  that is  such encodings will use  n     variables for an n block frame  an encoding
with boolean variables  on the other hand  will typically represent the block position with
a number of boolean variables  one for each other block that a block can be on  a boolean
encoding will thus use n      variables for an n block frame  while d will contain a graph
for every odd number of vertices in the first case  it will be increasingly sparse in the second
case  the class d of causal graphs for a generic planning problem will  thus  typically not
be sp closed  or even closed under taking subsets  furthermore  since d will typically not
contain a member for every possible number of vertices  it cannot possibly contain any of
the known np hard sets sin   sout   dp etc  as a subset  hence  in order to prove that
a class d of causal graphs is hard for np  or some other complexity class   it will often
be necessary to make a dedicated proof for d  this is often doable  however  a generic
planning problem has a corresponding function f that takes a parameter value n  e g  the
number of blocks in blocks world  such that f  n    n   if f is furthermore polynomialtime computable in the value of n  which will often be the case  then also the corresponding
causal graph  cg n    is polynomial time computable  however  even if this can be done
for many generic planning problems  it will be a specific proof for every specific encoding of
every particular generic planning problem  the same holds for particular classes of causal
graphs  every specific class will typically require its own dedicated proof 
in order to get around these problems and to be able to prove a more general result that
does not depend on the specific planning problems or causal graphs  we switch over to nonuniform complexity  this makes it possible to prove more powerful results  while retaining
natural connections with the ordinary complexity classes  the basic vehicle for proving nonuniform complexity results is the advice taking turing machine  which is defined as follows 
definition     an advice taking turing machine m has an associated sequence of advice
strings a    a    a           a special advice tape and an advice function a  from the natural
numbers to the advice sequence  s t  a n    an   on input x the advice tape is immediately
loaded with a   x     after that m continues like an ordinary turing machine  except that
it also has access to the advice written on the advice tape 
if there exists a polynomial p s t    a n     p n   for all n      then m is said to use
polynomial advice  the complexity class p poly is the set of all decision problems that can
be solved on some advice taking tm that runs in polynomial time using polynomial advice 
   

fibackstrom   jonsson

note that the advice depends only on the size of the input  not its content  and need
not even be computable  somewhat simplistically  an advice taking turing machine is a
machine that has an infinite data base with constant access time  however  for each input
size there is only a polynomial amount of information while there might be an exponential
number of instances sharing this information  the power of polynomial advice is thus still
somewhat limited and useful relationships are known about how the non uniform complexity
classes relate to the standard ones are known  one such result is the following 
theorem      karp   lipton        thm       if np  p poly  then the polynomial
hierarchy collapses to the second level 
    preparatory results
before carrying on to the main theorem of this section  we need a few auxiliary results  we
first show that if a planning instance has a causal graph g that is a subgraph of some graph
h  then the instance can be extended to an equivalent instance with h as causal graph 
lemma     let  be a planning instance and let g be a directed graph such that cg  
is a subgraph of g  then there is a planning instance g such that
 g can be constructed from  in polynomial time 
 cg g     g and
 g has a solution if and only if  has a solution 
furthermore  g has the same maximum number of pre  and postconditions for its operators
as   or one more if this value is zero in   
proof  let     v  init  goal  a  be a planning instance and let cg      v  e   let
g    vg   eg   be a directed graph such that cg   is a subgraph of g  let u   vg   v  
construct a planning instance g    vg   initg   goalg   ag   as follows 
 dg  u            for all u  u   and
dg  v    d v        for all v  v    where   is a new value not in d v   
 initg  v    init v   for all v  v   and
initg  u       for all u  u  
 goalg  v    goal v   for all v  v   and
goalg  u  is undefined for all u  u  
 let ag consist of the following operators 
 let ag contain all a  a 
 for each edge  x  v   eg   e such that x  vg and v  v   let ag also contain
an operator star x  v    hx       v    i 
 for each edge  x  u   eg such that x  vg and u  u   let ag also contain
an operator set x  u    hx   init x    u    i 
   

fia refined view of causal graphs and component sizes

obviously g can be constructed in polynomial time and cg g     g  so it remains
to prove that g has a solution if and only if  has a solution 
suppose p   a            an is a plan for   then p is also a plan for g since goalg  u  is
undefined for all u  u and a            an  ag   to the contrary  suppose p   a            an is a
plan for g   for each operator ai in p   there are three cases      ai  a      ai is a set
operator or     ai is a star operator  in case    operator ai serves no purpose since it only
modifies some variable in u   which has an undefined goal value  in case    operator ai sets
some variable v  v to   and has no effect on any other variables  if goalg  v  is undefined 
then ai serves no purpose  otherwise there must be some operator aj   j   i  such that aj
can change v from   to some value in d v   i e  ai serves no purpose in this case either  it
follows that the operator sequence p   obtained from p by removing all operators that are
not in a is also a plan for g   furthermore  since p   contains only operators from a it is
also a plan for   it follows that  has a plan if and only if g has a plan 
this construction increases the maximum domain size by one but has very little effect
on the maximum number of pre  and postconditions  this is suitable for our purpose  since
we do not consider the influence of domain sizes in this article  other constructions are
possible if we want to balance the various factors differently 
in the proof of the forthcoming theorem we will also do the opposite of taking graph
minors  that is  starting from a minor g of some target graph h we will extend g to h 
in order to do so  we need an operation similar to the opposite of edge contraction  this is
satisfied by a graph operation known as edge subdivision 
definition     let g    v  e  be a directed graph and let  u  v   e be an edge such that
u    v  then the subdivision of  u  v  in g is a graph g     v   w   e     where w is a new
vertex and e      e     u  v       u  w    w  v   
although one might consider other definitions  e g  in the case where both  u  v  and
 v  u  are in e  this one is sufficient for our purpose and it follows the usual extension to
directed graphs  cf   kuhn  osthus    young         usually an operation called smoothing
is considered as the inverse of edge subdivision  however  smoothing can be viewed as a
restricted case of edge contraction  so it is reasonable to think of edge subdivision as a sort
of inverse of edge contraction  an example of edge subdivision is illustrated in figure   
we further note that just like an edge contraction of a polypath is a polypath  also an edge
subdivision of a polypath is a polypath 
we also need an operation on planning instances corresponding to edge subdivision
in their causal graphs  for that purpose  we need a concept of variable substitution for
operators  we denote the substitution of a variable w for a variable v in a partial state s
with a v w   defined as 

if x   w 
 s v  
s x  
if x  vars s     v  w  
s v w  x   

undefined  otherwise 
if a is an operator  then the operator a    a v w  is defined such that pre a      pre a  v w 
and post a      post a  v w  
   

fibackstrom   jonsson

v 

v 
v  

v 

v  
v 

v 
v 

v 

v 

v 

v 
v 

a  a graph g

v 

v 
v 

w

v 

v 
v 

v 

b  the result of subdividing edge  v    v    in g 

figure    edge subdivision 

we now have the necessary concepts for modifying an arbitrary planning instance such
that the result corresponds to subdividing an edge in the causal graph of the instance 
however  we will only need to do this for instances where the causal graph is a polypath 
before proving that this can be done  we first need the following lemma  which states a
certain reordering property for plans when the causal graph is a polypath  if we choose an
arbitrary vertex v in a polypath g and remove v from g  then g falls apart into two weakly
connected components c  and c    in other words  the vertices of g can be partitioned
into three sets c    c  and c  such that c     v  and there is no edge directly between
a vertex in c  and a vertex in c    it then follows from the definition of causal graphs
that no operator that changes some variable in c  can have a precondition on a variable
in c  and vice versa  the following lemma utilises this fact to prove that any sequence
of operators that does not change variable v can be reordered such that all operators that
change variables in c  come before all operators that change variables in c   
lemma     let     v  init  goal  a  be a planning instance such that g   cg   is a
polypath  let v be an arbitrary variable in v   let c     v  and let c    c   v be the two
 possibly empty  weakly connected components of g that result if vertex v is removed from
g  define ai    a  a   vars post a    ci   for all i     i      let p be a plan for  
let p    p  and q be operator sequences such that p   p    q  p  and q contains no operator
from a    let q  be the subsequence of q containing only operators from a  and let q 
be the subsequence of q containing only operators from a    then p    q    q    p  is a plan
for  
proof  assume c    c  and c  as defined in the lemma and recall that c     v   first
note that g is acyclic since it is a polypath  so all operators in a are unary  it follows
that  a    a    a    is a partition of a and  thus  that a   a   a    a  let s    init p    
obviously   vars pre a  c     vars post a  c     for all a in q  and  vars pre a  c   
 vars post a    c     for all a in q    i e  for any state s it holds that s a   c    s  c  for
all a in q  and that s a   c    s  c  for all a in q    furthermore  for any state s it holds
   

fia refined view of causal graphs and component sizes

that s a  v    s v  for all a in q  since a   a    it follows that s   q   c    s   q     c  and
s   q   c    s   q     c    hence 
s   q    q     c    s   q   c   
s   q    q     c    s   q     c    s   q   c  and
s   q    q     c    s   q     c    s   q   c   
that is  s   q    q      s   q  and it follows that also p    q    q    p  is a plan for  
we now prove that if  is a planning instance such that cg   is a polypath  then we
can subdivide any edge in cg   and create a planning instance   such that cg     is
this subdivision of cg   and   is solvable if and only if  is solvable 
lemma     let  be a planning instance such that cg   is a polypath and let e be an
edge in cg    then there is a planning instance   such that
   can be constructed from  in polynomial time 
 cg     is an edge subdivision of e in cg   and
   has a solution if and only if  has a solution 
proof  let     v  init  goal  a  be a planning instance such that cg   is a polypath and
let e    u  v  be an edge in cg    construct a new instance      v     init    goal    a   
as follows 
 v     v   w   where d w    d u  and w   v  
 init   v    init v   for all v  v   and
init   w    init u  
 goal    goal 
 let a  consist of the following groups of operators 
   let a  contain all operators a  a such that u   vars pre a   or v   vars post a   
   let a  contain the operator a u w  for every operator a  a such that
u  vars pre a   and v  vars post a   
   let a  contain an operator copy u  w  x    hu   x   w   xi for every value
x  d v  
the operators in group   are the original operators from a corresponding to all edges in
cg   except  u  v   the operators in group   are the operators from a corresponding
to edge  u  v  but modified to instead correspond to the new edge  w  v   the operators
in group   correspond to the new edge  u  w  and are defined such that variable w can
mimic variable u  clearly  this is a polynomial time construction and cg     is an edge
subdivision of cg    it remains to prove that   has a plan if and only if  has a plan 
if  suppose p   a            an is a plan for   construct a new operator sequence p  
over a  from p as follows  first  for each ai in p such that u  vars pre ai    and v 
vars post ai     replace ai with ai  u w   then  for each ai in p such that u  vars post ai    
   

fibackstrom   jonsson

let x   post ai   u  and add operator copy u  w  x  between ai and ai     the resulting
sequence p   is a plan for    
only if  suppose p   a            an is a plan for     define the corresponding state sequence
s            sn such that s    init  and si   s   a            ai   for all i     i  n   without losing
generality  assume that p is a shortest plan for     which implies that ai is applicable in
si  for every i     i  n   define three variable sets c    c  and c  as in lemma    such
that c     w   v  c  and u  c    also define the corrsponding partition  a    a    a    of
a    i e  ai    a  a    vars post a    ci   for all i     i      then a  contains all copy
operators and nothing else  before proving the main result of this direction  we first prove
the following auxiliary result 
according to lemma    we can assume that every longest subsequence ak           a  that
does not contain any operator from a  is on the form ak           am   am             a  such that
ak           am  a  and am             a   a    since it is a longest such sequence  it must
hold that either     k     or     ak   a    in case     we have sk    s    init    so
sk   u    sk   w  since init   u    init   w   in case     operator ak    copy u  w  x  for
some x such that sk   w    sk   u    x  hence  sk   u    sk   w    x since ak  does
not change u  that is  in either case we have sk   u    sk   w   furthermore  for all i
 k  i  m  it holds that si   c   c      sk    c   c    since ai  a    it follows that
si  u    si  w  for all i  k  i  m   now  for every i  k  i      if w  vars pre ai    then
ai must be on the form a u w   for some a  a  so v  vars pre ai    by definition  hence 
ai  a  so i  m and it follows that si   u    si   w   since this proof holds for all longest
subsequences not containing any operator from a  we can conclude the following  which
will be used below 
    for any operator ai in p such that ai   a u w  for some a  a  it holds that
si   u    si   w  
we now prove the main result of this direction  that also  has a plan since   has a
plan  we do so by constructing a plan p    for  from p in two steps  first we construct an
intermediate operator sequence p   and then construct the plan p    from p     the sequence
p   is technically not a plan for either  or     but this intermediate step makes the proof
clearer  temporarily introduce a virtual dummy operator dum that has no precondition
and no postcondition  i e  it is applicable in any state and has no effect  then construct
the new operator sequence p     b            bn over a   dum  as follows 
 if ai  a  then bi   ai  
 if ai is a copy operator  then bi   dum 
 otherwise  ai   a u w  for some operator a  a  so let bi be that operator a 
define the corresponding state sequence t            tn such that t    init  and ti   t   b            bi  
for all i     i  n   we claim that ti  v   si  v for all i     i  n   proof by induction
over i 
basis  t    s  by definition 
induction  suppose ti   v   si   v for some i     i  n   there are three cases 
    ai   bi and ai  a  then w is not in the pre  or postcondition of either ai or bi so
bi is applicable in ti  since ai is applicable in si  and ti   v   si   v by assumption 
furthermore  ti  v   ti   bi    v   si   ai    v   si  v  
   

fia refined view of causal graphs and component sizes

    ai is a copy operator and bi   dum  it is immediate from the definition of bi
that it is applicable in ti  and that ti   ti    furthermore  vars post ai     v    so
si  v   si   v   since ti   v   si   v by assumption it thus follows that ti  v   si  v  
    ai is bi  u w  and bi  a  it follows from     that si   w    si   u   so si   w   
ti   u  since u  v and ti   v   si   v by assumption  since ai is applicable in si   
pre ai   w    pre bi   u  and pre ai   x    pre bi   x  for all variables in v   u   it follows that
bi is applicable in ti    by definition  vars post bi      vars post ai       v   since both ai
and bi must be unary  and it thus also follows from the definition that post bi     post ai   
hence  it also follows that ti  v   si  v   since ti   v   si   v by assumption 
we have thus shown that ti  v   si  v for all i     i  n   furthermore  clearly
ti   ti  for all i such that bi   dum  it follows that we can create a plan p    for  by
removing all dummy operators from p    
we conclude that  has a solution if and only if   has a solution 
we will finally need the following observations about  sat instances  let f be a  sat
formula with n variables and m clauses  if it contains no repeated clauses  then
m
n
 m   n  and  thus          n   m 
 
 
furthermore  f can be represented as a list of  m literals which requires  m     log n  
 m     log  m  bits  plus some overhead  hence  f can be represented by at most cm  bits 
for some constant c  and we will later use the upper bound   m    which is safe 
we also note that the reduction used in the proof of lemma   transforms a  sat
instance with n variables and m clauses to a planning instance with n     m     n
variables  however  n   m so n    m        m    m      m  which can be safely
overestimated with n    m   
    the main theorem
we are now prepared to state and prove the main theorem of this section  it follows from the
proof of theorem    that if in deg c   out deg c  and upath length c  are all bounded for a
class c of graphs  then cc size c  is bounded  in that case it is immediate from theorem  
that planning is tractable for c  this begs the question what happens if these parameters are
not bounded by a constant  yet bounded by some slow growing function  we will consider
the case when they are allowed to grow slowly  as long as they are polynomially related to
the instance size  since we have also noted that practical planning problems will typically
not have a causal graph of every size  we will only require that for every graph g in c there
must also be some larger graph g  in c of size at most p  g    for some polynomial p  we
also define the parameter   g    max upath length g   in deg g   out deg g    and require
that   g  and   g   are polynomially related  it turns out that planning is still hard under
these restrictions  as the following theorem says 
theorem     let p and q be increasing polynomials on the natural numbers  let c be
a class of directed graphs containing a subset of weakly connected graphs g    g    g         
such that 
    v  g      p q     
 v  gi        v  gi     p  v  gi       for all i      and
   

fibackstrom   jonsson

    v  gi     q   gi     for all i    
if planexist c  is polynomial time solvable  then the polynomial hierarchy collapses  this result holds even when restricted to operators with at most   preconditions and   postcondition
and all graphs in c are acyclic 
proof  let g    g    g          be a sequence of weakly connected graphs in c as assumed in the
theorem  let h    h    h          be a sequence of graphs defined as follows  for each i     
hi   gj for the smallest j such that q i    v  gj    
we first prove that i underestimates   hi    combining the requirement that q i  
 v  gj    with condition   of the theorem  that  v  gj     q   gj     we get q i    v  gj    
q   gj     since hi   gj we get q i    v  hi     q   hi     that is  that i    hi    it
follows that also i   v  hi    holds 
we then prove that  v  hi    is polynomially bounded by p q i    since j is choosen as the
smallest value satisfying that q i    v  gj     it must be that either j     or  v  gj      
q i   if j      then hi   gj   g  and  v  g      p q     by condition   in the theorem 
hence   v  hi       v  g      p q      p q i    since p and q are increasing  otherwise 
when j      condition   of the lemma says that  v  gj     p  v  gj       combining
this with the inequality  v  gj       q i  yields that  v  gj     p  v  gj        p q i   
that is   v  hi     p q i   since hi   gj   combining this with the previous result that
i   v  hi    and the construction of hi yields that h    h    h  is a sequence of graphs with
non decreasing and unbounded size 
now  define a sequence a    a    a          of tuples such that for all i     either of the
following holds 
   in deg hi    i and ai    in deg  hi   xi   such that xi is a subgraph of hi and xi   siin  
   out deg hi    i and ai    out deg  hi   xi   such that xi is a subgraph of hi and
xi   siout  
   upath length hi    i and ai    upath length  hi   xi   such that xi is a subgraph of hi
and xi is a polypath of length i 
for every i      at least one of these three cases must hold since i    hi   
define an advice taking turing machine m that uses the sequence a    a    a          as
advice and takes  sat formulae as input  assume that the representation of each formula
f is padded to size   m  bits  where m is the number of clauses  although somewhat
redundant  this is still a reasonable encoding in the sense of garey and johnson        
let m work as follows  let f be an input formula with n variables and m clauses and
let t     f        m    then the advice is at    x  ht   xt    first m constructs a planning
instance f   there are three cases depending on x 
x   in deg  by construction  xt is a subgraph of ht such that ht   stin   since t     m 
and n   m  it follows that n  t  so xt contains a subgraph h   such that h     snin  
construct f in the same way as in the proof of lemma    using the vertices of h  
as variables  then  cg f     h    
x   out deg  analogous to previous case  but constructing f according to the proof of
lemma   instead 
   

fia refined view of causal graphs and component sizes

x   upath length  by construction  xt is a subgraph of ht which is a polypath of length
t     m    suppose that xt contains less than m sinks and m     sources and that
path length xt       m    it then follows from proposition   that
 v  xt       m    m          m          m    t 
however  this contradicts the construction so xt must either contain a directed path
of length   m  or have at least m sinks and m     sources 
   if xt contains a subgraph h   which is a directed path of length   m    then
construct a planning instance f according to the proof of lemma    using the
vertices from h   as variables  then  cg f     h    
   if xt contains a subgraph h   which is a polypath with m sinks and m   sources 
then construct a planning instance 
f according to the proof of lemma    us 
  
ing the variables of h as variables  then  cg 
f     fm   this graph is a
fence  i e  a polypath where all directed paths are of length    each such path
can be stretched to a directed path of arbitrary length by repeatedly applying
lemma     the graph h   is a polypath that can be used as a template for
which paths in cg 
f   to stretch and how much in order to get a graph that
 
is isomorphic to h   instance 
f can thus be modified into a new instance f
such that cg f     h    
all these constructions can be done in polynomial time  and for all cases  f has a
solution if and only if f is satisfiable  furthermore  cg f   is isomorphic to a subgraph
of ht in all four cases  according to lemma    it is thus possible to extend f to a new
 
 
planning instance  
f such that cg f     ht and f has a solution if and only if  has
a solution  this extension can be done in polynomial time according to the same lemma 
since planexist c  can be solved in polynomial time by assumption in the theorem 
it thus follows that m can solve  sat in polynomial time  however  this implies that
np  p poly  which is impossible unless the polynomial hierarchy collapses  theorem     
to see that the result holds even if the operators under consideration have at most  
preconditions and   postcondition  simply note that this restriction holds for all reductions
used in the underlying np hardness proofs in section    similarly  the acyclicity restriction
holds since the result is based only on in stars  out stars and polypaths  which are all
acyclic graphs 
recall the generic blocks world encoding that we discussed in the beginning of this
section  the class d of causal graphs for these blocks world instances satisfies the requirements in theorem     which means that planexist d  is not likely to be tractable  however 
finding non optimal plans for blocks world is tractable  a plan of length at most twice the
length of the optimal plan can be found in polynomial time  gupta   nau         that is 
there are most likely more difficult problems than blocks world that happen to have exactly
the same causal graphs  which illustrates that the complexity of a generic planning problem
cannot be deduced from its corresponding class of causal graphs alone 
   

fibackstrom   jonsson

   np hard and np intermediate classes
the theorem by chen and gimenez        states a crisp complexity theoretic borderline  if
the component sizes are bounded by a constant  then planning is polynomial time solvable
and  otherwise  planning is not polynomial time solvable  we have exploited an extra
constraint  sp closure  to be able to prove np hardness  which leaves a greyzone between
the polynomial cases and the np hard ones  if we no longer require the classes to be spclosed  then they are no longer obviously np hard even if the components are unbounded 
the natural question then arises  can we say something about this middle ground  for
instance  can we say something about what the np intermediate cases may look like and
where the borderline between np hard and np intermediate is  although it does not seem
likely that we could find any results that characterize this borderline exactly  we can at
least give some partial answers to these questions  we will do this by proving two theorems
related to the growth rate of the components  the first of these shows that planning is still
np hard if the components grow as o  v  g    k   for integers k  while the second one shows
that planning is likely to be np intermediate if the components grow polylogarithmically 
theorem     for every constant integer k      there is a class gk of graphs such that
cc size g    v  g    k for all g  gk and planexist gk   is np hard 
proof  let k     be an arbitrary integer  construct the graph class gk    g    g    g          
as follows  for each m      let gm have mk  components  each of them isomorphic to dpm  
i e   v  gm      mk so all components are of size m    v  gm     k   we prove np hardness
of planexist gk   by reduction from planexist dp   let  be an arbitrary planning instance
such that cg    dp  then cg     dpm for some m      construct a new instance  
which consists of mk  renamed copies of   this is clearly a polynomial time construction
since k is constant and m         furthermore  cg     is isomorphic to gm and   has a
solution if and only if  has a solution  hence  this is a polynomial reduction so it follows
from lemma   that planexist gk   is np hard 
obviously  the size of the graphs is exponential in k 
our second result must be conditioned by the assumption that the exponential time
hypothesis  impagliazzo   paturi        impagliazzo  paturi    zane        holds  this
hypothesis is a conjecture stated as follows 
definition     for all constant integers k      let sk be the infimum of all real numbers
 such that k sat can be solved in o  n   time  where n is the number of variables of an
instance  the exponential time hypothesis  eth  is the conjecture that sk     for all k     
informally  eth says that satisfiability cannot be solved in subexponential time  eth
is not just an arbitrarily choosen concept  but a quite strong assumption that allows for
defining a theory similar to the one of np completeness  there is a concept called serf
 subexponential reduction family  reduction which preserves subexponential time solvability  there is also a concept called serf completeness which is similar to np completeness 
but based on serf reductions  that is  there is a subclass of the np complete problems
that are also serf complete  meaning that these can all be serf reduced to each other 
hence  if one of these can be solved in subexponential time  then all of them can 
   

fia refined view of causal graphs and component sizes

theorem     for all constant integers k     and all classes c of directed graphs  if
cc size g   logk  v  g   for all g  c  then planexist c  is not np hard unless eth
is false 
proof  let k     be an arbitrary integer  let  be an arbitrary planning instance with n
variables of maximum domain size d such that cc size cg     c  the components correspond to independent subinstances  which can thus be solved separately  each component
has a state space of size dc or less  so a plan for the corresponding subinstance can be found
in o d c   time  using dijkstras algorithm  since there are at most n components  the whole
instance can be solved in o nd c   time  however  it follows from the standard assumptions
of reasonable encodings that both n       and d        so a looser bound is that  can
be solved in o x  x c     o x   c   time  where x        
suppose planexist c  is np hard  then there is a polynomial reduction from  sat
to planexist c   furthermore  the size of a  sat instance is polynomially bounded in the
number of variables  hence  there must be some polynomial p such that for a  sat instance
with n variables  the corresponding planning instance  has size       p n  
since the number of variables in  is upper bounded by       it follows from the assumption that the component size is upper bounded by logk       logk p n   hence   can
k
be solved in o p n     log p n    time  according to the earlier observation  and
p n     log

k

p n 

    log p n       log

k

p n 

        log

k

p n   logk p n 

      log

 k

 k

p n 

 

 k

furthermore  logk p n   o logk n   since p is a polynomial  so    log p n    o log n  and
 k
it follows that  can be solved in  o log n  time  however  then  can be solved in  n
time for arbitrarily small   which contradicts eth  it follows that planexist c  cannot be
np hard unless eth is false 
since the components are unbounded  this problem is not likely to be solvable in polynomial
time either  it is thus an np intermediate problem under the double assumption that
w      nu fpt and that eth holds 
theorems    and    together thus tell us something about where the borderline between
np intermediate and np hard graph classes is  however  it is not a very crisp distinction 
asymptotically  there is quite a gap between the polylogarithmic functions and the root
functions  i e  functions on the form x  k    one may  for instance  note that the function
 

f  n      log n 

 
 log log n c

lies within this gap whenever     c     

   discussion
sp closed graph classes have appealing properties and fit in well as a concept stronger than
subgraph closed but weaker than minor closed  they also give a partial characterization of
where the borderline to np hardness lies  however  as noted earlier  it is possible to define
other types of graph classes which also imply that planning is np hard  one example is
the family g    g    g          of classes in the proof of theorem     another more specialized
and  perhaps  contrived class is the following  intended to give a contrast to the sp closure
concept and the gk classes 
   

fibackstrom   jonsson

a tournament is a directed graph formed by giving directions to each edge in a complete
graph  let t denote the set of tournaments and note that t is not sp closed  however 
tournaments are hamiltonian graphs  redei        so if t is a tournament on n vertices 
then path length t     n     furthermore  the path of length n    can be computed in
polynomial time  bar noy   naor        
assume we are given a  sat formula f with n variables and m clauses  let    
  m     n  i e    is polynomially bounded in f   according to lemma   we can thus
construct a planning instance f in polynomial time such that
   f contains   variables 
   cg f     dp    and
   f has a solution if and only if f is satisfiable 
choose an arbitrary tournament t with   vertices in t  find the path of length    in t
and identify it with cg f    then add dummy operators corresponding to the remaining
edges of t   we have thus shown that there is a polynomial time transformation from  sat
to planexist t   and that planexist t  is np hard  one may also note that variations of
this technique can be used for proving that planexist t    is np hard for many different
t   t 
while we have not considered domain sizes or tractable restrictions in this article  we
note that the theorem    may give some ideas for where to look for tractable cases  consider
the case where all variable domains are bounded in size by some constant k and where
cc size g   log v  g   using the first part of the proof  we see that planning can be solved
in o n  k   log n   time  however  k   log n     log k    log n     log n    log k   n  log k   which is
polynomial since k is a constant  that is  planning is tractable for this restricted case  even
though this observation is straightforward  it is interesting as a contrast to theorem     it
also suggests that there are even larger tractable subgraphs if we also consider additional
restrictions on the planning instances 
while we have explicitly commented on the sufficient number of pre  and postconditions
for the various results  there are also alternative such characterizations that might be relevant  it would bear to far to list all such possibilities  so let it suffice with one example 
the concept of prevail conditions  i e  preconditions on variables that are not changed by
the operator  originate from the sas  formalism  backstrom   nebel        but has more
recently been considered also in the context of causal graphs  gimenez and jonsson       
refer to an operator as k dependent if it has a precondition on at most k variables that it
does not also change  we may note that the proofs of lemmata    and    only introduce
operators that are   dependent  at most  since the proof of theorem    does not impose
any further such restrictions on the original planning instance  it follows that this theorem
holds also when all operators are   dependent  at most 
as a final question  one might wonder if it is of any practical use at all to know that
planning is tractable  or np intermediate  for severely limited component sizes  after all 
most planning instances are likely to have a causal graph that is weakly connected  that
is  the whole graph is one single component  to answer that question  the first important
observation to make is that the complexity of planning for instances is directly related to
the complexity of planning for the components separately  this is because there can be at
   

fia refined view of causal graphs and component sizes

most linearly  in the number of variables  many components  if planning can be solved in
polynomial time for all components of an instance  then it can be solved in polynomial time
for the whole instance  conversely  if planning cannot be solved in polynomial time for the
whole instance  then there is at least one component which is not polynomial time solvable 
that is  the complexity results for instances and for components are directly related to each
other  in other words  the results are relevant for all methods that artificially split the causal
graph into components  in one way or another  examples are the causal graph heuristic by
helmert      a   factored planning  brafman   domshlak        and structural pattern
data bases  katz   domshlak        

acknowledgments
the anonymous reviewers provided valuable comments and suggestions for improving this
article 

references
backstrom  c     nebel  b          complexity results for sas  planning  computational
intelligence             
bar noy  a     naor  j          sorting  minimal feedback sets  and hamilton paths in
tournaments  siam journal on discrete mathematics             
biggs  n          algebraic graph theory  cambridge univ  press   nd ed 
bodirsky  m     grohe  m          non dichotomies in constraint satisfaction complexity 
in proceedings of the   th international colloquium on automata  languages and
programming  icalp        reykjavik  iceland  pp         
brafman  r  i     domshlak  c          structure and complexity in planning with unary
operators  journal of artificial intelligence research             
brafman  r  i     domshlak  c          factored planning  how  when  and when not  in
proceedings of the   st national conference on artificial intelligence  aaai       
boston  ma  usa  pp          aaai press 
chen  h     gimenez  o          causal graphs and structurally restricted planning  journal of computer and systems science                 
domshlak  c     dinitz  y       a   multi agent off line coordination  structure and complexity  in proceedings of the  th european conference on planning  ecp     toledo 
spain 
domshlak  c     dinitz  y       b   multi agent off line coordination  structure and complexity  tech  rep   department of computer science  ben gurion university  cs      
downey  r  g     fellows  m  r          parameterized complexity  monographs in computer science  springer  new york 
flum  j     grohe  m          parameterized complexity theory  vol  xiv of texts in
theoretical computer science  an eatcs series  springer  berlin 
   

fibackstrom   jonsson

garey  m  r     johnson  d  s          computers and intractability  a guide to the theory
of np completeness  w  h  freeman  new york 
gimenez  o     jonsson  a          the complexity of planning problems with simple
causal graphs  journal of artificial intelligence research             
gimenez  o     jonsson  a          planning over chain causal graphs for variables with
domains of size   is np hard  journal of artificial intelligence research             
gimenez  o     jonsson  a          the influence of k dependence on the complexity of
planning  artificial intelligence                
gupta  n     nau  d  s          on the complexity of blocks world planning  artificial
intelligence                   
helmert  m          complexity results for standard benchmark domains in planning 
artificial intelligence                  
helmert  m          a planning heuristic based on causal graph analysis  in proceedings
of the   th international conference on automated planning and scheduling  icaps
       whistler  bc  canada  pp          aaai press 
helmert  m       a   the fast downward planning system  journal of artificial intelligence
research             
helmert  m       b   new complexity results for classical planning benchmarks  in proceedings of the   th international conference on automated planning and scheduling
 icaps        cumbria  uk  pp        aaai press 
impagliazzo  r     paturi  r          on the complexity of k sat  journal of computer
and system science                 
impagliazzo  r   paturi  r     zane  f          which problems have strongly exponential
complexity   journal of computer and system science                 
jonsson  a          the role of macros in tractable planning  journal of artificial intelligence research             
jonsson  p     backstrom  c       a   state variable planning under structural restrictions 
algorithms and complexity  artificial intelligence                    
jonsson  p     backstrom  c       b   tractable plan existence does not imply tractable
plan generation  annals of mathematics and artificial intelligence                   
karp  r  m     lipton  r  j          some connections between nonuniform and uniform complexity classes  in proceedings of the   th acm symposium on theory of
computing  stoc     los angeles  ca  usa  pp         
katz  m     domshlak  c          structural patterns of tractable sequentially optimal
planning  in proceedings of the   th international conference on automated planning
and scheduling  icaps        providence  ri  usa  pp          aaai press 
katz  m     domshlak  c          new islands of tractability of cost optimal planning 
journal of artificial intelligence research             
katz  m     domshlak  c          implicit abstraction heuristics  journal of artificial
intelligence research            
   

fia refined view of causal graphs and component sizes

katz  m   hoffmann  j     domshlak  c          who said we need to relax all variables   in proceedings of the   rd international conference on automated planning
and scheduling  icaps        rome  italy          aaai press 
katz  m     keyder  e          structural patterns beyond forks  extending the complexity
boundaries of classical planning  in proceedings of the   th aaai conference on
artificial intelligence  aaai        toronto  on  canada  aaai press 
knoblock  c  a          automatically generating abstractions for planning  artificial
intelligence                 
kuhn  d   osthus  d     young  a          a note on complete subdivisions in digraphs of
large outdegree  journal of graph theory             
ladner  r  e          on the structure of polynomial time reducibility  journal of the
acm                 
lovasz  l          graph minor theory  bulletin of the ams               
mohar  b          what is     a graph minor  notices of the ams                 
redei  l          ein kombinatorischer satz  acta litteraria szeged          
wehrle  m     helmert  m          the causal graph revisited for directed model checking 
in proceedings of static analysis  the   th international symposium  sas     los
angeles  ca  usa  vol       of lncs  pp         springer 
williams  b     nayak  p  p          a reactive planner for a model based executive 
in proceedings of the   th international joint conference on artificial intelligence
 ijcai     nagoya  japan  pp           

   

fi