journal of artificial intelligence research                  

submitted        published      

protecting privacy through distributed computation
in multi agent decision making
thomas leaute
boi faltings

thomas leaute a  epfl ch
boi faltings epfl ch

ecole polytechnique federale de lausanne  epfl 
artificial intelligence laboratory  lia 
station   
ch      lausanne  switzerland

abstract
as large scale theft of data from corporate servers is becoming increasingly common  it
becomes interesting to examine alternatives to the paradigm of centralizing sensitive data
into large databases  instead  one could use cryptography and distributed computation so
that sensitive data can be supplied and processed in encrypted form  and only the final
result is made known  in this paper  we examine how such a paradigm can be used to
implement constraint satisfaction  a technique that can solve a broad class of ai problems
such as resource allocation  planning  scheduling  and diagnosis  most previous work on
privacy in constraint satisfaction only attempted to protect specific types of information 
in particular the feasibility of particular combinations of decisions  we formalize and
extend these restricted notions of privacy by introducing four types of private information 
including the feasibility of decisions and the final decisions made  but also the identities of
the participants and the topology of the problem  we present distributed algorithms that
allow computing solutions to constraint satisfaction problems while maintaining these four
types of privacy  we formally prove the privacy properties of these algorithms  and show
experiments that compare their respective performance on benchmark problems 

   introduction
protecting the privacy of information is becoming a crucial concern to many users of the
increasingly ubiquitous information and communication technologies  companies invest a
lot of effort into keeping secret their internal costs and their future development strategies
from other actors on the market  most importantly from their competitors  individuals also
have a need for privacy of their personal information  for instance  carelessly disclosing ones
activity schedule or location might reveal to burglars opportunities to break into ones home 
on the other hand  accessing and using such private information is often necessary to solve
problems that depend on these data  in the context of supply chain management  companies
need to exchange information with their contractors and subcontractors about the quantities
of goods that must be produced  and at what price  when scheduling meetings or various
events with friends or co workers  individuals are confronted with the challenge of taking
coordinated scheduling decisions  while protecting their respective availability schedules 
artificial intelligence can be a crucial tool to help people make better decisions under
privacy concerns  by delegating part or all of the decision problem to personal intelligent
agents executing carefully chosen algorithms that are far too complex to be performed
     ai access foundation  all rights reserved 

fileaute   faltings

by the human alone  in particular  the framework of constraint satisfaction problems
 csps  is a core ai technology that has been successfully applied to many decision making
problems  from configuration to scheduling  to solving strategic games  here we show how
distributed ai algorithms can be used to solve such csps  while providing strong guarantees
on the privacy of the problem knowledge  through the use of techniques borrowed from
cryptography  this makes it possible to solve coordination problems that depend on secret
data  without having to reveal these data to other parties  on the other hand  distributed 
encrypted computation involving message exchange has a cost in terms of performance 
such that a suitable tradeoff between privacy and scalability must be found 
    motivating examples
in this paper  we present a set of novel  privacy protecting algorithms for distributed constraint satisfaction problems  discsps   a wide class of multi agent decision making problems with applications to many problems such as configuration  scheduling  planning  design
and diagnosis  we consider three examples to illustrate the privacy requirements that might
arise  meeting scheduling  airport slot allocation  and computing game equilibria 
in a meeting scheduling problem  maheswaran  tambe  bowring  pearce    varakantham         a number of meetings need to be scheduled  involving possibly overlapping sets
of participants  taking into account their respective availability constraints  all participants
to any given meeting must agree on a time for the meeting  one given participant can be
involved in multiple meetings  which creates constraints between meetings  in this problem class  participants usually want to protect the privacy of their respective availability
schedules  as well as the lists of meetings they are involved in 
another problem class is airport slot allocation  rassenti  smith    bulfin         where
airlines express interests in combinations of takeoff and landing time slots at airports  corresponding to possible travel routes for their aircraft  while the end goal for the airports is
to efficiently allocate their slots to airlines  from the point of view of the airlines it is crucial
that the combinations of slots they are interested in remain private  because they indicate
the routes they intend to fly  which is sensitive strategic information that they want to hide
from their competitors 
finally  consider the general class of one shot strategic games  such as the party game
 singh  soni    wellman         the players are invited to a party  and must decide whether
to attend  based on their respective intrinsic costs of attendance  and on whether the people
they like or dislike also choose to attend  players would best play strategies that form a
nash equilibrium  where no single player can be better off by deviating from its chosen
strategy  the problem of computing such an equilibrium is a typical example of a multiagent decision making problem  in which privacy is an issue  players do not necessarily want
to reveal their attendance costs  nor whether they like or dislike another invitee 
    four types of private information
as can be seen in the previous examples  the information that participants would like to
keep private can differ in nature  we propose to classify it into four privacy types  we only
briefly introduce and illustrate them here  more formal definitions are given in section       
   

fiprotecting privacy thru distributed computation in multi agent decision making

   agent privacy relates to the identities of the participants  consider for instance a
ceo who wants to schedule two meetings respectively with a journalist and with
another companys ceo  revealing to the journalist the other ceos involvement in
the decision making problem could leak out the companies plans to merge  in this
case agent privacy can be considered critical 
   topology privacy covers information about the presence of constraints  this is the
type of critical information that airline companies want to keep secret in the airport
slot allocation problem  the presence of a constraint between an airline and a specific
airport reveals the airlines strategic plans to offer flights to and from this airport 
   constraint privacy is about the nature of the constraints  this covers for instance
the participants availability schedules in the meeting scheduling problem  and  in the
party game  whether a player likes or dislikes other invitees 
   decision privacy has to do with the solution that is eventually chosen to the problem 
depending on the problem class  this type of privacy may or may not be relevant  in
the meeting scheduling problem  the time chosen for each meeting necessarily has to
be revealed to all participants of the meeting  however it can be desirable to hide this
information from non attendees 
like in previous work on privacy in discsp  we assume that the participants are honest 
but curious  goldreich         in that they honestly follow the algorithm  but are interested
in learning as much as possible from other agents private information based on the messages exchanged  note that this honesty assumption does not mean that all agents are
assumed to faithfully report their true constraints to the algorithm  they may be tempted
to strategize by reporting slightly different constraints  hoping that this would lead the algorithm to select a solution to the problem that they deem preferable to them  this issue of
incentive compatibility has been addressed in related work such as by petcu  faltings  and
parkes         and is orthogonal to the issue of privacy addressed in this paper  furthermore  an agent would take a risk in reporting constraints different from its true constraints 
reporting relaxed constraints could yield a solution that violates its true constraints and
would therefore not be viable  while reporting tighter constraints could make the overall
problem infeasible and the algorithm fail to find any solution at all 
on the other hand  our algorithms depart from previous work in two respects  first 
previous work almost exclusively focused on constraint privacy  most often ignoring agent 
topology and decision privacy  we show how to address all four types  and the algorithms
we propose correspond to various points in the tradeoff between different levels of privacy
and efficiency  second  while most of the literature focuses on quantitatively measuring
and reducing the amount of privacy loss in various discsp algorithms  we have developed
algorithms that give strong guarantees that certain pieces of private information will not be
leaked  in contrast  in previous privacy protecting algorithms  it is typically the case that
any piece of private information may be leaked with some  small  probability 
the rest of this paper is organized as follows  section   first formally defines the discsp
framework and the four aforementioned types of privacy  section   then presents a first
algorithm  called p dpop   section   then describes the p     dpop  algorithm  which is
   

fileaute   faltings

a variant that achieves a higher level of decision privacy  at the expense of an additional
computational overhead  another variant  called p   dpop   is introduced in section   in
order to further improve constraint privacy  finally  section   compares the performance
of these algorithms with the previous state of the art  on several classes of benchmarks 

   preliminaries
this section first formally defines the discsp framework  section       and then introduces
four types of privacy  section      
    distributed constraint satisfaction
after providing a formal definition of distributed constraint satisfaction  section        
we recall some existing algorithms for discsp and its optimization variant  section        
      definition
a distributed constraint satisfaction problem can be formally defined as follows 
definition    discsp   a discrete discsp is a tuple   a  x   a  d  c   
 a    a         ak   is a set of agents 
 x    x         xn   is a set of variables 
 a   x  a is a mapping that assigns the control of each variable xi to an agent a xi   
 d    d         dn   is a set of finite variable domains  variable xi takes values in di  
 c    c         cm   is a set of constraints  where each ci is a s ci   ary function of scope
 xi         xis ci      ci   di       dis ci     false  true   assigning false to infeasible
tuples  and true to feasible ones 
v
a solution is a complete assignment such that the conjunction ci c ci   true  which is
the case exactly when the assignment is consistent with all constraints 
some of the important assumptions of the discsp framework are the following  first 
we assume that all the details of a given constraint ci are known to all agents involved  if an
agent wants to keep some constraints private  it should formulate them in such a way that
they only involve variables it controls  furthermore  we assume that two neighboring agents
 i e  agents that share at least one constraint  are able to communicate with each other
securely  and that messages are delivered in fifo order and in finite time  on the other
hand  we assume that two non neighboring agents initially ignore everything about each
other  even including their involvement in the problem  in particular  a discsp algorithm
that protects agent privacy should not require them to communicate directly  nor should it
even allow them to discover each others presence  finally  we assume each agent honestly
follows the protocol  and we focus on preventing private information leaks to other agents 
figure   introduces a simple graph coloring problem instance that will be used to illustrate the algorithms throughout the rest of this paper  we assume that the five nodes in
   

fiprotecting privacy thru distributed computation in multi agent decision making

r    x 

  

  
x 

x     b
  

  

x 

  

x     b  r 

figure    the discsp constraint graph for a simple graph coloring problem instance 

the graph correspond to five different agents  which must each choose a color among red 
blue and green  these decisions are modeled by the five variables x            x  with domains
 r  b  g   each agent may express a secret  unary constraint on its variable  for instance 
x  does not want to be assigned the color red  binary  inequality constraints are imposed
between each pair of neighboring nodes  and are only known to the two agents involved 
distributed constraint optimization  dcop  is an extension of the discsp formalism 
in which constraints specify not only which variable assignments are feasible or infeasible 
but also assign costs  or utilities  to these assignments  an  optimal  solution to such a
dcop is then one that minimizes the sum of all costs  or maximizes the sum of all utilities  
the algorithms in this paper can easily be generalized to solve dcops  with a complexity
increase that is at most linear in an upper bound on the  assumed integer  cost of the
optimal solution  such a generalization is left outside the scope of this paper for the sake
of conciseness  and has been addressed by leaute and faltings        and leaute        
      complete algorithms for discsps
a range of distributed algorithms exist in the literature to solve discsps and dcops 
they can be seen as belonging to two classes  depending on how they order variables  the
largest class consists of algorithms that order the variables along a linear order  such as
abt  yokoo  durfee  ishida    kuwabara         awc  yokoo         synchbb  hirayama   yokoo         aas  silaghi  sam haroud    faltings         afc  meisels  
zivan         disfc  brito   meseguer          comp apo  mailler   lesser        grinshpoun   meisels         concdb  zivan   meisels         afb  gershman  meisels   
zivan        and concfb  netzer  meisels    grubshtein         the linear order may be
chosen and fixed initially before the algorithm is run  or dynamically revised online 
in the second class  variables are ordered along a tree based partial order  this includes
adopt  modi  shen  tambe    yokoo        and its variants such as bnb adopt  yeoh 
felner    koenig        and bnb adopt   gutierrez   meseguer         dpop  petcu
  faltings        and its countless variants  and ncbb  chechetka   sycara         which
all order the variables following a pseudo tree  definition     among the aforementioned
pseudo tree based algorithms  dpop is the only one using dynamic programming  dp  
while all others are based on search  other algorithms have been proposed that perform dp
on different partial variable orders  action gdl uses junction trees  vinyals  rodrguezaguilar    cerquides         and dcte cluster trees  brito   meseguer        
   

fileaute   faltings

      the dpop algorithm
the dpop algorithm was originally designed to solve optimization problems  dcops  and
described in terms of utility maximization  one way to apply it to pure satisfaction problems
 discsps  is to first reformulate the discsp into a max discsp  in which the constraints
are no longer boolean but rather take values in         where   stands for feasibility and
  for infeasibility  the cost minimizing variant of dpop  described below  can then be
applied to find a solution with minimal cost  where the cost  hereafter called feasibility
value  corresponds to the number of constraint violations  which we want to be equal to    
overview of the algorithm dpop is an instance of the general bucket elimination
scheme by dechter         performed distributedly  algorithm     it requires first arranging
the constraint graph into a pseudo tree  formally defined as follows 
definition    pseudo tree   a pseudo tree is a generalization of a tree  in which a node is
allowed to have links  back edges  with remote ancestors  pseudo parents  and with remote
descendants  pseudo children   but never with nodes in other branches of the tree 
a pseudo tree arrangement of the constraint graph in figure   is illustrated in figure   
this pseudo tree naturally decomposes the original problem into two  loosely coupled subproblems  corresponding to the two branches  which will perform the rest of the algorithm
in parallel  figure   also shows the feas messages  originally called util messages in the
context of utility maximization  that are exchanged during the propagation of feasibility
values  following a multi party dynamic programming computation  lines   to      in this
algorithm   overal dpop algorithm  for variable x
require  a pseudo tree ordering of the variables  px denotes xs parent
       util propagation  propagate feasibility values up the pseudo tree 
   m x  px      c c c   xscope c   scope c   childrenx pseudo childrenx     c x   
   join with received messages 
for each yi  childrenx do
  
wait for the message  feas  mi  x     from yi
  
sepyi  scope mi  
  
m x  px      m x  px       mi  x   
  
  

   project out x 
if x is not the root variable then
   
x  px      arg minx  m x  px     
   
send the message  feas  m x  px      px      to px
    else x  arg minx  m x      m x  px     actually only depends on x
  

  

   
   
   
   
   

    value propagation  propagate decisions top down along the pseudo tree 
if x is not the root then
wait for message  decision  px     from parent px
x  x  px   px    
for each yi  childrenx do send message  decision  sepyi   to yi
   

fiprotecting privacy thru distributed computation in multi agent decision making

x 

x   x 
r b g
     
x   x 
x 
r
 
b
 
g
 

x   x 
x 
x  r b g
r
     
b
     
g
     

x 

x 

x 

x 

x 

x   x 
x 
x  r b g
r
     
b
     
g
     

figure    multiparty dynamic programming computation of a feasible value for x    based
on a pseudo tree arrangement of the constraint graph in figure    the dashed
edge represents a back edge with a pseudo parent in the pseudo tree 

part of the algorithm  all messages travel bottom up along tree edges  consider for instance
the message sent by agent a x    to its parent agent a x     this message is the result of
the projection  lines    and     of variable x  out of the conjunction  line    of x  s two
constraints x     x  and x     b  and summarizes the minimal number of constraint violations that a x    can achieve  as a function of the ancestor variable x    more generally 
each message sent by a variable x summarizes the minimal number of constraint violations
achievable for the aggregate subproblem owned by the entire subtree rooted at x  as a
function whose scope is called the separator of x  line     in dpop  the separator of x necessarily includes xs parent px   and potentially other ancestor variables  this is indicated by
the notation m px      for instance  the message x   x  summarizes the minimal number
of constraint violations achievable for the entire subtree rooted at x    as a function of x  s
separator  px    x    x     notice that the separator of a variable x can contain variables
that are not neighbors of x  for example  x  is in x  s separator because a descendent of x 
has a constraint with x    in the privacy aware algorithms presented later in this paper  this
notion of separator is extended to allow for separators that do not necessarily include the
parent variable  and that may include multiple codenames referring to the same variables 
which might not necessarily be ancestors in the pseudo tree 
upon receiving the messages x   x  and x   x   line     agent a x    joins them
 line    with its constraint x     x    variable x  is then projected out of the resulting joint
table  which produces the message x   x   lines    and      at the end of this feasibility
propagation  line      the root variable x  chooses a value x  for itself that minimizes the
number of constraint violations over the entire problem  e g  x    r   this decision can
then be propagated downwards along tree edges via decision messages  originally called
value messages  until all variables have been assigned optimal values  lines    to     
   

fileaute   faltings

complexity given a pseudo tree ordering of the n variables  dpops bottom up and
top down phases each exchange exactly  n     messages  one through each tree edge  
however  while each decision message contains at most  n     variable assignments  the
feas message sent by a given variable x can contain exponentially many feasibility values 
because it contains a table representation of a function m of  sepx   variables  the size of
sepmax
the largest feas message is therefore o dmax
   where dmax is the size of the largest
variable domain  and sepmax   maxx  sepx     n    is the width of the pseudo tree  in the
best case  the width is equal to the treewidth of the constraint graph  however finding a
pseudo tree that achieves this minimal width is np hard  in practice  the pseudo tree is
generated by a heuristic  distributed  depth first traversal of the constraint graph  online
appendix     producing a so called dfs tree that is a pseudo tree in which all parentchild relationships are between neighbors in the constraint graph  since dpop exchanges
 n     feas messages  its overall complexity in terms of runtime  measured in number of
sepmax
constraint checks   memory  and information exchange is o n  dmax
  
privacy properties the privacy aware algorithms in section   are based on dpop 
because of two desirable properties that allow for higher levels of privacy  first  dpop
only requires message exchanges between neighboring agents  provided that the pseudotree used is a dfs tree  this is necessary to protect agent privacy  greenstadt  pearce 
and tambe        made the opposite claim that pseudo trees are detrimental to privacy
compared to linear orderings  however this claim is only valid if the only type of privacy
considered is constraint privacy  and does not hold if agent privacy and topology privacy
are guaranteed  i e  if the pseudo tree is not publicly known to all agents  the second  dpinherited property is that dpops performance does not depend on constraint tightness 
i e  how easy or hard it is to satisfy each constraint  for all other  search based algorithms 
inferences on the constraint tightness can be made by observing the runtime or the amount of
information exchanged  silaghi   mitra         in the case of meeting scheduling problems 
constraint tightness maps directly to the participants levels of availability  which is private
information  in application domains where this leak of constraint tightness is tolerable 
algorithms based on search rather than dp can be used  and many of the privacy enhancing
techniques presented in this paper for dpop are also applicable to search based algorithms 
    privacy in discsps
section       formally defines the four types of privacy considered in this paper  section      
then recalls previous work that attempted to address various subsets of these privacy types 
      privacy definitions
definition   introduces the concept of semi private information  faltings  leaute    petcu 
       which may inevitably be leaked by any discsp algorithm 
definition    semi private information   semi private information refers to information
about the problem and or its solution that an agent might consider private  but that can
inevitably be leaked to other agents by their views of the chosen solution to the discsp 
in other words  semi private information covers everything a given agent can discover
about other agents by making inferences simply based on its initial knowledge of the problem
   

fiprotecting privacy thru distributed computation in multi agent decision making

and on the values its variables take in the solution  for instance  in a graph coloring problem
involving only two colors  each node can infer the color of each of its neighbors from the
color it was assigned in the chosen solution  provided that the solution is correct  excluding
semi private information  we now distinguish four types of private information that agents
may desire to protect  faltings et al         
definition    agent privacy   no agent should be able to discover the identity  or even the
existence of non neighboring agents  a particular consequence of this type of privacy is that
two agents should only be allowed to communicate directly if they share a constraint 
in figure    this means for instance that agent a x    should not be able to discover the
existence and identities of agents a x    and a x     even if no two non neighboring agents
communicate directly  agent privacy might still be leaked by the contents of messages  in
this paper we propose a method based on codenames to fully protect agent privacy 
definition    topology privacy   no agent should be able to discover the existence of
topological constructs in the constraint graph  such as nodes  i e  variables   edges  i e 
constraints   or cycles  unless it owns a variable involved in the construct 
in figure    topology privacy means for instance that agent a x    should not discover
how many other neighbors x  has besides itself  however  a x    might discover the existence
of a cycle involving x    x  and x    this is tolerated because x  is involved in this cycle  but
a x    should not discover the length of the cycle  i e  that x  and x  share a neighbor  
definition    constraint privacy   no agent should be able to discover the nature of a
constraint that does not involve a variable it owns 
in figure    an example of a breach in constraint privacy would be if agent a x    were
able to discover that agent a x    does not want to be assigned the color blue  this is the
type of privacy that the discsp literature mostly focuses on 
definition    decision privacy   no agent should be able to discover the value that another
agents variable takes in the chosen solution  modulo semi private information  
in a distributed graph coloring problem  this means that no agent can discover the color
of any neighbor  let alone any non neighboring agent  in the solution chosen to the problem 
      previous work on privacy in discsp
before discussing what information may be leaked by a given algorithm  and how to prevent
it  it is important to clarify what information is assumed to be initially known to each agent 
initial knowledge assumptions in this paper  we use the following three assumptions 
which are currently the most widely used in the discsp literature 
   each agent a knows all agents that own variables that are neighbors of as variables 
but does not know any of the other agents  not even their existence  
   a variable and its domain are known only to its owner agent and to the agents owning
neighboring variables  but the other agents ignore the existence of the variable 
   

fileaute   faltings

   a constraint is fully known to all agents owning variables in its scope  and no other
agent knows anything about the constraint  not even its existence  
brito and meseguer        introduced partially known constraints  pkcs   whose
scopes are known to all agents involved  but the knowledge of whose nature  which assignments are allowed or disallowed  is distributed among these agents  this is a relaxation of
assumption    however it is worth noting that the algorithms presented in this paper can
still support pkcs without introducing privacy leaks by enforcing this assumption  because
any pkc can be decomposed into a number of constraints over copy variables such that
assumption   holds  for instance  if agents a        an share the knowledge of a unary pkc
over variable x  then this constraint can be decomposed into n unary constraints  such
that each constraint ci is known fully and only to agent ai and is expressed over a copy
variable xi owned by ai   equality constraints are added to the problem to enforce equality
of all copy variables  however  the introduction of copy variables can be detrimental to
decision privacy  grubshtein  grinshpoun  meisels  and zivan        later proposed the
similar concept of asymmetric constraints  which can also be reformulated as symmetric
constraints over copy variables for the purpose of applying our algorithms 
other previous work adopted a dual approach  assuming that variables are public and
known to all agents  but each constraint is known to only one agent  silaghi et al        
yokoo  suzuki    hirayama        silaghi      a   silaghi      b  even proposed a framework in which the constraints are secret to everyone  this dual approach has the disadvantage of necessarily violating topology privacy  since all variables are public 
measuring constraint privacy loss most of the literature on privacy in discsps
focuses on constraint privacy  metrics have been proposed to evaluate constraint privacy
loss in algorithms  in particular for distributed meeting scheduling  franzin  freuder  rossi 
  wallace        wallace   freuder         maheswaran  pearce  bowring  varakantham 
and tambe        designed a framework called valuation of possible states  vps  that
they used to measure constraint privacy loss in the optapo and synchbb algorithms  and
they considered the impact of whether the problem topology is public or only partially
known to the agents  greenstadt et al         also applied vps to evaluate dpop and
adopt on meeting scheduling problems  under the assumption that the problem topology
is public  doshi  matsui  silaghi  yokoo  and zanker        proposed to consider the cost of
privacy loss in optimization problems  in order to elegantly balance privacy and optimality 
preventing constraint privacy loss some previous work also proposed approaches to
partially reduce constraint privacy loss  for instance  brito and meseguer        described
a modification of the distributed forward checking  disfc  algorithm for discsps in which
agents are allowed to lie for a finite time in order to achieve higher levels of privacy  however  the performance of most search based algorithms like disfc leaks information about
constraint tightness  as explained at the end of section        to avoid this subtle privacy
leak  one must either perform full exhaustive search  which is the option chosen by silaghi 
or resort to dynamic programming  which is the option we have chosen in this paper 
the cryptographic technique of secret sharing  shamir        ben or  goldwasser   
wigderson        was also applied by silaghi  faltings  and petcu        and greenstadt 
grosz  and smith        to lower constraint privacy in dpop  assuming that the constraint
graph topology is public knowledge  cryptography has also been applied to provide strong
   

fiprotecting privacy thru distributed computation in multi agent decision making

guarantees on constraint privacy preservation in multi agent decision making  for instance 
yokoo and suzuki         yokoo et al         and yokoo  suzuki  and hirayama       
showed how a public key encryption scheme can be used to solve discsps using multiple
servers  while protecting both constraint privacy and decision privacy  bilogrevic  jadliwala 
hubaux  aad  and niemi        solved single meeting scheduling problems using similar
techniques  and one semi trusted server  in this paper however  we only consider algorithms
that do not make use of third parties  as such third parties might not be available  herlea 
claessens  preneel  neven  piessens  and decker        showed how to use secure multiparty
computation  smc    to securely schedule a single meeting  without relying on servers  in
smc  agents collaboratively compute the value of a given  publicly known function on
private inputs  without revealing the inputs  for herlea et al          the inputs are each
participants availability at a given time  and the function outputs whether they are all
available 
the mpc discsp  algorithm silaghi      a  also applied smc to solve general
discsps  where the private inputs are the agents constraint valuations  and the function
returns a randomly chosen solution  the algorithm proceeds as follows  leaute         each
agent ai first creates a vector fi with one entry per candidate solution to the discsp  equal
to   if the candidate solution satisfies ai s private constraints  and to   otherwise  to reduce
the size of fi   the candidate solutions may be filtered through publicly known constraints 
if there exists any  using shamirs polynomial secret sharing technique  shamir        benor et al          agent ai then sends one secret share fij of its vector fi to each other
agent aj   and receives corresponding secret shares fji of their respective vectors  agent ai
then multiplies together all the secret shares it received  the multiplication of shamir secret
shares is a non trivial operation  because each secret share is the value of a polynomial  and
multiplying two polynomials increases the degree of the output  which must always remain
lower than the number  a  of agents to be resolvable  therefore  after each multiplication
of two secret shares  agent ai must perform a complex sequence of operations involving the
exchange of messages in order to reduce the degree of the output 
after performing   a      such pairwise multiplications of secret shares  agent ai s vector fi contains secret shares of   at the entries corresponding to globally feasible solutions 
agent ai then performs a transformation on fi so that only one such secret share of  
remains  identifying one particular feasible solution  if there exists one   just selecting the
first such entry would a posteriori reveal that all previous entries correspond to infeasible
solutions to the discsp  to prevent this privacy leak  the vector fi is first collaboratively 
randomly permuted using a mix net  agent ai then performs a sequence of iterative operations on fi  including communication intensive multiplications  to set all its entries to
secret shares of    except for one secret share of   corresponding to the chosen solution
to the discsp  if any   the vector fi is then un shuffled by re traversing the mix net in
reverse  finally  agent ai can compute secret shares of the domain index of each variables
chosen assignment  and reveal these secret shares only to the owners of the variables 
this algorithm has numerous drawbacks  first  each agent must know all variables and
their domains to construct its initial vector fi   which immediately violates agent privacy
and topology privacy  table      page       second  shamirs secret sharing scheme is a
   silaghi uses the different acronym mpc for the same concept 

   

fileaute   faltings

majority threshold scheme  which means that if at least half of the agents collude  they
can discover everyones private information  even though  in this paper  we are assuming
that agents are honest and do not collude  a consequence of this threshold is that this
scheme does not provide any privacy guarantee when the problem involves only two agents 
third  this algorithm is often only practical for very small problems  because it performs
full exhaustive search  this is demonstrated by our experimental results in section   

   p dpop    full agent privacy and partial topology  constraint and
decision privacy
this section describes a variant of the dpop algorithm that guarantees full agent privacy 
it also partially protects topology  constraint  and decision privacy  algorithm   is an
improvement over the p dpop algorithm we originally proposed  faltings et al         
like dpop  the algorithm performs dynamic programming on a dfs tree ordering of the
variables  figure     algorithms to first elect one variable  and then generate a dfs tree
rooted at this variable are given in online appendices   and    these algorithms do not
reveal the pseudo tree in its entirety to any agent  instead  each agent only discovers the
 pseudo  parents and  pseudo  children of its own variables  for the sake of simplicity  we
will hereafter assume without loss of generality that the constraint graph consists of a single
component  if the problem actually consisted of two or more fully decoupled subproblems 
then each subproblem would be solved in parallel  independently from the others 
algorithm   overal p dpop  algorithm  for variable x
require  a dfs tree ordering of the variables
      choose and exchange codenames for x and its domain dx  
   wait for a message  codes  yix   dyxi   yxi   from each yi   parentx    pseudo parentsx
   for each yi  childrenx  pseudo childrenx do
  
xyi  large random number
  
dxyi  list of  dx   random  unique identifiers
  
xyi  random permutation of              dx   
  
send message  codes  xyi   dxyi   xyi   to yi

   

   choose and exchange obfuscation key for x 
wait for and record a message  key  keyyxi   from each yi  pseudo parentsx  if any 
for each yi  pseudo childrenx do
keyxyi  vector of large random numbers of b bits  indexed by dx
send message  key  keyxyi   to yi

   

propagate feasibility values up the pseudo tree  algorithm    section     

   

   propagate decisions top down along the pseudo tree  section      
if x is not the root then
wait for message  decision  px     from parent px
x  x  px   px        where x    was computed in algorithm    line   
for each yi  childrenx do
 y   to yi   with sepyi from algorithm    line   
send message  decision  sep
i

  
  
   
   

   
   
   
   
   

   

fiprotecting privacy thru distributed computation in multi agent decision making

    finding a feasible value for the root variable
as already illustrated for dpop in section        the agents perform a bottom up propagation of feasibility values along the pseudo tree  this is done in algorithm    which is an
extension of dpops util propagation phase  the extensions are indicated by comments
in bold   and improves over the algorithm we originally proposed  faltings et al        
by patching an important constraint privacy leak in the single variable feas messages
sent by variables with singleton separators  the following sections describe the obfuscation
techniques used to protect the private information that could be leaked by the feasibility
messages  using codenames  section        and addition of random numbers  section        
algorithm   algorithm to find a feasible value for the root of a dfs tree  for variable x
require  a dfs tree ordering of the variables  px denotes xs parent
      join local constraints 
   m x  px      c c c   xscope c   scope c   childrenx pseudo childrenx     c x   
  
  
  

   apply codenames 
for each yi   px    pseudo parentsx do
m x  px      replace  yi   dyi   in m x  px     with  yix   dyxi   from algorithm    line   
and apply the permutation yxi to dyxi

   obfuscate infeasible entries 
r  large  positive 
random number of b bits

m x  px    
if m x  px        
   m x  px     
m x  px       r if m x  px        
  
  

  
   
   
   
   
   
   

   join with received messages 
for each yi  childrenx do
wait for the message  feas  mi  x     from yi
sepyi  scope mi  
for each z  childrenx  pseudo childrenx do    resolve codenames
mi  x     identify  xz   dxz   as  x  dx   in mi  x     if xz is present 
m x  px      m x  px       mi  x   

   de obfuscate feasibility values with respect to x 
    for each yi  pseudo childrenx do
   
m x  px      m x  px      keyxyi  x     with keyxyi from algorithm    line   
   

   project out x 
if x is not the root variable then
   
x  px      arg minx  m x  px     
   
m px      minx  m x  px     
   

   

   
   
   
   
   

   obfuscate feasibility values 
for each yi  pseudo parentsx do
m px      m px       keyyxi  yix      with keyyxi from algorithm    line  
send the message  feas  m px      to px
else x  arg minx  m x      m x  px     actually only depends on x
   

fileaute   faltings

      hiding variable names and values using codenames
consider the feasibility message x   x  sent by agent a x    to its parent variable x  in
figure    this message is recalled in figure   a   reformulated in terms of minimizing the
number of constraint violations  if this message were actually received in cleartext  it would
breach agent privacy and topology privacy  agent a x    would be able to infer from the
dependency of the message on variable x  both the existence of agent a x     which violates
agent privacy  and the fact that x  is a neighbor of one or more unknown nodes below x   
x   x 
x 
x  r b g
r
     
b
     
g
     
 a  in cleartext

x 
r
b
g

x   x 
      
  
     
     
     

 b  partly obfuscated

x 
r
b
g

x   x 
      


             
             
             


      
      
      

 c  fully obfuscated

figure    the message sent by agent a x    to its parent variable x  in figure   

in order to patch these privacy leaks  variable x  and its domain d     r  b  g  are replaced with random codenames xx             and d x            figure  b  preliminarily
generated by a x    and communicated directly to the leaf of the back edge  algorithm   
lines   to     the leaf applies these codenames to its output message  algorithm    line    
and they are only resolved once the propagation reaches the root of the back edge  algorithm    line      not knowing these codenames  the agents in between  such as a x     can
only infer the existence of a cycle in the constraint graph involving some unknown ancestor and descendent  this is tolerated by the definition of topology privacy  definition   
since they are also involved in this cycle  a secret  random permutation  x  is also applied
to d x    this is useful for problem classes in which variable domains are public  notice that
if x  also had a constraint with x    the above reasoning would still hold  because x  would
then have sent a different codename xx    to x    which would then not be able to resolve the
unknown codename xx    to x    in this case  x  s separator would be  x    xx      xx       and its
message sent to x  would be three dimensional instead of two dimensional 
      obfuscating feasibility values
hiding variable names and values using codenames addresses the leaks of agent and topology
privacy  however  this does not address the fact that the feasibility values in the message
x   x  in figure   b  violate constraint privacy  because they reveal to x  that its subtree
can always find a feasible solution to its subproblem when x    r  regardless of the value of
the obfuscated variable         to patch this privacy leak  feasibility values are obfuscated
by adding large  random numbers that are generated by the root of the back edge  x   
and sent over a secure channel to the leaf of the back edge  algorithm    lines   to     
the number of bits b of the random numbers is a problem independent parameter of the
algorithm  the obfuscation is performed in such a way that a different random number is
   

fiprotecting privacy thru distributed computation in multi agent decision making

added to all feasibility values associated with each value of x    as in figure   c   using the
obfuscation key                           these random numbers are added by the leaf of
the back edge to its outgoing message  algorithm    line      and they are only eventually
subtracted when the propagation reaches the root of the back edge  algorithm    line     
notice that this obfuscation scheme achieves two objectives     it hides from x  the
absolute feasibility values of its subtree  and    it hides the relative dependencies of these
values on the obfuscated variable         because different random numbers were used for
each value in its obfuscated domain         agent a x    is still able to infer the relative
dependencies on its own variable x    which is necessary to perform the projection of this
variable  but it is unable to tell  for each value of the other  obfuscated  variable  whether
the subtrees problem is feasible  and if not  how many constraints are violated  notice in
particular that  for a given value of the obfuscated variable  i e  for any column   agent a x   
does not know whether any of the assignments to x  is feasible  and therefore it would be
incorrect to simply assume that the lowest of the obfuscated feasibility entries decrypts to   
similarly  equal entries in the same column correspond with a high probability to entries
that have the same number of constraint violations  but this number is not necessarily   
so it would be incorrect to infer they correspond to feasible entries 
notice also that this obfuscation scheme is only applicable in the presence of a backedge  i e  when the message contains more than just the parent variable  consider for
instance the single variable message x   x    recalled in figure   a   if agent a x    knew
that x  is a leaf of the pseudo tree  the cleartext message would reveal agent a x   s private
local constraint x     b  r  to agent a x     and the previous obfuscation scheme does not
apply because of the absence of back edges  notice that this threat to constraint privacy
is tempered by the fact that p dpop  s guarantees in terms of topology privacy prevent
agent a x    from discovering that x  is indeed a leaf  from a x   s point of view  a larger
subproblem might be hanging below variable x  in figure    and the message could actually
be an aggregation of multiple agents subproblems 

x 
r
b
g

x   x 
  conflicts
 
 
 

 a  in cleartext

x 

x   x 
  conflicts

r
b
g

 
 
      

 b  obfuscated

figure    the message received by agent a x    in figure   

to reduce this privacy leak present in the original algorithm  faltings et al          we
propose a new additional obfuscation scheme that consists in adding large  b bit   positive 
random numbers to positive entries in single variable messages  in order to obfuscate the
true numbers of constraint violations  algorithm    line   and figure   b    because these
random numbers are never subtracted back  they must not be added to zero entries  otherwise the algorithm would fail to find a solution with no violation  feasible entries are still
revealed  but the numbers of constraint violations for infeasible entries remain obfuscated 
   

fileaute   faltings

    propagating final decisions
once the feasibility values have propagated up all the way to the root of the pseudotree  and a feasible assignment to this root variable has been found  if there exists one  
this assignment is propagated down the pseudo tree  algorithm    lines    to      each
variable uses the assignments contained in the message from its parent  in order to look up
a corresponding assignment for itself  line      it then sends to each child the assignments
for the variables in its separator  line      using the same codenames as before so as to
protect agent and topology privacy  decision privacy is only partially guaranteed  because
each variable learns the values chosen for its parent and pseudo parents  but not for other 
non neighboring variables in its separator because they are hidden by unknown codenames 
    algorithm properties
this section first formally proves that the algorithm is complete  and analyses its complexity 
we then present an algorithm variant with lower complexity  finally  the privacy guarantees
provided by both algorithms  summarized in table      are formally described 
privacy type 

agent

topology

constraint

decision

p dpop   

full
full
full
 

partial
partial
partial
partial

partial
partial
full
partial

partial
full
full
partial

   

 dpop   

p
p   dpop   
mpc discsp 

table    privacy guarantees of various algorithms 

      completeness and complexity
theorem    provided that there are no codename clashes  p dpop   algorithm    terminates and returns a feasible solution to the discsp  if there exists one 
proof  after exchanging codenames and obfuscation keys  which is guaranteed to require
a number of messages at most quadratic in the number n of variables  the bottom up
propagation of feasibility values  algorithm    terminates after sending exactly  n    
messages  one up each tree edge   one can prove by induction  left to the reader  that
this multi party dynamic programming computation almost surely correctly reveals to each
variable x the  obfuscated  feasibility of its subtrees subproblem  as a function of x and
possibly of ancestor variables in the pseudo tree  this process may only fail in case of
collisions of codenames  when the roots of two overlapping back edges choose the same
codenames  such codename clashes are inherent to most privacy protecting algorithms 
and can be made as improbable as desired by augmenting the size of the codename space 
finally  the top down decision propagation phase  algorithm    lines    to     is guaranteed to yield a feasible assignment to each variable  if there exists one   after the exchange
of exactly  n     messages  one down each tree edge  
   

fiprotecting privacy thru distributed computation in multi agent decision making

when it comes to the complexity of the algorithm in terms of number of messages
exchanged  the bottleneck is in the election of the root variable  online appendix     which
requires o   d  n    messages  where  is the diameter of the constraint graph  d its degree 
and n is the number of variables  however  the  n     messages containing feasibility
values can be exponentially large  the message sent by variable x is expressed over  sepx  
 sep  
variable codenames  algorithm    line      and therefore contains o dmaxx   feasibility
values  where dmax is the size of the largest variable domain  the overall complexity in
terms of information exchange  memory and runtime  measured in number of constraint
sepmax
checks  is therefore o n  dmax
   where sepmax   maxx  sepx    this is the same as dpop 
except that in p dpop  each variable may appear multiple times under different codenames
in the same separator  hereby increasing the value of sepmax   however  this increase is only
by a multiplicative factor that is upper bounded by the degree of the constraint graph  since
the number of codenames for a given variable is at most equal to its number of neighbors 
empirically  our experimental results in section   suggest that  on almost all the problem
classes we considered  the median value of sepmax tends to grow rather linearly in n 
      p dpop  trading off topology privacy for performance
it is possible to reduce the sizes  sepxi   of the separators  by enforcing that each agent a x 
send the same codename x for x to all of xs  pseudo  children  unlike in algorithm    lines
  to     this variant will be identified by the absence of the plus sign in exponent  p dpop
is the version of the algorithm that was initially proposed by faltings et al         
as a result of this change  variables that previously may have occurred multiple times
in the same feasibility message under different codenames can now only appear at most
once  such that we now have sepmax   n  the worst case complexity of p dpop then
becomes the same as dpop  petcu   faltings         in which sepmax is equal to the
width of the pseudo tree  which is bounded below by the treewidth of the constraint graph 
however  privacy considerations prevents the use in p dpop of dpops more efficient  but
less privacy aware pseudo tree generation heuristics  resulting in higher width pseudo trees 
while the complexity of p dpop is hereby decreased compared to p dpop    sending
the same codename x for variable x to all its  pseudo  children has drawbacks in terms of
topology privacy  as analyzed below 
      full agent privacy
there are only two ways the identity of an agent a could be leaked to a non neighbor b 
   the algorithm can require a and b to exchange messages with each other  or    agent a
can receive a message whose content refers identifiably to b  case   can never happen in
any of our algorithms  because they only ever involve exchanging messages with neighboring
agents  case   is addressed mainly through the use of codenames 
theorem    the p dpop    algorithms guarantee full agent privacy 
proof  the p dpop    algorithms proceed in the following sequential phases  the preliminary phases of root election and pseudo tree generation are addressed in online appendices  
bottom up feasibility propagation  algorithm    each feasibility message contains
only a function  line     over a set of variables  whose names  if transmitted in clear
   

fileaute   faltings

text  could identify their owner agent  to prevent this agent privacy leak  p dpop   
replaces all variable names with secret  random codenames  as follows 
consider a variable x in the pseudo tree  note that no feasibility message sent by x or
by any ancestor of x can be a function of x  the message sent by x is not a function
of x  because x is projected out before the message is sent  line      variable x cannot
re appear in any feasibility message higher in the pseudo tree  because no agents local
problem can involve any variable lower in the pseudo tree  line    
similarly  consider now the feasibility message sent by a descendant y of x in the
pseudo tree  and assume first that y is a leaf of the pseudo tree  since y has no
children  the feasibility message it sends can only be a function of the variables in its
local problem  if this local problem involves x  y will replace x by its codename xy
 line    before it sends its feasibility message  one can then prove by inference that
no feasibility message sent by any variable between y and x will contain x either  it
can only  and not necessarily  contain one or several of its codenames xyi  
since the codenames xyi are random numbers chosen by x  algorithm    line    
and only communicated  through channels that are assumed secure  to the respective
neighbors yi of x  algorithm    line     no non neighbor of x receiving a message
involving any xyi can discover the identity of its owner agent 
the domain dx of variable x could also contain values that might identify its owner
agent  to fix this privacy risk  xs domain is also replaced by obfuscated domains dxyi
of random numbers  similarly to the way variable names are obfuscated  in this
paper  we make the simplifying assumption that all variables have the same domain
size  which naturally holds in many problem classes   so that one variables domain
size does not give any information about its owner agent  otherwise  variable domains
can be padded with fake values in order to make them all have the same size 
top down decision propagation  section      the messages contain assignments to
variables  algorithm    line      which are also obfuscated using codenames 
this concludes the proof that  in the p dpop    algorithms  no agent can receive any
message from which it can infer the identity of any non neighboring agent 
      partial topology privacy
theorem    p dpop guarantees partial topology privacy  the minor leaks of topology
privacy lie in the fact that a variable might be able to discover a lower bound on a neighbor
variables degree in the constraint graph  and a lower bound on the total number of variables 
proof  root election and pseudo tree generation are left to the online appendices 
bottom up feasibility propagation  algorithm    each variable x receives a feas
message from each child  containing a function whose scope might reveal topological
information  each variable y in this scope is represented by a secret codename y 
however x may be able to decrypt the codename y  if and only if y is a neighbor of x
 or is x itself   because y has sent the same codename y to all its neighbors  this
results in a leak of topology privacy  x discovers  for each neighboring ancestor y 
   

fiprotecting privacy thru distributed computation in multi agent decision making

whether y has at least one other neighbor below a given child of x  but it cannot
discover exactly how many of these other neighbors there are 
furthermore  in the case where x and y are not neighbors  x cannot decrypt y  but
it can still infer there exists another  non neighboring ancestor corresponding to this
codename  this is another breach of topology privacy  because y sent the same
codename y to all its neighbors  x can also discover whether that other ancestor has
at least one neighbor below each of xs children  moreover  since codenames are
large random numbers that are almost surely unique  x may discover the existence of
several  distinct such non neighboring ancestors 
top down decision propagation  section      each variable receives a message from
its parent  which can only contain codenames for variables and variable values that
were already present in the feas message received during the previous phase 
this concludes the proof that p dpop only partially protects topology privacy  the limited
topology information leaked to a variable only concerns its branch in the pseudo tree  no
information can be leaked about any other branch  not even their existence 
theorem    the use of different codenames for each  pseudo  child improves the topology
privacy in p dpop  compared to p dpop  but the same bounds can still be leaked 
proof  consider a variable x that receives a feas message including a secret codename y
corresponding to variable y     x   because y now sent a different codename to each of its
neighbors  x is no longer able to decrypt y  even if y is a neighbor of x  as a consequence 
x is no longer able to infer whether y refers to a known neighbor of x  or to an unknown 
non neighboring variable  however  since each codename now corresponds to a unique backedge in the pseudo tree  for each pair      of unknown codenames in xs received feas
message  if such a pair exists   at least one of the following statements must hold 
  and  refer to two different ancestors of x  and therefore x discovers at it has at least
two ancestors  which it might not have known  if it has no pseudo parent   and or
  and  were sent to two different descendants of x below  and possibly including  the
sender child y  and therefore x discovers that it has at least two descendants below
 and including  y  which it might not have known  if it has no pseudo child below y  
therefore x might be able to refine its lower bound on the total number of variables 
      partial constraint privacy
theorem    the p dpop    algorithms guarantee partial constraint privacy  the local
feasibility of a subproblem for a partial variable assignment x  may be leaked  even if x 
cannot be extended to an overall feasible solution  i e  this is not semi private information  
proof  information about constraints is only transmitted during feasibility propagation  algorithm     based on the knowledge of the optimal variable assignments transmitted during
the last phase  section       some of the feasibility information may be decrypted 
   

fileaute   faltings

single variable feasibility messages when a variable px receives a feasibility message
involving only px   the message has been obfuscated only by adding secret random
numbers to its infeasible entries  line     feasible entries remain equal to    and px
can identify which entries refer respectively to feasible or infeasible assignments to px  
however  the addition of a secret  positive  random number to each infeasible entry
ensures only an upper bound on the number of constraint violations is leaked  which
can be made as loose as desired by choosing random numbers as large as necessary 
multi variable feasibility messages if the feas message involves at least one other
variable yi   then all message entries have been obfuscated by adding large random
numbers keyyxi  yix   of b bits  line      furthermore  keyyxi  yix   is only known to the
sender x of the message and to its pseudo parent yi   but not to the recipient px   which
therefore cannot subtract it to de obfuscate the entries 
assume  for simplicity  that the message m px   yix   involves only the two variables
px and yix   the argument extends easily to more variables  the recipient px might
be able to make inferences     by fixing yix and comparing the obfuscated entries
corresponding to different values for px   or    by fixing px and varying yix instead 
   for a given value of yix   all entries have been obfuscated by adding the same
random number keyyxi  yix    line      so px can compute the relative differences of
feasibility values for various assignments to px   however  it cannot decrypt the
absolute values without knowing keyyxi  yix    in particular  the lowest obfuscated
value is not necessarily equal to keyyxi  yix    because it does not necessarily decrypt
to    all values of px may be infeasible for this particular value of yix  
there is one exception  if a feasible solution is found to the problem in which


yix   yix and px   px    then m px    yix   necessarily decrypts to    and therefore


px will be able to infer keyyxi  yix    after fixing yix   yix in the message and

subtracting keyyxi  yix    the same reasoning can be made as for the single variable
case  in which feasible and infeasible entries are identifiable  but the numbers of
constraint violations for infeasible entries remain obfuscated 
   for a given value of px   each feasibility value m px   yix   has been obfuscated
by adding a different  secret random number keyyxi  yix    choosing the number
of bits b sufficiently large makes sure that no useful information  relative  or
absolute  can be obtained by comparing the obfuscated feasibility values 
this concludes the proof that p dpop    guarantees partial constraint privacy 
      partial decision privacy
theorem    the p dpop    algorithms guarantee partial decision privacy  the leak lies
in the fact that a variable might discover the values chosen for some or all of its neighbors 
proof  first notice that the algorithm cannot leak any information about the chosen values
for variables that are lower in the pseudo tree  since these variables have been projected out
of the feasibility messages received  however  during the decision propagation phase  each
variable receives a message from its parent that contains the chosen values for its parent and
   

fiprotecting privacy thru distributed computation in multi agent decision making

pseudo parents  the message may also contain codenames for the assignments to other  nonneighboring variables  which the recipient will not be able to decode  furthermore  domains
are shuffled using secret permutations  making it impossible to decode the codename for
the value of a non neighboring variable from its index in the variables domain 

   p     dpop    adding full decision privacy
this section presents another variant of the p dpop  algorithm that achieves full decision
privacy  this results in a novel algorithm  which can be seen as a hybrid between the
p dpop  and p   dpop  leaute   faltings        algorithms  and is called p     dpop  
    overview of the algorithm
algorithm   patches the decision privacy leak in p dpop  by removing its decision propagation phase  only the root variable is assigned a value  and in order for all variables to be
assigned values  each variable is made root in turn  unless the first feasibility propagation
has revealed that the problem is infeasible  in which case the algorithm can terminate early  
 
the intuition behind this p     dpop  algorithm is therefore that p dpop  s bottom up
feasibility propagation phase is repeated multiple times  each time with a different variable x
as the root of the pseudo tree  lines    to      at the end of each iteration  a constraint
x   x is added to the problem to enforce consistency across iterations  line     
algorithm   overall p     dpop  algorithm with full decision privacy  for variable x
require  a first temporary dfs tree  a unique id idx   a tight strict lower bound on the
 
next unique id id 
x   and an upper bound n on the total number of variables
idx

id 
x idx

z      z     
   vectorx                                               
 
 z
 
n 

  
  
  
  
  
  
  
  
   
   
   
   
   
   
   

   exchange public key shares 
privatex  generate a private elgamal key for x
publicx  generate a set of  id 
x  idx      public key shares corresponding to privatex
for each share  publicx do toprevious  share  share   as in algorithm  
for i           n  do
wait for and record one message  share  share 
if share   publicx then toprevious  share  share   as in algorithm  
generate the compound elgamal public key based on all the public key shares
while vectorx     do
choose a new root  algorithm    section     
construct a new pseudo tree rooted at the new root  online appendix   
exchange codenames for x and its domain dx  algorithm    lines   to   
choose and exchange obfuscation key for x  algorithm    lines   to    
propagate feasibility values up the pseudo tree  algorithm    except line    
if x is root then add local constraint x   x   with x from algorithm    line   
   

fileaute   faltings

    choosing a new root variable
to iteratively reroot the pseudo tree  we propose to use an improved version of the rerooting
procedure we initially introduced for the p   dpop algorithm  leaute   faltings        
this procedure requires that each of the n variables be assigned a unique id  an algorithm
to achieve this is presented in online appendix    this algorithm reveals to each variable x
its unique id idx   as well as a tight strict lower bound on the next unique id id 
x  i e  the
  on the total number of variables 
 
   
and
an
upper
bound
n
next unique id equals id 
x
each variable x then creates a boolean vector vectorx with a single zero entry at the index
corresponding to its unique id idx  algorithm    line     this vector is then shuffled using
a random permutation used to hide the sequence in which variables become roots 
to keep the permutation secret  the vector is first encrypted using elgamal encryption
 appendix a   based on a compound public key jointly produced by the agents  algorithm   
lines   to     this asymmetric encryption scheme enables each agent to  re  encrypt the
entries in the vectors using a common public key  such that the decryption can only be
performed collaboratively by all the agents  using their respective private keys 
algorithm   algorithm to choose a new root  for variable x
procedure  shufflevectors   for variable x
   myid  large random number
   px  random permutation of          n   
   propagate xs encrypted vector backwards along the circular ordering
vectorx  e vectorx      encrypts the vector using the compound public key
   toprevious  vect  myid  vectorx       as in algorithm   in appendix b
  

  

   process all received vectors
   while true do
  
wait for a message  vect  id  vector  round  from the next variable
  

  
   
   
   
   
   
   
   
   
   
   
   

if round     then
if id    myid then for j    idx            id 
x do vector j    
else round  round        xs vector  move to next round
if round     and x is the current root then
round  round        the root starts each round except the first
if round     then vector  px  vector     shuffle the vector
if round     and id   myid then    done processing vectorx
vectorx  vector
continue
   pass on the vector backwards along the circular ordering
vector  e vector     re encrypts the vector using the compound public key
toprevious  vect  id  vector  round   as in algorithm   in appendix b

procedure  reroot   for variable x
    repeat entry  decrypt pop vectorx    while entry         as in algorithm  
    if entry     then x is the new root
   

fiprotecting privacy thru distributed computation in multi agent decision making

the agents then proceed as in algorithm    each variable x first starts the procedure
shufflevectors    which is run only once  this is a performance improvement over our
previous work  leaute   faltings         where it was performed at each iteration  all the
vectors are passed from variable to variable in a round robin fashion  using a circular message
routing algorithm presented in appendix b  each agent applies a secret permutation to
each vector to shuffle it  shufflevectors   proceeds in four rounds  during round  
 started on line    algorithm     each vector makes a full round along the circular ordering 
during which each variable x overwrites some of the entries with    line      at the same
positions it did for its own vectorx  algorithm    line     these   entries account for the
ids in  idx      id 
x   that have not been assigned to any variable  online appendix     once
x has received back its own vectorx   it enters the incomplete round    line     during which
vectorx is passed on until it reaches the current root  line      the root then starts round  
 line      during which each variable x shuffles each vector using its secret permutation px
 line      the incomplete round   returns the fully shuffled vector to its owner  line     
to reroot the variable ordering at the beginning of each iteration of p     dpop    each
variable x calls the procedure reroot    which removes and decrypts the first element of
vectorx   entries that decrypt to   correspond to unassigned ids and are skipped  the
single entry that decrypts to   identifies the new root  the decryption process  algorithm   
is a collaborative effort that involves each variable using its private elgamal key to partially
decrypt the cyphertext  which travels around the circular variable ordering in the same way
as the vectors  until it gets back to its sender variable  which can finally fully decrypt it 
algorithm   collaborative decryption of a multiply encrypted cyphertext e
procedure  decrypt e  for variable x
   codename  large random number used as a secret codename for x
   codenamesx  codenamesx   codename 
   toprevious  decr  codename  e   as in algorithm  
   wait for message  decr  codename  e   from next variable in the ordering
   return decryption of e using xs private key
procedure  collaborativedecryption   for variable x
   loop
  
wait for a message  decr  c  e  from next variable in the ordering
  
if c   codenamesx then
  
e  partial decryption of e using xs private key
   
toprevious  decr  c  e    as in algorithm  

    algorithm properties
 

we first analyze the completeness and complexity properties of the p     dpop    algorithms  and then we move on to their privacy properties 
      completeness and complexity
theorem    provided that there are no codename clashes  the p     dpop  algorithm
terminates and returns a feasible solution to the discsp  if there exists one 
   

fileaute   faltings

proof  on the basis of theorem    it remains to prove that the rerooting algorithm  
terminates and is correct  and that the overall algorithm remains correct  the latter is easy
to prove  at each iteration  a feasible value is found for the root variable  if there exists
one   and that value is necessarily consistent with the chosen assignments to previous roots
since these assignments are enforced by new  additional constraints  algorithm    line     
when it comes to the rerooting procedure  the unique id assignment algorithm  online
appendix    ensures that each of the n variables gets a unique id in          n      therefore 
each variable has a   entry at a unique position in its vector  algorithm    line     round  
of algorithm   also makes sure that all vectors have   entries at the same positions  this
ensures that exactly one variable will become the new root at each iteration  since all vectors
are applied the same sequence of permutations  and no variable will be root twice 
 

in terms of complexity  p     dpop  proceeds in a similar way to p dpop   section       except that the bottom up feasibility propagation phase is repeated n times  each
time with a different root variable   the overall complexity in information exchange theresep
fore becomes o n  dmaxmax    where sepmax is the maximum separator size over all variables 
and over all iterations  which therefore is likely to be higher than the exponent for pdpop    the information exchanged by the rerooting protocol is negligible in comparison 
sep
the runtime complexity  measured in number of constraint checks  is also o n   dmaxmax   
sep
but the memory complexity is only o n  dmaxmax    because removing the decision propagation phase makes it become unnecessary to compute and record x  px      algorithm   
line      our experimental results on graph coloring benchmarks  section      suggest that
the median value of sepmax may only be greater than the median value of sepmax in pdpop  by a small multiplicative factor  in terms of number of elgamal cryptographic
operations  the rerooting procedure requires a total of n  n    n   o n    encryptions 
each of the n variables  re  encrypts   n     vectors of size n   each variables vector
performs   full rounds  except for the roots vector  which performs only   full rounds  
with n   n   n   incrmin   where incrmin is a constant input parameter of the algorithm 
the procedure also requires a total of n  n   o n    collaborative decryptions  each of the
n variables  partially  decrypts n vectors or size n   
      full agent privacy
theorem    the p     dpop    algorithms guarantee full agent privacy 
proof  the unique id assignment and circular routing algorithms guarantee full agent privacy  as demonstrated respectively in online appendix   and appendix b 
pseudo tree rerooting  algorithm    the messages sent by shufflevectors   contain a variable id  a vector of elgamal cyphertexts  and a round number  the id
is used by the recipient to detect whether the vector is its own vector  it is a large
random number chosen by the owner agent  algorithm    line     and therefore it
cannot be linked to the identity of this owner agent by any other agent  the elgamal
vector and the round number also do not contain any information that could be used
to identify the agent  also note that the procedure used to exchange elgamal public
key shares  algorithm    lines   to    does not leak any information about agents
   

fiprotecting privacy thru distributed computation in multi agent decision making

identities  the reroot   procedure then makes use of the collaborative decryption
algorithm  whose properties in terms of agent privacy are discussed below 
collaborative decryption  algorithm    the procedure exchanges messages that contain an elgamal cyphertext  and a codename used like the variable id in algorithm   
this codename is similarly set to a large random number chosen by the current agent 
and cannot be linked to the identity of this agent by any other agent 
 

this concludes the proof that the p     dpop    algorithms guarantee agent privacy 
      partial topology privacy
 

the topology privacy in p     dpop    is only slightly worse than in p dpop     
theorem    the p     dpop    algorithms guarantee partial topology privacy  each variable unavoidably discovers the total number of variables in the problem  and might also
discover a lower bound on a neighbor variables degree in the constraint graph  the advan 
 
tages of p     dpop  over p     dpop are the same as p dpop  over p dpop 
proof  since there is one feasibility propagation phase per variable in the problem  the total
number of variables inevitably becomes public  the following analyzes the topology privacy
properties of each phase of p     dpop    that is not already present in p dpop      except
for unique id assignment  online appendix    and secure message routing  appendix b  
exchange of elgamal key shares  algorithm    lines     the messages containing elgamal key shares do not contain any information that could be used to make
inferences about the topology of the constraint graph 
pseudo tree rerooting  algorithm    each message travels along a circular variable
ordering using the message routing algorithm in appendix b  and contains 
 a vector that is encrypted  and re encrypted after each operation  and that therefore cannot provide any topological information 
 an id that identifies the owner of the vector  being a secret  large random number 
only the owner of the vector can identify itself 
 a round number can take the following values 
 round     only indicates that the vector is being modified  each variable
setting in turn some of the values to   
 round     only indicates that the vector is being sent to the root of the
pseudo tree  this does not happen for the vector of the  unknown  root 
 round     only indicates that the vector is being shuffled by each variable 
 round     only indicates that the vector is on its way back to its owner 
this does not happen for the vector belonging to the  unknown  root 
reroot   then uses the decryption algorithm whose properties are described below 
   

fileaute   faltings

collaborative decryption  algorithm    decr messages are passed along the circular variable ordering  containing a secret codename for the original sender variable 
which is the only variable capable of deciphering this codename  the last part of the
message payload is an elgamal cyphertext  which remains encrypted until it reaches
back the original sender  and therefore does not leak any topological information 
 

this concludes the proof that p     dpop    guarantees partial topology privacy 
      partial constraint privacy
 

the constraint privacy properties of the p     dpop    algorithms differ from those of pdpop      because the former protect decision privacy  which benefits constraint privacy  
but also reveal the total number of variables in the problem  which hurts constraint privacy  
theorem     the p     dpop    algorithms guarantee partial constraint privacy  the
leaks are the same as in p dpop     section         but they happen less frequently 
proof  single variable feasibility messages leak the same amount of constraint privacy as in
p dpop      notice however that  since the p     dpop    algorithms now reveal the total
number of variables  in some circumstances it may be possible for a variable to discover that
a child is a leaf  and that the feasibility message it sends therefore contains information about
its local subproblem only  however  multi variable feasibility messages leak potentially much
less information than in p dpop      consider again the simpler and non restrictive case
 
of a two variable message m px   yix   received by px   because p     dpop    now protects

decision privacy  px no longer discovers the value yix chosen for yix   and is therefore no
longer able to infer which of the entries corresponding to px   px  decrypts to   
one exception is when the following three conditions simultaneously hold     p     dpop

is used     the codename yix refers to a variable yix that is a neighbor of px   and    yix is

semi private information to px   then px will still discover yix   and will be able to make the
 
same inferences as in p dpop      if the first condition is not satisfied  i e  p     dpop  is
 
used instead of p     dpop  then px will not be able to link the codename yix to any known
 
variable  this is also the case if p     dpop is used  but the second condition does not

hold  finally  if the first two conditions hold  px will only be able to discover yix if it is
semi private information  i e  if it can infer it only from its knowledge of the problem  and
of its own chosen value px   
      full decision privacy
theorem     the p     dpop    algorithms guarantee full decision privacy 
proof  the leak of decision privacy in p dpop    is fixed by removing the decision propagation phase  instead  the variable ordering is rerooted  and the feasibility propagation
phase is restarted  it is not possible to compare the feasibility messages received from one
iteration to the next to infer the decision that has been made at the previous iteration  the
messages are not comparable  since different codenames and obfuscation keys are used 
   

fiprotecting privacy thru distributed computation in multi agent decision making

   p   dpop    adding full constraint privacy
we now describe how the previous  non fully secure obfuscation scheme can be replaced
with elgamal homomorphic encryption  appendix a  to achieve full constraint privacy 
which corresponds to the original p   dpop algorithm  leaute   faltings         improved
by the use of multiple codenames  an important limitation of the elgamal scheme is that
it is not fully homomorphic  it is possible to compute the or of two encrypted booleans 
but it is only possible to compute the and of an encrypted boolean with a cleartext
boolean  as a consequence  the bottom up feasibility propagation has to be performed on
a variable ordering such that each variable can have only one child  i e  a linear variable
ordering  figure     using the message routing algorithm in appendix b  otherwise  in a
pseudo tree variable ordering  a variable with two children would not be able to join the
two encrypted feasibility messages sent by the children  this could be addressed using the
fully homomorphic encryption scheme by gentry         however it is unclear whether this
scheme would be practically applicable and would have sufficient performance 
x 
x 

x 

x 

x 

figure    the  counter clock wise  circular variable ordering corresponding to figure   

    propagating encrypted feasibility values along a linear variable order
in contrast to figure    which illustrates multi party dynamic programming on a pseudotree variable ordering  counting constraint violations   figure   shows  in cleartext  how
it can be carried out on a linear ordering  in the boolean domain   this assumes that a
circular communication structure has preliminarily been set up as described in appendix b 
algorithm   gives the detailed pseudocode for this procedure  and is intended as a
replacement for line    in algorithm    the differences with the pseudo tree based algorithm   are the following  first  while algorithm   initially reformulated the discsp into
a max discsp so as to minimize the number of constraint violations  algorithm   works
directly on the original discsp problem  this means that the conjunction operator 
replaces the sum operator  lines   and      and the disjunction operator  replaces the
operator min  line      notice also that  in the case of the linear ordering  a variables local
subproblem no longer necessarily involves its parent variable in the ordering  line     just
like x  shares no constraint with x  in figures   and   
the next difference is that variable x no longer partially de obfuscates its feasibility
matrix before projecting itself  algorithm    line      the reason is that the elgamal
scheme is homomorphic  and therefore it is no longer necessary to first  partially  decrypt
   

fileaute   faltings

x 

x   x 
r
b
true false

g
true

x 

x 

x 
r
b
g

x   x 
x 
r
b
true false
true
true
false false

x   x 
x 
r
b
true false
true true
true true

x 
r
b
g
x 

g
true
true
false

x 

x 
r
b
g

g
true
true
true
x 
x   x 
x 
r
b
true true
true true
true false

g
true
false
true

figure    multiparty dynamic programming computation  in cleartext  of a feasible value
for variable x    using a linear variable ordering based on figure   

algorithm   propagating feasibility values along a linear ordering  for variable x
      join local constraints 
v
   m x     c c c   xscope c    scope c   childrenx pseudo childrenx     c x   

   apply codenames 
   for each yi   parentx    pseudo parentsx do
  
m x     replace  yi   dyi   in m x    with  yix   dyxi   from algorithm    line    and
apply the permutation yxi to dyxi
  

  
  
  
  
   

   join with received message 
wait for the message  feas  m     from the next variable in the ordering
for each z  childrenx  pseudo childrenx do
m     identify  xz   dxz   as  x  dx   in m     if xz is present 
m x     m x     m   

   project out x 
if x is not the root
w variable then
   
m    e   x m x        re encrypts using the compound public key
   
toprevious  feas  m     as in algorithm  
    else x  feasiblevalue m x     as in algorithm  
   

   

   

fiprotecting privacy thru distributed computation in multi agent decision making

the feasibility values to project x using the operator x   only the root variable requires
decryption  algorithm    line     to find a value x for its variable x whose encrypted
feasibility value decrypts to true  if any   this is described in the following section 
    decrypting a feasible value for the root variable
the decryption of feasibility values at the root is a collaborative process in which each variable partially decrypts the cyphertext using its private key  algorithm     the dichotomy
procedure in algorithm   uses at least log   dx   and at most log   dx       decryptions
to find a feasible assignment to the root variable  or to detect infeasibility 
algorithm   finding a feasible value in the encrypted feasibility matrix m x 
procedure  feasiblevalue m  x   xil       xir   
   if il   ir hthen
ki in half the remaining subdomain 
j    cut
il  ir
  
i  il  
 

w
  
f easible  decrypt ii m  x   xi   as in algorithm  
  
if f easible   true then return feasiblevalue m
  x   xii   
  
else return feasiblevalue m x   xi il  ir  i
else    only one value remains for x
  
f easible  decrypt m  x   xil    as in algorithm  
  
if f easible   true then return xil else return null
  

    algorithm properties
we first analyze the completeness and complexity properties of the p   dpop    algorithms 
and then we move on to their privacy properties 
      completeness and complexity
theorem     provided that there are no codename clashes  the p   dpop  algorithm
terminates and returns a feasible solution to the discsp  if there exists one 
proof  termination follows from theorem    and from the fact that the message routing
procedure in appendix b guarantees all feasibility messages eventually reach their destinations  when it comes to completeness  the homomorphic property of the elgamal scheme
ensures the projection of a variable x out of an encrypted feasibility matrix is correct  and
that the feasibility message received by each variable in the linear ordering summarizes the
 encrypted  feasibility of the lower agents aggregated subproblems  as a function of higher
variables  in particular  the feasibility message received by the root allows it to find a value
for its variable that satisfies the overall problem  if there exists one 
the analysis of the complexity of the algorithm remains similar to the analysis in secsep
tion      it is o n   dmaxmax   in information exchange and in number of constraint checks 
sep
and o n  dmaxmax   in memory  but sepmax is now the maximum separator size along the
successive linear variable orderings  instead of along the pseudo trees  the requirement that
   

fileaute   faltings

each variable may have at most one child tends to make this exponent increase significantly 
as illustrated empirically in section    in terms of number of elgamal cryptographic operations  in addition to the cost of rerooting the variable ordering  section       the algorithm
sep
also requires o n   dmaxmax   encryptions  and only o n log dmax   collaborative decryptions 
      full agent privacy
theorem     the p   dpop    algorithms guarantee full agent privacy 
 

proof  the only changes introduced in p   dpop    with respect to p     dpop    are in
feasibility propagation  and in finding a feasible value for the root variable 
elgamal feasibility propagation  algorithm    from the point of view of agent privacy  this is the same procedure as algorithm    but using algorithm   for message
routing  both of which algorithms guarantee agent privacy 
root variable assignment  algorithm    this consists in iteratively calling the procedure in algorithm    which has already been shown to guarantee agent privacy 
this concludes the proof that the p   dpop    algorithms guarantee agent privacy 
      partial topology privacy
theorem     the p   dpop    algorithms guarantee partial topology privacy  in addition
to the limited leaks of topology privacy in p     dpop      an agent might also be able to
discover that there exists another branch in the constraint graph that it is not involved in 
 

proof  there are only two relevant differences with p     dpop      the linear variable ordering  and the choice of a value for the root variable that requires collaborative decryption 
elgamal feasibility propagation  algorithm    to exchange feas messages along
a linear variable ordering  the algorithm makes use of the circular message routing
procedure  which is shown in appendix b to guarantee full topology privacy  however 
the last variable in the linear ordering needs to know it is the last in order to initiate
the feasibility propagation  therefore  by contraposition  non last variables know they
are not the last  and  in particular  non last leaves of the pseudo tree discover the
existence of another branch  this minor leak of topology privacy is already present
in the unique variable id assignment algorithm  online appendix     besides this 
the topology privacy properties of the feasibility propagation phases in p   dpop and
p   dpop  are the same as in p dpop and p dpop    respectively 
root variable assignment  algorithm    this algorithm involves recursively calling
the collaborative decryption procedure  shown to guarantee full topology privacy 
this concludes the proof that p   dpop    guarantees partial topology privacy 
   

fiprotecting privacy thru distributed computation in multi agent decision making

      full constraint privacy
theorem     the p   dpop    algorithms guarantee full constraint privacy 
proof  the p   dpop    algorithms fix all the leaks of constraint privacy in p    dpop     
by replacing the cryptographically insecure obfuscation through addition of random numbers  by the cryptographically secure elgamal encryption  appendix a   this makes it no
longer possible to compare two encrypted feasibility values without decrypting them  which
would require the collaboration of all agents  or an amount of computation to break the
encryption that can be made arbitrarily high in the worst case by increasing the elgamal
key size   in particular  while it is possible to compute the logical or of two cyphertexts
without decrypting them  the result remains encrypted  and cannot be compared to the two
inputs to decide which one is true  if any 
      full decision privacy
theorem     the p   dpop    algorithms guarantee full decision privacy 
proof  the same proof applies as to theorem    

   experimental results
we report the empirical performance of our algorithms against the state of the art mpcdiscsp  algorithm  on four classes of benchmarks  graph coloring  meeting scheduling 
resource allocation  and game equilibrium  we only compare to mpc discsp   because to
our knowledge it is the only other general discsp algorithm that provides strong privacy
guarantees  for each problem class  the choice of the discsp formulation is crucial  because
it dictates how the four types of privacy defined based on the discsp constraint graph will
relate to the actual privacy of the original problem  in particular  the p  dpop    algorithms use the standard discsp assumption that each constraint is known to all agents
owning a variable in its scope  section         therefore  when an agent wants to hide a
constraint from neighboring agents  it must express its constraint over copies of its neighbors variables  additional equality constraints must be introduced to make copy variables
equal to their respective original variables  in contrast  mpc discsp  does not make use of
this discsp assumption  and therefore it does not need the introduction of copy variables 
our first performance metric is simulated time  sultanik  lass    regli         which
is used  when all agents are simulated on a single machine  to estimate the time it would
have taken to solve the problem if they had run in parallel on dedicated machines  ignoring
communication delays   the two other metrics are the number of messages and the amount
of information exchanged  for each metric  we report the median over at least     problem
instances  with     confidence intervals  for the obfuscation in p    dpop      we used
random numbers of b       bits  while p   dpop    used     bit elgamal encryption 
mpc discsp  also used     bits for its paillier encryption  for the unique variable id
generation procedure in p    dpop      the parameter incrmin was set to     all algorithms
were implemented inside the java based frodo platform for discsp  leaute  ottens   
szymanek         coupled with the csp solver jacop  kuchcinski   szymanek        
the experiments were run on a     ghz  dual core computer  with java     and a java
heap space of   gb  the timeout was set to    min  wall clock time  
   

fileaute   faltings

    graph coloring
we first report the performance of the algorithms on distributed    color graph coloring
problems  the graphs were randomly generated with varying numbers of nodes  and an
edge density fixed to      notice that  with a fixed number of colors and a fixed edge
density  increasing the number of nodes increases the degree of the graph  and therefore
reduces the number of feasible solutions  this explains the trends in some of the following
graphs  the discsp formulation involves one decision variable per node  and assumes that
each variable is controlled by a single variable agent  notice that inter agent constraints are
binary inequality constraints  and therefore decision privacy is relevant to this problem class 
knowing ones chosen color is insufficient to infer the respective colors of ones neighbors 
to study the tradeoff between privacy and performance in mpc discsp   we considered
a variant denoted mpc discsp    which assumes all inter agent inequality constraints  i e 
node neighborhoods  are public  and only the final choice of colors is protected  each agent

simulated time  in ms 

   

induced width

  
mpc

 

mpc

  

 

p   dpop 
p   dpop

   
 

  

 
p 

 dpop

 
p 

 dpop

 
 

 

p dpop 

   

p dpop

 

dpop

   

 
 

 

 
 
 
 
number of nodes

 

  

 

number of messages

   

 

 
 
 
 
number of nodes

 

  

information exchanged  in bytes 

   

   

   

mpc
mpc

   



p    dpop 
 

   

p    dpop

  

p dpop 

   

   

p dpop

   
   

dpop

 

 

 
 
 
 
number of nodes

 

   
   

  

 

 

 
 
 
 
number of nodes

figure    performance on graph coloring problems 

   

 

  

fiprotecting privacy thru distributed computation in multi agent decision making

first enumerates all feasible solutions to the overall problem  section         and then uses
cryptographic techniques to securely and randomly choose one of the feasible solutions  if
there exists none  the algorithm therefore terminates without any cryptographic operations
nor exchanging messages  this explains the phase transition for mpc discsp  in the
following graphs  since the probability of infeasibility increases with the problem size 
figure   shows that mpc discsp   denoted as mpc in these and all subsequent figures 
scales very poorly  timing out on problems with more than   nodes  mpc discsp 
performs better  however  as mentioned before  it only protects the final choices of colors 
for small numbers of nodes  the total state space is small  and mpc discsp  performs
relatively well  for numbers of nodes above    the problem instances are mostly infeasible 
and mpc discsp  quickly detects infeasibility without having to exchange any message 
the most efficient algorithms by far are p dpop      whose performance curves are at
least one order of magnitude below all other algorithms  in particular  p dpops runtime
is sensibly the same as dpop  the communication overhead is almost solely due to the root
simulated time  in ms 

   

induced width
  
  

   
p dpop 

  
p dpop
dpop

   

 
 

   

 
  

  

  
  
  
number of nodes

  

  

number of messages

   

  

  
  
  
number of nodes

  

information exchanged  in bytes 

   
   

   
   
   
   
   
   

  

  

  
  
  
number of nodes

   

  

  

  

  
  
  
number of nodes

figure    performance on larger graph coloring problems 

   

  

fileaute   faltings

election algorithm   the cost of improved topology privacy in p dpop  vs  p dpop only
starts to show for problem sizes above    when the induced widths of p dpop  s pseudotrees start to deviate from p dpop and dpop  full decision privacy comes at much higher
costs  p     dpop    s curve is between   and   orders of magnitude above p dpop    s 
even though their induced widths remain sensibly the same  this suggests that rerooting
the pseudo tree  which involves expensive cryptographic operations  is by far the complexity
bottleneck  even when full constraint privacy is additionally guaranteed as in p   dpop     
whose linear variable orderings nevertheless have significantly higher induced widths than
p    dpop    s pseudo tree orderings  notice that the slope of the runtime curve decreases
as the problem size increases  this is due to the fact that more and more problems become
infeasible  and the p    dpop    algorithms are able to terminate after the first iteration
on infeasible problems  similarly to p dpop  vs  p dpop  the cost of improved topology
privacy is only visible above   nodes  p   dpop  even timed out on problems of size    
finally  figure   illustrates the fact that mpc discsp  tends to send large numbers of
small messages  while the p    dpop    algorithms send lower numbers of larger messages 
figure   compares the performance of p dpop    against dpop on larger graph coloring problem instances  on such larger problems  the improved topology privacy in pdpop  comes at a complexity price that is too high to scale above    nodes  on the other
hand  p dpops curves are only between one and two orders of magnitude above dpop 
and p dpops median runtime on problem instances of size    is below    s 
    meeting scheduling
we now report experimental results on random meeting scheduling benchmarks  we varied
the number of meetings  while keeping the number of participants per meeting to    for each
meeting  participants were randomly drawn from a common pool of   agents  the goal is to
assign a time to each meeting among   available time slots  such that no agent is required to
attend simultaneous meetings  the pool of agents was deliberately chosen small to increase
the complexity of the problems  by increasing the probability that each agent take part
in multiple meetings  note that fixing the pool size and the number of participants per
meeting still generates an unbounded number of different problem instances as we increase
the number of meetings  since the state space  the cartesian product of the domains of the
decision variables  keeps increasing with the number of meetings decisions to be made 
the discsp formulation for this problem class was the following  each agent owns
one variable of domain size   for each meeting it participates in  there is an alldifferent
constraint over all its variables to enforce that all its meetings are scheduled at different
times  for each meeting  a binary equality constraint expressed over the corresponding
variables owned by the two participants enforces that the participants agree on the time
for the meeting  notice that all inter agent constraints are binary equality constraints 
 
and therefore p     dpop    do not bring any additional privacy compared to p dpop     
since the values of neighboring variables are semi private information  therefore  we do not
report the performance of p     dpop      for mpc discsp   we simplified the formulation
by only introducing one variable per meeting  owned by its initiator  this way  for each
meeting  only its initiator is made public  but its exact list of participants remains secret
 it is only revealed a posteriori to the participants of the meeting when they attend it  
   

fiprotecting privacy thru distributed computation in multi agent decision making

simulated time  in ms 

   

 

   

p   dpop 
p   dpop

   

mpc

 
 

p dpop 

   

p dpop

 

dpop

   
   

induced width

 

 
 
 

 
 
 
 
number of meetings

 

 

number of messages

   

 
 
 
 
number of meetings

 

information exchanged  in bytes 

   

   

   

   
   
 

  

   
   
   

   
   

 

 
 
 
 
number of meetings

   

 

 

 
 
 
 
number of meetings

 

figure    performance on meeting scheduling problems 

as can be seen in figure    p   dpops performance is comparable to that of mpcdiscsp   but with much stronger privacy guarantees   although the former sends significantly more information on the smallest problems  but significantly fewer messages on the
largest problems they could solve within the timeout limit  on the other hand  because
it is a majority threshold scheme  mpc discsp  actually could not provide any privacy
guarantees on problems of size    since they only involved   agents  both algorithms could
only scale up to problems of size    and timed out on larger problems  p   dpop  s increased topology privacy comes at a price that made it time out earlier than p   dpop 
this complexity increase is due to p   dpop  s steeper induced width curve 
the p dpop    algorithms remain the most efficient by far  they perform between  
and   orders of magnitude better than all others  both in terms of runtime and information
exchanged  and like for graph coloring  the improved topology privacy in p dpop  comes
at a price that is negligible for small problems  but can grow to one order of magnitude on
problems of size    even if its induced width remains close to that of p dpop  in terms of
   

fileaute   faltings

runtime and information exchange  p dpop is only worse than dpop by a small factor
 since it has the same median induced width   however it sends approximately one order of
magnitude more messages  which is mostly due to the pseudo tree root election mechanism  
    resource allocation
next  we performed experiments on distributed resource allocation benchmarks  problem
instances were produced using the combinatorial auction problem generator cats  leytonbrown  pearson    shoham         ignoring bid prices  we used the temporal matching
distribution modeling the allocation of airport takeoff landing slots  fixing the total number
of slots  i e  resources  to    and varying the numbers of bids  each bid is a request for a
bundle of   resources  a takeoff slot and a corresponding landing slot   multiple requests
may be placed by the same airline company  each airline should have exactly one fulfilled 

simulated time  in ms 

   

induced width

 

   

 
mpc

   

 

p   dpop   
p dpop   

   

 

dpop

   
   

 
 
 

 

 
 
 
 
number of bids

 

 

 

 
 
 
 
number of bids

 

 

information exchanged  in bytes 

number of messages

   

 

   
   

   

   
   
   
   
   
   
   

   

 

 

 
 
 
 
number of bids

 

   

 

 

 

 
 
 
 
number of bids

figure     performance on resource allocation problems 

   

 

 

fiprotecting privacy thru distributed computation in multi agent decision making

this problem was modeled as a discsp as follows  leaute   faltings         one
agent is introduced for each bidder airline and for each resource slot  assuming that each
resource is controller by a different resource provider airport    for each resource x  and
for each bidder b that requests the resource  there is one binary variable xb controlled by
the resource provider  which models whether b is allocated the
p resource  xb      or not
 xb       the resource provider also expresses one constraint
   over all her variables
to enforce that her resource can only be allocated to at most one of the interested bidders 
for each variable xb   we also introduce one copy variable bx owned by the bidder b  with
the constraint xb   bx   each bidder b then expresses a constraint over all her variables 
enforcing that she should only be allocated two resources that correspond exactly to one of
her requests  the introduction of copy variables is motivated by the discsp assumption
that each agent knows all constraints involving its variables  and serves two privacy related
purposes     the full list of agents placing requests on a given resource is only known to the
resource provider  and    the full list of resources requested by a given agent  and in which
bundles  is only known to the agent itself  like for the meeting scheduling problem class  all
inter agent constraints are equality constraints  therefore we do not report the performance
of p     dpop      whose privacy guarantees are the same as p dpop     
for mpc discsp   the discsp formulation was simplified by not introducing copy
variables hold by bidders  since they are not necessary to protect constraint privacy  bidders
can request resources by expressing constraints directly over the variables owned by the
resource providers  however  since mpc discsp  assumes that all variables are public  in
order to increase topology privacy we introduced  for each resource  as many variables as
bidders  regardless of whether they are actually interested in the resource  to reduce the
size of the search space  we assumed that the     constraints were public 
figure    shows that the performance of mpc discsp  decreases very fast with the
number of requests  such that the algorithm was not able to scale beyond problems of
size    the p   dpop    algorithms seem to scale better  and were able to solve problems
involving   requests  on all three metrics  both algorithms were largely outperformed by
p dpop      whose runtime curve is remarkably flat  and almost overlaps with the runtime
curve of dpop  which is consistent with their undistinguishable induced width curves 
the overhead of p dpop    compared to dpop is slightly larger in terms of information
exchanged  and goes up to one order of magnitude in terms of number of messages  pdpop  and p   dpop  performed the same as their respective non plus variants 
    strategic game equilibria
finally  we report experimental results on one last class of problem benchmarks  which
corresponds to the distributed computation of pure nash equilibria in strategic games  we
used the particular example of the party game introduced by singh et al          which is
a one shot  simultaneous move  graphical game  kearns  littman    singh        in which
all players are invited to a common party  and each players possible strategies are whether
to attend the party or not  players are arranged in an undirected social graph  which
defines which other invitees each player knows  each players reward for attending the
   cats assumes there is a single auctioneer  and does not specify which slot is at which airport  this is
why we have assumed that each resource was provided by a separate resource provider 

   

fileaute   faltings

party depends on whether her acquaintances also decide to attend  and on whether she
likes them or not  the reward is   per attendee she likes  minus   per attendee she dislikes 
and minus a constant cost of attendance in         the reward for not attending is   
the problem of computing a nash equilibrium to such a game can be formulated into
a discsp as follows  each player is an agent  which owns one binary variable for its
strategy  and one copy variable for the strategy of each of its acquaintances  each variable
is constrained to be equal to each of its copy variables  using binary equality constraints like
for resource allocation problems  section       each agent also expresses one constraint over
all its variables  which only allows a particular strategy for the agent if it is a best response to
its neighbors joint strategies  notice that the resulting constraint graph is not the same as
the game graph  due to the presence of copy variables  a solution to the discsp therefore
yields a joint strategy profile for all players that is a pure nash equilibrium  since each
player plays best response to her neighbors  notice also that  since each player holds a copy

simulated time  in ms 

   

induced width

  
 

   

 

   

p   dpop   

 

mpc

 

p dpop

   

   

 
 

dpop

 

 

  

 
 

  

 
 

 

 
 
 
number of players

 

 

number of messages

   

 

 
 
 
number of players

 

information exchanged  in bytes 

   
   

   

   
 

  

   
   

   

   

 

 

 
 
 
number of players

   

 

 

 

 
 
 
number of players

figure     performance on party games 

   

 

fiprotecting privacy thru distributed computation in multi agent decision making

variable for each of her neighbors strategy  these strategies are semi private information
that cannot be protected  which is why we do not report the performance of p     dpop     
for mpc discsp   the discsp formulation can be simplified by not introducing copy
variables  vickrey   koller         an interesting consequence of this difference is that 
contrary to p   dpop      mpc discsp  is then able to hide each players chosen strategy
from her neighbors  in the context of the party game  this is not very useful to players who
decide to attend the party  since they will necessarily eventually discover whether their
acquaintances also decided to attend or not  on the other hand  a player who declines the
invitation does not directly discover anything about the list of attendees  she might still
be able to make indirect inferences about the decisions of her acquaintances  based on the
fact that her decision to decline is a best response to their respective chosen strategies 
figure    reports on the performance of the algorithms on random acyclic game graphs
of degree    i e  trees in which each node has at most   children   with varying numbers
of players  the p   dpop    algorithms were only able to scale up to problems of size  
due to the rapidly increasing induced width  and were outperformed by mpc discsp  by
at least one order of magnitude across all three metrics  both algorithms still performed
largely worse than the p dpop    algorithms  which are capable of scaling to much larger
problems  this is because  in this setting  the induced width remains bounded  since the
game graphs are acyclic  dpops induced width is constantly equal to    because each
feas message sent by agent ax to its parent agent ay is expressed only over ay s strategy
variable and the copy of ax s strategy variable held by ay   p dpop    s induced width
is increased by   because agent ay has at most   children in the pseudo tree  each using
a different codename for ay s strategy variable  as a result  the performance overhead in
p dpop    compared to dpop is minimal in terms of runtime  it is slightly larger in
information exchanged  and reaches one order of magnitude in number of messages 

   conclusion
in this paper  we have addressed the issue of providing strong privacy guarantees in distributed constraint satisfaction problems  discsps   we have defined four types of information about the problem that agents might want to hide from each other  agent privacy
 hiding an agents identity from non neighbors   topology privacy  keeping the topology
of the constraint graph private   constraint privacy  protecting the knowledge of the constraints   and decision privacy  the final value of each variable should only be known to
its owner agent   departing from previous work in the literature  which only addressed
subsets of these privacy types  and often focused on quantifying the privacy loss in various algorithms  we have proposed a set of algorithms with strong guarantees about what
information provably will not be leaked 
we have carried out performance experiments on four different classes of benchmarks 
graph coloring  meeting scheduling  resource allocation  and game equilibrium computation 
the results show that our algorithms not only provide stronger privacy guarantees  but also
scale better than the previous state of the art  we have explored the tradeoff between
privacy and performance  the p dpop  variant was shown to scale much better than the
others  but can only guarantee partial constraint and decision privacy  which may still be
considered sufficient in many problem classes  full decision privacy  p     dpop    and full
   

fileaute   faltings

constraint privacy  p   dpop    come at significantly higher prices in computation time and
information exchange  which  with todays hardware  limits their applicability to smaller
problem instances  we have compared the performance of our algorithms against the mpcdiscsp  algorithm  which can be considered the previous state of the art in discsp with
strong privacy guarantees  on the first three classes of benchmarks  all our algorithms
almost systematically outperformed mpc discsp  in terms of runtime and number of
messages exchanged  however  mpc discsp  proved to exchange less information than
p    dpop    on game equilibrium computation  mpc discsp  scaled much better than
p   dpop  along all three metrics  but was still largely outperformed by p dpop    in
terms of practical applicability  we have shown that some of our algorithms scale to mediumsize problems that are beyond reach of the previous state of the art in general discsp with
strong privacy guarantees  we have also investigated the application of these algorithms to
real life meeting scheduling  in collaboration with the nokia research center in lausanne 
future work could extend the techniques in this paper along several directions  first 
while we have restricted ourselves to pure satisfaction problems for the sake of simplicity 
our algorithms can be easily extended to solve distributed constraint optimization problems  dcops   in fact  our p    dpop  algorithms already are optimization algorithms 
only p   dpop  requires some changes to be applied to dcops  these changes involve
replacing elgamal encrypted boolean feasibility values with elgamal encrypted  bit wise
vector representations of integer cost values  as described by yokoo and suzuki         this
would incur an increase in complexity that is only linear in an upper bound on the cost of
the optimal solution  an optimization variant of mpc discsp   called mpc diswcsp  
was also already proposed by silaghi and mitra         we report performance comparisons
with our algorithms in other publications  leaute   faltings        leaute        
further avenues of future research could result from relaxing our assumption that agents
are honest  but curious  a number of challenging issues arise when attempting to apply
the techniques in this paper to self interested agents that can manipulate the protocol in
order to achieve solutions that better suit their selfish preferences  one such issue is that of
verifiability  which involves making it possible to check whether the protocols were executed
as designed  without the need to decrypt the messages exchanged  another interesting issue
is whether it is possible to modify the algorithms to make them incentive compatible  such
that it is in each agents best interest to honestly follow the protocol 

appendix a  cooperative elgamal homomorphic encryption
homomorphic encryption is a crucial building block of the privacy preserving algorithms
introduced in this paper  encryption is the process by which a message  in this appendix 
a boolean  can be turned into a cyphertext  in such a way that decrypting the cyphertext
to retrieve the initial cleartext message is impossible  or  in this case  computationally very
hard in the worst case  without the knowledge of the secret encryption key that was used to
produce the cyphertext  an encryption scheme is said to be homomorphic if it is possible
to perform operations on cyphertexts that translate to operations on the initial cleartext
messages  without the need to know the encryption key  elgamal encryption  elgamal 
      is one such encryption scheme that possesses this homomorphic property 
   

fiprotecting privacy thru distributed computation in multi agent decision making

a   basic elgamal encryption of booleans
elgamal encryption can be used to encrypt booleans such that performing the following
operations on encrypted booleans is possible without the knowledge of the decryption key 
 the and of an encrypted and a cleartext boolean 
 the or of two encrypted booleans 
elgamal encryption is a homomorphic  public key cryptography system based on the
intractability of the diffie hellman problem  tsiounis   yung         which proceeds as
follows  let p be a safe prime of the form  rt      where r is a large random number  and
t is a large prime  all numbers and all computations will be modulo p  let g be a generator
of zp   i e  g is such that its powers cover     p      with p and g assumed public knowledge 
the elgamal private key is a chosen random number x      p      and the associated public
key is y   gx   a cleartext number m is then encrypted as follows 
e m            my r   gr  

   

where r is a random number chosen by the encryptor  decryption proceeds as follows 
my r

 
 m 
x
 gr  x
a useful feature of elgamal encryption is that it allows to randomize an encrypted value
to generate a new encryption bearing no similarity with the original value  randomizing
e m  in eq      yields 








e    m     y r   g r      my r r   gr r  
which still decodes to m  to encrypt booleans  we represent false by    and true by a
value z       which allows us to compute the and and or operations 
e m   true   e    m   

e m   false   e   

e m     e m                       e m   m     
a   cooperative elgamal encryption
in the previous elgamal encryption scheme  decryption can be performed in a single step 
using the private key  which is a secret of the agent that originally encrypted the message 
however  it is also possible to perform elgamal encryption in such a way that all agents
need to cooperate in order to perform decryption  this is possible through the use of a
compound elgamal key  x  y  that is generated cooperatively by all agents  pedersen        
distributed key generation the elgamal key pairs  xi   yi   of n agents can be combined in the following fashion to obtain the compound key pair  x  y  
x   ni   xi

y   ni   yi  

distributed decryption if each agent publishes its decryption share  xi   the message
can be decrypted as follows 


  x  m 
ni    xi

   

fileaute   faltings

appendix b  routing of messages along a circular variable ordering
in order to implement the round robin exchange of vectors briefly presented in section     
the variables are ordered along a circular ordering that is mapped to the chosen pseudo tree 
as illustrated in figure    page        each variable needs to be able to send a message to
the previous variable  i e  clock wise  in the ordering  which is a challenge in itself because
only neighboring variables should communicate directly  furthermore  to protect agent and
topology privacy  no agent should know the overall circular ordering  to solve this issue 
algorithm   is the algorithm used in p   dpop  leaute   faltings        to route messages 
algorithm   sending a message m clock wise in the circular variable ordering 
procedure  toprevious m   for variable x
   if x is the root of the pseudo tree then send the message  last  m   to xs last child
   else send the message  prev  m   to xs parent
procedure  routemessages   for variable x
   loop
  
wait for an incoming message  type  m   from a neighbor yi
  
if type   last then
  
if x is a leaf then deliver message m to x
  
else send the message  last  m   to xs last child
  
else if type   prev then
  
if yi is xs first child then deliver the message m to x
   
else send the message  last  m   to the child before yi in xs list of children
consider for instance a message m that agent a x    wants to send to the previous
variable  which is x    but a x    does not know it  agent a x    wraps m into a prev
message that it sends to its parent variable x   line     because the sender variable x  is
x  s first  and only  child  a x    infers that it should deliver m to itself  line     consider
that a x    now wants to forward m to its previous variable  x    which a x    does not
know  like before  a x    sends a message  prev  m   to its parent variable x    which then
reacts by sending a message  last  m   to its last child preceding x  in its list of children 
which is x   line      last messages indicate that the payload m should be delivered to
the last leaf of the current subtree  line     therefore  a x    delivers m to itself  line    since
it has no children  if the root wants to send a message to its previous variable  it also uses
a last message to forward it to the last leaf of the overall pseudo tree  line    
theorem     algorithm   guarantees full agent privacy 
proof  the goal of this algorithm is precisely to address agent privacy issues in the pseudotree rerooting procedure  which involves each variable sending a message to the previous
variable in a circular ordering of the variables  there is no guarantee that there exist a
circular ordering such that any two consecutive variables are owned by neighboring agents 
which is necessary to protect agent privacy  therefore  algorithm   is responsible for routing
these messages through paths that only involve communication between neighboring agents 
the routing procedure itself only involves encapsulating the routed messages inside
prev or last messages  which do not contain any other payload  therefore  as long
   

fiprotecting privacy thru distributed computation in multi agent decision making

as the routed messages do not contain information that can be used to identify a nonneighboring agent  the routing procedure guarantees agent privacy 
theorem     algorithm   guarantees full topology privacy 
proof  the purpose of this algorithm is to enable variables to propagate messages along
a circular variable ordering  without the need to know any topological information about
the constraint graph  other than the knowledge of their respective  pseudo  parents and
 pseudo  children in the pseudo tree  toprevious   makes it possible to send a message
to the previous variable in the circular ordering  without knowing which variable this is 
 the reception of a  prev  m   message only indicates that the sender child wants
the included message m to be delivered to its previous variable  which is either the
recipient of the prev message  or an unknown descendant thereof 
 the reception of a  last  m   message from ones parent indicates that an unknown
variable  either the unknown root of the pseudo tree  or the unknown child of an
unknown ancestor  in another branch  wants m to be delivered to its previous variable 
which is ones descendant in the pseudo tree 

references
ben or  m   goldwasser  s     wigderson  a          completeness theorems for noncryptographic fault tolerant distributed computation  extended abstract   in proceedings of the twentieth annual acm symposium on theory of computing  stoc    
pp      
bilogrevic  i   jadliwala  m   hubaux  j  p   aad  i     niemi  v          privacy preserving
activity scheduling on mobile devices  in proceedings of the first acm conference
on data and application security and privacy  codaspy     pp         
brito  i     meseguer  p          distributed forward checking  in proceedings of the
ninth international conference on principles and practice of constraint programming
 cp     vol       of lecture notes in computer science  pp         
brito  i     meseguer  p          distributed forward checking may lie for privacy  in
proceedings of the ninth international workshop on distributed constraint reasoning
 cp dcr    
brito  i     meseguer  p          cluster tree elimination for distributed constraint optimization with quality guarantees  fundamenta informaticae              
chechetka  a     sycara  k          no commitment branch and bound search for distributed constraint optimization  in proceedings of the fifth international joint conference on autonomous agents and multiagent systems  aamas     pp      
     
dechter  r          constraint processing  morgan kaufmann 
   

fileaute   faltings

doshi  p   matsui  t   silaghi  m  c   yokoo  m     zanker  m          distributed private
constraint optimization  in proceedings of the      ieee wic acm international
conference on intelligent agent technology  iat     pp         
elgamal  t          a public key cryptosystem and a signature scheme based on discrete
logarithms  ieee transactions on information theory                 
faltings  b   leaute  t     petcu  a          privacy guarantees through distributed constraint satisfaction  in proceedings of the      ieee wic acm international conference on intelligent agent technology  iat     pp         
franzin  m  s   freuder  e  c   rossi  f     wallace  r  j          multi agent constraint
systems with preferences  efficiency  solution quality  and privacy loss  computational
intelligence                 
gentry  c          fully homomorphic encryption using ideal lattices  in proceedings of the
forty first annual acm symposium on theory of computing  stoc     pp     
     acm special interest group on algorithms and computation theory  sigact  
gershman  a   meisels  a     zivan  r          asynchronous forward bounding for distributed constraints optimization  in proceedings of the seventeenth european conference on artificial intelligence  ecai     pp         
goldreich  o          foundations of cryptography  vol     basic applications  cambridge
university press 
greenstadt  r   grosz  b     smith  m  d          ssdpop  using secret sharing to
improve the privacy of dcop  in proceedings of the ninth international workshop
on distributed constraint reasoning  cp dcr    
greenstadt  r   pearce  j  p     tambe  m          analysis of privacy loss in distributed
constraint optimization  in proceedings of the twenty first national conference on
artificial intelligence  aaai     pp         
grinshpoun  t     meisels  a          completeness and performance of the apo algorithm 
journal of artificial intelligence research  jair              
grubshtein  a   grinshpoun  t   meisels  a     zivan  r          asymmetric distributed
constraint optimization  in proceedings of the ijcai   distributed constraint reasoning workshop  dcr     pp       
gutierrez  p     meseguer  p          bnb adopt  with several soft arc consistency
levels  in proceedings of the nineteenth european conference on artificial intelligence
 ecai     no      in frontiers in artificial intelligence and applications  pp       
herlea  t   claessens  j   preneel  b   neven  g   piessens  f     decker  b  d          on securely scheduling a meeting  in proceedings of the sixteenth international conference
on information security  trusted information  the new decade challenge  sec    
international federation for information processing  ifip  series  pp         
hirayama  k     yokoo  m          distributed partial constraint satisfaction problem 
in proceedings of the third international conference on principles and practice of
constraint programming  cp     vol       of lecture notes in computer science 
pp         
   

fiprotecting privacy thru distributed computation in multi agent decision making

kearns  m  j   littman  m  l     singh  s  p          graphical models for game theory 
in proceedings of the seventeenth conference on uncertainty in artificial intelligence
 uai     pp         
kuchcinski  k     szymanek  r          java library  jacop java constraint programming
solver  http   jacop osolpro com  
leaute  t          distributed constraint optimization  privacy guarantees and stochastic
uncertainty  phd thesis  ecole polytechnique federale de lausanne  epfl  
leaute  t     faltings  b          privacy preserving multi agent constraint satisfaction 
in proceedings of the      ieee international conference on privacy  security  risk
and trust  passat     pp       
leaute  t     faltings  b          coordinating logistics operations with privacy guarantees  in proceedings of the twenty second international joint conference on artificial
intelligence  ijcai     pp           
leaute  t   ottens  b     szymanek  r          frodo      an open source framework for
distributed constraint optimization  in proc  of the ijcai   distributed constraint
reasoning workshop  dcr     pp          http   frodo  sourceforge net 
leyton brown  k   pearson  m     shoham  y          towards a universal test suite for
combinatorial auction algorithms  in proceedings of the second acm conference on
electronic commerce  ec     pp        acm special interest group on electronic
commerce  sigecom   http   www cs ubc ca  kevinlb cats 
maheswaran  r  t   pearce  j  p   bowring  e   varakantham  p     tambe  m         
privacy loss in distributed constraint reasoning  a quantitative framework for analysis
and its applications  autonomous agents and multi agent systems  jaamas          
     
maheswaran  r  t   tambe  m   bowring  e   pearce  j  p     varakantham  p         
taking dcop to the real world  efficient complete solutions for distributed multievent scheduling  in proceedings of the third international joint conference on autonomous agents and multiagent systems  aamas     vol     pp          acm
special interest group on artificial intelligence  sigart  
mailler  r     lesser  v  r          a mediation based protocol for distributed constraint
satisfaction  in proceedings of the fourth international workshop on distributed constraint reasoning  dcr    
meisels  a     zivan  r          asynchronous forward checking on discsps  in proceedings
of the fourth international workshop on distributed constraint reasoning  dcr    
modi  p  j   shen  w  m   tambe  m     yokoo  m          adopt  asynchronous distributed constraint optimization with quality guarantees  artificial intelligence      
       
netzer  a   meisels  a     grubshtein  a          concurrent forward bounding for dcops 
in proceedings of the twelfth international workshop on distributed constraint reasoning  dcr     pp       
   

fileaute   faltings

pedersen  t  p          a threshold cryptosystem without a trusted party  extended abstract   in advances in cryptology  eurocrypt    workshop on the theory and
application of cryptographic techniques  proceedings  vol      of lecture notes in
computer science  pp         
petcu  a     faltings  b          dpop  a scalable method for multiagent constraint
optimization  in proceedings of the nineteenth international joint conference on
artificial intelligence  ijcai     pp         
petcu  a   faltings  b     parkes  d  c          m dpop  faithful distributed implementation of efficient social choice problems  journal of artificial intelligence research
 jair              
rassenti  s  j   smith  v  l     bulfin  r  l          a combinatorial auction mechanism
for airport time slot allocation  the bell journal of economics                 
shamir  a          how to share a secret  communications of the acm                  
silaghi  m  c       a   hiding absence of solution for a distributed constraint satisfaction
problem  poster   in proceedings of the eighteenth international florida artificial
intelligence research society conference  flairs     pp         
silaghi  m  c       b   using secure discsp solvers for generalized vickrey auctions 
complete and stochastic techniques  in proceedings of the ijcai   distributed constraint reasoning workshop 
silaghi  m  c   faltings  b     petcu  a          secure combinatorial optimization simulating dfs tree based variable elimination  in proceedings of the ninth international
symposium on artificial intelligence and mathematics 
silaghi  m  c     mitra  d          distributed constraint satisfaction and optimization
with privacy enforcement  in proceedings of the      ieee wic acm international
conference on intelligent agent technology  iat     pp         
silaghi  m  c   sam haroud  d     faltings  b          asynchronous search with aggregations  in proceedings of the seventeenth national conference on artificial intelligence and twelfth conference on innovative applications of artificial intelligence
 aaai iaai     pp         
singh  s   soni  v     wellman  m  p          computing approximate bayes nash equilibria
in tree games of incomplete information  in proceedings of the fifth acm conference
on electronic commerce  ec     pp       
sultanik  e  a   lass  r  n     regli  w  c          dcopolis  a framework for simulating
and deploying distributed constraint optimization algorithms  in proceedings of the
ninth international workshop on distributed constraint reasoning  cp dcr    
tsiounis  y     yung  m          on the security of elgamal based encryption  in proceedings of the first international workshop on practice and theory in public key
cryptography  pkc     vol       of lecture notes in computer science  pp         
vickrey  d     koller  d          multi agent algorithms for solving graphical games  in proceedings of the eighteenth national conference on artificial intelligence  aaai    
pp         
   

fiprotecting privacy thru distributed computation in multi agent decision making

vinyals  m   rodrguez aguilar  j  a     cerquides  j          constructing a unifying
theory of dynamic programming dcop algorithms via the generalized distributive
law  autonomous agents and multi agent systems  jaamas                  
wallace  r  j     freuder  e  c          constraint based reasoning and privacy efficiency
tradeoffs in multi agent problem solving  artificial intelligence                   
yeoh  w   felner  a     koenig  s          bnb adopt  an asynchronous branch andbound dcop algorithm  journal of artificial intelligence research  jair         
    
yokoo  m          asynchronous weak commitment search for solving distributed constraint
satisfaction problems  in proceedings of the first international conference on principles and practice of constraint programming  cp     no      in lecture notes in
computer science  pp        
yokoo  m   durfee  e  h   ishida  t     kuwabara  k          distributed constraint satisfaction for formalizing distributed problem solving  in proceedings of the twelfth
international conference on distributed computing systems  icdcs     pp     
    
yokoo  m     suzuki  k          secure multi agent dynamic programming based on homomorphic encryption and its application to combinatorial auctions  in proceedings
of the first international joint conference on autonomous agents and multi agent
systems  aamas     pp         
yokoo  m   suzuki  k     hirayama  k          secure distributed constraint satisfaction 
reaching agreement without revealing private information  in proc   th intl  conf  on
principles and practice of constraint prog   cp     vol       of lncs  pp         
yokoo  m   suzuki  k     hirayama  k          secure distributed constraint satisfaction 
reaching agreement without revealing private information  artificial intelligence 
         distributed constraint satisfaction          
zivan  r     meisels  a          concurrent dynamic backtracking for distributed csps 
in proceedings of the tenth international conference on principles and practice of
constraint programming  cp     vol       of lecture notes in computer science 
pp         

   

fi