journal artificial intelligence research                 

submitted        published      

heuristic search time matters
ethan burns
wheeler ruml

eaburns cs unh edu
ruml cs unh edu

department computer science
university new hampshire
durham  nh       usa

minh b 

minh b do nasa gov

planning scheduling group
sgt inc 
nasa ames research center
moffett field  ca       usa

abstract
many applications shortest path algorithms  impractical find provably
optimal solution  one hope achieve appropriate balance search
time solution cost respects users preferences  preferences come many
forms  consider utility functions linearly trade off search time solution cost 
many natural utility functions expressed form  example  solution
cost represents makespan plan  equally weighting search time plan makespan
minimizes time arrival goal achieved  current state of theart approaches optimizing utility functions rely anytime algorithms  use
extensive training data compute termination policy  propose direct
approach  called bugsy  incorporates utility function directly search 
obviating need separate termination policy  describe new method based
off line parameter tuning novel benchmark domain planning time pressure
based platform style video games  present believe first
empirical study applying anytime monitoring heuristic search  compare
proposals  results suggest parameter tuning technique give
best performance representative set training instances available  not  bugsy
algorithm choice  performs well require off line training 
work extends tradition research metareasoning search illustrating
benefits embedding lightweight reasoning time search algorithm itself 

   introduction
many problems artificial intelligence formulated shortest path problems 
solved using heuristic search algorithms a   hart  nilsson    raphael 
       unfortunately  state spaces often grow exponentially problem size 
usually infeasible find optimal solutions shortest path problems practical interest 
instead  practitioners tend settle suboptimal solutions  often found
efficiently expensive execute  one left choice spending
long time searching cheap solution  little time searching expensive one 
argue new approach strictly concerned optimizing solution cost 
optimizing utility function given terms solution cost search time 
c
    
ai access foundation  rights reserved 

fiburns  ruml   

utility function  user specify preference search time solution
cost  algorithm handles rest 
consider utility functions given linear combination search time solution
cost  important form utility function two reasons  first  easily elicited
user already explicitly application domain  example  cost
given monetary terms  usually possible ask much time one willing spend
decrease solution cost certain amount  second  solution cost given terms
time  i e   cost represents time required agent execute solution  
form utility function used optimize call goal achievement time 
weighting search time execution time equally  utility aware search attempt
minimize sum two  thus attempting behave agent achieve
goal quickly possible 
existing techniques problem based anytime algorithms  dean  
boddy         general class algorithms emit stream solutions decreasing
cost converging optimal one  sufficient knowledge performance
profile anytime algorithm  represents probability decrease
solution cost certain amount given current solution cost additional search time 
possible create stopping policy aware users preference trading
solving time solution cost  hansen   zilberstein        finkelstein   markovitch        
two disadvantages using anytime algorithms trade off solving time
solution cost  first profile anytime algorithm must learned off line
representative set training instances  many settings  domain independent
planning  problem set unknown  one cannot easily assemble representative training set  also  often obvious parameters problem affect performance
difficult tell problem set representative  even instance generator
available  instances generates may represent seen real world 
second issue that  stopping policy aware users preference time
cost  underlying anytime algorithm oblivious emit stream
solutions regardless desired trade off  policy must simply best
solutions found  algorithm may waste lot time finding many
solutions simply discarded  search algorithm fully aware
possible candidate solutions available relative estimated merits 
paper presents four main contributions  first  combine anytime heuristic search
dynamic programming based monitoring technique hansen zilberstein
        best knowledge  first apply anytime monitoring
anytime heuristic search  second  present simple portfolio based method
estimates good parameter use bounded suboptimal search algorithm optimize
given utility function  third  present bugsy  best first search algorithm
rely off line training  yet accounts users preference search time
solution cost   one important difference bugsy previous proposals
trading off deliberation time solution cost bugsy considers trade off directly search algorithm  whereas previous techniques  based anytime
algorithms  consider trade off externally actual search algorithm  finally 
   previous version bugsy proposed ruml         see appendix discussion
improvements incorporated version presented here 

   

fiheuristic search time matters

present results set experiments comparing portfolio based method  anytime monitoring  bugsy  along utility oblivious algorithms a  greedy
best first search  real time search algorithms  decision theoretic a   dta   russell  
ericwefald         previously proposed utility aware search  much
work discussing trade off deliberation solution cost  best
knowledge first implement thoroughly evaluate many ideas
context heuristic search 
results experiments reveal two surprises  first  representative set
training instances available  effective approach simple technique
selecting bound use bounded suboptimal search  surprisingly  convincingly
dominates anytime algorithms monitoring tests  second  neither bugsy
anytime search monitoring dominates other  bugsy require off line
training  yet surprisingly  bugsy perform well methods use training data 
representative problem set available  bugsy algorithm choice 
work extends tradition research metareasoning planning illustrating
benefits embedding lightweight reasoning time search algorithm itself 

   background
section briefly describe heuristic search  present terminology used
remainder paper  discuss type utility functions addressing 
    heuristic search
considered paper  heuristic search technique finding shortest path
nodes weighted graph  many problems specified form  since
typical graphs much large represent explicitly  algorithms usually
generate graph lazily using function called expand  expand function returns
successors node graph  call process evaluating expand function
node expanding node  expanding node say generating
successors 
a   hart et al         probably best known heuristic search algorithm  maintains two sets nodes  open list contains frontier nodes generated
yet expanded  closed list contains nodes already expanded
 a common optimization closed list include nodes already
open list too   therefore represent duplicate states encountered again  open list
sorted f  n    g n    h n   g n  cost path initial node
node n  h n  heuristic estimate cheapest path cost n goal node
reachable n  algorithm proceeds removing node minimum f value
open list  expanding it  putting children open list  putting node
closed list  a  removes goal node open list  stops searching
returns path goal solution  finally  heuristic never over estimates
cost go called admissible  admissible heuristic  a  returns optimal
solutions 
dechter pearl        prove heuristic satisfies property called consistency
 for nodes n m  h n  h m    c n  m   c n  m  cost cheapest
   

fiburns  ruml   

path n m   a  expands fewest possible nodes required prove
optimality solution given heuristic  practice a  often takes long
 helmert   roger         thus given optimal efficiency infeasible look optimal
solutions many problems  instead  one must settle suboptimal solutions 
hope possible find sufficiently cheap solution within reasonable amount
time memory 
    suboptimal search
greedy best first search  michie   ross        popular suboptimal search algorithm 
proceeds a   orders open list heuristic  h n   idea
remaining search effort correlates remaining solution cost  words  assumes
easier find path goal nodes low h  strictly
attempting minimize search time  thayer ruml        show greedy best first
search different heuristic  d  effective  instead estimating cost go 
done traditional h functions  heuristic  called distance estimate  estimates
number remaining search nodes path cheapest solution beneath node 
practice  distance estimates readily available cost to go heuristics provide
much better performance used greedy best first search domains less cost
go directly correlated less search go  call greedy best first search using
heuristic speedy search  analogy greedy search 
greedy best first search find solutions quickly  bound
cost solutions  bounded suboptimal search algorithms remedy problem  weighted
a   pohl        perhaps common techniquesit proceeds a  
orders open list f  n    g n    w h n   w    weighting parameter 
w  puts emphasis heuristic estimate cost arriving node  thus
greedier a  often finds suboptimal solutions much faster a  finds
optimal ones  addition  weight provides bound suboptimality solutions 
solutions w times cost optimal solution  pohl         unlike
greedy best first search  weighted a  lets user select weight  allowing provide
either cheaper solutions faster solutions depending needs 
refer reader work thayer        in depth study suboptimal
bounded suboptimal search algorithms  including many use heuristics 
    utility functions
far  described a   optimizes solution cost  bounded suboptimal search 
finds solutions within constant factor optimal  greedy best first search 
attempts minimize solver time  often  none really desired  optimal solutions
require impractical amount resources  one rarely requires solutions strictly within
given bound optimal  unboundedly suboptimal solutions costly  instead 
propose optimizing simple utility function given linear combination search time
solution cost 
u  s  t     wf g  s    wt t 
   
solution  g  s  cost solution  time solution
returned  wf wt user specified weights used express preference trading off
   

fiheuristic search time matters

search time solution cost  number time units user willing spend
achieve improvement one cost unit wf  wt   quantity usually easily elicited
users already explicit application domain  cost empty
solution  g       user specified value defines utility achieved case
search gives without returning solution
linear utility function two main benefits  first  fairly expressive 
example  one optimize cost solution search time given
monetary terms  situation occur cloud computing environments computation time costs money  linear utility function capture optimal greedy search
using   weight execution time solution cost respectively  additionally 
linear utility function express goal achievement time weighting search time equally
solution makespan  practical examples minimizing goal achievement time
desired include robotic video game pathfinding problems  settings  user
often care optimal solutions take long find  may
care achieving goal quickly possible 
demonstration minimizing goal achievement time  made video
a   speedy search  bugsy solving pathfinding video game pathfinding problem 
available online appendix paper web  http   youtu be 
yluf  v plu  video includes three panels  showing agent using different
search algorithm  since focus finding cost optimal solutions 
speedy bugsy agents begin moving almost immediately  a  agent stands still
long time plans optimal path  doesnt start moving bugsy
arrived goal  occurring  speedy agent following
extremely circuitous path  doesnt reach goal approximately    seconds
a   didnt show agonizing seconds video  instead stopped recording
soon a  reached goal  clearly  bugsy agent  optimizes goal achievement
time  solution cost search time  preferred scenario 
quite expressive  linear utility functions rather simple  one main benefit
simplicity that  fixed utility function  passage time decays utility
values rate  simplification allows us ignore time passed
current decision point  express utility values terms utility
outcome starting current moment time  without benefit  mere passage
time would change relative ordering utilities different outcomes 
would need re compute utility values every point time order select best
outcome 
consider linear utility functions work  noted one
could consider expressive functions  step functions  example  represent
deadlines certain amount time elapsed utility acting greatly
decreases  bugsy support functions  anytime monitoring technique
discussed section     restrictions utility functions optimize 
anytime monitoring naturally handle expressive functions  step functions 

   previous work
next describe previous techniques trading off solver time solution cost 
   

fiburns  ruml   

    monitoring anytime algorithms
much previous work optimizing utility functions solving time cost  equation    focused finding stopping policies anytime algorithms  anytime algorithms
 dean   boddy        general class algorithms find one solution 
stream solutions strictly decreasing cost  get name one
stop anytime algorithm time get current best solution  anytime algorithms
attractive candidate optimizing utility function  since
single solution pick  opportunity choose solution
greater utility using algorithm finds single solution  different
solutions found different times  knew time algorithm
would find solutions cost solutions  could compute
utilities return solution maximizes utility  unfortunately  usually
possible know solutions anytime algorithm return without running it 
instead  algorithm running  one must continually make decision  stop now 
keep going 
deciding stop easy task  utility solution depends
cost time needed find it  one hand  stopping early reduce
amount computation time expense costly solution 
hand  algorithm continues  may reduce solution cost enough
justify extra computation time  case  final utility worse would
algorithm stopped earlier  little extra information  however 
possible create reasonable policy 
near optimal response time algorithm  nora  shekhar   dutta        provides
one simple stopping policy optimizing goal achievement time  nora  simply stops
anytime algorithm current search time user specified factor current
incumbent solutions execution time  shekhar dutta        prove the  search
stops time factor incumbent solution cost  goal achievement
time within factor min               optimal goal achievement time 
use nora slightly different shekhar dutta        
apply nora anytime heuristic search  instead  evaluated empirically
database query optimization problems  tree search problems  every leaf
node possible solution  describe one could use nora a  search 
make assumption a  stopped early without reaching goal
heuristic planning procedure used achieve goal executing partial
solution found a   procedure often available  using nora
anytime heuristic search  here  incumbent solution guaranteed reach
goal  disadvantage that  anytime stopping policies  cannot
better best solution found utility oblivious anytime algorithm 
nora finds solution within specified bound optimal goal achievement time 
instead  hansen zilberstein        present dynamic programming based technique
building optimal stopping policy utility function  requires one extra piece
information  profile anytime algorithm  hansen zilberstein define
profile probability distribution cost solution returned algorithm 
conditioned current solution cost additional time given improve
   

fiheuristic search time matters

solution  p  qj  qi   t   qj qi two possible solution costs
additional time  profile allows reasoning solution cost may decrease
algorithm given time improve it  requires extra knowledge 
performed small experiment  not shown here  found optimal policy found
using dynamic programming performs better simpler nora technique 
hansen zilbersteins technique monitors progress anytime algorithm
evaluating stopping policy discrete time intervals  algorithm considers stopping
every time units  utility achievable time algorithms current
solution costs qi is 

u  qi   t 
  stop 
   
v  qi   t    max p
p
 q
 q
 
t v
 q
 

 
t 

  continue

j
j
j
stopping policy is 

 qi   t    argmax




u  qi   t 
  stop 
p
p
 q
 q
 
t v
 q
 

 
t 

  continue
j
j
j

   

u user specified utility function p profile anytime algorithm 
show sophisticated technique accounts cost evaluating
policy  however  algorithms presented paper  cost evaluating policy
consists mere array lookup essentially free 
since profile anytime algorithm usually known  must estimated 
possible estimate profile off line one access representative set training instances  estimate profile  algorithm run training
instances   dimensional histogram created represent conditional probability distribution  p  qj  qi   t   needed compute stopping policy  cf  equation    
appendix c gives detailed description implementation procedure 
    anytime heuristic search
anytime algorithms general class many anytime algorithms
heuristic search  likhachev  gordon    thrun        hansen   zhou        richter 
thayer    ruml        van den berg  shah  huang    goldberg        thayer  benton   
helmert         paper use anytime repairing a   ara   likhachev et al        
since tended give best performance approaches according experiments
done thayer ruml         ara  executes series weighted a  searches 
smaller weight previous  since weight bounds solution cost 
looser bounds early iterations tend find costly solutions quickly  time passes
weight decreases  solution cost  eventually converging optimal  ara 
special handling duplicates encountered search enables
efficient still guaranteeing bound solutions 
anytime heuristic search algorithms  ara  parameters  running
ara   user must select weight schedule  typically comprised initial
weight amount decrement weight solution found 
behavior ara  varies different weight schedules  experiments  used
initial weight     decrement       schedule used likhachev
   

fiburns  ruml   


 
   
h  
b
d  


 

h    
d  

h  
c
d  
   
 
e

figure    small example graph 
et al          found gave best performance compared several
alternative schedules domains considered 
given fixed weight schedule  anytime heuristic search algorithm emit fixed
stream solutions given problem instance  algorithm take users
utility function account  solutions found regardless whether
user wants solution fast possible optimal solution costs  figure  
shows small  concrete example  goal find path node node e 
node labelled heuristic value  h  number nodes remaining
goal  d   edges labelled costs  user wants optimal
solution  algorithm would ideally return path a  b  c  e  however  user
wants solution fast possible  may better find solution a  d  e 
fewer nodes  may found fewer expansions  ara  considers cost 
distance  initial weight less         longer  cheaper  solution
found regardless users preference  monitoring technique select
best solutions found 
    contract search
dionne  thayer  ruml        consider problem contract search  goal
must returned hard deadline  unlike real time search  korf        
agents next action must ready deadline  contract search requires algorithm
return complete path goal  optimizing utility function  contract search must
aware cost solutions amount time required find them 
conventional approaches contract search use anytime algorithms  dionne et al 
       present deadline aware search  das  considers search time directly 
basic idea behind das consider states lead solutions deemed
reachable within deadline  two different estimates used determine set
nodes  estimate maximum length solution path search explore
deadline arrives  called dmax   estimate distance solution beneath
   

fiheuristic search time matters

search node open list  words d  states dmax   deemed
reachable  states pruned  search expands non pruned nodes best first
order f   g   h  updating dmax estimates on line  updates cause
remaining nodes pruned remaining time deadline  das uses
recovery mechanism repopulate open list set pruned nodes continues
searching deadline reached 
mentioned previously  estimates readily available normal cost to go heuristics  h  domains  leaves question estimate dmax   dionne et al 
       show simply using remaining number possible expansions  computed via
expansion rate remaining time  appropriate due phenomenon
call search vacillation  best first search expands nodes  typically expand straight single solution path  instead considers multiple solution paths
time  expanding nodes each  this  said vacillating
many different paths  may return work particular path
performed many expansions along others  account vacillation  dionne et al 
introduce metric called expansion delay estimates number additional expansions performed search expansion two successive nodes along single

texp
path  define dmax   rem
delay   trem time remaining deadline 
texp average expansion rate  delay average expansion delay  compute
average expansion delay averaging difference algorithms total expansion
count node expanded generated 
dionne et al         showed experimentally das performs favorably anytimebased approaches alternative contract search algorithms  indicating approach
directly considers search time may beneficial utility function optimization 

   off line bound selection
turn first two new methods introduced paper 
section  present simple technique trading search time
solution cost based bounded suboptimal search  recall bounded suboptimal
search algorithms return solutions guaranteed within user specified factor
optimal solution cost  practice  applications require actual bound  instead
bound used practitioners parameter tweaked speed up search
finding solutions quickly enough  fact bound trade search time
solution cost makes prime candidate automatic parameter tuning  rice        
exactly propose 
anytime methods discussed previous section  off line bound selection requires representative set training instances  instances used gather
information bounded suboptimal search trades off search time solution
cost  requirement user select set diverse bounds try
parameters search algorithm  algorithm run n training instances suboptimality bound  creating list n pairs bound 
sols b   h c    t           cn   tn  i b bound passed parameter algorithm 
ci cost solution ith training instance ti time ith
solution found  given utility function u   cost time r  select bound
   

fiburns  ruml   

gives greatest expected utility training set 


x
 
bound u   argmax

u  c  t 
 sols b  
b

   

 c t sols b  

experiments  select different weight use utility function
set                                may possible reduce number weights
training set using linear interpolation estimate performance parameters
used training  simple approach extended select
portfolio different algorithms addition different bounds  may beneficial 
example  include a  speedy search portfolio  algorithms
likely selected cheap solutions required solution must found quickly 
see section   simple technique outperforms ara  using anytime
monitor experimental evaluation  fact  representative set training instances
available  technique tends perform better algorithms
evaluate 
related technique dove tailing method valenzano  sturtevant  schaeffer  buro 
kishimoto         approach presented way side stepping need
parameter tuning running parameter settings simultaneously  found that 
dove tailing  weighted ida   korf        able return first solution much faster 
dove tailing greatly reduced high variance solving times given weight 
found dove tailing different operator orderings effective ida  
main difference work valenzano et al  quite
different goals  concern find first solution quickly  rather select
setting better optimizes user specified utility function  such  approach
run multiple settings time instead selects single parameter run
single search  fact  approaches complementary  given utility aware
algorithms parameters  one could use dove tailing avoid need perform
offline parameter selection 

   best first utility guided search
anytime search aware utility  monitoring bound selection require training 
section  present bugsy    utility aware search algorithm require
off line training 
    expansion order
a   bugsy best first search  instead ordering open list f   bugsy
orders open list estimate utility outcome resulting node
expansion  since utility dependent time  mere passage time affects utility
values  differs traditional search algorithms values used order
expansions remain constant  recall  however  using linear utility function 
utility values decay exact rate  given this  bugsy ignores past time
   bugsy acronym best first utility guided searchyes 

   

fiheuristic search time matters

compares utility estimates assuming time begins current decision point 
utility values match utility ultimate outcome  still
preserve relative order different choices agent make 
understand bugsys ordering function  first consider best utility
outcome resulting node expansion computed oracle  foreknowledge maximum utility outcome  purpose search algorithm would
achieve expanding nodes along path initial node order build
solution path  since utility function given linear combination solution cost
search time  utility value outcome written terms cost
length  possibly empty  maximum utility outcome  s 
u    wf g  s    wt  s  texp  

   

g  s  cost path  recall cost empty path user specified
constant    s  number nodes s  texp time required expand node  
given maximum utility value u   best utility outcome resulting
expanding node n is 

u
n leads maximum utility outcome

   
u  n   

u wt texp otherwise
words  utility get expanding node leads maximum utility
outcome maximum utility  expanding node simply waste time 
utility maximum utility minus cost performing unnecessary expansion 
practice  know maximum utility  must rely estimates  bugsy
uses two estimates approximate maximum utility  first  estimates cost
solution find beneath node as  f   note f estimate 
heuristic estimate true cost go  cheapest
solution beneath node may solution greatest utility  see appendix
possible alternatives  second estimates number expansions required find
solution beneath node n  exp n   one crude estimate remaining expansions d 
distance heuristic estimates remaining nodes solution path  reality 
bugsy experience search vacillation  discussed earlier  expanding nodes
along single solution path  account vacillation  use expansion
delay technique dionne et al         estimate exp n    delay d n   is 
expect remaining d n  steps goal require delay expansions 
bugsy either choose expand node  stop return empty solution 
one way bugsy differs a   bugsy decides among actions search
level  such terminating search  expanding one many open nodes   whereas
a  committed expanding nodes fixed order  bugsy node open
list represents possible outcome  bugsys maximum utility estimated using
maximum utility estimates open nodes equation   


u   max max  wf f  n    wt d n  delay texp    u        
   
nopen

   note expansion time constant general  includes time add remove elements
data structures open list 

   

fiburns  ruml   

bugsy initial   u   
   open  initial    closed   
  
  
n remove node open highest u n  value
  
n goal  return
  
add n closed
  
ns children c 
  
c goal u c      old version c open closed
  
skip c
  
else add c open
   
expansion count power two
   
re compute u n  nodes open list using recent estimates
   
re heapify open list
    loop step  
figure    pseudo code bugsy 
estimate u found  would possible substitute u equation  
estimate u  n   utility outcome expanding node open list 
however  bugsy going expand one node  need estimate u  n 
open node  bugsy simply expands node best estimated outcome 
additionally  instead computing maximization equation   scratch time
expand node  bugsy simply orders open list u n     wf f  n    wt
d n delay texp    iteration popping node maximum u n  expansion 
way  algorithm directly attempts maximize utility 
recall figure    shows two paths initial node  a  goal node  e 
bugsy accounts distance utility function  find shorter path a 
d  e utility function sufficiently emphasizes finding solutions quickly finding
cheaper solutions  hand  utility function gives preference finding
cheap solutions bugsy spend extra search time find cheaper path  a 
b  c  e 
    implementation
figure   shows high level pseudo code bugsy  clarity  code elides details
computing u n  values  algorithm proceeds a   selecting open node
highest u n  expansion  line     node goal  returned solution
 line     otherwise node put closed list  line    children generated 
new child put onto open list  line    except duplicate nodes nodes
expansion estimated negative utility  which occurs utility returning
solution greater continuing search   discarded  lines     
bugsy estimates current expansion time expansion delay online 
estimates change expansion  instead re sorting open list
expansion  bugsy re sorts whenever number nodes expanded power
   

fiheuristic search time matters

two  utility open node re computed using latest set estimates
texp expansion delay  as described section       open list re heapified
 lines        describe re sorting step greater detail section     
    stopping
bugsy orders open list decreasing order u n   stops searching maximum estimated utility less returning empty solution  may
possible continue searching anytime fashion first goal found 
utility perspective correct approach  prove here 
theorem   assuming expansion time texp constant  h admissible  exp never
overestimates expansions go  time bugsy finds first solution  s 
solutions bugsy would find beneath remaining nodes would result less utility
immediately returning s 
proof  let current time bugsy found solution s  utility returning
u  s      u  s     wf f  s  wt    u  s  utility returning now 
f  s  cost solution s  note h admissible goal  h s      
g s    g  s   f  s    f  s   therefore u s    u  s   exp never overestimates
expansions go exp s       since chosen expansion u n  u  s  every
node n open list 
let t n  minimum amount additional time bugsy requires find solution
beneath unexpanded node n  t n  texp since bugsy must least expand n 
node n open list  best utility bugsy could achieve going straight
cheapest goal n is 
u  n     wf f  n    wt  t n      

 wf f  n    wt  t n        since f  n  f  n  due admissibility h

 wf f  n    wt  exp n  texp       since exp never overestimates

  u n   definition u n 

u  s   since u  s    u s  chosen expansion  n

justifies bugsys strategy returning first goal node selects expansion 
noted bugsys estimate exp n    delay d n  lower bound 
see later sections  stopping criterion performs quite well practice 
    heuristic corrections
many best first search algorithms use admissible heuristic estimates never overestimate
true cost go  proof optimality a  proofs bounded suboptimality
bounded suboptimal search algorithms rely crucially admissibility property
heuristic  bugsy fixate cost optimal solutions guarantee bounded
cost  instead  bugsy attempts optimize utility function solution cost
one two terms  since strict cost guarantees  bugsy free drop
admissibility requirement informed inadmissible estimates available 
   

fiburns  ruml   

thayer  dionne  ruml        show inadmissible estimates provide better
performance bounded suboptimal search  one technique attempts correct
heuristic estimates on line using average single step error heuristic values
node best child  thayer et al  show technique provides good
search guidance  actually less accurate estimating true cost to go values
standard admissible heuristics  bugsy  undesirable  need
good guidance  proper estimates  thayer et al  show learning heuristic
off line linear regression provide accurate estimates  unfortunately  using
off line training would negate one bugsys main benefits  matter empirical
evaluation whether techniques provide better performance bugsy 
section      show using standard admissible heuristics often gives best
performance anyway 
    resorting
instead requiring off line training previous approaches  bugsy uses on line
estimates order nodes open list  first  many analyses regard texp
constant  practice depend log time heaps  cache behavior  multiprogramming overhead  among factors  implementation bugsy estimates texp
global average computed search  second  bugsys expansion delay estimate
calculated global average difference expansion count node
generated expanded  must done on line  unfortunately 
on line estimates may change node expansion  navely using latest estimates
compute u value newly generated nodes lead poor performance 
due comparisons used order open list  instead fair comparisons based
estimated utility node  recent fresh estimates new nodes
compared old possibly stale estimates nodes open
long time 
alleviate problem  implementation bugsy uses two sets estimates 
one stable set used order open list  one ever changing set maintaining
recent estimates  certain points throughout search  bugsy copies upto date estimates stable set  recomputes utility values open nodes 
re sorts open list  open list implemented binary heap re establish
heap property linear time number elements heap  unfortunately 
would still expensive every node expansion  so  instead  bugsy reorders
open list exponentially less frequently search progressesit reorders
number expansions power two  prove logarithmic scheme
adds constant amount overhead per expansion amortized entire search 
theorem   search space grows geometrically finite branching factor 
overhead reordering open list power of two expansions constant expansion amortized search 
proof  let b maximum branching factor  maximum number nodes
open list n expansions n  n    bn n   n b     total cost
   

fiheuristic search time matters

re sorting n expansions than 
lg n

x
i  

lg n


o n        

x
i  

o  i  b      definition n
lg n

  c b   

x

 i   c      definition

i  
lg n  

  c b     

    identity

c b       lg n   

pj


i    

   j    

  c b     n   

  o n 


so  overhead per expansion constant amortized expansions 
matter empirical evaluation determine constant overhead detrimentalwe
address section     

   experimental evaluation
techniques discussed involve approximations estimations may may
work well practice  section  present results experimental comparison
techniques better understand performance  algorithms
domains implemented c    source code available https   github com 
eaburns search 
    overview
following sections  answer several questions experimentally  first  would
ensure monitored ara  algorithm performing best comparing
profile learned off line oracle  see  off line profile 
estimate true profile algorithm  quite well informed 
section      proved re sorting adds constant overhead per expansion
amortized entire search  matter empirical evaluation determine
whether benefits outweigh overhead  experiments show re sorting
logarithmic schedule greatly outperforms bugsy without re sorting 
section     pointed bugsy require admissible heuristic estimates 
fact may perform better inadmissible  accurate heuristics  show
bugsy performs admissible heuristics  two different types corrected
heuristics  overall  conclude best configuration bugsy standard
admissible heuristics 
discussed expansion delay section      show results demonstrate
using expansion delay better simply using estimate expansions
goal  compare two variants bugsy  one ignores newly generated nodes
found already closed list  we call duplicate nodes  one
reinserts nodes onto open list better utility estimates
   

fiburns  ruml   

previously closed version  ignoring duplicates always performs better domains 
others performs better preference short search times 
then  compare a   speedy search  monitored ara   weighted a  learned
weight  bugsy  find simplest approach learning good weight
weighted a  gives best performance  find bugsy  doesnt use
off line training  performs well monitored ara   use off line
training  therefore  training instances available  recommend simple weighted
a  approach weight selected based performance training set 
training instances available bugsy algorithm choice 
lastly  compare bugsy real time search dta  platform pathfinding domain  experiments  bugsy achieves best utility 
    domains
order verify results hold variety different problems  performed
experiments four different domains  domains used described briefly
following paragraphs  detailed descriptions given appendix b 
         puzzle
   puzzle popular heuristic search benchmark small branching factor
duplicates  domain  used reasonably informed manhattan distance
heuristic  implementation followed heavily optimized solver presented burns 
hatem  leighton  ruml         ran     instances created korf        
plots including a  use results    instances solvable a   gb
memory 
      pancake problem
pancake problem another standard puzzle large constant branching factor 
experiments  used instances    pancakes  gap heuristic  helmert 
       since many problems difficult a   used ida  instead a 
domain 
      platform pathfinding
platform domain pathfinding domain creation dynamics based
  dimensional platform style video game  player must jump platforms
traverse maze  video games often naturally element time pressure 
large state space many cycles  reasonably informed heuristic based
visibility navigation  instances used experiments created randomly  using
generator described appendix b  domain particular interest
action costs given units time  each action   ms   objective minimizing
goal achievement time expressed linear combination search time solution
cost 
   

fiheuristic search time matters

      grid pathfinding
grid pathfinding popular heuristic search benchmark  motivated robotics video
games  experiments  used two different cost models  two different movement
models  cost models standard unit cost model life cost model
assigns action costs shortest  direct path expensive longer 
circuitous path  captures popular adage time money  instances
           grids uniformly distributed obstacles  heuristics based
manhattan distance heuristic four way grids  octile distance heuristic eightway grids  octile distance heuristic simple modification manhattan
distance

multiplies shorter horizontal vertical displacement   accounts
eight way move costs 
    anytime profile accuracy
want ensure implementation works well training instance sets
representative enough monitored ara  perform best  subsection 
evaluate accuracy stopping policies created using estimated anytime profiles
comparing oracle  since stopping policy guaranteed optimal
true algorithm profile  matter empirical study determine whether
estimated profile lead good policy 
estimate profile used monitored version ara   ran ara 
 gb memory limit convergence       separate test instances domain 
next  created histogram discretizing costs times solutions
       bins            experimented different utility functions varying
ratio wf  wt equation    small values wf  wt give preference finding solutions
quickly  whereas large values prefer finding cheaper solutions  case platform
game  example  viewed way change speed agent
moves  slow agent might benefit search order find shorter path 
fast agent execute path quickly  may prefer find feasible solution fast
possible 
figure   shows results experiment  box plots represent distribution
utility values found ara  using estimated stopping policy  given factor
oracles utility  oracle finds solutions anytime algorithm converges
optimal solution  picks solution would maximized utility
function  since utility values negative  larger factors represent smaller  more negative  utilities thus worse outcome  boxes surround second third quartiles 
whiskers extend extremes  circles show values    
inter quartile range outside box  center line box shows median 
gray rectangles show     confidence interval means  box represents
different wf  wt shown x axis  reference line drawn across      the
point oracle estimated policy performed equally well   many cases
boxes narrow indistinguishable line 
points figures lie slightly     line  indicating instances
oracle performed worse estimated policy  possible due
variance solving times  experiment  ara  runs used compute oracles
   

fiburns  ruml   

platform
factor oracle

factor oracle

   puzzle
 
   
   
 e  

 e    e    e  
cost time preference

 
 
 

 

 e  

 e  
 e  
 e  
cost time preference

  way unit grids

   pancake
factor oracle

   

factor oracle

 

   
   
 

    
    
 
    

 e  

 e    e    e  
cost time preference

 

 e  

 e    e    e  
cost time preference

  way unit grids

 

  way life grids
factor oracle

factor oracle

     
   
    
    

     
     
     

 e  

 e    e    e  
cost time preference

 

 e  

 e    e    e  
cost time preference

 

  way life grids
factor oracle

     
     
     
 
 e  

 e    e    e  
cost time preference

 

figure    comparison optimal stopping policy learned stopping policy 
   

fi   puzzle

 

   

 

 
  

  

log   cost time preference

 

  

   

 
  

log   cost time preference

   

 
  

 

 

   

   

 
  

  

log   cost time preference

  

log   cost time preference

 

  way life grids
log   factor best utility

   

  

  

log   cost time preference

resort
resort

 

  way life grids
log   factor best utility

  way unit grids
log   factor best utility

  way unit grids

platform
   

log   factor best utility

 

log   factor best utility

log   factor best utility

heuristic search time matters

  

 

 
  

  

log   cost time preference

  

figure    bugsy  resorting open list  circles  vs  boxes  
utilities occasionally found solutions slowly ara  runs using estimated
stopping policy  words  caused non determinism inherent utility
function depends solving time  obvious figure  instances quite
rare usually happened small values wf  wt   miniscule time differences
large effect utility 
results  conclude monitored ara  implementation performs
quite well  stopping policy often stopped best solution available
emitted underlying anytime algorithm 
    resort resort 
section     proved re sorting bugsys open list power of two expansions
added constant overhead per expansion amortized search  matter
empirical evaluation determine whether overhead worth effort 
re sorting schedules possible  tried re sorting power of two expansions 
figure   shows utility achieved bugsy without re sorting 
x axes show wf  wt ratio determining preference solution cost search time
log   scale  previous plots  smaller values indicate preference faster
search times larger values indicate preference cheaper solutions  axes show
factor utility achieved best technique instance  log  
scale  value log         indicates best utility achieved technique given
   

fiburns  ruml   

instance  values greater zero indicate less utility  points show mean value
test instances error bars giving     confidence intervals  plots 
see re sorting open list led significant improvements domains 
pancake puzzle  bugsy without re sorting unable solve instances within
 gb memory limit  remaining experiments  always enable re sorting
exponential schedule 
    heuristic corrections
section      mentioned bugsy require admissible heuristic estimates 
provides guarantees solution cost  section compare bugsy using
standard admissible heuristics bugsy using on line off line corrected heuristics 
following thayer et al          on line heuristic correction used global average
single step heuristic error node best offspring  off line heuristic
linear combination h  g  depth  d  node  coefficients term
off line heuristic learned solving set training problems using linear
least squares regression 
comparison shown figure    plots style figure    typically on line correction technique performed worstsome times significantly worse
two  attribute poor accuracy observed thayer et al 
        problems     puzzle   way unit cost grid pathfinding  off line correction technique performed best  general simple admissible
heuristics best competitive best  remainder experiments  chose use simplest variant without corrections require
off line training  which one bugsys main benefits   never worst
often best near best 
    expansion delay
section     described simply using approximation exp n   number
nodes expanded arrive goal beneath node n  inaccurate  search algorithm
expand nodes along path goal  instead vacillates
different solutions  account search vacillation  choose estimate exp n   
delay d n   delay average expansion delaythe average number nodes
expanded search makes progress along single path goal  subsection 
show experimentally using expansion delay provides much better performance
using alone 
figure   shows two versions bugsy  one uses expansion delay  labelled
exp  delay  one not  labelled without exp  delay  clear
figure using expansion delay beneficial  also  see right side
plots  cheaper solutions preferred short search times  using expansion delay
using itself  wf relatively large compared
wt utility functions  exp n  term little influence utility estimates 
   

fiheuristic search time matters

   puzzle

   

log   factor best utility

log   factor best utility



log   factor best utility

   pancake

platform
online
none
offline

   

   

 

 
  

  

  

log   factor best utility

log   factor best utility

    

 
  

    

 
  

  

 

log   cost time preference
  way life grids

log   factor best utility

  way life grids
log   factor best utility

 

    

 

log   cost time preference

   

    

 
  

  

log   cost time preference
  way unit grids

    

  

  

 

log   cost time preference

  way unit grids

  

    

 
  

 

log   cost time preference

    

  

    

    

 
  

log   cost time preference

  

  

log   cost time preference

figure    bugsy  heuristic corrections 

    duplicate dropping
suboptimal search algorithms expand nodes strict order increasing f   consequently  expand node  later re generate node via cheaper path 
call re generations duplicates  generated via cheaper paths
say inconsistent  current path cost  and subsequently cost
paths descendants  expensive necessary  likhachev et al  
       face inconsistent nodes  search algorithm put already expanded
node back open list cost accounts new  cheaper path 
node comes front open list  re expanded inconsistency
   

fiburns  ruml   

platform

   

   

   pancake

   

log   factor best utility

log   factor best utility

log   factor best utility

   puzzle

   

   

 

 
  

  

  

log   cost time preference

 

  

  

  

log   cost time preference

without exp  delay
exp  delay

log   factor best utility

log   factor best utility

   

  

 

  

  

  

  

log   cost time preference

 

  way unit grids

 

   
   
   
 

  

  

  

log   cost time preference

 

  

  

  

log   cost time preference

  way life grids

 

  way life grids

   

log   factor best utility

log   factor best utility

   

 

  way unit grids
   

   

   

   

 

   

   

   

 
  

  

  

  

log   cost time preference

  

  

log   cost time preference

figure    bugsy  expansion delay 
propagate descendants  unfortunately  lot
inconsistencies  search algorithm spend lot time re expanding
nodes again  alternative technique simply ignore inconsistency
drop duplicate nodes generated  dropping duplicates reduce
search effort needed find goal cost finding expensive solutions  whether
dropping duplicates beneficial typically depends domain  thayer   ruml 
      
figure   shows comparison bugsy without duplicate dropping 
platform  tiles  pancake domains using duplicate dropping nearly always better
re expanding duplicates  grid pathfinding problems with notable excep   

fiheuristic search time matters

    

   

    

   pancake
log   factor best utility

platform
log   factor best utility

log   factor best utility

   puzzle
   
   
   
   

    

    

 

 
  

  

  

log   cost time preference

 

 
  

  

  

log   cost time preference

duplicate reexpansion
duplicate dropping

    

    

 

  

  

  

 

    

    
    
 

  

  

  

log   cost time preference

 

  

  

  

log   cost time preference

 

  way life grids
log   factor best utility

  way life grids
log   factor best utility

  

log   cost time preference

  way unit grids
log   factor best utility

log   factor best utility

  way unit grids
    

  

 

   
   
   
 

     
     
     
 

  

  

  

  

log   cost time preference

  

  

log   cost time preference

figure    bugsy  duplicate dropping 

tion   way life cost gridsre expanding duplicate nodes seems give better performance
except solutions needed quickly possible  on left hand side plots  
reasonable  duplicate dropping tends sacrifice solution cost order
reduce search time  note also  values axes plots small 
results statistically significant  difference two techniques
grid problems duplicate re expansion performs better quite small  next
section see a  actually achieves utility many cases
duplicate re expansion outperforms duplicate dropping 
   

fiburns  ruml   

platform

log   factor best utility

log   factor best utility

   puzzle
   

   

 

 
  

  

log   cost time preference

 

  

  

log   cost time preference

 

log   factor best utility

   pancake

pee
ugsy


   

  

 
  

 

log   cost time preference

 

figure    comparison techniques 

    comparing techniques
understand promising configurations techniques studying  finally turn attention comparing them 
figures     show comparison three different techniques utility aware
search  plots larger previous plots improve clarity 
lines  plots include a   speedy search  bugsy  ara  monitoring
 ara    weighted a  weight chosen automatically different utility
function set                                wa    would expect 
preference shorter search times  on left end x axis   a  performed poorly 
stubbornly stuck optimal solutions  speedy search  however  performed quite well 
preference shifted toward desiring cheaper solutions  a  began better whereas
speedy worse  utility aware techniques much robust a 
   

fiheuristic search time matters

  way unit grids
log   factor best utility

log   factor best utility

  way unit grids

   

 

   

 
  

  

log   cost time preference

 

  

 

log   factor best utility

  way life grids

log   factor best utility

  way life grids

  

log   cost time preference

 

 
  

  

log   cost time preference

  

  

  

log   cost time preference

  

figure    comparison techniques  continued  
speedy  neither take users preference search time solution cost
account all 
utility aware techniques  bugsy weighted a  automatically
selected weight performed best  bugsy better    puzzle
platform domain  grid problems  bugsy weighted a  roughly
performance right side x axes  left side  bugsy tended get worse
relative utility aware techniques  ara  anytime monitor often
best performer  however  ara  performed significantly worse middle
right hand portion plot domains  leading us recommend weighted
a  technique simpler robust approach 
utility aware techniques often performed well a  low cost solutions
preferred  fast solutions preferred  techniques sometimes outperformed
speedy search  likely indicates solution cost still played roll final utility
   

fiburns  ruml   

log   factor best utility

orz   d

   

   

 
  

bugsy

ara 

  

 

log   cost time preference
wa 
a 
speedy

figure     grid pathfinding video game map 
left most points plots  ara  tended achieve greater utility
bugsy solutions needed quickly  cheaper solutions preferred 
bugsy tended better ara   domains  ara  spike low utility
ratios           peak appearing         life cost
grids  peak approximately coincides utility functions estimated
profile performed worse oracle shown figure    possibly indicating
      training instances required utility functions 
overall  utility aware techniques able achieve much greater utility
utility oblivious a  speedy algorithms  terribly surprising  surprisingly 
results suggest simple parameter tuning technique often give best
performance representative set training instances available  not  bugsy
algorithm choice performs well require off line training 
indeed  putting reasoning search time search algorithm itself  bugsy
competitive techniques requiring previous experience 
    limitations
previous set experiments  saw utility aware algorithms outperformed
speedy search a  wide range utility functions  section  look
one domain tends case  video game grid maps 
video games one main motivations research grid pathfinding problems 
sturtevant        observed grid maps created game designers often exhibit
different properties maps generated algorithmically  figure    shows comparison
bugsy  monitored ara   weighted a  automatically selected weight  speedy 
   

fiheuristic search time matters

figure     grid pathfinding video game map 

   
   
  

   

  speedy time

   

planning time

execution time

   

  speedy time

  speedy nodes

nodes expanded

   
   
  

 

 

  

instance

  

   
   
  

 

 

  

instance

  

 

 

  

instance

  

figure     nodes expanded  search time  execution time 
a  dragon age origins map orz   d benchmark set sturtevant 
map shown figure     fairly wide open area top  closed off
bottom half containing rooms hallways  format plot figure
previous subsection  see  a  gave best performance
large range utility functions  bugsy actually never outperformed speedy a 
entire experiment  neither ara   wa  gave best performance
single data point   hypothesized bugsys poor performance
problems easy solve  bugsys extra computation overhead  small 
prominent 
explore hypothesis  plotted performance bugsy given difference
speedy using single utility function given wf         wt     
   

fiburns  ruml   

left most utility function figure     function speedy search performed
best bugsy performed poorly  figure    shows number nodes expanded 
time spent executing  time spent searching bugsyas percentages
equivalent values speedy search  data points gathered random sample
   instances sturtevants        scenario set orz   d map  values
line      represent instances bugsy expanded fewer nodes spent less
time searching executing  values line represent instances bugsy
expanded nodes spent time speedy  x axes shows rank
instances sample increasing order optimal solution lengths 
see figure     bugsy expanded number nodes
similar execution times speedy  problems larger optimal solution
costs bugsy slightly less execution time  major difference performance
two algorithms  however  shown right most plot see bugsy
required search time speedy search almost every instance  since bugsy
speedy expanded number nodes  additional time must due
bugsys small amount extra overhead incurred re sorting computing utility 
conclude that  barring extra overhead  bugsy would performed well
best performer utility function  domains node expansion heuristic
computation isnt simplistic  overhead would insignificant 
     training set homogeneity
section     showed weighted a  approach outperformed techniques
domains  notable exception platform domain    puzzle 
bugsy best  additionally  compared domains  weighted a  technique
performed relatively poorly video game pathfinding  cf  figure    wa  outperformed utility oblivious approaches points except one   believe
poor performance wa  domains due heterogeneous training sets 
verify this  looked mean standard deviation optimal path lengths
problems domains  optimal path length viewed proxy
problem difficulty  high standard deviation statistic points diverse
set instancessome easy solve  quite difficult  platform
video game path finding domains  standard deviation optimal path length
greater     mean  twice domains  note that 
domains video game map  variety layout different areas map
means instances inherently differ characteristicsmerely gathering
instances produce homogeneous set  evidence supports hypothesis
weighted a s performance greatly hindered situations representative
training set available 
     real time search
main focus study algorithms off line searchthey find entire paths
goal execution begins  real time search  korf         search execution
happen parallel  agent allowed fixed amount time plan
must perform action  real time search possibility efficient
   

fiheuristic search time matters

off line search terms goal achievement time  search happens
parallel execution  goal achievement time simply execution time plus
small amount time required find first action  contrast off line
approach goal achievement time sum entire search time execution
time  situations  however  starting execution complete plan
goal acceptable  may lead agent dead end longer
reach goal  real time search may applicable  examples domains deadends include robotics  manufacturing  ruml  do  zhou    fromherz         spacecraft
control  exactly applications involving high value danger  automation
worthwhile  cases  desirable find entire plan guaranteed reach
goal  execution begins 
hernandez  baier  uras  koenig        introduce model comparing real time
algorithms off line techniques a   called game time model  game time
model partitions time uniform intervals  agent execute single action
interval  path planning happen parallel execution  the agent
plan step execution step t     goal move agent start
location goal location time intervals possible  minimizing goal achievement
time  objective discuss section    game time model special
case utility functions considered paper solution cost given discrete 
fixed duration units time 
real time search provides two benefits  first  may possible reduce goal
achievement time allowing search execution happen time  second 
agent start moving toward goal right awaya necessary property video games 
leaves us question whether real time search algorithms achieve
better goal achievement time off line utility aware methods  one hand  realtime search algorithms spend little time searching without making progress toward
goal  hand  real time search algorithms tend make decisions based
local information find costly solutions  results  hernandez et al 
report best approach solves problems initially known grid maps
number time intervals a   previous section  showed utilityaware techniques outperformed a  utility functions  section  compare
state of the art real time search algorithm called lss lrta   koenig   sun       
bugsy platform pathfinding domain  
previous experiments  tested algorithms variety values
ratio wf  wt   since interested goal achievement time  set wt    
calculate search time units seconds  means wf represents number
seconds one unit execution costthe speed agent  set real time
constraint lss lrta  allowed plan duration one unit
execution  always next action ready execution currently
executing action completed 
   compare time bounded a   tba  bjornsson  bulitko    sturtevant         method
performed best hernandez et al          platform domain forms directed search
graph  tba  works undirected search graphs  compare newer
f  lrta   sturtevant         perform well lss lrta  platform domain 
directed edges 

   

fiburns  ruml   

platform
log   factor best gat

   

lss lrta 
a 
speedy
bugsy

   

   

 
  

  

  

log   w f   w t

  

 

figure     comparison bugsy real time search 
figure    shows results comparison  see  lss lrta  gives rather
poor performance  goal achievement times nearly match a   bugsy able
achieve goal much faster  shows simply allowing search execution
take place parallel sufficient reduce goal achievement time  better
spend time searching solution way goal alternative spend
long time executing poor plan 
     decision theoretic a 
decision theoretic a   dta   russell   ericwefald        utility aware algorithm
allows concurrent search execution  based ideas real time heuristic
search  unlike traditional real time search  action emitted fixed
amount search  dta  decides stop searching emit action using decisiontheoretic analysis  time single best top level action lowest cost
estimate  search emits action decided utility emitting
action outweighs utility search  dta  uses approximation  found
off line training  solution cost estimate top level action improves
additional search  using consistent heuristic  estimate increase  nilsson 
       dta  stops searching decides time required raise best
actions estimated cost point longer best action costly
expected gain determining different best action 
compared bugsy  dta  relatively myopic considers cost
search involved selecting individual actions  dta  consider additional search
required solution path commits choosing action  bugsy
uses expansion delay reason required search effort entire
   

fiheuristic search time matters

log   factor best utility

platform  small instances 
speedy
a 
dta 
bugsy

   

   

   

 
  

  

  

log   w f   w t

  

 

figure     comparison bugsy dta  
path beneath node  dta  reasons search required determine best
action emit right now 
implemented dta  assess utility aware real time search might compare
utility aware off line search planning time pressure  figure    shows
results comparison dta  bugsy platform pathfinding domain 
unfortunately  dta  fairly poor performance  experiment used smaller instances
consisting   x   blocks  instead   x   block instances used previous experiments 
following russell ericwefald         gathered off line training data dta  using
states sampled uniformly probability     among visited real time
search algorithm  russell ericwefald         used algorithm called slrta  
used lss lrta   current state art  training set consisted
      x   platform instances  verified implementation ensuring
compared favorably a  speedy search    puzzlethe domain used
russell ericwefaldusing variety different utility functions  figure    
see dta  often significantly worse utility bugsy  often performing
slightly better speedy search  sometimes performing worse a   example 
cheap solutions desired 

   related work
bugsy uses estimates search time select whether terminate continue  select node expand  may said engaging metareasoning 
is  reasoning reasoning action take  much work
topic ai since late     s  dean   boddy        continuing today  cox   raja 
      
   

fiburns  ruml   

dean boddy        consider problem faced agent trying respond
predicted events time constraints  unlike setting  concern
choosing much time allocate prediction much allocate deliberation  solve type time dependent planning problem  suggest use  and
coined term  anytime algorithms  unlike anytime based techniques discussed
previously  attempt find stopping policy optimize utility function  dean
boddy used anytime algorithms means allowing different allocations time
predicting deliberation  later  boddy dean        show anytime
algorithms time dependent planning framework used delivery agent
must traverse set waypoints grid  allocating time ordering
waypoints planning used travel them  dean  kaelbling  kirman 
nicholson        adapt technique scheduling deliberation execution
planning face uncertainty 
garvey lesser        present design to time methods advocate using available time find best possible solution  unlike anytime approaches interrupted time  design to time method requires time deadline given
upfront  way  algorithm spend time focusing finding single
good solution  instead possibly wasting time finding intermediate results  design to time
differs contract techniques das  dionne et al          designto time framework must predefined set solvers known  or predictable 
solution times costs  design to time method select appropriate solver
problem deadline  possibly interleaving different solvers deemed appropriate 
information cost solutions times  design to time methods require  usually unavailable must learned off line  techniques das bugsy 
hand  use information computed on line 
hansen  zilberstein  danilchenko        show heuristic search inadmissible
heuristics used make anytime heuristic search algorithms  techniques
presented paper  consider problem trading off search effort solution
quality  end  propose one possible optimization function anytime heuristic
search search attempts maximize rate algorithm decreases solution
cost  anytime monitoring technique shown section      evaluation function
relies learning profile anytime algorithm offline  analysis  puzzle  conclude that  method good anytime behavior  little
benefit using instead trial and error based hand tuning  surprising given
strong performance demonstrated offline tuned weighted a  experiments 
recently  thayer et al         proposed approach minimizing time solutions anytime algorithms  demonstrate new state of the art
algorithm performs well wide variety domains  robust
previous approaches  bugsy  technique relies using heuristics estimate
search effort required find solutions  however  focus solutions
require least amount effort  optimize trade off search time
solution cost 
addition controlling expansion decisions  metareasoning used
heuristic evaluation  often search algorithms use maximum value computed
multiple heuristics accurate estimate cost goal  problems 
   

fiheuristic search time matters

domain independent planning  heuristics quite expensive  increased accuracy
gained via maximizing many heuristics may worth increased computation
time  domshlak  karpas  markovitch        introduce on line learning technique
decide single heuristic compute state  instead computing many
taking max 
related work using metareasoning control combinatorial search done
area constraint satisfaction problems  csps   boolean satisfiability  sat   tolpin
shimony        use rational metareasoning decide compute value ordering
heuristics csp solver  focus work value ordering heuristics
gave solution count estimates  solver bothered compute heuristic decision
points deemed worthwhile  experiments demonstrate new
metareasoning variant outperformed variant always computed heuristic
one computed heuristic randomly  horvitz  ruan  gomes  kautz  selman 
chickering        apply bayesian structure learning csps sat problems 
consider problem quasi group completion  unlike tolpin shimony       
use on line metareasoning control search  use off line bayesian learning set
hand selected variables predict whether instances long short running 
lot work attempting estimate size search trees offline  burns   ruml        knuth        chen        kilby  slaney  thiebaux    walsh 
      korf  reid    edelkamp        zohavi  felner  burch    holte        
related topic  concerned estimating search effort entire search
performed  one may imagine leveraging technique predict search time
algorithm bugsy  unfortunately  estimation methods rather costly
terms computation time  suitable estimator needed every
single node generation  another possibility use off line estimations find parameters
affect performance search given domain  knowledge could helpful
creating representative training sets used algorithms weighted a  anytime
monitoring  require off line training 

   conclusions
investigated utility aware search algorithms take account user specified
preference trading off search time solution cost  presented three different techniques
addressing problem  first method based previous work area
learning stopping policies anytime algorithms  best knowledge 
first demonstrate techniques area heuristic search  second method
novel use algorithm selection bounded suboptimal search chooses correct
weight use weighted a  given utility function  last technique
presented bugsy algorithm  bugsy technique three
require off line training 
performed empirical study techniques context heuristic search 
investigated effect parameters algorithm performance  compared
different techniques other  surprisingly  simplest technique learning
weight weighted a  able achieve greatest utility many problems  outperforming conventional anytime monitoring approach  surprisingly  bugsy 
   

fiburns  ruml   

algorithm use off line training  performed well off line
techniques advantage learning thousands off line training instances 
representative set training instances available bugsy algorithm
choice  overall  utility aware methods outperformed a  speedy search
wide range utility functions  demonstrates heuristic search longer
restricted solely optimizing solution cost  freeing user choice either slow
search times expensive solutions 
unlike previous methods trading deliberation time solution quality  bugsy considers trade off directly search algorithmdeciding  node  whether
result expansion worth time  new approach provides alternative anytime algorithms  instead returning stream solutions relying external
process decide additional search effort longer justified  search process
makes judgments based node evaluations available it  empirical
results demonstrate bugsy provides simple effective way solve shortest path
problems computation time matters  would suggest search procedures
usefully thought black boxes controlled external termination policy
complete intelligent agents  informed users goals acting rationally
basis information collect directly maximize users utility 

acknowledgments
greatly appreciate feedback suggestions shlomo zilberstein scott kiesel 
would think richard korf pointing work shekhar dutta
        grateful support nsf  grant         grant          
darpa cssg program  grant d  ap        university new hampshire
dissertation year fellowship  preliminary version bugsy presented ruml
        see appendix a  elisabeth crawford assisted original version
summer internship parc 

appendix a  previous bugsy
previous version bugsy proposed ruml         however  early
realization differs substantially one presented here  used aggressive duplicate
re expansion  heuristic corrections  used estimate remaining expansions
goal reached  section     showed duplicate dropping outperforms duplicate re expansion many domains  found inadmissible heuristics performed
poorly  cf section      practice  even compared standard admissible estimates  also  temper inadmissible corrected estimates  previous bugsy
multiplied heuristic estimates arbitrary weight  min       wt  wf           version require ad hoc fix  discussed poor estimate number
remaining expansions section      section     showed  experimentally 
using expansion delay performs much better using alone 
recall bugsy uses f approximate cost path length best
utility outcome enabled expansion node  note  however  f
function used throughout paper refer cheapest solution beneath node n 
   

fiheuristic search time matters

may goal results maximum utility  better assess available
outcomes  previous version bugsy computed two utility estimates node  one
cheapest solution beneath node nearest solution terms
node expansions  non unit cost domains  two estimates may differ  example 
life cost grid pathfinding domains  cheapest solution usually involves moving toward
top grid actions cheap  nearest solution follow straight line
path goal  general  large number different solutions
search node  solutions may cover whole spectrum different cost time trade offs 
considering cheapest solution  done implementation 
may possible find solutions better utility  hand  may
costly compute multiple heuristics node  whether modification
beneficial depends domain 

appendix b  domains
performed experiments variety different domains  describe
detail here 
b      puzzle
   puzzle one popular benchmark domains heuristic search algorithms 
consists   by   frame    tiles placed  one slot board
contain tile  called blank  tiles above  below  left right
blank may slid blank slot  objective    puzzle slide tiles
around order transform initially scrambled puzzle goal state blank
upper left corner tiles ordered     going left right  top bottom 
domain interesting plans hard find  branching factor small
varies little mean       korf et al          duplicates 
heuristic reasonably informed 
experiments use popular        puzzle instances created korf        
plots include a   however  used    instances solvable a   gb
memory  average optimal solution length instances       training
set  generated       instances using   million step random walk back goal
position  used manhattan distance heuristic  sums vertical horizontal
distance tile must move arrive goal position  implementation follows
heavily optimized solver presented burns et al         
b   pancake puzzle
pancake puzzle  dweighter        gates   papadimitriou        another permutation
puzzle  consists stack differently sized pancakes numbered  n   pancakes
must presented fancy breakfast  chef needs sort originally unordered
stack pancakes continually sticking spatula stack reversing order
pancakes above  said another way  pancake problem involves sorting sequence
numbers using prefix reversal operations  simple problem interesting
creates search graph large branching factor  the number pancakes minus one  
   

fiburns  ruml   

figure     screenshot platform pathfinding domain  left   zoomed out image
single instance  right   knight must find path starting
location  maze  door  on right side left image 
center right image  

experiments  used    randomly generated    pancake puzzle instances 
training set consisted       randomly generated instances  used powerful gap
heuristic helmert         sums number pairs adjacent pancakes
sequence 
b   platform pathfinding
platform domain pathfinding domain creation dynamics based
  dimensional platform style video game  written partially first author  called
mid    left image figure    shows screenshot mid  goal knight
traverse maze initial location  jumping platform platform 
reaches door  mid open source game available http   code google com p 
mid game  experiments game physics game ported c c  
embedded c   search codebase  generated       training instances
    test instances using level generator mid  example instance shown
right panel figure     domain unit cost large state space
well informed heuristic 
available actions different combinations controller keys may pressed
single iteration games main loop  left  right  jump  left right move
knight respective directions  holding time never considered
search domain  movements would cancel out  leaving knight
   author steve mccoy  drew tile graphics shown figure    

   

fiheuristic search time matters

place   jump button makes knight jump  applicable  knight jump
different heights holding jump button across multiple actions row
maximum    actions unit cost  cost entire solution number
game loop iterations  called frames  required execute path  frame corresponds
  ms game play 
state state space contains x  position knight using doubleprecision floating point values  velocity direction  x velocity stored
determined solely left right actions   number remaining actions
pressing jump button add additional height jump  boolean stating
whether knight currently falling  knight moves speed      units per
frame horizontal direction  jumps speed   units per frame  simulate
gravity falling      units per frame added knights downward velocity
maximum    units per frame 
details platform domain  please refer source code repository
given start section   
b     level generator
instances used experiments created using level generator mid 
special maze generator builds   dimensional platform mazes      grid blocks 
block either open occluded  ensure solvability given constraints imposed
limited jump height  generator builds maze stitching together pieces
hand created portfolio  piece consists number blocks either free
occluded  start end location traversability ensured within piece 
piece added grid location fits  piece fits
occlude block belongs previously placed piece  maze built using depthfirst procedure  piece selected random fits grid start location
lined end location predecessor placed procedure recurs 
number successors node chosen uniformly range    inclusive 
procedure backtracks pieces fit previous block 
maze constructed  blocks belong piece marked occluded 
right image figure    shows sample level generated procedure  source
code level generator available mid source repository mentioned above 
b     heuristic
developed heuristic platform domain based visibility navigation
 nilsson         maze pre processed convert grid representation set
polygons representing connected component occluded cells level  space
scaled account movement speed knight  knight fall faster
move horizontal direction  polygons end squished vertically
stretched horizontally  visibility navigation problem solved reverse
four corners goal cell center every non occluded cell maze 
maintain admissibility  cost edge visibility problem length


visibility line  instead maximum length line divided  
x displacements end points line  accounts fact
   

fiburns  ruml   

figure     visibility navigation instance platform domains heuristic  visibility path initial state goal state drawn red 

knight bemoving horizontally vertically time 
moving distance   scaled space still takes single frame 
search  heuristic value state computed one two different ways 
straight line path center knight goal occluded
maximum x distances goal scaled travel speed used
heuristic estimate  otherwise  heuristic cost path visibility graph
center cell contains knights center point minus maximum
x distance  in number frames  knights center point center
cell  figure    shows map right image figure     scaled  broken
polygon components  visibility path initial state goal
state drawn red 
b   grid pathfinding
final domain grid pathfinding  popular domain video games
robotics  garnered much attention heuristic search community 
experiments  used      x      grids four way eight way connectivity
uniform obstacle distributions  four way connected grids  cell blocked
probability       eight way connected grids cells blocked
probability       consider two different cost models  standard
unit cost model
horizontal vertical moves cost   diagonal moves cost   
called life cost model  move cost equal row number
move took place  causing cells toward top grid preferred 
life cost model  short direct solutions found quickly  however relatively
expensive  least cost solution involves many annoying economizing steps  ruml  
do         model viewed instantiation popular belief time
money  one choose incur additional cost shorter simpler path 
combination movement model cost model  generated    test instances      
training instances  finally  used manhattan distance heuristic four connected
grids octile distance heuristic eight connected grids  life cost model
   

fiheuristic search time matters

heuristics took account fact moving toward top grid back
may cheaper direct path 

appendix c  anytime policy estimation
challenging write algorithms rely off line training data  algorithm
behaves unexpectedly  unclear bug implementation  bug
off line learning procedure  training set merely insufficiently representative 
appendix  describe implemented verified procedure estimating
anytime profile 
figure    shows pseudocode building profile based description given
hansen zilberstein         algorithm accepts set solution streams
input  one stream solved instance  proceeds two steps  first step
count solutions function counts number times solution cost
improved upon  function iterates solution  line     computes bin
histogram cost value falls  line     subsequent solution count
added qqtcounts time step first solution improved second
solution  addition  number total improvements solution time bin
counted qtcounts array  costbin timebin functions bin cost time values
respectively returning integer corresponding index histogram 


q qmin
costbin q   
 qmax qmin   ncost


tmin
timebin t   
 tmax tmin   ntime
 
second step probabilities function converts counts computed
first step normalized probability values  achieved dividing number
steps solution cost qi improved solution cost qj  qqtcounts 
total number steps solution cost qi improved  qtcounts 
lines      probability values smoothed adding half smallest probability
bin representing solution cost improvement  step removes zero probabilities 
allowing improvement considered  finally  probabilities normalized
probability non decreasing cost solutions current cost time step sum
one  lines        profile computed  saved disk later use
computing stopping policy 
found extremely useful simple way validate policies
debugging implementation  one option create stopping policy  run ara 
monitoring handful instances handful utility functions verify
gives expected behavior  unfortunately  approach rather cumbersome
prone error  evaluated policy small number instances
willing run hand  instead  chose validate implementation plotting
polices generated training data different utility functions  plotting
extreme policies care solution cost search time  along
intermediate policies trade off two  much simpler debug code 
   

fiburns  ruml   

profile streams 
   qtcounts  qqtcounts count solutions streams 
   return probabilities qtcounts  qqtcounts 
count solutions streams 
   qtcounts new int ncost  ntime     initialized zero 
   qqtcounts new int ncost  ncost  ntime     initialized zero 
   streams
  
   s 
  
qi costbin s i  cost 
  
qcur qi   tcur  
  
   count cost time increment solution i 
   
j      s 
   
qnext costbin s j  cost 
   
tnext timebin s j  time s i  time 
   
   current solution cost time solution j 
   
  tcur tnext  
   
increment qtcounts qi   t 
   
increment qqtcounts qcur   qi   t 
   
qcur qnext   tcur tnext
   
   last solution cost final time 
   
  tcur ntime
   
increment qtcounts qi   t 
   
increment qqtcounts qcur   qi   t 
    return qtcounts  qqtcounts
probabilities qtcounts  qqtcounts 
    probs new float ncost  ncost  ntime 
    qi   ncost
   
  ntime
   
qtcounts qi   t      continue
   
qj   ncost
   
probs qj   qi   t  qqtcounts qj   qi   t  qtcounts qi   t 
    smoothing  add half smallest probability elements probs improving solution cost 
       normalize 
    qi   ncost
   
  ntime
   
sum  
   
qj   ncost
   
sum sum   probs qj   qi   t 
   
qj   ncost
   
probs qj   qi   t  probs qj   qi   t  sum
    return probs

figure     pseudocode profile estimation 

figure    shows plots created platform domain  plot cost
axis time x axis  green circles represent inputs policy
says keep searching  red crosses represent inputs policy says stop
   

fiheuristic search time matters

 a 

 b 

    

   

   

   

    

cost

    

cost

cost

    

 c 

    

   

time

   

time

   

    

   

   

   

time

figure     three different policies   a  prefers cheaper solutions expense  wf  
   wt        b  attempts trade search time solution cost  wf  
     wt        c  prefers solution fast possible  wf      wt  
   

searching return solution  expected  policy always continues goal
minimize solution cost always stops goal minimize search time  cf 
left most right most plots figure    respectively   center plot shows
successfully found policies trade search time solution cost stopping
cost sufficiently low  finally  left most plot  bottom most rightmost sides policy always stop implementation chose stop
training data available estimate profile given input values 

references
bjornsson  y   bulitko  v     sturtevant  n          tba   time bounded a   proceedings
twenty first international joint conference artificial intelligence  ijcai     pp         
boddy  m     dean  t          solving time dependent planning problems   proceedings
eleventh international joint conference artificial intelligence  ijcai     
vol     pp         
burns  e   hatem  m   leighton  m  j     ruml  w          implementing fast heuristic
search code  proceedings fifth annual symposium combinatorial search
 socs     
burns  e     ruml  w          iterative deepening search on line tree size prediction 
annals mathematics artificial intelligence  s        
chen  p  c          heuristic sampling  method predicting performance tree
searching programs  siam journal computing                 
cox  m  t     raja  a          metareasoning  thinking thinking  mit press 
   

fiburns  ruml   

dean  t     boddy  m          analysis time dependent planning  proceedings
seventh national conference artificial intelligence  aaai      pp       
dean  t   kaelbling  l  p   kirman  j     nicholson  a          planning deadlines
stochastic domains  proceedings eleventh national conference artificial
intelligence  vol       p       washington  dc 
dechter  r     pearl  j          optimality a   kanal  l     kumar  v   eds   
search artificial intelligence  pp          springer verlag 
dionne  a  j   thayer  j  t     ruml  w          deadline aware search using on line measures behavior  proceedings fourth annual symposium combinatorial
search  socs     
domshlak  c   karpas  e     markovitch  s          max max  online learning
speeding optimal planning  aaai conference artificial intelligence
 aaai      pp           
dweighter  h          elementary problem e      american mathematical monthly          
     
finkelstein  l     markovitch  s          optimal schedules monitoring anytime algorithms  artificial intelligence                 
garvey  a  j     lesser  v  r          design to time real time scheduling  systems  man
cybernetics  ieee transactions on                   
gates  w  h     papadimitriou  c  h          bounds sorting prefix reversal  discrete
mathematics               
hansen  e  a     zhou  r          anytime heuristic search  journal artificial intelligence
research                 
hansen  e  a     zilberstein  s          monitoring control anytime algorithms 
dynamic programming approach  artificial intelligence              
hansen  e  a   zilberstein  s     danilchenko  v  a          anytime heuristic search  first
results  tech  rep   university massachusetts  amherst 
hart  p  e   nilsson  n  j     raphael  b          formal basis heuristic determination minimum cost paths  ieee transactions systems science cybernetics 
ssc               
helmert  m          landmark heuristics pancake problem  proceedings
third symposium combinatorial search  socs     
helmert  m     roger  g          good almost perfect  proceedings
twenty third aaai conference artificial intelligence  aaai     
hernandez  c   baier  j   uras  t     koenig  s          time bounded adaptive a  
proceedings eleventh international joint conference autonomous agents
multiagent systems  aamas     
horvitz  e   ruan  y   gomes  c   kautz  h   selman  b     chickering  m         
bayesian approach tackling hard computational problems  proceetings
seventeenth conference uncertainty artificial intelligence  uai     
   

fiheuristic search time matters

kilby  p   slaney  j   thiebaux  s     walsh  t          estimating search tree size 
proceedings twenty first national conference artificial intelligence  aaai    
knuth  d  e          estimating efficiency backtrack programs  mathematics
computation                   
koenig  s     sun  x          comparing real time incremental heuristic search
real time situated agents  autonomous agents multi agent systems             
    
korf  r  e          iterative deepening a   optimal admissible tree search  proceedings ninth international joint conference artificial intelligence  pp 
         
korf  r  e          real time heuristic search  artificial intelligence                   
korf  r  e   reid  m     edelkamp  s          time complexity iterative deepening a  
artificial intelligence                  
likhachev  m   gordon  g     thrun  s          ara   anytime a  provable bounds
sub optimality  advances neural information processing systems  nips     
   
michie  d     ross  r          experiments adaptive graph traverser  machine
intelligence    pp         
nilsson  n  j          mobile automaton  application artificial intelligence techniques  proceedings first international joint conference artificial intelligence  ijcai      pp         
nilsson  n  j          principles artificial intelligence  tioga publishing co 
pohl  i          heuristic search viewed path finding graph  artificial intelligence 
          
rice  j  r          algorithm selection problem  advances computers            
richter  s   thayer  j  t     ruml  w          joy forgetting  faster anytime search
via restarting  proceedings twentieth international conference automated
planning scheduling  icaps      pp         
ruml  w   do  m   zhou  r     fromherz  m  p          on line planning scheduling 
application controlling modular printers  journal artificial intelligence research 
               
ruml  w     do  m  b          best first utility guided search  proceedings   th
international joint conference artificial intelligence  ijcai      pp           
russell  s     ericwefald         right thing  studies limited rationality 
mit press 
shekhar  s     dutta  s          minimizing response times real time planning
search  proceedings eleventh international joint conference artificial
intelligence  ijcai      pp          citeseer 
   

fiburns  ruml   

sturtevant  n          benchmarks grid based pathfinding  transactions computational intelligence ai games                 
sturtevant  n  r          distance learning agent centered heuristic search  proceedings
fourth annual symposium combinatorial search  socs     
thayer  j          faster optimal suboptimal heuristic search  ph d  thesis  university
new hampshire 
thayer  j  t   benton  j     helmert  m          better parameter free anytime search
minimizing time solutions  proceedings fifth annual symposium
combinatorial search  socs     
thayer  j  t   dionne  a     ruml  w          learning inadmissible heuristics
search  proceedings twenty first international conference automated
planning scheduling  icaps     
thayer  j  t     ruml  w          faster weighted a   optimistic approach
bounded suboptimal search  proceedings eighteenth international conference
automated planning scheduling  icaps     
thayer  j  t     ruml  w          using distance estimates heuristic search  proceedings nineteenth international conference automated planning scheduling  icaps     
thayer  j  t     ruml  w          anytime heuristic search  frameworks algorithms 
proceedings third annual symposium combinatorial search  socs     
tolpin  d     shimony  s  e          rational deployment csp heuristics  proceedings twenty second international joint conference artificial intelligence
 ijcai     
valenzano  r  a   sturtevant  n   schaeffer  j   buro  k     kishimoto  a          simultaneously searching multiple settings  alternative parameter tuning
suboptimal single agent search algorithms  proceedings twentieth international conference automated planning scheduling  icaps     
van den berg  j   shah  r   huang  a     goldberg  k          ana   anytime nonparametric a   proceedings twenty fifth aaai conference artificial intelligence
 aaai     
zohavi  u   felner  a   burch  n     holte  r          predicting performance ida 
using conditional distributions  journal artificial intelligence research            
   

   


