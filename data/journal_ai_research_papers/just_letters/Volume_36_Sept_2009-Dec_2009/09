journal artificial intelligence research                  

submitted        published      

friends foes  planning satisfiability
abstract cnf encodings
carmel domshlak

dcarmel ie technion ac il

technion israel institute technology 
haifa  israel

jorg hoffmann

joerg hoffmann inria fr

inria 
nancy  france

ashish sabharwal

sabhar cs cornell edu

cornell university 
ithaca  ny  usa

abstract
planning satisfiability  implemented in  instance  satplan tool 
highly competitive method finding parallel step optimal plans  bottleneck
approach prove absence plans certain length  specifically  optimal plan
n steps  typically costly prove plan length n  
pursue idea leading proof within solution length preserving abstractions  overapproximations  original planning task  promising abstraction
may much smaller state space  related methods highly successful model
checking  particular  design novel abstraction technique based one can 
several widely used planning benchmarks  construct abstractions exponentially
smaller state spaces preserving length optimal plan 
surprisingly  idea turns appear quite hopeless context planning
satisfiability  evaluating idea empirically  run experiments almost benchmarks
international planning competitions ipc       find even hand made
abstractions tend improve performance satplan  exploring findings
theoretical point view  identify interesting phenomenon may cause
behavior  compare various planning graph based cnf encodings original
planning task cnf encodings abstracted planning task  prove that 
many cases  shortest resolution refutation never shorter  
suggests fundamental weakness approach  motivates investigation
interplay declarative transition systems  over approximating abstractions 
sat encodings 

   introduction
areas model checking ai planning well known closely related
develop tools automatic behavior analysis large scale  declaratively specified transition systems  particular  planning model checking safety
propertieschecking reachability non temporal formulasproblems given description transition system  initial system state  target condition 
solution problem corresponds legal path transitions bringing system
initial state state satisfying target condition 
c
    
ai access foundation  rights reserved 

fidomshlak  hoffmann    sabharwal

model checking problem  solution corresponds error path system 
is  unwanted system behavior  proving absence error paths ultimate
goal system verification  thus traditional focus field exactly that 
besides clever symbolic representations state space  key technique accomplish
ambitious task abstraction  system abstraction corresponds over approximation
considered transition system  thus abstraction preserves transitions
original system  hence  abstract transition system contain solution 
neither original system  key success model checking that  many cases 
one prove absence solutions rather coarse abstractions comparatively
small state space  techniques kind explored depth long time 
arguably wide spread instance model checking predicate abstraction  graf
  sadi         system states form equivalence classes defined terms truth
values number expressions  the predicates   linear expressions integer
system variables  predicates learned analyzing spurious error paths too coarse
abstractions  clarke  grumberg  jha  lu    veith         methods kind
extremely successful verification temporal safety properties  e g   ball  majumdar 
millstein    rajamani        chaki  clarke  groce  jha    veith        henzinger  jhala 
majumdar    mcmillan        
contrast system verification  focus ai planning finding solutions
instances assumed solvable  particular  optimizing planning  task
find solution optimizes certain criterion  the focus analysis
here  sequential parallel length solution path  unlike general planning
solution good enough  main bottleneck length optimizing planning always
prove absence solutions certain length  particular  optimal plan
n steps  hardest bit typically prove plan length n   
note plan actually proved optimal  length optimizing
planner avoid constructing proof  matter computational techniques
based on 
agenda research apply idea model checking lengthoptimizing planning  lead optimality proofnon existence plan length n 
within abstraction  particular  focus interplay abstraction
proving optimality parallel step optimal planning satisfiability  approach
originally proposed kautz selman         later developed satplan tool
 kautz   selman        kautz        kautz  selman    hoffmann         satplan
performs iteration satisfiability tests cnf formulas b encoding existence
parallel plan length b  b starts   increased incrementally 
n first satisfiable formula  n equals length optimal parallel plan 
hence satplan parallel optimal  step optimal  planner  class planners 
satplan highly competitive  particular  satplan  st prizes optimal
planners international planning competition  ipc   namely ipc       kautz 
      hoffmann   edelkamp        ipc       kautz et al          one property
cnf encodings employed satplan plays key role analysis later
based planning graph structure  blum   furst              
course  objective closely relates many approaches developed planning
computing lower bounds based over approximations   e g   haslum   geffner       
   

fifriends foes  planning satisfiability abstract cnf encodings

edelkamp        haslum  botea  helmert  bonet    koenig        helmert  haslum   
hoffmann        katz   domshlak        bonet   geffner         key difference 
however  focus exact lower bounds  is  attempt actually prove optimality
within abstraction  want able prove optimality within abstraction 
abstraction must term solution length preserving  abstraction must
introduce solutions shorter optimal solution original problem 
lower bound step optimal planning exact  support
satplans iteration n    constitutes main bottleneck 
follows  briefly explain initial motivation behind work 
summarize empirical theoretical results 
    initial motivation
would course interesting explore whether predicate abstraction applied
planning  indeed  initial idea  however  discussions
idea lead nowhere   instead made different discovery  planning state spaces
often dramatically reduced  without introducing shorter solutions  based
abstraction technique call variable domain abstraction  technique essentially
adapts work hernadvolgyi holte        propositional strips formalism 
abstract strips task distinguishing certain values multiplevalued variables underlying strips encoding  is  p q propositions
corresponding non distinguished values  abstracted strips task acts p q
same  note generalizes abstraction used edelkamp        which 
multi valued variable  either abstracts away completely abstract
all  see details section   
first example noticed compression power variable domain abstraction classical logistics domain  domain  packages must transported within
cities using trucks cities using airplanes  actions load unload packages 
move vehicles  importantly  constraints  either of  vehicle capacities  fuel 
travel links  consequence  package p starts city destination
city b  cities c    a b completely irrelevant p  is  one choose
arbitrary location x city c  replace facts form at p l   l
location outside b  at p x   also  in p t   truck outside b 
replaced at p x   one completely abstract away positions packages
destination  minor optimizations possible  way
lose many distinctions different positions objectswithout introducing shorter
solution  optimal plan rely storing package p city ps origin
destination  state space reduction dramatic  abstracted state space contains
least    c    s    p states less  c  s  p respectively number
cities  city size  number locations city   number packages  similar
   still skeptical prospects  software artifacts  rigid control structure  numeric expressions
essential flow control  rather different nature planning problems  loose control
structure  numeric expressions non existent mostly used encode resource consumption   example  major advantage predicate abstraction capture loop invariantsa great feature 
seemingly rather irrelevant plan generation 

   

fidomshlak  hoffmann    sabharwal

abstractions made  similar state space reductions obtained  ipc
domains zenotravel  blocksworld  depots  satellite  rovers  see section    
    summary empirical results
first experiment  implemented logistics specific abstraction abstracting set planning tasks level description  modifying actions
initial state  planning tasks feature   airplanes    locations city 
  packages  number cities scales       account variance
hardness individual instances  took average values   random instances
problem size  increasing number cities introduces increasing amount
irrelevance  measure percentage relfrac facts considered relevant  not
abstracted   note additional cities irrelevant individual packagesthey cant removed completely task standard irrelevance
detection mechanisms  e g  rifo  nebel  dimopoulos    koehler         would try do 
provided abstracted tasks three optimizing planners  namely mips bdd
 edelkamp   helmert         ipp  hoffmann   nebel         satplan     order examine abstraction affects different approaches optimizing planning 
mips bdd searches blindly exploiting sophisticated symbolic representation
state space  ipp equivalent parallel state space heuristic search widely
used h  heuristicthe parallel version h  originally introduced graphplan  blum  
furst        haslum   geffner         thus  mips bdd  ipp  satplan   represent
orthogonal approaches optimizing planning   abstract task planner 
measured runtime  compared latter time taken planner
original task  time out set      seconds  used value
average computation time out occurred  stopped evaluating planner  
time outs within   instances one size 
figure   a    b    c  respectively show results mips bdd  ipp  satplan    comparing performance original abstracted tasks  apparent
figure   proving optimality within abstraction dramatically improved
performance mips bdd  significantly improved performance ipp  right
end scale  with    cities   mips bdd using abstraction find optimal sequential
plans almost fast satplan   find step optimal plans  given usually
much harder find optimal sequential plans optimal parallel plans  especially highly
parallel domains logistics  performance improvement quite remarkable   in
addition reduced state space size  mips bdd benefits small state encoding 
stops growing point maximal number locations relevant
package constant  
findings mips bdd ipp line original intuition and 
satplan   well  expected see much improved runtime behavior within
abstraction  surprise  not  appears figure   c   improvement
obtained satplan   proving optimality within abstraction hardly dis   satplan   version satplan competed      international planning competition 
   importantly  mips bdd sequentially optimal satplan   ipp step optimal  hence
one compare performance planners directly  particular
purpose here  focus planners reacts abstraction 

   

fifriends foes  planning satisfiability abstract cnf encodings

     

   

mips bdd abstract
mips bdd real
relfrac

     

    

  

   

ipp abstract
ipp real
relfrac

  

  

    

  

  
   

  

  

   

  

  
  

  

  

  

  

  
 

  

  

 

  

  
   

  

 
 

 

 

 

 

 

 

 

 

  

  

  

  

   

  

 
 

 

 

 

 

 

 a 

 

 

 

  

  

  

  

  

 b 
     

   

satplan abstract
satplan real
relfrac

  

    

  
  

   

  
  

  

  
  

 

  
  

   

 
 

 

 

 

 

 

 

 

 

  

  

  

  

  

 c 

figure    runtime performance  a  mips   b  ipp   c  satplan     abstract  without  real  hand made variable domain abstraction 
logistics instances explicitly scaled increase amount irrelevance  horizontal axis scales number cities  left vertical axis shows total runtime
seconds  right vertical axis shows percentage relfrac relevant facts 

cernible  right end scale  abstraction yields humble speed up factor     
particularly insignificant since speed up obtained drastically small
relfrac value    in ipc      logistics benchmarks  relfrac     average 
latter corresponds   cities figure    satplan   slight advantage
original tasks 
investigate broadly  conducted experiments almost strips
domains used international planning competitions  ipc  ipc       many
cases  tailored abstraction domain hand  results exhaustive
evaluation  discussed detail section    significantly depart
logistics specific abstraction above  mips bdd almost consistently obtained
significant improvement  ipp improvements happened rarely  typically
substantial   while ipp improved figure    note that  ipc   

fidomshlak  hoffmann    sabharwal

average relfrac      improvement yet strong   finally  satplan   
hardly ever obtained improvement 
causes difference profiting abstraction three different
planning techniques  intuitive interpretation results informedness
abstraction must compete informedness search itself  words 
better planner exploiting structure particular example  difficult
abstraction exploit structure already exploited  intuition
good correspondence logistics results figure    optimizing exactly
measure  original examples  satplan   faster ipp  inverse
relation holds regarding planner profits abstraction  said 
intuitive interpretations results are  point  mere speculation  left open
future research determine accurately precisely causes difference  herein 
concentrate planning satisfiability  identify fundamental weakness
approach respect profiting abstraction 
    summary theoretical results
intrigued results satplan     wondered kind effect abstraction
actually cnf encoding planning task formulated boolean satisfiability
problem instance  recall abstractions over approximations  is 
action sequence applicable original task applicable abstract task 
plan original task plan abstract task  so  intuitively  abstract task
generous original task  mind  consider cnf formula
n  encoding existence plan one step shorter optimal plan  consider
formula  n    generated abstract task  need prove n 
unsatisfiable   note n  is  fact  unsatisfiable solution length preserving
abstraction   intuitively  constrained formula is  easier lead
proof  n  generous  hence less constrained  n    mean
actually harder refute n  refute n   
abstraction methods  fact trivial see answer question
yes  say abstract n  ignoring clauses  n  sub formula
n    immediately implying resolution refutation n  resolution
refutation n    particular  shortest possible refutation cannot shorter
n    similar situation sometimes occurs interplay abstractions cnf
encodings planning problems  instance  suppose abstract ignoring subset
goals  cnf encodings planning  particular planning graph
based cnf encodings  kautz   selman        underlying satplan  goal fact yields
one clause cnf  hence  goal ignoring abstraction  n  sub formula
n    above 
complex example would correspond abstraction ignoring preconditions
delete effects  encodings used satplan  one several clauses related
ignored precondition delete effect disappear  however  cnf changes ways
because  one precondition delete effect less  actions facts become possible
later time steps  intuitively  additional actions facts help proving
   translation  deeply frustrated results satplan         

   

fifriends foes  planning satisfiability abstract cnf encodings

unsatisfiability n    formal proof intuitive statement  however  less obvious
one goal ignoring abstraction above  matters complicated 
much less intuitive  edelkamps        abstraction variable domain abstraction 
changes made abstract task affect add effects actions  recall
variable domain abstraction special interest likely satisfy
constraint solution length preservation 
investigate issues detail  one consider various possible combinations
cnf encodings abstraction methods  many different encodings planning sat
proposed  focus planning graph based encodings used
satplan system  appearances international planning competitions  kautz   selman        long  kautz  selman  bonet  geffner  koehler  brenner 
hoffmann  rittinger  anderson  weld  smith    fox        kautz        kautz et al         
indeed  according kautz selman  kautz   selman        long et al         
cnf encodingsin particular mutex relations computed graphplanare vital
satplans performance  recent results effective encodings may challenge
assessment  rintanen  heljanko    niemela        chen  huang  xing    zhang       
robinson  gretton  pham    sattar         even graphplan based encodings
interest simply widely used almost decade  remains
course important question whether extent results carry alternative cnf encodings  discuss issue depth concluding paper
section   
consider four different encodings  three used edition
ipc  fourth encoding considered sake completeness  encodings
differ two parameters  whether use action variables  action well fact
variables  whether include planning graph mutexes actions
direct interferences   the latter motivated fact often enormous
amount action mutexes  seriously blowing size formula  
abstractions side  focus abstraction methods formulated
manipulating planning tasks language level  i e   modifying tasks actions and or
initial goal states  many commonly used abstractions propositional strips
formulated way  consider six abstractions  namely     removing goals     
adding initial facts      removing preconditions      removing delete effects      edelkamps
       abstraction  removing entire facts       variable domain abstraction 
   combinations cnf encoding abstraction method  prove
shortest possible resolution refutation exponentially longer n  n   
   combinations involving abstractions variable domain abstraction 
prove shortest possible resolution refutation cannot shorter n 
n    abstraction      trivial outlined above  abstractions        
proof exploits fact abstractions lead larger planning graphs containing
actions facts  abstraction      reasoning work
facts disappear planning graph  however  one start removing fact
goal action preconditions  afterwards fact irrelevant one remove
initial state action effects 
matters complicated abstraction      is  variable domain abstraction 
encoding action variables full mutexes  show that  before 
   

fidomshlak  hoffmann    sabharwal

shortest possible resolution refutation cannot shorter n  n   
encoding action variables direct action mutexes  show
possible improvement bounded effort takes recover indirect
action mutexes  two encodings action fact variables  remains
open question whether bounds exist  
importantly  proofs valid general resolution  many
known restricted variants resolution  particular tree like resolution refutations generated dpll  davis   putnam        davis  logemann    loveland        
naturally  proofs separate combinations  rather exploit
exhibit common features 
practical significance theoretical results is  extent  debatable
direct connection best case resolution refutation size empirical
sat solver performance  even large refutation may easy find mostly
consists unit resolutions  vice versa  small refutation exists 
mean sat solver find it  notwithstanding  appears unlikely best case
resolution refutation size practical sat solver performance completely unrelated
 beyond obvious lower bound   one example indicates opposite planning
graph mutexes  mutexes reduce best case refutation size work
resolution even invoked   words  sat solvers exploit mutexes
prune search trees effectively  aware explicit empirical proof
tends happen often  seems little doubt does 
suggested explicitly kautz selman  kautz   selman        long et al        
ways explaining improved performacce system run graphplan based
encodings 
interesting situation arises  all  experiments  use variable domain abstraction encoding action variables direct action mutexes  as
employed satplans ipc   version   setting  resolution refutations get
shorter principle  although effort takes recover indirect action mutexes  further  employ trivial post abstraction simplification methods  such
removing action duplicates  which  show  potential shorten resolution refutations  still  reported above  discernible empirical improvement 
reason might sat solver find shorter refutations 
shorter refutations actually appear significant scale  evidence
indicating latter  mutex recovery becomes necessary rather special situations 
abstraction turns indirect mutex direct one  typically concern small fraction indirect mutexes  addition  mutex recovery
simplifications  well designed variable domain abstraction affected actions
typically irrelevant anyway  example  hand made logistics abstraction 
   reason complications answering question requires determining  planning graph
based encodings general  whether fact variables syntactic sugar may lead succinct
refutations  proof appears quite challenging  say section   
   general resolution recover mutexes effectively  c f  related investigations brafman       
rintanen         seem likely case tree like resolution 
best knowledge yet known 

   

fifriends foes  planning satisfiability abstract cnf encodings

effect potential improvements limited actions appearing redundant
plans  get back detail section   
view  theoretical results would potential importance even
evidence empirical relevance  simply quite surprising  moment
thought  clear resolution refutation become easier ignoring goals 
however  variable domain abstraction domains logistics deflates state spaces
immensely  point tiny fraction original size 
performing work  would never expected best case refutation size remain
same 
paper organized follows  section   discusses preliminaries  covering employed notions planning  planning graphs  propositional encodings  resolution  abstraction methods  particular  formally defines variable domain abstraction  section  
summarizes empirical results  section   presents results regarding resolution refutations abstract cnf encodings  related work discussed text appropriate  conclude section    appendix contains proofs  replaced
brief proof sketches main body text  additional empirical data
found online appendix  see jair web page article  

   preliminaries
begin discussion various concepts needed rest paper  propositional
strips planning  planning graphs  propositional cnf encodings planning problems 
resolution proofs unsatisfiability  abstraction methods used planning  general
rule notation  use variants of  p planning tasks  f  a  g sets facts 
actions  goals  respectively  abstractions  p g planning graphs 
propositional formulas encodings 
    strips planning graphs
classical planning devoted goal reachability analysis state transition models deterministic actions complete information  model tuple   hs  s    sg   a 
finite set states  s  initial state  sg set alternative
goal states  finite set actions    transition function 
 s  a  specifying state obtained applying s  solution  plan 
state transition model sequence actions a            generate sequence
states s            sm that      m   si   ai       si     sm sg  
ai planning targets large scale state transition models huge numbers
states  models assumed described concise manner via intuitive
declarative language  use propositional fragment strips language  fikes
  nilsson         brevity  refer fragment strips herein  informally 
planning task planning instance strips consists set propositional facts 
hold initially must hold simultaneously end plan
execution  state system time defined set propositional facts
hold time  task specifies set actions  defined
set precondition facts  set facts added state  set facts
removed state  action taken  formally  strips planning task
   

fidomshlak  hoffmann    sabharwal

given quadruple p    p  a  i  g  fact set p   initial state description p   goal
description g p   action set every action pre a   add  a  
del  a   subset p   planning task defines state transition
model   hs  s    sg   a  state space    p   initial state s    i 
s  sg iff g s  s  a s     a   pre a  s 
actions applicable s  a s    s  a     s   del  a   add  a  
assume actions reasonable sense add  a  del  a     
satisfied known planning benchmarks  particular satisfied benchmarks
used experiments  
many planning algorithms  including satplan  employ form approximate
reachability analysis  one primary tools purpose planning graph  first
introduced scope graphplan planner  blum   furst         length bound
b  planning graph p g p  associated p layered graph two kinds nodes 
fact nodes action nodes  layers alternate fact layers f      f              f  b  
action layers a     a             a b     pair layers f  t   a t  forming
time step t  first vertex layer f     contains initial state  a t  f  t     
    b action sets fact sets  respectively  available time step     
precisely  a t  includes actions pre a  f  t  pair
facts p  p  pre a  mutex layer  c f  below   further  a t  contains standard noop
action every fact f  t    f  t      contains union add effects
actions a t   obviously  a t  a t      f  t  f  t       goal facts g
label appropriate vertices f  b   p g p  four kinds edges 
    epre  t  f  t  a t  connect actions a t  preconditions f  t  
    eadd  t  a t  f  t      connect actions a t  add effects f  t      
    ea mutex  t  a t  a t  capture pair wise mutual exclusion relation actions a t    a t   a   t   ea mutex  t   actions a  cannot applied
simultaneously time t 
    ef  mutex  t  f  t  f  t  capture pair wise mutual exclusion relation facts
f  t    f  t   f    t   ef  mutex  t   facts f f   cannot hold together time
t 
note p g p  explicit edges deletion effects actions 
effects captured mutual exclusion relation  e g   p add  a    del  a    
 a    a    ea mutex times   mutex edges emutex   ea mutex ef  mutex
computed iterative calculation interfering action fact pairs  blum   furst 
       namely  two actions  directly  interfere effects one contradict effects
other  one deletes precondition other  two actions competing
   ipc      domain rovers  operators add delete artificial fact order prevent
parallel application  implement restriction via duplicating respective operators
sequentializing original duplicate via two artificial facts  similar fixes implemented
couple domains well 
   fact p p   associated noop p  delete effects   p  preconditions
add effects  dummy actions simply propagate facts one fact layer next 

   

fifriends foes  planning satisfiability abstract cnf encodings

needs mutex preconditions  combining two scenarios together  say
two actions mutex either  directly  interfere competing needs 
similar spirit  two facts mutex non mutex pair actions  in graph
layer directly below  together achieving facts  variant interest
planning graph which  iterative computation  ea mutex reduced contain
directly interfering actions  call reduced planning graph  denote
p gred  p   motivation considering that  often  reduced planning
graph results much smaller sat encodings  get back below 
    propositional encodings
consider three cnf encodings used  one version of  satplan  well
fourth encoding fits naturally picture  encodings takes input
planning task p length bound b  creates formula standard conjunctive
normal form  cnf   cnf formula solved off the shelf sat solver 
process constitutes basic step sat based approach planning implemented
satplan  kautz   selman                     one starts b     iteratively
increments b cnf becomes satisfiable first time  plan corresponding
satisfying assignment plan minimal b  hence optimal
sense  
cnf formula logically conjunction  and  clauses  clause disjunction  or  literals  literal propositional  boolean  variable negation 
cnf formulas often written set clauses  clause written set literals  underlying logical conjunction disjunction  respectively  implicit 
propositional encodings bounded length planning tasks specified terms various
kinds clauses generated encoding method 
encoding  a  constructed p g p  uses propositional action variables
 a t        b  a t    goal fact g goal clause form
 a   b             al  b      a          al actions a b    add g 
similarly  every a t      every p pre a  precondition clause
 a t   a   t             al  t      a          al actions a t    add p 
finally  mutex clause  a t   a   t   every  a  a    ea mutex  t  
 note dependence initial state taken account already
terms actions contained sets a t   need stated
explicitly cnf  
encoding  b  similar  a  except uses variables  and appropriate clauses 
facts  specifically  addition action variables  fact
variables  f  t      b  f f  t    goal fact g  goal clause simply
unit clause asserting g b       fact f  t   effect clause
form  f  t   a   t             al  t      a          al actions a t   
add f   every a t  every p pre a  precondition clause 
   versions satplan use naive incremental update b  shown
clever strategies  exploiting typical distribution runtime different values b  rintanen 
      streeter   smith        

   

fidomshlak  hoffmann    sabharwal

takes form  a t   p t    action mutex clauses  a t   a   t   every
 a  a    ea mutex  t   fact mutex clauses  f  t   f    t   every
 f  f     ef  mutex  t   finally  fact f f      initial state clause
 f       these strictly necessary implemented satplan
include here  
encoding  c   a  except based reduced planning graph p gred  p  
mutex clauses present action pairs whose preconditions effects
interfere directly 
encoding  d   b  except that   c   based p gred  p   mutex
clauses action pairs whose preconditions effects interfere directly  note 
however  fact mutexes full planning graph  p g p  
encodings reasonable ways turning planning graph cnf formula  encodings essentially underly competition implementations satplan 
detail below  first  note different encodings different benefits
drawbacks  first  observe encodings characterized two decisions     
include action mutexes graphplan  direct interferences     
include action variables  action fact variables  regarding     
empirical observation mutexes help one major observations
design satplan  then called blackbox   kautz   selman        long et al         
particular comparison earlier encoding methods  kautz  mcallester    selman        
hand  since mutexes talk pairs facts actions  encodings may
become quite largethere one clause every pair mutex actions mutex facts 
particularly critical actions  many planning benchmarks
thousands  compared hundred facts   indeed  turns action mutexes often consume critically large amounts memory  uncommon cnf
formulas millions clauses  action mutexes  kautz   selman       
kautz        kautz et al          motivates encodings  c   d   question
     make much difference  empirically  planning benchmarks 
consider distinction used versions satplan 
let us say words clarify exactly encodings  a  d  relate satplan
literature implementations  due long history satplan  well
imprecisions literature  little complicated  foremost reference
actual program code underlying satplan   satplan    i e   recent
versions used           competitions  encoding methods versions
implemented one authors paper  four different encoding
methods  action based  graphplan based  skinny action based  skinny graphplan based 
action based encoding exactly  a   graphplan based encoding exactly  b  
skinny graphplan based encoding exactly  d     skinny action based encoding
 c  except that  save runtime  planning graph implementation
propagate mutexes  after all  direct interferences present final encoding  
effectively computing relaxed planning graph  hoffmann   nebel         use normal
         version  skinny graphplan based encoding feature fact mutexes 
consequence encoding used      competition 

   

fifriends foes  planning satisfiability abstract cnf encodings

planning graph  c  sake readabilitythe greater similarity
encodings significantly simplifies write up  theoretical results hold stated
relaxed planning graphs 
satplan encodings develop historically  reflected literature  encodings used competitions  answer questions
extent necessary explaining encodings  a  d   original paper satplan
 kautz   selman        introduced rather different encodings  graphplan based encodings
direct action mutexes introduced next  observed yield performance
comparable graphplan  kautz   selman         subsequently  observed
modern sat solvers profit full  fact action  mutex relations actually
beat planners  several domains  kautz   selman           consequently 
graphlan based encoding  i e   encoding  b   used           competitions  long et al          prior      competition  encoding methods
re implemented  yielding four methods explained above  ipc   booklet paper
satplan    kautz        describes four encodings    version run competition skinny action based encoding  for theoretical results  equivalent
encoding  c   running planner ipc       turned full
fact mutexes helped domains  encoding  d  used instead  kautz et al  
       consider encoding  a  sake completeness 
    resolution refutations
theoretical results respect resolution proof system  robinson        
forms basis complete sat solvers around today  cf  beame  kautz 
  sabharwal         sound complete proof system  studied extensively theoretical practical reasons  works cnf formulas one
simple rule inference  given clauses  a  x   b  x   one derive clause  a  b 
resolving upon variable x  b shorthands arbitrary lists literals 
note choice clauses resolve arbitrary  long share variable 
opposite signs  resolution derivation clause c formula consists series
applications resolution rule starting clauses one eventually
derives c  c  unsatisfiable  empty clause      called resolution proof
 of unsatisfiability  refutation   size number applications
resolution rule   unsatisfiable  rc   denotes resolution complexity  
i e   size smallest resolution proof unsatisfiability   interested
whether applying abstraction planning task convert encoding one
smaller resolution complexity 
commonly studied sub class  still sound complete  resolution derivations
tree like resolution derivations  derived clause used
whole derivation  underlying graph structure proof tree 
    kautz selman        cite graphplan based encodings earlier work  which used action
mutexes   however  blackbox program code includes functions generate full mutexes  kautz
selman explicitly emphasize importance mutexes 
    paper abstract little imprecise description  initial state  goal  fact
mutex clauses mentioned  skinny action based encoding stated identical
encoding  c   i e   based full planning graph rather relaxed planning graph 

   

fidomshlak  hoffmann    sabharwal

interesting sub classes resolution include regular resolution  provably exponentially powerful tree like resolution variable resolved upon
path root leaf underlying proof graph  ordered
resolution  addition variables respect fixed ordering root to leaf path 
tree like resolution captures proofs unsatisfiability generated sat solvers
based dpll procedure  davis   putnam        davis et al         dont employ so called clause learning techniques  latter kind sat solvers provably
exponentially powerful even regular resolution although still within realm
general resolution  beame et al         
note arguments presented paper general  unrestricted  resolution  however  since aour constructions affect rely structural
properties resolution refutations consideration  results hold stated  except slight weakening case lemma       known variants resolution
setting variables true false replacing one variable another preserves
proof structure  variants include tree like  dpll   regular  ordered resolution 
state standard property resolution proofs use arguments 
pointing certain modifications  such variable restrictions shortening
clauses  given formula cause proofs become longer general resolution
natural sub classes  including mentioned above  let x variable
true  false  another  possibly negated  variable   variable restriction
x transformation replaces x throughout   simplifies
resulting formula removing clauses containing true variable negation 
removing false duplicate literals clauses  words  variable restriction
involves fixing value variable identifying another literal  simplifying
formula  sequence variable restrictions     denote
outcome applying  
following proposition combines two basic facts together form useful
us      variable restrictions cannot increase resolution complexity formula 
    lengthening clauses and or removing clauses cannot decrease resolution complexity
formula 
proposition      let cnf formulas  exists sequence variable
restrictions every clause   contains sub clause clause  
rc   rc    
explanation proposition use order  notation
used chosen match way eventually utilize proposition
proofs  below  conditions proposition imply one may obtain
applying restriction   possibly throwing away literals
clauses  possibly adding new clauses  intuitively  three modifications
reduce number solutions cannot make harder prove
formula unsatisfiable  property resolution refutations propositional formulas
previously used  at least indirectly  various contexts  completeness  include
proof appendix a  based folklore ideas proof complexity literature 
alternative proof  somewhat different notation  may found appendix
recent article hoffmann  gomes  selman        
   

fifriends foes  planning satisfiability abstract cnf encodings

way use proposition following  cnf encoding
abstracted planning task  encoding original planning task 
carefully chosen restriction bring focus variables already
appearing   proposition     imply original encoding harder
refute  using resolution natural sub classes  abstracted encoding 
    abstraction planning
abstraction methods various kinds put use planning  often quite successfully  one line work uses abstraction methods problem decomposition  cf  sacerdoti 
      knoblock        koehler   hoffmann         best knowledge 
approachexamining abstract state space order prove absence solutions
pursued before  line work relevant work domainindependent heuristic functions  cf  mcdermott        bonet   geffner        hoffmann  
nebel        edelkamp        haslum et al         helmert et al         katz   domshlak 
       there  abstraction means over approximation state space  work 
differs abstractions used  course  kinds over approximations
useful either purpose differ lot  use abstraction
paper  one define over approximations preserve  large extent  real
structure problem  particular  ideal goal find abstractions preserve length optimal solutionsomething one definitely wouldnt expect
abstraction underlying heuristic function  since solved every search state 
briefly review over approximation methods used
planning far  formally introduce novel one  variable domain abstraction 
use logistics domain illustrative example   
one wide spread over approximation method planning   subset relaxation
underlying computation made planning graph  blum   furst         generalized m subset relaxation haslum geffner         nutshell  one assumes
achieving set facts hard achieving hardest m subset  known
that  domains  including logistics    subset solution length  corresponding
length planning graph constructed first fact layer containing mutexes
goal facts  typically strictly lower length optimal plan 
     hand  computing m subset solution length typically costly 
still    o  p    one typically guarantee solution length preservation  helmert
  mattmuller        
second wide spread over approximation method ignoring delete lists  mcdermott 
      bonet   geffner         approximation  one simply removes  some of 
negative effects actions  negative effects removed  problem
becomes solvable time linear instance size  latter basis heuristic
functions used many modern planners  cf  bonet   geffner        hoffmann   nebel 
      gerevini  saetti    serina         ignoring deletes likely introduce shorter
solutions  example  towers hanoi problem  leads plans length n instead
 n    hoffmann         logistics  one ignores deletes moving actions
    stated  open topic explore model checking abstractions  particular predicate abstraction
 graf   sadi        clarke et al          instead planning abstractions 

   

fidomshlak  hoffmann    sabharwal

plans may get shorter vehicles never move back abstraction 
interestingly  ignoring deletes load unload decrease plan length  since
actions never undone optimal plan  use observation
experiments 
third abstraction introduced edelkamp        pattern database
heuristic  approximation  one completely removes facts problem
description  notably facts corresponding values multi valued variables 
enough facts removed  task becomes sufficiently simple  obviously  approximation hardly solution length preserving  logistics  remove  example 
fact at package  airport   then  particular  package  loaded onto airplane
airport  without actually precondition removed  optimal
plan make package pop anywhere 
fourth abstraction  finally  involves removing preconditions  sacerdoti       
and or goal facts  edelkamps abstraction  cannot expected solution
length preserving interesting cases 
calls new abstraction method  designed following hernadvolgyi
holte         considering strips like state transition systems multiple valued
 instead boolean  variables  propose reduce variable domains distinguishing certain values  example  content cell   puzzle
 blank                        may replaced  blank                          
mapped onto    observation that  many planning benchmarks  done
without introducing shorter plans  example  logistics unnecessary distinguish
positions packages irrelevant cities  therefore  replace domain at p  
 a    a    b    b    c    c             b initial goal cities p ai   bi        
locations cities a  b         abstract domain  a    a    b    b    c     strips 
amounts replacing set irrelevant facts at p  l  single fact at p  c    
formalize idea 
let persistently mutex denote standard notion two facts mutex
fixpoint layer planning graph  typically  different values multiple valued variable 
definition      let p    p  a  i  g  strips planning task  p  p  p pair
persistently mutex facts that  a    p  p    del  a   pre a  
  p      a  a a    i    g   called variable domain abstraction p 
defined follows 
   fact set f    f     f p    f   otherwise   f      f    p      p  
   action    pre  add   del     a      pre    add     del    p    add   del   
otherwise   a      pre    add     del      p   
words  definition     simply says replace p  p  p appears
add list delete list action  remove delete list   
situation arise  instance  action moves package one irrelevant position
    reader may wonder p remains add list  although prerequisite p  pre   reason
distinguish abstractions simplifications  change planning task 
abstractions  simplifications  way may alter tasks semantics  however 
simplifications may well affect resolution complexity  get back later paper 

   

fifriends foes  planning satisfiability abstract cnf encodings

another irrelevant position  operation  p equivalent originally
p p    p true abstracted action sequence p p  true
corresponding real action sequence  particular  proposition     states variable
domain abstraction over approximation usual sense 
proposition      let p    p  a  i  g  strips planning task  let  p   
  p      a    a    i    g   variable domain abstraction p  then  whenever
ha            plan p  h a              an  i plan  p  
proof  let state models induced p  p   first  let us show
that  state m  action m  applicable s   i 
 a  applicable  s    ii  p   s    a    p  p     s  a      
note that  since abstraction effect facts  p  p      ii  implies
  s    a       s  a    thus  together   i   ii  imply  iii  homomorphic
  finally  straightforward definition      iv  initial state
 i   goal states exactly   s    sg    together   iii   iv 
imply claim proposition     
let    pre  add   del    applicability  a   s  straightforward  p    pre 
 pre    pre  s  pre    spre  otherwise  pre     pre  p     p 
 s     s    p      p   cases  pre implies  pre   s   consider
sub claim  ii  case by case basis 
 p    p  add      p    p  del   p   add   a   p   del   a    thus
p   s    a   iff p  s  iff  p  p       iff  see assumption del case 
 p  p     s  a      
 p    p  add       p    p  del   p add   a   p   del   a    thus
p   s    a    hand   p  p     s  a     trivially holds here 
 p    p  add      p    p  del    p   add   a   p del   a    thus
p     s    a    hand  since p  p  persistently mutex facts p 
 p    p  del    p    p  pre   p  p     s  a     
 p    p  add       p    p  del    p add   a   p   del   a    thus
p   s    a    hand  add del    p    p  add   
immediately  p  p     s  a      
completes proof  ii  
arbitrarily coarse variable domain abstractions may generated iterating application definition      note variable domain abstraction refinement edelkamps
       abstractioninstead acting irrelevant positions could totally ignored 
distinguish whether package currently position  makes
difference preserving optimal solution length not   
hinted above  variable domain abstraction may able apply
simplifications  simplification  terminology  similar abstraction
    topic future work explore whether refined abstraction lead better pattern database
heuristics strips problems 

   

fidomshlak  hoffmann    sabharwal

manipulates planning task language level  however  abstractions may alter
tasks semantics  simplifications not  i e   simplifications introduce new
transitions goal states  concretely  consider two simplifications  planning task
p    p  a  i  g  duplicate actions exist a  a  pre a    pre a    
add  a    add  a     del  a    del  a       simplified planning task p except
a  removed  planning task p    p  a  i  g  irrelevant add effects
exists pre a  add  a       simplified planning task p except
remove pre a  add  a  
obviously  duplicate actions irrelevant add effects may arise outcome variable domain abstraction  example latter action moving package
irrelevant location irrelevant truck  example former two actions loading
package onto airplane distinct irrelevant locations    implementation 
simple post abstraction processing perform simplifications 
shall see section      simplifications lead decreased resolution complexity  thereby offsetting result abstractions such  many cases  cannot 
may seem little artificial distinguish abstractions simplifications way  seeing
many abstractions bound enable us simplify  however  note distinction
serves identify borderline can  cannot  reduce resolution
complexity  anyhow  shall see next section  abstraction tend help
empirically performance satplan even post abstraction simplifications 

   empirical results
performed broad empirical evaluation effect abstractions efficiency
optimizing planning algorithms  mostly focus variable domain abstraction 
definition      since clearly promising obtaining solution length preserving
abstractions 
section     explains specific variable domain abstractions employ experiments  section     explains experimental setting chose present huge
data set results  section     describes experiments variable domain abstraction ipc benchmarks  section     discusses results domain specific
abstractions hand made instances certain benchmark domains amount
irrelevance controlled  section     briefly summarizes findings abstraction
methods variable domain abstraction 
    variable domain abstractions
designed three different methods automatically generate variable domain abstractions  methods listed based increasingly conservative approximations
    note define actions triples pre  add   del   components  hence
two actions identical pre  add   del may contained set a  reflects practical planner
implementations  actions names and or unique ids  checks duplicate actions
usually performed 
    similar fashion  duplicate actions may arise outcome edelkamps        pattern database
abstraction 

   

fifriends foes  planning satisfiability abstract cnf encodings

relevance  common relevance approximations  cf  nebel et al          algorithmic basis is  cases  simplified backchaining goals 
 support starts first layer planning graph contains goal facts  possibly
mutexes them   goal fact layer  selects one achiever
preceding action layer marks preconditions action new sub goals 
process iterated created sub goals 
allsupports proceeds similarly  support except selects achievers
 sub  goal 
allsupportsnonmutex proceeds similarly allsupports except starts backchaining first plan graph layer contains goals without mutexes 
three methods  selected set relevant facts r p taken set
goals sub goals created backchaining  set facts turned
variable domain abstraction follows  first  compute partition problems
fact set p subsets p            pk pairwise persistently mutex facts  take
subsets correspond underlying multiple valued variables  e g   position
package   perform abstraction within pi values relevant 
i e   pi   r      within subset pi   arbitrarily choose one irrelevant fact p  i e  
p pi   r  replace irrelevant facts  i e   q pi   r q    p 
p 
example  logistics   support abstracts away in p  v  facts package p except vehicles v selected supportin particular  single
airplane  contrast  allsupports mark in p  v  relevant airplanes v unless
special case applies  e g   p must transported within origin city only   finally 
allsupportsnonmutex even conservative covers special cases
allsupports abstracts in p  v  fact away  note identifying positions inside
airplanes positions outside airplanes may well affect length optimal plan 
addition domain independent  automatic variable domain abstractions  six
ipc domains designed domain specific solution length preserving variable domain
abstractions hand  logistics  domain specific abstraction explained
introduction  zenotravel  use similar abstraction exploiting irrelevant object positions  blocksworld  on a  b  considered irrelevant b neither initial
goal position a  b initially clear    depots  combination logistics
blocksworld  abstraction combination two individual abstractions 
satellite  abstraction performs simple analysis goal relevance detect directions
irrelevant satellite turn to  direction relevant satellites initial direction  goal direction  potential goal camera calibration target 
similarly  rovers  waypoint  location  considered relevant rover
either initial position  relevant needed rock sample soil sample image 
necessarily lies path rover must traverse reach relevant location 
    last conditions necessary avoid possibility clearing block c moving
away c although actually placed third block 

   

fidomshlak  hoffmann    sabharwal

    experiment setup presentation
presented data generated set work stations running linux  pentium   processor running   ghz   gb ram  used time cutoff    minutes 
experimented plan length optimizing planners satplan    ipp  koehler 
nebel  hoffmann    dimopoulos         mips bdd  edelkamp   helmert          
choice satplan   rather satplan   arbitrary  except that  using
naive encoding  c   resolution best case satplan   improved variable domain abstractionmaking bad empirical results even significant 
note that  although satplan   could considered recent  contains
developments beyond satplan    switching back older version
encoding method 
test examples  took  exceptions listed below  strips domains used
international planning competitions including ipc       precisely  use
 ipc       airport  dining philosophers  optical telegraph  pipesworld notankage 
pipes  world tankage  psr 
 ipc       depots  driverlog  freecell  rovers  satellite  zenotravel 
 ipc       blocksworld logistics   miconic strips simple version
logistics  freecell part ipc      set  
 ipc       grid  mprime  mystery   movie trivial  gripper variable domain
abstraction cannot preserve solution length  logistics part ipc      set  
measurements aimed highlighting potential abstraction principle
speeding computation information task  concretely  given
planning task   create abstract version   run planner x it 
three possible outcomes 
    x finds plan   abstract plan  happens real plan  that is  plan
   record time taken find plan  along time taken x
find plan given original task  
    x finds plan real plan  since planners optimize plan
length  information still gain length optimal abstract plan 
lower bound length real plan  record time taken compute
bound  for example  satplan    time taken last unsatisfiable
iteration   along time taken x compute lower bound given
original task  
    x runs time memory  case  one could record time taken
last lower bound proved successfully  sake readability  omit
consider cases         above 
    satplan   ipp optimize step length plan  mips bdd optimizes sequential plan
length  however  again  performance planners stand comparative evaluation
here  refer three simply plan length optimizing planners 

   

fifriends foes  planning satisfiability abstract cnf encodings

note that  spirit optimistic usefulness abstraction 
include time taken create abstract task   note actually obtain
several results pair x  namely one result every particular variable domain
abstraction  sake readability  include distinctions results
 the distinctions mostly inconclusive uninteresting anyway   instead present
results following best abstraction perspective  skip abstract tasks
either solved  abstract since facts considered relevant 
abstract task remains  skip instance  otherwise  select abstract task
providing best information instance  best case abstract plan
real  else select highest lower bound    several abstractions providing
best information  choose one lowest runtime 
    ipc benchmarks
due sheer size experiments  planners multiplied    domainsdiscussing
entire result set neither feasible would useful  online appendix  see jair
web page article  contains detailed data three optimal planners  herein 
provide summary analysis showing main points  particular focus satplan   
detailed data satplan        ipc domains given table   
depots satellite selected table     
domains abstraction brings somewhat significant advantage 
logistics selected illustrative example 
psr selected due interesting caseunusually  current optimal planners well  or badly  psr current sub optimal  satisficing  planners 
domain  selected    challenging instances  challenging
measured runtime taken original task  note problem instance selection
criterion presentation optimistic point view abstraction 
instance  table   first specifies whether found abstract plan real plan not 
characterizes problem instance terms cases         explained above 
corresponding runtimes satplan   abstract real tasks given
rows ta tr   table specifies lower bound lg proved real task
planning graph  that is  f  t  first fact layer contain goal facts
mutexes them   lower bound la proved satplan   abstract task 
and  finally  actual length lr optimal plans real task  last row relfrac
table specifies percentage facts considered relevant 
depots  best case data shown table   scattered across four kinds
variable domain abstractions  automatic abstractions sometimes
sometimes less aggressive handmade abstraction  example  instances numbers
      best case aggressive  support strategy  time
    note quality information essential  abstraction tells us plan
must least n   steps  real plan length n  must still prove bound n 
typically takes time bounds together 

   

fidomshlak  hoffmann    sabharwal

index
isreal 
ta
tr
lg   l   l
relfrac
abs

index
isreal 
ta
tr
lg   l   l
relfrac
abs

index
isreal 
ta
tr
lg   l   l
relfrac
abs

index
isreal 
ta
tr
lg   l   l
relfrac
abs

 

     
     
       
   
 s

  
n
    
   
       
   
asnm

  

    
    
        
   
 s

 

     
     
        
   


 

      
      
       
   
hm

  

     
     
       
   
asnm

  

     
     
       
   
asnm

 

      
      
        
   


 

     
     
     
   
hm

  

     
     
       
   
asnm

  

     
     
       
   
asnm

 

     
     
       
   
asnm

 

      
      
     
   
hm

  
n
    
    
       
   
asnm

  
n
     
     
       
   
asnm

 
n
      
     
       
   


 

     
     
     
   
hm

  
n
    
    
       
   
asnm

  
n
      
     
       
   
asnm

  

     
     
       
   
asnm

depots
  
  
n

     
    
    
     
       
     
   
   
 s
asnm
logistics
  
  
n
n
      
      
      
      
               
   
   
asnm
hm
psr
  
  


    
   
    
    
               
   
   
asnm
asnm
satellite
  
  


      
     
      
      
     
     
   
   
hm
hm
  

      

       
   
hm

  
n
   
    
       
   
asnm

  
n
      
      
       
   
hm

  
n
      
     
     
   
hm

  

      

       
   
hm

  
n
    
    
       
   
asnm

  
n
      
      
       
   
hm

  
n
     
    
      
   
 s

  

      
      
     
   
hm

  

     
     
       
   
asnm

  
n
      
      
      
   


  

     
    
     
   
asnm

  

      
      
     
   
hm

  

      
      
       
   
asnm

  
n
      
      
      
   
hm

  

    
     
     
   
asnm

  

     
      
     
   
hm

  
n
    
    
      
   
 s

  
n
      
      
      
   


  

      

       
   


  

      
      
     
   
hm

  

    
    
       
   
asnm

  
n
   
   
     
   
 s

  
n
      
     
     
   
hm

table    full results  selected domains  satplan   variable domain abstraction  best of  see text   notations  index 
index  number  instance respective ipc suite  isreal  whether abstract plan real  y   n   l  length
optimal plan    known   lg   lower bound plan length proved planning graph  la lower bound proved abstract task 
ta   runtime  secs  needed prove lower bound la abstract task  tr runtime  secs  needed prove lower bound la
real task  relfrac  fraction facts considered relevant  dashes  time out  abs  corresponding form variable
domain abstraction   support   s   allsupports  as   allsupportsnonmutex  asnm   handmade  hm  

   

fifriends foes  planning satisfiability abstract cnf encodings

domain
airport
blocksworld
depots
dining philosophers
driverlog
freecell
grid
logistics
mprime
mystery
optical telegraph
pipesworld notankage
pipesworld tankage
psr
rovers
satellite
zenotravel

index
  
 
  
  
  
 
 
  
 
  
  
  
 
  
 
  
  

ta
    
     
     
   
     
   
    
     
   
     
    
     
     
     
    
     
     

satplan  
tr
isreal 
lg   l   l r
    

        
    

        


       
   

       
     
n
       
   

     
   
n
       
     
n
       
   

     
     

     
    
n
        
     

       
     
n
     
     

       
    

     


       
     
n
     

relfrac
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

table    results satplan   best case variable domain abstraction
challenging successful instances domain  notation table   

runtime better original task  yet cases abstraction
brings quite significant advantage  notably  instance number    satplan  
runs time original task  solves abstract task  finding real plan  within
minutes  logistics  best case data mostly  though exclusively  due
conservative allsupportsnonmutex handmade abstractions  abstract runtime
worse three cases  nos               slightly better  psr  best
cases almost exclusively due conservative allsupportsnonmutex abstraction 
runtimes  abstraction usually faster  marginally  satellite one
   domains abstraction brings significant  and largely consistent  runtime
advantage  best cases almost exclusively due hand made abstraction 
abstract plans real plans  often found significantly faster original task 
unclear us results good satellite  but  example  logistics 
state space reduction much larger 
next  table   provides overview results satplan      ipc
domains  make data presentation feasible  select one instance per domainthe
challenging successful instance  successful  mean least one abstract
task instance solved  abstract plan found   abstract task indeed
abstract  not facts relevant   challenging  mean maximum runtime original
task   
    another strategy would select task maximizes tr ta   time advantage given
abstraction  however  cases strategy would select trivial instance  namely  tr ta
consistently negative  maximal easiest tasks 

   

fidomshlak  hoffmann    sabharwal

domain
airport
blocksworld
depots
dining philosophers
driverlog
grid
logistics
mprime
mystery
optical telegraph
pipesworld notankage
pipesworldtankage
psr
rovers
satellite
zenotravel

index
 
 
  
 
 
 
 
 
 
 
 
 
  
 
 
  

ta
    
   
     
     
   
   
   
   
   
    
   
    
   
     
     
     

tr
   
   
     
     
   
   
   
   
   
   
   
   
   
     
      
     

ipp
isreal 




n
n

n
n
n

n
n
n



lg   l   l r
        
        
     
       
       
       
       
     
     
        
     
     
     
       
     
     

relfrac
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

table    similar table    ipp planner 

useful discuss    domains groups similar behavior  depots  logistics 
psr  satellite already discussed  airport  dining philosophers 
driverlog  mystery  mprime  optical telegraph  pipesworld notankage  pipesworld
tankage  satplan   runtimes consistently lower original tasks  exceptions mostly among easiest instances  picture less consistent qualitatively
similar zenotravel  degree advantage varies  relatively moderate
dining philosophers  up    less runtime original task   optical telegraph  up
      airport  up       pipesworld tankage  up       mprime  up      
much stronger zenotravel  up       mystery  up       driverlog  up      
pipesworld notankage  up      
rovers  runtime results inconclusive  minor advantages abstract
real depending instance  blocksworld  satplan   solves abstract tasks
  blocks only  independently abstraction used  dont know causes
bad behavior  freecell  time allsupports allsupportsnonmutex
abstract anything  abstractions generated  support  satplan   runs
time  leaving instance number   successful case  shown table    grid 
finally  ipc      test suite contains   instances  become huge quickly 
satplan   solve  abstract real  instances numbers      latter
shown table   
tables     provide similar snapshot results ipp mips bdd 
respectively  picture ipp is  roughly  similar satplan    main
difference is  fact  ipp weaker solver satplan   many domains 
effect domains contain interesting data  specifically  driverlog 
mprime  mystery  pipesworld notankage  psr  ipp either solves instances
time  all  satplan    see advantage abstraction depots
   

fifriends foes  planning satisfiability abstract cnf encodings

domain
airport
blocksworld
depots
dining philosophers
driverlog
freecell
grid
logistics
mprime
mystery
optical telegraph
pipesworld notankage
pipesworld tankage
psr
rovers
satellite
zenotravel

index


 

ta


   

mips bdd
tr
isreal 







lg   l   l r


       

relfrac


   

  

 
  



     

   
   












n




       

      
        



   

   
   



  
 

   
     

    
     




     
       

   
   

  

     





       

   

table    similar tables     mips bdd planner 

satellite  note satellite difference consistently huge 
see vague advantage abstraction logistics  mips bdd  even domains
gave meaningful data  domains dashed table    mips bdd runs
time even smallest instances  domains left empty  either could run
mips bdd technical reasons  stopped abnormally  remaining data
set   domains  however  abstractions  as expected  bring consistent advantage
mips bdd  particular  consider behavior logistics  rovers  zenotravelin
domains  mips bdd vastly improved abstraction satplan   ipp
less inconclusive 
    constructed benchmarks
shown use abstractionof variable domain abstraction  least
speed state art planning systems varies quite promising mips bdd
rather hopeless satplan    ran number focused experiments examine
subtle reasons phenomenon  experiments done three
ipc benchmarkslogistics  rovers  zenotravelwhere results ipc test
suites relatively bad  although possession hand made abstractions 
wanted test happens scale instances irrelevance  respective
experiment logistics  figure    discussed introduction  rovers  tried
large number instance size parameters  even minor modifications operators 
could find setting contained lot irrelevance challenging
satplan   ipp  short  appears rovers domain amenable
abstraction techniques  zenotravel  obtained picture shown figure   
   

fidomshlak  hoffmann    sabharwal

     

   

     

   

  
    

  

  

    

  

  
   

  

  

   

  

  
  

  

  

  

  

  
 

  

  
mips bdd abstract
mips bdd real
relfrac

   
 

 

 

 

 

 

 

 

  

  

 

  
ipp abstract
ipp real
relfrac

  
 

  

   

  

 

 

 

 

 

 a 

 

 

 

  

  

  

  
 
  

 b 
     

   
  

    

  
  

   

  
  

  

  
  

 

  
satplan abstract
satplan real
relfrac

   
 

 

 

 

 

 

 

 

  

  

  

  
 
  

 c 
figure    runtime performance mips bdd  a   ipp  b   satplan    c  
 abstract  without  real  hand made variable domain abstraction 
zenotravel instances explicitly scaled increase amount irrelevance 
horizontal axis scales number cities  left vertical axis shows total runtime
seconds  right vertical axis shows percentage relfrac relevant facts 

shown zenotravel instances always feature   airplanes   persons  number
cities scales       logistics  generated   random instances per size 
show average values time out      seconds  stopping plots   timeouts occurred instance size  all  relative behavior abstract real
curves planner quite similar observed figure   logistics 
satplan   ipp  abstraction slight disadvantage high relfrac 
becomes much efficient relfrac decreases  mips bdd  advantage brought
abstraction much pronounced  decreasing relfrac consistently widens
gap solving abstract real tasks  average value relfrac ipc
     zenotravel benchmarks      lying   cities         cities      
figure    yet much gained abstraction 
   

fifriends foes  planning satisfiability abstract cnf encodings

summary  appears planning benchmarks  like rovers  good
abstractions  others  like logistics zenotravel  enough irrelevance
ipc test suites 
important note situation may quite bad unsolvable examples  consider ipc benchmarks dining philosophers optical telegraph  edelkamp 
       dining philosophers extremely basic benchmark cannot abstracted
much further  contrast  optical telegraph essentially version dining philosophers
complex inner life  exchanging data two hands philosopher  
inner life affect existence solution  deadlock situation   depends exclusively outer interfaces philosophers  is  taking releasing
forks  however  inner life does  course  affect length solution  one exists 
constructed unsolvable version domain  without deadlock situation  giving
philosophers flexibility releasing forks  one would expect  setting
abstracting inner life away gives huge savings  i e   tasks proved unsolvable
much efficiently  suggests may easier abstract unsolvable tasks 
without invalidating property interest  exploring topic future work 
planning benchmark domains naturally contain unsolvable instances 
over subscription planning issue may become relevant  sanchez   kambhampati       
meuleau  brafman    benazera        
    abstractions
discussed earlier  one cannot expect removing preconditions  goals  entire facts
preserves plan length interesting cases  are  however  certain cases
delete effects safely ignored  specifically  driverlog  logistics  mprime  mystery 
zenotravel  one ignore deletes load unload actions state
object longer origin location  load  respectively object
longer inside vehicle  unload   rovers one ignore deletes actions taking
rock soil samples  namely deletes stating sample longer origin
location  ran planners respective abstracted tasks  results
summarized follows 
satplan   clear loss runtime using abstraction driverlog  e g  
task number    solved abstract vs  real       vs        sec  
ipp vast gain abstraction logistics  e g        vs        sec number     
vast loss zenotravel  e g         vs     sec number     
mips bdd vast loss abstraction driverlog  logistics  zenotravel  e g  
      vs      sec zenotravel number    
results inconclusive planner domain pairs 

   resolution complexity
discussed introduction  surprised see little improvement satplan experiments  despite dramatic state space reductions brought
   

fidomshlak  hoffmann    sabharwal

variable domain abstraction  shed light issue  examining resolution
complexity original vs  abstracted planning tasks  throughout section 
consider situation plan length boundthe number time steps cnf
encodingis small  thus cnfs unsatisfiable  note case
one sat tests performed satplan  particular  case
sat tests satplan proves optimality plan  is  non existence
plan n   steps n length optimal plan  proof typically
costly  accounting large fraction runtime taken satplan 
consider abstraction methods introduced section      plus  for completeness 
hypothetical abstraction method adds new initial facts  show section     that 
many cases  resolution complexity cannot improved delegating optimality
proof within abstraction  section     show that  considered cases 
resolution complexity become exponentially worse  section     briefly examines
effect post abstraction simplifications  sake readability  herein proofs
replaced proof sketches  full proofs available appendix a 
recall resolution complexity defined length shortest possible resolution refutation  proofs  arguments general  unrestricted  resolution 
however  constructions affect structure resolution refutations 
hence results hold stated  except slight weakening case lemma      
many known variants resolution  including tree like  dpll   regular  ordered
resolution  general  results hold variant resolution setting variables true false replacing one variable another preserves proof structure  the
slightly exceptional status lemma      explained discuss
result  
remainder paper  p planning task abstraction 
p denote respective abstracted planning task  is  planning task
results applying p 
    resolution complexity become better 
prove three main results  captured theorems        below  first
result holds four sat encodings  a  d  listed section      two
results apply encodings  a   c   respectively  respective encodings
abstraction methods  results essentially say resolution complexity cannot decrease
applying abstraction  outlined introduction  catchy  if imprecise  intuition
behind results over approximations  abstractions  result less constrained
formulas  harder refute  encoding  c   result offset effort
required recover graphplan mutexes  get back below  theorems
follow  recall section     rc   denotes resolution complexity   i e  
size smallest resolution proof unsatisfiability  
theorem      let p planning task  assume use encoding methods
 a  d   let abstraction p consists combination of 
 a  adding initial facts 
 b  ignoring preconditions  goals  deletes 
   

fifriends foes  planning satisfiability abstract cnf encodings

 c  removing fact completely 
let n length shortest plan p   let b   n  let encodings
b step plan existence p p   respectively  rc   rc    
theorem      let p planning task  assume use encoding method  a   let
abstraction p consists combination of 
 a  adding initial facts 
 b  ignoring preconditions  goals  deletes 
 c  removing fact completely 
 d  variable domain abstraction 
let n length shortest plan p   let b   n  let encodings
b step plan existence p p   respectively  rc   rc    
theorem      let p planning task  assume use encoding method  c   let
abstraction p consists combination of 
 a  adding initial facts 
 b  ignoring preconditions  goals  deletes 
 c  removing fact completely 
 d  variable domain abstraction 
let n length shortest plan p   let b   n  let encodings
b step plan existence p p   respectively  let number resolution steps
required infer additional mutex clauses appear  
encoding b step plan existence p per encoding  a   rc   rc       
note theorems n  defined length shortest plan p  
necessarily satisfies n length shortest plan p  hence 
n b m  satisfiable  detecting finding p plan length b
give us information length shortest plan p    b   n 
however  unsatifiable  tells us b     lower bound plan length p 
hence  theorems say this  either b n coarse disprove existence
plan length b  b   n decrease resolution complexity
disproofat least complexity deriving additional mutexes 
case theorem     
let us first linger bit theorem      general intuition results
abstractions induce less constrained formulas  hence resolution complexity cannot decrease  hold encoding  a  stated theorem     not  strict
sense  see proposition      later section   encoding  c   basically  answer
intuition imprecise general formulation  devil details 
particular case  issue variable domain abstraction makes use mutex
   

fidomshlak  hoffmann    sabharwal

relations encoding  c  aware of  sometimes  indirect mutex original
task  omitted encoding  c   becomes direct mutex abstraction  included encoding  c    refuting might involve recovering mutex  refutation
need do  hence  potential improvement resolution complexity may stem
power mutex relations  upper bound specified theorem     shows
thing improvement due to  proposition      provides example
mutex must recovered  hence proves analogue theorem    
hold encoding  c  
open question whether analogue theorem     holds encoding  b  
whether analogue theorem     holds encoding  d   discuss
below  open questions appear related intricate properties graphplanbased encodings vs  without fact variables  know mutexes may
need recovered encoding  d   example provided proposition      works
encodings  c   d   further  establish connection two open
questions  analogue theorem     holds encoding  b   immediately get
analogue theorem     holds encoding  d  
consider detail  note that  far removal goals concerned 
theorems actually trivial  four encoding methods  removes part
goals  sub formula   abstraction methods  latter
case  treat removal goals together methods since treament
cause overhead  goal clauses need discussed anyway  the set
achievers goal may change  
proofs  need helper notion captures over approximated planning graphs  assume planning task p planning graph p g p   assume
abstraction  p g p   typically many vertices p g p  
captures fact p allows fewer  and often more  facts actions p
does  will  general  result many constraints propositional translation
planning task  constraints  may seem abstraction could 
principle  make possible derive easier shorter proof fact plan exists
within specified bound  however  closer inspection restricted facts actions
already available original planning graph reveals one often ends fewer
weaker constraints original task  introduce notations
make formal 
definition      planning task p abstraction it  p g  p  defined
subgraph p g p   induced vertices p g p   similarly  p gred  p  defined
subgraph p gred  p   induced vertices p gred  p  
definition      let p planning task  abstraction called planning graph
abstraction p p g  p  p g p  identical sets vertices following
conditions hold 
    eadd  p g  p   eadd  p g p   
    epre  p g  p   epre  p g p   
    emutex  p g  p   emutex  p g p   
   

fifriends foes  planning satisfiability abstract cnf encodings

     g  g 
g  g  goal states p p   respectively  abstraction called
reduced planning graph abstraction conditions hold p gred  p  p gred  p 
instead 
lemma      let p planning task  assume use encoding method  a   b   let
planning graph abstraction p  let n length shortest plan p  
let b   n  let encodings b step plan existence p p   respectively 
rc   rc    
proof sketch  say set false variables appear   i e  
fix value variables    way defined p g  p  
yields precisely propositional encoding p g  p   show that  variable
restriction  clauses surviving present   either stronger
form  i e   fewer literals   example  encoding  a  precondition clause
c corresponding clause c due condition     definition     
states introduce new preconditions  c c due condition
    definition      states preserves add effectshence set actions
achieving precondition p contains corresponding set p  similar observation
holds effect clauses encoding  b   similar arguments apply
kinds clauses  claim follows proposition     
lemma      let p planning task  assume use encoding method  c   d   let
reduced planning graph abstraction p  let n length shortest plan
p   let b   n  let encodings b step plan existence p p  
respectively  rc   rc    
proof  argument identical proof lemma      except underlying
planning graph encodings  c   d  reduced planning graph  resulting potentially fewer mutex clauses encodings  a   b   respectively  this  however 
way affect proof arguments 
lemma      let p planning task  let modification p respects
following behavior 
 a  shrink list initial facts 
 b  grow set goal facts 
 c  preserves add lists unchanged 
 d  grow pre del lists 
planning graph abstraction p well reduced planning graph abstraction
p 
   

fidomshlak  hoffmann    sabharwal

proof sketch  proof straightforward  little tedious details  suppose
abstraction p satisfying prerequisites  must argue p g  p  p gred  p 
satisfy conditions definition      condition     involving goal states easily follows
property  b    p g p  p g  p   as well reduced counterparts 
shown set vertices  conditions         involving precondition
effect relations follow directly properties  c   d   hence remains prove
facts actions available p g p  available p g  p   showing    
    said   new mutex relations created facts
actions mutex p g p   showing       proof little tedious  proceeding
inductively construction planning graph  underlying intuition  however 
simple  p g  p  layer abstracts p g p  layer t  properties  a    c 
 d  respected   necessarily p g  p  layer     abstracts p g p 
layer      concludes argument 
following immediate consequence lemmas               
corollary      let p planning task  assume use encoding methods
 a  d   let abstraction p consists combination of 
 a  adding initial facts 
 b  ignoring preconditions  goals  deletes 
let n length shortest plan p   let b   n  let encodings
b step plan existence p p   respectively  rc   rc    
result essentially states rather intuitive fact that  abstraction anything yields larger planning graph  resulting graphplan based encodings
less constrained hence higher resolution complexity  if anything  
matters become much less intuitive consider abstractions remove entire
factsclearly  longer result over approximated planning graphs  since remove vertices  words  condition definition     p g  p 
p g p  identical sets vertices hold  need slightly different line
reasoning rely strictly abstracted planning graphs  first show
harmless remove fact appear goal pre del list 
rely corollary     reason requirement fact easily achieved 
lemma       let p planning task  assume use encoding methods
 a  d   let p fact appear goal pre del lists 
let abstraction p removes p initial facts add lists  let
n length shortest plan p   let b   n  let encodings
b step plan existence p p   respectively  rc     rc    
proof sketch  key point that  p appear goal never required
deleted action  p completely irrelevant planning task  particular
resolution refutations consider here  concretely  first prove every layer
planning graph  available facts mutex fact pairs remain same 
facts fact pairs involving p  is  thing lost fact layers
   

fifriends foes  planning satisfiability abstract cnf encodings

p g  p  p  since p occur precondition  action layers remain exactly
same  since p occur preconditions delete effects  action mutexes
remain exactly  they caused p  
discussion implies precondition clauses encodings
identical  given p appear goal  true goal clauses 
since action mutexes unchanged  follows actually identical
encodings  a   c   encodings  b   d   difference
contain initial state  effect  mutex clauses involving p 
however  clauses never participate resolution refutation   effect
mutex clauses contain p polarity  negative   initial state clause
positive form  p      time index different p effect mutex
clauses  hence every variable corresponding p occurs one polarity  concludes
argument 
corollary       let p planning task  assume use encoding methods
 a  d   let abstraction p removes fact completely  let n length
shortest plan p   let b   n  let encodings b step plan existence
p p   respectively  rc   rc    
proof  equivalent following two steps  first  remove p goal facts  if
present  pre del lists  corollary      step cannot improve resolution
complexity  second  p removed goal pre del lists 
remove p problem completely removing initial facts add lists
well  lemma       step well cannot improve resolution complexity 
done 
corollaries          together prove first main result  theorem     
move variable domain abstraction  matters complicated 
interesting abstraction method enables us construct solution length
preserving abstractions exponentially smaller state spaces  many benchmarks  first
show that  original form  result holds encoding  a  
lemma       let p planning task  assume use encoding method  a   let
variable domain abstraction p  let n length shortest plan p   let
b   n  let encodings b step plan existence p p   respectively 
rc   rc    
proof sketch  combines two persistently mutex facts p p  single fact p  first
show action pair  a  a    mutex p   mutex p 
way  a  a    become mutex per requires  w l o g   p  p del  a  pre a 
p  pre a    add  a     supposing  a  a    mutex p  p   del  a    p
mutex fact pre a     then   noop p   a    mutex p hence
 p  p    persistent mutex  contradiction 
hand  derive property rather similar planning graph
abstractions given definition      above  know abstract encoding
mutexes appear   further  set actions achieving
fact grows applying abstraction  goal shrink 
   

fidomshlak  hoffmann    sabharwal

subtle issue regards precondition clauses  action p  precondition p 
replaced p p   direct correspondence two  however 
lack correspondence affect precondition clause encoding  a  
takes form  a  a            ak    omits actual precondition fact achieved 
matter whether fact p  p 
next  proof lemma      set variables false appear
  arguments  difficult see clauses surviving
present   either stronger form  i e   fewer literals  
mutex clauses  obvious  goal clauses  argument exactly
proof sketch lemma     given above  precondition clauses  observe a            ak
contain achievers p  plus achievers p  claim follows
proposition     
corollaries          together lemma      prove second main result  theorem      encodings  b  d   matters complicated 
consider first encodings  b   d   differ  a 
fact variables  changes precondition clauses  action p p 
precondition  p p   longer get clause  a  a            ak   proof
sketch  instead  get clause  a  p   clause  correspondence  
particular  consider case two actions p  action precondition
p action a  precondition p    gives us clauses  a  p    a    p   
clauses  a  p    a    p    now  distinguish achievers
p p    problem regard  fact two
clauses share literalwhich dont exploited obtain shorter resolution
refutations  open question  discuss implications little detail
end sub section 
consider encoding  c   differs  a  includes direct action
mutexes  invalidates different argument proof lemma       still true
that  action pair  a  a    marked mutex p   mutex p 
however  happen  a  a    mutex p due direct interference
a     a  a    mutex p due mutex preconditions  rather direct
interference  since encoding  c  accounts direct interferences 
mutex appear   result improved resolution complexity
  following proposition proves formally 
proposition       assume use encoding method  c   exist planning task p 
variable domain abstraction p  b   n rc     rc     n
length shortest plan p   encodings b step plan existence
p p   respectively 
proof sketch  construct p    b specified  key property construction
two actions  getg  getg    needed achieve goal facts
g  g    respectively  precisely  getg      x    g    p      x   getg      p  y  
 g      p    task constructed  along help actions  way
x  p  p  pairwise persistently mutex  variable domain abstraction replaces
p  p  b set    action layer directly beneath goal layer  i e   action
   

fifriends foes  planning satisfiability abstract cnf encodings

layer a     planning graph marks getg  getg  mutex preconditions
mutex  encoding  c   however  include mutex clause
direct conflict  situation changes abstraction  getg  adds p instead p   
hence direct conflict delete effect getg    consequence 
abstraction two resolution steps suffice  applying getg  getg  a   
option achieve goals  new mutex clause immediately excludes option 
encoding original task  required mutex must first
derived reasoning preconditions x p 
note reason get shorter refutation variable domain abstraction turns indirect action mutex  due competing preconditions 
direct interference  so  abstraction exploits knowledge p p 
persistently mutexa fact ignored encoding  c   hence positive result stated
proposition      less related power abstraction power planning
graph mutexes  capture formally  follows  note using
plan length bound  cnf formula per encoding  c  sub formula cnf
formula per encoding  a   additional clauses  a  inferred it 
lemma       let p planning task  let variable domain abstraction p 
let n length shortest plan p   let b   n  let c
encodings b step plan existence p per encoding  a   c   respectively  let c
encoding b step plan existence p per encoding  c   let number
resolution steps required infer c additional mutex clauses appear  
rc c   rc c      
proof  denote encoding b step plan existence p per encoding  a  
have 
    preconditions lemma  rc c   rc a       resolution steps 
c turned   hence shortest resolution refutation
construct one c steps longer 
    lemma       rc a   rc a   
    c sub formula   hence rc a   rc c   
combining observations  have 
rc c   rc a    

observation    

rc a    
rc c    

observation    




observation    

finishes proof 
clearly  proof argument applies combination variable domain
abstraction abstractions  hence corollaries          together
lemmas           prove third main result  theorem      note latter
result hold variants resolution  claim lemma      
   

fidomshlak  hoffmann    sabharwal

number resolution steps takes derive action mutexes present original
encoding  used resolution refutation  variant resolution
consideration is  say  dpll tree like resolution  deriving mutex clause
enoughit must re derived many times used tree like resolution
refutation  hence effective value variants resolution would larger 
note case dpll solver learns mutex clauses virtue
wide spread clause learning technique 
lemma      particularly relevant empirical results  satplan   uses
encoding  c  experiments mostly focus variable domain abstraction 
explicit empirical proof  and proof would difficult come by  requiring
deep analysis sat solvers search spaces   seems reasonable assume that 
least extent  disappointing results satplan   due whats proved
lemma       abstraction cannot improve resolution complexity beyond effort
required recover indirect action mutexes  note bound given
lemma rather pessimistic  mutex  a  a    needs recovered case
a  competing needs p  replacing p  p results direct
interference incur simplifications  logistics domain  example 
abstraction happens actions loading package onto airplane two
different irrelevant cities  since load actions involved redundant
solutions anyway  seems doubtful mutexes play role resolution complexity 
generally  interesting consider upper bounds lemma      
many resolution steps take recover indirect action mutexes  general resolution  number steps polynomially bounded  since inference process conducted
planning graph simulated  for related investigation  see brafman        
restricted variants resolution  matters complicated  particular interest
behavior dpll clause learning  c f  above  far known formula dpll clause learning proofs provably substantially worse general
resolution proofs  would rather surprising planning graph mutexes
first  also  rintanen        provides related investigation  showing mutexes
recovered polynomial time particular   step lookahead procedure  related
 but identical  clause learning 
concluding sub section  let us turn attention encodings  b   d  
mentioned before  open question whether analogue theorem     holds
encoding  b   whether analogue theorem     holds encoding  d  
facing two problematic issues 
 i  fact variables  encoding  b   d   fact variables addition
action variables used encodings  a   c  
 ii  mutexes  encoding  c   may happen variable domain abstraction
converts implicit mutex encoding  d  original task explicit one
abstraction 
consider first issue  ii   situation exactly encoding  c   regard 
proposition      holds stated encoding  d  well  indeed proved using
   

fifriends foes  planning satisfiability abstract cnf encodings

exactly example minor adaptations proof arguments    similarly  lemma      holds encoding  d   exactly proof argumentsprovided
analogue lemma       and hence analogue theorem      holds encoding  b  
namely  proof arguments lemma      remain valid  except need refer
encoding  b  rather  a   accordingly need corresponding version
lemma       brings us issue  i  
variable domain abstraction perceived gluing sets facts together  recall
example clauses  a  p    a    p    sharing literals  clauses
 a  p    a    p  sharing literal p  discussed explain
proof lemma      work encodings  b   d   k     facts glued
together  groups k clauses become linked together fashion  question
is 
    resolution fruitfully exploit increased linkage 
issue appears related quite intricate properties graphplan based
encodings vs  without fact variables  encoding  a   differs encoding
 b  use fact variables  lemma      tells us resolution cannot
exploit variable domain abstraction  now  appears reasonable think adding fact
variables help lot  intuition being 
     whatever one encoding  b   one easily simulate encoding  a  
statement      true  answer question     no  yes
answer would contradict lemma       hence  initial attempt prove answer 
tried prove statement       however  initial investigation indicated
explicitly keeping fact variables  and non trivial constraints them  around  encoding  b 
might facilitate significantly shorter resolution derivations general  hence statement
     might false  namely  appear families formulas suitably
encoded planning tasks yield exponential separation encodings  a 
 b   true  suggests reasoning presence fact variables might
powerful hence might indeed able exploit linkage gain yielded
variable domain abstraction 
since purpose paper compare relative power various
graphplan based encodings  such  a   b    detail progress
towards disproving statement       besides  note that  statement      indeed false 
immediate implications answer question      definite
answer     left open future research 
    resolution complexity become worse 
answer title sub section definite yes  four encodings 
abstractions consider may exponentially deteriorate resolution complexity 
formally  following theorem 
    include full proof  c   d  appendix a 

   

fidomshlak  hoffmann    sabharwal

theorem       assume use encoding methods  a  d   exist
infinite sequence planning tasks p i   abstractions  i  p i   b i    n i 
rc   i   exponential rc  i   constant independent i  n i 
length shortest plan p  i    i   i  encodings b i  step plan
existence p i  p  i  respectively   i  consists one of 
 a  adding initial facts 
 b  ignoring preconditions  goals  deletes 
 c  removing fact completely 
 d  variable domain abstraction 
proof sketch  idea construct p i  planning task consists two separate
sub tasks  whose overall goal achieve goals sub tasks 
sub tasks infeasible within given plan length bound b i    the
tasks bounds constructed size grows polynomially i   however 
first sub task constructed require exponential size resolution refutations 
second allows constant size refutations  abstraction over approximates easy torefute sub task way becomes feasible within b i  steps  resolution
refutation overall task must rely hard to refute sub task  leads
exponential growth  i  resolution complexity  i   opposed constant resolution complexity  i   single one listed abstractions  feasibility
easy to refute sub task accomplished simple manner  hence proving theorem 
order construct planning tasks whose cnf encodings require exponential size
resolution refutations  resort pigeon hole problem formula php i   well
known resolution proof php i  must size exponential  haken        
construct simple pigeon hole planning task pp hp  i  capture problem 
show that  four encoding methods  a  d   cnf encoding b i     
either identical php i   transforms php i  variable restrictions  hence 
proposition      resolution refutation must size exponential i  final
construction uses combination two tasks  pp hp  i  serves hard to refute
sub task  pp hp     disjoint sets pigeon hole objects serves easy to refute
sub task 
essentially  theorem      states intuitive fact abstractions make bad
choices  approximating away concise reason planning task cannot
solved particular number steps  illustrate significance this  consider
comparison mutex relations  analogue theorem      hold
them  adding mutex clause cnf encoding improve resolution complexity 
sense  mutex relations considerably less risky abstractions consider
here 
pigeon hole problem used proof theorem      may seem artificial 
indeed contained sub problem wide spread domains concerned
transportation  example  gripper  available time steps serve holes
actions picking dropping balls pigeons  for related investigation  see
   

fifriends foes  planning satisfiability abstract cnf encodings

hoffmann et al          seems quite natural planning task may consist two
disconnected parts  one complex one easy prove unsolvable
given number steps  think transporting two packages  one
close many vehicles requires one step bound allows 
one already inside vehicle needs transported along single path road
connections much longer bound  a concrete example latter situation
formalized hoffmann et al         
    note simplifications
pointed section      may actions abstraction obviously
simplified without altering semantics planning task  particular  abstraction
might create duplicate actions  that is  actions identical preconditions effects  
well redundant add effects  that contained respective actions precondition  
turns natural post abstraction simplification planning task lead
lower resolution complexity 
proposition       assume use encoding methods  a  d   exist
planning task p  planning task p   identical p except either irrelevant
add affect duplicate action removed  b   n rc     rc     
n length shortest plan p    encodings b step plan
existence p p     respectively 
proof sketch  show claim duplicate actions  consider task p   encoding
pigeon hole problem   pigeons   holes  actions put pigeon p hole h 
plan length bound    point proof works solvable tasks p 
extra action a  whose preconditions two goals achieves third goal 
ensures solvability two steps  three goals  one pigeon 
mutex clauses direct action interference  pair goals
achieved three them  particular  every resolution refutation must resolve
three goal clauses  obtain p adding duplicate action one pigeons
one holes  respective goal clause becomes one literal longer 
refutation must get rid literal  hence necessitating one step  construction
works four encodings 
show claim removal redundant add effects  slightly modify p     replacing
effect new fact x including another action achieves third goal given
precondition x  optimal plan length    length bound   
refutation must resolve three goal clauses  if  p  give one preconditions
additional add effect  refutations become longer respective goal
clause does  again  construction works four encodings 
easy modify constructions used proof proposition      way
duplicate action  respectively redundancy add effect  arise
outcome variable domain abstraction  hence  via enabling simplifications  variable
domain abstraction may improve resolution best case behavior  duplicate actions 
true edelkamps        pattern database abstraction  open question
   

fidomshlak  hoffmann    sabharwal

whether improvement may exponential  whether bounded polynomially 
conjecture latter case  least unrestricted resolution 
notable examples proof proposition      specifically
constructed include duplicate actions redundant add effects actions relevant
solving problem form part optimal solution  well constructed variable
domain abstraction likely happen since abstraction target facts
irrelevant solution length  consider logistics domain example 
actions simplifications apply loads unloads packages to from locations
cities packages origin destination  actions involved
redundant solutions  seems doubtful simplification affects resolution
complexity  course  simplifications might help sat solvers anyway  this  however 
observed  least significantly  experiments 

   conclusion
abstractions  used here  power allow proving certain properties within much
smaller state spaces  particular  abstraction preserves length optimal
solution  optimality proved within abstraction  designed novel abstraction method strips planning suitable purpose  surprisingly 
approach yields little benefits planning as satisfiability approach represented satplan  even domains featuring hand made abstractions exponentially smaller state spaces  towards explaining this  shown that  many cases 
abstraction method  as well commonly used abstractions  lacks ability introduce shorter resolution refutationsother exploiting mutexes 
enabling certain post abstraction simplifications  contrast  shown
abstractions may exponentially increase size shortest resolution refutations 
several questions left open theoretical results  know whether variable domain abstraction improve resolution complexity combination encoding
 b   whether polynomial upper bound improvement variable domain
abstraction bring encoding  d   whether polynomial upper bound
improvement result simplifications  apart answering questions  importantly remains seen extent results generalize  bluntly
stated  intuition behind results over approximations usually result less
constrained formulas harder refute  however  actual technicalities
results depend quite lot detailsof encoding method abstraction
hence largely unclear extent intuitive statement captures reality 
particular  hold encodings planning sat 
would interesting  e g   look alternative encodings described kautz
selman         kautz et al          kautz selman         ernst  millstein 
weld         many encodings based unit clauses initial goal state 
action clauses stating action implies effects preconditions 
structureand lack mechanism planning graph propagates
changessome properties proved herein obvious  removing goals initial state
facts corresponds directly removing clauses  true preconditions  removing
fact completely may cases simply correspond removing clauses mention
   

fifriends foes  planning satisfiability abstract cnf encodings

fact  hence  encodings  seems proving results might indeed
comparatively easy  challenging subject may recent developments 
encodings rintanen et al         often give substantial speed ups
novel notions parallelity  encodings chen et al         introduce
long distance mutex relations  encodings robinson et al         make use
effective operator splitting factoring methods 
generally  results hold methods employed fields  particular 
hold model checking  abstraction  e g   graf   sadi        clarke
et al         sat encodings  e g   clarke  biere  raimi    zhu        prasad  biere 
  gupta        highly successful  one example actually obvious
results hold  gupta strichman        abstract ignoring clauses cnf
encoding original transition system  the motivation much smaller cnf
formula causes less overhead sat solver  
ambitiously  define generic framework formal notions declarative
transition systems  cnf encodings  abstractions suitable capture
results  prove generic statements  questions appear worthwhile
research challenges  indeed  think key contribution work may lie asking
question resolution complexity vs  without abstraction 
practical perspective  see mainly four lines research  first 
important question whether observations carry modified extended planningas sat systems  one ray ginsberg        guarantees plan
optimality branching restrictions within single sat call  rather
calling sat solver iteratively  second  remains open explore whether different
abstraction techniquesbased e g  predicate abstractioncan suitably adapted
planning  third  important note empirical results entirely negative 
mips bdd often substantially improved  even point where  figure   
optimal sequential planner highly competitive strong optimal parallel planner
satplan  highly parallel domain logistics  direction
may well worth exploring depth  finally  effective abstraction methods may
exist unsolvable examples  could potentially play crucial role over subscription
planning  sanchez   kambhampati        meuleau et al         

acknowledgments
thank anonymous reviewers  whose detailed comments helped greatly improve
paper  preliminary version work appeared icaps      th international
conference automated planning scheduling  hoffmann  sabharwal    domshlak 
       work carmel domshlak supported israel science foundation  isf 
grants                  well c  wellner research fund  part
work  jorg hoffmann employed max planck institute computer science 
saarbrucken  germany  sap research  karlsruhe  germany  work ashish
sabharwal supported iisi  cornell university  afosr grant fa                
national science foundation  nsf  expeditions computing award  computational
   

fidomshlak  hoffmann    sabharwal

sustainability grant           nsf iis award  grant           defense advanced
research projects agency  darpa  real grant fa                

appendix a  proof details
proof proposition      suppose sequence transformations consists   restrictions                      further  let   strengthening transformation replaces
clause    not necessarily strict  sub clause clause  
transformation exists assumptions proposition  observe
      transformation steps together convert  not necessarily strict  sub formula
  show       transformation steps individually increase
resolution complexity underlying formula  without loss generality 
prove fact single restriction transformation generic strengthening
transformation  since individually shown increase resolution
complexity formula  applied sequence combination  number
times  without increasing resolution complexity  would prove  particular 
resolution complexity sub formula   implying
resolution complexity  as additional initial clauses
cannot hurt resolution refutation   desired 
start single restriction transformation x y  ease notation 
assume initial formula f    c    c            cm   resulting simplified
     m  m  without loss
formula transformation f      c     c             cm
 
 
generality  assume ci equals empty clause    duplicate
clauses f     let    c    c            cm   cm             cm       resolution refutation
f smallest possible size  note involves initial clauses resolution
steps    construct resolution refutation   f   size larger
  following three steps 
step    transform    c            cm   cm             cm        ci defined
follows  application transformation x results ci containing true
variable negation  ci equals true  results ci containing
false duplicate literals  ci consists ci false duplicate literal removed 
otherwise ci   ci   note ci contain x either true  empty
clause  non empty  not necessarily strict  sub clause c  key property
ci still logical implicant cj ck ci derived resolving
cj ck original proof   ci may necessarily usual resolution
resolvent cj ck   next two steps fix 
step    transform    c            cm   cm             cm        ci equals ci
  defined sequentially  increasing i  follows  suppose
ci derived resolving clauses cj ck   j   k   i  assume
without loss generality already defined cj ck   ci equals
true  ci equals true well  otherwise  one two clauses cj ck
equals true  ci equals clause  otherwise  cj ck resolved
together variable ci resolvent two clauses  key
property here  seen easily considering sequential nature
   

fifriends foes  planning satisfiability abstract cnf encodings

transformation  ci either true  not necessarily proper  subclause ci   particular  cm       further  ci equal true
either resolution resolvent cj ck   equals    one cj ck
   
step    finally  transform   simply removing clauses equal true
occur previously clause sequence  stopping sequence soon
first empty clause encountered  construction      exactly
clauses   clauses  further  first m  clauses
  exactly clauses f     resolution refutation starting
initial clauses  desired 
consider strengthening transformation     essentially replaces
clause formula sub clause  thereby strengthening clause   show
applying   increase resolution complexity underlying formula 
again  ease notation  let initial formula f    c    c            cm   resolution
refutation    c    c            cm   cm             cm       smallest possible size 
argument along lines simpler restriction transformations 
transform    c            cm   cm             cm        m  ci equals
sub clause ci   maps ci to    m  ci defined sequentially  increasing
i  follows  suppose ci derived resolving clauses cj ck variable x 
j   k   i  assume without loss generality already defined cj
ck   x present cj ck   ci simply resolution resolvent
two clauses  otherwise  x present cj   ci equals cj   otherwise x must
present ck set ci equal ck   key property here  seen
easily considering sequential nature transformation  ci  not
necessarily proper  sub clause ci   particular  cm       further  ci either cj
ck resolution resolvent two  transform   simply removing
clauses occur previously clause sequence  construction 
exactly clauses   clauses  further  first m  clauses
  exactly clauses f     resolution refutation starting initial
clauses  desired 
proof lemma      let p planning task abstraction abstracts
p g p  applied  let   denote propositional encodings p p   respectively 
use either action only encoding  a  action fact encoding  b 
  let u denote set variables variables   finally 
let variable restriction sets every variable u false  setting 
propositional formula   nothing cnf encoding planning graph p g  p 
 using encoding method   a   b   used    particular 
clauses correspond actions facts p g p  trivially satisfied
  contain negation variable u   set false   call
remaining  yet unsatisfied clauses   surviving clauses  argue
surviving clause already present  perhaps stronger weaker form 
itself  showing easier prove   unsatisfiable prove
unsatisfiable 
   

fidomshlak  hoffmann    sabharwal

first consider encoding  a   conditions         definition      every surviving
precondition goal clause   corresponding clause itself  further 
condition     concerning facts added action  precondition
goal clause   contains sub clause corresponding clause   finally 
surviving mutex clauses     condition      present mutex clause  
observations  follows every surviving clause   contains  possibly
non strict  sub clause corresponding clause   applying proposition      obtain
rc   rc     finishing proof encoding  a  
consider encoding  b   first  definition     p g  p  p g p 
identical sets vertices  particular fact vertices f     same  hence
surviving initial state clause   present initial state clause   further  precondition clauses binary and  condition     definition      surviving
precondition clause   present precondition clause   similarly 
goal clause unit clause and  condition      surviving goal clause  
present goal clause   similar vein  surviving mutex clause  
present mutex clause   finally  surviving effect clause     condition
     contains sub clause corresponding effect clause     hence see
every surviving clause   contains  possibly non strict  sub clause corresponding clause   applying proposition     before  obtain rc   rc    
finishing proof encoding  b  
proof lemma      let p planning task abstraction respects
behavior specified lemma applied  show four conditions
definition     hold p g  p  p gred  p   observe condition    
definition     trivially holds property  b    therefore focus showing
v  p g p     v  p g  p    v  p gred  p     v  p gred  p    conditions       
definition     hold  fact  show p g  p  p gred  p  set
vertices original  reduced  planning graph  conditions         definition    
would immediately satisfied due properties  c     d    would
remain would condition      saying new mutex clauses added applying  
hence  task reduced proving following four new properties hold
step               b planning task 
 i  f  t  f  t  
 ii   t  a t  
 iii  ef mutex  t  f  t  ef  mutex  t  

 iv  ea mutex
 t  a t  ea mutex  t  

f  t   a t   ef  mutex  t   ea mutex  t  denote sets facts  actions  including
noops   fact mutexes  action mutexes generated p step t   versions
denote corresponding sets p   f  t   ef mutex  t   denotes   f    f   
    one needs add lists shrink applying   however  another argument
shortly require add lists grow either  justifying strict requirement property  c  

   

fifriends foes  planning satisfiability abstract cnf encodings


ef mutex  t    f    f     subset ef mutex  t  restricted facts   ea mutex
 t  

defined similarly  t  
order prove four properties hold  give inductive argument t 
alternating f  t  ef  mutex  t  one hand  a t  ea mutex  t 
other  base case      note f     f     property  a 
ef mutex     f     ef  mutex     sets empty 
words  goal prove certain facts actions available p
certain step  remain available p   similarly  two facts actions mutually
compatible p  remain mutually compatible p   seems intuitively justifiable
given properties   following argument formalizes intuition  terms
notation  use pre  del   add specify actions p pre   del   add
specify actions p  
first part inductive step  suppose f  t  f  t  ef mutex  t  f  t 

ef  mutex  t   show  t  a t  ea mutex
 t  a t  ea mutex  t   inductively
proving conditions  ii   iv  
let a t   pre  a  f  t  f  t   further  f  f   pre  a  pre a 
f  t    f  f       ef  mutex  t  ef mutex  t  f  t  hence  f  f       ef mutex  t  
therefore  t   proving  t  a t  
let a  a  a t   a  a      ea mutex  t   reduced planning graph

 t  due properties
direct mutexes  immediately  a  a      ea mutex

 c   d    done proving ea mutex  t  a t  ea mutex  t   otherwise 
general mutexes  several things hold  first  pre  a  pre a  f  t  f  t  
a    likewise  del  a  del  a  del  a    del  a     finally 
property  c   add  a  add  a   hence  c     pre  a  add  a   del  a   
 pre a add  a  del  a        last equality holds  a  a      ea mutex  t   similarly 
 c     pre  a   add  a    del  a      finally  f pre  a  pre a  f  t  f  t 
f   pre  a    pre a    f  t  f  t    f  f       ef  mutex  t 
ef mutex  t  f  t    implies  c     f  f       ef mutex  t    c      c      c    


 a  a      ea mutex
 t   proving ea mutex
 t  a t  ea mutex  t  

second part inductive step  suppose  t  a t  ea mutex
 t  a t 


ea mutex  t   show f  t    f  t    ef  mutex  t    f  t    ef  mutex  t 
    proving conditions  i   iii  


let f f  t       f aa t  add  a  aa  t  add  a    recall noop
actions included a t   need explicitly include f  t  f  t       
follows f f  t       proving f  t      f  t      
let f  f   f  t       f  f       ef  mutex  t       must exist
 
a  a t   t   c    f add  a  add  a    c    f   add  a    add  a  


 a  a      ea mutex  t  ea mutex
 t  a t    implies  c     a  a      ea mutex
 t  
 


 c      c      c      f  f     ef  mutex  t       proving ef  mutex  t  
   f  t    ef  mutex  t      
finishes inductive argument  showing conditions  i  iv  outlined
hold  earlier reasoning  proves vertices p g p  p g  p  
well reduced counterparts   so conditions        
definition     follow directly properties  c   d    mutex relations
p red  p   restricted facts actions p  subset mutex relations

   

fidomshlak  hoffmann    sabharwal

reduced mutex relations  respectively  p  so condition     definition    
holds   hence abstracts planning graph well reduced planning graph
p 
proof lemma       let abstraction removes p initial facts
add lists given planning task p p appear goal facts
pre del lists  proof lemma      let   denote propositional
encodings p p   respectively  use one encodings  a    b    c  
 d    show encodings  a   c   fact
identical  encodings  b   d   differ clauses cannot part
resolution proof 
end  use planning graph notation proof lemma    
begin arguing induction f  t    f  t     p   ef mutex  t    ef  mutex  t      p  p     

p  f  t     t    a t   ea mutex
 t    ea mutex  t   base case     

f       f      p  definition   ef mutex  t    ef  mutex       p  p      p  f     
sets empty  first part induction  suppose
inductive conditions f ef  mutex hold time step t  since p pre list 
implies  t    a t  well  further  since p del list 

ea mutex
 t    ea mutex  t   hence conditions ea mutex hold time step
t  second part induction  suppose inductive conditions
ea mutex hold time step t  implies f  t      consists f  t      possibly
p  further  ef  mutex  t      ef mutex  t      far mutexes involving
p concerned  follows conditions f ef  mutex hold time step     
finishing induction 

summarize  shown every step  sets a  ea mutex   ea mutex
exactly same  sets f  f ef  mutex   ef mutex facts
pairs facts involving p  words  new actions facts become available mutually excluded planning graph   everything involving p remains
unchanged  given this  observe four encodings  goal precondition clauses p exactly p p appear goal

pre lists all  similarly  ea mutex
 t    ea mutex  t  ef mutex  t    ef  mutex  t 

implies action mutexes p   fact mutexes present encoding 
p well  therefore  encodings  a   c      
finally  encodings  b   d   initial state  effect  mutex clauses
get removed applying   i e   present   however 
clauses mention propositional variables corresponding p 
variables appears one polarity throughout   namely  initial state clause
 p     clause may contain p positive polarity  effect mutex clauses
contain p time index      that  clauses cannot part
resolution refutation every variable appearing resolution refutation must
eventually resolved away order derive empty clause  follows
respect resolution refutations 
proof lemma       let p planning task   variable domain abstraction 
applied  combines two persistently mutex facts p p  single fact p 
brevity  let g denote p g p   define g   graph obtained unifying p
   

fifriends foes  planning satisfiability abstract cnf encodings

p  fact vertices fact layer g single vertex p layer  similarly
noop p  noop p    vertices action layers  finally  let g denote subgraph
p g p   induced vertices g     show g abstracted planning
graph sense similar definition     
begin arguing action pair  a  a    mutex p   mutex
p  see this  observe way  a  a    become mutex per requires 
w l o g   p  p del  a  pre a  p  pre a    add  a     suppose sake
contradiction  a  a    already mutex p  particular  means
p   del  a    p mutex fact pre a     this  however  implies
 noop p   a    mutex p fact pair  p  p    mutex next layer
p g p   contradiction p p  persistently mutex  follows edges
ea mutex g subset g 
since g   p initial facts  argument implies actions
facts available layer g   available layer p g p    particular 
g   construction  exactly set vertices g     further  since variable
domain abstraction  edges eadd epre g   g exactly same 
define     u  proof lemma        cnf encoding  a 
planning graph g   clauses corresponding actions facts
g trivially satisfied   call remaining clauses   surviving clauses
before 
observation edges ea mutex g g  surviving mutex clauses
  mutex clauses   surviving precondition goal clauses involving
p appear unchanged   since considering variable domain abstraction 
actions achieving p g precisely actions achieving either p p  g  hence 
surviving precondition goal clauses   involving p contain sub clause
precondition goal clause itself  follows proposition     rc  
rc    
proof proposition       example planning task  denoted p  works
encoding  c  encoding  d   let denote variable domain abstraction applied 
example uses following six facts  facts p p    glued together  
goal facts g  g    helper facts x  y  based facts  task p defined
follows 
initial state  p   goal  g    g   
action set containing five actions 
getx     p    x    p   
gety       y     
getg      x    g    p      x   
getg      p  y    g      p   
getp     p      p    p     
plan length bound    makes problem infeasible  shortest  parallel 
plan requires   steps  h getx  gety    getg      getp    getg   i  observe pairs
actionsexcept  getg    getg    pair involves getydirectly interfere
   

fidomshlak  hoffmann    sabharwal

therefore mutex  p g p   get following fact action sets
step   
f        p   a       noop p   getx  gety 
f        p  x  y   a       noop p   noop x   noop y   getx  gety  getg    getg   
f        p  x  y  g    g    p   
easy verify  iteratively  that  p g p   p x mutex f      p x
mutex f      p p  mutex f      x p  mutex f      mutexes
get f      planning graph reaches fixpoint  particular 
getg  getg  always  indirectly  mutex preconditions x p
persistently mutex  variable domain abstraction glue p p    converting
conflict getg  getg  direct interference  thereby allowing shorter
resolution refutation 
consider encoding  c  p g p   contains two goal clauses   getg      
 getg        clauses clearly must used resolution refutation formula  possible achieve goal individually within given time bound 
together  hence  shortest refutation must involve least two steps 
argue shortest refutation achieved abstracted task p
p itself 
p   get fact action sets planning graph  except f      
 p  x  y  g    g     i e   p  course present  a    a    contain getp
acts similarly noop p   corresponding encoding  c  consists exactly
clauses  plus clauses noop p  mirrored getp   except
get additional clause  getg       getg        mutex clauses arises
getg  interferes directly getg   rather indirectly incompatible preconditions   getg  adds p instead p    p deleted getg    yields
trivial two step  tree like  resolution proof p   using two goal clauses mutex
clause  namely  resolve second goal clause mutex clause deriving  getg       
resolve clause first goal clause   hand  original
task p  getg  getg  marked mutex layer a     dont directly
interfere  therefore  corresponding mutex clause immediately available 
resolution proof takes two steps must reason involve x 
encoding  d  works similarly  lets us derive new mutex clause discussed
above  goal clauses case simply  g        g        these  using
two corresponding effect clauses  derive two goal clauses encoding  c  two
steps  here  two step refutation discussed derives empty clause  thus 
four step resolution refutation p encoding  d   similarly small
resolution refutation p itself  refutation must  mentioned earlier 
reason x figure getg      getg      cannot true 
proof theorem       construct family strips tasks whose cnf encodings
similar pigeon hole problem formula php i   well known
resolution proof php i  must size exponential  haken         concretely 
php i  unsatisfiable formula encoding fact way assign    
   

fifriends foes  planning satisfiability abstract cnf encodings

pigeons holes pigeon assigned least one hole hole gets
one pigeon  formula i i      variables xp h p                   h
            i   pigeon p  pigeon clause  xp     xp             xp n    pair
pigeons  p  q  hole h  hole clause  xp h   xq h   
pigeon hole planning task pp hp  i  defined follows  pigeon p 
fact assigned  p   hole h  fact free h   initial state contains free
facts assigned facts  goal state contains i   assigned facts  available
actions  other noops  put p  h   puts pigeon p free hole h 
h longer remains free  formally  put p  h      free h     assigned  p     free h    
plan length bound b i  set   
consider one four encoding methods  a  d   let  i  encoding
pp hp  i   restrict  i  setting noop variables false  real restrictive
implication terms planning since plan length bound   none goal facts
available time step    action only encodings  a   c   identifying
action variables put p  h  php i  variables xp h immediately yields precisely
clauses php i   goal clauses  i  become pigeon clauses php i 
action mutex clauses become hole clauses  action fact encodings  b   d  
fix free fact variables time step   well assigned fact variables time step  
true  identify put p  h  action variables xp h   yields precisely
clauses php i   follows resolution hardness php i  proposition    
resolution proof fact planning task pp hp  i  plan
length   must require size exponential i 
claim follows planning task p    i  consists combination two
disconnected pigeon hole planning sub tasks  pp hp  i  pp hp      two separate sets
pigeon hole objects  goal p    i  naturally defined follows  put first
set     pigeons first set holes put second set two pigeons
second set holes  which consists single hole   overall cnf encoding
   i  p    i  logical conjunction encodings  i       on disjoint sets
variables  pp hp  i  pp hp      observe    i  proved unsatisfiable
proving unsatisfiability either two pigeon hole problems  particular 
constant size resolution refutation    i  involves refuting     component 
hand  argue listed abstractions make one hole
component p    i  trivially satisfiable  resolution refutation abstracted
task must resort proof unsatisfiability i hole component  i  p    i  
shown requires exponential size  hence single example p    i  serves show
claim combinations abstraction method cnf encoding 
easily verified pp hp     becomes solvable ignoring precondition
free    put       put        put pigeons single hole 
happens ignoring delete effect free    put       put       when
ignoring goal assigned      inserting assigned     initial state 
completely removing assigned      one hole component p    i  requires assign
one pigeon  course possible  finally  variable domain abstraction  note
assigned     assigned     persistently mutex pp hp     actions
achieving put       put        respectively  according definition     
hence replace assigned     assigned      resulting planning task 
   

fidomshlak  hoffmann    sabharwal

single goal assigned     achieved   step by  example  put       action 
concludes argument 
proof proposition       first consider removal duplicate actions  example planning task  denoted p     works four encodings  p   defined follows 
fact set  r    r    g    g    g   
initial state  r    r     goal  g    g    g   
action set containing seven actions 
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
help     g    g      g       
planning task  actions applicable initial state consume one
two resources r  r    actions achieves one goals  pair
goals reached  three them  solution perform two steps 
second help action serves accomplish g    set plan length
bound   
planning graph p g p     step   mutex relations direct
mutexes actions competing resource  hence  encoding  a  identical
encoding  c   encoding  b  identical encoding  d   properties clearly
hold planning task p p   except additional action     
identical     
consider encoding  a  p     goal clauses                                    
                  clauses mutex clauses form  i j  k  
difficult verify shortest resolution refutation involves    steps  one
derivation proceeds via deriving                                                        
              derived  sequence    steps involving resolution
one mutex clause  p  thing changes clause
                           instead                   plus additional mutex clauses  now 
obviously every resolution refutation must resolve three goal clauses  end
empty clause  hence additionally need get rid literal           clearly 
way resolve literal away additional step involving
one new mutex clauses  hence shortest possible resolution refutation
   steps 
encoding  b   resolution proofs first need make three steps resolving goal
clauses  g         g         g       respective effect clauses  g                       
 g                         g                        thereafter  matters
before 
show claim removal redundant add effects  slightly modify example 
define p   follows 
   

fifriends foes  planning satisfiability abstract cnf encodings

fact set  r    r    g    g    g    x 
initial state  r    r     goal  g    g    g   
action set containing eight actions 
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
help      g    g      x     
help      x    g       
task  single help action replaced two help actions need
applied consecutively  set plan length bound    before  planning graph
p g p     mutex relations direct mutexes actions competing
resource  encodings  a   c   b   d  respectively identical 
properties clearly hold planning task p p   except help 
additional add effect g   
consider encoding  a  p     goal clauses                  noop g                 
        noop g                          noop g         refuting involves showing
three goals cannot achieved step    step    combination
two  refutation needs resolve three clauses  before  p get
additional literal first clause                   help    noop g        
clearly  getting rid additional literal involves least one resolution step 
encoding  b   matters essentially except first need resolve goal
fact clauses respective effect clauses 

references
ball  t   majumdar  r   millstein  t     rajamani  s          automatic predicate abstraction c programs  pldi      programming language design implementation  pp         
beame  p   kautz  h     sabharwal  a          towards understanding harnessing
potential clause learning  journal artificial intelligence research             
beck  c   hansen  e   nebel  b     rintanen  j   eds            proceedings   th
international conference automated planning scheduling  icaps      aaai
press 
blum  a     furst  m          fast planning planning graph analysis  artificial
intelligence                   
blum  a  l     furst  m  l          fast planning planning graph analysis 
mellish  s   ed    proceedings   th international joint conference artificial
intelligence  ijcai      pp            montreal  canada  morgan kaufmann 
   

fidomshlak  hoffmann    sabharwal

boddy  m   fox  m     thiebaux  s   eds            proceedings   th international
conference automated planning scheduling  icaps      aaai press 
bonet  b     geffner  h          planning heuristic search  artificial intelligence        
        
bonet  b     geffner  h          heuristics planning penalties rewards formulated logic computed circuits  artificial intelligence              
         
brafman  r          reachability  relevance  resolution planning satisfiability approach  journal artificial intelligence research          
chaki  s   clarke  e   groce  a   jha  s     veith  h          modular verification software
components c  icse      int  conf  software engineering  pp         
chen  y   huang  r   xing  z     zhang  w          long distance mutual exclusion
planning  artificial intelligence                  
clarke  e  m   biere  a   raimi  r     zhu  y          bounded model checking using
satisfiability solving  formal methods system design              
clarke  e  m   grumberg  o   jha  s   lu  y     veith  h          counterexample guided
abstraction refinement symbolic model checking  journal association
computing machinery                 
davis  m   logemann  g     loveland  d          machine program theorem proving 
communications acm                
davis  m     putnam  h          computing procedure quantification theory  journal
association computing machinery                
edelkamp  s          planning pattern databases  cesta  a     borrajo  d   eds   
recent advances ai planning   th european conference planning  ecp    
pp        toledo  spain  springer verlag 
edelkamp  s          promela planning  ball  t     rajamani  s   eds    proceedings
  th international spin workshop model checking software  spin     
pp          portland  or  springer verlag 
edelkamp  s     helmert  m          exhibiting knowledge planning problems minimize state encoding length  biundo  s     fox  m   eds    recent advances ai
planning   th european conference planning  ecp     lecture notes artificial
intelligence  pp          durham  uk  springer verlag 
ernst  m   millstein  t     weld  d          automatic sat compilation planning problems  pollack  m   ed    proceedings   th international joint conference
artificial intelligence  ijcai      pp            nagoya  japan  morgan kaufmann 
fikes  r  e     nilsson  n  j          strips  new approach application theorem
proving problem solving  artificial intelligence                 
gerevini  a   saetti  a     serina  i          planning stochastic local search
temporal action graphs  journal artificial intelligence research             
   

fifriends foes  planning satisfiability abstract cnf encodings

graf  s     sadi  h          construction abstract state graphs pvs  cav     
computer aided verification  pp       
gupta  a     strichman  o          abstraction refinement bounded model checking 
etessami  k     rajamani  s   eds    proceedings   th international conference
computer aided verification  cav     lecture notes computer science  pp 
        edinburgh  uk  springer verlag 
haken  a          intractability resolution  theoretical computer science         
    
haslum  p     geffner  h          admissible heuristics optimal planning  chien  s  
kambhampati  r     knoblock  c   eds    proceedings  th international conference artificial intelligence planning systems  aips      pp          breckenridge  co  aaai press  menlo park 
haslum  p   botea  a   helmert  m   bonet  b     koenig  s          domain independent
construction pattern database heuristics cost optimal planning  proceedings
twenty second aaai conference artificial intelligence  aaai        pp 
          aaai press 
helmert  m     mattmuller  r          accuracy admissible heuristic functions selected planning domains  proceedings   rd aaai conference artificial
intelligence  pp          chicago  il  aaai press 
helmert  m   haslum  p     hoffmann  j          flexible abstraction heuristics optimal
sequential planning   boddy et al   boddy  fox    thiebaux         pp         
henzinger  t   jhala  r   majumdar  r     mcmillan  k          abstractions proofs 
popl      principles programming languages  pp         
hernadvolgyi  i     holte  r          psvn  vector representation production systems 
tech  rep           university ottawa 
hoffmann  j     edelkamp  s          deterministic part ipc    overview  journal
artificial intelligence research             
hoffmann  j     nebel  b          planning system  fast plan generation
heuristic search  journal artificial intelligence research             
hoffmann  j          ignoring delete lists works  local search topology planning
benchmarks  journal artificial intelligence research             
hoffmann  j   gomes  c     selman  b          structure problem hardness  goal asymmetry dpll proofs sat based planning  logical methods computer science 
        
hoffmann  j   sabharwal  a     domshlak  c          friends foes  ai planning
perspective abstraction search   long    smith  long   smith         pp 
       
katz  m     domshlak  c          structural pattern heuristics via fork decomposition  
beck et al   beck  hansen  nebel    rintanen         pp         
   

fidomshlak  hoffmann    sabharwal

kautz  h     selman  b          unifying sat based graph based planning  pollack  m   ed    proceedings   th international joint conference artificial
intelligence  ijcai      pp          stockholm  sweden  morgan kaufmann 
kautz  h          satplan    planning satisfiability  edelkamp  s   hoffmann 
j   littman  m     younes  h   eds    proceedings  th international planning
competition  ipc      whistler  bc  canada 
kautz  h   selman  b     hoffmann  j          satplan  planning satisfiability 
gerevini  a   dimopoulos  y   haslum  p   saetti  a   bonet  b     givan  b   eds   
proceedings  th international planning competition  ipc      ambleside  uk 
kautz  h  a   mcallester  d     selman  b          encoding plans propositional logic 
aiello  l  c   doyle  j     shapiro  s   eds    principles knowledge representation
reasoning  proceedings  th international conference  kr      pp         
cambridge  ma  morgan kaufmann 
kautz  h  a     selman  b          planning satisfiability  neumann  b   ed   
proceedings   th european conference artificial intelligence  ecai     
pp          vienna  austria  wiley 
kautz  h  a     selman  b          pushing envelope  planning  propositional logic 
stochastic search  proceedings   th national conference american
association artificial intelligence  aaai      pp            portland  or  mit
press 
knoblock  c  a          learning abstraction hierarchies problem solving  proceedings
 th national conference american association artificial intelligence
 aaai      pp          boston  ma  mit press 
koehler  j   nebel  b   hoffmann  j     dimopoulos  y          extending planning graphs
adl subset   steel    alami  steel   alami         pp         
koehler  j     hoffmann  j          reasonable forced goal orderings use
agenda driven planning algorithm  journal artificial intelligence research 
           
long  d   kautz  h  a   selman  b   bonet  b   geffner  h   koehler  j   brenner  m  
hoffmann  j   rittinger  f   anderson  c  r   weld  d  s   smith  d  e     fox  m 
        aips    planning competition  ai magazine               
long  d     smith  s   eds     icaps            proceedings   th international conference automated planning scheduling  icaps      ambleside  uk  morgan
kaufmann 
mcdermott  d          using regression match graphs control search planning  artificial intelligence                    
meuleau  n   brafman  r     benazera  e          stochastic over subscription planning
using hierarchies mdps   long    smith  long   smith         pp         
nebel  b   dimopoulos  y     koehler  j          ignoring irrelevant facts operators
plan generation   steel    alami  steel   alami         pp         
   

fifriends foes  planning satisfiability abstract cnf encodings

prasad  m  r   biere  a     gupta  a          survey recent advances sat based
formal verification  international journal software tools technlogy transfer 
              
ray  k     ginsberg  m  l          complexity optimal planning efficient
method finding solutions   beck et al   beck et al          pp         
rintanen  j          evaluation strategies planning satisfiability  saitta  l   ed   
proceedings   th european conference artificial intelligence  ecai      pp 
        valencia  spain  wiley 
rintanen  j          planning graphs propositional clause learning  brewka  g    
doherty  p   eds    principles knowledge representation reasoning  proceedings   th international conference  kr      pp          sydney  australia 
aaai press 
rintanen  j   heljanko  k     niemela  i          planning satisfiability  parallel plans
algorithms plan search  artificial intelligence  artificial intelligence              
         
robinson  j  a          machine oriented logic based resolution principle  journal
association computing machinery               
robinson  n   gretton  c   pham  d  n     sattar  a          compact efficient sat
encoding planning   beck et al   beck et al          pp         
sacerdoti  e          planning hierarchy abstraction spaces  proceedings
 rd international joint conference artificial intelligence  ijcai      pp         
stanford  ca  william kaufmann 
sanchez  r     kambhampati  s          planning graph heuristics selecting objectives over subscription planning problems  biundo  s   myers  k     rajan  k 
 eds    proceedings   th international conference automated planning
scheduling  icaps      pp          monterey  ca  usa  morgan kaufmann 
steel  s     alami  r   eds            recent advances ai planning   th european conference planning  ecp     vol       lecture notes artificial intelligence 
toulouse  france  springer verlag 
streeter  m     smith  s          using decision procedures efficiently optimization  
boddy et al   boddy et al          pp         

   


