journal of artificial intelligence research                  

submitted        published      

friends or foes  on planning as satisfiability
and abstract cnf encodings
carmel domshlak

dcarmel ie technion ac il

technion  israel institute of technology 
haifa  israel

jorg hoffmann

joerg hoffmann inria fr

inria 
nancy  france

ashish sabharwal

sabhar cs cornell edu

cornell university 
ithaca  ny  usa

abstract
planning as satisfiability  as implemented in  for instance  the satplan tool  is a
highly competitive method for finding parallel step optimal plans  a bottleneck in this
approach is to prove the absence of plans of a certain length  specifically  if the optimal plan
has n steps  then it is typically very costly to prove that there is no plan of length n   we
pursue the idea of leading this proof within solution length preserving abstractions  overapproximations  of the original planning task  this is promising because the abstraction
may have a much smaller state space  related methods are highly successful in model
checking  in particular  we design a novel abstraction technique based on which one can  in
several widely used planning benchmarks  construct abstractions that have exponentially
smaller state spaces while preserving the length of an optimal plan 
surprisingly  the idea turns out to appear quite hopeless in the context of planning as
satisfiability  evaluating our idea empirically  we run experiments on almost all benchmarks
of the international planning competitions up to ipc       and find that even hand made
abstractions do not tend to improve the performance of satplan  exploring these findings
from a theoretical point of view  we identify an interesting phenomenon that may cause
this behavior  we compare various planning graph based cnf encodings  of the original
planning task with the cnf encodings  of the abstracted planning task  we prove that 
in many cases  the shortest resolution refutation for  can never be shorter than that for  
this suggests a fundamental weakness of the approach  and motivates further investigation
of the interplay between declarative transition systems  over approximating abstractions 
and sat encodings 

   introduction
the areas of model checking and ai planning are well known to be closely related as
they both develop tools for automatic behavior analysis of large scale  declaratively specified transition systems  in particular  both in planning and in model checking of safety
propertieschecking reachability of non temporal formulasproblems are given by a description of a transition system  by an initial system state  and by a target condition  a
solution for such a problem corresponds to a legal path of transitions bringing the system
from the initial state to a state satisfying the target condition 
c
    
ai access foundation  all rights reserved 

fidomshlak  hoffmann    sabharwal

for a model checking problem  a solution corresponds to an error path in the system 
that is  to an unwanted system behavior  proving absence of such error paths is the ultimate
goal of system verification  and thus the traditional focus of the field is exactly on that 
besides clever symbolic representations of the state space  the key technique to accomplish
this ambitious task is abstraction  system abstraction corresponds to an over approximation
of the considered transition system  and thus abstraction preserves all the transitions of the
original system  hence  if the abstract transition system does not contain a solution  then
neither does the original system  the key to success in model checking is that  in many cases 
one can prove the absence of solutions in rather coarse abstractions with a comparatively
small state space  techniques of this kind have been explored in depth for a long time 
arguably its most wide spread instance in model checking is predicate abstraction  graf
  sadi         where system states form equivalence classes defined in terms of the truth
values of a number of expressions  the predicates   such as linear expressions over integer
system variables  predicates can be learned by analyzing spurious error paths in too coarse
abstractions  clarke  grumberg  jha  lu    veith         methods of this kind have been
extremely successful in the verification of temporal safety properties  e g   ball  majumdar 
millstein    rajamani        chaki  clarke  groce  jha    veith        henzinger  jhala 
majumdar    mcmillan        
in contrast to system verification  the focus in ai planning is on finding solutions in
instances that are assumed to be solvable  in particular  in optimizing planning  the task
is to find a solution that optimizes a certain criterion such as  the focus of our analysis
here  the sequential parallel length of the solution path  unlike in general planning where
any solution is good enough  the main bottleneck in length optimizing planning is always
to prove the absence of solutions of a certain length  in particular  if the optimal plan has
n steps  then the hardest bit is typically to prove that there is no plan of length n    
note that this is where the plan is actually proved to be optimal  and no length optimizing
planner can avoid constructing this proof  no matter what computational techniques it is
based on 
our agenda in this research is to apply the above idea from model checking to lengthoptimizing planning  we lead the optimality proofnon existence of a plan of length n 
within an abstraction  in particular  our focus is on the interplay between abstraction and
proving optimality in parallel step optimal planning as satisfiability  this approach was
originally proposed by kautz and selman         who later developed the satplan tool
 kautz   selman        kautz        kautz  selman    hoffmann         satplan
performs an iteration of satisfiability tests on cnf formulas b encoding the existence of a
parallel plan of length at most b  where b starts from   and is increased incrementally  if
n is the first satisfiable formula  then n equals the length of an optimal parallel plan  and
hence satplan is a parallel optimal  or step optimal  planner  in that class of planners 
satplan is highly competitive  in particular  satplan won  st prizes for optimal
planners in the international planning competition  ipc   namely in ipc       kautz 
      hoffmann   edelkamp        and in ipc       kautz et al          one property of
the cnf encodings employed by satplan that plays a key role in our analysis later on
is that these are based on the planning graph structure  blum   furst              
of course  our objective closely relates to the many approaches developed in planning
for computing lower bounds based on over approximations   e g   haslum   geffner       
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

edelkamp        haslum  botea  helmert  bonet    koenig        helmert  haslum   
hoffmann        katz   domshlak        bonet   geffner         the key difference 
however  is our focus on exact lower bounds  that is  the attempt to actually prove optimality
within the abstraction  if we want to be able to prove optimality within the abstraction 
then the abstraction must be what we term solution length preserving  the abstraction must
not introduce any solutions shorter than the optimal solution for the original problem  if
the lower bound for step optimal planning is not exact  then there will be no support for
satplans iteration n     which constitutes the main bottleneck 
in what follows  we briefly explain our initial motivation behind this work  and we
summarize our empirical and theoretical results 
    initial motivation
it would of course be interesting to explore whether predicate abstraction can be applied
to planning  indeed  that had been our initial idea  however  while our discussions of
this idea lead to nowhere   we instead made a different discovery  planning state spaces
can often be dramatically reduced  without introducing any shorter solutions  based on an
abstraction technique that we call variable domain abstraction  that technique essentially
adapts the work by hernadvolgyi and holte        to the propositional strips formalism 
we abstract the strips task by not distinguishing between certain values of the multiplevalued variables underlying the strips encoding  that is  if p and q are propositions
corresponding to non distinguished values  the abstracted strips task acts as if p and q
were the same  note that this generalizes the abstraction used by edelkamp        which 
for each multi valued variable  either abstracts it away completely or does not abstract it
at all  see the details in section   
the first example where we noticed the compression power of variable domain abstraction is the classical logistics domain  in this domain  packages must be transported within
cities using trucks and between cities using airplanes  actions load unload packages  and
move vehicles  importantly  there are no constraints on  either of  vehicle capacities  fuel 
or travel links  as a consequence  if a package p starts off in city a and has its destination in
city b  then all other cities c    a b are completely irrelevant to p  that is  one can choose
an arbitrary location x in such a city c  and replace all facts of the form at p l   where l is
a location outside a and b  with at p x   also  in p t   where t is a truck outside a and b 
can be replaced with at p x   one can completely abstract away the positions of packages
that have no destination  and some other minor optimizations are possible  this way we
lose many distinctions between different positions of objectswithout introducing a shorter
solution  an optimal plan will not rely on storing a package p in a city other than ps origin
or destination  the state space reduction is dramatic  the abstracted state space contains
at least    c      s     p states less  where c  s  and p respectively are the number of
cities  the city size  number of locations in each city   and the number of packages  similar
   we are still skeptical about the prospects  software artifacts  rigid control structure  numeric expressions
essential for the flow of control  have a rather different nature than planning problems  loose control
structure  numeric expressions non existent or mostly used to encode resource consumption   for example  a major advantage of predicate abstraction is that it can capture loop invariantsa great feature 
but seemingly rather irrelevant to plan generation 

   

fidomshlak  hoffmann    sabharwal

abstractions can be made  and similar state space reductions can be obtained  in other ipc
domains such as zenotravel  blocksworld  depots  satellite  and rovers  see section    
    summary of empirical results
in our first experiment  we have implemented our logistics specific abstraction by abstracting a set of planning tasks at the level of their description  modifying their actions and
their initial state  all these planning tasks feature   airplanes    locations in each city 
and   packages  the number of cities scales from   to     to account for the variance
in the hardness of individual instances  we took average values over   random instances
for each problem size  the increasing number of cities introduces an increasing amount of
irrelevance  which we measure by the percentage relfrac of facts considered relevant  not
abstracted   note here that the additional cities are irrelevant only for some of the individual packagesthey cant be removed completely from the task like standard irrelevance
detection mechanisms  e g  rifo  nebel  dimopoulos    koehler         would try to do 
we provided all the abstracted tasks to three optimizing planners  namely mips bdd
 edelkamp   helmert         ipp  hoffmann   nebel         and satplan     in order to examine how the abstraction affects different approaches to optimizing planning 
mips bdd searches blindly while exploiting a sophisticated symbolic representation of the
state space  ipp is equivalent to a parallel state space heuristic search with the widely
used h  heuristicthe parallel version of h  as originally introduced in graphplan  blum  
furst        haslum   geffner         thus  mips bdd  ipp  and satplan   represent
orthogonal approaches to optimizing planning   for each abstract task and planner  we
measured runtime  and compared the latter to the time taken by the same planner on the
original task  time out was set to      seconds  which was also used as the value for the
average computation if a time out occurred  we stopped evaluating a planner if it had  
time outs within the   instances of one size 
figure   a    b   and  c  respectively show our results for mips bdd  ipp  and satplan    comparing the performance on the original and abstracted tasks  it is apparent
from figure   that proving optimality within the abstraction dramatically improved the
performance of mips bdd  and significantly improved the performance of ipp  at the right
end of the scale  with    cities   mips bdd using the abstraction can find optimal sequential
plans almost as fast as satplan   can find step optimal plans  given that it is usually
much harder to find optimal sequential plans than optimal parallel plans  especially in highly
parallel domains such as logistics  this performance improvement is quite remarkable   in
addition to the reduced state space size  mips bdd benefits from the small state encoding 
which stops growing at some point because the maximal number of locations relevant to
each package is constant  
the above findings for mips bdd and ipp were in line with our original intuition and 
for satplan   as well  we expected to see much improved runtime behavior within the
abstraction  to our surprise  we did not  as appears in figure   c   the improvement
obtained for satplan   by proving optimality within the abstraction was hardly dis   satplan   is the version of satplan that competed in the      international planning competition 
   importantly  mips bdd is sequentially optimal while satplan   and ipp are step optimal  hence
one should not compare the performance of those planners directly  and in particular this is not our
purpose here  we focus on how each of the planners reacts to the abstraction 

   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

     

   

mips bdd abstract
mips bdd real
relfrac

     

    

  

   

ipp abstract
ipp real
relfrac

  

  

    

  

  
   

  

  

   

  

  
  

  

  

  

  

  
 

  

  

 

  

  
   

  

 
 

 

 

 

 

 

 

 

 

  

  

  

  

   

  

 
 

 

 

 

 

 

 a 

 

 

 

  

  

  

  

  

 b 
     

   

satplan abstract
satplan real
relfrac

  

    

  
  

   

  
  

  

  
  

 

  
  

   

 
 

 

 

 

 

 

 

 

 

  

  

  

  

  

 c 

figure    runtime performance of  a  mips   b  ipp  and  c  satplan    with  abstract  and without  real  our hand made variable domain abstraction  in
logistics instances explicitly scaled to increase the amount of irrelevance  horizontal axis scales the number of cities  left vertical axis shows total runtime in
seconds  right vertical axis shows the percentage relfrac of relevant facts 

cernible  at the right end of the scale  abstraction yields a humble speed up factor of     
that is particularly insignificant since this speed up is obtained at the drastically small
relfrac value of    in the ipc      logistics benchmarks  relfrac is     on average 
the latter corresponds to   cities in figure    where satplan   has a slight advantage
on the original tasks 
to investigate the above more broadly  we conducted experiments in almost all strips
domains used in all international planning competitions  ipc  up to ipc       in many
cases  we tailored the abstraction of the domain by hand  the results of this exhaustive
evaluation  discussed in detail in section    do not significantly depart from those for
the logistics specific abstraction above  for mips bdd we almost consistently obtained a
significant improvement  for ipp the improvements happened only rarely  and typically
these were not substantial   while ipp is improved in figure    note that  at the ipc   

fidomshlak  hoffmann    sabharwal

average relfrac of      the improvement is not yet strong   finally  for satplan    we
hardly ever obtained an improvement 
what causes the difference in profiting from abstraction between these three different
planning techniques  an intuitive interpretation of our results is that the informedness of
the abstraction must compete with the informedness of the search itself  in other words  the
better the planner is at exploiting the structure of a particular example  the more difficult it
is for the abstraction to exploit structure that is not already being exploited  this intuition
is in good correspondence with the logistics results in figure    while optimizing exactly the
same measure  on the original examples  satplan   is faster than ipp  while the inverse
relation holds regarding which planner profits more from the abstraction  that said  such
intuitive interpretations of our results are  at this point  mere speculation  it is left open for
future research to determine more accurately what precisely causes the difference  herein 
we concentrate only on planning as satisfiability  and identify a fundamental weakness of
this approach with respect to profiting from abstraction 
    summary of theoretical results
intrigued by our results for satplan     we wondered what kind of effect an abstraction
actually has on a cnf encoding of the planning task formulated as a boolean satisfiability
problem instance  recall here that our abstractions are over approximations  that is  any
action sequence applicable in the original task is applicable in the abstract task  and any
plan in the original task is a plan in the abstract task  so  intuitively  the abstract task
is more generous than the original task  with this in mind  consider the cnf formula
n  encoding the existence of a plan one step shorter than the optimal plan  and consider
the same formula  n    generated for the abstract task  we need to prove that n  is
unsatisfiable   note that n  is  in fact  unsatisfiable when  is a solution length preserving
abstraction   intuitively  the more constrained a formula is  the easier it is to lead such a
proof  but n  is more generous  and hence less constrained  than n    does this mean
that it is actually harder to refute n  than to refute n   
for some abstraction methods  it is in fact trivial to see that the answer to that question
is yes  say we abstract n  by ignoring some of its clauses  n  is then a sub formula
of n    immediately implying that any resolution refutation for n  is also a resolution
refutation for n    in particular  the shortest possible refutation cannot be shorter for
n    a similar situation sometimes occurs in the interplay between abstractions and cnf
encodings of planning problems  for instance  suppose we abstract by ignoring a subset
of the goals  in most cnf encodings of planning  and in particular in the planning graph
based cnf encodings  kautz   selman        underlying satplan  each goal fact yields
one clause in the cnf  hence  with a goal ignoring abstraction  n  is a sub formula of
n    just as above 
a more complex example would correspond to abstraction by ignoring preconditions or
delete effects  in the encodings used by satplan  one or several clauses related to the
ignored precondition delete effect disappear  however  the cnf changes also in other ways
because  with one precondition delete effect less  more actions and facts become possible
at later time steps  intuitively  those additional actions and facts do not help proving
   translation  deeply frustrated by our results for satplan          

   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

unsatisfiability of n    the formal proof of this intuitive statement  however  is less obvious
than the one for the goal ignoring abstraction above  matters are most complicated  and
much less intuitive  for edelkamps        abstraction and for variable domain abstraction 
where the changes made to the abstract task also affect the add effects of actions  recall
that variable domain abstraction is of special interest here because it is most likely to satisfy
the constraint of solution length preservation 
to investigate these issues in detail  one has to consider various possible combinations of
cnf encodings and abstraction methods  many different encodings of planning into sat
have been proposed  we focus on planning graph based encodings because those were used
in the satplan system  in all of its appearances in the international planning competitions  kautz   selman        long  kautz  selman  bonet  geffner  koehler  brenner 
hoffmann  rittinger  anderson  weld  smith    fox        kautz        kautz et al         
indeed  according to kautz and selman  kautz   selman        long et al          such
cnf encodingsin particular the mutex relations computed by graphplanare vital to
satplans performance  while recent results on more effective encodings may challenge
this assessment  rintanen  heljanko    niemela        chen  huang  xing    zhang       
robinson  gretton  pham    sattar         even so the graphplan based encodings are of
interest simply because they have been widely used during almost a decade  it remains of
course an important question whether and to what extent our results carry over to alternative cnf encodings  we discuss this issue in some depth when concluding the paper in
section   
we consider four different encodings  three of which have been used in some edition of
the ipc  the fourth encoding is considered for the sake of completeness  the encodings
differ in two parameters  whether they use only action variables  or action as well as fact
variables  and whether they include all planning graph mutexes between actions or only the
direct interferences   the latter is motivated by the fact that there is often an enormous
amount of action mutexes  seriously blowing up the size of the formula  
on the abstractions side  we focus on abstraction methods that can be formulated as
manipulating planning tasks at the language level  i e   modifying the tasks actions and or
initial goal states  many commonly used abstractions for propositional strips can be
formulated this way  we consider six such abstractions  namely     removing goals     
adding initial facts      removing preconditions      removing delete effects      edelkamps
       abstraction  removing entire facts   and     variable domain abstraction 
for all    combinations of cnf encoding and abstraction method  we prove that the
shortest possible resolution refutation can be exponentially longer for n  than for n   
for all    combinations involving abstractions other than variable domain abstraction  we
prove that the shortest possible resolution refutation cannot be shorter for n  than for
n    for abstraction      this is trivial as outlined above  for abstractions         the
proof exploits the fact that these abstractions lead to larger planning graphs containing
more actions and facts  for abstraction      this reasoning does not work because some
facts disappear from the planning graph  however  one can start by removing a fact from
the goal and all action preconditions  afterwards the fact is irrelevant and one can remove
it also from the initial state and action effects 
matters are most complicated for abstraction      that is  variable domain abstraction 
for the encoding with only action variables and full mutexes  we show that  as before 
   

fidomshlak  hoffmann    sabharwal

the shortest possible resolution refutation cannot be shorter for n  than for n    for
the encoding with only action variables and only direct action mutexes  we show that the
possible improvement is bounded from above by the effort it takes to recover the indirect
action mutexes  for the two encodings with both action and fact variables  it remains an
open question whether such bounds exist  
importantly  all our proofs are valid not only for general resolution  but also for many
of the known restricted variants of resolution  in particular for the tree like resolution refutations generated by dpll  davis   putnam        davis  logemann    loveland        
naturally  our proofs are not separate for each of the combinations  but rather exploit and
exhibit some of their common features 
the practical significance of our theoretical results is  to some extent  debatable as
there is no direct connection between best case resolution refutation size and empirical
sat solver performance  even a very large refutation may be easy to find if it mostly
consists of unit resolutions  vice versa  just because a small refutation exists  that does not
mean the sat solver will find it  this notwithstanding  it appears unlikely that best case
resolution refutation size and practical sat solver performance are completely unrelated
 beyond the obvious lower bound   one example that indicates the opposite are planning
graph mutexes  mutexes do reduce the best case refutation size by doing some of the work
before the resolution is even invoked   in other words  sat solvers can exploit the mutexes
to prune their search trees more effectively  we are not aware of explicit empirical proof
that this tends to happen often  but there seems to be little doubt that it does  that is also
suggested explicitly by kautz and selman  kautz   selman        long et al         by
ways of explaining the improved performacce of their system when run on graphplan based
encodings 
an interesting situation arises in  all  our experiments  we use variable domain abstraction on the encoding with only action variables and only direct action mutexes  as
employed in satplans ipc   version   in this setting  resolution refutations can get
shorter in principle  although only by the effort it takes to recover the indirect action mutexes  further  we employ some trivial post abstraction simplification methods  such as
removing action duplicates  which  as we show  also have the potential to shorten resolution refutations  still  as reported above  there is no discernible empirical improvement 
the reason might be that the sat solver does not find the shorter refutations  or that such
shorter refutations do not actually appear on a significant scale  there is some evidence
indicating the latter  mutex recovery becomes necessary only in rather special situations 
where the abstraction turns an indirect mutex into a direct one  this will typically concern only a small fraction of the indirect mutexes  in addition  for both mutex recovery
and simplifications  in a well designed variable domain abstraction the affected actions will
typically be irrelevant anyway  for example  with our hand made logistics abstraction 
   the reason for complications is that answering this question requires determining  for planning graph
based encodings in general  whether fact variables are only syntactic sugar or may lead to more succinct
refutations  such a proof appears quite challenging  we say some more on this in section   
   general resolution can recover the mutexes effectively  c f  the related investigations by brafman       
and rintanen         it does not seem likely that the same is the case for tree like resolution  but to the
best of our knowledge this is not yet known 

   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

the effect of the potential improvements is limited to actions appearing only in redundant
plans  we get back to this in detail in section   
in our view  the theoretical results would be of potential importance even with no
evidence of empirical relevance  simply because they are quite surprising  after a moment
of thought  it is clear that resolution refutation does not become easier by ignoring goals 
however  variable domain abstraction in domains such as logistics deflates state spaces
immensely  up to a point where they have only a tiny fraction of their original size  before
performing this work  we would never have expected the best case refutation size to remain
the same 
the paper is organized as follows  section   discusses preliminaries  covering the employed notions of planning  planning graphs  propositional encodings  resolution  and abstraction methods  in particular  it formally defines variable domain abstraction  section  
summarizes our empirical results  section   presents our results regarding resolution refutations in abstract cnf encodings  related work is discussed during the text where appropriate  we conclude in section    appendix a contains most proofs  which are replaced
with brief proof sketches in the main body of the text  additional empirical data can be
found in an online appendix  see jair web page for this article  

   preliminaries
we begin with a discussion of various concepts needed in the rest of the paper  propositional
strips planning  planning graphs  propositional cnf encodings of planning problems 
resolution proofs of unsatisfiability  and abstraction methods used in planning  as a general
rule of notation  we will use variants of  p for planning tasks  f  a  and g for sets of facts 
actions  and goals  respectively   for abstractions  p g for planning graphs  and  for
propositional formulas and encodings 
    strips and planning graphs
classical planning is devoted to goal reachability analysis in state transition models with deterministic actions and complete information  such a model is a tuple m   hs  s    sg   a  i
where s is a finite set of states  s   s is the initial state  and sg  s is a set of alternative
goal states  a is a finite set of actions  and    s  a  s is a transition function  with
 s  a  specifying the state obtained by applying a in s  a solution  that is a plan  for a
state transition model is a sequence of actions a            am from a that generate a sequence
of states s            sm such that  for    i   m   si   ai       si     and sm  sg  
while ai planning targets large scale state transition models with huge numbers of
states  these models are assumed to be described in a concise manner via some intuitive
declarative language  here we use a propositional fragment of the strips language  fikes
  nilsson         for brevity  we will refer to this fragment as strips herein  informally 
a planning task or planning instance in strips consists of a set of propositional facts  some
of which hold initially and some of which must hold simultaneously at the end of the plan
execution  the state of the system at any time is defined by the set of propositional facts
that hold at that time  the task specifies a set of actions  each of which is defined by a
set of precondition facts  a set of facts that are added to the state  and a set of facts that
are removed from the state  if the action is taken  formally  a strips planning task is
   

fidomshlak  hoffmann    sabharwal

given by a quadruple p    p  a  i  g  with fact set p   initial state description i  p   goal
description g  p   and action set a where for every action a  a we have pre a   add  a  
and del  a   each of which is a subset of p   such a planning task defines a state transition
model m   hs  s    sg   a  i with the state space s    p   the initial state s    i  and for
each s  s  we have s  sg iff g  s  for each s  s  a s     a  a   pre a   s  are the
actions applicable in s  and for each a  a s   we have  s  a     s   del  a    add  a   here
we assume that the actions are reasonable in the sense that add  a   del  a      this is
satisfied in most known planning benchmarks  in particular it is satisfied in all benchmarks
used in our experiments  
many planning algorithms  including satplan  employ some form of approximate
reachability analysis  one of the primary tools for this purpose is the planning graph  first
introduced in the scope of the graphplan planner  blum   furst         for a length bound
b  the planning graph p g p  associated with p is a layered graph with two kinds of nodes 
fact nodes and action nodes  the layers alternate between fact layers f      f              f  b  
and action layers a     a             a b      with each pair of layers f  t   a t  forming a
time step t  the first vertex layer f     contains the initial state  a t  and f  t      for
   t   b are the action sets and fact sets  respectively  available at time step t and t     
more precisely  each a t  includes all actions a  a where pre a   f  t  and no pair of
facts p  p   pre a  is mutex in layer t  c f  below   further  a t  contains the standard noop
action for every fact in f  t    each f  t      contains the union of the add effects of all
actions in a t   obviously  we have a t   a t      and f  t   f  t       the goal facts g
label appropriate vertices in f  b   p g p  has four kinds of edges 
    epre  t   f  t   a t  connect the actions in a t  with their preconditions in f  t  
    eadd  t   a t   f  t      connect the actions in a t  with their add effects in f  t      
    ea mutex  t   a t   a t  capture a pair wise mutual exclusion relation between actions in a t   if  a t   a   t    ea mutex  t   then actions a and a  cannot be applied
simultaneously at time t 
    ef  mutex  t   f  t   f  t  capture a pair wise mutual exclusion relation between facts
in f  t   if  f  t   f    t    ef  mutex  t   then facts f and f   cannot hold together at time
t 
note that p g p  does not have explicit edges for the deletion effects of actions  these
effects are captured in the mutual exclusion relation  e g   if p  add  a     del  a     then
 a    a     ea mutex at all times   the mutex edges emutex   ea mutex  ef  mutex are
computed by an iterative calculation of interfering action and fact pairs  blum   furst 
       namely  two actions  directly  interfere if the effects of one contradict the effects
of the other  or if one deletes a precondition of the other  two actions have competing
   in the ipc      domain rovers  some operators add and delete the same artificial fact in order to prevent
their parallel application  we implement this restriction via duplicating the respective operators and
sequentializing original and duplicate via two artificial facts  similar fixes have been implemented in a
couple of other domains as well 
   for a fact p  p   the associated noop p  has no delete effects  and has  p  as both its preconditions and
add effects  these are dummy actions that simply propagate facts from one fact layer to the next 

   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

needs if they have mutex preconditions  combining these two scenarios together  we say
that two actions are mutex if they either  directly  interfere or have competing needs  in
a similar spirit  two facts are mutex if there is no non mutex pair of actions  in the graph
layer directly below  together achieving both facts  a variant that will be of interest is the
planning graph in which  after the iterative computation  ea mutex is reduced to contain only
the directly interfering actions  we will call this the reduced planning graph  and denote it
with p gred  p   the motivation for considering this is that  often  the reduced planning
graph results in much smaller sat encodings  we get back to this below 
    propositional encodings
we consider three cnf encodings used by  one or the other version of  satplan  as well
as a fourth encoding that fits naturally into the picture  each of the encodings takes as input
a planning task p with length bound b  and creates a formula in the standard conjunctive
normal form  cnf   the cnf formula is then solved by an off the shelf sat solver  this
process constitutes the basic step in a sat based approach to planning as implemented in
satplan  kautz   selman                     where one starts with b     and iteratively
increments b until the cnf becomes satisfiable for the first time  the plan corresponding
to the satisfying assignment is then a plan with minimal b  and is hence optimal in that
sense  
a cnf formula  is logically a conjunction  and  of clauses  where a clause is a disjunction  or  of literals  and a literal is a propositional  boolean  variable or its negation 
cnf formulas are often written as a set of clauses  and each clause written as a set of literals  the underlying logical conjunction and disjunction  respectively  being implicit  our
propositional encodings of bounded length planning tasks are specified in terms of various
kinds of clauses generated by the encoding method 
encoding  a  is constructed from p g p  and uses the propositional action variables
 a t       t   b  a  a t    for each goal fact g there is a goal clause of the form
 a   b              al  b       where a          al are the actions in a b     that add g 
similarly  for every a t  with t     and every p  pre a  we have a precondition clause
 a t   a   t              al  t       where a          al are the actions in a t     that add p 
finally  we have a mutex clause  a t   a   t   for every t and  a  a     ea mutex  t  
 note here that the dependence on the initial state is taken into account already in
terms of which actions are contained in the sets a t   and does not need to be stated
explicitly in the cnf  
encoding  b  is similar to  a  except that it uses variables  and appropriate clauses 
also for the facts  more specifically  in addition to the action variables  it has fact
variables  f  t       t  b  f  f  t    for each goal fact g  the goal clause is simply a
unit clause asserting g b   for t     and each fact f  t   we now have an effect clause
of the form  f  t   a   t              al  t       where a          al are the actions in a t    
that add f   for every a t  and every p  pre a  we have a precondition clause  which
   while all versions of satplan use this naive incremental update on b  it has been shown that there are
more clever strategies  exploiting the typical distribution of runtime over different values of b  rintanen 
      streeter   smith        

   

fidomshlak  hoffmann    sabharwal

takes the form  a t   p t    we have action mutex clauses  a t   a   t   for every
t and  a  a     ea mutex  t   and fact mutex clauses  f  t   f    t   for every t and
 f  f      ef  mutex  t   finally  for each fact f  f      we have an initial state clause
 f       these are not strictly necessary but are implemented in satplan which is
why we include them here  
encoding  c  is like  a  except that it is based on the reduced planning graph p gred  p  
so that mutex clauses are present only for action pairs whose preconditions and effects
interfere directly 
encoding  d  is like  b  except that  as in  c   it is based on p gred  p   with mutex
clauses only for action pairs whose preconditions and effects interfere directly  note 
however  that the fact mutexes are those of the full planning graph  p g p  
all these encodings are reasonable ways of turning a planning graph into a cnf formula  the encodings essentially underly the competition implementations of satplan 
we will detail this below  first  note that the different encodings have different benefits
and drawbacks  first  observe that the encodings are characterized by two decisions     
should we include all action mutexes from graphplan  or only the direct interferences     
should we include only action variables  or both action and fact variables  regarding     
the empirical observation that mutexes help was one of the major observations in the
design of satplan  then called blackbox   kautz   selman        long et al          in
particular in comparison to earlier encoding methods  kautz  mcallester    selman        
on the other hand  since mutexes talk about pairs of facts and actions  the encodings may
become quite largethere will be one clause for every pair of mutex actions or mutex facts 
this is particularly critical for actions  of which in many planning benchmarks there are
thousands  compared to at most a few hundred facts   indeed  it turns out that action mutexes often consume critically large amounts of memory  it is not uncommon to have cnf
formulas with millions of clauses  most of which are action mutexes  kautz   selman       
kautz        kautz et al          this motivates encodings  c  and  d   as for question
     this does not make as much of a difference  empirically  in most planning benchmarks 
we consider this distinction only because it was used in some versions of satplan 
let us say a few words to clarify exactly how encodings  a  d  relate to the satplan
literature and implementations  due to the long history of satplan  as well as a few
imprecisions in the literature  this is a little complicated  our foremost reference is the
actual program code underlying satplan   and satplan    i e   the most recent
versions used in the      and      competitions  the encoding methods in these versions
were implemented by one of the authors of this paper  there are four different encoding
methods  action based  graphplan based  skinny action based  and skinny graphplan based 
the action based encoding is exactly  a   the graphplan based encoding is exactly  b   and
the skinny graphplan based encoding is exactly  d     the skinny action based encoding is
like  c  except that  to save some runtime  the planning graph implementation does not
propagate mutexes  after all  only direct interferences are present in the final encoding  
effectively computing a relaxed planning graph  hoffmann   nebel         we use a normal
    in the      version  the skinny graphplan based encoding did not feature fact mutexes  this is of no
consequence because that encoding was not used in the      competition 

   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

planning graph for  c  only for the sake of readabilitythe greater similarity to the other
encodings significantly simplifies the write up  and our theoretical results hold as stated
also for relaxed planning graphs 
how did the satplan encodings develop historically  how is this reflected in the literature  and which encodings were used in the competitions  we answer these questions to
the extent necessary for explaining encodings  a  d   the original paper on satplan
 kautz   selman        introduced rather different encodings  graphplan based encodings
with only direct action mutexes were introduced next  and observed to yield performance
comparable to graphplan itself  kautz   selman         subsequently  it was observed
that modern sat solvers profit from full  fact and action  mutex relations and actually
beat other planners  in several domains  kautz   selman           consequently  such
a graphlan based encoding  i e   our encoding  b   was used in the      and      competitions  long et al          prior to the      competition  the encoding methods were
re implemented  yielding the four methods explained above  the ipc   booklet paper on
satplan    kautz        describes these four encodings    the version run in the competition is the skinny action based encoding that is  for our theoretical results  equivalent
to encoding  c   when running the planner in ipc       it turned out that having full
fact mutexes helped in some domains  and so encoding  d  was used instead  kautz et al  
       we consider encoding  a  for the sake of completeness 
    resolution refutations
our theoretical results are with respect to the resolution proof system  robinson        
which forms the basis of most of the complete sat solvers around today  cf  beame  kautz 
  sabharwal         it is a sound and complete proof system  and has been studied extensively for theoretical and practical reasons  it works on cnf formulas and has only one
simple rule of inference  given clauses  a  x  and  b  x   one can derive the clause  a  b 
by resolving upon the variable x  here a and b are shorthands for arbitrary lists of literals 
note that the choice of clauses to resolve is arbitrary  as long as they share a variable  with
opposite signs  a resolution derivation  of a clause c from a formula  consists of a series
of applications of the resolution rule starting from the clauses in  such that one eventually
derives c  when c is the  unsatisfiable  empty clause       is called a resolution proof
 of unsatisfiability  or refutation of   the size of  is the number of applications of the
resolution rule in   when  is unsatisfiable  rc   denotes the resolution complexity of  
i e   the size of the smallest resolution proof of unsatisfiability of   we will be interested in
whether applying an abstraction to a planning task can convert its encoding into one that
has smaller resolution complexity 
a commonly studied sub class of  still sound and complete  resolution derivations is
that of tree like resolution derivations  where each derived clause is used at most once in
the whole derivation  the underlying graph structure of the proof is then a tree  other
    kautz and selman        cite graphplan based encodings from their earlier work  which used only action
mutexes   however  the blackbox program code includes functions that generate full mutexes  and kautz
and selman explicitly emphasize the importance of these mutexes 
    the paper is only an abstract and is a little imprecise in this description  initial state  goal  and fact
mutex clauses are not mentioned  the skinny action based encoding is stated to be identical to our
encoding  c   i e   based on a full planning graph rather than a relaxed planning graph 

   

fidomshlak  hoffmann    sabharwal

interesting sub classes of resolution include regular resolution  which is provably exponentially more powerful than tree like resolution and in which each variable is resolved upon
at most once in any path from the root to a leaf in the underlying proof graph  and ordered
resolution  where in addition variables respect a fixed ordering in any root to leaf path 
tree like resolution captures proofs of unsatisfiability generated by sat solvers that are
based on the dpll procedure  davis   putnam        davis et al         but dont employ so called clause learning techniques  the latter kind of sat solvers can be provably
exponentially more powerful than even regular resolution although still within the realm of
general resolution  beame et al         
we note that the arguments presented in this paper are for general  unrestricted  resolution  however  since most of aour constructions do not affect or rely on the structural
properties of the resolution refutations under consideration  the results hold as stated  except for a slight weakening in the case of lemma       for all known variants of resolution
for which setting variables to true or false or replacing one variable with another preserves
proof structure  these variants include tree like  dpll   regular  and ordered resolution 
we state a standard property of resolution proofs which we will use in our arguments 
pointing out that certain modifications  such as variable restrictions and shortening of
clauses  of a given formula do not cause proofs to become longer with general resolution
or any of its natural sub classes  including those mentioned above  let x be a variable of
 and y be true  false  or another  possibly negated  variable of   the variable restriction
x  y on  is a transformation that replaces x with y throughout   and simplifies the
resulting formula by removing all clauses containing true or a variable and its negation  and
by removing false or duplicate literals from clauses  in other words  a variable restriction
involves fixing the value of a variable or identifying it with another literal  and simplifying
the formula  if  is a sequence of variable restrictions on   then by   we denote the
outcome of applying  to  
the following proposition combines two basic facts together in a form that will be useful
for us      variable restrictions cannot increase the resolution complexity of a formula  and
    lengthening clauses and or removing clauses cannot decrease the resolution complexity
of a formula 
proposition      let  and  be cnf formulas  if there exists a sequence  of variable
restrictions on  such that every clause of    contains as a sub clause a clause of   then
rc    rc    
some explanation of this proposition and how we will use it is in order  the notation
used here is chosen to match the way we will eventually utilize this proposition in our
proofs  more on this below  the conditions in the proposition imply that one may obtain
 from  by applying the restriction    possibly throwing away some literals from some
clauses  and possibly adding new clauses  intuitively  each of these three modifications to
 can only reduce the number of solutions and cannot make it any harder to prove the
formula unsatisfiable  this property of resolution refutations of propositional formulas has
been previously used  at least indirectly  in various contexts  for completeness  we include
a proof in appendix a  based on folklore ideas from proof complexity literature  an
alternative proof  with a somewhat different notation  may also be found in the appendix
of a recent article by hoffmann  gomes  and selman        
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

the way we will use this proposition is the following   will be the cnf encoding of
an abstracted planning task   will be the encoding of the original planning task  and 
will be a carefully chosen restriction of  that will bring our focus to variables already
appearing in   proposition     will then imply that the original encoding is no harder to
refute  using resolution or its natural sub classes  than the abstracted encoding 
    abstraction in planning
abstraction methods of various kinds have been put to use in planning  often quite successfully  one line of work uses abstraction methods for problem decomposition  cf  sacerdoti 
      knoblock        koehler   hoffmann         to the best of our knowledge  our
approachexamining the abstract state space in order to prove the absence of solutions
has not been pursued before  the line of work most relevant to ours is the work on domainindependent heuristic functions  cf  mcdermott        bonet   geffner        hoffmann  
nebel        edelkamp        haslum et al         helmert et al         katz   domshlak 
       there  abstraction means over approximation of the state space  as in our work 
what differs is how the abstractions are used  of course  the kinds of over approximations
that are useful for either purpose can differ a lot  to use abstraction as we do in this
paper  one has to define over approximations that preserve  to a very large extent  the real
structure of the problem  in particular  our ideal goal is to find abstractions that preserve the length of an optimal solutionsomething one definitely wouldnt expect from the
abstraction underlying a heuristic function  since that has to be solved in every search state 
we briefly review some of the over approximation methods that have been used in
planning so far  we then formally introduce our novel one  variable domain abstraction  we
use the logistics domain as an illustrative example   
one wide spread over approximation method in planning is the   subset relaxation
underlying the computation made in a planning graph  blum   furst         which is generalized to an m subset relaxation by haslum and geffner         in a nutshell  one assumes
that achieving a set of facts is only as hard as achieving its hardest m subset  it is known
that  in most domains  including logistics  the   subset solution length  corresponding to
the length of a planning graph constructed up to the first fact layer containing no mutexes
between the goal facts  is typically strictly lower than the length of an optimal plan  for
m      on the other hand  computing m subset solution length is typically too costly  and
still  for no m   o  p    can one typically guarantee solution length preservation  helmert
  mattmuller        
a second wide spread over approximation method is ignoring delete lists  mcdermott 
      bonet   geffner         for this approximation  one simply removes  some of 
the negative effects of the actions  if all negative effects are removed  then the problem
becomes solvable in time linear in the instance size  the latter is the basis of the heuristic
functions used in many modern planners  cf  bonet   geffner        hoffmann   nebel 
      gerevini  saetti    serina         ignoring deletes is very likely to introduce shorter
solutions  for example  in the towers of hanoi problem  it leads to plans of length n instead
of  n     hoffmann         in logistics  if one ignores the deletes of moving actions then
    as stated  an open topic is to explore model checking abstractions  in particular predicate abstraction
 graf   sadi        clarke et al          instead of planning abstractions 

   

fidomshlak  hoffmann    sabharwal

the plans may get shorter because vehicles never have to move back in the abstraction 
interestingly  ignoring the deletes of load unload does not decrease plan length  since these
actions never have to be undone in an optimal plan  we use this observation in some of our
experiments 
a third abstraction was introduced by edelkamp        for his pattern database
heuristic  for this approximation  one completely removes some facts from the problem
description  notably facts corresponding to all values of some multi valued variables  if
enough facts are removed  the task becomes sufficiently simple  obviously  this approximation will hardly be solution length preserving  in logistics  if we remove  for example 
a fact at package  airport   then  in particular  package  can be loaded onto an airplane
at airport  without actually being there because that precondition is removed  an optimal
plan can now just make the package pop up anywhere 
a fourth abstraction  finally  involves removing some preconditions  sacerdoti       
and or goal facts  as with edelkamps abstraction  this cannot be expected to be solution
length preserving in interesting cases 
the above calls for a new abstraction method  which we designed following hernadvolgyi
and holte         considering strips like state transition systems with multiple valued
 instead of boolean  variables  they propose to reduce variable domains by not distinguishing between certain values  for example  if the content of a cell in the   puzzle can be in
 blank                        then that may be replaced with  blank            where                are
all mapped onto    our observation is that  in many planning benchmarks  this can be done
without introducing shorter plans  for example  in logistics it is unnecessary to distinguish
the positions of packages in irrelevant cities  therefore  we can replace the domain of at p  
 a    a    b    b    c    c             where a and b are the initial and goal cities of p and ai   bi        
are locations in cities a  b         with an abstract domain  a    a    b    b    c     in strips 
this amounts to replacing a set of irrelevant facts at p  l  with the single fact at p  c     we
now formalize this idea 
let persistently mutex denote the standard notion that two facts are mutex in the
fixpoint layer of a planning graph  typically  different values of a multiple valued variable 
definition      let p    p  a  i  g  be a strips planning task  p  p   p a pair of
persistently mutex facts such that  for all a  a  we have   p  p     del  a    pre a   then
  p      a  a  a    i    g   is called a variable domain abstraction of p  where  is
defined as follows 
   for a fact set f    f     f if p    f   otherwise   f      f    p       p  
   for an action a    pre  add   del     a      pre    add     del    if p    add   del   
otherwise   a      pre    add     del      p   
in words  definition     simply says that we replace p  with p  if p now appears both
in the add list and in the delete list of an action  we remove it from the delete list    this
situation will arise  for instance  if the action moves a package from one irrelevant position
    the reader may wonder why p remains in the add list  although by prerequisite p   pre   the reason
is that we distinguish between abstractions and simplifications  both change the planning task 
abstractions  but not simplifications  do so in a way that may alter the tasks semantics  however 
simplifications may as well affect resolution complexity  we will get back to this later in the paper 

   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

to another irrelevant position  after the operation  p is equivalent to what was originally
p  p    p is true after an abstracted action sequence if and only if p  p  is true after
the corresponding real action sequence  in particular  proposition     states that variable
domain abstraction is an over approximation in the usual sense 
proposition      let p    p  a  i  g  be a strips planning task  and let  p   
  p      a    a  a    i    g   be a variable domain abstraction of p  then  whenever
ha            an i is a plan for p  h a              an  i is a plan for  p  
proof  let m and m be the state models induced by p and  p   first  let us show
that  for each state s  m  and each action a  m  if a is applicable in s  then  i 
 a  is applicable in  s   and  ii  p    s    a   if and only if  p  p      s  a      
note that  since the abstraction  has no effect on facts other than  p  p      ii  implies
  s    a       s  a    thus  together   i  and  ii  imply that  iii  m is homomorphic
to m   finally  it is straightforward from definition     that  iv  the initial state in m
is  i   and that the goal states in m are exactly   s    s  sg    together   iii  and  iv 
imply the claim of proposition     
let a    pre  add   del    the applicability of  a  in  s  is straightforward  if p    pre 
then we have  pre    pre and  s  pre    spre  and otherwise  pre     pre  p     p 
and  s     s    p       p   in both cases  pre  s implies  pre    s   consider now the
sub claim  ii  on a case by case basis 
 p    p   add      p    p   del    we have p   add   a   and p   del   a    and thus
p    s    a   iff p   s  iff  p  p     s     iff  see assumption on del in the case 
 p  p      s  a      
 p    p   add       p    p   del    we have p  add   a   and p   del   a    and thus
p    s    a    on the other hand   p  p      s  a      also trivially holds here 
 p    p   add      p    p   del     we have p   add   a   and p  del   a    and thus
p     s    a    on the other hand  since p  p  are persistently mutex facts in p  and
 p    p   del    p    p   pre  we also have  p  p      s  a     
 p    p   add       p    p   del     we have p  add   a   and p   del   a    and thus
p    s    a    on the other hand  from add  del    and  p    p   add     we
immediately have  p  p      s  a      
this completes the proof of  ii  
arbitrarily coarse variable domain abstractions may be generated by iterating the application of definition      note that variable domain abstraction is a refinement of edelkamps
       abstractioninstead of acting as if the irrelevant positions could be totally ignored 
we do distinguish whether or not the package currently is at such a position  this makes
all the difference between preserving optimal solution length or not   
as hinted above  after variable domain abstraction we may be able to apply further
simplifications  a simplification  in our terminology  is similar to an abstraction in that it
    a topic for future work is to explore whether the refined abstraction can lead to better pattern database
heuristics for strips problems 

   

fidomshlak  hoffmann    sabharwal

manipulates a planning task at the language level  however  while abstractions may alter
the tasks semantics  simplifications do not  i e   simplifications do not introduce any new
transitions or goal states  concretely  we consider two simplifications  a planning task
p    p  a  i  g  has duplicate actions if there exist a  a   a so that pre a    pre a    
add  a    add  a     and del  a    del  a       the simplified planning task is like p except
that a  is removed  a planning task p    p  a  i  g  has irrelevant add effects if there
exists a  a so that pre a   add  a       the simplified planning task is like p except that
we remove pre a  from add  a  
obviously  duplicate actions and irrelevant add effects may arise as an outcome of variable domain abstraction  an example of the latter is an action moving a package from an
irrelevant location into an irrelevant truck  an example of the former are two actions loading
a package onto an airplane from distinct but irrelevant locations    in our implementation 
we have a simple post abstraction processing in which we perform all these simplifications 
as we shall see in section      the simplifications can lead to decreased resolution complexity  thereby offsetting our result that abstractions as such  in many cases  cannot  it
may seem a little artificial to distinguish abstractions and simplifications in this way  seeing
as many abstractions are bound to enable us to simplify  however  note that this distinction
only serves to identify the borderline between what can  and what cannot  reduce resolution
complexity  anyhow  as we shall see in the next section  abstraction does not tend to help
empirically with the performance of satplan even with post abstraction simplifications 

   empirical results
we have performed a broad empirical evaluation of the effect of abstractions on the efficiency
of optimizing planning algorithms  we mostly focus on variable domain abstraction  as in
definition      since it is clearly most promising for obtaining solution length preserving
abstractions 
section     explains the specific variable domain abstractions we employ in our experiments  section     explains the experimental setting and how we chose to present the huge
data set of the results  section     describes our experiments with variable domain abstraction in the ipc benchmarks  and section     discusses our results with domain specific
abstractions of hand made instances in certain benchmark domains where the amount of
irrelevance can be controlled  section     briefly summarizes our findings with abstraction
methods other than variable domain abstraction 
    variable domain abstractions
we designed three different methods to automatically generate variable domain abstractions  the methods as listed below are based on increasingly conservative approximations
    note that we define actions not to be triples of pre  add   del   but to have these components  hence
two actions with identical pre  add   del may be contained in the set a  this reflects practical planner
implementations  where actions have names and or unique ids  and checks for duplicate actions are not
usually performed 
    in a similar fashion  duplicate actions may arise as an outcome of edelkamps        pattern database
abstraction 

   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

of relevance  as is common in relevance approximations  cf  nebel et al          the algorithmic basis is  in all cases  a simplified backchaining from the goals 
 support starts in the first layer of a planning graph that contains all goal facts  possibly
with mutexes between them   for each goal fact in that layer  it selects one achiever in
the preceding action layer and marks the preconditions of that action as new sub goals 
then the process is iterated for the created sub goals 
allsupports proceeds similarly to  support except that it selects all achievers for each
 sub  goal 
allsupportsnonmutex proceeds similarly to allsupports except that it starts the backchaining at the first plan graph layer that contains the goals without mutexes 
in all three methods  the selected set of relevant facts r  p is taken to be the set
of goals and sub goals created during the backchaining  this set of facts is turned into
a variable domain abstraction as follows  first  we compute a partition of the problems
fact set p into subsets p            pk of pairwise persistently mutex facts  we take these
subsets to correspond to the underlying multiple valued variables  e g   the position of a
package   then we perform abstraction within those pi where not all values are relevant 
i e   pi   r      within each such subset pi   we arbitrarily choose one irrelevant fact p  i e  
p  pi   r  we then replace all other irrelevant facts  i e   all q  pi   r where q    p  with
p 
as an example  in logistics   support abstracts away all in p  v  facts for each package p except for those vehicles v that were selected as a supportin particular  a single
airplane  in contrast  allsupports will mark in p  v  as relevant for all airplanes v unless
some special case applies  e g   p must be transported within its origin city only   finally 
allsupportsnonmutex is even more conservative and covers some of the special cases in
which allsupports abstracts an in p  v  fact away  note that identifying positions inside
airplanes with positions outside airplanes may well affect the length of an optimal plan 
in addition to the domain independent  automatic variable domain abstractions  for six
ipc domains we have designed domain specific solution length preserving variable domain
abstractions by hand  for logistics  the domain specific abstraction was explained in the
introduction  for zenotravel  we use a similar abstraction exploiting irrelevant object positions  in blocksworld  on a  b  is considered irrelevant if b is neither the initial nor the
goal position of a  and b is initially clear    for depots  which is a combination of logistics
and blocksworld  our abstraction is a combination of the two individual abstractions  for
satellite  our abstraction performs a simple analysis of goal relevance to detect directions
that are irrelevant for a satellite to turn to  a direction is relevant only if it is the satellites initial direction  its goal direction  or a potential goal or camera calibration target 
similarly  in rovers  a waypoint  location  is considered relevant for a rover only if it is
either the initial position  or it is relevant for a needed rock sample soil sample image  or
it necessarily lies on a path the rover must traverse to reach some other relevant location 
    the last of these conditions is necessary to avoid the possibility of clearing a block c by moving a
away from c although a is actually placed on some third block 

   

fidomshlak  hoffmann    sabharwal

    experiment setup and presentation
the presented data were generated on a set of work stations running linux  each with a pentium   processor running at   ghz with   gb ram  we used a time cutoff of    minutes 
we experimented with the plan length optimizing planners satplan    ipp  koehler 
nebel  hoffmann    dimopoulos         and mips bdd  edelkamp   helmert          
our choice of satplan   rather than satplan   is arbitrary  except that  by using
the naive encoding  c   the resolution best case of satplan   can be improved by variable domain abstractionmaking our bad empirical results below even more significant 
note also that  although satplan   could be considered more recent  it contains no
developments beyond satplan    other than switching back to an older version of the
encoding method 
as test examples  we took  with few exceptions listed below  all strips domains used
in all international planning competitions until and including ipc       precisely  we use
 ipc       airport  dining philosophers  optical telegraph  pipesworld notankage 
pipes  world tankage  and psr 
 ipc       depots  driverlog  freecell  rovers  satellite  and zenotravel 
 ipc       blocksworld and logistics   miconic strips is just a very simple version of
logistics  freecell is part of our ipc      set  
 ipc       grid  mprime  and mystery   movie is trivial  in gripper variable domain
abstraction cannot preserve solution length  logistics is part of our ipc      set  
our measurements are aimed at highlighting the potential that abstraction in principle
has of speeding up the computation of information about a task  concretely  given a
planning task t   we create an abstract version t  of t   and run a planner x on it  there
are three possible outcomes 
    x finds a plan for t    an abstract plan  and it happens to be a real plan  that is  a plan
for t    we record the time taken to find the plan  along with the time taken by x to
find a plan given the original task t  
    x finds a plan for t  that is not a real plan  since all our planners optimize plan
length  the information we still gain is the length of the optimal abstract plan  which
is a lower bound on the length of the real plan  we record the time taken to compute
that bound  for example  for satplan    the time taken up to the last unsatisfiable
iteration   along with the time taken by x to compute the same lower bound given the
original task t  
    x runs out of time or memory  in this case  one could record the time taken up to the
last lower bound proved successfully  for the sake of readability  we omit this here and
consider only cases     and     above 
    while satplan   and ipp optimize step length of the plan  mips bdd optimizes sequential plan
length  however  again  as the performance of the planners does not stand for a comparative evaluation
here  we refer to all three simply as plan length optimizing planners 

   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

note that  in the spirit of being optimistic about the usefulness of abstraction  we do not
include the time taken to create the abstract task t    note also that we actually obtain
several results for each pair t and x  namely one result for every particular variable domain
abstraction  for the sake of readability  we do not include these distinctions in the results
 the distinctions are mostly inconclusive and uninteresting anyway   and instead present
the results from the following best abstraction perspective  we skip abstract tasks that
were either not solved  or that are not abstract since all facts are considered relevant 
if no abstract task remains  we skip the instance  otherwise  we select the abstract task
providing the best information about the instance  the best case is that the abstract plan
is real  else we select the highest lower bound    if there are several abstractions providing
the same best information  we choose the one with lowest runtime 
    ipc benchmarks
due to the sheer size of our experiments  planners multiplied with    domainsdiscussing
the entire result set is neither feasible nor would it be useful  an online appendix  see jair
web page for this article  contains detailed data for the three optimal planners  herein 
we provide a summary analysis showing the main points  with a particular focus on satplan   
detailed data for satplan   on   of our    ipc domains is given in table   
 depots and satellite are selected into the table because they are the only   of our   
domains where the abstraction brings a somewhat significant advantage 
 logistics is selected because it is our illustrative example 
 psr is selected due to being an interesting caseunusually  the current optimal planners do just as well  or badly  on psr as the current sub optimal  satisficing  planners 
in each domain  we selected the    most challenging instances  where challenging is
measured as the runtime taken in the original task  note that this problem instance selection
criterion for our presentation is also optimistic from the point of view of abstraction  for
each instance  table   first specifies whether the found abstract plan was a real plan or not 
this characterizes the problem instance in terms of cases     and     explained above  and
the corresponding runtimes of satplan   on abstract and real tasks are then given by
the rows ta and tr   the table then specifies the lower bound lg proved for the real task by
its planning graph  that is  t if f  t  is the first fact layer to contain all goal facts with no
mutexes between them   the lower bound la proved by satplan   in the abstract task 
and  finally  the actual length lr of the optimal plans for the real task  the last row relfrac
in the table specifies the percentage of facts considered relevant 
for depots  the best case data shown in table   is scattered across all four kinds of
variable domain abstractions  with the automatic abstractions being sometimes more and
sometimes less aggressive than our handmade abstraction  for example  instances numbers
   and    have their best case with the very aggressive  support strategy  most of the time
    note here that the quality of the information is essential  if the abstraction only tells us that the plan
must have at least n    steps  and the real plan length is n  then we must still prove the bound n  which
typically takes more time than all other bounds together 

   

fidomshlak  hoffmann    sabharwal

index
isreal 
ta
tr
lg   l a   l
relfrac
abs

index
isreal 
ta
tr
lg   l a   l
relfrac
abs

index
isreal 
ta
tr
lg   l a   l
relfrac
abs

index
isreal 
ta
tr
lg   l a   l
relfrac
abs

 
y
     
     
       
   
 s

  
n
    
   
       
   
asnm

  
y
    
    
        
   
 s

 
y
     
     
        
   
as

 
y
      
      
       
   
hm

  
y
     
     
       
   
asnm

  
y
     
     
       
   
asnm

 
y
      
      
        
   
as

 
y
     
     
     
   
hm

  
y
     
     
       
   
asnm

  
y
     
     
       
   
asnm

 
y
     
     
       
   
asnm

 
y
      
      
     
   
hm

  
n
    
    
       
   
asnm

  
n
     
     
       
   
asnm

 
n
      
     
       
   
as

 
y
     
     
     
   
hm

  
n
    
    
       
   
asnm

  
n
      
     
       
   
asnm

  
y
     
     
       
   
asnm

depots
  
  
n
y
     
    
    
     
       
     
   
   
 s
asnm
logistics
  
  
n
n
      
      
      
      
               
   
   
asnm
hm
psr
  
  
y
y
    
   
    
    
               
   
   
asnm
asnm
satellite
  
  
y
y
      
     
      
      
     
     
   
   
hm
hm
  
y
      

       
   
hm

  
n
   
    
       
   
asnm

  
n
      
      
       
   
hm

  
n
      
     
     
   
hm

  
y
      

       
   
hm

  
n
    
    
       
   
asnm

  
n
      
      
       
   
hm

  
n
     
    
      
   
 s

  
y
      
      
     
   
hm

  
y
     
     
       
   
asnm

  
n
      
      
      
   
as

  
y
     
    
     
   
asnm

  
y
      
      
     
   
hm

  
y
      
      
       
   
asnm

  
n
      
      
      
   
hm

  
y
    
     
     
   
asnm

  
y
     
      
     
   
hm

  
n
    
    
      
   
 s

  
n
      
      
      
   
as

  
y
      

       
   
as

  
y
      
      
     
   
hm

  
y
    
    
       
   
asnm

  
n
   
   
     
   
 s

  
n
      
     
     
   
hm

table    full results  in some selected domains  for satplan   and variable domain abstraction  best of  see text   notations  index 
index  number  of instance in respective ipc suite  isreal  whether the abstract plan real  y  or not  n   l  the length of the
optimal plan    if not known   lg   lower bound on plan length proved by planning graph  la lower bound proved in abstract task 
ta   runtime  secs  needed to prove the lower bound la in abstract task  tr runtime  secs  needed to prove the same lower bound la
but in real task  relfrac  fraction of facts considered relevant  dashes  time out  abs  is the corresponding form of variable
domain abstraction   support   s   allsupports  as   allsupportsnonmutex  asnm   and handmade  hm  

   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

domain
airport
blocksworld
depots
dining philosophers
driverlog
freecell
grid
logistics
mprime
mystery
optical telegraph
pipesworld notankage
pipesworld tankage
psr
rovers
satellite
zenotravel

index
  
 
  
  
  
 
 
  
 
  
  
  
 
  
 
  
  

ta
    
     
     
   
     
   
    
     
   
     
    
     
     
     
    
     
     

satplan  
tr
isreal 
lg   l a   l r
    
y
        
    
y
        

y
       
   
y
       
     
n
       
   
y
     
   
n
       
     
n
       
   
y
     
     
y
     
    
n
        
     
y
       
     
n
     
     
y
       
    
y
     

y
       
     
n
     

relfrac
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

table    results for satplan   with the best case variable domain abstraction on the
most challenging successful instances of each domain  notation as in table   

the runtime is better on the original task  yet there are a few cases where the abstraction
brings a quite significant advantage  most notably  in instance number    satplan  
runs out of time on the original task  but solves the abstract task  finding a real plan  within
a few minutes  in logistics  the best case data is mostly  though not exclusively  due to the
conservative allsupportsnonmutex and our handmade abstractions  the abstract runtime
is worse in all but three cases  nos               where it is slightly better  in psr  the best
cases are almost exclusively due to the conservative allsupportsnonmutex abstraction  as
for runtimes  abstraction is usually faster  but only marginally  satellite is the only one
of our    domains where abstraction brings a significant  and largely consistent  runtime
advantage  the best cases are almost exclusively due to our hand made abstraction  all
abstract plans are real plans  often found significantly faster than for the original task  it is
unclear to us why the results are good in satellite  but  for example  not in logistics  where
the state space reduction is much larger 
next  table   provides an overview of the results for satplan   in our    ipc
domains  to make data presentation feasible  we select just one instance per domainthe
most challenging successful instance  by successful  we mean that at least one abstract
task of that instance was solved  abstract plan found   and this abstract task was indeed
abstract  not all facts relevant   by challenging  we mean maximum runtime on the original
task   
    another strategy would be to select the task that maximizes tr  ta   the time advantage given by
abstraction  however  in most cases this strategy would select a trivial instance  namely  because tr  ta
is consistently negative  and maximal in the easiest tasks 

   

fidomshlak  hoffmann    sabharwal

domain
airport
blocksworld
depots
dining philosophers
driverlog
grid
logistics
mprime
mystery
optical telegraph
pipesworld notankage
pipesworldtankage
psr
rovers
satellite
zenotravel

index
 
 
  
 
 
 
 
 
 
 
 
 
  
 
 
  

ta
    
   
     
     
   
   
   
   
   
    
   
    
   
     
     
     

tr
   
   
     
     
   
   
   
   
   
   
   
   
   
     
      
     

ipp
isreal 
y
y
y
y
n
n
y
n
n
n
y
n
n
n
y
y

lg   l a   l r
        
        
     
       
       
       
       
     
     
        
     
     
     
       
     
     

relfrac
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

table    similar to table    but for the ipp planner 

it is useful to discuss the    domains in groups with similar behavior  depots  logistics 
psr  and satellite have already been discussed  in each of airport  dining philosophers 
driverlog  mystery  mprime  optical telegraph  pipesworld notankage  and pipesworld
tankage  satplan   runtimes are consistently lower on the original tasks  with few exceptions mostly among the easiest instances  the picture is less consistent but qualitatively
similar in zenotravel  the degree of the advantage varies  it is relatively moderate in
dining philosophers  up to    less runtime on original task   optical telegraph  up to
      airport  up to       pipesworld tankage  up to       and mprime  up to       it
is much stronger in zenotravel  up to       mystery  up to       driverlog  up to      
and pipesworld notankage  up to      
in rovers  the runtime results are inconclusive  with minor advantages for abstract or
real depending on the instance  in blocksworld  satplan   solves abstract tasks with
up to   blocks only  independently of the abstraction used  we dont know what causes this
bad behavior  in freecell  most of the time allsupports and allsupportsnonmutex do not
abstract anything  and in all abstractions generated with  support  satplan   runs out
of time  leaving instance number   as the only successful case  shown in table    in grid 
finally  the ipc      test suite contains only   instances  which become huge very quickly 
satplan   can solve  abstract or real  only instances numbers   and    and the latter is
shown in table   
tables   and   provide a similar snapshot on the results with ipp and mips bdd 
respectively  the picture for ipp is  roughly  similar to that for satplan    the main
difference is  in fact  that ipp is a weaker solver than satplan   in many domains  to
the effect that some more domains contain no interesting data  specifically  in driverlog 
mprime  mystery  pipesworld notankage  and psr  ipp either solves the instances in no
time  or not at all  like for satplan    we see an advantage for abstraction in depots
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

domain
airport
blocksworld
depots
dining philosophers
driverlog
freecell
grid
logistics
mprime
mystery
optical telegraph
pipesworld notankage
pipesworld tankage
psr
rovers
satellite
zenotravel

index


 

ta


   

mips bdd
tr
isreal 





y

lg   l a   l r


       

relfrac


   

  

 
  



     

   
   










y

n
y



       

      
        



   

   
   



  
 

   
     

    
     

y
y

     
       

   
   

  

     



y

       

   

table    similar to tables     but for the mips bdd planner 

and satellite  and we note that for satellite this difference is consistently huge  we also
see a vague advantage for abstraction in logistics  for mips bdd  even more domains
gave no meaningful data  in the domains dashed out in table    mips bdd runs out of
time on even the smallest instances  in the domains left empty  we either could not run
mips bdd for some technical reasons  or it stopped abnormally  in the remaining data
set of   domains  however  our abstractions  as expected  bring a consistent advantage for
mips bdd  in particular  consider the behavior in logistics  rovers  and zenotravelin
these domains  mips bdd is vastly improved by abstraction while satplan   and ipp
are more or less inconclusive 
    constructed benchmarks
the above has shown that the use of abstractionof variable domain abstraction  at least
to speed up state of the art planning systems varies from quite promising for mips bdd
to rather hopeless for satplan    we ran a number of focused experiments to examine
the more subtle reasons for this phenomenon  these experiments have been done on three
ipc benchmarkslogistics  rovers  and zenotravelwhere the results on the ipc test
suites are relatively bad  although we are in possession of hand made abstractions  we
wanted to test what happens when we scale the instances on irrelevance  the respective
experiment for logistics  figure    was discussed in the introduction  for rovers  we tried
a large number of instance size parameters  and even minor modifications of the operators 
but we could not find a setting that contained a lot of irrelevance and was challenging for
satplan   and ipp  in short  it appears that the rovers domain is not amenable to
abstraction techniques  for zenotravel  we obtained the picture shown in figure   
   

fidomshlak  hoffmann    sabharwal

     

   

     

   

  
    

  

  

    

  

  
   

  

  

   

  

  
  

  

  

  

  

  
 

  

  
mips bdd abstract
mips bdd real
relfrac

   
 

 

 

 

 

 

 

 

  

  

 

  
ipp abstract
ipp real
relfrac

  
 

  

   

  

 

 

 

 

 

 a 

 

 

 

  

  

  

  
 
  

 b 
     

   
  

    

  
  

   

  
  

  

  
  

 

  
satplan abstract
satplan real
relfrac

   
 

 

 

 

 

 

 

 

  

  

  

  
 
  

 c 
figure    runtime performance of mips bdd  a   ipp  b   and satplan    c   with
 abstract  and without  real  our hand made variable domain abstraction 
in zenotravel instances explicitly scaled to increase the amount of irrelevance 
horizontal axis scales the number of cities  left vertical axis shows total runtime
in seconds  right vertical axis shows the percentage relfrac of relevant facts 

the shown zenotravel instances always feature   airplanes and   persons  the number
of cities scales from   to     as in logistics  we generated   random instances per size 
and show average values with a time out of      seconds  stopping plots when   timeouts occurred at an instance size  all in all  the relative behavior of the abstract and real
curves for each planner is quite similar to what we observed in figure   with logistics 
for satplan   and ipp  abstraction has a slight disadvantage with high relfrac  and
becomes much more efficient as relfrac decreases  for mips bdd  the advantage brought
by the abstraction is much more pronounced  and decreasing relfrac consistently widens
the gap between solving abstract and real tasks  the average value of relfrac in the ipc
     zenotravel benchmarks is      lying in between   cities       and   cities       in
figure    where there is not yet much gained by the abstraction 
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

in summary  it appears that some planning benchmarks  like rovers  do not have good
abstractions  and most others  like logistics and zenotravel  do not have enough irrelevance
in the ipc test suites 
it is important to note that the situation may not be quite as bad for unsolvable examples  consider the ipc benchmarks dining philosophers and optical telegraph  edelkamp 
       dining philosophers is an extremely basic benchmark that cannot be abstracted
much further  in contrast  optical telegraph is essentially a version of dining philosophers
with a complex inner life  exchanging data between the two hands of each philosopher  
this inner life does not affect the existence of a solution  deadlock situation   which depends exclusively on the outer interfaces of the philosophers  that is  taking and releasing
forks  however  the inner life does  of course  affect the length of a solution  if one exists 
we constructed an unsolvable version of the domain  without deadlock situation  by giving
the philosophers more flexibility in releasing forks  as one would expect  in this setting
abstracting the inner life away gives huge savings  i e   the tasks can be proved unsolvable
much more efficiently  this suggests that it may be easier to abstract unsolvable tasks 
without invalidating the property of interest  exploring this is a topic for future work 
while most planning benchmark domains do not naturally contain unsolvable instances  in
over subscription planning this issue may become relevant  sanchez   kambhampati       
meuleau  brafman    benazera        
    other abstractions
as discussed earlier  one cannot expect that removing preconditions  goals  or entire facts
preserves plan length in interesting cases  there are  however  certain cases where some
delete effects can safely be ignored  specifically  in driverlog  logistics  mprime  mystery 
and zenotravel  one can ignore those deletes of load and unload actions which state
that an object is no longer at its origin location  load  respectively that an object is no
longer inside the vehicle  unload   in rovers one can ignore some deletes of actions taking
rock or soil samples  namely those deletes stating that the sample is no longer at its origin
location  we ran each of our planners on the respective abstracted tasks  the results can
be summarized as follows 
satplan   has a clear loss in runtime from using the abstraction in driverlog  e g  
task number    is solved abstract vs  real in       vs        sec  
ipp has a vast gain from abstraction in logistics  e g        vs        sec in number     
and a vast loss in zenotravel  e g         vs     sec in number     
mips bdd has a vast loss from abstraction in driverlog  logistics  and zenotravel  e g  
      vs      sec in zenotravel number    
the results are inconclusive for all other planner domain pairs 

   resolution complexity
as discussed in the introduction  we were surprised to see very little improvement to satplan in our experiments  despite the dramatic state space reductions brought about by
   

fidomshlak  hoffmann    sabharwal

variable domain abstraction  we now shed some light on this issue  by examining resolution
complexity in the original vs  the abstracted planning tasks  throughout the section  we
consider the situation where the plan length boundthe number of time steps in the cnf
encodingis too small  and thus the cnfs are unsatisfiable  note that this is the case in
all but one of the sat tests performed by satplan  in particular  it is the case in the
sat tests where satplan proves optimality of the plan  that is  the non existence of a
plan with n    steps where n is the length of an optimal plan  this proof is typically very
costly  accounting for a large fraction of the runtime taken by satplan 
we consider all abstraction methods introduced in section      plus  for completeness 
a hypothetical abstraction method that adds new initial facts  we show in section     that 
in many cases  the resolution complexity cannot be improved by delegating the optimality
proof to within the abstraction  in section     we then show that  in all considered cases 
the resolution complexity can become exponentially worse  section     briefly examines the
effect of post abstraction simplifications  for the sake of readability  herein most proofs are
replaced with proof sketches  the full proofs are available in appendix a 
recall that resolution complexity is defined as the length of the shortest possible resolution refutation  in all proofs  our arguments are for general  unrestricted  resolution 
however  our constructions do not affect the structure of the resolution refutations  and
hence the results hold as stated  except for a slight weakening in the case of lemma      
for many known variants of resolution  including tree like  dpll   regular  and ordered
resolution  in general  the results hold for any variant of resolution for which setting variables to true or false or replacing one variable with another preserves proof structure  the
slightly exceptional status of lemma      will be explained below when we discuss that
result  
in the remainder of the paper  if p is a planning task and  is an abstraction  then
by p  we denote the respective abstracted planning task  that is  the planning task that
results from applying  to p 
    can resolution complexity become better 
we prove three main results  which are captured by theorems        below  the first
result holds for all four sat encodings  a  d  as listed in section      the other two
results apply to encodings  a  and  c   respectively  for the respective encodings and
abstraction methods  the results essentially say that resolution complexity cannot decrease
by applying the abstraction  as outlined in the introduction  a catchy  if imprecise  intuition
behind these results is that over approximations  abstractions  result in less constrained
formulas  which are harder to refute  for encoding  c   the result is offset by the effort
required to recover all graphplan mutexes  we will get back to this below  for the theorems
that follow  recall from section     that rc   denotes the resolution complexity of   i e  
the size of the smallest resolution proof of unsatisfiability of  
theorem      let p be a planning task  assume we use any of the encoding methods
 a  d   let  be an abstraction of p that consists of any combination of 
 a  adding initial facts 
 b  ignoring preconditions  goals  or deletes  and
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

 c  removing a fact completely 
let n be the length of a shortest plan for p    and let b   n  let  and  be the encodings
of b step plan existence in p and p    respectively  then rc    rc    
theorem      let p be a planning task  assume we use encoding method  a   let  be
an abstraction of p that consists of any combination of 
 a  adding initial facts 
 b  ignoring preconditions  goals  or deletes 
 c  removing a fact completely  and
 d  variable domain abstraction 
let n be the length of a shortest plan for p    and let b   n  let  and  be the encodings
of b step plan existence in p and p    respectively  then rc    rc    
theorem      let p be a planning task  assume we use encoding method  c   let  be
an abstraction of p that consists of any combination of 
 a  adding initial facts 
 b  ignoring preconditions  goals  or deletes 
 c  removing a fact completely  and
 d  variable domain abstraction 
let n be the length of a shortest plan for p    and let b   n  let  and  be the encodings
of b step plan existence in p and p    respectively  let m be the number of resolution steps
required to infer from  the additional mutex clauses that appear in a   where a is the
encoding of b step plan existence in p as per encoding  a   then rc    rc      m  
note in all these theorems that n  defined to be the length of a shortest plan for p   
necessarily satisfies n  m where m is the length of a shortest plan for p  hence  for
n  b  m   is satisfiable  detecting this  finding out that p  has a plan of length b 
does not give us any information about the length of a shortest plan for p  for    b   n 
however   is unsatifiable  which tells us that b     is a lower bound on plan length in p 
hence  what the theorems say is this  either b  n and  is too coarse to disprove existence
of a plan of length b  or b   n and  does not decrease the resolution complexity of that
disproofat least by no more than the complexity of deriving the additional mutexes  in
the case of theorem     
let us first linger a bit on theorem      the general intuition of our results is that
abstractions induce less constrained formulas  and hence resolution complexity cannot decrease  so why does this hold for encoding  a  as stated in theorem     but not  in a strict
sense  see proposition      later in this section   for encoding  c   basically  the answer is
that the intuition is imprecise in this general formulation  and the devil is in the details 
in this particular case  the issue is that variable domain abstraction makes use of mutex
   

fidomshlak  hoffmann    sabharwal

relations which encoding  c  is not aware of  sometimes  an indirect mutex in the original
task  omitted in encoding  c   becomes a direct mutex in the abstraction  included in encoding  c    refuting  might then involve recovering that mutex  which a refutation of 
need not do  hence  a potential improvement in resolution complexity may stem from the
power of mutex relations  the upper bound specified in theorem     shows that this is the
only thing that an improvement can be due to  proposition      below provides an example
where a mutex must be recovered  and hence proves that an analogue of theorem     does
not hold for encoding  c  
it is an open question whether an analogue of theorem     holds for encoding  b   and
whether an analogue of theorem     holds for encoding  d   as we will discuss further
below  these open questions appear to be related to some intricate properties of graphplanbased encodings with vs  without fact variables  what we do know is that mutexes may
need to be recovered also in encoding  d   the example provided by proposition      works
for both encodings  c  and  d   further  we establish a connection between the two open
questions  if an analogue of theorem     holds for encoding  b   then we immediately get
that an analogue of theorem     holds for encoding  d  
we now consider all this in detail  note that  as far as the removal of goals is concerned 
the theorems are actually trivial  for all four encoding methods  if  only removes part of
the goals  then  is a sub formula of   for all other abstraction methods  the latter is not
the case  we treat removal of goals together with the other methods since that treament
does not cause any overhead  and the goal clauses need to be discussed anyway  the set of
achievers of a goal may change  
for some of the proofs  we need a helper notion that captures over approximated planning graphs  assume a planning task p and its planning graph p g p   and assume that
 is an abstraction  then p g p    will typically have many more vertices than p g p  
this captures the fact that p  allows no fewer  and often more  facts and actions than p
does  this will  in general  result in many more constraints in a propositional translation
of the planning task  with more constraints  it may seem like the abstraction could  in
principle  make it possible to derive an easier shorter proof of the fact that no plan exists
within the specified bound  however  a closer inspection restricted to facts and actions
already available in the original planning graph reveals that one often ends up with fewer
and weaker constraints than for the original task  we now introduce some notations to
make this formal 
definition      for a planning task p and an abstraction  of it  p g  p  is defined to be
the subgraph of p g p    induced by the vertices of p g p   similarly  p gred  p  is defined
to be the subgraph of p gred  p    induced by the vertices of p gred  p  
definition      let p be a planning task  an abstraction  is called a planning graph
abstraction of p if p g  p  and p g p  have identical sets of vertices and the following
conditions hold 
    eadd  p g  p    eadd  p g p   
    epre  p g  p    epre  p g p   
    emutex  p g  p    emutex  p g p    and
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

     g   g 
where g and  g  are the goal states of p and p    respectively  an abstraction  is called a
reduced planning graph abstraction if the above conditions hold for p gred  p  and p gred  p 
instead 
lemma      let p be a planning task  assume we use encoding method  a  or  b   let
 be a planning graph abstraction of p  let n be the length of a shortest plan for p    and
let b   n  let  and  be the encodings of b step plan existence in p and p    respectively 
then rc    rc    
proof sketch  say we set to false all variables of  that do not appear in   i e   we
fix the value of those variables to be    because of the way we defined p g  p   this
yields precisely the propositional encoding of p g  p   we show that  after this variable
restriction  the clauses surviving in  are also present in   either as is or in a stronger
form  i e   with fewer literals   for example  in encoding  a  each precondition clause
c  of  has a corresponding clause c in  due to condition     of definition      which
states that  does not introduce new preconditions  we have c   c due to condition
    of definition      which states that  preserves all add effectshence the set of actions
achieving the precondition in p  contains the corresponding set in p  a similar observation
holds for the effect clauses in encoding  b   and similar arguments apply to all the other
kinds of clauses  the claim then follows with proposition     
lemma      let p be a planning task  assume we use encoding method  c  or  d   let
 be a reduced planning graph abstraction of p  let n be the length of a shortest plan for
p    and let b   n  let  and  be the encodings of b step plan existence in p and p   
respectively  then rc    rc    
proof  the argument is identical to the proof of lemma      except that the underlying
planning graph for encodings  c  and  d  is the reduced planning graph  resulting in potentially fewer mutex clauses than in encodings  a  and  b   respectively  this  however 
does not in any way affect the proof arguments 
lemma      let p be a planning task  let  by any modification of p that respects the
following behavior 
 a   does not shrink the list of initial facts 
 b   does not grow the set of goal facts 
 c   preserves the add lists unchanged  and
 d   does not grow the pre and del lists 
then  is a planning graph abstraction of p as well as a reduced planning graph abstraction
of p 
   

fidomshlak  hoffmann    sabharwal

proof sketch  the proof is straightforward  but a little tedious in the details  suppose  is
an abstraction for p satisfying the prerequisites  we must argue that p g  p  and p gred  p 
satisfy the conditions in definition      condition     involving goal states easily follows
from property  b  of   once p g p  and p g  p   as well as their reduced counterparts 
are shown to have the same set of vertices  conditions     and     involving precondition
and effect relations follow directly from properties  c  and  d   it hence remains to prove
that all facts and actions available in p g p  are also available in p g  p   showing     and
    with what we just said   and that no new mutex relations are created between facts and
actions that are not mutex in p g p   showing       this proof is a little tedious  proceeding
inductively over the construction of the planning graph  the underlying intuition  however 
is simple  if p g  p  up to layer t abstracts p g p  up to layer t  and properties  a    c 
and  d  are respected by   then necessarily p g  p  up to layer t     abstracts p g p  up
to layer t      this concludes the argument 
the following is an immediate consequence of lemmas           and     
corollary      let p be a planning task  assume we use any of the encoding methods
 a  d   let  be an abstraction of p that consists of any combination of 
 a  adding initial facts  and
 b  ignoring preconditions  goals  or deletes 
let n be the length of a shortest plan for p    and let b   n  let  and  be the encodings
of b step plan existence in p and p    respectively  then rc    rc    
this result essentially states the rather intuitive fact that  if the abstraction does anything that yields a larger planning graph  then the resulting graphplan based encodings
will be less constrained and hence have a higher resolution complexity  if anything  
matters become much less intuitive once we consider abstractions that remove entire
factsclearly  these no longer result in over approximated planning graphs  since they remove some of the vertices  in other words  the condition in definition     that p g  p  and
p g p  have identical sets of vertices does not hold  and we need a slightly different line of
reasoning that does not rely strictly on abstracted planning graphs  we first show that it is
harmless to remove a fact if it does not appear in the goal and in any pre or del list  then
we rely on corollary     to reason that this requirement on a fact can be easily achieved 
lemma       let p be a planning task  assume we use any of the encoding methods
 a  d   let p be a fact that does not appear in the goal and in any of the pre or del lists 
and let  be the abstraction of p that removes p from the initial facts and the add lists  let
n be the length of a shortest plan for p    and let b   n  let  and  be the encodings of
b step plan existence in p and p    respectively  then rc     rc    
proof sketch  the key point is that  if p does not appear in the goal and is never required or
deleted by an action  then p is completely irrelevant to the planning task  and in particular
to the resolution refutations we consider here  concretely  we first prove that at every layer
of the planning graph  the available facts and the mutex fact pairs remain the same  up
to facts or fact pairs involving p  that is  the only thing that is lost in the fact layers of
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

p g  p  is p  since p does not occur in any precondition  the action layers remain exactly
the same  since p does not occur in any preconditions or delete effects  the action mutexes
also remain exactly the same  they were not caused by p  
the above discussion implies that the precondition clauses in all the encodings are
identical  given that p does not appear in the goal  the same is true of the goal clauses 
since the action mutexes are unchanged  it follows that  and  are actually identical
for encodings  a  and  c   for encodings  b  and  d   the only difference between  and
 is that  does not contain the initial state  effect  and mutex clauses involving p 
however  these clauses can never participate in a resolution refutation of   all effect and
mutex clauses contain p in the same polarity  negative   while an initial state clause has
the positive form  p      the time index is different from those of p in all effect and mutex
clauses  hence every variable corresponding to p occurs in only one polarity  this concludes
the argument 
corollary       let p be a planning task  assume we use any of the encoding methods
 a  d   let  be an abstraction of p that removes a fact completely  let n be the length of
a shortest plan for p    and let b   n  let  and  be the encodings of b step plan existence
in p and p    respectively  then rc    rc    
proof   is equivalent to the following two steps  first  remove p from the goal facts  if
present  and from all pre and del lists  by corollary      this step cannot improve resolution
complexity  second  now that p has been removed from the goal and the pre and del lists 
remove p from the problem completely by removing it from the initial facts and all add lists
as well  by lemma       this step as well cannot improve resolution complexity  and we
are done 
corollaries     and      together prove our first main result  theorem      we now
move on to variable domain abstraction  where matters are most complicated  and which is
most interesting because that abstraction method enables us to construct solution length
preserving abstractions with exponentially smaller state spaces  in many benchmarks  first
we show that  in its original form  the result holds for encoding  a  
lemma       let p be a planning task  assume we use encoding method  a   let  be
a variable domain abstraction of p  let n be the length of a shortest plan for p    and let
b   n  let  and  be the encodings of b step plan existence in p and p    respectively 
then rc    rc    
proof sketch   combines two persistently mutex facts p and p  into a single fact p  we first
show that if an action pair  a  a    is mutex in p    then it will also be mutex in p  the only
way for  a  a    to become mutex per  requires  w l o g   that in p  p  del  a   pre a  and
p   pre a     add  a     supposing  a  a    is not mutex in p  we have that p   del  a    and p
is not mutex with any fact in pre a     but then   noop p   a    is not mutex in p and hence
 p  p    is not a persistent mutex  in contradiction 
with this in hand  we can derive a property rather similar to that of planning graph
abstractions given in definition      by the above  we know that the abstract encoding 
does not have any mutexes that do not appear in   further  the set of actions achieving
each fact only grows by applying this abstraction  and the goal can only shrink  the most
   

fidomshlak  hoffmann    sabharwal

subtle issue regards precondition clauses  if an action a has p  as its precondition in p  then
this is replaced by p in p    so there is no direct correspondence between the two  however 
that lack of correspondence does not affect the precondition clause of encoding  a   which
takes the form  a  a            ak    this omits the actual precondition fact being achieved  so
it does not matter whether that fact is p  or p 
next  as in the proof to lemma      we set all variables to false which appear in  but
not in   with the above arguments  it is then not difficult to see that the clauses surviving
in  are also present in   either as is or in a stronger form  i e   with fewer literals   for
mutex clauses  this is obvious  for goal clauses  the argument is exactly the same as in the
proof sketch for lemma     given above  for precondition clauses  observe that a            ak
in the above will contain all achievers of p  plus all achievers of p  the claim now follows
with proposition     
corollaries     and      together with lemma      prove our second main result  theorem      for encodings  b  d   matters are more complicated 
consider first encodings  b  and  d   which differ from  a  in that they also have
fact variables  this changes the precondition clauses  if an action a in p has p  as its
precondition  but p in p    then we no longer get the clause  a  a            ak   as in the proof
sketch  instead  we get the clause  a  p   for this clause  there is no correspondence in  
in particular  consider the case where we have two actions in p  action a with precondition
p and action a  with precondition p    this gives us the clauses  a  p    a    p    in  and
the clauses  a  p    a    p  in    now   does not distinguish between the achievers
of p and those of p    so there is no problem in that regard  but can the fact that the two
clauses now share a literalwhich they dont in be exploited to obtain shorter resolution
refutations  this is an open question  we discuss its implications in a little more detail at
the end of this sub section 
consider now encoding  c   which differs from  a  in that it includes only direct action
mutexes  this invalidates a different argument in the proof of lemma       it is still true
that  if an action pair  a  a    is marked mutex in p    then it will also be mutex in p 
however  it can happen that  a  a    is mutex in p  due to a direct interference between
a and a    while  a  a    is mutex in p due to mutex preconditions  rather than a direct
interference  since encoding  c  accounts only for direct interferences  we then have a
mutex in  that does not appear in   this can result in improved resolution complexity
for    the following proposition proves this formally 
proposition       assume we use encoding method  c   there exist a planning task p  a
variable domain abstraction  of p  and b   n such that rc     rc     where n is the
length of a shortest plan for p    and  and  are the encodings of b step plan existence in
p and p    respectively 
proof sketch  we construct p    and b as specified  the key property of the construction
is that there are two actions  getg  and getg    that are both needed to achieve the goal facts
g  and g    respectively  more precisely  getg      x    g    p      x   and getg      p  y  
 g      p    the task is constructed  along with the help of a few other actions  in a way so
that x  p  and p  are pairwise persistently mutex  the variable domain abstraction replaces
p  with p  and b is set to    in the action layer directly beneath the goal layer  i e   in action
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

layer a     the planning graph marks getg  and getg  as mutex because their preconditions
are mutex  encoding  c   however  does not include this mutex clause because there is no
direct conflict  this situation changes after the abstraction  now getg  adds p instead of p   
and hence there is a direct conflict with the delete effect of getg    as a consequence  in the
abstraction two resolution steps suffice  applying both getg  and getg  in a    is the only
option to achieve the goals  and the new mutex clause immediately excludes that option 
this is not so in the encoding of the original task  where the required mutex must first be
derived by reasoning over the preconditions x and p 
note that the only reason why we get a shorter refutation for  is that variable domain abstraction turns an indirect action mutex  due to competing preconditions  into a
direct interference  in doing so  the abstraction exploits the knowledge that p and p  are
persistently mutexa fact that is ignored in encoding  c   hence the positive result stated
by proposition      is less related to the power of abstraction than to the power of planning
graph mutexes  we now capture this formally  in what follows  note that using the same
plan length bound  the cnf formula as per encoding  c  is a sub formula of the cnf
formula as per encoding  a   and all the additional clauses of  a  can be inferred from it 
lemma       let p be a planning task  let  be a variable domain abstraction of p 
let n be the length of a shortest plan for p    and let b   n  let a and c be the
encodings of b step plan existence in p as per encoding  a  and  c   respectively  let c
be the encoding of b step plan existence in p  as per encoding  c   let m be the number of
resolution steps required to infer from c the additional mutex clauses that appear in a  
then rc c    rc c     m  
proof  denote by a the encoding of b step plan existence in p  as per encoding  a   we
have 
    by the preconditions of the lemma  rc c    rc a     m   with m resolution steps 
c can be turned into a   and hence from the shortest resolution refutation for a
we can construct one for c that is m steps longer 
    from lemma       rc a    rc a   
    c is a sub formula of a   and hence rc a    rc c   
combining these observations  we have 
rc c    rc a     m

from observation    

rc a     m
rc c     m

from observation    




from observation    

this finishes the proof 
clearly  this proof argument applies also when  is a combination of variable domain
abstraction with all the other abstractions  hence corollaries     and      together with
lemmas      and      prove our third main result  theorem      note that this latter
result does not hold for all variants of resolution  in the claim of lemma       m is the
   

fidomshlak  hoffmann    sabharwal

number of resolution steps it takes to derive the action mutexes not present in the original
encoding  these are then used in the resolution refutation  if the variant of resolution
under consideration is  say  dpll or tree like resolution  deriving a mutex clause once is
not enoughit must be re derived as many times as it is used in the tree like resolution
refutation  hence the effective value of m for such variants of resolution would be larger 
note that this is not the case if the dpll solver learns the mutex clauses by virtue of the
wide spread clause learning technique 
lemma      is particularly relevant for our empirical results  because satplan   uses
encoding  c  and our experiments mostly focus on variable domain abstraction  while we
have no explicit empirical proof  and such a proof would be difficult to come by  requiring
a deep analysis of the sat solvers search spaces   it seems reasonable to assume that  at
least to some extent  the disappointing results for satplan   are due to whats proved
in lemma       the abstraction cannot improve resolution complexity beyond the effort
required to recover the indirect action mutexes  note here that the bound m given in
the lemma is rather pessimistic  a mutex  a  a    needs to be recovered only in the case
where a and a  have competing needs in p  and replacing p  with p results in a direct
interference but does not incur simplifications  in the logistics domain  for example  with
our abstraction this happens only for actions loading a package onto an airplane in two
different but irrelevant cities  since these load actions are involved only in redundant
solutions anyway  it seems doubtful that such mutexes play a role for resolution complexity 
more generally  it is interesting to consider upper bounds on m in lemma       how
many resolution steps does it take to recover the indirect action mutexes  for general resolution  the number of steps is polynomially bounded  since the inference process conducted
by the planning graph can be simulated  for a related investigation  see brafman        
for restricted variants of resolution  matters are more complicated  of particular interest
is the behavior of dpll clause learning  c f  the above  there is so far no known formula for which dpll clause learning proofs are provably substantially worse than general
resolution proofs  it would be rather surprising if planning graph mutexes were to be the
first  also  rintanen        provides a related investigation  showing that mutexes can be
recovered in polynomial time by a particular   step lookahead procedure  which is related
 but not identical  to clause learning 
concluding this sub section  let us again turn our attention to encodings  b  and  d  
as mentioned before  it is an open question whether an analogue of theorem     holds for
encoding  b   and whether an analogue of theorem     holds for encoding  d   we are
facing two problematic issues 
 i  fact variables  in both encoding  b  and  d   there are fact variables in addition
to the action variables used in encodings  a  and  c  
 ii  mutexes  like for encoding  c   it may happen that variable domain abstraction
converts an implicit mutex in encoding  d  of the original task into an explicit one in
the abstraction 
we consider first issue  ii   the situation is exactly as for encoding  c   in this regard 
proposition      holds as stated for encoding  d  as well  indeed it can be proved using
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

exactly the same example and only very minor adaptations of the proof arguments    similarly  lemma      holds for encoding  d   with exactly the same proof argumentsprovided
an analogue of lemma       and hence an analogue of theorem      holds for encoding  b  
namely  the proof arguments of lemma      all remain valid  except that we need to refer
to encoding  b  rather than  a   and that accordingly we need a corresponding version of
lemma       this brings us to issue  i  
variable domain abstraction can be perceived as gluing sets of facts together  recall
here the example with clauses  a  p    a    p    in  not sharing any literals  and clauses
 a  p    a    p  in  sharing the literal p  this was discussed above to explain why the
proof of lemma      does not work for encodings  b  and  d   if k     facts are glued
together  then groups of k clauses can become linked together in this fashion  the question
is 
    can resolution fruitfully exploit this increased linkage 
this issue appears to be related to some quite intricate properties of graphplan based
encodings with vs  without fact variables  for encoding  a   which differs from encoding
 b  only in that it does not use fact variables  lemma      tells us that resolution cannot
exploit variable domain abstraction  now  it appears reasonable to think that adding fact
variables does not help a lot  the intuition being 
     whatever one can do with encoding  b   one can easily simulate with encoding  a  
if statement      is true  then the answer to question     has to be no  because a yes
answer would contradict lemma       hence  in an initial attempt to prove the no answer 
we tried to prove statement       however  our initial investigation has indicated that by
explicitly keeping fact variables  and non trivial constraints on them  around  encoding  b 
might facilitate significantly shorter resolution derivations in general  and hence statement
     might be false  namely  there appear to be families of formulas that can be suitably
encoded into planning tasks to yield an exponential separation between encodings  a  and
 b   if this is true  then it suggests that reasoning in the presence of fact variables might
be more powerful and hence might indeed be able to exploit the linkage gain yielded by
variable domain abstraction 
since the purpose of this paper is not to compare the relative power of various
graphplan based encodings  such as that of  a  and  b    we do not detail our progress
towards disproving statement       besides  note that  if statement      is indeed false  then
that does not have any immediate implications on the answer to question      a definite
answer to     is left open for future research 
    can resolution complexity become worse 
the answer to the title of this sub section is a definite yes  with all four encodings 
any of the abstractions we consider may exponentially deteriorate resolution complexity 
formally  we have the following theorem 
    we include the full proof for both  c  and  d  in appendix a 

   

fidomshlak  hoffmann    sabharwal

theorem       assume we use any of the encoding methods  a  d   there exist an
infinite sequence of planning tasks p i   abstractions  i  of p i   and b i    n i  such that
rc   i   is exponential in i while rc  i   is a constant independent of i  where n i  is
the length of a shortest plan for p   i    i  and   i  are the encodings of b i  step plan
existence in p i  and p   i  respectively  and  i  consists of any one of 
 a  adding initial facts 
 b  ignoring preconditions  goals  or deletes 
 c  removing a fact completely  or
 d  variable domain abstraction 
proof sketch  the idea is to construct p i  as a planning task that consists of two separate
sub tasks  and whose overall goal is to achieve the goals of both of these sub tasks  each
of the sub tasks themselves is infeasible within the given plan length bound b i    the
tasks and bounds are constructed such that their size grows polynomially with i   however 
while the first sub task is constructed to require exponential size resolution refutations  the
second allows constant size refutations  if an abstraction over approximates the easy torefute sub task in a way so that it becomes feasible within b i  steps  then the resolution
refutation of the overall task must rely on the hard to refute sub task  this leads to an
exponential growth  over i  in resolution complexity for   i   as opposed to constant resolution complexity for  i   with any single one of the listed abstractions  feasibility of the
easy to refute sub task can be accomplished in a simple manner  hence proving the theorem 
in order to construct planning tasks whose cnf encodings require exponential size
resolution refutations  we resort to the pigeon hole problem formula php i   it is well
known that any resolution proof of php i  must be of size exponential in i  haken        
we construct a simple pigeon hole planning task pp hp  i  to capture this problem  we
show that  for any of the four encoding methods  a  d   the cnf encoding for b i     
is either identical to php i   or transforms into php i  by variable restrictions  hence 
by proposition      any resolution refutation must have size exponential in i  the final
construction uses a combination of two such tasks  pp hp  i  serves as the hard to refute
sub task  and pp hp     on disjoint sets of pigeon and hole objects serves as the easy to refute
sub task 
essentially  theorem      states the intuitive fact that abstractions can make bad
choices  approximating away the most concise reason for why a planning task cannot be
solved in a particular number of steps  to illustrate the significance of this  consider once
more the comparison to mutex relations  an analogue of theorem      does not hold for
them  adding a mutex clause to a cnf encoding can only improve resolution complexity  in
that sense  mutex relations are considerably less risky than the abstractions we consider
here 
while the pigeon hole problem used in the proof of theorem      may seem artificial  it is
indeed contained as a sub problem in wide spread domains such as some of those concerned
with transportation  for example  in gripper  the available time steps serve as holes
and the actions picking dropping balls are the pigeons  for a related investigation  see
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

hoffmann et al          it also seems quite natural that a planning task may consist of two
disconnected parts  one of which is complex while the other one is easy to prove unsolvable
in the given number of steps  just think of transporting two packages  one of which is
close to many vehicles and requires just one more step than the bound allows  while the
other one is already inside a vehicle and needs to be transported along a single path of road
connections that is much longer than the bound  a concrete example for the latter situation
is formalized by hoffmann et al         
    a note on simplifications
as pointed out in section      there may be actions that after abstraction can obviously be
simplified without altering the semantics of the planning task  in particular  an abstraction
might create duplicate actions  that is  actions having identical preconditions and effects  
as well as redundant add effects  that are contained in the respective actions precondition  
it turns out that such a natural post abstraction simplification of the planning task can lead
to lower resolution complexity 
proposition       assume we use any of the encoding methods  a  d   there exist a
planning task p  a planning task p   that is identical to p except that either an irrelevant
add affect or a duplicate action have been removed  and b   n so that rc     rc     
where n is the length of a shortest plan in p  and  and   are the encodings of b step plan
existence in p and p     respectively 
proof sketch  to show the claim for duplicate actions  we consider a task p   encoding the
pigeon hole problem for   pigeons and   holes  with actions that put pigeon p into hole h 
the plan length bound is    to point out that the proof works for solvable tasks p  an
extra action a  whose preconditions are two of the goals and which achieves the third goal 
ensures solvability in two steps  there are three goals  one for each pigeon  and there are
no mutex clauses other than direct action interference  because each pair of goals can be
achieved  but not the three of them  in particular  every resolution refutation must resolve
on all three goal clauses  we obtain p by adding a duplicate action for one of the pigeons
and one of the holes  the respective goal clause then becomes one literal longer  any
refutation must get rid of that literal  hence necessitating one more step  the construction
works for all four encodings 
to show the claim for removal of redundant add effects  we slightly modify p     replacing
as effect with a new fact x and including another action that achieves the third goal given
the precondition x  the optimal plan length now is    and the length bound is    any
refutation must resolve on all three goal clauses  if  for p  we give a one of its preconditions
as an additional add effect  then the refutations become longer because the respective goal
clause does  again  the construction works for all four encodings 
it is easy to modify the constructions used in the proof of proposition      in a way
so that the duplicate action  respectively the redundancy of the add effect  arise as an
outcome of variable domain abstraction  hence  via enabling such simplifications  variable
domain abstraction may improve the resolution best case behavior  for duplicate actions 
this is also true for edelkamps        pattern database abstraction  it is an open question
   

fidomshlak  hoffmann    sabharwal

whether the improvement may be exponential  or whether it is bounded polynomially  we
conjecture that the latter is the case  at least for unrestricted resolution 
it is also notable that the examples in the proof to proposition      are specifically
constructed to include duplicate actions redundant add effects for actions that are relevant
to solving the problem  they form part of an optimal solution  in a well constructed variable
domain abstraction this is not likely to happen since abstraction should target only the facts
that are irrelevant to solution length  consider the logistics domain as an example  the
only actions on which simplifications apply are loads unloads of packages to from locations
in cities other than the packages origin and destination  these actions are involved only
in redundant solutions  and it seems doubtful that their simplification affects resolution
complexity  of course  these simplifications might help sat solvers anyway  this  however 
is not observed  at least not significantly  in our experiments 

   conclusion
abstractions  as used here  have the power to allow proving certain properties within much
smaller state spaces  in particular  if an abstraction preserves the length of an optimal
solution  then optimality can be proved within the abstraction  we designed a novel abstraction method for strips planning that is suitable for this purpose  surprisingly  the
approach yields little or no benefits for the planning as satisfiability approach as represented by satplan  even in domains featuring hand made abstractions with exponentially smaller state spaces  towards explaining this  we have shown that  in many cases 
our abstraction method  as well as some other commonly used abstractions  lacks the ability to introduce shorter resolution refutationsother than through exploiting mutexes  or
enabling certain post abstraction simplifications  in contrast  we have shown that these
abstractions may exponentially increase the size of the shortest resolution refutations 
several questions are left open by our theoretical results  we do not know whether variable domain abstraction can improve resolution complexity in combination with encoding
 b   whether there is a polynomial upper bound on the improvement that variable domain
abstraction can bring for encoding  d   and whether there is a polynomial upper bound on
the improvement that can result from simplifications  apart from answering these questions  most importantly it remains to be seen to what extent the results generalize  bluntly
stated  the intuition behind the results is that over approximations usually result in less
constrained formulas which are harder to refute  however  the actual technicalities of
the results depend quite a lot on the detailsof both encoding method and abstraction
and hence it is largely unclear to what extent this intuitive statement captures reality  in
particular  does it hold for other encodings of planning into sat 
it would be interesting  e g   to look at the alternative encodings described by kautz
and selman         kautz et al          kautz and selman         ernst  millstein  and
weld         many of these encodings are based on unit clauses for initial and goal state 
and action clauses stating that an action implies each of its effects and preconditions  with
such a structureand the lack of a mechanism such as a planning graph that propagates
changessome of the properties proved herein are obvious  removing goals or initial state
facts corresponds directly to removing clauses  the same is true for preconditions  removing
a fact completely may in some cases simply correspond to removing all clauses that mention
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

the fact  hence  for these encodings  it seems that proving our results might indeed be
comparatively easy  a more challenging subject may be some more recent developments 
such as the encodings by rintanen et al         which often give substantial speed ups
through novel notions of parallelity  the encodings by chen et al         which introduce
long distance mutex relations  or the encodings by robinson et al         which make use
of effective operator splitting and factoring methods 
more generally  do our results hold for methods employed in other fields  in particular 
do they hold in model checking  where both abstraction  e g   graf   sadi        clarke
et al         and sat encodings  e g   clarke  biere  raimi    zhu        prasad  biere 
  gupta        are highly successful  there is one example where it is actually obvious
that our results hold  gupta and strichman        abstract by ignoring clauses in a cnf
encoding of the original transition system  the motivation is that the much smaller cnf
formula causes less overhead in the sat solver  
most ambitiously  can we define a generic framework with formal notions of declarative
transition systems  cnf encodings  and abstractions that are suitable to capture our
results  and prove more generic statements  all these questions appear to be worthwhile
research challenges  indeed  we think that a key contribution of our work may lie in asking
the question about resolution complexity with vs  without an abstraction 
from a more practical perspective  we see mainly four lines of further research  first  an
important question is whether our observations carry over to modified extended planningas sat systems  such as as the one by ray and ginsberg        which guarantees plan
optimality through branching restrictions within a single sat call  rather than through
calling the sat solver iteratively  second  it remains open to explore whether very different
abstraction techniquesbased e g  on predicate abstractioncan be suitably adapted to
planning  third  it is important to note that our empirical results are not entirely negative 
mips bdd is often substantially improved  even up to the point where  as in figure    this
optimal sequential planner is highly competitive with a strong optimal parallel planner such
as satplan  and this in a highly parallel domain such as logistics  this is a direction that
may well be worth exploring in more depth  finally  more effective abstraction methods may
exist for unsolvable examples  and could potentially play a crucial role in over subscription
planning  sanchez   kambhampati        meuleau et al         

acknowledgments
we thank the anonymous reviewers  whose detailed comments helped greatly to improve
the paper  a preliminary version of this work appeared at icaps    the   th international
conference on automated planning and scheduling  hoffmann  sabharwal    domshlak 
       the work of carmel domshlak was supported by israel science foundation  isf 
grants         and          as well as by the c  wellner research fund  for part of
this work  jorg hoffmann was employed at max planck institute for computer science 
saarbrucken  germany  and at sap research  karlsruhe  germany  the work of ashish
sabharwal was supported by iisi  cornell university  afosr grant fa                
the national science foundation  nsf  expeditions in computing award  computational
   

fidomshlak  hoffmann    sabharwal

sustainability grant           nsf iis award  grant           and the defense advanced
research projects agency  darpa  real grant fa                

appendix a  proof details
proof of proposition      suppose the sequence  of transformations consists of   restrictions                      further  let    be the strengthening transformation that replaces each
clause of    with a  not necessarily strict  sub clause that is also a clause of   such a
transformation exists because of the assumptions in the proposition  observe that these
      transformation steps together convert  into a  not necessarily strict  sub formula of
  we will show that each of these       transformation steps individually does not increase
the resolution complexity of the underlying formula  without loss of generality  we will
prove this fact for a single restriction transformation and then for a generic strengthening
transformation  since each of these will individually be shown to not increase the resolution
complexity of the formula  they can be applied in any sequence or combination  any number
of times  without increasing the resolution complexity  this would prove  in particular  that
the resolution complexity of a sub formula of  is no more than that of    implying that
the resolution complexity of  itself is no more than that of   as additional initial clauses
cannot hurt a resolution refutation   as desired 
we start with a single restriction transformation x  y  for ease of notation  we
will assume that the initial formula is f    c    c            cm   and the resulting simplified
     with m   m  without loss of
formula after the transformation is f      c     c             cm
 
 
generality  we will assume that no ci equals the empty clause    and there are no duplicate
clauses in f     let     c    c            cm   cm             cm       be a resolution refutation of
f of the smallest possible size  note that  involves m initial clauses and m  m resolution
steps  from   we construct a resolution refutation    of f   which will be of size no larger
than that of   we do this in the following three steps 
step    transform  into     c            cm   cm             cm        where ci is defined as
follows  if the application of the transformation x  y results in ci containing true
or a variable and its negation  then ci equals true  if it results in ci containing
false or duplicate literals  ci consists of ci with false or a duplicate literal removed 
otherwise ci   ci   note that ci does not contain x and is either true  the empty
clause  or a non empty  not necessarily strict  sub clause of c  the key property
here is that ci is still a logical implicant of cj and ck if ci was derived by resolving
cj and ck in the original proof   ci may not necessarily be a usual resolution
resolvent of cj and ck   which is what the next two steps will fix 
step    transform  into     c            cm   cm             cm        where ci equals ci for
i  m and for i   m is defined sequentially  for increasing i  as follows  suppose
ci was derived in  by resolving clauses cj and ck   where j   k   i  assume
without loss of generality that we have already defined cj and ck   if ci equals
true  then ci equals true as well  otherwise  if one of the two clauses cj and ck
equals true  then ci equals the other clause  otherwise  cj and ck can be resolved
together on some variable and ci is the resolvent of these two clauses  the key
property here  which can be seen easily by considering the sequential nature of the
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

transformation  is that each ci is either true or a  not necessarily proper  subclause of ci   in particular  cm       further  each ci that does not equal true is
either the resolution resolvent of cj and ck   or equals    with one of cj and ck
also being    
step    finally  transform  into    by simply removing any clauses that equal true or
occur previously in the clause sequence  and stopping the sequence as soon as the
first empty clause is encountered  by construction      and  have exactly m
clauses each and    has no more than m clauses  further  the first m  clauses of
   are exactly the clauses of f   and    is a resolution refutation starting from these
initial clauses  as desired 
we now consider the strengthening transformation      which essentially replaces each
clause of the formula with a sub clause  thereby strengthening this clause   we will show
that applying    does not increase the resolution complexity of the underlying formula 
again  for ease of notation  let the initial formula be f    c    c            cm   with a resolution
refutation     c    c            cm   cm             cm       of the smallest possible size  the
argument here is along the same lines as but simpler than for restriction transformations 
transform  into     c            cm   cm             cm        where for i  m  ci equals the
sub clause of ci that    maps ci to  and for i   m  ci is defined sequentially  for increasing
i  as follows  suppose ci was derived in  by resolving clauses cj and ck on variable x 
where j   k   i  assume without loss of generality that we have already defined cj and
ck   if x is present in both cj and ck   then ci is simply the resolution resolvent of these
two clauses  otherwise  if x is not present in cj   then ci equals cj   otherwise x must not be
present in ck and we set ci to equal ck   the key property here  which can again be seen
easily by considering the sequential nature of the transformation  is that each ci is a  not
necessarily proper  sub clause of ci   in particular  cm       further  each ci is either cj
or ck or the resolution resolvent of the two  now transform  into    by simply removing
any clauses that occur previously in the clause sequence  by construction   and  have
exactly m clauses each and    has no more than m clauses  further  the first m  clauses of
   are exactly the clauses of f   and    is a resolution refutation starting from these initial
clauses  as desired 
proof of lemma      let p be a planning task to which an abstraction  that abstracts
p g p  is applied  let    denote propositional encodings of p and p    respectively 
where we use either the action only encoding  a  or the action fact encoding  b  for both
 and    let u denote the set of variables in  that are not variables of   finally 
let  be the variable restriction that sets every variable in u to false  in this setting  the
propositional formula    is nothing but the cnf encoding of the planning graph p g  p 
 using the same encoding method   a  or  b   as used for  and     in particular  all
clauses of  that correspond to actions and facts not in p g p  are trivially satisfied by
   because they all contain the negation of a variable in u   which is set to false by    call
the remaining  yet unsatisfied clauses in    the surviving clauses  we will argue that
each surviving clause is already present  perhaps in a stronger but not a weaker form  in 
itself  showing that it can be no easier to prove    unsatisfiable than it is to prove  itself
unsatisfiable 
   

fidomshlak  hoffmann    sabharwal

first consider encoding  a   by conditions     and     of definition      every surviving
precondition and goal clause in    has a corresponding clause in  itself  further  by
condition     concerning which facts are added by which action  each such precondition or
goal clause in    contains as a sub clause the corresponding clause in   finally  each
surviving mutex clauses in      by condition      is also present as a mutex clause in  
from these observations  it follows that every surviving clause in    contains as a  possibly
non strict  sub clause the corresponding clause in   applying proposition      we obtain
rc    rc     finishing the proof for encoding  a  
now consider encoding  b   first  because by definition     p g  p  and p g p  have
identical sets of vertices  in particular the fact vertices f     are the same  and hence each
surviving initial state clause in    is also present as an initial state clause in   further  precondition clauses are binary and  by condition     of definition      each surviving
precondition clause in    is also present as a precondition clause in   similarly  each
goal clause is a unit clause and  by condition      each surviving goal clause in    is also
present as a goal clause in   in a similar vein  each surviving mutex clause in    is also
present as a mutex clause in   finally  each surviving effect clause in      by condition
     contains as a sub clause the corresponding effect clause in      hence we again see
that every surviving clause in    contains as a  possibly non strict  sub clause the corresponding clause in   applying proposition     as before  we obtain rc    rc    
finishing the proof for encoding  b  
proof of lemma      let p be a planning task to which an abstraction  that respects
the behavior specified in the lemma is applied  we will show that the four conditions
in definition     hold for both p g  p  and p gred  p   observe that condition     in
definition     trivially holds because of property  b  of   we therefore focus on showing
that v  p g p     v  p g  p    v  p gred  p     v  p gred  p    and that conditions       
in definition     hold  in fact  once we show that p g  p  and p gred  p  have the same set
of vertices as the original  reduced  planning graph  conditions     and     of definition    
would be immediately satisfied due to properties  c    and  d  of   and all that would
remain would be condition      saying that no new mutex clauses are added by applying  
hence  our task is reduced to proving that the following four new properties hold at
each step t                b of the planning task 
 i  f   t   f  t  
 ii  a  t   a t  
 iii  ef mutex  t  f  t   ef  mutex  t   and

 iv  ea mutex
 t  a t   ea mutex  t  

where f  t   a t   ef  mutex  t   and ea mutex  t  denote the sets of facts  actions  including
noops   fact mutexes  and action mutexes generated for p at step t  and the  versions of
these denote the corresponding sets for p    for   f   t   ef mutex  t   denotes   f    f    
    what one needs here is only that add lists do not shrink by applying   however  another argument will
shortly require that add lists do not grow either  justifying the strict requirement of property  c  

   

fifriends or foes  on planning as satisfiability and abstract cnf encodings


ef mutex  t    f    f      the subset of ef mutex  t  restricted to the facts in   ea mutex
 t  

is defined similarly for   a  t  
in order to prove that these four properties hold  we give an inductive argument on t 
alternating between f  t  and ef  mutex  t  on one hand  and a t  and ea mutex  t  on the
other  for the base case of t      note that f       f     by property  a  of  and
ef mutex     f      ef  mutex     because both of these sets are empty 
in words  our goal is to prove that if certain facts and actions are available in p at a
certain step  they remain available in p    similarly  if two facts or actions are mutually
compatible in p  they remain mutually compatible in p    this seems intuitively justifiable
given the properties of   the following argument formalizes this intuition  in terms of
notation  we will use pre  del   and add to specify actions in p and pre    del    and add  to
specify actions in p   
for the first part of the inductive step  suppose f   t   f  t  and ef mutex  t  f  t  

ef  mutex  t   we will show that a  t   a t  and ea mutex
 t  a t   ea mutex  t   inductively
proving conditions  ii  and  iv  
let a  a t   then pre   a   f  t   f   t   further  f  f    pre   a   pre a  
f  t   we have that  f  f       ef  mutex  t   ef mutex  t  f  t  and hence  f  f       ef mutex  t  
therefore a  a  t   proving that a  t   a t  
now let a  a   a t  be such that  a  a      ea mutex  t   for the reduced planning graph

 t  due to properties
with only direct mutexes  we immediately have that  a  a      ea mutex

 c  and  d  of   and we are done proving that ea mutex  t  a t   ea mutex  t   otherwise  for
more general mutexes  several things hold  first  we have pre   a   pre a   f  t   f   t  
and the same for a    likewise  we have del   a   del  a  and del   a     del  a     finally 
by property  c   we have add   a   add  a   hence  c     pre   a   add   a    del   a    
 pre a add  a  del  a        the last equality holds because  a  a      ea mutex  t   similarly 
 c     pre   a   add   a    del   a      finally  for all f  pre   a   pre a   f  t   f   t 
and for all f    pre   a     pre a     f  t   f   t   we have that  f  f       ef  mutex  t  
ef mutex  t  f  t    which implies  c     f  f       ef mutex  t   from  c      c     and  c     we


have  a  a      ea mutex
 t   proving that ea mutex
 t  a t   ea mutex  t  

for the second part of the inductive step  suppose a  t   a t  and ea mutex
 t  a t  


ea mutex  t   we will show that f  t     f  t    and ef  mutex  t    f  t     ef  mutex  t 
    proving conditions  i  and  iii  
s
s
let f  f  t       then f  aa t  add  a   aa  t  add   a    recall that noop
actions are included in a t   so that we need not explicitly include f  t  in f  t        it
follows that f  f   t       proving that f   t       f  t      
now let f  f    f  t      be such that  f  f       ef  mutex  t       then there must exist
 
a  a  a t   a  t  such that  c    f  add  a   add   a    c    f    add  a     add   a  


and  a  a      ea mutex  t   ea mutex
 t  a t    which implies that  c     a  a      ea mutex
 t  
 


from  c      c     and  c     we have  f  f     ef  mutex  t       proving that ef  mutex  t  
   f  t     ef  mutex  t      
this finishes the inductive argument  showing that conditions  i  iv  outlined above
hold  by our earlier reasoning  this proves both that the vertices of p g p  and p g  p  
as well as their reduced counterparts  are the same  so that conditions     and     of
definition     follow directly from properties  c  and  d  of   and the mutex relations of
p  and red  p   restricted to the facts and actions of p  are a subset of the mutex relations

   

fidomshlak  hoffmann    sabharwal

and the reduced mutex relations  respectively  of p  so that condition     of definition    
holds   hence  abstracts the planning graph as well as the reduced planning graph of
p 
proof of lemma       let  be the abstraction that removes p from the initial facts and
the add lists of a given planning task p in which p does not appear in the goal facts and
any of the pre or del lists  as in the proof of lemma      let    denote propositional
encodings of p and p    respectively  where we use one of the encodings  a    b    c   and
 d  for both  and    we will show that for encodings  a  and  c    and  are in fact
identical  and for encodings  b  and  d   differ only in clauses that cannot be part of any
resolution proof 
to this end  we use the planning graph notation from the proof of lemma     and
begin by arguing by induction that f   t    f  t     p   ef mutex  t    ef  mutex  t      p  p     

p   f  t    a  t    a t   and ea mutex
 t    ea mutex  t   for the base case of t     

f       f      p  by the definition of   and ef mutex  t    ef  mutex       p  p      p   f     
because both these sets are empty  for the first part of the induction  suppose that the
inductive conditions on f and ef  mutex hold at time step t  since p is not in any pre list 
this implies that a  t    a t  as well  further  since p is not in any del list  we also

have ea mutex
 t    ea mutex  t   hence the conditions on a and ea mutex hold at time step
t  for the second part of the induction  suppose that the inductive conditions on a and
ea mutex hold at time step t  this implies that f  t      consists of f   t      and possibly
p  further  ef  mutex  t      and ef mutex  t      are the same as far as mutexes not involving
p are concerned  it follows that the conditions on f and ef  mutex hold at time step t     
finishing the induction 

to summarize  we have shown that at every step  the sets a  a and ea mutex   ea mutex
are exactly the same  and the sets f  f  and ef  mutex   ef mutex are the same up to facts or
pairs of facts involving p  in other words  no new actions or facts become available or are mutually excluded in the planning graph because of   and everything not involving p remains
unchanged  given this  observe that with any of the four encodings  the goal and precondition clauses of p  are exactly the same as those of p because p does not appear in the goal

or the pre lists at all  similarly  ea mutex
 t    ea mutex  t  and ef mutex  t    ef  mutex  t 

implies that the action mutexes of p   and fact mutexes if present in the encoding  are the
same as those of p as well  therefore  for encodings  a  and  c       
finally  for encodings  b  and  d   we have initial state  effect  and mutex clauses in
 which do get removed by applying   i e   which are not present in    however  these
are the only clauses that mention propositional variables corresponding to p  and each of
these variables appears only with one polarity throughout   namely  an initial state clause
 p     is the only clause that may contain p in positive polarity  all effect and mutex clauses
that contain p do so with a time index t      because of that  these clauses cannot be part
of any resolution refutation of every variable appearing in a resolution refutation must
eventually be resolved away in order to derive the empty clause  it follows that  and 
are the same with respect to resolution refutations 
proof of lemma       let p be a planning task to which   a variable domain abstraction 
is applied   combines two persistently mutex facts p and p  into a single fact p  for
brevity  let g denote p g p   define g   to be the graph obtained by unifying any p and
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

p  fact vertices in each fact layer of g into a single vertex p in that layer  and similarly
any noop p  and noop p    vertices in action layers  finally  let g  denote the subgraph
of p g p    induced by the vertices of g     we will show that g  is an abstracted planning
graph in a sense very similar to definition     
we begin by arguing that if an action pair  a  a    is mutex in p    then it is also mutex
in p  to see this  observe that the only way for  a  a    to become mutex per  requires 
w l o g   that in p  p  del  a   pre a  and p   pre a     add  a     suppose for the sake
of contradiction that  a  a    is not already mutex in p  in particular  this means that
p   del  a    and p is not mutex with any fact in pre a     this  however  implies that
 noop p   a    is not mutex in p so that the fact pair  p  p    is not mutex in the next layer
of p g p   a contradiction because p and p  are persistently mutex  it follows that edges
ea mutex in g  are a subset of those in g 
since g   and p  have the same initial facts  the above argument implies that all actions
and facts available at any layer of g   are also available at that layer of p g p     in particular 
g    by construction  has exactly the same set of vertices as g     further  since  is a variable
domain abstraction  edges eadd and epre in g   and g  are exactly the same 
define      u  and  as in the proof of lemma         is the cnf encoding  a 
of the planning graph g    and all clauses of  corresponding to actions and facts not in
g  are trivially satisfied by    call the remaining clauses in    the surviving clauses as
before 
by our observation about edges ea mutex in g  and g  the surviving mutex clauses of
   are also mutex clauses of   the surviving precondition and goal clauses not involving
p appear unchanged in   since we are considering a variable domain abstraction  the
actions achieving p in g  are precisely the actions achieving either of p and p  in g  hence 
the surviving precondition and goal clauses of    involving p contain as a sub clause
a precondition or goal clause of  itself  it follows from proposition     that rc   
rc    
proof of proposition       the same example planning task  denoted p  works for both
encoding  c  and encoding  d   let  denote the variable domain abstraction to be applied 
the example uses the following six facts  facts p and p    which will be glued together by  
goal facts g  and g    and helper facts x  y  based on these facts  the task p is defined as
follows 
 initial state  p   goal  g    g   
 action set a containing five actions 
getx     p    x    p   
gety       y     
getg      x    g    p      x   
getg      p  y    g      p   
getp     p      p    p     
the plan length bound is    which makes the problem infeasible  the shortest  parallel 
plan requires   steps  h getx  gety    getg      getp    getg   i  observe that all pairs of
actionsexcept  getg    getg    and any pair that involves getydirectly interfere with each
   

fidomshlak  hoffmann    sabharwal

other and are therefore mutex  in p g p   we get the following fact and action sets up to
step   
 f        p   a       noop p   getx  gety 
 f        p  x  y   a       noop p   noop x   noop y   getx  gety  getg    getg   
 f        p  x  y  g    g    p   
it is easy to verify  iteratively  that  in p g p   p and x are mutex in f      p and x are
mutex in f      p and p  are mutex in f      x and p  are mutex in f      all these mutexes
we get also in f      where the planning graph reaches its fixpoint  in particular  we have
that getg  and getg  are always  indirectly  mutex because their preconditions x and p
are persistently mutex  the variable domain abstraction  will glue p and p    converting
the conflict between getg  and getg  into a direct interference  thereby allowing a shorter
resolution refutation 
consider encoding  c  of p g p   it contains two goal clauses   getg       and
 getg        these clauses clearly must be used in any resolution refutation of the formula  because it is possible to achieve each goal individually within the given time bound 
but not both together  hence  a shortest refutation must involve at least two steps  we
argue that such a shortest refutation can be achieved in the abstracted task p  but not in
p itself 
in p    we get the same fact and action sets in the planning graph  except that f      
 p  x  y  g    g     i e   p  is of course not present  and both a    and a    contain also getp
that acts here similarly to noop p   the corresponding encoding  c  consists of exactly
the same clauses as before  plus clauses with noop p  being mirrored with getp   except
that we get the additional clause  getg       getg        this mutex clauses arises because
getg  interferes directly with getg   rather than only indirectly through incompatible preconditions   because now getg  adds p instead of p    and p is deleted by getg    this yields a
trivial two step  tree like  resolution proof for p    using the two goal clauses and the mutex
clause  namely  resolve the second goal clause and the mutex clause deriving  getg       
and then resolve this clause with the first goal clause   on the other hand  in the original
task p  getg  and getg  are not marked mutex in layer a     because they dont directly
interfere  therefore  the corresponding mutex clause is not immediately available  and any
resolution proof takes more than two steps because it must reason about and involve x 
encoding  d  works similarly  and  lets us derive the new mutex clause discussed
above  the goal clauses in this case are simply  g       and  g        from these  using the
two corresponding effect clauses  we can derive the two goal clauses of encoding  c  in two
steps  from here  the two step refutation discussed above derives the empty clause  thus 
we have a four step resolution refutation for p  in encoding  d   there is no similarly small
resolution refutation in p itself  because any such refutation must  as mentioned earlier 
reason on x to figure out that getg      and getg      cannot both be true 
proof of theorem       we construct a family of strips tasks whose cnf encodings are
very similar to the pigeon hole problem formula php i   it is well known that any
resolution proof of php i  must be of size exponential in i  haken         concretely 
php i  is an unsatisfiable formula encoding the fact that there is no way to assign i    
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

pigeons to i holes such that each pigeon is assigned to at least one hole and no hole gets
more than one pigeon  the formula has i i      variables xp h where p              i       h 
            i   for each pigeon p  there is a pigeon clause  xp     xp             xp n    and for each pair
of pigeons  p  q  and hole h  there is a hole clause  xp h   xq h   
the pigeon hole planning task pp hp  i  is defined as follows  for each pigeon p  there is
a fact assigned  p   for each hole h  there is a fact free h   the initial state contains all i free
facts but no assigned facts  the goal state contains all i   assigned facts  the only available
actions  other than noops  are put p  h   which puts pigeon p into a free hole h  after which
h no longer remains free  formally  put p  h      free h     assigned  p     free h     the
plan length bound b i  is set to   
consider any one of the four encoding methods  a  d   and let  i  be the encoding of
pp hp  i   restrict  i  by setting all noop variables to false  this has no real restrictive
implication in terms of planning since the plan length bound is   and none of the goal facts
are available at time step    for the action only encodings  a  and  c   identifying the
action variables put p  h  with the php i  variables xp h immediately yields precisely the
clauses of php i   the goal clauses of  i  become the pigeon clauses of php i  and the
action mutex clauses become the hole clauses  for the action fact encodings  b  and  d  
fix all free fact variables at time step   as well as all assigned fact variables at time step   to
true  and identify put p  h  action variables as above with xp h   this again yields precisely
the clauses of php i   it follows from the resolution hardness of php i  and proposition    
that any resolution proof of the fact that the planning task pp hp  i  does not have a plan
of length   must require size exponential in i 
the claim now follows from a planning task p    i  which consists of a combination of two
disconnected pigeon hole planning sub tasks  pp hp  i  and pp hp      over two separate sets
of pigeon and hole objects  the goal for p    i  is naturally defined as follows  put the first
set of i     pigeons into the first set of i holes and put the second set of two pigeons into
the second set of holes  which consists of only a single hole   the overall cnf encoding
   i  of p    i  is the logical conjunction of the encodings  i  and      on disjoint sets
of variables  of pp hp  i  and pp hp      observe that    i  can be proved unsatisfiable by
proving unsatisfiability of either of the two pigeon hole problems  in particular  there is a
constant size resolution refutation of    i  which involves refuting the     component 
on the other hand  we argue that all of the listed abstractions can make the one hole
component of p    i  trivially satisfiable  so that a resolution refutation of the abstracted
task must resort to a proof of unsatisfiability of the i hole component  i  of p    i   which
we have shown requires exponential size  hence the single example p    i  serves to show the
claim for all combinations of abstraction method and cnf encoding 
it is easily verified that pp hp     becomes solvable when ignoring the precondition
free    of both put       and put        we can then put both pigeons into the single hole  the
same happens when ignoring the delete effect free    of both put       and put       when
ignoring the goal assigned      or when inserting assigned     into the initial state  or when
completely removing assigned      the one hole component of p    i  requires to assign only
one pigeon  which is of course possible  finally  for variable domain abstraction  note that
assigned     and assigned     are persistently mutex in pp hp     because the only actions
achieving them are put       and put        respectively  according to definition      we
can hence replace assigned     with assigned      in the resulting planning task  we have the
   

fidomshlak  hoffmann    sabharwal

single goal assigned     which can be achieved in   step by  for example  the put       action 
this concludes the argument 
proof of proposition       we first consider removal of duplicate actions  the same example planning task  denoted p     works for all four encodings  p   is defined as follows 
 fact set  r    r    g    g    g   
 initial state  r    r     goal  g    g    g   
 action set a containing seven actions 
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
help     g    g      g       
in this planning task  all actions that are applicable in the initial state consume one of
the two resources r  or r    each of the actions achieves just one of the goals  so each pair of
goals can be reached  but not all three of them  the only solution is to perform two steps 
in the second of which the help action serves to accomplish g    we set the plan length
bound to   
the planning graph p g p     up to step   has no mutex relations other than the direct
mutexes between actions competing for the same resource  hence  encoding  a  is identical
to encoding  c   and encoding  b  is identical to encoding  d   the same properties clearly
hold also for the planning task p that is like p   except that it has an additional action     
identical to     
consider encoding  a  of p     the goal clauses are                                    
and                   the only other clauses are mutex clauses of the form  i j  i k  
it is not difficult to verify that a shortest resolution refutation involves    steps  one
such derivation proceeds via deriving                                                        
              each of these can be derived  in this sequence  with   steps involving resolution
against one mutex clause  for p  the only thing that changes is that we now have the clause
                           instead of                   plus the additional mutex clauses  now 
obviously every resolution refutation must resolve on all three goal clauses  to end up with
an empty clause  we hence additionally need to get rid of the literal           clearly  there
is no way to do this other than to resolve that literal away with an additional step involving
one of the new mutex clauses  hence the shortest possible resolution refutation now has
    steps 
for encoding  b   the resolution proofs first need to make three steps resolving the goal
clauses  g         g         g       with the respective effect clauses  g                       
 g                        and  g                        thereafter  matters are the same as
before 
to show the claim for removal of redundant add effects  we slightly modify the example 
and define p   as follows 
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

 fact set  r    r    g    g    g    x 
 initial state  r    r     goal  g    g    g   
 action set a containing eight actions 
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
        r      g      r     
help      g    g      x     
help      x    g       
in this task  the single help action from before is replaced with two help actions that need to
be applied consecutively  we set the plan length bound to    as before  the planning graph
p g p     has no mutex relations other than the direct mutexes between actions competing
for the same resource  encodings  a   c  and  b   d  respectively are identical  the same
properties clearly hold also for the planning task p that is like p   except that help  has the
additional add effect g   
consider encoding  a  of p     the goal clauses are                  noop g                 
        noop g         and                  noop g         refuting this now involves showing
that the three goals cannot all be achieved in step    nor in step    nor in a combination
of the two  any refutation needs to resolve on all three clauses  as before  for p we get
an additional literal in the first clause  which is now                  help    noop g        
clearly  getting rid of that additional literal involves at least one more resolution step  for
encoding  b   matters are essentially the same except that we first need to resolve the goal
fact clauses against the respective effect clauses 

references
ball  t   majumdar  r   millstein  t     rajamani  s          automatic predicate abstraction of c programs  in pldi      programming language design and implementation  pp         
beame  p   kautz  h     sabharwal  a          towards understanding and harnessing the
potential of clause learning  journal of artificial intelligence research             
beck  c   hansen  e   nebel  b     rintanen  j   eds            proceedings of the   th
international conference on automated planning and scheduling  icaps      aaai
press 
blum  a     furst  m          fast planning through planning graph analysis  artificial
intelligence                   
blum  a  l     furst  m  l          fast planning through planning graph analysis  in
mellish  s   ed    proceedings of the   th international joint conference on artificial
intelligence  ijcai      pp            montreal  canada  morgan kaufmann 
   

fidomshlak  hoffmann    sabharwal

boddy  m   fox  m     thiebaux  s   eds            proceedings of the   th international
conference on automated planning and scheduling  icaps      aaai press 
bonet  b     geffner  h          planning as heuristic search  artificial intelligence        
        
bonet  b     geffner  h          heuristics for planning with penalties and rewards formulated in logic and computed through circuits  artificial intelligence              
         
brafman  r          on reachability  relevance  and resolution in the planning as satisfiability approach  journal of artificial intelligence research          
chaki  s   clarke  e   groce  a   jha  s     veith  h          modular verification of software
components in c  in icse      int  conf  on software engineering  pp         
chen  y   huang  r   xing  z     zhang  w          long distance mutual exclusion for
planning  artificial intelligence                  
clarke  e  m   biere  a   raimi  r     zhu  y          bounded model checking using
satisfiability solving  formal methods in system design              
clarke  e  m   grumberg  o   jha  s   lu  y     veith  h          counterexample guided
abstraction refinement for symbolic model checking  journal of the association for
computing machinery                 
davis  m   logemann  g     loveland  d          a machine program for theorem proving 
communications of the acm                
davis  m     putnam  h          a computing procedure for quantification theory  journal
of the association for computing machinery                
edelkamp  s          planning with pattern databases  in cesta  a     borrajo  d   eds   
recent advances in ai planning   th european conference on planning  ecp    
pp        toledo  spain  springer verlag 
edelkamp  s          promela planning  in ball  t     rajamani  s   eds    proceedings
of the   th international spin workshop on model checking of software  spin     
pp          portland  or  springer verlag 
edelkamp  s     helmert  m          exhibiting knowledge in planning problems to minimize state encoding length  in biundo  s     fox  m   eds    recent advances in ai
planning   th european conference on planning  ecp     lecture notes in artificial
intelligence  pp          durham  uk  springer verlag 
ernst  m   millstein  t     weld  d          automatic sat compilation of planning problems  in pollack  m   ed    proceedings of the   th international joint conference on
artificial intelligence  ijcai      pp            nagoya  japan  morgan kaufmann 
fikes  r  e     nilsson  n  j          strips  a new approach to the application of theorem
proving to problem solving  artificial intelligence                 
gerevini  a   saetti  a     serina  i          planning through stochastic local search and
temporal action graphs  journal of artificial intelligence research             
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

graf  s     sadi  h          construction of abstract state graphs with pvs  in cav     
computer aided verification  pp       
gupta  a     strichman  o          abstraction refinement for bounded model checking  in
etessami  k     rajamani  s   eds    proceedings of the   th international conference
on computer aided verification  cav     lecture notes in computer science  pp 
        edinburgh  uk  springer verlag 
haken  a          the intractability of resolution  theoretical computer science         
    
haslum  p     geffner  h          admissible heuristics for optimal planning  in chien  s  
kambhampati  r     knoblock  c   eds    proceedings of the  th international conference on artificial intelligence planning systems  aips      pp          breckenridge  co  aaai press  menlo park 
haslum  p   botea  a   helmert  m   bonet  b     koenig  s          domain independent
construction of pattern database heuristics for cost optimal planning  in proceedings
of the twenty second aaai conference on artificial intelligence  aaai        pp 
          aaai press 
helmert  m     mattmuller  r          accuracy of admissible heuristic functions in selected planning domains  in proceedings of the   rd aaai conference on artificial
intelligence  pp          chicago  il  aaai press 
helmert  m   haslum  p     hoffmann  j          flexible abstraction heuristics for optimal
sequential planning   in boddy et al   boddy  fox    thiebaux         pp         
henzinger  t   jhala  r   majumdar  r     mcmillan  k          abstractions from proofs 
in popl      principles of programming languages  pp         
hernadvolgyi  i     holte  r          psvn  a vector representation for production systems 
tech  rep           university of ottawa 
hoffmann  j     edelkamp  s          the deterministic part of ipc    an overview  journal
of artificial intelligence research             
hoffmann  j     nebel  b          the ff planning system  fast plan generation through
heuristic search  journal of artificial intelligence research             
hoffmann  j          where ignoring delete lists works  local search topology in planning
benchmarks  journal of artificial intelligence research             
hoffmann  j   gomes  c     selman  b          structure and problem hardness  goal asymmetry and dpll proofs in sat based planning  logical methods in computer science 
        
hoffmann  j   sabharwal  a     domshlak  c          friends or foes  an ai planning
perspective on abstraction and search   in long    smith  long   smith         pp 
       
katz  m     domshlak  c          structural pattern heuristics via fork decomposition   in
beck et al   beck  hansen  nebel    rintanen         pp         
   

fidomshlak  hoffmann    sabharwal

kautz  h     selman  b          unifying sat based and graph based planning  in pollack  m   ed    proceedings of the   th international joint conference on artificial
intelligence  ijcai      pp          stockholm  sweden  morgan kaufmann 
kautz  h          satplan    planning as satisfiability  in edelkamp  s   hoffmann 
j   littman  m     younes  h   eds    proceedings of the  th international planning
competition  ipc      whistler  bc  canada 
kautz  h   selman  b     hoffmann  j          satplan  planning as satisfiability  in
gerevini  a   dimopoulos  y   haslum  p   saetti  a   bonet  b     givan  b   eds   
proceedings of the  th international planning competition  ipc      ambleside  uk 
kautz  h  a   mcallester  d     selman  b          encoding plans in propositional logic  in
aiello  l  c   doyle  j     shapiro  s   eds    principles of knowledge representation
and reasoning  proceedings of the  th international conference  kr      pp         
cambridge  ma  morgan kaufmann 
kautz  h  a     selman  b          planning as satisfiability  in neumann  b   ed   
proceedings of the   th european conference on artificial intelligence  ecai     
pp          vienna  austria  wiley 
kautz  h  a     selman  b          pushing the envelope  planning  propositional logic 
and stochastic search  in proceedings of the   th national conference of the american
association for artificial intelligence  aaai      pp            portland  or  mit
press 
knoblock  c  a          learning abstraction hierarchies for problem solving  in proceedings
of the  th national conference of the american association for artificial intelligence
 aaai      pp          boston  ma  mit press 
koehler  j   nebel  b   hoffmann  j     dimopoulos  y          extending planning graphs
to an adl subset   in steel    alami  steel   alami         pp         
koehler  j     hoffmann  j          on reasonable and forced goal orderings and their use
in an agenda driven planning algorithm  journal of artificial intelligence research 
           
long  d   kautz  h  a   selman  b   bonet  b   geffner  h   koehler  j   brenner  m  
hoffmann  j   rittinger  f   anderson  c  r   weld  d  s   smith  d  e     fox  m 
        the aips    planning competition  ai magazine               
long  d     smith  s   eds     icaps            proceedings of the   th international conference on automated planning and scheduling  icaps      ambleside  uk  morgan
kaufmann 
mcdermott  d          using regression match graphs to control search in planning  artificial intelligence                    
meuleau  n   brafman  r     benazera  e          stochastic over subscription planning
using hierarchies of mdps   in long    smith  long   smith         pp         
nebel  b   dimopoulos  y     koehler  j          ignoring irrelevant facts and operators in
plan generation   in steel    alami  steel   alami         pp         
   

fifriends or foes  on planning as satisfiability and abstract cnf encodings

prasad  m  r   biere  a     gupta  a          a survey of recent advances in sat based
formal verification  international journal on software tools for technlogy transfer 
              
ray  k     ginsberg  m  l          the complexity of optimal planning and a more efficient
method for finding solutions   in beck et al   beck et al          pp         
rintanen  j          evaluation strategies for planning as satisfiability  in saitta  l   ed   
proceedings of the   th european conference on artificial intelligence  ecai      pp 
        valencia  spain  wiley 
rintanen  j          planning graphs and propositional clause learning  in brewka  g    
doherty  p   eds    principles of knowledge representation and reasoning  proceedings of the   th international conference  kr      pp          sydney  australia 
aaai press 
rintanen  j   heljanko  k     niemela  i          planning as satisfiability  parallel plans and
algorithms for plan search  artificial intelligence  artificial intelligence              
         
robinson  j  a          a machine oriented logic based on the resolution principle  journal
of the association for computing machinery               
robinson  n   gretton  c   pham  d  n     sattar  a          a compact and efficient sat
encoding for planning   in beck et al   beck et al          pp         
sacerdoti  e          planning in a hierarchy of abstraction spaces  in proceedings of the
 rd international joint conference on artificial intelligence  ijcai      pp         
stanford  ca  william kaufmann 
sanchez  r     kambhampati  s          planning graph heuristics for selecting objectives in over subscription planning problems  in biundo  s   myers  k     rajan  k 
 eds    proceedings of the   th international conference on automated planning and
scheduling  icaps      pp          monterey  ca  usa  morgan kaufmann 
steel  s     alami  r   eds            recent advances in ai planning   th european conference on planning  ecp     vol       of lecture notes in artificial intelligence 
toulouse  france  springer verlag 
streeter  m     smith  s          using decision procedures efficiently for optimization   in
boddy et al   boddy et al          pp         

   

fi