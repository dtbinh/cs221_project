journal of artificial intelligence research              

submitted        published      

the dl lite family and relations
alessandro artale
diego calvanese

artale inf unibz it
calvanese inf unibz it

krdb research centre
free university of bozen bolzano
piazza domenicani    i       bolzano  italy

roman kontchakov
michael zakharyaschev

roman dcs bbk ac uk
michael dcs bbk ac uk

department of computer science and information systems
birkbeck college
malet street  london wc e  hx  u k 

abstract
the recently introduced series of description logics under the common moniker dllite has attracted attention of the description logic and semantic web communities due to
the low computational complexity of inference  on the one hand  and the ability to represent
conceptual modeling formalisms  on the other  the main aim of this article is to carry out
a thorough and systematic investigation of inference in extensions of the original dl lite
logics along five axes  by  i  adding the boolean connectives and  ii  number restrictions to
concept constructs   iii  allowing role hierarchies   iv  allowing role disjointness  symmetry 
asymmetry  reflexivity  irreflexivity and transitivity constraints  and  v  adopting or dropping the unique name assumption  we analyze the combined complexity of satisfiability
for the resulting logics  as well as the data complexity of instance checking and answering
positive existential queries  our approach is based on embedding dl lite logics in suitable fragments of the one variable first order logic  which provides useful insights into their
properties and  in particular  computational behavior 

   introduction
description logic  cf  baader  calvanese  mcguinness  nardi    patel schneider       and
references therein  is a family of knowledge representation formalisms developed over the
past three decades and  in recent years  widely used in various application areas such as 
 conceptual modeling  bergamaschi   sartori        calvanese et al       b       
mcguinness   wright        franconi   ng        borgida   brachman        berardi  calvanese    de giacomo        artale et al                   b  
 information and data integration  beeri  levy    rousset        levy   rousset 
      goasdoue  lattes    rousset        calvanese et al       a      a      b 
      noy        meyer  lee    booth        
 ontology based data access  dolby et al         poggi et al       a  heymans et al  
      
 the semantic web  heflin   hendler        horrocks  patel schneider    van harmelen        
c
    
ai access foundation  all rights reserved 

fiartale  calvanese  kontchakov   zakharyaschev

description logics  dls  for short  underlie the standard web ontology language owl  
which is now in the process of being standardized by the w c in its second edition  owl   
the widespread use of dls as flexible modeling languages stems from the fact that 
similarly to more traditional modeling formalisms  they structure the domain of interest into
classes  or concepts  in the dl parlance  of objects with common properties  properties
are associated with objects by means of binary relationships  or roles  to other objects 
constraints available in standard dls also resemble those used in conceptual modeling
formalisms for structuring information  is a hierarchies  i e   inclusions  and disjointness
for concepts and roles  domain and range constraints for roles  mandatory participation in
roles  functionality and more general numeric restrictions for roles  covering within concept
hierarchies  etc  in a dl knowledge base  kb   these constraints are combined to form a
tbox asserting intensional knowledge  while an abox collects extensional knowledge about
individual objects  such as whether an object is an instance of a concept  or two objects are
connected by a role  the standard reasoning services over a dl kb include checking its
consistency  or satisfiability   instance checking  whether a certain individual is an instance
of a concept   and logic entailment  whether a certain constraint is logically implied by
the kb   more sophisticated services are emerging that can support modular development
of ontologies by checking  for example  whether one ontology is a conservative extension
of another with respect to a certain vocabulary  see  e g   ghilardi  lutz    wolter       
cuenca grau  horrocks  kazakov    sattler        kontchakov  wolter    zakharyaschev 
      kontchakov  pulina  sattler  schneider  selmer  wolter    zakharyaschev        
description logics have recently been used to provide access to large amounts of data
through a high level conceptual interface  which is of relevance to both data integration and
ontology based data access  in this setting  the tbox constitutes the conceptual  high level
view of the information managed by the system  and the abox is physically stored in a
relational database and accessed using the standard relational database technology  poggi
et al       a  calvanese et al          the fundamental inference service in this case is answering queries to the abox with the constraints in the tbox taken into account  the kind
of queries that have most often been considered are first order conjunctive queries  which
correspond to the commonly used select project join sql queries  the key properties
for such an approach to be viable in practice are  i  efficiency of query evaluation  with the
ideal target being traditional database query processing  and  ii  that query evaluation can
be done by leveraging the relational technology already used for storing the data 
with these objectives in mind  a series of description logicsthe dl lite familyhas
recently been proposed and investigated by calvanese  de giacomo  lembo  lenzerini 
and rosati                  a   and later extended by artale  calvanese  kontchakov 
and zakharyaschev      a   poggi  lembo  calvanese  de giacomo  lenzerini  and rosati
     a   most logics of the family meet the requirements above and  at the same time  are
capable of representing many important types of constraints used in conceptual modeling 
in particular  inference in various dl lite logics can be done efficiently both in the size
of the data  data complexity  and in the overall size of the kb  combined complexity  
it was shown that kb satisfiability in these logics is polynomial for combined complexity 
while answering queries is in ac  for data complexitywhich  roughly  means that  given a
   http   www w  org      owl 

 

fithe dl lite family and relations

conjunctive query over a kb  the query and the tbox can be rewritten  independently of the
abox  into a union of conjunctive queries over the abox alone   it is to be emphasized that
the data complexity measure is very important in the application context of the dl lite
logics  since one can reasonably assume that the size of the data largely dominates the size
of the tbox   query rewriting techniques have been implemented in various systems such as
quonto   acciarri  calvanese  de giacomo  lembo  lenzerini  palmieri    rosati       
poggi  rodriguez    ruzzi      b   rowlkit  corona  ruzzi    savo         owlgres
 stocker   smith        and requiem  perez urbina  motik    horrocks         it has
also been demonstrated  kontchakov et al         that developing  analyzing and re using
dl lite ontologies  tboxes  can be supported by efficient tools capable of checking various
types of entailment between such ontologies with respect to given vocabularies  in particular 
by minimal module extraction tools  kontchakov et al        which do not yet exist for
richer languages 
the significance of the dl lite family is testified by the fact that it forms the basis
of owl   ql  one of the three profiles of owl     the owl   profiles are fragments of
the full owl   language that have been designed and standardized for specific application
requirements  according to  the current version of  the official w c profiles document  the
purpose of owl   ql is to be the language of choice for applications that use very large
amounts of data and where query answering is the most important reasoning task 
the common denominator of the dl lite logics constructed so far is as follows   i  quantification over roles and their inverses is not qualified  in other words  in concepts of the
form r c we must have c      and  ii  the tbox axioms are concept inclusions that cannot represent any kind of disjunctive information  say  that two concepts cover the whole
domain   the other dl lite related dialects were designedwith the aim of capturing
more conceptual modeling constraints  but in a somewhat ad hoc mannerby extending
this core language with a number of constructs such as global functionality constraints 
role inclusions and restricted boolean operators on concepts  see section   for details  
although some attempts have been made  calvanese et al         artale et al       a 
kontchakov   zakharyaschev        to put the original dl lite logics into a more general
perspective and investigate their extensions with a variety of dl constructs required for
conceptual modeling  the resulting picture still remains rather fragmentary and far from
comprehensive  a systematic investigation of the dl lite family and relatives has become
even more urgent and challenging in view of the choice of the constructs to be included in
the specification of the owl   ql profile   in particular  because owl does not make the
unique name assumption  una  which was usually adopted in dl lite  and uses equalities
and inequalities between object names instead  
the main aim of this article is to fill in this gap and provide a thorough and comprehensive understanding of the interaction between various dl lite constructs and their impact
on the computational complexity of reasoning  to achieve this goal  we consider a spectrum
of logics  classified according to five mutually orthogonal features 
    the presence or absence of role inclusions 
   http   www dis uniroma  it quonto 
   http   www w  org tr owl  profiles 
   http   www w  org tr owl  profiles  owl   ql

 

fiartale  calvanese  kontchakov   zakharyaschev

    the form of the allowed concept inclusions  where we consider four classes  called core 
krom  horn  and bool  that exhibit different computational properties 
    the form of the allowed numeric constraints  ranging from none  to global functionality
constraints only  and to arbitrary number restrictions 
    the presence or absence of the unique name assumption  and the equalities and inequalities between object names  if this assumption is dropped   and
    the presence or absence of standard role constraints such as disjointness  symmetry 
asymmetry  reflexivity  irreflexivity  and transitivity 
for all the resulting cases  we investigate the combined and data complexity of kb satisfiability and instance checking  as well as the data complexity of query answering  the
obtained tight complexity results are summarized in section      table   and remark      
as already mentioned  the original motivation and distinguishing feature for the logics in
the dl lite family was their lite ness in the sense of low computational complexity of the
reasoning tasks  query answering in ac  for data complexity and tractable kb satisfiability
for combined complexity   in the broader perspective we take here  not all of our logics
meet this requirement  in particular  those with krom or bool concept inclusions   however 
we identify another distinguishing feature that can be regarded as the natural logic based
characterization of the dl lite family  embeddability into the one variable fragment of firstorder logic without equality and function symbols  this allows us to relate the complexity of
dl lite logics to the complexity of the corresponding fragments of first order logic  and thus
to obtain a deep insight into the underlying logical properties of each dl lite variant  for
example  most upper complexity bounds established below follow from this embedding and
well known results on the classical decision problem  see  e g   borger  gradel    gurevich 
      and descriptive complexity  see  e g   immerman        
one of the most interesting findings in this article is that number restrictions  even
expressed locally  instead of global role functionality  can be added to the original dl lite
logics  under the una and without role inclusions  for free  that is  without changing
their computational complexity  the first order approach shows that in most cases we can
also extend the dl lite logics with the role constraints mentioned above  again keeping the
same complexity  it also gives a framework to analyze the effect of adopting or dropping
the una and using  in equalities between object names  for example  we observe that if
equality is allowed in the language of dl lite  which only makes sense without the una 
then query answering becomes logspace complete for data complexity  and therefore not
first order rewritable  it also turns out that dropping the una results in p hardness of
reasoning  for both combined and data complexity  in the presence of functionality constraints  nlogspace hardness was shown by calvanese et al          and in np hardness
if arbitrary number restrictions are allowed 
another interesting finding is the dramatic impact of role inclusions  when combined
with number restrictions  or even functionality constraints   on the computational complexity of reasoning  as was already observed by calvanese et al          such a combination increases data complexity of instance checking from membership in logspace to
   note  by the way  that logics with bool concept inclusions turn out to be quite useful in conceptual
modeling and reasonably manageable computationally  kontchakov et al         

 

fithe dl lite family and relations

nlogspace hardness  we show here that the situation is actually even worse  for data
complexity  instance checking turns out to be p complete in the case of core and horn
logics and conp complete in the case of krom and bool logics  moreover  kb satisfiability 
which is nlogspace complete for combined complexity in the simplest core casei e   efficiently tractable  when role inclusions or number restrictions are used separatelybecomes
exptime completei e   provably intractable  when they are used together 
to retain both role inclusions and functionality constraints in the language and keep
complexity within the required limits  poggi et al       a  introduced another dl lite
dialect  called dl litea   which restricts the interaction between role inclusions and functionality constraints  here we extend this result by showing that the dl lite logics with
such a limited interaction between role inclusions and number restrictions can still be embedded into the one variable fragment of first order logic  and so exhibit the same behavior
as their fragments with only role inclusions or only number restrictions 
the article is structured in the following way  in section    we introduce the logics of the
extended dl lite family and illustrate their features as conceptual modeling formalisms 
in section    we discuss the reasoning services and the complexity measures to be analyzed
in what follows  and give an overview of the obtained complexity results  in section   
we place the introduced dl lite logics in the context of the original dl lite family  and
discuss its relationship with owl    in section    we study the combined complexity of
kb satisfiability and instance checking  while in section    we consider the data complexity
of these problems  in section    we study the data complexity of query answering  in
section    we analyze the impact of dropping the una and adding  in equalities between
object names on the complexity of reasoning  section   concludes the article 

   the extended dl lite family of description logics
description logic  baader et al         is a family of logics that have been studied and
used in knowledge representation and reasoning since the     s  in dls  the elements of
the domain of interest are structured into concepts  unary predicates   and their properties
are specified by means of roles  binary predicates   complex concept and role expressions
 or simply concepts and roles  are constructed  starting from a set of concept and role
names  by applying suitable constructs  where the set of available constructs depends on
the specific description logic  concepts and roles can then be used in a knowledge base to
assert knowledge  both at the intensional level  in a so called tbox  t for terminological  
and at the extensional level  in a so called abox  a for assertional   a tbox typically
consists of a set of axioms stating the inclusion between concepts and roles  in an abox  one
can assert membership of objects  i e   constants  in concepts  or that a pair of objects is
connected by a role  dls are supported by reasoning services  such as satisfiability checking
and query answering  that rely on their logic based semantics 
    syntax and semantics of the logics in the dl lite family
we introduce now the  extended  dl lite family of description logics  which was initially
proposed with the aim of capturing typical conceptual modeling formalisms  such as uml
class diagrams and er models  see section     for details   while maintaining good computational properties of standard dl reasoning tasks  calvanese et al          we begin
 

fiartale  calvanese  kontchakov   zakharyaschev

by defining the logic dl litehn
bool   which can be regarded as the supremum of the original
dl lite family  calvanese et al                   b  in the lattice of description logics 
hn
dl litehn
bool   the language of dl litebool contains object names a    a            concept names
a    a            and role names p    p            complex roles r and concepts c of this language
are defined as follows 

pk  

r

   

pk

 

b

   



 

ak

 

 q r 

c

   

b

 

c

 

c  u c   

where q is a positive integer  the concepts of the form b will be called basic 
a dl litehn
bool tbox  t   is a finite set of concept and role inclusion axioms  or simply
concept and role inclusions  of the form 
c  v c 

and

r  v r   

and an abox  a  is a finite set of assertions of the form 
ak  ai   

ak  ai   

pk  ai   aj  

and

pk  ai   aj   

taken together  t and a constitute the dl litehn
bool knowledge base k    t   a   in the
following  we denote by role k  the set of role names occurring in t and a  by role  k 
the set  pk   pk   pk  role k    and by ob a  the set of object names in a  for a role r 
we set 
 
pk   if r   pk  
inv r   
pk   if r   pk  
as usual in description logic  an interpretation  i    i   i    consists of a nonempty
domain i and an interpretation function i that assigns to each object name ai an element
aii  i   to each concept name ak a subset aik  i of the domain  and to each role name
pk a binary relation pki  i  i over the domain  unless otherwise stated  we adopt
here the unique name assumption  una  
aii    aij

for all

i    j 

 una 

however  we shall always indicate which of our results depend on the una and which do
not  and when they do depend on this assumption  we discuss also the consequences of
dropping it  see also sections   and    
the role and concept constructs are interpreted in i in the standard way 
 pk  i     y  x   i  i    x  y   pki   
i



i

  q r 

   

 
  x  i     y  i    x  y   ri    q  

 c i   i   c i  
i

 c  u c   

 

c i



 inverse role 
 the empty set 
 at least q r successors 
 not in c 

c i  

 both in c  and in c   

 

fithe dl lite family and relations

where  x denotes the cardinality of x  we will use standard abbreviations such as
c  t c     c  u c    

     

r       r  

 q r     q     r  

concepts of the form  q r and  q r are called number restrictions  and those of the form
r are called existential concepts 
the satisfaction relation    is also standard 
i    c  v c 

iff

c i  c i  

i    r  v r 

iff

r i  r i  

i    ak  ai  

iff aii  aik  

i    pk  ai   aj  

iff

 aii   aij    pki  

i    ak  ai  

iff aii 
  aik  

i    pk  ai   aj  

iff

 aii   aij   
  pki  

a knowledge base k    t   a  is said to be satisfiable  or consistent  if there is an interpretation  i  satisfying all the members of t and a  in this case we write i    k  as well as
i    t and i    a  and say that i is a model of k  and of t and a  
the languages of the dl lite family we investigate in this article are obtained by restricting the language of dl litehn
bool along three axes   i  the boolean operators  bool   on
concepts   ii  the number restrictions  n   and  iii  the role inclusions  or hierarchies  h  
similarly to classical logic  we adopt the following definitions  a dl litehn
bool tbox t
will be called a krom tbox   if its concept inclusions are restricted to 
b  v b   

b  v b 

or

b  v b 

 krom 

 here and below all the bi and b are basic concepts   t will be called a horn tbox if its
concept inclusions are restricted to 
l
bk v b
 horn 
k

 by definition  the empty conjunction is     finally  we will call t a core tbox if its
concept inclusions are restricted to 
b  v b 

or

b  v b   

 core 

as b  v b  is equivalent to b  u b  v   core tboxes can be regarded as sitting in the
intersection of krom and horn tboxes 
remark     we will sometimes use conjunctions
on the right hand side of concept includ
sions in these restricted languages  c v k bk   clearly  this syntactic sugar does not add
any extra expressive power 
hn
hn
hn
dl litehn
krom   dl litehorn and dl litecore   the fragments of dl litebool with krom 
hn
hn
horn  and core tboxes will be denoted by dl litekrom   dl litehorn and dl litehn
core   respectively  other fragments are obtained by limiting the use of number restrictions and role
inclusions 

   the krom fragment of first order logic consists of all formulas in prenex normal form whose quantifier free
part is a conjunction of binary clauses 

 

fiartale  calvanese  kontchakov   zakharyaschev

hn
dl liteh
   the fragment of dl lite      core  krom  horn  bool   without number
restrictions  q r  for q      but with role inclusions  will be denoted by dl liteh
   note
h
that  in dl lite   we can still use existential concepts r  that is     r  
hf
dl litehf
the fragment of dl litehn
in which of all number
   denote by dl lite

restrictions  q r  we have existential concepts  with q      and only those with q    
that occur in concept inclusions of the form    r v   such an inclusion is called a
global functionality constraint because it states that role r is functional  more precisely  if
i        r v   and both  x  y   ri and  x  z   ri   then y   z  
f
dl liten
   dl lite and dl lite   if role inclusions are excluded from the language 
then for each    core  krom  horn  bool  we obtain three fragments  dl liten
  with arbitrary number restrictions   dl litef
 with
functionality
constraints
and
existential
concepts

r   and dl lite  without number restrictions different from r  

as we shall see later on in this article  the logics of the form dl litehf
and dl litehn

  
even for    core  turn out to be computationally rather costly because of the interaction
between role inclusions and functionality constraints  or  more generally  number restrictions   on the other hand  for the purpose of conceptual modeling one may need both of
these constructs  cf  the example in section      a compromise can be found by artificially
limiting the interplay between role inclusions and number restrictions in a way similar to
the logic dl litea proposed by poggi et al       a  
for a tbox t   let vt denote the reflexive and transitive closure of the relation

 
 r  r      inv r   inv r       r v r   t
and let r t r  iff r vt r  and r  vt r  say that r  is a proper sub role of r in t if
r  vt r and r  
  t r 
 hn  

 hn  

dl lite   we now introduce the logics dl lite  
   core  krom  horn  bool  
hn
which  on the one hand  restrict the logics dl lite by limiting the interaction between
role inclusions and number restrictions in order to reduce complexity of reasoning  and  on
the other hand  include additional constructs  such as limited qualified existential quantifiers  role disjointness   a symmetry and  ir reflexivity constraints  which increase the
expressive power of the logics but do not affect their computational properties 
 hn  
dl lite
tboxes t must satisfy the conditions  a    a    below   we remind
the reader that an occurrence of a concept on the right hand  left hand  side of a concept
inclusion is called negative if it is in the scope of an odd  even  number of negations  
otherwise the occurrence is called positive  
 a    t may contain only positive occurrences of qualified number restrictions  q r c 
where c is a conjunction of concepts allowed on the right hand side of  concept
inclusions 
 a    if  q r c occurs in t   then t does not contain negative occurrences of number
restrictions  q   r or  q   inv r  with q      
 a    if r has a proper sub role in t   then t does not contain negative occurrences of
 q r or  q inv r  with q    
 

fithe dl lite family and relations

role
role
constraints inclusions
no

no

no

yes

disj 
 a sym 
 ir ref 
disj 
 a sym 
 ir ref 
tran 
a 

number
restrictions
r
r funct 
 qr
r
r funct 
 qr

concept inclusions
krom
horn
dl litekrom dl litehorn
dl litef
dl litef
krom
horn
n
dl litekrom dl liten
horn
h
dl liteh
dl lite
krom
horn
hf
dl litekrom dl litehf
horn
hn
dl litehn
dl lite
krom
horn

core
dl litecore
dl litef
core
dl liten
core
dl liteh
core
dl litehf
core
dl litehn
core

 hf  

bool
dl litebool
dl litef
bool
dl liten
bool
dl liteh
bool
dl litehf
bool
dl litehn
bool

 hf  

 hf  

 
r c funct a  dl lite hf
dl litekrom dl litehorn dl litebool
core
 hn  
 hn  
 hn  
 hn  
a 
 q r c
dl litecore
dl litekrom dl litehorn dl litebool

yes

 

 
r c funct a  dl lite hf
core

yes

 q r c a 

 hf   

dl litekrom

 

 hn   

 
dl lite hn
dl litekrom
core

 hf   

dl litehorn

 hn   

dl litehorn

 hf   

dl litebool

 hn   

dl litebool

restricted by  a    a    

table    the extended dl lite family 
 hn  

 it follows that no dl lite
tbox can contain both  say  a functionality constraint
   r v  and an occurrence of  q r c  for any q     
 hn  
additionally  dl lite
tboxes can contain role constraints  or axioms  of the form 
dis r    r    

asym pk   

sym pk   

irr pk   

and

ref pk   

the meaning of these new constructs is defined as usual  for an interpretation i    i   i   

 
   q r c i   x  i     y  c i    x  y   ri    q  
 i    dis r    r   
 i    asym pk  
 i    sym pk  
 i    irr pk  
 i    ref pk  

iff
iff

iff
iff
iff

r i  r i     roles r  and r  are disjoint  
pki   pk  i     role pk is asymmetric  

pki    pk  i

 pk is symmetric  

 x  x  
  pki for all x  i
 x  x   pki for all x  i

 pk is irreflexive  
 pk is reflexive  

it is to be emphasized that these extra constructs are often used in conceptual modeling
 hn  
and their introduction in dl lite
is motivated by the owl   ql proposal   note that
 hn  
dl lite
contains both dl liteh
and
dl liten

 as its proper fragments  
 hn   

 hn   

dl lite
 
for    bool  horn  krom  core   denote by dl lite
the extension
 hn  
of dl lite
with role transitivity constraints of the form tra pk    the meaning of which
is as expected 
 i    tra pk  

iff

 x  y   pki and  y  z   pki imply  x  z   pki   for all x  y  z  i
 pk is transitive  
 

fiartale  calvanese  kontchakov   zakharyaschev

dl litebool

dl litehn


 
i
 
dl litehorn






dl litekrom






 
i
 

dl litecore

pp
i

 
dl litehf

 
dl liteh


dl liten


 hn     
dl lite
dl lite hn


 
 
 

 
pp
i


 

dl litef


 

 



ip
p
dl lite

  
 hf   dl lite
dl lite hf



figure    language inclusions in the extended dl lite family 
we remind the reader of the standard restriction limiting the use of transitive roles in dls
 see  e g   horrocks  sattler    tobies        
 only simple roles r are allowed in concepts of the form  q r  for q    
where by a simple role in a given tbox t we understand a role without transitive sub roles
 including itself   in particular  if t contains tra p   then p and p  are not simple  and
so t cannot contain occurrences of concepts of the form  q p and  q p    for q    
 hf  

 hf   

 hf  

dl lite
and dl lite  
we also define languages dl lite
as sub languages
 hn  
of dl lite  
in which only number restrictions of the form r  r c and functionality
constraints    r v  are allowedprovided  of course  that they satisfy  a    a     in
 hf   
particular  r c is not allowed if r is functional  as before  dl lite
are the extensions
 hf  
of dl lite
with role transitivity constraints  satisfying the restriction above  
thus  the extended dl lite family we consider in this article consists of    different
logics collected in table    the inclusions between these logics are shown in figure   
they are obtained by taking the product of the left  and right hand parts of the picture 
where the subscript  on the right hand part ranges over  core  krom  horn  bool   i e   the
subscripts on the left hand part  and similarly  the superscript  on the left hand part
ranges over     f  n   h  hf  hn    hf    hn     hf      hn       i e   the superscripts on
the right hand part 
the position of these logics relative to other dl lite logics known in the literature and
the owl   ql profile will be discussed in section    and starting from section    we begin
a thorough investigation of the computational properties of the logics in the extended dllite family  both with and without the una  but before that we illustrate the expressive
power of the dl lite logics by a concrete example 
    dl lite for conceptual modeling
a tight correspondence between conceptual modeling formalisms  such as the er model
and uml class diagrams  and various description logics has been pointed out in various
papers  e g   calvanese et al       b        borgida   brachman        berardi et al  
       here we give an example showing how dl lite logics can be used for conceptual
modeling purposes  for more details see the work by artale et al       b  
  

fithe dl lite family and relations

    

employee

    

empcode  integer
salary  integer

workson
boss
    
project

manager

projectname  string

    
    
 disjoint  complete 

areamanager

manages
topmanager

    

figure    a uml class diagram 
let us consider the uml class diagram depicted in figure   and representing  a portion
of  a company information system  according to the diagram  all managers are employees and are partitioned into area managers and top managers  this information can be
represented by means of the following concept inclusions  where in brackets we specify the
minimal dl lite language the inclusion belongs to  
manager v employee

 dl litecore  

areamanager v manager

 dl litecore  

topmanager v manager

 dl litecore  

areamanager v topmanager

 dl litecore  

manager v areamanager t topmanager

 dl litebool  

each employee has two functional attributes  empcode and salary  with integer values 
unlike owl  here we do not distinguish between abstract objects and data values  hence
we model a datatype  such as integer   by means of a concept  and an attribute  such as
employees salary  by means of a role  thus  salary can be represented as follows 
employee v salary
salary



 dl litecore  

v integer

 dl litecore  
 dl litef
core  

   salary v 

the functional attribute empcode with values in integer is represented in the same way 
the binary relationship workson has employee as its domain and project as its range 
workson v employee
workson



 dl litecore  

v project

 dl litecore  

the binary relationship boss with domain employee and range manager is treated analogously  each employee works on a project and has exactly one boss  while a project must
  

fiartale  calvanese  kontchakov   zakharyaschev

involve at least three employees 
employee v workson

 dl litecore  

employee v boss

 dl litecore  
 dl litef
core  

   boss v 
project v    workson 

 dl liten
core  

a top manager manages exactly one project and also works on that project  while a project
is managed by exactly one top manager 
manages v topmanager
manages



v project

 dl litecore  

topmanager v manages
project v manages

 dl litecore  
 dl litecore  



 dl litecore  

   manages v 

 dl litef
core  

   manages  v 

 dl litef
core  
 dl liteh
core  

manages v workson

all in all  the only languages in the extended dl lite family capable of representing the
 hn  
uml class diagram in figure   are dl litehn
bool and dl litebool   note  however  that except for the covering constraint  manager v areamanager t topmanager   all other concept
inclusions in the dl lite translation of the uml class diagram belong to variants of the
 hn  
core fragments dl litehn
core and dl litecore   it is not hard to imagine a situation where
one needs horn concept inclusions to represent integrity constraints over uml class diagrams  for example  to express  together with the above axioms  that no chief executive
officer may work on five projects and be a manager of one of them 
ceo u     workson  u manages v 

 dl liten
horn  

in the context of uml class diagrams  the krom fragment dl litekrom  with its variants 
seems to be useless  it extends dl litecore with concept inclusions of the form b  v b 
or  equivalently    v b  t b    which are rarely used in conceptual modeling  indeed 
this would correspond to partitioning the whole domain of interest in just two parts  while
more general and useful covering constraints of the form b v b  t    t bk require the full
bool language  on the other hand  the krom fragments are important for pinpointing the
borderlines of various complexity classes over the description logics of the dl lite family
and their extensions  see table   

   reasoning in dl lite logics
we discuss now the reasoning problems we consider in this article  their mutual relationships  and the complexity measures we adopt  we also provide an overview of the complexity
results for dl lite logics obtained in this article 

  

fithe dl lite family and relations

    reasoning problems
we will concentrate on three fundamental and standard reasoning tasks for description
logics  satisfiability  or consistency   instance checking  and query answering 
for a dl l in the extended dl lite family  we define an l concept inclusion as any
concept inclusion allowed in l  similarly  we define the notions of l kb and l tbox 
finally  define an l concept as any concept that can occur on the right hand side of an
l concept inclusion or a conjunction of such concepts 
satisfiability  the kb satisfiability problem is to check  given an l kb k  whether there
is a model of k  clearly  satisfiability is the minimal requirement for any ontology  as is
well known in dl  baader et al          many other reasoning tasks for description logics
are reducible to the satisfiability problem  consider  for example  the subsumption problem 
given an l tbox t and an l concept inclusion c  v c    decide whether t    c  v c   
that is  c i  c i   for every model i of t   to reduce this problem to  un satisfiability  take
a fresh concept name a  a fresh object name a  and set k    t     a   where
t     t   a v c    a v c   

and a    a a   

it is easy
d to see that t    c  v c  iff k is not satisfiable  for core  krom and horn kbs  if
c    k dk   where each dk is a  possibly negated  basic concept  checking unsatisfiability
of k amounts to checking unsatisfiability of each of the kbs kk    tk   a   where tk  
t   a v c    a v dk    for horn kbs  replace a v b with the equivalent a u b v   
the concept satisfiability problemgiven an l tbox t and an l concept c  decide
whether c i     in a model i of t is also easily reducible to kb satisfiability  indeed 
take a fresh concept name a  a fresh object name a  and set k    t     a   where
t     t   a v c 

and a    a a   

then c is satisfiable with respect to t iff k is satisfiable 
instance checking  the instance checking problem is to decide  given an object name a 
an l concept c and an l kb k    t   a   whether k    c a   that is  ai  c i   for every
model i of k  instance checking is also reducible to  un satisfiability  an object a is an
instance of an l concept c in every model of k    t   a  iff the kb k     t     a     with
t     t   a v c 

and

a    a   a a   

is notdsatisfiable  where a is a fresh concept name  for core  krom and horn kbs  if
c   k dk   where each dk is a  possibly negated  basic concept  we can proceed as for
subsumption  checking the unsatisfiability of k  amounts to checking the unsatisfiability of
each kb kk     tk    a    with tk    t   a v dk   
conversely  kb satisfiability is reducible to the complement of instance checking  k is
satisfiable iff k     a a   for a fresh concept name a and a fresh object a 
query answering  a positive existential query q x            xn   is any first order formula
 x            xn   constructed by means of conjunction  disjunction and existential quantification starting from atoms of the from ak  t  and pk  t    t     where ak is a concept name  pk
  

fiartale  calvanese  kontchakov   zakharyaschev

a role name  and t  t    t  are terms taken from the list of variables y    y          and the list of
object names a    a           i e    is a positive existential formula   more precisely 
t

   

yi

 



   

ak  t 

ai  
 

pk  t    t   

 

    

 

    

 

yi  

the free variables of  are called distinguished variables of q and the bound ones are nondistinguished variables of q  we write q x            xn   for a query with distinguished variables
x            xn   a conjunctive query is a positive existential query that contains no disjunction
 it is constructed from atoms by means of conjunction and existential quantification only  
given a query q  x      x  with  x   x            xn and an n tuple  a of object names  we
write q  a  for the result of replacing every occurrence of xi in   x  with the ith member of
 a  queries containing no distinguished variables will be called ground  they are also known
as boolean  
let i    i   i   be an interpretation  an assignment a in i is a function associating
with every variable y an element a y  of i   we will use the following notation  ai a
  aii
i
and y i a   a y   the satisfaction relation for positive existential formulas with respect to
a given assignment a is defined inductively by taking 
i   a ak  t 

iff

ti a  aik  

i   a pk  t    t   

iff

i a
i
 ti a
    t     pk  

i   a     

iff

i   a   and i   a    

i   a     

iff

i   a   or i   a    

i   a yi 

iff

i   b   for some assignment b in i that may differ from a on yi  

for a ground query q  a   the satisfaction relation does not depend on the assignment a 
and so we write i    q  a  instead of i   a q  a   the answer to such a query is either yes
or no 
for a kb k    t   a   we say that a tuple  a of object names from a is a certain answer
to q  x  with respect to k  and write k    q  a   if i    q  a  whenever i    k  the query
answering problem can be formulated as follows  given an l kb k    t   a   a query q  x  
and a tuple  a of object names from a  decide whether k    q  a  
note that the instance checking problem is a special case of query answering  an object
a is an instance of an l concept c with respect to a kb k iff the answer to the query a a 
with respect to k  is yes  where k     t     a  and t     t   c v a   with a a fresh
concept name  for horn concepts b  u    u bk   we consider the query a   a       ak  a 
with respect to k    where k     t     a  and t     t   b  v a            bk v ak    with
the ai fresh concept names  similarly  we deal with krom concepts d  u    u dk   where
each di is a possibly negated basic concept  for core concepts  the reduction holds just for
conjunctions of basic concepts 
    complexity measures  data and combined complexity
the computational complexity of the reasoning problems discussed above can be analyzed
with respect to different complexity measures  which depend on those parameters of the
  

fithe dl lite family and relations

problem that are regarded to be the input  i e   can vary  and those that are regarded to
be fixed  for satisfiability and instance checking  the parameters to consider are the size
of the tbox t and the size of the abox a  that is the number of symbols in t and a 
denoted  t   and  a   respectively  the size  k  of the knowledge k    t   a  is simply given
by  t      a   for query answering  one more parameter to consider would be the size of the
query  however  in our analysis we adopt the standard database assumption that the size
of queries is always bounded by some reasonable constant and  in any case  negligible with
respect to both the size of the tbox and the size of the abox  thus we do not count the
query as part of the input 
hence  we consider our reasoning problems under two complexity measures  if the whole
kb k is regarded as an input  then we deal with combined complexity  if  however  only
the abox a is counted as an input  while the tbox t  and the query  is regarded to be
fixed  then our concern is data complexity  vardi         combined complexity is of interest
when we are still designing and testing the ontology  on the other hand  data complexity is
preferable in all those cases where the tbox is fixed or its size  and the size of the query  is
negligible compared to the size of the abox  which is the case  for instance  in the context
of ontology based data access  calvanese  de giacomo  lembo  lenzerini  poggi    rosati 
      and other data intensive applications  decker  erdmann  fensel    studer        noy 
      lenzerini        calvanese et al          since the logics of the dl lite family were
tailored to deal with large data sets stored in relational databases  data complexity of both
instance checking and query answering is of particular interest to us 
    remarks on the complexity classes logspace and ac 
in this paper  we deal with the following complexity classes 
ac    logspace  nlogspace  p  np  exptime 
their definitions can be found in the standard textbooks  e g   garey   johnson       
papadimitriou        vollmer        kozen         here we only remind the reader of the
two smallest classes logspace and ac   
a problem belongs to logspace if there is a two tape turing machine m such that 
starting with an input of length n written on the read only input tape  m stops in an accepting or rejecting state having used at most log n cells of the  initially blank  read write work
tape  a logspace transducer is a three tape turing machine that  having started with an
input of length n written on the read only input tape  writes the result  of polynomial size 
on the write only output tape using at most log n cells of the  initially blank  read write
work tape  a logspace reduction is a reduction computable by a logspace transducer 
the composition of two logspace transducers is also a logspace transducer  kozen 
      lemma      
the formal definition of the complexity class ac   see  e g   boppana   sipser       
vollmer       and references therein  is based on the circuit model  where functions are
represented as directed acyclic graphs built from unbounded fan in and  or and not
gates  i e   and and or gates may have an unbounded number of incoming edges   for
this definition we assume that decision problems are encoded in the alphabet        and
so can be regarded as boolean functions  ac  is the class of problems definable using
  

fiartale  calvanese  kontchakov   zakharyaschev

a family of circuits of constant depth and polynomial size  which can be generated by
a deterministic turing machine in logarithmic time  in the size of the input   the latter
condition is called logtime uniformity  intuitively  ac  allows us to use polynomially
many processors but the run time must be constant  a typical example of an ac  problem
is evaluation of first order queries over databases  or model checking of first order sentences
over finite models   where only the database  first order model  is regarded as the input
and the query  first order sentence  is assumed to be fixed  abiteboul  hull    vianu       
vollmer         on the other hand  the undirected graph reachability problem is known to
be in logspace  reingold        but not in ac    a boolean function f         n        
is called ac   reducible  or constant depth reducible  to a function g         n         if
there is a  logtime uniform  family of constant depth circuits built from and  or  not
and g gates that computes f   in this case we say that there is an ac   reduction  note that
all the reductions considered in section     are ac   reductions  unless otherwise indicated 
in what follows we write reduction for ac   reduction 
    summary of complexity results
in this article  our aim is to investigate  i  the combined and data complexity of the satisfiability and instance checking problems and  ii  the data complexity of the query answering
problem for the logics of the extended dl lite family  both with and without the una 
 hf   
the obtained and known results for the first    logics from table    the logics dl lite
 hn   
and dl lite
are not included  are summarized in table    we remind the reader that
satisfiability and instance checking are reducible to the complements of each other and that
instance checking is a special case of query answering   in fact  all of the results in the
table follow from the lower and upper bounds marked with    and     respectively  by
taking into account the hierarchy of languages of the dl lite family   for example  the
nlogspace membership of satisfiability in dl liten
krom in theorem     implies the same
n
f
upper bound for dl litekrom   dl litekrom   dl litecore   dl litef
core and dl litecore because
 
all of them are sub languages of dl liten
krom
remark     two further complexity results are to be noted  they are not included in
table    
 i  if equality between object names is allowed in the language of dl lite  which only
makes sense if the una is dropped  then the ac  memberships in table   are replaced by logspace completeness  see section    theorem     and       inequality
constraints do not affect the complexity 
 ii  if we extend any of our languages with role transitivity constraints then the combined complexity of satisfiability remains the same  while for data complexity  instance
checking and query answering become nlogspace hard  see lemma       i e   the
membership in ac  for data complexity is replaced by nlogspace completeness 
while all other complexity results remain the same 
in either case  the property of first order rewritabilitythat is  the possibility of rewriting
a given query q and a given tbox t into a single first order query q  returning the certain
answers to q over  t   a  for every abox a  which ensures that the query answering problem
is in ac  for data complexityis lost 
  

fithe dl lite family and relations

complexity
languages

una

combined complexity
satisfiability

 h 
dl lite core
   h 
dl litehorn
   h 
dl litekrom
   h 
dl litebool
 n   hf    hn   
dl lite f
core
 f  n   hf    hn   
dl litehorn
 f  n   hf    hn   
dl litekrom
 f  n   hf    hn   
dl litebool
 f   hf   
dl litecore horn
 f   hf   
dl litekrom
 f   hf   
dl litebool
 n   hn   
dl litecore horn
 n   hn   
dl litekrom bool
dl litehf
core horn
dl litehf
krom bool
dl litehn
core horn
hn
dl litekrom bool

yes no

yes

no

yes no

data complexity
instance checking
 

query answering

nlogspace   a 

in ac

in ac 

p   th        a 

in ac 

in ac    c 

 

nlogspace   th     

in ac

conp   b 

np   th        a 

in ac    th     

conp

 

nlogspace

in ac

in ac 

p   th           

in ac 

in ac    th     

nlogspace   th          

in ac 

conp

 

np   th           

in ac   cor     

conp

p   cor        th     

p   th     

p

p   cor     

p

conp

np

p   cor     

conp

np   th     

conp   th     

conp

np   th     

conp

conp

exptime   th      

p   th     

p   d 

exptime

conp   th     

conp

exptime

conp   th     

conp

exptime   f 

conp

conp   e 

 a  complexity of the respective fragment of propositional boolean logic
 b  follows from the proof of the data complexity result for instance checking in ale  schaerf       
 c   calvanese et al        
 d  follows from horn shiq  hustadt  motik    sattler        eiter  gottlob  ortiz    simkus       
 e  follows from shiq  ortiz  calvanese    eiter              glimm  horrocks  lutz    sattler       
 f  follows from shiq  tobies       

table    complexity of dl lite logics  all the complexity bounds save in ac   are tight  

    n  
means any of dl lite            dl liten
dl lite 

 in particular  dl lite   h  is either dl lite or dl liteh
   

dl litecore horn means dl litecore or dl litehorn  likewise for dl litekrom bool   
  x     x   means that the upper  respectively  lower  bound follows from  x  

detailed proofs of our results will be given in sections     for the variants of logics
involving number restrictions  all upper bounds hold also under the assumption that the
numbers q in concepts of the form  q r are given in binary   intuitively  this follows from
the fact that in our proofs we only use those numbers that explicitly occur in the kb   all
lower bounds remain the same for the unary coding  since in the corresponding proofs we
only use numbers not exceeding   
in the next section we consider the extended dl lite family in a more general context by
identifying its place among other dl lite related logics  in particular the owl   profiles 
  

fiartale  calvanese  kontchakov   zakharyaschev

   the landscape of dl lite logics
the original family of dl lite logics was created with two goals in mind  to identify
description logics that  on the one hand  are capable of representing some basic features
of conceptual modeling formalisms  such as uml class diagrams and er diagrams  and 
on the other hand  are computationally tractable  in particular  matching the ac  data
complexity of database query answering 
as we saw in section      to represent uml class diagrams one does not need the typical quantification constructs of the basic description logic alc  schmidt schau   smolka 
       namely  universal restriction r c and qualified existential quantification r c  one
can always take the role filler c to be    indeed  domain and range restrictions for a
relationship p can be expressed by the concepts inclusions p v b  and p  v b    respectively  thus  almost all concept inclusions required for capturing uml class diagrams
are of the form b  v b  or b  v b    these observations motivated the introduction by
calvanese et al         of the first dl lite logic  which in our new nomenclature corresponds
to dl litef
core   their main results were a polynomial time upper bound for the combined
complexity of kb satisfiability and a logspace upper bound for the data complexity of
conjunctive query answering  under the una   these results were extended by calvanese
h
et al         to two larger languages  dl litef
horn and dl litehorn   which were originally
called dl liteu f and dl liteu r   respectively  calvanese et al       b  introduced another member of the dl lite family  named dl liter    which extended dl liteh
core with
role disjointness axioms of the form dis r    r     the computational behavior of the new
logic turned out to be the same as that of dl liteh
core   it may be worth mentioning that
dl liteh
covers
the
dl
fragment
of
rdfs
 klyne
  carroll        hayes         note
core
also that calvanese et al         considered the variants of both dl liteu f and dl liteu r
with arbitrary n ary relations  not only the usual binary roles  and showed that query answering in them is still in logspace for data complexity  we conjecture that similar results
can be obtained for the other dl lite logics introduced in this paper  artale et al       b 
demonstrated how n ary relations can be represented in dl litef
core by means of reification 
a further variant of dl lite  called dl litea  a for attributes   was introduced by
poggi et al       a  with the aim of capturing as many features of conceptual modeling
formalisms as possible  while still maintaining the computational properties of the basic
variants of dl lite  one of the features in dl litea   borrowed from conceptual modeling
formalisms and adopted also in owl  is the distinction between  abstract  objects and data
values  and consequently  between concepts  sets of objects  and datatypes  sets of data
values   and between roles  i e   object properties in owl  relating objects with objects 
and attributes  i e   data properties in owl  relating objects with data values   however 
as far as the results in this paper are concerned  the distinction between concepts and
datatypes  and between roles and attributes has no impact on reasoning whatsoever  since
datatypes can simply be treated as special concepts that are mutually disjoint and are also
disjoint from the proper concepts  instead  more relevant for reasoning is the possibility
to express in dl litea both role inclusions and functionality  i e   dl litea includes both
f
hf
dl liteh
core and dl litecore   but not dl litecore  
as we have already mentioned  role inclusions and functionality constraints cannot be
combined in an unrestricted way without losing the good computational properties  in

  

fithe dl lite family and relations

 
b
b

dl litehn
krom
b

b

b

   

shiq
dl litehn
horn
b

dl litehn
bool
b

   
b

dl litekrom
b

b

dl litehf
core
b

 hn  

b

b

b

p

b

dl litecore
 hf  
dl litecore

dl liten
core

 hn  

dl litehorn
 hf  
dl litehorn
dl liten
horn
 
dl litea u
b

b

b

b

b

dl litehf
horn

dl lite 
a
dl litea
dl litef   dl litef
dl litef  u   dl litef
core
horn
h
dl liter   dl litecore
dl liter u   dl liteh
horn
dl litecore
b

b

in ac 

dl litebool

horn shiq

conp

 

b

dl litehn
core

b

b

b

figure    the dl lite family and relations 
theorems      and      we prove that satisfiability of dl litehf
core kbs is exptime hard
for combined complexity  while instance checking is data hard for p  nlogspace hardness
was shown by calvanese et al          in dl litea   to keep query answering in ac  for
data complexity and satisfiability in nlogspace for combined complexity  functional roles
 and attributes  are not allowed to be specialized  i e   used positively on the right hand
side of role  and attribute  inclusion axioms  so  condition  a    is a slight generalization
of this restriction  dl litea also allows axioms of the form b v r c for non functional
roles r  which is covered by conditions  a    and  a     thus  dl litea can be regarded
 hf  
 hn  
as a proper fragment of both dl litecore and dl litehorn   we show in sections     and  
that these three languages enjoy very similar computational properties under the una 
tractable satisfiability and query answering in ac   
we conclude this section with a picture in figure   illustrating the landscape of dllite related logics by grouping them according to the data complexity of positive existential
query answering under the una  the original eight dl lite logics  called by calvanese
et al       b  the dl lite family  are shown in the bottom sector of the picture  the logics
 
dl lite 
a and dl litea u extend dl litea and dl litea u with identification constraints 
 hn  

which are out of the scope of this article   their nearest relatives are the logic dl litehorn
and its fragments  which are all in ac  as well  the next layer contains the logics dl litehf
core
and dl litehf
 
in
which
query
answering
is
data complete
for
p
 no
matter
whether
the
horn
una is adopted or not   in fact  these logics are fragments of the much more expressive dl
horn shiq  which was shown to enjoy the same data complexity of query answering by
eiter et al          it remains to be seen whether polynomial query answering is practically
feasible  recent experiments with the dl el  lutz  toman    wolter        indicate that
this may indeed be the case  finally  very distant relatives of the dl lite family comprise

  

fiartale  calvanese  kontchakov   zakharyaschev

the upper layer of the picture  where query answering is data complete for conp  that is 
the same as for the very expressive dl shiq 
    the dl lite family and owl  
the upcoming version   of the web ontology language owl  defines three profiles   that
is  restricted versions of the language that suit specific needs  the dl lite family  notably
dl liteh
core  or the original dl liter    is at the basis of one of these owl   profiles  called
owl   ql  according to http   www w  org tr owl  profiles   owl   ql is aimed at
applications that use very large volumes of instance data  and where query answering is the
most important reasoning task  in owl   ql           sound and complete conjunctive query
answering can be performed in logspace with respect to the size of the data  assertions 
 and  polynomial time algorithms can be used to implement the ontology consistency and
class expression subsumption reasoning problems  the expressive power of the profile is
necessarily quite limited  although it does include most of the main features of conceptual
models such as uml class diagrams and er diagrams  in this section  we briefly discuss
the results obtained in this article in the context of additional constructs that are present
in owl   
a very important difference between the dl lite family and owl is the status of the
unique name assumption  una   this assumption is quite common in data management 
and hence adopted in the dl lite family  but not adopted in owl  instead  the owl
syntax provides explicit means for stating that object names  say a and b  are supposed to
denote the same individual  a  b  or that they should be interpreted differently  a   b  in
owl  these constructs are called sameas and differentfrom  
the complexity results we obtain for logics of the form dl liteh
 do not depend on
whether the una is adopted or not  because every model of a dl liteh
 kb without una
can be untangled into a model of the same kb respecting the una  see lemma       
n
however  this is not the case for the logics dl litef
 and dl lite   where there is an obvious
interaction between the una and number restrictions  cf  table     for example  under the
 
una  instance checking for dl litef
core is in ac for data complexity  whereas dropping this
assumption results in a much higher complexity  in section    we prove that it is p complete 
h
the addition of the equality construct  to dl liteh
core and dl litehorn slightly changes
data complexity of query answering and instance checking  as it rises from membership in
ac  to logspace completeness  see section    what is more important  however  is that
in this case we loose first order rewritability of query answering and instance checking  and
as a result cannot use the standard database query engines in a straightforward manner 
since the owl   profiles are defined as syntactic restrictions of the language without
changing the basic semantic assumptions  it was chosen not to include in the owl   ql
profile any construct that interferes with the una and which  in the absence of the una 
would cause higher complexity  that is why owl   ql does not include number restrictions  not even functionality constraints  also  keys  the mechanism of identifying objects
by means of the values of their properties  are not supported  although they are an impor   http   www w  org      owl 
   in logic  profiles would be called fragments as they are defined by placing restrictions on the owl  
syntax only 

  

fithe dl lite family and relations

tant notion in conceptual modeling  indeed  keys can be considered as a generalization of
functionality constraints  toman   weddell              calvanese  de giacomo  lembo 
lenzerini    rosati      a      b   since asserting a unary key  i e   one involving only a
single role r  is equivalent to asserting the functionality of the inverse of r  hence  in the
absence of the una  allowing keys would change the computational properties 
as we have already mentioned  some other standard owl constructs  such as role disjointness   a symmetry and  ir reflexivity constraints  can be added to the dl lite logics
without changing their computational behavior  role transitivity constraints  tra r   as hn  
serting that r must be interpreted as a transitive role  can also be added to dl litehorn but
this leads to the increase of the data complexity for all reasoning problems to nlogspace 
although satisfiability remains in p for combined complexity  these results can be found
in section     
of other constructs of owl   that so far are not supported by the dl lite logics we
mention nominals  i e   singleton concepts   boolean operators on roles  and role chains 

   satisfiability  combined complexity
dl litehn
bool is clearly a sub logic of the description logic shiq  the satisfiability problem
for which is known to be exptime complete  tobies        
in section     we show  however  that the satisfiability problem for dl liten
bool kbs is
 
reducible to the satisfiability problem for the one variable fragment  ql   of first order logic
without equality and function symbols  as satisfiability of ql   formulas is np complete
 see  e g   borger et al         and the logics under consideration contain full booleans on
concepts  satisfiability of dl liten
bool kbs is np complete as well  we shall also see that the
translations of horn and krom kbs into ql  belong to the horn and krom fragments of
ql    respectively  which are known to be p  and nlogspace complete  see  e g   papadimitriou        borger et al          in section      we will show how to simulate the behavior of
polynomial space bounded alternating turing machines by means of dl litehf
core kbs  this
will give the  optimal  exptime lower bound for satisfiability of kbs in all the languages
of our family containing unrestricted occurrences of both functionality constraints and role
inclusions  in section      we extend the embedding into ql    defined in section      to the
 hn  
logic dl litebool   thereby establishing the same upper bounds as for dl liten
bool and its
fragments  finally  in section     we investigate the impact of role transitivity constraints 
    dl liten
bool and its fragments  first order perspective
our aim in this section is to construct a reduction of the satisfiability problem for dl liten
bool
kbs to satisfiability of ql   formulas  we will do this in two steps  first we present a lengthy
yet quite natural and transparent  yet exponential  reduction    and then we shall see from
the proof that this reduction can be substantially optimized to a linear reduction   

let k    t   a  be a dl liten
bool kb  recall that role  k  denotes the set of direct and
inverse role names occurring in k and ob a  the set of object names occurring in a  for
r  role  k   let qr
t be the set of natural numbers containing   and all the numbers q
for which the concept  q r occurs in t  recall that the abox does not contain number
restrictions   note that  qr
t      if t contains a functionality constraint for r 

  

fiartale  calvanese  kontchakov   zakharyaschev

with every object name ai  ob a  we associate the individual constant ai of ql  and
with every concept name ai the unary predicate ai  x  from the signature of ql    for each
role r  role  k   we introduce  qr
t   many fresh unary predicates
for q  qr
t 

eq r x  

the intended meaning of these predicates is as follows  for a role name pk  
 eq pk  x  and eq pk  x  represent the sets of points with at least q distinct pk  successors
and at least q distinct pk  predecessors  respectively  in particular  e  pk  x  and
e  pk  x  represent the domain and range of pk   respectively 
additionally  for every pair of roles pk   pk  role  k   we take two fresh individual constants
dpk
and
dp
k
of ql    which will serve as representatives of the points from the domains of pk and
 
pk   respectively  provided that they are not empty   let dr k    dr   r  role  k   
furthermore  for each pair of object names ai   aj  ob a  and each r  role  k   we take
a fresh propositional variable rai aj of ql  to encode the abox assertion r ai   aj    
 
by induction on the construction of a dl liten
bool concept c we define the ql  formula
c  
    

 ai     ai  x  

  q r    eq r x  

 c    c   x  

 c  u c      c   x   c   x  

 

the dl liten
bool tbox t corresponds then to the ql  sentence x t  x   where
 

t   x   
c   x   c   x   

   

c  vc  t

the abox a is translated into the following pair of ql   sentences
 
 
 
a  
ak  ai   
ak  ai   
a

 

 

 

   

ak  ai  a

ak  ai  a

pk ai aj



 

pk ai aj  

   

pk  ai  aj  a

pk  ai  aj  a

for every role r  role  k   we need two ql   formulas 
r  x    e  r x   inv e  r  inv dr   
 

r  x   
eq  r x   eq r x   

   
   

 
q q   qr
t   q  q
 
  
q  q  q for no q    qr
t

   in what follows  we slightly abuse notation and write r ai   aj    a to indicate that pk  ai   aj    a if
r   pk   or pk  aj   ai    a if r   pk  

  

fithe dl lite family and relations

where  by overloading the inv operator  
 
eq pk   if r   pk  
inv eq r   
eq pk   if r   pk  

and

 
dp
k 
inv dr   
dpk  

if r   pk  
if r   pk  

formula     says that if the domain of r is not empty then its range is not empty either 
it contains the constant inv dr   the representative of the domain of inv r  
we also need formulas representing the relationship of the propositional variables rai aj
with the unary predicates for the role domain and range  for a role r  role  k   let r be
the following ql   sentence
 

 

 

q
 


rai ajk  eq r ai  

ai ob a  qqr
aj       ajq ob a  k  
t
jk   jk  for k  k 



 


rai aj  inv r aj ai      

ai  aj ob a 

where inv r aj ai is the propositional variable pk aj ai if r   pk and pk aj ai if r   pk  
note that the first conjunct of     is the only part of the translation that relies on the una 
finally  for the dl liten
bool knowledge base k    t   a   we set
i
h  
h
 
 
i
 

a  a

r  
k   x t   x  
r  x   r  x 
rrole  k 

rrole  k 

thus  k is a universal sentence of ql   
example     consider  for example  the kb k    t   a  with

 
t   a v p    p  v a  a v    p    v    p    p v a
and a    a a   p  a  a      then we obtain the following first order translation 
k   x  x   a a   p aa  


p aa   e  p  a   p aa  e  p  a  


p a  a  e  p  a     p a  a   e  p  a    


p  aa   e  p   a   p  aa  e  p   a  


p  a  a  e  p   a     p  a  a   e  p   a    


p aa   p aa  e  p  a   p a  a  p a  a   e  p  a    


p  aa   p  aa  e  p   a   p  a  a  p  a  a   e  p   a    




p aa   p  a  a  p a  a  p  aa   p aa  p  aa  p a  a   p  a  a   
where
 x   

a x   e  p   x 



e  p   x   a x   a x   e  p  x  


   e  p   x   e  p  x   a x  


e  p  x   e  p   dp    e  p   x   e  p  dp  


e  p  x   e  p  x   e  p   x   e  p   x       




  

fiartale  calvanese  kontchakov   zakharyaschev

 
theorem     a dl liten
bool knowledge base k    t   a  is satisfiable iff the ql  sentence

k is satisfiable 

proof    if k is satisfiable then there is a model m of k whose domain consists of
all the constants occurring in k i e   ob a   dr k   say  an herbrand model of k    we
denote this domain by d and the interpretations of the  unary  predicates p   propositional
variables p and constants a of ql  in m by p m   pm and am   respectively  thus  for every
constant a  we have am   a  let d  be the set of all constants a  a  ob a   without loss
of generality we may assume that d      
i
we construct an interpretation i for dl liten
bool based on some domain   d  that
will be inductively defined as the union

 

i  

where

wm  

w    d   

m  

the interpretations of the object names ai in i are given by their interpretations in m 
namely  aii   am
i  w    each set wm     for m     is constructed by adding to wm some
new elements that are fresh copies of certain elements from d   d    if such a new element
w  is a copy of w  d   d  then we write cp w      w  while for w  d  we let cp w    w 
the set wm   wm    for m     will be denoted by vm  for convenience  let w      so
that v    d    
the interpretations aik of concept names ak in i are defined by taking

 
aik   w  i   m    ak  cp w    
   
the interpretation pki of a role name pk in i will be defined inductively as the union
pki

 


 

pkm  

where

pkm  wm  wm  

m  

along with the construction of i   first  for a role r  role  k   we define the required
r rank r r  d  of a point d  d by taking

r r  d    max        q  qr
t   m    eq r d     
it follows from     that if r r  d    q then  for every q    qr
t   we have m    eq   r d 
whenever q    q  and m    eq  r d  whenever q   q     we also define the actual r rank
rm  r  w  of a point w  i at step m by taking
 
  w   wm    w  w     pkm    if r   pk  
rm  r  w   
  w   wm    w    w   pkm    if r   pk  
for the basis of induction we set  for each role name pk  role k  

 
m
pk     am
i   aj    w   w    m    pk ai aj  

   

observe that  by      for all r  role  k  and w  w   
r   r  w   r r  cp w   
  

    

fithe dl lite family and relations

suppose now that wm and the pkm   for m     have already been defined  if we had
rm  r  w    r r  cp w    for all roles r  role  k  and points w  wm   then the interpretation i we need would be constructed  however  in general this is not the case because
there may be some defects in the sense that the actual rank of some points is smaller than
the required rank 
for a role name pk  role k   consider the following two sets of defects in pkm  

 
m
w  vm   rm  pk   w    r pk   cp w    
k  

 
m
  w  vm   rm  pk   w    r pk   cp w    
k
the purpose of  say  m
k is to identify those defective points w  vm from which precisely
r pk   cp w   distinct pk  arrows should start  according to m   but some arrows are still
missing  only rm  pk   w  many arrows exist   to cure these defects  we extend wm and
pkm respectively to wm   and pkm   according to the following rules 
m
 m
k   let w  k   q   r pk   cp w    rm  pk   w  and d   cp w   we have m    eq   pk  d 
 
for some q    qr
t with q  q      then  by      m    e  pk  d  and  by     


m    e  pk  dpk    in this case we take q fresh copies w             wq  of dp
k  and set

 
 
cp wi     dpk   for    i  q   add them to wm   and add the pairs  w  wi       i  q 
to pkm    
m



 m
k   let w  k   q   r pk   cp w    rm  pk   w  and d   cp w   then m    eq   pk  d 

 
for some q    qr
t with q  q      so  by      we have m    e  pk  d  and  by     
 
 
m    e  pk  dpk    take q fresh copies w            wq of dpk  and set cp wi      dpk   for
   i  q   add them to wm   and add the pairs  wi    w      i  q  to pkm    

example     consider again the kb k and its first order translation k from example     
consider also a model m of k with the domain d    a  a    dp  dp    where
am    e  p  m    e  p   m    e  p  m   d 

 e  p   m    
 p aa   m    p  a  a m   t 

we begin the construction of the interpretation i of k by setting w    v    d     a  a   
and p       a  a      then we compute the required and actual ranks r r  w  and r   r  w  
for r   p  p    and w  v   
 i  r p  a      and r   p  a      
 iii  r p    a      and r   p    a      

 ii  r p  a        and r   p  a        
 iv  r p    a        and r   p    a        

at the next step  we draw a p  arrow from a to a fresh copy of dp to cure defect  i   draw
two p  arrows from a  to two more fresh copies of dp in order to cure defects  ii   and finally
we take a fresh copy of dp and connect it to a by a p  arrow  thereby curing defect  iii  
one more step of this unraveling construction is shown in figure   
observe the following important property of the construction  for m  m      w  vm 
and r  role  k  


if m   m   
  
rm  r  w   
    
q 
if m   m    for some q  r r  cp w   


r r  cp w    if m   m   
  

fiartale  calvanese  kontchakov   zakharyaschev

 

v 

a 
v 

a

v 

dp

dp

 
figure    unraveling model m  first three steps  
to prove this property  consider all possible cases 
 if m   m  then the point w has not been added to wm yet  i e   w 
  wm   and so we
have rm  r  w      
 if m   m  and m      then rm  r  w   r r  cp w   follows from      
 if m   m  and m      then w was added at step m  to cure a defect of some point
w   wm      this means that there is pk  role k  such that either  w    w   pkm 
 m   
   
and w   m
or  w  w     pkm  and w   k  
  consider the former case  we
k
 
since
fresh
witnesses
are
picked
up every time the rule  km     
have cp w    dp
k

is applied  rm   pk   w       rm   pk   w      and rm   r  w       for every r    pk   pk  
 
so it suffices to show that r pk   dp
k       indeed  as m    eq pk  cp w    for some

r
 
q  qt   we have  by      m    e  pk  cp w     and so  by      m    e  pk  dp
k    by the
 

  
the
latter
case
is
considered
analogously 
definition of r  we have r pk   dp
k
 if m   m      then  for each role name pk   all defects of w are cured at step m     
m  
 
by applying the rules  m
   therefore  rm      r  w    r r  cp w   
k   and  k
 if m   m      then      follows from the observation that new arrows involving w can
only be added at step m       that is  for all m    and each role name pk  role k  
pkm     pkm



vm  vm  



vm    vm  

    

i
it follows that  for all r  role  k   q  qr
t and w     we have 

m    eq r cp w  

iff

w    q r i  

    

indeed  if m    eq r cp w   then  by definition  r r  cp w    q  let w  vm    then 
by       rm  r  w    r r  cp w    q  for all m   m    it follows from the definition of
  

fithe dl lite family and relations

rm  r  w  and ri that w    q r i   conversely  let w    q r i and w  vm    then 
by       q  rm  r  w    r r  cp w    for all m   m    so  by the definition of r r  cp w  
and      m    eq r cp w   
by induction on the construction of concepts c in k one can readily see that  for every
w  i   we have
m    c   cp w  
iff
w  ci  
    
indeed  the basis is trivial for b    and follows from     for b   ak and from     
for b    q r  while the induction step for the booleans  c   c  and c   c  u c   
immediately follows from the induction hypothesis 
finally  we show that for each   t  a 
m     

iff

i     

the case    c  v c  follows from       for    ak  ai   and    ak  ai   from the
definition of aik   for    pk  ai   aj   and    pk  ai   aj    we have  aii   aij    pki iff  by      
 aii   aij    pk  iff  by      m    pk ai aj  
thus  we have established that i    k 
   conversely  suppose that i    k is an interpretation with domain i   we construct
i
a model m of k based on the same i   for every ai  ob a   we let am
i   ai and  for
every r  role  k   we take some d      r i if     r i     and an arbitrary element
i
d  i otherwise  and let drm   d  next  for every concept name ak   we let am
k   ak

m     q r i   finally  for every
and  for every role r  role  k  and q  qr
t   we set eq r

role r  role  k  and every pair of objects ai   aj  ob a   we define  rai aj  m to be true
iff i    r ai   aj    one can readily check that m    k   details are left to the reader 
q
the first order translation k of k is obviously too lengthy to provide us with reasonably
low complexity results   k     k         qt      role k         role k     ob a  qt   however  it
follows from the proof above that a lot of information in this translation is redundant and
can be safely omitted 
now we define a more concise translation k of k    t   a  into ql  by taking 
h
 
i
 
 
k   x t   x  
r  x   r  x 
 a
 a  
rrole  k 
 

where t   x   r  x   r  x  and a are defined as before by means of               and     
respectively  and
 
 
 
 
a  
eqr a r a  
 pk  ai   aj     
    
aob a 

rrole  k 
a  ob a  r a a   a

pk  ai  aj  a

where qr a is the maximum number in qr
t such that there are qr a many distinct ai with
r a  ai    a  here we use the una  and  pk  ai   aj       if pk  ai   aj    a and  
 
otherwise  now both the size of a and the size of k are linear in the size of a and k 
respectively  no matter whether the numbers are coded in unary or in binary 
  

fiartale  calvanese  kontchakov   zakharyaschev

more importantly  the translation  can actually be done in logspace  indeed  this
 
 
is trivially the case for t   x   r  x   r  x   a and the last conjunct of a   as for
 
the first conjunct of a then  for r  role  k  and a  ob a   the maximum qr a in
qr
t such that there are qr a many distinct ai with r a  ai    a  can be computed using
log min max qr
t    ob a      log  ob a   cells  initially we set q      and then enumerate all
object names ai in a incrementing the current q each time we find r a  ai    a  we stop if
q   max qr
t or we reach the end of the object name list  the resulting qr a is the maximum
number in qr
t not exceeding q 
example     the translation k of the kb k from example     looks as follows 
k   x  x   a a   e  p  a   e  p   a    
where  x  is defined by     
 

corollary     a dl liten
bool kb k is satisfiable iff the ql  sentence k is satisfiable 

proof the claim follows from the fact that k is satisfiable iff k is satisfiable  indeed  if
m    k then clearly m    k   conversely  if m    k then one can construct a new model
m  based on the same domain d as m by taking 
 

m
 am
k   ak   for all concept names ak  
 

 eq rm   eq rm   for all r  role  k  and q  qr
t 
 

  rai aj  m is true iff r ai   aj    a 
 

m
 am
i   ai   for all ai  ob a  
 

 drm   drm   for all r  role  k  
 

we claim that m     k   indeed  eq rm   eq rm   for every r  role  k  and q  qr
t   it
 
 
follows then that m     x t   x  and m     x r  x   by definition  m    va   m     a
q
and m     x r  x   it remains to show that m     r   suppose m     i   raaji   that
is r a  aji    a  for distinct aj            ajq   and q  qr
t   clearly  we have q  qr a and
m    eq r a  and thus m     eq r a  
q
as an immediate consequence of corollary      the facts that the translation  can be
done in logspace  that the satisfiability problem for ql   formulas is np complete and
that dl litebool contains all the booleansand so can encode full propositional logicwe
obtain the following result 
f
theorem     satisfiability of dl liten
bool   dl litebool and dl litebool knowledge bases is
np complete for combined complexity 
 

observe now that if k is a dl liten
krom kb then k is in the krom fragment of ql  
f
theorem     satisfiability of dl liten
   dl lite and dl lite knowledge bases  where
   core  krom   is nlogspace complete for combined complexity 

  

fithe dl lite family and relations

proof as the satisfiability problem for krom formulas with the prefix of the form x  as
in k   is nlogspace complete  see  e g   borger et al         exercise        and  is a
logspace reduction  satisfiability is in nlogspace for all the logics mentioned in the
theorem  as for the lower bound  it suffices to recall that the nlogspace hardness for
satisfiability of propositional krom formulas is proved by reduction of the directed graph
reachability problem using only core propositional formulas  borger et al          and so
satisfiability in all of the above logics is nlogspace hard 
q
 

if k is a dl liten
horn kb then k belongs to the universal horn fragment of ql  
f
theorem     satisfiability of dl liten
horn   dl litehorn and dl litehorn kbs is p complete
for combined complexity 

proof as ql  contains no function symbols and k is universal  satisfiability of k is
logspace reducible to satisfiability of a set of propositional horn formulas  namely  the
formulas that are obtained from k by replacing x with each of the constants occurring
in k   it remains to recall that the satisfiability problem for propositional horn formulas
is p complete  see  e g   papadimitriou         which gives the required upper bound for
q
dl liten
horn and lower bound for dl litehorn  
    dl litehf
core is exptime hard
unfortunately  the translation  constructed in the previous section cannot be extended
to logics of the form dl litehn
with both number restrictions and role inclusions  in this

section we show that the satisfiability problem for dl litehf
core kbs is exptime hard  which
matches the upper bound for satisfiability of dl litehn
kbs
even under binary coding of
bool
natural numbers  tobies        
note first that  although intersection is not allowed on the left hand side of dl litehf
core
concept inclusions  in certain cases  when the right hand side is consistent  we can simulate
it by using role inclusions and functionality constraints  suppose that a knowledge base k
contains a concept inclusion of the form c  u c  v c  define a new kb k  by replacing
this axiom in k with the following set of new axioms  where r    r    r    r     r   are fresh
role names 
c  v r 

c  v r   

    

r  v r    

r  v r    

    

   r   v  
r 

v

    

r   

    

r  v c 

    

r  v r    



  r  

r  v r    

v  

    
    

lemma      i  if i    k  then i    k  for every interpretation i 
 ii  if i    k and c i     then there is a model i   of k  which has the same domain as
i and agrees with it on every symbol from k 
  

fiartale  calvanese  kontchakov   zakharyaschev

proof  i  suppose that i    k  and x  c i  c i   by       there is y with  x  y   r i  
i   whence
and so y   r   i   and there is z with  x  z   r i   by         x  y    x  z    r  
y   z in view of       by       y   r   i and hence there is u with  u  y   r i and
i and  x  y   ri   finally  it follows
u   r   i   by       u  c i   by        u  y   r  
  
from      that u   x  and so x  c i   thus  i    k 
 ii  take some point c  c i and define an extension i   of i to the new role names by
setting 
 

 r i     x  x    x  c i   
 

 r i     x  x    x  c i   
 

 r i     x  x    x   c  u c   i      c  x    x   c  u c   i   
 

 

i   ri  ri
 r  
 
 

 

and

 

 

 

i   ri  ri  
r  
 
 

it is readily seen that i   satisfies all the axioms           and so i      k   

q

we are now in a position to prove the following 
theorem      satisfiability of dl litehf
core kbs is exptime hard for combined complexity
 with or without the una  
proof we will prove this theorem in two steps  first we consider the logic dl litehf
horn
and show how to encode the behavior of polynomial space bounded alternating turing machines  atms  for short  by means of dl litehf
horn kbs  as apspace   exptime  where
apspace is the class of problems recognized by polynomial space bounded atms  see  e g  
kozen         this will establish exptime hardness of satisfiability for dl litehf
horn   then 
using lemma      we will show how to get rid of conjunctions on the left hand side of the
concept inclusions involved in this encoding of atms and thus establish exptime hardness
of dl litehf
core  
without loss of generality  we can consider only atms m with binary computational
trees  this means that  for every non halting state q and every symbol a from the tape
alphabet  m has precisely two instructions of the form
 q  a    m  q     a    d   

and

 q  a    m  q      a     d     

    

where d    d         and   resp     means move the head right  resp   left  one cell 
we remind the reader that each non halting state of m is either an and state or an or state 
given such an atm m  a polynomial function p n  such that every run of m on every
input of length n does not use more than p n  tape cells  and an input word  a   a            an  
we construct a dl litehf
horn knowledge base km  a with the following properties   i  the size
of km  a is polynomial in the size of m   a  and  ii  m accepts  a iff km  a is not satisfiable 
denote by q the set of states and by  the tape alphabet of m 
to encode the instructions of m  we need the following roles 
 sq   sq    sq    for each q  q  informally  x   sq  i   for some interpretation i  means
that x represents a configuration of m with the state q  and x   sqk  i means that
the next state  according to the transition  km   is q  where k         
  

fithe dl lite family and relations

 hi   hi    hi    for each i  p n   x   hi  i means that x represents a configuration of
m where the head scans the ith cell  and x   hik  i that  according to the transition
 km   k          in the next configuration the head scans the ith cell 
    c     for each i  p n  and each a    x   c   i means that x represents
 cia   cia
ia
ia
k  i that  according
a configuration of m where the ith cell contains a  and x   cia
to  km   k          in the next configuration the ith cell contains a 

this intended meaning can be encoded using the following concept inclusions  for every
instruction  q  a   km  q     a      of m and every i   p n  

k
k
sq u hi u cia
v hi  
u sqk  u cia
  

    

and for every instruction  q  a   km  q     a      of m and every i      i  p n  

k
k
sq u hi u cia
v hi 
u sqk  u cia
  

    

to preserve the symbols on the tape that are not in the active cell  we use the following
concept inclusions  for k          i  j  p n  with j    i  and a   

k
hj u cia
v cia
 

    

to synchronize our roles  we need two more  functional  roles tk and a number of role
inclusions to be added to the tbox  for all k          i  p n   q  q  and a   
k
cia
v cia  

hik v hi  

sqk v sq  

    

k
cia
v tk  

hik v tk  

sqk v tk  

    

   tk v  

    

it remains to encode the acceptance conditions for m on  a  this can be done with the help
of the role names yk   for k          and the concept name a 
sq v a 

q an accepting state 

yk v tk  
   tk
tk u a
sq u yk
sq

    

v  
v

    

yk  

v a 

u y  u y  v a 

    

    
q an or state 

    

q an and state 

    

the tbox t of the dl litehf
horn knowledge base km  a we are constructing consists of the
axioms          together with the auxiliary axiom
a u d v  

    

where d is a fresh concept name  the abox a of km  a is comprised of the following
assertions  for some object names s and u 
sq   u  s  

q  the initial state 

h   u  s  
ciai  u  s  

    
    

i  p n   ai the ith symbol on the input tape 

    
    

d s  
  

fiartale  calvanese  kontchakov   zakharyaschev

clearly  km  a    t   a  is a dl litehf
a 
horn kb and its size is polynomial in the size of m   
lemma      the atm m accepts  a iff the kb km  a is not satisfiable 
proof    suppose that m accepts  a but i    km  a for some interpretation i  then we
can reconstruct the full computation tree for m on  a by induction in the following way 
let the root of the tree be the point si   by           s represents the initial configuration of m on  a in accordance with the intended meaning of the roles sq    h  and ciai
explained above  it does not matter if  for instance  we also have si   h   i   
assume now that we have already found a point x  i representing some configuration
c   b            bi     q  bi    bi             bp n   

    

where q is the current non halting state and the head scans the ith cell containing bi   this
means that we have
x   sq  i   hi  i

 i
and x   cjb
   
j

for all j  p n  

assume also that m contains two instructions of the form      for  q  bi    that is q is nonhalting  if we have  q  bi    km  q     b       for k     or    then  by      and       there are
points ys   yh and yj   for j  p n   in i such that
 x  ys     sqk   i  

k
 x  yh     hi  
 i  

k i
 x  yi     cib
    

k i
   
 x  yj     cjb
j

for j    i 

    c   and the c     j    i  are all sub roles of the functional role t  
by           sq     hi  
k
jbj
ib i
and so all the points ys   yh and yj coincide  we denote this point by xk   by       we then
have 

 x  xk    tki  

 i
 i
    cib
xk   sq   i   hi  
  

 i
   
and xk   cjb
j

for j    i 

similarly  if we have  q  bi    km  q      b        for k     or    then  by      and       there is
a point xk  i such that
 x  xk    tki  

 i
 i
    cib
xk   sq    i   hi 
    

 i
   
and xk   cjb
j

for j    i 

thus  for k         xk is a tk  successor of x representing the configuration ck of m after it
has executed  q  bi    km  q      b     d  in c  in this case ck is called the k successor of c 
according to       every point in the constructed computation tree for m on  a representing a configuration with an accepting state is in ai   suppose now  inductively  that
x represents some configuration c of the form       q is an or state  xk represents the ksuccessor of c and  x  xk    tki   for k         and one of the xk   say x    is in ai   in
view of       we have x    y   i   as t  is functional by      and y  is a sub role of
t  by        x  x     y i   and so  by       x  ai   the case of x being an and state is
considered analogously with the help of      
since m accepts  a  we then conclude that si  ai   contrary to      and      
   conversely  suppose now that m does not accept  a  consider the full computation
tree             with nodes labeled with configurations of m in such a way that the root
is labeled with the initial configuration
 q    a     a            an   an             ap n   
  

fithe dl lite family and relations

 where the ai   for n      i  p n   are all blank   and if some node x in the tree is labeled
with a non halting c of the form      and m contains two instructions of the form       then
x has one     successor labeled with the   successor of c and one     successor labeled with
the   successor of c   it should be emphasized that             is a tree  where different
nodes may be labeled with the same configuration  
we use this tree to construct an interpretation i    i   i   as follows 
 i      u   for some u 
   
 si is the root of  and ui   u 
 di    si   
k  i    x  x     c k  i   and  x  x     c k  i   for j    i 
  x  xk     sqk   i    x  xk     hi  
k
k
jbj
ib 
iff x is labeled with c of the form        q  bi    km  q     b      and x  k xk   for k        
k  i    x  x     c k  i   and  x  x     c k  i   for j    i 
  x  xk     sqk   i    x  xk     hi 
k
k
jbj
ib 
k
iff x is labeled with c of the form        q  bi    m  q     b      and x  k xk   for k        

  u  si     sq   i    u  si     h   i    u  si     ciai  i   i  p n  and over  the extensions
for the roles sq   hi and cia are defined according to      
 tki    k   for k        
 y i   y i and ai are defined inductively 
 induction basis  if x   is labeled with an accepting configuration  then x  ai  
 induction step   i  if x  k xk   for k         and xk  ai   then  x  xk    yki    ii  if
x is an or state  respectively  and state  and  x  xk    yki for some  respectively 
all  k          then x  ai  
it follows from the given definition that i    km  a   details are left to the reader 

q

the lemma we have just proved establishes that satisfiability of dl litehf
horn kbs is
exptime hard  our next aim is to show how one can eliminate the conjunctions in the
left hand side of the tbox axioms                     we will do this with the help of
lemma      before applying it  we check first that if km  a is satisfiable then it is satisfiable
in an interpretation i such that i    km  a and c i      for every c occurring in an
axiom of the form c  u c  v c in k  consider  for instance  axiom      and assume that
i    km  a   but  sqk   i     then  we can construct a new interpretation i   by adding two
 
 
new points  say x and y  to the domain of i  and setting  x  y    sqk   i    x  y    sq   i  
 
 
 
 x  y    tk  i   furthermore  if q   is an accepting state  we also set y  ai and  x  y   yki  
one can readily check that i   is still a model for km  a   the other conjuncts of      and
the remaining axioms are considered analogously 
after an application of lemma     to an axiom of the form c  uc  v c with c    c   uc   
we obtain  by           a new kb k  with the concept inclusion of the form c   uc    v r   
which also requires treatment by means of the same lemma  to be able to do this  we again
  

fiartale  calvanese  kontchakov   zakharyaschev

  

have to check that k  is satisfiable in some interpretation i    with  r   i      suppose
 
that i      k  and  r   i     then we can construct i    by adding two new points  say x
 
 
i     ri   and ri     it
and y  to the domain of i     adding x to c i and  x  y  to each of r i   r  
  
 
is readily seen that i       k   
it is to be noted that the proof above does not depend on whether the una is adopted
or not 
q
as an immediate consequence we obtain 
corollary      satisfiability of dl litehf
and dl litehn
kbs with or without the una


is exptime complete for combined complexity  where    core  krom  horn  bool  
    reconciling number restrictions and role inclusions
as we have seen in the previous section  the unrestricted interaction between number restrictions and role inclusions allowed in the logics of the form dl litehn
results in high

combined complexity of satisfiability  in section      we shall see that the data complexity
of instance checking and query answering also becomes unacceptably high for these logics 
a quick look at the proof of theorem      reveals the culprit  the interplay between role
inclusions r  v r  r  v r and functionality constraints    r v   which effectively mean
that if r   x  y  and r   x  z  then y   z  in this section we study the case when such an
interplay is not allowed 
 hn  
recall from section     that dl lite
tboxes t   for    core  krom  horn  bool  
satisfy the following conditions 
 a    t may contain only positive occurrences of qualified number restrictions  q r c 
where c is a conjunction of concepts allowed on the right hand side of  concept
inclusions 
 a    if  q r c occurs in t   then t does not contain negative occurrences of number
restrictions  q   r or  q   inv r  with q      
 a    if r has a proper sub role in t   then t does not contain negative occurrences of
 q r or  q inv r  with q    
 hn  

dl lite
tboxes can contain role constraints such as dis r    r     asym pk    sym pk   
irr pk    and ref pk   
our main aim in this section is to prove the following theorem and develop the technical
 hn  
tools we need to investigate the data complexity of reasoning with dl litebool and its
sublogics later on in the paper 
 hn  

theorem      for combined complexity   i  satisfiability of dl litebool kbs is np hn  
complete   ii  satisfiability of dl litehorn kbs is p complete  and  iii  satisfiability of
 hn  
 hn  
dl litekrom and dl litecore kbs is nlogspace complete 

  

fithe dl lite family and relations

 hn  

let us consider first the sub language of dl litebool

without qualified number restric hn  

tions and the role constraints mentioned above  we denote it by dl litebool   this sub 

 hn  

language is required for purely technical reasons  in section    we will also use dl litehorn  
but we do not need the core or krom fragments 
 hn  
suppose we are given a dl litebool
kb k    t   a   let id be a distinguished
role name  we will use it to simulate the identity relation required for encoding the role
constraints  we assume that either k does not contain id at all or satisfies the following
conditions 
 id    id ai   aj    a iff i   j  for all ai   aj  ob a  

 
id       
 id      v id  id v id  t   and qid
t   qt
 id    id is only allowed in role inclusions of the form id v id and id v r 
in what follows  without loss of generality  we will assume that
 

 
r

 q  qr
t  qt whenever r vt r
 

 for if this is not the case we can always add the missing numbers to qr
t   e g   by introducing
fictitious concept inclusions of the form  v  q r    
now  in the same way as in section      we define two translations e and e of k into
the one variable fragment ql  of first order logic  the former translation  e   retains the
information about the relationships between abox objects  and we show that every model
of ke can again be unraveled into a model of k  we define e by taking 
h
ke   x t   x   t r  x  

 

r  x   r  x 

i



rrole  k 

h

 

 

a  a 

 


r 

rrole  k 

 

rai aj  r  ai aj

i

 

rvr  t
ai  aj ob a 

 

 

where t   x   a   a   r  x   r  x  and r are as in        and
 
 

t r  x   
eq r x   eq r   x   
rvr  t or
inv r vinv r   t

    

qqr
t

the following lemma is an analogue of theorem     
 hn  

lemma      a dl litebool

kb k is satisfiable iff the ql   sentence ke is satisfiable 

proof the proof basically follows the lines of the proof of theorem     with some modifications  we present a modified unraveling construction here  the converse direction is exactly
the same as in theorem     
in each equivalence class  ri      rj   ri t rj   we select a single role  a representative
of that class  and denote it by rept  ri    when extending pkm to pkm     we use the following
modified curing rules 
  

fiartale  calvanese  kontchakov   zakharyaschev



 m
k   if pk    rept  pk   do nothing  the defects are cured for rept  pk    otherwise  let
m
w  k   q   r pk   cp w    rm  pk   w  and d   cp w   we have m    eq  pk  d  for
some q    q      then  by      m    e  pk  d  and  by      m    e  pk  dp
k    in this
      dp   for    i  q  
case we take q fresh copies w             wq  of dp
 and
set
cp w
i
k
k
add them to wm   and

 add the pairs  w  wi        i  q  to each pjm   with pk vt pj  including
pj   pk   
 add the pairs  wi    w      i  q  to each pjm   with pk vt pj  
 if id occurs in k  add the pairs  wi    wi        i  q  to each pjm   with id vt pj  

m
 m
k   this rule is the mirror image of  k    pk and dpk are replaced everywhere with

pk and dpk   respectively  see the proof of theorem     

it follows from this definition that id never has any
in the resulting
 defects and is interpreted
 
interpretation i by the identity relation idi    w  w    w  i   the interpretations of
roles respect all the role inclusions  i e   r i  r i whenever r  vt r   
it remains to show that the constructed interpretation i is indeed a model of k 
first       trivially holds for id as both the required and actual ranks are equal to    second       holds for r such that r    id and r has no proper sub roles  the proof is exactly
the same as in theorem      taking into account that we cure defects only for a single role in
each equivalence class and that  by       for all r    r   we have r r    cp w     r r  cp w  
and r inv r   cp w     r inv r     cp w    it follows that      holds for id and any role r
without proper sub roles  however       does not necessarily hold for roles r with proper
sub roles  as follows from the construction  the actual rank may be greater than the required
rank  in which case we only have the following 
if m    eq r cp w  

then

w    q r i  

however  this is enough for our purposes  by induction on the structure of concepts and
using  a     one can show that i    c  v c  whenever m    x  c   x   c   x    for each
concept inclusion c  v c   t   and therefore  i    t   we also have i    a  see the proof
of theorem      and thus i    k 
q
remark      it follows from the proofs of theorem     and lemma      that  for the
 hn  
dl litebool
kb k    t   a   every model m of ke induces a model im of k with the
following properties 
 abox  for all ai   aj  ob a   we have  aii m   aij m    rim iff r ai   aj    clet  a   where
clet  a   



 
r   ai   aj     r   ai   aj    a  r  vt r   

 forest  the object names a  ob a  induce a partitioning of im into disjoint labeled
trees ta    ta   ea    a   with nodes ta   edges ea   root aim   and a labeling function
 a   ea  role  k     id  id   
  

fithe dl lite family and relations

 copy  there is a function cp   im  ob a   dr k  such that
 cp aim     a for a  ob a   and
 cp w    dr if  for some a and w   ta    w    w   ea and  a  w    w    inv r  
 iso  for each r  role  k   all labeled subtrees generated by elements w  im with
cp w    dr are isomorphic 
 concept  w  b im iff m    b   cp w    for each basic concept b in k and each w  im  
fi
 

 role  idim    w  w  fi w  im and  for every other role name pk  
pkim  



 

 
 aii m   aij m     r ai   aj    a  r vt pk

 w  w    id vt pk

  
 
 w  w     ea    a  w  w      r  r vt pk  
aob a 

such a model will be called an untangled model of k  the untangled model of k induced by
m  to be more precise  
the translation e generalizes  and thus suffers from the same exponential blowup  so
we define an optimized translation  e   which is linear in the size of k  by taking 
h
 
i
 
 
 a
 a e  
r  x   r  x 
ke   x t   x   t r  x  
rrole  k 
 

where t   x   t r  x   r  x   r  x  and a are defined by                     and     
respectively  and
 
 
 
 
e r a 
ae  
eqr a

    
 pk  ai   aj   e  
aob a 

rrole  k 
a  ob a  r a a   clet  a 

pk  ai  aj  a

e
e
where qr a
is the maximum number in qr
t such that there are qr a many distinct ai with
r a  ai    clet  a   here we use the una  and  pk  ai   aj   e    if pk  ai   aj    clet  a 

and   otherwise  cf        we note again that if qr
t        for all roles r  role  k   then
the translation does not depend on whether the una is adopted or not 
the following corollary is proved similarly to corollary     
 hn  

corollary      a dl litebool

kb k is satisfiable iff the ql   sentence ke is satisfiable 

it should be clear that the translation e can be computed in nlogspace  for combined
 
complexity   indeed  this is readily seen for t   x   t r  x   r  x   r  x   and a   in
 
order to compute ae   we need to be able to check whether r ai   aj    clet  a   this test
can be performed by a non deterministic algorithm using logarithmic space in  role  k  
 it is basically the same as the standard directed graph reachability problem  which is
nlogspace complete  see  e g   kozen         it can be done using n  log  role  k    
  log  ob a   cells on the work tape  where n is a constant  in fact  n     is enough  one
  

fiartale  calvanese  kontchakov   zakharyaschev

has to store r  the current role r  and the path length for the graph reachability subroutine 
which is also bounded by log  role  k     therefore  the translation e can be computed
by an nlogspace transducer 
 hn  
now we show how satisfiability of dl litebool kbs can be easily reduced to satisfiability
 hn  

 hn  

of dl litebool
kbs  first  we assume that dl litebool kbs contain no role symmetry
and asymmetry constraints because asym pk   can be equivalently replaced with dis pk   pk  
and sym pk   with pk v pk  it should be noted that the introduction of pk v pk in the
tbox does not violate  a      the following lemma allows us to get rid of qualified number
restrictions as well as role disjointness  reflexivity and irreflexivity constraints 
 hn  

lemma      for every dl litebool
kb k    t   a  such that

 hn  

kb k     t     a     one can construct a dl litebool

 every untangled model im of k is a model of k    provided that
there are no r   ai   aj    r   ai   aj    clet  a  with dis r    r     t    
there is no r ai   ai    clet  a  with irr r   t    

    

 every model i   of k  gives rise to a model i of k based on the same domain as i   and
such that i agrees with i   on all symbols from k   
 hn  

 hn  

if k  is a dl litehorn kb then k is a dl litehorn

kb 

proof first  for every pair r  c such that  q r c occurs in t     we introduce a fresh role
name rc   then we replace each  positive  occurrence of  q r c in t   with  q rc and
add the following concept and role inclusions to the tbox 

vc
rc

and

rc v r 

we repeat this procedure until all the occurrences of qualified number restrictions are eliminated  denote by t    the resulting tbox  observe that  a    and  a    ensure that t   
satisfies  a     we also notice that c occurs only on the right hand side of those extra
axioms and thus t    belongs to the same fragment as t     it should be clear that  since the
 q r c occur only positively  every model of t    is a model of t     conversely  for every
model i   of t     there is a model i    of t    based on the same domain such that i    coincides
i        w  u   ri     u  c i      for each new role r   so 
with i   on all symbols in t   and rc
c
without loss of generality we may assume that t     t     
let
 
 
 
 tirref
 tdisj
 
t     t    tref
    t 
 
where tref
irref and tdisj are the sets of role reflexivity  irreflexivity and disjointness con hn  

straints in t   and t   is the remaining dl litebool
tbox  let

 

 
 
t       v id  id v id
 id v p   ref p    tref
 

 
a     id ai   ai     ai  ob a     
 hn  

we construct k by modifying the dl litebool
kb k     t    t     a   a     in two steps 
    take a fresh role name s and
step    for every reflexivity constraint ref p    tref
p
  

fithe dl lite family and relations

 add a new role inclusion sp v p to the tbox 
 replace every basic concept b in t   with b sp   which is defined inductively as follows 
 asp   a  for each concept name a 
   q r sp    q r  for each role r 
   p  p    
   q p  sp     q     sp and   q p   sp     q     sp   for q    
  p  sp     and  p   sp     
 replace r ai   aj    a  such that r t   p with sp  ai   aj   whenever i    j 
intuitively  we split the role p into its irreflexive part sp and id  note that if p has a
reflexive proper sub role then  by  a     there are no restrictions on the maximal number
of p  successors and p  predecessors  and therefore on sp if ref p    t     let  t    a  be the
 hn  
resulting dl litebool
kb  clearly   t    a  satisfies  id    id     observe that
clet   a  role k      clet   t    a    
 

 

    

where role k    means the restriction to the role names in k   
let im be an untangled model of  t    a   we show that im    t     consider a role p
with ref p    t     notice that sp has no proper sub roles in t  and idim is disjoint with
spim   thus  spim  idim  p im and
     b sp  im  b im   for b    q r with q     whenever ref p    t     r   p  p    and
p has a proper sub role in t    
if p has no proper sub roles in t    i e   no proper sub roles in t  different from sp and id 
then we have spim  idim   p im   so  for all basic concepts b in t   not covered by      we
have b im    b sp  im   it follows from  a    that im    t    
 
   
step    next we take into account the set d   tdisj
  dis pk   id    irr pk    tirref
of disjointness constraints by modifying the kb  t    a  constructed at the previous step 
observe that r  v  is a logical consequence of any t  dis r    r     whenever r  vt r   
let t   t   t    where t  is defined by taking
fi

 
t    r  v  fi r  vt  r  and either dis r    r     d or dis r    r     d  
by  role   for any untangled model im of  t   a  and r    r   role  k   im    dis r    r   
if there are no r   ai   aj    r   ai   aj    clet   a   which  by       means that there are no
r   ai   aj    r   ai   aj    clet   t    a     so  if      holds then every untangled model im of
 

 

    as idim is the identity relation 
 t   a  is also a model of t   d and thus  im    tdisj
 
 
 
we have im    tref  tirref   by       im    a and as we have shown above  im    t    
therefore  im    k   
conversely  suppose i   is a model of k    let i be an interpretation such that idi
 
 
 
is the identity relation  spi   p i   idi   for all p with ref p    t     and ai   ai  
 
 
p i   p i and ai   ai   for all concept  role and object names a  p and a in k    clearly 
i     t    t     a   a      by the definition of the sp   i    t  and  since i    d  we obtain
i    t  and thus i    t   by       i    a  whence i    k 
q

  

fiartale  calvanese  kontchakov   zakharyaschev

 hn  

now  as follows from lemma       given a dl lite
kb k    for    krom  horn 

 hn  
bool   we can compute the dl litebool
kb k using a logspace transducer  which is
essentially required for checking whether r t   p    we immediately obtain theorem     
from lemma      by observing that  for each    krom  horn  bool   ke belongs to the
respective first order fragment and that condition      can be checked in nlogspace
 hn  
 computing clet  a  requires directed graph accessibility checks   the result for dl litecore
 hn  
follows from the corresponding result for dl litekrom  
    role transitivity constraints
 hn   

we now consider the languages dl lite
     core  krom  horn  bool   which extend
 hn  
dl lite
with role transitivity constraints of the form tra pk    we remind the reader
that a role is called simple  see  e g   horrocks et al         if it has no transitive sub roles
 including itself  and that only simple roles r are allowed in concepts of the form  q r  for
q     in particular  if t contains tra p   then p and p  are not simple  and so t cannot
contain occurrences of concepts of the form  q p and  q p    for q    
 hn   
for a dl lite
kb k    t   a   define the transitive closure trat  a  of a by
taking

 
trat  a    a  p  ai    ain     ai        ain  p  ai    aij      a     j   n  tra p    t  
clearly  trat  a  can be computed in nlogspace  for each pair  ai   aj   of objects in ob a  
we add p  ai   aj   to trat  a  iff there is a p  path of length    ob a   between ai and aj in
a  recall that the directed graph reachability problem is nlogspace complete  
 hn   

 hn  

lemma      a dl lite
kb  t   a  is satisfiable iff the dl lite
kb  t     a    is
 
satisfiable  where t results from t by removing all the transitivity axioms and
a    clet  trat  clet  a    
proof indeed  if the kb  t     a    is satisfiable then we construct a model i for it as described
in the proofs of lemmas      and      and then take the transitive closure of p i for every p
with tra p    t  and update each ri with p vt r   as p and p  are simple  t contains
no axioms imposing upper bounds on the number of p  successors and predecessors  and so
the resulting interpretation must be a model of  t   a   the converse direction is trivial  q
we note that an analogue of remark      also holds in this case  just replace clet  a 
with clet  trat  clet  a    in  abox  and take the transitive closure for each transitive subrole in  role  
remark      it should be noted that there are two different reasons for the reduction in
lemma      to be in nlogspace rather than in logspace  as the reduction  is   first 
in order to compute clet  a   for each pair of ai   aj   one has to find a path in the directed
graph induced by the role inclusion axioms  second  in order to compute trat  clet  a    one
has to find a path in the graph induced by the abox a itself  so  if we are concerned with
the data complexity  clet  a  can be computed in logspace  in fact  in ac    as we shall
  

fithe dl lite family and relations

see in section      because the role inclusion graph  and hence its size  does not depend on
a  the second reason  however  is more dangerous for data complexity as we shall see in
section     
as a consequence of lemma      and theorem      we obtain the following 
 hn   

corollary      for combined complexity   i  satisfiability of dl litebool
complete   ii 
 hn   
dl litekrom

 hn   
satisfiability of dl litehorn kbs is p complete 
 hn   
and dl litecore
kbs is nlogspace complete 

kbs is np 

and  iii  satisfiability of

note again that if the kbs do not contain number restrictions of the form  q r  for
q      as in the extensions of the dl liteh
 languages  then the result does not depend on
the una 
remark      it should be noted that role disjointness  symmetry  asymmetry and transitivity constraints can be added to any of the logics dl litehf
and dl litehn

   for
   core  krom  horn  bool   without changing the combined complexity of their satisfiability problems  which  by corollary       are all exptime complete   indeed  as follows
from theorem    of glimm et al          kb satisfiability in the extension of shiq
with role conjunction is in exptime if the length of role conjunctions is bounded by
some constant  in our case  this constant is   because dis r    r    can be encoded by
 r  u r      v   asym r  is dealt with similarly   we conjecture that role reflexivity and irreflexivity constraints do not change complexity either 

   instance checking  data complexity
so far we have assumed the whole kb k    t   a  to be the input for the satisfiability problem  according to the classification suggested by vardi         we have been considering
its combined complexity  two other types of complexity for knowledge bases are 
 the schema  or tbox   complexity  where only the tbox t is regarded to be the input 
while the abox a is assumed to be fixed  and
 the data  or abox   complexity  where only the abox a is regarded to be the input 
it is easy to see that the schema complexity of the satisfiability problem for all our logics
considered above coincides with the corresponding combined complexity  in this section 
we analyze the data complexity of satisfiability and instance checking 
 hn  

h
    dl liten
bool   dl litebool and dl litebool

are in ac 

in what follows  without loss of generality we assume that all role and concept names of
a given knowledge base k    t   a  occur in its tbox and write role t    role  t   and
dr t   instead of role k   role  k  and dr k   respectively  the set of concept names in t
 hn  
is denoted by con t    in this section we reduce satisfiability of dl litebool kbs to model
checking in first order logic  to this end  we fix a signature containing two unary predicates
ak and ak   for each concept name ak   and two binary predicates pk and pk   for each role
name pk  
  

fiartale  calvanese  kontchakov   zakharyaschev

 hn  

consider first the case of a dl litebool
kb k  we represent the abox a of k as
a first order model aa of the above signature  the domain of aa is ob a  and  for all
ai   aj  ob a  and all predicates ak   ak   pk and pk in the signature 
aa    ak  ai  

iff

ak  ai    a 

aa    pk  ai   aj  

iff

pk  ai   aj    a 

aa    ak  ai  

iff

ak  ai    a 

aa    pk  ai   aj  

iff

pk  ai   aj    a 

now we construct a first order sentence t in the same signature such that  i  t depends
on t but does not depend on a  and  ii  aa    t iff ke is satisfiable 
to simplify presentation  we denote by ext t   the extension of t with the following
concept inclusions 
 
 
  
  q   r v  q r  for all r  role  t   and q  q    qr
t such that q   q and q   q   q
  
r
for no q  qt   and
 
 
  q r v  q r    for all q  qr
t and r v r  t or inv r  v inv r    t  
v
clearly   ext t     x  is equivalent  in first order logic  to t   x t r  x  rrole  t   r  x  
see          and      
let bcon t   be the set of basic concepts occurring in t  i e   concepts of the form a
and  q r  for a  con t    r  role  t   and q  qr
t    to indicate which basic concepts
hold or do not hold on a domain element of a first order model of ke   we use functions
   bcon t           which will be called types  denote by tp the set of all such types
 there are   bcon t    of them   for a complex concept c  we define  c  by induction 
 c     c  and  c  u c       c      c     the propositional variable free formula
 

t  
 c      c   
c  vc  ext t  

ensures that the type  is consistent with concept and role inclusions in t   it should be
emphasized that  t is built from  and   using the boolean connectives and therefore does
not depend on a particular domain element of aa   the following formula is true if a given
 
 
element x of aa is of type   see a and ae       and       respectively  
   x   

 


 ak  x    ak      ak  x    ak   



ak con t  

 

 

eq rt  x     q r 



 



rrole  t   qqr
t


xy pkt  x  y   pk  x  y     

pk role t  

where eq rt  x  and rt  x  y   for r  role  t    are abbreviations defined by
 
 

eq rt  x    y        yq
 yi    yj   
rt  x  yi    
 i jq

rt  x  y   

 
pk vt

pk  x  y 



 
pk vt

r

  

    

 iq

pk  y  x  
r

    

fithe dl lite family and relations

clearly  we have r ai   aj    clet  a  iff aa    rt  ai   aj   and aa    eq rt  a  iff a has at
least q distinct r successors in clet  a   and thus in every model of k  
without loss of generality we may assume that role  t      r            rk        denote
by tpk the set of k tuples   containing a type dri  tp for each role ri  role  t    we
then set
 
 
x t  x  
t
 
k
 
tp

where
 dr       drk  

t

 x 

 

  

   x    t

 



t
dr
i





tp

ri role  t  

 



 ri   

ri role  t  

 



ds  ri    inv dri    inv ri     

srole  t  

to explain the meaning of the subformulas of t   assume that  t   a  is satisfiable  in order
to construct a model m for ke from the first order model aa   we have to specify the basic
concepts that contain a given constant of ke   in other words  we have to select a type for
each dri  dr t   and each a  ob a   the formula t says that one can select a k tuple
of types      dr            drk    tpk such that one of its disjuncts is true in aa   such a
k tuple fixes the witness part of the model m  consisting of the dri   and determines the
basic concepts these dri belong to  then each disjunct of t says that  having fixed the
witness part of the model   for every a  ob a   there is a type   determining the basic
concepts a belongs to  such that
  is consistent with the information about a in a  cf     x   
  is also consistent with the concept and role inclusions of t  cf   t   
t   
 each of dr            drk is consistent with the concept and role inclusions of t  cf  dr
i

 each role ri with a nonempty domain  i e   either  or any of ds is   on ri   has
a nonempty range  in particular  inv dri    inv ri         see also r  x  as defined
by     
lemma     aa    t iff ke is satisfiable 
 
proof    fix some      dr            drk    tpk such that aa    x t  x   then  for each
 

a  ob a   fix some type such that the respective disjunct of t  x  holds on a in aa and
denote it by a   define a first order model m over the domain ob a   dr t   by taking 
 m    b   c  iff c  b       for all c  ob a   dr t   and b  bcon t  
 b  is the unary predicate for b as defined on p       it is easy to check that m    ke  
   suppose now that ke is satisfiable  then there is a model m of ke with domain
ob a   dr t    to see that aa    t   it suffices to take the functions dri and a defined
by 
  

fiartale  calvanese  kontchakov   zakharyaschev

 dri  b      iff m    b   dri    for dri  dr t   and b  bcon t   
 a  b      iff m    b   a   for a  ob a  and b  bcon t   
details are left to the reader 

q

it follows from lemmas     and      and corollary      that we have 
h
corollary     the satisfiability and instance checking problems for dl liten
bool   dl litebool
 hn  
and dl litebool kbs are in ac  for data complexity 
 hn  

h
proof dl liten
bool and dl litebool are sub languages of dl litebool   and for them the
 hn  
result immediately follows from lemma     and corollary       for a dl litebool kb
 hn  

k     t     a     by lemma       we construct a dl litebool
kb k    t   a  such that
 
k is satisfiable iff k is satisfiable and      holds  the latter condition corresponds to the
following first order sentence
 
 


t    
xy r t  x  y   r t  x  y   

x pkt  x  x     
dis r   r   t  

irr pk  t  

evaluated in aa   therefore  k  is satisfiable iff aa    t  t     let    t  t   and   
be the result of replacing each sp  t    t     for ref p    t     with p  t    t      t     t     see the
proof of lemma       it remains to observe that aa     iff aa         
q
as before  this result does not depend on the una for any member of the dl lite family
that has no number restrictions of the form  q r  for q     in particular  for dl liteh
bool
and its fragments  
we also note that transitive roles cannot be included in our languages for free if we are
concerned with data complexity 
lemma     satisfiability and instance checking of dl litecore kbs extended with role transitivity constraints are nlogspace hard for data complexity 
proof suppose we are given a directed graph  let p be a role name  define an abox
a by taking p  ai   aj    a iff there is an edge  ai   aj   in the graph  then a node an is
reachable from a node a  iff the dl litecore abox a   p  a    an    is not satisfiable in
models with transitive p   this encoding immediately gives the claim of the lemma because
the directed graph reachability problem is nlogspace complete  nlogspace is closed
under the complement  see  e g   kozen        and the tbox  tra p    does not depend on
the input 
q
on the other hand  as the reduction of lemma      is computable in nlogspace  we
obtain the following 
 hn   

corollary     satisfiability and instance checking of dl litebool
complete for data complexity 

kbs are nlogspace 

proof the upper bound is obtained by applying the nlogspace reduction of lemma     
and using corollary      the lower bound follows from lemma     
q

  

fithe dl lite family and relations

    p  and conp hardness for data complexity
let us now turn to the data complexity of instance checking for the dl lite logics with
arbitrary number restrictions and role inclusions  as follows from the results of ortiz et al 
       for shiq  instance checking  and in fact query answering  for dl litehn
bool is in
conp for data complexity  while the results of hustadt et al         and eiter et al        
for horn shiq imply a polynomial time upper bound for dl litehf
horn  
here we show that these upper bounds are optimal in the following sense  on the one
hand  instance checking in dl litehf
core is p hard for data complexity  on the other hand 
hn
it becomes conp hard for both dl litehf
krom and dl litecore  that is  if we allow negated
concept names or arbitrary number restrictionsin fact     r is enough   note that the
results of this section do not depend on whether we adopt the una or not 
theorem     the instance checking  and query answering  problem for dl litehf
krom kbs
is data hard for conp  with or without the una  
proof the proof is by reduction of the unsatisfiability problem for    cnf  which is
known to be conp complete  schaerf         given a    cnf formula
  

n
 

 ak    ak    ak    ak     

k  

where each ak j is one of the propositional variables a            am   we construct a kb  t   a  
whose tbox t does not depend on   we will use the object names f   ck   for    k  n 
and ai   for    i  m  role names s  sf and pj   pj t   pj f   for    j     and concept names
a and d 
define a to be the set of the following assertions  for    k  n 
s f  ck   

p   ck   ak     

p   ck   ak     

p   ck   ak     

p   ck   ak     

and let t consist of the axioms
   pj v  
pj f v pj  

pj t v pj  

pj t v pj f  

pj f


pj t

v a 

p  f u p  f u p  t u p  t v

sf  

v a 

for   j    

    

for    j    

    

for    j    

    

for    j    

    
    



   s v  

    

sf v s 

    

sf v d 

    

note that axiom      does not belong to dl litehf
krom because of the conjunctions in its
left hand side  however  it can be eliminated with the help of lemma      so let us prove
that  t   a      d f   iff  is not satisfiable 
   suppose that  is not satisfiable and i     t   a    define an assignment a of the
truth values t and f to propositional variables by taking a ai     t iff aii  ai   as  is false
  

fiartale  calvanese  kontchakov   zakharyaschev

under a  there is k     k  n  such that a ak       a ak       f and a ak       a ak       t 
in view of       for each j     j     we have cik   pj t  i   pj f  i   and by      
cik   pj  i   therefore  by      and       cik   pj t  i if a ak j     t and cik   pj f  i if
a ak j     f  and hence  by       cik   sf  i   then by      and       we have f i   sf  i  
from which  by       f i  di   it follows that  t   a      d f   
   conversely  suppose that  is satisfiable  then there is an assignment a such that
a ak       t or a ak       t or a ak       f or a ak       f  for all    k  n  define i by taking

  
    
  i   x i      i  m  yk      k  n  z  
 aii   xi   for    i  m 
cik   yk   for    k  n 
f i   z 

  
    
 ai   xi   a ai     t  yk      k  n  z  

  
  
 
i    y   ai        k  n  a a     t   x   x     a a     t   z  z   
 pj t
i i
i
k k j
k j
  
 

i    y   ai        k  n  a a     f   x   x     a a     f  
 pj f
i i
i
k j
k k j
i  p i   for    j    
 pji   pj t
j f

 
 sfi    z  yk     a ak    ak    ak    ak       f    

 
 s i    z  yk        k  n  

 
 di   z   a     f    

it is not hard to check that i     t   a   and i     d f   

q

theorem     the instance checking  and the query answering  problem for dl litehn
core
kbs is data hard for conp  with or without the una  
proof the proof is again by reduction of the unsatisfiability problem for    cnf  the
hf
main difference from the previous one is that dl litehn
core   unlike dl litekrom   cannot express
covering conditions like       it turns out  however  that we can use number restrictions
to represent constraints of this kind  given a    cnf formula   we take the same abox
a constructed in the proof of theorem      the   independent  tbox t   describing the
meaning of any such representation of  in terms of a   is also defined in the same way as
in that proof  except that the axiom      is now replaced by the following set of axioms 
tj   v tj  


  tj

v  

pj v tj    

tj  

u


tj  

tj   v tj  

v

    
    

pj v tj    


tj  
 

   tj v pj t

tj   v tj  

    
    

tj   v pj f  

    

where tj   tj     tj     tj   are fresh role names  for each j     j     note that axioms     
and      do not belong to dl litehn
core because of the conjunctions in their left hand side  but
  

fithe dl lite family and relations

we can easily eliminate them using lemma      so it remains to prove that  t   a      d f  
iff  is not satisfiable 
   suppose that  is not satisfiable and i     t   a    define an assignment a of the
truth values t and f to propositional variables by taking a ai     t iff aii  ai   as  is
false under a  there is k     k  n  such that a ak       a ak       f  a ak       a ak       t 
for each j     j     we have cik   pj  i   by       cik   tj    i    tj    i   so there
i and  ci   v    t i   if v    v then ci      t  i
are v    v  such that  cik   v     tj  
 
 
j
j  
k  
k
 i
and  by       cik   pj t  i   otherwise  if v    v    v  we have v   tj  
  by      
and so by      and       cik   tj    i   from which  by       cik   pj f  i   therefore 
cik   pj t  i   pj f  i   and by       cik   pj  i   thus  by      and       cik   pj t  i
if a ak j     t and cik   pj f  i if a ak j     f  and hence  by       cik   sf  i   then
by      and       we have f i   sf  i   from which  by       f i  di   it follows that
 t   a      d f   
   conversely  suppose that  is satisfiable  then there is an assignment a such that
a ak       t or a ak       t or a ak       f or a ak       f  for all    k  n  define i by taking

  
  
    
 i   xi      i  m  yk      k  n  uk j     uk j        j        k  n  z  
 aii   xi   for    i  m 

cik   yk   for    k  n 

f i   z 

 ai    xi   a ai     t  
 

i    y   ai        k  n  a a     t   for    j    
 pj t
k j
k k j
 

i    y   ai        k  n  a a     f   for    j    
 pj f
k j
k k j
i  p i   for    j    
 pji   pj t
j f

 
i    y   u
 tj  
k k j          k  n   for    j    

 
i    y   u
 tj  
k k j          k  n  a ak j     t 

 
 yk   uk j          k  n  a ak j     f   for    j    

 
i    y   u
 tj  
i k j          k  n  a ak j     f   for    j    
i  ti  
 tji   tj  
j  

 
 sfi    z  yk     a ak    ak    ak    ak       f    

 
 s i    z  yk        k  n  

 
 di   z   a     f    

it is not hard to check that i     t   a   and i     d f   

q

our next lower bound would follow from theorem    item   in the work of calvanese
et al          unfortunately  the proof there is incorrect and cannot be repaired 
theorem     the instance checking  and query answering  problem for dl litehf
core kbs
is data hard for p  with or without the una  
  

fiartale  calvanese  kontchakov   zakharyaschev

proof the proof is by reduction of the entailment problem for horn cnf  which is known
to be p complete  see  e g   borger et al         exercise         given a horn cnf formula
  

n
 

 ak    ak    ak    



k  

p
 

al    

l  

where each ak j and each al   is one of the propositional variables a            am   we construct a
kb  t   a   whose tbox t does not depend on   we will need the object names c            cn
and vk j i   for    k  n     j        i  m  for each variable  we take one object name
for each possible occurrence of this variable in each non unit clause   role names s  st and
pj   pj t   for    j     and a concept name a 
define a to be the set containing the assertions 
s v    i   v    i    s v    i   v    i    s v    i   v    i    s v    i   v    i    s v    i   v    i         
        s vn   i   vn   i    s vn   i   v    i   
pj  vk j i   ck  

iff

a v    i  

al     ai  

iff

ak j   ai  

for    i  m 

for    i  m     k  n     j    
for    i  m     l  p

 all objects for each variable are organized in an s cycle and pj  vk j i   ck    a iff the
variable ai occurs in the kth non unit clause of  in the jth position   let t consist of the
following concept and role inclusions 
st v s 

    

   s v  

    

a v st  
st

    

v a 

    

   p  v 
p  t v p   
a v p  t  


p  t

u

  p 

   p  v  

    

p  t v p   

    

a v p  t  

    

v  

    

p  t v p   

    


p  t

v


p  t
 

    

p  t v a 

    

as before  here we have an axiom  namely       that does not belong to dl litehf
core because
of the conjunction in its left hand side  but again it can be eliminated with the help of
lemma      our aim is to show that  t   a      a v    i    iff     ai   
   suppose that     ai    consider an arbitrary model i of  t   a   and define a to be
the assignment of the truth values t and f to propositional variables such that a ai     t iff
i
i
v    i
 ai   for    i  m  by           for each i     i  m  we have either vk j i
 ai  
i
i
for all k  j with    k  n     j     or vk j i 
  a   for all k  j with    k  n 
   j     now  if we have a ak       t and a ak       t  for    k  n then  by          
 i
 i
 i
i
cik   p  t
     p  t
    by       cik   p  t
  and hence  by      and       vk   i
  p  t  i  
  

fithe dl lite family and relations

st   s
s
pj t   pj
pj

a   a   a 
y 

a   a   a 
y 

a
a

 

xk j i
 

zk j i
a 

a 

a 

a 

a 

figure    the model i satisfying  t   a    for     a   a   a      a   a   a    
i
i
where ak     ai   which means  by       that vk   i
 ai   and so v    i
 ai and a ai     t  it
i
follows that a     t  and hence a ai      t  which  by definition  means that v    i
 ai  
 
so we can conclude that  t   a      a v    i    

   conversely  suppose that      ai    then there is an assignment a with a     t
and a ai      f  we construct a model i of  t   a   such that i     a v    i     define i by
taking

  
 
 i   xk j i   zk j i      k  n     j        i  m  yk      k  n  
 cik   yk   for    k  n 
i
  xk j i   for    k  n     j        i  m 
 vk j i

 
 ai   xk j i      k  n     j     a ai     t  
 

 
 si  
si   where si    xk   i   xk   i     xk   i   xk   i     xk   i   xk    i        k  n
 im

and k      k     if k   n  and k        if k   n 
 
 sti  
si  
 im
a ai   t


 
 pji    xk j i   yk        k  n  ai   ak j  
 xk j i   zk j i        k  n  ai    ak j   for    j    

 
 p i    xk   i   yk        k  n  ai   ak    

 
i    x
 pj t
 k j i   yk        k  n  ai   ak j   a a
  i    t 
 xk j i   zk j i        k  n  ai    ak j   for    j    

 
i    x
 p  t
k   i   yk        k  n  ai   ak     a ai     t  
it is routine to check that we indeed have i     t   a   and i     a v    i     see figure   for
an example 
q

  

fiartale  calvanese  kontchakov   zakharyaschev

   query answering  data complexity
the positive existential query answering problem is known to be data complete for conp
in the case of dl litehn
bool   the upper bound follows from the results of ortiz et al         
while the lower bound was established for dl litekrom by calvanese et al          schaerf
        in the case of dl litehf
horn   query answering is data complete for p  as follows
from the results of hustadt et al         and eiter et al         for horn shiq  while for
 
dl liteh
horn it is in ac  calvanese et al         
in fact  the conp upper bound holds for the extension of dl litehn
bool with role disjointness and  a symmetry constraints  this follows from glimm et al         theorem    
cf  remark        we conjecture that the same result holds for role  ir reflexivity constraints 
our main result in this section is the following 
theorem     the positive existential query answering problem for the logics dl liten
horn  
 hn  
h
 
dl litehorn and dl litehorn is in ac for data complexity 
 hn  

proof suppose that we are given a consistent dl litehorn kb k     t     a     with all its
concept and role names occurring in the tbox t     and a positive existential query in prenex
 hn  
form q  x     y   x   y   in the signature of k    consider the dl litehorn kb k    t   a 
 hn  

provided by lemma       the language dl litehorn

is defined in section      

lemma     for every tuple  a of object names in k    we have k     q  a  iff i    q  a  for
all untangled models i of k 
proof    suppose that k     q  a  and i is an untangled model i of k  by lemma     
and in view of consistency of k    which ensures that      holds  we then have i    k  and
therefore  i    q  a  
   suppose i      k    by lemma       there is a model i of k with the same domain as
 
i that coincides with i   on all symbols in k    as i    q  a   we must then have i      q  a  
and so k     q  a  as required 
q
next we show that  as ke is a horn sentence  it is enough to consider just one special
model i  of k in the formulation of lemma      let m  be the minimal herbrand model of
 the universal horn sentence  ke   we remind the reader  for details consult  e g   apt       
rautenberg        that m  can be constructed by taking the intersection of all herbrand
models for ke   that is  of all models based on the domain that consists of constant symbols
from ke i e      ob a   dr t    cf  remark       we then have the following
m     b   c 

iff

ke    b   c  

for b  bcon t   and c   

let i  be the untangled model of k induced by m    denote the domain of i  by i   
property  copy  of remark      provides us with a function cp   i    
there are two consequences of lemma       first  we have
aii    b i 

iff

k    b ai   

for b  bcon t   and ai  ob a  

  

    

fithe dl lite family and relations

second  for every r  role  t    if ri      then ri      for all models i of k  indeed  if
ri      then m      r   dr   therefore   t   r v    a  is not satisfiable  and thus
ri      for all i with i    k  moreover  if ri      then
w  b i 

iff

k    r v b 

for b  bcon t   and w  i  with cp w    dr      

lemma     if i     q  a  then i    q  a  for all untangled models i of k 
proof suppose i    k  as q  a  is a positive existential sentence  it is enough to construct
a homomorphism h   i   i  we remind the reader that  by  forest   the domain i  of
i  is partitioned into disjoint trees ta   for a  ob a   define the depth of a point w  i 
to be the length of the shortest path in the respective tree to its root  denote by wm the
set of points of depth  m  in particular  w     ai    a  ob a    we construct h as the
union of maps hm   m     where each hm is defined on wm and has the following properties 
hm    w    hm  w   for all w  wm   and
 am   for every w  wm   if w  b i  then hm  w   b i   for each b  bcon t   
 bm   for all u  v  wm   if  u  v   ri  then  hm  u   hm  v    ri   for each r  role  t   
for the basis of induction  we set h   aii       aii   for ai  ob a   property  a    follows then
from      and  b    from  abox  of remark      
for the induction step  suppose that hm has already been defined for wm   m     set
hm    w    hm  w  for all w  wm   consider an arbitrary v  wm     wm   by  forest  
there is a unique u  wm such that  u  v   ea   for some ta   let  a  u  v    s  then 
by  copy   cp v    inv ds   by  role   u   s i  and  by  am    hm  u    s i   which
means that there is w  i with  hm  u   w   s i   set hm    v    w  as cp v    inv ds 
and  inv s  i       it follows from      that if v  b i  then w   b i whenever we have
w    inv s  i   as w   inv s  i   we obtain  am     for v  to show  bm      we notice
that  by  role   we have  w  v   ri    for some w  wm     just in two cases  either
w  wm     wm   and then w   v and id vt r  or w  wm   and then w   u and s vt r 
in the former case   hm    v   hm    v    ri because idi is the identity relation by  role  
in the latter case  we have  u  v   s i    hence  hm    u   hm    v    s i and  as s vt r 
 hm    u   hm    v    ri  
q
assume now that  in the query q  x     y   x   y    we have  y   y            yk   and  is a
quantifier free formula  our next lemma shows that in this case to check whether i     q  a 
it suffices to consider only the points of depth  m  in i    for some m  that does not
depend on  a  
lemma     let m    k    role  t     if i      y   a   y   then there is an assignment a  in
wm   i e   a   yi    wm  for all i  such that i    a    a   y   
proof suppose that i    a   a   y    for some assignment a in i    and that there is yi  
   i  k  with a yi   
  wm    let y be the minimal subset of  y that contains yi and
every y such that either p  y     y  or p  y  y     is a subformula of   for some y    y and
some role name p   let yj  y be such that there is m    role  t    with a yj    wm and
  

fiartale  calvanese  kontchakov   zakharyaschev

a y  
  wm  for all y  y  for convenience  w     as before   clearly  such an m exists 
a yi   
  wm    y has at most k variables and  by  forest   relations p i  can connect a point
in wn   wn  only with a point in wn     wn    for n     let w   a yj   be a point in
ta   as w  wm   wm    we have cp w    dr  for some r  role  t    as there are at most
 role  t    distinct labels in each labeled tree ta and in view of  copy   for each point u
of depth    role  t     there is a point u  of depth   role  t    in the same ta such that
cp u    cp u     by  iso   the trees generated by u and u  are isomorphic  so  there is an
isomorphism g from the labeled tree generated by w  which contains all a y   for y  y  
onto the labeled tree generated by some point of depth   role  t    in ta   define a new
assignment ay by taking ay  y    g a y   if y  y and ay  y    a y  otherwise  by  copy  
 concept  and  role  we then have i    ay   a   y   and ay  y   wm    for each y  y   if
ay  yj   
  wm  for some j  we repeat the described construction  after at most k iterations
we shall obtain an assignment a  required by the lemma 
q
to complete the proof of theorem      we encode the problem k    q  a   as a model
checking problem for first order formulas  in precisely the same way as in section      we
fix a signature that contains unary predicates a  a  for each concept name a  and binary
predicates p   p   for each role name p   and then represent the abox a of k as a first order
model aa with domain ob a   now we define a first order formula t  q   x  in the above
signature such that  i  t  q   x  depends on t and q but not on a  and  ii  aa    t  q   a 
iff i     q  a  
we begin by defining formulas b  x   for b  bcon t    that describe the types of the
elements of ob a  in the model i  in the following sense  see also       
aa    b  ai  

iff aii    b i   

for b  bcon t   and ai  ob a  

    

   x       x         of formulas
these formulas are defined as the fixed points of sequences b
b
with one free variable  where
 
a x  
if b   a 
 
b  x   
t
eq r  x   if b    q r 
 

i 
i 
i
 
b
 x    b
 x  
b
 x       b
 x    for i    
 
k
b  uubk vbext t  

and eq rt  x  is given by        as in section      to simplify presentation we use ext t   instead of t    it should be clear that if there is some i such that  for all b  bcon t   
i  x    i    x   i e   every  i  x  is equivalent to  i    x  in first order logic   then
b
b
b
b
i  x    j  x  for every b  bcon t   and j  i  so the minimum such i does not
b
b
n  x  
exceed n    bcon t     and we set b  x    b
next we introduce sentences b dr   for b  bcon t   and dr  dr t    that describe the
types of elements in dr t   in the following sense  see also       
aa    b dr

iff

w  b i    for b  bcon t   and each w  i  with cp w    dr 

    

 by  concept   this definition is correct   these sentences are defined similarly to b  x  
namely  for each b  bcon t   and each dr  dr t    we inductively define a sequence
  

fithe dl lite family and relations

 
 
b dr
  b dr
        by taking
 
b dr
   b dr

and

i
b dr
  ib dr 

 


i 
i 
b






  for i    
 dr
b
 dr
 
k

b  uubk vbext t  

where ib dr     for all i     whenever b    r and
 r dr   x inv r   x 

and

ir dr  

 

i 
inv r  ds
 

for i    

dsdr t  
i  
i
it should be clear that there is i   role  t   n such that b dr
 b dr
  for all b  bcon t  
 role  t   n

and dr  dr t    so we set b dr   b dr
 
now we consider the directed graph gt    vt   et    where vt is the set of all equivalence
classes  r    r     r    r t r     such that r is not empty in some model of t   and et
is the set of all pairs   ri     rj    such that
 path  t    inv ri   v  q rj

and

either inv ri    vt rj or q    

and rj has no proper sub role satisfying  path   we have   ri     rj     et iff  for any
abox a    whenever the minimal untangled model i  of  t   a    contains a copy w of inv dri    
for ri    ri    then w is connected to a copy of inv drj     for rj    rj    by all relations s
with rj vt s 
recall now that we are given a query q  x     y   x   y    where  is a quantifier free
positive formula and  y   y            yk   let t  m  be the set of all paths in the graph gt of
length  m    more precisely 
   
 
t  m        r      r              rn         n  m      rj     rj       et   for    j   n  
r

for       t  m  and a role r  role  t    we write      if one of the following three
conditions is satisfied   i        and id vt r   ii    s       or  iii          inv s    for
some role s with s vt r 
let kt  m  be the set of all k tuples of the form                  k    i  t  m    intuitively 
when evaluating the query  y   x   y   over i    each bound  or non distinguished  variable yi
is mapped to a point w in wm    however  the first order model aa does not contain the
points from wm    w    and to represent them  we use the following trick  by  forest  
every point w in wm  is uniquely determined by the pair  a     where ai  is the root of the
tree ta containing w  and  is the sequence of labels  a  u  v  on the path from ai  to w 
it follows from the unraveling procedure and  path  that   t  m    so  in the formula
t  q we are about to define we assume that the yi range over w  and represent the first
component of the pairs  a     whereas the second component is encoded in the ith member
of    these yi should not be confused with the yi in the original query q  which range over
all of wm     in order to treat arbitrary terms t occurring in   x   y   in a uniform way  we
set t      if t   a  ob a  or t   xi   and t    i   if t   yi  the distinguished variables xi
and the object names a are mapped to w  and do not require the second component of the
pairs  
given an assignment a  in wm  we denote by split a    the pair  a       where a is an
assignment in aa and                  k    kt  m  are such that
  

fiartale  calvanese  kontchakov   zakharyaschev

 for each distinguished variable xi   a xi     a with ai    a   xi   
 for each bound variable yi   a yi     a and i     r              rn     n  m    with ai 
being the root of the tree containing a   yi   and r            rn being the sequence of
labels  a  u  v  on the path from ai  to a   yi   
not every pair  a       however  corresponds to an assignment in wm  because some paths
in   may not exist in our i    gt represents possible paths in all models for the fixed
tbox t and varying abox  as follows from the unraveling procedure  a point in wm    w 
corresponds to a  ob a  and      r            t  m  iff a does not have enough r witnesses
 
r
in a  i e   iff aa    q
   with
r  a   q r  a   for some q  qt   thus  for every  a   
                 k    there is an assignment a  in wm  with split a       a      iff aa   a     y   
where
 
 

 
q
         k    y            yk    
ri  yi    q ri  yi  
r

 ik
i   

qqt i

and each ri   for    i  k with i      is such that i     ri            
we define now  for every    kt  m    concept name a and role name r 
 
a  t  
if t     
a   t   
a inv ds    if t         s   for some     t  m   
 t
 

 


r  t    t     if t    t     
r
r   t    t     
 t    t    
if t    t   and either t       or t       


 
otherwise 
where rt  y    y    is given by       we claim that  for every assignment a  in wm  and
 a      split a    
i    a  a t 

iff

aa   a a   t  

i    a  r t    t   

iff

aa   a r   t    t    

for all concept names a and terms t 
for all roles r and terms t    t   

    
    

for a a   a xi   or a yi   with i    the claim follows from       for a yi   with i        s  
by  copy   we have cp a yi      inv dr   for some r   s   the claim then follows from      
for r yi    yi    with i    i      the claim follows from  abox   let us consider the case
of r yi    yi    with i       we have a   yi    
  w  and thus  by  role   i    a  r yi    yi    iff
 a   yi     a   yi    are in the same tree ta   for a  ob a   i e   aa   a  yi    yi    
 and either  a   yi     a   yi      ea and then  a  a   yi     a   yi       s for some s vt r 
or  a   yi     a   yi      ea and then  a  a   yi     a   yi       s for some inv s  vt r  or
r

a   yi      a   yi    and then id vt r  i e   i   i   
other cases are similar and left to the reader 
finally  let     x   y   be the result of attaching the superscript   to each atom of  and

  
t  q   x     y
    x   y        y    
 
 kt  m

 

  

fithe dl lite family and relations

as follows from           for every assignment a  in wm    we have i    a    x   y   iff
aa   a     x   y   for  a      split a     for the converse direction notice that  if aa   a     y  
then there is an assignment a  in wm  with split a       a      
clearly  aa    t  q   a  iff i     q  a   for every tuple  a  we also note that  for every
pair of tuples  a and  b of object names in ob a       a   b  is a positive existential sentence
with inequalities  and so is domain independent    it is also easily seen that  for each  b 
    b  is domain independent  it follows from the minimality of i  that t  q   a  is domainindependent  for each tuple  a of object names in ob a  

finally  note that the resulting query contains   role  t   k k  role  t     disjuncts  q

   dl lite without the unique name assumption
in this section  unless otherwise stated  we assume that the interpretations do not respect
the una  that is  we may have aii   aij for distinct object names ai and aj   the consequence
relation   nouna refers to the class of such interpretations 
description logics without the una are usually extended with additional equality and
inequality constraints of the form 
ai  aj

and

ai   aj  

where ai   aj are object names  their semantics is quite obvious  we have i    ai  aj iff
aii   aij   and i    ai   aj iff aii    aij   the equality and inequality constraints are supposed
to belong to the abox part of a knowledge base  it is to be noted  however  that reasoning
with equalities is logspace reducible to reasoning without them 
lemma     for every kb k    t   a   one can construct in logspace in the size of
a a kb k     t   a    without equality constraints such that i    k iff i    k    for every
interpretation i 
proof let g    v  e  be the undirected graph with

 
v   ob a  
e    ai   aj     ai  aj  a or aj  ai  a
and  ai   the set of all vertices of g that are reachable from ai   define a  by removing all the
equality constraints from a and replacing every ai with aj   ai   with minimal j  note that
this minimal j can be computed in logspace  just enumerate the object names aj with
respect to the order of their indexes j and check whether the current aj is reachable from
ai in g  it remains to recall that reachability in undirected graphs is slogspace complete
and that slogspace   logspace  reingold        
q
as we mentioned in section      the logics of the form dl liteh
 do not feel whether
we adopt the una or not  with this observation and lemmas            and     at hand 
we obtain the following result as a consequence of theorem      
    a query q  
x  is said to be domain independent in case aa   a q  
x  iff a   a q  
x   for each a such that
the domain of a contains ob a   the active domain of aa   and aa   aaa and p a   p aa   for all concept
and role names a and p  

  

fiartale  calvanese  kontchakov   zakharyaschev

theorem     with or without the una  for combined complexity   i  satisfiability of
h
dl liteh
bool kbs is np complete   ii  satisfiability of dl litehorn kbs is p complete  and
h
 iii  satisfiability of dl liteh
krom and dl litecore kbs is nlogspace complete  these results hold even if the kbs contain role disjointness   a symmetry   ir  reflexivity and transitivity constraints  equalities and inequalities 
on the other hand  from corollary     and lemmas            and     we can derive
the following 
theorem     without the una  satisfiability and instance checking for dl liteh
bool kbs
 
 
are in ac for data complexity  these problems are also in ac if the kbs contain role
disjointness   a symmetry and  ir  reflexivity constraints and inequalities  however  they
are logspace complete if the kbs may contain equalities  and nlogspace complete if
role transitivity constraints are allowed 
we also note that our complexity results  corollary       theorems          and      for
the logics dl litehf
and dl litehn
do not depend on the una 


in this section  we analyze the combined and data complexity of reasoning in the logics
 hf  
 hn  
of the form dl lite
and dl lite
 as well as their fragments  without the una 
the obtained and known results are summarized in table   on page    
 hn  

    dl lite

  arbitrary number restrictions

the following theorem shows that the interaction between number restrictions and the
possibility of identifying objects in the abox results in a higher complexity 
theorem     without the una  satisfiability of dl liten
core kbs  even without equality
and inequality constraints  is np hard for both combined and data complexity 
proof the proof is by reduction of the following variant of the  sat problemcalled monotone one in three  sat which is known to be np complete  garey   johnson        
given a positive  cnf formula
  

n
 


ak    ak    ak    

k  

where each ak j is one of the propositional variables a            am   decide whether there is an
assignment for the variables aj such that exactly one variable is true in each of the clauses
k
in   to encode this problem in the language of dl liten
core   we need object names ai   for
   k  n     i  m  and ck and tk   for    k  n  role names s and p   and concept
names a    a    a    let a be the abox containing the following assertions 
s a i   a i            s ain    ani    s ani   a i   

for    i  m 

s t    t             s tn    tn    s tn   t    
p  ck   tk   

for    k  n 

p  ck   akk j    aj  akk j   

for    k  n     j    

  

fithe dl lite family and relations

and let t be the tbox with the following axioms 
a  v a   

a  v a   

a  v a   

   s v  

   p v  

clearly   t   a   is a dl liten
core kb and t does not depend on   so that we cover both
combined and data complexity   we claim that the answer to the monotone one in three
 sat problem is positive iff  t   a   is satisfiable without the una 
   suppose i     t   a    define an assignment a of the truth values f and t to
propositional variables by taking a ai     t iff  a i  i    t   i   our aim is to show that
a ak j     t for exactly one j             for each k     k  n  for all j            
we have  cik    akk j  i    p i   moreover   akk i  i     akk j  i for i    j  as cik      p  i and
 cik    tk  i    p i   we then must have  akk j  i    tk  i for some unique j             it follows
from functionality of s that  for each    k  n  we have  a k j  i    t   i for exactly one
j            
   let a be an assignment satisfying the monotone one in three  sat problem  take
some ai  with a ai      t  clearly  such an i  exists  for otherwise a     f  and construct
an interpretation i    i   i   by taking 

  
 
 i   yk   z k      k  n  xki   a ai     f     i  m     k  n  
 cik   yk and  tk  i   z k   for    k  n 
 
xki   if a ai     f 
  aki  i  
for    i  m     k  n 
z k   if a ai     t 

 
 s i     a i  i    a i  i              ain   i    ani  i      ani  i    a i  i        i  m  
 

 p i    cik    tk  i     cik    akk    i     cik    akk    i     cik    akk    i        k  n  
it is readily checked that i     t   a   

q

in fact  the above lower bound is optimal 
 hn  

 hn   

theorem     without the una  satisfiability of dl liten
and dl lite
   dl lite
kbs with equality and inequality constraints is np complete for both combined and data
complexity and any    core  krom  horn  bool  
proof the lower bound is immediate from theorem      and the matching upper bound
 hn   
can be proved by the following non deterministic algorithm  given a dl litebool
kb
k    t   a   we
 guess an equivalence relation  over ob a  

 select in each equivalence class ai   a representative  say ai   and replace every occurrence of a  ai   in a with ai  
 fail if the equalities and inequalities are violated in the resulting aboxi e   if it
contains ai   ai or ai  aj   for i    j 
  

fiartale  calvanese  kontchakov   zakharyaschev

 otherwise  remove the equality and inequality constraints from the abox and denote
the result by a   
 hn   

 use the np satisfiability checking algorithm for dl litebool
kb k     t   a    is consistent under the una 

to decide whether the

clearly  if the algorithm returns yes  then i      k    for some i   respecting the una  and
we can construct a model i of k  not necessarily respecting the una  by extending i   with
 
the following interpretation of object names  ai   aii   whenever ai is the representative
of a   i coincides with i   on all other symbols   conversely  if i    k then we take
the equivalence relation  defined by ai  aj iff aii   aij   let i   be constructed from
i by removing the interpretations of all object names that are not representatives of the
equivalence classes for   it follows that i   respects the una and i      k    so the algorithm
returns yes 
q
 hf  

    dl lite

  functionality constraints
 hf   

let us consider now dl litebool
and its fragments  the following lemma shows that for
these logics reasoning without the una can be reduced in polynomial time in the size of
the abox to reasoning under the una 
 hf   

lemma     for every dl litebool

kb k    t   a  with equality and inequality con hf   

straints  one can construct in polynomial time in  a  a dl litebool
kb k     t   a    such
that a  contains no equalities and inequalities and k is satisfiable without the una iff k 
is satisfiable under the una 
proof in what follows by identifying aj with ak in a we mean replacing each occurrence
of ak in a with aj   we construct a  by first identifying aj with ak   for each aj  ak  a 
and removing the equality from a  and then exhaustively applying the following procedure
to a 
 if    r v   t and r ai   aj    r ai   ak    clet  a   for distinct aj and ak   then
identify aj with ak  recall that a functional r cannot have transitive sub roles and
thus clet  a  is enough  
if the resulting abox contains ai   ai   for some ai   then  clearly  k is not satisfiable  so
we add a ai   and a ai   to the abox  for some concept name a  finally  we remove
all inequalities from the abox and denote the result by a    it should be clear that a  is
computed from a in polynomial time and that  without the una  k is satisfiable iff k  is
satisfiable  so it suffices to show that k  is satisfiable without the una iff it is satisfiable
under the una  the implication    is trivial 
   observe that the above procedure ensures that
e
qr a
   

for each r with    s v   t   r vt s and a  ob a   
 hn  

 see page    for definitions   let k   be the dl litebool
kb provided by lemma      for
k    it follows from the above property and the proofs of lemma      and corollary     
  

fithe dl lite family and relations

that if k   is satisfiable without the una then  k    e is satisfied in a first order model
with some constants interpreted by the same domain element  as  k    e is a universal
first order sentence containing no equality  it is satisfiable in a first order model such that
all constants are interpreted by distinct elements  it follows from the proofs of lemma     
and corollary      that this first order model can be unraveled into a model j for k  
respecting the una  by lemma       j is a model of k   
q
the reduction above cannot be done better than in p  as shown by the next theorem 
theorem     without the una  satisfiability of dl litef
core kbs  even without equality
and inequality constraints  is p hard for both combined and data complexity 
proof the proof is by reduction of the entailment problem for horn cnf  as in the proof
of theorem       let
  

n
 

ak    ak    ak  



p
 



al  

l  

k  

be a horn cnf formula  where each ak j and each al   is one of the propositional variables
a            am and ak     ak     ak   are all distinct  for each k     k  n  to encode the pk
complete problem     ai   in the language of dl litef
core we need object names t  ai   for
   k  n     i  m  and fk and gk   for    k  n  and role names p   q  s and t   the
abox a contains the following assertions
s a i   a i            s an 
  ani    s ani   a i   
i

for    i  m 

p  akk     fk    p  akk     gk    q gk   akk      q fk   akk     
t  t  a l     

for    k  n 

for    l  p 

and the tbox t asserts that all of the roles are functional 
   p v  

   q v  

  s v 

and

   t v  

clearly  k    t   a  is a dl litef
core kb and t does not depend on   we claim that
    aj iff  t   a   t  t  a j     is not satisfiable without the una  to show this  it suffices
to prove that     aj iff k   nouna t  t  a j   
   suppose     aj   then we can derive aj from  using the following inference rules 
     al   for each l     l  p 
 if     ak   and     ak     for some k     k  n  then     ak    
we show that k   nouna t  t  a j   by induction on the length of the derivation of aj from  
the basis of induction is trivial  so assume that aj   ak         ak         ak     for some k 
   k  n  and that k   nouna t  t  a k      t  t  a k      suppose also that i    k  since t
 
 
is functional  we have  a k    i    a k    i   since s is functional   akk    i    akk    i   for all k    
   k    n  and in particular  for k     k  then  since p is functional  fki   gki   from which 
 
 
by functionality of q   akk    i    akk    i   finally  since s is functional   akk    i    akk    i  
  

fiartale  calvanese  kontchakov   zakharyaschev

for all k        k    n  and in particular  for k        thus  i    t  t  a j   and therefore
k   nouna t  t  a j   
   suppose that      aj   then there is an assignment a such that a     t and
a aj     f  construct an interpretation i by taking

  
    
 i   xki   a ai     f     k  n     i  m  z k   uk   vk      k  n  w  
 
xki   if a ai     f 
  aki  i  
for    k  n and    i  m 
z k   if a ai     t 

 
 ti   w  t i    w  z      

 
 s i     a i  i    a i  i              an 
 i    ani  i      ani  i    a i  i        i  m  
i
 
vk   if a ak       f 
 fki   uk and gki  
for    k  n 
uk   if a ak       t 
 

 p i     akk    i   fki      akk    i   gki        k  n  
 

 qi    gki    akk    i     fki    akk    i        k  n  
it is readily checked that i    k and i     t  t  a j    and so k    nouna t  t  a j   

q

the above result strengthens the nlogspace lower bound for instance checking in
dl litef
core proved by calvanese et al         
 hf  

 hf   

corollary     without the una  satisfiability of dl litef
and dl lite
   dl lite
kbs     core  krom  horn   with equalities and inequalities is p complete for both combined and data complexity 
 hf  
 hf   
without the una  satisfiability of dl litef
kbs with
bool   dl litebool and dl litebool
equalities and inequalities is np complete for combined complexity and p complete for data
complexity 

proof the upper bounds follow from lemma     and the corresponding upper bounds for
the una case  the np lower bound for combined complexity is obvious and the polynomial
lower bounds follow from theorem     
q
    query answering  data complexity
the p and conp upper bounds for query answering without the una follow from the results for horn shiq  hustadt et al         eiter et al         and shiq  ortiz et al        
      glimm et al          respectively  see the discussion at the beginning of section    
we present here the following result 
theorem     without the una  positive existential query answering for dl liteh
horn kbs
with role disjointness   a symmetry   ir  reflexivity constraints and inequalities is in ac 
for data complexity  this problem is logspace complete if  additionally  equalities are
allowed in the kbs 
  

fithe dl lite family and relations

proof the proof follows the lines of the proof of theorem     and uses the observation
that models without the una give no more answers than their untangled counterparts 
more precisely  let kb k     t     a    be as above  suppose that it is consistent  let q  x 
be a positive existential query in the signature of k    given k    lemma      provides
us with a kb k  it is easy to see that k is a dl liteh
horn kb extended with inequality
constraints  the following is an analogue of lemma      which also allows us to get rid of
those inequalities 
lemma      for every tuple  a of object names in k    we have k    nouna q  a  iff i    q  a 
for all untangled models i of k  respecting the una  
proof    suppose that k    nouna q  a  and i is an untangled model of k  as i respects
the una  by lemma      and in view of satisfiability of k    which ensures that      holds 
we then have i    k  and therefore  i    q  a  
   suppose i      k    we construct an interpretation j   respecting the una as follows 
 
 
 
 
let j be the disjoint union of i and ob a   define a function h   j  i by taking
 
 
h a    ai   for each a  ob a   and h w    w  for each w  i   and let


 
 
  
 
  
aj   a 
aj   u   h u   ai
and
p j    u  v     h x   h v    p i  
for each object  concept and role name a  a  p   clearly  j   respects the una and j      k   
it also follows that h is a homomorphism 
by lemma       there is a model i of k with the same domain as j   that coincides
with j   on all symbols in k    as i    q  a   we must then have j      q  a   and since h is a
homomorphism  i      q  a   therefore  k    nouna q  a  as required 
q
the remaining part of the proof is exactly as in theorem      since now we may assume
that k is a dl liteh
horn kb containing no inequality constraints  
logspace completeness for the case with equalities follows from lemma     
q

   conclusion
in this article  we investigated the boundaries of the extended dl lite family of description
logics by providing a thorough and comprehensive understanding of the interaction between
various dl lite constructs and their impact on the computational complexity of reasoning 
we studied    different logics  classified according to five mutually orthogonal features 
    the presence or absence of role inclusion assertions      the form of the allowed concept
inclusion assertions  distinguishing four main logical groups called core  krom  horn  and
bool      the form of the allowed numeric constraints  ranging from none  to global functionality constraints only  and to arbitrary number restrictions      the presence or absence
of the unique name assumption  and equalities and inequalities between object names  if
this assumption is dropped   and     the presence or absence of standard role constraints
such as role disjointness  role symmetry  asymmetry  reflexivity  irreflexivity and transitivity  for all of the resulting logics  we studied the combined and data complexity of kb
satisfiability and instance checking  as well as the data complexity of answering positive
existential queries 
  

fiartale  calvanese  kontchakov   zakharyaschev

query answering
  instance checking

conp
query answering

 
legend
satisfiability
combined complexity

with without una
role inclusions

f

n

exptime
np
p
nlogspace

no una
no role inclusions

f

una
no role inclusions

conp
p
in ac 

oo
l

n

instance checking
data complexity

b

ro
m
k

co

h

or
n

 

re

f

n

figure    complexity of basic dl lite logics 
the obtained tight complexity results are illustrated in figure    where the combined
complexity of satisfiability is represented by the height of vertical dashed lines  while the
data complexity of instance checking by the size and color of the circle on top of these lines
 recall that satisfiability and instance checking are reducible to the complement of each
other   the data complexity of query answering for the core and horn logics  shown on
the left hand side of the separating vertical plane  coincides with the data complexity of
instance checking  for the krom and bool logics  shown on the right hand side of the plane 
query answering is always data complete for conp  the upper layer shows the complexity
of logics with role inclusions  in which case it does not depend on whether we adopt the
una or not  the middle and the lower layers deal with the logics without role inclusions
when the una is dropped or adopted  respectively  in each of these layers  the twelve
languages are arranged in the      grid  one axis shows the type of concepts inclusions
allowed  horn  core  krom  bool   while the other the type of number restrictions  none 
global functionality f or arbitrary n    some observations are in order 
 under the una but without role inclusions  number restrictions do not increase the
complexity of reasoning  which depends only on the form of concept inclusions allowed 
 on the other hand  without any form of number restrictions  the logics can have role
inclusions and are insensitive to the una  again  the complexity is determined by the
shape of concept inclusions only 
 in either of the above cases  instance checking is in ac  for data complexity  which
means that the problems are first order rewritable 

  

fithe dl lite family and relations

 without una adopted and without either disjunctions or role inclusions  functionality
leads to p completeness of instance checking for data complexity  which suggests its
reducibility to datalog 
 for data complexity  there is no difference between the core and horn logics  and
between the krom and bool ones  which means that the core and krom logics can be
extended with conjunctions on the left hand side of concept inclusions for free 
 hf  

 hn  

finally  for the logics dl lite
and dl lite
with both  qualified  number restrictions and role inclusions  whose interaction is restricted by conditions  a    a     the
complexity of reasoning always coincides with the complexity of the fragments dl litef

and  respectively  dl liten
 without role inclusions  no matter whether we adopt the una
or not 
role disjointness  symmetry and asymmetry constraints can be added to any of the
 hn  
 hf  
languages without changing their complexity  in fact  the dl lite
and dl lite
logics contain all of the above types of constraints together with role reflexivity and irreflexivity  we conjecture that  ir reflexivity constraints can be added to all other logics without
affecting their complexity  however  if we extend any dl lite logic with role transitivity
constraints  then the combined complexity of satisfiability remains the same  while instance
checking and query answering become data hard for nlogspace  and the addition of
equality between object nameswhich only makes sense if the una is droppedleads to
an increase from membership in ac  to logspace completeness for data complexity  all
other results remain unchanged 
the list of dl constructs considered in this paper is far from being complete  for
example  it would be of interest to analyze the impact of nominals  role chains and boolean
operators on roles on the computational behavior of the dl lite logics  another interesting
and practically important problem is to investigate in depth the interaction between various
constructs with the aim of pushing restrictions like  a    a    as far as possible 
one of the main ideas behind the dl lite logics was to provide efficient access to large
amounts of data through a high level conceptual interface  this is supposed to be achieved
by representing the high level view of the information managed by the system as a dl lite
tbox t   the data stored in a relational database as an abox a  and then rewriting positive existential queries to the knowledge base  t   a  as standard first order queries to the
database represented by a  such an approach is believed to be viable because  for a number
of dl lite logics  the query answering problem is in ac  for data complexity  cf  theorems          and figure    the first order rewriting technique has been implemented in
various system  notably in quonto  acciarri et al         poggi et al       b   which can
query  relying on ontology to relational mappings  data stored in any standard relational
database management system  and in owlgres  stocker   smith         which can access
an abox stored in a postgres database  though  to the best of our knowledge  the latter
implementation is incomplete for conjunctive query answering   it is to be noted  however 
that the size of the rewritten query can be substantially larger than the size of the original
query  which can cause problems even for a very efficient database query engine 
for a positive existential query q and tbox t   there are two major sources of high
complexity of the first order formula t  q in the proof of theorem       i  the formulas
b  x  computing whether an abox object is an instance of a concept b  and the formulas
  

fiartale  calvanese  kontchakov   zakharyaschev

r dr computing whether objects with outgoing r arrows are instances of b   and  ii  the
 hn  
disjunction over the paths   in the graph gt   in the case of dl litecore   the size of
 hn  
b  x  is linear in  t    while for dl litehorn it can become exponential  however  various
optimizations are possible   the size of the disjunction in  ii  is exponential in the number
of non distinguished variables in q  one way of removing source  i  would be to extend
the given database  abox  a by precomputing the horn closure of the abox with respect
to the tbox and storing the resulting data in a supplementary database  this approach
is advocated by lutz et al         for querying databases via the description logic el  it
could also be promising for the horn fragments of expressive description logics such as
shiq  hustadt et al         hustadt  motik    sattler       containing dl litehf
horn as
a sub languagefor which the data complexity of instance checking  hustadt et al        
      and conjunctive query answering is polynomial  eiter et al          the disadvantage
of using a supplementary database is the necessity to update it every time the abox is
changed  it would be interesting to investigate this alternative approach for dl lite logics
and compare it with the approach described above  another important problem is to
characterize those queries for which the disjunction in  ii  can be represented by a formula
of polynomial size 
as the unique name assumption is replaced in owl by the constructs sameas and
differentfrom  i e    and     a challenging problem is to investigate possible ways of
dealing with equality  inequality does not require any special treatment as shown in the
proof of lemma        although reasoning with equality is logspace reducible to reasoning without it  cf  lemma       we lose the property of first order rewritability  and
computing equivalence classes under  may be too costly for real world applications 
dl lite logics are among those few examples of dls for which usually very complex
non standard reasoning problemssuch as checking whether one ontology is a conservative
extension of another one with respect to a given signature   kontchakov et al         
computing minimal modules of ontologies with respect to   kontchakov et al         or
uniform interpolants  wang  wang  topor    pan       can be supported by practical
reasoning tools  however  only first steps have been made in this direction  and more
research is needed in order to include these reasoning problems and tools into the standard
owl toolkit  it would be also interesting to investigate the unification problem for dl lite
logics  baader   narendran        
finally  there exist certain parallels between the horn logics of the dl lite family  el 
horn shiq and the first order language of tuple and equality generating dependencies 
tgds and egds  used in the theory of databases  see  e g   gottlob   nash         further
investigations of the relationships between these logics may lead to a deeper understanding
of the role description logics can play in the database framework 
acknowledgments
this research has been partially supported by fet project tones  thinking ontologies   funded within the eu  th framework programme under contract fp        and
by the large scale integrating project  ip  ontorule  ontologies meet business rules
ontologies   funded by the ec under ict call   fp  ict         contract number fp         we thank the referees for their constructive criticism  comments  and suggestions 

  

fithe dl lite family and relations

references
abiteboul  s   hull  r     vianu  v          foundations of databases  addison wesley 
acciarri  a   calvanese  d   de giacomo  g   lembo  d   lenzerini  m   palmieri  m    
rosati  r          quonto  querying ontologies  in proc  of the   th nat  conf 
on artificial intelligence  aaai        pp           
apt  k          logic programming  in van leeuwen  j   ed    handbook of theoretical
computer science  volume b  formal models and sematics  pp          elsevier
and mit press 
artale  a   calvanese  d   kontchakov  r     zakharyaschev  m       a   dl lite in the
light of first order logic  in proc  of the   nd nat  conf  on artificial intelligence
 aaai        pp         
artale  a   calvanese  d   kontchakov  r   ryzhikov  v     zakharyaschev  m       b  
reasoning over extended er models  in proc  of the   th int  conf  on conceptual
modeling  er        vol       of lecture notes in computer science  pp         
springer 
artale  a   cesarini  f     soda  g          describing database objects in a concept
language environment  ieee trans  on knowledge and data engineering            
    
artale  a   parent  c     spaccapietra  s          evolving objects in temporal information
systems  ann  of mathematics and artificial intelligence          
baader  f     narendran  p          unification of concepts terms in description logics  j 
of symbolic computation                 
baader  f   calvanese  d   mcguinness  d   nardi  d     patel schneider  p  f   eds   
        the description logic handbook  theory  implementation and applications 
cambridge university press    nd edition        
beeri  c   levy  a  y     rousset  m  c          rewriting queries using views in description
logics  in proc  of the   th acm sigact sigmod sigart symp  on principles
of database systems  pods     pp        
berardi  d   calvanese  d     de giacomo  g          reasoning on uml class diagrams 
artificial intelligence                  
bergamaschi  s     sartori  c          on taxonomic reasoning in conceptual design  acm
trans  on database systems                 
boppana  r     sipser  m          the complexity of finite functions  in van leeuwen  j 
 ed    handbook of theoretical computer science  volume a  algorithms and complexity  pp          elsevier and mit press 
borger  e   gradel  e     gurevich  y          the classical decision problem  perspectives
in mathematical logic  springer 
borgida  a     brachman  r  j          conceptual modeling with description logics  in
baader et al   baader et al          chap      pp         

  

fiartale  calvanese  kontchakov   zakharyaschev

calvanese  d   de giacomo  g   lembo  d   lenzerini  m   poggi  a     rosati  r         
ontology based database access  in proc  of the   th ital  conf  on database systems
 sebd        pp         
calvanese  d   de giacomo  g   lembo  d   lenzerini  m   poggi  a   rosati  r     ruzzi  m 
        data integration through dl lite a ontologies  in schewe  k  d     thalheim 
b   eds    revised selected papers of the  rd int  workshop on semantics in data and
knowledge bases  sdkb        vol       of lecture notes in computer science  pp 
      springer 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          dl lite 
tractable description logics for ontologies  in proc  of the   th nat  conf  on artificial
intelligence  aaai        pp         
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          data
complexity of query answering in description logics  in proc  of the   th int  conf  on
the principles of knowledge representation and reasoning  kr        pp         
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r       a   can owl
model football leagues   in proc  of the  rd int  workshop on owl  experiences and
directions  owled        vol      of ceur workshop proceedings 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r       b   tractable
reasoning and efficient query answering in description logics  the dl lite family  j 
of automated reasoning                 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r       a   inconsistency tolerance in p p data integration  an epistemic logic approach  information
systems                 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r       b   path based
identification constraints in description logics  in proc  of the   th int  conf  on the
principles of knowledge representation and reasoning  kr        pp         
calvanese  d   de giacomo  g     lenzerini  m       a   description logics for information
integration  in kakas  a     sadri  f   eds    computational logic  logic programming and beyond  essays in honour of robert a  kowalski  vol       of lecture notes
in computer science  pp        springer 
calvanese  d   de giacomo  g     lenzerini  m       b   a framework for ontology integration  in cruz  i   decker  s   euzenat  j     mcguinness  d   eds    the emerging
semantic web  selected papers from the first semantic web working symposium 
pp          ios press 
calvanese  d   de giacomo  g   lenzerini  m   nardi  d     rosati  r       a   description
logic framework for information integration  in proc  of the  th int  conf  on the
principles of knowledge representation and reasoning  kr     pp      
calvanese  d   lenzerini  m     nardi  d       b   description logics for conceptual data
modeling  in chomicki  j     saake  g   eds    logics for databases and information
systems  pp          kluwer academic publishers 
calvanese  d   lenzerini  m     nardi  d          unifying class based representation formalisms  j  of artificial intelligence research             
  

fithe dl lite family and relations

corona  c   ruzzi  m     savo  d  f          filling the gap between owl   ql and
quonto  rowlkit  in proc  of the   nd int  workshop on description logics
 dl        vol      of ceur workshop proceedings 
cuenca grau  b   horrocks  i   kazakov  y     sattler  u          modular reuse of ontologies  theory and practice  j  of artificial intelligence research             
decker  s   erdmann  m   fensel  d     studer  r          ontobroker  ontology based
access to distributed and semi structured information  in meersman  r   tari  z  
  stevens  s   eds    database semantic  semantic issues in multimedia systems 
chap      pp          kluwer academic publishers 
dolby  j   fokoue  a   kalyanpur  a   ma  l   schonberg  e   srinivas  k     sun  x         
scalable grounded conjunctive query evaluation over large and expressive knowledge
bases  in proc  of the  th int  semantic web conf   iswc        vol       of lecture
notes in computer science  pp          springer 
eiter  t   gottlob  g   ortiz  m     simkus  m          query answering in the description logic horn shiq  in proc  of the   th eur  conference on logics in artificial
intelligence  jelia        pp         
franconi  e     ng  g          the i com tool for intelligent conceptual modeling  in proc  of
the  th int  workshop on knowledge representation meets databases  krdb       
vol     of ceur workshop proceedings  pp       
garey  m     johnson  d          computers and intractability  a guide to the theory of
np completeness  w  h  freeman 
ghilardi  s   lutz  c     wolter  f          did i damage my ontology  a case for conservative extensions in description logics  in doherty  p   mylopoulos  j     welty 
c   eds    proc  of the   th int  conf  on the principles of knowledge representation
and reasoning  kr        pp         
glimm  b   horrocks  i   lutz  c     sattler  u          conjunctive query answering for the
description logic shiq  in proc  of the   th int  joint conf  on artificial intelligence
 ijcai        pp         
goasdoue  f   lattes  v     rousset  m  c          the use of carin language and
algorithms for information integration  the picsel system  int  j  of cooperative
information systems                
gottlob  g     nash  a          efficient core computation in data exchange  j  of the
acm              
hayes  p          rdf semantics  w c recommendation  http   www w  org tr 
rdf mt  
heflin  j     hendler  j          a portrait of the semantic web in action  ieee intelligent
systems               
heymans  s   ma  l   anicic  d   ma  z   steinmetz  n   pan  y   mei  j   fokoue  a  
kalyanpur  a   kershenbaum  a   schonberg  e   srinivas  k   feier  c   hench  g  
wetzstein  b     keller  u          ontology reasoning with large data repositories 
in hepp  m   de leenheer  p   de moor  a     sure  y   eds    ontology management 
  

fiartale  calvanese  kontchakov   zakharyaschev

semantic web  semantic web services  and business applications  vol    of semantic
web and beyond computing for human experience  pp         springer 
horrocks  i   patel schneider  p  f     van harmelen  f          from shiq and rdf to
owl  the making of a web ontology language  j  of web semantics             
horrocks  i   sattler  u     tobies  s          practical reasoning for very expressive description logics  j  of the interest group in pure and applied logic                
hustadt  u   motik  b     sattler  u          reasoning in description logics by a reduction
to disjunctive datalog  j  of automated reasoning                 
hustadt  u   motik  b     sattler  u          data complexity of reasoning in very expressive
description logics  in proc  of the   th int  joint conf  on artificial intelligence
 ijcai        pp         
immerman  n          descriptive complexity  springer 
klyne  g     carroll  j  j          resource description framework  rdf   concepts and
abstract syntax  w c recommendation  http   www w  org tr rdf concepts  
kontchakov  r   pulina  l   sattler  u   schneider  t   selmer  p   wolter  f     zakharyaschev  m          minimal module extraction from dl lite ontologies using
qbf solvers  in proc  of the   st int  joint conf  on artificial intelligence  ijcai        pp         
kontchakov  r   wolter  f     zakharyaschev  m          can you tell the difference
between dl lite ontologies   in proc  of the   th int  conf  on the principles of
knowledge representation and reasoning  kr        pp         
kontchakov  r     zakharyaschev  m          dl lite and role inclusions  in domingue  j  
  anutariya  c   eds    proc  of the  rd asian semantic web conf   aswc       
vol       of lecture notes in computer science  pp        springer 
kozen  d          theory of computation  springer 
lenzerini  m          data integration  a theoretical perspective  in proc  of the   st acm
sigact sigmod sigart symp  on principles of database systems  pods       
pp         
levy  a  y     rousset  m  c          combining horn rules and description logics in
carin  artificial intelligence                   
lutz  c   toman  d     wolter  f          conjunctive query answering in el using a
database system  in proc  of the  th int  workshop on owl  experiences and directions  owled       
mcguinness  d     wright  j  r          conceptual modelling for configuration  a description logic based approach  artificial intelligence for engineering design  analysis  and
manufacturing  special issue on configuration             
meyer  t   lee  k     booth  r          knowledge integration for description logics  in
proc  of the   th nat  conf  on artificial intelligence  aaai        pp         
noy  n  f          semantic integration  a survey of ontology based approaches  sigmod
record               
  

fithe dl lite family and relations

ortiz  m   calvanese  d     eiter  t          characterizing data complexity for conjunctive
query answering in expressive description logics  in proc  of the   st nat  conf  on
artificial intelligence  aaai        pp         
ortiz  m   calvanese  d     eiter  t          data complexity of query answering in expressive description logics via tableaux  j  of automated reasoning               
papadimitriou  c          computational complexity  addison wesley 
perez urbina  h   motik  b     horrocks  i          a comparison of query rewriting
techniques for dl lite  in proc  of the   nd int  workshop on description logics
 dl        vol      of ceur workshop proceedings 
poggi  a   lembo  d   calvanese  d   de giacomo  g   lenzerini  m     rosati  r       a  
linking data to ontologies  j  on data semantics  x         
poggi  a   rodriguez  m     ruzzi  m       b   ontology based database access with
dig mastro and the obda plugin for protege  in clark  k     patel schneider 
p  f   eds    proc  of the  th int  workshop on owl  experiences and directions
 owled      dc  
rautenberg  w          a concise introduction to mathematical logic  springer 
reingold  o          undirected connectivity in log space  j  of the acm         
schaerf  a          on the complexity of the instance checking problem in concept languages
with existential quantification  j  of intelligent information systems            
schmidt schau  m     smolka  g          attributive concept descriptions with complements  artificial intelligence              
stocker  m     smith  m          owlgres  a scalable owl reasoner  in proc  of the  th
int  workshop on owl  experiences and directions  owled       
tobies  s          complexity results and practical algorithms for logics in knowledge representation  ph d  thesis  lufg theoretical computer science  rwth aachen  germany 
toman  d     weddell  g  e          on the interaction between inverse features and pathfunctional dependencies in description logics  in proc  of the   th int  joint conf  on
artificial intelligence  ijcai        pp         
toman  d     weddell  g  e          on keys and functional dependencies as first class
citizens in description logics  j  of automated reasoning                  
vardi  m          the complexity of relational query languages  extended abstract   in
proc  of the   th acm sigact symp  on theory of computing  stoc     pp 
       
vollmer  h          introduction to circuit complexity  a uniform approach  springer 
wang  z   wang  k   topor  r  w     pan  j  z          forgetting concepts in dl lite 
in bechhofer  s   hauswirth  m   hoffmann  j     koubarakis  m   eds    proc  of the
 th eur  semantic web conf   eswc        vol       of lecture notes in computer
science  pp          springer 

  

fi