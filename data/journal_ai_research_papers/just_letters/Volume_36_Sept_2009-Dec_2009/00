journal artificial intelligence research              

submitted        published      

dl lite family relations
alessandro artale
diego calvanese

artale inf unibz it
calvanese inf unibz it

krdb research centre
free university bozen bolzano
piazza domenicani    i       bolzano  italy

roman kontchakov
michael zakharyaschev

roman dcs bbk ac uk
michael dcs bbk ac uk

department computer science information systems
birkbeck college
malet street  london wc e  hx  u k 

abstract
recently introduced series description logics common moniker dllite attracted attention description logic semantic web communities due
low computational complexity inference  one hand  ability represent
conceptual modeling formalisms  other  main aim article carry
thorough systematic investigation inference extensions original dl lite
logics along five axes   i  adding boolean connectives  ii  number restrictions
concept constructs   iii  allowing role hierarchies   iv  allowing role disjointness  symmetry 
asymmetry  reflexivity  irreflexivity transitivity constraints   v  adopting dropping unique name assumption  analyze combined complexity satisfiability
resulting logics  well data complexity instance checking answering
positive existential queries  approach based embedding dl lite logics suitable fragments one variable first order logic  provides useful insights
properties and  particular  computational behavior 

   introduction
description logic  cf  baader  calvanese  mcguinness  nardi    patel schneider      
references therein  family knowledge representation formalisms developed
past three decades and  recent years  widely used various application areas as 
conceptual modeling  bergamaschi   sartori        calvanese et al       b       
mcguinness   wright        franconi   ng        borgida   brachman        berardi  calvanese    de giacomo        artale et al                   b  
information data integration  beeri  levy    rousset        levy   rousset 
      goasdoue  lattes    rousset        calvanese et al       a      a      b 
      noy        meyer  lee    booth        
ontology based data access  dolby et al         poggi et al       a  heymans et al  
      
semantic web  heflin   hendler        horrocks  patel schneider    van harmelen        
c
    
ai access foundation  rights reserved 

fiartale  calvanese  kontchakov   zakharyaschev

description logics  dls  short  underlie standard web ontology language owl  
process standardized w c second edition  owl   
widespread use dls flexible modeling languages stems fact that 
similarly traditional modeling formalisms  structure domain interest
classes  or concepts  dl parlance  objects common properties  properties
associated objects means binary relationships  or roles  objects 
constraints available standard dls resemble used conceptual modeling
formalisms structuring information  is a hierarchies  i e   inclusions  disjointness
concepts roles  domain range constraints roles  mandatory participation
roles  functionality general numeric restrictions roles  covering within concept
hierarchies  etc  dl knowledge base  kb   constraints combined form
tbox asserting intensional knowledge  abox collects extensional knowledge
individual objects  whether object instance concept  two objects
connected role  standard reasoning services dl kb include checking
consistency  or satisfiability   instance checking  whether certain individual instance
concept   logic entailment  whether certain constraint logically implied
kb   sophisticated services emerging support modular development
ontologies checking  example  whether one ontology conservative extension
another respect certain vocabulary  see  e g   ghilardi  lutz    wolter       
cuenca grau  horrocks  kazakov    sattler        kontchakov  wolter    zakharyaschev 
      kontchakov  pulina  sattler  schneider  selmer  wolter    zakharyaschev        
description logics recently used provide access large amounts data
high level conceptual interface  relevance data integration
ontology based data access  setting  tbox constitutes conceptual  high level
view information managed system  abox physically stored
relational database accessed using standard relational database technology  poggi
et al       a  calvanese et al          fundamental inference service case answering queries abox constraints tbox taken account  kind
queries often considered first order conjunctive queries 
correspond commonly used select project join sql queries  key properties
approach viable practice  i  efficiency query evaluation 
ideal target traditional database query processing   ii  query evaluation
done leveraging relational technology already used storing data 
objectives mind  series description logicsthe dl lite familyhas
recently proposed investigated calvanese  de giacomo  lembo  lenzerini 
rosati                  a   later extended artale  calvanese  kontchakov 
zakharyaschev      a   poggi  lembo  calvanese  de giacomo  lenzerini  rosati
     a   logics family meet requirements and  time 
capable representing many important types constraints used conceptual modeling 
particular  inference various dl lite logics done efficiently size
data  data complexity  overall size kb  combined complexity  
shown kb satisfiability logics polynomial combined complexity 
answering queries ac  data complexitywhich  roughly  means that  given
   http   www w  org      owl 

 

fithe dl lite family relations

conjunctive query kb  query tbox rewritten  independently
abox  union conjunctive queries abox alone   it emphasized
data complexity measure important application context dl lite
logics  since one reasonably assume size data largely dominates size
tbox   query rewriting techniques implemented various systems
quonto   acciarri  calvanese  de giacomo  lembo  lenzerini  palmieri    rosati       
poggi  rodriguez    ruzzi      b   rowlkit  corona  ruzzi    savo         owlgres
 stocker   smith        requiem  perez urbina  motik    horrocks        
demonstrated  kontchakov et al         developing  analyzing re using
dl lite ontologies  tboxes  supported efficient tools capable checking various
types entailment ontologies respect given vocabularies  particular 
minimal module extraction tools  kontchakov et al        which yet exist
richer languages 
significance dl lite family testified fact forms basis
owl   ql  one three profiles owl     owl   profiles fragments
full owl   language designed standardized specific application
requirements  according  the current version of  official w c profiles document 
purpose owl   ql language choice applications use large
amounts data query answering important reasoning task 
common denominator dl lite logics constructed far follows   i  quantification roles inverses qualified  in words  concepts
form r c must c       ii  tbox axioms concept inclusions cannot represent kind disjunctive information  say  two concepts cover whole
domain   dl lite related dialects designedwith aim capturing
conceptual modeling constraints  somewhat ad hoc mannerby extending
core language number constructs global functionality constraints 
role inclusions restricted boolean operators concepts  see section   details  
although attempts made  calvanese et al         artale et al       a 
kontchakov   zakharyaschev        put original dl lite logics general
perspective investigate extensions variety dl constructs required
conceptual modeling  resulting picture still remains rather fragmentary far
comprehensive  systematic investigation dl lite family relatives become
even urgent challenging view choice constructs included
specification owl   ql profile   in particular  owl make
unique name assumption  una  usually adopted dl lite  uses equalities
inequalities object names instead  
main aim article fill gap provide thorough comprehensive understanding interaction various dl lite constructs impact
computational complexity reasoning  achieve goal  consider spectrum
logics  classified according five mutually orthogonal features 
    presence absence role inclusions 
   http   www dis uniroma  it quonto 
   http   www w  org tr owl  profiles 
   http   www w  org tr owl  profiles  owl   ql

 

fiartale  calvanese  kontchakov   zakharyaschev

    form allowed concept inclusions  consider four classes  called core 
krom  horn  bool  exhibit different computational properties 
    form allowed numeric constraints  ranging none  global functionality
constraints only  arbitrary number restrictions 
    presence absence unique name assumption  and equalities inequalities object names  assumption dropped  
    presence absence standard role constraints disjointness  symmetry 
asymmetry  reflexivity  irreflexivity  transitivity 
resulting cases  investigate combined data complexity kb satisfiability instance checking  well data complexity query answering 
obtained tight complexity results summarized section      table   remark      
already mentioned  original motivation distinguishing feature logics
dl lite family lite ness sense low computational complexity
reasoning tasks  query answering ac  data complexity tractable kb satisfiability
combined complexity   broader perspective take here  logics
meet requirement  particular  krom bool concept inclusions   however 
identify another distinguishing feature regarded natural logic based
characterization dl lite family  embeddability one variable fragment firstorder logic without equality function symbols  allows us relate complexity
dl lite logics complexity corresponding fragments first order logic  thus
obtain deep insight underlying logical properties dl lite variant 
example  upper complexity bounds established follow embedding
well known results classical decision problem  see  e g   borger  gradel    gurevich 
      descriptive complexity  see  e g   immerman        
one interesting findings article number restrictions  even
expressed locally  instead global role functionality  added original dl lite
logics  under una without role inclusions  free  is  without changing
computational complexity  first order approach shows cases
extend dl lite logics role constraints mentioned above  keeping
complexity  gives framework analyze effect adopting dropping
una using  in equalities object names  example  observe
equality allowed language dl lite  which makes sense without una 
query answering becomes logspace complete data complexity  therefore
first order rewritable  turns dropping una results p hardness
reasoning  for combined data complexity  presence functionality constraints  nlogspace hardness shown calvanese et al          np hardness
arbitrary number restrictions allowed 
another interesting finding dramatic impact role inclusions  combined
number restrictions  or even functionality constraints   computational complexity reasoning  already observed calvanese et al          combination increases data complexity instance checking membership logspace
   note  way  logics bool concept inclusions turn quite useful conceptual
modeling reasonably manageable computationally  kontchakov et al         

 

fithe dl lite family relations

nlogspace hardness  show situation actually even worse  data
complexity  instance checking turns p complete case core horn
logics conp complete case krom bool logics  moreover  kb satisfiability 
nlogspace complete combined complexity simplest core casei e   efficiently tractable  role inclusions number restrictions used separatelybecomes
exptime completei e   provably intractable  used together 
retain role inclusions functionality constraints language keep
complexity within required limits  poggi et al       a  introduced another dl lite
dialect  called dl litea   restricts interaction role inclusions functionality constraints  extend result showing dl lite logics
limited interaction role inclusions number restrictions still embedded one variable fragment first order logic  exhibit behavior
fragments role inclusions number restrictions 
article structured following way  section    introduce logics
extended dl lite family illustrate features conceptual modeling formalisms 
section    discuss reasoning services complexity measures analyzed
follows  give overview obtained complexity results  section   
place introduced dl lite logics context original dl lite family 
discuss relationship owl    section    study combined complexity
kb satisfiability instance checking  section    consider data complexity
problems  section    study data complexity query answering 
section    analyze impact dropping una adding  in equalities
object names complexity reasoning  section   concludes article 

   extended dl lite family description logics
description logic  baader et al         family logics studied
used knowledge representation reasoning since     s  dls  elements
domain interest structured concepts  unary predicates   properties
specified means roles  binary predicates   complex concept role expressions
 or simply concepts roles  constructed  starting set concept role
names  applying suitable constructs  set available constructs depends
specific description logic  concepts roles used knowledge base
assert knowledge  intensional level  so called tbox  t terminological  
extensional level  so called abox  a assertional   tbox typically
consists set axioms stating inclusion concepts roles  abox  one
assert membership objects  i e   constants  concepts  pair objects
connected role  dls supported reasoning services  satisfiability checking
query answering  rely logic based semantics 
    syntax semantics logics dl lite family
introduce  extended  dl lite family description logics  initially
proposed aim capturing typical conceptual modeling formalisms  uml
class diagrams er models  see section     details   maintaining good computational properties standard dl reasoning tasks  calvanese et al          begin
 

fiartale  calvanese  kontchakov   zakharyaschev

defining logic dl litehn
bool   regarded supremum original
dl lite family  calvanese et al                   b  lattice description logics 
hn
dl litehn
bool   language dl litebool contains object names a    a            concept names
a    a            role names p    p            complex roles r concepts c language
defined follows 

pk  

r

   

pk

 

b

   



 

ak

 

q r 

c

   

b

 

c

 

c  u c   

q positive integer  concepts form b called basic 
dl litehn
bool tbox    finite set concept role inclusion axioms  or simply
concept role inclusions  form 
c  v c 



r  v r   

abox  a  finite set assertions form 
ak  ai   

ak  ai   

pk  ai   aj  



pk  ai   aj   

taken together  constitute dl litehn
bool knowledge base k    t   a  
following  denote role k  set role names occurring a  role  k 
set  pk   pk   pk role k    ob a  set object names a  role r 
set 
 
pk   r   pk  
inv r   
pk   r   pk  
usual description logic  interpretation     i      consists nonempty
domain interpretation function assigns object name ai element
aii   concept name ak subset aik domain  role name
pk binary relation pki domain  unless otherwise stated  adopt
unique name assumption  una  
aii    aij



   j 

 una 

however  shall always indicate results depend una
not  depend assumption  discuss consequences
dropping  see sections      
role concept constructs interpreted standard way 
 pk  i     y  x     x  y  pki   






  q r 

   


  x     y    x  y  ri   q  

 c i     c  


 c  u c   

 

c i



 inverse role 
 the empty set 
 at least q r successors 
 not c 

c i  

 both c  c   

 

fithe dl lite family relations

 x denotes cardinality x  use standard abbreviations
c  c     c  u c    

     

r       r  

q r     q     r  

concepts form q r q r called number restrictions  form
r called existential concepts 
satisfaction relation    standard 
   c  v c 

iff

c i c i  

   r  v r 

iff

r i r i  

   ak  ai  

iff aii aik  

   pk  ai   aj  

iff

 aii   aij   pki  

   ak  ai  

iff aii
  aik  

   pk  ai   aj  

iff

 aii   aij  
  pki  

knowledge base k    t   a  said satisfiable  or consistent  interpretation  i  satisfying members a  case write    k  as well
      a  say model k  and a  
languages dl lite family investigate article obtained restricting language dl litehn
bool along three axes   i  boolean operators  bool  
concepts   ii  number restrictions  n    iii  role inclusions  hierarchies  h  
similarly classical logic  adopt following definitions  dl litehn
bool tbox
called krom tbox   concept inclusions restricted to 
b  v b   

b  v b 



b  v b 

 krom 

 here bi b basic concepts   called horn tbox
concept inclusions restricted to 
l
bk v b
 horn 
k

 by definition  empty conjunction     finally  call core tbox
concept inclusions restricted to 
b  v b 



b  v b   

 core 

b  v b  equivalent b  u b  v   core tboxes regarded sitting
intersection krom horn tboxes 
remark     sometimes use conjunctions
right hand side concept includ
sions restricted languages  c v k bk   clearly  syntactic sugar add
extra expressive power 
hn
hn
hn
dl litehn
krom   dl litehorn dl litecore   fragments dl litebool krom 
hn
hn
horn  core tboxes denoted dl litekrom   dl litehorn dl litehn
core   respectively  fragments obtained limiting use number restrictions role
inclusions 

   krom fragment first order logic consists formulas prenex normal form whose quantifier free
part conjunction binary clauses 

 

fiartale  calvanese  kontchakov   zakharyaschev

hn
dl liteh
  fragment dl lite    core  krom  horn  bool   without number
restrictions q r  q     but role inclusions  denoted dl liteh
  note
h
that  dl lite   still use existential concepts r  that is    r  
hf
dl litehf
fragment dl litehn
number
  denote dl lite

restrictions q r  existential concepts  with q      q    
occur concept inclusions form   r v   inclusion called
global functionality constraint states role r functional  more precisely 
       r v    x  y  ri  x  z  ri     z  
f
dl liten
  dl lite dl lite   role inclusions excluded language 
 core  krom  horn  bool  obtain three fragments  dl liten
 with arbitrary number restrictions   dl litef
 with
functionality
constraints

existential
concepts

r   dl lite  without number restrictions different r  

shall see later article  logics form dl litehf
dl litehn

 
even   core  turn computationally rather costly interaction
role inclusions functionality constraints  or  generally  number restrictions   hand  purpose conceptual modeling one may need
constructs  cf  example section      compromise found artificially
limiting interplay role inclusions number restrictions way similar
logic dl litea proposed poggi et al       a  
tbox   let vt denote reflexive transitive closure relation


 r  r      inv r   inv r       r v r 
let r r  iff r vt r  r  vt r  say r  proper sub role r
r  vt r r 
  r 
 hn  

 hn  

dl lite   introduce logics dl lite  
 core  krom  horn  bool  
hn
which  one hand  restrict logics dl lite limiting interaction
role inclusions number restrictions order reduce complexity reasoning  and 
hand  include additional constructs  limited qualified existential quantifiers  role disjointness   a symmetry  ir reflexivity constraints  increase
expressive power logics affect computational properties 
 hn  
dl lite
tboxes must satisfy conditions  a    a    below   we remind
reader occurrence concept right hand  left hand  side concept
inclusion called negative scope odd  even  number negations  
otherwise occurrence called positive  
 a    may contain positive occurrences qualified number restrictions q r c 
c conjunction concepts allowed right hand side  concept
inclusions 
 a    q r c occurs   contain negative occurrences number
restrictions q   r q   inv r  q     
 a    r proper sub role   contain negative occurrences
q r q inv r  q   
 

fithe dl lite family relations

role
role
constraints inclusions






yes

disj 
 a sym 
 ir ref 
disj 
 a sym 
 ir ref 
tran 
a 

number
restrictions
r
r funct 
qr
r
r funct 
qr

concept inclusions
krom
horn
dl litekrom dl litehorn
dl litef
dl litef
krom
horn
n
dl litekrom dl liten
horn
h
dl liteh
dl lite
krom
horn
hf
dl litekrom dl litehf
horn
hn
dl litehn
dl lite
krom
horn

core
dl litecore
dl litef
core
dl liten
core
dl liteh
core
dl litehf
core
dl litehn
core

 hf  

bool
dl litebool
dl litef
bool
dl liten
bool
dl liteh
bool
dl litehf
bool
dl litehn
bool

 hf  

 hf  

 
r c funct a  dl lite hf
dl litekrom dl litehorn dl litebool
core
 hn  
 hn  
 hn  
 hn  
a 
q r c
dl litecore
dl litekrom dl litehorn dl litebool

yes

 

 
r c funct a  dl lite hf
core

yes

q r c a 

 hf   

dl litekrom

 

 hn   

 
dl lite hn
dl litekrom
core

 hf   

dl litehorn

 hn   

dl litehorn

 hf   

dl litebool

 hn   

dl litebool

restricted  a    a    

table    extended dl lite family 
 hn  

 it follows dl lite
tbox contain both  say  functionality constraint
  r v occurrence q r c  q    
 hn  
additionally  dl lite
tboxes contain role constraints  or axioms  form 
dis r    r    

asym pk   

sym pk   

irr pk   



ref pk   

meaning new constructs defined usual  interpretation    i     


  q r c i   x     y c    x  y  ri   q  
   dis r    r   
   asym pk  
   sym pk  
   irr pk  
   ref pk  

iff
iff

iff
iff
iff

r i r i    roles r  r  disjoint  
pki  pk  i    role pk asymmetric  

pki    pk  i

 pk symmetric  

 x  x 
  pki x
 x  x  pki x

 pk irreflexive  
 pk reflexive  

emphasized extra constructs often used conceptual modeling
 hn  
introduction dl lite
motivated owl   ql proposal   note
 hn  
dl lite
contains dl liteh

dl liten

proper fragments  
 hn   

 hn   

dl lite
 
 bool  horn  krom  core   denote dl lite
extension
 hn  
dl lite
role transitivity constraints form tra pk    meaning
expected 
   tra pk  

iff

 x  y  pki  y  z  pki imply  x  z  pki   x  y  z
 pk transitive  
 

fiartale  calvanese  kontchakov   zakharyaschev

dl litebool

dl litehn


 

 
dl litehorn






dl litekrom






 

 

dl litecore

pp


 
dl litehf

 
dl liteh


dl liten


 hn     
dl lite
dl lite hn


 
 
 

 
pp



 

dl litef


 





ip
p
dl lite

  
 hf   dl lite
dl lite hf



figure    language inclusions extended dl lite family 
remind reader standard restriction limiting use transitive roles dls
 see  e g   horrocks  sattler    tobies        
simple roles r allowed concepts form q r  q   
simple role given tbox understand role without transitive sub roles
 including itself   particular  contains tra p   p p simple 
cannot contain occurrences concepts form q p q p   q   
 hf  

 hf   

 hf  

dl lite
dl lite  
define languages dl lite
sub languages
 hn  
dl lite  
number restrictions form r  r c functionality
constraints   r v allowedprovided  course  satisfy  a    a    
 hf   
particular  r c allowed r functional  before  dl lite
extensions
 hf  
dl lite
role transitivity constraints  satisfying restriction above  
thus  extended dl lite family consider article consists    different
logics collected table    inclusions logics shown figure   
obtained taking product left  right hand parts picture 
subscript right hand part ranges  core  krom  horn  bool   i e  
subscripts left hand part  similarly  superscript left hand part
ranges     f  n   h  hf  hn    hf    hn     hf      hn       i e   superscripts
right hand part 
position logics relative dl lite logics known literature
owl   ql profile discussed section    starting section    begin
thorough investigation computational properties logics extended dllite family  without una  illustrate expressive
power dl lite logics concrete example 
    dl lite conceptual modeling
tight correspondence conceptual modeling formalisms  er model
uml class diagrams  various description logics pointed various
papers  e g   calvanese et al       b        borgida   brachman        berardi et al  
       give example showing dl lite logics used conceptual
modeling purposes  details see work artale et al       b  
  

fithe dl lite family relations

    

employee

    

empcode  integer
salary  integer

workson
boss
    
project

manager

projectname  string

    
    
 disjoint  complete 

areamanager

manages
topmanager

    

figure    uml class diagram 
let us consider uml class diagram depicted figure   representing  a portion
of  company information system  according diagram  managers employees partitioned area managers top managers  information
represented means following concept inclusions  where brackets specify
minimal dl lite language inclusion belongs to  
manager v employee

 dl litecore  

areamanager v manager

 dl litecore  

topmanager v manager

 dl litecore  

areamanager v topmanager

 dl litecore  

manager v areamanager topmanager

 dl litebool  

employee two functional attributes  empcode salary  integer values 
unlike owl  distinguish abstract objects data values  hence
model datatype  integer   means concept  attribute 
employees salary  means role  thus  salary represented follows 
employee v salary
salary



 dl litecore  

v integer

 dl litecore  
 dl litef
core  

  salary v

functional attribute empcode values integer represented way 
binary relationship workson employee domain project range 
workson v employee
workson



 dl litecore  

v project

 dl litecore  

binary relationship boss domain employee range manager treated analogously  employee works project exactly one boss  project must
  

fiartale  calvanese  kontchakov   zakharyaschev

involve least three employees 
employee v workson

 dl litecore  

employee v boss

 dl litecore  
 dl litef
core  

  boss v
project v   workson

 dl liten
core  

top manager manages exactly one project works project  project
managed exactly one top manager 
manages v topmanager
manages



v project

 dl litecore  

topmanager v manages
project v manages

 dl litecore  
 dl litecore  



 dl litecore  

  manages v

 dl litef
core  

  manages v

 dl litef
core  
 dl liteh
core  

manages v workson

all  languages extended dl lite family capable representing
 hn  
uml class diagram figure   dl litehn
bool dl litebool   note  however  except covering constraint  manager v areamanager topmanager   concept
inclusions dl lite translation uml class diagram belong variants
 hn  
core fragments dl litehn
core dl litecore   hard imagine situation
one needs horn concept inclusions represent integrity constraints uml class diagrams  example  express  together axioms  chief executive
officer may work five projects manager one them 
ceo u     workson  u manages v

 dl liten
horn  

context uml class diagrams  krom fragment dl litekrom  with variants 
seems useless  extends dl litecore concept inclusions form b  v b 
or  equivalently    v b  b    rarely used conceptual modeling  indeed 
would correspond partitioning whole domain interest two parts 
general useful covering constraints form b v b  bk require full
bool language  hand  krom fragments important pinpointing
borderlines various complexity classes description logics dl lite family
extensions  see table   

   reasoning dl lite logics
discuss reasoning problems consider article  mutual relationships  complexity measures adopt  provide overview complexity
results dl lite logics obtained article 

  

fithe dl lite family relations

    reasoning problems
concentrate three fundamental standard reasoning tasks description
logics  satisfiability  or consistency   instance checking  query answering 
dl l extended dl lite family  define l concept inclusion
concept inclusion allowed l  similarly  define notions l kb l tbox 
finally  define l concept concept occur right hand side
l concept inclusion conjunction concepts 
satisfiability  kb satisfiability problem check  given l kb k  whether
model k  clearly  satisfiability minimal requirement ontology 
well known dl  baader et al          many reasoning tasks description logics
reducible satisfiability problem  consider  example  subsumption problem 
given l tbox l concept inclusion c  v c    decide whether    c  v c   
is  c i c i   every model   reduce problem  un satisfiability  take
fresh concept name a  fresh object name a  set k    t     a  
     a v c    v c   

   a a   

easy
see    c  v c  iff k satisfiable  core  krom horn kbs 
c    k dk   dk  possibly negated  basic concept  checking unsatisfiability
k amounts checking unsatisfiability kbs kk    tk   a   tk  
 a v c    v dk    for horn kbs  replace v b equivalent u b v   
concept satisfiability problemgiven l tbox l concept c  decide
whether c    model easily reducible kb satisfiability  indeed 
take fresh concept name a  fresh object name a  set k    t     a  
     a v c 

   a a   

c satisfiable respect iff k satisfiable 
instance checking  instance checking problem decide  given object name a 
l concept c l kb k    t   a   whether k    c a   is  ai c   every
model k  instance checking reducible  un satisfiability  object
instance l concept c every model k    t   a  iff kb k     t     a    
     a v c 



a     a a   

notdsatisfiable  fresh concept name  core  krom horn kbs 
c   k dk   dk  possibly negated  basic concept  proceed
subsumption  checking unsatisfiability k  amounts checking unsatisfiability
kb kk     tk    a    tk     a v dk   
conversely  kb satisfiability reducible complement instance checking  k
satisfiable iff k     a a   fresh concept name fresh object a 
query answering  positive existential query q x            xn   first order formula
 x            xn   constructed means conjunction  disjunction existential quantification starting atoms ak  t  pk  t    t     ak concept name  pk
  

fiartale  calvanese  kontchakov   zakharyaschev

role name  t  t    t  terms taken list variables y    y          list
object names a    a           i e   positive existential formula   precisely 


   

yi

 



   

ak  t 

ai  
 

pk  t    t   

 

   

 

   

 

yi  

free variables called distinguished variables q bound ones nondistinguished variables q  write q x            xn   query distinguished variables
x            xn   conjunctive query positive existential query contains disjunction
 it constructed atoms means conjunction existential quantification only  
given query q  x      x   x   x            xn n tuple  a object names 
write q  a  result replacing every occurrence xi   x  ith member
 a  queries containing distinguished variables called ground  they known
boolean  
let    i     interpretation  assignment function associating
every variable element a y    use following notation  ai a
  aii

i a   a y   satisfaction relation positive existential formulas respect
given assignment defined inductively taking 
  a ak  t 

iff

ti a aik  

  a pk  t    t   

iff

i a

 ti a
    t    pk  

  a    

iff

  a     a    

  a    

iff

  a     a    

  a yi

iff

  b   assignment b may differ yi  

ground query q  a   satisfaction relation depend assignment a 
write    q  a  instead   a q  a   answer query either yes
no 
kb k    t   a   say tuple  a object names certain answer
q  x  respect k  write k    q  a      q  a  whenever    k  query
answering problem formulated follows  given l kb k    t   a   query q  x  
tuple  a object names a  decide whether k    q  a  
note instance checking problem special case query answering  object
instance l concept c respect kb k iff answer query a a 
respect k  yes  k     t     a       c v a   fresh
concept name  horn concepts b  u u bk   consider query a   a  ak  a 
respect k    k     t     a       b  v a            bk v ak   
ai fresh concept names  similarly  deal krom concepts d  u u dk  
di possibly negated basic concept  core concepts  reduction holds
conjunctions basic concepts 
    complexity measures  data combined complexity
computational complexity reasoning problems discussed analyzed
respect different complexity measures  depend parameters
  

fithe dl lite family relations

problem regarded input  i e   vary  regarded
fixed  satisfiability instance checking  parameters consider size
tbox size abox a  number symbols a 
denoted  t    a   respectively  size  k  knowledge k    t   a  simply given
 t      a   query answering  one parameter consider would size
query  however  analysis adopt standard database assumption size
queries always bounded reasonable constant and  case  negligible
respect size tbox size abox  thus count
query part input 
hence  consider reasoning problems two complexity measures  whole
kb k regarded input  deal combined complexity  if  however 
abox counted input  tbox  and query  regarded
fixed  concern data complexity  vardi         combined complexity interest
still designing testing ontology  hand  data complexity
preferable cases tbox fixed size  and size query 
negligible compared size abox  case  instance  context
ontology based data access  calvanese  de giacomo  lembo  lenzerini  poggi    rosati 
      data intensive applications  decker  erdmann  fensel    studer        noy 
      lenzerini        calvanese et al          since logics dl lite family
tailored deal large data sets stored relational databases  data complexity
instance checking query answering particular interest us 
    remarks complexity classes logspace ac 
paper  deal following complexity classes 
ac    logspace nlogspace p np exptime 
definitions found standard textbooks  e g   garey   johnson       
papadimitriou        vollmer        kozen         remind reader
two smallest classes logspace ac   
problem belongs logspace two tape turing machine that 
starting input length n written read only input tape  stops accepting rejecting state used log n cells  initially blank  read write work
tape  logspace transducer three tape turing machine that  started
input length n written read only input tape  writes result  of polynomial size 
write only output tape using log n cells  initially blank  read write
work tape  logspace reduction reduction computable logspace transducer 
composition two logspace transducers logspace transducer  kozen 
      lemma      
formal definition complexity class ac   see  e g   boppana   sipser       
vollmer       references therein  based circuit model  functions
represented directed acyclic graphs built unbounded fan in and 
gates  i e   gates may unbounded number incoming edges  
definition assume decision problems encoded alphabet       
regarded boolean functions  ac  class problems definable using
  

fiartale  calvanese  kontchakov   zakharyaschev

family circuits constant depth polynomial size  generated
deterministic turing machine logarithmic time  in size input   latter
condition called logtime uniformity  intuitively  ac  allows us use polynomially
many processors run time must constant  typical example ac  problem
evaluation first order queries databases  or model checking first order sentences
finite models   database  first order model  regarded input
query  first order sentence  assumed fixed  abiteboul  hull    vianu       
vollmer         hand  undirected graph reachability problem known
logspace  reingold        ac    boolean function f         n       
called ac   reducible  or constant depth reducible  function g         n       
 logtime uniform  family constant depth circuits built and  or 
g gates computes f   case say ac   reduction  note
reductions considered section     ac   reductions  unless otherwise indicated 
follows write reduction ac   reduction 
    summary complexity results
article  aim investigate  i  combined data complexity satisfiability instance checking problems  ii  data complexity query answering
problem logics extended dl lite family  without una 
 hf   
obtained known results first    logics table    the logics dl lite
 hn   
dl lite
included  summarized table    we remind reader
satisfiability instance checking reducible complements
instance checking special case query answering   fact  results
table follow lower upper bounds marked        respectively  by
taking account hierarchy languages dl lite family   example 
nlogspace membership satisfiability dl liten
krom theorem     implies
n
f
upper bound dl litekrom   dl litekrom   dl litecore   dl litef
core dl litecore
 
sub languages dl liten
krom
remark     two complexity results noted  they included
table    
 i  equality object names allowed language dl lite 
makes sense una dropped  ac  memberships table   replaced logspace completeness  see section    theorem           inequality
constraints affect complexity 
 ii  extend languages role transitivity constraints combined complexity satisfiability remains same  data complexity  instance
checking query answering become nlogspace hard  see lemma       i e  
membership ac  data complexity replaced nlogspace completeness 
complexity results remain same 
either case  property first order rewritabilitythat is  possibility rewriting
given query q given tbox single first order query q  returning certain
answers q  t   a  every abox a  ensures query answering problem
ac  data complexityis lost 
  

fithe dl lite family relations

complexity
languages

una

combined complexity
satisfiability

 h 
dl lite core
   h 
dl litehorn
   h 
dl litekrom
   h 
dl litebool
 n   hf    hn   
dl lite f
core
 f  n   hf    hn   
dl litehorn
 f  n   hf    hn   
dl litekrom
 f  n   hf    hn   
dl litebool
 f   hf   
dl litecore horn
 f   hf   
dl litekrom
 f   hf   
dl litebool
 n   hn   
dl litecore horn
 n   hn   
dl litekrom bool
dl litehf
core horn
dl litehf
krom bool
dl litehn
core horn
hn
dl litekrom bool

yes no

yes



yes no

data complexity
instance checking
 

query answering

nlogspace  a 

ac

ac 

p  th       a 

ac 

ac   c 

 

nlogspace  th     

ac

conp  b 

np  th       a 

ac   th     

conp

 

nlogspace

ac

ac 

p  th           

ac 

ac   th     

nlogspace  th          

ac 

conp

 

np  th           

ac  cor     

conp

p  cor       th     

p  th     

p

p  cor     

p

conp

np

p  cor     

conp

np  th     

conp  th     

conp

np  th     

conp

conp

exptime  th      

p  th     

p  d 

exptime

conp  th     

conp

exptime

conp  th     

conp

exptime  f 

conp

conp  e 

 a  complexity respective fragment propositional boolean logic
 b  follows proof data complexity result instance checking ale  schaerf       
 c   calvanese et al        
 d  follows horn shiq  hustadt  motik    sattler        eiter  gottlob  ortiz    simkus       
 e  follows shiq  ortiz  calvanese    eiter              glimm  horrocks  lutz    sattler       
 f  follows shiq  tobies       

table    complexity dl lite logics  all complexity bounds save ac  tight  

    n  
means dl lite            dl liten
dl lite 

 in particular  dl lite   h  either dl lite dl liteh
  

dl litecore horn means dl litecore dl litehorn  likewise dl litekrom bool   
 x     x   means upper  respectively  lower  bound follows  x  

detailed proofs results given sections     variants logics
involving number restrictions  upper bounds hold assumption
numbers q concepts form q r given binary   intuitively  follows
fact proofs use numbers explicitly occur kb  
lower bounds remain unary coding  since corresponding proofs
use numbers exceeding   
next section consider extended dl lite family general context
identifying place among dl lite related logics  particular owl   profiles 
  

fiartale  calvanese  kontchakov   zakharyaschev

   landscape dl lite logics
original family dl lite logics created two goals mind  identify
description logics that  one hand  capable representing basic features
conceptual modeling formalisms  such uml class diagrams er diagrams  and 
hand  computationally tractable  particular  matching ac  data
complexity database query answering 
saw section      represent uml class diagrams one need typical quantification constructs basic description logic alc  schmidt schau   smolka 
       namely  universal restriction r c qualified existential quantification r c  one
always take role filler c    indeed  domain range restrictions
relationship p expressed concepts inclusions p v b  p v b    respectively  thus  almost concept inclusions required capturing uml class diagrams
form b  v b  b  v b    observations motivated introduction
calvanese et al         first dl lite logic  new nomenclature corresponds
dl litef
core   main results polynomial time upper bound combined
complexity kb satisfiability logspace upper bound data complexity
conjunctive query answering  under una   results extended calvanese
h
et al         two larger languages  dl litef
horn dl litehorn   originally
called dl liteu f dl liteu r   respectively  calvanese et al       b  introduced another member dl lite family  named dl liter    extended dl liteh
core
role disjointness axioms form dis r    r     computational behavior new
logic turned dl liteh
core   may worth mentioning
dl liteh
covers

dl
fragment

rdfs
 klyne
  carroll        hayes         note
core
calvanese et al         considered variants dl liteu f dl liteu r
arbitrary n ary relations  not usual binary roles  showed query answering still logspace data complexity  conjecture similar results
obtained dl lite logics introduced paper  artale et al       b 
demonstrated n ary relations represented dl litef
core means reification 
variant dl lite  called dl litea  a attributes   introduced
poggi et al       a  aim capturing many features conceptual modeling
formalisms possible  still maintaining computational properties basic
variants dl lite  one features dl litea   borrowed conceptual modeling
formalisms adopted owl  distinction  abstract  objects data
values  consequently  concepts  sets objects  datatypes  sets data
values   roles  i e   object properties owl  relating objects objects 
attributes  i e   data properties owl  relating objects data values   however 
far results paper concerned  distinction concepts
datatypes  roles attributes impact reasoning whatsoever  since
datatypes simply treated special concepts mutually disjoint
disjoint proper concepts  instead  relevant reasoning possibility
express dl litea role inclusions functionality  i e   dl litea includes
f
hf
dl liteh
core dl litecore   dl litecore  
already mentioned  role inclusions functionality constraints cannot
combined unrestricted way without losing good computational properties 

  

fithe dl lite family relations

 
b
b

dl litehn
krom
b

b

b

   

shiq
dl litehn
horn
b

dl litehn
bool
b

   
b

dl litekrom
b

b

dl litehf
core
b

 hn  

b

b

b

p

b

dl litecore
 hf  
dl litecore

dl liten
core

 hn  

dl litehorn
 hf  
dl litehorn
dl liten
horn
 
dl litea u
b

b

b

b

b

dl litehf
horn

dl lite 

dl litea
dl litef   dl litef
dl litef  u   dl litef
core
horn
h
dl liter   dl litecore
dl liter u   dl liteh
horn
dl litecore
b

b

ac 

dl litebool

horn shiq

conp

 

b

dl litehn
core

b

b

b

figure    dl lite family relations 
theorems           prove satisfiability dl litehf
core kbs exptime hard
combined complexity  instance checking data hard p  nlogspace hardness
shown calvanese et al          dl litea   keep query answering ac 
data complexity satisfiability nlogspace combined complexity  functional roles
 and attributes  allowed specialized  i e   used positively right hand
side role  and attribute  inclusion axioms  so  condition  a    slight generalization
restriction  dl litea allows axioms form b v r c non functional
roles r  covered conditions  a     a     thus  dl litea regarded
 hf  
 hn  
proper fragment dl litecore dl litehorn   show sections      
three languages enjoy similar computational properties una 
tractable satisfiability query answering ac   
conclude section picture figure   illustrating landscape dllite related logics grouping according data complexity positive existential
query answering una  original eight dl lite logics  called calvanese
et al       b  dl lite family  shown bottom sector picture  the logics
 
dl lite 
dl litea u extend dl litea dl litea u identification constraints 
 hn  

scope article   nearest relatives logic dl litehorn
fragments  ac  well  next layer contains logics dl litehf
core
dl litehf
 


query
answering

data complete

p
 no
matter
whether

horn
una adopted not   fact  logics fragments much expressive dl
horn shiq  shown enjoy data complexity query answering
eiter et al          remains seen whether polynomial query answering practically
feasible  recent experiments dl el  lutz  toman    wolter        indicate
may indeed case  finally  distant relatives dl lite family comprise

  

fiartale  calvanese  kontchakov   zakharyaschev

upper layer picture  query answering data complete conp  is 
expressive dl shiq 
    dl lite family owl  
upcoming version   web ontology language owl  defines three profiles  
is  restricted versions language suit specific needs  dl lite family  notably
dl liteh
core  or original dl liter    basis one owl   profiles  called
owl   ql  according http   www w  org tr owl  profiles   owl   ql aimed
applications use large volumes instance data  query answering
important reasoning task  owl   ql           sound complete conjunctive query
answering performed logspace respect size data  assertions 
 and  polynomial time algorithms used implement ontology consistency
class expression subsumption reasoning problems  expressive power profile
necessarily quite limited  although include main features conceptual
models uml class diagrams er diagrams  section  briefly discuss
results obtained article context additional constructs present
owl   
important difference dl lite family owl status
unique name assumption  una   assumption quite common data management 
hence adopted dl lite family  adopted owl  instead  owl
syntax provides explicit means stating object names  say b  supposed
denote individual  b  interpreted differently    b  in
owl  constructs called sameas differentfrom  
complexity results obtain logics form dl liteh
depend
whether una adopted  because every model dl liteh
kb without una
untangled model kb respecting una  see lemma       
n
however  case logics dl litef
dl lite   obvious
interaction una number restrictions  cf  table     example 
 
una  instance checking dl litef
core ac data complexity  whereas dropping
assumption results much higher complexity  section    prove p complete 
h
addition equality construct dl liteh
core dl litehorn slightly changes
data complexity query answering instance checking  rises membership
ac  logspace completeness  see section    important  however 
case loose first order rewritability query answering instance checking 
result cannot use standard database query engines straightforward manner 
since owl   profiles defined syntactic restrictions language without
changing basic semantic assumptions  chosen include owl   ql
profile construct interferes una which  absence una 
would cause higher complexity  owl   ql include number restrictions  even functionality constraints  also  keys  the mechanism identifying objects
means values properties  supported  although impor   http   www w  org      owl 
   logic  profiles would called fragments defined placing restrictions owl  
syntax only 

  

fithe dl lite family relations

tant notion conceptual modeling  indeed  keys considered generalization
functionality constraints  toman   weddell              calvanese  de giacomo  lembo 
lenzerini    rosati      a      b   since asserting unary key  i e   one involving
single role r  equivalent asserting functionality inverse r  hence 
absence una  allowing keys would change computational properties 
already mentioned  standard owl constructs  role disjointness   a symmetry  ir reflexivity constraints  added dl lite logics
without changing computational behavior  role transitivity constraints  tra r   as hn  
serting r must interpreted transitive role  added dl litehorn
leads increase data complexity reasoning problems nlogspace 
although satisfiability remains p combined complexity  results found
section     
constructs owl   far supported dl lite logics
mention nominals  i e   singleton concepts   boolean operators roles  role chains 

   satisfiability  combined complexity
dl litehn
bool clearly sub logic description logic shiq  satisfiability problem
known exptime complete  tobies        
section     show  however  satisfiability problem dl liten
bool kbs
 
reducible satisfiability problem one variable fragment  ql   first order logic
without equality function symbols  satisfiability ql   formulas np complete
 see  e g   borger et al         logics consideration contain full booleans
concepts  satisfiability dl liten
bool kbs np complete well  shall see
translations horn krom kbs ql  belong horn krom fragments
ql    respectively  known p  nlogspace complete  see  e g   papadimitriou        borger et al          section      show simulate behavior
polynomial space bounded alternating turing machines means dl litehf
core kbs 
give  optimal  exptime lower bound satisfiability kbs languages
family containing unrestricted occurrences functionality constraints role
inclusions  section      extend embedding ql    defined section     
 hn  
logic dl litebool   thereby establishing upper bounds dl liten
bool
fragments  finally  section     investigate impact role transitivity constraints 
    dl liten
bool fragments  first order perspective
aim section construct reduction satisfiability problem dl liten
bool
kbs satisfiability ql   formulas  two steps  first present lengthy
yet quite natural transparent  yet exponential  reduction   shall see
proof reduction substantially optimized linear reduction  

let k    t   a  dl liten
bool kb  recall role  k  denotes set direct
inverse role names occurring k ob a  set object names occurring a 
r role  k   let qr
set natural numbers containing   numbers q
concept q r occurs  recall abox contain number
restrictions   note  qr
    contains functionality constraint r 

  

fiartale  calvanese  kontchakov   zakharyaschev

every object name ai ob a  associate individual constant ai ql 
every concept name ai unary predicate ai  x  signature ql   
role r role  k   introduce  qr
  many fresh unary predicates
q qr
t 

eq r x  

intended meaning predicates follows  role name pk  
eq pk  x  eq pk  x  represent sets points least q distinct pk  successors
least q distinct pk  predecessors  respectively  particular  e  pk  x 
e  pk  x  represent domain range pk   respectively 
additionally  every pair roles pk   pk role  k   take two fresh individual constants
dpk

dp
k
ql    serve representatives points domains pk

pk   respectively  provided empty   let dr k    dr   r role  k   
furthermore  pair object names ai   aj ob a  r role  k   take
fresh propositional variable rai aj ql  encode abox assertion r ai   aj    
 
induction construction dl liten
bool concept c define ql  formula
c  
   

 ai     ai  x  

  q r    eq r x  

 c    c  x  

 c  u c      c   x  c   x  

 

dl liten
bool tbox corresponds ql  sentence x  x  
 

 x   
c   x  c   x   

   

c  vc 

abox translated following pair ql   sentences
 
 
 
 
ak  ai  
ak  ai   


 

 

 

   

ak  ai  a

ak  ai  a

pk ai aj



 

pk ai aj  

   

pk  ai  aj  a

pk  ai  aj  a

every role r role  k   need two ql   formulas 
r  x    e  r x  inv e  r  inv dr   
 

r  x   
eq  r x  eq r x   

   
   

 
q q   qr
  q  q
 
  
q  q  q q    qr


   follows  slightly abuse notation write r ai   aj   indicate pk  ai   aj  
r   pk   pk  aj   ai   r   pk  

  

fithe dl lite family relations

 by overloading inv operator  
 
eq pk   r   pk  
inv eq r   
eq pk   r   pk  



 
dp
k 
inv dr   
dpk  

r   pk  
r   pk  

formula     says domain r empty range empty either 
contains constant inv dr   representative domain inv r  
need formulas representing relationship propositional variables rai aj
unary predicates role domain range  role r role  k   let r
following ql   sentence
 

 

 

q
 


rai ajk eq r ai  

ai ob a  qqr
aj       ajq ob a  k  

jk   jk  k  k 



 


rai aj inv r aj ai      

ai  aj ob a 

inv r aj ai propositional variable pk aj ai r   pk pk aj ai r   pk  
note first conjunct     part translation relies una 
finally  dl liten
bool knowledge base k    t   a   set

h  
h
 
 

 



r  
k   x  x 
r  x  r  x 
rrole  k 

rrole  k 

thus  k universal sentence ql   
example     consider  example  kb k    t   a 


  v p   p v a  v   p    v   p   p v
   a a   p  a  a      obtain following first order translation 
k   x  x  a a  p aa 


p aa  e  p  a  p aa e  p  a 


p a  e  p  a    p a  a  e  p  a   


p aa  e  p  a  p aa e  p  a 


p a  e  p  a    p a  a  e  p  a   


p aa  p aa e  p  a  p a  p a  a  e  p  a   


p aa  p aa e  p  a  p a  p a  a  e  p  a   




p aa  p a  p a  p aa  p aa p aa p a  a  p a  a   

 x   

a x  e  p  x 



e  p  x  a x  a x  e  p  x 


  e  p  x  e  p  x  a x 


e  p  x  e  p  dp   e  p  x  e  p  dp 


e  p  x  e  p  x  e  p  x  e  p  x       




  

fiartale  calvanese  kontchakov   zakharyaschev

 
theorem     dl liten
bool knowledge base k    t   a  satisfiable iff ql  sentence

k satisfiable 

proof    k satisfiable model k whose domain consists
constants occurring k i e   ob a  dr k   say  herbrand model k   
denote domain interpretations  unary  predicates p   propositional
variables p constants ql  p   pm   respectively  thus  every
constant a    a  let d  set constants a  ob a   without loss
generality may assume d      

construct interpretation dl liten
bool based domain d 
inductively defined union

 

 



wm  

w    d   

m  

interpretations object names ai given interpretations m 
namely  aii  
w    set wm        constructed adding wm
new elements fresh copies certain elements   d    new element
w  copy w   d  write cp w      w  w d  let cp w    w 
set wm   wm       denoted vm  for convenience  let w     
v    d    
interpretations aik concept names ak defined taking


aik   w      ak  cp w    
   
interpretation pki role name pk defined inductively union
pki

 


 

pkm  



pkm wm wm  

m  

along construction   first  role r role  k   define required
r rank r r  d  point taking

r r  d    max       q qr
     eq r d     
follows     r r  d    q then  every q   qr
     eq   r d 
whenever q   q     eq  r d  whenever q   q     define actual r rank
rm  r  w  point w step taking
 
  w  wm    w  w    pkm    r   pk  
rm  r  w   
  w  wm    w    w  pkm    r   pk  
basis induction set  role name pk role k  



pk     am
  aj   w  w       pk ai aj  

   

observe that       r role  k  w w   
r   r  w  r r  cp w   
  

    

fithe dl lite family relations

suppose wm pkm      already defined 
rm  r  w    r r  cp w    roles r role  k  points w wm   interpretation need would constructed  however  general case
may defects sense actual rank points smaller
required rank 
role name pk role k   consider following two sets defects pkm  



w vm   rm  pk   w    r pk   cp w    
k  



  w vm   rm  pk   w    r pk   cp w    
k
purpose of  say 
k identify defective points w vm precisely
r pk   cp w   distinct pk  arrows start  according m   arrows still
missing  only rm  pk   w  many arrows exist   cure defects  extend wm
pkm respectively wm   pkm   according following rules 

 m
k   let w k   q   r pk   cp w   rm  pk   w    cp w      eq   pk  d 
 
q   qr
q q      then          e  pk  d  and      


   e  pk  dpk    case take q fresh copies w             wq  dp
k  and set

 
 
cp wi     dpk     q   add wm   add pairs  w  wi      q 
pkm    




 m
k   let w k   q   r pk   cp w   rm  pk   w    cp w      eq   pk  d 

 
q   qr
q q      so          e  pk  d  and      
 
 
   e  pk  dpk    take q fresh copies w            wq dpk  and set cp wi      dpk  
  q   add wm   add pairs  wi    w     q  pkm    

example     consider kb k first order translation k example     
consider model k domain    a  a    dp  dp   
   e  p  m    e  p  m    e  p  m   d 

 e  p  m    
 p aa   m    p a  a m   t 

begin construction interpretation k setting w    v    d     a  a   
p       a  a      compute required actual ranks r r  w  r   r  w  
r  p  p   w v   
 i  r p  a      r   p  a      
 iii  r p   a      r   p   a      

 ii  r p  a        r   p  a        
 iv  r p   a        r   p   a        

next step  draw p  arrow fresh copy dp cure defect  i   draw
two p  arrows a  two fresh copies dp order cure defects  ii   finally
take fresh copy dp connect p  arrow  thereby curing defect  iii  
one step unraveling construction shown figure   
observe following important property construction  m  m     w vm 
r role  k  


  m   
  
rm  r  w   
    
q 
  m    q r r  cp w   


r r  cp w      m   
  

fiartale  calvanese  kontchakov   zakharyaschev

 

v 

a 
v 



v 

dp

dp

 
figure    unraveling model  first three steps  
prove property  consider possible cases 
  m  point w added wm yet  i e   w
  wm  
rm  r  w      
  m  m      rm  r  w  r r  cp w   follows      
  m  m      w added step m  cure defect point
w  wm      means pk role k  either  w    w  pkm 
 m   
   
w 
 w  w    pkm  w  k  
  consider former case 
k
 
since
fresh
witnesses

picked
every time rule  km     
cp w    dp
k

applied  rm   pk   w       rm   pk   w      rm   r  w       every r    pk   pk  
 
suffices show r pk   dp
k      indeed     eq pk  cp w   

r
 
q qt   have          e  pk  cp w     so          e  pk  dp
k   
 

  

latter
case

considered
analogously 
definition r  r pk   dp
k
  m      then  role name pk   defects w cured step m     
m 
 
applying rules  m
   therefore  rm      r  w    r r  cp w   
k    k
  m           follows observation new arrows involving w
added step m       is    role name pk role k  
pkm     pkm



vm vm  



vm   vm  

    


follows that  r role  k   q qr
w   have 

   eq r cp w  

iff

w   q r i  

    

indeed     eq r cp w   then  definition  r r  cp w   q  let w vm    then 
      rm  r  w    r r  cp w   q    m    follows definition
  

fithe dl lite family relations

rm  r  w  ri w   q r i   conversely  let w   q r i w vm    then 
      q rm  r  w    r r  cp w      m    so  definition r r  cp w  
        eq r cp w   
induction construction concepts c k one readily see that  every
w  
   c  cp w  
iff
w ci  
    
indeed  basis trivial b   follows     b   ak     
b   q r  induction step booleans  c   c  c   c  u c   
immediately follows induction hypothesis 
finally  show a 
  

iff

    

case   c  v c  follows         ak  ai     ak  ai  
definition aik     pk  ai   aj     pk  ai   aj     aii   aij   pki iff       
 aii   aij   pk  iff          pk ai aj  
thus  established    k 
   conversely  suppose    k interpretation domain   construct

model k based   every ai ob a   let
  ai and 
every r role  k   take     r i     r i    arbitrary element

otherwise  let drm   d  next  every concept name ak   let
k   ak

    q r i   finally  every
and  every role r role  k  q qr
  set eq r

role r role  k  every pair objects ai   aj ob a   define  rai aj  m true
iff    r ai   aj    one readily check    k   details left reader 
q
first order translation k k obviously lengthy provide us reasonably
low complexity results   k    k         qt     role k        role k    ob a  qt   however 
follows proof lot information translation redundant
safely omitted 
define concise translation k k    t   a  ql  taking 
h
 

 
 
k   x  x 
r  x  r  x 

 
rrole  k 
 

 x   r  x   r  x  defined means                   
respectively 
 
 
 
 
 
eqr a r a 
 pk  ai   aj     
    
aob a 

rrole  k 
a  ob a  r a a   a

pk  ai  aj  a

qr a maximum number qr
qr a many distinct ai
r a  ai    here use una   pk  ai   aj      pk  ai   aj    
 
otherwise  size size k linear size k 
respectively  matter whether numbers coded unary binary 
  

fiartale  calvanese  kontchakov   zakharyaschev

importantly  translation actually done logspace  indeed 
 
 
trivially case  x   r  x   r  x   last conjunct  
 
first conjunct then  r role  k  ob a   maximum qr a
qr
qr a many distinct ai r a  ai   a  computed using
log min max qr
   ob a      log  ob a   cells  initially set q      enumerate
object names ai incrementing current q time find r a  ai   a  stop
q   max qr
reach end object name list  resulting qr a maximum
number qr
exceeding q 
example     translation k kb k example     looks follows 
k   x  x  a a  e  p  a  e  p  a    
 x  defined     
 

corollary     dl liten
bool kb k satisfiable iff ql  sentence k satisfiable 

proof claim follows fact k satisfiable iff k satisfiable  indeed 
   k clearly    k   conversely     k one construct new model
m  based domain taking 
 



k   ak   concept names ak  
 

eq rm   eq rm   r role  k  q qr
t 
 

 rai aj  m true iff r ai   aj   a 
 



  ai   ai ob a  
 

drm   drm   r role  k  
 

claim m     k   indeed  eq rm   eq rm   every r role  k  q qr
 
 
 
follows m     x  x  m     x r  x   definition  m    va   m    
q
m     x r  x   remains show m     r   suppose m     i   raaji  
r a  aji   a  distinct aj            ajq   q qr
  clearly  q qr a
   eq r a  thus m     eq r a  
q
immediate consequence corollary      facts translation
done logspace  satisfiability problem ql   formulas np complete
dl litebool contains booleansand encode full propositional logicwe
obtain following result 
f
theorem     satisfiability dl liten
bool   dl litebool dl litebool knowledge bases
np complete combined complexity 
 

observe k dl liten
krom kb k krom fragment ql  
f
theorem     satisfiability dl liten
  dl lite dl lite knowledge bases 
 core  krom   nlogspace complete combined complexity 

  

fithe dl lite family relations

proof satisfiability problem krom formulas prefix form x  as
k   nlogspace complete  see  e g   borger et al         exercise       
logspace reduction  satisfiability nlogspace logics mentioned
theorem  lower bound  suffices recall nlogspace hardness
satisfiability propositional krom formulas proved reduction directed graph
reachability problem using core propositional formulas  borger et al         
satisfiability logics nlogspace hard 
q
 

k dl liten
horn kb k belongs universal horn fragment ql  
f
theorem     satisfiability dl liten
horn   dl litehorn dl litehorn kbs p complete
combined complexity 

proof ql  contains function symbols k universal  satisfiability k
logspace reducible satisfiability set propositional horn formulas  namely 
formulas obtained k replacing x constants occurring
k   remains recall satisfiability problem propositional horn formulas
p complete  see  e g   papadimitriou         gives required upper bound
q
dl liten
horn lower bound dl litehorn  
    dl litehf
core exptime hard
unfortunately  translation constructed previous section cannot extended
logics form dl litehn
number restrictions role inclusions 

section show satisfiability problem dl litehf
core kbs exptime hard 
matches upper bound satisfiability dl litehn
kbs
even binary coding
bool
natural numbers  tobies        
note first that  although intersection allowed left hand side dl litehf
core
concept inclusions  certain cases  when right hand side consistent  simulate
using role inclusions functionality constraints  suppose knowledge base k
contains concept inclusion form c  u c  v c  define new kb k  replacing
axiom k following set new axioms  r    r    r    r     r   fresh
role names 
c  v r 

c  v r   

    

r  v r    

r  v r    

    

  r   v  
r 

v

    

r   

    

r  v c 

    

r  v r    



  r  

r  v r    

v  

    
    

lemma      i     k     k  every interpretation i 
 ii     k c    model   k  domain
agrees every symbol k 
  

fiartale  calvanese  kontchakov   zakharyaschev

proof  i  suppose    k  x c i c i          x  y  r i  
  whence
 r   i   z  x  z  r i           x  y    x  z   r  
  z view              r   i hence u  u  y  r i
 x  y  ri   finally  follows
u  r   i         u c          u  y  r  
  
     u   x  x c   thus     k 
 ii  take point c c define extension   new role names
setting 
 

r i     x  x    x c i   
 

r i     x  x    x c i   
 

r i     x  x    x  c  u c   i     c  x    x  c  u c   i   
 

 

  ri ri
r  
 
 

 



 

 

 

  ri ri  
r  
 
 

readily seen   satisfies axioms                k   

q

position prove following 
theorem      satisfiability dl litehf
core kbs exptime hard combined complexity
 with without una  
proof prove theorem two steps  first consider logic dl litehf
horn
show encode behavior polynomial space bounded alternating turing machines  atms  short  means dl litehf
horn kbs  apspace   exptime 
apspace class problems recognized polynomial space bounded atms  see  e g  
kozen         establish exptime hardness satisfiability dl litehf
horn   then 
using lemma      show get rid conjunctions left hand side
concept inclusions involved encoding atms thus establish exptime hardness
dl litehf
core  
without loss generality  consider atms binary computational
trees  means that  every non halting state q every symbol tape
alphabet  precisely two instructions form
 q  a    m  q     a    d   



 q  a    m  q      a     d     

    

d    d         resp     means move head right  resp   left  one cell 
remind reader non halting state either and state or state 
given atm m  polynomial function p n  every run every
input length n use p n  tape cells  input word  a   a             
construct dl litehf
horn knowledge base km  a following properties   i  size
km  a polynomial size m   a   ii  accepts  a iff km  a satisfiable 
denote q set states tape alphabet m 
encode instructions m  need following roles 
sq   sq    sq    q q  informally  x  sq  i   interpretation i  means
x represents configuration state q  x  sqk  i means
next state  according transition  km   q  k        
  

fithe dl lite family relations

hi   hi    hi    p n   x  hi  i means x represents configuration
head scans ith cell  x  hik  i that  according transition
 km   k         next configuration head scans ith cell 
    c     p n    x  c  i means x represents
cia   cia
ia
ia
k  i that  according
configuration ith cell contains a  x  cia
 km   k         next configuration ith cell contains a 

intended meaning encoded using following concept inclusions  every
instruction  q  a   km  q     a      every   p n  

k
k
sq u hi u cia
v hi  
u sqk  u cia
  

    

every instruction  q  a   km  q     a      every i      p n  

k
k
sq u hi u cia
v hi 
u sqk  u cia
  

    

preserve symbols tape active cell  use following
concept inclusions  k         i  j p n  j    i   

k
hj u cia
v cia
 

    

synchronize roles  need two  functional  roles tk number role
inclusions added tbox  k         p n   q q   
k
cia
v cia  

hik v hi  

sqk v sq  

    

k
cia
v tk  

hik v tk  

sqk v tk  

    

  tk v  

    

remains encode acceptance conditions  a  done help
role names yk   k         concept name a 
sq v a 

q accepting state 

yk v tk  
  tk
tk u
sq u yk
sq

    

v  
v

    

yk  

v a 

u y  u y  v a 

    

    
q or state 

    

q and state 

    

tbox dl litehf
horn knowledge base km  a constructing consists
axioms          together auxiliary axiom
u v  

    

fresh concept name  abox km  a comprised following
assertions  object names u 
sq   u  s  

q  initial state 

h   u  s  
ciai  u  s  

    
    

p n   ai ith symbol input tape 

    
    

d s  
  

fiartale  calvanese  kontchakov   zakharyaschev

clearly  km  a    t   a  dl litehf
a 
horn kb size polynomial size m   
lemma      atm accepts  a iff kb km  a satisfiable 
proof    suppose accepts  a    km  a interpretation i 
reconstruct full computation tree  a induction following way 
let root tree point si             represents initial configuration  a accordance intended meaning roles sq    h  ciai
explained  it matter if  instance  si  h   i   
assume already found point x representing configuration
c   b            bi     q  bi    bi             bp n   

    

q current non halting state head scans ith cell containing bi  
means
x  sq  i  hi  i


x  cjb
   
j

j p n  

assume contains two instructions form       q  bi    q nonhalting   q  bi    km  q     b       k        then            
points ys   yh yj   j p n  
 x  ys    sqk   i  

k
 x  yh    hi  
 i  

k
 x  yi    cib
    

k
   
 x  yj    cjb
j

j    i 

    c   c     j    i  sub roles functional role  
          sq     hi  
k
jbj
ib i
points ys   yh yj coincide  denote point xk        
have 

 x  xk   tki  



   cib
xk  sq   i  hi  
  


   
xk  cjb
j

j    i 

similarly   q  bi    km  q      b        k        then            
point xk
 x  xk   tki  



   cib
xk  sq    i  hi 
    


   
xk  cjb
j

j    i 

thus  k         xk tk  successor x representing configuration ck
executed  q  bi    km  q      b     d  c  case ck called k successor c 
according       every point constructed computation tree  a representing configuration accepting state ai   suppose now  inductively 
x represents configuration c form       q or state  xk represents ksuccessor c  x  xk   tki   k         one xk   say x    ai  
view       x   y   i   t  functional      y  sub role
t         x  x    y i   so        x ai   case x and state
considered analogously help      
since accepts  a  conclude si ai   contrary           
   conversely  suppose accept  a  consider full computation
tree            nodes labeled configurations way root
labeled initial configuration
 q    a     a              an             ap n   
  

fithe dl lite family relations

 where ai   n     p n   blank   node x tree labeled
non halting c form      contains two instructions form      
x one     successor labeled   successor c one     successor labeled
  successor c   it emphasized            tree  different
nodes may labeled configuration  
use tree construct interpretation    i     follows 
   u   u
   
si root ui   u 
di    si   
k  i    x  x    c k  i    x  x    c k  i   j    i 
 x  xk    sqk   i    x  xk    hi  
k
k
jbj
ib 
iff x labeled c form        q  bi    km  q     b      x  k xk   k        
k  i    x  x    c k  i    x  x    c k  i   j    i 
 x  xk    sqk   i    x  xk    hi 
k
k
jbj
ib 
k
iff x labeled c form        q  bi    m  q     b      x  k xk   k        

 u  si    sq   i    u  si    h   i    u  si    ciai  i   p n  extensions
roles sq   hi cia defined according      
tki    k   k        
y i   y i ai defined inductively 
induction basis  x labeled accepting configuration  x ai  
induction step   i  x  k xk   k         xk ai    x  xk   yki    ii 
x or state  respectively  and state   x  xk   yki  respectively 
all  k         x ai  
follows given definition    km  a   details left reader 

q

lemma proved establishes satisfiability dl litehf
horn kbs
exptime hard  next aim show one eliminate conjunctions
left hand side tbox axioms                     help
lemma      applying it  check first km  a satisfiable satisfiable
interpretation    km  a c      every c occurring
axiom form c  u c  v c k  consider  instance  axiom      assume
   km  a    sqk   i     then  construct new interpretation   adding two
 
 
new points  say x y  domain i  setting  x  y   sqk   i    x  y   sq   i  
 
 
 
 x  y   tk  i   furthermore  q   accepting state  set ai  x  y  yki  
one readily check   still model km  a   conjuncts     
remaining axioms considered analogously 
application lemma     axiom form c  uc  v c c    c   uc   
obtain            new kb k  concept inclusion form c   uc    v r   
requires treatment means lemma  able this 
  

fiartale  calvanese  kontchakov   zakharyaschev

  

check k  satisfiable interpretation     r   i      suppose
 
     k   r   i     construct    adding two new points  say x
 
 
    ri   ri    
y  domain     adding x c  x  y  r i   r  
  
 
readily seen       k   
noted proof depend whether una adopted
not 
q
immediate consequence obtain 
corollary      satisfiability dl litehf
dl litehn
kbs without una


exptime complete combined complexity   core  krom  horn  bool  
    reconciling number restrictions role inclusions
seen previous section  unrestricted interaction number restrictions role inclusions allowed logics form dl litehn
results high

combined complexity satisfiability  section      shall see data complexity
instance checking query answering becomes unacceptably high logics 
quick look proof theorem      reveals culprit  interplay role
inclusions r  v r  r  v r functionality constraints   r v   effectively mean
r   x  y  r   x  z    z  section study case
interplay allowed 
 hn  
recall section     dl lite
tboxes    core  krom  horn  bool  
satisfy following conditions 
 a    may contain positive occurrences qualified number restrictions q r c 
c conjunction concepts allowed right hand side  concept
inclusions 
 a    q r c occurs   contain negative occurrences number
restrictions q   r q   inv r  q     
 a    r proper sub role   contain negative occurrences
q r q inv r  q   
 hn  

dl lite
tboxes contain role constraints dis r    r     asym pk    sym pk   
irr pk    ref pk   
main aim section prove following theorem develop technical
 hn  
tools need investigate data complexity reasoning dl litebool
sublogics later paper 
 hn  

theorem      combined complexity   i  satisfiability dl litebool kbs np hn  
complete   ii  satisfiability dl litehorn kbs p complete   iii  satisfiability
 hn  
 hn  
dl litekrom dl litecore kbs nlogspace complete 

  

fithe dl lite family relations

 hn  

let us consider first sub language dl litebool

without qualified number restric hn  

tions role constraints mentioned above  denote dl litebool   sub 

 hn  

language required purely technical reasons  section    use dl litehorn  
need core krom fragments 
 hn  
suppose given dl litebool
kb k    t   a   let id distinguished
role name  use simulate identity relation required encoding role
constraints  assume either k contain id satisfies following
conditions 
 id    id ai   aj   iff   j  ai   aj ob a  


id       
 id      v id  id v id   qid
  qt
 id    id allowed role inclusions form id v id id v r 
follows  without loss generality  assume
 

 
r

 q  qr
qt whenever r vt r
 

 for case always add missing numbers qr
  e g   introducing
fictitious concept inclusions form v q r    
now  way section      define two translations e e k
one variable fragment ql  first order logic  former translation  e   retains
information relationships abox objects  show every model
ke unraveled model k  define e taking 
h
ke   x  x  r  x 

 

r  x  r  x 





rrole  k 

h

 

 



 


r

rrole  k 

 

rai aj r  ai aj



 

rvr 
ai  aj ob a 

 

 

 x       r  x   r  x  r       
 
 

r  x   
eq r x  eq r   x   
rvr 
inv r vinv r   t

    

qqr


following lemma analogue theorem     
 hn  

lemma      dl litebool

kb k satisfiable iff ql   sentence ke satisfiable 

proof proof basically follows lines proof theorem     modifications  present modified unraveling construction here  converse direction exactly
theorem     
equivalence class  ri      rj   ri rj   select single role  a representative
class  denote rept  ri    extending pkm pkm     use following
modified curing rules 
  

fiartale  calvanese  kontchakov   zakharyaschev



 m
k   pk    rept  pk   nothing  defects cured rept  pk    otherwise  let

w k   q   r pk   cp w   rm  pk   w    cp w      eq  pk  d 
q   q      then          e  pk  d  and          e  pk  dp
k   
      dp     q  
case take q fresh copies w             wq  dp
 and
set
cp w

k
k
add wm  

add pairs  w  wi       q  pjm   pk vt pj  including
pj   pk   
add pairs  wi    w     q  pjm   pk vt pj  
id occurs k  add pairs  wi    wi       q  pjm   id vt pj  


 m
k   rule mirror image  k    pk dpk replaced everywhere

pk dpk   respectively  see proof theorem     

follows definition id never
resulting
defects interpreted

interpretation identity relation idi    w  w    w   interpretations
roles respect role inclusions  i e   r i r i whenever r  vt r   
remains show constructed interpretation indeed model k 
first       trivially holds id required actual ranks equal    second       holds r r    id r proper sub roles  proof exactly
theorem      taking account cure defects single role
equivalence class that        r   r   r r    cp w     r r  cp w  
r inv r   cp w     r inv r     cp w    follows      holds id role r
without proper sub roles  however       necessarily hold roles r proper
sub roles  follows construction  actual rank may greater required
rank  case following 
   eq r cp w  



w   q r i  

however  enough purposes  induction structure concepts
using  a     one show    c  v c  whenever    x  c   x  c   x   
concept inclusion c  v c    therefore           see proof
theorem      thus    k 
q
remark      follows proofs theorem     lemma      that 
 hn  
dl litebool
kb k    t   a   every model ke induces model im k
following properties 
 abox  ai   aj ob a    aii   aij   rim iff r ai   aj   clet  a  
clet  a   




r   ai   aj     r   ai   aj   a  r  vt r   

 forest  object names ob a  induce partitioning im disjoint labeled
trees ta    ta   ea    a   nodes ta   edges ea   root aim   labeling function
 a   ea role  k     id  id   
  

fithe dl lite family relations

 copy  function cp   im ob a  dr k 
cp aim     ob a  
cp w    dr if  w  ta    w    w  ea  a  w    w    inv r  
 iso  r role  k   labeled subtrees generated elements w im
cp w    dr isomorphic 
 concept  w b im iff    b  cp w    basic concept b k w im  



 role  idim    w  w  w im and  every role name pk  
pkim  






 aii   aij     r ai   aj   a  r vt pk

 w  w    id vt pk

 

 w  w    ea    a  w  w      r  r vt pk  
aob a 

model called untangled model k  the untangled model k induced
m  precise  
translation e generalizes thus suffers exponential blowup 
define optimized translation  e   linear size k  taking 
h
 

 
 

e  
r  x  r  x 
ke   x  x  r  x 
rrole  k 
 

 x   r  x   r  x   r  x  defined                         
respectively 
 
 
 
 
e r a 
ae  
eqr a

    
 pk  ai   aj   e  
aob a 

rrole  k 
a  ob a  r a a   clet  a 

pk  ai  aj  a

e
e
qr a
maximum number qr
qr a many distinct ai
r a  ai   clet  a   here use una   pk  ai   aj   e   pk  ai   aj   clet  a 

  otherwise  cf        note qr
       roles r role  k  
translation depend whether una adopted not 
following corollary proved similarly corollary     
 hn  

corollary      dl litebool

kb k satisfiable iff ql   sentence ke satisfiable 

clear translation e computed nlogspace  for combined
 
complexity   indeed  readily seen  x   r  x   r  x   r  x    
 
order compute ae   need able check whether r ai   aj   clet  a   test
performed non deterministic algorithm using logarithmic space  role  k  
 it basically standard directed graph reachability problem 
nlogspace complete  see  e g   kozen         done using n log  role  k    
  log  ob a   cells work tape  n constant  in fact  n     enough  one
  

fiartale  calvanese  kontchakov   zakharyaschev

store r  current role r  path length graph reachability subroutine 
bounded log  role  k     therefore  translation e computed
nlogspace transducer 
 hn  
show satisfiability dl litebool kbs easily reduced satisfiability
 hn  

 hn  

dl litebool
kbs  first  assume dl litebool kbs contain role symmetry
asymmetry constraints asym pk   equivalently replaced dis pk   pk  
sym pk   pk v pk  it noted introduction pk v pk
tbox violate  a      following lemma allows us get rid qualified number
restrictions well role disjointness  reflexivity irreflexivity constraints 
 hn  

lemma      every dl litebool
kb k    t   a 

 hn  

kb k     t     a     one construct dl litebool

every untangled model im k model k    provided
r   ai   aj    r   ai   aj   clet  a  dis r    r       
r ai   ai   clet  a  irr r     

    

every model   k  gives rise model k based domain  
agrees   symbols k   
 hn  

 hn  

k  dl litehorn kb k dl litehorn

kb 

proof first  every pair r  c q r c occurs     introduce fresh role
name rc   replace  positive  occurrence q r c   q rc
add following concept role inclusions tbox 

vc
rc



rc v r 

repeat procedure occurrences qualified number restrictions eliminated  denote    resulting tbox  observe  a     a    ensure   
satisfies  a     notice c occurs right hand side extra
axioms thus    belongs fragment     clear that  since
q r c occur positively  every model    model     conversely  every
model       model       based domain    coincides
       w  u  ri     u c      new role r   so 
  symbols   rc
c
without loss generality may assume         
let
 
 
 
tirref
tdisj
 
    t   tref
    t 
 
tref
irref tdisj sets role reflexivity  irreflexivity disjointness con hn  

straints   t   remaining dl litebool
tbox  let




 
t       v id  id v id
id v p   ref p   tref
 


a     id ai   ai     ai ob a     
 hn  

construct k modifying dl litebool
kb k     t   t     a  a     two steps 
    take fresh role name
step    every reflexivity constraint ref p   tref
p
  

fithe dl lite family relations

add new role inclusion sp v p tbox 
replace every basic concept b t   b sp   defined inductively follows 
asp   a  concept name a 
  q r sp   q r  role r
   p  p   
  q p  sp    q    sp   q p  sp    q    sp   q   
 p  sp      p  sp     
replace r ai   aj   a  r   p sp  ai   aj   whenever    j 
intuitively  split role p irreflexive part sp id  note p
reflexive proper sub role then   a     restrictions maximal number
p  successors p  predecessors  therefore sp ref p       let  t    a 
 hn  
resulting dl litebool
kb  clearly   t    a  satisfies  id    id     observe
clet   a  role k      clet      a    
 

 

    

role k    means restriction role names k   
let im untangled model  t    a   show im    t     consider role p
ref p       notice sp proper sub roles t  idim disjoint
spim   thus  spim idim p im
     b sp  im b im   b   q r q    whenever ref p       r  p  p  
p proper sub role    
p proper sub roles    i e   proper sub roles t  different sp id 
spim idim   p im   so  basic concepts b t   covered     
b im    b sp  im   follows  a    im    t    
 
   
step    next take account set   tdisj
 dis pk   id    irr pk   tirref
disjointness constraints modifying kb  t    a  constructed previous step 
observe r  v logical consequence  dis r    r     whenever r  vt r   
let   t  t    t  defined taking



t    r  v r  vt  r  either dis r    r    dis r    r     
 role   untangled model im  t   a  r    r  role  k   im    dis r    r   
r   ai   aj    r   ai   aj   clet   a   which        means
r   ai   aj    r   ai   aj   clet      a     so       holds every untangled model im
 

 

    idim identity relation 
 t   a  model t  thus  im    tdisj
 
 
 
im    tref tirref         im    shown above  im    t    
therefore  im    k   
conversely  suppose   model k    let interpretation idi
 
 
 
identity relation  spi   p   idi   p ref p       ai   ai  
 
 
p   p ai   ai   concept  role object names a  p k    clearly 
    t   t     a  a      definition sp      t  and  since    d  obtain
   t  thus               a  whence    k 
q

  

fiartale  calvanese  kontchakov   zakharyaschev

 hn  

now  follows lemma       given dl lite
kb k     krom  horn 

 hn  
bool   compute dl litebool
kb k using logspace transducer  which
essentially required checking whether r   p    immediately obtain theorem     
lemma      observing that   krom  horn  bool   ke belongs
respective first order fragment condition      checked nlogspace
 hn  
 computing clet  a  requires directed graph accessibility checks   result dl litecore
 hn  
follows corresponding result dl litekrom  
    role transitivity constraints
 hn   

consider languages dl lite
   core  krom  horn  bool   extend
 hn  
dl lite
role transitivity constraints form tra pk    remind reader
role called simple  see  e g   horrocks et al         transitive sub roles
 including itself  simple roles r allowed concepts form q r 
q    particular  contains tra p   p p simple  cannot
contain occurrences concepts form q p q p   q   
 hn   
dl lite
kb k    t   a   define transitive closure trat  a 
taking


trat  a    p  ai        ai        ain  p  ai    aij     a    j   n  tra p    
clearly  trat  a  computed nlogspace  pair  ai   aj   objects ob a  
add p  ai   aj   trat  a  iff p  path length    ob a   ai aj
 recall directed graph reachability problem nlogspace complete  
 hn   

 hn  

lemma      dl lite
kb  t   a  satisfiable iff dl lite
kb  t     a   
 
satisfiable  results removing transitivity axioms
a    clet  trat  clet  a    
proof indeed  kb  t     a    satisfiable construct model described
proofs lemmas           take transitive closure p every p
tra p    and update ri p vt r   p p simple  contains
axioms imposing upper bounds number p  successors predecessors 
resulting interpretation must model  t   a   converse direction trivial  q
note analogue remark      holds case  replace clet  a 
clet  trat  clet  a     abox  take transitive closure transitive subrole  role  
remark      noted two different reasons reduction
lemma      nlogspace rather logspace  as reduction is   first 
order compute clet  a   pair ai   aj   one find path directed
graph induced role inclusion axioms  second  order compute trat  clet  a    one
find path graph induced abox itself  so  concerned
data complexity  clet  a  computed logspace  in fact  ac    shall
  

fithe dl lite family relations

see section      role inclusion graph  and hence size  depend
a  second reason  however  dangerous data complexity shall see
section     
consequence lemma      theorem      obtain following 
 hn   

corollary      combined complexity   i  satisfiability dl litebool
complete   ii 
 hn   
dl litekrom

 hn   
satisfiability dl litehorn kbs p complete 
 hn   
dl litecore
kbs nlogspace complete 

kbs np 

 iii  satisfiability

note kbs contain number restrictions form q r 
q     as extensions dl liteh
languages  result depend
una 
remark      noted role disjointness  symmetry  asymmetry transitivity constraints added logics dl litehf
dl litehn

 
 core  krom  horn  bool   without changing combined complexity satisfiability problems  which  corollary       exptime complete   indeed  follows
theorem    glimm et al          kb satisfiability extension shiq
role conjunction exptime length role conjunctions bounded
constant  in case  constant   dis r    r    encoded
 r  u r      v   asym r  dealt similarly   conjecture role reflexivity irreflexivity constraints change complexity either 

   instance checking  data complexity
far assumed whole kb k    t   a  input satisfiability problem  according classification suggested vardi         considering
combined complexity  two types complexity knowledge bases are 
schema  or tbox   complexity  tbox regarded input 
abox assumed fixed 
data  or abox   complexity  abox regarded input 
easy see schema complexity satisfiability problem logics
considered coincides corresponding combined complexity  section 
analyze data complexity satisfiability instance checking 
 hn  

h
    dl liten
bool   dl litebool dl litebool

ac 

follows  without loss generality assume role concept names
given knowledge base k    t   a  occur tbox write role t    role  t  
dr t   instead role k   role  k  dr k   respectively  set concept names
 hn  
denoted con t    section reduce satisfiability dl litebool kbs model
checking first order logic  end  fix signature containing two unary predicates
ak ak   concept name ak   two binary predicates pk pk   role
name pk  
  

fiartale  calvanese  kontchakov   zakharyaschev

 hn  

consider first case dl litebool
kb k  represent abox k
first order model aa signature  domain aa ob a  and 
ai   aj ob a  predicates ak   ak   pk pk signature 
aa    ak  ai  

iff

ak  ai   a 

aa    pk  ai   aj  

iff

pk  ai   aj   a 

aa    ak  ai  

iff

ak  ai   a 

aa    pk  ai   aj  

iff

pk  ai   aj   a 

construct first order sentence signature  i  depends
depend a   ii  aa    iff ke satisfiable 
simplify presentation  denote ext t   extension following
concept inclusions 
 
 
  
q   r v q r  r role  t   q  q   qr
q   q q   q   q
  
r
q qt  
 
 
q r v q r    q qr
r v r inv r  v inv r    
v
clearly   ext t     x  equivalent  in first order logic   x t r  x  rrole  t   r  x  
see               
let bcon t   set basic concepts occurring  i e   concepts form
q r  con t    r role  t   q qr
   indicate basic concepts
hold hold domain element first order model ke   use functions
  bcon t          called types  denote tp set types
 there   bcon t    them   complex concept c  define  c  induction 
 c     c   c  u c       c     c     propositional variable free formula
 

 
 c     c   
c  vc  ext t  

ensures type consistent concept role inclusions  
emphasized built   using boolean connectives therefore
depend particular domain element aa   following formula true given
 
 
element x aa type  see ae             respectively  
 x   

 


 ak  x   ak     ak  x   ak   



ak con t  

 

 

eq rt  x    q r 



 



rrole  t   qqr



xy pkt  x  y  pk  x  y   

pk role t  

eq rt  x  rt  x  y   r role  t    abbreviations defined
 
 

eq rt  x    y        yq
 yi    yj  
rt  x  yi    
 i jq

rt  x  y   

 
pk vt

pk  x  y 



 
pk vt

r

  

    

 iq

pk  y  x  
r

    

fithe dl lite family relations

clearly  r ai   aj   clet  a  iff aa    rt  ai   aj   aa    eq rt  a  iff
least q distinct r successors clet  a   and thus every model k  
without loss generality may assume role  t      r            rk        denote
tpk set k tuples   containing type dri tp role ri role  t   
set
 
 
x  x  

 
k
 
tp


 dr       drk  



 x 

 

 

 x 

 




dr






tp

ri role  t  

 



 ri  

ri role  t  

 



ds  ri   inv dri    inv ri     

srole  t  

explain meaning subformulas   assume  t   a  satisfiable  order
construct model ke first order model aa   specify basic
concepts contain given constant ke   words  select type
dri dr t   ob a   formula says one select k tuple
types      dr            drk   tpk one disjuncts true aa  
k tuple fixes witness part model m  consisting dri   determines
basic concepts dri belong to  disjunct says  having fixed
witness part model   every ob a   type  determining basic
concepts belongs to 
consistent information  cf   x   
consistent concept role inclusions  cf    
  
dr            drk consistent concept role inclusions  cf  dr


role ri nonempty domain  i e   either ds   ri  
nonempty range  particular  inv dri    inv ri         see r  x  defined
    
lemma     aa    iff ke satisfiable 
 
proof    fix      dr            drk   tpk aa    x  x   then 
 

ob a   fix type respective disjunct  x  holds aa
denote   define first order model domain ob a  dr t   taking 
   b  c  iff c  b       c ob a  dr t   b bcon t  
 b unary predicate b defined p       easy check    ke  
   suppose ke satisfiable  model ke domain
ob a  dr t    see aa      suffices take functions dri defined
by 
  

fiartale  calvanese  kontchakov   zakharyaschev

dri  b      iff    b  dri    dri dr t   b bcon t   
 b      iff    b  a   ob a  b bcon t   
details left reader 

q

follows lemmas          corollary      have 
h
corollary     satisfiability instance checking problems dl liten
bool   dl litebool
 hn  
dl litebool kbs ac  data complexity 
 hn  

h
proof dl liten
bool dl litebool sub languages dl litebool  
 hn  
result immediately follows lemma     corollary       dl litebool kb
 hn  

k     t     a     lemma       construct dl litebool
kb k    t   a 
 
k satisfiable iff k satisfiable      holds  latter condition corresponds
following first order sentence
 
 


   
xy r t  x  y  r t  x  y 

x pkt  x  x   
dis r   r   t  

irr pk  t  

evaluated aa   therefore  k  satisfiable iff aa        let      
result replacing sp  t    t     ref p       p  t    t     t     t     see
proof lemma       remains observe aa    iff aa        
q
before  result depend una member dl lite family
number restrictions form q r  q    in particular  dl liteh
bool
fragments  
note transitive roles cannot included languages free
concerned data complexity 
lemma     satisfiability instance checking dl litecore kbs extended role transitivity constraints nlogspace hard data complexity 
proof suppose given directed graph  let p role name  define abox
taking p  ai   aj   iff edge  ai   aj   graph  node
reachable node a  iff dl litecore abox  p  a       satisfiable
models transitive p   encoding immediately gives claim lemma
directed graph reachability problem nlogspace complete  nlogspace closed
complement  see  e g   kozen        tbox  tra p    depend
input 
q
hand  reduction lemma      computable nlogspace 
obtain following 
 hn   

corollary     satisfiability instance checking dl litebool
complete data complexity 

kbs nlogspace 

proof upper bound obtained applying nlogspace reduction lemma     
using corollary      lower bound follows lemma     
q

  

fithe dl lite family relations

    p  conp hardness data complexity
let us turn data complexity instance checking dl lite logics
arbitrary number restrictions role inclusions  follows results ortiz et al 
       shiq  instance checking  and fact query answering  dl litehn
bool
conp data complexity  results hustadt et al         eiter et al        
horn shiq imply polynomial time upper bound dl litehf
horn  
show upper bounds optimal following sense  one
hand  instance checking dl litehf
core p hard data complexity  hand 
hn
becomes conp hard dl litehf
krom dl litecore  that is  allow negated
concept names arbitrary number restrictionsin fact    r enough   note
results section depend whether adopt una not 
theorem     instance checking  and query answering  problem dl litehf
krom kbs
data hard conp  with without una  
proof proof reduction unsatisfiability problem    cnf 
known conp complete  schaerf         given    cnf formula
 

n
 

 ak   ak   ak   ak     

k  

ak j one propositional variables a              construct kb  t    
whose tbox depend   use object names f   ck     k n 
ai     m  role names s  sf pj   pj t   pj f     j    concept names
d 
define set following assertions    k n 
s f  ck   

p   ck   ak     

p   ck   ak     

p   ck   ak     

p   ck   ak     

let consist axioms
  pj v  
pj f v pj  

pj t v pj  

pj t v pj f  

pj f


pj t

v a 

p  f u p  f u p  t u p  t v

sf  

v a 

for  j   

    

  j   

    

  j   

    

  j   

    
    



  v  

    

sf v s 

    

sf v d 

    

note axiom      belong dl litehf
krom conjunctions
left hand side  however  eliminated help lemma      let us prove
 t        d f   iff satisfiable 
   suppose satisfiable     t      define assignment
truth values f propositional variables taking a ai     iff aii ai   false
  

fiartale  calvanese  kontchakov   zakharyaschev

a  k    k n  a ak       a ak       f a ak       a ak       t 
view       j    j    cik  pj t  i  pj f  i        
cik  pj  i   therefore             cik  pj t  i a ak j     cik  pj f  i
a ak j     f  hence        cik  sf  i              f  sf  i  
which        f di   follows  t        d f   
   conversely  suppose satisfiable  assignment
a ak       a ak       a ak       f a ak       f    k n  define taking



  x     yk     k n z  
aii   xi     m 
cik   yk     k n 
f   z 



ai   xi   a ai     yk     k n z  




   y   ai       k n  a a      x   x     a a      z  z   
pj t


k k j
k j



   y   ai       k n  a a     f  x   x     a a     f  
pj f


k j
k k j
p     j   
pji   pj t
j f


sfi    z  yk     a ak   ak   ak   ak       f    


   z  yk       k n  


di   z   a     f    

hard check     t         d f   

q

theorem     instance checking  and query answering  problem dl litehn
core
kbs data hard conp  with without una  
proof proof reduction unsatisfiability problem    cnf 
hf
main difference previous one dl litehn
core   unlike dl litekrom   cannot express
covering conditions       turns out  however  use number restrictions
represent constraints kind  given    cnf formula   take abox
constructed proof theorem        independent  tbox   describing
meaning representation terms   defined way
proof  except axiom      replaced following set axioms 
tj   v tj  


  tj

v  

pj v tj    

tj  

u


tj  

tj   v tj  

v

    
    

pj v tj    


tj  
 

  tj v pj t

tj   v tj  

    
    

tj   v pj f  

    

tj   tj     tj     tj   fresh role names  j    j    note axioms     
     belong dl litehn
core conjunctions left hand side 
  

fithe dl lite family relations

easily eliminate using lemma      remains prove  t        d f  
iff satisfiable 
   suppose satisfiable     t      define assignment
truth values f propositional variables taking a ai     iff aii ai  
false a  k    k n  a ak       a ak       f  a ak       a ak       t 
j    j    cik  pj  i         cik  tj    i    tj    i  
 ci   v     v    v ci      i
v    v   cik   v    tj  
 
 
j
j  
k  
k

and        cik  pj t  i   otherwise  v    v    v  v  tj  
       
           cik  tj    i   which        cik  pj f  i   therefore 
cik  pj t  i  pj f  i         cik  pj  i   thus             cik  pj t  i
a ak j     cik  pj f  i a ak j     f  hence        cik  sf  i  
           f  sf  i   which        f di   follows
 t        d f   
   conversely  suppose satisfiable  assignment
a ak       a ak       a ak       f a ak       f    k n  define taking




  xi     yk     k n uk j     uk j       j      k n z  
aii   xi     m 

cik   yk     k n 

f   z 

ai    xi   a ai     t  


   y   ai       k n  a a         j   
pj t
k j
k k j


   y   ai       k n  a a     f     j   
pj f
k j
k k j
p     j   
pji   pj t
j f


   y   u
tj  
k k j         k n     j   


   y   u
tj  
k k j         k n  a ak j    


 yk   uk j         k n  a ak j     f     j   


   y   u
tj  
k j         k n  a ak j     f     j   
ti  
tji   tj  
j  


sfi    z  yk     a ak   ak   ak   ak       f    


   z  yk       k n  


di   z   a     f    

hard check     t         d f   

q

next lower bound would follow theorem    item   work calvanese
et al          unfortunately  proof incorrect cannot repaired 
theorem     instance checking  and query answering  problem dl litehf
core kbs
data hard p  with without una  
  

fiartale  calvanese  kontchakov   zakharyaschev

proof proof reduction entailment problem horn cnf  known
p complete  see  e g   borger et al         exercise         given horn cnf formula
 

n
 

 ak   ak   ak    



k  

p
 

al    

l  

ak j al   one propositional variables a              construct
kb  t     whose tbox depend   need object names c            cn
vk j i     k n    j       for variable  take one object name
possible occurrence variable non unit clause   role names s  st
pj   pj t     j    concept name a 
define set containing assertions 
s v    i   v    i    s v    i   v    i    s v    i   v    i    s v    i   v    i    s v    i   v    i         
        s vn   i   vn   i    s vn   i   v    i   
pj  vk j i   ck  

iff

a v    i  

al     ai  

iff

ak j   ai  

  m 

  m    k n    j   
  m    l p

 all objects variable organized s cycle pj  vk j i   ck   iff
variable ai occurs kth non unit clause jth position   let consist
following concept role inclusions 
st v s 

    

  v  

    

v st  
st

    

v a 

    

  p  v
p  t v p   
v p  t  


p  t

u

  p 

  p  v  

    

p  t v p   

    

v p  t  

    

v  

    

p  t v p   

    


p  t

v


p  t
 

    

p  t v a 

    

before  axiom  namely       belong dl litehf
core
conjunction left hand side  eliminated help
lemma      aim show  t        a v    i    iff    ai   
   suppose    ai    consider arbitrary model  t     define
assignment truth values f propositional variables a ai     iff


v    i
ai     m            i    m  either vk j i
ai  


k  j   k n    j    vk j i
    k  j   k n 
  j    now  a ak       a ak       t    k n then           




cik  p  t
     p  t
          cik  p  t
  hence             vk   i
 p  t  i  
  

fithe dl lite family relations

st  

pj t   pj
pj

a  a  a 
y 

a  a  a 
y 




 

xk j i
 

zk j i
a 

a 

a 

a 

a 

figure    model satisfying  t         a  a  a     a  a  a    


ak     ai   means        vk   i
ai   v    i
ai a ai     t 

follows a     t  hence a ai      t  which  definition  means v    i
ai  
 
conclude  t        a v    i    

   conversely  suppose     ai    assignment a    
a ai      f  construct model  t         a v    i     define
taking



  xk j i   zk j i     k n    j      yk     k n  
cik   yk     k n 

  xk j i     k n    j      m 
vk j i


ai   xk j i     k n    j    a ai      
 


si  
si   si    xk   i   xk   i     xk   i   xk   i     xk   i   xk    i       k n
 im

k     k     k   n  k       k   n 
 
sti  
si  
 im
a ai   t



pji    xk j i   yk       k n  ai   ak j
 xk j i   zk j i       k n  ai    ak j     j   


p i    xk   i   yk       k n  ai   ak    


   x
pj t
k j i   yk       k n  ai   ak j   a a
i   
 xk j i   zk j i       k n  ai    ak j     j   


   x
p  t
k   i   yk       k n  ai   ak     a ai      
routine check indeed     t         a v    i     see figure  
example 
q

  

fiartale  calvanese  kontchakov   zakharyaschev

   query answering  data complexity
positive existential query answering problem known data complete conp
case dl litehn
bool   upper bound follows results ortiz et al         
lower bound established dl litekrom calvanese et al          schaerf
        case dl litehf
horn   query answering data complete p  follows
results hustadt et al         eiter et al         horn shiq 
 
dl liteh
horn ac  calvanese et al         
fact  conp upper bound holds extension dl litehn
bool role disjointness  a symmetry constraints  this follows glimm et al         theorem    
cf  remark        conjecture result holds role  ir reflexivity constraints 
main result section following 
theorem     positive existential query answering problem logics dl liten
horn  
 hn  
h
 
dl litehorn dl litehorn ac data complexity 
 hn  

proof suppose given consistent dl litehorn kb k     t     a     with
concept role names occurring tbox     positive existential query prenex
 hn  
form q  x     y   x   y   signature k    consider dl litehorn kb k    t   a 
 hn  

provided lemma       the language dl litehorn

defined section      

lemma     every tuple  a object names k    k     q  a  iff    q  a 
untangled models k 
proof    suppose k     q  a  untangled model k  lemma     
view consistency k    ensures      holds     k 
therefore     q  a  
   suppose      k    lemma       model k domain
 
coincides   symbols k       q  a   must      q  a  
k     q  a  required 
q
next show that  ke horn sentence  enough consider one special
model i  k formulation lemma      let m  minimal herbrand model
 the universal horn sentence  ke   remind reader  for details consult  e g   apt       
rautenberg        m  constructed taking intersection herbrand
models ke   is  models based domain consists constant symbols
ke i e     ob a  dr t    cf  remark       following
m     b  c 

iff

ke    b  c  

b bcon t   c  

let i  untangled model k induced m    denote domain i  i   
property  copy  remark      provides us function cp   i   
two consequences lemma       first 
aii   b i 

iff

k    b ai   

b bcon t   ai ob a  

  

    

fithe dl lite family relations

second  every r role  t    ri     ri      models k  indeed 
ri     m      r   dr   therefore   t  r v    a  satisfiable  thus
ri         k  moreover  ri    
w b i 

iff

k    r v b 

b bcon t   w i  cp w    dr      

lemma     i     q  a     q  a  untangled models k 
proof suppose    k  q  a  positive existential sentence  enough construct
homomorphism h   i  i  remind reader that   forest   domain i 
i  partitioned disjoint trees ta   ob a   define depth point w i 
length shortest path respective tree root  denote wm
set points depth m  particular  w     ai    ob a    construct h
union maps hm      hm defined wm following properties 
hm    w    hm  w   w wm  
 am   every w wm   w b i  hm  w  b   b bcon t   
 bm   u  v wm    u  v  ri   hm  u   hm  v   ri   r role  t   
basis induction  set h   aii       aii   ai ob a   property  a    follows
      b     abox  remark      
induction step  suppose hm already defined wm      set
hm    w    hm  w  w wm   consider arbitrary v wm     wm    forest  
unique u wm  u  v  ea   ta   let  a  u  v    s  then 
 copy   cp v    inv ds    role   u  s i  and   am    hm  u   s i  
means w  hm  u   w    set hm    v    w  cp v    inv ds 
 inv s  i       follows      v b i  w  b whenever
w   inv s  i   w  inv s  i   obtain  am     v  show  bm      notice
that   role    w  v  ri    w wm     two cases  either
w wm     wm   w   v id vt r  w wm   w   u vt r 
former case   hm    v   hm    v   ri idi identity relation  role  
latter case   u  v  i    hence  hm    u   hm    v   and  vt r 
 hm    u   hm    v   ri  
q
assume that  query q  x     y   x   y     y   y            yk  
quantifier free formula  next lemma shows case check whether i     q  a 
suffices consider points depth m  i    m 
depend  a  
lemma     let m    k    role  t     i      y   a   y   assignment a 
wm   i e   a   yi   wm  i  i    a    a   y   
proof suppose i    a   a   y    assignment i    yi  
  k  a yi  
  wm    let minimal subset  y contains yi
every either p  y     y  p  y      subformula    
role name p   let yj    role  t    a yj   wm
  

fiartale  calvanese  kontchakov   zakharyaschev

a y 
  wm   for convenience  w    before   clearly  exists 
a yi  
  wm    k variables and   forest   relations p i  connect point
wn   wn  point wn     wn    n    let w   a yj   point
ta   w wm   wm    cp w    dr  r role  t   
 role  t    distinct labels labeled tree ta view  copy   point u
depth    role  t     point u  depth  role  t    ta
cp u    cp u      iso   trees generated u u  isomorphic  so 
isomorphism g labeled tree generated w  which contains a y    
onto labeled tree generated point depth  role  t    ta   define new
assignment ay taking ay  y    g a y   ay  y    a y  otherwise   copy  
 concept   role  i    ay   a   y   ay  y  wm     
ay  yj  
  wm  j  repeat described construction  k iterations
shall obtain assignment a  required lemma 
q
complete proof theorem      encode problem k    q  a   model
checking problem first order formulas  precisely way section     
fix signature contains unary predicates a  a  concept name a  binary
predicates p   p   role name p   represent abox k first order
model aa domain ob a   define first order formula  q   x 
signature  i   q   x  depends q a   ii  aa     q   a 
iff i     q  a  
begin defining formulas b  x   b bcon t    describe types
elements ob a  model i  following sense  see       
aa    b  ai  

iff aii   b i   

b bcon t   ai ob a  

    

   x      x         formulas
formulas defined fixed points sequences b
b
one free variable 
 
a x  
b   a 
 
b  x   

eq r  x   b   q r 
 

i 
i 

 
b
 x    b
 x 
b
 x  b
 x      
 
k
b  uubk vbext t  

eq rt  x  given        as section      simplify presentation use ext t   instead    clear that  b bcon t   
 x  i    x   i e   every  x  equivalent i    x  first order logic  
b
b
b
b
 x  j  x  every b bcon t   j i  minimum
b
b
n  x  
exceed n    bcon t     set b  x    b
next introduce sentences b dr   b bcon t   dr dr t    describe
types elements dr t   following sense  see       
aa    b dr

iff

w b i    b bcon t   w i  cp w    dr 

    

 by  concept   definition correct   sentences defined similarly b  x  
namely  b bcon t   dr dr t    inductively define sequence
  

fithe dl lite family relations

 
 
b dr
  b dr
        taking
 
b dr
   b dr




b dr
  ib dr

 


i 
i 
b






    
 dr
b
 dr
 
k

b  uubk vbext t  

ib dr        whenever b    r
 r dr   x inv r   x 



ir dr  

 

i 
inv r  ds
 

  

dsdr t  
i  

clear  role  t   n b dr
b dr
  b bcon t  
 role  t   n

dr dr t    set b dr   b dr
 
consider directed graph gt    vt   et    vt set equivalence
classes  r    r     r    r r     r empty model   et
set pairs   ri     rj   
 path     inv ri   v q rj



either inv ri    vt rj q   

rj proper sub role satisfying  path     ri     rj    et iff 
abox a    whenever minimal untangled model i   t   a    contains copy w inv dri    
ri   ri    w connected copy inv drj     rj   rj    relations
rj vt s 
recall given query q  x     y   x   y    quantifier free
positive formula  y   y            yk   let  m  set paths graph gt
length m    precisely 


 m      r      r              rn        n m      rj     rj      et     j   n  
r

     m  role r role  t    write   one following three
conditions satisfied   i      id vt r   ii    s       iii        inv s   
role vt r 
let kt  m  set k tuples form                  k     m    intuitively 
evaluating query  y   x   y   i    bound  non distinguished  variable yi
mapped point w wm    however  first order model aa contain
points wm    w    represent them  use following trick   forest  
every point w wm  uniquely determined pair  a     ai  root
tree ta containing w  sequence labels  a  u  v  path ai  w 
follows unraveling procedure  path   m    so  formula
 q define assume yi range w  represent first
component pairs  a     whereas second component encoded ith member
   these yi confused yi original query q  range
wm     order treat arbitrary terms occurring   x   y   uniform way 
set t        ob a    xi   t        yi  the distinguished variables xi
object names mapped w  require second component
pairs  
given assignment a  wm  denote split a    pair  a      
assignment aa                  k   kt  m 
  

fiartale  calvanese  kontchakov   zakharyaschev

distinguished variable xi   a xi     ai    a   xi   
bound variable yi   a yi         r              rn     n m    ai 
root tree containing a   yi   r            rn sequence
labels  a  u  v  path ai  a   yi   
every pair  a       however  corresponds assignment wm  paths
  may exist i    gt represents possible paths models fixed
tbox varying abox  follows unraveling procedure  point wm    w 
corresponds ob a      r            m  iff enough r witnesses
 
r
a  i e   iff aa    q
 
r  a  q r  a   q qt   thus  every  a   
                 k    assignment a  wm  split a       a      iff aa   a     y   

 
 

 
q
        k    y            yk    
ri  yi   q ri  yi  
r

 ik
  

qqt

ri     k          ri            
define now  every   kt  m    concept name role name r 
 
 t  
t     
a   t   
a inv ds    t        s      m   

 

 


r  t    t     t    t     
r
r   t    t     
 t    t    
t   t   either t      t       


 
otherwise 
rt  y    y    given       claim that  every assignment a  wm 
 a      split a    
i    a  a t 

iff

aa   a a   t  

i    a  r t    t   

iff

aa   a r   t    t    

concept names terms t 
roles r terms t    t   

    
    

a a   a xi   a yi     claim follows       a yi         s  
 copy   cp a yi      inv dr   r  s   claim follows      
r yi    yi    i    i      claim follows  abox   let us consider case
r yi    yi    i       a   yi   
  w  thus   role   i    a  r yi    yi    iff
a   yi     a   yi    tree ta   ob a   i e   aa   a  yi    yi    
either  a   yi     a   yi     ea  a  a   yi     a   yi       vt r 
 a   yi     a   yi     ea  a  a   yi     a   yi       inv s  vt r 
r

a   yi      a   yi    id vt r  i e   i  i   
cases similar left reader 
finally  let     x   y   result attaching superscript   atom

 
 q   x     y
    x   y       y    
 
kt  m

 

  

fithe dl lite family relations

follows           every assignment a  wm    i    a    x   y   iff
aa   a     x   y    a      split a     converse direction notice that  aa   a     y  
assignment a  wm  split a       a      
clearly  aa     q   a  iff i     q  a   every tuple  a  note that  every
pair tuples  a  b object names ob a       a   b  positive existential sentence
inequalities  domain independent    easily seen that   b 
    b  domain independent  follows minimality i   q   a  domainindependent  tuple  a object names ob a  

finally  note resulting query contains  role  t   k k  role  t     disjuncts  q

   dl lite without unique name assumption
section  unless otherwise stated  assume interpretations respect
una  is  may aii   aij distinct object names ai aj   consequence
relation   nouna refers class interpretations 
description logics without una usually extended additional equality
inequality constraints form 
ai aj



ai   aj  

ai   aj object names  semantics quite obvious     ai aj iff
aii   aij      ai   aj iff aii    aij   equality inequality constraints supposed
belong abox part knowledge base  noted  however  reasoning
equalities logspace reducible reasoning without them 
lemma     every kb k    t   a   one construct logspace size
kb k     t   a    without equality constraints    k iff    k    every
interpretation i 
proof let g    v  e  undirected graph


v   ob a  
e    ai   aj     ai aj aj ai
 ai   set vertices g reachable ai   define a  removing
equality constraints replacing every ai aj  ai   minimal j  note
minimal j computed logspace  enumerate object names aj
respect order indexes j check whether current aj reachable
ai g  remains recall reachability undirected graphs slogspace complete
slogspace   logspace  reingold        
q
mentioned section      logics form dl liteh
feel whether
adopt una not  observation lemmas                hand 
obtain following result consequence theorem      
    query q  
x  said domain independent case aa   a q  
x  iff   a q  
x  
domain contains ob a   active domain aa   aa   aaa p   p aa   concept
role names p  

  

fiartale  calvanese  kontchakov   zakharyaschev

theorem     without una  combined complexity   i  satisfiability
h
dl liteh
bool kbs np complete   ii  satisfiability dl litehorn kbs p complete 
h
 iii  satisfiability dl liteh
krom dl litecore kbs nlogspace complete  results hold even kbs contain role disjointness   a symmetry   ir  reflexivity transitivity constraints  equalities inequalities 
hand  corollary     lemmas                derive
following 
theorem     without una  satisfiability instance checking dl liteh
bool kbs
 
 
ac data complexity  problems ac kbs contain role
disjointness   a symmetry  ir  reflexivity constraints inequalities  however 
logspace complete kbs may contain equalities  nlogspace complete
role transitivity constraints allowed 
note complexity results  corollary       theorems              
logics dl litehf
dl litehn
depend una 


section  analyze combined data complexity reasoning logics
 hf  
 hn  
form dl lite
dl lite
 as well fragments  without una 
obtained known results summarized table   page    
 hn  

    dl lite

  arbitrary number restrictions

following theorem shows interaction number restrictions
possibility identifying objects abox results higher complexity 
theorem     without una  satisfiability dl liten
core kbs  even without equality
inequality constraints  np hard combined data complexity 
proof proof reduction following variant  sat problemcalled monotone one in three  sat known np complete  garey   johnson        
given positive  cnf formula
 

n
 


ak   ak   ak    

k  

ak j one propositional variables a              decide whether
assignment variables aj exactly one variable true clauses
k
  encode problem language dl liten
core   need object names ai  
  k n    m  ck tk     k n  role names p   concept
names a    a    a    let abox containing following assertions 
s a i   a i            s ain    ani    s ani   a i   

  m 

s t    t             s tn    tn    s tn   t    
p  ck   tk   

  k n 

p  ck   akk j    aj  akk j   

  k n    j   

  

fithe dl lite family relations

let tbox following axioms 
a  v a   

a  v a   

a  v a   

  v  

  p v  

clearly   t     dl liten
core kb depend  so cover
combined data complexity   claim answer monotone one in three
 sat problem positive iff  t     satisfiable without una 
   suppose     t      define assignment truth values f
propositional variables taking a ai     iff  a i  i    t   i   aim show
a ak j     exactly one j            k    k n  j           
 cik    akk j  i   p   moreover   akk i  i     akk j  i    j  cik     p  i
 cik    tk  i   p   must  akk j  i    tk  i unique j            follows
functionality that    k n   a k j  i    t   i exactly one
j           
   let assignment satisfying monotone one in three  sat problem  take
ai  a ai       clearly  i  exists  otherwise a     f  construct
interpretation    i     taking 



  yk   z k     k n xki   a ai     f    m    k n  
cik   yk  tk  i   z k     k n 
 
xki   a ai     f 
 aki  i  
  m    k n 
z k   a ai     t 


    a i  i    a i  i              ain   i    ani  i      ani  i    a i  i        


p    cik    tk  i     cik    akk    i     cik    akk    i     cik    akk    i       k n  
readily checked     t     

q

fact  lower bound optimal 
 hn  

 hn   

theorem     without una  satisfiability dl liten
dl lite
  dl lite
kbs equality inequality constraints np complete combined data
complexity  core  krom  horn  bool  
proof lower bound immediate theorem      matching upper bound
 hn   
proved following non deterministic algorithm  given dl litebool
kb
k    t   a  
guess equivalence relation ob a  

select equivalence class ai   representative  say ai   replace every occurrence ai   ai  
fail equalities inequalities violated resulting aboxi e  
contains ai   ai ai aj      j 
  

fiartale  calvanese  kontchakov   zakharyaschev

otherwise  remove equality inequality constraints abox denote
result a   
 hn   

use np satisfiability checking algorithm dl litebool
kb k     t   a    consistent una 

decide whether

clearly  algorithm returns yes       k      respecting una 
construct model k  not necessarily respecting una  extending  
 
following interpretation object names  ai   aii   whenever ai representative
a   i coincides   symbols   conversely     k take
equivalence relation defined ai aj iff aii   aij   let   constructed
removing interpretations object names representatives
equivalence classes   follows   respects una      k    algorithm
returns yes 
q
 hf  

    dl lite

  functionality constraints
 hf   

let us consider dl litebool
fragments  following lemma shows
logics reasoning without una reduced polynomial time size
abox reasoning una 
 hf   

lemma     every dl litebool

kb k    t   a  equality inequality con hf   

straints  one construct polynomial time  a  dl litebool
kb k     t   a   
a  contains equalities inequalities k satisfiable without una iff k 
satisfiable una 
proof follows identifying aj ak mean replacing occurrence
ak aj   construct a  first identifying aj ak   aj ak a 
removing equality a  exhaustively applying following procedure
a 
  r v r ai   aj    r ai   ak   clet  a   distinct aj ak  
identify aj ak  recall functional r cannot transitive sub roles
thus clet  a  enough  
resulting abox contains ai   ai   ai   then  clearly  k satisfiable 
add a ai   a ai   abox  concept name a  finally  remove
inequalities abox denote result a    clear a 
computed polynomial time that  without una  k satisfiable iff k 
satisfiable  suffices show k  satisfiable without una iff satisfiable
una  implication    trivial 
   observe procedure ensures
e
qr a
  

r   v   r vt ob a   
 hn  

 see page    definitions   let k   dl litebool
kb provided lemma     
k    follows property proofs lemma      corollary     
  

fithe dl lite family relations

k   satisfiable without una  k    e satisfied first order model
constants interpreted domain element   k    e universal
first order sentence containing equality  satisfiable first order model
constants interpreted distinct elements  follows proofs lemma     
corollary      first order model unraveled model j k  
respecting una  lemma       j model k   
q
reduction cannot done better p  shown next theorem 
theorem     without una  satisfiability dl litef
core kbs  even without equality
inequality constraints  p hard combined data complexity 
proof proof reduction entailment problem horn cnf  as proof
theorem       let
 

n
 

ak   ak   ak  



p
 



al  

l  

k  

horn cnf formula  ak j al   one propositional variables
a            ak     ak     ak   distinct  k    k n  encode pk
complete problem    ai   language dl litef
core need object names t  ai  
  k n    m  fk gk     k n  role names p   q   
abox contains following assertions
s a i   a i            s an 
  ani    s ani   a i   


  m 

p  akk     fk    p  akk     gk    q gk   akk      q fk   akk     
 t  a l     

  k n 

  l p 

tbox asserts roles functional 
  p v  

  q v  

 s v



  v  

clearly  k    t   a  dl litef
core kb depend   claim
   aj iff  t    t  t  a j     satisfiable without una  show this  suffices
prove    aj iff k   nouna  t  a j   
   suppose    aj   derive aj using following inference rules 
   al   l    l p 
   ak      ak     k    k n     ak    
show k   nouna  t  a j   induction length derivation aj  
basis induction trivial  assume aj   ak        ak        ak     k 
  k n  k   nouna  t  a k      t  a k      suppose    k  since
 
 
functional   a k    i    a k    i   since functional   akk    i    akk    i   k    
  k   n  particular  k     k  then  since p functional  fki   gki   which 
 
 
functionality q   akk    i    akk    i   finally  since functional   akk    i    akk    i  
  

fiartale  calvanese  kontchakov   zakharyaschev

k       k   n  particular  k        thus      t  a j   therefore
k   nouna  t  a j   
   suppose     aj   assignment a    
a aj     f  construct interpretation taking



  xki   a ai     f    k n    z k   uk   vk     k n w  
 
xki   a ai     f 
 aki  i  
  k n   m 
z k   a ai     t 


ti   w     w  z      


    a i  i    a i  i              an 
 i    ani  i      ani  i    a i  i        

 
vk   a ak       f 
fki   uk gki  
  k n 
uk   a ak       t 


p     akk    i   fki      akk    i   gki       k n  


qi    gki    akk    i     fki    akk    i       k n  
readily checked    k      t  a j    k    nouna  t  a j   

q

result strengthens nlogspace lower bound instance checking
dl litef
core proved calvanese et al         
 hf  

 hf   

corollary     without una  satisfiability dl litef
dl lite
  dl lite
kbs   core  krom  horn   equalities inequalities p complete combined data complexity 
 hf  
 hf   
without una  satisfiability dl litef
kbs
bool   dl litebool dl litebool
equalities inequalities np complete combined complexity p complete data
complexity 

proof upper bounds follow lemma     corresponding upper bounds
una case  np lower bound combined complexity obvious polynomial
lower bounds follow theorem     
q
    query answering  data complexity
p conp upper bounds query answering without una follow results horn shiq  hustadt et al         eiter et al         shiq  ortiz et al        
      glimm et al          respectively  see discussion beginning section    
present following result 
theorem     without una  positive existential query answering dl liteh
horn kbs
role disjointness   a symmetry   ir  reflexivity constraints inequalities ac 
data complexity  problem logspace complete if  additionally  equalities
allowed kbs 
  

fithe dl lite family relations

proof proof follows lines proof theorem     uses observation
models without una give answers untangled counterparts 
precisely  let kb k     t     a    above  suppose consistent  let q  x 
positive existential query signature k    given k    lemma      provides
us kb k  easy see k dl liteh
horn kb extended inequality
constraints  following analogue lemma      allows us get rid
inequalities 
lemma      every tuple  a object names k    k    nouna q  a  iff    q  a 
untangled models k  respecting una  
proof    suppose k    nouna q  a  untangled model k  respects
una  lemma      view satisfiability k    ensures      holds 
   k  therefore     q  a  
   suppose      k    construct interpretation j   respecting una follows 
 
 
 
 
let j disjoint union ob a   define function h   j taking
 
 
h a    ai   ob a   h w    w  w   let


 
 
 
 
 
aj   a 
aj   u   h u  ai

p j    u  v     h x   h v   p  
object  concept role name a  a  p   clearly  j   respects una j      k   
follows h homomorphism 
lemma       model k domain j   coincides
j   symbols k       q  a   must j      q  a   since h
homomorphism       q  a   therefore  k    nouna q  a  required 
q
remaining part proof exactly theorem      since may assume
k dl liteh
horn kb containing inequality constraints  
logspace completeness case equalities follows lemma     
q

   conclusion
article  investigated boundaries extended dl lite family description
logics providing thorough comprehensive understanding interaction
various dl lite constructs impact computational complexity reasoning 
studied    different logics  classified according five mutually orthogonal features 
    presence absence role inclusion assertions      form allowed concept
inclusion assertions  distinguishing four main logical groups called core  krom  horn 
bool      form allowed numeric constraints  ranging none  global functionality constraints only  arbitrary number restrictions      presence absence
unique name assumption  and equalities inequalities object names 
assumption dropped       presence absence standard role constraints
role disjointness  role symmetry  asymmetry  reflexivity  irreflexivity transitivity  resulting logics  studied combined data complexity kb
satisfiability instance checking  well data complexity answering positive
existential queries 
  

fiartale  calvanese  kontchakov   zakharyaschev

query answering
  instance checking

conp
query answering

 
legend
satisfiability
combined complexity

with without una
role inclusions

f

n

exptime
np
p
nlogspace

una
role inclusions

f

una
role inclusions

conp
p
ac 

oo
l

n

instance checking
data complexity

b

ro

k

co

h


n

 



f

n

figure    complexity basic dl lite logics 
obtained tight complexity results illustrated figure    combined
complexity satisfiability represented height vertical dashed lines 
data complexity instance checking size color circle top lines
 recall satisfiability instance checking reducible complement
other   data complexity query answering core horn logics  shown
left hand side separating vertical plane  coincides data complexity
instance checking  krom bool logics  shown right hand side plane 
query answering always data complete conp  upper layer shows complexity
logics role inclusions  case depend whether adopt
una not  middle lower layers deal logics without role inclusions
una dropped adopted  respectively  layers  twelve
languages arranged     grid  one axis shows type concepts inclusions
allowed  horn  core  krom  bool   type number restrictions  none 
global functionality f arbitrary n    observations order 
una without role inclusions  number restrictions increase
complexity reasoning  depends form concept inclusions allowed 
hand  without form number restrictions  logics role
inclusions insensitive una  again  complexity determined
shape concept inclusions only 
either cases  instance checking ac  data complexity 
means problems first order rewritable 

  

fithe dl lite family relations

without una adopted without either disjunctions role inclusions  functionality
leads p completeness instance checking data complexity  suggests
reducibility datalog 
data complexity  difference core horn logics 
krom bool ones  means core krom logics
extended conjunctions left hand side concept inclusions free 
 hf  

 hn  

finally  logics dl lite
dl lite
 qualified  number restrictions role inclusions  whose interaction restricted conditions  a    a    
complexity reasoning always coincides complexity fragments dl litef

and  respectively  dl liten
without role inclusions  matter whether adopt una
not 
role disjointness  symmetry asymmetry constraints added
 hn  
 hf  
languages without changing complexity  fact  dl lite
dl lite
logics contain types constraints together role reflexivity irreflexivity  conjecture  ir reflexivity constraints added logics without
affecting complexity  however  extend dl lite logic role transitivity
constraints  combined complexity satisfiability remains same  instance
checking query answering become data hard nlogspace  addition
equality object nameswhich makes sense una droppedleads
increase membership ac  logspace completeness data complexity 
results remain unchanged 
list dl constructs considered paper far complete 
example  would interest analyze impact nominals  role chains boolean
operators roles computational behavior dl lite logics  another interesting
practically important problem investigate depth interaction various
constructs aim pushing restrictions  a    a    far possible 
one main ideas behind dl lite logics provide efficient access large
amounts data high level conceptual interface  supposed achieved
representing high level view information managed system dl lite
tbox   data stored relational database abox a  rewriting positive existential queries knowledge base  t   a  standard first order queries
database represented a  approach believed viable because  number
dl lite logics  query answering problem ac  data complexity  cf  theorems          figure    first order rewriting technique implemented
various system  notably quonto  acciarri et al         poggi et al       b  
query  relying ontology to relational mappings  data stored standard relational
database management system  owlgres  stocker   smith         access
abox stored postgres database  though  best knowledge  latter
implementation incomplete conjunctive query answering   noted  however 
size rewritten query substantially larger size original
query  cause problems even efficient database query engine 
positive existential query q tbox   two major sources high
complexity first order formula  q proof theorem       i  formulas
b  x  computing whether abox object instance concept b  and formulas
  

fiartale  calvanese  kontchakov   zakharyaschev

r dr computing whether objects outgoing r arrows instances b    ii 
 hn  
disjunction paths   graph gt   case dl litecore   size
 hn  
b  x  linear  t    dl litehorn become exponential  however  various
optimizations possible   size disjunction  ii  exponential number
non distinguished variables q  one way removing source  i  would extend
given database  abox  precomputing horn closure abox respect
tbox storing resulting data supplementary database  approach
advocated lutz et al         querying databases via description logic el 
could promising horn fragments expressive description logics
shiq  hustadt et al         hustadt  motik    sattler       containing dl litehf
horn
sub languagefor data complexity instance checking  hustadt et al        
      conjunctive query answering polynomial  eiter et al          disadvantage
using supplementary database necessity update every time abox
changed  would interesting investigate alternative approach dl lite logics
compare approach described above  another important problem
characterize queries disjunction  ii  represented formula
polynomial size 
unique name assumption replaced owl constructs sameas
differentfrom  i e       challenging problem investigate possible ways
dealing equality  inequality require special treatment shown
proof lemma        although reasoning equality logspace reducible reasoning without  cf  lemma       lose property first order rewritability 
computing equivalence classes may costly real world applications 
dl lite logics among examples dls usually complex
non standard reasoning problemssuch checking whether one ontology conservative
extension another one respect given signature  kontchakov et al         
computing minimal modules ontologies respect  kontchakov et al        
uniform interpolants  wang  wang  topor    pan       can supported practical
reasoning tools  however  first steps made direction 
research needed order include reasoning problems tools standard
owl toolkit  would interesting investigate unification problem dl lite
logics  baader   narendran        
finally  exist certain parallels horn logics dl lite family  el 
horn shiq first order language tuple equality generating dependencies 
tgds egds  used theory databases  see  e g   gottlob   nash        
investigations relationships logics may lead deeper understanding
role description logics play database framework 
acknowledgments
research partially supported fet project tones  thinking ontologies   funded within eu  th framework programme contract fp       
large scale integrating project  ip  ontorule  ontologies meet business rules
ontologies   funded ec ict call   fp  ict         contract number fp         thank referees constructive criticism  comments  suggestions 

  

fithe dl lite family relations

references
abiteboul  s   hull  r     vianu  v          foundations databases  addison wesley 
acciarri  a   calvanese  d   de giacomo  g   lembo  d   lenzerini  m   palmieri  m    
rosati  r          quonto  querying ontologies  proc    th nat  conf 
artificial intelligence  aaai        pp           
apt  k          logic programming  van leeuwen  j   ed    handbook theoretical
computer science  volume b  formal models sematics  pp          elsevier
mit press 
artale  a   calvanese  d   kontchakov  r     zakharyaschev  m       a   dl lite
light first order logic  proc    nd nat  conf  artificial intelligence
 aaai        pp         
artale  a   calvanese  d   kontchakov  r   ryzhikov  v     zakharyaschev  m       b  
reasoning extended er models  proc    th int  conf  conceptual
modeling  er        vol       lecture notes computer science  pp         
springer 
artale  a   cesarini  f     soda  g          describing database objects concept
language environment  ieee trans  knowledge data engineering            
    
artale  a   parent  c     spaccapietra  s          evolving objects temporal information
systems  ann  mathematics artificial intelligence          
baader  f     narendran  p          unification concepts terms description logics  j 
symbolic computation                 
baader  f   calvanese  d   mcguinness  d   nardi  d     patel schneider  p  f   eds   
        description logic handbook  theory  implementation applications 
cambridge university press    nd edition        
beeri  c   levy  a  y     rousset  m  c          rewriting queries using views description
logics  proc    th acm sigact sigmod sigart symp  principles
database systems  pods     pp        
berardi  d   calvanese  d     de giacomo  g          reasoning uml class diagrams 
artificial intelligence                  
bergamaschi  s     sartori  c          taxonomic reasoning conceptual design  acm
trans  database systems                 
boppana  r     sipser  m          complexity finite functions  van leeuwen  j 
 ed    handbook theoretical computer science  volume a  algorithms complexity  pp          elsevier mit press 
borger  e   gradel  e     gurevich  y          classical decision problem  perspectives
mathematical logic  springer 
borgida  a     brachman  r  j          conceptual modeling description logics 
baader et al   baader et al          chap      pp         

  

fiartale  calvanese  kontchakov   zakharyaschev

calvanese  d   de giacomo  g   lembo  d   lenzerini  m   poggi  a     rosati  r         
ontology based database access  proc    th ital  conf  database systems
 sebd        pp         
calvanese  d   de giacomo  g   lembo  d   lenzerini  m   poggi  a   rosati  r     ruzzi  m 
        data integration dl lite ontologies  schewe  k  d     thalheim 
b   eds    revised selected papers  rd int  workshop semantics data
knowledge bases  sdkb        vol       lecture notes computer science  pp 
      springer 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          dl lite 
tractable description logics ontologies  proc    th nat  conf  artificial
intelligence  aaai        pp         
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          data
complexity query answering description logics  proc    th int  conf 
principles knowledge representation reasoning  kr        pp         
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r       a   owl
model football leagues   proc   rd int  workshop owl  experiences
directions  owled        vol      ceur workshop proceedings 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r       b   tractable
reasoning efficient query answering description logics  dl lite family  j 
automated reasoning                 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r       a   inconsistency tolerance p p data integration  epistemic logic approach  information
systems                 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r       b   path based
identification constraints description logics  proc    th int  conf 
principles knowledge representation reasoning  kr        pp         
calvanese  d   de giacomo  g     lenzerini  m       a   description logics information
integration  kakas  a     sadri  f   eds    computational logic  logic programming beyond  essays honour robert a  kowalski  vol       lecture notes
computer science  pp        springer 
calvanese  d   de giacomo  g     lenzerini  m       b   framework ontology integration  cruz  i   decker  s   euzenat  j     mcguinness  d   eds    emerging
semantic web selected papers first semantic web working symposium 
pp          ios press 
calvanese  d   de giacomo  g   lenzerini  m   nardi  d     rosati  r       a   description
logic framework information integration  proc   th int  conf 
principles knowledge representation reasoning  kr     pp      
calvanese  d   lenzerini  m     nardi  d       b   description logics conceptual data
modeling  chomicki  j     saake  g   eds    logics databases information
systems  pp          kluwer academic publishers 
calvanese  d   lenzerini  m     nardi  d          unifying class based representation formalisms  j  artificial intelligence research             
  

fithe dl lite family relations

corona  c   ruzzi  m     savo  d  f          filling gap owl   ql
quonto  rowlkit  proc    nd int  workshop description logics
 dl        vol      ceur workshop proceedings 
cuenca grau  b   horrocks  i   kazakov  y     sattler  u          modular reuse ontologies  theory practice  j  artificial intelligence research             
decker  s   erdmann  m   fensel  d     studer  r          ontobroker  ontology based
access distributed semi structured information  meersman  r   tari  z  
  stevens  s   eds    database semantic  semantic issues multimedia systems 
chap      pp          kluwer academic publishers 
dolby  j   fokoue  a   kalyanpur  a   ma  l   schonberg  e   srinivas  k     sun  x         
scalable grounded conjunctive query evaluation large expressive knowledge
bases  proc   th int  semantic web conf   iswc        vol       lecture
notes computer science  pp          springer 
eiter  t   gottlob  g   ortiz  m     simkus  m          query answering description logic horn shiq  proc    th eur  conference logics artificial
intelligence  jelia        pp         
franconi  e     ng  g          i com tool intelligent conceptual modeling  proc 
 th int  workshop knowledge representation meets databases  krdb       
vol     ceur workshop proceedings  pp       
garey  m     johnson  d          computers intractability  guide theory
np completeness  w  h  freeman 
ghilardi  s   lutz  c     wolter  f          damage ontology  case conservative extensions description logics  doherty  p   mylopoulos  j     welty 
c   eds    proc    th int  conf  principles knowledge representation
reasoning  kr        pp         
glimm  b   horrocks  i   lutz  c     sattler  u          conjunctive query answering
description logic shiq  proc    th int  joint conf  artificial intelligence
 ijcai        pp         
goasdoue  f   lattes  v     rousset  m  c          use carin language
algorithms information integration  picsel system  int  j  cooperative
information systems                
gottlob  g     nash  a          efficient core computation data exchange  j 
acm              
hayes  p          rdf semantics  w c recommendation  http   www w  org tr 
rdf mt  
heflin  j     hendler  j          portrait semantic web action  ieee intelligent
systems               
heymans  s   ma  l   anicic  d   ma  z   steinmetz  n   pan  y   mei  j   fokoue  a  
kalyanpur  a   kershenbaum  a   schonberg  e   srinivas  k   feier  c   hench  g  
wetzstein  b     keller  u          ontology reasoning large data repositories 
hepp  m   de leenheer  p   de moor  a     sure  y   eds    ontology management 
  

fiartale  calvanese  kontchakov   zakharyaschev

semantic web  semantic web services  business applications  vol    semantic
web beyond computing human experience  pp         springer 
horrocks  i   patel schneider  p  f     van harmelen  f          shiq rdf
owl  making web ontology language  j  web semantics             
horrocks  i   sattler  u     tobies  s          practical reasoning expressive description logics  j  interest group pure applied logic                
hustadt  u   motik  b     sattler  u          reasoning description logics reduction
disjunctive datalog  j  automated reasoning                 
hustadt  u   motik  b     sattler  u          data complexity reasoning expressive
description logics  proc    th int  joint conf  artificial intelligence
 ijcai        pp         
immerman  n          descriptive complexity  springer 
klyne  g     carroll  j  j          resource description framework  rdf   concepts
abstract syntax  w c recommendation  http   www w  org tr rdf concepts  
kontchakov  r   pulina  l   sattler  u   schneider  t   selmer  p   wolter  f     zakharyaschev  m          minimal module extraction dl lite ontologies using
qbf solvers  proc    st int  joint conf  artificial intelligence  ijcai        pp         
kontchakov  r   wolter  f     zakharyaschev  m          tell difference
dl lite ontologies   proc    th int  conf  principles
knowledge representation reasoning  kr        pp         
kontchakov  r     zakharyaschev  m          dl lite role inclusions  domingue  j  
  anutariya  c   eds    proc   rd asian semantic web conf   aswc       
vol       lecture notes computer science  pp        springer 
kozen  d          theory computation  springer 
lenzerini  m          data integration  theoretical perspective  proc    st acm
sigact sigmod sigart symp  principles database systems  pods       
pp         
levy  a  y     rousset  m  c          combining horn rules description logics
carin  artificial intelligence                   
lutz  c   toman  d     wolter  f          conjunctive query answering el using
database system  proc   th int  workshop owl  experiences directions  owled       
mcguinness  d     wright  j  r          conceptual modelling configuration  description logic based approach  artificial intelligence engineering design  analysis 
manufacturing  special issue configuration             
meyer  t   lee  k     booth  r          knowledge integration description logics 
proc    th nat  conf  artificial intelligence  aaai        pp         
noy  n  f          semantic integration  survey ontology based approaches  sigmod
record               
  

fithe dl lite family relations

ortiz  m   calvanese  d     eiter  t          characterizing data complexity conjunctive
query answering expressive description logics  proc    st nat  conf 
artificial intelligence  aaai        pp         
ortiz  m   calvanese  d     eiter  t          data complexity query answering expressive description logics via tableaux  j  automated reasoning               
papadimitriou  c          computational complexity  addison wesley 
perez urbina  h   motik  b     horrocks  i          comparison query rewriting
techniques dl lite  proc    nd int  workshop description logics
 dl        vol      ceur workshop proceedings 
poggi  a   lembo  d   calvanese  d   de giacomo  g   lenzerini  m     rosati  r       a  
linking data ontologies  j  data semantics  x         
poggi  a   rodriguez  m     ruzzi  m       b   ontology based database access
dig mastro obda plugin protege  clark  k     patel schneider 
p  f   eds    proc   th int  workshop owl  experiences directions
 owled      dc  
rautenberg  w          concise introduction mathematical logic  springer 
reingold  o          undirected connectivity log space  j  acm         
schaerf  a          complexity instance checking problem concept languages
existential quantification  j  intelligent information systems            
schmidt schau  m     smolka  g          attributive concept descriptions complements  artificial intelligence              
stocker  m     smith  m          owlgres  scalable owl reasoner  proc   th
int  workshop owl  experiences directions  owled       
tobies  s          complexity results practical algorithms logics knowledge representation  ph d  thesis  lufg theoretical computer science  rwth aachen  germany 
toman  d     weddell  g  e          interaction inverse features pathfunctional dependencies description logics  proc    th int  joint conf 
artificial intelligence  ijcai        pp         
toman  d     weddell  g  e          keys functional dependencies first class
citizens description logics  j  automated reasoning                  
vardi  m          complexity relational query languages  extended abstract  
proc    th acm sigact symp  theory computing  stoc     pp 
       
vollmer  h          introduction circuit complexity  uniform approach  springer 
wang  z   wang  k   topor  r  w     pan  j  z          forgetting concepts dl lite 
bechhofer  s   hauswirth  m   hoffmann  j     koubarakis  m   eds    proc 
 th eur  semantic web conf   eswc        vol       lecture notes computer
science  pp          springer 

  


