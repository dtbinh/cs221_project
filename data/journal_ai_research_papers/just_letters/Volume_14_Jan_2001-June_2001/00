journal artificial intelligence research               

submitted       published     

reachability  relevance  resolution planning
satisfiability approach
ronen i  brafman

brafman cs bgu ac il

department computer science  ben gurion university
p o box      beer sheva        israel

abstract

recent years  growing awareness importance reachability
relevance based pruning techniques planning  little work specifically targets
techniques  paper  compare ability two classes algorithms propagate
discover reachability relevance constraints classical planning problems  first
class algorithms operates sat encoded planning problems obtained using linear
graphplan encoding schemes  applies unit propagation general resolution steps  involving larger clauses  plan encodings  second class operates
plan level contains two families pruning algorithms  reachable k relevantk   reachable k provides coherent description number existing forward pruning
techniques used numerous algorithms  relevant k captures different grades backward pruning  results shed light ability different plan encoding schemes
propagate information forward backward relative merit plan level
sat level pruning methods 
   introduction

success planning satisfiability  pas  approach  kautz   selman             
led various attempts refine initial methods used improve understanding performance  particular  various methods generating formulas
planning instances compared  ernst  millstein    weld         various systematic alternatives original stochastic method examined  e g   bayardo
  schrag        li   anbulagan         still  many issues surrounding approach
poorly understood  particular  little known uence encoding method
performance 
concentrating two encoding methods proposed kautz selman        
linear graphplan based encodings  examine uence ability
propagate reachability relevance information via unit propagation and  generally 
k  clause resolution  comparing pruning ability techniques
class algorithms reachability relevance analysis operate original
problem formulation  reachable k relevant k  reachable k simplified variant
similar algorithm state pruning markov decision processes  boutilier  brafman   
geib         relevant k natural counterpart used relevance analysis 
algorithms provide coherent framework discussing different grades reachability
relevance based pruning methods appear literature 
work motivated growing role forward backward pruning methods
play current planning algorithms important role propagation techniques

c      ai access foundation morgan kaufmann publishers  rights reserved 

fibrafman

sat solvers used planning satisfiability approach  unit propagation plays
central role davis putnam algorithm  davis   putman        many
offsprings  e g   crawford   auton        freeman        gomes  selman    kautz       
li   anbulagan        used preprocessing step stochastic methods
applied  moreover  limited form binary propagation used crawford s compact
program simplifying cnf formulas utilized blackbox planner  kautz
  selman         results shed light relationship pruning
techniques 
paper organized follows  section   provides background material  describing
basic ideas pas framework graphplan algorithm  section   
discuss reachable k   algorithm performing reachability analysis  compare
ability prune possible actions k clause resolution  section   describe
relevant k similar reachable k applied relevance analysis  again 
compare methods based resolution  section   empirically compare results
various methods k         conclude discussion future related work
section    proofs appear appendix  main arguments described
body paper 
   background

graphplan algorithm  blum   furst        satplan algorithm  kautz
  selman        profoundly altered direction research within planning
community  two main concepts studied paper  reachability analysis plan
encodings  become central current planning research thanks planners 
brie discuss planners  particular  aspects pertaining topic 

    reachability analysis graphplan
purpose reachability analysis discover unreachable states world
infeasible actions  i e   actions cannot performed course successful plan 
discovering actions ahead time  reduce space needs searched
find valid plan  principle  full edged reachability analysis requires forward search
space possible states  expensive operation  instead  opt
sound  incomplete methods  methods discover actions
ruled out  however  action rule infeasible need considered
searching plan 
graphplan planner provides good example utility approximate reachability analysis  graphplan two main stages  first stage  approximate reachability analysis conducted  yielding data structure called planning graph
represents sound  incomplete  approximation set states reachable
initial state  second stage  graphplan searches plan structure 
graphplan s planning graph construction algorithm presents particularly good tradeoff
computational complexity pruning power  utility pruning search
space attested planner s good performance 
planning graph construction algorithm viewed generating list annotated sets  odd elements list contain sets propositions  even elements
 

fireachability  relevance  resolution

list contain sets actions  set annotated mutual exclusion constraints members  intuitively  action set contains list actions could
performed step concurrent action plan  i e   plan allowing concurrent
execution actions interfere other   proposition set contains
propositions could hold    sets concurrent  actions performed 
mutual exclusion constraints circumscribe sets indicating certain pairs
actions propositions cannot occur time particular stage  hence 
propositions p  q appear proposition set  possible  or accurately
  algorithm rule possibility  i step plan applied initial
state could lead world p and or q hold  however  p q marked
mutually exclusive know p q cannot hold together i step plan
performed 
sets constructed follows  first proposition set contains propositions
hold initial state  first action set contains actions performed
initial state  general  set propositions contains effects actions
i   action set  action set contains actions whose preconditions appear
i   set propositions  provided preconditions marked mutually
exclusive  mutual exclusion constraints added follows  two actions marked
mutually exclusive action set preconditions marked mutually exclusive
i     clearly  preconditions actions cannot hold time
point  cannot perform actions together time point  another reason
marking actions mutually exclusive con ict  is  one action destroys
precondition effect action  two propositions proposition set
marked mutually exclusive pairs actions i   action set
effects mutually exclusive  case  way us achieve
propositions together stage 
initial construction planning graph terminated goal propositions
appear last proposition set  point  graphplan performs form regressionbased search planning graph structure  search fails  planning graph
extended one additional layer actions one additional layer propositions
searched again  details  see article blum furst        
th

th

th

th

th

th

th

th

th

th

th

th

    planning satisfiability approach
planning satisfiability approach  pas short   works follows  given planning
problem bound n size plan  plan encoder generates propositional
formula conjunctive normal form  formula following property  satisfiable
iff planning problem solution n time steps  intuitively  formula
composed propositions describing state world throughout execution
n step plan 
propositional language top formula defined contains proposition
possible aspect world time point  example  suppose looking
blocks  world domain states described using clear relations 
case  pair blocks x  y  time point   n shall introduce
proposition pon    corresponds x top time t  similarly 
x y t

 

fibrafman

every block x time point   n  shall introduce proposition pclear   
corresponds x clear time t 
truth assignment language described viewed describing state
world execution n step plan  instance  pon     assigned
true   block top block b time    course  truth assignments
language would correspond anything resembling true state world
execution actual plan  example  on a b  on b a  could
assigned true   goal encoding scheme generate formula
assignment satisfying formula correspond true state world
execution actual plan achieves desired goal  axiom formula
places constraint value propositions combined effect
constraints ensure resulting formula precisely desired truth
assignments  example  one type axiom conjunction propositions
corresponding initial state  truth assignment satisfying axiom must ensure
propositions hold time    another class axioms could state
action performed time world time   must satisfy preconditions
a  next sections discuss two central plan encodings detail 
appropriate formula generated  simplified using various well
known techniques  particular  simplifiers employ unit resolution step  genesereth
  nilsson         unit resolution  also known unit propagation   works follows 
satisfy cnf formula  must satisfy clauses  particular  one
clauses contains single literal  such clause known unit clause   immediately
know variable appearing clause must assigned appropriate value 
clause containing literal satisfied now  removed
formula  clause c containing negation literal resolved
unit clause  resulting clause  which smaller c  replace c  example 
suppose formula  p      q   p     r   p   first disjunct   p  unit clause 
hence  p must assigned true   makes third clause   r   p   satisfied  second
clause resolved first clause  replace   q    p    q  
new unit clause    q   proposition q must assigned value false  
additional clauses containing q  q  could remove them  simplify them 
appropriate 
simplification  apply favorite algorithm finding satisfying assignments 
one attained  decoder used obtain actual plan solution 
find satisfying assignment  increase value n  the size plan  
try again 
finally  note blackbox planner  kautz   selman        combines pas
graphplan s reachability analysis  constructs planning graph  uses
generate particular plan encoding 
x t

a b 

   reachability resolution

reachability relevance analysis form essential part successful modern planning
algorithms  notable example reachability analysis graphplan s planning
graph  blum   furst         many recent planners employ either reachability analysis
 

fireachability  relevance  resolution

 e g   bonet  loerincs    geffner         relevance analysis  e g   mcdermoot        nebel 
dimopoulos    koehler          kambhampati  parker    lambrecht        
importance reachability relevance analysis noted context decisiontheoretic planning well  example  boutilier dearden        employ relevance
analysis reduce state space  boutilier  brafman  geib        describe
general method reachability analysis mdps  below  discuss method
simplified form suitable classical planning problems described using strips representation language  fikes   nilsson         section    present counterpart
method performing relevance analysis relate algorithms k clause resolution
context sat encoded planning problems 

    propagating reachability information
reachable k  boutilier  brafman    geib        algorithm estimating states
reachable given initial state  formulated  quite general applies domains non deterministic actions conditional effects  figure    present
simplified version algorithm  reachable k   deals deterministic  unconditional actions represented strips representation language  prolog implementation
reachable k available www cs bgu ac il  pdm 
important reason interest reachable k similarity uential planning graph construction graphplan planner  blum   furst        
fact  generalizes ideas behind graphplan s planning graph  equivalent
reachable    use denote set actions feasible steps initial state 

denote corresponding set propositions  c denote constraints
propositions  fp            p g   c propositions cannot co occur

steps  c denotes similar constraints actions  here    fl  p g  l used
restrict attention linear action sequences  p used allow concurrent
non con icting actions  i e   actions destroy others  effects preconditions
whose preconditions constrained co occur   course  k     sets


c c empty     actually  defined  c
empty even
k      plays real part algorithm  ignored   finally  note
description  set possible actions contains actions form noop l  
l literal 
k      represent propositional action levels graphplan s
planning graph  c c hold respective mutual exclusion constraints 
stated termination condition reachable k  one formulated
based content index itself  pas framework  number
time steps fixed  one would opt second alternative  reachable k gives us sets
actions propositions      could occur performance j actions  or
j sets concurrently non con icting actions  initial state  easy see
reachable k sound following sense 














l








p






j

j

theorem   set propositions actions excluded reachable k time j

feasible plan which  time j   propositions hold or  respectively 
actions appear 
 

fibrafman

  literals hold initial state 



s 



c s 

  fg 

  actions whose preconditions s   
c al
    ffai   aj gjai   aj   a       j  neither ai aj noops aj noop whose effect
destroyed ai g 
c ap   ffai   aj gjai   aj   a       j  ai deletes precondition effect aj g 


a 

 

define si   ai inductively follows 
  literals appear effects ai    
c si   l tuples literals  l k   appearing si subset set
actions ai   literals appearing among effects  appears c ai  
 where   fl  p g appropriate  




  actions whose preconditions appear si subset preconditions appears
c si  
c al
  ffal   aj gjal   aj   ai   l    j  neither al aj noops  aj noop whose effect
destroyed al g 
c api   ffaj            ajl gjl k  aj            ajl   ai   jm    jn    n  either     ajm
deletes precondition effect ajn    n     subset union
preconditions aj            ajl appears c si g 




figure    reachable k algorithm
sometimes  actions executed particular time point p holds
 p effect  case  ignore noop p  action  part
useful plan   however  formulated  p appear reachable k  s next level 
denote reachable  k variant noop p  appear case 
computational complexity reachable k o njajjlj e   njljjaj    n
number levels generate  jaj number possible actions  jlj size
propositional language used  e maximal number actions particular
shared effect  detailed explanation appears appendix b 
example  illustrate parallel action version reachable k  use following
planning domain  four propositions  p    p    p    p    intuitively  think
representing binary counter   bits    actions 
increases counter one different states  domain single non noop
action applicable state  a  changes least significant bit  a  changes next
bit  a  changes third bit  a  changes significant bit  applicable
first   bits one  specifically actions are 
k

k

k



   planning algorithms  e g   pas approach  may necessary leave noops in 

 

fireachability  relevance  resolution

a 

precondition 

 

a 

precondition 

p 

a 

precondition 

p

p

a 

precondition 

p

p

p 

  effect 

p 

 

       effect          
              effect                 
                  effect                   
p

p

p

p

p

p

p

p

p

p
p

p

p 

 

compare reachable   reachable   using initial state   p    p    p    p   
corresponds binary representation    concentrate  more interesting 
parallel action version algorithm  shall mention noops explicitly obvious
mutual exclusion constraints propositions negations 
context reachable    c c empty  practical purpose 
start s    f p     p     p     p  g  action affecting first bit applicable 
a    fa  g  and relevant noops   s    fp     p     p     p     p  g 
preconditions a  a  appear s    a    fa    a  g  consequently
s    fp     p    p     p     p     p  g  now  apply a    a    fa    a    a  g 
s    fp     p    p     p    p     p     p  g  finally  stage preconditions a  appear
well  a    fa    a    a    a  g 
next  consider reachable    again  s    f p     p     p     p  g  c s  empty  a   
fa  g  next step have  s    fp    p     p    p    p g  interesting constraints
c s    a    fa    a  g  however  c contains  a    a     interfering
actions  s    fp     p    p     p    p     p     p  g  case k      however  c s  contains
 p    p     follows fact actions a  capable producing p 
a  noop p     action a  capable producing p  a    a  interferes
a  noop p    therefore  c s  contains  p    p     a  applicable
stage  hence  a    fa    a  g  one action less set a  reachable   s    s    fp     p    p     p    p     p     p  g  however  c s  contain  p    p   
 because noop p   used achieve p    con ict with  e g   noop p    
therefore  a    fa    a    a  g 
see k     improves ability prune k      suppose s   
fp    p    p    p  g  i e   counter s value       consider k     first 
a    a  s    f p   p    p    p     p    p     p  g   p    p      p     p       p    p   
 p    p    c s    mutual exclusion relations stems fact a 
mutually exclusive noop p   noop p     therefore  a    fa    a  g 
s    s    f p   p    p    p     p    p     p  g  c s  contains  p    p    only 
a    fa    a    a  g  now  c s  empty  a    fa    a    a    a  g  however  k     
c s  contains ternary constraint  p    p    p     ternary constraint remains c s 
well  c s    c s  k      a     a   






    k clause resolution reachability
 clause resolution  or propagation  refers resolution pairs clauses one whose
length k most  k     variant  i e   unit propagation  integral part
major algorithms generating satisfying assignments 
wish compare type reachability information derived performing k clause
resolution sat encoded planning problems  information obtained running
k

 

fibrafman

reachable k algorithm  reachability information mean constraints set
actions possible time point constraints world states  in form of  e g   sets
unreachable propositions k tuples propositions   hence  example  constraint
form a t    a   t  implies one actions a  must appear time
plan  constraint form  a t    a  t  implies one actions a  must
appear plan  similar constraints propositions holding time point
derived  principle  constraints reduce search space could help us attain
solution quickly  however  effectiveness deduced constraints depends
precise algorithm used  moreover  comparison large class constraints
seems quite dicult  therefore  article concentrate concrete class
reachability information form  a t   i e   action cannot performed
state reachable via steps  powerful constraint utilized effectively
almost planners  perhaps exception partial order planners   consequently 
shall say algorithm alg  generates reachability information another
algorithm alg  whenever alg  able determine action cannot performed
time t  alg  able reach conclusion well  addition 
conclusions alg  reach alg  cannot reach  hence  alg  generates
strict superset constraints actions  of type interested in  generated
algorithm  note mean alg  better alg 
every instance  always good  cases better  section
shall compare pruning ability two reachable k variants two encoding
methods discussed kautz selman          linear encoding graphplan
encoding 
      linear plan encoding

linear plan encoding  kautz   selman        simple natural method
translating planning problem formula satisfiable iff valid plan
length n  for given n   clauses linear plan encoding fall following
classes 
   action implies preconditions prior execution 
   action implies effects following execution 
   action affect proposition  frame axioms  
   least one action time point 
   one action time point 
explicit frame axioms  noops needed linear encoding  as
opposed graphplan encoding   addition  formula contains unary clauses
describing initial goal states  however  purpose analyzing reachability
effects  exclude description goal state  which plays role relevance analysis  
consider mechanism resolution yield reachability information  given
propositions hold initial state  derive negation actions whose
   third  state based  encoding method cannot generated automatically 

 

fireachability  relevance  resolution

preconditions hold using unit propagation axioms class    propagating
unit clauses appropriate instance axiom class    obtain disjunction
actions executed first time point  far  identical
reachable  k provides  propagate information forward  resolve
action disjunctions axioms class      this  however  requires binary resolution
 discussed below   hence  except unlikely case single action possible 
derive using unit propagation alone  reachable    
hand  provide us list possible effects actions possibly
prune future actions whose preconditions appear list  conclude 
lemma   context linear encoding  reachable    yields reachability in 

formation unit propagation 

example  consider blocks  world domain single action schema move object source 

destination    preconditions are  on object source   clear object   clear destination 
effects are  on object destination   clear source    on object source     clear
 destination   except destination table always clear   k
stacks blocks initially  k  actions performed initial state  i e   moving block
top stack top another stack table   discovered
algorithms  particular  unit propagation yield disjunction actions 
know blocks   blocks top cannot participate
second move action  reachable   find due fact
clear  suppose one block  initially feasible move actions participate
frame axiom form move o s d   clear a        clear a      which  clausal
form  move o s d  clear a        clear a      resolving  clear a     
 move o s d   clear a      could deduce  clear a      could rule
actions precondition  restricted unit propagation 
requires deducing move o s d  initially feasible action  cannot make
deduction 
propagated information forward using axioms class     used binary
resolution  as discussed lemma     set disjunctions possible
effects  including frame effects  initially allowable actions  number
disjuncts o e    e maximal number effects action
number actions executed initially  cases  disjunctions could
contain single literal  e g   initially allowable actions leave proposition
unchanged  one disjunctions contains literals negations
action s precondition  deduce negation action resolving
axioms class   
example  example considered would generate disjunction form
move o    s    d      move o    s    d      move o    s    d     containing instances move
action time   whose negations deduced  discussed above 
actions  obtain clause form  move o        clear a      resolve
binary clauses clause above  obtain unary clause  clear a     








   fact  since use plain strips  need three action schemas  one moving block block  one
moving block table  one moving block table  however 
affect analysis  stick single move action following examples 

 

fibrafman

used conjunction class   axioms deduce negations step   actions
whose preconditions include clear a     
saw  effect disjunctions discussed allow us rule certain propositions combinations propositions  analogous mutual exclusion constraints 
mutual exclusion constraints used prune actions  example  deduce  p       p p preconditions action a  deduce  a
using binary resolution  by resolving precondition axioms disjunction   however 
show below  binary resolution trouble propagating even binary mutual exclusion
constraints forward  believe generally true  i e   k clause resolution
trouble propagating k ary constraints  show following 




lemma   reachable   binary resolution  in case linear encoding  incomparable 

prove providing two examples  one reachable   able prune
action binary resolution cannot  one converse hold 
first  consider   bit counter initial value       i e    p    p     p     p     four steps obtain following  s    f p    p     p    p     p    p     p  g c s   
f p    p      p    p  g  therefore  a    fa    a    a  g  implies s    s    claim
 p    p      c s  well  means a     a    see this  consider pairs
actions p  p  effects  are   a    a      a    noop p      noop p     a    
 noop p    noop p       a    a    pair real actions  always mutually exclusive
linear encoding  preconditions  a    noop p    mutually exclusive according
c s    preconditions  noop p    noop p     finally   noop p    a   
interfering actions  conclude  p    p      c s  a     a   
run binary resolution procedure linear encoding problem 
could deduce a     a    stems fact ternary resolution needed
propagate mutual exclusion p  p    recall obtain mutual exclusion
constraints resolving disjunction actions ruled out 
case  time   would following disjunction  a     a     a     noop  p    
  noop    p    goal deduce  p      p   using  p      p   various axioms 
this  try deduce either  p     p   actions disjunction 
easy deduce  p   a    p   a     however  believe impossible
deduce  p      p   a   noops   reason
deduction involves use frame axioms  ternary  know that  e g    p  
holds  apply unit resolution frame axioms obtain binary clause  however 
know  p      p    resolve frame axiom remain
ternary clause  get desired result must resolve two ternary clauses 
finally  let us see example use binary resolution derive ternary
constraint  definition  reachable   cannot derive constraints  suppose
initial state  p   q   r  four actions  a  p  r effects  a  q  r effects 

a  p  q effects  a  p  q  r preconditions  using reachable    deduce
a   a   a  possible time    get possible effects p  q  r   p   q   r  recall
   fact deduction impossible verified  hypothesizing reason
it 

  

fireachability  relevance  resolution

must include noop actions reachable k order capture frame effects  
strict subset p  q  r appear set constraints c s    since deal binary
constraints only  set fp  q  rg appear c s    therefore  consider a 
possible time    although  fact  impossible  using binary resolution  would
obtained constraint  p    q    r  referring time    would enabled
us deduce a  impossible time   
      graphplan encoding

graphplan encoding differs linear encoding ability consider multiple
concurrent  non interfering  actions  allowing one obtain shorter plans which  turn 
reduce search space size  constructs following sets clauses 
   action implies preconditions 
   effect implies one actions effect 
   least one action time point 
   two con icting actions cannot occur together 
besides obvious ability consider multiple parallel  non interfering  actions  important difference graphplan linear encoding axiom class    referred
 ernst et al         explanatory frame axioms   clauses class contain
positive occurrences action literals negative occurrences state literals 
linear case  using unit propagation infer actions cannot
applied initial state  using axioms class    propagate information forward  deducing negation effects cannot produced initially allowable
actions  information enables us exclude actions whose preconditions cannot produced  forward propagation essentially identical reachable    informally
conclude 

lemma   context

encoding  unit propagation reachable  
yield reachability information  ignore explicit constraints appearing
axiom class    use constraints  unit propagation yield reachability
information 
graphplan

precise carefully define notion reachability constraints context
graphplan encoding  example  graphplan encoding derive
constraint says one group actions must appear plan  constraint
necessarily rule action graphplan encoding permits multiple
actions time point   however  linear encoding constraint
immediately rule actions single action allowed time
point  mentioned earlier  paper concentrate strict exclusion constraints
   however  actions interfere cannot occur concurrently  know action
occur deduce action interferes occur  precisely
class   axioms enter picture 
 

  

fibrafman

lead immediate reduction search space ruling need certain
actions certain time points 
k      mechanism remains same  now  axioms class   play
prominent role use exclude actions cases
before  however  problem propagating mutual exclusion constraints forward
linear encoding reappear here  consequently  k clause resolution
context graphplan encoding reachable k incomparable 
   relevance resolution

relevance analysis complex task performed various degrees 
instance  considering last action level  one exclude actions produce
literal goal  however  actions producing goal literal irrelevant 
example  consider blocks  world planning problem color blocks
specified part goal  observed nebel  dimopoulos  koehler        
paint block action still  intuitively  irrelevant initial final colors blocks
same  however  goal literal effect 
section  formulate algorithm relevance analysis  called relevant k  
relevant k perform deeper relevance analysis needed determine
paint block action irrelevant example  rather  relevant k similar
motivation form reachable k   similar soundness property  relevant k
prunes search space excluding states goal reachable within
given number steps actions useful achieving goal state within
given number steps 
relevant   similar number existing components existing planners 
mcdermott s greedy regression graph  mcdermoot        nebel  dimopoulos 
koehler s and or trees  nebel et al          relevant k generalizes ideas arbitrary
levels interactions  taking consideration mutual exclusion constraints relevant
states must satisfy  relevant k slightly complicated reachable k
strips formalism allows incomplete description goal states  propagating partial information raises diculties  naturally  goal state partially specified 
fewer constraints available start with  fewer constraints derived 
algorithm described figure    aware similar  general formulation
ideas  therefore  worthwhile going central points algorithm 
concentrating interesting complex case parallel actions allowed  however  this  point important assumption shall make
action representation used  proposition symbol shall appear preconditions effects action  restriction dicult enforce 
strips based domain representation transformed description
assumptions satisfied  example  p precondition action appear
effect a  simply add effect  know must hold
action executed  p appears effect neither p  p appear
preconditions a  decompose two versions action  one p
precondition one  p precondition  note worst case 
transformation cause exponential blow up number actions 
  

fireachability  relevance  resolution

r contains actions useful safe w r t  goal 
a  contains ar  noops safe w r t  goal 


a 

contains pairs interfering actions a   
define ri   si   ari   ai inductively follows 
ri union preconditions actions ari    


c a 





union preconditions actions ai    

contains sets literals si   js j k set actions ai  
whose preconditions contain case   c ai    
ari contains actions useful w r t  ri subset effects contained
c si  
ai contains ari noops useful w r t  si  
c ai contains action sets ai either     contains two interfering
actions      subset set effects c si  



cs

action descriptions must contain set propositional symbols precondition
effect lists 

figure    relevant k algorithm
k     algorithm quite simple  and identical parallel linear cases  
case  ignore sets   c   c  as degenerate  consider
sets r only  starting goal literals  stage set
literals construct next set actions  action set contains actions
effect current literal set  however  goal effects action
part preconditions  ignore action irrelevant  next  new literal set
constructed  containing set preconditions current set actions  repeat
process new set 
k      picture becomes bit complicated  start set
relevant actions    actions achieve one desired literals 
particular  a  contains actions one goal literals effect  but
precondition   goal partially specified  literals part could hold
previous time step  hence  include appropriate noop actions larger set 
  contains noops destroy needed propositions  subset
actions mutually exclusive contains interfering actions actions whose
effects mutually exclusive  given set     generate set r   includes
preconditions     set defined set preconditions actions  
goal completely specified state  sets r sets
identical  need distinguish them 








r




r


r

r






r


r












  



r


fibrafman

facilitate description relevant k algorithm  would useful add
simple definitions  first  wish revise definition interfering actions
context relevant k algorithm  say actions a  a  interfere
effect con icts precondition effect a   and beyond
previous definition term  preconditions inconsistent  action useful
w r t   with respect to  literal l noop action preserving l l effect 
precondition  a  useful w r t  set literals useful w r t  one
set s elements  set actions safe w r t  set literals action
effect negates element  
relevant k embodies intuitions described above  note increased index corresponds points earlier time  definition sets   r     quite intuitive 
contains preconditions actions previous   r contains preconditions actions   contains actions useful  mutually exclusive 
effects  defined much   w r t  rather r   set c contains
literals mutually exclusive particular point  set l literals mutually
exclusive set relevant actions l among preconditions mutually
exclusive  set c contains mutually exclusive sets actions  set actions
mutually exclusive contains interfering actions set effects mutually
exclusive 
example  order illustrate relevant k algorithm  shall use counter
example used section      starting three bit counter using propositions 
p    p    p    actions a    a    a  change value single bit     
provided values lower bits   
start final state f p     p    p  g k      since final state fully
specified  distinction sets r   a 
contains action a  three relevant noops  s  contains fp     p    p     p    p     p  g 
a  contains a    a    a    appropriate noops  remaining sets look
same 
k      a  s  k     case  however  c s  contains   p    p   
 p     p     implies a  cannot applied  hence  a  contains a  a   
a    unlike case k      action a  would introduced next step 
next  consider partially specified goal  fp    p  g k      a   
fa    noop p    noop p  g a  p  effect  a  destroy p   whereas
a    example  effect goal  a  would contain a  well
noops p   p    r    fp    p     p    p  g s    fp     p    p     p    p  g  next  a 
contains fa    a  g  etc 
finally  suppose four bits  goal state f p     p    p    p  g  i e  
counter s bit value        k      a  contains a  s    fp     p    p     p    p     p    p  g 
however  c s  contains pairs   p     p       p     p    others  a  contains a    a 
noops  s    s    now  c s  contain   p     p     contain
  p     p     though  precludes action a  a    next step 
s    s    s    c s  longer contains   p     p     implies
add a  a  effects longer mutually exclusive  overall 
a    fa  g  a    fa    a  g  a    fa    a    a  g  a    fa    a    a    a  g  however  k     










r


r




r


r
















r




r

r

r

  

fireachability  relevance  resolution

would still mutual exclusion constraint   p     p     p     would
allow us add a    hence  k      a    fa    a    a  g 
prove following soundness results 
c s 

theorem   let

state goal reachable using m step plan
 where step contain number non interfering actions       set
literals satisfied subset   subset c       exists
m step plan reaching goal set actions plan
v steps last subset c  






v

v

corollary theorem is 

corollary   initial state goal reachable minimal  in
number operators  plan p   a          a    where steps numbered backwards 
reaching goal s  a  c contain subset a   










complexity relevant k o jaj jlj   jlj
jaj   jaj number
actions  jlj number proposition language  maximal number
preconditions action  details  see appendix b 
compare amount relevance information propagated backwards
using k clause resolution goal literals opposed relevant k   consider unit
propagation first  context linear encoding  see actions destroy
goal condition ruled out  however  actions irrelevant
produce irrelevant effects pruned   hand  relevant   prunes
actions destroy goal literal actions simply irrelevant 
slightly degenerate case actions one destroy goal proposition 
case  using unit propagation able deduce previous state  consequently 
have 
k

k

k
mp

p

lemma   context linear encoding  unless single safe  final action 

unit propagation yields less relevance information relevant   

context graphplan encoding situation often worse  unit propagation prunes even less linear encoding  goal propositions appear
class    effect  axioms  propagating axioms  obtain disjunctions
positive action propositions explaining particular goal proposition  assume
literals one explanation  see new unit clauses emerge  consequently  prune nothing 
example  consider blocks  world domain again  suppose three
blocks a b  c  goal on a b   clearly  action moves block c
moves another block top block c irrelevant last action  consider
graphplan encoding  unit clause on a b t   where last
time point   resolve effect axiom lists possible causes
on a b t   aside noop action  actions moving c b
   general  proving action ruled means shown models  i e  
plans  action appear  cannot expect able irrelevant action
since could possibly inserted plan without affecting it 

  

fibrafman

moving table b  yields new ternary clause additional unit
clauses  axioms on a b t  appears negated 
notice means excluding actions destroy one goal literals 
example  goal clear a t   would want action move b c a t   
last action  however  above  deduce clear a t  is  move b a c t   move b a table t     move c a b t    move c a table t     noop clear a      
could use binary resolution stage  could deduce negation action
effect  clear a t   action would mutually exclusive
five actions 
goal literal l single explanation must noop action  which implies
 real  operator effect   case  would able deduce
noop action must hold  using precondition axioms  would deduce
l must hold previous step  using mutex axioms  class    could deduce
negation action destroys l  however  cannot deduce negation
action interact l  whether simply irrelevant destroys
goal literal 
example  consider domain rocket domain  rocket fuel 
action fueling rocket  suppose rocket fuel goal
state  hence  fuel t  holds  since explanation axiom fuel binary clause  i e  
 fuel t    noop fuel t      resolving axiom fact fuel t   derive new
unit clause noop fuel t      using precondition axioms  derive fuel t    
using mutex axiom  derive action fly t     one whose effects
 fuel t     notice  though  cannot deduce negation action
interact proposition fuel  whether irrelevant  example  fuel
proposition goal  action loading rocket 
affect value proposition fuel need considered final action
plan  however  before  way deducing  load t    
action produce fuel reasoning would apply step 
able deduce fact fuel holds time point plan 
using fact  able prune actions  fuel precondition 
relevant   able so   fuel precondition effect
relevant point  considered relevant action  

lemma   context

encoding  action changing value every literal  unit propagation yields less relevance information
relevant   
graphplan

actual values appears section    particular  examples looked at 
graphplan encoding could prune action  follows  quite typical 
fact domains  facts hold final state achieved
number actions  hence  unit propagation deduce disjunctions possible
   course  particular domain action whose precondition  fuel 
observation still valid  example  may maintenance action performed
rocket without fuel 

  

fireachability  relevance  resolution

actions  none unit clause  since way deducing negated actions 
propagation stops point 
general case similar  linear encoding  obtained disjunction
allowable actions  generate disjunction allowable preconditions  information
propagated backwards much forward case  yet  k     case 
expect form backwards reachability analysis goal state  rather true
relevance analysis  again  relevant k likely much better job here 
takes explicit relevance issues account  however  case reachability analysis 
ability k clause resolution yield constraints order greater k 
cannot show relevant k always better 
context graphplan encoding  generate disjunctions relevant
actions  disjunctions relevant preconditions deduced  etc  however 
irrelevant actions excluded explicitly  since one action allowed
step  conclude relevant action must appear 
exclude actions destroy goal proposition  again  deduce constraints
order greater k via k clause resolution  cannot provide general result here 
finally  note     graphplan planner incorporate relevance analysis  mea graphplan  recent variant   kambhampati et al         
well ipp  nebel et al              ernst  millstein  weld        discuss enhanced
version graphplan encoding contains effects axioms well  i e   axioms
form action   effect   terms ability propagate reachability relevance
information  see added ability rule actions destroy needed propositions
 as linear encoding  
   empirical evaluation

previous sections attempted understand mechanisms resolution
yields reachability relevance information compare natural class
direct reachability relevance algorithms  noted  relationship always
subsumption  interest examine actual pruning abilities
algorithms  section describe performance algorithms number
standard planning problems  limited number domains used  caution
exercised interpreting results  however  interesting results emerge 
first set experiments examined performance unary methods large blocks
world logistics domain problems  used blocks  world problems bw dir a b c d
satplan distribution  involving            blocks  respectively   minimal 
plans length            logistics  domain problems based instances described
 brafman   hoos        involving   packages   cities  minimal plans size
         respectively  sat encodings generated using medic program  ernst
et al          used crse options obtain linear encoding erpe options
obtain graphplan like encodings  however  encoding obtained via erpe options contain explicit effect axioms  linear encoding  axiom improve
graphplan encoding s ability propagate relevance information 
   instances part ucpop distribution  maintained university washington 
http   www research att com  kautz blackbox index html  blackbox home page 

  

fibrafman

log a
log b
log c
bw a
bw b
bw c
bw d

j j


    
    
    
    
     
     
      

reach rel r r u rch l  u rel l 
             
   
  
             
   
  
              
   
  
             
   
   
             
    
   
                
    
   
                
    
    

table    pruning effects unary methods  jaj number possible actions
course minimal length plan  following entries hold number
actions pruned using  reachable    relevant    combined  unit propagation
linear encoding using initial state  using final state  unit propagation
graphplan encoding using final state yielded pruning  execution
times reach relevant algorithms      seconds except bw c      
sec    bw d       sec   
set experiments measured number potential actions eliminated
following algorithms  reachable    relevant    reachable   relevant   combined 
reachability analysis via unit resolution using initial state  relevance analysis via
unit resolution using goal state  consider graphplan encoding
following reasons 
    unit propagation graphplan encoding yields much information reachable       particular experiments  and cases   unit resolution based
final state graphplan encoding prunes little  any  actions
fact appearing goal state number potential producing actions     
version graphplan encoding produced medic basically equivalent
linear encoding terms relevance information contains explicit effect axioms 
actual numbers appear table    first column provides size set
actions minimal plan length  following columns provide number actions
pruned various methods tested  evident reachable   extremely effective 
relevance analysis seems much less useful  although relevant   prune non negligible
number actions  results unit resolution quite disappointing  although line
theoretical analysis  recalling unit resolution graphplan encoding
equivalent reachable    see much greater potential pruning
graphplan encoding  another interesting observation little overlap
reachability relevance analysis  stems fact pruning
effect algorithms often quite shallow  pruning done
first steps  in reachability  last steps  in relevance   finally  note
k     algorithms quite fast  unit propagation important heuristic sat
solution algorithms based david putnam algorithm  davis   putman        
extremely fast  negligible running times  i e          seconds   surprisingly 
  

fireachability  relevance  resolution

bw sm a
bw sm b
bw sm c
log sm a
log sm b
log sm c
hanoi  
hanoi  
hanoi  

j j


  
  
   
  
  
  
  
  
   

rch  rch  rel    rch  l  rch  l  rch  gp  rch  gp  rel    l g 
  
  
 
  
  
  
  
 
  
  
  
  
  
  
  
 
   
   
   
  
   
   
   
  
  
  
 
  
  
  
  
 
   
   
  
  
   
   
   
 
   
   
  
  
   
   
   
 
  
  
  
  
   
  
   
 
   
   
  
  
   
   
   
  
   
   
  
   
   
   
   
  

table    effects unary binary methods  jaj number possible actions per step   following columns hold number actions pruned
course minimal length  or longer  plan using reachable    reachable   
relevant      which yield value   unit propagation linear
encoding using initial state  binary propagation linear encoding using initial state  unit propagation graphplan encoding using initial state 
binary propagation graphplan encoding using initial state  final
column correspond propagation using goal state  methods  i e   unit
binary  encodings yielded values 
reachable   relevant   extremely fast  execution times algorithms
less      seconds  except bw c       sec    bw d       sec   
amount small fraction running times required modern sat algorithms  
next set experiments  shown table    introduces binary pruning methods
well  here  limited slow performance prolog implementation
reachable   medic encoder  ernst et al          looked blocks world problems involving        blocks  respectively  looked logistics domain problems
involving one package two cities  three packages two cities  three packages
three cities  addition  looked three hanoi tower problems        disks 
number points worth mentioning 



two domains  blocks  world hanoi   reachable   slightly useful
reachable    logistics domain  hand  reachable   much
effective  however  must remember reachable   yields mutual exclusion
constraints measure  constraints quite useful
important role graphplan planner 



clear winner emerges  blocks world domain  binary resolution linear
encoding prunes reachable    whereas logistics domain  reachable  prunes more  interestingly  binary resolution graphplan encoding less

   experiments conducted pc pentiumii     processor 

  

fibrafman

time
reach  
reach  
u res lin 
b res lin 
u b res gp 

                    
                    
                   
                            
                   
                    

  
  
 
  
 
  

  
  
 
  
 
  

  
  
 
  
 
  

  
  
 
  
 
  

  
  
 
  
 
  

  
  
 
  
 
  

table    reachability analysis    bit counter  shown number unpruned actions per time step  rows correspond reachable    reachable    unit
resolution linear encoding  binary resolution linear encoding 
last row corresponds unit binary resolution graphplan encoding 
identical effect 
effective linear encoding  however  graphplan encoding allows
shorter plans  consequently  smaller search spaces  therefore  graphplanencoding still likely ecient 



relevant   advantage relevant    fact  behavior observed
using resolution well  unit binary resolution linear graphplan
encodings pruned amount actions  consequently  present one
column  indeed  see sets experiments reported tables     
relevance analysis contributes little  one obvious reason goal state
often incomplete much less constrained initial state  at least explicitly  
therefore  algorithms diculty deriving relevance constraints  however 
one s intuition seems indicate case  least
extent observed  means providing better relevance analysis 
although may require sophisticated derivation state constraints 



predicted  relevance analysis much useful state space level
truth assignment level 



expected  graphplan encoding typically better linear encoding 

finally  ran tests    bit version counter domains described
text  constrained domain single action applicable
state wanted see much would discovered algorithms  results shown tables      number permisable actions
given function time step  table   presents results forward pruning
using reachable    reachable    unit binary propagation using graphplan
linear encodings  table   presents results backward pruning using relevant   
relevant    unit binary propagation using linear encodings 

  

fireachability  relevance  resolution

time
rel    u b res gp 
u res l 
b res l 

                                      
                                      
                                              
                               

table    relevance analysis    bit counter  shown number unpruned
actions per time step   identical  results reachable    reachable    unitresolution graphplan encoding  binary resolution graphplan
encoding appear first row  next rows correspond unit binary
resolution linear encoding  respectively 

   conclusion

shown connection scheme used encode planning instances
ability propagate reachability relevance information initial final steps
time points  hope results serve improve understanding
factors contributing performance different encoding methods  addition 
provided crisp general formulation class reachability relevance algorithms
appear various forms different planning algorithms  compared pruning
ability resolution based propagation methods operate encoded plans 
reachable k relevant k algorithms operate plan level  empirical
results show complex picture  clear winner emerges  however  seems
domain constrained  making parallel actions less useful  binary methods
little advantage unary methods  addition  show relevance analysis best
conducted plan level  sat based planning algorithms  would suggest use
simple plan level relevance analysis stage prior plan encoding  observation
confirmed recent results reported do  srivastava  kambhampati        
 brafman         pointed binary clauses form large fraction
clauses sat encoded planning problems  given results regarding utility binary
resolution  natural idea augment standard clause simplification techniques  e g   unit
propagation  limited form binary clause preprocessing  initial results presented
indicated utility idea  instances unit clauses could derived
form binary resolution  nice reductions running time demonstrated 
unit clauses derivable via method  small overhead incurred 
principled  systematic  ecient technique based ideas investigated
 brafman        
work among first attempts theoretically analyze different encoding schemes 
concentrated one particular aspect encodings  i e   ability propagate concrete state information backwards forwards  naturally  attempt a priori
limited scope  ability one factor uencing performance various
algorithms  uence probably significant systematic methods based
david putnam procedure methods based stochastic local search 
  

fibrafman

authors considered ideas presented here  too  kautz selman
       discuss relation graphplan s mutex constraint restricted form
binary propagation  particular show mutex computation limited form
negative binary propagation  mutex propagation  two assertions mutual exclusion
yield new one  course  mutual exclusion statement equivalent binary
clause  e g   either action performed action b performed   hence
view process limited form binary propagation  f p    qg fp    rg
deduce f q    rg  graphplan performs operation  incomplete manner 
addition  tested additional limited inference methods failed literal strategy
 attempting prove particular literal inconsistent using unit propagation 
binary failed literal strategy  attempting prove binary clause inconsistent using
unit propagation   methods directly correspond methods considered
paper  closely related one options medic system encoding
planning problems  simple inference method referred simple data  ow
analysis  ernst et al          method basically instance reachable   
haslum geffner        present parametrized class admissible heuristics functions h   interesting important relation heuristic function
generation technique discussed paper parameterized class reachability
analysis algorithms discussed paper  heuristic function assigns  
state means believes goal reachable s  heuristic function
admissible  fact  true  thus  admissible heuristic functions provide sound
tool pruning   goal reachable state assign value
   fact  derivation heuristic functions class h closely related
computation reachable k  cases  instead analyzing actual states  analyze
subsets states size k interactions  however  designing heuristic functions 
greater emphasis put distance current state state
set literals appears without mutual exclusion constraints  i e   indices sets
c   
finally  recent paper do  srivastava  khambhampati        examines encoded
planning problems generated blackbox planner  blackbox utilizes mutual exclusion constraints derived graphplan s planning graph  authors show
constraints useful  despite fact increase size encoding 
addition  authors examine utility adding explicit mutual exclusion constraints
stemming  state space based  relevance analysis  constraints appear improve
planner s performance  fact  seems constraints described do  srivastava  kambhampati        powerful generated relevant   
believe relevant k strengthened  hope examine issue
closely future 
k

k





acknowledgments

wish thank craig boutilier chris geib valuable discussions reachability analysis anonymous reviewers useful detailed comments  particularly
grateful olga rozenfeld implemented algorithms prolog  suggested use
  

fireachability  relevance  resolution

counter example illustrating algorithms  provided important corrections
previous drafts  work supported part paul ivanier center robotics
research production management 
appendix a  proofs

theorem   set propositions actions excluded reachable k time j

feasible plan which  time j   propositions hold  or  respectively 
actions appear 

proof  immediate  consider valid plan states world
execution plan  straightforward show appear within sets
without constrained virtue valid plan 

ai



lemma   context linear encoding  reachable    yields reachability information unit propagation 

proof  given definitions used earlier on  formal statement lemma
follows  let k integer denoting length plan  let
  set

actions pruned reachable    k th level given planning domain initial
state  let
set actions pruned unit resolution linear
encoding planning domain using k steps  i e   actions deduce unit
clause containing negation corresponding variable   without goal state
supplied 
  planning instances
 
 a
 a
first let us consider unit resolution  unit clauses available initially correspond propositions hold initial state  axioms propositions denoting state time   appear class    precondition axioms   
 frame axioms   however  clauses class   ternary contain one
proposition  ternary frame clauses yield unit clause able rule
actions one  cannot  stage  therefore  unit clauses
derived resolving current unit clauses class   clauses  resolutions
yield new unit clauses containing negated actions  negated actions resolved
clauses containing positive action variables  variables appear class  
 at least one action  axioms 
two cases consider  first  suppose able rule
actions one  using frame effect axioms  derive state time   
situation analogous time   knowledge
initial state  since reachable    puts us position  claim follows  using
simple inductive argument   next  suppose cannot rule actions one 
case  new unit clauses  unit propagation stops  reachable   
able rule actions ruled unit propagation process  moreover 
actions ruled common effect  effect deduced using
reachable      rule actions require negation precondition 
type information obtained via unit propagation 
reach

u

res

reach

u

res

reach

  

u

res

fibrafman

lemma   context

graphplan encoding  unit propagation reachable  
rule sets actions  ignore explicit constraints appearing axiom
class    use constraints  unit propagation yield reachability information 

proof  first  suppose ignore mutex axioms class    using unit propagation 

deduce negation actions whose preconditions violated time    negated
action literals resolved class    effect explanation  axioms 
able rule explanations time   proposition  deduce negation
manner  mechanism allow us exclude variable using
reachable    similarly  negated action literals resolved class    at least oneaction  axioms  yields information  time   variables deduce
used rule time   actions 
notice following  deduce p time    one actions produce p
must hold time    information explicit reachable   algorithm  although
appear graphplan s planning graph form edges   however  cannot
used rule actions restricted unit resolution 
class   axioms make difference case  suppose able
conclude particular action produces p must occur  i e   deducing p
ruling causes except a   case  actions mutually exclusive
cannot occur  actions may affect p all  negation need
necessarily derivable using reachable   

theorem   let

state goal reachable using m step plan
 where step contain number non interfering actions       set
literals satisfied subset   subset c       exists
m step plan reaching goal set actions plan
v steps last subset c  




v

v

proof  recall assume proposition appearing effects action

appears preconditions well  always enforce requirement converting
action satisfy set actions satisfy it 
proof proceeds induction number steps goal reachable 
let state goal g reachable single step  let set
actions one step plan reaching g   definition  contain
interfering actions  addition  know g reachable performing
preconditions g n effects of  a  must hold  
first  suppose contrary literal l     l    s    notice
definition a    s  contains literals consistent
g  therefore  l must inconsistent g  i e    l   g  since l     must
action   precondition l effect  l  otherwise  l would hold
performing a   action would a  preconditions  l among them  would
s    conclude s   
next  want show one step plan reaching g whose
actions a    discussion see plan reaching g
r

  

fireachability  relevance  resolution

contains action a  changing value every proposition l holds
inconsistent g  clearly  none actions effect
inconsistent g  let a  denote set actions  applying a 
transform literals inconsistent g value g destroy
value literal consistent g  since a  a  constitutes valid plan  i e  
actions interfere other  achieves g  definition  a  a   
conclude proof base step  must show subset c s   
suppose  contrary subset   c s    seen
    set actions a  a  a  l     either
precondition action a  l consistent g destroyed a   
denote a   set consisting a  noop   corresponding l    
preconditions element a    definition a    a     a   
however      c s  a     c a  implies a   contains interfering actions 
claim impossible  first  effects a   either g consistent
g  construction  addition  preconditions a     therefore
  actual state world  cannot contain con icting literals  hence 
 
   c s   
next  suppose established inductive hypothesis   let
us prove holds   m  hence  let state exists mstep plan   a            attaining g  let    denote state obtained applying
a    know
  step plan achieving g     
  
inductive hypothesis  satisfies conditions theorem  particular  know
     subset    c     complete proof would
sucient show    reachable one step plan a  whose actions
c   proof similar base case 
r













corollary   initial state goal reachable minimal  in
number operators  plan p   a          a    where steps numbered backwards 
reaching goal s  a  c contain subset a   










proof  inspection proof previous theorem shows every step

found subset set actions candidate plan satisfied
relevant conditions  particular  consider minimal plan  elements must satisfy
conditions 

lemma   context linear encoding  unless single safe  final action 
unit propagation yields less relevance information relevant   

initially  unit clauses goal literals  resolve effect
axioms only  would yield negation various actions  i e   unsafe actions  
negated action literals resolved action disjunction  axiom class    
however  one safe final action  obtain unit clause
disjunction  nothing farther do  information 
more  easily obtainable relevant   
  

fibrafman

lemma   context

graphplan encoding  action changing value every literal  unit propagation yields less relevance information
relevant   

proof  see text prior lemma 
appendix b  complexity reachable k relevant k

computational complexity reachable k o njajjlj e   njljjaj    n
number levels generate  jaj number possible actions  jlj size
propositional language used  e maximal number actions particular
shared effect  explain below  complexity dominated time required
produce sets c c  
set possible effects    produced o jaj   steps  maximal
number effects 
c requires examining l  tuples elements   l k  
 jlj   elements  tuple find set actions produce
it  done quickly  provided maintained pointers actions  number
sets actions o e    since k actions needed  
set actions must check whether subset member c     given
appropriate representation c     done time o jaj   accomplish this 
use binary tree whose leafs correspond bit vectors  depth tree
jaj size o jc  j   finally  need maintain c similar tree bitvectors  done o jlj    or  c small  lower cost   overall cost
producing c o jlj je j jaj  
produce set   go actions check whether preconditions
appear   requires o jaj   steps  assuming bit vector representation   
maximal number preconditions action  check
whether preconditions appear c   since ja j jaj check whether
subset set preconditions appears c time o jlj   requires o jajjlj 
steps 
finally  need produce c   requires generating subsets size
k less  taking  jaj   steps  subset must check whether preconditions contain element c   again  provided appropriate data structure c
maintained  done o jlj  set preconditions  case
c   assumed c maintained tree bit vectors  generated time
 jaj    overall complexity step  jljjaj   
note small values k data structures likely provide better performance 
next  address relevant k  analysis assumption
set variables appear preconditions effects operator  noted 
transforming set operators satisfy property set operators
satisfy may cause exponential blow up worst case 
complexity relevant k o jaj jlj   jlj jaj   jaj number
actions  jlj number proposition language  maximal number
k



k

k





e



e



k

k









k

k





k





p



p











k







k

k

k

k

k

k
p

p

  

fireachability  relevance  resolution

preconditions action  analysis quite similar case reachable k 
ignore sets r subsets larger whose generation
contributes constant factors 
set preconditions    produced o jaj   steps 
compute c   iterate o jlj   sets literals  set examine
sets actions preconditions  o m   sets 
set actions  need check c     check
performed o jaj  steps  overall complexity step o jlj jaj  
produce set   go actions useful   require o jlje    where
before  e maximal number actions particular effect   action 
check whether effects c   since need perform check
every action  overall complexity o jlje   jljjaj  
finally  need produce sets c   interfering actions pre computed
cost amortized steps  case  computation requires
 
 mjaj   steps  maximal sum preconditions effects action 
next  examine effects l tuples actions  l k  see whether
effects subset c   takes o jaj jlj  steps 
again  small values k  and particular  k         tighter analysis possible 
r










p

k



k
p



k



k
p







k



references

bayardo  r  j     schrag  r  c          using csp look back techniques solve real world
sat instances  proc  aaai     pp          
blum  a     furst  m  l          fast planning planning graph analysis  artificial
intelligence              
bonet  b   loerincs  g     geffner  h          robust fast action selection mechanism
planning  proc  aaai     pp          
boutilier  c   brafman  r  i     geib  c          structured reachability analysis markov
decision processes  proc    th conference uncertainty ai  pp        
boutilier  c     dearden  r          using abstractions decision theoretic planning
time constraints  proc  aaai     pp            
brafman  r  i          reachability  relevance  resolution  planning satisfiability
approach  ijcai     pp          
brafman  r  i     hoos  h  h          encode encode   i  linear planning 
ijcai     pp          
brafman  r  i          simplifier propositional formulas many binary clauses 
tech  rep         dept  computer science  ben gurion university 
crawford  j     auton  l  d          experimental results cross over point
satisfiability problems  proc  aaai     pp        
  

fibrafman

davis  m     putman  h          computing procedure quantification theory  journal
acm             
do  m  b   srivastava  b     kambhampati  s          investigating effect relevance
reachability constraints sat encodings planning  proc  fifth intl 
conf  ai planning scheduling systems 
ernst  m  d   millstein  t  d     weld  d  s          automatic sat compilation
planning problems  proceedings international joint conference artificial
intelligence 
fikes  r     nilsson  n          strips  new approach application theorem
proving problem solving  artificial intelligence                   
freeman  j  w          improvements propositional satisfiability search algorithms 
ph d  thesis  u  pennsylvania dept  computer information science 
genesereth  m  r     nilsson  n  j          logical foundations artificial intelligence 
kaufmann  los altos  ca 
gomes  c  p   selman  b     kautz  h          boosting combinatorial search
randomization  proc    th nat  conf  ai  pp          
haslum  p     geffner  h          admissible heuristics optimal planning  proc 
fifth intl  conf  ai planning scheduling systems  pp          
kambhampati  s   parker  e     lambrecht  e          understanding exending graphplan  proc   th european conf  planning  pp          
kautz  h     selman  b          planning satisfiability  proc    th european
conf  ai  pp          
kautz  h     selman  b          pushing envelope  planning  propositional logic 
stochastic search  proc    th national conference ai  aaai      pp 
          
kautz  h     selman  b          unifying sat based graph based planning  proc 
  th intl  joint conf  ai  ijcai      pp          
li  c  m     anbulagan         heuristics based unit propagation satisfiability
problems  proc  ijcai    
mcdermoot  d          heuristic estimator means ends analysis planning  proc 
 rd int  conf ai planning systems  pp          
nebel  b   dimopoulos  y     koehler  j          ignoring irrelevant facts operators
plan generation  proc   th european conf  planning 

  


