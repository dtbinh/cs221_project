journal of artificial intelligence research                  

submitted        published      

what s in an attribute 
consequences for the least common subsumer

ralf kusters

kuesters ti informatik uni kiel de

institut f
ur informatik und praktische mathematik
christian albrechts universit
at zu kiel
      kiel
germany

alex borgida

borgida cs rutgers edu

department of computer science
rutgers university
piscataway  nj      
usa

abstract

functional relationships between objects  called  attributes   are of considerable importance in knowledge representation languages  including description logics  dls   a study
of the literature indicates that papers have made  often implicitly  different assumptions
about the nature of attributes  whether they are always required to have a value  or whether
they can be partial functions  the work presented here is the first explicit study of this
difference for subclasses of the classic dl  involving the same as concept constructor 
it is shown that although determining subsumption between concept descriptions has the
same complexity  though requiring different algorithms   the story is different in the case
of determining the least common subsumer  lcs   for attributes interpreted as partial
functions  the lcs exists and can be computed relatively easily  even in this case our results
correct and extend three previous papers about the lcs of dls  in the case where attributes
must have a value  the lcs may not exist  and even if it exists it may be of exponential size 
interestingly  it is possible to decide in polynomial time if the lcs exists 
   introduction

knowledge representation systems based on description logics  dls  have been the subject of continued attention in artificial intelligence  both as a subject of theoretical studies
 borgida        baader        baader   sattler        giacomo   lenzerini        calvanese  giacomo    lenzerini      b  and in applications  artale  franconi  guarino   
pazzi        brachman  mcguinness  patel schneider    borgida        mcguinness  
patel schneider         more impressively  dls have found applications in other areas involving information processing  such as databases  borgida        calvanese  lenzerini 
  nardi         semi structured data  calvanese  giacomo    lenzerini            a  
information integration  calvanese  giacomo  lenzerini  nardi    rosati        borgida
  kusters         as well as more general problems such as configuration  mcguinness
  wright        and software engineering  borgida   devanbu        devanbu   jones 
       in fact  wherever the ubiquitous term  ontology  is used these days  e g   for proc      ai access foundation and morgan kaufmann publishers  all rights reserved 

fi steres  borgida
ku

viding the semantics of web xml documents   dls are prime contenders because of their
clear semantics and well studied computational properties 
in description logics  one takes an object centered view  where the world is modeled as
individuals  connected by binary relationships  here called roles   and grouped into classes
 called concepts   for those more familiar with predicate logic  objects correspond to
constants  roles to binary predicates  and concepts to unary predicates  in every dl system 
the concepts of the application domain are described by concept descriptions that are built
from atomic concepts and roles using the  constructors  provided by the dl language  for
example  consider a situation where we want a concept describing individual cars that have
had frequent  at least     repairs  and also record the fact that for cars  their model is the
same as their manufacturer s model  concepts can be thought of as being built up from
 possibly nested  simpler noun phrases  so the above concept  called lemon in the sequel 
might be captured as the conjunction of
 objects that are cars 
 things all of whose model values are in concept model 
 things all of whose madeby values are in concept manufacturer 
 things whose model value is the same as the model of the madeby attribute 
 things with at least    repairs values 
 things all of whose repairs values are repairreport  
using the syntax of the classic language  we can abbreviate the above  while emphasizing
the term like nature of descriptions and the constructors used in each 
 and car
 all model model 
 all madeby manufacturer 
 same as  model   madeby  model  
 at least    repairs 
 all repairs repairreport  
so  for example  the concept term  at least n p  has constructor at least  and denotes
objects which are related by the relationship p to at least n other objects  in turn   all p
c  has as instances exactly those objects which are related by p only to instances of c 
finally  we present the same concept in a mathematical notation which is more succinct
and preferred in formal work on dls 
lemon    car u
 model model u
 madeby manufacturer u
madeby    model  madeby  u
    repairs u
 repairs repairreport

unlike preceding formalisms  such as semantic networks and frames  quillian        minsky 
       dls are equipped with a formal semantics  which can be given by a translation into
   

fiwhat s in an attribute 

first order predicate logic  borgida         for example  moreover  dl systems provide their
users with various inference capabilities that allow them to deduce implicit knowledge from
the explicitly represented knowledge  for instance  the subsumption algorithms allow one to
determine subconcept superconcept relationships  c is subsumed by d  c v d  if and only
if all instances of c are also instances of d  i e   the first description is always interpreted
as a subset of the second description  for example  the concept car obviously subsumes the
concept description lemon  while  at least    repairs  is subsumed by  at least   repairs  
the traditional inference problems for dl systems  such as subsumption  inconsistency
detection  membership checking  are by now well investigated  algorithms and detailed
complexity results for realizing such inferences are available for a variety of dls of differing
expressive power   see  e g    baader   sattler        for an overview 
    least common subsumer

the least common subsumer  lcs  of concepts is the most specific concept description subsuming the given concepts  finding the lcs was first introduced as a new inference problem
for dls by cohen  borgida  and hirsh         one motivation for considering the lcs is to
use it as an alternative to disjunction  the idea is to replace disjunctions like c  t    t c
by the lcs of c           c   borgida and etherington        call this operation knowledge base
vivification  although  in general  the lcs is not equivalent to the corresponding disjunction 
it is the best approximation of the disjunctive concept within the available language  using
such an approximation is motivated by the fact that  in many cases  adding disjunction
would increase the complexity of reasoning  
as proposed by baader et al   baader   kusters        baader  kusters    molitor 
       the lcs operation can be used to support the  bottom up  construction of dl knowledge bases  where  roughly speaking  starting from  typical  examples an lcs algorithm
is used to compute a concept description that  i  contains all these examples  and  ii  is
the most specific description satisfying property  i   baader and kusters have presented
such an algorithm for cyclic aln  concept descriptions  aln is a relatively simple language allowing for concept conjunction  primitive negation  value restrictions  and number
restrictions  also  baader et al         have proposed an lcs algorithm for a dl allowing
existential restrictions instead of number restrictions 
originally  the lcs was introduced as an operation in the context of inductive learning
from examples  cohen et al          and several papers followed up this lead  the dls
considered were mostly sublanguages of classic which allowed for same as equalities  i e  
expressions like  same as  madeby   model  madeby    cohen et al  proposed an lcs
algorithm for aln and a language that allows for concept conjunction and same as  which
we will call s   the algorithm for s was extended by cohen and hirsh      a  to coreclassic  which additionally allows for value restrictions  see  cohen   hirsh      b  for
experimental results   finally  frazier and pitt        presented an lcs algorithm for full
classic 
n

n

   observe that if the language already allows for disjunction  we have lcs c            cn    c  t    t cn   in
particular  this means that  for such languages  the lcs is not really of interest 

   

fi steres  borgida
ku

    total vs  partial attributes

in most knowledge representation systems  including dls  functional relationships  here
called attributes  also called  features  in the literature   are distinguished as a subclass
of general relationships  at least in part because functional restrictions occur so frequently
in practice    in the above example  clearly madeby and model are meant to be attributes 
thus making unnecessary number restrictions like  and  at most   madeby   at least
  madeby    in addition  distinguishing attributes helps identify tractable subsets of dl
constructors  in classic  coreferences between attribute chains  as in the above examples 
can be reasoned with eciently  borgida   patel schneider         while if we changed to
roles  e g   allowed  same as  repairs   ownedby  repairspaidfor    the subsumption problem becomes undecidable  schmidt schau        
whereas the distinction between roles and attributes in dls is both theoretically and
practically well understood  we have discovered that another distinction  namely the one between attributes being interpreted as total functions  total attributes   and those interpreted
as partial functions  partial attributes    has  slipped through the cracks  of contemporary
research  a total attribute always has a value in  the world out there   even if we do not
know it in the knowledge base currently  a partial attribute may not have a value  this
distinction is useful in practice  since there is a difference between a car possibly  but not
necessarily  having a cd player  and the car necessarily having a manufacturer  which just
may not be known in the current knowledge base   the latter is modeled by defining the
attribute madeby to be a total attribute  note that with madeby being a total attribute 
every individual in the world of discourse  not only cars  must have a filler for madeby 
since  however  no structural information is provided for fillers of madeby of non car individuals  all implications drawn about these fillers are trivial  thus  making madeby a total
attribute seems reasonable in this case  a car s cd player  on the other hand  should be
modeled by a partial attribute to express the fact that cars are not required to have a cd
player  to indicate that a particular car does have a cd player  one would have to add the
description  at least   cdplayer  
    new results

as mentioned above  in conjunction with the same as constructor  roles and attributes
behave very differently with respect to subsumption  the main objective of this paper is to
show that the distinction between total and partial attributes induces significantly different
behaviour in computing the lcs  in the presence of same as  more precisely  the purpose of
this paper is twofold 
first  we show that with respect to the complexity of deciding subsumption there is no
difference between partial and total attributes  borgida and patel schneider        have
shown that when attributes are total  subsumption of classic concept descriptions can
be decided in polynomial time  as shown in the present work  slight modifications of the
algorithm proposed by borgida and patel schneider suce to handle partial attributes 
   readers coming from the machine learning community should be aware of the difference between our
 attributes   functional roles  and their  attributes   which are components of an input feature vector
that usually describes an exemplar 

   

fiwhat s in an attribute 

moreover  these modifications do not change the complexity of the algorithm  thus  partial
and total attributes behave very similarly from the subsumption point of view 
second  and this is the more surprising result of this paper  the distinction between
partial and total attributes does have a significant impact on the problem of computing the
lcs  previous results on sublanguages of classic show that if partial attributes are used 
the lcs of two concept descriptions always exists  and can be computed in polynomial time 
if  however  only total attributes are involved  the situation is very different  the lcs need
no longer even exist  and in case it exists its size may grow exponential in the size of the
given concept descriptions  nevertheless  the existence of the lcs of two concept descriptions
can be decided in polynomial time 
specifically  in previous work  cohen et al         cohen   hirsh      a  frazier  
pitt        concerning the lcs computation in classic  constructions and proofs have been
made without realizing the difference between the two types of attributes  without going
into details here  the main problem for lcs is that merely finite graphs have been employed 
making the constructions applicable only for the partial attribute case  in addition to fixing
these problems  this paper also presents the proper handling of inconsistent concepts in the
lcs algorithm for classic presented by frazier and pitt        
although our results about subsumption are not as intriguing  the proofs to show the
results on the lcs make extensive use of the corresponding subsumption algorithms  which
is one reason we present them beforehand in this paper 
returning to the general differences between the cases of total and partial attributes 
one could say that the fundamental cause for the differences lies in the same as constructor 
whose semantics normally requires that  i  the two chains of attributes each have a value 
and  ii  that these values coincide  in the case of total attributes  same as obeys the principle
c v u   v implies c v u  w   v  w
where u v  and w are sequences of total attributes  e g    madeby  model   because condition
 i  is ensured by the total aspect of all the attributes  in the case of partial attributes  the
above implication does not hold  because w  and hence u  w  is no longer guaranteed to have
a value  implying that the same as restriction may not hold  clearly  this implication affects
the results of subsumption  as far as lcs is concerned  a certain graph  representing the lcs
of the two given concepts  may be infinite in the case of total attributes  thus jeopardizing
the existence of the lcs 
the more general significance of our result is that knowledge representation language
designers and users need to explicitly check at the beginning whether they deal with total or partial attributes because the choice can have significant effects  although in some
situations total attributes are convenient  to guarantee the existence of attributes without
having to resort to number restrictions  our results show that they can have drawbacks 
all things considered  requiring all attributes to be total appears to be less desirable  concerning classic  the technical results in this paper support the use of partial attributes
because these ensure the existence of the lcs and its computation in polynomial time as
well as the ecient decision of subsumption  moreover  the current implementation of the
classic subsumption algorithm does not require major changes in order to handle partial
attributes 
   

fi steres  borgida
ku

the outline of this paper is as follows  in the following section  the basic notions necessary for our investigations are introduced  then  in the two subsequent sections  subsumption and lcs computation in classic with partial attributes is investigated  more precisely 
in section   we offer a subsumption algorithm for the sublanguage classic of classic 
which contains all main classic constructors  in section    we present an lcs algorithm
for classic concept descriptions  along the lines of that proposed by cohen and hirsh
     a   and formally prove its correctness  thereby resolving some shortcomings of previous
lcs algorithms  which did not handle inconsistencies properly  finally  section   covers the
central new result of this paper  i e   the lcs computation in presence of total attributes 
for this section  we restrict our investigations to the sublanguage s of classic in order to
concentrate on the changes caused by going from partial to total attributes  nevertheless 
we strongly conjecture that all the results proved in this section can easily be extended to
classic and classic using similar techniques as the one employed in the two previous
sections 
   formal preliminaries

in this section  we introduce the syntax and semantics of the description languages considered in this paper and formally define subsumption and equivalence of concept descriptions 
finally  the least common subsumer of concept descriptions is specified 
definition   let c   r  and a be disjoint finite sets representing the set of concept names 
the set of role names  and the set of attribute names  the set of all classic  concept
descriptions over c   r  and a is inductively defined as follows 
 every element of c is a concept description  concept name  like car  
 the symbol   is a concept description  top concept  denoting the universe of all
objects  
 if r   r is a role and n    is a nonnegative integer  then  n r and  n r are concept
descriptions  number restrictions  like     repairs  
 if c and d are concept descriptions  then c u d is a concept description  concept
conjunction  




if c is a concept description and r is a role or an attribute  then
description  value restriction  like  madeby manufacturer  

 r c

is a concept

if k  h    are non negative integers and a            a   b            b   a are attributes  then
     a   b       b is a concept description  same as equality  like madeby  
model  madeby   note that the two sequences may be empty  i e   k     or h     
the empty sequence is denoted by   
k

a 

k

h

h

often we dispense with  in the composition of attributes  for example  the sequence
a      a is simply written as a     a   moreover  we will use  r     r  c as abbreviation
of  r   r      r  c   where we have    c in case n      and this denotes c  
as usual  the semantics of classic is defined in a model theoretic way by means of
interpretations 
k

n

k

n

   

fiwhat s in an attribute 

definition   an interpretation i consists of a nonempty domain i and an interpretation
function i   the interpretation function assigns extensions to atomic identifiers as follows 





the extension of a concept name e is some subset e i of the domain 
the extension of a role name r is some subset ri of i  i  

the extension of an attribute name a is some partial function ai from i to i   i e  
if  x  y      ai and  x  y      ai then y    y   
given roles or attributes r   we use  r     r  i to denote the composition of the binary
relations ri   if n     then the result is  i   which denotes the identity relation  i e    i   
f d  d  j d   i g  for an individual d   i   we define ri  d     fe j  d  e    ri g  if the r  s
are attributes  we say that  r     r  i is defined for d iff  r     r  i  d        occasionally 
we will refer to  r     r   d i as the image of d under  r     r  i  d  
the extension c i of a concept description c is inductively defined as follows 
  i    i  
i

n

i

i

n

n

n

n

  n r i    fd   i j cardinality fe   i j  d  e    ri g   ng 
  n r i    fd   i j cardinality fe   i j  d  e    ri g   ng 
 c u d i    c i   di  
  r c  i    fd   i j ri  d   c i g where r is a role or an attribute 
 a     a   b     b  i    fd   i j  a     a  i and  b     b  i are defined for d
and  a     a  i  d     b     b  i  d g 
note that in the above definition attributes are interpreted as partial functions  since the
main point of this paper is to demonstrate the impact of different semantics for attributes 
we occasionally restrict the set of interpretations to those that map attributes to total
functions  such interpretations are called t interpretations and the attributes interpreted
in this way are called total attributes in order to distinguish them from partial ones 
we stress  as remarked in the introduction  that in the definition of  a     a   b     b  i  
a     a and b     b must be defined on d in order for d to satisfy the same as restriction 
although this is the standard semantics for same as equalities  one could also think of
relaxing this restriction  for example  the same as condition might be specified to hold if
either both paths are undefined or both images are defined and have identical values  a
third definition might be satisfied if even just one of the paths is undefined  each of these
definitions of the semantics of same as might lead to different results  however  in this
paper we only pursue the standard semantics 
the subsumption relationship between concept descriptions is defined as follows 
definition   a concept description c is subsumed by the concept description d  c v d
for short  if and only if for all interpretations i   c i  di   if we consider only total
interpretations  we get t subsumption  c v d iff c i  di for all t interpretations i  






k

h

k

h

k

h

k

k

h

t

   

h

fi steres  borgida
ku

having defined subsumption  equivalence of concept descriptions is defined in the usual way 
 d if and only if c v d and d v c   t equivalence c  d is specified analogously 
as already mentioned in the introduction  the main difference between partial and total
attributes with respect to subsumption is that u   v v u  w   v  w holds for all attribute
chains u  v  w  whereas it is not necessarily the case that u   v v u  w   v  w 
finally  before introducing the lcs operation formally and concluding this section  we
comment on the expressive power of classic   since  syntactically  classic lacks some
common constructors  although classic   as introduced here  does not contain the bottom
concept   explicitly  it can be expressed by  e g       r  u     r   we will use   as an
abbreviation for inconsistent concept descriptions  furthermore  primitive negation  i e  
negation of concept names  can be simulated by number restrictions  for a concept name
e one can replace every occurrence of e by     r   and the negation  e of e by     r  
where r is a new role name  finally  for an attribute a the following equivalences hold 
  n a     for n         a    a   a       a        n a     for n     and
    a     a     these show that we do not lose any expressive power by not allowing
for number restrictions on attributes  still  full classic is somewhat more expressive than
classic   this is mainly due to the introduction of individuals  also called nominals  in
classic  for the sake of completeness we give the syntax of the full classic language  
this requires a further set  o  representing the set of individual names  then we can define
two additional concept constructors
 fe         e g  for individuals e   o  enumeration as in ff all  summer  springg 
 p   e for a role or attribute p  and an individual e  fills as in currentseason   summer  
in a technical report  kusters and borgida        extend some of the results presented in
this work to full classic  in the case when individuals have a non standard semantics 
the least common subsumer of a set of concept descriptions is the most specific concept
subsuming all concept descriptions of the set 
definition   the concept description d is the least common subsumer  lcs  of the concept
descriptions c            c  lcs c            c   for short  iff i  c v d for all i              n and ii 
for every d  with that property d v d    analogously  we define lcs  c            c   using v
c

t

t

e

e

e

m

i

n

n

i

t

instead of v 

n

t

note that the lcs of concept descriptions may not exist  but if it does  by definition it is
uniquely determined up to equivalence  in this sense  we may refer to the lcs 
in the following two sections  attributes are always interpreted as partial functions  only
in section   do we consider total attributes 
   characterizing subsumption in

classic

in this section we modify the characterization of t subsumption for classic  as proposed
by borgida and patel schneider         to handle the case of partial attributes  we do
   even here we are omitting constructs dealing with integers and other so called  host individuals   which
cannot have roles of their own and can only act as role attribute fillers 

   

fiwhat s in an attribute 

so in detail  because the tools used for deciding subsumption are intimately related to the
computation of lcs 
t subsumption in classic is decided by a multi part process  first  descriptions are
turned into description graphs  next  description graphs are put into canonical form  where
certain inferences are explicated and other redundancies are reduced by combining nodes
and edges in the graph  finally  t subsumption is determined between a description and a
canonical description graph 
in order to  inherit  the proofs  we have tried to minimize the necessary adjustments to
the specification in  borgida   patel schneider         for this reason  roughly speaking 
attributes are treated as roles unless they form part of a same as equality   note that
attributes participating in a same as construct must have values   to some extent  this
will allow us to adopt the semantics of the original description graphs  which is crucial for
proofs  however  the two different occurrences of attributes  namely  in a same as equality
vs  a role in a value restriction  require us to modify and extend the definition of description
graphs  the normalization rules  and the subsumption algorithm itself 
in the following  we present the steps of the subsumption algorithm in detail  we start
with the definition of description graphs 
    description graphs

intuitively  description graphs reect the syntactic structure of concept descriptions  a
description graph is a labeled  directed multigraph  with a distinguished node  roughly
speaking  the edges  a edges   of the graph capture the constraints expressed by same as
equalities  the labels of nodes contain  among others  a set of so called r edges  which
correspond to value restrictions  unlike the description graphs defined by borgida and
patel schneider  here the r edges are not only labeled with role names but also with attribute
names   we shall comment later on the advantage of this modification in order to deal with
partial attributes   the r edges lead to nested description graphs  representing the concepts
of the corresponding value restrictions 
before defining description graphs formally  in figure   we present a graph corresponding
to the concept description lemon defined in the introduction  we use g manufacturer  
g model   as well as g repairreport  to denote description graphs for the concept names
manufacturer  model  and repairreport  these graphs are very simple  they merely consist
of one node  labeled with the corresponding concept name  in general  such graphs can
be more complex since a value restriction like  r c leads to a  possibly complex  nested
concept description c  
although number restrictions on attributes are not allowed  r edges labeled with attributes  like model and madeby  always have the restriction        in order to capture the
semantics of attributes  formally  description graphs  nodes  and edges are defined mutually
recursively as follows 
definition   a description graph g is a tuple  n  e  n    l   consisting of a finite set n of
nodes  a finite set e of edges  a edges   a distinguished node n    n  root of the graph  
and a function l from n into the set of labels of nodes  we will occasionally use the notation
g n odes  g edges  and g root to access the components n   e and n  of the graph g 
   

fi steres  borgida
ku

f g

madeby

f g

repairreport 

g 

madeby

repairs

model

       

model 

g 

model       

fcar  g
 

madeby       

manufacturer 

g 

figure    a description graph for lemon  where the large node is the root of the graph
an a edge is a tuple of the form  n    a  n    where n    n  are nodes and a is an attribute
name 
a label of a node is defined to be   or a tuple of the form  c  h    consisting of a finite
set c of concept names  the atoms of the node  and a finite set h of tuples  the r edges of
the node   concept names in a description graph stand for atomic concept names and   
we will occasionally use the notation n atoms and n redges to access the components c
and h of the node n 
an r edge is a tuple   r  m  m  g     consisting of a role or attribute name  r  a min  m 
which is a non negative integer  a max  m   which is a non negative integer or    and a
 recursively nested  description graph g    the graph g  will often be called the restriction
graph of the node for the role r  we require the nodes of g  to be distinct from all the nodes
of g and other nested description graphs of g  if r is an attribute  then we require  m    
and m   f    g 

given a description graph g and a node n   g n odes  we define gj to be the graph
 n  e  n  l   gj is said to be rooted at n  a sequence p   n a  a     a n with k    and
 n    a   n     g edges  i              k  is called path in g from the node n  to n  p   g
for short   for k     the path p is called empty  w   a     a is called the label of p  the
empty path has label     p is called rooted if n  is the root of g  occasionally  we write
n  a     a n   g omitting the intermediate nodes 
throughout this work we make the assumption that description graphs are connected 
a description graph is said to be connected if all nodes of the graph can be reached by a
rooted path and all nested graphs are connected  the semantics of description graphs  see
definition    is not altered if nodes that cannot be reached from the root are deleted 
in order to merge description graphs we need the notion of  recursive set of nodes  of
a description graph g  the recursive set of nodes of g is the union of the nodes of g and
the recursive set of nodes of all nested description graphs of g 
just as for concept descriptions  the semantics of description graphs is defined by means
of an interpretation i   we introduce a function  which assigns an individual of the domain
of i to every node of the graph  this ensures that all same as equalities are satisfied 
n

k

n

i

i

i

k

k

k

k

k

   

fiwhat s in an attribute 

definition   let g    n  e  n    l  be a description graph and let i be an interpretation 
an element  d  of i is in gi   iff there is some total function    from n into i such
that
  

d

   n   

  n    n    ni   and
   for all  n    a  n      e we have   n      n       ai  
the extension ni of a node n with label   is the empty set  an element  d  of i is in ni  
   for all

where

       c  h    iff

l n

  c   we have d   b i   and
for all  r  m  m  g      h  

   for all
  

n

b

 a  there are between m and m elements  d    of the domain such that
and
 b  d    g i for all d  such that  d  d      ri  

 d  d      ri  

cohen and hirsh      a  defined the semantics of description graphs in a different way 
avoiding the introduction of a total function   the problem with their definition is 
however  that it is only well defined for acyclic graphs  which  for example  excludes sameas equalities of the form     spouse  spouse  or even p   p  q 
the semantics of the graphs proposed by borgida and patel schneider        is similar
to definition    however  in that paper a edges captured not only same as equalities but
also all value restrictions on attributes  still  in the context of partial attributes  we could
not define the semantics of description graphs by means of a total function  since some
attributes might not have fillers  specifying the semantics of description graphs in terms
of partial mappings  would make the definition even longer  furthermore  the proofs in
 borgida   patel schneider        would not carry over as easily  therefore  in order to
keep  a total function  value restrictions of attributes are initially always translated into redges  the next section will present the translation of concept descriptions into description
graphs in detail 
having defined the semantics of description graphs  subsumption and equivalence between description graphs  e g   h v g  as well as concept descriptions and description
graphs  e g   c v g  is defined in the same way as subsumption and equivalence between
concept descriptions 
    translating concept descriptions into description graphs

following borgida and patel schneider         a classic concept description is turned
into a description graph by a recursive process  in this process  nodes and description
graphs are often merged 
definition   the merge of two nodes  n   n    is a new node n with the following label 
if n  or n  have label    then the label of n is    otherwise if both labels are not equal to
   then n atoms   n  atoms   n  atoms and n redges   n  redges   n  redges 
   

fi steres  borgida
ku

if g     n    e    n    l    and g     n    e    n    l    are two description graphs with disjoint
recursive sets of nodes  then the merge of g  and g    g    g  g     n  e  n    l   is defined
as follows 

  

   n   n  
n     n    n    fn  g  n fn    n  g 
e     e    e    n   n    n   n     i e   e is the union of e  and e  where every occurrence

  

l n

  
  

n 

of n    n  is substituted by n   

       l  n  for all n   n  n fn g  l n     l   n  for all n   n  n fn  g  and l n   is

defined by the label obtained by merging n  and

n   

now  a classic  concept description c can be turned into its corresponding description
g c   by the following translation rules 
     is turned into a description graph with one node n  and no a edges  the only atom
of the node is   and the set of r edges is empty 
   a concept name is turned into a description graph with one node and no a edges  the
atoms of the node contain only the concept name and the node has no r edges 
   a description of the form   n r  is turned into a description graph with one node and
no a edges  the node has as its atoms   and it has a single r edge  r  n     g    
where g    is specified by the first translation rule 
   a description of the form   n r  is turned into a description graph with one node
and no a edges  the node has as its atom   and it has a single r edge  r     n  g     
   a description of the form a     a   b     b is turned into a graph with pairwise
distinct nodes n           n    m           m    the root m     n   and an additional node
n   m    n  the set of a edges consists of  n    a    n      n    a    n              n     a   n  
and  m   b    m      m   b    m             m    b   m    i e   two disjoint paths which coincide on their starting point  n   and their final point  n   note that for p     the first
path is the empty path from n  to n  and for q     the second path is the empty path
from n  to n    all nodes have   as their only atom and no r edges 
   a description of the form  r c   where r is a role  is turned into a description graph
with one node and no a edges  the node has the atom f g and it has a single r edge
 r        g c    
   a description of the form  a c   where a is an attribute  is turned into a description
graph with one node and no a edges  the node has the atom f g and it has a single
r edge  a        g c      in the work by borgida and patel schneider  the concept
description  a c is turned into an a edge  as already mentioned  this would cause
problems for attributes interpreted as partial functions when defining the semantics
by means of  as specified in definition    

graph

p

p

p

q

q

q

p

q

   

q

q

p

p

fiwhat s in an attribute 

   to turn a description of the form c u d into a description graph  construct g c   and
g d   and merge them 
figure   shows the description graph built in this way for the concept lemon of our example 
it can easily be verified that the translation preserves extensions 
theorem   a concept description c and its corresponding description graph g c   are
equivalent  i e  c i   g c  i for every interpretation i  
the main diculty in the proof of this theorem is in showing that merging two description
graphs corresponds to the conjunction of concept descriptions 
lemma   for all interpretations i   if n  and n  are nodes  then  n   n   i   ni    ni    if
i
g  and g  are description graphs then  g   g   i   gi
    g   
the proof of the preceding statement is rather simple and like the one in  borgida   patelschneider        
    translating description graphs to concept descriptions

although the characterization of subsumption does not require translating description
graphs back to concept descriptions  this translation is presented here to show that concept descriptions and description graphs are equivalent representations of classic concept
descriptions  in subsequent sections  we will in fact need to turn graphs into concept descriptions 
the translation of a description graph g can be specified in a rather straightforward
recursive definition  the main idea of the translation stems from cohen and hirsh      a  
who employed spanning trees to translate same as equalities  a spanning tree of a  connected  graph is a tree rooted at the same node as the graph and containing all nodes of the
graph  in particular  it coincides with the graph except that some a edges are deleted  for
example  one possible spanning tree t for g in figure   is obtained by deleting the a edge
labeled madeby  whose origin is the root of g 
now  let g be a connected description graph and t be a spanning tree for it  then 
the corresponding concept description c is obtained as a conjunction of the following
descriptions 
   c contains  i  a same as equality v   v for every leaf n of t   where v is the label
of the rooted path in t to n  and  ii  a same as equality v   a   v  for each a edge
 n    a  n     g edges not contained in t   where v is the label of the rooted path to
n in t   i        
   for every node n in t   c contains a value restriction  v c   where v is the label of
the rooted path in t to n  and c denotes the translation of the label of n  i e   c is
a conjunction obtained as follows 
 every concept name in the atoms of n is a conjunct in c  
 for every r edge  r  m  m  g    of n  c contains  a  the number restrictions  mr 
and   m r   in case r is a role and m       and  b  the value restriction  r c    
where c   is the recursively defined translation of g   
g

g

i

i

g

n

n

n

n

n

g

g

   

fi steres  borgida
ku

in case the set of atoms and r edges of n is empty  define c      
referring to the graph g in figure    c contains the same as equalities model  madeby  
model  madeby and madeby   model  madeby  furthermore  if n  denotes the root of g 
c has the value restrictions    c    model    and  model madeby    where c
corresponds to lemon as defined in the introduction  but without the same as equality  note
that  although in this case the same as equality model  madeby   model  madeby is not
needed  one cannot dispense with    i  in the construction above  as illustrated by the following example  without    i   the description graph g a   a  would be turned into the
description    which is not equivalent to a   a since the same as equality requires that the
path a has a value  which may not be the case 
it is easy to prove that the translation thus defined is correct in the following sense
 kusters   borgida        
n

g

n 

g

n 

lemma   every connected description graph g is equivalent to its translation c   i e   for
all interpretations i   gi   c i  
g

g

    canonical description graphs

in the following we occasionally refer to  marking a node incoherent   this means that the
label of this node is changed to     marking a description graph as incoherent  means that
the description graph is replaced by the graph g    corresponding to    i e   the graph
consisting only of one node with label   
one important property of canonical description graphs is that they are deterministic 
i e   every node has at most one outgoing edge  a edge or r edge  labeled with the same
attribute or role name  following borgida and patel schneider         in order to turn a
description graph into a canonical graph we need to merge a edges and r edges  in addition 
different from their work  it might be necessary to  lift  r edges to a edges 
to merge two a edges  n  a  n   and  n  a  n    in a description graph g  replace them
with a single new edge  n  a  n    where n  is the result of merging n  and n   in addition 
replace n  and n  by n  in all other a edges of g 
in order to merge two r edges  r  s    k    g      r  s    k    g    replace them by the new r edge
 r  max s    s     min k    k     g   g    
to lift up an r edge  a  m  m  g   of a node n in a concept graph g with an a edge
 n  a  n     remove it from n redges  and augment g by adding g  n odes to g n odes 
g  edges to g edges  as well as adding  n  a  g  root  to g edges  a precondition for
applying this transformation is that m      or m     and g corresponds to the graph
g     the reason for this precondition is that if an r edge of the form  a        g   is lifted
without g being inconsistent  the fact that no a successors are allowed is lost  normalization rule    see below  will guarantee that this precondition can always be satisfied 
a description graph g is transformed into canonical form by exhaustively applying the
following normalization rules  a graph is called canonical if none of these rules can be
applied 
   if some node in g is marked incoherent  mark the description graph as incoherent 
 reason  even if the node is not a root  attributes corresponding to a edges must always
a

a

a

a

a

a

a

   

fiwhat s in an attribute 

have a value  since they participate in same as equalities   and this value cannot belong to the

 
   if some r edge in a node has its min greater than its max  mark the node incoherent 
 reason   
 
 
   add   to the atoms of every node  if absent 
   if some r edge in a node has its restriction graph marked incoherent  change its max
to     reason       
  
   if some r edge in a node has a max of    mark its restriction graph as incoherent 
 reason  see    
   if some r edge is of the form  r        g    where g  only contains one node with empty
set of atoms or with the atoms set to f g and no r edges  then remove this r edge 
 reason 
  
   if some node has two r edges labeled with the same role  merge the two edges  as
described above   reason 
 
   
   if some description graph has two a edges from the same node labeled with the
same attribute  merge the two edges  as described above   reason 
 
   
   if some node in a graph has both an a edge and an r edge for the same attribute  then
 lift up the r edge  if the precondition is satisfied  see above    reason  the value
restrictions imposed on attributes that participate in same as equalities must be made explicit
and gathered at one place similar to the previous to cases  
we need to show that the transformations to canonical form do not change the semantics
of the graph  the main diculty is in showing that the merging processes and the lifting
preserve the semantics  the only difference from  borgida   patel schneider        is that
in addition to merging r edges and a edges we also need to lift up r edges  therefore 
we omit the proofs showing that merging edges preserves extensions  the proofs of the
following two lemmas are routine and quite similar to the one of lemma   
lemma   let g    n  e  n    l  be a description graph with two mergeable a edges and let
g     n     e     n    l    be the result of merging these two a edges  then  g  g   
empty set 



r u



r   

r

  r  

 r     

 r c u  r d   r  c u d

 a c u  a d 

 a  c u d

lemma   let n be a node with two mergeable r edges and let n  be the node with these
edges merged  then  ni   n i for every interpretation i  
lemma   let g    n  e  n    l  be a description graph with node n and a edge  n  a  n     
suppose n has an associated r edge  a  m  m  g    provided that the precondition for lifting
r edges is satisfied and that g     n     e     n    l    is the result of this transformation  then
g  g   
proof  it is sucient to show that gij   g  ij   since only the label of n is changed in g 
a

and only n obtains an additional a edge  which points to the graph g not connected to
n

n

a

   

fi steres  borgida
ku

repairreport

g

fmodel  g
 

model

repairs

model

       

fcar  g
 

madeby

fmanufacturer  g
 

figure    the canonical description graph for lemon  where the left most node is the root 
the rest of g    w l o g  we therefore may assume that n is the root of g  i e   n   n   let
d   gi   thus  there is a function  from n into i as specified in definition   and an
individual e such that d    n   e    n     and  d  e    ai   this implies e   gi   hence 
there exists a function   from g  n odes into i for g and e satisfying the conditions in
definition    since the sets of nodes of g and g are disjoint  we can define    to be the
union of  and    i e       m      m  for all nodes m in g and    m       m  for all
nodes m in g   since  by construction  for the additional a edge  n  a  g  root    e   we
have     n       g  root     ai   it follows that all conditions in definition   are satisfied
for d and g   and thus  d   g i  
now let d   g i   thus  there is a function    from n   into i according to definition   
let e       g  root       n     let g   be the description graph we obtain from g  by
deleting the nodes corresponding to g   which is the same graph as g without the r edge
 a  m  m  g    if we restrict    to the nodes of g     then it follows d   g  i   furthermore 
restricting    to the nodes of g yields e   gi   in particular  g can not be marked
incoherent  then  our precondition ensures m      thus  since e is the only a successor of
d  we can conclude d   gi  
ut
a

a

a

a

a

a

a

a

a

a

a

a

a

having dealt with the issue of merging and lifting  it is now easy to verify that  normalization  does not affect the meaning of description graphs 
theorem   if g is a description graph and g  is the corresponding canonical description
graph  then g  g   

as an example  the canonical description graph of the graph given in figure   is depicted
in figure   
    subsumption algorithm

the final part of the subsumption process is checking to see if a canonical description graph
is subsumed by a concept description  as in borgida and patel schneider         where
attributes are total  it turns out that it is not necessary to turn the potential subsumer
into a canonical description graph  the subsumption algorithm presented next can also be
considered as a characterization of subsumption 
   

fiwhat s in an attribute 

algorithm    subsumption algorithm  given a concept description d and description graph g    n  e  n    l   subsumes  d  g  is defined to be true if and only if one of the
following conditions hold 
   the description graph
  

d

  

d

  

d

  

d

g

is marked incoherent 

is a concept name or    and d is an element of the atoms of n   

is   n r  and i  some r edge of n  has r as its role  and min greater than or equal
to n  or ii  n     

is   n r  and some r edge of n  has r as its role  and max less than or equal to n 
is

   a   b     b

  and there are rooted paths with label
in g ending at the same node 
a 

n

m

a 

a

n

and

b 

b

m

is  r c   for a role r  and either  i  some r edge of n  has r as its role and g 
as its restriction graph with subsumes  c  g     or  ii  subsumes  c  g       reason 
 r       
   d is  a c   for an attribute a  and  i  some a edge of g is of the form  n    a  n     and
subsumes  c   n  e  n    l    or  ii  some r edge of n  has a as its attribute  and g  as
its restriction graph with subsumes  c  g     or  iii  subsumes  c  g     

  

d

  

d

is e u f and both subsumes  e  g  and subsumes  f  g  are true 

there are only two differences between this algorithm and the one for total attributes presented by borgida and patel schneider  see also algorithm     first  in the partial attribute
case  given d    a c   one needs to look up the value restriction either in some a edge or
some r edge of g  since attributes can label both a edges and r edges   in the total attribute
case  attributes can only label a edges so that examining r edges was not necessary   the
second and most important distinction is the treatment of same as equalities  as shown in
the above algorithm  with d   a     a   b     b one only needs to check whether there
exist two paths labeled v    a     a and w    b     b leading the same node in g  in the
total attribute case  however  it suces if there exist prefixes v  and w  of v and w with this
property  as long as the remaining suxes are identical 
soundness and completeness of this algorithm is stated in the following theorem 
theorem   let c   d be classic descriptions  then  c v d iff subsumes  d  g   
where g is the canonical form of g c   
the soundness of the subsumption algorithm  i e   the if direction in the theorem stated
above  is pretty obvious  as in  borgida   patel schneider         the main point of the
only if direction  proof of completeness  is that the canonical graph g is deterministic 
i e   from any node  given a role or attribute name r  there is at most one outgoing r edge
or a edge with r as label  we point the reader to  borgida   patel schneider        for
the proof  since it is almost identical to the one for total attributes already published there 
these proofs reveal that  for the if direction of theorem    description graphs need not be
normalized  thus  one can also show 
n

m

n

m

c

c

c

   

fi steres  borgida
ku

remark   let g be some  not necessarily normalized description graph  and let
concept description  then  subsumes  d  g  implies g v d 

d

be a

classic

borgida and patel schneider argue that the canonical description graph g of a concept
description c can be constructed in time polynomial in the size of c   furthermore  algorithm   runs in time polynomial in the size of g and d  it is not hard to see that the
changes presented here do not increase the complexity  thus  soundness and completeness
of the subsumption algorithm provides us with the following corollary 
corollary   subsumption for classic concept descriptions c and d  where attributes
are interpreted as partial functions  can be decided in time polynomial in the size of c and
d 
   computing the lcs in

classic

in this section  we will show that the lcs of two classic concept descriptions can be stated
in terms of a product of canonical description graphs  a similar result has been proven by
cohen and hirsh      a  for a sublanguage of classic   which only allows for concept
names  concept conjunction  value restrictions  and same as equalities  in particular  this
sublanguage does not allow for inconsistent concept descriptions  which  for example  can be
expressed by conicting number restrictions   furthermore  the semantics of the description
graphs provided by cohen and hirsh restricts the results to the case when description graphs
are acyclic  this excludes  for example  same as equalities of the form    spouse  spouse 
in the following  we first define the product of description graphs  then  we show that
for given concept descriptions c and d  the lcs is equivalent to a description graph obtained
as the product of g and g   our constructions and proofs will be quite close to those in
 cohen   hirsh      a  
c

d

    the product of description graphs

a description graph represents the constraints that must be satisfied by all individuals in the
extension of the graph  intuitively  the product of two description graphs is the intersection
of these constraints as the product of finite automata corresponds to the intersection of the
words accepted by the automata  however  in the definition of the product of description
graphs special care has to be taken of incoherent nodes  i e   nodes labeled with    also 
since attributes may occur both in r edges and a edges  one needs to take the product
between restriction graphs of r edges  on the one hand  and the original graphs g  or g 
 rooted at certain nodes   on the other hand 
definition   let g     n    e    n    l    and g     n    e    n    l    be two description graphs 
then  the product g    g   g      n  e  n    l  of the two graphs is recursively defined as
follows 
  
  
  

   n   n   
n      n    n    
e   f  n  n     a   m  m     j  n  a  m    e  and  n    a  m      e  g 
n

   

fiwhat s in an attribute 

   let n   n  and n    n    if l   n       then let l  n  n        l   n    and  analogously 
if l   n         then l  n  n        l   n   otherwise  for l   n     s    h    and l   n     
 s    h    define l  n  n        s  h   where
 a 
 b 

s

   s    s  

  
 
 
 
 
 
  j  r  p    q    g      h     r  p    q    g      h  g  
f a        g  m  g    j  n  a  m    e     a  p    q    g      h  g  
f a        g   g  m   j  a  p    q    g      h     n   a  m    e  g 
h

 

 

 

f r  min p    p    max q    q    g   g 
 

j

 

 

 

 

j

 

according to this definition  if in the tuple  n  n   some node  say n  is incoherent  then
the label of  n  n    coincides with the one for n   the reason for defining the label in this
way is that lcs    c    c for every concept description c   this has been overlooked by
frazier and pitt         thus making their constructions and proofs only hold for concept
descriptions that do not contain inconsistent subexpressions 
note that g  as defined here  might not be connected  i e   it might contain nodes that
cannot be reached from the root n   even if g  and g  are connected this can happen
because all tuples  n   n    belong to the set of nodes of g regardless of whether they are
reachable from the root or not  however  as already mentioned in section     we may
assume g to be connected 
also note that the product graph can be translated back into a classic concept
description since the product of two description graphs is once again a description graph 
    computing the lcs

we now prove the main theorem of this subsection  which states that the product of two
description graphs is equivalent to the lcs of the corresponding concept descriptions 
theorem   let c  and c  be two concept descriptions  and let g  and g  be corresponding
canonical description graphs  then  c       lcs c    c    
g

g

let g    g   g    we will only sketch the proof showing that c subsumes c  and 
by symmetry  also c   see  kusters   borgida        for details   by construction  if there
are two rooted paths to a common node in g  then g  has corresponding paths leading to
the same node as well  thus  by theorem    the same as equalities in c subsume the ones
in c    now  let t be a spanning tree of g   m   m    be a node in g  and v be the label of
the rooted path in t to  m    m     then  by construction it follows that there exists a rooted
path in g  to m  labeled v  furthermore  a rather straightforward inductive proof shows
that the concept description e corresponding to the label of  m    m    subsumes g  j  
this implies  v e w g    as a result  we can conclude g w g   
the more interesting part of the proof is to show that c is not only a common subsumer
of c  and c   but the least common subsumer 
we now show by induction over the size of d  c   and c  that if d subsumes c  and
c    then d subsumes c   we distinguish different cases according to the definition of
 subsumes    let g     n    e    n   l    be the canonical description graph of c   g   
 n    e    n   l    be the canonical description graph of c    and g    n  e  n    l    g   g   
in the following  we assume that c  v d and c  v d  thus  subsumes  d  g   and
proof 

g

g

m 

g

g

   

fi steres  borgida
ku

  d  g    we show that subsumes  d  g   then  remark   implies g v d  and
thus  c v d  note that one cannot use theorem   since g might not be a canonical
description graph 
   if g is incoherent  then there is nothing to show 
   if d is a concept name     or a number restriction  then by definition of the label of
n  it is easy to see that subsumes  d  g  
   if d is v   w  then there exist nodes m  in g  and m  in g  such that there are two
paths from n  to m  with label v and w  respectively  as well as two paths from n  to
m  with label v and w  then  by definition of g it is easy to see that there are two
paths from n     n   n    to  m    m   with label v and w  respectively  this shows
subsumes  d  g  
   if d is  r c   r a role or attribute  then one of several cases applies 
 i  n  and n  have r edges with role or attribute r  and restriction graphs g   and g    
respectively  such that subsumes  c  g     and subsumes  c  g     
 ii  without loss of generality  n  has an a edge pointing to m  with attribute r  such
that subsumes  c  g      where g      g  j   and n  has an r edge with restriction
graph g   such that subsumes  c  g     
in both cases  i  and  ii   subsumes  c  g    g     follows by induction  furthermore 
by definition of g there is an r edge with role r and restriction graph g    g   for n  
this implies subsumes  d  g  
 iii  n  and n  have a edges with attribute r leading to nodes m  and m    respectively  then  subsumes  c  g  j   and subsumes  c  g  j    by induction  we know
subsumes  c  g  j
 g  j    it is easy to see that gj 
 g  j   fur    g  j
thermore  by definition there is an a edge with attribute r from  n   n    to  m    m   
in g  this shows subsumes  d  g  
 iv   without loss of generality  n  has no r edge and no a edge with role or attribute
r   this implies subsumes  c  g      which also ensures subsumes  d  g  
   if d is e u f   then by definition of the subsumption algorithm  subsumes  e  g    and
subsumes  e  g    hold  by induction  we have subsumes  e  g   and analogously 
subsumes  f  g   thus  subsumes  d  g  
ut
as stated in section      a canonical description graph for a classic concept description
can be computed in time polynomial in the size of the concept description  it is not hard
to verify that the product of two description graphs can be computed in time polynomial in
the size of the graphs  in addition  the concept description corresponding to a description
graph can be computed in time polynomial in the size of the graph  thus  as a consequence
of theorem   we obtain 
subsumes
g

m 

m 

m 

m 

m 

m   m 

m 

m 

corollary   the lcs of two classic concept descriptions always exists and can be computed in time polynomial in the size of the concept descriptions 
   

fiwhat s in an attribute 

j   j    i

j   j    i

i

a

a

a

i

a

figure    the canonical description graph for d   without node labels 
i

as intimated in  cohen et al          this statement does not hold for sequences of concept
descriptions  intuitively  generalizing the lcs algorithm to sequences of  say  n concept descriptions  means computing the product of n description graphs  the following proposition
shows that the size of such a product graph may grow exponentially in n  thus  the lcs
computed in this way grows exponentially in the size of the given sequence  however  this
does not imply that this exponential blow up is unavoidable  there might exist a smaller 
still equivalent representation of the lcs  nevertheless  we can show that the exponential
growth is inevitable 
proposition   for all integers n    there exists a sequence d            d of classic
concept descriptions such that the size of every classic concept description equivalent to
lcs d            d   is at least exponential in n where the size of the d   s is linear in n 
proof  as in cohen et al          for a given n  define the concept descriptions d as
follows 
d    u      a   u u  a   a a   u      a a  
  
  
n

n

i

i

i

j

j

i

j

i

i

i

j

i

i

where a            a denote attributes  the canonical description graph for d is depicted in
figure    using algorithm   it is easy to see that d v v   w iff the number of a   s in v and
the number of a   s in w are equal modulo   where v  w are words over fa            a g  this
implies that
d            d v v   w
iff for all    i  n the number of a  s in v and
   
 
the number of a s in w are equal modulo   
let s  f           ng be a non empty set  we define v    a    a k where i         i
are the elements of s and w    a   a      a k   with a      a a a   now let e be the lcs
of d            d   and let g be the corresponding canonical description graph with root n  
from     we know that e v v   w for every s  f           ng  algorithm   implies that
the paths from n  in g labeled v and w exist and that they lead to the same node q  
assume there are non empty subsets s  t of f           ng  s    t  such that q   q   this would
imply e v v   v in contradiction to      thus  s    t implies q    q   since there are
    non empty subsets of f           ng  this shows that g contains at least     nodes 
the fact that the size of g is linear in the size of e completes the proof 
ut
this proposition shows that algorithms computing the lcs of sequences are necessarily worstcase exponential  conversely  based on the polynomial time algorithm for the binary lcs
operation  an exponential time algorithm can easily be specified employing the following
identity lcs d            d    lcs d   lcs d     lcs    lcs d    d        
n

i

i

i

i

n

n

i

i

i 

s

i 

s

n

i 

i

j

i

j

j

k

j

e

s

s

e

s

s

s

s

s

t

s

n

e

e

n

n

n

   

t

t

n

fi steres  borgida
ku

corollary   the size of the lcs of sequences of classic concept descriptions can grow
exponentially in the size of the sequences and there exists an exponential time algorithm for
computing the lcs 
   the lcs for same as and total attributes

in the previous sections  attributes were interpreted as partial functions  in this section 
we will present the significant changes in computing the lcs that occur when considering
total functions instead of partial functions  more precisely  we will look at a sublanguage
s of classic that only allows for concept conjunction and same as equalities  but where
we have the general assumption that attributes are interpreted as total functions 
we restrict our attention to the language s in order to concentrate on the changes
caused by going from partial to total functions  we strongly conjecture  however  that the
results represented here can easily be transfered to classic by extending the description
graphs for s as in section   
first  we show that in s the lcs of two concept descriptions does not always exist 
then  we will present a polynomial decision algorithm for the existence of an lcs of two
concept descriptions  finally  it will be shown that if the lcs of two concept descriptions
exists  then it might be exponential in the size of the given concept descriptions and it can
be computed in exponential time 
in the sequel  we will simply refer to the lcs by lcs  since throughout the section
attributes are always assumed to be total  this does not lead to any confusion 
once again  it may be useful to keep in mind that for total  though not partial  attributes
we have  u   v  v  u  w   v  w  for any u  w  v   a  where a is the set of finite words
over a  the finite set of attribute names  indeed  all the differences between partial and
total attributes shown in this section finally trace back to this property 
t

t

t

t

t

    the existence of the lcs

in this subsection  we prove that the lcs of two concept descriptions in s does not always
exist  nevertheless  there is always an infinite representation of the lcs  which will be used
in the next subsection to characterize the existence of the lcs 
to accomplish the above  we return to the graph based characterization of t subsumption
proposed by borgida and patel schneider         and modified for partial attributes in section    for a concept description c   let g denote the corresponding canonical description
graph  as defined in section      its semantics is specified as in section      although now
the set of interpretations is restricted to allow attributes to be interpreted as total functions
only 
since s contains no concept names and does not allow for value restrictions  the nodes
in g do not contain concept names and the set of r edges is empty  therefore  g can
be defined by the triple  n  e  n    where n is a finite set of nodes  e is a finite set over
n  a  n   and n  is the root of the graph 
as a corollary of the results of borgida and patel schneider  subsumption c v d of
concept descriptions c and d in s can be decided with the following algorithm  which also
provides us with a characterization of t subsumption 
c

c

c

t

   

fiwhat s in an attribute 

g

c   

d   

c

g
a

a

b

b

d

d
c

figure    the canonical graphs for c  and d 
algorithm   let c   d be concept descriptions in s   and g    n  e  n    be the canonical
description graph of c   then  subsumes   d  g   is defined to be true if and only if one
of the following conditions hold 
c

t

  

c

is v   w and there are words v    w    u   a such that v   v  u and w   w  u  and
there are rooted paths in g labeled v  and w    respectively  ending at the same node 

d

c

  and subsumes   d    g   are true 
apart from the additional constructors handled by algorithm    algorithm   only differs
from algorithm   in that  for total attributes  as considered here  it is sucient if prefixes
of rooted paths v and w lead to a common node  as long as the remainder in both cases is
the same path 
  

d

is d  u d  and both subsumes   d    g
t

c

t

c

theorem   there are concept descriptions in s such that the lcs of these concept descriptions does not exist in s  

this result corrects the statement of cohen et al         that the lcs always exists  a
statement that inadvertently assumed that attributes were partial  not total 
as proof  we offer the following s  concept descriptions  which are shown not to have an
lcs 
c     a   b 
d     a   ac u b   bc u ad   bd 
the graphs for these concepts are depicted in figure   
the following statement shows that an lcs e of c  and d  would satisfy a condition
which does not have a  regular structure   this statement can easily be verified using
algorithm   
e v v w
iff v   w or there exists a nonnegative integer n and u  
a such that v   ac du and w   bc du or vice versa 
given this description of the lcs of c  and d    one can show  again  by employing algorithm    that no finite description graph can be equivalent to e   however  we omit this
elementary proof here  because the absence of the lcs also follows from theorem    where
infinite graphs are used to characterize the existence of an lcs  note that in the partial
attribute case  the lcs of c  and d  is equivalent to a   a u b   b  a result that can be
t

n

   

n

fi steres  borgida
ku

obtained by the lcs algorithm presented in the previous section  the corresponding  finite  description graph consists of a root and two additional nodes  where the root has two
outgoing edges leading to the two nodes and labeled a and b  respectively 
to state theorem    we first introduce infinite description graphs and show that there
always exists an infinite description graph representing the lcs of two s  concept descriptions 
an infinite description graph g is defined  like a finite graph  by a triple  n  e  n   
except that the set of nodes n and the set of edges e may be infinite  as in the finite case 
nvn    g means that g contains a path from n to n  labeled with the word v   a   the
semantics of infinite graphs is defined as in the finite case  furthermore  infinite graphs are
translated into concept descriptions as follows  take an  infinite  spanning tree t of g  and 
as in the finite case  for every edge of g not contained in it  add to c a same as equality 
note that in contrast to the partial attribute case  c need not contain same as equalities of
the form v   v since  for total attributes  v   v     still  c might be a concept description
with an infinite number of conjuncts  thus  an infinite concept description   the semantics
of such concept descriptions is defined in the obvious way  analogously to lemma    one
can show that an  infinite  graph g and its corresponding  infinite  concept description c
are equivalent  i e   c  g 
we call an  infinite  description graph g deterministic if  and only if  for every node n
in g and every attribute a   a there exists at most one a successor for n in g  the graph
g is called complete if for every node n in g and every attribute a   a there is  at least 
one a successor for n in g  clearly  for a deterministic and complete  infinite  description
graph  every path is uniquely determined by its starting point and its label 
algorithm    which deals with finite description graphs g   can be generalized to deterministic and complete  infinite  description graphs g in a straightforward way  to see
this  first note that a  finite  description graph coming from an s  concept description is
canonical iff it is deterministic in the sense just introduced  analogously  a deterministic
infinite graph can be viewed as being canonical  thus  requiring  infinite  graphs to be
deterministic satisfies the precondition of algorithm    now  if in addition these graphs are
complete  then  unlike the condition stated in the subsumption algorithm  it is no longer
necessary to consider prefixes of words because a complete graph contains a rooted path
for every word  more precisely  if v  and w  lead to the same node  then this is the case for
v   v   u and w   w  u as well  thus making it unnecessary to consider the prefixes v   and w 
of v and w  respectively  summing up  we can conclude 
corollary   let g    n  e  n    be a deterministic and complete  infinite  description
g

g

g

g

g

c

graph and

v  w

  a  then 
gv v w
iff
t

n  vn

  g and n wn   g for some node n 

we shall construct an  infinite  graph representing the lcs of two concept descriptions in s
as the product of the so called completed canonical graphs  this infinite representation of
the lcs will be used later to characterize the existence of an lcs in s   i e   the existence of a
finite representation of the lcs 
we now define the completion of a graph  intuitively  a graph is completed by iteratively
adding outgoing a edges labeled with an attribute a for every node in the graph that does
not have such an outgoing a edge  this process might extend a graph by infinite trees  as
an example  the completion of g  cf  figure    is depicted in figure   with a   fa  b  c  dg 
c 

   

fiwhat s in an attribute 

g

 
c  
 

a

d



c

c

b

b

d

a

a

b

c

d

a

b

c

d

   
   
figure    the complete graph for c 
formally  completions are defined as follows  let g be an  infinite  description graph 
the graph g  is an extension of g if for every node n in g and for every attribute a   a
such that n has no outgoing edges labeled a  a new node m is added  as well as an edge
 n  a  m    now  let g    g    g          be a sequence of graphs such that g    g and g    is
an extension of g   for i     if g    n   e   n    then
   
g      
n 
e   n   
n a

i

n a

i

i

i

i

 

i

 
construction  g 
i

i

i

is called the completion of g  by
is a complete graph  furthermore  if
 
g is deterministic  then g is deterministic as well  finally  it is easy to see that a graph
and its extension sare equivalent  thus  by induction  g   g 
the nodes in   n   i e   the nodes in g  that are not in g  are called tree nodes  the
nodes of g are called non tree nodes  by construction  for every tree node t in g  there is
exactly one direct predecessor of t in g   i e   there is exactly one node n and one attribute
a such that  n  a  t  is an edge in g    n is called a predecessor of t  furthermore  there is
exactly one youngest ancestor n in g of a tree node t in g   n is the youngest ancestor of
t if there is a path from n to t in g  which does not contain non tree nodes except for n 
note that there is only one path from n to t in g   finally  observe that non tree nodes
have only non tree nodes as ancestors 
note that the completion of a canonical description graph is always complete and deterministic 
in the sequel  let c   d be two concept descriptions in s   g    n   e   n    g  
 n   e   n   be their corresponding canonical graphs  and g    g  be the completions of
g   g   the products g    g  g and g
     g   g  are specified as in definition   
as usual  we may assume g and g  are connected  i e   they only contain nodes that are
reachable from the root  n   n    otherwise  one can remove all those nodes that cannot be
reached from the root without changing the semantics of the graphs 
we denote the product g   g  by g  instead of g   or g   because otherwise
this graph could be confused with the completion of g  in general  these graphs do not
t

i

i

c

d

c

d

d

c

d

c

c

d

c

d

c

d

   

d

c

d

c

c

d

fi steres  borgida
ku

coincide  as an example  take the products g  g and g   g   see figure   for the
graphs g and g    the former product results in a graph that consists of a root with
two outgoing a edges  one labeled a and the other one labeled b   as mentioned before  this
graph corresponds to the lcs of c  and d  in the partial attribute case   the product of
the completed graphs  on the other hand  is a graph that is obtained as the completion of
the graph depicted in figure    the infinite trees are omitted for the sake of simplicity  
as an easy consequence of the fact that g  g  and corollary    one can prove the
following lemma 
c 

lemma  

c 

d 

c

c

c 

d 

d 

c

v v   w iff n
t

c

vn

  g  and n
c

c

wn

  g  for a node n in g   
c

c

but then  by the construction of g  we know 
proposition   c v
for a node n in g   

t

v

  w and d v v   w iff  n
t

c

    g  and  n

  nd vn

c

 

  nd wn

  g 

in particular  g  represents the lcs of the concept descriptions c and d in the following
sense 
corollary   the  infinite  concept description c   corresponding to g  is the lcs of c
and d  i e   i  c  d v c   and ii  c  d v e   implies c   v e   for every s  concept
description e    
g

t

t

g

t

g

    characterizing the existence of an lcs

let c   d be concept descriptions in s and let the graphs g   g   g  g    g   and g 
be defined as above 
we will show that g  not only represents a  possibly infinite  lcs of the s  concept
descriptions c and d  corollary     but that g  can be used to characterize the existence
of a finite lcs  the existence depends on whether g  contains a finite or an infinite number
of so called same as nodes 
definition   a node n of an  infinite  description graph h is called a same as node if
c

there exist two direct predecessors of
may be labeled differently  

a

n

in

h 

d

 the a edges leading to

c

c

c

d

d

d


b

d

d

d

c

c

c

figure    a subgraph of g   g 
c 

   

d 

c

n

d

from these nodes

fiwhat s in an attribute 

for example  the graph depicted in figure   contains an infinite number of same as nodes 
we will show that this is a sucient and necessary condition for the lcs of c  and d  not
to exist 
it is helpful to observe that same as nodes in g  have one of the forms  g  f     f  t  
and  t  f    where g and f are non tree nodes and t is a tree node  there cannot exist a
same as node of the form  t   t     where both t  and t  are tree nodes  since tree nodes
only have exactly one direct predecessor  and thus  t   t    does  moreover  if g  has an
infinite number of same as nodes  it must have an infinite number of same as nodes of the
form  f  t  or  t  f    because there only exist a finite number of nodes in g  of the form
 g  f    for this reason  in the following lemma we only characterize same as nodes of the
form  f  t    nodes of the form  t  f   can be dealt with analogously   to state the lemma 
recall that with n un vn    h   for some graph h   we describe a path in h labeled uv
from n  to n  that passes through node n  after u  i e   n un    h and n vn    h    this
is generalized the obvious way to interpret n u n u n u n    h  
g

 

 nc   nd  
v

w

 h    p   

x

 h    p   

g

  
 

  
 
  

v
h

w
h 

  
 x

 e    q   

 e    q   
a

e 

  

e 

a
n

   f  t 

figure    same as nodes in g 
lemma   given a node f in g and a tree node t in g    the node n    f  t  in g  is a
same as node iff
c




d

there exist nodes  h    p      h    p    in g  h     h   
there exist nodes  e    q      e    q    in g    where e    e  are distinct nodes in g and
q  is a node in g    and
there exists an attribute a   a and v  w  x   a   v    w  where a is the set of attributes
in c  
c

d



such that

 n

c

   

   

      and  n

         
for the direct successors  h     p     and  h     p     of  h    p   

  nd v h    p  x e    q  a f  t

c

   

  nd w h    p  x e    q  a f  t

are paths in g   see figure    
and  h    p    in this paths  we  in addition  require p   to be a tree node in g    
d

   note that since g
  is deterministic  the successors of  h    p    and  h    p    in the two paths must in fact
be of the form    p     

   

fi steres  borgida
ku

the if direction is obvious  we proceed with the only if direction and assume that
is a same as node in g   let p  be the  uniquely determined  youngest ancestor of t in
g    in particular  p  is a node in g and there exists p  xq  at in g  with a   a and
x   a such that the successor of p  in this path is a tree node in g  
since n is a same as node and t can only be reached via q  and the attribute a  there
must exist e    e  in g   e     e    with  e    q   a f  t    e    q  a f  t    g   since g  is
connected  there are paths from  n   n   to  e    q   and  e    q    every path from n to q 
must pass through p  and the sux of the label of this path is x  consequently  there exist
nodes h    h  in g such that  h    p   x e    q   a f  t  and  h    p  x e    q  a f  t  are paths
in g   in particular  xa is a label of a path from h  to f in g   and the label xa only
consists of attributes contained in c   if h    h   then this  together with the fact that g
is deterministic  would imply e    e    hence  h     h    let v  w be the labels of the paths
from  n   n   to  h    p    and  h    p    respectively  as g is deterministic and h     h   it
follows that v    w 
ut
the main results of this section is stated in the next theorem  as a direct consequence of
this theorem  we obtain that there exists no lcs in s for the concept descriptions c  and
d  of our example 
proof 
n

d

d

d

d

c

c

d

d

c

c

c

c

d

theorem   the lcs of c and d exists iff the number of same as nodes in g  is finite 

we start by proving the only if direction  for this purpose  we assume that g 
contains an infinite number of same as nodes and show that there is no  finite  lcs for c
and d in s  
as argued before  we may assume that g  contains an infinite number of same as nodes
of the form  f  t  or  t  f    where t is a tree node and f is a non tree node  more precisely 
say g  contains for every i    nodes n    f   t   such that f is a node in g and t is
a tree node in g   according to lemma    for every same as node n there exist nodes
h    h    e    e  in g   p  in g   and q  in g  as well as a   a and x   a with the
properties required in lemma   
since g and g are finite description graphs  the number of tuples of the form
h    h    e    e    f   a is finite  thus  there must be an infinite number of i s yielding
the same tuple h   h    e    e    f  a  in particular  h     h  and e     e  are nodes in g and
there is an infinite number of same as nodes of the form n    f  t     finally  as in the
lemma  let v  w be the label of paths  in g  from  n   n   to  h    p    and  h    p    
now  assume there is an lcs e of c and d in s   according to corollary    e  c    
let g be the finite canonical graph for e with root n   by proposition   and lemma  
we know e v vx a   wx a  from algorithm   it follows that there are words v   w    and u
such that vx a   v  u and wx a   w  u  where the paths in g starting from n  labeled v   
w  lead to the same node in g  
if u       then u   u a for some word u   then  algorithm   ensures e v vx   wx  
however  by lemma   we know that the words vx and wx lead to different nodes in
g
    namely   e    q    and  e    q     which  with proposition    leads to the contradiction
e  g
   v vx   wx   thus  u     
as a result  for every i    there exists a node q in g such that n vx aq and n wx aq
are paths in g   because g is a finite description graph  there exist i  j     i    j   with
proof 

i

i

i

i

c

d

 i

 i

 i

 i

c

c

 i

 i

i

i

 i

d

 i

i

d

i

d

 i

 i

i

i

c

i

c

 i

d

t

g

e

t

i

i

i

i

e

e

t

i

 i

t

i

i

 i

i

i

e

i

i

e

   

e

i

i

i

i

fiwhat s in an attribute 

  q   by algorithm    this implies e v vx a   wx a  on the other hand  the path in
starting from  n   n   with label vx a leads to the node n and the one for wx a leads
to n   since n    n   proposition   implies e  v vx a   wx a  which is a contradiction  to
sum up  we have shown that there does not exist an lcs for c and d in s  
this shows that there is no lcs of c   d in s which completes the proof of the only if
direction 
we now prove the if direction of theorem    for this purpose  we assume that g  has
only a finite number of same as nodes  note that every same as node in g  has only a
finite number of direct predecessors  to see this  two cases are distinguished  i  a node of
the form  g    g    in g has only predecessors in g  ii  if t is a tree node and g a non tree node 
then a predecessor of  g  t  in g  is of the form  g    t   where t  is the unique predecessor
 tree or non tree node  of t and g  is a non tree node  since the number of nodes in g
and g is finite  in both cases we only have a finite number of predecessors  but then  the
spanning tree t of g  coincides with g  except for a finite number of edges because  if t
does not contain a certain edge  then this edge leads to a same as node  as a result  c  
is an s  concept description because it is a finite conjunction of same as equalities  finally 
corollary   shows that c   is the lcs of c and d 
ut
if v   w is a conjunct in c     then v and w lead from the root of g  to a same as node 
as mentioned before  same as nodes are of the form  f  g    f  t   or  t  f    where t is a tree
node and f  g are non tree nodes  consequently  v and w must be paths in g or g  
thus  they only contain attributes occurring in c or d 
qi

g
 

j

t

c

j

i

d

i

j

i

i

j

t

i

j

j

c

d

g

g

g

c

d

corollary   if the lcs of two concept description c and d in s exists  then there is a
concept description in s only containing attributes occurring in c or d that is equivalent
to the lcs 

therefore  when asking for the existence of an lcs  we can w o l g  assume that the set of
attributes a is finite  this fact will be used in the following two subsections 
    deciding the existence of an lcs

from the following corollary we will derive the desired decision algorithm for the existence
of an lcs of two concept descriptions in s   to state the corollary we need to introduce the
language l c  q    q      fw   a j there is a path from the node q  to q  in g labeled wg 
since description graphs can be viewed as finite automata  such a language will be regular 
moreover  let aa denote the set faw j w   ag for an attribute a   a  where a is a finite
alphabet 
g

c

corollary   g  contains an infinite number of same as nodes iff either
 i  there exist nodes  h    p      h    p    in g as well as nodes f   e    e  in g   and attributes
a  b   a such that
c

  

h 

   h    e     e   

  

p 

does not have a b successor in g  

  

 e    a  f     e    a  f   are edges in g

d

c

  and
   

fi steres  borgida
ku

  

 

lgc h    e 

    l c  h    e      ba is an infinite set of words 
g

or
 ii  the same statement as  i  but with r oles of c and

d

switched 

we first prove the only if direction  assume that g  contains an infinite number
of same as nodes  then  w l o g   we find the configuration in g  described in the proof
of theorem    this configuration satisfies the conditions    and    stated in the corollary 
if  for i    j   the words x and x coincide  we can conclude n   n because g  is a
deterministic graph  however  by definition  n    n   hence  x    x   because a is finite 
we can  w l o g   assume that all x  s have b   a as their first letter for some fixed b  thus 
condition    is satisfied as well  according to the configuration  the b successor of    p    in
g
  is of the form    p     where p   is a tree node  thus  p  does not have a b successor in
g   which means that condition    is satisfied 
we now prove the if direction of the corollary  for this purpose  let bx   l c  h    e     
l c  h    e      ba   since p  has no b successor in g it follows that there are tree nodes
t  t  in g  such that p  bxtat    g    thus  we have  h    p   bx e    t a f  t      g
  and
 

 h    p   bx e    t a f  t     g   since e     e   we can conclude  e    t      e    t   this means
that  f  t   is a same as node  analogously  for by   l c  h    e      l c  h    e      ba there
are tree nodes s  s  in g  such that p bysas    g  and  f  s   is a same as node in g  
since bx and by both start with b  and the b successor of p  in g  is a tree node  x    y
implies s     t   hence   f  t   and  f  s   are distinct same as nodes  this shows that if the
set l c  h    e      l c  h    e      ba is infinite  g  must have an infinite number of same as
nodes 
ut
for given nodes  h    p     h    p    in g  attributes a  b   a  nodes f  e   e    g the conditions    to    in corollary   can obviously be checked in time polynomial in the size of the
concept descriptions c and d  as for the last condition  note that an automaton accepting
the language l c  h    e      l c  h    e      ba can be constructed in time polynomial in the
size of c   furthermore  for a given finite automaton it is decidable in time polynomial in
the size of the automaton if it accepts an infinite language  see the book by hopcroft and
ullman        for details   thus  condition    can be tested in time polynomial in the size
of c and d as well  finally  since the size of g and g is polynomial in the size of c and d 
only a polynomial number of configurations need to be tested  together with corollary  
these complexities provide us with the following corollary 
proof 

i

j

i

i

j

j

i

j

i

d

g

g

d

d

d

g

d

g

d

d

g

g

c

g

g

c

corollary   for given concept descriptions c and d in s it is decidable in time polynomial
in the size of c and d whether lcs of c and d exists in s  
    computing the lcs

in this subsection  we first show that the size of an lcs of two s  concept descriptions may
grow exponentially in the size of the concept descriptions  this is a stronger result than
that presented for partial attributes  where it was only shown that the lcs of a sequence of
concept descriptions in s can grow exponentially  then  we present an exponential time lcs
algorithm for s  concept descriptions 
   

fiwhat s in an attribute 

gc  

 

gdk

 

a

c

c



a

b

a

d

d

c

c

b

a


d

d

k

figure    the canonical description graphs for c   and d

k

in order to show that the lcs may be of exponential size  we consider the following
example  where a    fa  b  c  dg we define
     a   b 
c
d
   u   ac   ad u u   bc   bd u ac a   bc a 
the corresponding canonical description graphs g   and g k are depicted in figure   
a finite graph representing the lcs of c   and d is depicted in figure   for k     
this graph can easily be derived from g    g k   the graph comprises two binary trees
of height k  and thus  it contains at least   nodes  in the following  we will show that
there is no canonical description graph g k  with root n   representing the lcs e of c  
and d with less than   nodes  let x   fc  dg be a word of length k over fc  dg  and let
v    axa  w    bxa  using the canonical description graphs g   and g k it is easy to see
that c   v v   w and d v v   w  thus  e v v   w  by algorithm    this means that
there are words v   w    u such that v   v  u  w   w  u  and there are paths from n  labeled
v   and w  in g k leading to the same node in g k   suppose u       then  algorithm  
implies e v ax   bx  but according to g   d  v ax   bx  therefore u must be the empty
k

k

i

k

i

i

i

i

k

k

i

d

c

k

d

c

k

e

k

k

k

k

d

c

t

t

k

t

k

e

k

e

t

d

a

c

t

b

d

d

c

 
c

d

a

c

a

a

d

d

a

a

c

a

d

a

c

a

figure    a finite graph representing the lcs of c   and d 
   

fi steres  borgida
ku

word    this proves that in g k there is a path from n  labeled axa for every x   fc  dg  
hence  there is a path for every ax  now  let y   fc  dg be such that x    y  if the paths
for ax and ay from n  in g k lead to the same node  then this implies e v ax   ay in
contradiction to c    v ax   ay  as a result  ax and ay lead to different nodes in g k   since
fc  dg contains   words  this shows that g k has at least   nodes  finally  taking into
account that the size of a canonical description graph of a concept description in s is linear
in the size of the corresponding description we obtain the following theorem 
k

e

k

e

k

t

t

k

e

k

k

e

theorem   the lcs of two s  concept descriptions may grow exponentially in the size of
the concepts 

the following  exponential time  algorithm computes the lcs of two s  concept descriptions
in case it exists 
algorithm  
input  concept descriptions c   d in s   for which the lcs exists in s  
output  lcs of c and d in s  
   compute g     g

g

c

d

 

   for every combination

 of nodes  h    p      h    p   in g   g  g   h     h   
 a   a  e    e    f in g   e     e    where  e    a  f   and  e    a  f   are edges in g
c

d

c

extend g  as follows  let g
in

c

h   t

 g

h   t

be two trees representing the  finite  set of words

 
l     l c  h    e      l c  h    e     
g

 

g

b

  succ 

p 

 

   
f g  if a    succ p  
ba a  

 

 

otherwise

where succ p       fb j p  has a b successorg and the set of nodes of g     g     and
g  are assumed to be disjoint  now  replace the root of g   by  h    p     the root of
g   by  h    p     and extend g  by the nodes and edges of these two trees  finally 
add a new node n for every word v in l  and for each node of the trees g   and
g   reachable from the root of g   and g   by a path labeled v   add an edge with
label a from it to n   the extension is illustrated in figure    
h  t

h  t

h  t

h  t

v

h  t

h  t

h  t

h  t

v

   the same as in step    with r oles of c and d switched 
   compute the canonical graph of g    which is called g  again  then  output the concept
description c   of g   
g

proposition   the translation
of c and d 

cg 

of the graph g  computed by algorithm   is the lcs e
   

fiwhat s in an attribute 

 

g

 h    p   

 h    p   

b

a

b

a

b

n

a
c

a

a
c

a

bc

n
d

a

a

d

bad

n

figure     the extension at the nodes  h    p     h    p    in g  where l   fb  bc  badg
it is easy to see that if there are two paths in g  labeled y  and y  leading from
the root  n   n   to the same node  then g  contains such paths as well  consequently 
 e   g  v g  
now  assume e v y    y   y     y   by proposition   we know that there are paths
in g  labeled y  and y  leading to the same node n  w l o g  we may assume that n is a
same as node in g   otherwise  there exist words y    y     u with y    y  u  y    y  u such
that y   and y   lead to a same as node  if we can show that g  contains paths labeled y  
and y   leading to the same node  then  by algorithm    this is sucient for g  v y    y  
so let n be a same as node  we distinguish two cases 
   if n is a node in g   g  g   then the paths for y  and y  are paths in g  since g
is a subgraph of g  this holds for g  as well  hence  c   v y    y  
   assume n is not a node in g  then  since n is a same as node  we know that n is of the
form  f  t  or  t  f   where f is a non tree node and t is a tree node  by symmetry  we
may assume that n    f  t   now it is easy to see that there exist nodes h    h    e    e  in
g   p  in g   and a tree node q  in g  as well as a   a and x  v  w   a as specified
in lemma   such that y    vxa and y    wxa  but then  with h    h    e    e    p   f and
a the preconditions of algorithm   are satisfied and x   l  therefore  by construction
of g  there are paths labeled y  and y   respectively  leading from the root to the same
node 
ut
we note that the product g of g and g can be computed in time polynomial in the
size of c and d  furthermore  there is only a polynomial number of combinations of nodes
 h    p      h    p   in g  e    e    f in g   a   a  finally  the finite automaton for l can be
computed in time polynomial in the size of c and d  in particular  the set of states of this
automaton can polynomially be bounded in the size of c and d  if l contained a word
longer than the number of states  the accepting path in the automaton contains a cycle  but
then  the automaton would accept infinitely many words  in contradiction to the assumption
that l is finite  thus  the length of all words in l can be bounded polynomially in the
size of c and d  in particular  this means that l contains only an exponential number of
words  trees representing these words can be computed in time exponential in the size of
c and d  
proof 

c

t

d

t

t

t

c

d

g

c

d

d

c

d

c

   

t

fi steres  borgida
ku

corollary   if the lcs of two s  concept descriptions exists  then it can be computed in time
exponential in the size of the concept descriptions 
   conclusion

attributes   binary relations that can have at most one value   have been distinguished
in many knowledge representation schemes and other object centered modeling languages 
this had been done to facilitate modeling and  in description logics  to help identify tractable
sets of concept constructors  e g   restricting same as to attributes   in fact  same as restrictions are quite important from a practical point of view  because they support the modeling
of actions and their components  borgida   devanbu        
a second distinction  between attributes as total versus partial functions  had not been
considered so essential until now  this paper has shown that this distinction can sometime
have significant effects 
in particular  we have first shown that the approach for computing subsumption of
classic concepts with total attributes  presented by borgida and patel schneider        
can be modified to accommodate partial attributes  by treating partial attributes as roles
until they participate in same as restrictions  in which case they are  converted  to total attributes  as a result  we obtain polynomial time algorithms for subsumption and
consistency checking in this case also 
in the case of computing least common subsumers  which was introduced as a technique
for learning non propositional descriptions of concepts  we first noted that several of the
papers in the literature  cohen   hirsh      a  frazier   pitt         implicitly  used
partial attributes  when considering classic  furthermore  these papers used a weaker
version of the  concept graphs  employed in  borgida   patel schneider         which
make the results only hold for the case of same as restrictions that do not generate  cycles  
furthermore  the algorithm proposed by frazier and pitt        does not handle inconsistent
concepts  which can easily arise in classic concepts as a result of conicts between lower
and upper bounds of roles 
therefore  we have provided an lcs algorithm together with a formal proof of correctness
for a sublanguage of classic with partial attributes  which allows for same as equalities
and inconsistent concepts   the algorithm and proofs can easily be extended to full classic
 kusters   borgida         in this case  the lcs always exists  and it can be computed in
time polynomial in the size of the two initial concept descriptions  as shown by cohen et al 
        there are sequences of concept descriptions for which the lcs may grow exponentially
in the size of the sequence 
to complete the picture  and as the main part of the paper  we then examined the
question of computing lcs in the case of total attributes  surprisingly  the situation here
is very different from the partial attribute case  unlike with subsumption   first  for the
language s the lcs may not even exist   the existence of the lcs mentioned by cohen et al 
       is due to an inadvertent switch to partial semantics for attributes   nevertheless 
the existence of the lcs of two concept descriptions can be decided in polynomial time  but
if the lcs exists  it may grow exponentially in the size of the concept descriptions  and hence
the computation of the lcs may take time exponential in the size of the two given concept
descriptions 
   

fiwhat s in an attribute 

as an aside  we note that it has been pointed out by cohen et al         that concept
descriptions in s correspond to a finitely generated right congruence  furthermore  in this
context the lcs of two concept descriptions is the intersection of right congruences  thus 
the results presented in this paper also show that the intersection of finitely generated
right congruences is not always a finitely generated right congruence  and that there is a
polynomial algorithm for deciding this question  finally  if the intersection can be finitely
generated  then the generating system may be exponential and can be computed with
an exponential time algorithm in the size of the generating systems of the given right
congruences 
the results in this paper therefore lay out the scope of the effect of making attributes
be total or partial functions in a description logic that supports the same as constructor 
moreover  we correct some problems and extend results in the previous literature 
we believe that the disparity between the results in the two cases should serve as a
warning to other researchers in knowledge representation and reasoning  concerning the
importance of explicitly considering the difference between total and partial attributes 
acknowledgments

the authors wish to thank the anonymous reviewers for their helpful comments  this
research was supported in part by nsf grant iri          it was carried out while the
first author was at the rutgers university and the rwth aachen 
references

artale  a   franconi  e   guarino  n     pazzi  l          part whole relations in objectcentered systems  an overview  data   knowledge engineering                  
baader  f          a formal definition for the expressive power of terminological knowledge representation languages  journal of logic and computation               
baader  f     kusters  r          computing the least common subsumer and the most
specific concept in the presence of cyclic aln  concept descriptions  in herzog 
o     gunter  a   eds    proceedings of the   nd annual german conference on
artificial intelligence  ki     vol       of lecture notes in computer science  pp 
        bremen  germany  springer verlag 
baader  f   kusters  r     molitor  r          computing least common subsumers in
description logics with existential restrictions  in dean  t   ed    proceedings of the
  th international joint conference on artificial intelligence  ijcai      pp        
stockholm  sweden  morgan kaufmann publishers 
baader  f     sattler  u          tableaux algorithms for description logics  in proceedings of the international conference on automated reasoning with analytic tableaux
and related methods  tableaux        vol       of lecture notes in artifical intelligence  pp       university of st  andrews  scotland 
   

fi steres  borgida
ku

borgida  a          on the relationship between description logic and predicate logic 
in proceedings of the third international conference on information and knowledge
management  cikm      pp          gaithersburg  maryland  acm press 
borgida  a          description logics in data management  ieee trans  on knowledge
and data engineering                 
borgida  a     devanbu  p          adding more  dl  to idl  towards more knowledgeable
component inter operability  in proceedings of the      international conference on
software engineering  pp          los angeles  ca usa  acm 
borgida  a     etherington  d          hierarchical knowledge bases and ecient disjunctive reasoning  in brachman  r     h j  levesque  r  r   eds    proceedings
of the  st international conference on principles of knowledge representation and
reasoning  kr      pp        toronto  canada  morgan kaufmann publishers 
borgida  a     kusters  r          what s not in a name  some properties of a purely
structural approach to integrating large dl knowledge bases  in baader  f    
sattler  u   eds    proceedings of the      international workshop on description
logics  dl       no     in ceur ws aachen  germany  rwth aachen 
borgida  a     patel schneider  p          a semantics and complete algorithm for subsumption in the classic description logic  journal of artificial intelligence research             
brachman  r   mcguinness  d   patel schneider  p     borgida  a           reducing 
classic to practice  knowledge representation theory meets reality  artificial
intelligence                     
calvanese  d   giacomo  g  d     lenzerini  m          what can knowledge representation do for semi structured data   in proceedings of the   th national conference
of the american association for artificial intelligence  aaai     pp           aaai
press the mit press 
calvanese  d   giacomo  g  d     lenzerini  m       a   modeling and querying semistructured data  network and information systems                 
calvanese  d   giacomo  g  d     lenzerini  m       b   reasoning in expressive description logics with fixpoints based on automata on infinite trees  in dean  t   ed   
proceedings of the   th international joint conference on artificial intelligence  ijcai      pp        stockholm  sweden  morgan kaufmann publishers 
calvanese  d   giacomo  g  d   lenzerini  m   nardi  d     rosati  r          description
logic framework for information integration  in cohn  a   schubert  l     shapiro  s 
 eds    proceedings of the  th international conference on the principles of knowledge
representation and reasoning  kr      pp       trento  italy  morgan kaufmann
publishers 
calvanese  d   lenzerini  m     nardi  d          unifying class based representation
formalisms  journal of artificial intelligence research              
   

fiwhat s in an attribute 

cohen  w  w     hirsh  h       a   learnability of description logics with equality constraints  machine learning                    
cohen  w  w     hirsh  h       b   learning the classic description logic  theoretical and experimental results  in doyle  j   sandewall  e     torasso  p   eds   
proceedings of the fourth international conference on principles of knowledge representation and reasoning  kr      pp          bonn  germany  morgan kaufmann
publishers 
cohen  w   borgida  a     hirsh  h          computing least common subsumers in description logics  in swartout  w   ed    proceedings of the   th national conference
on artificial intelligence  pp          san jose  ca  mit press 
devanbu  p     jones  m          the use of description logics in kbse systems  acm
transactions on software engineering and methodology  tosem                  
frazier  m     pitt  l          classic learning  machine learning journal              
giacomo  g  d     lenzerini  m          tbox and abox reasoning in expressive description logics  in aiello  l   doyle  j     shapiro  s   eds    proceedings of the  th
international conference on principles of knowledge representation and reasoning
 kr      pp          boston  usa  morgan kaufmann publishers 
hopcroft  j     ullman  j          introduction to automata theory  addison wesley publ 
co 
kusters  r     borgida  a          what s in an attribute  consequences for the least
common subsumer  tech  rep  dcs tr      rutgers university  usa  available via
ftp   ftp cs rutgers edu pub technical reports  
mcguinness  d     patel schneider  p          usability issues in knowledge representation systems  in proceedings of the   th national conference on artificial intelligence
 aaai     and of the   th conference on innovative applications of artificial intelligence  iaai      pp          menlo park  aaai press 
mcguinness  d     wright  j          an industrial strength description logic based
configurator platform  ieee intelligent systems                
minsky  m          a framework for representing knowledge  in winston  p   ed    the
psychology of computer vision mcgraw hill  new york 
quillian  m          semantic memory  in minsky  m   ed    semantic information processing  pp          cambridge  mass  mit press 
schmidt schau  m          subsumption in kl one is undecidable  in brachman  r  j 
 ed    proceedings of the  st international conference on principles of knowledge
representation and reasoning  kr      pp          toronto  ont  morgan kaufmann
publishers 
   

fi