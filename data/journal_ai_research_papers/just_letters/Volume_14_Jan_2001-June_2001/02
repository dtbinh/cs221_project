journal artificial intelligence research                

submitted       published     

con ict directed backjumping revisited
xinguang chen

xinguang cs ualberta ca

peter van beek

vanbeek uwaterloo ca

department computing science  university alberta
edmonton  alberta  canada t g  h 
department computer science  university waterloo
waterloo  ontario  canada n l  g 

abstract

recent years  many improvements backtracking algorithms solving constraint
satisfaction problems proposed  techniques improving backtracking algorithms conveniently classified look ahead schemes look back schemes  unfortunately  look ahead look back schemes entirely orthogonal
observed empirically enhancement look ahead techniques sometimes counterproductive effects look back techniques  paper  focus relationship
two important look ahead techniques using variable ordering heuristic maintaining level local consistency backtracking search and
look back technique con ict directed backjumping  cbj   show exists
 perfect  dynamic variable ordering cbj becomes redundant  show
theoretically level local consistency maintained backtracking
search increased  less backjumping improvement  theoretical
results partially explain backtracking algorithm look ahead phase
cannot benefit backjumping look back scheme  finally  show empirically
adding cbj backtracking algorithm maintains generalized arc consistency
 gac   algorithm refer gac cbj  still provide orders magnitude
speedups  empirical results contrast bessiere regin s conclusion       
cbj useless algorithm maintains arc consistency 

   introduction

constraint satisfaction problems  csps  generic problem solving framework  constraint satisfaction problem consists set variables  associated domain
values  set constraints  constraints expressed relation  defined
subset variables  denoting consistent value assignments satisfy
constraint  solution csp assignment value every variable  way
every constraint satisfied 
constraint satisfaction problems usually solved search methods  among
backtracking algorithm improvements widely used  techniques
improving backtracking algorithms conveniently classified look ahead schemes
look back schemes  dechter         look ahead schemes invoked whenever
algorithm preparing extend current partial solution  look ahead schemes include
functions choose next variable instantiated  choose next value
give current variable  reduce search space maintaining certain level
local consistency search  e g   bacchus   van run        bessiere   regin       
c      ai access foundation morgan kaufmann publishers  rights reserved 

fichen   van beek

haralick   elliott        mcgregor        nadel        sabin   freuder         lookback schemes invoked whenever algorithm encounters dead end prepares
backtracking step  look back schemes include functions decide far
backtrack analyzing reasons dead end  backjumping  decide new
constraints record con icts arise later search  e g  
bruynooghe        dechter        frost   dechter        gaschnig        prosser      b 
schiex   verfaillie        
backtracking algorithm hybrid look ahead look back schemes
 prosser      b   paper  focus relationship two important look ahead techniques using variable ordering heuristic maintaining level
local consistency backtracking search and look back technique con ictdirected backjumping  cbj   prosser      b   unfortunately  look ahead lookback schemes entirely orthogonal observed previous experimental
work level consistency maintained backtracking search increased variable ordering heuristic improved  effects cbj diminished
 bacchus   van run        bessiere   regin        prosser      a      b   example 
observed prosser s      b  experiments that  given static variable ordering  increasing level local consistency maintained none level forward checking 
diminishes effects cbj  bacchus van run        observe experiments
adding dynamic variable ordering  an improvement static variable ordering 
forward checking algorithm diminishes effects cbj  experiments
effects diminished almost negligible present argument
might hold general  bessiere regin        observe experiments
simultaneously increasing level local consistency even arc consistency
improving dynamic variable ordering heuristic diminishes effects cbj
much that  implementation  overhead maintaining data structures
backjumping actually slows algorithm  conjecture arc consistency
maintained good variable ordering heuristic used   cbj becomes useless  
paper  present theoretical results deepen understanding relationship look ahead techniques cbj look back technique  show
exists  perfect  dynamic variable ordering chronological backtracking algorithm cbj becomes redundant  variable ordering heuristic
consistent  perfect  heuristic  less chance cbj reduce search effort 
show cbj algorithm maintains strong k consistency backtracking search incomparable exponentially better other 
result refined introducing concept backjump level execution
backjumping algorithm showing algorithm maintains strong k consistency
never visits nodes backjumping algorithm allowed backjump
k levels  thus  level local consistency maintained backtracking search
increased  less backjumping improvement  together  theoretical
results partially explain backtracking algorithm look ahead phase
cannot benefit backjumping look back scheme  results extend
partial ordering backtracking algorithms presented kondrak van beek       
include backtracking algorithms cbj hybrids maintain levels local con  

ficonflict directed backjumping revisited

sistency beyond forward checking  including important algorithms maintain arc
consistency 
present empirical results show that  although effects cbj may
diminished  adding cbj backtracking algorithm maintains generalized arc
consistency  gac   algorithm refer gac cbj  still provide orders
magnitude speedups  empirical results contrast bessiere regin s       
conclusion cbj useless algorithm maintains arc consistency 

   background

section  formally define constraint satisfaction problems  brie review local
consistency search tree explored backtracking algorithm 

    constraint satisfaction problems
definition    csp  instance constraint satisfaction problem tuple p  
 v   d  c    where 
v   fx          xng finite set n variables 
  fdom x           dom xn g set domains  variable x   v associated finite domain possible values  dom x   maximum domain size
maxx v jdom x j denoted d 

c   fc          cmg finite set constraints relations  constraint c   c
pair  vars c    rel c    

  vars c     fxi           xiri g ordered subset variables  called con 

straint scope scheme  size vars c   known arity constraint  arity constraint equal    called binary constraint 
non binary constraint constraint arity greater    maximum
arity constraints c   maxc  c jvars c  j  denoted r 
  rel c   subset cartesian product dom xi    dom xiri   specifies
allowed combinations values variables vars c    element
cartesian product dom xi    dom xiri   called tuple vars c   
thus  rel c   often regarded set tuples vars c   

following  assume variable x   v   least one constraint
c   c x   vars c    definition  tuple set variables x   fx          xkg
ordered list values  a           ak   ai   dom xi                k  tuple x
regarded set variable value pairs fx  a           xk ak g  furthermore 
tuple x viewed function   x    x x dom x  variable
x   x   t x    dom x   subset variables x   x   use t x    denote tuple
x   restricting x    use vars t  denote set variables tuple t 
   throughout paper  use n  d  m  r denote number variables  maximum domain
size  number constraints  maximum arity constraints csp  respectively 

  

fichen   van beek

assignment set variables x tuple x   say assignment x
consistent constraint c either vars c     x t vars c      rel c    partial
solution csp assignment subset variables  say partial solution
consistent consistent constraints  solution csp consistent
partial solution variables  solution exists  csp said insoluble 
csp empty either one variables empty domain one constraints
empty set tuples  obviously  empty csp insoluble  given two csp instances
p  p    say p    p  exactly set variables  set
domains set constraints  i e   syntactically same 

definition    projection  given constraint c subset variables vars c   
projection c constraint  vars s c     rel s c     ft s   j  
rel c  g 
definition    selection  given constraint c assignment subset variables x vars c    selection tc constraint  vars t c     vars c  
rel tc     fs j s x       rel c  g 
    local consistency

inconsistency consistent partial solution variables cannot
extended additional variables cannot part global solution 
using backtracking search find solution  inconsistency lead dead end
search  insight led definition properties characterize level
consistency csp development algorithms achieving levels
consistency removing inconsistencies  e g   mackworth      a  montanari        
effective backtracking algorithms finding solutions csps maintain level
consistency search  e g   gaschnig        haralick   elliott        mcgregor 
      sabin   freuder        
mackworth      a  defines three properties binary csps characterize local consistencies  node  arc  path consistency  mackworth      b  generalizes arc consistency
non binary csps 

definition    arc consistency  given constraint c variable x   vars c   
value   dom x  supported c tuple   rel c    t x    a 
called support fx ag c   c arc consistent variables
x   vars c    values   dom x   fx ag supported c   csp arc

consistent constraints arc consistent 
freuder        generalizes node  arc  path consistency  k consistency 

definition    k consistency  csp k consistent given consistent
partial solution k     distinct variables  exists instantiation kth variable
partial solution plus instantiation consistent  csp strongly kconsistent j  consistent   j k 
  

ficonflict directed backjumping revisited

binary csps  node  arc path consistency correspond one   two  threeconsistency  respectively  however  definition k consistency require csp
binary arc consistency two consistency non binary csps 
strongly n consistent csp property consistent partial solution
successively extended full solution csp without backtracking 

    search tree backtracking algorithms

idea backtracking algorithm extend partial solutions  stage  uninstantiated variable selected assigned value domain extend current
partial solution    constraints used check whether extension may lead
possible solution csp prune subtrees containing solutions based
current partial solution  backtracking search  variables divided
three sets  past variables  already instantiated   current variable  now instantiated  
future variables  not yet instantiated   dead end occurs values current variable rejected leading full solution  case  instantiated
variables become uninstantiated   i e   removed current partial solution 
process called backtracking  recently instantiated variable becomes
uninstantiated called chronological backtracking   otherwise  called backjumping  backtracking algorithm terminates possible assignments tested
certain number solutions found 
backtracking search may seen search tree traversal  approach
identify tuples  assignments values variables  nodes  empty tuple root
tree  first level nodes   tuples  representing assignment value
single variable   second level nodes   tuples  on  levels closer
root called shallower levels levels farther root called deeper levels 
similarly  variables corresponding levels called shallower deeper 
say backtracking algorithm visits node search tree stage
algorithm s execution current partial solution identifies node  nodes visited
backtracking algorithm form subset nodes belonging search tree 
call subset  together connecting edges  backtrack tree generated
backtracking algorithm 
backtracking algorithm con ict directed backjumping  cbj   prosser      b  maintains con ict set every variable  every time instantiation current variable
xi con ict instantiation past variable xh   variable xh added
con ict set xi   values tried current variable xi  
cbj backtracks deepest variable xh con ict set xi   time 
variables con ict set xi   exception xh   added con ict set
xh   information con icts lost 
throughout paper refer following backtracking algorithms  see kondrak
  van beek        prosser      b detailed explanations examples
algorithms   chronological backtracking  bt   backjumping  bj   gaschnig         con ictdirected backjumping  cbj   prosser      b   forward checking  fc   haralick   elliott 
      mcgregor         forward checking con ict directed backjumping  fc cbj 
   throughout paper  assume static value ordering used backtracking search 

  

fichen   van beek

 prosser      b   maintaining arc consistency  mac   gaschnig        sabin   freuder 
       maintaining arc consistency con icted directed backjumping  mac cbj 
 prosser        

   variable ordering heuristics backjumping

section  present theoretical results deepen understanding relationship look ahead technique using variable ordering heuristic
look back technique cbj 
previous work  kondrak van beek        show that  given deterministic
static dynamic variable ordering heuristic  cbj never visits nodes bt  bacchus
van run        show bj  restricted version cbj  visits exactly nodes
bt fail first dynamic variable ordering heuristic used  previous empirical work
shows number nodes cbj saves depends variable ordering heuristic
used  bacchus   van run        bessiere   regin        prosser      b  
show that  given csp variable ordering cbj  exists  perfect 
variable ordering chronological backtracking algorithm  bt  bt never
visits nodes cbj  variable ordering heuristic consistent
 perfect  heuristic  less chance cbj reduce search effort 
first consider case insoluble csps  cbj applied insoluble csp 
always backjumps dead end state  i e   terminate backjump
situation solution csp found 

lemma   given insoluble csp variable ordering cbj  exists variable

ordering bt bt never visits nodes cbj show solution
exists 

proof backtrack tree generated cbj variable ordering  let last

backjump terminates execution cbj variable xj root
backtrack tree  choose xj first variable bt  value domain
xj   current node backtrack tree cbj consistent  not leaf node  
next variable chosen instantiated assigning xj variable backjumps
xj causes assignment xj revoked  entire variable ordering
bt worked similar  recursive manner  variable ordering bt
well defined  remains show current node backtrack tree cbj
inconsistent  a leaf node   corresponding node backtrack tree bt
inconsistent  and therefore next variable needs chosen   show variables
skipped variable ordering constructed bt irrelevant dead end states
encountered cbj  suppose stage ordered variables instantiated
bt xj           xjk   value   dom xjk   choose next variable xjk  
variable backjumps current variable xjk cbj backtrack tree 
prove induction con ict set xjk   used backjumping subsumed
fxj           xjk g  k     case last backjump terminates execution cbj 
hypothesis true con ict set xj  empty set  suppose true
case k      xjk   backjumps xjk   con ict set xjk   merged
con ict set xjk   inductive assumption  con ict set xjk subsumed
  

ficonflict directed backjumping revisited

fxj           xjk   g  thus con ict set xjk   subsumed fxj           xjk g  therefore 
hypothesis holds case k      cbj finds instantiation xjk
inconsistent assignments past variables added con ict
set xjk   bt able find inconsistency con ict set xjk
subsumed fxj           xjk   g  thus  variable ordering bt well defined 
soluble csps  distinguish problem finding one solution
finding solutions 

lemma   given csp variable ordering cbj find first solution 

exists variable ordering bt bt never visits nodes cbj find
first solution 

proof without loss generality  let fx  a          xn g first solution found 

variable ordering bt constructed following way  first variable chosen
bt x  first variable path root solution cbj
backtrack tree  assume static value ordering backtracking search 
values domain x  precede value a  must rejected cbj bt
value a  used instantiate x    furthermore  fx  a           xn g
first solution encountered cbj variable ordering value ordering 
instantiation x  value preceding a  leads insoluble subproblem
eventually cbj backjumps deeper variable x  revoke assignment  note
x  cannot skipped backjump deeper variable x  first
level search tree solution csp  assigning x 
values precede a  domain leads insoluble subproblems instantiation
order bt arranged lemma    whenever xk instantiated value ak  
xk   chosen next variable  follows xk path root
solution cbj backtrack tree  again  values domain xk   precede
ak   value ordering must rejected cbj bt ak   assigned
xk    instantiation xk   values leads insoluble subproblem
eventually cbj backjumps deeper variable xk     similarly  xk   cannot
skipped backjump deeper variable otherwise least one
assignments x           xk must changed fx  a           xn g
first solution encountered cbj  insoluble subproblems  instantiation
order bt arranged lemma    finally  xn instantiated bt
finds solution 
cbj used find solutions  special steps must taken handle con ict sets  problem con ict sets cbj meant indicate
instantiations responsible previously discovered inconsistency  however 
solution found  con ict sets cannot always interpreted way  search
solutions  rather inconsistency  causes algorithm backtrack 
need differentiate two causes cbj backtracks      detecting inconsistency      searching solutions  latter case  backtrack must
always chronological  is  immediately preceding variable  simple solution
remember number solutions found far variable chosen instantiated 
  

fichen   van beek

later dead end state encountered level  compare recorded number current number solutions  difference indicates solutions
found interval search  forces algorithm backtrack chronologically 
otherwise algorithm performs normal backjumping analyzing con ict set
current variable 

lemma   given csp variable ordering cbj find solutions  exists
variable ordering bt bt never visits nodes cbj find
solutions 
proof let first solution found cbj fx 

a          xn g order
x           xn  first construct variable ordering bt applied find first

solution  however  bt follows strict chronological backtracking  inevitably
visit nodes fx  a           xj    aj      xj a j g    j n a j comes
aj domain xj   cbj skips nodes  example  deeper
level variable xh xj      instantiations x           xj changed  bt
possibly visit nodes cbj  show cannot happen induction
distance current level j deepest level n  cbj found
solution level n  try values xn eventually backtrack xn    
nodes level n cannot skipped  suppose true case level j    
consider case level j   xj aj skipped backjumping 
aj last value domain  cbj backtrack xj    number
solutions changed  true case j   otherwise cbj change
instantiation xj next value domain  let current partial solution
  fx  a          xj   aj    xj a j g  subtree rooted contains solutions 
inductive hypothesis  cbj skip node level j  
subtree rooted contains solution  exists backjump deeper level
variable xh escape subtree  could jump beyond xj skipped 
case  con ict set xh subsumed fx           xj    g  definition con ict
set  know current instantiations variables con ict set cannot lead
solution  however current instantiations fx           xj    g lead solution 
fx  a          xn ang  contradiction  con ict set xh must contain
xj thus node level j cannot skipped  values domain
xj tried  cbj chronologically backtrack xj    number
solutions changed  thus  xj    aj    skipped  hypothesis true
case level j   construct variable ordering bt following way 
current partial solution   fx  a           xj    aj      xj a j g cannot extended
solution  construct variable ordering insoluble subproblem 
extended solution  construct variable ordering bt case finding
first solution subproblem  recursively apply steps backjump
level xj changes instantiation xj a j   variable ordering  bt
never visit nodes cbj 

theorem   given csp variable ordering cbj  exists variable ordering

bt bt never visits nodes cbj solving csp 
  

ficonflict directed backjumping revisited

x    x  x 
x    x    x     
x    x  x 
x          x    f       g

x 

 

cbj backtrack tree

x 

 

x 

x 

x 
 

x 

x 

x 

x 

x 

x 
 

x 

x 

x 

x 

x 

x 
 

p

p p
x 

x 

 

p p p

bt backtrack tree
 

x 

x 

x 
 

x 

x 

x 

x 

x 

x 
 

x 

x 

x 
 

p

p p

p p p

figure    illustration variable ordering constructed bt cbj backtrack
tree  for csp shown upper left  

proof follows lemmas         
example   figure   shows bt backtrack tree based variable ordering constructed
execution cbj solve csp  hypothetical  dynamic variable ordering 
first solution found cbj fx     x     x     x     x   g  thus  bt
first instantiates x  x     node fx     x     x   g fx     x 
   x   g cbj backtrack tree lead insoluble subproblems  variable ordering
bt nodes constructed case insoluble csps  example 
cbj backtrack tree  last backjump revoke node fx     x     x   g
  

fichen   van beek

x  x    next variable instantiated bt node x   
ordering  bt avoids instantiating x  visits fewer nodes cbj  bt instantiates
x     x     x     finds first solution 
shown exists  perfect  variable ordering cbj becomes
redundant  course   perfect  ordering would known priori  practice 
primary goal designing variable ordering heuristics simulate execution
cbj  reduce size overall backtrack tree  example  popular failfirst heuristic selects next variable instantiated variable minimal
remaining domain size  the size domain removing values con ict
past instantiations  shown minimize size overall tree
certain assumptions  secondary effect  however  variables con icts
past instantiations likely instantiated sooner  thus approximating  perfect 
ordering diminishing effects backjumping 

   maintaining consistency backjumping

section  present theoretical results deepen understanding relationship look ahead technique maintaining level local consistency
backtracking search look back technique cbj 
previous work  kondrak van beek        show that  given deterministic
static dynamic variable ordering heuristic  cbj never visits nodes bt
fc cbj never visits nodes fc  prosser      a  shows removal
inconsistent value domain variable diminish effects cbj
cbj visit fewer nodes algorithm combines cbj discovery
removal inconsistent values  previous empirical work shows number
nodes cbj saves depends level local consistency maintained  bacchus   van
run        bessiere   regin        prosser      b  
extend partial ordering backtracking algorithms presented kondrak
van beek        include backtracking algorithms cbj hybrids maintain
levels local consistency beyond forward checking  including important algorithms
maintain arc consistency  show cbj algorithm maintains strong kconsistency backtracking search incomparable exponentially
better other  result refined using concept backjump level
execution backjumping algorithm showing algorithm maintains
strong k consistency never visits nodes backjumping algorithm allowed
backjump k levels  thus  level local consistency maintained
backtracking search increased  less backjumping improvement 
section      consider backjumping algorithms define series algorithms bjk   section      consider look ahead algorithms maintain level
local consistency define series algorithms mck   finally  section      consider relationships backjumping look ahead algorithms
hybrids  reader interested technical proofs results jump
directly section 
  

ficonflict directed backjumping revisited

x 

x    x  x 
x    x    x     
x    x  x 
x            x    f       g

 

x 

 

x 

d  
x 

x 

 

x 
d  

x 

 

d  
d  

 
 

p p

figure    illustration backjump levels cbj backtrack tree  for csp shown
upper right  

    backjump level bjk

analyze uence level consistency backjumping  need notion
backjump level  informally  level backjump distance  measured backjumps 
backjump destination  farthest  dead end 

definition    backjump level  kondrak   van beek        definition back 

jump level recursive 
   backjump variable xi variable xh level   performed directly
dead end state every value xi fails consistency check 
   backjump variable xi variable xh level    backjumps performed
variable xi level less d  least one level     

example   figure   shows backjump levels example cbj backtrack tree 

one level backjump x  x  every value domain x  fails consistency
check  cbj finds two solutions problem thus chronologically backtracks
x  x    later x   backjumps level one two respectively  last
three level backjump x  x   
classifying backjumps performed backjumping algorithm different levels 
weaken cbj series backjumping algorithms perform limited
levels backjumps  bjk backjumping algorithm allowed perform
k level backjumps chronologically backtracks j  level backjump j   k
encountered    bjn equivalent cbj  performs unlimited backjumps  bj 
   bjk theoretical interest since practice one would use cbj rather artificially prevent
backjumping  i e   one actually add code prevent backjumping 

  

fichen   van beek

equivalent gaschnig s        bj  first level backjumps backjumps
dead ends 
one may immediately conclude bjk   always better bjk one
level backjumps  however  precise  need justify situation
bjk may skip node visited bjk   exist  similar result kondrak
van beek  theorem            show that 

theorem   bjk visits nodes bjk   visits 
    maintaining strong k consistency  mck  

although backtracking algorithms maintain arc consistency  or truncated form arc
consistency called forward checking  search well studied  backtracking algorithm maintains strong k consistency  mck   never fully addressed
literature  order study relationship bjk mck   need specify
precisely mck algorithms 
generic scheme maintain level local consistency backtracking search
perform node search tree one full cycle consistency achievement  consistency achievement algorithm applied csp induced current partial
solution  if  result  induced csp becomes empty applying consistency
algorithm  instantiation current variable dead end rejected 
resulting csp empty  instantiation current variable accepted
search continues next level 
simplest form induced csp restrict domains instantiated
variables one value leave set constraints unchanged  idea
traced back gaschnig s        implementation mac  referred deeb  i e  
domain element elimination backtracking  however  order establish relation
bjk mck   need restricted definition induced csp 
constraints induced csp selections projections constraints
original csp respect partial solution 

definition    induced csp  given consistent partial solution csp p   csp
induced t  denoted p jt   variables p except instantiated t 
domain variable p   constraint c p
vars c     vars t   constraint c     vars c  vars t   t vars c   vars t   c    p jt 
example   consider graph coloring problem corresponding csp shown
figure    original csp four variables  x           x   x    x   x    fr  g  bg
x    frg  five binary constraints  x   
  x   x     x   x     x   x     x  x     x  
given partial solution   fx  g  x  bg  csp induced t  p jt   two variables 
x  x    unary binary constraints shown figure   
maintaining strong k consistency algorithm  mck   node backtrack
tree applies strong k consistency achievement algorithm csp induced

current partial solution  architecture  fc viewed maintaining
one consistency  binary csps  mac viewed maintaining strong twoconsistency 
  

ficonflict directed backjumping revisited

algorithm enforcing strong k consistency csp instance detect remove
inconsistencies   fx  a           xj aj    g   j k consistent
cannot consistently extended j th variable xj   remove inconsistency 
make inconsistent resulting csp removing values domains  removing
inconsistent tuples existing constraints  adding new constraints csp 
use concept k proof tree characterizing tuples removed
strong k consistency achievement algorithm 

definition    k proof tree  k proof tree partial solution k vari 

ables csp tree node associated partial solution
k variables csp      root k proof tree associated t     
leaf node k proof tree inconsistent csp      non leaf node
k proof tree consistent csp  children next level nodes
s    fx a g         s    fx alg s  s  x    vars s   dom x    fa           al g 

example   figure   shows three proof tree  more one possible    fx  gg

given graph coloring problem  non leaf node  including root t  consistent 
leaf node inconsistent csp  since constructed three prooftree tuple cannot part solution csp strong   consistency
achievement algorithm would remove it 
general  k proof tree inconsistency csp constructed  algorithm achieving strong k consistency would deduce remove inconsistency 
applying strong k consistency achievement algorithm csp  children
node k proof tree inconsistent resulting csp  node inconsistent resulting csp one subtuples cannot consistently extended
additional variable  leaf nodes k proof tree inconsistent
original csp  bottom up manner inconsistency root tree
deduced removed resulting csp  special case  k proof tree
empty inconsistency csp constructed  csp empty enforcing
strong k consistency since every way extend variable shown lead
inconsistency  and therefore  value would removed domain resulting
empty domain   hand  csp made strongly k consistent 
partial solution k variables inconsistent resulting csp  k proof tree
original csp constructed  inconsistent original csp 
k proof tree contains single node t  otherwise  subtuple t  cannot extended
additional variable x  i e   partial solutions t    fx a  g         t    fx al g 
dom x    fa          alg  inconsistent resulting csp  construct
k proof tree recursively inconsistencies  special case  csp
empty enforcing strong k consistency  k proof tree empty inconsistency
original csp constructed 
following lemmas  lemma   lemma    reveal basic properties induced csps strong k consistency enforcement induced csps  used
proofs theorem    theorem    

  

fichen   van beek

x 

  
x 

r g  b

  

  

r g  b

  

r

x 

x 

g

x 
x 

g
g

x   x    x    fr  g bg  x    frg
c  x   x      x     x 
c  x   x      x     x 
c  x   x      x     x 
c  x   x      x     x 
c  x   x      x     x 

  

r g  b
x 

x 
x 

g
r

x 
x 

r
r

x 
x 
x 

g
b
r

x 
x 

r
r

x 
x 

g
b

x 
x 
x 

g
b
g

x 
x 
x 

g
b
b

figure    three proof tree fx  g g graph coloring problem  leaf nodes
proof tree inconsistent csp 

lemma   given csp p two partial solutions t  p   t   p jt   
 p jt  jt  t  
proof clearly p jt   p jt jt  t set variables set domains 

vars c   vars t    t  c   vars c   vars t    t   t  vars c   vars t  c    constraint
c p   selection projection made p jt   p jt  jt  t  therefore  p jt 
 p jt  jt  t set constraints 

lemma   given csp p consistent partial solution p    i  p empty
achieving strong k consistency   ii  exists variable x   vars t  value
t x  removed domain x achieving strong k consistency p   p jt
empty achieving strong k consistency 

proof first show that  given consistent partial solution csp p   k proof 

tree inconsistency p   corresponding well defined k proof tree tt
inconsistency s    s vars s    vars t    induced csp p jt   provided
  

ficonflict directed backjumping revisited

x    fr  g  bg  x    frg
c  x      f r    b g
c  x      f r    g g
c  x      f r g
c  x    x      x     x 


x 

r

x 
x 

r
r

x 

g

x 

b

figure    proof tree empty inconsistency csp p jt induced   fx 
g  x  bg constructed proof tree fx  g g csp p shown
figure   
contain assignments inconsistent assignments t  tt constructed
three steps  see figure   example    step    remove nodes
descendants contain assignments inconsistent assignments
t   step    replace remaining node t  node t     t   vars t     vars t   
i e   remove variables occur thus occur p jt   t 
leaf node   definition t  consistent p   possible corresponding
node t   tt inconsistent p jt   case  make t   leaf node
removing descendants  t  leaf node   definition t  inconsistent
p   i e   exists constraint c p t  satisfy c   must
case vars c     vars t   since vars c   vars t  contradicts fact t 
inconsistent c consistent therefore consistent c   t  agree
assignments step     hence  corresponding constraint c   p jt
selection projection c p   now  easy verify corresponding node
t   inconsistent c   therefore well defined leaf node   step    remove
subsumed nodes   node t  subsumed node t  t   necessarily only 
child t  vars t   vars t    children subsumed node t  made children
parent t   
now  suppose p empty achieving strong k consistency  k prooftree empty inconsistency p construct k proof tree empty
inconsistency p jt   therefore  p jt empty achieving strong k consistency  suppose
exists variable x   vars t   value t x  removed domain
x achieving strong k consistency p   k proof tree fx t x g
p construct k proof tree empty inconsistency p jt  therefore p jt
empty achieving strong k consistency 

  

fichen   van beek

lemma   given csp p assignment fx ag    dom x   induced csp
p jfx ag empty achieving strong  k      consistency  value removed
domain x achieving strong k consistency p  

proof suppose p jfx ag empty achieving strong  k      consistency  thus 
 k      proof tree empty inconsistency p jfx ag   convert  k     proof tree k proof tree fx ag p   node original  k      proof tree
replaced   fx ag  thus  root tree becomes fx ag  furthermore 
leaf node original  k      proof tree  i e   consistent p jfx ag  
easy verify   fx ag consistent p   leaf node original
 k      proof tree  i e   inconsistent p jfx ag  constraint c   p jfx ag

satisfy c    let c   selection projection constraint c p  
thus    fx ag satisfy constraint c p therefore inconsistent p  
hence  constructed k proof tree fx ag p thus would removed
domain x achieving strong k consistency p  

mck extends current node csp induced current partial solution
empty achieving strong k consistency  node thus called k consistent node 

definition    k consistent node  node search tree k consistent node
csp induced empty enforcing strong k consistency  node
k consistent called k inconsistent 

lemma   node k consistent  ancestors k consistent 
proof let t  one t s ancestors  t  t  lemma    p jt    p jt   jt t    thus 
p jt induced subproblem p jt    lemma    p jt empty achieving
strong k consistency  p jt  empty either achieving strong k consistency  thus  t 
k consistent 

following theorem applies case finding solutions 

theorem    mck visits node  parent k consistent  node k consistent 
mck visits node 

proof first part true mck would branch node parent
found k inconsistent  prove second part induction depth search tree 
hypothesis trivial j      suppose true j     k consistent
node level j      let current variable x  lemma    t s parent t  level
j k consistent  thus  mck visit t    lemma    p jt    p jt   jfx t x g 
 p jt   jfx t x g empty achieving strong k consistency  lemma    value t x 
removed domain x achieving strong k consistency p jt   
consequence  mck visit t 

necessary sucient condition mck visit node t s parent kconsistent value assigned current variable removed
domain enforcing strong k consistency t s parent 
  

ficonflict directed backjumping revisited

theorem    given csp variable ordering  mck visits nodes mck  

visits 

proof follows theorem    lemma   
    relationship bjk mck

kondrak van beek        shown binary csps  bj  bj    visits
nodes fc  mc   visits  fc cbj  mc  cbj  cbj incomparable 
extend partial ordering backtracking algorithms include relationship
mck   bjk   mck  cbj    k n  results case general csps 
i e   restricted binary csps 
begin characterizing important property cbj algorithm 

lemma    cbj performs one level backjump deeper variable xi shallower
variable xh   node th level xh one inconsistent 

proof let si con ict set xi used backjumping xh deepest variable  show xi experience domain wipe enforcing oneconsistency induced csp p jth  si     node ti level xi leaf node 
i e   ti inconsistent p   suppose ti satisfy constraint c xi   vars c  
vars c   si   fxi g  selection c p jth  si     constrains one variable
fxig  prohibit value ti  xi  xi  thus  xi experience domain wipe
enforcing one consistency p jth  si     note p jth induced subproblem p jth  si    
lemma    p jth empty enforcing one consistency  thus  th level xh
one inconsistent 
lemma    cbj performs k level backjump deeper variable xi shallower
variable xh   current node th level xh k inconsistent 
proof let si current con ict set xi xh deepest variable  show
k level backjump xi xh   p jth  si   empty enforcing strong

k consistency thus th k inconsistent  proof induction k  k     true
lemma     suppose hypothesis true case k     true
case k  i e   k level backjump xi xh   induced csp p jth  si  
empty enforcing strong k consistency  least one value left
domain xi enforcing strong k consistency p jth  si     know node ti
level xi instantiating xi either incompatible th  i e   leaf node 
l level backjumped deeper variable xj     l   k  see figure    
however  ti cannot leaf node otherwise would removed domain xi
enforcing strong k consistency  let sj con ict set xj   hypothesis 
induced csp p jti  sj   empty achieving strong l consistency  value
removed resulting csp  lemma    induced csp p jth  si   fxi ag
empty achieving strong  k      consistency  ti  sj   th  si     fxi ag 
induced csp p jti  sj   empty achieving strong  k      consistency  leads
contradiction  thus p jth  si   empty achieving strong k consistency th
level xh k inconsistent 
  

fichen   van beek

th

xh
k level backjumping

   

ti

con ict set si xi

l level backjumping  l   k

   

con ict set sj xj

figure    scenario cbj backtrack tree used proof lemma    

theorem    given csp variable ordering  bjk visits nodes mck
visits 

proof proof induction level search tree  mck visits node
level j search tree  bjk visits node  j     trivial  suppose true
case j     node visited mck level j      know
mck bjk visit t s parent level j   chance may skipped bjk
bjk backjumps deeper variable xi level shallower variable xh
level h  h   j       i  thus  node level h k inconsistent  by lemma     
since node level h ancestor know t s parent k consistent
lemma    node level h k consistent  contradiction  therefore  bjk
visits level j     
mck combined backjumping  namely mck  cbj  provided con ict sets
computed correctly achieving strong k consistency induced csps 

theorem    given csp variable ordering  mck visits nodes mck cbj

visits 

proof mck cbj behaves exactly mck forward phase

backtracking search  easy verify mck  cbj visits node t s parent
k consistent value assigned current variable removed
domain achieving strong k consistency t s parent  therefore  mck  cbj never
visits nodes mck does 
figure    present hierarchy terms size backtrack tree bjk  
mck   mck  cbj  path algorithm algorithm b figure 
know never visits nodes b does  example  mck never visits
nodes bjj   j k  otherwise  instances show may
exponentially better b  vice versa 
  

ficonflict directed backjumping revisited

bjn
 cbj 

  
 

  

bjk

bjk

mcn

mcn  cbj

  
 

  
 

  

mck

    cbj

mck

mck

mck  cbj

  
 

  
 

  
 

bj

 

mc

 

mc  cbj

 bj 

 fc 

 fc cbj 

 

figure    hierarchy bjk   mck   mck  cbj terms size backtrack
tree 
following example shows  fixed integer k   n  exists csp instance
cbj visits exponentially fewer nodes algorithm maintains strong
k consistency backtracking search  

example   given fixed integer k  construct binary csp n   k    variables 
x           xn k    y          yk     xn k           xn    dom xi     f          ng   n   
dom yj     f          kg   j k      constraints are  xi  
  xj      j  
yi  
  yj      j   problem consists two separate pigeon hole subproblems  one

variables x          xn   variables y           yk     insoluble 
see  pigeon hole problem highly locally consistent  first subproblem strongly nconsistent second strongly k consistent  static variable ordering 
   independently  bacchus grove        present similar example show given fixed k  cbj
may exponentially better algorithm called mikc   essentially maintains k consistency
backtracking search 

  

fichen   van beek

backtracking algorithm maintaining strong k consistency would encounter dead end
xn k   instantiated  would find subproblem xn k            xn  
strongly k consistent  thus  algorithm backtrack reaches second
pigeon hole subproblem  explore nk   nodes level n   k     search tree
thus take exponential number steps find problem insoluble  cbj
encounter dead end level xn k   continues second pigeon hole
problem  eventually find second pigeon hole problem insoluble backjump
root search tree  total number nodes explored bounded constant 
o  k     k   fixed k  therefore  cbj exponentially better algorithm
maintaining strong k consistency 
example   shows that  although mck visits fewer nodes bjk theorem    
bjk   exponentially better mck   however  bjk   better mck
 k      level backjump chronological backtrack  see
true  suppose particular instance  k      level backjumps
chronological backtracks  i e   backjump immediately preceding variable
variable ordering single variable becomes uninstantiated removed
current partial solution   case  freedom backjump one additional level
rather chronologically backtrack make difference bjk   effectively
bjk thus cannot better mck   thus  bjk   better mck
 k      level non chronological backjump  note  however  since
number backjumps level k    less equal number backjumps level
k  k increases gets unlikely  thus  level local consistency
maintained backtracking search increased  less backjumping
improvement 
consider example   again  level backtrack tree mck   instantiation
past variables removes one distinct value domain current
variable  recall mck never instantiates variable y  reaches dead end
xn k      maintain con ict sets variables  con ict set current
variable would include past variables thus dead end encountered
algorithm  backjump computed con ict sets would necessarily
chronologically backtrack  thus  example shows  mck  cbj mck visit
exactly nodes consequently bjk   exponentially better mck cbj  furthermore  mck    cbj reach second pigeon hole problem without
encountering dead end  finally retreat second pigeon hole problem
root search tree backjumps  thus  mck    cbj may exponentially better
mck  cbj  particular  shows surprising result mac cbj visit
exponentially nodes fc cbj 
finally  following example shows  fixed integer k   n  exists csp
instance algorithm maintains strong k consistency backtracking
search visits exponentially fewer nodes cbj 

example   consider csp defined example    searched static variable
ordering y           yk   x          xn     yk    

  

ficonflict directed backjumping revisited

   empirical evaluation adding cbj gac

section  report experiments examined effect adding cbj
backtracking algorithm maintains generalized arc consistency  gac   algorithm
refer gac cbj  previous work shown importance algorithms
maintain arc consistency  e g   sabin   freuder        bessiere   regin         show
adding cbj backtracking algorithm maintains generalized arc consistency
speed algorithm several orders magnitude hard  structured problems 
previous empirical studies adding cbj backtracking algorithm maintains
level local consistency led mixed conclusions  adding cbj forward checking 
truncated form arc consistency  shown give improvements always
significant ones  prosser      b  observes static variable ordering  fc cbj
three times faster fc zebra problem  smith grant        observe
dynamic variable ordering  adding cbj fc led significant savings
hard random problems occur easy region  bacchus van run       
observe dynamic variable ordering  adding cbj fc led
   improvement zebra problem  n queens problems  random binary problems 
bayardo schrag              show adding cbj well known davis putnam
algorithm  sat version forward checking  significant improvement hard
random real world   sat problems 
adding cbj algorithm maintains full arc consistency received less attention literature  one study aware of  bessiere regin       
observe adding cbj mac  the binary version gac  actually slows
algorithm random binary problems due overhead maintaining con ict sets 
conjecture  when mac good variable ordering heuristic used  cbj
becomes useless  
empirical results lead us differ bessiere regin s conclusion
usefulness adding cbj algorithm maintains full arc consistency  implementation able significantly reduce overhead maintaining con ict sets
use additional data structures   problems adding cbj
lead many savings nodes visited  implementation cbj degrade performance significant factor  demonstrate improvement re doing bessiere
regin s        experiments random binary problems  show experiments two structured domains gac cbj sometimes improve gac several
orders magnitude hard instances 
experiments  ran gac gac cbj instance problem
recorded cpu times  comparing cpu times appropriate underlying code
gac gac cbj identical  gac cbj containing additional code
maintain con ict sets determine far jump back  two dynamic variable
orderings used  popular dom deg heuristic chooses next variable
minimal domain size breaks ties choosing variable maximum degree
 the number constraints constrain variable  dom deg heuristic
proposed bessiere regin        chooses next variable minimal
   see online appendix source code description key data structures implementations gac gac cbj 

  

fichen   van beek

value domain size divided degree  experiments run     mhz
pentium ii s     megabytes memory 

    random problems

run time performance gac gac cbj compared sets randomly
generated binary csps  set random problems defined   tuple  n  d  r  m  t  
n number variables  uniform domain size  r uniform arity
constraints  number randomly generated constraints  uniform
tightness number tuples constraint  case  constraint tightness
chosen approximately half instances population insoluble 
i e   instances phase transition region 
table    effect domain size average time  seconds  solve random instances
     d         t   set contained     random instances  gac cbj
gac used dom deg variable ordering 

gac cbj gac
 
             
  
     
     
    
    
  
  
    
    
  
    
    
  
    
    
  
    
    
     
     
  

ratio
    
    
    
    
    
    
    
    

bessiere regin        examine effect domain size average time
solve random instances      d         t   see figure    right  bessiere   regin        
implementation cbj  adding cbj steadily worsens performance domain
size increases      mac cbj     times slower mac alone 
implementation  difference performance gac cbj gac negligible
problems  see table    
remaining sets random problems bessiere regin used experiments compare performance mac cbj mac simple provide
meaningful comparison solved less      seconds     mhz
pentium ii computer  thus  chose harder sets random binary problems 
instance ran gac gac cbj recorded cpu times  report
average ratio cpu times  gac gac cbj   set contained     random
instances  first set problems                        average ratio dom deg
variable ordering      average ratio dom deg variable ordering      
second set problems                         average ratios dom deg
  

ficonflict directed backjumping revisited

dom deg variable orderings       words  average gac little
    faster gac cbj problems 

    planning problems

planning  one required find sequence actions initial state goal
state  formulated csp  formulation used experiments 
state modeled collection variables constraints enforce assignments
variables represent consistent state valid transition states   see kautz  
selman        van beek   chen       details formulation planning
csp  
table    time  seconds  solve instances grid planning problem  absence
entry indicates problem solved within       seconds     hours 
cpu time 
dom deg
gac gac cbj
    
    

 
        
 
 
 
 
 
 

dom deg
gac gac cbj
    
    

             
 

       

 

 
 
 

      

 
 
 

experiments used     instances used first ai planning systems
competition  june            instances come five different domains  gripper 
mystery  mprime  logistics  grid  experiments report  gac gaccbj based ac   mackworth      a  found give best performance 
gripper  mystery  mprime domains  instances could solved
   seconds gac gac cbj  easy problems  increased
overhead cbj rarely led savings  overall gac        faster gac cbj 
table   shows comparison gac gac cbj solving   instances
grid problems  gac cbj showed improvement grid problems  example 
solved problem   half hour  gac failed find solution    hours 
table   shows comparison gac gac cbj solving    instances
logistics problem  one third instances  gac cbj improved gac 
example  instances            gac cbj ran several orders magnitude faster
gac  instance     gac exhausted    hours time limit gac cbj found
solution within   minutes  gac cbj gac performed similarly easier instances
sometimes gac cbj     slower gac 

  

fichen   van beek

table    time  seconds  solve instances logistics planning problem  absence
entry indicates problem solved within       seconds    
hours  cpu time 
dom deg
gac
gac cbj
    
    
    
    

 
 
 
     
 
    
 
    
 
     
 
    
    
 
 
    
 
  
  
    
  
    
  
    
  
    
  
 
  
     
  
      
           
    
  
          
    
  
  
 
  
 
  
    
  
     
  
 
           
  
 
  
 
  
 

    

dom deg
gac
gac cbj
    
    
    
    

    

    

     

     

      
 
    
     
           
                

       
    
    
       

    
    

     

    
    
    
 
    
    
    
    

    

     

    
    
    
    
    
 
    
    
    
    

    

    
    
    
    
    
 
    
    
    
    

    

       

     

              

     

    
 
 
    
     
 
 
 
 

  

    
 
 
    
     
 
 
 
 

    
 
 
    
     
 
 
 
 

ficonflict directed backjumping revisited

    crossword puzzle problems

crossword puzzle generation  one required fill grid words
dictionary  formulated csp  formulation used experiments 
unknown words represented variable takes values dictionary 
binary constraints enforce intersecting words agree intersecting letter
word dictionary appears solution  figure   shows
example     crossword puzzle grid  csp model grid    variables     binary
 intersection  constraints      not equals  constraints 
 

 

 

 

 

 

 

 

 

  

  

  

  

  

  

  

  

  

  

  

  

figure    crossword puzzle 
experiments used    grids two dictionaries total     instances
problem ranged easy hard  grids  used    instances
following sizes                              dictionaries used
uk dictionary  collects         words largest domain
word variable contains        values  linux dictionary  collects       
words largest domain word variable       values 
experiments report  gac gac cbj based ac   bessiere   regin 
      found give best performance  see sillito       discussion
integrating ac  backtracking search  
figure   shows approximate cumulative frequency curves empirical results 
plotting ratio time taken solve instance gac time
taken solve instance gac cbj  thus  example  read curve
representing dom deg variable ordering approximately     tests adding
cbj little effect remaining     tests led orders magnitude
improvements  read curves                    percentiles data
sets  where value median   th percentile value   th test  
crossover point  gac cbj starts perform well better gac occurs
around   th percentile  tables     examine data closely showing
  

fichen   van beek

    

ratio  gac   gac cbj 

dom degree
dom degree

   

  

 

   
  

  

  

  

  
test

  

  

  

  

   

figure    effect execution time gac adding con ict directed backjumping  gaccbj   curve represents     tests instances crossword puzzle problem
tests ordered ratio time taken solve instance
gac time taken solve instance gac cbj 
actual times solve instances gac performed best instances
gac cbj performed best 
table    gac versus gac cbj instances crossword puzzle problem  ten
best improvements time  seconds  gac gac cbj solve instance
presented 
dom deg
rank gac gac cbj
 
    
    
 
    
    
 
    
    
 
    
    
        
      
     
     
 
 
     
     
 
     
     
 
     
     
     
        
  

dom deg
gac gac cbj
    
    
    
    
    
    
     
     
    
    
    
    
    
    
     
     
     
     
    
    

ficonflict directed backjumping revisited

table    gac versus gac cbj instances crossword puzzle problem  ten
best improvements time  seconds  gac cbj gac solve instance
presented  absence entry indicates problem solved
within       seconds     hours  cpu time 
dom deg
dom deg
rank gac gac cbj gac gac cbj
 
 
     
 
     
 
 
              
     
 
 
     
 
      
 
 
     
 
      
 
      
 
      
 
 
      
 
      
 
 
 
      
 
      
         
      
 
       
 
      
     
 
       
  
 
       
 
       

summary  smaller  easier crossword puzzle instances gac slightly
faster gac cbj  many puzzles noticeable difference 
larger  harder puzzles gac cbj orders magnitude faster gac 

   conclusion

paper  presented three main results  first  showed choice dynamic
variable ordering heuristic weaken effects backjumping technique  second 
showed level local consistency maintained backtracking
search increased  less backjumping improvement  together
results partially explain backtracking algorithm look ahead phase
cannot benefit backjumping look back scheme extend partial
ordering backtracking algorithms presented kondrak van beek        include
backtracking algorithms cbj hybrids maintain levels local consistency
beyond forward checking  third  finally  showed adding cbj backtracking
algorithm maintains generalized arc consistency  still  speed algorithm
several orders magnitude hard  structured problems  throughout paper 
restrict binary csps 

acknowledgements
authors wish thank referees careful reading previous version
paper helpful comments  financial support canadian government
nserc program gratefully acknowledged 
  

fichen   van beek

references

bacchus  f     grove  a          looking forward constraint satisfaction algorithms 
unpublished manuscript 
bacchus  f     van run  p          dynamic variable ordering csps  proceedings
first international conference principles practice constraint programming 
pp           cassis  france  available as  springer lecture notes computer science
    
bayardo jr   r  j     schrag  r          using csp look back techniques solve exceptionally hard sat instances  proceedings second international conference
principles practice constraint programming  pp         cambridge  mass 
available as  springer lecture notes computer science      
bayardo jr  r  j     schrag  r  c          using csp look back techniques solve realworld sat instances  proceedings fourteenth national conference artificial intelligence  pp           providence  ri 
bessiere  c     regin  j  c          mac combined heuristics  two reasons forsake
fc  and cbj   hard problems  proceedings second international conference principles practice constraint programming  pp         cambridge 
mass 
bessiere  c     regin  j  c          arc consistency general constraint networks  preliminary results  proceedings sixteenth international joint conference
artificial intelligence  pp           nagoya  japan 
bruynooghe  m          solving combinatorial search problems intelligent backtracking 
information processing letters            
chen  x          theoretical comparison selected csp solving modeling techniques  ph d  thesis  university alberta 
dechter  r          enhancement schemes constraint processing  backjumping  learning 
cutset decomposition  artificial intelligence              
dechter  r          constraint networks  shapiro  s  c   ed    encyclopedia artificial
intelligence   nd edition  pp           john wiley   sons 
freuder  e  c          synthesizing constraint expressions  comm  acm              
frost  d     dechter  r          dead end driven learning  proceedings twelfth
national conference artificial intelligence  pp           seattle  wash 
gaschnig  j          experimental case studies backtrack vs  waltz type vs  new algorithms satisficing assignment problems  proceedings second canadian
conference artificial intelligence  pp           toronto  ont 
haralick  r  m     elliott  g  l          increasing tree search eciency constraint
satisfaction problems  artificial intelligence              
kautz  h     selman  b          planning satisfiability  proceedings   th
european conference artificial intelligence  pp           vienna 
  

ficonflict directed backjumping revisited

kondrak  g     van beek  p          theoretical evaluation selected backtracking
algorithms  artificial intelligence              
mackworth  a  k       a   consistency networks relations  artificial intelligence    
       
mackworth  a  k       b   reading sketch maps  proceedings fifth international joint conference artificial intelligence  pp           cambridge  mass 
mcgregor  j  j          relational consistency algorithms application finding
subgraph graph isomorphisms  inform  sci               
montanari  u          networks constraints  fundamental properties applications
picture processing  inform  sci             
nadel  b  a          constraint satisfaction algorithms  computational intelligence    
        
prosser  p       a   domain filtering degrade intelligent backtracking search  proceedings thirteenth international joint conference artificial intelligence 
pp           chambery  france 
prosser  p       b   hybrid algorithms constraint satisfaction problem  computational intelligence             
prosser  p          mac cbj  maintaining arc consistency con ict directed backjumping  research report      university strathclyde 
sabin  d     freuder  e  c          contradicting conventional wisdom constraint satisfaction  proceedings   th european conference artificial intelligence 
pp           amsterdam 
schiex  t     verfaillie  g          nogood recording static dynamic constraint
satisfaction problems  international journal artificial intelligence tools          
sillito  j          improving estimating cost backtracking algorithms csps  
msc thesis  university alberta       
smith  b  m     grant  s  a          sparse constraint graphs exceptionally hard problems  proceedings fourteenth international joint conference artificial
intelligence  pp           montreal 
van beek  p     chen  x          cplan  constraint programming approach planning 
proceedings sixteenth national conference artificial intelligence  pp 
         orlando  florida 

  


