journal of artificial intelligence research                  

submitted       published     

partial order planning with concurrent interacting actions
craig boutilier

cebly cs toronto edu

department of computer science
university of toronto
toronto  on  m s  h   canada

ronen i  brafman

brafman cs bgu ac il

department of computer science
ben gurion university
beer sheva  israel      

abstract

in order to generate plans for agents with multiple actuators  agent teams  or distributed controllers  we must be able to represent and plan using concurrent actions with
interacting effects  this has historically been considered a challenging task requiring a
temporal planner with the ability to reason explicitly about time  we show that with
simple modifications  the
action representation language can be used to represent
interacting actions  moreover  algorithms for partial order planning require only small
modifications in order to be applied in such multiagent domains  we demonstrate this fact
by developing a sound and complete partial order planner for planning with concurrent interacting actions  pomp  that extends existing partial order planners in a straightforward
way  these results open the way to the use of partial order planners for the centralized
control of cooperative multiagent systems 
strips

   introduction
in order to construct plans for agents with multiple actuators  such as multi armed robots  
agent teams  or controllers distributed throughout an environment  we must be able to
model the effects and interactions of multiple actions executed concurrently  and generate plans that take these interactions into account  a viable solution to the basic
multiagent multi actuator planning  map  problem must include economical action descriptions that are convenient to specify and are easily manipulable by planning algorithms 
as well as planning methods that can deal with the interactions generally associated with
concurrent actions 
surprisingly  despite the interest in multiagent applications for instance  in robotics
 donald  jennings    rus        khatib  yokoi  chang  ruspini  holmberg  casal   
baader        and distributed ai  e g   see the various proceedings of the international
conference on multiagent systems  and the large body of work on distributed multiagent
planning  very little research addresses this basic problem of planning in the context of
concurrent interacting actions  researchers in distributed ai have considered many central
issues in multiagent planning and multiagent interaction  but much existing research is
concerned mainly with problems stemming from the distributed nature of such systems 
such as task decomposition and resource allocation  durfee   lesser        wilkins  
myers        stone   veloso         obtaining local plans that combine to form global plans

c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fiboutilier   brafman

 durfee   lesser        ephrati  pollack    rosenschein         minimizing communication
needs  wolverton   des jardins        donald et al          and so on  as opposed to this
form of distributed planning  our focus in this paper is on centralized planning for agent
teams  or distributed actuators  
representation of concurrent actions has been dealt with by various researchers in the
knowledge representation community  e g   lin   shoham        reiter        de giacomo 
lesperance    levesque        moses   tennenholtz        pinto         of particular
note are the action languages ac  baral   gelfond        and c  giunchiglia   lifschitz 
      which enable the specification of concurrent interacting actions and employ a nonmonotonic override mechanism to deduce the effects of a set of actions with conicting
effects  finally  a number of contemporary planners can handle concurrent noninteracting
actions to a certain degree examples include graphplan  blum   furst         and ipp
 koehler         which extends graphplan to handle resource constraints  and more recently
obdd based planners such as mbp  cimatti  giunchiglia  giunchiglia    traverso       
and umop  jensen   veloso        while knoblock        provides a good discussion of
the issue of parallelizing serial plans 
despite these advances  one often sees in the planning community suggestions that
temporal planners are required to adequately deal with concurrent interacting actions  for
example  in his discussion of parallel execution plans  knoblock        asserts 
to handle these cases  of interacting actions  requires the introduction of an
explicit representation of time  such as that provided in temporal planning systems 
a similar perspective seems implicit in the work on parallel action execution presented by
lingard and richards         certainly time plays a role in planning in any planner the
idea that sequences of actions occur embodies an implicit notion of time  however  we
disagree that time in centralized multiagent planning must be dealt with in a more explicit
fashion than in single agent planning  the main aim of this paper is to demonstrate that the
map problem can be solved using very simple extensions to existing  single agent  planners
like ucpop  penberthy   weld         we provide a representation and map algorithm
that requires no explicit representation of time  this is not to deny that explicit temporal
representations are useful in planning for many problems these may be necessary but
we do not think this is the key bottleneck in planning the activities of multiagent teams 
specifically  we view temporal issues to be orthogonal to the main concerns facing multiagent
planning 
the central issue in multiagent planning lies in the fact that individual agent actions
do interact  sometimes planning is hindered as a result of action interaction  action x of
agent   might destroy the intended effect of action y of agent   if executed concurrently  for
example  in a half duplex communication line  we cannot allow simultaneous transmission
of messages from both sides  in such a case  a planning algorithm has to make sure that
x and y are not executed at the same time  more interesting is the fact that planning
often benefits as a result of action interaction  action x of agent   might only achieve an
intended effect if agent   performs action y concurrently  for example  opening a typical
door requires two simultaneous actions  turning the knob and pushing the door  in military
activities  different units may have to coordinate their actions in order to be effective  e g  
   

fiplanning with concurrent interacting actions

turn on engines or lights simultaneously  or attack at the same time   similar situations
arise in a variety of domains  in such cases  a planning algorithm has to ensure that the
appropriate actions are executed at the same time  an action representation that makes
these interactions explicit and a planning algorithm that can  as result of these interactions 
prescribe that certain actions must or must not be executed concurrently are some of the
main features of any multiagent planner  temporal representations may play a role in the
scheduling of such actions  but are not strictly necessary for reasoning about the effects of
interaction  or lack thereof  
to illustrate some of these issues  consider the following example which will be discussed
in detail later in the paper  two agents must move a large set of blocks from one room to
another  while they could pick up each block separately  a better solution would be to use
an existing table in the following manner  first  the agents put all blocks on the table 
then they each lift one side of the table  however  they must lift the table simultaneously 
otherwise  if only one side of the table is lifted  all the blocks will fall off  having lifted
the table  they must move it to the other room  there they put the table down  in fact 
depending on the precise goal and effects of actions  it may be better for one agent to drop
its side of the table  causing all of the blocks to slide off at once  notice how generating
this plan requires the agents to coordinate in two different ways  first  they must lift the
table together so that the blocks do not fall  later  one of them  and only one  must drop
its side of the table to let the blocks fall 
since the actions of distinct agents interact  we cannot  in general  specify the effects of
an individual s actions without taking into account what other actions might be performed
by other agents at the same time  that truly concurrent actions are often desirable precludes
the oft used trick of  interleaving semantics   reiter        de giacomo et al          agents
lifting a table on which there are a number of items must do so simultaneously or risk the
items sliding from the table  perhaps causing damage  interleaving individual  lift my side
of table  actions will not do 
one way to handle action interactions is to specify the effects of all joint actions directly 
more specifically  let ai be the set of actions available to agent i  assuming n agents labeled
       n   and let the joint action space be a   a       an   we treat each element of this
space as a separate action  and specify its effects using our favorite action representation  
the main advantage of this reduction scheme is that the resulting planning problem can
be tackled using any standard planning algorithm  however  it has some serious drawbacks
with respect to ease of representation  first  the number of joint actions increases exponentially with the number of agents  this has severe implications for the specification and
planning process  second  this reduction fails to exploit the fact that a substantial fraction of the individual actions may not interact at all  or at least not interact under certain
conditions  we would like a representation of actions in multiagent multi actuator settings
that exploits the independence of individual action effects to whatever extent possible  for
instance  while the lift actions of the two agents may interact  many other actions will not
 e g   one agent lifting the table and another picking up a block   hence  we do not need
   our discussion will center on the strips action representation  but similar considerations apply to other
representations such as the situation calculus  mccarthy   hayes        reiter        and dynamic bayes
nets  dean   kanazawa        boutilier   goldszmidt        

   

fiboutilier   brafman

to explicitly consider all combinations of these actions  and can specify certain individual
effects separately  combining the effects  as needed  
joint actions also cause problems for the planning process itself  their use in the context
of most planners forces what seems to be an excessive degree of commitment  whenever
the individual action of some agent can accomplish a desired effect  we must insert into our
plan a joint action  thereby committing all other agents to specific actions to be executed
concurrently  even though the actual choices may be irrelevant  for these reasons  we desire
a more  distributed  representation of actions 
we are therefore faced with the following two problems 
   the representation problem  how do we naturally and concisely represent interactions
among concurrently executed actions 
   the planning problem  how do we plan in the context of such a representation 
in this paper  we show how the strips action representation can be augmented to
handle concurrent interacting actions and how existing nonlinear planners can be adapted
to handle such actions  in fact  it might come as a surprise that solving both problems
requires only a small number of changes to existing nonlinear planners  such as ucpop
 penberthy   weld          the main addition to the strips representation for action a
is a concurrent action list  this describes restrictions on the actions that can  or cannot  be
executed concurrently in order for a to have the specified effect  indeed  a can have a number
of different conditional effects depending on which concurrent actions are applied   in order
to handle this richer language  we must make a number of modifications to  standard 
partial order planners   a  we add equality  respectively  inequality  constraints on action
orderings to enforce concurrency  respectively  nonconcurrency  constraints  and  b  we
expand the definition of threats to cover concurrent actions that could prevent an intended
action effect 
we emphasize that we deal with the problem of planning the activities of multiple agents
or agents with multiple actuators in a centralized fashion  as opposed to distributed planning  our model assumes that one has available a central controller that can decide on an
appropriate joint plan and communicate this plan to individual agents  or actuators   while
distributed planning is an important and dicult problem  it is not the problem addressed
in this work  we also assume that some mechanism is available by which individual agents
can ensure that the execution of their concurrent plans are synchronized  again  while an
issue of significance and subtlety  it is not a task we consider in this paper 
we note that planning with parallel actions has been addressed in some detail by lingard
and richards         specifically  they provide a very general framework for understanding
constraint posting  least commitment planners that allow for concurrent action execution 
however  as mentioned above  their work takes an explicit temporal view of the problem
and focuses primarily on issues having to do with action duration  furthermore  while
multiagent planning could presumably be made to fit within their model  this seems not
to be their main motivation  in fact  the planning algorithms they discuss deal with the
issue of ensuring that parallel actions do not have negative synergistic effects  and explicitly
   moreover  other planning algorithms  e g   blum   furst        kautz   selman        should prove
amenable to extension to planning with concurrent interacting actions using similar ideas 

   

fiplanning with concurrent interacting actions

exclude the possibility of positive synergy  in our work  we abstract away from the temporal
component and focus precisely on planning in the presence of such synergies  both positive
and negative 
in the following section we describe our strips style representation for concurrent 
interacting actions and multiagent plans  in section   we describe the partial order multiagent planning algorithm  pomp   a modified version of the ucpop algorithm that can be
used to generate plans for multiagent teams or multiactuator devices  section   illustrates
the pomp algorithm on an extended example  in section   we discuss the soundness and
completeness of the pomp algorithm  we conclude in section   with a discussion of some
issues raised by this work 

   representing concurrent actions and plans

we begin by considering the representation of concurrent actions and partially ordered plans
using a simple extension of traditional planning representations  we first describe a standard action representation based on the strips model  specifically that used by ucpop
 penberthy   weld         we then describe the extension of this representation to represent concurrent interacting actions and its semantics  and finally describe the representation
and semantics of partially ordered multiagent plans 

    the strips action representation

variants of the strips action representation language  fikes   nilsson        have been
employed in many planning systems  we assume a finite set of predicates and domain
objects  generally typed  that characterize the domain in question  states of this system
are truth assignments to ground atomic formulae of this language  a state is represented
as a set  or conjunction  of those ground atoms true in that state  such as
f

ontable b     holding a  b   g

thus embodying the closed world assumption  reiter         actions induce state transitions
and can be viewed as partial mappings from states to states  an action a is represented
using a precondition and an effect  each a conjunction of literals  sometimes referred to
as the precondition or effect list   if a state does not satisfy the conjunction of literals
in the precondition list  the effect of applying the action is undefined  otherwise  the
state resulting from performing action a is determined by deleting from the current state
description all negative literals appearing in the effect list of a and adding all positive
literals appearing in the effect list 
as an example  the action of picking up a particular block b from the oor is described
in figure    using the usual lisp style notation of many planning systems  this action can
be executed when the agent s hand is empty and block b is clear and on the oor  after
the action is executed  the agent s hand is no longer empty  it holds b    and b is not on
the oor 
since the action of picking up a block from a location is essentially the same  regardless
of the particular block and location  a whole class of such actions can be described using an
action schema or operator with free variables denoting the object to be picked up and the
   

fiboutilier   brafman

 define  action pickup block b from floor 
 precondition  and  on floor b   handempty   clear b  
 effect
 and  not  handempty    not  on floor b    holding b    

figure    the pickup block b from oor action
 define  operator pickup 
 parameters
  x  y 
 precondition  and  on  x  y   handempty   clear  x   not     x  y   
 effect
 and  not  handempty    not  on  x  y    holding  x    

figure    the pickup action schema
pickup location  an action schema specification is similar to the specification of a single
action except for the use of free variables  the precondition list of an action schema can
contain  along with predicates  or more precisely  proposition  schemata    equality and
inequality constraints on the variables 
figure   illustrates an action schema for the pickup action  it has two variables   x and
 y   which stand for the object being picked up and the location of the object  respectively 
the precondition list includes the requirements that  x be on  y   that the hand is empty 
that  x is clear  and that  x and  y designate different objects  i e   one cannot pickup an
object from atop itself  
the strips representation can be enhanced  obtaining a more expressive language that
allows for a form of universal quantification in the action description  e g   as in ucpop
penberthy   weld         in addition  conditional effects can be captured using a when
clause consisting of an antecedent and a consequent  the semantics of the action description
is similar to the original semantics except that in states s that satisfy the preconditions of
the action and the antecedent of the when clause  the actual effect of the action is the union
of the  standard  effect specified in the effect list and the consequent of the when clause 
the when clause does not change the expressiveness of the language each conditional
action description can be expressed using separate non conditional actions in the classic
strips representation to capture each when clause  however  it allows for a more economical and natural specification of actions  for example  in the classic strips blocks world 
after putting some block b  on a destination block b    block b  is no longer clear  however 
after putting b  on the table  the table remains clear  hence  a different putdown schema is
required to describe moving a block to the table  using a when clause  we can use a single
schema with a conditional effect that modifies the standard effect of the action in case the
destination is not the table  i e   the when clause will state that when the destination is not
the table  it will become unclear   in addition  conditional effects may allow us to postpone
commitment during planning  e g   we may decide to put a block down  but we don t have
to commit to whether the destination is the table or not  

    representing concurrent actions in strips

the introduction of concurrent interacting actions requires us to address two issues specific
to the multiagent setting  who is performing the action  and what other actions are being
   

fiplanning with concurrent interacting actions

 define  operator pickup 
 parameters
  a   x  y 
 precondition  and  on  x  y  handempty  a    clear  x  not     x  y   
 concurrent
 not  and  pickup  a   x  y   not     a   a     
 effect
 and  not  handempty  a     not  on  x  y    holding  a   x   

figure    the multiagent pickup schema
performed at the same time  first  we deal with the identity of the performing agent by
introducing an agent variable to each action schema  when the schema is instantiated  this
variable is bound to a constant denoting the particular agent that is carrying out the action 
second  we must take into account the fact that for an action to have a particular effect 
certain actions may or may not be performed concurrently  we capture such constraints by
adding a concurrent action list to the existing precondition and effect lists in the specification of an action  the concurrent action list is a list of action schemata and negated action
schemata  some of which can be partially instantiated  if an action schema a  appears in
the concurrent action list of an action a then an instance of schema a  must be performed
concurrently with action a in order to have the intended effect  if an action schema a 
appears negated in the concurrent action list of an action a then no instance of schema a 
can be performed concurrently with action a if a is to have the prescribed effect 
the concurrent action list is similar to the precondition list in the following sense 
when the constraints it specifies on the environment in which the action is performed are
satisfied  the action will have the effects specified in the effect list  notice that positive
action schemata are implicitly existentially quantified one instance of that schema must
occur concurrently whereas negated action schema are implicitly universally quantified 
no instance of this schema should be performed concurrently 
a schema a  appearing in the concurrent action list of schema a can be partially instantiated or constrained  if a  contains free variables appearing in the parameter list of a  then
these variables must be instantiated as they are instantiated in a  in addition  constraints
that restrict the possible instantiations of the schema a can appear within the concurrent
action list  this can be seen in the description of the multiagent setting version of the action
pickup shown in figure    the multiagent pickup schema has an additional parameter   a  
signifying the performing agent  its list of preconditions and effects is similar to that of the
single agent pickup schema  but it also has the concurrent action list 
 not  and  pickup  a   x  y   not     a   a     

the  not  prefix restricts the set of actions that can be performed concurrently with any
instance of the schema pickup  a    x   y    in particular  we disallow concurrent execution
of any instance of the schema pickup  a    x   y   such that  a  is different from  a   that
is  no other agent should attempt to pickup the object  x at the same time 
using this representation  we can represent actions whose effects are modified by the
concurrent execution of other actions  for example  suppose that when agent a  lifts up
one side of a table all blocks on it are dumped onto the oor as long as no other agent
a  lifts the other side  but if some agent a  does lift the other side of the table then the
effect is simply to raise the side of the table  clearly  we can distinguish between these two
   

fiboutilier   brafman

 define  operator lower 
 parameters
  a   s  
 precondition  and  holding  a   s    raised  s   
 effect
 and  not  raised  s   
 forall  x
 when   ontable  x 
 not  and  lower  a   s   not     s   s      
 and  onfloor  x   not  ontable  x       

figure    the lower action schema
cases using the concurrency conditions  not  lift  a   side   and  lift  a   side  
however  treating them as standard concurrency conditions essentially splits the action into
two separate actions with similar effects  as in single agent representations  we can treat
such  modifiers  using a when clause  but now  the antecedent of the when clause has two
parts  a list of additional preconditions and a list of additional concurrency conditions  the
general form of the when clause is now  when antecedent effect   where the antecedent
itself consists of two parts   preconditions concurrency constraints   the latter list
has the same form as that of the concurrent action list  and similar semantics  thus 
whenever the precondition part of the antecedent is satisfied in the current state and the
concurrency condition is satisfied by the actions executed concurrently  the actual effect of
the action is obtained by conjoining the standard effect with the consequent of the when
clause 
the syntax of when clauses is illustrated in the table lowering action described in figure    notice that this operator contains a universally quantified effect  that is  an effect
of the form  forall  x  effect  x    this allows us to state that the conditional effect 
described by the when clause  applies to any object  x that satisfies its precondition  e g   to
every object on the table in this case   the use of universally quantified conditional effects
in finite domains is well understood  see weld s        discussion   however  to simplify
our presentation  we do not treat it formally in this paper 
when we lower one side of the table  that side is no longer raised  in addition  if there
is some object on the table  then lowering one side of the table will cause that object to fall 
as long as the other side of the table is not being lowered at the same time  here  we use
universal quantification to describe the fact that this will happen to any object that is on
the table  notice that in the concurrent part of the antecedent we see a constrained schema
again  it stipulates that the additional effect  i e   the objects falling to the oor from the
table  will occur if no instance of the schema lower  a    s   is executed concurrently  where
 s  is different than  s   
an action description can have no when clause  one when clause  or multiple when
clauses  in the latter case  the preconditions of all the when clauses must be disjoint  
one might insist that the set of when clauses be exhaustive as well  however  we do not
   in certain cases we might also insist that  a     a   if agents can perform only one action at a time 
but an agent with multiple effectors  to take one example  might be able to lower one or both sides
concurrently  see below for more on this 
   in the case of multiple clauses  the disjointness restriction can be relaxed if the effects are independent 
much like in a bayes net action description  boutilier   goldszmidt        

   

fiplanning with concurrent interacting actions

require this  if no when clause is satisfied when an action is performed  we assume that the
 additional  effect is null  that is  the effect of the action is simply that given by the main
effect list  when we discuss the when clauses of a specific action in our formal definitions
below  we will generally assume the existence of an implicit when clause whose precondition
consists of the negation of preconditions of the explicitly specified when clauses  and whose
effect list is empty  this allows our definitions to be stated more concisely  

    the semantics of concurrent action specifications

the semantics of individual actions is  of course  different in our multiagent setting than in
the single agent case  it is not individual actions that transform one state of the world into
another state of the world  rather it is joint actions that define state transitions  joint
actions describe the set of individual actions  some of which could be no ops  performed by
each of the agents  that is  they are n tuples of individual actions 
given a joint action a   ha         ani  we refer to the individual actions ai as the elements
of a  we say that the concurrent action list of an element ai of a is satisfied with respect
to a just when  for every positive schema a in this list  a contains some element aj  j    i 
which is an instance of a  and for every negative schema a  in the list  none of the elements
aj     j  n  is an instance of a   ignoring for the moment the existence of when clauses 
we can define the notion of joint action consistency in a straightforward manner 

definition let a   a     an be a joint action where no individual action ai contains a
h



i

when clause  we say a is consistent if





the precondition lists pi of each ai are jointly  logically  consistent  i e   they do
not contain a proposition and its negation  
the effect lists ei of each ai are jointly consistent 
the concurrent action list of each element of a is satisfied w r t  a 

given a state s  a consistent joint action a   ha        an i can be executed in s if the
precondition lists of all elements of a are satisfied in s  the resulting state t is obtained by
taking the union of the effect lists of each of the elements of a and applying it to s  as in
the single agent case  in fact  a consistent joint action a can be viewed as a single agent
action whose preconditions are the union of the preconditions of the various ai and whose
effects are the union of the effects of the ai  
notice that under this semantics  a joint action is inconsistent if some individual action
a causes q to be true  and another b causes q to be false  it is the responsibility of the
axiomatizer of the planning domain to recognize such conicts and either state the true
effect when a and b are performed concurrently  by imposing conditional effects with concurrent action conditions  or to disallow concurrent execution  by imposing nonconcurrency
conditions   
   we do not assume that such a clause is ever explicitly constructed for planning purposes it is merely a
conceptual device 
   one can easily preprocess actions descriptions in order to check for consistency  if actions a and b are
discovered to have conicting effects  but the specification allows them to be executed concurrently 
an algorithm could automatically add a nonconcurrency constraint to each action description  thus

   

fiboutilier   brafman

with when clauses the definition of consistency is a bit more involved  consistent joint
actions without when clauses can be applied consistently at all possible states  if they are
applicable at all   in contrast  joint actions with when clauses may be consistent when
applied at some states  but inconsistent at others  given a joint action a   ha         ani
and a specific state s  exactly one when clause of each action ai will be satisfied  that is 
just one clause will have its preconditions and concurrency constraints satisfied   thus the
joint action and the state together determine which conditional effects are selected 

definition given a joint action a   a     an and state s  the active when clause wi of
h



i

ai relative to s and a is the  unique  when clause that is satisfied by s and a  i e  
whose preconditions are satisfied by s and whose concurrency constraints are satisfied
by a  

we thus relativize the notion of consistency in this case 

definition let a   a     an be a joint action  where individual actions ai may contain
h



i

when clauses   let s be some state  let wi be the active when clause for ai  w r t  s 
a   and let wi have preconditions wpi  concurrency constraints wci  and effects wei 
we say a is consistent at state s if 





the precondition lists pi and active when preconditions wpi of each ai are mutually consistent 
the effect lists ei and active when effects wei of each ai are mutually consistent 
the concurrent action list of each element of a is satisfied w r t  a 

note that we do not require that the concurrent action lists in the when clauses be satisfied 
since they are  selected  by a  note also that this definition reduces to the  whenless 
definition if the individual actions have no when clauses an action is consistent with respect
to s iff it is consistent in the original sense 
given a state s  a joint action a   ha         ani  involving when clauses  that is consistent
with respect to s can be executed in s if the precondition lists of all elements of a are satisfied
in s  the resulting state t is obtained by taking the union of the effect lists of each of the
elements of a  together with the effect lists of each of the active when clauses  and applying
it to s 
several interesting issues arise in the specification of actions for multiple agents  first 
we assume throughout the rest of the paper that each agent can perform only one action
at a time  so any possible concurrent actions must be performed by distinct agents  this
allows our action descriptions to be simpler than they otherwise might  when a single
agent can perform more than one action at a time  it can be captured using a group of
 agents  denoting its different actuators  if these agents can only perform certain actions
preventing problems from arising during the planning process  this would be valid only if a and b could
not  in fact  be  meaningfully  performed concurrently  if they can  then it is important that the domain
axiomatizer specify what the true interacting effect is  e g   maybe action a dominates   we note that
this automatic inconsistency detection and repair admits a certain additional degree of convenience in
domain specification 
   we assume an implicit when clause corresponding to the negation of explicitly stated clauses as described
above 

   

fiplanning with concurrent interacting actions

concurrently  this can be captured by adding extra concurrency constraints  more generally 
different agents may have different capabilities  and it would be useful to have the ability
to explicitly specify these capabilities in the form of constraints on the types of actions that
different agents can execute  one way to handle such constraints is via a preprocessing
step that augments the action descriptions with additional preconditions or concurrency
conditions that capture these constraints  an alternative is to alter the planning algorithm
to take such constraints into account explicitly  when these are simple constraints for
instance  the fact that there are n agents might imply that only n actions can be executed
concurrently this can be done in a simple and ecient manner  this is the approach
we take in the planning algorithm we develop in section    however  when the capability
constraints are complex  the former method seems better 
another issue that must be addressed is the precise effect of a joint action  one of
whose individual actions negates some precondition of a concurrently executed individual
action  we make no special allowances for this  simply retaining the semantics described
above  while this does not complicate the definition of joint actions  we note that some
such combinations may not make sense  for example  the concurrent writing of variable p
to q and variable q to p in a computer program might be seen as each action destroying
the preconditions of the other  yet the net effect of the individual actions is simply a swap
of values  hence  in certain circumstances  it may be acceptable to describe the actions
this way  and in others this may not be the true effect of the joint action  again  we can
treat this issue in several ways  we can allow the specification of such actions and design
the planner so that it excludes such combinations when forming concurrent plans unless an
explicit concurrency condition is given  this means the axiomatizer need not think about
such interactions   or we can allow such combinations  in general  but explicitly exclude
problematic cases by adding nonconcurrency constraints 
finally  an undesirable  though theoretically unproblematic  situation can arise if we
provide  incongruous  concurrency lists  for example  we may require action a to be concurrent with b in order to have a particular effect  while b may be required to be nonconcurrent
with a  this can span a set of actions with more than two elements  naturally   hence  a and
b cannot occur together in a consistent joint action  and we would not be able to achieve
the intended effect of a  although the planner will eventually  recognize  this fact  such
specifications can lead to unnecessary backtracking during the planning process  again 
this is something that is easily detected by a preprocessor  and we will generally assume
that concurrency lists are congruous 

    concurrent plan representation
before moving on to discuss the planning process  we describe our representation for multiagent plans  which is a rather straightforward extension of standard single agent  partially
ordered plan representations  a  single agent  nonlinear plan consists of      a set of action
instances      various strict ordering constraints using the relations   and   on the ordering of these actions  and     codesignation and non codesignation constraints on the values
of variables appearing in these actions  forcing them to have the same or different values 
respectively  weld        penberthy   weld         a plan of this sort represents its set of
possible linearizations  the set of totally ordered plans formed from its action instances that
   

fiboutilier   brafman

do not violate any of the ordering  codesignation  and non codesignation constraints   we
say a plan is consistent if it has some linearization  the set of linearizations can be seen as
the  semantics  of a nonlinear plan in some sense  a  consistent  nonlinear plan satisfies a
goal set g  given starting state s  if any linearization is guaranteed to satisfy g 
a concurrent nonlinear plan for n agents  labeled         n  is similar  it consists of a set
of action instances  with agent arguments  though not necessarily instantiated  together
with a set of arbitrary ordering constraints over the actions  i e           and     and the
usual codesignation and non codesignation constraints  unlike single agent nonlinear plans 
we allow equality and inequality ordering constraints so that concurrent or nonconcurrent
execution of a pair of actions can be imposed  our semantics must allow for the concurrent
execution of actions by our n agents  to this end we extend the notion of a linearization 
definition let p be a concurrent nonlinear plan for agents         n  an n linearization of
p is a sequence of joint actions a      ak for agents         n such that
   each individual action instance in p is a member of exactly one joint action ai  
   no individual action occurs in a       ak other than those in p   or individual
no op actions 
   the codesignation and non codesignation constraints in p are respected  and
   the ordering constraints in p are respected  more precisely  for any individual
action instances a and b in p   and joint actions aj and ak in which a and b
occur  any ordering constraints between a and b are true of aj and ak   that is 
if af           gb  then j f           gk 
in other words  the actions in p are arranged in a set of joint actions such that the ordering
of individual actions satisfies the constraints  and  synchronization  is ensured by no ops 
note that if we have a set of k actions  which are allowed to be executed by distinct
agents  with no ordering constraints  the set of linearizations includes the  short  plan
with a single joint action where all k actions are executed concurrently by different agents
 assuming k  n   a  strung out  plan where the k actions are executed one at a time by a
single agent  with all others doing nothing  or where different agents take turns doing the
individual actions    longer  plans stretched out even further by joint no ops  or anything
in between 

example suppose our planner outputs the following plan for a group of three agents  the
set of actions is

f

a     b     c     d     e     f    

g

with the ordering constraints

e      b     c      d     a      e     d      f    

f

 

g

here  the numerical arguments denote the agent performing the action  joint actions
involve one action for each of the three agents  a simple   linearization of this plan 
depicted as the first linearization in figure    and using n to denote no ops for the
   concurrent execution has also been considered in this context for non interacting actions  see knoblock s
discussion of this issue  knoblock        

   

fiplanning with concurrent interacting actions

time

 

 

 

 

 

time

 

 

 

agent  

a

e

n

n

n

agent  

a

e

n

agent  

n

b

c

n

f

agent  

c

b

f

agent  

n

n

n

d

n

agent  

n

d

n

linearization  

linearization  

figure    two possible linearizations of a partially ordered multiagent plan
corresponding agents is 
           i h            i

ha

 n

 n

  e

 b

 n

  hn

           i
 c

 n

  hn

           i
 n

 d

  hn

           i
 f

 n

we can insert additional tuples of the form hn      n      n    i in any location we
wish  another possible   linearization  the second in figure    is 

a     c     n       e     b     d      n      f      n    

h

i h

i h

i

in fact  this is the shortest   linearization of the plan 
the definition of n linearization requires that no agent perform more than one action at
a time  this conforms with the assumption we made in the last section  though the definition could quite easily be relaxed to allow this  because of no ops  our n linearizations do
not correspond to shortest plans  either in the concurrently on nonconcurrently executed
senses of the term  however  it is a relatively easy matter to  sweep through  a concurrent nonlinear plan and construct some shortest n linearization  one with the fewest joint
actions  or taking the least amount of  time   though we do not have an explicit notion
of time  the sequence of joint actions in an n linearization implicitly determines a time line
along which each agent must execute its individual actions  the fact that concurrency and
nonconcurrency constraints are enforced in the linearizations ensure that the plan is coordinated and synchronized  we note that in order to execute such a plan in a coordinated
fashion the agents will need some synchronization mechanism  this issue is not dealt with
in this paper 

   planning with concurrent actions

in figure    we present the pomp algorithm  a version of weld s pop algorithm  weld 
      modified to handle concurrent actions  to keep the discussion simple  we begin
by describing pomp without considering conditional action effects  below we describe
the simple modifications required to add conditionals  i e   to build the analog of cpop  
though we do not discuss universal quantification in this paper  our algorithm could easily
be extended to handle universally quantified effects in much the same way as penberthy
and weld s        full ucpop algorithm 
   

fiboutilier   brafman

pomp ha  o  l  nc b i agenda  
termination  if agenda is empty  return ha  o  l  nc b i 
goal selection  let hq  aneed i be a pair on the agenda    aneed is an action and q is a conjunct from its
precondition list  
action selection  let aadd   choose an action one of whose effects unifies with q subject to the constraints in b    this may be a newly instantiated action from  or an action that is already in a
and can be ordered consistently prior to aneed   if no such action exists  then return failure  let
q a g  form b by adding to b any codesignation constraints that are needed
l   l   faadd  
need
in order to force aadd to have the desired effect  let o   o   faadd   aneed g  if aadd is newly
instantiated  then a   a   faadd g and o   o   fa    aadd   a g  otherwise  let a   a  
concurrent action selection  if aadd is newly instantiated then apply the following steps to all positive
actions ffconc in its concurrent list  let aconc   choose a newly instantiated action from  or an
action that is already in a and can be ordered consistently concurrently with aadd  make sure that
there is a free agent that can perform this action concurrently with aadd and any other concurrently
scheduled actions  if no such action exists then return failure  let o   o   faconc   aneedg  if
aconc is newly instantiated  then a   a   faadd g and o   o   fa    aconc   a g  otherwise 
let a   a   if aadd is the agent variable in aadd and aconc is the agent variable in aconc   then
add aadd    aconc to b   as well as all similar non codesignation constraints for actions a such that
a   aadd   o 
re apply this step to aconc   if needed 
for every negative action a conc in aadd concurrent list let nc   nc   fa conc    aadd g  add to
b any codesignation constraints associated with a conc  
updating of goal state  let agenda   agenda   fhq  aneedig 
if aadd is newly instantiated  then add fhqj   aaddig to agenda for every qj that is a logical precondition of aadd  add the other preconditions to b   if additional concurrent actions were added  add
their preconditions as well 
causal link protection  for every action at that might threaten a causal link ap  r ac perform one of
 a  demotion  add at   ap to o  
 b  weak promotion  add at  ac to o   if no agent can perform at concurrently with ac   add
at   ac  instead 
if neither constraint is consistent  then return failure 
nonconcurrency enforcement for every action at that threatens a nonconcurrency constraint a    a
 i e   at is an instance of the schema a that does not violate any constraint in b   add a consistent
constraint  either
 a  demotion  add at   a to o  
 b  promotion  add at   a to o  
if neither constraint is consistent  then return failure 
recursive invocation  pomp ha   o   l   nc   b i agenda   
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

figure    the partially ordered multiagent planning algorithm

   

fiplanning with concurrent interacting actions

we assume the existence of a function mgu q  r  b   which returns the most general
unifier of the literals q and r with respect to the codesignation constraints in b   this is
used wherever unification of action schemata is required  see the action selection step in
figure   and our discussion of nc threats below   the algorithm has a number of input
variables  the set a contains all action instances inserted into the plan so far  the set o
contains ordering constraints on elements of a  the set l contains causal links  the set
nc contains nonconcurrency constraints  and the set b contains the current codesignation
constraints  the set nc does not appear in the pop algorithm and contains elements of
the form a    a  where a    is an action schema and a is an action instance from a 
intuitively  a nonconcurrency constraint of this form requires that no action instance a 
that matches the schema a subject to the  non  codesignation constraints should appear
concurrently with a in the plan 
the agenda is a set of pairs of the form hq  ai  listing preconditions q that have not
been achieved yet and the actions a that require them  initially  the sets l  nc   and b
are empty  while a contains the two fictitious actions a  and a    where a  has the initial
state propositions as its effects and a  has the goal state conditions as its preconditions 
the agenda contains all pairs hq  a  i such that q is one of the conjuncts in the description
of the goal state  this specification of the initial agenda is identical to that used in pop
 weld         finally  we note that the choose operator  which appears in the action
selection and concurrent action selection steps  denotes nondeterministic choice 
again  this device is just that used in pop to make algorithm specification independent of
the search strategy actually used for planning  intuitively  a complete planner will require
one to search over nondeterministic choices  backtracking over those that lead to failure 
many of the structures and algorithmic steps of pomp correspond exactly to those
used in pop  rather than describe these in detail  we focus our discussion on the elements
of pomp that differ from pop  apart from the additional data structure nc mentioned
above  one key difference is the additional concurrent action selection step in pomp 
which takes care of the concurrency requirements of each newly instantiated action 
one final key distinction is the notion of a threat used in pomp  which is more general
than that used by pop  much like pop  given a plan ha  o  l  nc i  we say that at
q a when o   fa  a   a g is consistent  and a has  q
threatens the causal link ap  
c
p
t
c
t
as an effect  threats are handled using demotion  much like in pop   or weak promotion 
the latter differs from the standard promotion technique used in pop  it allows at to be
ordered concurrently with ac   not just after ac   
apart from handling conventional threats in a different manner  we have another form of
threat in concurrent plans  namely  nc threats   we say that action instance at threatens the
nonconcurrency constraint a    ac if o   fat   ac g is consistent and at is an instantiation
of a that does not violate any of the codesignation constraints  demotion and promotion
can be used to handle nc threats  just as they do more conventional threats  notice that
although the set nc contains negative  inequality  constraints  they will ultimately be
grounded in the set of positive constraints in o  following the approach suggested by weld
   if we wish to exclude actions that negate some precondition of another concurrent action  see discussion
in section     we must use o   fap  at  ac g in the definition of threat  and we must change weak
promotion to standard promotion 

   

fiboutilier   brafman

        we do not consider an action to be a threat if some of its variables can be consistently
instantiated in a manner that would remove the threat 
the pomp algorithm must check for the consistency of ordering constraints in several
places  in action selection where an action chosen to achieve an effect must be consistently ordered before the consumer of that effect  in concurrent action selection
where each concurrency requirement added to the plan must be tested for consistency  and
in nonconcurrency enforcement where demotion or promotion is used to ensure that
no nonconcurrency requirements are violated  the consistency testing of a set of ordering
constraints is very similar to that employed in pop  see weld        for a nice discussion   with one key difference  the existence of equality     and inequality      ordering
constraints as opposed to simple strict inequalities  i e     and     however  with minor
modifications  standard consistency checking algorithms for strict ordering constraints can
be used  equality can be dealt with by simply  merging  actions that must occur concurrently  i e   treating them as a single action for the purposes of consistency testing  
inequalities are easily handled by assuming all actions occur at different points whenever
possible  non strict inequalities  i e    and   do not arise directly in our algorithm
 though these two can be easily dealt with   we refer to ghallab and alaoui        for
further details on processing such constraints 
the pomp algorithm as described can easily be modified to handle conditional effects 
just as the pop algorithm can be extended to cpop  the main fact to note is that in the
action selection phase  we can use an action whose conditional effects achieve the chosen
subgoal  in that case  we do not just add the preconditions of the selected action to the
agenda  but also the antecedent of the particular conditional effect  this to ensure that
the action has this particular effect   we handle the additional concurrency conditions in
the antecedent much like the regular concurrency conditions  as in the cpop algorithm 
we must consider the possibility that a particular conditional effect of an added action
threatens an established causal link  in this case  we can  aside from using the existing
threat resolution techniques  consider a form of confrontation   where we add the negation
of the conditional effect s antecedent to the agenda  again  we have several ways to do
this  we could add the negation of some literal in the antecedent s condition to the agenda 
but we can also add a concurrent action to negate a negative concurrency condition in the
antecedent  or post a nonconcurrency constraint to offset a positive concurrency constraint
in the antecedent  the details of such steps are straightforward and look similar to those
involved in the unconditional algorithm 

   an example of the pomp algorithm
in this section  we formalize the example alluded to in the introduction and describe the
construction of a concurrent plan for this problem using the pomp algorithm 
in the initial state  two agents  agent  and agent   are located in room   together with
a table and a set of blocks scattered around the room  their goal is to ensure that all of
the blocks are in room  and the table is on the oor  in order to simplify this example  we
assume there is only one block b   we omit certain natural operators  and we simplify action
descriptions  in order to compactly represent the multiple block version of this  we would
require the introduction of universal quantification  as shown by weld         this can
   

fiplanning with concurrent interacting actions

be done with little diculty  intuitively  the agents should gather the blocks in the room
 in this case only one   put them on the table  carry the table to the other room  dump
the blocks from the table  and then put the table down  while this is not the best plan
for a single block  it illustrates how such a plan would be constructed for multiple blocks
 in which case this strategy is better than that of agents making multiple trips carrying
individual blocks   we use the following actions 







pickup a  b   agent a picks up a block b
putdown a  b   agent a puts block b on the table
totable a  s   agent a moves to side s  left  right  of the table
movetable a  r   agent a moves to room r with the table
lift a  s   agent a lifts side s of the table
lower a  s   agent a lowers side s of the table

the a variables are of type agent   b variables are of type block   r variables are of type room  
and s variables are of type table side   we omit other natural actions since they won t be
used in the plan of interest  
the domain is described using the following predicates 









ontable b   block b is on the table
onfloor b   block b is on the oor
atside a  s   agent a is at side s  left  right  of the table
up s   side s of the table is raised
down s   side s of the table is on the oor
inroom x  r   object x  agent  block  table  is in room r
handempty a   the hand of agent a is empty
holding a  x   agent a is holding x  block  side of table 

the operator descriptions are defined in figure   
the initial state of our planning problem is 
inroom b  room    onfloor b    inroom agent   room    inroom agent   room   
inroom table  room    down leftside   down rightside g

f

the goal propositions are 
inroom b  room    onfloor b    down leftside   down rightside g

f

we now consider how a concurrent nonlinear plan for this multiagent planning problem
might be generated by pomp 
   

fiboutilier   brafman

 define  operator pickup 
 parameters
  a   x 
 precondition  and  inroom  a   r    inroom  x  r  
 handempty  a    onfloor  x  
 concurrent
 and  not  pickup  a   x    not     a   a    
 effect
 and  not  handempty  a     not  onfloor  x    holding  a   x   
 define  operator putdown 
 parameters
  a   x 
 precondition
 and  inroom  a   r    inroom  x  r    inroom table  r  
 holding  a   x  
 concurrent
 not  lift  a   s   
 effect
 and  not  holding  a   x    ontable  x   handempty  a    
 define  operator totable 
 parameters
  a   s  
 precondition  and  inroom  a   r    inroom table  r    not  atside  a   s    
 concurrent
 and  not  totable  a   s     not     a   a    
 effect
 atside  a   s   

 define  operator movetable 
 parameters
  a   r  
 precondition  holding  a  table 
 concurrent
 and  movetable  a   r    not     a   a    
 effect
 and  inroom  r  table   inroom  r   a  
 when   ontable  x       inroom  r   x    
 define  operator lower 
 parameters
  a   s  
 precondition  and  holding  a   s    up  s   
 concurrent
 and  not  lift  a   s     not     a   a     not     s   s    
 effect
 and  not  up  s    down  s    not  holding  a   s   
 when   and  ontable  x   up  s    not     s   s    
 and  not  lower  a   s     not     a   a     
 and  onfloor  x   not  ontable x      
 define  operator lift 
 parameters
  a   s  
 precondition  and  atside  s   a    down  s    down  s    not     s   s    
 concurrent
 and  not  lower  a   s     not     a   a     not     s   s    
 effect
 and  not  down  s     up  s    holding  a   s  
 when   and  ontable  x   down  s    not     s   s    
 and  not  lift  a   s     
 and  onfloor  x   not  ontable x      

figure    the table movers domain

   

fiplanning with concurrent interacting actions

suppose that inroom b  room   is the first goal selected  this can be achieved by performing a    movetable a   room   via its conditional effect  note that a  is an agent variable  so there is no commitment to which agent performs this action     we must add both
holding a   table  and ontable b   to the agenda and insert the appropriate causal links 
in addition  the concurrent list forces us to add the action a    movetable a   room   to
the plan together with the non codesignation constraint a     a   the ordering constraint
a    a  is added as well  when we add a   we must add its precondition holding a   table 
to the agenda as well  the structure of the partially constructed plan might be viewed as
follows   
inroom block  r  

a 

goal

movetable a  r  

a 

c

movetable a  r  

next  we choose the subgoal ontable b   from the agenda  which we just added   we
add the action a    putdown a   b   to the plan with the appropriate ordering constraint
a    a   its preconditions are added to the agenda and a causal link is added to l  in
addition  we must add to nc the nonconcurrency constraint not lift a  s    no agent can
lift any side of the table while the block is being placed on it if the desired effect is to be
achieved 
inroom block  r  

ontable block 

a 
putdown a  block 

a 

movetable a  r  

goal

c

a 

movetable a  r  

    we do not pursue the notion of heuristics for action selection here  but we do note that this action is
a plausible candidate for selection in the multi block setting  if the goal list asserts that a number of
blocks should be in the second room  the single action of moving the table will achieve all of these under
the appropriate conditions  i e   all the blocks are on the table   if action selection favors  conditional 
actions that achieve more goals or subgoals  this action will be considered before the actions needed for
 one by one  transport of the blocks by the individual agents  so this choice is not as silly as it might
seem in the single block setting 
    in the plan diagrams that follow  we indicate actions as ai with the name of the action below it  variables
are indicated by lower case names  we do not indicate co designation constraints in the diagrams   an
arrow from one action to another denotes a causal link  from producer to consumer   labeled by the
proposition being produced  large arrows labeled with a c  resp  nc  denote concurrency  resp 
nonconcurrency  constraints between actions  we use left to right ordering to denote the temporal
ordering of actions  if such constraints exist 

   

fiboutilier   brafman

now we choose the subgoal holding a   table   this can be achieved using a   
lift a   s    with the ordering constraint a    a    all the preconditions are added to
the agenda  but no concurrency conditions are added  yet   for this action  since we do not
yet need to invoke the conditional effects of that action induced by simultaneous lifting of
the other side of the table 
holding a  table 

a 
lift a  ls 

inroom block  r  

nc ontable block 

a 

a 

putdown a  block 

goal

movetable a  r  
c

a 

movetable a  r  

we now note that the conditional effect of a  poses a threat to the causal link a  ontable
 
a   this is because lifting a single side of the table will dump the block from the table  in
addition  the nonconcurrency constraint associated with a    that no lifting be performed
concurrently with a    is threatened by a   an nc threat   as indicated in the plan diagram
above  the confrontation strategy is used to handle the first threat  and the action a   
lift a   s   scheduled concurrently with a    the constraints s     s  and a     a  are also
imposed  this ensures that the undesirable effect will not occur  we resolve the nc threat
by ordering a  before a      the resulting partially completed plan is now free of threats 
holding a  table 

a 
lift a  ls 

inroom block  r  
ontable block 

a 
putdown a  block 

c

a 

movetable a  r  

goal

c

a 

a 

lift a  rs 

movetable a  r  

next  we choose the subgoal down leftside   this is achieved using the action a   
lower a   leftside  and its preconditions are added to the agenda  in a completely similar
way  a    lower a   rightside  is added to achieve down rightside   again  we anticipate
the unification of these agent variables  
    in anticipation of a subsequent step  we use variable a  in the plan diagram instead of a   since they
will soon be unified  to keep things concrete  we have also replaced s  and s  with particular sides of
the table  leftside and rightside  to make the discussion a bit less convoluted 

   

fiplanning with concurrent interacting actions

a 
lower a  ls 
down ls 

a 

holding a  table 

lift a  ls 
ontable block 

inroom block  r  

a 

a 

putdown a  block  c

movetable a  r  

goal

c

a 

a 

lift a  rs 

movetable a  r  

a 

down rs 

lower a  rs 

we now choose to work on the preconditions of a  and a    both of the preconditions 
up s  and holding a  s   are effects of lift  so we use a  and a  as their producers  at this
stage  both a  and a  are constrained to follow a  and a    but there are no constraints
on the relative ordering of a  and a  themselves  we also see that both a  and a 
 potentially  threaten the causal link a  ontable
 
a   that is  they each have a conditional
effect that would cause the block to fall from the table  there are several ways to resolve
these two threats  including confrontation  we choose strict promotion  and order both a 
and a  to occur after a  and a   
holding a  ls 
up a  ls 

a 

a 
lower a  ls 

holding a  table 

down ls 

lift a  ls 
ontable block 

a

 

putdown a  block 

c

a 
lift a  rs 

inroom block  r  

a 

movetable a  r  

goal

c

a 

movetable a  r  

down rs 

a 
lower a  rs 
up a  rs 
holding a  rs 

now  we choose the subgoal onfloor b    which is a conditional effect of the lower
action  we choose to accomplish it using an existing action  a    in order to obtain the
desired effect  we ensure the antecedent of the when clause for this effect holds  this involves
adding the conditions of the antecedent  ontable b   and up leftside   to the agenda  and
imposing the nonconcurrency constraint of the antecedent  namely  that no concurrent
lower action can take place  this constraint is threatened by the action a    so we order
   

fiboutilier   brafman

a  before a  by posting the constraint a    a     the conditions of the antecedent 
ontable b   and up leftside   can use a  and a  as the producers  respectively 
ontable block 
holding a  ls 
up a  ls 

a 

a 
lower a  ls 

holding a  table 

down ls 
onfloor block 

lift a  ls 
ontable block 

a

 

putdown a  block 

c

inroom block  r  

a 

movetable a  r  

goal

c
holding a  table  a
 
lift a  rs 
movetable a  r  

a 

down rs 

a 
up a  rs 

lower a  rs 

holding a  rs 

the only unsolved subgoal is the precondition of the initial putdown a   b   action
 others  such as down leftside  for the lift action  are produced by the initial state   we
don t illustrate it  but it is a simple matter to introduce the pickup a   b   action before
putdown a   b   
we now have the following plan  first  the block is picked up and put on the table by
some agent a   either of agent  or agent  can do this   this is followed by two concurrent
lift actions and two concurrent move actions which get the table to the other room with the
block on top  next  we have a single lower action  which makes the block fall off  followed
by another lower action which ensures that both sides of the table are on the oor  we
note that the plan does not care which of the agents  the one who lifts the leftside or the
rightside  initially puts the block on the table   

   soundness and completeness of the pomp algorithm
we say that a planning algorithm is sound if it generates only plans that are guaranteed
to achieve the goals posed to it  a complete algorithm is guaranteed to generate a plan if
a successful plan exists    in the case of concurrent nonlinear plans  we will say that an
algorithm is sound if each n linearization of the plan produced for a given problem will
reach a goal state  and an algorithm is complete if it successfully generates a concurrent
nonlinear plan whenever there is a sequence of joint actions  i e   an n linearization of some
    the other ordering a    a  could have been used to resolve this threat  but it would cause an  unresolvable  threat to the conditions of the antecedent  which require that the other side remain up  it is 
of course  only  unresolvable  in the sense that it would require the agents to pick up the block  etc  
essentially introducing a cycle in the plan 
    further examples of map problems  the plans produced by pomp  and code implementing the pomp
algorithm can be obtained at http   www cs bgu ac il ishayl project  
    for formal definitions of these concepts  we refer the reader to  penberthy   weld        

   

fiplanning with concurrent interacting actions

concurrent plan  that achieves the goal from the initial state  we now show that the pomp
algorithm is both sound and complete 
the soundness proof is straightforward  suppose that the generated plan is not sound 
thus  some n linearization of the plan does not achieve the goal or some required subgoal
 i e   a precondition of one of the plan s actions   because of the agenda mechanism  it
is clear that for each needed goal or precondition there exists an action in the plan that
achieves that subgoal  goal or precondition   moreover  there is an explicit causal link in
the plan for that particular subgoal as well as an ordering constraint requiring that the
producing action to appear prior to the consuming action  or the goal   any n linearization
of a plan is another plan obtained from the original plan by adding new  consistent  strict
 i e        ordering constraints  recall that the original plan s ordering constraints must
have been consistent  otherwise it would not constitute a solution  and that there were no
threats  clearly  by adding new strict ordering constraints we cannot cause any new threats
to causal links or violate a nonconcurrency constraint  hence  the resulting n linearization
respects all causal links of the original plan and all ordering constraints of the original plan 
to complete the proof  we must be convinced that pomp actually considers all possible 
relevant interactions between actions  consider some effect p of an action a needed by some
action b which is ordered after a  given the semantics of actions  there are only two reasons
why p will not hold prior to the execution of b      some action c between a and b  possibly
concurrent with a  has an effect  p   or     a did not actually have p as an effect  case    
contradicts the fact that there are no threats  in our extended sense  covering the possibility
of c occurring concurrently with a  in the context of this plan  case     implies that either
p is an effect of a subject to some concurrency or nonconcurrency condition that is violated
in this n linearization  any such problem would have been taken care of by the action
selection or nonconcurrency enforcement steps  and by the ordering constraints  
thus it should be clear that any n linearization of a plan produced by pomp does in fact
achieve all its goals  that is  pomp is sound 
the completeness proof rests on three key elements 
   a reduction from multiagent planning problems to single agent planning problems 
   the fact that pomp can solve a multiagent planning problem iff pop can solve the
single agent planning problem obtained via this reduction 
   the fact that pop is sound and complete  penberthy   weld        
first  we show how given a multiagent planning problem  a similar single agent planning
problem can be obtained  we shall refer to the generated problem as the equivalent single
agent planning problem  or the esa problem   this reduction has the property that a plan
for the multiagent planning problem exists if and only if a plan for the esa problem exists 
in the introduction  we discussed such a reduction via the use of joint actions  here  we will
use a similar idea  but with a little more care so that both pomp and pop will perform
similar steps in the solution of the original problem and the esa problem  respectively 
combining these results with the fact that pop is sound and complete  we can deduce that
pomp is sound and complete as well 
   

fiboutilier   brafman

in the discussion below  we ignore conditional effects to avoid undue and  for the most
part  uninteresting complications  the extension of the arguments to deal with conditional
effects is straightforward  we first recall the following facts relevant to our argument 
 a  pop and pomp are nondeterministic planning algorithms and  although there
are various ways of making them deterministic  this issue is orthogonal to the
proof  thus  in showing the correspondence between pop and pomp alluded to
in point     above  we can utilize the exibility awarded to us by each planner s
use of nondeterministic choice  in particular  it is sucient to show that for a
given solution path for one planner  a similar solution path exists for the other 
 b  the choice of the next agenda element to work on is immaterial for both pop
and pomp it can affect the running time  e g   by causing backtracking  but
not the existence of a solution  hence  we are exible in ordering the subgoals
achieved  as long as we respect causality  i e   we cannot achieve a goal that is
derived from a precondition of an action that was not introduced yet  
 c  by introducing additional ordering constraints consistent with current constraints
in a valid plan  we obtain a valid plan for the given problem 
 d  the precise order in which actions and ordering constraints are inserted does
not affect the validity of the solution  in fact  as is well known in the planning
community  one can postpone the threat resolution step without affecting the
soundness or completeness of the algorithm  as long as all threats are eventually
resolved 
our proof will proceed in two stages  in the first stage  we will limit ourselves to a
restricted set of planning problems for which we can show the connections with pop in a
straightforward fashion  we then relax this restriction to show the correspondence between
the two planners in the general case 
recall that in section     we suggested a possible restriction on the set of actions one
is allowed to execute concurrently  namely  that no two actions a and b are permitted to
occur concurrently if one s effects negate any of the other s preconditions  we remarked
that this concurrent  non clobbering condition  if not enforced in the action specification
itself  is easily enforced by the pomp algorithm if we modify the definition of a threat and
use promotions instead of weak promotions to resolve threats  let us restrict attention  for
the time being  to domains respecting this condition 
we first note the following fact  let m be some pomp plan  and consider some nlinearization of m in which a  and a  occur concurrently  but where m is such that no
future actions require the effects produced by the concurrent execution of these actions 
that is  actions a  and a  are not forced to occur concurrently by plan m   in this case 
any similar n linearization in which a  is ordered before a    or vice versa  and no other
ordering constraints are violated  some such linearization must exist  will also achieve the
goal  the only case in which this might not happen is when one of a  or a  clobbers the
other s preconditions  but this has been explicitly disallowed in our restricted setting  by
the imposition of a nonconcurrency constraint or  precondition   
   

fiplanning with concurrent interacting actions

now consider the esa problem  where the actions available to the agent are as follows 
for each individual action a that has no concurrency constraints in the multiagent problem 
we create an action corresponding to the joint action where a is performed by its  owning 
agent  and no ops are executed by every other agent  and for each individual action a that
has concurrency conditions  requiring that actions b      bk be executed concurrently  we
create an action corresponding to the joint action where a and each of the bi are performed 
but no other actions apart from no ops are performed    we note that nonconcurrency
constraints are ignored in the esa problem definition 
clearly  if a joint action sequence exists for a given problem  there also exists a concurrent nonlinear plan for that problem  in addition  by the argument above involving
the assumption that no concurrent action clobber another s precondition  it is also easy
to see that  if a concurrent nonlinear plan can be found for a problem  there also exists a
concurrent nonlinear plan in which the only concurrency constraints involve actions whose
specification requires the concurrent execution of another action  or set of actions  in order
to obtain a particular effect  this implies that  should a problem be solvable  it is solvable
by a sequence of joint actions of the type constructed above  using only single agent individual actions together with a set of no ops  or at most involving minimal sets of interacting
actions  in other words  a concurrent nonlinear plan exists for a given problem iff a plan for
the esa problem exists  we note that the structure of any solution for the esa problem
 or any linearization of a nonlinear single agent plan for the esa problem  is very specific 
actions occur concurrently only if they are forced to  in other words  solutions to the esa
problem are strung out plans  in which agents  take turns  performing their actions 
next  we want to show that  in our restricted setting  pomp s solution path for a given
planning problem and pop s solution path for its esa problem resemble each other  this
becomes apparent once we combine pomp s action selection and concurrent action selection
steps  we obtain a step that is equivalent to the action selection step of pop for the esa
problem  i e   whenever pomp chooses an action which requires another concurrent action 
the required concurrent action is immediately inserted as well  this is equivalent to inserting
the proper esa action   in fact  now pop and pomp look almost identical  except for
pomp s nonconcurrency enforcement step  however  because of the fashion in which
the esa problem was defined  all nonconcurrency constraints are automatically  imposed 
in the plan produced by pop since they refer to different joint actions  any linearization
of these joint actions enforces the nonconcurrency of all joint actions  therefore  the only
 single agent  actions that can occur together in pop s solution to the esa problem are
those that have to occur together and on which there is no nonconcurrency constraint   in
fact  on these actions there is an explicit concurrency constraint    
the above argument demonstrates that pop and pomp generate  identical  sets of
plans  except for two small differences  first  pomp s semantics allows for concurrent
execution of certain actions  even though they need not be executed concurrently in order
    it is important to note that a single action schema gives rise to n individual actions  one for each
agent  e g   lift agent   s  and lift agent   s  are distinct actions  and separate joint actions for these
will be created   similarly  when the concurrency conditions involve action schemata  any permitted
combination of agent instantiations will give rise to a distinct joint action 
    this assumes that concurrency lists are congruous  as described in section    but if  not  a simple
redefinition of the esa problem can be given so that no  incongruous  concurrent actions are admitted 

   

fiboutilier   brafman

to solve the problem  while pop  for the esa problem  cannot generate plans that admit
this  however  this difference cannot affect the completeness argument  since it means that
pomp is more exible than pop     second  pomp commits to a particular ordering of
actions for which there is a nonconcurrency constraint  while pop will not make such a
commitment if both orderings are consistent  however  if both are consistent  and remain
unordered in the final plan for the esa problem  then the choice pomp makes cannot
impact the solution  and pomp can produce either alternative if the ordering does matter  
now  using the fact that pop is sound and complete  the virtual equivalence of pomp and
pop steps  and our facts about strung out plans and the esa problem  we see that pomp
is sound and complete for the special case where concurrent actions do not destroy each
other s preconditions 
finally  we wish to remove the restrictions placed on concurrent actions  and admit
problems where a concurrent action can clobber the precondition of another  we note that
problems of this type exist that cannot be solved by a strung out plan in the sense defined
above  for instance  consider the following problem  we have two actions 


action a  precondition p   effect q



action b  precondition  q  effect  p

actions a and b have no nonconcurrency constraints  thus they are not required to be
concurrent to have their specified effects when considered in isolation  suppose our initial
state is fp   qg and the goal state is f p  qg  the only plan that achieves this goal requires
that a and b be executed concurrently  if we order one before the other  we will destroy the
ability to perform the second  and the goal will not be reachable  thus  pomp can solve
this problem while pop could not solve the esa problem  as formulated above  
to deal with the more general case  we extend the construction of the esa problem by
including  in addition to the actions used in the restricted case  a joint action in the esa
problem for any set of actions a satisfying the following conditions 


each element of a is permitted to be executed concurrently  but need not be forced
to be concurrent  



each element of a clobbers the precondition of some other element of a 



no element of a can be removed without destroying this property 

in other words  we create a joint action corresponding to the concurrent execution of each
element of such a set a  we ll call these  self clobbering  joint actions  it should be evident
that a concurrent nonlinear plan exists for an arbitrary multiagent planning problem iff there
exists a sequence of joint actions  allowing self clobbering actions  that solve the problem 
and hence  by the soundness and completeness of pop  iff pop can find a plan for this
generalized esa problem  we have already seen that pomp can emulate any step of pop
    this additional exibility impacts only the soundness of pomp  and is addressed above   in fact  we
could have used the current line of reasoning as part of an integrated soundness and completeness proof
based on the pop pomp correspondence  in which case  we would need to explain why this last point
does not hinder the soundness of pomp 

   

fiplanning with concurrent interacting actions

involving actions other than self clobbering actions  we simply have to show that pomp
can emulate pop s introduction of self clobbering actions to show completeness 
let a be some self clobbering joint action  we claim that pop is complete  for the
generalized esa problem  if it only ever considers adding a to an incomplete plan when
each of its elements ai   a has an effect that satisfies some subgoal on the agenda  suppose 
to the contrary  that ai   a has no consumer on the current agenda  then either a is not
necessary in a successful plan  since some subset of the actions in a can be used   or the
actions that consume the effects of some ai have not yet been introduced  we can discount
the former case by considering only executions of pop that do not use this action  pop
will be complete even if this action is never considered  since it is able to introduce the
individual components  or concurrent subsets  of a that do produce the necessary effects 
we can discount the latter case  since there must be a valid execution of pop that introduces
the  ultimate  consumers of each element of ai before introducing a  thus  without loss of
generality  we assume that each element ai   a satisfies some subgoal on the agenda if a is
introduced by pop 
now suppose pop introduces a self clobbering action a  since all ai   a satisfy some
agenda item  pomp can simulate this step as follows  introduce each ai in turn to satisfy
some agenda item  postponing threat resolution among the ai   resolve the self threats among
the ai through weak promotion in the causal link protection step  so that we impose
ordering constraint ai  aj for ai that threatens aj    in the example above  for instance 
once actions a and b are added to achieve subgoals q and  p   respectively  the only way
to resolve the mutual threat is by weak promotion of both actions  that is  we impose a  b
and b  a  in other words  they are forced to be concurrent  thus any introduction of
a self clobbering joint action by pop  under the assumptions stated above  has a strong
correspondence with a sequence of possible steps in pomp  since pop can always find
a plan under these assumptions  so can pomp  thus the completeness of pomp in the
general case of arbitrary multiagent planning problems is demonstrated 

   concluding remarks
one often finds assertions in the planning literature that planning with interacting actions
is an inherently problematic affair  requiring substantial extension to existing single agent
planning representations and algorithms  thus  it is somewhat surprising that only minor
changes are needed to enable the strips action representation language to capture interacting actions  and that relatively small modifications to existing nonlinear planners are
required to generate concurrent plans  our solution involves the addition of a concurrent
action list to the standard action description  specifying which actions should or should
not be scheduled concurrently with the current action in order to achieve a desired effect 
the pop planner is augmented by two steps  one which handles the insertion of required
concurrent actions  and one which handles threats emanating from the potential concurrent
execution of two interfering actions  in addition  explicit reasoning with equality and inequality constraints is introduced  because of the strong resemblance between our solution
for the multiagent case and the solution for the single agent case  little overhead is incurred
when actions do not interact  in fact  in the extreme case of non interacting actions  both
our extension to strips and to pop reduce to their single agent equivalents 
   

fiboutilier   brafman

there is a close connection between our specification method and knoblock s       
approach to generating parallel execution plans  knoblock adds to the action description a
list that describes the resources used by the action  actions that require the same resource
 e g   access to a database  cannot be scheduled at the same time  hence  knoblock s
resource list actually characterizes one form of nonconcurrency constraint    in fact  we
believe that certain nonconcurrency constraints are more naturally described using such a
resource list than with the general method proposed here augmenting our language with
such lists should not prove dicult 
the treatment of concurrent actions in the specification languages ac  baral   gelfond        and c  giunchiglia   lifschitz        has many features in common with our
extension of strips  although c   in particular  is a very expressive language with many
additional features   these languages allow the use of complex actions which are sets of
primitive actions analogous to the ability we provide to combine a number of elements
into a joint action  typically  complex actions inherit their effects from the primitive actions contained in them  however  explicit specification of the effects of complex actions is
possible  overriding this inheritance  this overriding mechanism can extend to an arbitrary
number of levels  e g   an action a can have some effect  which is overridden when a and b
are performed concurrently  but this effect is itself overridden when c is performed as well 
etc    in these action description languages  an implicit view of time is adopted  much like
in our treatment  and concurrent actions are assumed to be performed simultaneously  until quite recently  there were no tools for actually synthesizing plans for domains described
in languages such as c   however  recent progress in model based techniques had led to
a number of new algorithms  including a sat encoding for the language c  giunchiglia 
      
when the effects of one agent s actions depend on the actions performed by other agents
at the same time  action specification becomes a complex task  the strips representation is
useful because it admits a relatively simple planning algorithm  however  despite strips s
semantic adequacy and its ability  in principle  to represent any set of actions  verifying that
a domain description is accurate becomes more dicult when interactions must be taken into
account  consequently  we believe that the use of dynamic bayes nets  in conjunction with
conditional outcome  or probability  trees  boutilier   goldszmidt         can provide a
more natural and concise representation of actions in multiagent settings  this specification
technique makes clear the inuence of different context conditions on an action s effects 
and allows one to exploit the independence of different effects  while this representation
can be used for stochastic domains  dynamic bayes nets offer these advantages even in the
case of purely deterministic actions  the pomp algorithm naturally extends to this form
of domain description  and a more complete treatment of this issue would be an interesting
direction for future research 
while adapting existing nonlinear planners to handle interacting actions is conceptually
simple  we expect that the increase in domain complexity will inevitably lead to poor computational performance  indeed  in our experiments with the pomp algorithm  we have
found that performance is greatly affected by the ordering of agenda items  hence  adequate
heuristics for making the various choices the planner is faced with namely  choosing sub    in principle  any nonconcurrency constraint can be handled in this manner by introducing fictitious
resources 

   

fiplanning with concurrent interacting actions

goals  choosing actions that achieve them  and choosing threat resolution strategies will
become even more critical  of course  the same issues are central for single agent nonlinear
planners  though we anticipate that the multiagent case with its interacting actions will
require different  or additional  heuristics 
an interesting topic for future work would be extending newer planning algorithms
such as graphplan  blum   furst        to handle our multiagent representation language 
indeed  the model based algorithm of cimatti  et al         seems to offer promising developments in this direction  naturally  all representational issues raised in this paper arise
regardless of the particular planning algorithm used  although with different implications 
for example  the question of whether or not to allow for concurrent actions that destroy
one another s preconditions affected which threat removal operators were valid in pomp 
whereas in graphplan they would affect the definition of interfering actions  and consequently  the question of which actions are considered mutually exclusive  
finally  we note that the approach we have considered is suitable for a team of agents
with a common set of goals  it assumes that some central entity generates the plan  and
that the agents have access to a global clock or some other synchronization mechanism
 this is typically the case for a single agent with multiple effectors  and applies in certain
cases to more truly distributed systems   an important research issue is how such plans
can be generated and executed in a distributed fashion  and how their execution should
be coordinated and controlled  this is an important question to which some answers have
emerged in the dai literature  des jardins  durfee  ortiz jr     wolverton        grosz 
hunsberger    kraus        des jardins   wolverton        boutilier              brafman 
halpern    shoham        and the distributed systems literature  fagin  halpern  moses 
  vardi        

acknowledgments
thanks to the referees for their suggestions on the presentation of these ideas and to mike
wellman for his helpful comments  we also thank daniel fogel  ishay levy  and igor razgon
for their implementation of the pomp algorithm  boutilier was supported by nserc research grant ogp         and the nce iris ii program project ic    brafman was supported by paul ivanier center for robotics and nce iris ii program project ic    much
of this work was undertaken while both authors were at the university of british columbia 
department of computer science  preliminary results in this paper were presented in
 planning with concurrent interacting actions   proceedings of the fourteenth national
conference on artificial intelligence  aaai      providence  ri  pp                

references
baral  c     gelfond  m          reasoning about effects of concurrent actions  journal of
logic programming         
blum  a  l     furst  m  l          fast planning through graph analysis  in proceedings
of the fourteenth international joint conference on artificial intelligence  pp       
     montreal 
   

fiboutilier   brafman

boutilier  c          planning  learning and coordination in multiagent decision processes 
in proceedings of the sixth conference on theoretical aspects of rationality and
knowledge  pp          amsterdam 
boutilier  c          sequential optimality and coordination in multiagent systems  in
proceedings of the sixteenth international joint conference on artificial intelligence 
pp          stockholm 
boutilier  c     goldszmidt  m          the frame problem and bayesian network action
representations  in proceedings of the eleventh biennial canadian conference on
artificial intelligence  pp        toronto 
brafman  r  i   halpern  j  y     shoham  y          on the knowledge requirements of
tasks  artificial intelligence                    
cimatti  a   giunchiglia  e   giunchiglia  f     traverso  p          planning via model
checking  a decision procedure for ar  in proceedings of the fourth european conference on planning  ecp      pp          toulouse 
de giacomo  g   lesperance  y     levesque  h  j          reasoning about concurrent
execution  prioritized interrupts  and exogenous actions in the situation calculus  in
proceedings of the fifteenth international joint conference on artificial intelligence 
pp            nagoya 
dean  t     kanazawa  k          persistence and probabilistic projection  ieee trans 
on systems  man and cybernetics                  
des jardins  m  e   durfee  e  h   ortiz jr   c  l     wolverton  m  j          a survey of
research in distributed continual planning  ai magazine                
des jardins  m  e     wolverton  m  j          coodinating a distributed planning system 
ai magazine                
donald  b  r   jennings  j     rus  d          information invariants for cooperating
autonomous mobile robots  in proceedings of the international symposium on robotics
research hidden valley  pa 
durfee  e  h     lesser  v  r          negotiating task decomposition and allocation using
partial global planning  in huhns  m     gasser  l   eds    distributed ai  vol    
morgan kaufmann 
durfee  e  h     lesser  v  r          partial global planning  a coordination framework for distributed hypothesis formation  ieee transactions on system  man  and
cybernetics                    
ephrati  e   pollack  m  e     rosenschein  j  s          a tractable heuristic that maximizes global utility through plan combination  in proceedings of the first international conference on multiagent systems  pp         san francisco 
   

fiplanning with concurrent interacting actions

fagin  r   halpern  j  y   moses  y     vardi  m  y          reasoning about knowledge 
mit press  cambridge  ma 
fikes  r     nilsson  n          strips  a new approach to the application of theorem
proving to problem solving  artificial intelligence                   
ghallab  m     alaoui  a  m          managing eciently temporal relations through
indexed spanning trees  in proceedings of the eleventh international joint conference
on artificial intelligence  pp            detroit 
giunchiglia  e          planning as satisfiability with expressive action languages  concurrency  constraints and nondeterminism  in proceedings of the seventh international
conference on principles of knowledge representation and reasoning  kr      pp 
        breckenridge  co 
giunchiglia  e     lifschitz  v          an action language based on causal explanation 
preliminary report  in proceedings of the fifteenth national conference on artificial
intelligence  pp          madison  wi 
grosz  b  j   hunsberger  l     kraus  s          planning and acting together  ai
magazine                
jensen  r  m     veloso  m  m          obdd based universal planning for synchronized
agents in non deterministic domains  journal of artificial intelligence research     
        
kautz  h     selman  b          pushing the envelope  planning  propositional logic  and
stochastic search  in proceedings of the thirteenth national conference on artificial
intelligence  pp            portland  or 
khatib  o   yokoi  k   chang  k   ruspini  d   holmberg  r   casal  a     baader  a 
        force strategies for cooperative tasks in multiple mobile manipulation systems 
in giralt  g     hirzinger  g   eds    robotics research    the seventh international
symposium  pp           springer verlag  berlin 
knoblock  c  a          generating parallel execution plans with a partial order planner 
in proceedings of the second international conference on ai planning systems  pp 
       chicago 
koehler  j          planning under resource constraints  in proceedings of the thirteenth
european conference on artificial intelligence  pp          brighton  uk 
lin  f     shoham  y          concurrent actions in the situation calculus  in proceedings
of the tenth national conference on artificial intelligence  pp          san jose 
lingard  a  r     richards  e  b          planning parallel actions  artificial intelligence 
                
mccarthy  j     hayes  p          some philosophical problems from the standpoint of
artificial intelligence  machine intelligence             
   

fiboutilier   brafman

moses  y     tennenholtz  m          multi entity models  machine intelligence            
penberthy  j  s     weld  d  s          ucpop  a sound  complete  partial order planner for
adl  in proceedings of the third international conference on principles of knowledge
representation and reasoning  kr      pp          cambridge  ma 
pinto  j          concurrent actions and interacting effects  in proceedings of the sixth
international conference on principles of knowledge rerpresentation and reasoning
 kr      pp          trento 
reiter  r          on closed world databases  in gallaire  h     minker  j   eds    logic
and databases  pp         plenum  new york 
reiter  r          the frame problem in the situation calculus  a simple solution  sometimes  and a completeness result for goal regression  in lifschitz  v   ed    artificial
intelligence and mathematical theory of computation  papers in honor of john mccarthy   pp           academic press  san diego 
reiter  r          natural actions  concurrency and continuous time in the situation calculus  in proceedings of the fifth international conference on principles of knowledge
representation and reasoning  kr      pp       
stone  p     veloso  m  m          task decomposition  dynamic role assignment  and lowbandwidth communication for real time strategic teamwork  artificial intelligence 
                 
weld  d  s          an introduction to least commitment planning  ai magazine         
      
wilkins  d  e     myers  k  l          a multiagent planning architecture  in proceedings of
the fourth international conference on ai planning systems  pp          pittsburgh 
wolverton  m  j     des jardins  m          controlling communication in distributed planning using irrelevance reasoning  in proceedings of the fifteenth national conference
on artificial intelligence  pp          madison  wi 

   

fi