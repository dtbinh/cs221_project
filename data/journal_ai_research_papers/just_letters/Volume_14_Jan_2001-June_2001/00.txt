journal of artificial intelligence research               

submitted       published     

on reachability  relevance  and resolution in the planning
as satisfiability approach
ronen i  brafman

brafman cs bgu ac il

department of computer science  ben gurion university
p o box      beer sheva        israel

abstract

in recent years  there is a growing awareness of the importance of reachability and
relevance based pruning techniques for planning  but little work specifically targets these
techniques  in this paper  we compare the ability of two classes of algorithms to propagate
and discover reachability and relevance constraints in classical planning problems  the first
class of algorithms operates on sat encoded planning problems obtained using the linear
and graphplan encoding schemes  it applies unit propagation and more general resolution steps  involving larger clauses  to these plan encodings  the second class operates at
the plan level and contains two families of pruning algorithms  reachable k and relevantk   reachable k provides a coherent description of a number of existing forward pruning
techniques used in numerous algorithms  while relevant k captures different grades of backward pruning  our results shed light on the ability of different plan encoding schemes to
propagate information forward and backward and on the relative merit of plan level and
sat level pruning methods 
   introduction

the success of the planning as satisfiability  pas  approach  kautz   selman             
has led to various attempts to refine the initial methods used and to improve our understanding of its performance  in particular  various methods for generating formulas from
planning instances have been compared  ernst  millstein    weld         and various systematic alternatives to the original stochastic method have been examined  e g   bayardo
  schrag        li   anbulagan         still  many issues surrounding this approach are
poorly understood  in particular  little is known about the inuence of the encoding method
on performance 
concentrating on the two encoding methods proposed by kautz and selman         the
linear and the graphplan based encodings  we examine their inuence on the ability to
propagate reachability and relevance information via unit propagation and  more generally 
k  clause resolution  we do so by comparing the pruning ability of these techniques to that
of a class of algorithms for reachability and relevance analysis that operate on the original
problem formulation  reachable k and relevant k  reachable k is a simplified variant of
a similar algorithm for state pruning in markov decision processes  boutilier  brafman   
geib         while relevant k is a natural counterpart used for relevance analysis  both
algorithms provide a coherent framework for discussing different grades of reachability and
relevance based pruning methods that appear in the literature 
our work is motivated by the growing role that forward and backward pruning methods
play in current planning algorithms and the important role of propagation techniques in

c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fibrafman

all sat solvers used in the planning as satisfiability approach  unit propagation plays
a central role in the davis putnam algorithm  davis   putman        and many of its
offsprings  e g   crawford   auton        freeman        gomes  selman    kautz       
li   anbulagan        and it is used as a preprocessing step when stochastic methods are
applied  moreover  a limited form of binary propagation is used in crawford s compact
program for simplifying cnf formulas which is utilized in the blackbox planner  kautz
  selman         our results shed some light on the relationship between these pruning
techniques 
the paper is organized as follows  section   provides background material  describing
the basic ideas of the pas framework and the graphplan algorithm  in section    we
discuss reachable k   an algorithm for performing reachability analysis  and compare its
ability to prune possible actions to that of k clause resolution  in section   we describe
relevant k which is similar to reachable k and is applied to relevance analysis  again  we
compare it to methods based on resolution  in section   we empirically compare the results
of various methods for k         we conclude with a discussion of future and related work
in section    proofs appear in the appendix  but their main arguments are described in the
body of the paper 
   background

the graphplan algorithm  blum   furst        and the satplan algorithm  kautz
  selman        have profoundly altered the direction of research within the planning
community  two of the main concepts studied in this paper  reachability analysis and plan
encodings  have become central to current planning research thanks to these planners  we
briey discuss these planners  and in particular  their aspects pertaining to our topic 

    reachability analysis in graphplan
the purpose of reachability analysis is to discover unreachable states of the world and
infeasible actions  i e   actions that cannot be performed in the course of a successful plan 
by discovering such actions ahead of time  we reduce the space that needs to be searched to
find a valid plan  in principle  full edged reachability analysis requires forward search in
the space of possible states  this is a very expensive operation  and instead  we can opt for
sound  but incomplete methods  such methods do not discover all the actions that can be
ruled out  however  any action that they rule out is infeasible and need not be considered
when searching for a plan 
the graphplan planner provides a good example of the utility of approximate reachability analysis  graphplan has two main stages  in the first stage  approximate reachability analysis is conducted  yielding a data structure called the planning graph which
represents a sound  but incomplete  approximation of the set of states reachable from the
initial state  in the second stage  graphplan searches for a plan over this structure 
graphplan s planning graph construction algorithm presents a particularly good tradeoff
between computational complexity and pruning power  and its utility in pruning the search
space is attested to by the planner s good performance 
the planning graph construction algorithm can be viewed as generating a list of annotated sets  the odd elements in this list contain sets of propositions  the even elements
 

fireachability  relevance  and resolution

in this list contain sets of actions  each such set is annotated with mutual exclusion constraints on its members  intuitively  the i action set contains the list of actions that could
be performed at the i step of a concurrent action plan  i e   a plan allowing for concurrent
execution of actions that do not interfere with each other   the i proposition set contains
propositions that could hold after i    sets of concurrent  actions have been performed 
the mutual exclusion constraints circumscribe these sets by indicating that certain pairs of
actions or propositions cannot occur at the same time at a particular stage  hence  if the
propositions p  q appear in the i proposition set  then it is possible  or more accurately
  the algorithm does not rule out the possibility  that an i step plan applied at the initial
state could lead to a world in which p and or q hold  however  if p and q are marked
mutually exclusive then we know that p and q cannot hold together after some i step plan
has been performed 
the sets are constructed as follows  the first proposition set contains the propositions
that hold at the initial state  the first action set contains the actions that can be performed
at the initial state  in general  the i set of propositions contains the effects of actions in
the i   action set  and the i action set contains actions whose preconditions appear in
the i   set of propositions  provided that their preconditions are not marked as mutually
exclusive  mutual exclusion constraints are added as follows  two actions are marked
mutually exclusive at the i action set if their preconditions are marked mutually exclusive
at the i     clearly  if all the preconditions of these actions cannot hold at this time
point  we cannot perform both actions together at this time point  another reason for
marking actions as mutually exclusive is if they conict  that is  if one action destroys a
precondition or an effect of the other action  two propositions at the i proposition set
are marked mutually exclusive if all pairs of actions in the i   action set that have them
as effects are mutually exclusive  when that is the case  there is no way for us to achieve
both of these propositions together at this stage 
the initial construction of the planning graph is terminated once all goal propositions
appear in the last proposition set  at that point  graphplan performs a form of regressionbased search on the planning graph structure  if this search fails  the planning graph is
extended by one additional layer of actions and one additional layer of propositions and
searched again  for more details  see the article by blum and furst        
th

th

th

th

th

th

th

th

th

th

th

th

    the planning as satisfiability approach
the planning as satisfiability approach  pas for short   works as follows  given a planning
problem and a bound n on the size of the plan  the plan encoder generates a propositional
formula in conjunctive normal form  this formula has the following property  it is satisfiable
iff the planning problem has a solution with at most n time steps  intuitively  the formula
is composed of propositions describing the state of the world throughout the execution of
an n step plan 
the propositional language on top of which the formula is defined contains a proposition
for each possible aspect of the world at each time point  for example  suppose we are looking
at the blocks  world domain where states are described using the on and clear relations 
in that case  for any pair of blocks x  y  and any time point    t  n we shall introduce
a proposition pon    which corresponds to x being on top of y at time t  similarly  for
x y t

 

fibrafman

every block x and time point    t  n  we shall introduce a proposition pclear    which
corresponds to x being clear at time t 
a truth assignment to the language described above can be viewed as describing the state
of the world during the execution of an n step plan  for instance  if pon     is assigned
true   then block a is on top of block b at time    of course  most truth assignments
to this language would not correspond to anything resembling the true state of the world
during the execution of an actual plan  for example  both on a b  and on b a  could
be assigned true   the goal of the encoding scheme is to generate a formula such that any
assignment satisfying this formula will correspond to the true state of the world during
the execution of an actual plan that achieves the desired goal  each axiom in this formula
places some constraint on the value of these propositions so that the combined effect of
these constraints is to ensure that the resulting formula has precisely the desired truth
assignments  for example  one type of axiom will be a conjunction of all the propositions
corresponding to the initial state  any truth assignment satisfying this axiom must ensure
that these propositions hold at time    another class of axioms could state that if some
action a is performed at time t then the world at time t   must satisfy the preconditions
of a  in the next sections we discuss two of the central plan encodings in more detail 
once an appropriate formula has been generated  it is simplified using various well
known techniques  in particular  all simplifiers employ a unit resolution step  genesereth
  nilsson         unit resolution  also known as unit propagation   works as follows  to
satisfy a cnf formula  we must satisfy each of its clauses  in particular  if one of the
clauses contains a single literal  such a clause is known as a unit clause   we immediately
know that the variable appearing in this clause must be assigned an appropriate value  any
clause containing the same literal will be satisfied now  and it can be removed from the
formula  any clause c containing the negation of that literal can be resolved against this
unit clause  and the resulting clause  which is smaller than c  can replace c  for example 
suppose we have the formula  p      q   p     r   p   the first disjunct   p  is a unit clause 
hence  p must be assigned true   this makes the third clause   r   p   satisfied  the second
clause is now resolved with the first clause  and we replace   q    p  by   q   we now
have a new unit clause    q   and so the proposition q must be assigned the value false   if
we had additional clauses containing q or  q  we could remove them  or simplify them  as
appropriate 
after simplification  we apply our favorite algorithm for finding satisfying assignments 
and if one is attained  a decoder is used to obtain an actual plan from this solution  if we
do not find a satisfying assignment  we increase the value of n  the size of the plan   and
try again 
finally  we note that the blackbox planner  kautz   selman        combines pas
with graphplan s reachability analysis  it constructs a planning graph  and uses it to
generate a particular plan encoding 
x t

a b 

   reachability and resolution

reachability and relevance analysis form an essential part of successful modern planning
algorithms  the most notable example of reachability analysis is graphplan s planning
graph  blum   furst         and many recent planners employ either reachability analysis
 

fireachability  relevance  and resolution

 e g   bonet  loerincs    geffner         relevance analysis  e g   mcdermoot        nebel 
dimopoulos    koehler         or both  kambhampati  parker    lambrecht         the
importance of reachability and relevance analysis has been noted in the context of decisiontheoretic planning as well  for example  boutilier and dearden        employ relevance
analysis to reduce the state space  and boutilier  brafman  and geib        describe a
general method for reachability analysis for mdps  below  we discuss this method in a
simplified form suitable for classical planning problems described using the strips representation language  fikes   nilsson         in section    we present a counterpart of this
method for performing relevance analysis and relate these algorithms to k clause resolution
in the context of sat encoded planning problems 

    propagating reachability information
reachable k  boutilier  brafman    geib        is an algorithm for estimating the states
reachable from a given initial state  as formulated  it is quite general and applies to domains with non deterministic actions and conditional effects  in figure    we present a
simplified version of that algorithm  reachable k   which deals with deterministic  unconditional actions represented in the strips representation language  a prolog implementation
of reachable k is available at www cs bgu ac il  pdm 
an important reason for our interest in reachable k is its similarity to the inuential planning graph construction of the graphplan planner  blum   furst         in
fact  it generalizes the ideas behind graphplan s planning graph  which is equivalent to
reachable    we use a to denote the set of actions feasible i steps from the initial state 

s to denote the corresponding set of propositions  and c s to denote constraints on these
propositions  such that if fp            p g   c s  then these propositions cannot co occur after

i steps  c a denotes similar constraints on actions  here     fl  p g  where l is used when
we restrict our attention to linear action sequences  and p is used when we allow concurrent
non conicting actions  i e   actions that do not destroy each others  effects or preconditions
and whose preconditions are not constrained not to co occur   of course  for k     the sets


c s and c a are empty for all i      actually  as defined  c a
is not empty even when
k      but it plays no real part in the algorithm  and it should be ignored   finally  note
that in this description  the set of possible actions contains all actions of the form noop l  
where l is a literal 
when k      s and a represent the propositional and action levels of graphplan s
planning graph  and c s and c a hold their respective mutual exclusion constraints 
we have not stated a termination condition for reachable k  but one can be formulated
based on the content of s or the index i itself  in the pas framework  where the number
of time steps is fixed  one would opt for the second alternative  reachable k gives us sets
of actions and propositions  a   s   that could occur after the performance of j actions  or
j sets of concurrently non conicting actions  from the initial state  it is easy to see that
reachable k is sound in the following sense 
i

i

i

m

i

i

i

l
i

i

i

i

p
i

i

i

j

j

theorem   if a set of propositions or actions is excluded by reachable k at time j then

there is no feasible plan in which  at time j   these propositions hold or  respectively  these
actions appear 
 

fibrafman

  literals that hold in the initial state 



s 



c s 

  fg 

  actions all of whose preconditions are in s   
 c al
    ffai   aj gjai   aj   a    i    j  neither ai nor aj are noops or aj is a noop whose effect
is destroyed by ai g 
 c ap   ffai   aj gjai   aj   a    i    j  and ai deletes a precondition or an effect of aj g 


a 

 

we define si   ai inductively as follows 
i   literals that appear in the effects of ai    
 c si   l tuples of literals  where l  k   appearing in si such that some subset of any set
of actions from ai   that has these literals appearing among their effects  appears in c ai  
 where    fl  p g as appropriate  


s

i   actions whose preconditions appear in si and no subset of their preconditions appears
in c si  
 c al
i   ffal   aj gjal   aj   ai   l    j  neither al nor aj are noops  or aj is a noop whose effect is
destroyed by al g 
 c api   ffaj            ajl gjl  k  aj            ajl   ai   jm    jn for m    n  and either     ajm
deletes a precondition or an effect of ajn for some m    n or     some subset of the union of
preconditions of aj            ajl appears in c si g 


a

figure    the reachable k algorithm
sometimes  all actions that can be executed at a particular time point in which p holds
have  p as an effect  in that case  we can ignore the noop p  action  as it will not be part
of any useful plan   however  as formulated  p will appear in reachable k  s next level  we
denote by reachable  k a variant in which noop p  does not appear in such a case 
the computational complexity of reachable k is o njajjlj e   njljjaj    where n is
the number of levels we generate  jaj is the number of possible actions  jlj is the size of the
propositional language used  and e is the maximal number of actions that have a particular
shared effect  a more detailed explanation appears in appendix b 
example  to illustrate the parallel action version of reachable k  we use the following
planning domain  there are four propositions  p    p    p    p    intuitively  we can think of
them as representing a binary counter with   bits  there are   actions  each of which
increases the counter by one at different states  in this domain only a single non noop
action is applicable at each state  a  changes the least significant bit  a  changes the next
bit  a  changes the third bit  and a  changes the most significant bit  a is applicable only
if the first i   bits are one  more specifically the actions are 
k

k

k

i

   for some planning algorithms  e g   in the pas approach  it may be necessary to leave the noops in 

 

fireachability  relevance  and resolution

a 

precondition 

 

a 

precondition 

p 

a 

precondition 

p

p

a 

precondition 

p

p

p 

  effect 

p 

 

       effect          
              effect                 
                  effect                   
p

p

p

p

p

p

p

p

p

p
p

p

p 

 

we compare reachable   and reachable   using the initial state   p    p    p    p   
which corresponds to a binary representation of    we concentrate on the  more interesting 
parallel action version of the algorithm  and we shall not mention noops explicitly or obvious
mutual exclusion constraints between propositions and their negations 
in the context of reachable    c s and c a are empty  for all practical purpose  we
start with s    f p     p     p     p  g  only the action affecting the first bit is applicable  and
a    fa  g  and all the relevant noops   we now have s    fp     p     p     p     p  g  because
the preconditions for both a  and a  appear in s    we have that a    fa    a  g  consequently
s    fp     p    p     p     p     p  g  now  we can also apply a    and we have a    fa    a    a  g 
s    fp     p    p     p    p     p     p  g  finally  at this stage all preconditions of a  appear as
well  and a    fa    a    a    a  g 
next  consider reachable    again  s    f p     p     p     p  g  c s  is empty  and a   
fa  g  in the next step we have  s    fp    p     p    p    p g  with no interesting constraints
in c s    and a    fa    a  g  however  now c a contains  a    a     which are interfering
actions  s    fp     p    p     p    p     p     p  g  as in the case of k      however  c s  contains
 p    p     this follows from the fact that the only actions in a  capable of producing p  are
a  and noop p     and the only action in a  capable of producing p  is a    a  interferes
with both a  an noop p    therefore  because c s  contains  p    p     a  is not applicable
at this stage  hence  a    fa    a  g  which is one action less than the set a  in reachable   s    s    fp     p    p     p    p     p     p  g  however  now c s  does not contain  p    p   
 because noop p   can be used to achieve p    and it does not conict with  e g   noop p    
therefore  a    fa    a    a  g 
to see how k     improves our ability to prune over k      suppose that s   
fp    p    p    p  g  i e   the counter s value is       and consider k     first  we have
a    a  and s    f p   p    p    p     p    p     p  g  with  p    p      p     p       p    p    and
 p    p    in c s    each of these mutual exclusion relations stems from the fact that a 
is mutually exclusive with noop p   and noop p     therefore  a    fa    a  g  again
s    s    f p   p    p    p     p    p     p  g  but now c s  contains  p    p    only  and so
a    fa    a    a  g  now  c s  is empty  and so a    fa    a    a    a  g  however  if k     
c s  contains the ternary constraint  p    p    p     this ternary constraint remains in c s  as
well  and in c s    because it is in c s  for k      we have that a     a   
i

i

i

    k clause resolution and reachability
 clause resolution  or propagation  refers to the resolution of pairs of clauses one of whose
length is k at most  the k     variant  i e   unit propagation  is an integral part of all
major algorithms for generating satisfying assignments 
we wish to compare the type of reachability information derived by performing k clause
resolution on sat encoded planning problems  with the information obtained by running
k

 

fibrafman

the reachable k algorithm  by reachability information we mean constraints on the set of
actions possible at a time point or constraints on world states  in the form of  e g   sets of
unreachable propositions or k tuples of propositions   hence  for example  a constraint of
the form a t    a   t  implies that one of the actions a or a  must appear at time t in the
plan  a constraint of the form  a t    a  t  implies that one of the actions a or a  must not
appear in the plan  similar constraints on the propositions holding at a time point can also
be derived  in principle  such constraints reduce our search space and could help us attain
a solution more quickly  however  the effectiveness of such deduced constraints depends
on the precise algorithm used  moreover  comparison over a very large class of constraints
seems quite dicult  therefore  in this article we concentrate on a very concrete class of
reachability information of the form  a t   i e   the action a cannot be performed at any
state reachable via t steps  these are powerful constraint which can be utilized effectively
by almost all planners  perhaps with the exception of partial order planners   consequently 
we shall say that an algorithm alg  generates more reachability information than another
algorithm alg  if whenever alg  is able to determine that some action a cannot be performed
at some time t  alg  is able to reach this conclusion as well  and in addition  there are such
conclusions which alg  can reach but which alg  cannot reach  hence  alg  generates a
strict superset of the constraints on actions  of the type we are interested in  generated
by the other algorithm  note that this does not mean that alg  is better than alg  on
every instance  only that it is always as good  and in some cases better  in this section
we shall compare the pruning ability of the two reachable k variants and two encoding
methods discussed by kautz and selman          the linear encoding and the graphplan
encoding 
      linear plan encoding

the linear plan encoding  kautz   selman        is a simple and natural method for
translating a planning problem into a formula that is satisfiable iff there is a valid plan of
length n  for some given n   the clauses in the linear plan encoding fall into the following
classes 
   an action implies its preconditions prior to its execution 
   an action implies its effects following its execution 
   an action does not affect any other proposition  frame axioms  
   there is at least one action at each time point 
   there is at most one action at each time point 
because we have explicit frame axioms  noops are not needed in the linear encoding  as
opposed to the graphplan encoding   in addition  the formula contains unary clauses
describing the initial and goal states  however  for the purpose of analyzing reachability
effects  we exclude the description of the goal state  which plays a role in relevance analysis  
consider the mechanism by which resolution can yield reachability information  given
the propositions that hold at the initial state  we can derive the negation of actions whose
   the third  state based  encoding method cannot be generated automatically 

 

fireachability  relevance  and resolution

preconditions do not hold using unit propagation on axioms of class    propagating these
unit clauses with the appropriate instance of axiom class    we will obtain a disjunction
of all actions that can be executed at the first time point  so far  this is identical to
what reachable  k provides  to propagate this information forward  we can resolve these
action disjunctions with axioms of class   and    this  however  requires binary resolution
 discussed below   hence  except for the unlikely case in which a single action is possible 
there is no more that we can derive using unit propagation alone  reachable     on the
other hand  can provide us with a list of all possible effects of these actions and possibly
prune out future actions whose preconditions do not appear in this list  we conclude 
lemma   in the context of the linear encoding  reachable    yields more reachability in 

formation than unit propagation 

example  consider a blocks  world domain with a single action schema move object source 

destination    its preconditions are  on object source   clear object   clear destination 
and its effects are  on object destination   clear source    on object source     clear
 destination   except when the destination is the table which is always clear   if we have k
stacks of blocks initially  k  actions can be performed at the initial state  i e   moving a block
from the top of a stack to the top of another stack or the table   this will be discovered by
both algorithms  in particular  unit propagation will yield a disjunction of all these actions 
we know that all blocks that are   or more blocks below the top cannot participate in
the second move action  reachable   will find this out due to the fact that they are not
clear  suppose that a is one such block  all initially feasible move actions participate in
a frame axiom of the form move o s d   clear a        clear a      which  in clausal
form is  move o s d  clear a        clear a      resolving against  clear a      we
have  move o s d   clear a      if we could deduce  clear a      we could rule out all
actions that have it as a precondition  but if we are restricted to unit propagation  this
requires deducing move o s d  for some initially feasible action  and we cannot make such
a deduction 
if we propagated information forward using axioms of class   and   and used binary
resolution  as discussed before lemma     we now have a set of disjunctions of the possible
effects  including frame effects  of the initially allowable actions  the number of such
disjuncts is o e    where e is the maximal number of effects of an action and m is the
number of actions that can be executed initially  in some cases  these disjunctions could
contain a single literal  e g   when all initially allowable actions leave some proposition
unchanged  when one of these disjunctions contains only literals that are negations of
some action s precondition  we can deduce the negation of this action by resolving with
axioms of class   
example  in the example considered above we would generate a disjunction of the form
move o    s    d      move o    s    d      move o    s    d     containing all instances of the move
action for time   whose negations have not been deduced  as discussed above  for all such
actions  we can obtain a clause of the form  move o   s   d    clear a      once we resolve
these binary clauses against the clause above  we obtain a unary clause  clear a      that
m

i

i

i

   in fact  since we use plain strips  we need three action schemas  one for moving a block to a block  one
for moving a block to a table  and one from moving a block from the table  however  as this does not
affect our analysis  we stick to a single move action in this and the following examples 

 

fibrafman

can be used in conjunction with class   axioms to deduce the negations of step   actions
whose preconditions include clear a     
as we saw  the effect disjunctions discussed above allow us to rule out certain propositions or combinations of propositions  these are analogous to mutual exclusion constraints 
these mutual exclusion constraints can be used to prune actions  for example  if we deduce  p          p and all the p are preconditions of some action a  we can deduce  a
using binary resolution  by resolving precondition axioms with this disjunction   however 
as we show below  binary resolution has trouble propagating even binary mutual exclusion
constraints forward  we believe that this is generally true  i e   k clause resolution will have
trouble propagating k ary constraints  we can show the following 
m

i

lemma   reachable   and binary resolution  in the case of the linear encoding  are incomparable 

we prove this by providing two examples  one in which reachable   is able to prune
an action that binary resolution cannot  and one in which the converse hold 
first  consider the   bit counter with initial value       i e    p    p     p     p     after four steps we obtain the following  s    f p    p     p    p     p    p     p  g and c s   
f p    p      p    p  g  therefore  a    fa    a    a  g  this implies that s    s    we claim
that  p    p      c s  as well  which means that a     a    to see this  consider all pairs of
actions that have p  and p  as effects  they are   a    a      a    noop p      noop p     a     and
 noop p    noop p       a    a    is a pair of real actions  which are always mutually exclusive
in the linear encoding  the preconditions of  a    noop p    are mutually exclusive according
to c s    and so are the preconditions of  noop p    noop p     finally   noop p    a    are
interfering actions  we conclude that  p    p      c s  and a     a   
when we run a binary resolution procedure on the linear encoding of this problem 
we could not deduce a     a    this stems from the fact that ternary resolution is needed
to propagate the mutual exclusion of p  and p    recall that we obtain mutual exclusion
constraints by resolving against a disjunction of actions that have not been ruled out  in
the above case  at time   we would have the following disjunction  a     a     a     noop  p    
     noop    p    our goal is to deduce  p      p   using  p      p   and the various axioms 
to do this  we will try to deduce either  p     p   from each of the actions in the disjunction 
it is easy to deduce  p   from a   and  p   from a     however  we believe that it is impossible
to deduce  p      p   from a   and from some of the noops   the reason for this is that such
a deduction involves the use of frame axioms  which are ternary  if we know that  e g    p  
holds  we apply unit resolution to the frame axioms and obtain a binary clause  however 
here we only know  p      p    once we resolve this against a frame axiom we remain with
a ternary clause  to get our desired result we must resolve two such ternary clauses 
finally  let us see an example in which we use binary resolution to derive a ternary
constraint  by definition  reachable   cannot derive such constraints  suppose that the
initial state is  p   q   r  we have four actions  a  has p  r as effects  a  has q  r as effects 

a  has p  q as effects  and a  has p  q  r as preconditions  using reachable    we deduce that
a   a   a  are possible at time    we get as their possible effects p  q  r   p   q   r  recall
   the fact that the deduction is impossible has been verified  what we are hypothesizing here is the reason
for it 

  

fireachability  relevance  and resolution

that we must include all noop actions in reachable k in order to capture frame effects   no
strict subset of p  q  r can appear in the set of constraints c s    since we deal with binary
constraints only  the set fp  q  rg does not appear in c s    therefore  we will consider a 
possible at time    although  in fact  it is impossible  using binary resolution  we would
have obtained the constraint  p    q    r  referring to time    which would have enabled
us to deduce that a  is impossible at time   
      the graphplan encoding

the graphplan encoding differs from the linear encoding by its ability to consider multiple
concurrent  non interfering  actions  allowing one to obtain shorter plans which  in turn 
can reduce the search space size  it constructs the following sets of clauses 
   an action implies its preconditions 
   an effect implies one of the actions that has this effect 
   there is at least one action at each time point 
   two conicting actions cannot occur together 
besides the obvious ability to consider multiple parallel  non interfering  actions  the important difference between the graphplan and linear encoding is in axiom class    referred
to in  ernst et al         as explanatory frame axioms   clauses in this class will contain
positive occurrences of action literals and negative occurrences of state literals 
as in the linear case  using unit propagation we can infer which actions cannot be
applied at the initial state  using axioms of class    we can propagate this information forward  deducing the negation of all effects that cannot be produced by the initially allowable
actions  this information enables us to exclude actions whose preconditions cannot be produced  this forward propagation is essentially identical to reachable    we can informally
conclude 

lemma   in the context of the

encoding  unit propagation and reachable  
yield the same reachability information  if we ignore the explicit constraints appearing in
axiom class    if we use these constraints  unit propagation can yield more reachability
information 
graphplan

to be precise we have to carefully define the notion of reachability constraints in the context
of the graphplan encoding  for example  in the graphplan encoding we can derive a
constraint that says that one of a group of actions must appear in the plan  this constraint
will not necessarily rule out any action because the graphplan encoding permits multiple
actions at the same time point   however  in the linear encoding such a constraint will
immediately rule out all other actions because only a single action is allowed at each time
point  as we mentioned earlier  in this paper we concentrate on strict exclusion constraints
   however  because actions that interfere with each other cannot occur concurrently  if we know that action
a will occur then we can deduce that any action a that interferes with a will not occur  this is precisely
where class   axioms enter the picture 
 

  

fibrafman

which lead to an immediate reduction in the search space by ruling out the need for certain
actions at certain time points 
when k      the mechanism remains the same  but now  axioms of class   can play
a more prominent role because we can use them to exclude actions in more cases than
before  however  the same problem of propagating mutual exclusion constraints forward
which we had with the linear encoding reappear here  consequently  k clause resolution in
the context of the graphplan encoding and reachable k are incomparable 
   relevance and resolution

relevance analysis is a complex task and it can be performed to various degrees  for
instance  considering the last action level  one can exclude actions that do not produce a
literal in the goal  however  some actions producing a goal literal can also be irrelevant 
for example  consider a blocks  world planning problem in which the color of the blocks
is specified as part of the goal  as observed by nebel  dimopoulos  and koehler         a
paint block action is still  intuitively  irrelevant if the initial and final colors of the blocks
are the same  however  it does have a goal literal as an effect 
in this section  we formulate an algorithm for relevance analysis  called relevant k  
relevant k does not perform the deeper relevance analysis needed to determine that the
paint block action is irrelevant in the above example  rather  relevant k is similar in its
motivation and form to reachable k   and it has a similar soundness property  relevant k
prunes the search space by excluding states from which the goal is not reachable within a
given number of steps and actions that are not useful for achieving the goal state within a
given number of steps 
relevant   is similar to a number of existing components of existing planners  such
as mcdermott s greedy regression graph  mcdermoot        and nebel  dimopoulos  and
koehler s and or trees  nebel et al          relevant k generalizes these ideas to arbitrary
levels of interactions  taking into consideration mutual exclusion constraints that relevant
states must satisfy  relevant k is slightly more complicated then reachable k because the
strips formalism allows incomplete description of goal states  and propagating this partial information raises some diculties  naturally  if the goal state is partially specified 
fewer constraints are available to start with  and so fewer constraints will be derived  the
algorithm is described in figure    we are not aware of a similar  general formulation of
these ideas  therefore  it is worthwhile going over the central points of this algorithm 
concentrating on the more interesting and complex case in which parallel actions are allowed  however  before we do this  we point out an important assumption we shall make
on the action representation used  no proposition symbol shall appear only in the preconditions or only in the effects of an action  this restriction is not dicult to enforce  as any
strips based domain representation can be transformed into a description in which this
assumptions is satisfied  for example  if p is a precondition of action a that does not appear
in the effect of a  we can simply add it to the effect  as we know that it must hold after
the action is executed  if p appears in the effect of a but neither p nor  p appear in the
preconditions of a  we can decompose a into two versions of the a action  one in which p is
a precondition and one in which  p is a precondition  note that in the worst case  such a
transformation can cause an exponential blow up in the number of actions 
  

fireachability  relevance  and resolution

r contains all actions that are useful and safe w r t  the goal 
 a  contains ar  and all noops that are safe w r t  the goal 


a 

contains all pairs of interfering actions in a   
we define ri   si   ari   ai inductively as follows 
 ri is the union of preconditions of actions in ari    


c a 



s

i is the union of preconditions of actions in ai    

i contains sets s of literals such that s  si   js j  k and for any set of actions a  ai  
whose preconditions contain s it is the case that a   c ai    
 ari contains all actions that are useful w r t  ri but no subset of their effects is contained in
c si  
 ai contains ari and all noops useful w r t  si  
 c ai contains all action sets a such that a  ai and either     a contains two interfering
actions  or     some subset of the set of effects of a is in c si  



cs

action descriptions must contain the same set of propositional symbols in their precondition and
effect lists 

figure    the relevant k algorithm
for k     the algorithm is quite simple  and identical in the parallel and linear cases   in
that case  we can ignore the sets s   c s   a and c a  as they are degenerate  and consider
the sets r and a only  starting with the goal literals  at each stage we have a set of
literals from which we construct the next set of actions  this action set contains actions
with an effect in the current literal set  however  if all the goal effects of an action are all
part of its preconditions  we can ignore that action as irrelevant  next  a new literal set is
constructed  containing the set of preconditions of the current set of actions  and we repeat
the process with this new set 
when k      the picture becomes a bit more complicated  we start with the set
of relevant actions  a   these are actions that achieve one of the desired literals  in
particular  a  contains only actions that have one of the goal literals as an effect  but not
as a precondition   if the goal is partially specified  literals that are not part of it could hold
in the previous time step  hence  we include the appropriate noop actions in a larger set 
a   which contains both a and noops that do not destroy needed propositions  a subset
of the actions in a is mutually exclusive if it contains interfering actions or actions whose
effects are mutually exclusive  given the set a     we generate the set r   which includes
the preconditions of a     the set s is defined as the set of preconditions of actions in a  
if the goal is a completely specified state  there is no the sets r and s and the sets a
and a are identical  and so we need not distinguish between them 
i

i

i

i

r
i

i

r
i

r

r
i

i

i

r
i

r
i

i

i

i

i

i

  

i

r
i

fibrafman

to facilitate the description of the relevant k algorithm  it would be useful to add a
few simple definitions  first  we wish to revise the definition of interfering actions in the
context of the relevant k algorithm  we say that actions a  a  interfere with each other if
some effect of a conicts with some precondition or effect of a  or  and this is beyond the
previous definition of this term  if their preconditions are inconsistent  an action a is useful
w r t   with respect to  some literal l if a is the noop action preserving l or l is an effect 
but not a precondition  of a  a is useful w r t  some set of literals if it is useful w r t  one of
the set s elements  a set a of actions is safe w r t  some set of s of literals if no action in
a has an effect that negates an element of s  
relevant k embodies the intuitions described above  note that an increased index corresponds to points earlier in time  the definition of the sets s   r   a   a is quite intuitive 
s contains the preconditions of the actions in the previous a   and r contains the preconditions of actions in a   a contains actions that have a useful  but not mutually exclusive 
effects  a is defined much like a   but w r t  s rather than r   the set c s contains
literals that are mutually exclusive at a particular point  a set l of literals is mutually
exclusive if any set of relevant actions that have l among their preconditions are mutually
exclusive  the set c a contains mutually exclusive sets of actions  a set of actions a is
mutually exclusive if it contains interfering actions or if the set of its effects is mutually
exclusive 
example  in order to illustrate the relevant k algorithm  we shall once again use the counter
example used in section      starting with a three bit counter and using the propositions 
p    p    p    each of the actions a    a    a  can change the value of a single bit from   to   
provided the values of the lower bits are   
we start with the final state f p     p    p  g and k      since the final state is fully
specified  there is no distinction between the sets s and r and between a and a   a 
contains the action a  and the three relevant noops  s  contains fp     p    p     p    p     p  g 
a  now contains a    a    a    and the appropriate noops  and the remaining sets look the
same 
if k      a  and s  are as in the k     case  however  c s  contains   p    p    and
 p     p     which implies that a  cannot be applied  hence  a  contains a  and a    but not
a    unlike the case of k      the action a  would be introduced only in the next step 
next  consider a partially specified goal  such as fp    p  g and with k      a   
fa    noop p    noop p  g because a  has p  as an effect  and a  does not destroy p   whereas
a    for example  does not have an effect in the goal  a  would now contain a  as well as
the noops for p  and  p    r    fp    p     p    p  g and s    fp     p    p     p    p  g  next  a 
contains fa    a  g  etc 
finally  suppose we have four bits  and the goal state is f p     p    p    p  g  i e   the
counter s bit value is        if k      a  contains a  and s    fp     p    p     p    p     p    p  g 
however  c s  contains pairs such as   p     p       p     p    and others  a  contains a    a 
and some noops  s    s    but now  c s  does not contain   p     p     it does contain
  p     p     though  and that precludes action a  from being in a    in the next step  we
have s    s    s    and c s  no longer contains   p     p     this implies that we can
add a  to a  because its effects are no longer mutually exclusive  so overall  we have
a    fa  g  a    fa    a  g  a    fa    a    a  g  and a    fa    a    a    a  g  however  if k      at
i

i

i

i

i

r
i

r
i

i

r
i

r
i

i

i

i

i

i

i

i

r
i

i

r

r

r

  

fireachability  relevance  and resolution

we would still have a mutual exclusion constraint on   p     p     p     which would not
allow us to add a    hence  when k      a    fa    a    a  g 
we can prove the following soundness results 
c s 

theorem   let

be some state from which the goal is reachable using an m step plan
 where each step can contain a number of non interfering actions   then     the set of
literals satisfied in s is a subset of s   no subset of which is in c s   and     there exists
an m step plan for reaching the goal from s such that if a is the set of actions in the plan
v steps before last then a  a and no subset of a is in c a  
s

m

m

v

v

a corollary of this theorem is 

corollary   for any initial state s from which the goal is reachable and any minimal  in
the number of operators  plan p   a          a    where the steps are numbered backwards  for
reaching the goal from s  we have a   a and c a does not contain any subset of a   
m

i

i

i

i

the complexity of relevant k is o jaj jlj   jlj
jaj   where jaj is the number of
actions  jlj is the number of proposition in the language  and m is the maximal number
of preconditions of an action  for more details  see appendix b 
we now compare the amount of relevance information that can be propagated backwards
using k clause resolution and the goal literals as opposed to relevant k   consider unit
propagation first  in the context of the linear encoding  we see that all actions that destroy
some goal condition will be ruled out  however  actions that are irrelevant because they
produce irrelevant effects will not be pruned   on the other hand  relevant   prunes both
actions that destroy some goal literal and actions that are simply irrelevant  there is a
slightly degenerate case in which all actions but one destroy some goal proposition  in that
case  using unit propagation we will be able to deduce the previous state  consequently  we
have 
k

k

k
mp

p

lemma   in the context of the linear encoding  unless there is a single safe  final action 

unit propagation yields less relevance information than relevant   

in the context of the graphplan encoding the situation is often worse  and unit propagation prunes even less than in the linear encoding  the goal propositions appear only in
class    effect  axioms  propagating them against these axioms  we obtain disjunctions of
positive action propositions explaining a particular goal proposition  if we assume that all
literals have more than one explanation  we see that no new unit clauses emerge  consequently  we can prune nothing 
example  consider the blocks  world domain once again  suppose that there are three
blocks a b  and c  and that the goal is on a b   clearly  any action that moves block c
or moves another block on top of block c is irrelevant as a last action  when we consider
the graphplan encoding  the only unit clause we have is on a b t   where t is the last
time point   we can resolve it against the effect axiom that lists the the possible causes for
on a b t   aside from the noop action  there are actions such as moving a from c to b
   in general  proving that an action should be ruled out means that we have shown that in all models  i e  
all plans  this action does not appear  we cannot expect to be able to do this for an irrelevant action
since it could possibly be inserted into the plan without affecting it 

  

fibrafman

and moving a from the table to b  this yields a new ternary clause and no additional unit
clauses  there are no other axioms in which on a b t  appears negated 
notice that we have no means of excluding actions that destroy one of the goal literals 
for example  if our goal was clear a t   we would not want the action move b c a t    as
a last action  however  as above  all that we can deduce from clear a t  is  move b a c t   move b a table t     move c a b t    move c a table t     noop clear a  t     
if we could use binary resolution at this stage  we could deduce the negation of any action
with the effect  clear a t   because any such action would be mutually exclusive from
any of the above five actions 
if a goal literal l has a single explanation it must be a noop action  which implies that
there is no  real  operator that has it as an effect   in that case  we would be able to deduce
that this noop action must hold  and using the precondition axioms  we would deduce that
l must hold at the previous step  using the mutex axioms  class    we could deduce the
negation of any action that destroys l  however  we cannot deduce the negation of any
action that does not interact with l  whether it is simply irrelevant or it destroys some
other goal literal 
example  consider a domain such as the rocket domain  where a rocket can have fuel 
but there is no action for fueling a rocket  suppose that the rocket has fuel in the goal
state  hence  fuel t  holds  since the explanation axiom for fuel is a binary clause  i e  
 fuel t    noop fuel t      resolving this axiom with the fact fuel t   we derive a new
unit clause noop fuel t      using the precondition axioms  we can derive fuel t    
using the mutex axiom  we can derive an action such as fly t     one of whose effects is
 fuel t     notice  though  that we cannot deduce the negation of an action that does
not interact with the proposition fuel  whether or not it is irrelevant  for example  if fuel
is the only proposition in the goal  then an action such as loading the rocket  which does
not affect the value of the proposition fuel need not be considered for the final action of
the plan  however  as before  there is no way of deducing  load t    
because no action can produce fuel the same reasoning would apply to any step  and
we will be able to deduce the fact that fuel holds at each time point during the plan 
using this fact  we will be able to prune out all actions that have  fuel as a precondition 
relevant   will not be able to do so  if a has  fuel as a precondition but a has an effect
that is relevant at some point  a will be considered a relevant action  

lemma   in the context of the

encoding  if there is an action for changing the value of every literal  then unit propagation yields less relevance information than
relevant   
graphplan

some actual values appears in section    in particular  in the examples we looked at 
the graphplan encoding could not prune any action  this follows from the  quite typical 
fact that in these domains  each of the facts that hold at the final state can be achieved
by a number of actions  hence  unit propagation can deduce only disjunctions of possible
   of course  in this particular domain we do not have an action whose precondition is  fuel  but the
observation is still valid  for example  we may have a maintenance action which can be performed only
when the rocket is without fuel 

  

fireachability  relevance  and resolution

actions  none of which are a unit clause  since we have no way of deducing negated actions 
propagation stops at this point 
the general case is similar  in the linear encoding  having obtained a disjunction of
allowable actions  we can generate a disjunction of allowable preconditions  this information
is propagated backwards much like the forward case  yet  as in the k     case  all we can
expect is a form of backwards reachability analysis from the goal state  rather than true
relevance analysis  again  relevant k is likely to do a much better job here  because it
takes explicit relevance issues into account  however  as in the case of reachability analysis 
because of the ability of k clause resolution to yield constraints of order greater than k  we
cannot show that relevant k is always better 
in the context of the graphplan encoding  we will generate disjunctions of relevant
actions  from which disjunctions of relevant preconditions can be deduced  etc  however 
irrelevant actions will not be excluded explicitly  since more than one action is allowed at
each step  and we will only conclude that some relevant action must appear  nor can we
exclude actions that destroy a goal proposition  again  because we can deduce constraints
of order greater than k via k clause resolution  we cannot provide a general result here 
finally  we note that     the graphplan planner does not incorporate relevance analysis  but mea graphplan  a more recent variant  does  kambhampati et al          as
well as ipp  nebel et al              ernst  millstein  and weld        discuss an enhanced
version of the graphplan encoding which contains effects axioms as well  i e   axioms of
the form action   effect   in terms of the ability to propagate reachability and relevance
information  we see an added ability to rule out actions that destroy needed propositions
 as in the linear encoding  
   empirical evaluation

in the previous sections we attempted to understand the mechanisms by which resolution
yields reachability and relevance information and to compare them to a natural class of
direct reachability and relevance algorithms  as we noted  the relationship is not always
that of subsumption  and it is of interest to examine the actual pruning abilities of these
algorithms  in this section we describe the performance of these algorithms on a number
of standard planning problems  because of the limited number of domains used  caution
should be exercised in interpreting these results  however  some interesting results emerge 
our first set of experiments examined the performance of unary methods on large blocks
world and logistics domain problems  we used the blocks  world problems bw dir a b c d
from the satplan distribution  involving            blocks  respectively  and  minimal 
plans of length            the logistics  domain problems are based on instances described
in  brafman   hoos        involving   packages and   cities  with minimal plans of size
         respectively  sat encodings were generated using the medic program  ernst
et al          we used the crse options to obtain a linear encoding and the erpe options
to obtain a graphplan like encodings  however  the encoding obtained via the erpe options contain explicit effect axioms  as in the linear encoding  these axiom improve the
graphplan encoding s ability to propagate relevance information 
   these instances are part of the ucpop distribution  maintained by the university of washington  or
from http   www research att com  kautz blackbox index html  the blackbox home page 

  

fibrafman

log a
log b
log c
bw a
bw b
bw c
bw d

j j
a

    
    
    
    
     
     
      

reach rel r r u rch l  u rel l 
             
   
  
             
   
  
              
   
  
             
   
   
             
    
   
                
    
   
                
    
    

table    pruning effects of unary methods  jaj is the number of possible actions in
the course of a minimal length plan  the following entries hold the number of
actions pruned using  reachable    relevant    both combined  unit propagation
on linear encoding using initial state  and using the final state  unit propagation
in the graphplan encoding using the final state yielded no pruning  execution
times for the reach relevant algorithms are       seconds except for bw c      
sec    and bw d       sec   
in this set of experiments we measured the number of potential actions eliminated by
the following algorithms  reachable    relevant    reachable   and relevant   combined 
reachability analysis via unit resolution using the initial state  and relevance analysis via
unit resolution using the goal state  we did not consider the graphplan encoding for the
following reasons 
    unit propagation in the graphplan encoding yields as much information as reachable       for our particular experiments  and in most other cases   unit resolution based on
the final state in the graphplan encoding prunes little  if any  actions because for each
fact appearing in the goal state there are a number of potential producing actions     
the version of the graphplan encoding produced by medic is basically equivalent to the
linear encoding in terms of relevance information because it contains explicit effect axioms 
the actual numbers appear in table    the first column provides the size of the set of
actions for the minimal plan length  the following columns provide the number of actions
pruned by the various methods tested  it is evident that reachable   is extremely effective 
relevance analysis seems much less useful  although relevant   does prune a non negligible
number of actions  the results for unit resolution are quite disappointing  although in line
with our theoretical analysis  recalling that unit resolution in the graphplan encoding
is equivalent to reachable    we see that there is a much greater potential for pruning in
the graphplan encoding  another interesting observation is that there is little overlap
between the reachability and relevance analysis  this stems from the fact that the pruning
effect of these algorithms is often quite shallow  most of the pruning is done on the very
first steps  in reachability  or very last steps  in relevance   finally  we note that the
k     algorithms are quite fast  unit propagation is an important heuristic in all sat
solution algorithms based on the david putnam algorithm  davis   putman         and
it is extremely fast  with negligible running times  i e          seconds   not surprisingly 
  

fireachability  relevance  and resolution

bw sm a
bw sm b
bw sm c
log sm a
log sm b
log sm c
hanoi  
hanoi  
hanoi  

j j
a

  
  
   
  
  
  
  
  
   

rch  rch  rel    rch  l  rch  l  rch  gp  rch  gp  rel    l g 
  
  
 
  
  
  
  
 
  
  
  
  
  
  
  
 
   
   
   
  
   
   
   
  
  
  
 
  
  
  
  
 
   
   
  
  
   
   
   
 
   
   
  
  
   
   
   
 
  
  
  
  
   
  
   
 
   
   
  
  
   
   
   
  
   
   
  
   
   
   
   
  

table    effects of unary and binary methods  jaj is the number of possible actions per step   the following columns hold the number of actions pruned during
the course of a minimal length  or longer  plan using reachable    reachable   
relevant   and    which yield the same value   unit propagation on the linear
encoding using initial state  binary propagation on the linear encoding using initial state  unit propagation on the graphplan encoding using initial state  and
binary propagation on the graphplan encoding using initial state  the final
column correspond to propagation using the goal state  all methods  i e   unit
and binary  on both encodings yielded the same values 
reachable   and relevant   are also extremely fast  execution times for these algorithms
were less than       seconds  except for bw c       sec    and bw d       sec    for which
these amount to a small fraction of the running times required by modern sat algorithms  
the next set of experiments  shown in table    introduces binary pruning methods
as well  here  we were limited by the slow performance of our prolog implementation of
reachable   and the medic encoder  ernst et al          we looked at blocks world problems involving      and   blocks  respectively  and we looked at logistics domain problems
involving one package and two cities  three packages and two cities  and three packages and
three cities  in addition  we looked at three hanoi tower problems with      and   disks 
there are a number of points worth mentioning 



in two domains  blocks  world and hanoi   reachable   is only slightly more useful
than reachable    in the logistics domain  on the other hand  reachable   is much
more effective  however  we must remember that reachable   yields mutual exclusion
constraints which we did not measure  these constraints can be quite useful and they
have an important role in the graphplan planner 



no clear winner emerges  in the blocks world domain  binary resolution in the linear
encoding prunes more than reachable    whereas in the logistics domain  reachable  prunes more  interestingly  binary resolution in the graphplan encoding is less

   these experiments were conducted on a pc with a pentiumii     processor 

  

fibrafman

time
reach  
reach  
u res lin 
b res lin 
u b res gp 

                    
                    
                   
                            
                   
                    

  
  
 
  
 
  

  
  
 
  
 
  

  
  
 
  
 
  

  
  
 
  
 
  

  
  
 
  
 
  

  
  
 
  
 
  

table    reachability analysis in a    bit counter  shown are the number of unpruned actions per time step  rows correspond to reachable    reachable    unit
resolution on the linear encoding  binary resolution on the linear encoding  the
last row corresponds to unit and binary resolution on the graphplan encoding 
which had identical effect 
effective than in the linear encoding  however  the graphplan encoding allows for
shorter plans  and consequently  smaller search spaces  therefore  the graphplanencoding is still likely to be more ecient 



relevant   has no advantage over relevant    in fact  this behavior was observed when
using resolution as well  unit and binary resolution on both the linear and graphplan
encodings pruned the same amount of actions  consequently  we present them in one
column  indeed  we see from both sets of experiments reported in tables   and   
that relevance analysis contributes little  one obvious reason is that the goal state is
often incomplete and much less constrained than the initial state  at least explicitly  
therefore  the algorithms have diculty deriving relevance constraints  however 
one s intuition seems to indicate that this should not be the case  at least not to
the extent observed  there should be means of providing better relevance analysis 
although they may require more sophisticated derivation of state constraints 



as predicted  relevance analysis is much more useful at the state space level than at
the truth assignment level 



as expected  the graphplan encoding is typically better than the linear encoding 

finally  we ran some tests on a    bit version of the counter domains described in
the text  this is a very constrained domain in which only a single action is applicable
at each state and we wanted to see how much of this would be discovered by the algorithms  the results are shown in tables   and    where the number of permisable actions
is given as a function of the the time step  table   presents the results for forward pruning
using reachable    reachable    and unit and binary propagation using the graphplan
and linear encodings  table   presents the results for backward pruning using relevant   
relevant    and unit and binary propagation using the linear encodings 

  

fireachability  relevance  and resolution

time
rel    u b res gp 
u res l 
b res l 

                                      
                                      
                                              
                               

table    relevance analysis in a    bit counter  shown are the number of unpruned
actions per time step  the  identical  results for reachable    reachable    unitresolution on the graphplan encoding  and binary resolution on the graphplan
encoding appear in the first row  the next rows correspond to unit and binary
resolution on the linear encoding  respectively 

   conclusion

we have shown a connection between the scheme used to encode planning instances and the
ability to propagate reachability and relevance information from the initial and final steps
to other time points  we hope that these results will serve to improve our understanding of
the factors contributing to the performance of different encoding methods  in addition  we
provided a crisp and general formulation of a class of reachability and relevance algorithms
that appear in various forms in different planning algorithms  we compared the pruning
ability of resolution based propagation methods which operate on encoded plans  to that of
the reachable k and relevant k algorithms which operate at the plan level  our empirical
results show a complex picture  where no clear winner emerges  however  it seems that
when the domain is constrained  making parallel actions less useful  binary methods have
little advantage over unary methods  in addition  they show that relevance analysis is best
conducted at the plan level  for sat based planning algorithms  this would suggest the use
of a simple plan level relevance analysis stage prior to the plan encoding  this observation
is confirmed by recent results reported by do  srivastava  and kambhampati        
in  brafman         we pointed out that binary clauses form a large fraction of the
clauses in sat encoded planning problems  given our results regarding the utility of binary
resolution  a natural idea is to augment standard clause simplification techniques  e g   unit
propagation  with some limited form of binary clause preprocessing  initial results presented
there indicated the utility of this idea  in instances where unit clauses could be derived from
this form of binary resolution  nice reductions in running time were demonstrated  when
unit clauses were not derivable via this method  only a small overhead was incurred  a
more principled  systematic  and ecient technique based on these ideas is investigated in
 brafman        
this work is among the first attempts to theoretically analyze different encoding schemes 
we have concentrated on one particular aspect of such encodings  i e   their ability to propagate concrete state information backwards and forwards  naturally  this attempt is a priori
limited in its scope  as this ability is only one factor inuencing the performance of various
algorithms  and its inuence is probably more significant in systematic methods based on
the david putnam procedure than in methods based on stochastic local search 
  

fibrafman

other authors have considered some of the ideas presented here  too  kautz and selman
       discuss the relation between graphplan s mutex constraint and a restricted form
of binary propagation  in particular they show that mutex computation is a limited form
of negative binary propagation  in mutex propagation  two assertions of mutual exclusion
yield a new one  of course  each mutual exclusion statement is equivalent to a binary
clause  e g   either action a is not performed or action b is not performed   hence we can
view this process as a limited form of binary propagation  from f p    qg and fp    rg
deduce f q    rg  graphplan performs this operation  but in an incomplete manner  in
addition  they tested additional limited inference methods such as the failed literal strategy
 attempting to prove that a particular literal is inconsistent using unit propagation  and the
binary failed literal strategy  attempting to prove that a binary clause is inconsistent using
unit propagation   these methods do not directly correspond to the methods considered
in this paper  more closely related is one of the options in the medic system for encoding
planning problems  a simple inference method which is referred to as simple data ow
analysis  ernst et al          this method is basically an instance of reachable   
haslum and geffner        present a parametrized class of admissible heuristics functions h   there is an interesting and important relation between the heuristic function
generation technique discussed in that paper and the parameterized class of reachability
analysis algorithms discussed in this paper  when a heuristic function assigns   to some
state s this means it believes that goal is not reachable from s  if the heuristic function is
admissible  then in fact  this is true  thus  admissible heuristic functions provide a sound
tool for pruning   the goal is not reachable from any state to which they assign the value
   in fact  the derivation of the heuristic functions of class h is closely related to our
computation of reachable k  in both cases  instead of analyzing actual states  we analyze
subsets of states of size k and their interactions  however  in designing heuristic functions 
a greater emphasis is put on the distance from the current state to a state in which some
set of literals appears without mutual exclusion constraints  i e   the indices of the sets s
and c s   
finally  a recent paper by do  srivastava  and khambhampati        examines encoded
planning problems generated by the blackbox planner  blackbox utilizes mutual exclusion constraints derived from graphplan s planning graph  the authors show that
these constraints are useful  despite the fact that they increase the size of the encoding 
in addition  the authors examine the utility of adding explicit mutual exclusion constraints
stemming from  state space based  relevance analysis  these constraints appear to improve
the planner s performance  in fact  it seems that the constraints described by do  srivastava  and kambhampati        are more powerful than those generated by relevant    we
believe that relevant k can and should be strengthened  and we hope to examine this issue
more closely in the future 
k

k

i

i

acknowledgments

i wish to thank craig boutilier and chris geib for valuable discussions on reachability analysis and the anonymous reviewers for very useful and detailed comments  i am particularly
grateful to olga rozenfeld who implemented the algorithms in prolog  suggested the use of
  

fireachability  relevance  and resolution

the counter example for illustrating the algorithms  and provided important corrections to
previous drafts  this work was supported in part by the paul ivanier center for robotics
research and production management 
appendix a  proofs

theorem   if a set of propositions or actions is excluded by reachable k at time j then

there is no feasible plan in which  at time j   these propositions hold  or  respectively  these
actions appear 

proof  this is immediate  consider any valid plan and the states of the world during the
execution of this plan  it is straightforward to show that both appear within the sets
and s without being constrained by virtue of this being a valid plan 

ai

i

lemma   in the context of the linear encoding  reachable    yields more reachability information than unit propagation 

proof  given the definitions used earlier on  a more formal statement of this lemma is as
follows  let k be some integer denoting the length of a plan  let a
  be the set of

actions pruned by reachable    up to the k th level given some planning domain and initial
state  let a
be the set of actions that are pruned by unit resolution on the linear
encoding of this planning domain using k steps  i e   actions for which we can deduce a unit
clause containing the negation of their corresponding variable   but without a goal state
supplied  then a
  and for some planning instances a
 
 a
 a
first let us consider unit resolution  the unit clauses that are available initially correspond to the propositions that hold at the initial state  the only axioms in which propositions denoting the state at time   appear are those of class    precondition axioms  and  
 frame axioms   however  the clauses in class   are ternary and contain at most one such
proposition  these ternary frame clauses can yield a unit clause only if we are able to rule
out all actions but one  which we cannot  at this stage  therefore  unit clauses can only
be derived by resolving the current unit clauses with class   clauses  such resolutions can
yield new unit clauses containing negated actions  these negated actions can be resolved
against clauses containing positive action variables  such variables appear only in class  
 at least one action  axioms 
now there are two cases to consider  first  suppose that we have been able to rule out
all actions but one  using the frame and effect axioms  we can derive the state at time   
our situation now is analogous to that in which we were at time   with knowledge of the
initial state  since reachable    puts us in the same position  our claim follows  using a
simple inductive argument   next  suppose that we cannot rule out all actions but one  in
that case  we have no new unit clauses  and so unit propagation stops  reachable    will be
able to rule out all actions ruled out by the unit propagation process  moreover  if all the
actions that are not ruled out have some common effect  that effect can be deduced using
reachable      and it can rule out actions that require its negation as a precondition  this
type of information is not obtained via unit propagation 
reach

u

res

reach

u

res

reach

  

u

res

fibrafman

lemma   in the context of the

graphplan encoding  unit propagation and reachable  
rule out the same sets of actions  if we ignore the explicit constraints appearing in axiom
class    if we use these constraints  unit propagation can yield more reachability information 

proof  first  suppose we ignore the mutex axioms of class    using unit propagation  we

deduce the negation of those actions whose preconditions are violated at time    negated
action literals can be resolved against class    effect explanation  axioms  if we have been
able to rule out all explanations of some time   proposition  we can deduce its negation
in this manner  the same mechanism will allow us to exclude this variable when using
reachable    similarly  negated action literals can be resolved against class    at least oneaction  axioms  but this yields no more information  those time   variables we can deduce
can be used to rule out time   actions 
notice the following  if we can deduce p at time    then one of the actions that produce p
must hold at time    this information is not explicit in the reachable   algorithm  although
it appear in the graphplan s planning graph in the form of edges   however  it cannot
be used to rule out other actions if we are restricted to unit resolution 
class   axioms can make a difference in the above case  suppose we have been able
to conclude that a particular action a that produces p must occur  i e   by deducing p and
ruling out all its causes except a   in that case  all actions that are mutually exclusive
with a cannot occur  these actions may not affect p at all  and their negation need not
necessarily be derivable using reachable   

theorem   let

s be some state from which the goal is reachable using an m step plan
 where each step can contain a number of non interfering actions   then     the set of
literals satisfied in s is a subset of s   no subset of which is in c s   and     there exists
an m step plan for reaching the goal from s such that if a is the set of actions in the plan
v steps before last then a  a and no subset of a is in c a  
m

m

v

v

proof  recall that we assume that any proposition appearing in the effects of an action

appears in its preconditions as well  we can always enforce this requirement by converting
an action that does not satisfy it into an a set of actions that satisfy it 
our proof proceeds by induction on the number of steps by which the goal is reachable 
let s be some state from which the goal g is reachable by a single step  let a be the set
of actions in such a one step plan for reaching g from s   by definition  a does not contain
interfering actions  in addition  we know that if g is reachable from s by performing a
then the preconditions of a and g n effects of  a  must hold in s  
first  suppose to the contrary that for some literal l   s   we have that l    s    notice
that by definition of a    we have that s  contains all literals that are consistent with
g  therefore  l must be inconsistent with g  i e    l   g  since l   s   there must be
some action a   a with the precondition l and the effect  l  otherwise  l would hold after
performing a   such an action would be in a  and its preconditions  l among them  would
be in s    we conclude that s  s   
next  we want to show that there is a one step plan for reaching g from s all of whose
actions are in a    from the discussion above we see that the plan a for reaching g from
r

  

fireachability  relevance  and resolution

contains an action from a  for changing the value of every proposition l that holds in
s and that is inconsistent with g  clearly  none of these actions can have an effect that
is inconsistent with g  let a   a denote the set of such actions  by applying a  at s
we transform all literals inconsistent with g to their value in g and we do not destroy the
value of any literal consistent with g  since a   a  it constitutes a valid plan  i e   its
actions do not interfere with each other  that achieves g  by definition  a   a   
to conclude the proof of the base step  we must show that no subset of s is in c s   
suppose  to the contrary that some subset s   of s is in c s    we have seen that for any
such s     there is some set of actions a   a such that a   a  and each l   s   is either
a precondition of some action in a  or l is consistent with g and is not destroyed by a   
denote by a   the set consisting of a  and any noop   corresponding to those l   s   that
are not preconditions of an element in a    by definition of a    we have that a     a   
however  if s     c s  then a     c a  which implies that a   contains interfering actions 
we claim that this is impossible  first  all the effects of a   are either in g or consistent
with g  by construction  in addition  all the preconditions of a   are in s   and therefore in
s   because s is an actual state of the world  it cannot contain conicting literals  hence 
 
s    c s   
next  suppose that we have established our inductive hypothesis for all i   m and let
us prove that it holds for i   m  hence  let s be some state for which there exists an mstep plan a   a            a for attaining g  let s    denote the state obtained by applying
a  to s   we know that there is an m
  step plan for achieving g from s      by our
  
inductive hypothesis  s satisfies the conditions of the theorem  in particular  we know
that s     s   and no subset of s    is in c s     to complete our proof it would be
sucient to show that s    is reachable by a one step plan a  whose actions are in a but
not in c a   the proof is similar to the base case 
r

s

m

m

m

m

m

corollary   for any initial state s from which the goal is reachable and any minimal  in
the number of operators  plan p   a          a    where the steps are numbered backwards  for
reaching the goal from s  we have a   a and c a does not contain any subset of a   
m

i

i

i

i

proof  an inspection of the proof of the previous theorem shows that in every step we

have found some subset of the set of actions in each candidate plan that satisfied the
relevant conditions  in particular  consider a minimal plan  all its elements must satisfy
these conditions 

lemma   in the context of the linear encoding  unless there is a single safe  final action 
unit propagation yields less relevance information than relevant   

initially  our only unit clauses are goal literals  we can resolve then against the effect
axioms only  this would yield negation of various actions  i e   unsafe actions   these
negated action literals can be resolved only against the action disjunction  axiom class    
however  if there is more than one safe final action  we will not obtain a unit clause from
this disjunction  and there is nothing farther that we can do  the same information  and
more  is easily obtainable from relevant   
  

fibrafman

lemma   in the context of the

graphplan encoding  if there is an action for changing the value of every literal  then unit propagation yields less relevance information than
relevant   

proof  see text prior to this lemma 
appendix b  the complexity of reachable k and relevant k

the computational complexity of reachable k is o njajjlj e   njljjaj    where n is the
number of levels we generate  jaj is the number of possible actions  jlj is the size of the
propositional language used  and e is the maximal number of actions that have a particular
shared effect  as we explain below  the complexity is dominated by the time required to
produce the sets c s and c a  
the set of possible effects  s   is produced in o jaj m   steps  where m is the maximal
number of effects 
c s requires examining all l  tuples of elements in s   for l  k   and there are at most
o  jlj   such elements  for each such tuple we have to find the set of actions that produce
it  this can be done quickly  provided we maintained pointers to these actions  the number
of such sets of actions is o e    since no more than k actions are needed   for each such
set of actions we must check whether some subset of it is a member of c a     given an
appropriate representation of c a     this can be done in time o jaj   to accomplish this 
we can use a binary tree whose leafs correspond to bit vectors  the depth of this tree is
jaj and its size is o jc a  j   finally  we need to maintain c s as a similar tree of bitvectors  this can be done in o jlj    or  if c s is small  at a lower cost   the overall cost
of producing c s is o jlj je j jaj  
to produce the set a   we go over all actions and check whether their preconditions
appear in s   this requires o jaj  m   steps  assuming a bit vector representation of s   
where m is the maximal number of preconditions of an action  we also have to check
whether the preconditions appear in c s   since ja j  jaj and we can check whether a
subset of the set of preconditions appears in c s in time o jlj   this requires o jajjlj 
steps 
finally  we need to produce the c a   this requires generating all subsets of a of size
k or less  taking o  jaj   steps  for each such subset we must check whether its preconditions contain an element of c s   again  provided an appropriate data structure for c s
is maintained  this can be done in o jlj  for each set of preconditions  as in the case of
c s   we assumed c a is maintained as a tree of bit vectors  which can be generated in time
o  jaj    the overall complexity of this step is o  jljjaj   
note that for small values of k other data structures are likely to provide better performance 
next  we address relevant k  our analysis is under the assumption that the same
set of variables appear in the preconditions and effects of each operator  as we noted 
transforming a set of operators that do not satisfy this property into a set of operators that
satisfy it may cause an exponential blow up in the worst case 
the complexity of relevant k is o jaj jlj   jlj m jaj   where jaj is the number of
actions  jlj is the number of proposition in the language  and m is the maximal number of
k

i

k

k

i

i

e

i

e

i

k

k

i

i

i

i

k

k

i

i

k

i

i

p

i

p

i

i

i

i

i

k

i

i

i

k

k

k

k

k

k
p

p

  

fireachability  relevance  and resolution

preconditions of an action  the analysis is quite similar to the case of reachable k  and we
ignore the sets r and a which are subsets of the larger s and a and whose generation
contributes constant factors 
the set of preconditions  s   is produced in o jaj  m   steps 
to compute c s   we iterate over o jlj   sets of literals  for each such set we examine
all sets of actions that have it as preconditions  and there are at most o m   such sets  for
each such set of actions  we need to check that it is not in c a     each such check can be
performed in o jaj  steps  the overall complexity of this step is o jlj m jaj  
to produce the set a   we go over all actions useful for s   which require o jlje    where
as before  e is the maximal number of actions that have a particular effect   for each action 
we check whether its effects are in c s   since we need to perform this check at most once
for every action  the overall complexity of o jlje   jljjaj  
finally  we need to produce the sets c a   interfering actions can be pre computed with
the cost amortized over all steps  in any case  their computation requires no more than
 
o  mjaj   steps  where m is the maximal sum of preconditions and effects for an action 
next  we have to examine the effects of all l tuples of actions  where l  k  and see whether
these effects have a subset in c s   this takes o jaj jlj  steps 
again  for small values of k  and in particular  k         a tighter analysis is possible 
r
i

i

i

i

i

p

k

i

k
p

i

k

i

k
p

i

i

i

k

i

references

bayardo  r  j     schrag  r  c          using csp look back techniques to solve real world
sat instances  in proc  aaai     pp          
blum  a     furst  m  l          fast planning through planning graph analysis  artificial
intelligence              
bonet  b   loerincs  g     geffner  h          a robust and fast action selection mechanism
for planning  in proc  aaai     pp          
boutilier  c   brafman  r  i     geib  c          structured reachability analysis for markov
decision processes  in proc  of   th conference on uncertainty in ai  pp        
boutilier  c     dearden  r          using abstractions for decision theoretic planning with
time constraints  in proc  of aaai     pp            
brafman  r  i          reachability  relevance  resolution  and the planning as satisfiability
approach  in ijcai     pp          
brafman  r  i     hoos  h  h          to encode or not to encode   i  linear planning  in
ijcai     pp          
brafman  r  i          a simplifier for propositional formulas with many binary clauses 
tech  rep         dept  of computer science  ben gurion university 
crawford  j     auton  l  d          experimental results on the cross over point in
satisfiability problems  in proc  aaai     pp        
  

fibrafman

davis  m     putman  h          a computing procedure for quantification theory  journal
of the acm             
do  m  b   srivastava  b     kambhampati  s          investigating the effect of relevance
and reachability constraints on sat encodings of planning  in proc  of the fifth intl 
conf  on ai planning and scheduling systems 
ernst  m  d   millstein  t  d     weld  d  s          automatic sat compilation of
planning problems  in proceedings of the international joint conference on artificial
intelligence 
fikes  r     nilsson  n          strips  a new approach to the application of theorem
proving to problem solving  artificial intelligence                   
freeman  j  w          improvements to propositional satisfiability search algorithms 
ph d  thesis  u  pennsylvania dept  of computer and information science 
genesereth  m  r     nilsson  n  j          logical foundations of artificial intelligence 
kaufmann  los altos  ca 
gomes  c  p   selman  b     kautz  h          boosting combinatorial search through
randomization  in proc  of   th nat  conf  ai  pp          
haslum  p     geffner  h          admissible heuristics for optimal planning  in proc  of
the fifth intl  conf  on ai planning and scheduling systems  pp          
kambhampati  s   parker  e     lambrecht  e          understanding and exending graphplan  in proc   th european conf  on planning  pp          
kautz  h     selman  b          planning as satisfiability  in proc  of the   th european
conf  on ai  pp          
kautz  h     selman  b          pushing the envelope  planning  propositional logic  and
stochastic search  in proc  of the   th national conference on ai  aaai      pp 
          
kautz  h     selman  b          unifying sat based and graph based planning  in proc 
  th intl  joint conf  on ai  ijcai      pp          
li  c  m     anbulagan         heuristics based on unit propagation for satisfiability
problems  in proc  ijcai    
mcdermoot  d          a heuristic estimator for means ends analysis in planning  in proc 
 rd int  conf on ai planning systems  pp          
nebel  b   dimopoulos  y     koehler  j          ignoring irrelevant facts and operators in
plan generation  in proc   th european conf  on planning 

  

fi