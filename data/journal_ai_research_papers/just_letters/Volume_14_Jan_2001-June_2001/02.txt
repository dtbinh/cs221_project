journal of artificial intelligence research                

submitted       published     

conict directed backjumping revisited
xinguang chen

xinguang cs ualberta ca

peter van beek

vanbeek uwaterloo ca

department of computing science  university of alberta
edmonton  alberta  canada t g  h 
department of computer science  university of waterloo
waterloo  ontario  canada n l  g 

abstract

in recent years  many improvements to backtracking algorithms for solving constraint
satisfaction problems have been proposed  the techniques for improving backtracking algorithms can be conveniently classified as look ahead schemes and look back schemes  unfortunately  look ahead and look back schemes are not entirely orthogonal as it has been
observed empirically that the enhancement of look ahead techniques is sometimes counterproductive to the effects of look back techniques  in this paper  we focus on the relationship
between the two most important look ahead techniques using a variable ordering heuristic and maintaining a level of local consistency during the backtracking search and the
look back technique of conict directed backjumping  cbj   we show that there exists a
 perfect  dynamic variable ordering such that cbj becomes redundant  we also show
theoretically that as the level of local consistency that is maintained in the backtracking
search is increased  the less that backjumping will be an improvement  our theoretical
results partially explain why a backtracking algorithm doing more in the look ahead phase
cannot benefit more from the backjumping look back scheme  finally  we show empirically
that adding cbj to a backtracking algorithm that maintains generalized arc consistency
 gac   an algorithm that we refer to as gac cbj  can still provide orders of magnitude
speedups  our empirical results contrast with bessiere and regin s conclusion        that
cbj is useless to an algorithm that maintains arc consistency 

   introduction

constraint satisfaction problems  csps  are a generic problem solving framework  a constraint satisfaction problem consists of a set of variables  each associated with a domain of
values  and a set of constraints  each of the constraints is expressed as a relation  defined
on some subset of the variables  denoting the consistent value assignments that satisfy the
constraint  a solution to a csp is an assignment of a value to every variable  in such a way
that every constraint is satisfied 
constraint satisfaction problems are usually solved by search methods  among which
the backtracking algorithm and its improvements are widely used  the techniques for
improving backtracking algorithms can be conveniently classified as look ahead schemes
and look back schemes  dechter         look ahead schemes are invoked whenever the
algorithm is preparing to extend the current partial solution  look ahead schemes include
the functions that choose the next variable to be instantiated  choose the next value to
give to the current variable  and reduce the search space by maintaining a certain level of
local consistency during the search  e g   bacchus   van run        bessiere   regin       
c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fichen   van beek

haralick   elliott        mcgregor        nadel        sabin   freuder         lookback schemes are invoked whenever the algorithm encounters a dead end and prepares for
the backtracking step  look back schemes include the functions that decide how far to
backtrack by analyzing the reasons for the dead end  backjumping  and decide what new
constraints to record so that the same conicts do not arise again later in the search  e g  
bruynooghe        dechter        frost   dechter        gaschnig        prosser      b 
schiex   verfaillie        
a backtracking algorithm can be a hybrid of both look ahead and look back schemes
 prosser      b   in this paper  we focus on the relationship between the two most important look ahead techniques using a variable ordering heuristic and maintaining a level of
local consistency during the backtracking search and the look back technique of conictdirected backjumping  cbj   prosser      b   unfortunately  these look ahead and lookback schemes are not entirely orthogonal as it can be observed in previous experimental
work that as the level of consistency that is maintained in the backtracking search is increased and as the variable ordering heuristic is improved  the effects of cbj are diminished
 bacchus   van run        bessiere   regin        prosser      a      b   for example  it
can be observed in prosser s      b  experiments that  given a static variable ordering  increasing the level of local consistency maintained from none to the level of forward checking 
diminishes the effects of cbj  bacchus and van run        observe from their experiments
that adding a dynamic variable ordering  an improvement over a static variable ordering 
to a forward checking algorithm diminishes the effects of cbj  in their experiments the
effects are so diminished as to be almost negligible and they present an argument for why
this might hold in general  bessiere and regin        observe from their experiments that
simultaneously increasing the level of local consistency even further to arc consistency and
further improving the dynamic variable ordering heuristic diminishes the effects of cbj
so much that  in their implementation  the overhead of maintaining the data structures for
backjumping actually slows down the algorithm  they conjecture that when arc consistency
is maintained and a good variable ordering heuristic is used   cbj becomes useless  
in this paper  we present theoretical results that deepen our understanding of the relationship between look ahead techniques and the cbj look back technique  we show that
there exists a  perfect  dynamic variable ordering for the chronological backtracking algorithm such that cbj becomes redundant  the more that a variable ordering heuristic is
consistent with the  perfect  heuristic  the less chance cbj has to reduce the search effort 
we also show that cbj and an algorithm that maintains strong k consistency in the backtracking search are incomparable in that each can be exponentially better than the other 
this result is refined by introducing the concept of backjump level in the execution of a
backjumping algorithm and showing that an algorithm that maintains strong k consistency
never visits more nodes than a backjumping algorithm that is allowed to backjump at most
k levels  thus  as the level of local consistency that is maintained in the backtracking search
is increased  the less that backjumping will be an improvement  together  our theoretical
results partially explain why a backtracking algorithm doing more in the look ahead phase
cannot benefit more from the backjumping look back scheme  our results also extend the
partial ordering of backtracking algorithms presented by kondrak and van beek        to
include backtracking algorithms and their cbj hybrids that maintain levels of local con  

ficonflict directed backjumping revisited

sistency beyond forward checking  including the important algorithms that maintain arc
consistency 
we also present empirical results that show that  although the effects of cbj may
be diminished  adding cbj to a backtracking algorithm that maintains generalized arc
consistency  gac   an algorithm that we refer to as gac cbj  can still provide orders
of magnitude speedups  our empirical results contrast with bessiere and regin s       
conclusion that cbj is useless to an algorithm that maintains arc consistency 

   background

in this section  we formally define constraint satisfaction problems  and briey review local
consistency and the search tree explored by a backtracking algorithm 

    constraint satisfaction problems
definition    csp  an instance of a constraint satisfaction problem is a tuple p  
 v   d  c    where 
 v   fx          xng is a finite set of n variables 
 d   fdom x           dom xn g is a set of domains  each variable x   v is associated with a finite domain of possible values  dom x   the maximum domain size
maxx v jdom x j is denoted by d 

 c   fc          cmg is a finite set of m constraints or relations  each constraint c   c
is a pair  vars c    rel c     where

  vars c     fxi           xiri g is an ordered subset of the variables  called the con 

straint scope or scheme  the size of vars c   is known as the arity of the constraint  if the arity of the constraint is equal to    it is called a binary constraint 
a non binary constraint is a constraint with arity greater than    the maximum
arity of the constraints in c   maxc  c jvars c  j  is denoted by r 
  rel c   is a subset of the cartesian product dom xi     dom xiri   that specifies
the allowed combinations of values for the variables in vars c    an element of
the cartesian product dom xi         dom xiri   is called a tuple on vars c   
thus  rel c   is often regarded as a set of tuples over vars c   

in the following  we assume that for any variable x   v   there is at least one constraint
c   c such that x   vars c    by definition  a tuple over a set of variables x   fx          xkg
is an ordered list of values  a           ak   such that ai   dom xi    i             k  a tuple over x
can also be regarded as a set of variable value pairs fx  a           xk ak g  furthermore 
a tuple over x can be viewed as a function t   x    x x dom x  such that for each variable
x   x   t x    dom x   for a subset of variables x    x   we use t x    to denote a tuple over
x   by restricting t over x    we also use vars t  to denote the set of variables for tuple t 
   throughout the paper  we use n  d  m  and r to denote the number of variables  the maximum domain
size  the number of constraints  and the maximum arity of the constraints in the csp  respectively 

  

fichen   van beek

an assignment to a set of variables x is a tuple over x   we say an assignment t to x
is consistent with a constraint c if either vars c     x or t vars c      rel c    a partial
solution to a csp is an assignment to a subset of variables  we say a partial solution is
consistent if it is consistent with each of the constraints  a solution to a csp is a consistent
partial solution over all the variables  if no solution exists  the csp is said to be insoluble 
a csp is empty if either one of its variables has an empty domain or one of its constraints
has an empty set of tuples  obviously  an empty csp is insoluble  given two csp instances
p  and p    we say p    p  if they have exactly the same set of variables  the same set of
domains and the same set of constraints  i e   they are syntactically the same 

definition    projection  given a constraint c and a subset of variables s  vars c   
the projection s c is a constraint  where vars s c     s and rel s c     ft s   j t  
rel c  g 
definition    selection  given a constraint c and an assignment t to a subset of variables x  vars c    the selection tc is a constraint  where vars t c     vars c   and
rel tc     fs j s x     t and s   rel c  g 
    local consistency

an inconsistency is a consistent partial solution over some of the variables that cannot be
extended to additional variables and so cannot be part of any global solution  if we are
using a backtracking search to find a solution  such an inconsistency can lead to a dead end
in the search  this insight has led to the definition of properties that characterize the level
of consistency of a csp and to the development of algorithms for achieving these levels
of consistency by removing inconsistencies  e g   mackworth      a  montanari         and
to effective backtracking algorithms for finding solutions to csps that maintain a level of
consistency during the search  e g   gaschnig        haralick   elliott        mcgregor 
      sabin   freuder        
mackworth      a  defines three properties of binary csps that characterize local consistencies  node  arc  and path consistency  mackworth      b  generalizes arc consistency
to non binary csps 

definition    arc consistency  given a constraint c and a variable x   vars c    a
value a   dom x  is supported in c if there is a tuple t   rel c    such that t x    a  t
is then called a support for fx ag in c   c is arc consistent if for each of the variables
x   vars c    and each of the values a   dom x   fx ag is supported in c   a csp is arc

consistent if each of its constraints is arc consistent 
freuder        generalizes node  arc  and path consistency  to k consistency 

definition    k consistency  a csp is k consistent if and only if given any consistent
partial solution over k     distinct variables  there exists an instantiation of any kth variable
such that the partial solution plus that instantiation is consistent  a csp is strongly kconsistent if it is j  consistent for all    j  k 
  

ficonflict directed backjumping revisited

for binary csps  node  arc and path consistency correspond to one   two  and threeconsistency  respectively  however  the definition of k consistency does not require the csp
to be binary and arc consistency is not the same as two consistency for non binary csps 
a strongly n consistent csp has the property that any consistent partial solution can be
successively extended to a full solution of the csp without backtracking 

    search tree and backtracking algorithms

the idea of a backtracking algorithm is to extend partial solutions  at each stage  an uninstantiated variable is selected and assigned a value from its domain to extend the current
partial solution    constraints are used to check whether such an extension may lead to a
possible solution of the csp and to prune subtrees containing no solutions based on the
current partial solution  during a backtracking search  the variables can be divided into
three sets  past variables  already instantiated   current variable  now being instantiated  
and future variables  not yet instantiated   a dead end occurs when all values of the current variable are rejected as not leading to a full solution  in such a case  some instantiated
variables become uninstantiated   i e   they are removed from the current partial solution 
this process is called backtracking  if only the most recently instantiated variable becomes
uninstantiated then it is called chronological backtracking   otherwise  it is called backjumping  a backtracking algorithm terminates when all possible assignments have been tested
or a certain number of solutions have been found 
a backtracking search may be seen as a search tree traversal  in this approach we
identify tuples  assignments of values to variables  with nodes  the empty tuple is the root
of the tree  the first level nodes are   tuples  representing an assignment of a value to a
single variable   the second level nodes are   tuples  and so on  the levels closer to the
root are called shallower levels and the levels farther from the root are called deeper levels 
similarly  the variables corresponding to these levels are called shallower and deeper  we
say that a backtracking algorithm visits a node in the search tree if at some stage of the
algorithm s execution the current partial solution identifies the node  the nodes visited
by a backtracking algorithm form a subset of all the nodes belonging to the search tree 
we call this subset  together with the connecting edges  the backtrack tree generated by a
backtracking algorithm 
the backtracking algorithm conict directed backjumping  cbj   prosser      b  maintains a conict set for every variable  every time an instantiation of the current variable
xi is in conict with an instantiation of some past variable xh   the variable xh is added to
the conict set of xi   when there are no more values to be tried for the current variable xi  
cbj backtracks to the deepest variable xh in the conict set of xi   at the same time  the
variables in the conict set of xi   with the exception of xh   are added to the conict set of
xh   so that no information about conicts is lost 
throughout the paper we refer to the following backtracking algorithms  see kondrak
  van beek        prosser      b for detailed explanations and examples of most of these
algorithms   chronological backtracking  bt   backjumping  bj   gaschnig         conictdirected backjumping  cbj   prosser      b   forward checking  fc   haralick   elliott 
      mcgregor         forward checking and conict directed backjumping  fc cbj 
   throughout this paper  we assume that a static value ordering is used in the backtracking search 

  

fichen   van beek

 prosser      b   maintaining arc consistency  mac   gaschnig        sabin   freuder 
       and maintaining arc consistency and conicted directed backjumping  mac cbj 
 prosser        

   variable ordering heuristics and backjumping

in this section  we present theoretical results that deepen our understanding of the relationship between the look ahead technique of using a variable ordering heuristic and the
look back technique of cbj 
in previous work  kondrak and van beek        show that  given the same deterministic
static or dynamic variable ordering heuristic  cbj never visits more nodes than bt  bacchus
and van run        show that bj  a restricted version of cbj  visits exactly the same nodes
as bt if the fail first dynamic variable ordering heuristic is used  previous empirical work
shows that the number of nodes that cbj saves depends on the variable ordering heuristic
used  bacchus   van run        bessiere   regin        prosser      b  
we show that  given a csp and a variable ordering for cbj  there exists a  perfect 
variable ordering for the chronological backtracking algorithm  bt  such that bt never
visits more nodes than cbj  the more that a variable ordering heuristic is consistent with
the  perfect  heuristic  the less chance cbj has to reduce the search effort 
we first consider the case of insoluble csps  when cbj is applied to an insoluble csp 
it always backjumps from a dead end state  i e   it does not terminate or backjump from a
situation in which a solution of the csp was found 

lemma   given an insoluble csp and a variable ordering for cbj  there exists a variable

ordering for bt such that bt never visits more nodes than cbj to show that no solution
exists 

proof in the backtrack tree generated by cbj under the variable ordering  let the last

backjump that terminates the execution of cbj be from variable xj to the root of the
backtrack tree  we choose xj to be the first variable for bt  for each value a in the domain
of xj   if the current node in the backtrack tree for cbj is consistent  not a leaf node   the
next variable chosen to be instantiated after assigning a to xj is the variable that backjumps
to xj and causes the assignment xj a to be revoked  the entire variable ordering for
bt can be worked out in a similar  recursive manner  for this variable ordering for bt to
be well defined  it remains to show that if the current node in the backtrack tree for cbj
is inconsistent  a leaf node   the corresponding node in the backtrack tree for bt is also
inconsistent  and therefore no next variable needs to be chosen   we show that the variables
skipped in the variable ordering constructed for bt are irrelevant to the dead end states
encountered by cbj  suppose at a stage we have ordered the variables to be instantiated
for bt as xj           xjk   and for value a   dom xjk   we choose the next variable xjk   as
the variable which backjumps to the current variable xjk in the cbj backtrack tree  we
prove by induction that the conict set of xjk   used in the backjumping is subsumed by
fxj           xjk g  k     is the case of the last backjump that terminates the execution of cbj 
the hypothesis is true because the conict set of xj  is an empty set  suppose it is true for
the case of k      because xjk   backjumps to xjk   the conict set of xjk   is merged in the
conict set of xjk   from the inductive assumption  the conict set of xjk is subsumed by
  

ficonflict directed backjumping revisited

fxj           xjk   g  and thus the conict set of xjk   is subsumed by fxj           xjk g  therefore 
the hypothesis holds for the case of k      if cbj finds out that instantiation xjk a is
inconsistent with the assignments of some past variables which are added to the conict
set of xjk   bt is also able to find out the inconsistency because the conict set of xjk is
subsumed by fxj           xjk   g  thus  the variable ordering for bt is well defined 
for soluble csps  we further distinguish the problem between finding one solution and
finding all solutions 

lemma   given a csp and a variable ordering for cbj to find the first solution  there

exists a variable ordering for bt such that bt never visits more nodes than cbj to find
the first solution 

proof without loss of generality  let fx  a          xn an g be the first solution found  a

variable ordering for bt can be constructed in the following way  the first variable chosen
for bt is x  as it is the first variable in the path from the root to the solution in the cbj
backtrack tree  because we assume a static value ordering in the backtracking search  all
values in the domain of x  that precede value a  must be rejected by cbj and bt before
value a  is used to instantiate x    furthermore  because fx  a           xn an g is the
first solution encountered by cbj under the above variable ordering and value ordering 
the instantiation of x  with a value preceding a  leads to an insoluble subproblem and
eventually cbj backjumps from a deeper variable to x  to revoke that assignment  note
that x  cannot be skipped by a backjump from a deeper variable because x  is on the first
level of the search tree and there is a solution for the csp  assigning x  with each of the
values that precede a  in its domain leads to insoluble subproblems and the instantiation
order for bt can be arranged as in lemma    whenever xk is instantiated with value ak  
xk   is chosen to be the next variable  as it follows xk in the path from the root to the
solution in the cbj backtrack tree  again  all values in the domain of xk   that precede
ak   in the value ordering must be rejected by cbj and bt before ak   is assigned to
xk    the instantiation of xk   with each of these values leads to an insoluble subproblem
and eventually cbj backjumps from a deeper variable to xk     similarly  xk   cannot
be skipped by a backjump from a deeper variable because otherwise at least one of the
assignments to x           xk must be changed so that fx  a           xn an g is not the
first solution encountered by cbj  in each of these insoluble subproblems  the instantiation
order for bt can be arranged as in lemma    finally  xn is instantiated with an and bt
finds the solution 
when cbj is used to find all solutions  special steps must be taken to handle the conict sets  the problem here is that the conict sets of cbj are meant to indicate which
instantiations are responsible for some previously discovered inconsistency  however  after
a solution is found  conict sets cannot always be interpreted in this way  it is the search
for other solutions  rather than an inconsistency  that causes the algorithm to backtrack 
we need to differentiate between two causes of cbj backtracks      detecting an inconsistency  and     searching for other solutions  in the latter case  the backtrack must be
always chronological  that is  to the immediately preceding variable  a simple solution is to
remember the number of solutions found so far when a variable is chosen to be instantiated 
  

fichen   van beek

and later when a dead end state is encountered at this level  we compare the recorded number with the current number of solutions  a difference indicates that some solutions have
been found in this interval of search  and forces the algorithm to backtrack chronologically 
otherwise the algorithm performs a normal backjumping by analyzing the conict set of
the current variable 

lemma   given a csp and a variable ordering for cbj to find all solutions  there exists
a variable ordering for bt such that bt never visits more nodes than cbj to find all
solutions 
proof let the first solution found by cbj be fx 

a          xn an g in the order of
x           xn  we first construct the variable ordering for bt as it is applied to find the first

solution  however  because bt follows a strict chronological backtracking  it will inevitably
visit all the nodes fx  a           xj    aj      xj a j g  where    j  n and a j comes
after aj in the domain of xj   if cbj skips any of these nodes  for example  from a deeper
level variable xh to xj      while the instantiations of x           xj have not been changed  bt
will possibly visit more nodes than cbj  we will show this cannot happen by induction
on the distance between the current level j and the deepest level n  after cbj has found
the solution at level n  it will try other values for xn and eventually backtrack to xn     so
the nodes at level n cannot be skipped  suppose it is true for the case of level j     and
now we consider the case of level j   because xj aj was not skipped in the backjumping 
if aj is the last value in its domain  cbj will backtrack to xj    because the number of
solutions has been changed  so it is true for the case of j   otherwise cbj will change
the instantiation of xj to the next value in its domain  let the current partial solution be
t   fx  a          xj   aj    xj a j g  if the subtree rooted by t contains solutions 
from the inductive hypothesis  cbj will not skip this node because it is on level j   if
the subtree rooted by t contains no solution  there exists a backjump from a deeper level
variable xh to escape this subtree  could it jump beyond xj such that t is skipped  in that
case  the conict set of xh is subsumed in fx           xj    g  from the definition of conict
set  we know that the current instantiations of the variables in the conict set cannot lead
to a solution  however the current instantiations of fx           xj    g do lead to a solution 
fx  a          xn ang  that is a contradiction  so the conict set of xh must contain
xj and thus the node t at level j cannot be skipped  after all the values in the domain
of xj have been tried  cbj will chronologically backtrack to xj    because the number of
solutions has changed  thus  xj    aj    will not be skipped  the hypothesis is true for
the case of any level j   then we construct the variable ordering for bt in the following way 
if the current partial solution t   fx  a           xj    aj      xj a j g cannot be extended
to a solution  we construct a variable ordering for the insoluble subproblem  if t can be
extended to a solution  we construct a variable ordering for bt as the case of finding the
first solution in this subproblem  and recursively apply the above steps until a backjump
to level xj changes the instantiation xj a j   under the above variable ordering  bt will
never visit more nodes than cbj 

theorem   given a csp and a variable ordering for cbj  there exists a variable ordering

for bt such that bt never visits more nodes than cbj in solving the csp 
  

ficonflict directed backjumping revisited

x    x   x 
x    x    x     
x    x   x 
x          x    f       g

x 

 

cbj backtrack tree

x 

 

x 

x 

x 
 

x 

x 

x 

x 

x 

x 
 

x 

x 

x 

x 

x 

x 
 

p

p p
x 

x 

 

p p p

bt backtrack tree
 

x 

x 

x 
 

x 

x 

x 

x 

x 

x 
 

x 

x 

x 
 

p

p p

p p p

figure    an illustration of the variable ordering constructed for bt from a cbj backtrack
tree  for the csp shown upper left  

proof follows from lemmas       and   
example   figure   shows the bt backtrack tree based on the variable ordering constructed
from the execution of cbj to solve a csp under a  hypothetical  dynamic variable ordering 
the first solution found by cbj is fx     x     x     x     x   g  thus  bt
first instantiates x  and x  to    the node fx     x     x   g and fx     x 
   x   g in the cbj backtrack tree lead to insoluble subproblems  the variable ordering
for bt at each of these nodes is constructed as in the case of insoluble csps  for example 
in the cbj backtrack tree  the last backjump to revoke the node fx     x     x   g
  

fichen   van beek

is from x  to x    so the next variable instantiated in bt at this node is x    under such an
ordering  bt avoids instantiating x  and visits fewer nodes than cbj  then bt instantiates
x  to    x  to    and x  to    and finds the first solution 
we have shown that there exists a  perfect  variable ordering such that cbj becomes
redundant  of course  the  perfect  ordering would not be known a priori  and in practice 
the primary goal in designing variable ordering heuristics is not to simulate the execution of
cbj  but to reduce the size of the overall backtrack tree  as an example  the popular failfirst heuristic selects as the next variable to be instantiated the variable with the minimal
remaining domain size  the size of the domain after removing values that are in conict
with past instantiations  as this can be shown to minimize the size of the overall tree under
certain assumptions  a secondary effect  however  is that variables that have conicts with
past instantiations are likely to be instantiated sooner  thus approximating the  perfect 
ordering and diminishing the effects of backjumping 

   maintaining consistency and backjumping

in this section  we present theoretical results that deepen our understanding of the relationship between the look ahead technique of maintaining a level of local consistency during
the backtracking search and the look back technique of cbj 
in previous work  kondrak and van beek        show that  given the same deterministic
static or dynamic variable ordering heuristic  cbj never visits more nodes than bt and
fc cbj never visits more nodes than fc  prosser      a  shows that the removal of an
inconsistent value from the domain of a variable can diminish the effects of cbj and that
cbj can visit fewer nodes than an algorithm that combines cbj with the discovery and
removal of some inconsistent values  previous empirical work shows that the number of
nodes that cbj saves depends on the level of local consistency maintained  bacchus   van
run        bessiere   regin        prosser      b  
we extend the partial ordering of backtracking algorithms presented by kondrak and
van beek        to include backtracking algorithms and their cbj hybrids that maintain
levels of local consistency beyond forward checking  including the important algorithms that
maintain arc consistency  we show that cbj and an algorithm that maintains strong kconsistency in the backtracking search are incomparable in that each can be exponentially
better than the other  this result is refined by using the concept of backjump level in
the execution of a backjumping algorithm and showing that an algorithm that maintains
strong k consistency never visits more nodes than a backjumping algorithm that is allowed
to backjump at most k levels  thus  as the level of local consistency that is maintained in
the backtracking search is increased  the less that backjumping will be an improvement 
in section      we consider the backjumping algorithms and define the series of algorithms bjk   in section      we consider the look ahead algorithms that maintain a level of
local consistency and define the series of algorithms mck   finally  in section      we consider the relationships between the backjumping and the look ahead algorithms and their
hybrids  the reader who is not interested in the technical proofs of the results should jump
directly to this section 
  

ficonflict directed backjumping revisited

x 

x    x   x 
x    x    x     
x    x   x 
x            x    f       g

 

x 

 

x 

d  
x 

x 

 

x 
d  

x 

 

d  
d  

 
 

p p

figure    an illustration of backjump levels in a cbj backtrack tree  for the csp shown
upper right  

    backjump level and bjk

to analyze the inuence of the level of consistency on the backjumping  we need the notion of
backjump level  informally  the level of a backjump is the distance  measured in backjumps 
from the backjump destination to the  farthest  dead end 

definition    backjump level  kondrak   van beek        the definition of back 

jump level is recursive 
   a backjump from variable xi to variable xh is of level   if it is performed directly from a
dead end state in which every value of xi fails a consistency check 
   a backjump from variable xi to variable xh is of level d     if all backjumps performed
to variable xi are of level less than d  and at least one of them is of level d     

example   figure   shows the backjump levels in an example cbj backtrack tree  there is

a one level backjump from x  to x  because every value in the domain of x  fails a consistency
check  then cbj finds two solutions for the problem and thus it chronologically backtracks
from x  to x    and later to x   the backjumps are of level one and two respectively  at last
there is a three level backjump from x  to x   
by classifying the backjumps performed by a backjumping algorithm into different levels 
we can now weaken cbj into a series of backjumping algorithms which perform limited
levels of backjumps  bjk is a backjumping algorithm which is allowed to perform at most
k level backjumps and it chronologically backtracks when a j  level backjump for j   k is
encountered    bjn is equivalent to cbj  which performs unlimited backjumps  and bj  is
   bjk is only of theoretical interest since in practice one would use cbj rather than artificially prevent
backjumping  i e   one has to actually add code to prevent backjumping 

  

fichen   van beek

equivalent to gaschnig s        bj  which only does the first level backjumps or backjumps
from dead ends 
one may immediately conclude that bjk   is always better than bjk because it does one
more level of backjumps  however  to be more precise  we need to justify that a situation
where bjk may skip a node visited by bjk   does not exist  similar to a result by kondrak
and van beek  theorem            we can show that 

theorem   bjk visits all the nodes that bjk   visits 
    maintaining strong k consistency  mck  

although backtracking algorithms that maintain arc consistency  or a truncated form of arc
consistency called forward checking  during the search have been well studied  a backtracking algorithm that maintains strong k consistency  mck   has never been fully addressed in
the literature  in order to study the relationship between bjk and mck   we need to specify
precisely the mck algorithms 
a generic scheme to maintain a level of local consistency in a backtracking search is to
perform at each node in the search tree one full cycle of consistency achievement  a consistency achievement algorithm is applied to the csp which is induced by the current partial
solution  if  as a result  the induced csp becomes empty after applying the consistency
algorithm  the instantiation of the current variable is a dead end and should be rejected 
if the resulting csp is not empty  the instantiation of the current variable is accepted and
the search continues to the next level 
the simplest form of an induced csp is to restrict the domains of the instantiated
variables to have only one value and leave the set of constraints unchanged  this idea can
be traced back to gaschnig s        implementation of mac  referred to as deeb  i e  
domain element elimination with backtracking  however  in order to establish a relation
between bjk and mck   we need a more restricted definition of the induced csp  where the
constraints in the induced csp are the selections and projections of the constraints in the
original csp with respect to a partial solution 

definition    induced csp  given a consistent partial solution t of a csp p   the csp
induced by t  denoted by p jt   has all the variables in p except those instantiated by t 
the domain of each variable is the same as in p   and for each constraint c in p where
vars c     vars t   there is a constraint c     vars c  vars t   t vars c   vars t   c    in p jt 
example   consider the graph coloring problem and the corresponding csp shown in
figure    the original csp has four variables  x           x   where x    x   x    fr  g  bg and
x    frg  and five binary constraints  x   
  x   x     x   x     x   x     x  and x     x  
given a partial solution t   fx  g  x  bg  the csp induced by t  p jt   has two variables 
x  and x    and the unary and binary constraints shown in figure   
the maintaining strong k consistency algorithm  mck   at each node in the backtrack
tree applies a strong k consistency achievement algorithm to the csp induced by the

current partial solution  under such an architecture  fc can be viewed as maintaining
one consistency  and for binary csps  mac can be viewed as maintaining strong twoconsistency 
  

ficonflict directed backjumping revisited

an algorithm enforcing strong k consistency on a csp instance should detect and remove
all those inconsistencies t   fx  a           xj aj    g where    j  k and t is consistent
but cannot be consistently extended to some j th variable xj   to remove an inconsistency 
we make it inconsistent in the resulting csp by removing values from domains  removing
inconsistent tuples from existing constraints  or adding new constraints to the csp 
we use the concept of a k proof tree in characterizing the tuples that are removed by a
strong k consistency achievement algorithm 

definition    k proof tree  a k proof tree for a partial solution t over at most k vari 

ables in a csp is a tree in which each node is associated with a partial solution over at most
k variables in the csp  where     the root of the k proof tree is associated with t  and    
each leaf node of the k proof tree is inconsistent in the csp  and     each non leaf node s
of the k proof tree is consistent in the csp  and the children of s at the next level are nodes
s    fx a g         s    fx alg such that s   s  x    vars s   and dom x    fa           al g 

example   figure   shows a three proof tree  more than one is possible  for t   fx  gg

in the given graph coloring problem  each non leaf node  including the root t  is consistent 
and each leaf node is inconsistent in the csp  since we have constructed a three prooftree for the tuple t it cannot be part of a solution to the csp and a strong   consistency
achievement algorithm would remove it 
in general  if a k proof tree for an inconsistency in a csp can be constructed  an algorithm achieving strong k consistency would deduce and remove the inconsistency  after
applying a strong k consistency achievement algorithm on the csp  if all the children of
a node in the k proof tree are inconsistent in the resulting csp  that node is also inconsistent in the resulting csp because one of its subtuples cannot be consistently extended
to an additional variable  because all the leaf nodes in the k proof tree are inconsistent in
the original csp  in a bottom up manner the inconsistency of the root of the tree can be
deduced and removed from the resulting csp  as a special case  if a k proof tree for the
empty inconsistency in a csp can be constructed  the csp will be empty after enforcing
strong k consistency since every way to extend a variable has been shown to lead to an
inconsistency  and therefore  each value would be removed from the domain resulting in the
empty domain   on the other hand  after a csp has been made strongly k consistent  if a
partial solution t over at most k variables is inconsistent in the resulting csp  a k proof tree
for t in the original csp can be constructed  if t is inconsistent in the original csp  the
k proof tree contains the single node t  otherwise  t or a subtuple t  of t cannot be extended
to an additional variable x  i e   all the partial solutions t    fx a  g         t    fx al g 
where dom x    fa          alg  are inconsistent in the resulting csp  then we can construct
the k proof tree recursively for each of those inconsistencies  as a special case  if a csp
is empty after enforcing strong k consistency  a k proof tree for the empty inconsistency in
the original csp can be constructed 
the following lemmas  lemma   to lemma    reveal some basic properties about induced csps and strong k consistency enforcement on induced csps  which are used in the
proofs of theorem    and theorem    

  

fichen   van beek

x 

  
x 

r g  b

  

  

r g  b

  

r

x 

x 

g

x 
x 

g
g

x   x    x    fr  g bg  x    frg
c  x   x      x     x 
c  x   x      x     x 
c  x   x      x     x 
c  x   x      x     x 
c  x   x      x     x 

  

r g  b
x 

x 
x 

g
r

x 
x 

r
r

x 
x 
x 

g
b
r

x 
x 

r
r

x 
x 

g
b

x 
x 
x 

g
b
g

x 
x 
x 

g
b
b

figure    a three proof tree for fx  g g in the graph coloring problem  all leaf nodes in
the proof tree are inconsistent in the csp 

lemma   given a csp p and two partial solutions t and t  of p   if t  t   then p jt   
 p jt  jt  t  
proof clearly p jt  and  p jt jt  t have the same set of variables and the same set of domains 

because vars c   vars t    t  c   vars c   vars t    t   t  vars c   vars t  t c    for each constraint
c in p   the same selection and projection are made in p jt  and  p jt  jt  t  therefore  p jt 
and  p jt  jt  t have the same set of constraints 

lemma   given a csp p and a consistent partial solution t of p   if  i  p is empty after
achieving strong k consistency  or  ii  there exists a variable x   vars t  such that the value
t x  is removed from the domain of x when achieving strong k consistency on p   then p jt
is empty after achieving strong k consistency 

proof we first show that  given a consistent partial solution t of a csp p   and a k proof 

tree t for an inconsistency s in p   there is a corresponding well defined k proof tree tt for
the inconsistency s    s vars s    vars t    in the induced csp p jt   provided s does not
  

ficonflict directed backjumping revisited

x    fr  g  bg  x    frg
c  x      f r    b g
c  x      f r    g g
c  x      f r g
c  x    x      x     x 


x 

r

x 
x 

r
r

x 

g

x 

b

figure    proof tree for the empty inconsistency in the csp p jt induced by t   fx 
g  x  bg constructed from the proof tree for fx  g g in the csp p shown in
figure   
contain any assignments that are inconsistent with the assignments in t  tt is constructed
from t in three steps  see figure   for an example    step    remove from t all nodes and
their descendants which contain assignments that are inconsistent with the assignments in
t   step    replace each remaining node t  in t with the node t     t   vars t     vars t   
i e   remove those variables which occur in t and thus do not occur in p jt   if t  is not a
leaf node in t   then by definition t  is consistent in p   it is possible that the corresponding
node t   in tt is inconsistent in p jt   should this be the case  we make t   into a leaf node by
removing all of its descendants  if t  is a leaf node in t   then by definition t  is inconsistent
in p   i e   there exists a constraint c in p such that t  does not satisfy c   it must be
the case that vars c     vars t   since vars c    vars t  contradicts the fact that t  is
inconsistent with c and t is consistent and therefore consistent with c   but t  and t agree on
their assignments by step     hence  there is a corresponding constraint c   in p jt which is
the selection and projection of c in p   now  it is easy to verify that the corresponding node
t   is also inconsistent with c   and is therefore a well defined leaf node   step    remove all
subsumed nodes from t   where node t  is subsumed by node t  if t  is a  necessarily only 
child of t  and vars t    vars t    all children of a subsumed node t  are made children
of the parent of t   
now  suppose p is empty after achieving strong k consistency  then there is a k prooftree for the empty inconsistency in p and we can construct a k proof tree for the empty
inconsistency in p jt   therefore  p jt is empty after achieving strong k consistency  suppose
there exists a variable x   vars t   such that the value t x  is removed from the domain of
x when achieving strong k consistency on p   then there is a k proof tree for fx t x g in
p and we can construct a k proof tree for the empty inconsistency in p jt  therefore p jt is
empty after achieving strong k consistency 

  

fichen   van beek

lemma   given a csp p and an assignment fx ag  a   dom x   if the induced csp
p jfx ag is empty after achieving strong  k      consistency  then the value a is removed
from the domain of x when achieving strong k consistency on p  

proof suppose p jfx ag is empty after achieving strong  k      consistency  thus  there is
a  k      proof tree for the empty inconsistency in p jfx ag   we now convert the  k     proof tree to a k proof tree for fx ag in p   each node t in the original  k      proof tree
is replaced by t   fx ag  thus  the root of the tree becomes fx ag  furthermore 
if t is not a leaf node in the original  k      proof tree  i e   t is consistent in p jfx ag   it
is easy to verify that t   fx ag is consistent in p   if t is a leaf node in the original
 k      proof tree  i e   t is inconsistent in p jfx ag  there is a constraint c   in p jfx ag such

that t does not satisfy c    let c   be the selection and projection of the constraint c in p  
thus  t   fx ag does not satisfy the constraint c in p and is therefore inconsistent in p  
hence  we have constructed a k proof tree for fx ag in p and thus a would be removed
from the domain of x when achieving strong k consistency on p  

mck extends the current node if the csp induced by the current partial solution is not
empty after achieving strong k consistency  the node is thus called a k consistent node 

definition    k consistent node  a node t in the search tree is a k consistent node if
the csp induced by t is not empty after enforcing strong k consistency  a node which is
not k consistent is called k inconsistent 

lemma   if node t is k consistent  its ancestors are also k consistent 
proof let t  be one of t s ancestors  because t   t  from lemma    p jt    p jt   jt t    thus 
p jt is an induced subproblem of p jt    from lemma    if p jt is not empty after achieving
strong k consistency  p jt  is not empty either after achieving strong k consistency  thus  t 
is k consistent 

the following theorem applies to the case of finding all solutions 

theorem    if mck visits a node  then its parent is k consistent  if a node is k consistent 
then mck visits the node 

proof the first part is true because mck would not branch on this node if its parent was
found k inconsistent  we prove the second part by induction on the depth of the search tree 
the hypothesis is trivial for j      suppose it is true for j     and we have a k consistent
node t at level j      let the current variable be x  from lemma    t s parent t  at level
j is k consistent  thus  mck will visit t    from lemma    p jt    p jt   jfx t x g  because
 p jt   jfx t x g is not empty after achieving strong k consistency  from lemma    value t x 
will not be removed from the domain of x when achieving strong k consistency in p jt    as
a consequence  mck will visit t 

a necessary and sucient condition for mck to visit a node t is that t s parent is kconsistent and the value assigned to the current variable by t has not been removed from
its domain when enforcing strong k consistency on t s parent 
  

ficonflict directed backjumping revisited

theorem    given a csp and a variable ordering  mck visits all the nodes that mck  

visits 

proof follows from theorem    and lemma   
    relationship between bjk and mck

kondrak and van beek        have shown that for binary csps  bj  bj    visits all the
nodes that fc  mc   visits  and fc cbj  mc  cbj  and cbj are incomparable  we
extend their partial ordering of backtracking algorithms to include the relationship between
mck   bjk   and mck  cbj     k  n  all of our results are for the case of general csps 
i e   they are not restricted to binary csps 
we begin by characterizing an important property of the cbj algorithm 

lemma    if cbj performs a one level backjump from a deeper variable xi to a shallower
variable xh   the node th at the level of xh is one inconsistent 

proof let si be the conict set of xi used in the backjumping in which xh is the deepest variable  we show that xi will experience a domain wipe out when enforcing oneconsistency on the induced csp p jth  si     each node ti at the level of xi is a leaf node 
i e   ti is inconsistent in p   suppose ti does not satisfy constraint c where xi   vars c  
and vars c    si   fxi g  the selection of c in p jth  si     which constrains only one variable
fxig  should prohibit value ti  xi  of xi  thus  xi will experience a domain wipe out when
enforcing one consistency on p jth  si     note that p jth is an induced subproblem of p jth  si    
from lemma    p jth is empty after enforcing one consistency  thus  th at the level of xh
is one inconsistent 
lemma    if cbj performs a k level backjump from a deeper variable xi to a shallower
variable xh   the current node th at the level of xh is k inconsistent 
proof let si be the current conict set of xi in which xh is the deepest variable  we show
that if there is a k level backjump from xi to xh   then p jth  si   is empty after enforcing strong

k consistency and thus th is k inconsistent  the proof is by induction on k  k     is true
from lemma     suppose the hypothesis is true for the case of k     but it is not true for
the case of k  i e   there is a k level backjump from xi to xh   but the induced csp p jth  si  
is not empty after enforcing strong k consistency  so there is at least one value a left in the
domain of xi after enforcing strong k consistency on p jth  si     we know that the node ti at
the level of xi instantiating xi with a is either incompatible with th  i e   it is a leaf node 
or is l level backjumped from some deeper variable xj   for some    l   k  see figure    
however  ti cannot be a leaf node as otherwise a would be removed from the domain of xi
when enforcing strong k consistency  let sj be the conict set of xj   from the hypothesis 
the induced csp p jti  sj   is empty after achieving strong l consistency  because value a is
not removed from the resulting csp  from lemma    the induced csp p jth  si   fxi ag is not
empty after achieving strong  k      consistency  because ti  sj    th  si     fxi ag  the
induced csp p jti  sj   is not empty after achieving strong  k      consistency  that leads to
a contradiction  thus p jth  si   is empty after achieving strong k consistency and th at the
level of xh is k inconsistent 
  

fichen   van beek

th

xh
k level backjumping

   

ti

conict set si xi

l level backjumping  l   k

   

conict set sj xj

figure    a scenario in the cbj backtrack tree used in the proof of lemma    

theorem    given a csp and a variable ordering  bjk visits all the nodes that mck
visits 

proof the proof is by induction on the level of the search tree  if mck visits a node at
level j in the search tree  bjk visits the same node  j     is trivial  suppose that it is true
for the case of j     and we have a node t visited by mck at level j      we know both
mck and bjk visit t s parent at level j   the only chance that t may be skipped by bjk is
that bjk backjumps from some deeper variable xi at level i to a shallower variable xh at
level h  such that h   j       i  thus  the node at level h is k inconsistent  by lemma     
since the node at level h is an ancestor of t and we know t s parent is k consistent from
lemma    the node at level h is k consistent  that is the contradiction  therefore  bjk
visits t at level j     
mck can be combined with backjumping  namely mck  cbj  provided the conict sets
are computed correctly after achieving strong k consistency on the induced csps 

theorem    given a csp and a variable ordering  mck visits all the nodes that mck cbj

visits 

proof because mck cbj behaves exactly the same as mck in the forward phase of a

backtracking search  it is easy to verify that mck  cbj visits a node t only if t s parent
is k consistent and the value assigned to the current variable by t was not removed from
its domain when achieving strong k consistency on t s parent  therefore  mck  cbj never
visits more nodes than mck does 
in figure    we present a hierarchy in terms of the size of the backtrack tree for bjk  
mck   and mck  cbj  if there is a path from algorithm a to algorithm b in the figure 
we know that a never visits more nodes than b does  for example  mck never visits
more nodes than bjj   for all j  k  otherwise  there are instances to show a may be
exponentially better than b  and vice versa 
  

ficonflict directed backjumping revisited

bjn
 cbj 

  
 

  

bjk

bjk

mcn

mcn  cbj

  
 

  
 

  

mck

    cbj

mck

mck

mck  cbj

  
 

  
 

  
 

bj

 

mc

 

mc  cbj

 bj 

 fc 

 fc cbj 

 

figure    a hierarchy for bjk   mck   and mck  cbj in terms of the size of the backtrack
tree 
as the following example shows  for any fixed integer k   n  there exists a csp instance
such that cbj visits exponentially fewer nodes than an algorithm that maintains strong
k consistency in the backtracking search  

example   given a fixed integer k  we can construct a binary csp with n   k    variables 
x           xn k    y          yk     xn k           xn    where dom xi     f          ng for    i  n   
and dom yj     f          kg for    j  k      the constraints are  xi  
  xj   for i    j   and
yi  
  yj   for i    j   the problem consists of two separate pigeon hole subproblems  one over

variables x          xn   and the other over variables y           yk     and is insoluble  as we can
see  the pigeon hole problem is highly locally consistent  the first subproblem is strongly nconsistent and the second is strongly k consistent  under the above static variable ordering 
   independently  bacchus and grove        present a similar example to show that given a fixed k  cbj
may be exponentially better than an algorithm called mikc   which essentially maintains k consistency
in the backtracking search 

  

fichen   van beek

a backtracking algorithm maintaining strong k consistency would not encounter a dead end
until xn k   is instantiated  then it would find that the subproblem of xn k            xn  
is not strongly k consistent  thus  the algorithm will backtrack before it reaches the second
pigeon hole subproblem  it will explore nk   nodes at level n   k     of the search tree and
thus take an exponential number of steps to find the problem is insoluble  cbj does not
encounter a dead end at the level of xn k   and it continues to the second pigeon hole
problem  eventually it will find the second pigeon hole problem is insoluble and backjump
to the root of the search tree  the total number of nodes explored is bounded by a constant 
o  k     k   for a fixed k  therefore  cbj can be exponentially better than an algorithm
maintaining strong k consistency 
example   also shows that  although mck visits fewer nodes than bjk by theorem    
bjk   can be exponentially better than mck   however  bjk   can be better than mck
only if there is a  k      level backjump that is not also a chronological backtrack  to see
that this is true  suppose that on a particular instance all  k      level backjumps are also
chronological backtracks  i e   the backjump is to the immediately preceding variable in the
variable ordering and only that single variable becomes uninstantiated and is removed from
the current partial solution   in this case  the freedom to backjump one additional level
rather than chronologically backtrack does not make a difference and bjk   is effectively
bjk and thus cannot be better than mck   thus  bjk   can be better than mck only
if there is a  k      level non chronological backjump  we note  however  that since the
number of backjumps of level k    is less than or equal to the number of backjumps of level
k  as k increases this gets more and more unlikely  thus  as the level of local consistency
that is maintained in the backtracking search is increased  the less that backjumping will
be an improvement 
consider example   again  at each level of the backtrack tree for mck   the instantiation
of each of the past variables removes one distinct value from the domain of the current
variable  recall that mck never instantiates the variable y  as it reaches a dead end at
xn k      if we were to maintain conict sets for the variables  the conict set for the current
variable would include all of its past variables and thus when a dead end is encountered
by the algorithm  any backjump computed from the conict sets would also necessarily be
a chronologically backtrack  thus  as this example shows  mck  cbj and mck can visit
exactly the same nodes and consequently bjk   can be exponentially better than mck cbj  furthermore  because mck    cbj can reach the second pigeon hole problem without
encountering a dead end  it can finally retreat from the second pigeon hole problem to the
root of the search tree by backjumps  thus  mck    cbj may be exponentially better
than mck  cbj  in particular  this shows the surprising result that mac cbj can visit
exponentially more nodes than fc cbj 
finally  as the following example shows  for any fixed integer k   n  there exists a csp
instance such that an algorithm that maintains strong k consistency in the backtracking
search visits exponentially fewer nodes than cbj 

example   consider the csp as defined in example    but searched with the static variable
ordering y           yk   x          xn     yk    

  

ficonflict directed backjumping revisited

   empirical evaluation of adding cbj to gac

in this section  we report on experiments that examined the effect of adding cbj to a
backtracking algorithm that maintains generalized arc consistency  gac   an algorithm
that we refer to as gac cbj  previous work has shown the importance of algorithms that
maintain arc consistency  e g   sabin   freuder        bessiere   regin         we show
that adding cbj to a backtracking algorithm that maintains generalized arc consistency
can speed up the algorithm by several orders of magnitude on hard  structured problems 
previous empirical studies of adding cbj to a backtracking algorithm that maintains a
level of local consistency have led to mixed conclusions  adding cbj to forward checking 
a truncated form of arc consistency  has been shown to give improvements but not always
significant ones  prosser      b  observes that with a static variable ordering  fc cbj is
about three times faster than fc on the zebra problem  smith and grant        observe
that with a dynamic variable ordering  adding cbj to fc led to significant savings but
only on hard random problems that occur in the easy region  bacchus and van run       
observe that with a dynamic variable ordering  adding cbj to fc only led to at most a
   improvement on the zebra problem  n queens problems  and random binary problems 
bayardo and schrag              show that adding cbj to the well known davis putnam
algorithm  the sat version of forward checking  can be a significant improvement on hard
random and real world   sat problems 
adding cbj to an algorithm that maintains full arc consistency has received less attention in the literature  in the one study that we are aware of  bessiere and regin       
observe that adding cbj to mac  the binary version of gac  actually slows down the
algorithm on random binary problems due to the overhead of maintaining the conict sets 
they conjecture that  when mac and a good variable ordering heuristic are used  cbj
becomes useless  
our empirical results lead us to differ with bessiere and regin s conclusion about the
usefulness of adding cbj to an algorithm that maintains full arc consistency  in our implementation we were able to significantly reduce the overhead of maintaining the conict sets
through the use of additional data structures   on problems where adding cbj does not
lead to many savings in nodes visited  our implementation of cbj also does not degrade performance by any significant factor  we demonstrate the improvement by re doing bessiere
and regin s        experiments on random binary problems  we then show through experiments in two structured domains that gac cbj can sometimes improve gac by several
orders of magnitude on hard instances 
in our experiments  we ran both gac and gac cbj on each instance of a problem
and recorded the cpu times  comparing cpu times is appropriate as the underlying code
for gac and gac cbj is identical  with gac cbj containing only additional code to
maintain the conict sets and to determine how far to jump back  two dynamic variable
orderings were used  the popular dom deg heuristic which chooses the next variable with
the minimal domain size and breaks ties by choosing the variable with the maximum degree
 the number of the constraints that constrain that variable  and the dom deg heuristic
proposed by bessiere and regin        which chooses the next variable with the minimal
   see the online appendix for the source code and a description of the key data structures in our implementations of gac and gac cbj 

  

fichen   van beek

value of the domain size divided by its degree  all experiments were run on     mhz
pentium ii s with     megabytes of memory 

    random problems

the run time performance of gac and gac cbj were compared on sets of randomly
generated binary csps  a set of random problems is defined by a   tuple  n  d  r  m  t  
where n is the number of the variables  d is the uniform domain size  r is the uniform arity
of the constraints  m is the number of randomly generated constraints  and t is the uniform
tightness or number of tuples in each constraint  in each case  the constraint tightness t
was chosen so that approximately half of the instances in the population were insoluble 
i e   the instances were from the phase transition region 
table    effect of domain size on average time  seconds  to solve random instances from
     d         t   each set contained     random instances  both gac cbj and
gac used the dom deg variable ordering 

d gac cbj gac
 
             
  
     
     
    
    
  
  
    
    
  
    
    
  
    
    
  
    
    
     
     
  

ratio
    
    
    
    
    
    
    
    

bessiere and regin        examine the effect of domain size on the average time to
solve random instances from      d         t   see figure    right  in bessiere   regin        
with their implementation of cbj  adding cbj steadily worsens performance as domain
size increases until at d      mac cbj is about     times slower than mac alone  with our
implementation  the difference in performance between gac cbj and gac was negligible
on these problems  see table    
the remaining sets of random problems that bessiere and regin used in their experiments to compare the performance of mac cbj and mac are now too simple to provide
a meaningful comparison as they can be solved in less than      seconds on a     mhz
pentium ii computer  thus  we chose harder sets of random binary problems  on each
instance we ran both gac and gac cbj and recorded the cpu times  here we report
the average ratio of the cpu times  gac over gac cbj   each set contained     random
instances  on the first set of problems                        the average ratio for the dom deg
variable ordering was      and the average ratio for the dom deg variable ordering was      
on the second set of problems                         the average ratios for both the dom deg
  

ficonflict directed backjumping revisited

and dom deg variable orderings was       in other words  on average gac was a little over
    faster than gac cbj on these problems 

    planning problems

planning  where one is required to find a sequence of actions from an initial state to a goal
state  can be formulated as a csp  in the formulation we used in our experiments  each
state is modeled by a collection of variables and the constraints enforce the assignments of
variables to represent a consistent state or a valid transition between states   see kautz  
selman        van beek   chen       for more details on the formulation of planning as a
csp  
table    time  seconds  to solve instances of the grid planning problem  the absence of an
entry indicates that the problem was not solved within       seconds     hours 
of cpu time 
dom deg
gac gac cbj
    
    

 
        
 
 
 
 
 
 

dom deg
gac gac cbj
    
    

             
 

       

 

 
 
 

      

 
 
 

in the experiments we used all     instances used in the first ai planning systems
competition  june            the instances come from five different domains  gripper 
mystery  mprime  logistics  and grid  in the experiments we report  both gac and gaccbj were based on ac   mackworth      a  as this was found to give the best performance 
for the gripper  mystery  and mprime domains  each of the instances could be solved
in under    seconds by both gac and gac cbj  on these easy problems  the increased
overhead of cbj rarely led to savings  and overall gac was        faster than gac cbj 
table   shows the comparison between gac and gac cbj in solving the   instances
of the grid problems  gac cbj showed improvement on the grid problems  for example 
it solved problem   in about half an hour  but gac failed to find a solution in    hours 
table   shows the comparison between gac and gac cbj in solving the    instances
of the logistics problem  on about one third of the instances  gac cbj improved on gac 
for example  on instances        and     gac cbj ran several orders of magnitude faster
than gac  and on instance     gac exhausted the    hours time limit but gac cbj found
a solution within   minutes  gac cbj and gac performed similarly on easier instances
and sometimes gac cbj was about     slower than gac 

  

fichen   van beek

table    time  seconds  to solve instances of the logistics planning problem  the absence
of an entry indicates that the problem was not solved within       seconds    
hours  of cpu time 
dom deg
gac
gac cbj
    
    
    
    

 
 
 
     
 
    
 
    
 
     
 
    
    
 
 
    
 
  
  
    
  
    
  
    
  
    
  
 
  
     
  
      
           
    
  
          
    
  
  
 
  
 
  
    
  
     
  
 
           
  
 
  
 
  
 

    

dom deg
gac
gac cbj
    
    
    
    

    

    

     

     

      
 
    
     
           
                

       
    
    
       

    
    

     

    
    
    
 
    
    
    
    

    

     

    
    
    
    
    
 
    
    
    
    

    

    
    
    
    
    
 
    
    
    
    

    

       

     

              

     

    
 
 
    
     
 
 
 
 

  

    
 
 
    
     
 
 
 
 

    
 
 
    
     
 
 
 
 

ficonflict directed backjumping revisited

    crossword puzzle problems

crossword puzzle generation  where one is required to fill in a grid with words from a
dictionary  can be formulated as a csp  in the formulation we used in our experiments  each
of the unknown words is represented by a variable which takes values from the dictionary 
binary constraints enforce that intersecting words agree on their intersecting letter and
that a word from the dictionary appears at most once in a solution  figure   shows an
example      crossword puzzle grid  a csp model of this grid has    variables     binary
 intersection  constraints  and     not equals  constraints 
 

 

 

 

 

 

 

 

 

  

  

  

  

  

  

  

  

  

  

  

  

figure    a crossword puzzle 
in the experiments we used    grids and two dictionaries for a total of     instances of
the problem that ranged from easy to very hard  for the grids  we used    instances at each
of the following sizes                        and       for the dictionaries we used
the uk dictionary  which collects about         words and in which the largest domain for a
word variable contains about        values  and the linux dictionary  which collects       
words and in which the largest domain for a word variable has about       values  in the
experiments we report  both gac and gac cbj were based on ac   bessiere   regin 
      as this was found to give the best performance  see sillito       for a discussion of
integrating ac  into backtracking search  
figure   shows approximate cumulative frequency curves for the empirical results  where
we are plotting the ratio of the time taken to solve an instance by gac over the time
taken to solve the instance by gac cbj  thus  for example  we can read from the curve
representing the dom deg variable ordering that for approximately     of the tests adding
cbj had little effect and that for the remaining     of the tests it led to orders of magnitude
improvements  we can also read from the curves the                    percentiles of the data
sets  where the value of the median is the   th percentile or the value of the   th test   the
crossover point  where gac cbj starts to perform as well as or better than gac occurs
around the   th percentile  tables   and   examine the data more closely by showing the
  

fichen   van beek

    

ratio  gac   gac cbj 

dom degree
dom degree

   

  

 

   
  

  

  

  

  
test

  

  

  

  

   

figure    effect on execution time of gac of adding conict directed backjumping  gaccbj   a curve represents     tests on instances of the crossword puzzle problem
where the tests are ordered by the ratio of time taken to solve the instance by
gac over time taken to solve the instance by gac cbj 
actual times to solve the instances where gac performed best and the instances where
gac cbj performed best 
table    gac versus gac cbj on instances of the crossword puzzle problem  the ten
best improvements in time  seconds  of gac over gac cbj to solve an instance
are presented 
dom deg
rank gac gac cbj
 
    
    
 
    
    
 
    
    
 
    
    
        
      
     
     
 
 
     
     
 
     
     
 
     
     
     
        
  

dom deg
gac gac cbj
    
    
    
    
    
    
     
     
    
    
    
    
    
    
     
     
     
     
    
    

ficonflict directed backjumping revisited

table    gac versus gac cbj on instances of the crossword puzzle problem  the ten
best improvements in time  seconds  of gac cbj over gac to solve an instance
are presented  the absence of an entry indicates that the problem was not solved
within       seconds     hours  of cpu time 
dom deg
dom deg
rank gac gac cbj gac gac cbj
 
 
     
 
     
 
 
              
     
 
 
     
 
      
 
 
     
 
      
 
      
 
      
 
 
      
 
      
 
 
 
      
 
      
         
      
 
       
 
      
     
 
       
  
 
       
 
       

in summary  on some of the smaller  easier crossword puzzle instances gac was slightly
faster than gac cbj  on many of the puzzles there was no noticeable difference  and on
some of the larger  harder puzzles gac cbj was orders of magnitude faster than gac 

   conclusion

in this paper  we presented three main results  first  we showed that the choice of dynamic
variable ordering heuristic can weaken the effects of the backjumping technique  second 
we showed that as the level of local consistency that is maintained in the backtracking
search is increased  the less that backjumping will be an improvement  together these
results partially explain why a backtracking algorithm doing more in the look ahead phase
cannot benefit more from the backjumping look back scheme and they extend the partial
ordering of backtracking algorithms presented by kondrak and van beek        to include
backtracking algorithms and their cbj hybrids that maintain levels of local consistency
beyond forward checking  third  and finally  we showed that adding cbj to a backtracking
algorithm that maintains generalized arc consistency can  still  speed up the algorithm by
several orders of magnitude on hard  structured problems  throughout the paper  we did
not restrict ourselves to binary csps 

acknowledgements
the authors wish to thank the referees for their careful reading of a previous version of
the paper and their helpful comments  the financial support of the canadian government
through their nserc program is gratefully acknowledged 
  

fichen   van beek

references

bacchus  f     grove  a          looking forward in constraint satisfaction algorithms 
unpublished manuscript 
bacchus  f     van run  p          dynamic variable ordering in csps  in proceedings of the
first international conference on principles and practice of constraint programming 
pp           cassis  france  available as  springer lecture notes in computer science
    
bayardo jr   r  j     schrag  r          using csp look back techniques to solve exceptionally hard sat instances  in proceedings of the second international conference
on principles and practice of constraint programming  pp         cambridge  mass 
available as  springer lecture notes in computer science      
bayardo jr  r  j     schrag  r  c          using csp look back techniques to solve realworld sat instances  in proceedings of the fourteenth national conference on artificial intelligence  pp           providence  ri 
bessiere  c     regin  j  c          mac and combined heuristics  two reasons to forsake
fc  and cbj   on hard problems  in proceedings of the second international conference on principles and practice of constraint programming  pp         cambridge 
mass 
bessiere  c     regin  j  c          arc consistency for general constraint networks  preliminary results  in proceedings of the sixteenth international joint conference on
artificial intelligence  pp           nagoya  japan 
bruynooghe  m          solving combinatorial search problems by intelligent backtracking 
information processing letters            
chen  x          a theoretical comparison of selected csp solving and modeling techniques  ph d  thesis  university of alberta 
dechter  r          enhancement schemes for constraint processing  backjumping  learning 
and cutset decomposition  artificial intelligence              
dechter  r          constraint networks  in shapiro  s  c   ed    encyclopedia of artificial
intelligence   nd edition  pp           john wiley   sons 
freuder  e  c          synthesizing constraint expressions  comm  acm              
frost  d     dechter  r          dead end driven learning  in proceedings of the twelfth
national conference on artificial intelligence  pp           seattle  wash 
gaschnig  j          experimental case studies of backtrack vs  waltz type vs  new algorithms for satisficing assignment problems  in proceedings of the second canadian
conference on artificial intelligence  pp           toronto  ont 
haralick  r  m     elliott  g  l          increasing tree search eciency for constraint
satisfaction problems  artificial intelligence              
kautz  h     selman  b          planning as satisfiability  in proceedings of the   th
european conference on artificial intelligence  pp           vienna 
  

ficonflict directed backjumping revisited

kondrak  g     van beek  p          a theoretical evaluation of selected backtracking
algorithms  artificial intelligence              
mackworth  a  k       a   consistency in networks of relations  artificial intelligence    
       
mackworth  a  k       b   on reading sketch maps  in proceedings of the fifth international joint conference on artificial intelligence  pp           cambridge  mass 
mcgregor  j  j          relational consistency algorithms and their application in finding
subgraph and graph isomorphisms  inform  sci               
montanari  u          networks of constraints  fundamental properties and applications to
picture processing  inform  sci             
nadel  b  a          constraint satisfaction algorithms  computational intelligence    
        
prosser  p       a   domain filtering can degrade intelligent backtracking search  in proceedings of the thirteenth international joint conference on artificial intelligence 
pp           chambery  france 
prosser  p       b   hybrid algorithms for the constraint satisfaction problem  computational intelligence             
prosser  p          mac cbj  maintaining arc consistency with conict directed backjumping  research report      university of strathclyde 
sabin  d     freuder  e  c          contradicting conventional wisdom in constraint satisfaction  in proceedings of the   th european conference on artificial intelligence 
pp           amsterdam 
schiex  t     verfaillie  g          nogood recording for static and dynamic constraint
satisfaction problems  international journal on artificial intelligence tools          
sillito  j          improving and estimating the cost of backtracking algorithms for csps  
msc thesis  university of alberta       
smith  b  m     grant  s  a          sparse constraint graphs and exceptionally hard problems  in proceedings of the fourteenth international joint conference on artificial
intelligence  pp           montreal 
van beek  p     chen  x          cplan  a constraint programming approach to planning 
in proceedings of the sixteenth national conference on artificial intelligence  pp 
         orlando  florida 

  

fi