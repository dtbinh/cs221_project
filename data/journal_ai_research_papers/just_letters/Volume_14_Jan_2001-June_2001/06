journal artificial intelligence research                  

submitted        published      

what s attribute 
consequences least common subsumer

ralf kusters

kuesters ti informatik uni kiel de

institut f
ur informatik und praktische mathematik
christian albrechts universit
zu kiel
      kiel
germany

alex borgida

borgida cs rutgers edu

department computer science
rutgers university
piscataway  nj      
usa

abstract

functional relationships objects  called  attributes   considerable importance knowledge representation languages  including description logics  dls   study
literature indicates papers made  often implicitly  different assumptions
nature attributes  whether always required value  whether
partial functions  work presented first explicit study
difference subclasses classic dl  involving same as concept constructor 
shown although determining subsumption concept descriptions
complexity  though requiring different algorithms   story different case
determining least common subsumer  lcs   attributes interpreted partial
functions  lcs exists computed relatively easily  even case results
correct extend three previous papers lcs dls  case attributes
must value  lcs may exist  even exists may exponential size 
interestingly  possible decide polynomial time lcs exists 
   introduction

knowledge representation systems based description logics  dls  subject continued attention artificial intelligence  subject theoretical studies
 borgida        baader        baader   sattler        giacomo   lenzerini        calvanese  giacomo    lenzerini      b  applications  artale  franconi  guarino   
pazzi        brachman  mcguinness  patel schneider    borgida        mcguinness  
patel schneider         impressively  dls found applications areas involving information processing  databases  borgida        calvanese  lenzerini 
  nardi         semi structured data  calvanese  giacomo    lenzerini            a  
information integration  calvanese  giacomo  lenzerini  nardi    rosati        borgida
  kusters         well general problems configuration  mcguinness
  wright        software engineering  borgida   devanbu        devanbu   jones 
       fact  wherever ubiquitous term  ontology  used days  e g   pro c      ai access foundation morgan kaufmann publishers  rights reserved 

steres  borgida
ku

viding semantics web xml documents   dls prime contenders
clear semantics well studied computational properties 
description logics  one takes object centered view  world modeled
individuals  connected binary relationships  here called roles   grouped classes
 called concepts   familiar predicate logic  objects correspond
constants  roles binary predicates  concepts unary predicates  every dl system 
concepts application domain described concept descriptions built
atomic concepts roles using  constructors  provided dl language 
example  consider situation want concept describing individual cars
frequent  at least     repairs  record fact cars  model
manufacturer s model  concepts thought built
 possibly nested  simpler noun phrases  concept  called lemon sequel 
might captured conjunction
 objects cars 
 things whose model values concept model 
 things whose madeby values concept manufacturer 
 things whose model value model madeby attribute 
 things least    repairs values 
 things whose repairs values repairreport  
using syntax classic language  abbreviate above  emphasizing
term like nature descriptions constructors used each 
 and car
 all model model 
 all madeby manufacturer 
 same as  model   madeby model  
 at least    repairs 
 all repairs repairreport  
so  example  concept term  at least n p  constructor at least  denotes
objects related relationship p least n objects  turn   all p
c  instances exactly objects related p instances c 
finally  present concept mathematical notation succinct
preferred formal work dls 
lemon    car u
 model model u
 madeby manufacturer u
madeby    model madeby  u
   repairs u
 repairs repairreport

unlike preceding formalisms  semantic networks frames  quillian        minsky 
       dls equipped formal semantics  given translation
   

fiwhat s attribute 

first order predicate logic  borgida         example  moreover  dl systems provide
users various inference capabilities allow deduce implicit knowledge
explicitly represented knowledge  instance  subsumption algorithms allow one
determine subconcept superconcept relationships  c subsumed  c v d 
instances c instances d  i e   first description always interpreted
subset second description  example  concept car obviously subsumes
concept description lemon   at least    repairs  subsumed  at least   repairs  
traditional inference problems dl systems  subsumption  inconsistency
detection  membership checking  well investigated  algorithms detailed
complexity results realizing inferences available variety dls differing
expressive power   see  e g    baader   sattler        overview 
    least common subsumer

least common subsumer  lcs  concepts specific concept description subsuming given concepts  finding lcs first introduced new inference problem
dls cohen  borgida  hirsh         one motivation considering lcs
use alternative disjunction  idea replace disjunctions c  c
lcs c           c   borgida etherington        call operation knowledge base
vivification  although  general  lcs equivalent corresponding disjunction 
best approximation disjunctive concept within available language  using
approximation motivated fact that  many cases  adding disjunction
would increase complexity reasoning  
proposed baader et al   baader   kusters        baader  kusters    molitor 
       lcs operation used support  bottom up  construction dl knowledge bases  where  roughly speaking  starting  typical  examples lcs algorithm
used compute concept description  i  contains examples   ii 
specific description satisfying property  i   baader kusters presented
algorithm cyclic aln  concept descriptions  aln relatively simple language allowing concept conjunction  primitive negation  value restrictions  number
restrictions  also  baader et al         proposed lcs algorithm dl allowing
existential restrictions instead number restrictions 
originally  lcs introduced operation context inductive learning
examples  cohen et al          several papers followed lead  dls
considered mostly sublanguages classic allowed same as equalities  i e  
expressions  same as  madeby   model madeby    cohen et al  proposed lcs
algorithm aln language allows concept conjunction same as 
call   algorithm extended cohen hirsh      a  coreclassic  additionally allows value restrictions  see  cohen   hirsh      b 
experimental results   finally  frazier pitt        presented lcs algorithm full
classic 
n

n

   observe language already allows disjunction  lcs c            cn   c  cn  
particular  means that  languages  lcs really interest 

   

steres  borgida
ku

    total vs  partial attributes

knowledge representation systems  including dls  functional relationships 
called attributes  also called  features  literature   distinguished subclass
general relationships  least part functional restrictions occur frequently
practice    example  clearly madeby model meant attributes 
thus making unnecessary number restrictions  and  at most   madeby   at least
  madeby    addition  distinguishing attributes helps identify tractable subsets dl
constructors  classic  coreferences attribute chains  as examples 
reasoned eciently  borgida   patel schneider         changed
roles  e g   allowed  same as  repairs   ownedby repairspaidfor    subsumption problem becomes undecidable  schmidt schau        
whereas distinction roles attributes dls theoretically
practically well understood  discovered another distinction  namely one attributes interpreted total functions  total attributes   interpreted
partial functions  partial attributes     slipped cracks  contemporary
research  total attribute always value  the world there   even
know knowledge base currently  partial attribute may value 
distinction useful practice  since difference car possibly 
necessarily  cd player  car necessarily manufacturer  which
may known current knowledge base   latter modeled defining
attribute madeby total attribute  note madeby total attribute 
every individual world discourse  not cars  must filler madeby 
since  however  structural information provided fillers madeby non car individuals  implications drawn fillers trivial  thus  making madeby total
attribute seems reasonable case  car s cd player  hand 
modeled partial attribute express fact cars required cd
player  indicate particular car cd player  one would add
description  at least   cdplayer  
    new results

mentioned above  conjunction same as constructor  roles attributes
behave differently respect subsumption  main objective paper
show distinction total partial attributes induces significantly different
behaviour computing lcs  presence same as  precisely  purpose
paper twofold 
first  show respect complexity deciding subsumption
difference partial total attributes  borgida patel schneider       
shown attributes total  subsumption classic concept descriptions
decided polynomial time  shown present work  slight modifications
algorithm proposed borgida patel schneider suce handle partial attributes 
   readers coming machine learning community aware difference
 attributes   functional roles   attributes   components input feature vector
usually describes exemplar 

   

fiwhat s attribute 

moreover  modifications change complexity algorithm  thus  partial
total attributes behave similarly subsumption point view 
second  surprising result paper  distinction
partial total attributes significant impact problem computing
lcs  previous results sublanguages classic show partial attributes used 
lcs two concept descriptions always exists  computed polynomial time 
if  however  total attributes involved  situation different  lcs need
longer even exist  case exists size may grow exponential size
given concept descriptions  nevertheless  existence lcs two concept descriptions
decided polynomial time 
specifically  previous work  cohen et al         cohen   hirsh      a  frazier  
pitt        concerning lcs computation classic  constructions proofs
made without realizing difference two types attributes  without going
details here  main problem lcs merely finite graphs employed 
making constructions applicable partial attribute case  addition fixing
problems  paper presents proper handling inconsistent concepts
lcs algorithm classic presented frazier pitt        
although results subsumption intriguing  proofs show
results lcs make extensive use corresponding subsumption algorithms 
one reason present beforehand paper 
returning general differences cases total partial attributes 
one could say fundamental cause differences lies same as constructor 
whose semantics normally requires  i  two chains attributes value 
 ii  values coincide  case total attributes  same as obeys principle
c v u   v implies c v u w   v w
u v  w sequences total attributes  e g    madeby model   condition
 i  ensured total aspect attributes  case partial attributes 
implication hold  w  hence u w  longer guaranteed
value  implying same as restriction may hold  clearly  implication affects
results subsumption  far lcs concerned  certain graph  representing lcs
two given concepts  may infinite case total attributes  thus jeopardizing
existence lcs 
general significance result knowledge representation language
designers users need explicitly check beginning whether deal total partial attributes choice significant effects  although
situations total attributes convenient  guarantee existence attributes without
resort number restrictions  results show drawbacks 
things considered  requiring attributes total appears less desirable  concerning classic  technical results paper support use partial attributes
ensure existence lcs computation polynomial time
well ecient decision subsumption  moreover  current implementation
classic subsumption algorithm require major changes order handle partial
attributes 
   

steres  borgida
ku

outline paper follows  following section  basic notions necessary investigations introduced  then  two subsequent sections  subsumption lcs computation classic partial attributes investigated  precisely 
section   offer subsumption algorithm sublanguage classic classic 
contains main classic constructors  section    present lcs algorithm
classic concept descriptions  along lines proposed cohen hirsh
     a   formally prove correctness  thereby resolving shortcomings previous
lcs algorithms  handle inconsistencies properly  finally  section   covers
central new result paper  i e   lcs computation presence total attributes 
section  restrict investigations sublanguage classic order
concentrate changes caused going partial total attributes  nevertheless 
strongly conjecture results proved section easily extended
classic classic using similar techniques one employed two previous
sections 
   formal preliminaries

section  introduce syntax semantics description languages considered paper formally define subsumption equivalence concept descriptions 
finally  least common subsumer concept descriptions specified 
definition   let c   r  disjoint finite sets representing set concept names 
set role names  set attribute names  set classic  concept
descriptions c   r  inductively defined follows 
every element c concept description  concept name  car  
symbol   concept description  top concept  denoting universe
objects  
r   r role n   nonnegative integer  n r n r concept
descriptions  number restrictions     repairs  
c concept descriptions  c u concept description  concept
conjunction  




c concept description r role attribute 
description  value restriction   madeby manufacturer  

 r c

concept

k  h   non negative integers a              b            b   attributes 
  b  b concept description  same as equality  madeby  
model madeby   note two sequences may empty  i e   k     h     
empty sequence denoted   
k

a 

k

h

h

often dispense composition attributes  example  sequence
a  simply written a    moreover  use  r  r  c abbreviation
 r   r   r  c      c case n      denotes c  
usual  semantics classic defined model theoretic way means
interpretations 
k

n

k

n

   

fiwhat s attribute 

definition   interpretation consists nonempty domain interpretation
function   interpretation function assigns extensions atomic identifiers follows 





extension concept name e subset e domain 
extension role name r subset ri  

extension attribute name partial function ai   i e  
 x  y      ai  x  y      ai y    y   
given roles attributes r   use  r  r  i denote composition binary
relations ri   n     result  i   denotes identity relation  i e    i   
f d  d  j   g  individual     define ri  d     fe j  d  e    ri g  r  s
attributes  say  r  r  i defined iff  r  r  i  d        occasionally 
refer  r  r   d i image  r  r  i  d  
extension c concept description c inductively defined follows 
 i     


n





n

n

n

n

  n r i    fd   j cardinality fe   j  d  e    ri g  ng 
  n r i    fd   j cardinality fe   j  d  e    ri g  ng 
 c u d i    c   di  
  r c  i    fd   j ri  d  c g r role attribute 
 a    b  b  i    fd   j  a   i  b  b  i defined
 a   i  d     b  b  i  d g 
note definition attributes interpreted partial functions  since
main point paper demonstrate impact different semantics attributes 
occasionally restrict set interpretations map attributes total
functions  interpretations called t interpretations attributes interpreted
way called total attributes order distinguish partial ones 
stress  remarked introduction  definition  a    b  b  i  
a  b  b must defined order satisfy same as restriction 
although standard semantics same as equalities  one could think
relaxing restriction  example  same as condition might specified hold
either paths undefined images defined identical values 
third definition might satisfied even one paths undefined 
definitions semantics same as might lead different results  however 
paper pursue standard semantics 
subsumption relationship concept descriptions defined follows 
definition   concept description c subsumed concept description  c v
short  interpretations   c di   consider total
interpretations  get t subsumption  c v iff c di t interpretations  






k

h

k

h

k

h

k

k

h



   

h

steres  borgida
ku

defined subsumption  equivalence concept descriptions defined usual way 
c v v c   t equivalence c specified analogously 
already mentioned introduction  main difference partial total
attributes respect subsumption u   v v u w   v w holds attribute
chains u  v  w  whereas necessarily case u   v v u w   v w 
finally  introducing lcs operation formally concluding section 
comment expressive power classic   since  syntactically  classic lacks
common constructors  although classic   introduced here  contain bottom
concept   explicitly  expressed by  e g       r  u     r   use  
abbreviation inconsistent concept descriptions  furthermore  primitive negation  i e  
negation concept names  simulated number restrictions  concept name
e one replace every occurrence e     r   negation  e e     r  
r new role name  finally  attribute following equivalences hold 
  n a    n        a   a   a       a       n a    n   
    a    a     show lose expressive power allowing
number restrictions attributes  still  full classic somewhat expressive
classic   mainly due introduction individuals  also called nominals 
classic  sake completeness give syntax full classic language  
requires set  o  representing set individual names  define
two additional concept constructors
fe         e g  individuals e    enumeration all  summer  springg 
p   e role attribute p  individual e  fills currentseason   summer  
technical report  kusters borgida        extend results presented
work full classic  case individuals non standard semantics 
least common subsumer set concept descriptions specific concept
subsuming concept descriptions set 
definition   concept description least common subsumer  lcs  concept
descriptions c            c  lcs c            c   short  iff i  c v              n ii 
every d  property v d    analogously  define lcs  c            c   using v
c





e

e

e





n

n





instead v 

n



note lcs concept descriptions may exist  does  definition
uniquely determined equivalence  sense  may refer lcs 
following two sections  attributes always interpreted partial functions 
section   consider total attributes 
   characterizing subsumption

classic

section modify characterization t subsumption classic  proposed
borgida patel schneider         handle case partial attributes 
   even omitting constructs dealing integers so called  host individuals  
cannot roles act role attribute fillers 

   

fiwhat s attribute 

detail  tools used deciding subsumption intimately related
computation lcs 
t subsumption classic decided multi part process  first  descriptions
turned description graphs  next  description graphs put canonical form 
certain inferences explicated redundancies reduced combining nodes
edges graph  finally  t subsumption determined description
canonical description graph 
order  inherit  proofs  tried minimize necessary adjustments
specification  borgida   patel schneider         reason  roughly speaking 
attributes treated roles unless form part same as equality   note
attributes participating same as construct must values   extent 
allow us adopt semantics original description graphs  crucial
proofs  however  two different occurrences attributes  namely  same as equality
vs  role value restriction  require us modify extend definition description
graphs  normalization rules  subsumption algorithm itself 
following  present steps subsumption algorithm detail  start
definition description graphs 
    description graphs

intuitively  description graphs ect syntactic structure concept descriptions 
description graph labeled  directed multigraph  distinguished node  roughly
speaking  edges  a edges   graph capture constraints expressed same as
equalities  labels nodes contain  among others  set so called r edges 
correspond value restrictions  unlike description graphs defined borgida
patel schneider  r edges labeled role names attribute
names   we shall comment later advantage modification order deal
partial attributes   r edges lead nested description graphs  representing concepts
corresponding value restrictions 
defining description graphs formally  figure   present graph corresponding
concept description lemon defined introduction  use g manufacturer  
g model   well g repairreport  denote description graphs concept names
manufacturer  model  repairreport  graphs simple  merely consist
one node  labeled corresponding concept name  general  graphs
complex since value restriction  r c leads  possibly complex  nested
concept description c  
although number restrictions attributes allowed  r edges labeled attributes  model madeby  always restriction        order capture
semantics attributes  formally  description graphs  nodes  edges defined mutually
recursively follows 
definition   description graph g tuple  n  e  n    l   consisting finite set n
nodes  finite set e edges  a edges   distinguished node n    n  root graph  
function l n set labels nodes  occasionally use notation
g n odes  g edges  g root access components n   e n  graph g 
   

steres  borgida
ku

f g

madeby

f g

repairreport 

g 

madeby

repairs

model

       

model 

g 

model       

fcar  g
 

madeby       

manufacturer 

g 

figure    description graph lemon  large node root graph
a edge tuple form  n    a  n    n    n  nodes attribute
name 
label node defined   tuple form  c  h    consisting finite
set c concept names  the atoms node  finite set h tuples  the r edges
node   concept names description graph stand atomic concept names   
occasionally use notation n atoms n redges access components c
h node n 
r edge tuple   r  m  m  g     consisting role attribute name  r  min  m 
non negative integer  max    non negative integer   
 recursively nested  description graph g    graph g  often called restriction
graph node role r  require nodes g  distinct nodes
g nested description graphs g  r attribute  require     
  f    g 

given description graph g node n   g n odes  define gj graph
 n  e  n  l   gj said rooted n  sequence p   n a  a  n k  
 n      n     g edges               k  called path g node n  n  p   g
short   k     path p called empty  w   a  called label p  the
empty path label     p called rooted n  root g  occasionally  write
n  a  n   g omitting intermediate nodes 
throughout work make assumption description graphs connected 
description graph said connected nodes graph reached
rooted path nested graphs connected  semantics description graphs  see
definition    altered nodes cannot reached root deleted 
order merge description graphs need notion  recursive set nodes 
description graph g  recursive set nodes g union nodes g
recursive set nodes nested description graphs g 
concept descriptions  semantics description graphs defined means
interpretation   introduce function assigns individual domain
every node graph  ensures same as equalities satisfied 
n

k

n







k

k

k

k

k

   

fiwhat s attribute 

definition   let g    n  e  n    l  description graph let interpretation 
element  d  gi   iff total function    n

  



   n   

  n    n    ni  
    n    a  n      e   n      n       ai  
extension ni node n label   empty set  element  d  ni  
  



       c  h    iff

l n

  c     b  
 r  m  m  g      h  

  
  

n

b

 a  elements  d    domain

 b  d    g i d   d  d      ri  

 d  d      ri  

cohen hirsh      a  defined semantics description graphs different way 
avoiding introduction total function   problem definition is 
however  well defined acyclic graphs  which  example  excludes sameas equalities form     spouse spouse  even p   p q 
semantics graphs proposed borgida patel schneider        similar
definition    however  paper a edges captured same as equalities
value restrictions attributes  still  context partial attributes  could
define semantics description graphs means total function since
attributes might fillers  specifying semantics description graphs terms
partial mappings would make definition even longer  furthermore  proofs
 borgida   patel schneider        would carry easily  therefore  order
keep total function  value restrictions attributes initially always translated redges  next section present translation concept descriptions description
graphs detail 
defined semantics description graphs  subsumption equivalence description graphs  e g   h v g  well concept descriptions description
graphs  e g   c v g  defined way subsumption equivalence
concept descriptions 
    translating concept descriptions description graphs

following borgida patel schneider         classic concept description turned
description graph recursive process  process  nodes description
graphs often merged 
definition   merge two nodes  n  n    new node n following label 
n  n  label    label n    otherwise labels equal
   n atoms   n  atoms   n  atoms n redges   n  redges   n  redges 
   

steres  borgida
ku

g     n    e    n    l    g     n    e    n    l    two description graphs disjoint
recursive sets nodes  merge g  g    g    g  g     n  e  n    l   defined
follows 

  

   n  n  
n     n    n    fn  g  n fn    n  g 
e     e    e    n   n    n   n     i e   e union e  e  every occurrence

  

l n

  
  

n 

n    n  substituted n   

       l  n  n   n  n fn g  l n     l   n  n   n  n fn  g  l n  

defined label obtained merging n 

n   

now  classic  concept description c turned corresponding description
g c   following translation rules 
     turned description graph one node n  a edges  atom
node   set r edges empty 
   concept name turned description graph one node a edges 
atoms node contain concept name node r edges 
   description form   n r  turned description graph one node
a edges  node atoms   single r edge  r  n     g    
g    specified first translation rule 
   description form   n r  turned description graph one node
a edges  node atom   single r edge  r     n  g     
   description form a    b  b turned graph pairwise
distinct nodes n           n    m              root m     n   additional node
n      n  set a edges consists  n    a    n      n    a    n              n       n  
 m   b    m      m   b    m             m    b      i e   two disjoint paths coincide starting point  n   final point  n   note p     first
path empty path n  n  q     second path empty path
n  n    nodes   atom r edges 
   description form  r c   r role  turned description graph
one node a edges  node atom f g single r edge
 r        g c    
   description form  a c   attribute  turned description
graph one node a edges  node atom f g single
r edge  a        g c      in work borgida patel schneider  concept
description  a c turned a edge  already mentioned  would cause
problems attributes interpreted partial functions defining semantics
means specified definition    

graph

p

p

p

q

q

q

p

q

   

q

q

p

p

fiwhat s attribute 

   turn description form c u description graph  construct g c  
g d   merge them 
figure   shows description graph built way concept lemon example 
easily verified translation preserves extensions 
theorem   concept description c corresponding description graph g c  
equivalent  i e  c   g c  i every interpretation  
main diculty proof theorem showing merging two description
graphs corresponds conjunction concept descriptions 
lemma   interpretations   n  n  nodes   n  n   i   ni    ni   

g  g  description graphs  g  g   i   gi
    g   
proof preceding statement rather simple one  borgida   patelschneider        
    translating description graphs concept descriptions

although characterization subsumption require translating description
graphs back concept descriptions  translation presented show concept descriptions description graphs equivalent representations classic concept
descriptions  subsequent sections  fact need turn graphs concept descriptions 
translation description graph g specified rather straightforward
recursive definition  main idea translation stems cohen hirsh      a  
employed spanning trees translate same as equalities  spanning tree  connected  graph tree rooted node graph containing nodes
graph  particular  coincides graph except a edges deleted 
example  one possible spanning tree g figure   obtained deleting a edge
labeled madeby  whose origin root g 
now  let g connected description graph spanning tree it  then 
corresponding concept description c obtained conjunction following
descriptions 
   c contains  i  same as equality v   v every leaf n   v label
rooted path n   ii  same as equality v    v  a edge
 n    a  n     g edges contained   v label rooted path
n          
   every node n   c contains value restriction  v c   v label
rooted path n  c denotes translation label n  i e   c
conjunction obtained follows 
every concept name atoms n conjunct c  
every r edge  r  m  m  g    n  c contains  a  number restrictions  mr 
  r   in case r role        b  value restriction  r c    
c   recursively defined translation g   
g

g





g

n

n

n

n

n

g

g

   

steres  borgida
ku

case set atoms r edges n empty  define c      
referring graph g figure    c contains same as equalities model madeby  
model madeby madeby   model madeby  furthermore  n  denotes root g 
c value restrictions    c    model     model madeby    c
corresponds lemon defined introduction  without same as equality  note
that  although case same as equality model madeby   model madeby
needed  one cannot dispense    i  construction above  illustrated following example  without    i   description graph g a   a  would turned
description    equivalent   since same as equality requires
path value  may case 
easy prove translation thus defined correct following sense
 kusters   borgida        
n

g

n 

g

n 

lemma   every connected description graph g equivalent translation c   i e  
interpretations   gi   c  
g

g

    canonical description graphs

following occasionally refer  marking node incoherent   means
label node changed     marking description graph incoherent  means
description graph replaced graph g    corresponding    i e   graph
consisting one node label   
one important property canonical description graphs deterministic 
i e   every node one outgoing edge  a edge r edge  labeled
attribute role name  following borgida patel schneider         order turn
description graph canonical graph need merge a edges r edges  addition 
different work  might necessary  lift  r edges a edges 
merge two a edges  n  a  n    n  a  n    description graph g  replace
single new edge  n  a  n    n  result merging n  n   addition 
replace n  n  n  a edges g 
order merge two r edges  r  s    k    g      r  s    k    g    replace new r edge
 r  max s    s     min k    k     g  g    
lift r edge  a  m  m  g   node n concept graph g a edge
 n  a  n     remove n redges  augment g adding g  n odes g n odes 
g  edges g edges  well adding  n  a  g  root  g edges  precondition
applying transformation          g corresponds graph
g     reason precondition r edge form  a        g   lifted
without g inconsistent  fact a successors allowed lost  normalization rule    see below  guarantee precondition always satisfied 
description graph g transformed canonical form exhaustively applying
following normalization rules  graph called canonical none rules
applied 
   node g marked incoherent  mark description graph incoherent 
 reason  even node root  attributes corresponding a edges must always














   

fiwhat s attribute 

value  since participate same as equalities   value cannot belong

 
   r edge node min greater max  mark node incoherent 
 reason   
 
 
   add   atoms every node  absent 
   r edge node restriction graph marked incoherent  change max
    reason       
  
   r edge node max    mark restriction graph incoherent 
 reason  see    
   r edge form  r        g    g  contains one node empty
set atoms atoms set f g r edges  remove r edge 
 reason 
  
   node two r edges labeled role  merge two edges 
described above   reason 
 
   
   description graph two a edges node labeled
attribute  merge two edges  described above   reason 
 
   
   node graph a edge r edge attribute 
 lift r edge  precondition satisfied  see above    reason  value
restrictions imposed attributes participate same as equalities must made explicit
gathered one place similar previous cases  
need show transformations canonical form change semantics
graph  main diculty showing merging processes lifting
preserve semantics  difference  borgida   patel schneider       
addition merging r edges a edges need lift r edges  therefore 
omit proofs showing merging edges preserves extensions  proofs
following two lemmas routine quite similar one lemma   
lemma   let g    n  e  n    l  description graph two mergeable a edges let
g     n     e     n    l    result merging two a edges  then  g g   
empty set 



r u



r  

r

 r  

 r    

 r c u  r d  r  c u

 a c u  a d

 a  c u

lemma   let n node two mergeable r edges let n  node
edges merged  then  ni   n i every interpretation  
lemma   let g    n  e  n    l  description graph node n a edge  n  a  n     
suppose n associated r edge  a  m  m  g    provided precondition lifting
r edges satisfied g     n     e     n    l    result transformation 
g g   
proof  sucient show gij   g  ij   since label n changed g 


n obtains additional a edge  points graph g connected
n

n



   

steres  borgida
ku

repairreport

g

fmodel  g
 

model

repairs

model

       

fcar  g
 

madeby

fmanufacturer  g
 

figure    canonical description graph lemon  left most node root 
rest g    w l o g  therefore may assume n root g  i e   n   n   let
  gi   thus  function n specified definition  
individual e    n   e    n      d  e    ai   implies e   gi   hence 
exists function   g  n odes g e satisfying conditions
definition    since sets nodes g g disjoint  define   
union    i e       m      m  nodes g    m       m 
nodes g   since  construction  additional a edge  n  a  g  root    e  
    n       g  root     ai   follows conditions definition   satisfied
g   thus    g i  
let   g i   thus  function    n   according definition   
let e       g  root       n     let g   description graph obtain g 
deleting nodes corresponding g   graph g without r edge
 a  m  m  g    restrict    nodes g     follows   g  i   furthermore 
restricting    nodes g yields e   gi   particular  g marked
incoherent  then  precondition ensures      thus  since e a successor
d  conclude   gi  
ut


























dealt issue merging lifting  easy verify  normalization  affect meaning description graphs 
theorem   g description graph g  corresponding canonical description
graph  g g   

example  canonical description graph graph given figure   depicted
figure   
    subsumption algorithm

final part subsumption process checking see canonical description graph
subsumed concept description  borgida patel schneider        
attributes total  turns necessary turn potential subsumer
canonical description graph  subsumption algorithm presented next
considered characterization subsumption 
   

fiwhat s attribute 

algorithm    subsumption algorithm  given concept description description graph g    n  e  n    l   subsumes  d  g  defined true one
following conditions hold 
   description graph
  



  



  



  



g

marked incoherent 

concept name    element atoms n   

  n r  i  r edge n  r role  min greater equal
n  ii  n     

  n r  r edge n  r role  max less equal n 


  b  b

  rooted paths label
g ending node 
a 

n



a 



n



b 

b



 r c   role r  either  i  r edge n  r role g 
restriction graph subsumes  c  g      ii  subsumes  c  g       reason 
 r      
    a c   attribute a   i  a edge g form  n    a  n    
subsumes  c   n  e  n    l     ii  r edge n  attribute  g 
restriction graph subsumes  c  g      iii  subsumes  c  g     

  



  



e u f subsumes  e  g  subsumes  f  g  true 

two differences algorithm one total attributes presented borgida patel schneider  see algorithm     first  partial attribute
case  given    a c   one needs look value restriction either a edge
r edge g  since attributes label a edges r edges   in total attribute
case  attributes label a edges examining r edges necessary  
second important distinction treatment same as equalities  shown
algorithm    a    b  b one needs check whether
exist two paths labeled v    a  w    b  b leading node g 
total attribute case  however  suces exist prefixes v  w  v w
property  long remaining suxes identical 
soundness completeness algorithm stated following theorem 
theorem   let c   classic descriptions  then  c v iff subsumes  d  g   
g canonical form g c   
soundness subsumption algorithm  i e   direction theorem stated
above  pretty obvious   borgida   patel schneider         main point
only if direction  proof completeness  canonical graph g deterministic 
i e   node  given role attribute name r  one outgoing r edge
a edge r label  point reader  borgida   patel schneider       
proof  since almost identical one total attributes already published there 
proofs reveal that  direction theorem    description graphs need
normalized  thus  one show 
n



n



c

c

c

   

steres  borgida
ku

remark   let g  not necessarily normalized description graph  let
concept description  then  subsumes  d  g  implies g v d 





classic

borgida patel schneider argue canonical description graph g concept
description c constructed time polynomial size c   furthermore  algorithm   runs time polynomial size g d  hard see
changes presented increase complexity  thus  soundness completeness
subsumption algorithm provides us following corollary 
corollary   subsumption classic concept descriptions c d  attributes
interpreted partial functions  decided time polynomial size c
d 
   computing lcs

classic

section  show lcs two classic concept descriptions stated
terms product canonical description graphs  similar result proven
cohen hirsh      a  sublanguage classic   allows concept
names  concept conjunction  value restrictions  same as equalities  particular 
sublanguage allow inconsistent concept descriptions  which  example 
expressed con icting number restrictions   furthermore  semantics description
graphs provided cohen hirsh restricts results case description graphs
acyclic  excludes  example  same as equalities form   spouse spouse 
following  first define product description graphs  then  show
given concept descriptions c d  lcs equivalent description graph obtained
product g g   constructions proofs quite close
 cohen   hirsh      a  
c



    product description graphs

description graph represents constraints must satisfied individuals
extension graph  intuitively  product two description graphs intersection
constraints as product finite automata corresponds intersection
words accepted automata  however  definition product description
graphs special care taken incoherent nodes  i e   nodes labeled    also 
since attributes may occur r edges a edges  one needs take product
restriction graphs r edges  one hand  original graphs g  g 
 rooted certain nodes   hand 
definition   let g     n    e    n    l    g     n    e    n    l    two description graphs 
then  product g    g  g      n  e  n    l  two graphs recursively defined
follows 
  
  
  

   n  n   
n      n    n    
e   f  n  n     a   m  m     j  n  a  m    e   n    a  m      e  g 
n

   

fiwhat s attribute 

   let n   n  n    n    l   n       let l  n  n        l   n    and  analogously 
l   n         l  n  n        l   n   otherwise  l   n     s    h    l   n     
 s    h    define l  n  n        s  h  
 a 
 b 



   s    s  

  
 
 
 
 
 
  j  r  p    q    g      h     r  p    q    g      h  g  
f a        g  g    j  n  a  m    e     a  p    q    g      h  g  
f a        g  g    j  a  p    q    g      h     n   a  m    e  g 
h

 

 

 

f r  min p    p    max q    q    g  g 
 

j

 

 

 

 

j

 

according definition  tuple  n  n   node  say n  incoherent 
label  n  n    coincides one n   reason defining label
way lcs    c   c every concept description c   overlooked
frazier pitt         thus making constructions proofs hold concept
descriptions contain inconsistent subexpressions 
note g  defined here  might connected  i e   might contain nodes
cannot reached root n   even g  g  connected happen
tuples  n   n    belong set nodes g regardless whether
reachable root not  however  already mentioned section     may
assume g connected 
note product graph translated back classic concept
description since product two description graphs description graph 
    computing lcs

prove main theorem subsection  states product two
description graphs equivalent lcs corresponding concept descriptions 
theorem   let c  c  two concept descriptions  let g  g  corresponding
canonical description graphs  then  c     lcs c    c    
g

g

let g    g  g    sketch proof showing c subsumes c  and 
symmetry  c   see  kusters   borgida        details   construction 
two rooted paths common node g  g  corresponding paths leading
node well  thus  theorem    same as equalities c subsume ones
c    now  let spanning tree g   m   m    node g  v label
rooted path  m    m     then  construction follows exists rooted
path g  m  labeled v  furthermore  rather straightforward inductive proof shows
concept description e corresponding label  m    m    subsumes g  j  
implies  v e w g    result  conclude g w g   
interesting part proof show c common subsumer
c  c   least common subsumer 
show induction size d  c   c  subsumes c 
c    subsumes c   distinguish different cases according definition
 subsumes    let g     n    e    n   l    canonical description graph c   g   
 n    e    n   l    canonical description graph c    g    n  e  n    l    g  g   
following  assume c  v c  v d  thus  subsumes  d  g  
proof 

g

g

m 

g

g

   

steres  borgida
ku

  d  g    show subsumes  d  g   then  remark   implies g v d 
thus  c v d  note one cannot use theorem   since g might canonical
description graph 
   g incoherent  nothing show 
   concept name     number restriction  definition label
n  easy see subsumes  d  g  
   v   w  exist nodes m  g  m  g  two
paths n  m  label v w  respectively  well two paths n 
m  label v w  then  definition g easy see two
paths n     n   n     m    m   label v w  respectively  shows
subsumes  d  g  
    r c   r role attribute  one several cases applies 
 i  n  n  r edges role attribute r  restriction graphs g   g    
respectively  subsumes  c  g     subsumes  c  g     
 ii  without loss generality  n  a edge pointing m  attribute r 
subsumes  c  g      g      g  j   n  r edge restriction
graph g   subsumes  c  g     
cases  i   ii   subsumes  c  g   g     follows induction  furthermore 
definition g r edge role r restriction graph g   g   n  
implies subsumes  d  g  
 iii  n  n  a edges attribute r leading nodes m  m    respectively  then  subsumes  c  g  j   subsumes  c  g  j    induction  know
subsumes  c  g  j
g  j    easy see gj 
g  j   fur    g  j
thermore  definition a edge attribute r  n   n     m    m   
g  shows subsumes  d  g  
 iv   without loss generality  n  r edge a edge role attribute
r   implies subsumes  c  g      ensures subsumes  d  g  
   e u f   definition subsumption algorithm  subsumes  e  g   
subsumes  e  g    hold  induction  subsumes  e  g   analogously 
subsumes  f  g   thus  subsumes  d  g  
ut
stated section      canonical description graph classic concept description
computed time polynomial size concept description  hard
verify product two description graphs computed time polynomial
size graphs  addition  concept description corresponding description
graph computed time polynomial size graph  thus  consequence
theorem   obtain 
subsumes
g

m 

m 

m 

m 

m 

m   m 

m 

m 

corollary   lcs two classic concept descriptions always exists computed time polynomial size concept descriptions 
   

fiwhat s attribute 

j   j   

j   j   













figure    canonical description graph   without node labels 


intimated  cohen et al          statement hold sequences concept
descriptions  intuitively  generalizing lcs algorithm sequences of  say  n concept descriptions  means computing product n description graphs  following proposition
shows size product graph may grow exponentially n  thus  lcs
computed way grows exponentially size given sequence  however 
imply exponential blow up unavoidable  might exist smaller 
still equivalent representation lcs  nevertheless  show exponential
growth inevitable 
proposition   integers n   exists sequence d            classic
concept descriptions size every classic concept description equivalent
lcs d              least exponential n size   linear n 
proof  cohen et al          given n  define concept descriptions
follows 
   u        u u  a     u       
  
  
n

n







j

j



j







j





a            denote attributes  canonical description graph depicted
figure    using algorithm   easy see v v   w iff number   v
number   w equal modulo   v  w words fa            g 
implies
d            v v   w
iff   n number  s v
   
 
number w equal modulo   
let f           ng non empty set  define v    k i     
elements w        k          let e lcs
d              let g corresponding canonical description graph root n  
    know e v v   w every f           ng  algorithm   implies
paths n  g labeled v w exist lead node q  
assume non empty subsets s  f           ng     t  q   q   would
imply e v v   v contradiction      thus     implies q    q   since
    non empty subsets f           ng  shows g contains least     nodes 
fact size g linear size e completes proof 
ut
proposition shows algorithms computing lcs sequences necessarily worstcase exponential  conversely  based polynomial time algorithm binary lcs
operation  exponential time algorithm easily specified employing following
identity lcs d              lcs d   lcs d     lcs  lcs d    d      
n









n

n





i 



i 



n

i 



j



j

j

k

j

e





e















n

e

e

n

n

n

   





n

steres  borgida
ku

corollary   size lcs sequences classic concept descriptions grow
exponentially size sequences exists exponential time algorithm
computing lcs 
   lcs same as total attributes

previous sections  attributes interpreted partial functions  section 
present significant changes computing lcs occur considering
total functions instead partial functions  precisely  look sublanguage
classic allows concept conjunction same as equalities 
general assumption attributes interpreted total functions 
restrict attention language order concentrate changes
caused going partial total functions  strongly conjecture  however 
results represented easily transfered classic extending description
graphs section   
first  show lcs two concept descriptions always exist 
then  present polynomial decision algorithm existence lcs two
concept descriptions  finally  shown lcs two concept descriptions
exists  might exponential size given concept descriptions
computed exponential time 
sequel  simply refer lcs lcs  since throughout section
attributes always assumed total  lead confusion 
again  may useful keep mind total  though partial  attributes
 u   v  v  u w   v w  u  w  v   a  set finite words
a  finite set attribute names  indeed  differences partial
total attributes shown section finally trace back property 










    existence lcs

subsection  prove lcs two concept descriptions always
exist  nevertheless  always infinite representation lcs  used
next subsection characterize existence lcs 
accomplish above  return graph based characterization t subsumption
proposed borgida patel schneider         modified partial attributes section    concept description c   let g denote corresponding canonical description
graph  defined section      semantics specified section      although
set interpretations restricted allow attributes interpreted total functions
only 
since contains concept names allow value restrictions  nodes
g contain concept names set r edges empty  therefore  g
defined triple  n  e  n    n finite set nodes  e finite set
n n   n  root graph 
corollary results borgida patel schneider  subsumption c v
concept descriptions c decided following algorithm 
provides us characterization t subsumption 
c

c

c



   

fiwhat s attribute 

g

c   

d   

c

g




b

b




c

figure    canonical graphs c  d 
algorithm   let c   concept descriptions   g    n  e  n    canonical
description graph c   then  subsumes   d  g   defined true one
following conditions hold 
c



  

c

v   w words v    w    u   v   v  u w   w  u 
rooted paths g labeled v  w    respectively  ending node 



c

  subsumes   d    g   true 
apart additional constructors handled algorithm    algorithm   differs
algorithm   that  total attributes  considered here  sucient prefixes
rooted paths v w lead common node  long remainder cases
path 
  



d  u d  subsumes   d    g


c



c

theorem   concept descriptions lcs concept descriptions exist  

result corrects statement cohen et al         lcs always exists 
statement inadvertently assumed attributes partial  total 
proof  offer following  concept descriptions  shown
lcs 
c       b 
d       ac u b   bc u ad   bd 
graphs concepts depicted figure   
following statement shows lcs e c  d  would satisfy condition
 regular structure   statement easily verified using
algorithm   
e v v w
iff v   w exists nonnegative integer n u  
v   ac du w   bc du vice versa 
given description lcs c  d    one show  again  employing algorithm    finite description graph equivalent e   however  omit
elementary proof here  absence lcs follows theorem   
infinite graphs used characterize existence lcs  note partial
attribute case  lcs c  d  equivalent   u b   b  result


n

   

n

steres  borgida
ku

obtained lcs algorithm presented previous section  corresponding  finite  description graph consists root two additional nodes  root two
outgoing edges leading two nodes labeled b  respectively 
state theorem    first introduce infinite description graphs show
always exists infinite description graph representing lcs two  concept descriptions 
infinite description graph g defined  finite graph  triple  n  e  n   
except set nodes n set edges e may infinite  finite case 
nvn    g means g contains path n n  labeled word v    
semantics infinite graphs defined finite case  furthermore  infinite graphs
translated concept descriptions follows  take  infinite  spanning tree g  and 
finite case  every edge g contained it  add c same as equality 
note contrast partial attribute case  c need contain same as equalities
form v   v since  total attributes  v   v    still  c might concept description
infinite number conjuncts  thus  infinite concept description   semantics
concept descriptions defined obvious way  analogously lemma    one
show  infinite  graph g corresponding  infinite  concept description c
equivalent  i e   c g 
call  infinite  description graph g deterministic if  if  every node n
g every attribute   exists one a successor n g  graph
g called complete every node n g every attribute    at least 
one a successor n g  clearly  deterministic complete  infinite  description
graph  every path uniquely determined starting point label 
algorithm    which deals finite description graphs g   generalized deterministic complete  infinite  description graphs g straightforward way  see
this  first note  finite  description graph coming  concept description
canonical iff deterministic sense introduced  analogously  deterministic
infinite graph viewed canonical  thus  requiring  infinite  graphs
deterministic satisfies precondition algorithm    now  addition graphs
complete   unlike condition stated subsumption algorithm  longer
necessary consider prefixes words complete graph contains rooted path
every word  precisely  v  w  lead node  case
v   v   u w   w  u well  thus making unnecessary consider prefixes v   w 
v w  respectively  summing up  conclude 
corollary   let g    n  e  n    deterministic complete  infinite  description
g

g

g

g

g

c

graph

v  w

  a  then 
gv v w
iff


n  vn

  g n wn   g node n 

shall construct  infinite  graph representing lcs two concept descriptions
product so called completed canonical graphs  infinite representation
lcs used later characterize existence lcs   i e   existence
finite representation lcs 
define completion graph  intuitively  graph completed iteratively
adding outgoing a edges labeled attribute every node graph
outgoing a edge  process might extend graph infinite trees 
example  completion g  cf  figure    depicted figure     fa  b  c  dg 
c 

   

fiwhat s attribute 

g

 
c  
 







c

c

b

b







b

c





b

c



   
   
figure    complete graph c 
formally  completions defined follows  let g  infinite  description graph 
graph g  extension g every node n g every attribute  
n outgoing edges labeled a  new node added  well edge
 n  a     now  let g    g    g          sequence graphs g    g g   
extension g      g    n   e   n   
   
g      
n 
e   n   
n a



n a









 



 
construction  g 






called completion g 
complete graph  furthermore 
 
g deterministic  g deterministic well  finally  easy see graph
extension sare equivalent  thus  induction  g  g 
nodes   n   i e   nodes g  g  called tree nodes 
nodes g called non tree nodes  construction  every tree node g 
exactly one direct predecessor g   i e   exactly one node n one attribute
 n  a  t  edge g    n called a predecessor t  furthermore 
exactly one youngest ancestor n g tree node g   n youngest ancestor
path n g  contain non tree nodes except n 
note one path n g   finally  observe non tree nodes
non tree nodes ancestors 
note completion canonical description graph always complete deterministic 
sequel  let c   two concept descriptions   g    n   e   n    g  
 n   e   n   corresponding canonical graphs  g    g  completions
g   g   products g    g g g
     g  g  specified definition   
usual  may assume g g  connected  i e   contain nodes
reachable root  n   n    otherwise  one remove nodes cannot
reached root without changing semantics graphs 
denote product g  g  g  instead g   or g   otherwise
graph could confused completion g  general  graphs






c



c





c



c

c



c



c



   



c



c

c



steres  borgida
ku

coincide  example  take products g g g  g   see figure  
graphs g g    former product results graph consists root
two outgoing a edges  one labeled one labeled b   as mentioned before 
graph corresponds lcs c  d  partial attribute case   product
completed graphs  hand  graph obtained completion
graph depicted figure    the infinite trees omitted sake simplicity  
easy consequence fact g g  corollary    one prove
following lemma 
c 

lemma  

c 

d 

c

c

c 

d 

d 

c

v v   w iff n


c

vn

  g  n
c

c

wn

  g  node n g   
c

c

then  construction g  know 
proposition   c v
node n g   



v

  w v v   w iff  n


c

    g   n

  nd vn

c

 

  nd wn

  g 

particular  g  represents lcs concept descriptions c following
sense 
corollary    infinite  concept description c   corresponding g  lcs c
d  i e   i  c  v c   ii  c  v e   implies c   v e   every  concept
description e    
g





g



g

    characterizing existence lcs

let c   concept descriptions let graphs g   g   g  g    g   g 
defined above 
show g  represents  possibly infinite  lcs  concept
descriptions c  corollary     g  used characterize existence
finite lcs  existence depends whether g  contains finite infinite number
so called same as nodes 
definition   node n  infinite  description graph h called same as node
c

exist two direct predecessors
may labeled differently  



n



h 



 the a edges leading

c

c

c








b







c

c

c

figure    subgraph g  g 
c 

   

d 

c

n



nodes

fiwhat s attribute 

example  graph depicted figure   contains infinite number same as nodes 
show sucient necessary condition lcs c  d 
exist 
helpful observe same as nodes g  one forms  g  f     f  t  
 t  f    g f non tree nodes tree node  cannot exist
same as node form  t   t     t  t  tree nodes  since tree nodes
exactly one direct predecessor  thus  t   t    does  moreover  g 
infinite number same as nodes  must infinite number same as nodes
form  f  t   t  f    exist finite number nodes g  form
 g  f    reason  following lemma characterize same as nodes
form  f  t    nodes form  t  f   dealt analogously   state lemma 
recall n un vn    h   graph h   describe path h labeled uv
n  n  passes node n  u  i e   n un    h n vn    h   
generalized obvious way interpret n u n u n u n    h  
g

 

 nc   nd  
v

w

 h    p   

x

 h    p   

g

  
 

  
 
  

v
h

w
h 

  
 x

 e    q   

 e    q   


e 

  

e 


n

   f  t 

figure    same as nodes g 
lemma   given node f g tree node g    node n    f  t  g 
same as node iff
c






exist nodes  h    p      h    p    g  h     h   
exist nodes  e    q      e    q    g    e    e  distinct nodes g
q  node g   
exists attribute   v  w  x     v    w  set attributes
c  
c







 n

c

   

   

       n

         
direct successors  h     p      h     p      h    p   

  nd v h    p  x e    q  f 

c

   

  nd w h    p  x e    q  f 

paths g   see figure    
 h    p    paths  we  addition  require p   tree node g    


   note since g
  deterministic  successors  h    p     h    p    two paths must fact
form    p     

   

steres  borgida
ku

direction obvious  proceed only if direction assume
same as node g   let p   uniquely determined  youngest ancestor
g    particular  p  node g exists p  xq  g   
x   successor p  path tree node g  
since n same as node reached via q  attribute a 
must exist e    e  g   e     e     e    q   a f  t    e    q  a f  t    g   since g 
connected  paths  n   n    e    q    e    q    every path n q 
must pass p  sux label path x  consequently  exist
nodes h    h  g  h    p   x e    q   a f  t   h    p  x e    q  a f  t  paths
g   particular  xa label path h  f g   label xa
consists attributes contained c   h    h   this  together fact g
deterministic  would imply e    e    hence  h     h    let v  w labels paths
 n   n    h    p     h    p    respectively  g deterministic h     h  
follows v    w 
ut
main results section stated next theorem  direct consequence
theorem  obtain exists lcs concept descriptions c 
d  example 
proof 
n









c

c





c

c

c

c



theorem   lcs c exists iff number same as nodes g  finite 

start proving only if direction  purpose  assume g 
contains infinite number same as nodes show  finite  lcs c
 
argued before  may assume g  contains infinite number same as nodes
form  f  t   t  f    tree node f non tree node  precisely 
say g  contains every   nodes n    f     f node g
tree node g   according lemma    every same as node n exist nodes
h    h    e    e  g   p  g   q  g  well   x  
properties required lemma   
since g g finite description graphs  number tuples form
h    h    e    e    f   finite  thus  must infinite number i s yielding
tuple h   h    e    e    f  a  particular  h     h  e     e  nodes g
infinite number same as nodes form n    f  t     finally 
lemma  let v  w label paths  in g   n   n    h    p     h    p    
now  assume lcs e c   according corollary    e c    
let g finite canonical graph e root n   proposition   lemma  
know e v vx   wx a  algorithm   follows words v   w    u
vx   v  u wx   w  u  paths g starting n  labeled v   
w  lead node g  
u       u   u a word u   then  algorithm   ensures e v vx   wx  
however  lemma   know words vx wx lead different nodes
g
    namely   e    q     e    q     which  proposition    leads contradiction
e g
   v vx   wx   thus  u     
result  every   exists node q g n vx aq n wx aq
paths g   g finite description graph  exist i  j       j  
proof 









c



 i

 i

 i

 i

c

c

 i

 i





 i



 i









 i

 i





c



c

 i





g

e











e

e





 i







 i





e





e

   

e









fiwhat s attribute 

  q   algorithm    implies e v vx   wx a  hand  path
starting  n   n   label vx leads node n one wx leads
n   since n    n   proposition   implies e  v vx   wx a  contradiction 
sum up  shown exist lcs c  
shows lcs c   completes proof only if
direction 
prove direction theorem    purpose  assume g 
finite number same as nodes  note every same as node g 
finite number direct predecessors  see this  two cases distinguished  i  node
form  g    g    g predecessors g  ii  tree node g non tree node 
predecessor  g  t  g  form  g    t   t  unique predecessor
 tree non tree node  g  non tree node  since number nodes g
g finite  cases finite number predecessors  then 
spanning tree g  coincides g  except finite number edges because 
contain certain edge  edge leads same as node  result  c  
 concept description finite conjunction same as equalities  finally 
corollary   shows c   lcs c d 
ut
v   w conjunct c     v w lead root g  same as node 
mentioned before  same as nodes form  f  g    f  t    t  f    tree
node f  g non tree nodes  consequently  v w must paths g g  
thus  contain attributes occurring c d 
qi

g
 

j



c

j







j





j





j

j

c



g

g

g

c



corollary   lcs two concept description c exists 
concept description containing attributes occurring c equivalent
lcs 

therefore  asking existence lcs  w o l g  assume set
attributes finite  fact used following two subsections 
    deciding existence lcs

following corollary derive desired decision algorithm existence
lcs two concept descriptions   state corollary need introduce
language l c  q    q      fw   j path node q  q  g labeled wg 
since description graphs viewed finite automata  language regular 
moreover  let aa denote set faw j w   ag attribute   a  finite
alphabet 
g

c

corollary   g  contains infinite number same as nodes iff either
 i  exist nodes  h    p      h    p    g well nodes f   e    e  g   attributes
a  b  
c

  

h 

   h    e     e   

  

p 

b successor g  

  

 e    a  f     e    a  f   edges g



c

 
   

steres  borgida
ku

  

 

lgc h    e 

    l c  h    e      ba infinite set words 
g


 ii  statement  i  r oles c



switched 

first prove only if direction  assume g  contains infinite number
same as nodes  then  w l o g   find configuration g  described proof
theorem    configuration satisfies conditions       stated corollary 
if     j   words x x coincide  conclude n   n g 
deterministic graph  however  definition  n    n   hence  x    x   finite 
can  w l o g   assume x  s b   first letter fixed b  thus 
condition    satisfied well  according configuration  b successor    p   
g
  form    p     p   tree node  thus  p  b successor
g   means condition    satisfied 
prove direction corollary  purpose  let bx   l c  h    e     
l c  h    e      ba   since p  b successor g follows tree nodes
t  t  g  p  bxtat    g    thus   h    p   bx e    t a f  t      g
 
 

 h    p   bx e    t a f      g   since e     e   conclude  e    t      e    t   means
 f  t   same as node  analogously    l c  h    e      l c  h    e      ba
tree nodes s  s  g  p bysas    g   f  s   same as node g  
since bx start b  b successor p  g  tree node  x   
implies s     t   hence   f  t    f  s   distinct same as nodes  shows
set l c  h    e      l c  h    e      ba infinite  g  must infinite number same as
nodes 
ut
given nodes  h    p     h    p    g  attributes a  b   a  nodes f  e   e    g conditions       corollary   obviously checked time polynomial size
concept descriptions c d  last condition  note automaton accepting
language l c  h    e      l c  h    e      ba constructed time polynomial
size c   furthermore  given finite automaton decidable time polynomial
size automaton accepts infinite language  see book hopcroft
ullman        details   thus  condition    tested time polynomial size
c well  finally  since size g g polynomial size c d 
polynomial number configurations need tested  together corollary  
complexities provide us following corollary 
proof 



j





j

j



j





g

g







g



g





g

g

c

g

g

c

corollary   given concept descriptions c decidable time polynomial
size c whether lcs c exists  
    computing lcs

subsection  first show size lcs two  concept descriptions may
grow exponentially size concept descriptions  stronger result
presented partial attributes  shown lcs sequence
concept descriptions grow exponentially  then  present exponential time lcs
algorithm  concept descriptions 
   

fiwhat s attribute 

gc  

 

gdk

 



c

c





b







c

c

b








k

figure    canonical description graphs c  

k

order show lcs may exponential size  consider following
example     fa  b  c  dg we define
       b 
c

   u   ac   ad u u   bc   bd u ac   bc a 
corresponding canonical description graphs g   g k depicted figure   
finite graph representing lcs c   depicted figure   k     
graph easily derived g   g k   graph comprises two binary trees
height k  thus  contains least   nodes  following  show
canonical description graph g k  with root n   representing lcs e c  
less   nodes  let x   fc  dg word length k fc  dg  let
v    axa  w    bxa  using canonical description graphs g   g k easy see
c   v v   w v v   w  thus  e v v   w  algorithm    means
words v   w    u v   v  u  w   w  u  paths n  labeled
v   w  g k leading node g k   suppose u       then  algorithm  
implies e v ax   bx  according g    v ax   bx  therefore u must empty
k

k



k









k

k





c

k



c

k

e

k

k

k

k



c





k



k

e

k

e







c



b





c

 
c





c













c







c



figure    finite graph representing lcs c   d 
   

steres  borgida
ku

word    proves g k path n  labeled axa every x   fc  dg  
hence  path every ax  now  let   fc  dg x    y  paths
ax ay n  g k lead node  implies e v ax   ay
contradiction c    v ax   ay  result  ax ay lead different nodes g k   since
fc  dg contains   words  shows g k least   nodes  finally  taking
account size canonical description graph concept description linear
size corresponding description obtain following theorem 
k

e

k

e

k





k

e

k

k

e

theorem   lcs two  concept descriptions may grow exponentially size
concepts 

following  exponential time  algorithm computes lcs two  concept descriptions
case exists 
algorithm  
input  concept descriptions c     lcs exists  
output  lcs c  
   compute g     g

g

c



 

   every combination

nodes  h    p      h    p   g   g g   h     h   
  a  e    e    f g   e     e     e    a  f    e    a  f   edges g
c



c

extend g  follows  let g


c

h   t

 g

h   t

two trees representing  finite  set words

 
l     l c  h    e      l c  h    e     
g

 

g

b

  succ 

p 

 

   
f g     succ p  
ba  

 

 

otherwise

succ p       fb j p  b successorg set nodes g     g    
g  assumed disjoint  now  replace root g    h    p     root
g    h    p     extend g  nodes edges two trees  finally 
add new node n every word v l  node trees g  
g   reachable root g   g   path labeled v   add edge
label n   extension illustrated figure    
h  t

h  t

h  t

h  t

v

h  t

h  t

h  t

h  t

v

   step    r oles c switched 
   compute canonical graph g    called g  again  then  output concept
description c   g   
g

proposition   translation
c d 

cg 

graph g  computed algorithm   lcs e
   

fiwhat s attribute 

 

g

 h    p   

 h    p   

b



b



b

n


c




c



bc

n








bad

n

figure     extension nodes  h    p     h    p    g  l   fb  bc  badg
easy see two paths g  labeled y  y  leading
root  n   n   node  g  contains paths well  consequently 
 e  g  v g  
now  assume e v y    y   y     y   proposition   know paths
g  labeled y  y  leading node n  w l o g  may assume n
same as node g   otherwise  exist words y    y     u y    y  u  y    y  u
y   y   lead same as node  show g  contains paths labeled y  
y   leading node  then  algorithm    sucient g  v y    y  
let n same as node  distinguish two cases 
   n node g   g g   paths y  y  paths g  since g
subgraph g  holds g  well  hence  c   v y    y  
   assume n node g  then  since n same as node  know n
form  f  t   t  f   f non tree node tree node  symmetry 
may assume n    f  t   easy see exist nodes h    h    e    e 
g   p  g   tree node q  g  well   x  v  w   specified
lemma   y    vxa y    wxa  then  h    h    e    e    p   f
preconditions algorithm   satisfied x   l  therefore  construction
g  paths labeled y  y   respectively  leading root
node 
ut
note product g g g computed time polynomial
size c d  furthermore  polynomial number combinations nodes
 h    p      h    p   g  e    e    f g     a  finally  finite automaton l
computed time polynomial size c d  particular  set states
automaton polynomially bounded size c d  l contained word
longer number states  accepting path automaton contains cycle 
then  automaton would accept infinitely many words  contradiction assumption
l finite  thus  length words l bounded polynomially
size c d  particular  means l contains exponential number
words  trees representing words computed time exponential size
c  
proof 

c











c



g

c





c



c

   



steres  borgida
ku

corollary   lcs two  concept descriptions exists  computed time
exponential size concept descriptions 
   conclusion

attributes   binary relations one value   distinguished
many knowledge representation schemes object centered modeling languages 
done facilitate modeling and  description logics  help identify tractable
sets concept constructors  e g   restricting same as attributes   fact  same as restrictions quite important practical point view  support modeling
actions components  borgida   devanbu        
second distinction  attributes total versus partial functions 
considered essential now  paper shown distinction sometime
significant effects 
particular  first shown approach computing subsumption
classic concepts total attributes  presented borgida patel schneider        
modified accommodate partial attributes  treating partial attributes roles
participate same as restrictions  case  converted  total attributes  result  obtain polynomial time algorithms subsumption
consistency checking case also 
case computing least common subsumers  introduced technique
learning non propositional descriptions concepts  first noted several
papers literature  cohen   hirsh      a  frazier   pitt         implicitly  used
partial attributes  considering classic  furthermore  papers used weaker
version  concept graphs  employed  borgida   patel schneider        
make results hold case same as restrictions generate  cycles  
furthermore  algorithm proposed frazier pitt        handle inconsistent
concepts  easily arise classic concepts result con icts lower
upper bounds roles 
therefore  provided lcs algorithm together formal proof correctness
sublanguage classic partial attributes  allows same as equalities
inconsistent concepts   algorithm proofs easily extended full classic
 kusters   borgida         case  lcs always exists  computed
time polynomial size two initial concept descriptions  shown cohen et al 
        sequences concept descriptions lcs may grow exponentially
size sequence 
complete picture  main part paper  examined
question computing lcs case total attributes  surprisingly  situation
different partial attribute case  unlike subsumption   first 
language lcs may even exist   the existence lcs mentioned cohen et al 
       due inadvertent switch partial semantics attributes   nevertheless 
existence lcs two concept descriptions decided polynomial time 
lcs exists  may grow exponentially size concept descriptions  hence
computation lcs may take time exponential size two given concept
descriptions 
   

fiwhat s attribute 

aside  note pointed cohen et al         concept
descriptions correspond finitely generated right congruence  furthermore 
context lcs two concept descriptions intersection right congruences  thus 
results presented paper show intersection finitely generated
right congruences always finitely generated right congruence 
polynomial algorithm deciding question  finally  intersection finitely
generated  generating system may exponential computed
exponential time algorithm size generating systems given right
congruences 
results paper therefore lay scope effect making attributes
total partial functions description logic supports same as constructor 
moreover  correct problems extend results previous literature 
believe disparity results two cases serve
warning researchers knowledge representation reasoning  concerning
importance explicitly considering difference total partial attributes 
acknowledgments

authors wish thank anonymous reviewers helpful comments 
research supported part nsf grant iri          carried
first author rutgers university rwth aachen 
references

artale  a   franconi  e   guarino  n     pazzi  l          part whole relations objectcentered systems  overview  data   knowledge engineering                  
baader  f          formal definition expressive power terminological knowledge representation languages  journal logic computation               
baader  f     kusters  r          computing least common subsumer
specific concept presence cyclic aln  concept descriptions  herzog 
o     gunter  a   eds    proceedings   nd annual german conference
artificial intelligence  ki     vol       lecture notes computer science  pp 
        bremen  germany  springer verlag 
baader  f   kusters  r     molitor  r          computing least common subsumers
description logics existential restrictions  dean  t   ed    proceedings
  th international joint conference artificial intelligence  ijcai      pp        
stockholm  sweden  morgan kaufmann publishers 
baader  f     sattler  u          tableaux algorithms description logics  proceedings international conference automated reasoning analytic tableaux
related methods  tableaux        vol       lecture notes artifical intelligence  pp       university st  andrews  scotland 
   

steres  borgida
ku

borgida  a          relationship description logic predicate logic 
proceedings third international conference information knowledge
management  cikm      pp          gaithersburg  maryland  acm press 
borgida  a          description logics data management  ieee trans  knowledge
data engineering                 
borgida  a     devanbu  p          adding  dl  idl  towards knowledgeable
component inter operability  proceedings      international conference
software engineering  pp          los angeles  ca usa  acm 
borgida  a     etherington  d          hierarchical knowledge bases ecient disjunctive reasoning  brachman  r     h j  levesque  r  r   eds    proceedings
 st international conference principles knowledge representation
reasoning  kr      pp        toronto  canada  morgan kaufmann publishers 
borgida  a     kusters  r          what s name  properties purely
structural approach integrating large dl knowledge bases  baader  f    
sattler  u   eds    proceedings      international workshop description
logics  dl       no     ceur ws aachen  germany  rwth aachen 
borgida  a     patel schneider  p          semantics complete algorithm subsumption classic description logic  journal artificial intelligence research             
brachman  r   mcguinness  d   patel schneider  p     borgida  a           reducing 
classic practice  knowledge representation theory meets reality  artificial
intelligence                     
calvanese  d   giacomo  g  d     lenzerini  m          knowledge representation semi structured data   proceedings   th national conference
american association artificial intelligence  aaai     pp           aaai
press the mit press 
calvanese  d   giacomo  g  d     lenzerini  m       a   modeling querying semistructured data  network information systems                 
calvanese  d   giacomo  g  d     lenzerini  m       b   reasoning expressive description logics fixpoints based automata infinite trees  dean  t   ed   
proceedings   th international joint conference artificial intelligence  ijcai      pp        stockholm  sweden  morgan kaufmann publishers 
calvanese  d   giacomo  g  d   lenzerini  m   nardi  d     rosati  r          description
logic framework information integration  cohn  a   schubert  l     shapiro  s 
 eds    proceedings  th international conference principles knowledge
representation reasoning  kr      pp       trento  italy  morgan kaufmann
publishers 
calvanese  d   lenzerini  m     nardi  d          unifying class based representation
formalisms  journal artificial intelligence research              
   

fiwhat s attribute 

cohen  w  w     hirsh  h       a   learnability description logics equality constraints  machine learning                    
cohen  w  w     hirsh  h       b   learning classic description logic  theoretical experimental results  doyle  j   sandewall  e     torasso  p   eds   
proceedings fourth international conference principles knowledge representation reasoning  kr      pp          bonn  germany  morgan kaufmann
publishers 
cohen  w   borgida  a     hirsh  h          computing least common subsumers description logics  swartout  w   ed    proceedings   th national conference
artificial intelligence  pp          san jose  ca  mit press 
devanbu  p     jones  m          use description logics kbse systems  acm
transactions software engineering methodology  tosem                  
frazier  m     pitt  l          classic learning  machine learning journal              
giacomo  g  d     lenzerini  m          tbox abox reasoning expressive description logics  aiello  l   doyle  j     shapiro  s   eds    proceedings  th
international conference principles knowledge representation reasoning
 kr      pp          boston  usa  morgan kaufmann publishers 
hopcroft  j     ullman  j          introduction automata theory  addison wesley publ 
co 
kusters  r     borgida  a          what s attribute  consequences least
common subsumer  tech  rep  dcs tr      rutgers university  usa  available via
ftp   ftp cs rutgers edu pub technical reports  
mcguinness  d     patel schneider  p          usability issues knowledge representation systems  proceedings   th national conference artificial intelligence
 aaai       th conference innovative applications artificial intelligence  iaai      pp          menlo park  aaai press 
mcguinness  d     wright  j          industrial strength description logic based
configurator platform  ieee intelligent systems                
minsky  m          framework representing knowledge  winston  p   ed   
psychology computer vision mcgraw hill  new york 
quillian  m          semantic memory  minsky  m   ed    semantic information processing  pp          cambridge  mass  mit press 
schmidt schau  m          subsumption kl one undecidable  brachman  r  j 
 ed    proceedings  st international conference principles knowledge
representation reasoning  kr      pp          toronto  ont  morgan kaufmann
publishers 
   


