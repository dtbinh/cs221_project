journal artificial intelligence research                  

submitted       published     

partial order planning concurrent interacting actions
craig boutilier

cebly cs toronto edu

department computer science
university toronto
toronto  on  m s  h   canada

ronen i  brafman

brafman cs bgu ac il

department computer science
ben gurion university
beer sheva  israel      

abstract

order generate plans agents multiple actuators  agent teams  distributed controllers  must able represent plan using concurrent actions
interacting effects  historically considered challenging task requiring
temporal planner ability reason explicitly time  show
simple modifications 
action representation language used represent
interacting actions  moreover  algorithms partial order planning require small
modifications order applied multiagent domains  demonstrate fact
developing sound complete partial order planner planning concurrent interacting actions  pomp  extends existing partial order planners straightforward
way  results open way use partial order planners centralized
control cooperative multiagent systems 
strips

   introduction
order construct plans agents multiple actuators  such multi armed robots  
agent teams  controllers distributed throughout environment  must able
model effects interactions multiple actions executed concurrently  generate plans take interactions account  viable solution basic
multiagent multi actuator planning  map  problem must include economical action descriptions convenient specify easily manipulable planning algorithms 
well planning methods deal interactions generally associated
concurrent actions 
surprisingly  despite interest multiagent applications for instance  robotics
 donald  jennings    rus        khatib  yokoi  chang  ruspini  holmberg  casal   
baader        distributed ai  e g   see various proceedings international
conference multiagent systems  and large body work distributed multiagent
planning  little research addresses basic problem planning context
concurrent interacting actions  researchers distributed ai considered many central
issues multiagent planning multiagent interaction  much existing research
concerned mainly problems stemming distributed nature systems 
task decomposition resource allocation  durfee   lesser        wilkins  
myers        stone   veloso         obtaining local plans combine form global plans

c      ai access foundation morgan kaufmann publishers  rights reserved 

fiboutilier   brafman

 durfee   lesser        ephrati  pollack    rosenschein         minimizing communication
needs  wolverton   des jardins        donald et al          on  opposed
form distributed planning  focus paper centralized planning agent
teams  or distributed actuators  
representation concurrent actions dealt various researchers
knowledge representation community  e g   lin   shoham        reiter        de giacomo 
lesperance    levesque        moses   tennenholtz        pinto         particular
note action languages ac  baral   gelfond        c  giunchiglia   lifschitz 
      enable specification concurrent interacting actions employ nonmonotonic override mechanism deduce effects set actions con icting
effects  finally  number contemporary planners handle concurrent noninteracting
actions certain degree examples include graphplan  blum   furst         ipp
 koehler         extends graphplan handle resource constraints  recently
obdd based planners mbp  cimatti  giunchiglia  giunchiglia    traverso       
umop  jensen   veloso        while knoblock        provides good discussion
issue parallelizing serial plans 
despite advances  one often sees planning community suggestions
temporal planners required adequately deal concurrent interacting actions 
example  discussion parallel execution plans  knoblock        asserts 
handle cases  of interacting actions  requires introduction
explicit representation time  provided temporal planning systems 
similar perspective seems implicit work parallel action execution presented
lingard richards         certainly time plays role planning in planner
idea sequences actions occur embodies implicit notion time  however 
disagree time centralized multiagent planning must dealt explicit
fashion single agent planning  main aim paper demonstrate
map problem solved using simple extensions existing  single agent  planners
ucpop  penberthy   weld         provide representation map algorithm
requires explicit representation time  deny explicit temporal
representations useful planning for many problems may necessary but
think key bottleneck planning activities multiagent teams 
specifically  view temporal issues orthogonal main concerns facing multiagent
planning 
central issue multiagent planning lies fact individual agent actions
interact  sometimes planning hindered result action interaction  action x
agent   might destroy intended effect action agent   executed concurrently 
example  half duplex communication line  cannot allow simultaneous transmission
messages sides  case  planning algorithm make sure
x executed time  interesting fact planning
often benefits result action interaction  action x agent   might achieve
intended effect agent   performs action concurrently  example  opening typical
door requires two simultaneous actions  turning knob pushing door  military
activities  different units may coordinate actions order effective  e g  
   

fiplanning concurrent interacting actions

turn engines lights simultaneously  attack time   similar situations
arise variety domains  cases  planning algorithm ensure
appropriate actions executed time  action representation makes
interactions explicit planning algorithm can  result interactions 
prescribe certain actions must must executed concurrently
main features multiagent planner  temporal representations may play role
scheduling actions  strictly necessary reasoning effects
interaction  or lack thereof  
illustrate issues  consider following example discussed
detail later paper  two agents must move large set blocks one room
another  could pick block separately  better solution would use
existing table following manner  first  agents put blocks table 
lift one side table  however  must lift table simultaneously 
otherwise  one side table lifted  blocks fall off  lifted
table  must move room  put table down  fact 
depending precise goal effects actions  may better one agent drop
side table  causing blocks slide once  notice generating
plan requires agents coordinate two different ways  first  must lift
table together blocks fall  later  one  and one  must drop
side table let blocks fall 
since actions distinct agents interact  cannot  general  specify effects
individual s actions without taking account actions might performed
agents time  truly concurrent actions often desirable precludes
oft used trick  interleaving semantics   reiter        de giacomo et al          agents
lifting table number items must simultaneously risk
items sliding table  perhaps causing damage  interleaving individual  lift side
table  actions do 
one way handle action interactions specify effects joint actions directly 
specifically  let ai set actions available agent  assuming n agents labeled
       n   let joint action space a  a    treat element
space separate action  specify effects using favorite action representation  
main advantage reduction scheme resulting planning problem
tackled using standard planning algorithm  however  serious drawbacks
respect ease representation  first  number joint actions increases exponentially number agents  severe implications specification
planning process  second  reduction fails exploit fact substantial fraction individual actions may interact all  least interact certain
conditions  would representation actions multiagent multi actuator settings
exploits independence individual action effects whatever extent possible 
instance  lift actions two agents may interact  many actions
 e g   one agent lifting table another picking block   hence  need
   discussion center strips action representation  similar considerations apply
representations situation calculus  mccarthy   hayes        reiter        dynamic bayes
nets  dean   kanazawa        boutilier   goldszmidt        

   

fiboutilier   brafman

explicitly consider combinations actions  specify certain individual
effects separately  combining effects  as needed  
joint actions cause problems planning process itself  use context
planners forces seems excessive degree commitment  whenever
individual action agent accomplish desired effect  must insert
plan joint action  thereby committing agents specific actions executed
concurrently  even though actual choices may irrelevant  reasons  desire
 distributed  representation actions 
therefore faced following two problems 
   representation problem  naturally concisely represent interactions
among concurrently executed actions 
   planning problem  plan context representation 
paper  show strips action representation augmented
handle concurrent interacting actions existing nonlinear planners adapted
handle actions  fact  might come surprise solving problems
requires small number changes existing nonlinear planners  ucpop
 penberthy   weld          main addition strips representation action
concurrent action list  describes restrictions actions  or cannot 
executed concurrently order specified effect  indeed  number
different conditional effects depending concurrent actions applied   order
handle richer language  must make number modifications  standard 
partial order planners   a  add equality  respectively  inequality  constraints action
orderings enforce concurrency  respectively  nonconcurrency  constraints   b 
expand definition threats cover concurrent actions could prevent intended
action effect 
emphasize deal problem planning activities multiple agents
agents multiple actuators centralized fashion  opposed distributed planning  model assumes one available central controller decide
appropriate joint plan communicate plan individual agents  or actuators  
distributed planning important dicult problem  problem addressed
work  assume mechanism available individual agents
ensure execution concurrent plans synchronized  again 
issue significance subtlety  task consider paper 
note planning parallel actions addressed detail lingard
richards         specifically  provide general framework understanding
constraint posting  least commitment planners allow concurrent action execution 
however  mentioned above  work takes explicit temporal view problem
focuses primarily issues action duration  furthermore 
multiagent planning could presumably made fit within model  seems
main motivation  fact  planning algorithms discuss deal
issue ensuring parallel actions negative synergistic effects  explicitly
   moreover  planning algorithms  e g   blum   furst        kautz   selman        prove
amenable extension planning concurrent interacting actions using similar ideas 

   

fiplanning concurrent interacting actions

exclude possibility positive synergy  work  abstract away temporal
component focus precisely planning presence synergies  positive
negative 
following section describe strips style representation concurrent 
interacting actions multiagent plans  section   describe partial order multiagent planning algorithm  pomp   modified version ucpop algorithm
used generate plans multiagent teams multiactuator devices  section   illustrates
pomp algorithm extended example  section   discuss soundness
completeness pomp algorithm  conclude section   discussion
issues raised work 

   representing concurrent actions plans

begin considering representation concurrent actions partially ordered plans
using simple extension traditional planning representations  first describe standard action representation based strips model  specifically used ucpop
 penberthy   weld         describe extension representation represent concurrent interacting actions semantics  finally describe representation
semantics partially ordered multiagent plans 

    strips action representation

variants strips action representation language  fikes   nilsson       
employed many planning systems  assume finite set predicates domain
objects  generally typed  characterize domain question  states system
truth assignments ground atomic formulae language  state represented
set  or conjunction  ground atoms true state 
f

ontable b     holding a  b   g

thus embodying closed world assumption  reiter         actions induce state transitions
viewed partial mappings states states  action represented
using precondition effect  conjunction literals  sometimes referred
precondition effect list   state satisfy conjunction literals
precondition list  effect applying action undefined  otherwise 
state resulting performing action determined deleting current state
description negative literals appearing effect list adding positive
literals appearing effect list 
example  action picking particular block b oor described
figure    using usual lisp style notation many planning systems  action
executed agent s hand empty block b clear oor 
action executed  agent s hand longer empty  it holds b    b
oor 
since action picking block location essentially same  regardless
particular block location  whole class actions described using
action schema operator free variables denoting object picked
   

fiboutilier   brafman

 define  action pickup block b from floor 
 precondition  and  on floor b   handempty   clear b  
 effect
 and  not  handempty    not  on floor b    holding b    

figure    pickup block b from  oor action
 define  operator pickup 
 parameters
  x  y 
 precondition  and  on  x  y   handempty   clear  x   not     x  y   
 effect
 and  not  handempty    not  on  x  y    holding  x    

figure    pickup action schema
pickup location  action schema specification similar specification single
action except use free variables  precondition list action schema
contain  along predicates  or precisely  proposition  schemata    equality
inequality constraints variables 
figure   illustrates action schema pickup action  two variables   x
 y   stand object picked location object  respectively 
precondition list includes requirements  x  y   hand empty 
 x clear   x  y designate different objects  i e   one cannot pickup
object atop itself  
strips representation enhanced  obtaining expressive language
allows form universal quantification action description  e g   ucpop
penberthy   weld         addition  conditional effects captured using
clause consisting antecedent consequent  semantics action description
similar original semantics except states satisfy preconditions
action antecedent clause  actual effect action union
 standard  effect specified effect list consequent clause 
clause change expressiveness language each conditional
action description expressed using separate non conditional actions classic
strips representation capture clause  however  allows economical natural specification actions  example  classic strips blocks world 
putting block b  destination block b    block b  longer clear  however 
putting b  table  table remains clear  hence  different putdown schema
required describe moving block table  using clause  use single
schema conditional effect modifies standard effect action case
destination table  i e   clause state destination
table  become unclear   addition  conditional effects may allow us postpone
commitment planning  e g   may decide put block down  don t
commit whether destination table not  

    representing concurrent actions strips

introduction concurrent interacting actions requires us address two issues specific
multiagent setting  performing action  actions
   

fiplanning concurrent interacting actions

 define  operator pickup 
 parameters
  a   x  y 
 precondition  and  on  x  y  handempty  a    clear  x  not     x  y   
 concurrent
 not  and  pickup  a   x  y   not     a   a     
 effect
 and  not  handempty  a     not  on  x  y    holding  a   x   

figure    multiagent pickup schema
performed time  first  deal identity performing agent
introducing agent variable action schema  schema instantiated 
variable bound constant denoting particular agent carrying action 
second  must take account fact action particular effect 
certain actions may may performed concurrently  capture constraints
adding concurrent action list existing precondition effect lists specification action  concurrent action list list action schemata negated action
schemata  partially instantiated  action schema a  appears
concurrent action list action instance schema a  must performed
concurrently action order intended effect  action schema a 
appears negated concurrent action list action instance schema a 
performed concurrently action prescribed effect 
concurrent action list similar precondition list following sense 
constraints specifies environment action performed
satisfied  action effects specified effect list  notice positive
action schemata implicitly existentially quantified one instance schema must
occur concurrently whereas negated action schema implicitly universally quantified 
instance schema performed concurrently 
schema a  appearing concurrent action list schema partially instantiated constrained  a  contains free variables appearing parameter list a 
variables must instantiated instantiated a  addition  constraints
restrict possible instantiations schema appear within concurrent
action list  seen description multiagent setting version action
pickup shown figure    multiagent pickup schema additional parameter   a  
signifying performing agent  list preconditions effects similar
single agent pickup schema  concurrent action list 
 not  and  pickup  a   x  y   not     a   a     

 not  prefix restricts set actions performed concurrently
instance schema pickup  a    x   y    particular  disallow concurrent execution
instance schema pickup  a    x   y    a  different  a  
is  agent attempt pickup object  x time 
using representation  represent actions whose effects modified
concurrent execution actions  example  suppose agent a  lifts
one side table blocks dumped onto oor long agent
a  lifts side  agent a  lift side table
effect simply raise side table  clearly  distinguish two
   

fiboutilier   brafman

 define  operator lower 
 parameters
  a   s  
 precondition  and  holding  a   s    raised  s   
 effect
 and  not  raised  s   
 forall  x
 when   ontable  x 
 not  and  lower  a   s   not     s   s      
 and  onfloor  x   not  ontable  x       

figure    lower action schema
cases using concurrency conditions  not  lift  a   side    lift  a   side  
however  treating standard concurrency conditions essentially splits action
two separate actions similar effects  single agent representations  treat
 modifiers  using clause  now  antecedent clause two
parts  list additional preconditions list additional concurrency conditions 
general form clause  when antecedent effect   antecedent
consists two parts   preconditions concurrency constraints   latter list
form concurrent action list  similar semantics  thus 
whenever precondition part antecedent satisfied current state
concurrency condition satisfied actions executed concurrently  actual effect
action obtained conjoining standard effect consequent
clause 
syntax clauses illustrated table lowering action described figure    notice operator contains universally quantified effect  is  effect
form  forall  x  effect  x    allows us state conditional effect 
described clause  applies object  x satisfies precondition  e g  
every object table case   use universally quantified conditional effects
finite domains well understood  see weld s        discussion   however  simplify
presentation  treat formally paper 
lower one side table  side longer raised  addition 
object table  lowering one side table cause object fall 
long side table lowered time  here  use
universal quantification describe fact happen object
table  notice concurrent part antecedent see constrained schema
again  stipulates additional effect  i e   objects falling oor
table  occur instance schema lower  a    s   executed concurrently 
 s  different  s   
action description clause  one clause  multiple
clauses  latter case  preconditions clauses must disjoint  
one might insist set clauses exhaustive well  however 
   certain cases might insist  a     a   agents perform one action time 
agent multiple effectors  to take one example  might able lower one sides
concurrently  see this 
   case multiple clauses  disjointness restriction relaxed effects independent 
much bayes net action description  boutilier   goldszmidt        

   

fiplanning concurrent interacting actions

require this  clause satisfied action performed  assume
 additional  effect null  is  effect action simply given main
effect list  discuss clauses specific action formal definitions
below  generally assume existence implicit clause whose precondition
consists negation preconditions explicitly specified clauses  whose
effect list empty  allows definitions stated concisely  

    semantics concurrent action specifications

semantics individual actions is  course  different multiagent setting
single agent case  individual actions transform one state world
another state world  rather joint actions define state transitions  joint
actions describe set individual actions  some could no ops  performed
agents  is  n tuples individual actions 
given joint action   ha      ani  refer individual actions ai elements
a  say concurrent action list element ai satisfied respect
when  every positive schema list  contains element aj  j    i 
instance a  every negative schema a  list  none elements
aj    j n  instance a   ignoring moment existence clauses 
define notion joint action consistency straightforward manner 

definition let   a     joint action individual action ai contains
h





clause  say consistent





precondition lists pi ai jointly  logically  consistent  i e  
contain proposition negation  
effect lists ei ai jointly consistent 
concurrent action list element satisfied w r t  a 

given state s  consistent joint action   ha     executed
precondition lists elements satisfied s  resulting state obtained
taking union effect lists elements applying s 
single agent case  fact  consistent joint action viewed single agent
action whose preconditions union preconditions various ai whose
effects union effects ai  
notice semantics  joint action inconsistent individual action
causes q true  another b causes q false  responsibility
axiomatizer planning domain recognize con icts either state true
effect b performed concurrently  by imposing conditional effects concurrent action conditions  disallow concurrent execution  by imposing nonconcurrency
conditions   
   assume clause ever explicitly constructed planning purposes it merely
conceptual device 
   one easily preprocess actions descriptions order check consistency  actions b
discovered con icting effects  specification allows executed concurrently 
algorithm could automatically add nonconcurrency constraint action description  thus

   

fiboutilier   brafman

clauses definition consistency bit involved  consistent joint
actions without clauses applied consistently possible states  if
applicable all   contrast  joint actions clauses may consistent
applied states  inconsistent others  given joint action   ha      ani
specific state s  exactly one clause action ai satisfied  is 
one clause preconditions concurrency constraints satisfied   thus
joint action state together determine conditional effects selected 

definition given joint action   a     state s  active clause wi
h





ai relative  unique  clause satisfied  i e  
whose preconditions satisfied whose concurrency constraints satisfied
a  

thus relativize notion consistency case 

definition let   a     joint action  where individual actions ai may contain
h





clauses   let state  let wi active clause ai  w r t  s 
a   let wi preconditions wpi  concurrency constraints wci  effects wei 
say consistent state if 





precondition lists pi active when preconditions wpi ai mutually consistent 
effect lists ei active when effects wei ai mutually consistent 
concurrent action list element satisfied w r t  a 

note require concurrent action lists clauses satisfied 
since  selected  a  note definition reduces  whenless 
definition individual actions clauses an action consistent respect
iff consistent original sense 
given state s  joint action   ha      ani  involving clauses  consistent
respect executed precondition lists elements satisfied
s  resulting state obtained taking union effect lists
elements a  together effect lists active clauses  applying
s 
several interesting issues arise specification actions multiple agents  first 
assume throughout rest paper agent perform one action
time  possible concurrent actions must performed distinct agents 
allows action descriptions simpler otherwise might  single
agent perform one action time  captured using group
 agents  denoting different actuators  agents perform certain actions
preventing problems arising planning process  would valid b could
not  fact   meaningfully  performed concurrently  can  important domain
axiomatizer specify true interacting effect  e g   maybe action dominates   note
automatic inconsistency detection repair admits certain additional degree convenience
domain specification 
   assume implicit clause corresponding negation explicitly stated clauses described
above 

   

fiplanning concurrent interacting actions

concurrently  captured adding extra concurrency constraints  generally 
different agents may different capabilities  would useful ability
explicitly specify capabilities form constraints types actions
different agents execute  one way handle constraints via preprocessing
step augments action descriptions additional preconditions concurrency
conditions capture constraints  alternative alter planning algorithm
take constraints account explicitly  simple constraints for
instance  fact n agents might imply n actions executed
concurrently this done simple ecient manner  approach
take planning algorithm develop section    however  capability
constraints complex  former method seems better 
another issue must addressed precise effect joint action  one
whose individual actions negates precondition concurrently executed individual
action  make special allowances this  simply retaining semantics described
above  complicate definition joint actions  note
combinations may make sense  example  concurrent writing variable p
q variable q p computer program might seen action destroying
preconditions other  yet net effect individual actions simply swap
values  hence  certain circumstances  may acceptable describe actions
way  others may true effect joint action  again 
treat issue several ways  allow specification actions design
planner excludes combinations forming concurrent plans unless
explicit concurrency condition given  this means axiomatizer need think
interactions   allow combinations  general  explicitly exclude
problematic cases adding nonconcurrency constraints 
finally  undesirable  though theoretically unproblematic  situation arise
provide  incongruous  concurrency lists  example  may require action concurrent b order particular effect  b may required nonconcurrent
 this span set actions two elements  naturally   hence 
b cannot occur together consistent joint action  would able achieve
intended effect a  although planner eventually  recognize  fact 
specifications lead unnecessary backtracking planning process  again 
something easily detected preprocessor  generally assume
concurrency lists congruous 

    concurrent plan representation
moving discuss planning process  describe representation multiagent plans  rather straightforward extension standard single agent  partially
ordered plan representations   single agent  nonlinear plan consists of      set action
instances      various strict ordering constraints using relations     ordering actions      codesignation non codesignation constraints values
variables appearing actions  forcing different values 
respectively  weld        penberthy   weld         plan sort represents set
possible linearizations  set totally ordered plans formed action instances
   

fiboutilier   brafman

violate ordering  codesignation  non codesignation constraints  
say plan consistent linearization  set linearizations seen
 semantics  nonlinear plan sense   consistent  nonlinear plan satisfies
goal set g  given starting state s  linearization guaranteed satisfy g 
concurrent nonlinear plan n agents  labeled         n  similar  consists set
action instances  with agent arguments  though necessarily instantiated  together
set arbitrary ordering constraints actions  i e              
usual codesignation non codesignation constraints  unlike single agent nonlinear plans 
allow equality inequality ordering constraints concurrent nonconcurrent
execution pair actions imposed  semantics must allow concurrent
execution actions n agents  end extend notion linearization 
definition let p concurrent nonlinear plan agents         n  n linearization
p sequence joint actions a   ak agents         n
   individual action instance p member exactly one joint action ai  
   individual action occurs a    ak p   individual
no op actions 
   codesignation non codesignation constraints p respected 
   ordering constraints p respected  precisely  individual
action instances b p   joint actions aj ak b
occur  ordering constraints b true aj ak   is 
af           gb  j f           gk 
words  actions p arranged set joint actions ordering
individual actions satisfies constraints   synchronization  ensured no ops 
note set k actions  which allowed executed distinct
agents  ordering constraints  set linearizations includes  short  plan
single joint action k actions executed concurrently different agents
 assuming k n    strung out  plan k actions executed one time
single agent  others nothing  or different agents take turns
individual actions    longer  plans stretched even joint no ops  anything
between 

example suppose planner outputs following plan group three agents 
set actions

f

a     b     c     d     e     f    

g

ordering constraints

e      b     c      d     a      e     d      f    

f

 

g

here  numerical arguments denote agent performing action  joint actions
involve one action three agents  simple   linearization plan 
depicted first linearization figure    using n denote no ops
   concurrent execution considered context non interacting actions  see knoblock s
discussion issue  knoblock        

   

fiplanning concurrent interacting actions

time

 

 

 

 

 

time

 

 

 

agent  



e

n

n

n

agent  



e

n

agent  

n

b

c

n

f

agent  

c

b

f

agent  

n

n

n



n

agent  

n



n

linearization  

linearization  

figure    two possible linearizations partially ordered multiagent plan
corresponding agents is 
           i h            i

ha

 n

 n

  e

 b

 n

  hn

           i
 c

 n

  hn

           i
 n

 d

  hn

           i
 f

 n

insert additional tuples form hn      n      n    i location
wish  another possible   linearization  the second figure    is 

a     c     n       e     b     d      n      f      n    

h

h

h



fact  shortest   linearization plan 
definition n linearization requires agent perform one action
time  conforms assumption made last section  though definition could quite easily relaxed allow this  no ops  n linearizations
correspond shortest plans  either concurrently nonconcurrently executed
senses term  however  relatively easy matter  sweep through  concurrent nonlinear plan construct shortest n linearization  one fewest joint
actions  taking least amount  time   though explicit notion
time  sequence joint actions n linearization implicitly determines time line
along agent must execute individual actions  fact concurrency
nonconcurrency constraints enforced linearizations ensure plan coordinated synchronized  note order execute plan coordinated
fashion agents need synchronization mechanism  issue dealt
paper 

   planning concurrent actions

figure    present pomp algorithm  version weld s pop algorithm  weld 
      modified handle concurrent actions  keep discussion simple  begin
describing pomp without considering conditional action effects  describe
simple modifications required add conditionals  i e   build analog cpop  
though discuss universal quantification paper  algorithm could easily
extended handle universally quantified effects much way penberthy
weld s        full ucpop algorithm 
   

fiboutilier   brafman

pomp ha  o  l  nc b i agenda  
termination  agenda empty  return ha  o  l  nc b i 
goal selection  let hq  aneed pair agenda    aneed action q conjunct
precondition list  
action selection  let aadd   choose action one whose effects unifies q subject constraints b    this may newly instantiated action action already
ordered consistently prior aneed   action exists  return failure  let
q g  form b adding b codesignation constraints needed
l   l   faadd  
need
order force aadd desired effect  let     faadd   aneed g  aadd newly
instantiated      faadd g     fa    aadd   g  otherwise  let   a  
concurrent action selection  aadd newly instantiated apply following steps positive
actions ffconc concurrent list  let aconc   choose newly instantiated action
action already ordered consistently concurrently aadd  make sure
free agent perform action concurrently aadd concurrently
scheduled actions  action exists return failure  let     faconc   aneedg 
aconc newly instantiated      faadd g     fa    aconc   g  otherwise 
let   a   aadd agent variable aadd aconc agent variable aconc  
add aadd    aconc b   well similar non codesignation constraints actions
  aadd   o 
re apply step aconc   needed 
every negative action conc aadd concurrent list let nc   nc   fa conc    aadd g  add
b codesignation constraints associated conc  
updating goal state  let agenda   agenda   fhq  aneedig 
aadd newly instantiated  add fhqj   aaddig agenda every qj logical precondition aadd  add preconditions b   additional concurrent actions added  add
preconditions well 
causal link protection  every action might threaten causal link ap  r ac perform one
 a  demotion  add   ap  
 b  weak promotion  add ac   agent perform concurrently ac   add
  ac  instead 
neither constraint consistent  return failure 
nonconcurrency enforcement every action threatens nonconcurrency constraint   
 i e   instance schema violate constraint b   add consistent
constraint  either
 a  demotion  add    
 b  promotion  add    
neither constraint consistent  return failure 
recursive invocation  pomp ha     l   nc   b i agenda   
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

figure    partially ordered multiagent planning algorithm

   

fiplanning concurrent interacting actions

assume existence function mgu q  r  b   returns general
unifier literals q r respect codesignation constraints b  
used wherever unification action schemata required  see action selection step
figure   discussion nc threats below   algorithm number input
variables  set contains action instances inserted plan far  set
contains ordering constraints elements a  set l contains causal links  set
nc contains nonconcurrency constraints  set b contains current codesignation
constraints  set nc appear pop algorithm contains elements
form    a    action schema action instance a 
intuitively  nonconcurrency constraint form requires action instance a 
matches schema subject  non  codesignation constraints appear
concurrently plan 
agenda set pairs form hq  ai  listing preconditions q
achieved yet actions require them  initially  sets l  nc   b
empty  contains two fictitious actions a  a    a  initial
state propositions effects a  goal state conditions preconditions 
agenda contains pairs hq  a  q one conjuncts description
goal state  specification initial agenda identical used pop
 weld         finally  note choose operator  appears action
selection concurrent action selection steps  denotes nondeterministic choice 
again  device used pop make algorithm specification independent
search strategy actually used planning  intuitively  complete planner require
one search nondeterministic choices  backtracking lead failure 
many structures algorithmic steps pomp correspond exactly
used pop  rather describe detail  focus discussion elements
pomp differ pop  apart additional data structure nc mentioned
above  one key difference additional concurrent action selection step pomp 
takes care concurrency requirements newly instantiated action 
one final key distinction notion threat used pomp  general
used pop  much pop  given plan ha  o  l  nc i  say
q   fa   g consistent   q
threatens causal link ap  
c
p

c

effect  threats handled using demotion  much pop   weak promotion 
latter differs standard promotion technique used pop  allows
ordered concurrently ac   ac   
apart handling conventional threats different manner  another form
threat concurrent plans  namely  nc threats   say action instance threatens
nonconcurrency constraint    ac   fat   ac g consistent instantiation
violate codesignation constraints  demotion promotion
used handle nc threats  conventional threats  notice
although set nc contains negative  inequality  constraints  ultimately
grounded set positive constraints o  following approach suggested weld
   wish exclude actions negate precondition another concurrent action  see discussion
section     must use   fap ac g definition threat  must change weak
promotion standard promotion 

   

fiboutilier   brafman

        consider action threat variables consistently
instantiated manner would remove threat 
pomp algorithm must check consistency ordering constraints several
places  action selection action chosen achieve effect must consistently ordered consumer effect  concurrent action selection
concurrency requirement added plan must tested consistency 
nonconcurrency enforcement demotion promotion used ensure
nonconcurrency requirements violated  consistency testing set ordering
constraints similar employed pop  see weld        nice discussion   one key difference  existence equality     inequality      ordering
constraints opposed simple strict inequalities  i e         however  minor
modifications  standard consistency checking algorithms strict ordering constraints
used  equality dealt simply  merging  actions must occur concurrently  i e   treating single action purposes consistency testing  
inequalities easily handled assuming actions occur different points whenever
possible  non strict inequalities  i e     arise directly algorithm
 though two easily dealt with   refer ghallab alaoui       
details processing constraints 
pomp algorithm described easily modified handle conditional effects 
pop algorithm extended cpop  main fact note
action selection phase  use action whose conditional effects achieve chosen
subgoal  case  add preconditions selected action
agenda  antecedent particular conditional effect  this ensure
action particular effect   handle additional concurrency conditions
antecedent much regular concurrency conditions  cpop algorithm 
must consider possibility particular conditional effect added action
threatens established causal link  case  can  aside using existing
threat resolution techniques  consider form confrontation   add negation
conditional effect s antecedent agenda  again  several ways
this  could add negation literal antecedent s condition agenda 
add concurrent action negate negative concurrency condition
antecedent  post nonconcurrency constraint offset positive concurrency constraint
antecedent  details steps straightforward look similar
involved unconditional algorithm 

   example pomp algorithm
section  formalize example alluded introduction describe
construction concurrent plan problem using pomp algorithm 
initial state  two agents  agent  agent   located room   together
table set blocks scattered around room  goal ensure
blocks room  table oor  order simplify example 
assume one block b   omit certain natural operators  simplify action
descriptions  order compactly represent multiple block version this  would
require introduction universal quantification  shown weld        
   

fiplanning concurrent interacting actions

done little diculty  intuitively  agents gather blocks room
 in case one   put table  carry table room  dump
blocks table  put table down  best plan
single block  illustrates plan would constructed multiple blocks
 in case strategy better agents making multiple trips carrying
individual blocks   use following actions 







pickup a  b   agent picks block b
putdown a  b   agent puts block b table
totable a  s   agent moves side  left  right  table
movetable a  r   agent moves room r table
lift a  s   agent lifts side table
lower a  s   agent lowers side table

variables type agent   b variables type block   r variables type room  
variables type table side   we omit natural actions since won t
used plan interest  
domain described using following predicates 









ontable b   block b table
onfloor b   block b oor
atside a  s   agent side  left  right  table
up s   side table raised
down s   side table oor
inroom x  r   object x  agent  block  table  room r
handempty a   hand agent empty
holding a  x   agent holding x  block  side table 

operator descriptions defined figure   
initial state planning problem is 
inroom b  room    onfloor b    inroom agent   room    inroom agent   room   
inroom table  room    down leftside   down rightside g

f

goal propositions are 
inroom b  room    onfloor b    down leftside   down rightside g

f

consider concurrent nonlinear plan multiagent planning problem
might generated pomp 
   

fiboutilier   brafman

 define  operator pickup 
 parameters
  a   x 
 precondition  and  inroom  a   r    inroom  x  r  
 handempty  a    onfloor  x  
 concurrent
 and  not  pickup  a   x    not     a   a    
 effect
 and  not  handempty  a     not  onfloor  x    holding  a   x   
 define  operator putdown 
 parameters
  a   x 
 precondition
 and  inroom  a   r    inroom  x  r    inroom table  r  
 holding  a   x  
 concurrent
 not  lift  a   s   
 effect
 and  not  holding  a   x    ontable  x   handempty  a    
 define  operator totable 
 parameters
  a   s  
 precondition  and  inroom  a   r    inroom table  r    not  atside  a   s    
 concurrent
 and  not  totable  a   s     not     a   a    
 effect
 atside  a   s   

 define  operator movetable 
 parameters
  a   r  
 precondition  holding  a  table 
 concurrent
 and  movetable  a   r    not     a   a    
 effect
 and  inroom  r  table   inroom  r   a  
 when   ontable  x       inroom  r   x    
 define  operator lower 
 parameters
  a   s  
 precondition  and  holding  a   s    up  s   
 concurrent
 and  not  lift  a   s     not     a   a     not     s   s    
 effect
 and  not  up  s    down  s    not  holding  a   s   
 when   and  ontable  x   up  s    not     s   s    
 and  not  lower  a   s     not     a   a     
 and  onfloor  x   not  ontable x      
 define  operator lift 
 parameters
  a   s  
 precondition  and  atside  s   a    down  s    down  s    not     s   s    
 concurrent
 and  not  lower  a   s     not     a   a     not     s   s    
 effect
 and  not  down  s     up  s    holding  a   s  
 when   and  ontable  x   down  s    not     s   s    
 and  not  lift  a   s     
 and  onfloor  x   not  ontable x      

figure    table movers domain

   

fiplanning concurrent interacting actions

suppose inroom b  room   first goal selected  achieved performing a    movetable a   room   via conditional effect  note a  agent variable  commitment agent performs action     must add
holding a   table  ontable b   agenda insert appropriate causal links 
addition  concurrent list forces us add action a    movetable a   room  
plan together non codesignation constraint a     a   ordering constraint
a    a  added well  add a   must add precondition holding a   table 
agenda well  structure partially constructed plan might viewed
follows   
inroom block  r  

a 

goal

movetable a  r  

a 

c

movetable a  r  

next  choose subgoal ontable b   agenda  which added  
add action a    putdown a   b   plan appropriate ordering constraint
a    a   preconditions added agenda causal link added l 
addition  must add nc nonconcurrency constraint not lift a  s    agent
lift side table block placed desired effect
achieved 
inroom block  r  

ontable block 

a 
putdown a  block 

a 

movetable a  r  

goal

c

a 

movetable a  r  

    pursue notion heuristics action selection here  note action
plausible candidate selection multi block setting  goal list asserts number
blocks second room  single action moving table achieve
appropriate conditions  i e   blocks table   action selection favors  conditional 
actions achieve goals subgoals  action considered actions needed
 one one  transport blocks individual agents  choice silly might
seem single block setting 
    plan diagrams follow  indicate actions ai name action it  variables
indicated lower case names  we indicate co designation constraints diagrams  
arrow one action another denotes causal link  from producer consumer   labeled
proposition produced  large arrows labeled c  resp  nc  denote concurrency  resp 
nonconcurrency  constraints actions  use left to right ordering denote temporal
ordering actions  constraints exist 

   

fiboutilier   brafman

choose subgoal holding a   table   achieved using a   
lift a   s    ordering constraint a    a    preconditions added
agenda  concurrency conditions added  yet   action  since
yet need invoke conditional effects action induced simultaneous lifting
side table 
holding a  table 

a 
lift a  ls 

inroom block  r  

nc ontable block 

a 

a 

putdown a  block 

goal

movetable a  r  
c

a 

movetable a  r  

note conditional effect a  poses threat causal link a  ontable
 
a   lifting single side table dump block table 
addition  nonconcurrency constraint associated a    lifting performed
concurrently a    threatened a   an nc threat   indicated plan diagram
above  confrontation strategy used handle first threat  action a   
lift a   s   scheduled concurrently a    constraints s     s  a     a 
imposed  ensures undesirable effect occur  resolve nc threat
ordering a  a      resulting partially completed plan free threats 
holding a  table 

a 
lift a  ls 

inroom block  r  
ontable block 

a 
putdown a  block 

c

a 

movetable a  r  

goal

c

a 

a 

lift a  rs 

movetable a  r  

next  choose subgoal down leftside   achieved using action a   
lower a   leftside  preconditions added agenda  completely similar
way  a    lower a   rightside  added achieve down rightside   again  anticipate
unification agent variables  
    anticipation subsequent step  use variable a  plan diagram instead a   since
soon unified  keep things concrete  replaced s  s  particular sides
table  leftside rightside  make discussion bit less convoluted 

   

fiplanning concurrent interacting actions

a 
lower a  ls 
down ls 

a 

holding a  table 

lift a  ls 
ontable block 

inroom block  r  

a 

a 

putdown a  block  c

movetable a  r  

goal

c

a 

a 

lift a  rs 

movetable a  r  

a 

down rs 

lower a  rs 

choose work preconditions a  a    preconditions 
up s  holding a  s   effects lift  use a  a  producers 
stage  a  a  constrained follow a  a    constraints
relative ordering a  a  themselves  see a  a 
 potentially  threaten causal link a  ontable
 
a   is  conditional
effect would cause block fall table  several ways resolve
two threats  including confrontation  choose strict promotion  order a 
a  occur a  a   
holding a  ls 
up a  ls 

a 

a 
lower a  ls 

holding a  table 

down ls 

lift a  ls 
ontable block 



 

putdown a  block 

c

a 
lift a  rs 

inroom block  r  

a 

movetable a  r  

goal

c

a 

movetable a  r  

down rs 

a 
lower a  rs 
up a  rs 
holding a  rs 

now  choose subgoal onfloor b    conditional effect lower
action  choose accomplish using existing action  a    order obtain
desired effect  ensure antecedent clause effect holds  involves
adding conditions antecedent  ontable b   up leftside   agenda 
imposing nonconcurrency constraint antecedent  namely  concurrent
lower action take place  constraint threatened action a    order
   

fiboutilier   brafman

a  a  posting constraint a    a     conditions antecedent 
ontable b   up leftside   use a  a  producers  respectively 
ontable block 
holding a  ls 
up a  ls 

a 

a 
lower a  ls 

holding a  table 

down ls 
onfloor block 

lift a  ls 
ontable block 



 

putdown a  block 

c

inroom block  r  

a 

movetable a  r  

goal

c
holding a  table 
 
lift a  rs 
movetable a  r  

a 

down rs 

a 
up a  rs 

lower a  rs 

holding a  rs 

unsolved subgoal precondition initial putdown a   b   action
 others  down leftside  lift action  produced initial state  
don t illustrate it  simple matter introduce pickup a   b   action
putdown a   b   
following plan  first  block picked put table
agent a   either agent  agent  this   followed two concurrent
lift actions two concurrent move actions get table room
block top  next  single lower action  makes block fall off  followed
another lower action ensures sides table oor 
note plan care agents  the one lifts leftside
rightside  initially puts block table   

   soundness completeness pomp algorithm
say planning algorithm sound generates plans guaranteed
achieve goals posed it  complete algorithm guaranteed generate plan
successful plan exists    case concurrent nonlinear plans  say
algorithm sound n linearization plan produced given problem
reach goal state  algorithm complete successfully generates concurrent
nonlinear plan whenever sequence joint actions  i e   n linearization
    ordering a    a  could used resolve threat  would cause  unresolvable  threat conditions antecedent  require side remain up  is 
course   unresolvable  sense would require agents pick block  etc  
essentially introducing cycle plan 
    examples map problems  plans produced pomp  code implementing pomp
algorithm obtained http   www cs bgu ac il ishayl project  
    formal definitions concepts  refer reader  penberthy   weld        

   

fiplanning concurrent interacting actions

concurrent plan  achieves goal initial state  show pomp
algorithm sound complete 
soundness proof straightforward  suppose generated plan sound 
thus  n linearization plan achieve goal required subgoal
 i e   precondition one plan s actions   agenda mechanism 
clear needed goal precondition exists action plan
achieves subgoal  goal precondition   moreover  explicit causal link
plan particular subgoal well ordering constraint requiring
producing action appear prior consuming action  or goal   n linearization
plan another plan obtained original plan adding new  consistent  strict
 i e        ordering constraints  recall original plan s ordering constraints must
consistent  otherwise would constitute solution 
threats  clearly  adding new strict ordering constraints cannot cause new threats
causal links violate nonconcurrency constraint  hence  resulting n linearization
respects causal links original plan ordering constraints original plan 
complete proof  must convinced pomp actually considers possible 
relevant interactions actions  consider effect p action needed
action b ordered a  given semantics actions  two reasons
p hold prior execution b      action c b  possibly
concurrent a  effect  p       actually p effect  case    
contradicts fact threats  in extended sense  covering possibility
c occurring concurrently a  context plan  case     implies either
p effect subject concurrency nonconcurrency condition violated
n linearization  problem would taken care action
selection nonconcurrency enforcement steps  and ordering constraints  
thus clear n linearization plan produced pomp fact
achieve goals  is  pomp sound 
completeness proof rests three key elements 
   reduction multiagent planning problems single agent planning problems 
   fact pomp solve multiagent planning problem iff pop solve
single agent planning problem obtained via reduction 
   fact pop sound complete  penberthy   weld        
first  show given multiagent planning problem  similar single agent planning
problem obtained  shall refer generated problem equivalent single
agent planning problem  or esa problem   reduction property plan
multiagent planning problem exists plan esa problem exists 
introduction  discussed reduction via use joint actions  here 
use similar idea  little care pomp pop perform
similar steps solution original problem esa problem  respectively 
combining results fact pop sound complete  deduce
pomp sound complete well 
   

fiboutilier   brafman

discussion below  ignore conditional effects avoid undue and 
part  uninteresting complications  extension arguments deal conditional
effects straightforward  first recall following facts relevant argument 
 a  pop pomp nondeterministic planning algorithms and  although
various ways making deterministic  issue orthogonal
proof  thus  showing correspondence pop pomp alluded
point     above  utilize exibility awarded us planner s
use nondeterministic choice  particular  sucient show
given solution path one planner  similar solution path exists other 
 b  choice next agenda element work immaterial pop
pomp it affect running time  e g   causing backtracking 
existence solution  hence  exible ordering subgoals
achieved  long respect causality  i e   cannot achieve goal
derived precondition action introduced yet  
 c  introducing additional ordering constraints consistent current constraints
valid plan  obtain valid plan given problem 
 d  precise order actions ordering constraints inserted
affect validity solution  fact  well known planning
community  one postpone threat resolution step without affecting
soundness completeness algorithm  long threats eventually
resolved 
proof proceed two stages  first stage  limit
restricted set planning problems show connections pop
straightforward fashion  relax restriction show correspondence
two planners general case 
recall section     suggested possible restriction set actions one
allowed execute concurrently  namely  two actions b permitted
occur concurrently one s effects negate other s preconditions  remarked
concurrent  non clobbering condition  enforced action specification
itself  easily enforced pomp algorithm modify definition threat
use promotions instead weak promotions resolve threats  let us restrict attention 
time being  domains respecting condition 
first note following fact  let pomp plan  consider nlinearization a  a  occur concurrently 
future actions require effects produced concurrent execution actions 
is  actions a  a  forced occur concurrently plan   case 
similar n linearization a  ordered a    vice versa 
ordering constraints violated  some linearization must exist  achieve
goal  case might happen one a  a  clobbers
other s preconditions  explicitly disallowed restricted setting  by
imposition nonconcurrency constraint  precondition   
   

fiplanning concurrent interacting actions

consider esa problem  actions available agent follows 
individual action concurrency constraints multiagent problem 
create action corresponding joint action performed  owning 
agent  no ops executed every agent  individual action
concurrency conditions  requiring actions b   bk executed concurrently 
create action corresponding joint action bi performed 
actions apart no ops performed    note nonconcurrency
constraints ignored esa problem definition 
clearly  joint action sequence exists given problem  exists concurrent nonlinear plan problem  addition  argument involving
assumption concurrent action clobber another s precondition  easy
see that  concurrent nonlinear plan found problem  exists
concurrent nonlinear plan concurrency constraints involve actions whose
specification requires concurrent execution another action  or set actions  order
obtain particular effect  implies that  problem solvable  solvable
sequence joint actions type constructed above  using single agent individual actions together set no ops  involving minimal sets interacting
actions  words  concurrent nonlinear plan exists given problem iff plan
esa problem exists  note structure solution esa problem
 or linearization nonlinear single agent plan esa problem  specific 
actions occur concurrently forced to  words  solutions esa
problem strung plans  agents  take turns  performing actions 
next  want show  in restricted setting  pomp s solution path given
planning problem pop s solution path esa problem resemble other 
becomes apparent combine pomp s action selection concurrent action selection
steps  obtain step equivalent action selection step pop esa
problem  i e   whenever pomp chooses action requires another concurrent action 
required concurrent action immediately inserted well  equivalent inserting
proper esa action   fact  pop pomp look almost identical  except
pomp s nonconcurrency enforcement step  however  fashion
esa problem defined  nonconcurrency constraints automatically  imposed 
plan produced pop since refer different joint actions  linearization
joint actions enforces nonconcurrency joint actions  therefore 
 single agent  actions occur together pop s solution esa problem
occur together nonconcurrency constraint   in
fact  actions explicit concurrency constraint    
argument demonstrates pop pomp generate  identical  sets
plans  except two small differences  first  pomp s semantics allows concurrent
execution certain actions  even though need executed concurrently order
    important note single action schema gives rise n individual actions  one
agent  e g   lift agent   s  lift agent   s  distinct actions  separate joint actions
created   similarly  concurrency conditions involve action schemata  permitted
combination agent instantiations give rise distinct joint action 
    assumes concurrency lists congruous  described section    if  not  simple
redefinition esa problem given  incongruous  concurrent actions admitted 

   

fiboutilier   brafman

solve problem  pop  for esa problem  cannot generate plans admit
this  however  difference cannot affect completeness argument  since means
pomp exible pop     second  pomp commits particular ordering
actions nonconcurrency constraint  pop make
commitment orderings consistent  however  consistent  and remain
unordered final plan esa problem  choice pomp makes cannot
impact solution  and pomp produce either alternative ordering matter  
now  using fact pop sound complete  virtual equivalence pomp
pop steps  facts strung plans esa problem  see pomp
sound complete special case concurrent actions destroy
other s preconditions 
finally  wish remove restrictions placed concurrent actions  admit
problems concurrent action clobber precondition another  note
problems type exist cannot solved strung plan sense defined
above  instance  consider following problem  two actions 


action a  precondition p   effect q



action b  precondition  q  effect  p

actions b nonconcurrency constraints  thus required
concurrent specified effects considered isolation  suppose initial
state fp   qg goal state f p  qg  plan achieves goal requires
b executed concurrently  order one other  destroy
ability perform second  goal reachable  thus  pomp solve
problem pop could solve esa problem  as formulated above  
deal general case  extend construction esa problem
including  in addition actions used restricted case  joint action esa
problem set actions satisfying following conditions 


element permitted executed concurrently  but need forced
concurrent  



element clobbers precondition element a 



element removed without destroying property 

words  create joint action corresponding concurrent execution
element set a  we ll call  self clobbering  joint actions  evident
concurrent nonlinear plan exists arbitrary multiagent planning problem iff
exists sequence joint actions  allowing self clobbering actions  solve problem 
hence  by soundness completeness pop  iff pop find plan
generalized esa problem  already seen pomp emulate step pop
    additional exibility impacts soundness pomp  and addressed above   fact 
could used current line reasoning part integrated soundness completeness proof
based pop pomp correspondence  case  would need explain last point
hinder soundness pomp 

   

fiplanning concurrent interacting actions

involving actions self clobbering actions  simply show pomp
emulate pop s introduction self clobbering actions show completeness 
let self clobbering joint action  claim pop complete  for
generalized esa problem  ever considers adding incomplete plan
elements ai   effect satisfies subgoal agenda  suppose 
contrary  ai   consumer current agenda  either
necessary successful plan  since subset actions used  
actions consume effects ai yet introduced  discount
former case considering executions pop use action  pop
complete even action never considered  since able introduce
individual components  or concurrent subsets  produce necessary effects 
discount latter case  since must valid execution pop introduces
 ultimate  consumers element ai introducing a  thus  without loss
generality  assume element ai   satisfies subgoal agenda
introduced pop 
suppose pop introduces self clobbering action a  since ai   satisfy
agenda item  pomp simulate step follows  introduce ai turn satisfy
agenda item  postponing threat resolution among ai   resolve self threats among
ai weak promotion causal link protection step  so impose
ordering constraint ai aj ai threatens aj    example above  instance 
actions b added achieve subgoals q  p   respectively  way
resolve mutual threat weak promotion actions  is  impose b
b a  words  forced concurrent  thus introduction
self clobbering joint action pop  under assumptions stated above  strong
correspondence sequence possible steps pomp  since pop always find
plan assumptions  pomp  thus completeness pomp
general case arbitrary multiagent planning problems demonstrated 

   concluding remarks
one often finds assertions planning literature planning interacting actions
inherently problematic affair  requiring substantial extension existing single agent
planning representations algorithms  thus  somewhat surprising minor
changes needed enable strips action representation language capture interacting actions  relatively small modifications existing nonlinear planners
required generate concurrent plans  solution involves addition concurrent
action list standard action description  specifying actions
scheduled concurrently current action order achieve desired effect 
pop planner augmented two steps  one handles insertion required
concurrent actions  one handles threats emanating potential concurrent
execution two interfering actions  addition  explicit reasoning equality inequality constraints introduced  strong resemblance solution
multiagent case solution single agent case  little overhead incurred
actions interact  fact  extreme case non interacting actions 
extension strips pop reduce single agent equivalents 
   

fiboutilier   brafman

close connection specification method knoblock s       
approach generating parallel execution plans  knoblock adds action description
list describes resources used action  actions require resource
 e g   access database  cannot scheduled time  hence  knoblock s
resource list actually characterizes one form nonconcurrency constraint    fact 
believe certain nonconcurrency constraints naturally described using
resource list general method proposed here augmenting language
lists prove dicult 
treatment concurrent actions specification languages ac  baral   gelfond        c  giunchiglia   lifschitz        many features common
extension strips  although c   particular  expressive language many
additional features   languages allow use complex actions which sets
primitive actions analogous ability provide combine number elements
joint action  typically  complex actions inherit effects primitive actions contained them  however  explicit specification effects complex actions
possible  overriding inheritance  overriding mechanism extend arbitrary
number levels  e g   action effect  overridden b
performed concurrently  effect overridden c performed well 
etc    action description languages  implicit view time adopted  much
treatment  concurrent actions assumed performed simultaneously  quite recently  tools actually synthesizing plans domains described
languages c   however  recent progress model based techniques led
number new algorithms  including sat encoding language c  giunchiglia 
      
effects one agent s actions depend actions performed agents
time  action specification becomes complex task  strips representation
useful admits relatively simple planning algorithm  however  despite strips s
semantic adequacy ability  principle  represent set actions  verifying
domain description accurate becomes dicult interactions must taken
account  consequently  believe use dynamic bayes nets  conjunction
conditional outcome  or probability  trees  boutilier   goldszmidt         provide
natural concise representation actions multiagent settings  specification
technique makes clear uence different context conditions action s effects 
allows one exploit independence different effects  representation
used stochastic domains  dynamic bayes nets offer advantages even
case purely deterministic actions  pomp algorithm naturally extends form
domain description  complete treatment issue would interesting
direction future research 
adapting existing nonlinear planners handle interacting actions conceptually
simple  expect increase domain complexity inevitably lead poor computational performance  indeed  experiments pomp algorithm 
found performance greatly affected ordering agenda items  hence  adequate
heuristics making various choices planner faced with namely  choosing sub    principle  nonconcurrency constraint handled manner introducing fictitious
resources 

   

fiplanning concurrent interacting actions

goals  choosing actions achieve them  choosing threat resolution strategies will
become even critical  course  issues central single agent nonlinear
planners  though anticipate multiagent case interacting actions
require different  additional  heuristics 
interesting topic future work would extending newer planning algorithms
graphplan  blum   furst        handle multiagent representation language 
indeed  model based algorithm cimatti  et al         seems offer promising developments direction  naturally  representational issues raised paper arise
regardless particular planning algorithm used  although different implications 
example  question whether allow concurrent actions destroy
one another s preconditions affected threat removal operators valid pomp 
whereas graphplan would affect definition interfering actions  and consequently  question actions considered mutually exclusive  
finally  note approach considered suitable team agents
common set goals  assumes central entity generates plan 
agents access global clock synchronization mechanism
 this typically case single agent multiple effectors  applies certain
cases truly distributed systems   important research issue plans
generated executed distributed fashion  execution
coordinated controlled  important question answers
emerged dai literature  des jardins  durfee  ortiz jr     wolverton        grosz 
hunsberger    kraus        des jardins   wolverton        boutilier              brafman 
halpern    shoham        distributed systems literature  fagin  halpern  moses 
  vardi        

acknowledgments
thanks referees suggestions presentation ideas mike
wellman helpful comments  thank daniel fogel  ishay levy  igor razgon
implementation pomp algorithm  boutilier supported nserc research grant ogp         nce iris ii program project ic    brafman supported paul ivanier center robotics nce iris ii program project ic    much
work undertaken authors university british columbia 
department computer science  preliminary results paper presented
 planning concurrent interacting actions   proceedings fourteenth national
conference artificial intelligence  aaai      providence  ri  pp                

references
baral  c     gelfond  m          reasoning effects concurrent actions  journal
logic programming         
blum  a  l     furst  m  l          fast planning graph analysis  proceedings
fourteenth international joint conference artificial intelligence  pp       
     montreal 
   

fiboutilier   brafman

boutilier  c          planning  learning coordination multiagent decision processes 
proceedings sixth conference theoretical aspects rationality
knowledge  pp          amsterdam 
boutilier  c          sequential optimality coordination multiagent systems 
proceedings sixteenth international joint conference artificial intelligence 
pp          stockholm 
boutilier  c     goldszmidt  m          frame problem bayesian network action
representations  proceedings eleventh biennial canadian conference
artificial intelligence  pp        toronto 
brafman  r  i   halpern  j  y     shoham  y          knowledge requirements
tasks  artificial intelligence                    
cimatti  a   giunchiglia  e   giunchiglia  f     traverso  p          planning via model
checking  decision procedure ar  proceedings fourth european conference planning  ecp      pp          toulouse 
de giacomo  g   lesperance  y     levesque  h  j          reasoning concurrent
execution  prioritized interrupts  exogenous actions situation calculus 
proceedings fifteenth international joint conference artificial intelligence 
pp            nagoya 
dean  t     kanazawa  k          persistence probabilistic projection  ieee trans 
systems  man cybernetics                  
des jardins  m  e   durfee  e  h   ortiz jr   c  l     wolverton  m  j          survey
research distributed continual planning  ai magazine                
des jardins  m  e     wolverton  m  j          coodinating distributed planning system 
ai magazine                
donald  b  r   jennings  j     rus  d          information invariants cooperating
autonomous mobile robots  proceedings international symposium robotics
research hidden valley  pa 
durfee  e  h     lesser  v  r          negotiating task decomposition allocation using
partial global planning  huhns  m     gasser  l   eds    distributed ai  vol    
morgan kaufmann 
durfee  e  h     lesser  v  r          partial global planning  coordination framework distributed hypothesis formation  ieee transactions system  man 
cybernetics                    
ephrati  e   pollack  m  e     rosenschein  j  s          tractable heuristic maximizes global utility plan combination  proceedings first international conference multiagent systems  pp         san francisco 
   

fiplanning concurrent interacting actions

fagin  r   halpern  j  y   moses  y     vardi  m  y          reasoning knowledge 
mit press  cambridge  ma 
fikes  r     nilsson  n          strips  new approach application theorem
proving problem solving  artificial intelligence                   
ghallab  m     alaoui  a  m          managing eciently temporal relations
indexed spanning trees  proceedings eleventh international joint conference
artificial intelligence  pp            detroit 
giunchiglia  e          planning satisfiability expressive action languages  concurrency  constraints nondeterminism  proceedings seventh international
conference principles knowledge representation reasoning  kr      pp 
        breckenridge  co 
giunchiglia  e     lifschitz  v          action language based causal explanation 
preliminary report  proceedings fifteenth national conference artificial
intelligence  pp          madison  wi 
grosz  b  j   hunsberger  l     kraus  s          planning acting together  ai
magazine                
jensen  r  m     veloso  m  m          obdd based universal planning synchronized
agents non deterministic domains  journal artificial intelligence research     
        
kautz  h     selman  b          pushing envelope  planning  propositional logic 
stochastic search  proceedings thirteenth national conference artificial
intelligence  pp            portland  or 
khatib  o   yokoi  k   chang  k   ruspini  d   holmberg  r   casal  a     baader  a 
        force strategies cooperative tasks multiple mobile manipulation systems 
giralt  g     hirzinger  g   eds    robotics research    seventh international
symposium  pp           springer verlag  berlin 
knoblock  c  a          generating parallel execution plans partial order planner 
proceedings second international conference ai planning systems  pp 
       chicago 
koehler  j          planning resource constraints  proceedings thirteenth
european conference artificial intelligence  pp          brighton  uk 
lin  f     shoham  y          concurrent actions situation calculus  proceedings
tenth national conference artificial intelligence  pp          san jose 
lingard  a  r     richards  e  b          planning parallel actions  artificial intelligence 
                
mccarthy  j     hayes  p          philosophical problems standpoint
artificial intelligence  machine intelligence             
   

fiboutilier   brafman

moses  y     tennenholtz  m          multi entity models  machine intelligence            
penberthy  j  s     weld  d  s          ucpop  sound  complete  partial order planner
adl  proceedings third international conference principles knowledge
representation reasoning  kr      pp          cambridge  ma 
pinto  j          concurrent actions interacting effects  proceedings sixth
international conference principles knowledge rerpresentation reasoning
 kr      pp          trento 
reiter  r          closed world databases  gallaire  h     minker  j   eds    logic
databases  pp         plenum  new york 
reiter  r          frame problem situation calculus  simple solution  sometimes  completeness result goal regression  lifschitz  v   ed    artificial
intelligence mathematical theory computation  papers honor john mccarthy   pp           academic press  san diego 
reiter  r          natural actions  concurrency continuous time situation calculus  proceedings fifth international conference principles knowledge
representation reasoning  kr      pp       
stone  p     veloso  m  m          task decomposition  dynamic role assignment  lowbandwidth communication real time strategic teamwork  artificial intelligence 
                 
weld  d  s          introduction least commitment planning  ai magazine         
      
wilkins  d  e     myers  k  l          multiagent planning architecture  proceedings
fourth international conference ai planning systems  pp          pittsburgh 
wolverton  m  j     des jardins  m          controlling communication distributed planning using irrelevance reasoning  proceedings fifteenth national conference
artificial intelligence  pp          madison  wi 

   


