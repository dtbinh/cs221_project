journal of artificial intelligence research                  

submitted        published     

structure and complexity in planning with unary operators
ronen i  brafman
carmel domshlak

brafman cs bgu ac il
dcarmel cs bgu ac il

department of computer science
ben gurion university
p o  box            beer sheva  israel

abstract
unary operator domains  i e   domains in which operators have a single effect  arise
naturally in many control problems  in its most general form  the problem of strips planning in unary operator domains is known to be as hard as the general strips planning
problem  both are pspace complete  however  unary operator domains induce a natural
structure  called the domains causal graph  this graph relates between the preconditions
and effect of each domain operator  causal graphs were exploited by williams and nayak
in order to analyze plan generation for one of the controllers in nasas deep space one
spacecraft  there  they utilized the fact that when this graph is acyclic  a serialization
ordering over any subgoal can be obtained quickly  in this paper we conduct a comprehensive study of the relationship between the structure of a domains causal graph and the
complexity of planning in this domain  on the positive side  we show that a non trivial
polynomial time plan generation algorithm exists for domains whose causal graph induces
a polytree with a constant bound on its node indegree  on the negative side  we show
that even plan existence is hard when the graph is a directed path singly connected dag 
more generally  we show that the number of paths in the causal graph is closely related to
the complexity of planning in the associated domain  finally we relate our results to the
question of complexity of planning with serializable subgoals 

   introduction
one of the first well formulated problems addressed by ai researchers was the planning
problem  simply stated  it involves the generation of a sequence of system transformations 
taken out of a given set of system transformations  called actions or plan operators   whose
combined effect is to move the system from some given initial state into one of a set of
desired goal states  the planning problem is known to be intractable in general  chapman 
       and tractable algorithms exist for very restrictive classes of problems only  this
discouraging fact has not deterred planning researchers  indeed  many researchers believe
that real world problems have some properties  or structure  that could be exploited  either
implicitly or explicitly  in this paper we attempt to understand the relationship between
structure and complexity in planning problems in which each action changes the value of a
single variable 
to study the relation between the structure and the complexity in a class of problems
we must identify a set of parameters that characterize it  in the case of planning  a number
of such problem properties have been studied in the past  which we review in more detail
in section     these properties have been mostly syntactical  i e   they involve restriction
on operators  e g   the type and number of preconditions or effects that operators have  for
c
    
ai access foundation and morgan kaufmann publishers  all rights reserved 

fibrafman   domshlak

example  bylander        showed that strips planning in domains where each operator is
restricted to have positive preconditions and one postcondition only is tractable  backstrom
and klein      b  considered other  more global types of syntactical restrictions  but using
a more refined model in which two types of preconditions are considered  prevail conditions 
which are variable values that are required prior to the execution of the operator and are
not affected by the operator  and preconditions  which are affected by the operator  for
example  they have shown that when operators have a single effect  no two operators have
the same effect  and each variable can be affected only in one context  of prevail conditions 
then the planning problem can be solved in polynomial time  however  these restrictions
are very strict  and it is difficult to find reasonable domains satisfying them 
in this paper we concentrate on more global properties of unary operator domains 
properties that capture some of the interactions between different planning operators  the
tool we use to study these properties is the domains causal graph  a causal graph is a
directed graph whose nodes stand for the domain propositions  an edge  p  q  appears in
the causal graph if and only if some operator that changes the value of q has a prevail
condition involving p  such a problem structure was introduced by knoblock        in
the context of automatically generating abstractions for planning  subsequently  jonsson
and backstrom      b  introduced the  s class of planning problems with unary operators 
which was characterized by the acyclicity of the causal graph  and some restrictions on the
operator set  it was shown that determining plan existence for this class of problems is
polynomial  while plan generation is provably intractable 
complexity results for unary operators would be of theoretical interest alone if one
could not supply interesting problems in which unary operators are used  one interesting
application in which this problem arises is the determination of dominance relationship
between different outcomes in a cp net  boutilier  brafman  hoos    poole         this
problem is reducible to strips planning with unary operators 
another example  of greater interest to the planning community  is a planning based
reactive control system that commands the nasa deep space one autonomous spacecraft  pell  bernard  chien  gat  muscettola  nayak  wagner    williams        williams
  nayak               this system was hailed by weld        in his recent survey of ai
planning as one of the most exciting recent developments in the area of planning  naturally  the complete system  pell et al         is very complex  however  its configuration
planning and execution subsystem are of particular interest to us  in the context of controlling deep space one  williams and nayak              present a reactive planner  burton 
that generates a single control action for the main engine subsystem of the spacecraft  and
compensates for anomalies at every step  given a high level goal  for example  thrust in
one of the engines   burton continually tries to transition the system toward a state that
satisfies the desired goal  what is particularly relevant for us is that burtons task can be
described as a strips planning problem in which each operator affects only a single variable  hardware component   williams and nayak        argue that in physical hardware
it is usually the case that each state variable is commanded separately  however  burton is
based on two additional important restrictions  first  the planner is explicitly supplied with
a serialization order for any satisfiable set of goal  second  all operators must be reversible 
one of the reasons cited for designing burton as a reactive planner that generates a
single action at a time was the potential intractability of generating whole plans  indeed 
   

fistructure and complexity in planning with unary operators

williams and nayak were pessimistic about the prospects of generating whole plans quickly
even for burton  i e   for problem instances with serializable sub goals and single effect
operators  as our results show  this pessimism was not fully justified 
our work continues the study of planning with unary operators  this apparently easier
problem is in fact as hard as the general strips planning problem  bylander         however  we can obtain finer distinctions and some positive results if we pay closer attention to
the causal structure of the domain  for example  it is easy to show that when the causal
graph is a tree  it is easy to determine a serializability ordering over any set of sub goals 
and consequently  obtain a plan in polynomial time  in this paper we analyze the relationship between the domains causal graph and the complexity of plan generation and plan
existence  in particular we prove the following results 
 when the causal graph forms a polytree  the induced undirected graph is acyclic   and
its node indegree is bounded by a constant  then plan existence and plan generation
are polynomial 
 when the causal graph is directed path singly connected  there is at most one directed
path between any pair of nodes   then plan existence is np complete 
 in general  plan generation for the problems with acyclic causal graphs is provably
intractable  i e   the problem requires exponential time  the corresponding claim
is derived from a previous result by jonsson and backstrom      b   however  we
show that the complexity of plan generation for these problems can be bounded by a
function of the number of paths within the causal graph 
note that the complexity of the problems with polytree causal graphs but with unbounded
node indegree remains an open problem  it is still to be shown whether they can be solved
in polynomial time  or they are np complete 
finally  we relate our results to an old open question  how difficult is it to generate
plans for problems with serializable subgoals  korf         this question was stated by
bylander         and different hypotheses were raised by different researchers  here  we
present a clear  though somewhat disappointing answer  first  our results suggest that even
when the underlying causal graph of the problem is acyclic  and thus the problem is known
to be serializable   finding a serialization ordering on the problem subgoals may be hard 
second  we show that even if the actual serialization ordering on the subgoals is known 
solving the problem is not necessarily easy 
the rest of this paper is organized as follows  in section   we first introduce some
basic formalism used in the paper  then discuss  motivate and illustrate the notion of causal
graph  in sections   and   we present our results on the relation between the form of
the causal graph and the complexity of the planning problem  in section   we discuss the
sub goal serializability issue and the impact of our results on it  in section   we describe
some related work on complexity of planning  and connect our work with the previous
results  we summarize in section    finally  appendix a provides a short review of the
pop algorithm  penberthy   weld         and appendix b provides some of the proofs 
   

fibrafman   domshlak

   basic formalism and causal graphs
in this paper we consider only propositional planning problems  using the propositional
strips with negative goals formalism  bylander         in which both positive and negative
preconditions are allowed  following backstrom and klein      b   we distinguish between
preconditions and prevail conditions  in the former case the variable involved changes its
value after the operator is executed  while in the latter case the value does not change  the
post condition of an operator expresses which state variables it changes and what values
these variables will have after executing the operator  the pre condition specifies which
values these changed variables must have before the operator is executed  the prevail
condition specifies which of the unchanged variables must have some specific value before
execution of the operator and what these values are  hence  prevail conditions  such as
having a visa  are needed in order to apply an operator  such as enter usa  but their
values do not change after the operator is applied  finally  we assume that an operator is
applicable if and only if both its pre  and prevail conditions are satisfied 
formally  we assume that a problem instance is given by a quadruple    hv    init  goali 
where 
 v    v            vn   is a set of propositional state variables  each one with an associated
binary domain d vi    the domain d vi   of the variable vi induces an extended domain
d   vi     d vi     u   where u denotes the unspecified value 
 init is an initial  fully specified state  i e  init  d v            d vn   
 goal is a set of possible goal states  we assume that such a set is specified by a partial
assignment on v  thus goal  d   v            d   vn   
     a            an   is a finite set of operators of the form hpre  post  prvi  where
pre  post  prv  d   v            d   vn   denote the pre   post   and prevail condition 
respectively  in what follows  by pre a   post a   and prv a  we denote the corresponding conditions of an operator a  and by pre a  i   post a  i   and prv a  i  the
corresponding values of the variable vi  
for every vi  v  we must have either pre a  i    u or prv a  i    u  further 
post a  i     u if and only if pre a  i     u  in which case post a  i     pre a  i  
in this paper we analyse only planning problems with unary operators  therefore  in
what follows  we assume that  for each operator a    we have that 
   there exists a variable vi  v  such that pre a  i     u  and
   for each other variable vj  v   vi    pre a  j    u 
note that specifying both pre  and postconditions in case of only propositional variables
is redundant  and we use it only to simplify the presentation  likewise  our assumption that
post a     u implies pre a     u is different from the usual strips formalism  and requires
an exponential time translation in general  however  in our case of only unary operators 
this translation takes only linear time 
   

fistructure and complexity in planning with unary operators

    causal graphs
causal graphs were used by williams and nayak        as a tool for describing the structure
of planning domains with unary operators  they represent a dependence relation between
the state variables in the domain  a causal graph g is a directed graph whose nodes
correspond to the state variables  an edge from p to q appears in the causal graph if
and only if some operator that changes the value of q has a prevail condition involving
some value of p  hence the immediate predecessors of q in g are all those variables that
affect our ability to change the value of q  such a problem structure was introduced by
knoblock        in the context of automatic generation of abstractions for planning  the
causal graph is an intuitive model which is easily constructed given any planning problem 
causal graphs are not the only graphical structure that can be derived from a given
planning problem  and effectively exploited in solving it  for instance  graphs in which
operators and literals  and not variables propositions  are represented by the nodes  and the
edges represent both prevail and preconditions were introduced by etzioni        and smith
and peot         in particular  problem space graphs of etzioni        and operator graphs
of smith and peot        were proposed as mechanisms to reduce the number of threats
that arise during the total order and partial order planning  respectively  however  in this
paper we focus on the causal graphs  since they were shown to be especially informative
when all operators are unary  jonsson   backstrom      b  williams   nayak        
causal graphs have an important potential role in the design of autonomous industrial
systems  as argued and demonstrated by williams and nayak         unary operators are
natural when the manipulated objects are hardware components  since the basic control
actions in such systems change the state of a single hardware component  the applicability
of these control actions in any state depends on the state of the affected component as
well as on the state of the related hardware components  this naturally gives rise to a
planning domain with unary operators  moreover  since the state variables correspond
to hardware components  in the induced causal graph we typically see that the prevail
dependencies between variables are usually implicitly entailed by the inter composition of
the hardware components  thus  the causal graph of such domains resembles the structure
of and the relationships between the systems hardware components  this resemblance has
important practical ramifications for system design given the relationship between causal
graph structure and the complexity of plan generation  it enables the system designer to
consider the effect of his hardware design on the systems ability to autonomously generate
control sequences 
a case in point is the planning problem studied by williams and nayak         which
had a number of important features  all operators were unary and reversible  and the causal
graph was acyclic  williams and nayak argued that acyclic connectivity frequently occurs
in designed systems  however  the requirement that all operators should be reversible seems
to us restrictive  and it has important impact on the complexity of the problem  in the
case of the burton planner  williams   nayak         there were good reasons to make this
assumption  burtons reactive nature precludes extensive deliberation on the consequences
of its operators  thus it leaves open the possibility that operators may degrade the systems
capabilities  leading it to dead ends  in that case  the restriction to reversible operators was
   

fibrafman   domshlak

required in order to achieve a more reliable system  as we show later  in certain cases 
complete plans can be generated efficiently even when the operators are not reversible 
williams and nayaks work has another interesting aspect  as noted by weld        
for a long time  researchers have known that planning problems with serializable subgoals
are likely to be easier to solve  williams and nayak recognized that their spacecraft configuration task was serializable  many real world problems are not   and  more importantly 
they developed a fast algorithm for computing the correct order based on the fact that
the underlying causal graph is acyclic  however  their algorithm makes heavy use of the
fact that all operators are reversible  informally  reversibility implies that we can solve our
subgoals one by one as long as they are consistent with some topological order of the causal
graph without taking into account any global considerations  any side effect can always
be undone  without the assumption of operator reversibility  it is relatively easy to show
that williams and nayaks algorithm works only if the causal graph forms a directed chain 
even when the causal graph is a tree  although the problem is easy  one must take care in
the choice of which subgoal to achieve next when operators are not reversible  as we show
later  when the structure of the causal graph is more complicated than a directed tree then
either the problem is hard or  if not  a more sophisticated algorithm is required 
finally  we note that the existence of reversible operators might make the problem seem
easier than it actually is  in this paper we present an example of a propositional planning
problem with unary operators  acyclic causal graph  and totally reversible operators  the
minimal solution of which is exponentially long in the size of the problems description 
    example
in order to illustrate the notion of a causal graph  consider the following example  inspired
by the work of williams and nayak        on controlling the main engine subsystem of the
cassini spacecraft  in general  and its valve driver circuitry  in particular 
each valve v l  on off  is controlled by a valve driver v ld  open close   and a safety
control unit scu  safe unsafe   each driver controls exactly one valve  while a safety
control unit can control several valves  commands to the driver are sent via a driver
control unit  that consist of two switches  s l and s r   which can be either on or off  the
activating states of s l and s r are described below  a valve reacts  by a state change 
to a command from its driver only if  i  the instruction actually involve a state change
 i e   an open valve should not be reopened   and  ii  the safety control unit indicates that
manipulating the valve is safe  in addition  the valve can be closed if the safety control unit
indicates an unsafe situation  for simplicity of presentation  table   presents the operator
set for controlling the valves and valve drivers only  the dashed boxes stand for driver
control units  two switches in each 
now suppose that the valves v l  and v l    with the drivers v ld  and v ld    respectively  are controlled by a shared safety control unit scu   given the operator set in
table    the causal graph for controlling this subsystem is presented in figure   

   polytree causal graphs
starting at this section  we show how  by bounding the structural complexity of the causal
graph  we can bound the complexity of plan generation  recall that we use a propositional
   

fistructure and complexity in planning with unary operators

affected component
v ld
vl

pre
close
open
on
of f
on

post
open
close
of f
on
of f

prv
sl      sr    
sl      sr    
v ld   close  scu   saf e
v ld   open  scu   saf e
scu   unsaf e

table    a subset of the operator set for the valve circuitry controller example 
                                

                                




s r

s l




ee
ww
e

         eee           www w        
ee
w
w
e 
 ww

v ld 

gg
g 

scu

hh
hh
hh
hh
h 



s r 
s l g
g
y
g
y


         ggg g           yy y        



w
ww
ww
w
w
w  w

v ld 

gg
gg
gg
gg
g 

v l 

yy
 yy

vv
vv
v
vv
v  v

v l 

figure    causal graph for the example 
language  binary variables  to describe the state of the world  and each operator is described
by its prevail conditions  single precondition  and single effect  or post condition   the
precondition and the effect are two literals  one the negation of the other 
a causal graph forms a polytree if there is a single path between every pair of nodes in
the induced undirected graph    i e   the induced undirected graph is a tree  for example  the
causal graph presented in figure   forms a polytree  for this class of problems we present
a planning algorithm which is polynomial if the indegree of all nodes in the causal graph is
bounded by a constant  we argue that this assumption is reasonable if the prevail dependencies reflect the inter composition of some controlled hardware components  williams  
nayak        
given a propositional planning instance with a polytree causal graph  we 
   provide a general upper bound for the number of times that a variable may be required
to change its value on a valid  irreducible plan 
   using this general upper bound  provide a polynomial time procedure  called determinemax sequence  that  given a variable v  determines the actual maximal number of
times that v can change its value on a valid  irreducible plan 
   provide a preprocessing algorithm that   a  determines whether or not a plan for a
given problem instance of our class exists  and  b  performs a substantial amount of
   these graphs are also known as singly connected dags 

   

fibrafman   domshlak

preprocessing for the subsequent step of plan generating  this algorithm is based on
a top down execution of determine max sequence on the variables of the given
problem instance 
   if the answer of the plan existence check is positive we run a particular deterministic instance of the pop algorithm   penberthy   weld         called pop pcg 
that generates the required plan using the information provided by the preprocessing
algorithm  without backtracking  in linear time 
informally  this process is based on the following properties of the planning problems
with polytree causal graph  first  the bound achieved in step   is necessary for the steps     
which are the main steps of our technique  by itself  this bound will be valid not only for
a polytree  but for a wider class of directed path singly connected causal graphs  however 
steps     will be valid for polytree causal graphs only  because of the following properties
of this form of dependence relation between the variables 
 i  given a variable v  v  changing the value of a parent  immediate predecessor 
w  pred v  does not require any changes of neither other parents of v  nor their
predecessors in the causal graph 
 ii  the number of times that a variable v will be able to change its value along a valid
plan for a given problem instance depends directly both on these numbers for pred v  
and on the actual ordering of the value changes of pred v  
 iii  from  i  it follows that all the possible orderings of the value changes of pred v  are
legal  in addition  it will be shown that chosing an ordering for the value changes of
pred v  will not affect our ability to change the value of any variable except of v 
 iv  the crucial part of the process  steps      is basically about finding the right ordering of
the right number of value changes of pred v  for each variable v  v  by synchronizing
these changes to vs parents appropriately  we can increase the number of possible
changes to v 
we start with some notation  first  a valid plan p for a given planning instance 
will be called irreducible if any subplan p   of p is not a plan for   in the following sense 
removal of any subset of  not necessarily subsequent  actions from p makes the resulting
plan either illegal  or its initial state is not init  or its goal state is not one of the states
specified by goal  the notion of irreducible plans was introduced by kambhampati        
where it was exploited for admissible pruning of partial plans during search   
   a short review of the pop algorithm  and the corresponding formalism is provided in appendix a  for
those familiar with the algorithm  we note one slight technical change  stemming from the use of unary
operators  pop uses two fictitious actions a  and a to capture the initial and goal state  respectively 
here  we replace each of these actions by a set of actions  each with a single effect  the  fictitious  action
setting the initial value of variable vi is denoted a i and the fictitious action whose precondition is the
goal value of variable vi is denoted ai  
   irreducible plans were called in  kambhampati        minimal plans  however  we decided to change the
name of this concept in order to prevent an ambiguity between minimal as irreducible and minimal
as optimal 

   

fistructure and complexity in planning with unary operators

now  given a planning instance   let p be the set of all irreducible plans for   we
denote by maxreq v  the maximal number of times that a variable v  v changes its value
in the course of execution of an irreducible plan for   formally  let req p  v  be the number
of times that v changes its value in the course of execution of a plan p   then 
maxreq v    max req p  v  
p p

observe that  for any planning problem with unary operators  a variable must change
its value at most once for each required change of its immediate successors in the causal
graph  in order to satisfy the necessary prevail conditions   and then at most once in order
to obtain the value requested by the goal  thus  for all variables in v  maxreq v  satisfies 
x
maxreq v      
maxreq u 
   
succ v 

where succ v  denotes the immediate successors of v in the corresponding causal graph 
adopting the terminology from  domshlak   shimony        shimony   domshlak        
a directed acyclic graph g is directed path singly connected if  for every pair of nodes s  t  g 
there is at most one directed path from s to t  the following lemma shows that if the causal
graph forms a directed path singly connected dag then we can bound maxreq v  by n 
clearly  all polytrees are directed path singly connected dags  but not vice versa 
lemma   for any solvable problem instance  with a directed path singly connected causal
graph over n variables  for any variable v  we have that maxreq v   n 
proof  the proof is by induction on n  for n     it is obvious that maxreq v      now
suppose that when  v    n    then for any v  v 
maxreq v   n   
let   be some problem instance for which  v       n  suppose that the variables in v    
 v          vn   are topologically ordered based on the domains causal graph  clearly  vn is
a leaf node  i e   succ  vn        we will denote by  the problem instance obtained by
removing vn from the domain  and the corresponding variable set by v  according to eq    
for each immediate predecessor v of vn in the causal graph 
newmaxreq v   maxreq v    newmaxreq vn    maxreq v     
where newmaxreq v  denotes maxreq v  with respect to     generally  since the causal
graph is directed path singly connected  for each variable v  v    

maxreq v       if there is a path from v to vn
newmaxreq v  
   
maxreq v  
otherwise
and thus  for each v  v     holds
newmaxreq v   n

   

fibrafman   domshlak

recall that maxreq v  stands for an upper bound on the number of value changes of v
that may be required by a valid  irreducible plan  however  the maximal achievable number
of value changes of v  denoted by maxposs v  can be greater or less than maxreq v   for
example  if v has no predecessors in the causal graph  and there are two operators affecting
v differently  then maxposs v     
we denote the upper bound on the feasible number of value changes of v that may
be required in a valid  irreducible plan for  by fmaxreq v   informally  no more than
maxposs v  value changes of v can be required and no more than maxreq v  value changes
of v should be required  thus
fmaxreq v    min maxposs v   maxreq v  

   

determining fmaxreq v  for all variables requires explicit examination of a given problem instance  recall that here we restrict the causal graph of  to form a polytree  to
simplify the presentation  we assume that the goal values are specified for all state variables 
i e  goal  d v            d vn    later we show that this assumption does not affect the
generality of the algorithm  denote by v   and v  the initial and the goal values of v in  
and by v   the set of all operators affecting v  first we examine the root variables of
the causal graph  then we analyze the rest of the variables 
denote by pred v  the immediate predecessors of v in the causal graph  if pred v     
 
 

then there are at most two operators a
v   av in v   av has v as its postcondition  while

av has the reverse effect  since these operators have no prevail condition  if both a
v and
 
av are presented in   then they can be applied one after another an infinite number of
 
times  therefore  from eq     fmaxreq v    n  if v     a
v   av   then we have two cases 
if the initial and the goal values of v are the same  then we cannot change the value of v
and reconstruct it later  and thus fmaxreq v       alternatively  if the initial and the goal
values of v are different then if v    a 
v   then we can achieve the goal value of v but only
once and thus fmaxreq v       otherwise  the goal value of v is unachievable  thus the
given problem instance is unsolvable  table   summarize this analysis 

v 
v 

 

v

  

v

v

 av   a 
v 
otherwise
 
 a
v   av  
 
 av  
otherwise

fmaxreq v 
n
 
n
 
no solution

table    fmaxreq v  values for the root variables in the causal graph 
now consider a variable v which is presented by an internal node in the causal graph 
pred v     w            wk    
    observe that the number of possible value changes of v depends
on and only on 
   the initial and the goal values of v  i e   v   and v   
   

fistructure and complexity in planning with unary operators

   the set of operators affecting v  i e   v  
   the maximally possible  but still reasonable  number of times that predecessors of v
can change their values  i e   fmaxreq w             fmaxreq wk   
   the actual scheduling of the value changes of the predecessors of v 
the last point is crucial  it means that in order to determine fmaxreq v  we should find
a particular scheduling of the value changes of pred v  that allows such a maximal number
of value changes for v  the corresponding interleaving sequence of vs values  starting and
finishing by v   and v  respectively  with fmaxreq v  value changes will be called maximal
and will be denoted by  v     v     fmaxreq v       
from lemma    for    i  k  we have fmaxreq wi    n  thus the number of different
orderings of value changes of pred v  can be exponential in n  for instance  when  for
   i  k  we have fmaxreq wi     n  this number of different orderings can be expressed
as 


k 
n 
yx
n    ni    
  nk
j
j 
i   j  

where the correctness of the expression on the left side of the inequality is shown by lemma  
 see appendix b  p        clearly  we cannot check all these orderings in a naive manner 
following  we provide an algorithm that determines  v  in time which is polynomial in n 
for clarity of presentation we want to distinguish between the different elements of a
maximal sequence  v   since all variables are binary  we denote the initial value of v  v    
by bv and the opposite value by wv  black white   similarly  bi and wi will stand for the
corresponding values of the variable vi   if so  we can think about all the operators in 
as described in this language  likewise  we sequentially number the appearances of each
value of v on  v   for example  biv stands for the ith appearance of the value bv along
 v   to illustrate this notation  suppose that d v     true  f alse   the initial value of v
is v     true  and fmaxreq v       then  we have 
bv  true
wv  f alse
 v    b v  wv   b v  wv   b v
first  for every variable v  every operator a  v is extended to a set of operators that
explicitly specify prevail values for all parents of v in the causal graph  if  pred v     k 
and the prevail condition of a is specified only in terms of some    k    k parents  of
 
v  then a is extended to a set of  kk operators  where each operator extends a by an
instantiation of the previously unspecified parents of v  for example  consider a variable v
with pred v     u  w   and an operator
a    pre    bv    post    wv    prv    bu    
   for every other parent wj of v  we have prv a  j    u 

   

fibrafman   domshlak

the prevail condition of which does not involve w  this operator is extended to a pair of
operators 
a     pre    bv    post    wv    prv    bu   bw   
a      pre    bv    post    wv    prv    bu   ww   

corresponding to the possible values of w  in what follows  we refer to the operator set
resulting from such a compilation of  as      note that  under the assumption of constantly
bounded maximal indegree  of the causal graph  compiling  into    takes only polynomial
     and thus         o n      
time  since  for every variable v     
v   
given the maximal sequences  w              wk   and the operator set   
v we construct
 
a directed graph  denoted as ge  v   that captures all  and only  feasible sequences of  up
to n  value changes of v  where each value change is annotated with the corresponding
assignment on pred v   although the number of the captured sequences can be exponential
in n  the size of g e  v  is polynomial in n  with respect to this graph  the problem of finding
the maximal sequence  v  is reduced to the problem of finding a longest path from a given
node to an arbitrary other node in a directed acyclic graph 
the graph g e  v  is created in three incremental steps  at the first step  given the
maximal sequences  w              wk   and the operator set   
v we construct a directed labeled
graph g v  capturing information about all sequences of assignments on pred v  that can
enable n or less value flips of v  the graph g v  is defined as follows 
   g v  consist of  nodes  where

 n    n    j  and  v     v     or
  n    j      and  v      v      j  n
 

n     otherwise
   g v  forms a   colored multichain  i e    i  the nodes of the graph are colored by black
and white  starting by black   ii  there are no two subsequent nodes with the same
color   iii  for    i       edges from the node i are only to the node i     
observe that such a construction of g v  promises that the color of the last node will
be consistent with v   
   the nodes of g v  are denoted precisely by the elements of the maximal sequence
 v   i e   biv stands for the ith black node in g v  
   suppose that there are m operators in   
v that change the value of v from bv to wv   in
i
this case  for each i  there are m edges from biv to wvi   and    
v    m edges from wv to
bi  
v   all edges are labeled by the prevail conditions of the corresponding operators 
i e   a k tuple of the values of w            wk   this tuple is denoted by l e   label of the
edge e  and its component  corresponding to a predecessor wi   is denoted by l e wi  
this formal definition of g v  is relatively complicated  thus we provide a demonstrating
example  suppose that we are given a problem instance over   variables  and we consider
   

fistructure and complexity in planning with unary operators

a variable v with pred v     u  w   v     bv   and v    wv   recall that every operator in
   is presented as a three tuple hpre  post  prvi of pre   post   and prevail conditions of the
operator respectively  suppose that 
 
 
 u    b u  wu 
 w    b w  ww
 b w  ww
  
 av    pre    bv    post    wv    prv    bu   ww   
  
a     pre    wv    post    bv    prv    bu   bw   
v  
 v 
av    pre    wv    post    bv    prv    wu   ww   

for this case  the graph g v  is presented by figure   
bu bw
bu ww  
b v

wv 

bu bw

 
 

bu ww  
b v

wv 

 

  bu ww  

  bv

wv 

wu ww

wu ww

figure    example of the graph g v  
the constructed graph g v  captures information about all potentially possible executions of the operators in   
v that can provide us maxreq v  or less value changes of v 
each path  started at the source node of g v   uniquely corresponds to such an execution 
although the number of these alternative executions may be exponential in n  this graphical representation is compact  the number of edges in g v  is o n     
v     note that the
information about the number of times that each operator in   
can
be executed is not
v
captured by g v   the following two steps add this information indirectly and exploit it to
find a maximal sequence  v  
at the second step of construction  we expand g v  with respect to the maximal sequences  w              wk   as follows  each edge e  g v   which by definition corresponds
to some operator a    
v    is replaced by a set of edges such that their labels correspond to
all possible assignments of the elements of  w              wk   to l e   i e   prv a    likewise 
we add a dummy source node sv   with an edge from sv to the original source node of g v 
labeled by a tuple of the first elements of  w              wk      initial values of w            wk   
similarly  we add a dummy target node tv   with an edge from the original target node of
g v  to tv labeled by a tuple of the last elements of  w              wk      goal values of
w            wk    we denote this extended graph by g   v   and figure   illustrates g   v  for the
example above 
the extended graph g   v  can be viewed as a projection of the maximal sequences  wi   
   i  k  on the graph g v   each edge in g v  may be replaced by o nk   edges in g   v  
and thus the number of edges in g   v  is o nk       
v    
it is easy to see that not all paths in g   v  starting at sv are relevant  for example  in
g   v  above  an operator instance prevailed by b u b w can not be performed after an operator
    thus  now we are faced with the problem of finding a longest
instance prevailed by b u ww
feasible path from sv to a node in g   v   the label of which is consistent with v    the
following  last  step provides a reduction of the problem of finding a longest feasible path
from sv to a v   colored node in g   v  to a known problem of finding a longest path in a
   

fibrafman   domshlak

b u b w

b u b w
 
b u ww

sv

b u b w

  b 
v
 
b u ww

 

b u b w
 
  wv
  w 
wu
w

  
 
  bh v

 
b u ww

 
b u ww

  w 
wu
w

 

b u b w
 
  wv

  
 
  bh v

  w 
wu
w

 
b u ww

 

 
  wv

  w 
wu
w

  tv

 
b u ww

  w 
wu
w

figure    example of the graph g   v  
directed acyclic graph  let the graph g e  v  have the edges of g   v  as nodes  and let its
edges be defined by all allowed pairs of immediately subsequent edges in g   v    e  e    is
allowed if  for    i  k  either l e wi   l e   wi or l e   wi appears after l e wi on  wi    such
a construction is a variant of a so called edge graph known in graph theory  the addition
in our case is the exclusion of non allowed edges from it  clearly  g e  v  can be constructed
 
in time polynomial in size of g   v   and the number of edges in g e  v  is o n k       
v     
b u b w

b  b 

 
wu  ww

 
wu  ww

u  w j
   jj
   jjj
   jjjj
   jjj
j
  
jj
jj
  
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
bu bw   
b u ww
bu ww
bu ww
bu bw   
    
    
jj
 
    
  
u 
jj
     
   
u
    
    
jj
u
 
 
    
   
jj
     
     
u
j 
 
 
 
 
 
 
u
    
    
  
     
 
 
 
 
 
 
 
 
 
 
 
bu bw
wu  ww
     
    
     
     
ii
u 
    
    
ii
u
     
     
ii
uu
    
    
     
     
ii
uu
u
 
 
 
 
 
 
i 
u
   
   

u

   w  w 
   w  w 
 
  w 
  w 
b u ww
b
b
u wj
u w
   u w
   u w
jj
jj
jj
  
jj
jj    
jj  
jj  
jj  
j  
  

figure    example of the graph g e  v  
figure   presents g e  v  for our example  the dashed edges present the longest path
from the dummy source node to a node that corresponds to a value change from v  to v 
 from bv to wv    such a longest path in g e  v  describes a maximal sequence of value changes
 v   and its length is actually fmaxreq v       in our example   v    b v  wv   b v  wv    and
fmaxreq v       note that if v     v  then the empty path will be also acceptable since 
in general  v does not have to change its value  in this case fmaxreq v      and  v  will
consist of only one element which corresponds to the initial    goal  value of v 
observe that a longest path in g e  v  describes not only  v  but also the actual sequence
j
of invocations of the operators from   
v that provides  v   we denote by  a bv    and
j
 a wv    the sequences of operator instances that have as effects the corresponding elements
from the sequences  bjv   and  wvj     bjv     wvj      v   of vs values  respectively  in
what follows  we address these sequences of operator instances as one sequence of operator
   

fistructure and complexity in planning with unary operators

procedure forward check   
   topologically sort all variables v based on the the causal graph 
   for each variable v  v  call determine max sequence   v   respecting the above
ordering 
   if one of the calls to determine max sequence return failure  then return failure 
otherwise return success 
procedure determine max sequence    v 
   if pred v     then
 a  if v      v  and a 
v   v   return failure 
 b  otherwise  determine  v  according to the rules in table    and return success 
   otherwise  if pred v     w            wk   then
 a  construct g v   based on v     v    and   
v   
 b  construct g   v   from g v   based on  w            wk    
 c  construct g e  v   from g   v   based on  w            wk    
 d  determine the longest path in g e  v  to a node corresponding to a v   ended value
change  and derive  v  and the corresponding sequence of operators from it 
 e  if v      v  and fmaxreq v       return failure  otherwise  return success 
figure    forward check algorithm
fmaxreq v 

instances v    a vi   i  

vi

 




  where a vi   has vi as its effect  and
i  

bv    
i
 

 w  
v

i    k    

kn

i    k

procedure forward check in figure   summarizes the presented approach  note that
finding a set of longest paths from a node to all other nodes in a directed acyclic graph
can be done in time linear in the size of the graph  wiest   levy         therefore  the
time complexity of a call to the determine max sequence procedure with a variable v is
 
bounded by the size of the constructed graph g e  v  and thus is o n k      
v      forwardcheck calls determine max sequence n times  therefore  if the maximal node indegree
is bounded by a constant   then the overall complexity of the algorithm is o  v            
i e   polynomial in the size of the problem description 
theorem   a given problem instance with a polytree causal graph is solvable if and only
if  for each v  v  forward check succeeds in constructing the maximal sequence  v  
forward check fails if and only if at least one of the calls to the determine maxsequence procedure fails  in turn  a call to determine max sequence on a variable v
   

fibrafman   domshlak

algorithm  pop pcg  ha  o  li  agenda   
   termination  if agenda is empty  return ha  o  li
   goal selection  let hi   aneed i be a rightmost pair on the agenda  by definition 
aneed  a and i is one of the pre prevail conditions of aneed   
   operator selection 
 a  if aneed    ai  i   ij   then aadd   a ij    i   a i   
 b  otherwise 
i  let m   max   j   a ij    a  
ii  if vi is consistent with im  both associated with the same color from  b  w  
then aadd   a im    else aadd   a im     


   plan updating  let l   l   aadd i aneed    and let o   o   aadd   aneed    if
aadd is newly instantiated  then a   a   aadd   and o   o   a i   aadd   ai  
 otherwise a and o remain unchanged  
   update goal set  let agenda   agenda    hi   aneed i   if aadd is newly instantiated 
then for each of its pre prevail conditions q  add hq  aadd i to agenda 
   threat prevention  if aadd   a ij    j      then  for each a  a  s t  ij  belongs
to the prevail conditions of a  add  a   a ij    to o 
   recursive invocation  pop pcg ha  o  li  agenda     where agenda is topologically ordered  based on the causal graph with respect to the precondition part of each
pair  
figure    pop pcg algorithm
fails if and only if the initial and the goal values of v are different but there is no way to
change the value of v even once  thus  if forward check fails  then no plan exists 
to prove the opposite direction we proceed as follows  we define the pop pcg algorithm
 pop for polytree causal graphs  and show that it will succeed without backtracking if
forward check succeeds   pop pcg is described in detail in figure    and it works as
follows  first  let us expand each sequence of operator instances i by a i     a b i    which
will stand for the dummy operator a i    recall that up until now  only operators of the
form a ij   for j     were defined   the algorithm maintains a goal agenda sorted based
on the causal graph structure  parent variables appear after their descendents  at each
point  the next agenda item is selected  if it requires achieving some value for vi we add the
corresponding operator to the plan with the desired effect  step  a   actually  if we would
be ready to accept plans with possible redundant steps  we can omit the next step  b from
the algorithm by assuming that the goal value of each variable v is the last element of the
   for a short review of the pop algorithm  the corresponding formalism  and the description of the initial
call to the algorithm  we refer the reader to appendix a 

   

fistructure and complexity in planning with unary operators

maximal sequence  v   however  if we would like our plan to be irreducible  then a careful
decision about the really required number of value changes of each variable is required 
this decision is captured in step  b by analysis of the value changes of a variable vi that
were found necessary in the previous iterations of the algorithm in order to satisfy the
predecessors of vi in the causal graph  note that the agenda is sorted with respect to some
reverse topological ordering of the causal graph  thus if an operator affecting vi was selected
from the agenda then no operator affecting some predecessor of vi in the causal graph will
appear on the agenda until the end of the algorithm  no threats arise in pop pcg  and the
ordering constraints are consistent 
lemma   if forward check was successful then pop pcg will return a valid plan 
proof 

the lemma will follow from the following claims 

   for every agenda item  there exists an operator that has it as an effect 
   there are no threats in the output of pop pcg 
   the ordering constraints in o are consistent 
   the agenda will be empty after a polynomial number of steps 
for the proof see appendix b  p       
recall that  for simplicity of presentation  we assumed that the goal values are specified
for all state variables  single goal state   i e  goal  d v            d vn    now we show that
the presented approach  with minor modifications  works for a set of possible goal states as
well  if such a set is specified by a partial assignment on v  i e  goal  d   v        d   vn   
note that the latter assumption is widely accepted in the planning literature 
first  no modifications should be done in processing variables that are specified by goal 
now  for each variable v  such that v  is not specified by goal  the modifications are as
follows 
   the graph g v  will consist of exactly n nodes  this is correct since  i  according to
lemma    n changes of v have to be sufficient  and  ii  any value change of v can be
its last value change 
   no changes in construction of g   v  and g e  v  
   in the procedure determine max sequence 
 a  in step  d  determine the longest path from the dummy source node to any other
node in the graph 
 b  in step  e  always return success 
again  this is correct since any value change of v can be its last value change  and  in
particular  v may remain unchanged in a plan for a given problem 
finally  the pop pcg algorithm starts with a null plan that contains the end operator
ai only if vi is specified by goal 
   

fibrafman   domshlak

   directed path singly connected and general dags
in this section we analyze planning complexity in face of more complicated causal graphs 
first  we show that when the causal graph is directed path singly connected even plan
existence is np complete  second  we show that for general causal graphs the situation is
even worse  finally  we characterize an important parameter of the causal graph affecting
planning complexity  which allows us to extend the class of problems which are in np 
theorem   plan existence for strips planning problems with unary operators and directedpath singly connected causal graph is np complete 
proof 

for the proof see appendix b  p       

note that node indegree in the causal graph of the problem created in the proof of
theorem   is bounded by    the hardness for directed path singly connected causal graphs
with maximal indegree lower than   is thus open 
the directed path singly connected structure of the causal graph turns out to be crucial
for guaranteeing reasonable solution times  as we now show  there are solvable propositional planning problems with an arbitrary acyclic  dag  causal graph that have minimal
solutions of exponential size  analysis of this class of problems points to the reason for such
provable intractability  this allows us to characterize an important parameter of the causal
graph affecting planning complexity and to extend the class of problems which are in np 
however  all these restricted problems are still np complete 
theorem   plan generation for general strips planning problems with unary operators
and acyclic causal graph is provably intractable  i e  it is harder than np 
this theorem follows from theorem     in  jonsson   backstrom      b   that shows
that plan generation for the  s problem class is provably intractable  the point is that the
upper bound for minplansize  presented in eq     can be exponential in the size of the input
in this case  first  we show by example that this upper bound can be achieved  then we
present some analysis of the reasons for this intractability 
the following example shows that an exponential upper bound can be achieved  it was
used in the proof of theorem     in  jonsson   backstrom      b   and was originally
presented in a different context by backstrom and nebel         consider a propositional
planning problem with  v    n  where  for    i  n  d vi            and pred vi    
 v          vi     the operator set  consist of  n operators  a    a           an   a n   where
pre ai   j   

post a i   j 


 

  if j   i
u otherwise


 
pre a i   j    post ai   j   
u

  
 
 
prv ai   j    prv ai   j   

u
   

if j   i
otherwise
if j   i   
if j   i   
otherwise

fistructure and complexity in planning with unary operators

it is easy to see that the causal graph of this problem forms a dag  see figure     and
an instance of this planning problem with the initial state h            i and the goal state
h               i has a unique minimal solution of length  n    corresponding to a hamilton
path in the state space 
pqrs
wvut
v 

pqrs
  wvut
v 

 

   

 

pqrs
wvut
vn 

 
pqrs
  wvut
vn
 

figure    causal graph for the proof of theorem  
now we show that this escalation in complexity can be parametrized by the form of
the causal graph 
lemma   for any solvable problem instance  with an acyclic causal graph over n variables  for any variable v  we have that 
maxreq vi       

n
x

 vi   vj  

j i  

where  vi   vj   denotes the total number of different  not necessary disjoint  paths from vi
to vj   where variables are ordered via a topological sort of the causal graph 
proof  the proof is by induction on i  for i   n it is obvious that maxreq vn      
now we assume that the lemma holds for any i   k  and prove it for i   k  without loss
of generality  assume that succ vk        otherwise  we simply have that maxreq vk      
the proof is straightforward 
eq   

maxreq vk  



x

   

maxreq vik   

vik succ vk  
i h 



x

     succ vk     

vik succ vk  

 

  

n
x

n
x

 vik   vj    

j ik   

 vk   vj  

j k  


lemma   entails that the upper bound for minplansize   for a general planning problem
with unary operators and acyclic causal graph depends on the number of different paths
between the nodes in the causal graph  an immediate conclusion is that there is a significant
class of problems with an acyclic causal graph for which planning is in np  let a dag be
called max  connected if the number of different directed paths between every two nodes
in this graph is bounded by  
   

fibrafman   domshlak

theorem   plan generation for strips planning problems with unary operators and max connected causal graph is np complete if  is polynomially bounded 
proof  membership in np is straightforward  if the variables of a given problem  are
considered in a topological ordering induced by the causal graph  then from lemma   follows
that  for any variable vi   maxreq vi    n  in turn  from this follows that minplansize   
n    and thus  if  is polynomially bounded  then we can guess a minimal plan for  that
could be verified in polynomial time 
the hardness follows from theorem   that shows that even if the causal graph is max  connected  directed path singly connected   then plan existence  and thus plan generation 
is hard  

   serializable subgoals
a set of subgoals is defined to be serializable  korf        if there exists an ordering among
the subgoals such that the subgoals can always be solved sequentially without ever violating
a previously solved subgoal in the order  naturally  not all collections of subgoals are
serializable  sometimes it may be necessary to interleave plans for achieving different goals 
however  when a problem instance is serially decomposable  it is possible to design a set of
macro operators with respect to which the subgoals are serializable  korf        
a problem instance is serially decomposable if there exists some ordering of the state
variables for which the effect of each operator on each state variable depends only on that
state variable and previous state variables in the ordering  unfortunately  bylander       
shows that determining serial decomposability of a problem is pspace complete 
one major open problem put forth by bylander in this context is  if a problem is
known to be serially decomposable  how difficult is it to determine whether a given instance
is solvable  as far as we know  the only work in this direction was done by chalasani
et al          where the serial decomposability of the general permutation problem was
considered  in particular  they showed that this problem is in np  but it is unknown
whether it is np hard  recently  some complementary results for bylanders question were
presented koehler and hoffmann         our results shed more light on this question 
any problem instance based on a unary operator domain whose causal graph is acyclic is
serially decomposable  therefore  it can be concluded that finding a solution for serially
decomposable problems may require exponential time  i e   the problem is in exptime  
however  bylanders question is about plan existence  in that case  theorem   does not
apply  and we can only apply our np hardness result  for directed path singly connected
graphs   since it addresses plan existence as well 
weld        hypothesized that      if the underlying causal graph of the planning
problem is acyclic  then a serialization ordering on the subgoals of the problem is obvious 
    serialized subgoals could be solved extremely quickly because no backtracking is required
between them  although the first observation sounds intuitive  our results suggest that it
is rarely true  the acyclicity of the causal graph implies serializability  but in most of the
cases its structure does not provide us sufficient information about the actual serialization
ordering  even when the causal graph is a directed tree one must think first before choosing
   

fistructure and complexity in planning with unary operators

an ordering  likewise  our results imply that when the causal graph does not form an
undirected tree determining a subgoal ordering is np complete  and if the causal graph is
not directed path singly connected  the problem is even more complex 
the second observation is not always true either  the problem is that it is important to
determine not only the serialization ordering over the subgoals  but also the exact strategies
for achieving them  as we showed  in certain cases  a problem with n serializable subgoals
requires an exponentially long solution  when the domain variables are not binary  the
situation is even worse  some of the corresponding complexity results can be derived from
the computational analysis of domshlak and dinitz        

   connection with related work on planning complexity
the idea of analyzing and exploiting structural properties is not new to classical planning 
and in the last few years a number of important results have emerged  generating plans
in the context of the strips representation language was shown by bylander        to
be pspace complete  despite this fact  the existence of many successful planning systems 
especially in recent years  demonstrates that planning is possible and practical for a wide list
of domains  bylander argues that the large gap between the theoretical hardness of planning
and its practical success stems from the use of domain dependent problem analysis and
algorithms  consequently  various authors have explored the existence of some constrained
problem classes for which planning is easier 
in this section we shortly overview some of the major  previous results on complexity
of planning  and discuss their relationship to the results presented in this paper  for a
more detailed presentation of the previous results discussed below we refer the reader to
the original papers 
    local syntactical restrictions
in his seminal paper  bylander        presents a number of complexity results for propositional planning  analyzing different planning problems based on the type of formulas used 
the number and type  positive negative  of operator pre  and postconditions  etc  the work
of bylander is extended by some interesting  complementary results by erol at al         
for example  bylander shows that propositional planning in domains where each operator
is restricted to have positive preconditions and one postcondition only is tractable  generally  extremely severe restrictions on operators are required to guarantee tractability  or
even membership in np  note that bylander        and erol et al         focuses on local
syntactical properties of operators  i e   properties of single operators 
the only syntactic restriction that we pose on the planning problems in this paper is
the unarity of the operators  determining plan existence for this  apparently easier class
of problems was shown by bylander to be as hard as general propositional planning  i e 
pspace complete  note that this result by itself does not entail our theorem    since
planning problems with unary operators may induce causal graphs with cycles  therefore 
none of our results is entailed by the results presented by bylander        and erol et
al         
   

fibrafman   domshlak

    global syntactical restrictions
backstrom and klein      a      b   and  subsequently  backstrom and nebel        
consider other types of restrictions  but using a more refined model  the sas formalism  in
which 
   the state variables are multi valued  and
   two types of preconditions are considered  prevail conditions  which are variable
values that are required prior to the execution of the operator and are not affected by
the operator  and preconditions  which are affected by the operator 
in general  four different restrictions were considered in these works 
 p  post uniqueness  for each effect there is at most one operator that achieves this effect 
in other words  desired effects determine operators to be used in a plan  formally  a
problem instance is post unique if and only if  for each vi  v and x  d vi    there is
at most one operator a   such that post a  i    x 
 s  single valuedness  at most one value of each state variable appears in the prevail
conditions of the operators  for instance  if a certain operator requires the light
to be on  as a prevail condition   no other operator can use the prevail condition
that the light is off  formally  a problem instance is single valued iff there exist no
two operators a  a    and vi  v such that prv a  i     u  prv a    i     u  and
prv a  i     prv a    i  
 u  unariness  each operator affects only one state variable 
 b  binariness  all state variables have exactly two possible values  i e  all state variables
are propositional 
all these four properties are syntactical  however  the properties p and s differ from the
properties u and b by the fact that they have a global nature  post uniqueness and singlevaluedness restrict not the form of the operators  but a global property of the whole set of
operators  backstrom and nebel        showed that us  unariness and single valuedness 
is the extreme problem class for which plan generation is polynomial   
the problems that we analyzed in this paper belong to the problem class ub  by definition  as we already mentioned  even determining plan existence for this class of problems
is pspace complete  now consider the problem class pub  backstrom and nebel       
showed that   i  pub has instances with exponentially long minimal solutions  thus plan
generation for pub is requires exponential time   ii  existence of bounded length plans for
pub is strongly np hard  and  iii  the complexity of general plan existence for pub is still
an open question  informally it means that strengthening restrictions from ub to pub
does not reduce the complexity significantly  at least from the practical point of view 
proposition   every ub problem instance with a tree causal graph is either post unique 
or can be transformed into an equivalent post unique problem instance in  low  polynomial
time  thus  treeub  pub 
   for a thorough analysis of the complexity of sas planning  we refer to backstrom and nebel        

   

fistructure and complexity in planning with unary operators

proof  consider a ub problem with a tree causal graph  and suppose that it is not postunique  it means that there exist a variable v  v  with d v     v     v       such that there
exist two operators a    a   v that change the value of v from v   to v      and prv a      
prv a    
from the assumption that the causal graph forms a tree it follows that  pred v      
if pred v      then it is easy to see that the existence of such a pair of operators is
simply impossible  therefore  let pred v     w   where d w     w    w      without loss of
generality assume that prv a    w     w     prv a    w     w      otherwise  if  for instance 
prv a    w    u  then it is easy to see that a  is a redundant operator 
observe that in this case  prevail dependence of v on w is redundant  we can replace
the pair of operators a    a  in  by a single operator a that changes the value of v from
v   to v    without any prevail condition  the replacement of a    a  by a brings us to an
equivalent problem instance in which the operator set v is post unique  this way we
continue to process iteratively all such problematic variables v until we arrive at a postunique problem instance  

proposition   there are ub problem instances with a tree causal graph that are not singlevalued  thus treeub   ubs 
proof  the proof of proposition   is straightforward  consider a variable v  v  d v   
 v     v       such that succ v     u  w   it can be the case that any value change of u will be
prevailed by v     while any value change of w will be prevailed by v      therefore  restricting
causal graphs even to trees does not entail single valuedness   
propositions   and   show that treeub is a polynomial subclass of pub that is not
entailed by any tractability results of backstrom and nebel        
proposition   there are ub problem instances with a polytree causal graph that are neither single valued  nor post unique 
proof  the proof is straightforward  consider a planning problem with a polytree causal
graph  such that there exist a variable v  v with pred v     u  w   and the following
operator set v  
pre
v 
v 
v   
v   

post
v   
v   
v 
v 

prv
 u    w    
 u     w   
 u    w   
 u     w    

clearly  any problem instance with such v   is neither single valued  nor postunique  since  i  there is more than one operator achieving any value of v  and  ii  both
values of u  and both values of w  appear in prevail conditions of the operators in v   note
   using the simple construction technique from the proof of proposition   it can be shown that restricting
causal graphs to directed chains only does entails single valuedness  however  this case is too restrictive 

   

fibrafman   domshlak

that the maximal indegree of such a polytree can be minimal  i e  equal to    thus  the
proposition is valid for any polytree that is not a tree  
from proposition   it follows that theorems   and   introduce new polynomial and
np easy subclasses of the ub problem class  respectively 
    structural restrictions in propositional planning
jonsson and backstrom      b  present the  s class of planning problems  this class is most
closely related to the problems examined in this paper  since it defines a special subclass of
problems with binary variables  unary operators and acyclic causal graphs  the  s problem
class is defined by posing some additional  relatively severe  restrictions on the problems
operator set  each variable v in a  s problem instance is required to be either  i  static 
i e   unchangeable   ii  symmetrically reversible  i e   for each operator a affecting v  there
exist an operator a  affecting v with the same prevail conditions and the opposite effect 
or  iii  splitting  for the formal definition of the splitting property we refer to jonsson
and backstrom      b   informally  if a binary variable v is splitting then the problem
instance can be split into three  well defined subproblems that can be solved independently 
for this class of planning problems it was shown that plan existence can be determined in
polynomial time  while plan generation is provably intractable  since there are instances of
 s with exponentially long minimal solutions  in particular  the problem instance that we
used in the proof of theorem   is in  s 
the complexity analysis by jnonsson and backstrom      b  is somewhat unique in
the research on complexity of propositional planning  since  to the best of our knowledge 
this was the only attempt to exploit not only syntactical restrictions on the operator set 
but also some structural restrictions on interaction between the variables  our analysis
can be seen as continuing this direction by looking on the structural restrictions only  we
believe that eliminating the marginal effect of the problem structure on the problems  potential  hardness will allow us to understand better the connection between the component
interactions topology  and the potential complexity of the problem 
    structural restrictions in multi valued formalisms
when the variables are no longer propositional  some additional properties of the problems
can be identified  and  possibly  exploited  in particular  additional internal structures of
the problem can be analysed 
jonsson and backstrom      a  analyze different properties of a multi valued problem
structure  which is called the domain transition graph  such a structure is defined for each
state variable of the problem  and it describes possible transitions between different values
of this variable  the domain transition graph of a state variable v is a directed labeled
graph gv    v  e   where v is associated with the vs set of possible values  d v   and
 x  a  y   e if and only if the operator a can be applied at some state in which v   x  and
its application results in a state in which v   y holds 
jonsson and backstrom identify sets of structural restrictions on domain transition
graphs which make planning instances tractable  roughly  the properties are the following 
    the problem domain is interference safe  i e   each operator is either unary or irreplace   

fistructure and complexity in planning with unary operators

able with respect to every variable it affects  an operator a is irreplaceable with respect
to a variable v if the removal of all edges from gv that stem from a disconnects some
weakly connected component of gv       for every variable v  the graph gv   restricted to
the set of values that appear in the prevail conditions of some operators  is acyclic      any
sequence of operators annotating a path from x to y in the domain transition graph of v  is
stronger than all shortest such sequences connecting x and y  here  a sequence a            ak
is stronger than a             a l if there is a subsequence ai            ail of a            ak such that for
every    j  l  the prevail conditions of a j are a subset of the prevail conditions of aij  
jonsson and backstrom present a map of the computational complexity of problems with
different restrictions  displaying the frontier between the tractable and intractable cases 
each domain transition graph combines and structures the influence of many operators
on a particular variable  therefore  they provide us a more global picture than the operator
set alone  hence  in spite of the fact that domain transition graphs do not capture the relationship between different variables  they do allow us to express some structural properties
that address interactions between the variables  e g   see property     above  
observe that domain transition graphs are not very informative in the case of propositional planning  since they are only distinguish between the variables that can be changed
only in one direction and the variables that can be changed in both directions  although
this property of domain transition graphs allows to distinguish between the polynomial
planning with only positive postconditions  and the pspace complete planning with both
positive and negative postconditions  bylander         it seems to be not very helpful in
further hierarchical refinement of the propositional planning complexity  on the other hand 
there is no a priori reason why the causal graphs will not be informative in the multi valued
case  exploiting the properties of causal graphs  together with the properties of domain
transition graphs  seems to be a natural direction to extend the work presented in this paper 
the recent work of domshlak and dinitz        on multi entity off line coordination can be
seen as investigating connections between the structure of the causal graph  together with
the properties of the domain transition graphs  and the complexity of the corresponding
problems in case of multi valued domains  to the best of our knowledge  this is the only
work that was done with respect to such a mixed structural analysis  and a lot of work
remains to be done  for instance  combining various properties of the domain transition
graphs studied by jonsson and backstrom      a   with the properties of the problems
causal graph is a direction for the further research 

   summary and future work
we have shown that the form of the causal graph for strips planning problems with unary
operators is an important factor in determining the computational complexity of plan generation  in particular  we have shown that a polynomial time algorithm exists for any
problem with a polytree causal graph and the node indegree bounded by a constant  more
generally  this result shows that planning with polytree causal graphs is at most  what is
often referred to in the bayes nets literature as  locally exponential  i e   it is exponential in the maximal number of parents of a node  note that in hardware control planning
problems the maximal node indegree is expected to be small  since prevail dependencies
between the variables reflect the direct interconnections between the corresponding hard   

fibrafman   domshlak

ware components  likewise we have shown that for a problem with directed path singly
connected causal graph the maximal plan length is a low order polynomial  but the problem
is np complete  more generally  we have shown a relation between the number of paths between variables in the causal graph and the computational complexity of the corresponding
planning problem  finally we have presented the impact of our results on the question of
complexity of planning problems with serializable subgoals  and connected our work with
previous results on planning complexity 
our work leaves a number of open questions with respect to purely syntactical  and a
mixture of both structural and syntactical restrictions on the planning problems with unary
operators  in the former case  one of the most important directions is a further analysis of
causal graphs with constantly bounded node indegree  it turns out that complexity analysis for this class of problems will be very helpful in understanding various computational
properties of cp nets  boutilier et al          although here we provided a partial answer
for this question  the general picture of the worst case complexity for this class of problems
is not clear  for example  if the indegree of the causal graph is known to be bounded by
   and this is the only structural property of the causal graph  it is even not clear whether
this problem subclass is in np 
in the latter case  various syntactical restrictions can be analysed together with the form
of the causal graph  for example  one may be interested in the computational properties
of the problems with acyclic causal graphs  and the restriction that every operator has at
most  prevail conditions  where  is bounded by a constant  this  as well as many other
related questions with respect to various special cases of planning with unary operators are
of interest for the future work 

acknowledgments
a preliminary version of this paper appeared in the sixth international conference on artificial intelligence planning and scheduling  april        we would like to thank the three
anonymous reviewers for their extremely helpful comments  ronen brafman is supported
in part by the paul ivanier center for robotics research and production management 

   

fistructure and complexity in planning with unary operators

appendix a  a short review of pop  causal links and threats
we represent a plan as a tuple  ha  o  li  where a is a set of unary operators  o is a set of
ordering constraints over a  and l is a set of causal links  for example  if a    a    a    a   
then o might be the set  a    a    a    a     these constraints specify a plan in which
a  is necessarily the last operator  but do not commit to a particular order on a  and a   
naturally  the set of ordering constraints must be consistent  i e   there must exist some

total order satisfying them  a causal link has the form ap i ac   where ap and ac are
operators and i is a possible value for some propositional variable vi   it denotes the fact
that ap produces  i e   has the postcondition  vi   i which is consumed by ac  i e   used to
satisfy a pre  or prevail condition of ac    causal links help us detect whether one operator
at interferes with the work done to enable the execution of some other operator ac   in that
case  at is said to constitute a threat to one of a c s causal links  formally  suppose that


ha  o  li is a plan  and ap i ac is a causal link in l  let at be a different operator in a 


we say that at threatens ap i ac when the following two criteria are satisfied 
 o   ap   at   ac   is consistent  and
 at has i as an effect 
when a partial order plan p contains threats  it is possible that the goal will not be
achieved by some  or all  of the total order plans consistent with p s ordering constraints 
to prevent this  the plan generator must check for threats and remove them by adding one
of two possible ordering constraints  at   ap  demotion  or ac   at  promotion  
a tutorial introduction to pop algorithms can be found in  weld         pop is a
regressive framework for partial order planning that starts with the null plan and continuously updates it by inserting new actions and removing threats  this process continues until
the precondition and the prevail conditions of every operator in the plan are supported by
some causal link and no threats exist  the first argument to pop is a plan and the second
argument is an agenda of goals that need to be supported by causal links  each item on the
agenda is represented by a pair hi   ai where i is either pre  or prevail condition of a plan
action a  the last argument to pop is the whole collection of the operators defined by
the planning instance  the initial call to pop contains the null plan  a specially initialized
agenda  and the operator set  of the given problem 
in this paper we introduce a specialized  deterministic pop algorithm that starts the
planning process using a variant of the null plan which encodes the planning problem  in
particular  if the planning instance has v            vn as the goal then the corresponding null
plan has exactly  n dummy unary operators  a    a             a n   a            an    n ordering
constraints  o     a     a              a n   an     and no causal links  l       for every
vi  v  a i is the corresponding start operator   it has neither pre  nor prevail conditions 
and its effect specifies the value of the variable vi in the initial state  which is denoted by
vi    similarly  ai is the end operator   it has no effect  no prevail conditions  but its
precondition is set to the value of vi in the goal state  which in turn is denoted by vi   
   actually  the goal state may not specify the values of all the variables  thus the number of the end
operators can be less than n  however  for clarity of presentation  we leave this definition of the null
plan 

   

fibrafman   domshlak

our description of the null plan is modified from that of weld        to better suit the
restriction to unary operators  likewise  the initial call to our pop algorithm contains the
agenda  hv    a  i          hvn   an i  

   

fistructure and complexity in planning with unary operators

appendix b  proofs and auxiliary results
lemma   if forward check was successful then pop pcg will return a valid plan 
proof 

the lemma will follow from the following claims 

   for every agenda item  there exists an operator that has it as an effect 
   there are no threats in the output of pop pcg 
   the ordering constraints in o are consistent 
   the agenda will be empty after a polynomial number of steps 
      the first claim follows from the success of the forward check procedure 
forward check implies that for any ij   vi   there is an operator instance a ij   
i   a i    therefore  if ij   vi   then the existence of an appropriate aadd is promised 
assume to the contrary that ij    vi   and  without loss of generality  assume that this
is the first iteration that it happens  if so  then for each variable u  succ vi    there is no
edge labeled by ij in the graph g   u   which is created by the forward check  from this
follows that aneed cannot have ij as a prevail condition  and thus aneed has to affect the
variable vi itself  in this case either aneed   a ij     or aneed   ai  
consider the former case  if aneed   a ij     then ij   was previously selected from the
agenda  by our assumption it means that ij     vi    and it contradicts our assumption
that ij    vi   since ij is a predecessor of ij   on  vi   
now consider the last option that aneed   ai   if aadd   a ij   then the goal value of
the variable vi is consistent with ij   and a ij     a  see step   b ii   if a ij     a
then ij  was previously selected from the agenda  by our assumption it means that
ij    vi    however  it contradicts our assumption that ij    vi   since  vi    by
definition  terminates with a node consistent with the goal value of vi  
in addition  since we have shown that the only operators added into a are those from
i   a i   ai    for    i  n  the agenda will be empty after o n    steps 


    suppose that some operator at threatens ap i ac   i e  
 o   ap   at   ac   is consistent  and
 at has i as an effect 
for a given variable vi   pop pcg forces the operators affecting vi as follows  step    
a i  a i      a i              a ix   

x  fmaxreq vi  

   

thus ac can only be an operator with i as a prevail condition  note that ap and at
affect the same variable vi   in     we already showed that i   ij   vi    in that
case at   a il    l   j  however  if ij is a prevail condition of ac then the ordering
constraint  ac   a ij      was added to o at step    if so then from eq     it follows that
   

fibrafman   domshlak

 a il     a ij      a ij       a il     l   j  will be implied by o   ap   at   ac    and it
contradicts with the assumption that o   ap   at   ac   is consistent 
    the ordering constraints are consistent if no two operators ai and aj are such that
o implies   ai   aj     aj   ai     in what follows  ai will be used to denote an arbitrary
operator affecting variable vi  
first note that each ordering constraint added in step   or step   is either between
operators affecting the same variable or between operators affecting a variable and its child
 with respect to the causal graph   in particular  if ai   aj was added in step   then either
vi   vj or vi  pred vj    whereas if ai   aj was added in step   then vj  pred vi   
assume  to the contrary that o implies ai   aj and aj   ai   from the argument
above  we know that there is a  possibly empty  path between vi and vj in the undirected
graph induced by the causal graph  by our structural assumption  we know that such an
undirected path between vi and vj is unique  and thus the situation is as follows  we have
two chains of operators
   ai   a i            axi     a i            axi                   a im           aximm   aj
   ai   a i            ayi     a i            ayi                   a im           ayimm   aj

such that  for    k  m  both xk    and yk     the corresponding unique undirected
path between vi and vj is 
vi   vi   vi          vim   vim   vj
without loss of generality  the internal elements of  and  are disjoint  otherwise  if there
is an operator b that belongs to the internal parts of both  and  then we can reduce
these chains and deduce ai   b and ai   b 
the proof of consistency is as follows 
 a  we prove that if such  and  exist then at least one of them should have at least
one internal element 
 b  we show some useful property of  and   that is exploited in  c  
 c  we show that for    k  m  axikk and ayikk are different except when x    y      
note that  a  together with  c  contradicts our assumption that aximm   ayimm  
 a  assume  to the contrary  that both  and  do not contain any internal elements 
if so  then the algorithm actually adds to o ordering constraints ai   aj and aj   ai  
if vi and vj are the same variable then ai   aj can only stem from step   and only
because ai has the precondition of aj as its effect  however  by definition of forwardcheck  aj can not have the same role w r t  ai and thus it is impossible that aj   ai was
added to o  alternatively  if vi is a parent of vj then ai   aj can stem only from step  
because ai has the prevail condition of aj as its effect  suppose that ai   a bji   and thus
bji  prv aj    in turn  aj   ai can be added only in step   because aj has the precondition
of ai as the prevail condition  but if bji  prv aj   then ai   a wij    and this contradicts
   

fistructure and complexity in planning with unary operators

our assumption that ai   a bji    alternatively  we can assume that ai   a wij   but this
situation is completely symmetric  and thus the result will be the same  hence we proved
that either  or  have to contain at least one internal element  in particular it means
that the next to last elements of  and  are different and this fact is exploited later in the
proof 
 b  consider subchains of  that consist of operators affecting only one particular variable  for each such a subchain  i e  for    k  m  for    j  xk     the ordering
j
j  
constraint ajik   aj  
ik can only stem from step   because aik has the precondition of aik
as its effect  thus  post ajik     pre aj  
ik    similarly  for the subchains of   for    k  m
j
and for    j  yk   post aik     pre aj 
ik    in what follows we denote this property of 
and  by local monotonicity 
 c  first suppose that either x      or y       or both  consider the following sequence 
   ayi     ayi               a i    a i          axi  
from the local monotonicity  the construction of forward check  and the fact that      
 
it follows that post ayi    appears before post axi     on the maximal sequence vi    continuing
 

with the next variable vi  we claim that post ayi    has to appear before post axi     on vi   
 i  if vi  is a parent of vi  then axi     a i  can only stem from step   because axi   has
the prevail condition of a i  as its effect  in turn  ayi     a i  can only stem from step  
because the prevail condition of a i  is the precondition of ayi     from the relation between
axi   and ayi     and the construction of g e  vi    in forward check  it follows that post a i   
appears before post a i    on  vi     subsequently  from the local monotonicity it follows
that post ayi     appears before post axi     on  vi    
 ii  similarly  if vi  is a parent of vi  then ayi     a i  can only stem from step   because
a i  has the prevail condition of ayi   as its effect  and axi     a i  can only stem from step  
because the prevail condition of axi   is the precondition of a i    from the relation between
axi   and ayi     and the construction of g e  vi    in forward check  it follows that post a i   
appears before post a i    on  vi     and again  from the local monotonicity it follows that
post ayi     appears before post axi     on  vi    
alternatively  if x    y      then axi     ayi     ai   from  a  immediately follows
that a i     a i    and an analysis similar to the above shows that post ayi     appears before
post axi     on  vi    
having established that post ayi     appears before post axi     on  vi     it is apparent
that an inductive argument will allow us to show that for all k     we have that post ayikk  
appears before post axikk   on  vik    note that in particular it means that the operators
axikk and ayikk are different  and this contradicts our assumption that aximm   ayimm   

   

fibrafman   domshlak

theorem  
plan existence for strips planning problems with unary operators and
directed path singly connected causal graph is np complete 
proof  first we show the membership in np  let minplansize   denote the size of the
minimal plan for a problem instance   using the maxreq property of the state variables 
the following upper bound for minplansize   is straightforward from the lemma   
x
minplansize   
maxreq v   n 
   
vv

thus  if we guess a minimal solution for a given solvable problem  we can verify it in low
polynomial time 
the proof of the hardness is by polynomial reduction from   sat to the corresponding
propositional plan generation problem with a directed path singly connected causal graph 
  sat is the problem of finding a satisfying assignment for a propositional formula in conjunctive normal form in which each conjunct  clause  has at most three literals 
let f   c       cn be a propositional formula belonging to   sat  and let x            xm
be the variables used in f  an equivalent propositional planning problem with a directedpath singly connected causal graph can be constructed as follows  the variable set is v  
 x    x            xm   xm     c            cn    the variables xi and xi have no predecessors in
the causal graph  thus pred xi     pred xi         in turn  for    i  n  pred ci    
 xi    xi    xi    xi    xi    xi     where xi    xi    and xi  are the variables that participate in
the ith clause of f  finally  init and goal consist of false and true assignments to all
variables in v  respectively 
let every operator a   be presented as a three tuple h pre    post    prv i of pre  post 
and prevail conditions respectively  then  the corresponding operator set  is specified as
follows 
xi

  

h f     t     i  

xi

  

h f     t     i  

 ci

  

h f     t     i  i  h f     t     i  i  h f     t     i  i

 

where ji     j     corresponds to the truth assignment on the variable xij that satisfies
the ith clause of f  let ci    x   x   x     then  i    x    t  x    f     i    x   
f  x    t   and  i    x    t  x    f   
to illustrate the proposed reduction consider the following example  formula f consist
of   clauses   x   x   x      x   x   x      x   x   x     the causal graph of the
corresponding planning problem is as follows 
 abc
gfed
 abc
 abc
gfed
gfed
 abc
 abc
 abc
gfed
 abc
gfed
x  f gfed
x 
x  f gfed
x 
x
x 
x 
  
  f     
   ff
 
 
h

  
   fff
  f   
      h x  x  x 
 

 
 
 
f
f
h

 
 ff
  
 
a
x  x 
 
f
ff      a
       x  x  h h
f
ff    
 
a

 
 
 
x

f
 h
f  
a
f            x  x  x 
h a a
 ffff     
  
f
 
x
h

 
 
x 
  fff   
 h a a

   x     x  f x  f   
ff     
h

 
 
    
 
x
f   h a a
ff    
  
f       x    x  x 
f      
     x
 abc
gfed
 abc
gfed
 abc
gfed
c 
c 
c 
   

 abc
gfed
x 
x   x a
a
a

fistructure and complexity in planning with unary operators

this is a propositional planning problem with single effect operators and an underlying
directed path singly connected causal graph  clearly  goal is reachable   is solvable  if and
only if a satisfying assignment for f can be found  thus  plan existence for the propositional
planning problems with directed path singly connected causal graphs is np complete  

lemma   given k ordered sequences          k of n elements each  the number t  k  of
different merges of          k   preserving the orderings induced by          k on their elements  is given by 


k 
n 
yx
n    ni    
t  k   
   
j 
j
i   j  

proof  considering the merge operation of such k sequences as iterative merge of i  
   i  k  with the already merged sequences             i    it is easy to see that t  k  can
be expressed as 
 
t  k      s  n k      n    k    
t  k   
   
  
k  
where s x  y  stands for the number of different  order preserving merges of two ordered
sequences of sizes x and y  without loss of generality  we assume that x  y  
we consider the process of merging two ordered sequences  and                 as 
 i  partition of    into j sub sequences 
 ii  partition of  into l sub sequences  where j     l  j      and
 iii  interleaving and order preserving concatenation of the sub sequences of  and     
first  observe that    can be partitioned into    j        sub sequences  second  for
    
any j  the numbers of different partitions corresponding to steps  i  and  ii  are  j 
and

    
  respectively  finally  given a pair of such partitions of  and      there exist exactly
j
one possible interleaving and order preserving concatenation as in step  iii   therefore  we
have 


y 
x
y  x  
s x  y   
   
j 
j
j  

and combining eq    with eq     we arrive to eq     

   

fibrafman   domshlak

references
backstrom  c     klein  i       a   parallel non binary planning in polynomial time  in
proceedings of twelfth international joint conference on artificial intelligence  pp 
        sydney  australia  morgan kaufmann publishers 
backstrom  c     klein  i       b   planning in polynomial time  the sas pubs class 
computational intelligence                
backstrom  c     nebel  b          complexity results for sas  planning  computational
intelligence                 
boutilier  c   brafman  r   hoos  h     poole  d          reasoning with conditional ceteris
paribus preference statements  in proceedings of the fifteenth annual conference on
uncertainty in artificial intelligence  pp        morgan kaufmann publishers 
bylander  t          complexity results for serial decomposability  in proceedings of the
tenth national conference on artificial intelligence  pp          san jose  cl  aaai
press 
bylander  t          the computational complexity of propositional strips planning 
artificial intelligence                   
chalasani  p   etzioni  o     mount  j          integrating efficient model learning and
problem solving algorithms in permutation environments  in proceedings of the second
international conference on principles of knowledge representation and reasoning 
pp        cambridge  ma  morgan kaufmann publishers 
chapman  d          planning for conjunctive goals  artificial intelligence                 
domshlak  c     dinitz  y          multi agent off line coordination  structure and complexity  in proceedings of sixth european conference on planning  toledo  spain 
domshlak  c     shimony  s  e          efficient probabilistic reasoning in bayes nets
with mutual exclusion and context specific independence  in proceedings of the sixteenth international flairs conference  special track on uncertain reasoning  st 
augustine  fl  aaai press  to appear 
erol  k   nau  d  s     subrahmanian  v  s          complexity  decidability and undecidability results for domain independent planning  artificial intelligence  special issue
on planning                
etzioni  o          acquiring search control knowledge via static analysis  artificial intelligence                 
jonsson  p     backstrom  c       a   state variable planning under structural restrictions 
algorithms and complexity  artificial intelligence                   
jonsson  p     backstrom  c       b   tractable plan existence does not imply tractable
plan generation  annals of mathematics and artificial intelligence                   
kambhampati  s          admissible pruning strategies based on plan minimality for planspace planning  in proceedings of the fourteenth international joint conference on
artificial intelligence  pp            montreal  canada 
   

fistructure and complexity in planning with unary operators

knoblock  c          automatically generating abstractions for planning  artificial intelligence                 
koehler  j     hoffmann  j          on reasonable and forced goal orderings and their use
in an agenda driven planning algorithm  journal of artificial intelligence research 
           
korf  r          macro operators  a weak method for learning  artificial intelligence         
     
korf  r          planning as search  a quantitative approach  artificial intelligence         
     
pell  b   bernard  d   chien  s   gat  e   muscettola  n   nayak  p   wagner  m     williams 
b          an autonomous spacecraft agent prototype  in proceedings of the first
international conference on autonomous agents  pp          marina del rey  cl 
acm press 
penberthy  j  s     weld  d  s          ucpop  a sound  complete  partial order planner
for adl  in proceedings of third international conference on principles of knowledge representation and reasoning  pp          cambridge  ma  morgan kaufmann
publishers 
shimony  s  e     domshlak  c          complexity of probabilistic reasoning in  directedpath  singly connected  not polytree   bayes networks  submitted for publication 
smith  d     peot  m          postponing threats in partial order planning  in proceedings of
the eleventh national conference on artificial intelligence  pp          washington 
d c  aaai press 
weld  d  s          an introduction to least commitment planning  ai magazine         
     
weld  d  s          recent advances in ai planning  ai magazine                
wiest  j  d     levy  f  k          a management guide to pert cpm  prentice hall 
williams  b     nayak  p          a model based approach to reactive self configuring systems  in proceedings of the thirteenth national conference on artificial intelligence 
pp          portland  or  aaai press 
williams  b     nayak  p          a reactive planner for a model based executive  in
proceedings of the fifteenth international joint conference on artificial intelligence 
pp            nagoya  japan 

   

fi