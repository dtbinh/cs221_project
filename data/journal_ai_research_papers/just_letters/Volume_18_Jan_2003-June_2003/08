journal artificial intelligence research                  

submitted        published     

structure complexity planning unary operators
ronen i  brafman
carmel domshlak

brafman cs bgu ac il
dcarmel cs bgu ac il

department computer science
ben gurion university
p o  box            beer sheva  israel

abstract
unary operator domains i e   domains operators single effect arise
naturally many control problems  general form  problem strips planning unary operator domains known hard general strips planning
problem pspace complete  however  unary operator domains induce natural
structure  called domains causal graph  graph relates preconditions
effect domain operator  causal graphs exploited williams nayak
order analyze plan generation one controllers nasas deep space one
spacecraft  there  utilized fact graph acyclic  serialization
ordering subgoal obtained quickly  paper conduct comprehensive study relationship structure domains causal graph
complexity planning domain  positive side  show non trivial
polynomial time plan generation algorithm exists domains whose causal graph induces
polytree constant bound node indegree  negative side  show
even plan existence hard graph directed path singly connected dag 
generally  show number paths causal graph closely related
complexity planning associated domain  finally relate results
question complexity planning serializable subgoals 

   introduction
one first well formulated problems addressed ai researchers planning
problem  simply stated  involves generation sequence system transformations 
taken given set system transformations  called actions plan operators   whose
combined effect move system given initial state one set
desired goal states  planning problem known intractable general  chapman 
       tractable algorithms exist restrictive classes problems only 
discouraging fact deterred planning researchers  indeed  many researchers believe
real world problems properties  structure  could exploited  either
implicitly explicitly  paper attempt understand relationship
structure complexity planning problems action changes value
single variable 
study relation structure complexity class problems
must identify set parameters characterize it  case planning  number
problem properties studied past  which review detail
section     properties mostly syntactical  i e   involve restriction
operators  e g   type number preconditions effects operators have 
c
    
ai access foundation morgan kaufmann publishers  rights reserved 

fibrafman   domshlak

example  bylander        showed strips planning domains operator
restricted positive preconditions one postcondition tractable  backstrom
klein      b  considered other  global types syntactical restrictions  using
refined model two types preconditions considered  prevail conditions 
variable values required prior execution operator
affected operator  preconditions  affected operator 
example  shown operators single effect  two operators
effect  variable affected one context  of prevail conditions 
planning problem solved polynomial time  however  restrictions
strict  difficult find reasonable domains satisfying them 
paper concentrate global properties unary operator domains 
properties capture interactions different planning operators 
tool use study properties domains causal graph  causal graph
directed graph whose nodes stand domain propositions  edge  p  q  appears
causal graph operator changes value q prevail
condition involving p  problem structure introduced knoblock       
context automatically generating abstractions planning  subsequently  jonsson
backstrom      b  introduced  s class planning problems unary operators 
characterized acyclicity causal graph  restrictions
operator set  shown determining plan existence class problems
polynomial  plan generation provably intractable 
complexity results unary operators would theoretical interest alone one
could supply interesting problems unary operators used  one interesting
application problem arises determination dominance relationship
different outcomes cp net  boutilier  brafman  hoos    poole        
problem reducible strips planning unary operators 
another example  greater interest planning community  planning based
reactive control system commands nasa deep space one autonomous spacecraft  pell  bernard  chien  gat  muscettola  nayak  wagner    williams        williams
  nayak               system hailed weld        recent survey ai
planning one exciting recent developments area planning  naturally  complete system  pell et al         complex  however  configuration
planning execution subsystem particular interest us  context controlling deep space one  williams nayak              present reactive planner  burton 
generates single control action main engine subsystem spacecraft 
compensates anomalies every step  given high level goal  for example  thrust
one engines   burton continually tries transition system toward state
satisfies desired goal  particularly relevant us burtons task
described strips planning problem operator affects single variable  hardware component  williams nayak        argue physical hardware
usually case state variable commanded separately  however  burton
based two additional important restrictions  first  planner explicitly supplied
serialization order satisfiable set goal  second  operators must reversible 
one reasons cited designing burton reactive planner generates
single action time potential intractability generating whole plans  indeed 
   

fistructure complexity planning unary operators

williams nayak pessimistic prospects generating whole plans quickly
even burton  i e   problem instances serializable sub goals single effect
operators  results show  pessimism fully justified 
work continues study planning unary operators  apparently easier
problem fact hard general strips planning problem  bylander         however  obtain finer distinctions positive results pay closer attention
causal structure domain  example  easy show causal
graph tree  easy determine serializability ordering set sub goals 
consequently  obtain plan polynomial time  paper analyze relationship domains causal graph complexity plan generation plan
existence  particular prove following results 
causal graph forms polytree  the induced undirected graph acyclic  
node indegree bounded constant  plan existence plan generation
polynomial 
causal graph directed path singly connected  there one directed
path pair nodes   plan existence np complete 
general  plan generation problems acyclic causal graphs provably
intractable  i e   problem requires exponential time  corresponding claim
derived previous result jonsson backstrom      b   however 
show complexity plan generation problems bounded
function number paths within causal graph 
note complexity problems polytree causal graphs unbounded
node indegree remains open problem still shown whether solved
polynomial time  np complete 
finally  relate results old open question  difficult generate
plans problems serializable subgoals  korf         question stated
bylander         different hypotheses raised different researchers  here 
present clear  though somewhat disappointing answer  first  results suggest even
underlying causal graph problem acyclic  and thus problem known
serializable   finding serialization ordering problem subgoals may hard 
second  show even actual serialization ordering subgoals known 
solving problem necessarily easy 
rest paper organized follows  section   first introduce
basic formalism used paper  discuss  motivate illustrate notion causal
graph  sections     present results relation form
causal graph complexity planning problem  section   discuss
sub goal serializability issue impact results it  section   describe
related work complexity planning  connect work previous
results  summarize section    finally  appendix provides short review
pop algorithm  penberthy   weld         appendix b provides proofs 
   

fibrafman   domshlak

   basic formalism causal graphs
paper consider propositional planning problems  using propositional
strips negative goals formalism  bylander         positive negative
preconditions allowed  following backstrom klein      b   distinguish
preconditions prevail conditions  former case variable involved changes
value operator executed  latter case value change 
post condition operator expresses state variables changes values
variables executing operator  pre condition specifies
values changed variables must operator executed  prevail
condition specifies unchanged variables must specific value
execution operator values are  hence  prevail conditions 
visa  needed order apply operator  enter usa 
values change operator applied  finally  assume operator
applicable pre  prevail conditions satisfied 
formally  assume problem instance given quadruple   hv    init  goali 
where 
v    v            vn   set propositional state variables  one associated
binary domain d vi    domain d vi   variable vi induces extended domain
d   vi     d vi    u   u denotes unspecified value 
init initial  fully specified state  i e  init d v          d vn   
goal set possible goal states  assume set specified partial
assignment v  thus goal d   v          d   vn   
   a              finite set operators form hpre  post  prvi 
pre  post  prv d   v          d   vn   denote pre   post   prevail condition 
respectively  follows  pre a   post a   prv a  denote corresponding conditions operator a  pre a  i   post a  i   prv a  i 
corresponding values variable vi  
every vi v  must either pre a  i    u prv a  i    u  further 
post a  i     u pre a  i     u  case post a  i     pre a  i  
paper analyse planning problems unary operators  therefore 
follows  assume that  operator   that 
   exists variable vi v  pre a  i     u 
   variable vj v  vi    pre a  j    u 
note specifying pre  postconditions case propositional variables
redundant  use simplify presentation  likewise  assumption
post a     u implies pre a     u different usual strips formalism  requires
exponential time translation general  however  case unary operators 
translation takes linear time 
   

fistructure complexity planning unary operators

    causal graphs
causal graphs used williams nayak        tool describing structure
planning domains unary operators  represent dependence relation
state variables domain  causal graph g directed graph whose nodes
correspond state variables  edge p q appears causal graph
operator changes value q prevail condition involving
value p  hence immediate predecessors q g variables
affect ability change value q  problem structure introduced
knoblock        context automatic generation abstractions planning 
causal graph intuitive model easily constructed given planning problem 
causal graphs graphical structure derived given
planning problem  effectively exploited solving it  instance  graphs
operators literals  and variables propositions  represented nodes 
edges represent prevail preconditions introduced etzioni        smith
peot         particular  problem space graphs etzioni        operator graphs
smith peot        proposed mechanisms reduce number threats
arise total order partial order planning  respectively  however 
paper focus causal graphs  since shown especially informative
operators unary  jonsson   backstrom      b  williams   nayak        
causal graphs important potential role design autonomous industrial
systems  argued demonstrated williams nayak         unary operators
natural manipulated objects hardware components  since basic control
actions systems change state single hardware component  applicability
control actions state depends state affected component
well state related hardware components  naturally gives rise
planning domain unary operators  moreover  since state variables correspond
hardware components  induced causal graph typically see prevail
dependencies variables usually implicitly entailed inter composition
hardware components  thus  causal graph domains resembles structure
relationships systems hardware components  resemblance
important practical ramifications system design given relationship causal
graph structure complexity plan generation  enables system designer
consider effect hardware design systems ability autonomously generate
control sequences 
case point planning problem studied williams nayak        
number important features  operators unary reversible  causal
graph acyclic  williams nayak argued acyclic connectivity frequently occurs
designed systems  however  requirement operators reversible seems
us restrictive  important impact complexity problem 
case burton planner  williams   nayak         good reasons make
assumption  burtons reactive nature precludes extensive deliberation consequences
operators  thus leaves open possibility operators may degrade systems
capabilities  leading dead ends  case  restriction reversible operators
   

fibrafman   domshlak

required order achieve reliable system  show later  certain cases 
complete plans generated efficiently even operators reversible 
williams nayaks work another interesting aspect  noted weld        
long time  researchers known planning problems serializable subgoals
likely easier solve  williams nayak recognized spacecraft configuration task serializable  many real world problems not   and  importantly 
developed fast algorithm computing correct order based fact
underlying causal graph acyclic  however  algorithm makes heavy use
fact operators reversible  informally  reversibility implies solve
subgoals one one long consistent topological order causal
graph without taking account global considerations  side effect always
undone  without assumption operator reversibility  relatively easy show
williams nayaks algorithm works causal graph forms directed chain 
even causal graph tree  although problem easy  one must take care
choice subgoal achieve next operators reversible  show
later  structure causal graph complicated directed tree
either problem hard or  not  sophisticated algorithm required 
finally  note existence reversible operators might make problem seem
easier actually is  paper present example propositional planning
problem unary operators  acyclic causal graph  totally reversible operators 
minimal solution exponentially long size problems description 
    example
order illustrate notion causal graph  consider following example  inspired
work williams nayak        controlling main engine subsystem
cassini spacecraft  general  valve driver circuitry  particular 
valve v l  on off  controlled valve driver v ld  open close   safety
control unit scu  safe unsafe   driver controls exactly one valve  safety
control unit control several valves  commands driver sent via driver
control unit  consist two switches  l r   either off 
activating states l r described below  valve reacts  by state change 
command driver  i  instruction actually involve state change
 i e   open valve reopened    ii  safety control unit indicates
manipulating valve safe  addition  valve closed safety control unit
indicates unsafe situation  simplicity presentation  table   presents operator
set controlling valves valve drivers only  dashed boxes stand driver
control units  two switches each 
suppose valves v l  v l    drivers v ld  v ld    respectively  controlled shared safety control unit scu   given operator set
table    causal graph controlling subsystem presented figure   

   polytree causal graphs
starting section  show how  bounding structural complexity causal
graph  bound complexity plan generation  recall use propositional
   

fistructure complexity planning unary operators

affected component
v ld
vl

pre
close
open

f


post
open
close
f

f

prv
sl     sr    
sl     sr    
v ld   close scu   saf e
v ld   open scu   saf e
scu   unsaf e

table    subset operator set valve circuitry controller example 
                               

                               




s r

s l




ee
ww
e

         eee           www w        
ee
w
w
e 
 ww

v ld 

gg
g 

scu

hh
hh
hh
hh
h 



s r
s l g
g

g



         ggg g           yy y        



w
ww
ww
w
w
w  w

v ld 

gg
gg
gg
gg
g 

v l 

yy
 yy

vv
vv
v
vv
v  v

v l 

figure    causal graph example 
language  binary variables  describe state world  operator described
prevail conditions  single precondition  single effect  or post condition  
precondition effect two literals  one negation other 
causal graph forms polytree single path every pair nodes
induced undirected graph    i e   induced undirected graph tree  example 
causal graph presented figure   forms polytree  class problems present
planning algorithm polynomial indegree nodes causal graph
bounded constant  argue assumption reasonable prevail dependencies reflect inter composition controlled hardware components  williams  
nayak        
given propositional planning instance polytree causal graph  we 
   provide general upper bound number times variable may required
change value valid  irreducible plan 
   using general upper bound  provide polynomial time procedure  called determinemax sequence  that  given variable v  determines actual maximal number
times v change value valid  irreducible plan 
   provide preprocessing algorithm that   a  determines whether plan
given problem instance class exists   b  performs substantial amount
   graphs known singly connected dags 

   

fibrafman   domshlak

preprocessing subsequent step plan generating  algorithm based
top down execution determine max sequence variables given
problem instance 
   answer plan existence check positive run particular deterministic instance pop algorithm   penberthy   weld         called pop pcg 
generates required plan using information provided preprocessing
algorithm  without backtracking  linear time 
informally  process based following properties planning problems
polytree causal graph  first  bound achieved step   necessary steps     
main steps technique  itself  bound valid
polytree  wider class directed path singly connected causal graphs  however 
steps     valid polytree causal graphs only  following properties
form dependence relation variables 
 i  given variable v v  changing value parent  immediate predecessor 
w pred v  require changes neither parents v 
predecessors causal graph 
 ii  number times variable v able change value along valid
plan given problem instance depends directly numbers pred v  
actual ordering value changes pred v  
 iii   i  follows possible orderings value changes pred v 
legal  addition  shown chosing ordering value changes
pred v  affect ability change value variable except v 
 iv  crucial part process  steps      basically finding right ordering
right number value changes pred v  variable v v  synchronizing
changes vs parents appropriately  increase number possible
changes v 
start notation  first  valid plan p given planning instance
called irreducible subplan p   p plan   following sense 
removal subset  not necessarily subsequent  actions p makes resulting
plan either illegal  initial state init  goal state one states
specified goal  notion irreducible plans introduced kambhampati        
exploited admissible pruning partial plans search   
   short review pop algorithm  corresponding formalism provided appendix a 
familiar algorithm  note one slight technical change  stemming use unary
operators  pop uses two fictitious actions a  capture initial goal state  respectively 
here  replace actions set actions  single effect   fictitious  action
setting initial value variable vi denoted a i fictitious action whose precondition
goal value variable vi denoted ai  
   irreducible plans called  kambhampati        minimal plans  however  decided change
name concept order prevent ambiguity minimal irreducible minimal
optimal 

   

fistructure complexity planning unary operators

now  given planning instance   let p set irreducible plans  
denote maxreq v  maximal number times variable v v changes value
course execution irreducible plan   formally  let req p  v  number
times v changes value course execution plan p   then 
maxreq v    max req p  v  
p p

observe that  planning problem unary operators  variable must change
value required change immediate successors causal
graph  in order satisfy necessary prevail conditions   order
obtain value requested goal  thus  variables v  maxreq v  satisfies 
x
maxreq v     
maxreq u 
   
succ v 

succ v  denotes immediate successors v corresponding causal graph 
adopting terminology  domshlak   shimony        shimony   domshlak        
directed acyclic graph g directed path singly connected if  every pair nodes s  g 
one directed path t  following lemma shows causal
graph forms directed path singly connected dag bound maxreq v  n 
clearly  polytrees directed path singly connected dags  vice versa 
lemma   solvable problem instance directed path singly connected causal
graph n variables  variable v  maxreq v  n 
proof  proof induction n  n     obvious maxreq v    
suppose  v    n   v v 
maxreq v  n  
let   problem instance  v       n  suppose variables v    
 v          vn   topologically ordered based domains causal graph  clearly  vn
leaf node  i e   succ  vn        denote problem instance obtained
removing vn domain  corresponding variable set v  according eq    
immediate predecessor v vn causal graph 
newmaxreq v  maxreq v    newmaxreq vn   maxreq v     
newmaxreq v  denotes maxreq v  respect     generally  since causal
graph directed path singly connected  variable v v    

maxreq v       path v vn
newmaxreq v 
   
maxreq v  
otherwise
thus  v v     holds
newmaxreq v  n

   

fibrafman   domshlak

recall maxreq v  stands upper bound number value changes v
may required valid  irreducible plan  however  maximal achievable number
value changes v  denoted maxposs v  greater less maxreq v  
example  v predecessors causal graph  two operators affecting
v differently  maxposs v     
denote upper bound feasible number value changes v may
required valid  irreducible plan fmaxreq v   informally 
maxposs v  value changes v required maxreq v  value changes
v required  thus
fmaxreq v    min maxposs v   maxreq v  

   

determining fmaxreq v  variables requires explicit examination given problem instance  recall restrict causal graph form polytree 
simplify presentation  assume goal values specified state variables 
i e  goal d v          d vn    later show assumption affect
generality algorithm  denote v   v initial goal values v  
v set operators affecting v  first examine root variables
causal graph  analyze rest variables 
denote pred v  immediate predecessors v causal graph  pred v     
 
 

two operators
v   av v   av v postcondition 

av reverse effect  since operators prevail condition 
v
 
av presented   applied one another infinite number
 
times  therefore  eq     fmaxreq v    n  v     a
v   av   two cases 
initial goal values v same  cannot change value v
reconstruct later  thus fmaxreq v       alternatively  initial goal
values v different v    a 
v   achieve goal value v
thus fmaxreq v       otherwise  goal value v unachievable  thus
given problem instance unsolvable  table   summarize analysis 

v 
v 

 

v

  

v

v

 av   a 
v 
otherwise
 
 a
v   av  
 
 av  
otherwise

fmaxreq v 
n
 
n
 
solution

table    fmaxreq v  values root variables causal graph 
consider variable v presented internal node causal graph 
pred v     w            wk    
    observe number possible value changes v depends
on 
   initial goal values v  i e   v   v  
   

fistructure complexity planning unary operators

   set operators affecting v  i e   v  
   maximally possible  but still reasonable  number times predecessors v
change values  i e   fmaxreq w             fmaxreq wk   
   actual scheduling value changes predecessors v 
last point crucial means order determine fmaxreq v  find
particular scheduling value changes pred v  allows maximal number
value changes v  corresponding interleaving sequence vs values  starting
finishing v   v respectively  fmaxreq v  value changes called maximal
denoted  v     v     fmaxreq v       
lemma      k  fmaxreq wi   n  thus number different
orderings value changes pred v  exponential n  instance  when 
  k  fmaxreq wi     n  number different orderings expressed
as 


k 
n
yx
n   ni    
 nk
j
j 
i   j  

correctness expression left side inequality shown lemma  
 see appendix b  p        clearly  cannot check orderings naive manner 
following  provide algorithm determines  v  time polynomial n 
clarity presentation want distinguish different elements
maximal sequence  v   since variables binary  denote initial value v  v    
bv opposite value wv  black white   similarly  bi wi stand
corresponding values variable vi   so  think operators
described language  likewise  sequentially number appearances
value v  v   example  biv stands ith appearance value bv along
 v   illustrate notation  suppose d v     true  f alse   initial value v
v     true  fmaxreq v       then  have 
bv true
wv f alse
 v    b v wv  b v wv  b v
first  every variable v  every operator v extended set operators
explicitly specify prevail values parents v causal graph   pred v     k 
prevail condition specified terms   k   k parents 
 
v  extended set  kk operators  operator extends
instantiation previously unspecified parents v  example  consider variable v
pred v     u  w   operator
   pre    bv    post    wv    prv    bu    
   every parent wj v  prv a  j    u 

   

fibrafman   domshlak

prevail condition involve w  operator extended pair
operators 
a     pre    bv    post    wv    prv    bu   bw   
a      pre    bv    post    wv    prv    bu   ww   

corresponding possible values w  follows  refer operator set
resulting compilation      note that  assumption constantly
bounded maximal indegree causal graph  compiling    takes polynomial
     thus         o n      
time  since  every variable v     
v   
given maximal sequences  w              wk   operator set   
v construct
 
directed graph  denoted ge  v   captures  and only  feasible sequences of 
n  value changes v  value change annotated corresponding
assignment pred v   although number captured sequences exponential
n  size g e  v  polynomial n  respect graph  problem finding
maximal sequence  v  reduced problem finding longest path given
node arbitrary node directed acyclic graph 
graph g e  v  created three incremental steps  first step  given
maximal sequences  w              wk   operator set   
v construct directed labeled
graph g v  capturing information sequences assignments pred v 
enable n less value flips v  graph g v  defined follows 
   g v  consist nodes 

n    n    j   v     v   
  n    j       v      v     j n
 

n    otherwise
   g v  forms   colored multichain  i e    i  nodes graph colored black
white  starting black   ii  two subsequent nodes
color   iii       edges node node     
observe construction g v  promises color last node
consistent v  
   nodes g v  denoted precisely elements maximal sequence
 v   i e   biv stands ith black node g v  
   suppose operators   
v change value v bv wv  

case  i  edges biv wvi      
v   edges wv
bi  
v   edges labeled prevail conditions corresponding operators 
i e   k tuple values w            wk   tuple denoted l e   label
edge e  component  corresponding predecessor wi   denoted l e wi  
formal definition g v  relatively complicated  thus provide demonstrating
example  suppose given problem instance   variables  consider
   

fistructure complexity planning unary operators

variable v pred v     u  w   v     bv   v   wv   recall every operator
   presented three tuple hpre  post  prvi pre   post   prevail conditions
operator respectively  suppose that 
 
 
 u    b u wu 
 w    b w ww
b w ww
 
av    pre    bv    post    wv    prv    bu   ww   
  
a     pre    wv    post    bv    prv    bu   bw   
v  
v 
av    pre    wv    post    bv    prv    wu   ww   

case  graph g v  presented figure   
bu bw
bu ww  
b v

wv 

bu bw

 
 

bu ww  
b v

wv 

 

  bu ww  

  bv

wv 

wu ww

wu ww

figure    example graph g v  
constructed graph g v  captures information potentially possible executions operators   
v provide us maxreq v  less value changes v 
path  started source node g v   uniquely corresponds execution 
although number alternative executions may exponential n  graphical representation compact  number edges g v  o n    
v     note
information number times operator   

executed
v
captured g v   following two steps add information indirectly exploit
find maximal sequence  v  
second step construction  expand g v  respect maximal sequences  w              wk   follows  edge e g v   which definition corresponds
operator   
v    replaced set edges labels correspond
possible assignments elements  w              wk   l e   i e   prv a    likewise 
add dummy source node sv   edge sv original source node g v 
labeled tuple first elements  w              wk      initial values w            wk   
similarly  add dummy target node tv   edge original target node
g v  tv labeled tuple last elements  w              wk      goal values
w            wk    denote extended graph g   v   figure   illustrates g   v 
example above 
extended graph g   v  viewed projection maximal sequences  wi   
  k  graph g v   edge g v  may replaced o nk   edges g   v  
thus number edges g   v  o nk      
v    
easy see paths g   v  starting sv relevant  example 
g   v  above  operator instance prevailed b u b w performed operator
    thus  faced problem finding longest
instance prevailed b u ww
feasible path sv node g   v   label consistent v  
following  last  step provides reduction problem finding longest feasible path
sv v  colored node g   v  known problem finding longest path
   

fibrafman   domshlak

b u b w

b u b w
 
b u ww

sv

b u b w

  b 
v
 
b u ww

 

b u b w
 
  wv
  w 
wu
w

 
 
  bh v

 
b u ww

 
b u ww

  w 
wu
w

 

b u b w
 
  wv

 
 
  bh v

  w 
wu
w

 
b u ww

 

 
  wv

  w 
wu
w

  tv

 
b u ww

  w 
wu
w

figure    example graph g   v  
directed acyclic graph  let graph g e  v  edges g   v  nodes  let
edges defined allowed pairs immediately subsequent edges g   v    e  e   
allowed if    k  either l e wi   l e   wi l e   wi appears l e wi  wi   
construction variant called edge graph known graph theory  addition
case exclusion non allowed edges it  clearly  g e  v  constructed
 
time polynomial size g   v   number edges g e  v  o n k      
v     
b u b w

b  b 

 
wu  ww

 
wu  ww

u  w j
   jj
   jjj
   jjjj
   jjj
j
  
jj
jj
  
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
bu bw   
b u ww
bu ww
bu ww
bu bw   
    
    
jj
 
    
  
u 
jj
     
   
u
    
    
jj
u
 
 
    
   
jj
     
     
u
j 
 
 
 
 
 
 
u
    
    
  
     
 
 
 
 
 
 
 
 
 
 
 
bu bw
wu  ww
     
    
     
     
ii
u 
    
    
ii
u
     
     
ii
uu
    
    
     
     
ii
uu
u
 
 
 
 
 
 
i 
u
  
  

u

   w  w 
   w  w 
 
  w 
  w 
b u ww
b
b
u wj
u w
   u w
   u w
jj
jj
jj
  
jj
jj    
jj  
jj  
jj  
j 
 

figure    example graph g e  v  
figure   presents g e  v  example  dashed edges present longest path
dummy source node node corresponds value change v v
 from bv wv    longest path g e  v  describes maximal sequence value changes
 v   length actually fmaxreq v       example   v    b v wv  b v wv   
fmaxreq v       note v     v empty path acceptable since 
general  v change value  case fmaxreq v       v 
consist one element corresponds initial    goal  value v 
observe longest path g e  v  describes  v  actual sequence
j
invocations operators   
v provides  v   denote  a bv   
j
 a wv    sequences operator instances effects corresponding elements
sequences  bjv    wvj     bjv    wvj      v   vs values  respectively 
follows  address sequences operator instances one sequence operator
   

fistructure complexity planning unary operators

procedure forward check   
   topologically sort variables v based causal graph 
   variable v v  call determine max sequence   v   respecting
ordering 
   one calls determine max sequence return failure  return failure 
otherwise return success 
procedure determine max sequence    v 
   pred v   
 a  v      v a 
v   v   return failure 
 b  otherwise  determine  v  according rules table    return success 
   otherwise  pred v     w            wk  
 a  construct g v   based v     v     
v   
 b  construct g   v   from g v   based  w            wk    
 c  construct g e  v   from g   v   based  w            wk    
 d  determine longest path g e  v  node corresponding v  ended value
change  derive  v  corresponding sequence operators it 
 e  v      v fmaxreq v       return failure  otherwise  return success 
figure    forward check algorithm
fmaxreq v 

instances v    a vi   i  

vi

 




  a vi   vi effect 
i  

bv    

 

w  
v

   k    

kn

   k

procedure forward check figure   summarizes presented approach  note
finding set longest paths node nodes directed acyclic graph
done time linear size graph  wiest   levy         therefore 
time complexity call determine max sequence procedure variable v
 
bounded size constructed graph g e  v  thus o n k      
v      forwardcheck calls determine max sequence n times  therefore  maximal node indegree
bounded constant   overall complexity algorithm o  v            
i e   polynomial size problem description 
theorem   given problem instance polytree causal graph solvable
if  v v  forward check succeeds constructing maximal sequence  v  
forward check fails least one calls determine maxsequence procedure fails  turn  call determine max sequence variable v
   

fibrafman   domshlak

algorithm  pop pcg  ha  o  li  agenda   
   termination  agenda empty  return ha  o  li
   goal selection  let hi   aneed rightmost pair agenda  by definition 
aneed one pre prevail conditions aneed   
   operator selection 
 a  aneed    ai  i   ij   aadd   a ij    a i   
 b  otherwise 
i  let   max   j   a ij   a  
ii  vi consistent im  both associated color  b  w  
aadd   a im    else aadd   a im     


   plan updating  let l   l  aadd aneed    let    aadd   aneed   
aadd newly instantiated     aadd      a i   aadd   ai  
 otherwise remain unchanged  
   update goal set  let agenda   agenda    hi   aneed i   aadd newly instantiated 
pre prevail conditions q  add hq  aadd agenda 
   threat prevention  aadd   a ij    j      then  a  s t  ij  belongs
prevail conditions a  add  a   a ij    o 
   recursive invocation  pop pcg ha  o  li  agenda     agenda topologically ordered  based causal graph respect precondition part
pair  
figure    pop pcg algorithm
fails initial goal values v different way
change value v even once  thus  forward check fails  plan exists 
prove opposite direction proceed follows  define pop pcg algorithm
 pop polytree causal graphs  show succeed without backtracking
forward check succeeds   pop pcg described detail figure    works
follows  first  let us expand sequence operator instances a i     a b i   
stand dummy operator a i    recall now  operators
form a ij   j     defined   algorithm maintains goal agenda sorted based
causal graph structure  parent variables appear descendents 
point  next agenda item selected  requires achieving value vi add
corresponding operator plan desired effect  step  a   actually  would
ready accept plans possible redundant steps  omit next step  b
algorithm assuming goal value variable v last element
   short review pop algorithm  corresponding formalism  description initial
call algorithm  refer reader appendix a 

   

fistructure complexity planning unary operators

maximal sequence  v   however  would plan irreducible  careful
decision really required number value changes variable required 
decision captured step  b analysis value changes variable vi
found necessary previous iterations algorithm order satisfy
predecessors vi causal graph  note agenda sorted respect
reverse topological ordering causal graph  thus operator affecting vi selected
agenda operator affecting predecessor vi causal graph
appear agenda end algorithm  threats arise pop pcg 
ordering constraints consistent 
lemma   forward check successful pop pcg return valid plan 
proof 

lemma follow following claims 

   every agenda item  exists operator effect 
   threats output pop pcg 
   ordering constraints consistent 
   agenda empty polynomial number steps 
proof see appendix b  p      
recall that  simplicity presentation  assumed goal values specified
state variables  single goal state   i e  goal d v          d vn    show
presented approach  minor modifications  works set possible goal states
well  set specified partial assignment v  i e  goal d   v        d   vn   
note latter assumption widely accepted planning literature 
first  modifications done processing variables specified goal 
now  variable v  v specified goal  modifications
follows 
   graph g v  consist exactly n nodes  correct since  i  according
lemma    n changes v sufficient   ii  value change v
last value change 
   changes construction g   v  g e  v  
   procedure determine max sequence 
 a  step  d  determine longest path dummy source node
node graph 
 b  step  e  always return success 
again  correct since value change v last value change  and 
particular  v may remain unchanged plan given problem 
finally  pop pcg algorithm starts null plan contains end operator
ai vi specified goal 
   

fibrafman   domshlak

   directed path singly connected general dags
section analyze planning complexity face complicated causal graphs 
first  show causal graph directed path singly connected even plan
existence np complete  second  show general causal graphs situation
even worse  finally  characterize important parameter causal graph affecting
planning complexity  allows us extend class problems np 
theorem   plan existence strips planning problems unary operators directedpath singly connected causal graph np complete 
proof 

proof see appendix b  p      

note node indegree causal graph problem created proof
theorem   bounded    hardness directed path singly connected causal graphs
maximal indegree lower   thus open 
directed path singly connected structure causal graph turns crucial
guaranteeing reasonable solution times  show  solvable propositional planning problems arbitrary acyclic  dag  causal graph minimal
solutions exponential size  analysis class problems points reason
provable intractability  allows us characterize important parameter causal
graph affecting planning complexity extend class problems np 
however  restricted problems still np complete 
theorem   plan generation general strips planning problems unary operators
acyclic causal graph provably intractable  i e  harder np 
theorem follows theorem      jonsson   backstrom      b   shows
plan generation  s problem class provably intractable  point
upper bound minplansize  presented eq     exponential size input
case  first  show example upper bound achieved 
present analysis reasons intractability 
following example shows exponential upper bound achieved 
used proof theorem      jonsson   backstrom      b   originally
presented different context backstrom nebel         consider propositional
planning problem  v    n  where    n  d vi            pred vi    
 v          vi     operator set consist  n operators  a    a             a n  
pre ai   j   

post a i   j 


 

  j  
u otherwise


 
pre a i   j    post ai   j   
u

 
 
 
prv ai   j    prv ai   j   

u
   

j  
otherwise
j    
j    
otherwise

fistructure complexity planning unary operators

easy see causal graph problem forms dag  see figure    
instance planning problem initial state h            i goal state
h               i unique minimal solution length  n   corresponding hamilton
path state space 
pqrs
wvut
v 

pqrs
  wvut
v 

 

   

 

pqrs
wvut
vn 

 
pqrs
  wvut
vn
 

figure    causal graph proof theorem  
show escalation complexity parametrized form
causal graph 
lemma   solvable problem instance acyclic causal graph n variables  variable v  that 
maxreq vi      

n
x

 vi   vj  

j i  

 vi   vj   denotes total number different  necessary disjoint  paths vi
vj   variables ordered via topological sort causal graph 
proof  proof induction i    n obvious maxreq vn     
assume lemma holds   k  prove   k  without loss
generality  assume succ vk        otherwise  simply maxreq vk     
proof straightforward 
eq   

maxreq vk  



x

   

maxreq vik  

vik succ vk  
i h 



x

     succ vk     

vik succ vk  

 

  

n
x

n
x

 vik   vj    

j ik   

 vk   vj  

j k  


lemma   entails upper bound minplansize   general planning problem
unary operators acyclic causal graph depends number different paths
nodes causal graph  immediate conclusion significant
class problems acyclic causal graph planning np  let dag
called max  connected number different directed paths every two nodes
graph bounded  
   

fibrafman   domshlak

theorem   plan generation strips planning problems unary operators max connected causal graph np complete polynomially bounded 
proof  membership np straightforward  variables given problem
considered topological ordering induced causal graph  lemma   follows
that  variable vi   maxreq vi   n  turn  follows minplansize  
n    thus  polynomially bounded  guess minimal plan
could verified polynomial time 
hardness follows theorem   shows even causal graph max  connected  directed path singly connected   plan existence  and thus plan generation 
hard 

   serializable subgoals
set subgoals defined serializable  korf        exists ordering among
subgoals subgoals always solved sequentially without ever violating
previously solved subgoal order  naturally  collections subgoals
serializable sometimes may necessary interleave plans achieving different goals 
however  problem instance serially decomposable  possible design set
macro operators respect subgoals serializable  korf        
problem instance serially decomposable exists ordering state
variables effect operator state variable depends
state variable previous state variables ordering  unfortunately  bylander       
shows determining serial decomposability problem pspace complete 
one major open problem put forth bylander context is  problem
known serially decomposable  difficult determine whether given instance
solvable  far know  work direction done chalasani
et al          serial decomposability general permutation problem
considered  particular  showed problem np  unknown
whether np hard  recently  complementary results bylanders question
presented koehler hoffmann         results shed light question 
problem instance based unary operator domain whose causal graph acyclic
serially decomposable  therefore  concluded finding solution serially
decomposable problems may require exponential time  i e   problem exptime  
however  bylanders question plan existence  case  theorem  
apply  apply np hardness result  for directed path singly connected
graphs   since addresses plan existence well 
weld        hypothesized that      underlying causal graph planning
problem acyclic  serialization ordering subgoals problem obvious 
    serialized subgoals could solved extremely quickly backtracking required
them  although first observation sounds intuitive  results suggest
rarely true  acyclicity causal graph implies serializability 
cases structure provide us sufficient information actual serialization
ordering  even causal graph directed tree one must think first choosing
   

fistructure complexity planning unary operators

ordering  likewise  results imply causal graph form
undirected tree determining subgoal ordering np complete  causal graph
directed path singly connected  problem even complex 
second observation always true either  problem important
determine serialization ordering subgoals  exact strategies
achieving them  showed  certain cases  problem n serializable subgoals
requires exponentially long solution  domain variables binary 
situation even worse corresponding complexity results derived
computational analysis domshlak dinitz        

   connection related work planning complexity
idea analyzing exploiting structural properties new classical planning 
last years number important results emerged  generating plans
context strips representation language shown bylander       
pspace complete  despite fact  existence many successful planning systems 
especially recent years  demonstrates planning possible practical wide list
domains  bylander argues large gap theoretical hardness planning
practical success stems use domain dependent problem analysis
algorithms  consequently  various authors explored existence constrained
problem classes planning easier 
section shortly overview major  previous results complexity
planning  discuss relationship results presented paper 
detailed presentation previous results discussed refer reader
original papers 
    local syntactical restrictions
seminal paper  bylander        presents number complexity results propositional planning  analyzing different planning problems based type formulas used 
number type  positive negative  operator pre  postconditions  etc  work
bylander extended interesting  complementary results erol al         
example  bylander shows propositional planning domains operator
restricted positive preconditions one postcondition tractable  generally  extremely severe restrictions operators required guarantee tractability 
even membership np  note bylander        erol et al         focuses local
syntactical properties operators  i e   properties single operators 
syntactic restriction pose planning problems paper
unarity operators  determining plan existence this  apparently easier class
problems shown bylander hard general propositional planning  i e 
pspace complete  note result entail theorem    since
planning problems unary operators may induce causal graphs cycles  therefore 
none results entailed results presented bylander        erol et
al         
   

fibrafman   domshlak

    global syntactical restrictions
backstrom klein      a      b   and  subsequently  backstrom nebel        
consider types restrictions  using refined model  the sas formalism 
which 
   state variables multi valued 
   two types preconditions considered  prevail conditions  variable
values required prior execution operator affected
operator  preconditions  affected operator 
general  four different restrictions considered works 
 p  post uniqueness  effect one operator achieves effect 
words  desired effects determine operators used plan  formally 
problem instance post unique if  vi v x d vi   
one operator post a  i    x 
 s  single valuedness  one value state variable appears prevail
conditions operators  instance  certain operator requires light
 as prevail condition   operator use prevail condition
light off  formally  problem instance single valued iff exist
two operators a  a  vi v prv a  i     u  prv a    i     u 
prv a  i     prv a    i  
 u  unariness  operator affects one state variable 
 b  binariness  state variables exactly two possible values  i e  state variables
propositional 
four properties syntactical  however  properties p differ
properties u b fact global nature  post uniqueness singlevaluedness restrict form operators  global property whole set
operators  backstrom nebel        showed us  unariness single valuedness 
extreme problem class plan generation polynomial   
problems analyzed paper belong problem class ub  definition  already mentioned  even determining plan existence class problems
pspace complete  consider problem class pub  backstrom nebel       
showed that   i  pub instances exponentially long minimal solutions  thus plan
generation pub requires exponential time   ii  existence bounded length plans
pub strongly np hard   iii  complexity general plan existence pub still
open question  informally means strengthening restrictions ub pub
reduce complexity significantly  least practical point view 
proposition   every ub problem instance tree causal graph either post unique 
transformed equivalent post unique problem instance  low  polynomial
time  thus  treeub pub 
   thorough analysis complexity sas planning  refer backstrom nebel        

   

fistructure complexity planning unary operators

proof  consider ub problem tree causal graph  suppose postunique  means exist variable v v  d v     v     v      
exist two operators a    a  v change value v v   v      prv a      
prv a    
assumption causal graph forms tree follows  pred v     
pred v      easy see existence pair operators
simply impossible  therefore  let pred v     w   d w     w    w      without loss
generality assume prv a    w     w     prv a    w     w      otherwise  if  instance 
prv a    w    u  easy see a  redundant operator 
observe case  prevail dependence v w redundant  replace
pair operators a    a  single operator changes value v
v   v    without prevail condition  replacement a    a  brings us
equivalent problem instance operator set v post unique  way
continue process iteratively problematic variables v arrive postunique problem instance 

proposition   ub problem instances tree causal graph singlevalued  thus treeub   ubs 
proof  proof proposition   straightforward  consider variable v v  d v   
 v     v       succ v     u  w   case value change u
prevailed v     value change w prevailed v      therefore  restricting
causal graphs even trees entail single valuedness  
propositions     show treeub polynomial subclass pub
entailed tractability results backstrom nebel        
proposition   ub problem instances polytree causal graph neither single valued  post unique 
proof  proof straightforward  consider planning problem polytree causal
graph  exist variable v v pred v     u  w   following
operator set v  
pre
v 
v 
v   
v   

post
v   
v   
v 
v 

prv
 u    w    
 u     w   
 u    w   
 u     w    

clearly  problem instance v neither single valued  postunique  since  i  one operator achieving value v   ii 
values u  and values w  appear prevail conditions operators v   note
   using simple construction technique proof proposition   shown restricting
causal graphs directed chains entails single valuedness  however  case restrictive 

   

fibrafman   domshlak

maximal indegree polytree minimal  i e  equal    thus 
proposition valid polytree tree 
proposition   follows theorems     introduce new polynomial
np easy subclasses ub problem class  respectively 
    structural restrictions propositional planning
jonsson backstrom      b  present  s class planning problems  class
closely related problems examined paper  since defines special subclass
problems binary variables  unary operators acyclic causal graphs   s problem
class defined posing additional  relatively severe  restrictions problems
operator set  variable v  s problem instance required either  i  static 
i e   unchangeable   ii  symmetrically reversible  i e   operator affecting v 
exist operator a  affecting v prevail conditions opposite effect 
 iii  splitting  formal definition splitting property refer jonsson
backstrom      b   informally  binary variable v splitting problem
instance split three  well defined subproblems solved independently 
class planning problems shown plan existence determined
polynomial time  plan generation provably intractable  since instances
 s exponentially long minimal solutions  particular  problem instance
used proof theorem    s 
complexity analysis jnonsson backstrom      b  somewhat unique
research complexity propositional planning  since  best knowledge 
attempt exploit syntactical restrictions operator set 
structural restrictions interaction variables  analysis
seen continuing direction looking structural restrictions only 
believe eliminating marginal effect problem structure problems  potential  hardness allow us understand better connection component
interactions topology  potential complexity problem 
    structural restrictions multi valued formalisms
variables longer propositional  additional properties problems
identified  and  possibly  exploited  particular  additional internal structures
problem analysed 
jonsson backstrom      a  analyze different properties multi valued problem
structure  called domain transition graph  structure defined
state variable problem  describes possible transitions different values
variable  domain transition graph state variable v directed labeled
graph gv    v  e   v associated vs set possible values  d v  
 x  a  y  e operator applied state v   x 
application results state v   holds 
jonsson backstrom identify sets structural restrictions domain transition
graphs make planning instances tractable  roughly  properties following 
    problem domain interference safe  i e   operator either unary irreplace   

fistructure complexity planning unary operators

able respect every variable affects  operator irreplaceable respect
variable v removal edges gv stem disconnects
weakly connected component gv       every variable v  graph gv   restricted
set values appear prevail conditions operators  acyclic     
sequence operators annotating path x domain transition graph v 
stronger shortest sequences connecting x y  here  sequence a            ak
stronger a             a l subsequence ai            ail a            ak
every   j l  prevail conditions a j subset prevail conditions aij  
jonsson backstrom present map computational complexity problems
different restrictions  displaying frontier tractable intractable cases 
domain transition graph combines structures influence many operators
particular variable  therefore  provide us global picture operator
set alone  hence  spite fact domain transition graphs capture relationship different variables  allow us express structural properties
address interactions variables  e g   see property     above  
observe domain transition graphs informative case propositional planning  since distinguish variables changed
one direction variables changed directions  although
property domain transition graphs allows distinguish polynomial
planning positive postconditions  pspace complete planning
positive negative postconditions  bylander         seems helpful
hierarchical refinement propositional planning complexity  hand 
priori reason causal graphs informative multi valued
case  exploiting properties causal graphs  together properties domain
transition graphs  seems natural direction extend work presented paper 
recent work domshlak dinitz        multi entity off line coordination
seen investigating connections structure causal graph  together
properties domain transition graphs  complexity corresponding
problems case multi valued domains  best knowledge 
work done respect mixed structural analysis  lot work
remains done  instance  combining various properties domain transition
graphs studied jonsson backstrom      a   properties problems
causal graph direction research 

   summary future work
shown form causal graph strips planning problems unary
operators important factor determining computational complexity plan generation  particular  shown polynomial time algorithm exists
problem polytree causal graph node indegree bounded constant 
generally  result shows planning polytree causal graphs  what
often referred bayes nets literature as  locally exponential  i e   exponential maximal number parents node  note hardware control planning
problems maximal node indegree expected small  since prevail dependencies
variables reflect direct interconnections corresponding hard   

fibrafman   domshlak

ware components  likewise shown problem directed path singly
connected causal graph maximal plan length low order polynomial  problem
np complete  generally  shown relation number paths variables causal graph computational complexity corresponding
planning problem  finally presented impact results question
complexity planning problems serializable subgoals  connected work
previous results planning complexity 
work leaves number open questions respect purely syntactical 
mixture structural syntactical restrictions planning problems unary
operators  former case  one important directions analysis
causal graphs constantly bounded node indegree  turns complexity analysis class problems helpful understanding various computational
properties cp nets  boutilier et al          although provided partial answer
question  general picture worst case complexity class problems
clear  example  indegree causal graph known bounded
   structural property causal graph  even clear whether
problem subclass np 
latter case  various syntactical restrictions analysed together form
causal graph  example  one may interested computational properties
problems acyclic causal graphs  restriction every operator
prevail conditions  bounded constant  this  well many
related questions respect various special cases planning unary operators
interest future work 

acknowledgments
preliminary version paper appeared sixth international conference artificial intelligence planning scheduling  april        would thank three
anonymous reviewers extremely helpful comments  ronen brafman supported
part paul ivanier center robotics research production management 

   

fistructure complexity planning unary operators

appendix a  short review pop  causal links threats
represent plan tuple  ha  o  li  set unary operators  set
ordering constraints a  l set causal links  example     a    a    a   
might set  a    a    a    a     constraints specify plan
a  necessarily last operator  commit particular order a  a   
naturally  set ordering constraints must consistent  i e   must exist

total order satisfying them  causal link form ap ac   ap ac
operators possible value propositional variable vi   denotes fact
ap produces  i e   postcondition  vi   consumed ac  i e   used
satisfy pre  prevail condition ac    causal links help us detect whether one operator
interferes work done enable execution operator ac  
case  said constitute threat one a c causal links  formally  suppose


ha  o  li plan  ap ac causal link l  let different operator a 


say threatens ap ac following two criteria satisfied 
 ap     ac   consistent 
effect 
partial order plan p contains threats  possible goal
achieved  or all  total order plans consistent p ordering constraints 
prevent this  plan generator must check threats remove adding one
two possible ordering constraints    ap  demotion  ac    promotion  
tutorial introduction pop algorithms found  weld         pop
regressive framework partial order planning starts null plan continuously updates inserting new actions removing threats  process continues
precondition prevail conditions every operator plan supported
causal link threats exist  first argument pop plan second
argument agenda goals need supported causal links  item
agenda represented pair hi   ai either pre  prevail condition plan
action a  last argument pop whole collection operators defined
planning instance  initial call pop contains null plan  specially initialized
agenda  operator set given problem 
paper introduce specialized  deterministic pop algorithm starts
planning process using variant null plan encodes planning problem 
particular  planning instance v            vn goal corresponding null
plan exactly  n dummy unary operators     a             a n   a               n ordering
constraints      a     a              a n       causal links  l       every
vi v  a i corresponding start operator   neither pre  prevail conditions 
effect specifies value variable vi initial state  denoted
vi    similarly  ai end operator   effect  prevail conditions 
precondition set value vi goal state  turn denoted vi   
   actually  goal state may specify values variables  thus number end
operators less n  however  clarity presentation  leave definition null
plan 

   

fibrafman   domshlak

description null plan modified weld        better suit
restriction unary operators  likewise  initial call pop algorithm contains
agenda  hv    a  i          hvn   i  

   

fistructure complexity planning unary operators

appendix b  proofs auxiliary results
lemma   forward check successful pop pcg return valid plan 
proof 

lemma follow following claims 

   every agenda item  exists operator effect 
   threats output pop pcg 
   ordering constraints consistent 
   agenda empty polynomial number steps 
      first claim follows success forward check procedure 
forward check implies ij  vi   operator instance a ij  
 a i    therefore  ij  vi   existence appropriate aadd promised 
assume contrary ij    vi   and  without loss generality  assume
first iteration happens  so  variable u succ vi   
edge labeled ij graph g   u   created forward check 
follows aneed cannot ij prevail condition  thus aneed affect
variable vi itself  case either aneed   a ij     aneed   ai  
consider former case  aneed   a ij     ij   previously selected
agenda  assumption means ij    vi    contradicts assumption
ij    vi   since ij predecessor ij    vi   
consider last option aneed   ai   aadd   a ij   goal value
variable vi consistent ij   a ij     see step   b ii   a ij   
ij  previously selected agenda  assumption means
ij   vi    however  contradicts assumption ij    vi   since  vi   
definition  terminates node consistent goal value vi  
addition  since shown operators added
 a i   ai      n  agenda empty o n    steps 


    suppose operator threatens ap ac   i e  
 ap     ac   consistent 
effect 
given variable vi   pop pcg forces operators affecting vi follows  step    
a i a i      a i              a ix   

x fmaxreq vi  

   

thus ac operator prevail condition  note ap
affect variable vi       already showed   ij  vi   
case   a il    l   j  however  ij prevail condition ac ordering
constraint  ac   a ij      added step    eq     follows
   

fibrafman   domshlak

 a il     a ij      a ij       a il     l   j  implied  ap     ac   
contradicts assumption  ap     ac   consistent 
    ordering constraints consistent two operators ai aj
implies   ai   aj     aj   ai     follows  ai used denote arbitrary
operator affecting variable vi  
first note ordering constraint added step   step   either
operators affecting variable operators affecting variable child
 with respect causal graph   particular  ai   aj added step   either
vi   vj vi pred vj    whereas ai   aj added step   vj pred vi   
assume  contrary implies ai   aj aj   ai   argument
above  know a  possibly empty  path vi vj undirected
graph induced causal graph  structural assumption  know
undirected path vi vj unique  thus situation follows 
two chains operators
  ai   a i            axi     a i            axi                   a im           aximm   aj
  ai   a i            ayi     a i            ayi                   a im           ayimm   aj

that    k m  xk   yk    corresponding unique undirected
path vi vj is 
vi   vi  vi        vim  vim   vj
without loss generality  internal elements disjoint  otherwise 
operator b belongs internal parts reduce
chains deduce ai   b ai   b 
proof consistency follows 
 a  prove exist least one least
one internal element 
 b  show useful property   exploited  c  
 c  show   k m  axikk ayikk different except x    y      
note  a  together  c  contradicts assumption aximm   ayimm  
 a  assume  contrary  contain internal elements 
so  algorithm actually adds ordering constraints ai   aj aj   ai  
vi vj variable ai   aj stem step  
ai precondition aj effect  however  definition forwardcheck  aj role w r t  ai thus impossible aj   ai
added o  alternatively  vi parent vj ai   aj stem step  
ai prevail condition aj effect  suppose ai   a bji   thus
bji prv aj    turn  aj   ai added step   aj precondition
ai prevail condition  bji prv aj   ai   a wij    contradicts
   

fistructure complexity planning unary operators

assumption ai   a bji    alternatively  assume ai   a wij  
situation completely symmetric  thus result same  hence proved
either contain least one internal element  particular means
next last elements different fact exploited later
proof 
 b  consider subchains consist operators affecting one particular variable  subchain  i e    k m    j xk    ordering
j
j  
constraint ajik   aj  
ik stem step   aik precondition aik
effect  thus  post ajik     pre aj  
ik    similarly  subchains     k
j
  j yk   post aik     pre aj 
ik    follows denote property
local monotonicity 
 c  first suppose either x      y       both  consider following sequence 
  ayi     ayi               a i    a i          axi  
local monotonicity  construction forward check  fact     
 
follows post ayi    appears post axi     maximal sequence vi    continuing
 

next variable vi  claim post ayi    appear post axi     vi   
 i  vi  parent vi  axi     a i  stem step   axi  
prevail condition a i  effect  turn  ayi     a i  stem step  
prevail condition a i  precondition ayi     relation
axi   ayi     construction g e  vi    forward check  follows post a i   
appears post a i     vi     subsequently  local monotonicity follows
post ayi     appears post axi      vi    
 ii  similarly  vi  parent vi  ayi     a i  stem step  
a i  prevail condition ayi   effect  axi     a i  stem step  
prevail condition axi   precondition a i    relation
axi   ayi     construction g e  vi    forward check  follows post a i   
appears post a i     vi     again  local monotonicity follows
post ayi     appears post axi      vi    
alternatively  x    y      axi     ayi     ai    a  immediately follows
a i     a i    analysis similar shows post ayi     appears
post axi      vi    
established post ayi     appears post axi      vi     apparent
inductive argument allow us show k     post ayikk  
appears post axikk    vik    note particular means operators
axikk ayikk different  contradicts assumption aximm   ayimm  

   

fibrafman   domshlak

theorem  
plan existence strips planning problems unary operators
directed path singly connected causal graph np complete 
proof  first show membership np  let minplansize   denote size
minimal plan problem instance   using maxreq property state variables 
following upper bound minplansize   straightforward lemma   
x
minplansize  
maxreq v  n 
   
vv

thus  guess minimal solution given solvable problem  verify low
polynomial time 
proof hardness polynomial reduction   sat corresponding
propositional plan generation problem directed path singly connected causal graph 
  sat problem finding satisfying assignment propositional formula conjunctive normal form conjunct  clause  three literals 
let f   c       cn propositional formula belonging   sat  let x            xm
variables used f  equivalent propositional planning problem directedpath singly connected causal graph constructed follows  variable set v  
 x    x            xm   xm    c            cn    variables xi xi predecessors
causal graph  thus pred xi     pred xi         turn    n  pred ci    
 xi    xi    xi    xi    xi    xi     xi    xi    xi  variables participate
ith clause f  finally  init goal consist false true assignments
variables v  respectively 
let every operator presented three tuple h pre    post    prv i pre  post 
prevail conditions respectively  then  corresponding operator set specified
follows 
xi

  

h f     t     i  

xi

  

h f     t     i  

ci

  

h f     t     i  i  h f     t     i  i  h f     t     i  i



ji    j    corresponds truth assignment variable xij satisfies
ith clause f  let ci    x  x  x      i    x    t  x    f     i    x   
f  x    t    i    x    t  x    f   
illustrate proposed reduction consider following example  formula f consist
  clauses   x  x  x     x  x  x     x  x  x     causal graph
corresponding planning problem follows 
 abc
gfed
 abc
 abc
gfed
gfed
 abc
 abc
 abc
gfed
 abc
gfed
x  f gfed
x 
x  f gfed
x 
x
x 
x 
  
  f    
  
 
 
h

  
   fff
  f  
      h x  x  x 
 

 
 
 
f
f
h

 
 ff
  
 

x  x 
 
f
   
       x  x  h h
f
 
 


 
 
 
x

f
 h
f  

f            x  x  x 
h
ffff    
  
f
 
x
h

 
 
x 
fff   
 h

   x     x  f x  f   
ff    
h

 
 
  
 
x
f   h
ff   
  
f    x    x  x 
f 
  x
 abc
gfed
 abc
gfed
 abc
gfed
c 
c 
c 
   

 abc
gfed
x 
x   x



fistructure complexity planning unary operators

propositional planning problem single effect operators underlying
directed path singly connected causal graph  clearly  goal reachable   solvable 
satisfying assignment f found  thus  plan existence propositional
planning problems directed path singly connected causal graphs np complete 

lemma   given k ordered sequences       k n elements each  number  k 
different merges       k   preserving orderings induced       k elements  given by 


k 
n
yx
n   ni    
 k   
   
j 
j
i   j  

proof  considering merge operation k sequences iterative merge  
  k  already merged sequences             i    easy see  k 
expressed as 
 
 k     n k     n    k    
 k   
   
  
k  
s x  y  stands number different  order preserving merges two ordered
sequences sizes x  without loss generality  assume x y  
consider process merging two ordered sequences               as 
 i  partition   j sub sequences 
 ii  partition l sub sequences  j   l j     
 iii  interleaving order preserving concatenation sub sequences    
first  observe   partitioned   j       sub sequences  second 
    
j  numbers different partitions corresponding steps  i   ii   j 


    
  respectively  finally  given pair partitions     exist exactly
j
one possible interleaving order preserving concatenation step  iii   therefore 
have 



x
y  x  
s x  y   
   
j 
j
j  

combining eq    eq     arrive eq    

   

fibrafman   domshlak

references
backstrom  c     klein  i       a   parallel non binary planning polynomial time 
proceedings twelfth international joint conference artificial intelligence  pp 
        sydney  australia  morgan kaufmann publishers 
backstrom  c     klein  i       b   planning polynomial time  sas pubs class 
computational intelligence                
backstrom  c     nebel  b          complexity results sas  planning  computational
intelligence                 
boutilier  c   brafman  r   hoos  h     poole  d          reasoning conditional ceteris
paribus preference statements  proceedings fifteenth annual conference
uncertainty artificial intelligence  pp        morgan kaufmann publishers 
bylander  t          complexity results serial decomposability  proceedings
tenth national conference artificial intelligence  pp          san jose  cl  aaai
press 
bylander  t          computational complexity propositional strips planning 
artificial intelligence                   
chalasani  p   etzioni  o     mount  j          integrating efficient model learning
problem solving algorithms permutation environments  proceedings second
international conference principles knowledge representation reasoning 
pp        cambridge  ma  morgan kaufmann publishers 
chapman  d          planning conjunctive goals  artificial intelligence                 
domshlak  c     dinitz  y          multi agent off line coordination  structure complexity  proceedings sixth european conference planning  toledo  spain 
domshlak  c     shimony  s  e          efficient probabilistic reasoning bayes nets
mutual exclusion context specific independence  proceedings sixteenth international flairs conference  special track uncertain reasoning  st 
augustine  fl  aaai press  appear 
erol  k   nau  d  s     subrahmanian  v  s          complexity  decidability undecidability results domain independent planning  artificial intelligence  special issue
planning                
etzioni  o          acquiring search control knowledge via static analysis  artificial intelligence                 
jonsson  p     backstrom  c       a   state variable planning structural restrictions 
algorithms complexity  artificial intelligence                   
jonsson  p     backstrom  c       b   tractable plan existence imply tractable
plan generation  annals mathematics artificial intelligence                   
kambhampati  s          admissible pruning strategies based plan minimality planspace planning  proceedings fourteenth international joint conference
artificial intelligence  pp            montreal  canada 
   

fistructure complexity planning unary operators

knoblock  c          automatically generating abstractions planning  artificial intelligence                 
koehler  j     hoffmann  j          reasonable forced goal orderings use
agenda driven planning algorithm  journal artificial intelligence research 
           
korf  r          macro operators  weak method learning  artificial intelligence         
     
korf  r          planning search  quantitative approach  artificial intelligence         
     
pell  b   bernard  d   chien  s   gat  e   muscettola  n   nayak  p   wagner  m     williams 
b          autonomous spacecraft agent prototype  proceedings first
international conference autonomous agents  pp          marina del rey  cl 
acm press 
penberthy  j  s     weld  d  s          ucpop  sound  complete  partial order planner
adl  proceedings third international conference principles knowledge representation reasoning  pp          cambridge  ma  morgan kaufmann
publishers 
shimony  s  e     domshlak  c          complexity probabilistic reasoning  directedpath  singly connected  not polytree   bayes networks  submitted publication 
smith  d     peot  m          postponing threats partial order planning  proceedings
eleventh national conference artificial intelligence  pp          washington 
d c  aaai press 
weld  d  s          introduction least commitment planning  ai magazine         
     
weld  d  s          recent advances ai planning  ai magazine                
wiest  j  d     levy  f  k          management guide pert cpm  prentice hall 
williams  b     nayak  p          model based approach reactive self configuring systems  proceedings thirteenth national conference artificial intelligence 
pp          portland  or  aaai press 
williams  b     nayak  p          reactive planner model based executive 
proceedings fifteenth international joint conference artificial intelligence 
pp            nagoya  japan 

   


