journal artificial intelligence research                   

submitted        published      

graph abstraction real time heuristic search
vadim bulitko
nathan sturtevant
jieshan lu
timothy yau

bulitko   ualberta   ca
nathanst   cs   ualberta   ca
jieshan   cs   ualberta   ca
thyau   ualberta   ca

department computing science  university alberta
edmonton  alberta  t g  e   canada

abstract
real time heuristic search methods used situated agents applications require
amount planning per move independent problem size  agents plan
actions time local search space avoid getting trapped local minima improving heuristic function time  extend wide class real time search algorithms
automatically built state abstraction prove completeness convergence resulting
family algorithms  analyze impact abstraction extensive empirical study
real time pathfinding  abstraction found improve efficiency providing better trading offs
planning time  learning speed negatively correlated performance measures 
keywords  learning real time heuristic search  state abstraction  goal directed navigation 

   introduction motivation
paper study problem agent centered real time heuristic search  koenig        
distinctive property search agent must repeatedly plan execute actions
within constant time interval independent size problem solved 
restriction severely limits range applicable algorithms  instance  static search algorithms
 e g   a  hart  nilsson    raphael         re planning algorithms  e g   d  stenz        
anytime algorithms  e g   ara  likhachev  gordon    thrun        anytime re planning
algorithms  e g   ad  likhachev  ferguson  gordon  stentz    thrun        cannot guarantee
constant bound planning time per action  lrta  provides guarantees planning
actions time updating heuristic function  solution quality poor
lengthy convergence process  korf        ishida        
motivating example  consider navigation gridworld maps commercial computer
games  games  agent tasked go location map current
location  agent must react quickly users command regardless maps size
complexity  consequently  game companies impose time per action limit pathfinding algorithms  example  bioware corp   major game company  limits planning time     ms
pathfinding units  and many units planning simultaneously  
additional challenge comes form limited sensing virtual reality trainers
artificial intelligence controlled characters may access entire map priori  order
avoid unrealistic behavior  dini  van lent  carpenter    iyer         agents build
internal map model based sensing limited amount map around position 
efficient search agent would minimize delay incurred planning actions  explore
learn environment quickly  always discover optimal path goal  unfortunately 
c
    
ai access foundation  rights reserved 

fib ulitko   turtevant  l u     yau

measures negatively correlated  or antagonistic  optimizing performance one
measure results worse performance one others  instance  reducing amount
planning done action improves agents response time  leads slower learning
due lower quality actions taken agent 
propose use graph abstraction improve efficiency search agents make
following four contributions  first  introduce new algorithm  path refinement learning
real time search  pr lrts     enhances existing real time heuristic search algorithms
automatically built graph abstraction  pr lrts learns heuristic function abstract space
thereby substantially accelerating learning  actions abstract space refined actions
environment a  algorithm  approach allows agents generate actions constant
time  explore environment quickly  converge near optimal solutions  paper use
previously published clique abstraction  sturtevant   buro         contributions specific
abstraction three fold  first  introduce initial clique building repair procedure
detail previously published  second  prove worst case bound suboptimality
path induced abstraction  third  present first application state abstraction
real time heuristic search 
standard practice heuristic search literature promote new algorithms trading
small amount one performance measure large gain another performance measure 
instance  state abstraction non real time heuristic search shown trade little solution
quality substantial reduction running time  e g   holte  mkadmi  zimmer    macdonald 
      botea  muller    schaeffer         unfortunately  always clear whether tradeoffs made optimally  second contribution  demonstrate pr lrts outperforms
number algorithms respect two antagonistic measures  e g   learning speed
amount planning per action  
third contribution  analyze effects abstraction search respect commonly
used performance measures  solution suboptimality  amount planning per action  total travel 
total planning time  memory footprint  knowing effects deepens understanding realtime heuristic search methods well guides practitioner selecting appropriate
search algorithm configuration application  fourth  show theoretically pr lrts
unifies extends several well known existing heuristic search algorithms satisfies realtime operation  completeness  convergence properties  contribution viewed
follow up previous unification extension efforts  bulitko   lee        
rest paper organized follows  begin formulating problem real time
heuristic search section    new algorithm  pr lrts  described section    empirical
results follow section    theoretical results presented section    review existing
agent centered search algorithms well work automatic graph abstraction section   
paper concluded discussion current limitations future research 

   real time heuristic search
defining property real time heuristic search amount planning performed
agent per action constant upper bound depend problem size  low bounds
preferred applications  guarantee agents fast response presented new
goal  real time search agent plans next action considering states local search space
   early version algorithm published conference paper  bulitko  sturtevant    kazakevich        

  

fig raph bstraction r eal   time h euristic earch

  sc s 
  sc    sg
 
sense environment  update agents model
 
compute partial path p originates current state sc
 
execute p
 
update current state sc
  end
figure    real time heuristic search  a single trial  
surrounding current position  heuristic function  or simply heuristic  estimates cumulative
cost state goal  used agent rank available actions select
promising one  process shown schematically figure    agents current state sc
set initial state s  line    long goal sg reached  line     agent senses
environment around  see section   details  updates model search graph
operating line    computes  partial  path current state toward goal
state line    real time property requires lines     execute constant bounded time
regardless problem size  accomplished calling real time heuristic search algorithm
line    paper  discuss three candidate algorithms  lrta  section      lrts
section      pr lrts section    would called line    agent
executes path line   updates current state line   
trial defined agents problem solving experience traveling start state
goal state  goal state reached  agent teleported start state next
trial begins  convergence process defined first sequence trials agent longer
updates heuristic function model search problem  first trial without updates
final trial learning process said converged 
    learning real time a   lrta  
first review best known real time heuristic search algorithm  learning real time a 
 lrta    korf         algorithm shown figure    line    d ply breadth first search
duplicate detection used find frontier states precisely actions away current state
s  standard path max  mero        technique used deal possible inconsistencies
heuristic function computing g   h values  value state  s  sum
cost shortest path sc s  denoted g s  s   estimated cost shortest path
sg  i e   heuristic value h s  sg     state minimizes sum identified s 
line    heuristic value current state updated line    finally  path one action
toward promising frontier state s  returned line   
path lrta  sc   sg   d 
 
 
 
 

generate successor states sc actions away
find state s  lowest g sc   s      h s    sg  
update h sc   sg   g sc   s      h s    sg   greater current h
return first action along optimal path sc s 
figure    lrta  algorithm 

  

fib ulitko   turtevant  l u     yau

    learning real time search  lrts 
lrts extends lrta  three ways  puts weight heuristic function  uses maxof min learning rule  utilizes backtracking  review extensions detail
section     walk lrts operation below  lrts three control parameters  lookahead
n  optimality weight         learning quota        operates follows 
current state sc   agent running lrts conducts full width d ply lookahead search  line  
figure     ply  finds promising state  line     assuming initial heuristic
h admissible  safely increase h sc   maximum among f  values promising states
levels  line     total learning amount u  updated line    exceeds learning quota
  agent backtracks previous state planned  lines        otherwise  returns
path moves current state sc promising state level  line    
learning amount u reset   agent start state  i e   beginning trial  
path lrts sc   sg   d     
 
 
 

generate successor states sc   actions away           
level i  find state si lowest f  si     g sc   si     h si   sg  
update h sc   sg   max f  si   greater current h

 
 
 
 
 
 

increase amount learning u h
u
return path actions sc sd
else
return path actions backtrack previous state  set u  
end

 id

figure    lrts algorithm 
lrts parameters previously studied length  bulitko   lee         summarize trends  higher lookahead reduces convergence travel  convergence memory  suboptimality  however  increases first move lag  lower heuristic weight leads less optimal
solutions and  generally speaking  reduces convergence travel convergence memory  first move
lag influenced   lower learning quota causes backtracking tends reduce
convergence travel convergence memory  affect first move lag 
    notation
definition     search problem defined tuple  g  c  s    sg   h    g    s  e 
directed weighted graph  henceforth search graph   finite set states  or vertices 
e finite set edges them  edge weights defined cost function
c   e       c s    s    travel cost edge e    s    s     s  start
state  sg goal state  h          initial heuristic function  assume
h   sg        out edges state called moves actions  number out edges  i e  
out degree state  called branching factor state 
definition     solution search problem path start state s  goal state sg  
path denoted  s    s            sg   si valid state valid edge
pair states  si   si      travel cost path sum travel costs edges 
  

fig raph bstraction r eal   time h euristic earch

definition     times  search agent resides single search state sc called current
state  agent change current state executing actions thus incurring travel
cost  initially  current state coincides start state s    agent said succeed
makes current state coincide goal state sg  
assume goal state reachable state agent get start
state  needed completeness real time heuristic search algorithms  follow
standard practice real time heuristic search literature assume environment
stationary deterministic  additionally  support backtracking  shue   zamani        shue 
li    zamani         i e   reversing agents actions   require every action reverse
action  needed backtracking enabled algorithm 
definition     travel cost state s  state s  denoted dist s    s    defined cost
shortest path s  s    throughout paper  assume dist satisfies triangle
inequality  s    s    s   dist s    s    dist s    s      dist s    s      then  state  s  h  s 
defined minimal travel cost goal  h  s    dist s  sg    heuristic function  h 
approximation h   admissible overestimate h    h s  h  s    value
h state referred heuristic value state s  assume heuristic
function h sg       trivially holds admissible h 
experiments break ties moves fixed fashion  e g   always prefer
action north  north east  east  etc   entails agents behavior
identical trials final trial  necessarily mean entire search graph
explored learned heuristic accurate states 
definition     convergence travel cumulative cost edges traversed agent
convergence process  convergence planning amount planning effort expended
agent convergence process  first move lag amount planning effort expended
agent first move final trial  convergence memory measured total
number heuristic values stored convergence process  standard practice realtime heuristic search literature  e g   korf        shimbo   ishida        store heuristic
values hash table  hash table misses handled procedurally specified initial heuristic h 
 e g   manhattan distance grid based pathfinding   convergence memory number
entries hash table convergence  finally  suboptimality defined percentage points
final trial solution cost excess relative shortest path cost  instance  agent
incurred travel cost     shortest path cost      suboptimality     
measure planning effort two ways  first  report number states algorithm
touched  i e   considered  planning  measure called edges traversed  e g   holte
et al         p        second  report physical cpu time  measured    ghz powerpc g 
computer gcc     mac os         measure convergence memory terms
number heuristic values stored  meaningful heuristic value stored takes
fixed amount memory  i e   double type c    implementation algorithm 
definition     search algorithm exhibits real time performance heuristic search problem
planning effort per move constant bounded constant independent problem size
 assuming fixed maximum branching factor  
  

fib ulitko   turtevant  l u     yau

objectives real time search agent complete  i e   arrive goal state
every trial   converge  i e   finish learning process finite number trials  
minimize five performance measures described above  rest paper discuss
existing new algorithms compare terms objectives 
    application  goal directed navigation
one motivating applications heuristic search goal directed navigation  known
pathfinding  special case heuristic search problem formalized previous section
search graph  s  e  defined terrain map  thus  states vertices correspond
geographical positions map  edges describe passability blocking  cost function
represents difficulty time traversing terrain 
real time pathfinding motivated primarily time sensitive robotics  e g   koenig   simmons        koenig        kitano  tadokoro  noda  matsubara  takahashi  shinjou    shimada 
      koenig  tovey    smirnov        computer games  latter include real time strategy
games  e g   blizzard entertainment         first person shooters  e g   id software         roleplaying games  e g   bioware corp          these  time plays critical role since number
agents perform pathfinding simultaneously gamers would rapid response fluid
gameplay  result  pathfinding become major computational expense  age empires
ii  ensemble studios        takes        simulation time  pottinger        
paper  follow footsteps furcy koenig         shimbo ishida        
koenig         botea et al          hernandez meseguer      a      b   sigmundarson
bjornsson         koenig likhachev        situate empirical study navigation
two dimensional grid based maps  cells square cell connected four cardinally
 i e   west  north  east  south  four diagonally neighboring cells  cell occupied
agent  i e   free  wall  i e   blocked  
free grid cell constitutes vertex state search space s  agent travel
two free neighboring cells  s  s    edge  s    s 
  added set edges e 
paper  set edge costs   cardinal moves   diagonal moves  cell initially
occupied agent s    target cell sg   example converting grid based map
search problem defined  g  c  s    sg   h    shown figure    note allow
diagonal moves cut corners and  thus  state s  connected states s    s    s    sg  
done non zero size agent able pass zero width bottleneck
formed two diagonally adjacent blocked cells  case one corner  e g  
states
s  s  figure     allowing cut would lead actual travel distance
exceeding   since non zero width agent walk around corner 
video games often feature repeated pathfinding experiences map two reasons 
 i  units commute source destination  e g   resource collectors
real time strategy games   ii  ally units share results learning  i e   heuristic
function   since trial typically improves heuristic values many states  even single trial
single unit use units different start states long share goal
state  often case state abstraction entire region map  e g   room
role playing game players home base real time strategy game  mapped
single abstract state  thus  single trial learning experiences multiple units approximated
multi trial learning experience single unit  latter scenario study paper 
  

fig raph bstraction r eal   time h euristic earch

goal

s 

s 

sg

s 

start

s 

s 

s 

s 

s 

s 

figure       grid based map  left  converted   state search graph  right   thinner
cardinaldirection edges cost    thicker diagonal edges cost   
line furcy koenig         shimbo ishida         sigmundarson bjornsson       
others 

   search graph discovery
paper  require search agent know problem entirety  instead  portion
search problem neighborhood current state sc sensed agent time
step  assume agent remember parts problem sensed far 
words  times agent internal representation  model  search space like 
model updated agent discovers search graph  line   figure    
let us illustrate exploration process goal directed navigation  terrain map initially
unknown agent  moves around environment  grid cells whose coordinates within
fixed visibility radius agents current position sensed  formally  agent situated cell
 x  y  check status  free blocked  cell  x         x x    r  y     r 
r n visibility radius  thus  two visible cells  x         x          agent tell
edge cost  similar virtual sensors used thalmann 
noser  huang        
one common approach assume regular structure unknown part search
space  koenig et al         koenig        bulitko   lee        koenig   likhachev        
instance  grid based pathfinding  agent assume obstacles gridworld
senses otherwise  this sometimes called free space assumption   demonstrate
figure    agent assumes space obstacle free  a  builds internal
model accordingly  b   exploration reveals obstacles environment  c  cause agent
update model  d   impose restriction search agent never needs add edges
model exploration weights discovered edges never change  words  agents
initial model optimistic contains superset edges actual search graph  adding edges
allowing arbitrary edge weight changes may require agent explore environment explicitly  combining exploration exploitation effectively active research area  for early work 
refer sutton        addressed paper 
map discovery natural robotics sensors limited ranges  software domains 
agent theoretically access entire environment  several types arguments
made justify restricting agents senses software domains  first  omniscient virtual
  

fib ulitko   turtevant  l u     yau

actual search space 

agent s model 

explored actual search space 

updated agent s model 

 a 

 b 

 c 

 d 

figure     a   initially part search space shown solid lines sensed agent
 shown stick figure   agents model assumes regular structure unknown
part  b   agent moves north east  senses additional part search space
 c  updates model correspondingly  d  
humans tend behave unrealistically and  thus  less suitable virtual reality trainers  dini
et al          likewise  commercial games  revealing entire map ai player viewed
negatively cheating  second  computationally expensive sense  orkin       
reason entire environment  thalmann et al         aylett   luck         consequently 
localized sensing used large scale multi unit systems  reynolds        

   path refinement learning real time search  pr lrts 
real time heuristic search algorithms plan using small part search graph surrounds
agents current state  order avoid getting stuck infinite loops  update heuristic
function time  approach guarantees action planned constant bounded
amount time  downside slow convergence 
central idea pr lrts address downside running real time search
smaller abstract search graph refining produced abstract path ground level path 
abstract graph image original graph abstraction operator  operator
maps region states original graph single abstract state abstract graph 
applied multiple times  hierarchy abstractions formed  hierarchy forest  a tree
connected component search graph  formalized section     
variety terminologies used literature discussing relationship states different levels abstraction  different contexts abstract states
referred clusters  botea et al          sectors regions  sturtevant         images  holte
et al          abstraction forest  line  bacchus   yang        bulitko
et al         sturtevant   buro         sometimes call image abstraction operator parent
pre image children  terms confused successor states lookahead
search  first describe pr lrts intuitive level illustrate example section      give formal details section     describe abstraction operator detail 
    path refinement
pr lrts computes paths several levels abstraction  first  path found
abstract search space  at level     abstract path defines region lower level abstract
  

fig raph bstraction r eal   time h euristic earch

path pr lrts sc   sg  
 
 
 
 
 
 
 
 
 
  
  
  
  

level sc      
return
end
p  pr lrts parent sc    parent sg   
p   
sg   child end p  
end
c    s   parent s  p 
switch algorithm level sc    
a    return a  sc   sg   c 
lrts   return lrts sc   sg   c 
pass through   return p
end switch

figure    pr lrts algorithm 
space searched refining abstract path  refinement proceeds incrementally
level    i e   ground  search space reached ground path produced  order
keep amount planning per move constant bounded regardless ground space size 
need real time algorithm abstract search graph  paper  use lrts
fixed top level abstraction      a  refinement lower levels   abstract levels
left pass through merely increase amount state aggregation  processing
carried them  design choice motivated experimentation  section    
pr lrts operates recursively presented figure    line   checks states passed
top level abstraction pathfinding occur  so  empty path
returned  line     otherwise  function calls recursively compute path
abstract image sc  denoted parent sc   line    abstract image sg   returned
path  if non empty checked line    used derive new destination line    specifically 
new destination sg child end abstract path p   line    compute
corridor c comprised pre images states path p  corridor c empty
path p computed line   empty  finally  run algorithm assigned current level
abstraction  i e   level sc sg   lines        a  lrts tasked
find either full  in case a   partial path  in case lrts  sc sg limited
set states c  convention  empty corridor  c     allows a  lrts search entire
graph  note processing happens pass through level  line      
   agent explores environment moving about  actually use local repair a  instead a  
described section   
   child used  choices may lead better performance  intuitively  child chosen
child end p   closest representative abstract state end p  among children end p   
pathfinding  implement child s  return element children s  geographically closest average coordinates states children s   also  goal state sg happens pre image end p 
pick child end p   
   note functions child parent handle pass through levels  specifically  line    state sg
computed child first non pass through level level path p computed  likewise  line
   states forming corridor c first non pass through level  level i  level path p  level
j   thus  parent s  apply abstraction mapping j times parent s  p level j 

  

fib ulitko   turtevant  l u     yau

implementation a  standard  hart et al         except run  line     subgraph
defined corridor c  line     implementation lrts taken literature  bulitko
  lee        described section      a   run lrts corridor c 

figure    path refinement process  original graph  level    shown bottom 
abstract graph  level    shown top 
illustration purposes  consider example figure    example        one
level abstraction  shown top  used addition ground level  shown bottom  
sc current state sg destination state  lrts assigned level   a 
assigned level    subfigure  i  shows ground state space one level abstraction
above  agent must plan path sc sg located ground level  first  abstract
parents sc sg   parent sc     s c parent sg     s g   located  lrts    
plans three steps abstract space  ii   corridor c ground level comprised children
abstract path built  iii   child representing end abstract path set
new destination sg  iv   finally  a  run within corridor find path sc new
destination sg  v  
agent executing path computed pr lrts  new areas search graph may
seen  causes updates abstraction hierarchy agent maintains  pr lrts clears
recomputes abstract paths upon discovering new areas search graph  also  ground
path proves invalid  e g   runs newly discovered obstacle   execution stops pr lrts
replans current state using updated abstraction hierarchy 
graph discovery lead arbitrary updates abstract search graphs agent maintains 
implementation  lrts operating abstract graph resets heuristic function abstract search graph updated way  hand  updates ground level graph
limited state edge removals  section     consequently  heuristic learned ground
level remains admissible need reset upon updates 
    automatic graph abstraction
use term abstraction operator  or abstraction  short  mean graph homomorphism
line holte et al          namely  abstraction many to one function maps  abstracts 
one states single abstract state  adjacent vertices mapped adjacent identical
vertices  property   below   given graph homomorphism function model search
problem  pr lrts agent builds   additional abstract search graphs  collectively called abstrac  

fig raph bstraction r eal   time h euristic earch

tion hierarchy  follows  first applies graph homomorphism search graph model
 called ground level graph   result abstract search graph level    process
repeated abstract search graph level   computed  homomorphic abstraction
used long resulting hierarchy abstract graphs satisfies several key properties  following introduce properties informally illustrate example  appendix b
formalize them 
property   every abstract graph search graph sense definition     section   
property   every state unique abstract parent  except states top level abstraction  
property   every state abstract level  least one child state below 
property   given heuristic search problem  number children abstract state upperbounded constant independent number states ground level graph 
corollary property number ground level states abstract single
state fixed level abstraction constant bounded constant independent
ground level graph size 
property    graph homomorphism  every edge search graph level abstraction
either corresponding edge level states connected edge abstract
single abstract state 
property   abstract edge exists two states edge least
child one state child other 
property   two children abstract state connected path whose states
children abstract state 
property   abstraction hierarchy consistent agents model search problem
times  is  properties     satisfied respect agents model 
paper  use clique based abstraction mechanism  sturtevant   buro         operates finding fully connected components  cliques  search graph mapping
single abstract state  method building abstractions favored recent analysis sturtevant
jansen        earlier analysis holte et al         section      showed reduction
search effort due abstraction maximized minimizing edge diameter set children
maximizing size  clique  edge diameter  i e   maximum number edges
two elements  one number states clique maximized 
present clique based abstraction mechanism developing several stages handtraceable example  illustrate properties introduced satisfied
example  formal introduction clique abstraction technique complete pseudocode
found appendix a  review ways building abstraction section      note
general clique computation np complete  finding cliques two dimensional grid based search
graphs done efficiently  appendix a  
  

fib ulitko   turtevant  l u     yau

single application abstraction procedure illustrated figure    cliques size four
first located graph  meaning states s    s    s  s  abstracted s    
cliques size three already abstracted first step  cliques size two
abstracted next  includes s  s  abstracted s     s  s 
abstracted s     sg degree    add s     however s  degree two 
abstracted parent  s     adding degree   states neighbors reduces number
resulting abstract states increases edge diameter set children  it becomes  
set  s    s    sg     minor detail abstraction happens effective grid based
pathfinding  one use pure clique abstraction well 
s 

s 

sg

s  

s 
s 

s 

s  

s 
s  

s 

s 

s  

s 

level    original graph 

level    abstract graph 

figure    clique abstraction  original search graph figure   shown left abstracted
search graph right 

s 

s 

sg

s  
s   

s 
s 

s 

s  

s 
s  

s 

s 

s   
 

s  

s   

s 

level    original graph 

level  

level  

level  

figure    three iterations clique abstraction procedure 
abstraction process successively applied single abstract state connected component original graph remains  figure    level     illustrate
abstraction properties figure    property   requires four abstraction levels
figure   search graph sense definition     section    property   requires
  

fig raph bstraction r eal   time h euristic earch

state levels         unique parent level above  property   requires
state levels         non empty set children level below  property   places
upper bound number children abstract state have  example bound
   properties     require that  two abstract states connected path  parents
children connected  consider  instance  abstract states s   s    
connected level   abstract path p    s     s     s     s     them  thus  child
s   connected child s   level    instance  s  connected s    property  
requires children node s   connected internal path within s      s     s     s     s     form
clique  property satisfied 
costs abstract edges  e g   edge  s     s     figure    defined arbitrary way
long resulting search graph satisfies properties section    however  better performance  low cost abstract path abstraction low cost ground path  paper
experiment grid based navigation and  correspondingly  define cost edge  s     s    
euclidean distance average coordinates children s     children s      figure     

figure     coordinates edge costs levels abstraction hierarchy  grid level
 leftmost illustration  vertex
coordinates given column row labels  ground
edges cost    cardinal     diagonal   abstract states labeled  x  y   abstract
edges labeled approximate cost 

practice  property   satisfied repairing agents abstraction hierarchy upon updates
agents model  illustrate  imagine agent discovered discrepancies
terrain elevation state s  s   figure    prevent able traverse edge
 s    s     update model removing edge  additionally  degree one state s 
join clique  s    s     point  agents abstraction hierarchy needs repaired 
accomplished replacing abstract states s   s   single abstract state s     edges  s     s    
 s     s     removed  one level abstraction used repair
propagated higher levels well  repair mechanism presented detail appendix a   
prove section   pr lrts algorithm operate abstraction mechanism
satisfies properties listed above 
  

fib ulitko   turtevant  l u     yau

figure     two six maps used experiments 

   empirical study
empirical evaluation effects state abstraction learning real time heuristic search
presented four parts  section      introduce concept trading antagonistic
measures demonstrate pr lrts makes trade offs efficiently  due use
abstraction and  consequently  investigate effects abstraction independently lrts
control parameters section      study pr lrts performance scales problem
size  section       finally  examine interplay effects abstraction lrts
control parameters  domain specific study present details appendix f 
experimental setup follows  used      problems randomly generated three
maps modeled environments role playing game  bioware corp         three maps
modeled battlefields real time strategy game  blizzard entertainment         six
maps                                     states grids                 
two maps figure     four maps shown appendix c       problems
uniformly distributed across five buckets bucket represents range optimal solution
costs  first     problems optimal path cost          range  next     problems
fell          bucket last     problems           bucket 
experimented various assignments algorithms  a   lrts  none  levels abstraction  experimentation  found keeping lrts top  a  bottom level
leaving intermediate levels pass through yielded best results testbed  following  present results     pr lrts configurations  denoted lrts   d        
level abstraction lrts control parameters d    operates  a  running
bottom level         run lrts ground level run a  all  lrts
parameter space follows                     lookahead depth               optimality
weight                       learning quota            two visibility radii used 
         analysis  focus case visibility radius     line
previous publications area  bulitko et al         bulitko   lee         experiments
visibility radius      yielded similar results  point reference  ran single nonreal time algorithm  a   algorithms implemented within hierarchical open graph
framework  sturtevant        c   run cluster  aggregate     years intel
xeon    ghz cpu 
  

fig raph bstraction r eal   time h euristic earch

    antagonistic performance measure trade off
practitioners viewpoint  section viewed parameter selection guide  start
finding sets parameters optimize performance pr lrts along single measure 
consider optimizing pairs antagonistic performance measures 
research optimizing single performance measures within lrts published bulitko
lee         table   extend results include a  pr lrts  best algorithms
single performance measure a  lrta  use abstraction  exception
convergence planning interplay planning per move convergence travel 
table    optimizing single performance measure 
measure
convergence travel
first move lag  states touched 
conv  memory
suboptimality
conv  planning  states touched 

best algorithm
a 
lrta 
a 
a  lrta 
lrts   d                   lrts   d                  

power abstraction comes attempt optimize two negatively correlated  or
antagonistic  performance measures simultaneously  consider  instance  convergence travel
first move lag  order lower convergence travel  agent needs select better actions 
done increasing amount planning per move which  turn  increases first move
lag  measures negatively correlated  performance along one measure traded
performance along other  thus  interested algorithms make trade offs
efficiently  order make analysis specific  first introduce concept dominance
respect set parameterized algorithms 
definition     algorithm said dominate algorithm b respect performance measures
x set problems p average performance measured x worse
bs  avgp x a  worse avgp x b  avgp y a  worse avgp y b  
algorithm c called dominated set algorithms set contains another algorithm
dominates it 
definition illustrated figure    non dominated algorithms shown solid circles dominated algorithms shown hollow circles  intuitively  non dominated algorithms
make trade off performance measures x efficiently among algorithms
set  considered practice one wants optimize performance measures  dominated algorithms safely excluded consideration regardless relative
importance measures x particular application 
non dominated algorithms ten pairs antagonistic measures summarized table   
a  weighted version korfs lrta  extreme cases performance measures  a 
minimizes convergence travel uses heuristic memory  lrta  minimizes first move lag 
non dominated algorithms pr lrts abstraction  words  abstraction
path refinement improve efficiency trading antagonistic performance measures  figure   
shows dominance plot convergence planning first move lag  pr lrts forms frontier
  

fiperformance
measure  

performance
measure  

worse

worse

b ulitko   turtevant  l u     yau

b


better

better

nondominated
algorithms

better

performance
measure  

better

worse

performance
measure  

worse

figure     left  algorithm dominates algorithm b  left   right  non dominated algorithms
shown solid circles  dominated algorithms shown hollow circles 
non dominated algorithms  the rightmost non dominated point weighted lrta 
extremely low first move lag   plots combinations appendix d 

firstmove lag  states touched 

dominated
nondominated

 

  

lrts         
 

  

lrts         

lrts         

 

  

lrts        
 

  

 

  
convergence planning  states touched 

 

  

figure     dominance convergence planning first move lag 
dominance analysis done respect performance measures averaged
benchmark set problems  dominance analysis level individual problems found
appendix e shows similar trends 
    effects abstraction individual performance measures
section study effects abstraction individual performance measures  arbitrarily choose three diverse lrts parameter combinations lookahead d  optimality weight  
learning quota                                          plots figure     qualitative
summary table    analysis trends below 
convergence planning decreases abstraction level  increase planning per move higher abstraction levels overcompensated decrease convergence
travel  exact shape curves due interplay two measures 
  

fig raph bstraction r eal   time h euristic earch

table    trading antagonistic performance measures 
measure  
first move lag
 states touched 
first move lag
 states touched 
first move lag
 states touched 
first move lag
 time 
first move lag
 time 
first move lag
 time 
suboptimality
suboptimality
suboptimality
suboptimality

measure  
conv  travel
conv  memory
conv  plan 
 states touched 
conv  travel
conv  memory
conv  plan 
 time 
conv  plan 
 states touched 
conv  plan 
 time 
conv  travel
conv  memory

non dominated algorithms  extreme cases italic 
a   lrta          
lrts       d                                        
a   lrta          
lrts       d                                   
lrts       d                 
lrta         
a   lrta          
lrts       d                                   
a   lrta               
lrts       d                                
a   lrta          
lrts       d                             
a  
lrts       d                                     
a 
a 
a 

first move lag increases abstraction level  due fact corridor
ground level induced abstract path length computed lrts abstract level
increases abstraction level  two additional factors affecting shape curves 
first  average out degree abstract states varies abstraction level  second  boundaries
abstract graphs often seen lookahead     higher abstraction level 
convergence memory decreases abstraction level learning algorithm  lrts  operates smaller abstract maps incurs smaller travel cost  practice  amount learning
lrts tends correlate tightly travel  instance  lrts             correlation
convergence memory convergence travel empirically measured       
confidence     
suboptimality increases abstraction  increase due fact abstraction
level progressively simplifies ground graph topology and  abstract path guaranteed
refinable ground path  may lead agent away shortest solution  illustrative
example given appendix b   refinement complete abstract path      longer
optimal ground path  derivation theoretical upper bound suboptimality due
abstraction found appendix b    second mechanism explains suboptimality rises faster
shallower lrts searches  specifically  a  ground level refines abstract d step path
finding ground level solution current state ground representative end
abstract path  solution guaranteed optimal within corridor necessarily
pass geographically closely intermediate states abstract path  thus  giving a 
corridor induced longer abstract path liberates plot path possibly far off
intermediate states abstract path  phenomenon illustrated appendix b  
feeding a  abstract path small fragments results suboptimality giving
big picture abstract path entirety  third factor affecting suboptimality curves
  

fi 

 

    
x   

  
b ulitko
  turtevant  l u     yau

 
 

convergence travel

  

 

x   

 
 
 

  
 

  

  

  

  abstraction
 
  level 
abstraction
level
abstraction level

  
 

first move lag

    

first move lag
first move lag

  

 

    

    

       
 

    
    

    

  

    
    
    

  

    
                      
abstraction
level
abstraction
level
abstraction
level

    

  

    

 

x   
 
 x   

   
    x    

 

  

   

   
   

 

  

   

    
    
 

  

 

    
    
    

 

  
    
    
  
      
 
  
    
    
  

    
    

       

   

  
  
  
abstraction
level
abstraction level

    
    
      
        

  
  

  

x   
x   
  
    
    
 
 
x   
  
 
 
 
      
abstraction level
       
    
        

suboptimality    
convergence memory
suboptimality
   
convergence
memory
convergence
memory
suboptimality
   

convergence travel
convergence travel

  

 

  

 

   

x   
x   
  

  

convergence
memory memory
convergence
convergence
memoryconvergence
planning planning
convergence
convergenceplanning

first move lag
first move
convergence travel
first move lag
lag
convergence planning
convergencetravel
travel
convergence
convergence
planning
convergence
planning

 

x     
  x   
 

   

 
 
 
abstraction level

 

  
  
   
abstraction
level
abstraction
level

   

   
   
    

     
     
     
 abstraction
  level
 
level
abstraction
abstraction
level
abstraction
level
abstraction level

 
 
 
abstraction level

     
 

 

  

   
 

  

 

  
   
     
   
 
   
    
     

  
  
   
abstraction
level
abstraction
level

d       t  
d       t  
 
 
 
d         t    
abstraction level
d         t    
d         t  
d         t  

 

d       t  
d         t    
 
 
 
    
     level     
abstraction
abstraction
level
abstraction
level
abstraction
level
abstraction
level

 
     

d         t  

suboptimality    

suboptimality    
suboptimality    

figure     effects abstraction in  pr lrts 
error bars indicate standard errors
d       t  
d       t  
d       t  
 
 
 
 
 
d         t    
d         t    
d         t    
       
small see data points abstraction
level
d         t  
d         t  
d         t  

       

figure optimality weight   setting lower values leads higher suboptimality
 
independently
  
 
  abstraction
 
 
  bulitko   lee        
  
    abstraction
  
  
  
level
convergence
travel
decreases
abstraction bottom level search constrained within
abstraction
level
abstraction level
narrow corridor induced abstract path  decrease noticeable shallow lookahead searches  d           algorithms using lookahead     low convergence
travel even without abstraction  convergence travel lower bounded double optimal
solution cost  one optimal solution first trial map discovered one
final trial map discovery heuristic learning   consequently  abstraction diminished
gains deeper lookahead  d       although effect would disappear larger maps 
table    qualitative effects abstraction  general trends 
measure   parameter
first move lag
convergence planning
convergence memory
suboptimality
convergence travel

  






given higher abstraction reduces convergence travel  one may ask compares
reducing convergence travel non abstract algorithms simply terminating convergence
process final trial  figure    compare four algorithms single problem  a  
non abstract lrts           two abstract versions  lrts             lrts             
left plot figure demonstrates well known fact convergence learning heuristic
search algorithms non monotinic  e g  shimbo   ishida         right plot shows cost
shortest solution function cumulative travel  prefer algorithms find shorter solutions traveling little possible  plot  abstract algorithms perform better  lower
  

fig raph bstraction r eal   time h euristic earch

a 
lrts        
lrts         

travel trial

   

lrts         

   
   
   
   
  

 

 

 
trial

 

a 
lrts        
lrts         

   
shortest solution found

   

   

   
   
   
  

  

lrts         

   

   

   

   
   
    
cumulative travel

    

    

figure     convergence process level individual trials 
curves  preferred  words  single problem  better run abstract algorithms non abstract algorithms regardless early convergence process terminated 
observe case problems assignments d    tried 
certain cases  prematurely terminating convergence process non abstract algorithm indeed
beneficial  future research investigate extent one automatically select best
algorithm number trials run for 
    effects abstraction  scaling problem size
section investigate effects abstraction problem size increases  measure
size problem cost shortest path start goal position  henceforth
optimal solution cost  
figures       show five performance measures plotted bucket averages  data
point  use middle bucket  e g                   horizontal coordinate  error bars
indicate standard errors  overall  results demonstrate abstraction enables pr lrts
applied larger problems significantly dampening increase convergence travel  convergence planning  convergence memory  advantages come price suboptimality
first move lag  former clearly increases abstraction lookahead small  figure    
virtually bucket independent  lookahead      figure     draws curves together
deeper lookahead diminishes effects abstraction suboptimality  cf  figure     
first move lag virtually bucket independent except case     abstraction levels
     figure      there  first move lag capped problems lower buckets goal
seen start state higher levels abstraction  consequently  lrts computes
abstract path shorter nine moves  leads smaller corridor less work
a  refining path  consequently  first move lag reduced  problems become
larger  lrts room compute full nine move abstract path first move lag increases 
abstraction level   phenomenon takes place bucket    seeing goal state
start state frequent enough make impact  happens abstraction level
  proximity abstract goal continues cut search short even largest problems 
finally  observe minute decrease first move lag larger problems  appears
due fact problems higher buckets tend start state located cluttered
region map  so optimal solution cost necessarily higher   walls reduce number
states touched agent first move reduce first move lag 
  

fib ulitko   turtevant  l u     yau

 

 

x   

 
convergence planning

convergence travel

 
 
 
 
 
 

    

   

 

   

 

 

 

              
optimal solution cost

x   

firstmove lag

 

              
optimal solution cost

   

   

 

              
optimal solution cost

  

    

suboptimality    

convergence memory

l  

  

    

   

l  
l  

  

l  

  

l  

  
 

 

 

              
optimal solution cost

              
optimal solution cost

figure     scaling up  curve shows bucketed means lrtsl             error bars indicate standard errors small see data points 

   theoretical analysis
pr lrts subsumes several known algorithms abstraction used  clearly  lrts  bulitko   lee        special case pr lrts abstraction used  lrts subsumes generalizes several real time search algorithms including lrta   korf         weighted
lrta   shimbo   ishida          trap  bulitko        sla  sla t  shue   zamani       
shue et al         
theorem      real time operation  heuristic search problem  lrts   d      amount
planning per action constant bounded  constant depends constant control
parameters n                independent problems number states 
first prove auxiliary lemma 
lemma      downward refinement property  abstract path p    sa           sb    two
children ends connected path lying entirely corridor induced p  means
abstract path refined within corridor formed children  formally 
  k   p    sa           sb    p  s k   e k    
s a children s    s b children sm  
p     s a           s b    p   s k     e k       s  p   s  sp children s     
  

     

fig raph bstraction r eal   time h euristic earch

 

    

    

    
    

 

 

 

 

 

   

 

              
optimal solution cost

x   

firstmove lag

    

 
convergence planning

convergence travel

    

    
    
    

              
optimal solution cost

    

              
optimal solution cost

l  

   

   

  

 

              
optimal solution cost

suboptimality    

convergence memory

l  

 

l  
l  

 

l  

 

 

              
optimal solution cost

figure     scaling up  curve shows bucketed means lrtsl             error bars indicate standard errors small see data points 
proof  proof induction number edges abstract path  base case   
means two children single abstract state connected path lies entirely
set children abstract state  holds due property   
suppose statement holds abstract paths length j  show
holds abstract paths length j    consider arbitrary abstract path p  s k   e k    k  
  j     edges  represent p  s            sj     sj      consider arbitrary children
s   children s    s j   children sj      need show path p   s k
    e k     lies entirely union children states p  let us denote
cp    let s j   arbitrary child state sj     since s  sj   j edges apart 
inductive supposition  path s   s j   lies entirely cp   left
show s j   s j   connected within cp   s j   s j   parent 
property   guarantees connected  different parents  property   provides
guarantee  either way  induction step completed 
prove theorem     
proof  abstract level    lrts d      considers bd abstract states
algorithm design  cf  section       b maximum degree state  assumed earlier
paper  maximum degree state depend number states  resulting
abstract path longer abstract edges induces corridor ground level  corridor
consists ground level states abstract abstract states path  size corridor
  

fib ulitko   turtevant  l u     yau

upper bounded number edges path  at d  multiplied maximum number
ground level children abstract state level    latter upper bounded constant
independent number ground level states due property    a  running corridor
constant bounded size takes constant bounded time  finally  abstraction repair o     
independent graph size  appendix a    
completeness defined ability reach goal state every trial  prove completeness lrts   d      based following reasoning  recall lrts   d      uses
lrts algorithm build abstract path level    uses corridor restricted a 
ground level refine abstract path sequence ground level edges  due property  
section      a  always able find path ground level states sc sg
lie within corridor c time execution gets line   figure    due exploration
process  agents model search graph may different graph actually
reality  consequently  path found a  may contain ground level edge agent believes
exist reality not  following lemma demonstrates execution failure
possible finite number times given search graph 
lemma     finite number path execution failures trial 
proof  contradiction  suppose infinite number failures  failure due
discovery least one new blocked edge vertex ground level graph 
infinitely many blocked edges vertices finite graph 
direct corollary lemma trial  moment time
graph discoveries made trial  therefore  executing a s path indeed allow
agent follow abstract path actual map 
lemma     lrts complete abstract graph 
proof  first  show abstract graph satisfies properties lrts shown
complete  theorem      bulitko   lee         is  abstract graph finite  action
reversible  self loops  actions positive cost  goal state reachable
every state  graph stationary deterministically traversible  p      bulitko
  lee         due abstraction mechanism requirements section      properties listed
satisfied clique abstraction mechanism long ground level graph satisfies
properties well  which require section     thus  lrts running abstract graph
ground graph complete 
pr lrts  however  lrts abstract graph execute actions  instead 
current  abstract  state computed abstract parent agents current ground level state 
therefore  critical question whether agent able find ground level path current
state ground level state corresponding end abstract path computed line  
figure    failure would mean corridor computed line   figure  
used refine path contain ground level path sc sg   due downward
refinement property  lemma       due graph discovery 
according lemma      finite number failures  a  algorithm operating
ground level guaranteed find path reach end abstract path computed lrts 
thus  lrts effective ability execute abstract actions  putting results
  

fig raph bstraction r eal   time h euristic earch

together  conclude valid d    parameters  lrts abstract graph finds
goal every trial 
two lemmas lead directly following statement 
theorem     lrts   d      complete 
proof  follows directly lemma     lemma     
theorem     lrts   d      fixed tie breaking converges final solution finite
number trials  subsequent trials  update search graph model heuristic
follows path 
proof  follows lemma     theorem      bulitko   lee        way
lemma     theorem     proved above 
theoretical results suboptimality found appendix b  

   related research
existing heuristic search methods situated methods divided two categories  full
search real time search  full search algorithms form entire solution given current
knowledge search graph  contrast  real time search plans small segment  frequently
first action  solution executes right away  due local nature planning 
real time search algorithms need update heuristic function avoid getting stuck local
minima heuristic function 
    full search
common full search algorithm version a   hart et al         called local repair a   stout 
       it  full search conducted agents current state goal state free space
assumption  agent executes computed path either destination reached
path becomes invalid  e g   previously unknown wall blocks way   latter case  agent
replans current position goal  local repair a  suffers two problems  first 
searches shortest solution and  general search problem  may end expanding number
states exponential solution cost due inaccuracies heuristic function  pearl        
second  re planning episodes re use results previous search 
first problem addressed suboptimal versions a  frequently implemented
via weighting heuristic function  pohl               weighted a   wa   usually finds
longer solution less time  suboptimal solution found  improved upon
conducting additional searches  done re using open list successive
searches  hansen  zilberstein    danilchenko        likhachev et al         hansen   zhou       
re running a  tunnel induced suboptimal solution  furcy         later case 
beam search backtracking used place weighted a   furcy   koenig        
second problem addressed incremental search methods d   stenz         d 
lite  koenig   likhachev      a  lpa   koenig   likhachev      b   algorithms reuse
information previous search  thus speeding subsequent replanning episodes 
  

fib ulitko   turtevant  l u     yau

algorithms  full path computed first move executed
agent  consequently  planning time per move constant bounded increases
problem size  thus  agent centered full search real time 
    learning real time search
since seminal work lrta   korf         research field learning real time heuristic
search flourished resulting twenty algorithms numerous variations 
described following four attributes 
local search space set states whose heuristic values accessed planning
stage  two common choices full width limited depth lookahead  korf        shimbo  
ishida        shue   zamani        shue et al         furcy   koenig        hernandez  
meseguer      a      b  sigmundarson   bjornsson        rayner  davison  bulitko  anderson 
  lu        a  shaped lookahead  koenig        koenig   likhachev         additional
choices decision theoretic based shaping  russell   wefald        dynamic lookahead
depth selection  bulitko        lustrek   bulitko        
local learning space set states whose heuristic values updated  common
choices are  current state  korf        shimbo   ishida        shue   zamani        shue
et al         furcy   koenig        bulitko         states within local search space  koenig 
      koenig   likhachev        previously visited states neighbors  hernandez  
meseguer      a      b  sigmundarson   bjornsson        rayner et al         
learning rule used update heuristic values states learning space 
common choices dynamic programming mini min  korf        shue   zamani        shue
et al         hernandez   meseguer      a      b  sigmundarson   bjornsson        rayner
et al          weighted versions  shimbo   ishida         max mins  bulitko         modified dijkstras algorithm  koenig         updates respect shortest path
current state best looking state frontier local search space  koenig   likhachev 
       additionally  several algorithms learn one heuristic function  russell   wefald 
      furcy   koenig        shimbo   ishida        
control strategy decides move following planning learning phases  commonly
used strategies include  first move optimal path promising frontier state  korf 
      furcy   koenig        hernandez   meseguer      a      b   entire path  bulitko 
       backtracking moves  shue   zamani        shue et al         bulitko        sigmundarson   bjornsson        
given multitude proposed algorithms  unification efforts undertaken  particular  bulitko lee        suggested framework  called learning real time search  lrts  
combine extend lrta   korf         weighted lrta   shimbo   ishida         sla   shue
  zamani         sla t  shue et al          large extent   trap  bulitko        
dimensions described above  lrts operates follows  uses full width fixed depth local search
space transposition tables prune duplicate states  lrts uses max mins learning rule
update heuristic value current state  its local learning space   control strategy moves
agent promising frontier state cumulative volume heuristic function updates
trial user specified quota backtracks previous state otherwise  section      
within lrts  unification several algorithms accomplished implementing
several methods local search space selection  learning rule  control strategy 
  

fig raph bstraction r eal   time h euristic earch

methods engaged run time via user specified parameters  resulting parameter space contained original algorithms plus numerous new combinations  enabling tuning
performance according specific problem objective function particular application 
demonstration  bulitko et al         tuned lrts ten maps computer game baldurs
gate  bioware corp         achieved convergence speed two orders magnitude
faster lrta   finding paths within    optimal  time  lrts
five times faster first move incremental a   despite improvements  lrts
real time search algorithms converge slowly a  and  visually  may behave unintelligently
repeatedly revisiting dead ends corners 
    state abstraction
idea abstraction previously applied full search methods  particular  hpa 
pra   botea et al         sturtevant   buro        use abstraction speed a  search  instead
running a  lowest level graph  instead run a  smaller abstract graph  pra 
computes abstract path refines similar manner pr lrts  however  pra 
dynamically chooses abstract level use  computes path intermediate level
 i e   pass through levels   pra  widens corridors decrease suboptimality
cost lower speed 
hpa  abstracts map using large regions  selects connection points  gates  neighboring regions  gates region  optimal paths gates pre computed off line
using a  stored table  means refining abstract path  i e   sequence
region gates  done simply concatenating stored optimal paths  smoothing applied
post processing step decrease suboptimality resulting path 
algorithms based ideas presented holte et al          used
abstraction mechanism similar manner use clique abstraction  method 
star abstraction  described radius abstraction  is  state selected 
aggregated together states fixed radius original state  holte et al        s
work initially gain wide acclaim  because  time  little interest problems
small enough fit memory  motivating applications  pathfinding computer
games  resulted resurgence interest techniques 
class algorithms first plan abstract path  refined traversable path 
another approach build abstraction directly used planning realworld  includes methods framed quad trees  yahja  stentz  singh    brummit        
efficiently represent sparse maps  quad trees multi resolution representation 
areas map represented high resolution  others represented lower resolution 
abstraction differs abstractions clique abstraction applied
once  applications would produce lower resolution maps  although clique abstraction
could applied graph implied framed quad tree representation 
one common use abstraction provide better heuristics  holte  perez  zimmer 
macdonald        used result abstract search provide accurate heuristic lowlevel search performed path refinement  similarly  pattern databases abstractions
built solved off line  abstract solution costs stored used search
heuristic function  culberson   schaeffer        felner  zahavi  schaeffer    holte        
  

fib ulitko   turtevant  l u     yau

pr lrts presented paper first real time heuristic search algorithm use
automatically built state abstraction  path refinement algorithms listed conduct full search
therefore cannot guarantee constant bounded planning time agents moves 

   limitations future work
results presented paper open several directions future research  first  pr lrts
able operate wide class homomorphic graph abstraction techniques  thus  would
interest investigate extent effects graph abstraction real time search
presented paper specific clique abstraction mechanism pathfinding domain 
recent work shown clique abstraction parameters well tuned minimize
work done traditional path planning  sturtevant   jansen         experiments pathfinding
suggested clique abstraction well suited map abstraction represents key
properties underlying space well  particular  branching factor stays roughly constant
higher levels abstraction  empty map  instance  number nodes level
abstraction reduced factor four clique abstraction  branching factor
every state stay same   corner states   neighbors  edge states  
neighbors  middle states   neighbors   may case domains 
instance  sliding tile puzzle maximum branching factor abstract states quickly increases
abstraction level  result  corridor derived abstract path pr lrts becomes
excessively wide effectively constrain a  search ground level  conjecture
algorithms use homomorphic abstractions effective domain abstraction
preserves average  minimum  maximum branching factor original problem
level abstraction  clique abstraction  likely work well three dimensional pathfinding 
problem specific mechanisms would needed permutation type puzzles  area
open research provide abstraction 
second  pr lrts uses abstract solution restrict search original ground level
graph  interesting combine complementary approach using cost
optimal solution abstract problem heuristic estimate original search graph
context real time search  particular  looking effective ways propagating heuristic
values higher lower levels abstraction hierarchy 
third  state aggregation one way generalizing learning  future research consider
combining function approximation heuristic function  commonly practiced
large scale applications reinforcement learning 
fourth  presently investigating applications pr lrts dynamic environments 
particular  studying extent savings memory gained learning higher
abstraction level afford application pr lrts moving target search  existing algorithm  ishida   korf        requires learning number heuristic values quadratic size
map  prohibitive case commercial game maps 
finally  presently extending graph abstraction method presented paper
stochastic environments formulated markov decision processes 
  

fig raph bstraction r eal   time h euristic earch

   conclusions
situated agents real time environments expected act quickly efficiently learning
initially unknown environment  response time learning speed antagonistic performance
measures planning leads better actions and  consequently  faster convergence longer
response time  full search algorithms  local repair a   converge quickly
constant bounded planning time per move  real time heuristic search algorithms constantbounded planning times per move  learn slowly 
paper  attempted combine best approaches suggest hybrid algorithm  pr lrts  learns heuristic function smaller abstract space uses corridorrestricted a  generate partial ground level path  large scale empirical study  pr lrts
found dominate virtually tested algorithms use abstraction respect
several performance measure pairs  combination learning planning brings real time performance much larger search spaces  substantially benefiting applications pathfinding
robotics video games 

acknowledgments
funding provided national science engineering research council canada 
alberta ingenuity centre machine learning  informatics circle research excellence 
university alberta  appreciate input david thue  rich korf  rob holte  csaba
szepesvari  david furcy  adi botea  special thanks go jonathan schaeffer anonymous reviewers whose detailed comments greatly improved paper  research enabled use westgrid computing resources  funded part canada foundation innovation  alberta innovation science  bc advanced education  participating
research institutions  particular  would acknowledge help roman baranowski 
masao fujinaga  doug phillips 

appendix a  clique abstraction
describe clique abstraction mechanism several stages  first  present
algorithm building initial abstraction hierarchy using free space assumption 
describe repair procedure updates abstract graphs agent explores environment 
finally  consider suboptimality solution caused abstraction examples derive worstcase upper bound 
a   building initial abstraction hierarchy
pseudo code building initial clique abstraction figure     abstract procedure
 lines       takes set states level maps single abstract state level
     involves creating new abstract state storing parent child links  if  line    
new abstract edge added one already exists  add extra edge increase
count associated edge  counts used facilitate abstraction repair described
next section 
general  clique finding np complete problem  garey   johnson         however 
eight connected two dimensional grid based search graphs largest possible clique size   
  

fib ulitko   turtevant  l u     yau

graph cliqueabstraction graph g 
 
initialize graph g  
 
       
 
unabstracted state g
 
part i clique c
 
g   g    abstract c  
 
end
 
end
 
end
 
   unabstracted state g
  
degree s     
  
set parent s  parent neighbor s  
  
else
  
g   g    abstract n  
  
end
   end
  
   edge e    v    v   
  
parent v       parent v   
  
g   g     parent v     parent v     
  
end
   end
   return g  
figure     building initial clique abstraction 
degree
state constant bounded  as required section    time per

clique constant  i e      state accesses check eight neighbors find   form   clique
together current state   thus  total running time single clique abstraction
o  s     s  number states original search graph  abstraction procedure
reduces graph size least constant factor greater one  total cost abstracting
graph o  s   cost additional abstraction step reduced exponentially 
a   repairing abstraction hierarchy
agent explores environment  may find edges states blocked  cases 
remove corresponding states edges model need propagate changes
abstract graphs abstraction hierarchy  demonstrate repair code figure   
example shows repair procedure amortized constant time cost 
figure    remove edges level   graph bottom left figure  right
side figure shows full abstract graph edges removed  level
show portion abstract graph assume states edges graph 
shown schematically level   gray 
level   four states marked form abstract state level   
true states marked a  joined edge level    abstracted
  

fig raph bstraction r eal   time h euristic earch

removeedge edge e  level l  graph g 
 
decrease edge count e
 
child edge count e      return end
 
e    v    v   
 
remove e g l 
 
parent v      parent v   
 
addtorepairq parent v    
 
else
 
removeedge  parent v     parent v      l      g 
 
end
removestate state s  level l  graph g 
   edge e incident
  
removeedge e  l  g 
   end
   remove g l 
   addtorepairq parent s  
handlerepairq  
   repairq empty
  
remove state lowest level l g
  
abstraction properties hold
  
addtorepairq parent s  
  
split state s        sn abstraction properties holds si
  
          n either 
  
   merge si existing abstract state
  
   extract si new abstract state
  
end
  
end
   end
figure     repairing abstraction hierarchy 
four edges level    remove edges level   graph using removeedge  
procedure figure     first three removals simply decrement count associated
abstract edge  line       fourth removal  however  result removing
edge  line     removal recursively propagated  line   
abstraction hierarchy  change abstract graph level    edge count
decremented 
   edges must removed perform full split top bottom
states level   figure     removing first edge e e level   requires
removal    underlying edges level   correspond   edges level    all edges
a  b  b  
state repair first occurs remove edge e e  case e e
parent  g added repair queue  line       repair queue processed
set removal operations  edge e e removed  children g level  
longer form clique  thus  g must split two states h h  initially states
  

fib ulitko   turtevant  l u     yau

removal   repair
level  

removal   repair
h 

level  

split

split

g

e 

h
f 

e 

level  

level  

level  

split

e

f

b 

c 

d 



b

c



e

level  

split

e

f

f

a 

b 

c 

d 



b

c



split

e

    level   edges 

a 

f

a 

level  

level  

split



split

   level   edges 

a 

f 

b

c



split



b

c



figure     example repairing clique abstraction 

edge them  edge removed last edges level
  removed  repair code work many abstraction mechanisms  specifically 
check abstract states children still form clique  line     changed check
corresponding property non clique abstraction 
example  amortized cost abstraction repair constant  imagine agent traversing graph level   left right discovering wall splitting top bottom rows
states  as shown split label figure   step graph sensed
agent edges removed level   graph  removing three edges  a  a    a  b  
 b  a  level   requires removing six edges level    similarly  removing three edges
 e  e    e  f    f  e  requires removing    edges level    general  agent traveling
level   must move twice far  or remove twice many states  repair required
additional level abstraction  thus  number abstraction levels repaired traversing n
ground edges  is 
n
n
n
n
n
                  log   n    o n  
 
 
 
  
n

consequently  example  amortized repair cost per edge traveled o     general 
worst case complexity repair o    and  pr lrts    constant independent graph size 
repairs propagated abstraction hierarchy  line    figure     
  

fig raph bstraction r eal   time h euristic earch

appendix b  abstraction properties
abstraction properties informally introduced illustrated example section     
appendix makes presentation mathematically precise  section  variables i  k  run
natural numbers including   
property    agent using abstraction maintains hierarchy   abstract search graphs addition model environment  abstract graphs search graph sense
section    following denote abstract search graph level i     
 g i   c i   s   i   sg  i   h   i    before  g i     s i   e i   
property    state search graph level n     unique parent state s  level
n     abstract search graph  formally 


s k   k      s  s k      parent s    s   

 b   

property    state search graph level m         least one child
state s  level    notation children s  represents set children state s  thus 
s  children s  


s k   k     s  s k    s  children s   

 b   

property    given heuristic search problem s  instance problem  number
children abstract state upper bounded constant independent number states 
s  search problem   s  e   c  s    sg   h    i        s i 
   children s     m   

 b   

property     graph homomorphism  every edge  s    s    e k   k   n either corresponding abstract edge level k     s  s  abstract state 
s    s  s k   k    
  s    s    e k     parent s     parent s     e k      parent s      parent s        b   

property    edge exists abstract states s  s  edge
child s  child s   
s    s  s k   k    


 
 
 s    s    e k    s  children s    s  children s     s     s     e k     
last property  need following definition 
  

 b   

fib ulitko   turtevant  l u     yau

definition b   path p space  s k   e k      k   defined ordered sequence
states s k  whose two sequential states constitute valid edge e k   formally  p
path  s k   e k   if 
s            sm s k   p    s            sm     i      si   si     e k     

 b   

use notation p  s k   e k   indicate vertices edges path p
sets s k   e k  respectively  notation p indicates state path p 
property   two children abstract state connected path whose states
children abstract state 
s k       k   s     s   children s  p    s             s      s k     e k       b   
b   abstraction induced suboptimality  examples
abstraction cause suboptimality  figure    left  refining abstract path  solid
arrows indicate abstract path  ground level path shown thinner dashed arrows 
agents position shown goals position g  white cells form corridor
induced abstract path  optimal path shown right 

figure     abstraction causes suboptimality 
partial path refinement increase suboptimality  refining entire abstract path  figure    
left  yield shorter paths refining segment abstract path  figure     right   solid
arrows indicate abstract path  ground level path shown thinner dashed arrows 
agents position shown goals position g 
b   abstraction induced suboptimality  upper bound
two factors contribute suboptimality paths returned pr lrts  first
factor parameters chosen lrts  weighted allow suboptimality  effect
analyzed literature  bulitko   lee         analyze suboptimality
introduced abstraction  simplicity analysis consider uniform abstraction
level k states abstracted parent next level abstraction  assumption simplifies analysis enables application analysis non clique abstraction
mechanism maintain property  proving result  introduce two simple lemmas 
  

fig raph bstraction r eal   time h euristic earch

figure     partial path refinement increases suboptimality 
lemma b   suppose abstract edges cost  lowest cost path p states
b j edges lowest cost abstract path abstract parents a  b  
j abstract edges 
proof  prove contradiction  suppose lowest cost abstract path q a  b  
  j edges  consider abstract images states p  either abstract
edge coincide due property    thus form abstract path p  a 
b   due property   j edges  since assumption theorem
abstract edges cost  lowest cost path q a  b   must higher
cost path p  a  b    figure     right   results contradiction 
lemma b   path created refining abstract edge level   cannot longer o k    
level   
proof  demonstrated right portion figure     assume every abstract state
exactly k children  so  level   abstraction state cannot k  
children  assuming path cannot visit single node once  refined path
therefore o k     edges 
present main result 
theorem b   assume every abstract state k children ground level edge costs
    e   level   abstraction  cost path created refining abstract path
level   level    the original space  o ek     times costly optimal path
abstract edges happen uniform cost o e  k      abstract edges costs     ek    
 from lemma b    
proof  first  deal case edges abstract graph uniform cost  consider
two level   states b abstract level   states a    b    left side figure      lowestcost path p b j edges lowest cost abstract path a  b  
j abstract edges lemma b   
  

fib ulitko   turtevant  l u     yau

path p   j edges

path q    j edges

a 

b 



b

a 

path p  j edges

b 

path p   j edges

figure     proving lowest cost abstract path j edges 
suppose agent state seeking go state b  agent first computes
lowest cost abstract path a  b     worst case  abstract path j edges 
suppose two abstract paths a  b     t   t   shown figure     left 
j edges and  due uniform abstract edge cost assumption  cost  worst
case scenario  t   refined lowest cost path t  b t   refined
highest cost path t  b  analyzing cost ratio t  t  arrive
upper bound theorem 
  edge

path t     j edges

a 

level  

b 

level  
path t     j edges

k   edges

figure     paths t     t   cost yet refine shortest longest paths 
due lemma b    one abstract edge level   refined k   level   edges 
worst case  t  j edges t  jk     edges  the result abstracting   levels k  
states single state   furthermore  edges t  cost   leading total cost t 
j  edges t  cost e leading total cost t  e jk       thus  ratio
t  t  costs higher ek   proves first statement theorem 
case abstract edges non uniform costs     ek      consider two abstract paths t   t   a  b     cost ejk     highest possible
cost level   image cost j ground path  path t     abstract cost might overestimated
j abstract edges  cost ek   refine level   path t  j edges
cost   each  thus  total cost t  j lowest possible cost b 
path t   cost t   ejk   abstract edges  cost    since
abstract edges refined k   edges level    path t   refined path t 
ejk   k   edges  cost e  consequently  total cost t 
e ejk   k     je  k      thus  ratio costs t  t  e  k     
  

fig raph bstraction r eal   time h euristic earch

t  
t  


a 

b



b

b 

w
c

c
t  

w

w

j

w

w

j

figure     grid based example achieving worst case suboptimality 
worst case upper bound tight  occurs severely underestimate cost
suboptimal path overestimate cost optimal path  figure    show
happen practice  level   map shown left  lowest cost path  t    states
b straight line cost j  corridors width    length corridors 
w  chosen level   abstraction  states corridor abstract together
single state  map cliques size two  i e   k     theorem b    
right part figure    shows level   abstract graph thick lines original map
light gray  abstraction  path t   a  b    the abstract parents
b  goes lower part map  path t   abstract cost  c   j   w
abstract edges refine w ground level edges each  thus  total cost refined path t 
w   c   j     cw   jw  path t   abstract image t  abstract cost w   k  
j edges  leading total abstract cost jk     jw  shown right side
figure highly zigzagged path 
choose c t   costs much t     agent bad luck
choosing refine t     make certainty  make cost t   slightly higher
cost t     accomplished setting  c   j   w jw  here   c jw j w
c jw   jk     j     result  agent chooses refine t   t    cost
 cw   jw    j        j     o j       ratio cost t       
corresponds bound theorem k      e     
experimental results demonstrate large suboptimality occur practice  illustration  consider histogram suboptimality values      problems
parametrizations pr lrts figure    
suboptimality become practical concern  one use ideas hpa   botea
et al          optimal path costs within regions pre computed cached  precomputation help prevent severe over  under estimation abstract path costs
assumed worst case analysis theorem b   

appendix c  maps used empirical study
four additional maps shown figure    
  

fib ulitko   turtevant  l u     yau

 

percentage problems

  

 

  

 

  

 

  

 

  

  

  

  
  
suboptimality    

   

   

figure     histogram suboptimality experiments 

figure     four additional maps used experiments 

appendix d  dominance average  plots
six plots corresponding entries table   shown figures        
  

fig raph bstraction r eal   time h euristic earch

a 
lrts         
           
        
           
lrts
           
lrts          
        
           

dominated
nondominated

lrts         

firstmove lag  states touched 

lrts
        
lrts
        
           
  
 

  

lrts
lrts          
        
lrts         
 

lrts         
 

  

lrts         

lrts         
lrts         

lrts         

 

  

lrts        
 

 

  

  
convergence travel

a 

dominated
nondominated

lrts         
lrts            
lrts         
 
lrts            
 
lrts
lrts          
        

 

firstmove lag  seconds 

  

lrtslrts
        
        
 
 
lrts         
lrts         
lrts         
lrts            
 

 

lrts
lrts
        
         lrts            
   
 

  

lrts
        
lrts
        
 
 

lrts        
 

 

  

  
convergence travel

a 

dominated
nondominated
 

firstmove lag  seconds 

  

lrts         
 

lrts         
lrts            
 

 

  

lrts
lrts
        
         lrts            
   
 
lrts
lrts          
        

lrts        
 

  
convergence planning  seconds 

 

  

figure     dominance several pairs performance measures  part   

appendix e  dominance individual problems
section     introduced concept dominance demonstrated pr lrts abstraction dominates extreme search algorithms use abstraction  analysis done using cost values averaged      problems  section consider
  

fib ulitko   turtevant  l u     yau

a 
lrts            
        
lrts         
           
lrts          
           
           
        

dominated
nondominated

 

firstmove lag  states touched 

lrts         
           
        
           
 

  

lrts         
        
lrts         
           
        
           
 

lrts
           
lrts          
        
 

  

lrts
lrts          
        

lrts
        
lrts
        
  

 

  

lrts        

 

   

    

    

convergence memory
a 
lrts            
         
 

dominated
non dominated

lrts            
lrts          
           
lrts
lrts           
 

  

first move lag  seconds 

  

lrts          
lrts          
           
           
 
lrts
           
lrts            
           

  

lrts
lrts           
           

  

lrts          

lrts         
lrts         

 

   

    

    

convergence memory

dominated
nondominated

  
lrts         

suboptimality    

  

lrts         

  

lrts         
lrts
lrts
        
           
  

  

lrts         
lrts         
           
lrts
lrts          
           

 

 

a 
 

  

 

  
convergence planning  states touched 

 

  

figure     dominance several pairs performance measures  part   
dominance individual problems  due high variance problems difficulty 
report percentages problems dominance achieved  every pair algorithms 
measure percentage problems first algorithm dominates second 
measure percentage problems second algorithm dominates first  ratio
two percentages call dominance ratio 
  

fig raph bstraction r eal   time h euristic earch

 

  

 

firstmove lag

  

 

  

 

  

 

  
 
  

 

 

  

 

  

  

convergence travel
 

x   

convergence travel

firstmove lag
   

  

   

  
lrts          

lrts          

   
  
 
 
 
 

   
   
   
   

 
  
lrts        

  

   
   
lrts        

 

x   

   

figure     top  lrts             shown filled star  lrts           shown hollow
star  bottom left  convergence travel  bottom right  first move lag 
table    statistics two algorithms figure    
algorithm

convergence travel

first move lag



lrts          

      

      

      

lrts         

      

     

     

dominance ratio
     

top figure    see reproduction corresponding plot figure   
two particular algorithms marked stars  filled star lrts             uses three
levels abstraction  hollow star lrts           operates entirely ground level 
statistics reported table    bottom left figure shows advantages pr lrts
respect convergence travel  approximately          problems  pr lrts
travels less lrts convergence  points    degree line   respect
first move lag  pr lrts superior lrts     problems  bottom right
figure   finally      problems pr lrts dominates lrts  i e   outperforms
  

fib ulitko   turtevant  l u     yau

  

suboptimality    

  
  
  
 
 
 
  

 

 

 

  

  
convergence planning

 

convergence planning

x   

 

  

  

suboptimality    

 
  

 

lrts          

lrts          

 

 
 
 

 

 
 
 
lrts        

 

  

  

  

 

 

 

 

x   

  

  
  
lrts        

  

figure     top  lrts             shown filled star  lrts           shown hollow
star  bottom left  convergence planning  bottom right  suboptimality 
respect measures   hand  lrts dominates pr lrts approximately
   problems  leads dominance ratio       
table    statistics two algorithms figure    
algorithm

convergence planning

suboptimality



lrts          

      

      

      

lrts         

      

      

     

dominance ratio
    

similarly  figure    compares two algorithms respect convergence planning suboptimality final solution  top figure  corresponding plot figure   
lrts             shown filled star lrts           shown hollow star  percent
points domination individual problems found table    plot bottom left
figure shows pr lrts lower convergence planning cost lrts    
problems  plot bottom right shows suboptimality solutions algorithms
  

fig raph bstraction r eal   time h euristic earch

produced  pr lrts optimal lrts     time  finally  pr lrts
dominates lrts     problems  domination way  i e   lrts dominates
pr lrts  happens       problems  leads dominance ratio      
several factors influence results  first  high variance difficulty
individual problems due distribution five buckets optimal path distance  consequently  high variance algorithms trade antagonistic performance measures
problems  case large difference mean values 
figure     dominance average supported dominance majority individual problems  conversely  small difference mean values  e g        suboptimality algorithms
figure     lead overwhelming dominance level individual problems 
extended analysis pairs algorithms displayed figures         convergence travel first move lag  dominance ratio varies      values
infinity averaging        standard error         convergence planning
suboptimality  dominance ratio varies      values infinity averaging      standard error       finally  set     algorithms tested
study  therefore  results viewed approximation actual dominance
relationship among algorithms 

appendix f  interaction abstraction lrts parameters
section     observed general trends influence abstraction five performance measures  abstraction level adds another dimension parameter space lrts  previously
defined d      natural question four parameters interact  order facilitate
comprehensible visualization paper  reduce lrts parameter space d   
d  setting    i e   disabling backtracking lrts   justified two reasons  first 
recent studies  bulitko   lee        sigmundarson   bjornsson        shown effects
backtracking highly domain specific 
table   gives overview influence abstraction parameters lrts qualitative level  detailed analysis five performance measures follows 
important note experiments performed set fixed cost paths fixed size
maps  consequently  map boundary effects observed higher levels abstraction 
detail contribution below 
table    influence lrts parameters impact abstraction  cell table represents impact abstraction either amplified  a  diminished  d  increase
  lower case indicate minor effect    indicates effect 
increase






measure   control parameter
convergence travel
first move lag
convergence planning
convergence memory
suboptimality

increase





convergence travel  increasing abstraction level generally decreases convergence travel
lrts learns smaller abstract maps  independently  increasing lookahead depth lrts
  

fib ulitko   turtevant  l u     yau

convergence travel
x   

x   

level  
level  
optimality weight

 
 
 
 
 
 
   
optimality weight

 

difference convergence travel
 

 

 

   

   

 
   

 
   
   

 

 

   

 

   

lookahead depth

 

convergence travel

 
 
lookahead depth

 

difference convergence travel
    

 
level  
level  
optimality weight

    
    
    
 
 
   
optimality weight

    

   

    
    
   

   

 
   
   

 

 

 

   

lookahead depth

 

 
 
lookahead depth

 

figure     convergence travel  impact abstraction function d    top two graphs 
lrts d    vs  lrts   d     bottom two graphs  lrts   d    vs  lrts   d    
similar effect  bulitko   lee         convergence travel lower bounded doubled optimal
cost start goal  as first trial reveal parts map and  consequently 
cannot final   therefore  decreasing convergence travel via either two mechanisms diminishes
gains mechanism  effect seen figure    noticeable
gap convergence travel abstractions levels      lookahead   
small difference using abstraction levels      thus  increasing lookahead
slightly diminishes effect abstraction  hence table   increasing increases
convergence travel  higher value   gained using abstraction 
increase amplifies advantage abstraction 
first move lag generally increases abstraction level lookahead depth 
lookahead depth increases  size corridor used a  search increases well  thus 
increasing amplifies first move lag due abstraction  pr lrts must plan within
lookahead space  within lrts  inside corridor  within a    figure     
deeper lookahead amplifies impact abstraction  simplified analysis below 
assume map obstacle free leads levels abstraction regular grids
 ignoring boundary effects   length path two points  expressed number
actions  is  thus  decreased factor two abstraction level  assumptions 
total number states pr lrts touches first move  d    abstract graph
  

fig raph bstraction r eal   time h euristic earch

firstmove lag

difference firstmove lag
   

 
level  
level  

   
optimality weight

    
    
    
 
 
   
optimality weight

   

   

   
   
   
   
   

   

 
   
   

 

 

   

 

   

lookahead depth

 

firstmove lag

 
 
lookahead depth

 

difference firstmove lag
 

   

level  
level  
optimality weight

    
    
    
    
 
 
   
optimality weight

   
    

    
   
    

 
   
   

 

 

 

   

lookahead depth

 

 
 
lookahead depth

 

figure     first move lag  impact abstraction function d    top two graphs  lrts d   
vs  lrts   d     bottom two graphs  lrts   d    vs  lrts   d    
 d      ground graph  latter quantity simply number edges ground
path computed number edges abstract path  d  multiplied reduction factor
     adding abstraction levels increases first move lag  d        increase
linear function lookahead depth d  thus  larger values amplify effect adding extra
abstraction levels 
several points glossed simplified analysis  first  reduction
path length always two fold assumed above  presence walls  higher levels
abstraction less likely locate merge fully fledged   element cliques  second  boundaries
abstract graph reached lrts less moves higher abstraction level 
effectively decreases quantity formula size corridor
reduced generous estimate d     finally  feeding a  longer abstract path often improves
performance analyzed previous section  cf  figure      explains
abstraction level   deepening lookahead diminishing returns seen figure    
optimality weight affect number states touched lrts abstract level 
hand  change cost resulting a  search different abstract path may
computed lrts  overall  however  effect first move lag impact
abstraction inconsequential  figure     
  

fib ulitko   turtevant  l u     yau

convergence planning

 

difference convergence planning

x   

 

 

x   

level  
level  

 
optimality weight

 
 
 
 
 
   

   
   

 
   

   

 

optimality weight

   
   

 

 

 

   

lookahead depth

 

convergence planning

 

difference convergence planning
     

 

 

x   

level  
level  

     
optimality weight

 
 
 
 
 
   
optimality weight

 
 
lookahead depth

   

     
     
    

   

 

 
   
   

 

 

    

 

   

lookahead depth

 

 
 
lookahead depth

 

figure     convergence planning  impact abstraction function d    top two graphs 
lrts d    vs  lrts   d     bottom two graphs  lrts   d    vs  lrts   d    
convergence planning  abstraction level increases  convergence planning generally
decreases  effect complex  deeper lookahead increases cost
individual planning step  overall decreases planning costs convergence faster  interplay
two trends moderates overall influence seen figure    
effect convergence planning non trivial  general  lower values reduce
convergence planning cost  note convergence planning cost product average planning
time per unit distance convergence travel  discussed above  optimality weight
amplifies effects abstraction convergence travel  time  substantially
affect increase planning per move abstraction goes up  combining two influences 
conclude optimality weight amplify effects abstraction convergence planning 
confirmed empirically figure    
convergence memory  abstraction decreases amount memory used convergence fewer states learn  effects convergence travel described above  strong correlation convergence
travel convergence memory previously discussed  visually figures      
display similar trends 
suboptimality  increasing abstraction level increases suboptimality  plain lrts  lookahead depth effect suboptimality final solution  however  combine deeper
  

fig raph bstraction r eal   time h euristic earch

convergence memory

difference convergence memory
    

 
level  
level  
optimality weight

    
    
   
 
 
   
optimality weight

   

   

   
   
   
   

 
   
   

 

 

 

   

lookahead depth

 

convergence memory

 
 
lookahead depth

 

difference convergence memory
  

 
level  
level  

  
optimality weight

   
   
  
 
 
   
optimality weight

  

   

  
  
  
  
   

  

 
   
   

 

 

  

 

   

lookahead depth

 

 
 
lookahead depth

 

figure     convergence memory  impact abstraction function d    top two graphs 
lrts d    vs  lrts   d     bottom two graphs  lrts   d    vs  lrts   d    

lookahead abstraction suboptimality arising abstraction decreases  deeper lookahead abstract goal state seen earlier making pr lrts corridor constrained a   additionally 
discussed section     figure     refining shorter paths  computed lrts lower
d  introduces additional suboptimality  suboptimality lower bounded     increasing lookahead diminishes effects abstraction suboptimality  figure     hence table   
increasing decreases amount suboptimality abstraction used  combined abstraction increasing minor amplification effect difference abstraction
makes  figure     two reasons  first  abstract levels graphs fairly small makes
less difference there  second  degree suboptimality abstract path translate directly
degree suboptimality resulting ground path a  may still find reasonable
ground path  thus  influence abstract level overshadowed suboptimaly
introduced process refinement  cf  figure     

  

fib ulitko   turtevant  l u     yau

suboptimality    

difference suboptimality    
 

 
level  
level  

 
optimality weight

  
  
  
 
   
   

 

   
 

optimality weight

 

 

   

 
 
 
  

   

  

 
   

lookahead depth

 

suboptimality    

 
 
lookahead depth

 

difference suboptimality    
 

 
level  
level  

 
optimality weight

  
  
  
 
   
   

 

   
optimality weight

 

 

  

 

   
 
 
 

   

  

 
   

lookahead depth

 

 
 
lookahead depth

 

figure     suboptimality  impact abstraction function d    top two graphs  lrts d   
vs  lrts   d     bottom two graphs  lrts   d    vs  lrts   d    

  

fig raph bstraction r eal   time h euristic earch

references
aylett  r     luck  m          applying artificial intelligence virtual reality  intelligent virtual
environments  applied artificial intelligence             
bacchus  f     yang  q          downward refinement efficiency hierarchical problem
solving   artificial intelligence               
bioware corp          baldurs gate   published interplay  http   www bioware com bgate  
november          
blizzard entertainment         warcraft iii  reign chaos   published blizzard entertainment 
http   www blizzard com war   july         
botea  a   muller  m     schaeffer  j          near optimal hierarchical path finding  journal
game development            
bulitko  v          learning adaptive real time search  tech  rep  http     arxiv  org   abs   cs ai
           computer science research repository  corr  
bulitko  v     lee  g          learning real time search  unifying framework  journal
artificial intelligence research  jair               
bulitko  v   sturtevant  n     kazakevich  m          speeding learning real time search via
automatic state abstraction  proceedings national conference artificial intelligence  aaai   pp             pittsburgh  pennsylvania 
culberson  j     schaeffer  j          searching pattern databases  csci  canadian ai
conference   advances artificial intelligence  pp          springer verlag 
dini  d  m   van lent  m   carpenter  p     iyer  k          building robust planning execution
systems virtual worlds  proceedings artificial intelligence interactive digital
entertainment conference  aiide   pp        marina del rey  california 
ensemble studios         age empires ii  age kings   published microsoft game studios 
http   www microsoft com games age   june          
felner  a   zahavi  u   schaeffer  j     holte  r          dual lookups pattern databases 
proceedings international joint conference artificial intelligence  ijcai   pp     
     edinburgh  united kingdom 
furcy  d          itsa   iterative tunneling search a   proceedings national
conference artificial intelligence  aaai   workshop heuristic search  memory based
heuristics applications  boston  massachusetts 
furcy  d     koenig  s          speeding convergence real time search  proceedings
national conference artificial intelligence  aaai   pp         
furcy  d     koenig  s          limited discrepancy beam search  proceedings international joint conference artificial intelligence  ijcai   pp         
garey  m  r     johnson  d  s          computers intractability  guide theory
np completeness  w  h  freeman   co   new york  ny  usa 
hansen  e  a     zhou  r          anytime heuristic search  journal artificial intelligence
research  jair              
  

fib ulitko   turtevant  l u     yau

hansen  e  a   zilberstein  s     danilchenko  v  a          anytime heuristic search  first results 
tech  rep  cmpsci        computer science department  university massachusetts 
hart  p   nilsson  n     raphael  b          formal basis heuristic determination
minimum cost paths  ieee transactions systems science cybernetics               
hernandez  c     meseguer  p       a   improving convergence lrta  k   proceedings
international joint conference artificial intelligence  ijcai   workshop planning
learning priori unknown dynamic domains  pp        edinburgh  uk 
hernandez  c     meseguer  p       b   lrta  k   proceedings international joint
conference artificial intelligence  ijcai   pp            edinburgh  uk 
holte  r   mkadmi  t   zimmer  r  m     macdonald  a  j          speeding problem solving
abstraction  graph oriented approach  artificial intelligence                  
holte  r   perez  m   zimmer  r     macdonald  a          hierarchical a   searching abstraction
hierarchies efficiently  tech  rep  tr        university ottawa 
id software         doom   published id software  http   en wikipedia org wiki doom  december          
ishida  t          moving target search intelligence  national conference artificial
intelligence  aaai   pp         
ishida  t     korf  r          moving target search  proceedings international joint
conference artificial intelligence  ijcai   pp         
kitano  h   tadokoro  s   noda  i   matsubara  h   takahashi  t   shinjou  a     shimada  s         
robocup rescue  search rescue large scale disasters domain autonomous agents
research  proceedings ieee conference man  systems  cybernetics  vol    
pp         
koenig  s          exploring unknown environments real time search reinforcement learning  proceedings neural information processing systems  pp           
koenig  s          comparison fast search methods real time situated agents  proceedings int  joint conf  autonomous agents multiagent systems  pp          
koenig  s     likhachev  m       a   d  lite  proceedings national conference
artificial intelligence  aaai   pp         
koenig  s     likhachev  m       b   incremental a   advances neural information processing systems  nips   pp           
koenig  s          agent centered search  artificial intelligence magazine                
koenig  s     likhachev  m          real time adaptive a   proceedings international
joint conference autonomous agents multiagent systems  aamas   pp         
koenig  s     simmons  r          solving robot navigation problems initial pose uncertainty
using real time heuristic search  proceedings international conference artificial
intelligence planning systems  pp          
koenig  s   tovey  c     smirnov  y          performance bounds planning unknown terrain 
artificial intelligence              
  

fig raph bstraction r eal   time h euristic earch

korf  r          real time heuristic search  artificial intelligence                  
likhachev  m   ferguson  d   gordon  g   stentz  a     thrun  s          anytime dynamic a  
anytime  replanning algorithm  proceedings international conference automated
planning scheduling  icaps  
likhachev  m   gordon  g  j     thrun  s          ara   anytime a  provable bounds suboptimality  thrun  s   saul  l     scholkopf  b   eds    advances neural information
processing systems     mit press  cambridge  ma 
lustrek  m     bulitko  v          lookahead pathology real time path finding  proceedings
national conference artificial intelligence  aaai   workshop learning search 
pp          boston  massachusetts 
mero  l          heuristic search algorithm modifiable estimate  artificial intelligence     
     
orkin  j            states   plan  ai f e a r  proceedings game developers
conference  gdc   http   www jorkin com gdc     orkin jeff fear doc 
pearl  j          heuristics  addison wesley 
pohl  i          first results effect error heuristic search  meltzer  b     michie  d 
 eds    machine intelligence  vol     pp          american elsevier  new york 
pohl  i          avoidance  relative  catastrophe  heuristic competence  genuine dynamic
weighting computaional issues heuristic problem solving  proceedings international joint conference artificial intelligence  ijcai   pp       
pottinger  d  c          terrain analysis realtime strategy games  proceedings computer
game developers conference  www gamasutra com features gdcarchive      pottinger doc 
rayner  d  c   davison  k   bulitko  v   anderson  k     lu  j          real time heuristic search
priority queue  proceedings international joint conference artificial
intelligence  ijcai   pp            hyderabad  india 
reynolds  c  w          flocks  herds schools  distributed behavioral model  siggraph
    proceedings   th annual conference computer graphics interactive techniques  pp        new york  ny  usa  acm press 
russell  s     wefald  e          right thing  studies limited rationality  mit press 
shimbo  m     ishida  t          controlling learning process real time heuristic search 
artificial intelligence              
shue  l  y   li  s  t     zamani  r          intelligent heuristic algorithm project scheduling
problems  proceedings   nd annual meeting decision sciences institute 
shue  l  y     zamani  r          admissible heuristic search algorithm  proceedings
 th international symposium methodologies intelligent systems  ismis      vol     
lnai  pp       
sigmundarson  s     bjornsson  y          value back propagation vs  backtracking realtime search  proceedings national conference artificial intelligence  aaai  
workshop learning search  boston  massachusetts  usa  aaai press 
  

fib ulitko   turtevant  l u     yau

stenz  a          focussed d  algorithm real time replanning  proceedings
international joint conference artificial intelligence  ijcai   pp           
stout  b          smart moves  intelligent pathfinding  game developer magazine  october       
sturtevant  n          hog   hierarchical open graph  http   www cs ualberta ca nathanst hog  
sturtevant  n          memory efficient abstractions pathfinding  proceedings third
conference artificial intelligence interactive digital entertainment  pp        stanford  california 
sturtevant  n     buro  m          partial pathfinding using map abstraction refinement 
proceedings national conference artificial intelligence  aaai   pp           
pittsburgh  pennsylvania 
sturtevant  n     jansen  r          analysis map based abstraction refinement 
proceedings  th international symposium abstraction  reformulation approximation  whistler  british columbia   in press  
sutton  r          integrated architectures learning  planning  reacting based approximating dynamic programming  proceedings seventh international conference
machine learning  pp          morgan kaufmann 
thalmann  d   noser  h     huang  z          autonomous virtual actors based virtual sensors 
lecture notes computer science  lncs   creating personalities synthetic actors 
towards autonomous personality agents  vol        pp        springer verlag  london 
yahja  a   stentz  a  t   singh  s     brummit  b          framed quadtree path planning mobile
robots operating sparse environments  proceedings  ieee conference robotics
automation   icra   leuven  belgium 

   


