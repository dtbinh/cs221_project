journal artificial intelligence research                  

submitted        published     

planning spectrum one  two  three  infinity
marco pistore

pistore dit unitn it

department information communication technology
university trento
via sommarive           povo  trento   italy

moshe y  vardi

vardi cs rice edu

department computer science
rice university
     s  main street  houston  texas

abstract
linear temporal logic  ltl  widely used defining conditions execution
paths dynamic systems  case dynamic systems allow nondeterministic
evolutions  one specify  along ltl formula   paths
required satisfy formula  two extreme cases universal interpretation a  
requires formula satisfied execution paths  existential
interpretation e   requires formula satisfied execution path 
ltl applied definition goals planning problems nondeterministic
domains  two extreme cases restrictive  often impossible develop plans
achieve goal nondeterministic evolutions system  weak
require goal satisfied execution 
paper explore alternative interpretations ltl formula
extreme cases  define new language permits arbitrary combination
e quantifiers  thus allowing  instance  require finite execution
extended execution satisfying ltl formula  ae   
finite execution whose extensions satisfy ltl formula  ea    show
eight combinations path quantifiers relevant  corresponding alternation
quantifiers length one  a e   two  ae ea   three  aea eae  
infinity   ae   ea     present planning algorithm new language
based automata theoretic approach  study complexity 

   introduction
automated task planning  fikes   nilsson        penberthy   weld        ghallab  nau 
  traverso         given description dynamic domain basic actions
performed it  given goal defines success condition achieved  one
find suitable plan  is  description actions executed domain
order achieve goal  classical planning concentrates called reachability
goals  is  goals define set final desired states reached  quite often
practical applications require plans deal goals general sets
final states  several planning approaches recently proposed  temporal logic
formulas used goal language  thus allowing goals define conditions
whole plan execution paths  i e   sequences states resulting execution
plans  bacchus   kabanza              calvanese  de giacomo    vardi        cerrito  
c
    
ai access foundation  rights reserved 

fipistore   vardi

mayer        dal lago  pistore    traverso        de giacomo   vardi        kvarnstrom
  doherty        pistore   traverso         approaches use linear temporal
logic  ltl   emerson        goal language  ltl allows one express reachability
goals  e g   f q reach q   maintainability goals  e g   g q maintain q   well goals
combine reachability maintainability requirements  e g   f g q reach set
states q maintained   boolean combinations goals 
planning nondeterministic domains  cimatti  pistore  roveri    traverso       
peot   smith        warren         actions allowed different outcomes 
possible know planning time different possible outcomes actually
take place  nondeterminism action outcome necessary modeling realistic way
several practical domains  ranging robotics autonomous controllers two player
games   instance  realistic robotic application one take account
actions pick object might result failure  e g   object slips
robots hand   consequence nondeterminism execution plan may lead
one possible execution path  therefore  one distinguish whether given
goal satisfied possible execution paths  in case speak strong
planning   possible execution paths  weak planning   case
ltl goal   strong planning corresponds interpreting formula universal
way  a   weak planning corresponds interpreting existential way 
e  
weak strong plans two extreme ways satisfying ltl formula  nondeterministic planning domains  might impossible achieve goals strong way 
instance  robotic application might impossible fulfill given task objects
keep slipping robots hand  hand  weak plans unreliable 
since achieve goal overly optimistic assumptions outcomes
action executions 
case reachability goals  strong cyclic planning  cimatti et al         daniele 
traverso    vardi        shown provide viable compromise weak
strong planning  formally  plan strong cyclic possible partial execution
plan always extended execution reaches goal state  strong cyclic
planning allows plans encode iterative trial and error strategies  pick
object succeed  execution strategies may loop forever case
action pick object continuously fails  failure achieving goal
unfair execution usually acceptable  branching time logics ctl ctl  allow
expressing goals take account nondeterminism  indeed  daniele et al        
show encode strong cyclic reachability goals ctl formulas  however  ctl
ctl  path quantifiers interleaved temporal operators  making difficult
extend encoding strong cyclic planning proposed daniele et al         generic
temporal goals 
paper define new logic allows exploring different degrees
ltl formula satisfied exist strong goal a  weak goal
e   consider logic formulas form    ltl formula
path quantifier generalizes e quantifiers used strong weak planning 
   see work ghallab et al         deeper discussion fundamental role nondeterminism
planning problems practical applications 

   

fithe planning spectrum one  two  three  infinity

path quantifier  finite infinite  word alphabet  a  e   path quantifier
seen definition two player game selection outcome action
execution  player  corresponding symbol a  chooses action outcomes order
make goal fail  player e  corresponding symbol e  chooses action outcomes
order satisfy goal   turn  active player controls outcome action
execution finite number actions passes control player  
say plan satisfies goal   player e winning strategy  namely if 
possible moves player a  player e always able build execution path
satisfies ltl formula  
different path quantifiers define different alternations turns players e 
instance  goal a  require formula satisfied independently
hostile player chooses outcomes actions  is  ask strong plan 
goal e  require formula satisfied action outcomes chosen
friendly player e  is  ask weak plan  goal ae  require
every plan execution led player extended player e successful execution
satisfies formula   case reachability goal  corresponds asking
strong cyclic solution  goal ea  require that  initial set actions
controlled player e  guarantee formula satisfied independently
player choose outcome following actions  final example 
goal  ae      aeaea   require formula satisfied executions
player e possibility controlling action outcome infinite number
times 
path quantifiers define arbitrary combinations turns players e 
hence different degrees satisfying ltl goal  show  however  that  rather surprisingly  finite number alternatives exist strong weak planning 
eight canonical path quantifiers give rise plans different strength  every
path quantifier equivalent canonical one  canonical path quantifiers correspond
games length one  a e   two  ae ea   three  aea eae  
games defining infinite alternation players e   ae   ea    
show that  case reachability goals   f q  canonical path quantifiers
collapse  three different degrees solution possible  corresponding weak
 e  f q   strong  a  f q   strong cyclic  ae  f q  planning 
finally  present planning algorithm new goal language study
complexity  algorithm based automata theoretic approach  emerson   jutla 
      kupferman  vardi    wolper         planning domains goals represented
suitable automata  planning reduced problem checking whether given
automaton nonempty  proposed algorithm time complexity doubly
exponential size goal formula  known planning problem
 exptime complete goals form a   pnueli   rosner         hence
complexity algorithm optimal 
structure paper follows  section   present preliminaries
automata theory temporal logics  section   define planning domains
plans  section   define ae ltl  new logic path quantifier  study basic
   path quantifier finite word  player last turn chooses action outcome
rest infinite execution 

   

fipistore   vardi

properties  section   present planning algorithm ae ltl  section  
apply new logic particular cases reachability maintainability goals 
section   make comparisons related works present concluding remarks 

   preliminaries
section introduces preliminaries automata theory temporal logics 
    automata theory
given nonempty alphabet   infinite word infinite sequence                  
symbols   finite state automata proposed finite structures accept
sets infinite words  paper  interested tree automata  namely finite
state automata recognize trees alphabet   rather words 
definition    tree   leafless  tree subset n that 
root tree 
x n x  
x   x n n  x  
x  i      x n n  x  
arity x number children  namely arity x      i   x     let
n  tree d tree arity x  x    labelled tree pair      
tree     following  denote  labelled tree     
  let   dom    
let  labelled tree  path p  possibly infinite  sequence x    x          nodes
xi dom    xk     xk ik     following  denote p     set
finite paths p     set infinite paths   given  finite infinite  path p 
denote  p  string  x     x      x    x          sequence nodes
path p  say finite  resp  infinite  path p  finite  resp  infinite  extension
finite path p sequence nodes p prefix sequence nodes p   
tree automaton automaton accepts sets trees  paper  consider
particular family tree automata  namely parity tree automata  emerson   jutla        
definition    parity tree automata  parity tree automaton parity index k
tuple   h  d  q  q      i  where 
finite  nonempty alphabet 
n finite set arities 
q finite set states 
q  q initial state 
   

fithe planning spectrum one  two  three  infinity





  q  q transition function   q    d   q  
  q             k  parity mapping 
tree automaton accepts tree accepting run automaton tree 
intuitively  parity tree automaton state q reading d ary node
tree labeled   nondeterministically chooses d tuple hq            qd  q    d 
makes copies itself  one child node tree  state
i th copy updated qi   run parity tree automaton accepting if  along every
infinite path  minimal priority visited infinitely often even number 
definition    tree acceptance  parity tree automaton   h  d  q  q      accepts  labelled d tree exists accepting run r   namely exists
mapping r   q that 
r     q   
x arity x    hr x           r x  d   i  r x    x   d  
along every infinite path x    x         
infinitely many nodes xi even 

  minimal integer h  r xi      h

tree automaton nonempty exists tree



accepted a 

emerson jutla        shown emptiness parity tree automaton
decided time exponential parity index polynomial number
states 
theorem   emptiness parity tree automaton n states index k
determined time no k   
    temporal logics
formulas linear temporal logic  ltl   emerson        built top set prop
atomic propositions using standard boolean operators  unary temporal operator
x  next   binary temporal operator u  until   following assume
fixed set atomic propositions prop  define    prop set subsets
prop 
definition    ltl  ltl formulas prop defined following grammar 
q prop 
    q       x   u
define following auxiliary operators  f     u  eventually future  
g   f  always future    ltl formulas interpreted infinite words
  following  write w   ltl whenever infinite word w satisfies ltl
formula  
definition    ltl semantics  let w                 infinite word let
ltl formula  define w    ltl   n  follows 
   

fipistore   vardi

w    ltl q iff q  
w    ltl iff hold w    ltl  
w    ltl   iff w    ltl w    ltl    
w    ltl x iff w  i     ltl  
w    ltl u   iff j w  k   ltl k   j
w  j   ltl    
say w satisfies   written w   ltl   w      ltl  
ctl   emerson        example branching time logic  path quantifiers
 for paths  e  for path  prefix arbitrary combinations linear time
operators 
definition    ctl   ctl  formulas prop defined following grammar 
q prop 
    q         e
          x   u
ctl  formulas interpreted  labelled trees  following  write
whenever satisfies ctl  formula  



  ctl 

definition    ctl  semantics  let  labelled tree let ctl  formula 
define   x   ctl    x   follows 


  x   ctl  q iff q  x  



  x   ctl  iff hold   x   ctl   



  x   ctl   



  x   ctl  iff   p   ctl  holds infinite paths p   x    x          x    x 



 x



iff

  ctl  e iff
x    x 

  x   ctl    x   ctl     

 p

  ctl  holds infinite path p   x    x         

  p   ctl    p p      defined follows 



  p   ctl  iff p   x    x            x    ctl   



  p   ctl  iff hold   p   ctl   



  p   ctl   



  p   ctl  x iff   p    ctl    p    x    x          p   x    x    x          



  p   ctl  u   iff j     pk   ctl    k   j
  pj   ctl      pi   xi   xi           p   x    x          

iff

  p   ctl    p   ctl     

   

fithe planning spectrum one  two  three  infinity

put b on a


b

c

b


put c on b
c

c
b


figure    possible scenario blocks world domain 
say



satisfies ctl  formula   written



  ctl   

    ctl   

following theorem states possible build tree automaton accepts
trees satisfying ctl  formula  tree automaton number states
doubly exponential parity index exponential length formula 
proof theorem given emerson jutla        
theorem   let ctl  formula  let n finite set arities  one
build parity tree automaton ad
accepts exactly  labelled d trees satisfy  
 
automaton ad
 
formula  

o    

states parity index  o          length

   planning domains plans
 nondeterministic  planning domain  cimatti et al         expressed terms
set states  one designated initial state  set actions  transition
function describing  the execution of  action leads one state possibly many
different states 
definition    planning domain  planning domain tuple   h      a  ri where 
finite set states 
  initial state 
finite set actions 
r     transition relation 
require     r   a  
assume states ordered  write r   a    h                n whenever
r   a                     n             n  
example   consider blocks world domain consisting set blocks  initially
table  stacked top order build towers  see
figure    
states domain possible configurations blocks  case
three blocks    states  corresponding blocks table    configuration  
  block tower remaining block table    configurations     block tower
   possible configurations   assume initially blocks table 
   

fipistore   vardi

actions domain put x   put x table  wait  x
two  different  blocks  actions put x put x table possible
blocks top x  otherwise could pick x   addition  action
put x requires blocks top  otherwise could put x
top   
assume outcome action put x nondeterministic  indeed  trying
put block top tower may fail  case tower destroyed  action
wait nondeterministic  possible table bumped towers
destroyed 
plan guides evolution planning domain issuing actions executed 
case nondeterministic domains  conditional plans  cimatti et al         pistore  
traverso        required  is  next action issued plan may depend
outcome previous actions  consider general definition plans 
plan mapping sequence states  representing past history domain
evolution  action executed 
definition    plan  plan partial function       that 
 w     a    r   a     
 w     a    r   a  iff w   dom   
w dom   w      w dom   
   defined iff     initial state domain 
conditions previous definition ensure plan defines action executed
exactly finite paths w   reached executing plan initial
state domain 
example   possible plan blocks world domain example   represented figure    remark importance plans action executed depends
whole sequence states corresponding past history evolution  indeed 
according plan figure    two different actions put c put c table
performed state block b top a  depending past history 
since consider nondeterministic planning domains  execution action may
lead different outcomes  therefore  execution plan planning domain
described  a  labelled tree  component label tree corresponds
state planning domain  component describes action executed
state 
definition     execution tree  execution tree domain plan
 a  labelled tree defined follows 


          a     

initial state domain a         
   

fithe planning spectrum one  two  three  infinity

w

 w 

abc

put b

b
abc ac

put c b

b
abc ac

c
b


b
abc ac

c
b


b
ac

b
abc ac

c
b


b
ac

put c table

history

put b table

abc

wait
wait

figure    plan blocks world domain 
p   x            xn p      p         a         a     n      r n      
 
h             d 
i  every     following conditions hold  xn dom   
 xn i     i    a i   a i        n i    
planning problem consists planning domain goal g defines set
desired behaviors  following  assume goal g defines set execution
trees  namely execution trees exhibit behaviors described goal  we say
execution trees satisfy goal  
definition     planning problem  planning problem pair  d  g  
planning domain g goal  solution planning problem  d  g  plan
execution tree satisfies goal g 

   logic path quantifiers
section define new logic based ltl extends
possibility defining conditions sets paths satisfy ltl property 
start motivating logic necessary defining planning goals 
example   consider blocks world domain introduced previous section  intuitively  plan example   solution goal building tower consisting
blocks a  b  c destroying it  goal easily formulated ltl
   

fipistore   vardi

formula 
    f   c b b table  f  c table b table table   
notice however that  due nondeterminism outcome actions  plan may
fail satisfy goal  possible  instance  action put c b fails
tower destroyed  case  plan proceeds performing wait actions  hence
tower never finished  formally  plan solution goal requires
path execution structure satisfies ltl formula    
clearly  better ways achieve goal building tower destroying
it  fail building tower  rather giving up  restart building keep
trying succeed  strategy allows achieving goal paths 
keep destroying tower try build achieve goal 
see  logic path quantifiers going define allow us formalize
mean paths 
consider following ltl formula 
    f g   c b b table  
formula requires building tower maintaining it  case two possible
ways fail achieve goal  fail build tower  or  built  fail
maintain  remember wait action may nondeterministically lead destruction
tower   similarly case formula     planning goal requires satisfying
formula   paths execution tree unsatisfiable  hand  goal
requires satisfying paths weak  logic allows us demanding
paths satisfy formula 
finally  consider following ltl formula 
    g f   c b b table  
requires tower exists infinitely many time  i e   tower gets destroyed 
rebuild it  intuitively  goal admits plans achieve often  i e  
paths      again  path logic needed give formal meaning
paths 
order able represent planning goals discussed previous example 
consider logic formulas form    ltl formula path
quantifier defines set infinite paths formula checked  two
extreme cases path quantifier a  used denote must hold
paths  path quantifier e  used denote must hold paths 
general  path quantifier  finite infinite  word alphabet  a  e  defines
alternation selection two modalities corresponding e a  instance 
writing ae  require finite paths infinite extension satisfies
  writing ea  require extensions finite path satisfy  
path quantifier seen definition two player game selection
paths satisfy ltl formula  player  corresponding a  tries build
path satisfy ltl formula  player e  corresponding e  tries
   

fithe planning spectrum one  two  three  infinity

build path ltl formula holds  different path quantifiers define different
alternations turns players e  game starts path consisting
initial state  and  turns  players e extend path finite
number nodes  case path quantifier finite word  player moves last
game extends finite path built far infinite path  formula satisfied
player e winning strategy  namely if  possible moves player a 
always able build path satisfies ltl formula 
example   let us consider three ltl formulas defined example    let us see
path quantifiers introduced applied 
case formula     plan presented example   satisfies requirement e    
path tower built destroyed  satisfies stronger
requirement ea   stresses fact that  case  tower built
destroyed  safely give control player a  formula   satisfied
stronger way  however  indeed  plan keeps trying build tower satisfies
requirement ae     well requirement aea     player cannot reach state
satisfaction goal prevented 
let us consider formula     case  find plans satisfying ae    
plan satisfy requirement aea     indeed  player simple strategy win 
gets control built tower  bump table  similar considerations hold
formula     case  find plans requirement ae    
requirement aea     case  however  plans exist requirement aeaeae     
player e gets control infinitely often  rebuild tower needed 
rest section give formal definition study basic properties
logic path quantifiers 
    finite games
start considering games finite number moves  path quantifiers
corresponding finite words  a  e  
definition     ae ltl  ae ltl formula pair g      ltl
formula  a  e   path quantifier 
following definition describes games corresponding finite path quantifiers 
definition     semantics ae ltl  let p finite path  labelled tree
then 
p    a  finite extensions p  p holds p       
p    e  finite extension p  p holds p       
p    a  infinite extensions p  p holds

 p      ltl  

p    e  infinite extension p  p holds
   

 p      ltl  

 

fipistore   vardi

say  labelled tree satisfies ae ltl formula g  write
p     g  p    root  



   g 

ae ltl allows path quantifiers consisting arbitrary combination
es  combination corresponds different set rules game
e  theorem   show freedom definition path quantifier
needed  six path quantifiers sufficient capture possible games 
result based concept equivalent path quantifiers 
consider formulas a  f p ae  f p  easy see two formulas equisatisfiable  i e   tree satisfies a  f p satisfies ae  f p  vice versa 
case  path quantifiers ae power  depends fact
use path quantifiers combination ltl formula f p  combine
two path quantifiers different ltl formulas  g p  possible find
trees satisfy latter path quantifier former  reason  cannot
consider two path quantifiers equivalent  indeed  order two path quantifiers
equivalent  equi satisfiable ltl formulas  intuition
formalized following definition 
definition     equivalent path quantifiers  let   two path quantifiers 
say implies     written
     labelled trees ltl formulas
 
       implies       say equivalent     written    
 
 

 
following lemma describes basic properties path quantifiers
equivalences among them  exploit results proof theorem   
lemma   let      a  e    following implications equivalences hold 
   aa  a  ee  e   
   a 

   

e      empty 

   a 

aea  eae 

e   

   aeae  ae  eaea  ea   
proof  proof lemma  order prove  
   prove that  given
 
arbitrary tree arbitrary ltl formula   p      implies p         every
finite path p   indeed  p        implies p         finite paths p  easy
prove  induction   p        implies p         finite paths p 
following  refer proof technique prefix induction 
   show that  every finite path p  p    aa    p    a    
equivalence aa  a  follows prefix induction 
let us assume p    aa     prove p    a     is  p        
every finite  extension p  p  since p    aa     definition    know that 
   assume   empty word  proof case   empty word similar 

   

fithe planning spectrum one  two  three  infinity

every finite extension p  p  p     a     hence  definition     know
every finite extension p   p    p           since p  finite extension p   
conclude p          therefore  p         holds finite extensions p 
p 
let us assume p    a     prove p    aa     is  finite
extensions p  p  finite extensions p   p    p           remark
finite path p   finite extension p  therefore p          holds since
p    a    
concludes proof equivalence aa  a    proof
equivalence ee  e  similar 
   let us assume first   empty word  distinguish two cases  depending
first symbol         a     prove aa  
a    
 
  
already item   lemma    e   show that 
every finite path p  p    ae     p    e      a 
  follows
  
prefix induction  let us assume p    ae    then  finite extensions p 
p exists finite  extension p   p  p           let us take p    p 
know finite extension p   p p           is 
according definition     p    e    
let us assume   empty word  hypothesis        
empty  distinguish two cases  depending last symbol       a 
prove   aa
  a  already item   lemma 
     e  prove every finite path p  p    ea  p    e  
   ea
   e follows prefix induction  let us assume p    ea  
definition     exists finite extension p  p that  every infinite
extension p   p   p       ltl   let p   infinite extension p   
know p   infinite extension p   p       ltl   then 
definition    deduce p    e  
concludes proof a 

    proof  

e  similar 

   item   lemma know a 
aa  item   know
 
 
aa
aea   concludes proof a 
aea    proof
eae 
e  similar 
   item   lemma know  a eae 
 a e    moreover 
 
 
item    know a e  
aea e    therefore  deduce ae 
 
 
aeae   proof ea eaea  similar 

prove first main result paper  finite path quantifier
equivalent canonical path quantifier length three 
theorem   finite path quantifier canonical finite path quantifier
   a  e ae  ea aea  eae 
   assume    empty word  proof case    empty similar 

   

fipistore   vardi

    moreover  following implications hold canonical finite
path quantifiers 
   
 o  o  o   aea o   o  o   ae











 

 
 
 

ea
eae  o  o o    e




proof  first prove path quantifier equivalent canonical path
quantifier     iterative application lemma       obtain path quantifier
         contain two adjacent e  then  iterative
application lemma       transform    equivalent path quantifier  
length    canonical path quantifiers     precisely quantifiers
length   contain two adjacent e 
implications     


aea eae

e come lemma      

aea

ea ae

eae come lemma      

aea

ae ea

eae come lemma      



remark lemma   theorem   depend usage ltl formula
  depend general observation
  whenever player e select
game   set paths subset selected game  
    infinite games
consider infinite games  namely path quantifiers consisting infinite words
alphabet  a  e   see infinite games express finite path quantifiers
studied previous subsection  infinite games  corresponding infinite alternation two players e  cannot expressed
finite path quantifiers 
case infinite games  assume player e moves according strategy
suggests extend finite path  say       infinite
game  winning strategy player e  strategy winning if  whenever
p infinite path obtained according i e   allowing player play
arbitrary way requiring player e follows strategy p satisfies ltl
formula  
definition     strategy  strategy  labelled tree mapping   p    
p     maps every finite path p one finite extensions  p  
definition     semantics ae ltl  let        a  e  infinite
path quantifier  infinite path p possible outcome game strategy
generating sequence it  namely  infinite sequence p    p          finite paths
that 
pi finite prefixes p 
   

fithe planning spectrum one  two  three  infinity

p    root tree

 

  e pi      pi   
  pi    arbitrary  extension pi  
denote p      set infinite paths possible outcomes game
strategy   tree satisfies ae ltl formula g      written    g 
strategy  p    ltl paths p p      
remark possible paths generating sequence stop growing  i e  
pi pi   pj j i  case  according previous
definition  infinite paths p extend pi possible outcomes 
next lemmas extend analysis equivalence among path quantifiers
infinite games   first lemma shows finite path quantifiers particular cases
infinite path quantifiers  namely  correspond infinite path quantifiers
end infinite sequence e 
lemma   let finite path quantifier   a   e  e 
proof  prove  a  a  proof equivalence similar 
first  prove  a 
a  let tree ltl formula
    a     moreover  let strategy p p   a      satisfy  
order prove    a  sufficient use strategy moves player
e  namely  whenever need prove p    e    according definition     take
p     p  move prove p          way  infinite paths selected
definition    coincide possible outcomes game  a    hence satisfy
ltl formula  
concludes proof  a 
a  prove
 a    distinguish
three cases 
case    a n   n   
case   lemma        a     a    let tree
ltl formula     a  paths satisfy formula  
easy check     a    paths satisfy formula  
sufficient conclude  a na  a n  a   
case   e   
case  ea  indeed  arbitrary path quantifier starts e
ends a  lemma       collapse adjacent occurrences
e   thus obtaining  ea n n      moreover  lemma     
 ea n ea 
let tree ltl formula     ea 
finite path p infinite extensions p satisfy   now  let
   definitions implication equivalence relations  definition     apply case
infinite path quantifiers 

   

fipistore   vardi

strategy      p  every infinite path p p  e   a     
satisfies   indeed  since player e first turn  possible outcomes
infinite extensions      p 
concludes proof e a

e   a   

case    a n e    n     
reasoning proof previous case  easy show aea 
let tree ltl formula     aea 
every finite path p finite extension p  p infinite
extensions p  satisfy formula   let strategy p     p 
finite extension p infinite extensions p  satisfy   every
infinite path p p   a n e   a      satisfies   indeed  let p    p            pn   pn          
generating sequence p  pn      pn   p infinite extension pn    
construction know p satisfies  
concludes proof  a n e a

 a n e   a   

every finite path quantifier falls one three considered cases  therefore 
conclude
 a  every finite path quantifier  

next lemma defines sufficient condition proving
useful proofs forthcoming lemmas 

    condition

lemma   let   two infinite path quantifiers  let us assume  labelled
trees strategy strategy   p          p      

   
proof  let us assume       suitable strategy
p p      satisfy ltl formula   let   strategy p         
p       hypothesis  possible outcomes game   strategy   satisfy ltl
formula   hence         concludes proof
   

next lemma show games players e alternate infinitely
often equivalent one two games  ae   ea    is  assume
player extends path turn passes player 
lemma   let infinite path quantifier contains infinite number
infinite number e   ae   ea   
proof  let    a m   e n   a m   e n  mi   ni      show  ae   
first  prove  ae 
  let strategy tree let p infinite
path   show p p      p p   ae       lemma  
sufficient proving  ae 
 
let p    p          generating sequence p according   moreover  let p      
p  i     pm   n    mi   ni   mi p  i     pm   n    mi   ni   mi      easy
check p     p     p           valid generating sequence p according game  ae 
strategy   indeed  extensions p   p     p   p     p   p           moves player a 
   

fithe planning spectrum one  two  three  infinity

hence arbitrary  extensions p   p     p   p           correspond extensions
pm  pm       pm   n   m  pm   n   m               moves player e hence
respect strategy  
prove
 ae    let strategy tree   define strategy
p p       lemma   sufficient proving
p p   ae      


 ae   
  kp  p  kp   p p  ni   is  strategy path
let p finite path   p 
i  
p obtained applying kp times strategy   number times strategy applied
depends length  p  path p 
p possible
show that  p possible outcome game strategy  

outcome game  ae  strategy   let p    p          generating sequence p

according  ae   
p    p         p     p        p          n   p     p         p   
   z    
 z
     z  
m  times

m  times
n  times
 
n 
 p      p           p     p         p       

 

 z

n  times

     z  
m  times

valid generating sequence p according   extensions corresponding
occurrence symbol e consist application strategy hence valid
player e  moreover  extension ni  p i    p i   valid move player
p i   extension ni  p i     indeed  ni  p i    prefix p i  and hence p i    
p p i   
 i      kp i   p i    kp
since p i    p
 i   
x   nx ni   since  p i    i 
conditions definition    easily checked 
concludes proof  ae     a m   e n   a m   e n    proof
 ea     e m   a n   e m   a n  similar 

next lemma contains auxiliary results path quantifiers 
lemma   let finite path quantifier   infinite path quantifier 
   a 
    a 

   

e   

a  e 

 e   

proof 
   prove a 
    let strategy tree let p infinite
path   show p p        p p  a       let p    p         
generating sequence p according     easy check
p    p            pi    pi   pi   pi            length   valid generating sequence
p according a    indeed  extension pi pi valid move player
a  concludes proof a 
   
prove  
e         e    e    e e     e       
e 
  trivially true        e    assume  without loss
generality      a     case  let strategy tree let p
   

fipistore   vardi

path   show p p  e      p p         let p    p         
generating sequence p according e    easy check
p    p            pi   pi            length   valid generating sequence p
according     indeed  extension pi pi   valid  corresponds
first symbol   assumed symbol a  concludes proof
 
e   
   prove  a 

    proof  

 e  similar 

let strategy tree let p infinite path   show
p p   a      p p         let p    p          generating sequence p
according     easy check p    p          valid generating sequence p according  a    fact   a  defines less restrictive
conditions generating sequences    
sufficient conclude  a 

   



complete picture theorem    finite infinite path quantifier
equivalent canonical path quantifier defines game consisting alternated moves
players e length one  two  three  infinity 
theorem   finite infinite path quantifier canonical path quantifier
   a  e ae  ea aea  eae   ae     ea   
    moreover  following implications hold canonical path
quantifiers 
   
 o  o  o   aea  o  o  o    ae   o  o  o   ae









ea  o  o  o  








 ea 






 o  o o    eae  o  o o    e

proof  first prove path quantifier equivalent canonical path quantifier 
theorem    true finite path quantifiers  consider infinite path
quantifiers 
let infinite path quantifier  distinguish three cases 
contains infinite number infinite number e  then  lemma   
equivalent one canonical games  ae   ea   
contains finite number a  case  ends infinite sequence e 
and  lemma       finite path quantifier      theorem      
equivalent canonical path quantifier  concludes proof
case 
contains finite number e  case similar previous one 
implications     
   

fithe planning spectrum one  two  three  infinity

 ae 
 ae   

 ea  comes lemma       taking empty word    

aea
 ae     ae 
     

ae  ea

 ea     ea 

eae come lemmas  

implications come theorem   



    strictness implications
conclude section showing arrows diagram theorem  
describe strict implications  namely  eight canonical path quantifiers different 
let us consider following  i  p  q  labelled binary tree  root labelled
node two children labelled p q 
    
   
im
qqq mmmmm
q
q
mmm
q
m 
qqq
    
    
    
    
p  xq
q
 

   
 


  
 

  

 




    
    
    
    
    
    
    
    
p 
q 
p 
q 
   
   
   
   








    
    
    
    
    
    
    
    
    
    
    
    
    
p     
p
p     
q
q
p
q
q     

let us consider following ltl formulas 
f p  player e satisfy formula moves least once  visiting p labelled
node 
g f p  player e satisfy formula visit infinite number p labelled
nodes  is  final move finite game  moves infinitely often
infinite game 
f g p  player e satisfy formula takes control game
certain point on  is  final move finite game 
g q  player e satisfy formula player never plays  since player
immediately visit q labelled node 
x p  player e satisfy formula playing first turn moving left
child root node 
following graph shows formulas hold path quantifiers 
fp

gfp

fgp

g q

 o o    aea  o    ae   o o    ae


xp




















ea  o o     ea   o o    eae  o  o o    e
   

fipistore   vardi

   planning algorithm ae ltl
section present planning algorithm ae ltl goals  start showing
build parity tree automaton accepts trees satisfy given ae ltl
formula  show tree automaton adapted  accepts
trees correspond valid plans given planning domain  way  problem
checking whether exists plan given domain ae ltl goal
reduced emptiness problem tree automata  finally  study complexity
planning ae ltl goals prove problem  exptime complete 
    tree automata ae ltl formulas
berwanger  gradel  kreutzer        shown ae ltl formulas expressed directly ctl  formulas  reduction exploits equivalence expressive
power ctl  monadic path logic  moller   rabinovich         tree automaton
obtained ae ltl formula using reduction theorem    however 
translation proposed berwanger et al         upper bound non elementary
complexity  hence useful complexity analysis  paper describe
different  direct reduction better suited purposes 
 labelled tree satisfies formula   suitable subset paths
tree satisfy   subset paths chosen according   order
characterize suitable subsets paths  assume w marking tree  
use labels w define selected paths 
definition     w marking  w marking  labelled tree   w  w   labelled tree w dom      dom w   and  whenever  x      w  x       w 
w  x       w  
exploit w markings follows  associate ae ltl formula   ctl 
formula       tree satisfies formula   wmarking satisfies       
definition     ae ltl ctl   let   ae ltl formula  ctl  formula
      defined follows 
  a     
  e      e
  ea      ef w a f w  
  aea      ag ef w a f w  
  ae      ag exg w a f g w  
  eae      ef ag exg w a f g w  
   ae        ag ef w a g f w  
   ea        ef ag ef w a g f w  
case path quantifiers e  direct translation ctl 
exploit w marking  cases  ctl  formula       conjunction
   

fithe planning spectrum one  two  three  infinity

two sub formulas  first one characterizes good markings according path
quantifier   second one guarantees paths selected according
marking satisfy ltl formula   case path quantifiers ea aea  mark
w nodes that  reached  guarantee formula satisfied  selected
paths hence contain node labelled w  formula f w   case
path quantifiers ae eae  mark w descendants node define
infinite path satisfies   selected paths hence that  certain node
on  continuously labelled w  formula f g w   case path quantifiers  ae 
 ea    finally  mark w nodes player e wants reach according
strategy passing turn player a  selected paths hence
contain infinite number nodes labelled w  formula g f w   is  paths along
player e moves infinitely often 
theorem     labelled tree satisfies ae ltl formula  
w marking satisfies formula       
proof  proof  consider cases   aea    ae    ae   
cases similar 
assume tree satisfies    show exists w marking w
satisfies       
case   aea  according definition     tree satisfies aea   every
finite path p extended finite path p  infinite extensions
p   p  satisfy   let us mark w nodes w correspond
extension p  path p  construction  marked tree satisfies ag ef w 
remains show marked tree satisfies a f w   
let us consider path p   tree satisfies f w  let us show p  
satisfies   since p   satisfies f w  know contains nodes marked w  let
p  finite prefix path p   first node marked w  construction 
exists finite path p p  finite extension p infinite
extensions p  satisfy   consequence  p   satisfies  
case   ae  according definition     tree satisfies ae  
finite paths p infinite extension p satisfies   therefore 
define mapping   p     p     associates finite path p infinite
extension m p  satisfies   assume  without loss generality  that  p 
finite extension p prefix m p   m p      m p   is 
far p  extends finite path p along infinite path m p  associates
p  infinite path m p  
every finite path p  let us mark w node w child p
along infinite path m p   construction  marked tree satisfies ag exg w 
remains show marked tree satisfies a f g w   
let us consider path p   tree satisfies f g w  let us show p  
satisfies   since p   satisfies f g w  know path p
descendants p along p   marked w  order prove p   satisfies
   

fipistore   vardi

show p     m p   assume contradiction m p     p   let p 
longest common prefix m p  p     observe p prefix p    hence
m p    m p     implies child node p  along p   marked w 
absurd  since definition p descendants p along p   marked
w 
case    ae    according definition     tree satisfies  ae    
exists suitable strategy player e possible outcomes game
strategy satisfy   let us mark w nodes w correspond
extension  p  finite path p  is  mark w nodes
reached move player e according strategy   marked
tree satisfies formula ag ef w  is  every finite path p extended
finite path p  node corresponding p  marked w  indeed 
construction  sufficient take p     p     extension p   p  remains
show marked tree satisfies a g f w   
let us consider path p tree satisfies g f w  let us show p
satisfies   purpose  show p possible outcome game
strategy   remark that  given arbitrary finite prefix p  p always possible
find finite extension p   p   p     prefix p  indeed 
set paths p    p    p  finite prefix p  infinite  infinite nodes
marked w path p 
now  let p    p    p          sequence finite paths defined follows  p      
root three  p k   shortest extension p k  p k    
prefix p  p k      p k      easy check p    p    p          generating
sequence p according  ae    hence  definition     infinite path p
satisfies ltl formula  
concludes proof satisfies    exists w marking
satisfies       
assume w marked tree w satisfies        show satisfies
  
case   aea  marked tree satisfies formula ag ef w  means
finite path p  ag  exists finite extension p  final node
p  marked w  ef w    let p   infinite extension finite path p   
show p   satisfies ltl formula   clearly  p   satisfies formula f w 
since tree satisfies formula a f w    infinite paths satisfy f w
satisfy   therefore  p   satisfies ltl formula  
case   ae  marked tree satisfies formula ag exg w  then 
finite path p  ag  exists infinite extension p  that  certain
node on  nodes p  marked w  exg w   show that  p 
infinite extension finite path p  p  satisfies ltl formula   clearly 
p  satisfies formula f g w  since tree satisfies formula a f g w   
infinite paths satisfy f g w satisfy   therefore  p  satisfies ltl
formula  
   

fithe planning spectrum one  two  three  infinity

case    ae    let strategy that  every finite path p  node
corresponding  p  marked w  remark always possible define
strategy  fact  marked tree satisfies formula ag ef w  hence 
finite path p extended finite path p  node corresponding
p  marked w 
let p possible outcome game strategy   prove p satisfies
ltl formula   definition     infinite path p contains infinite set
nodes marked w  nodes reached move player e  hence 
p satisfies formula g f w  since tree satisfies formula a g f w   
infinite paths satisfy g f w satisfy   therefore  path p satisfies ltl
formula  
concludes proof that  exists w marking tree
     



satisfies       


kupferman        defines extension ctl  existential quantification
atomic propositions  egctl   examines complexity model checking satisfiability
new logic  remark ae ltl seen subset egctl   indeed 
according theorem      labelled tree satisfies ae ltl formula  
satisfies egctl  formula w       
following definition show transform parity tree automaton
ctl  formula       parity tree automaton ae ltl formula   
transformation performed abstracting away information w marking
input alphabet transition relation tree automaton 
definition    let   h w  w   d  q  q      parity tree automaton  parity
tree automaton aw   h  d  q  q    w   i  obtained abstracting away wmarking  defined follows  w  q    d     q     w   d   q     w   d  
lemma    let aw two parity tree automata definition     aw accepts
exactly  labelled trees w marking accepted a 
proof  let w   w  w   labelled tree let corresponding  labelled
tree  obtained abstracting away w marking  show w accepted a 
accepted aw   let r   q accepting run w a  r
accepting run aw   indeed  x   arity x    d  w  x       m 
 w  w   hr x             r x d  i  r x      m   d    x     
and  definition aw   hr x             r x d  i w  r x     d  
show that   labelled tree accepted aw     w  w  labelled tree w w marking accepted a  let r   q
accepting run aw   definition run  know x   arity x   
 x      hr x             r x d  i w  r x     d   definition w  
know hr x             r x d  i  r x      w   d   r x      w   d   let us define
w  x       w  hr x             r x d  i  r x      w   d   w  x       w  otherwise 
easy check r accepting run w a 

   

fipistore   vardi

ingredients defining tree automaton accepts
trees satisfy given ae ltl formula 
definition     tree automaton ae ltl  let n finite set arities 
let   ae ltl formula  parity tree automaton ad
  obtained applying
transformation described definition    parity automaton ad
      built according
theorem   
theorem    parity tree automaton ad
  accepts exactly  labelled d trees
satisfy formula   
proof  theorem    parity tree automaton ad
      accepts d trees satisfy
ctl  formula        therefore  parity tree automaton ad
  accepts d trees
satisfy formula   lemma    theorem    

parity tree automaton ad
  parity index exponential number
states doubly exponential length formula  
 
proposition    parity tree automaton ad
   

o    

states parity index  o      

proof  construction definition    change number states
parity index automaton  therefore  proposition follows theorem   

    planning algorithm
describe automaton ad
  exploited order build plan goal
  given domain 
start defining tree automaton accepts trees define valid
plans planning domain   h      a  ri  recall that  according definition   
transition relation r maps state action tuple next states
h                n   r   a  
following assume finite set arities compatible domain
d  namely  r   a    h            a  d 
definition     tree automaton planning domain  let   h      a  ri
planning domain let set arities compatible domain d 

tree automaton ad
corresponding planning domain ad   ha  d            i 
h                  a   d  h              r   a               
 
according definition      a  labelled tree obtained plan
domain d  show converse true  namely   a  labelled tree
accepted tree automaton ad
induces plan 
definition     plan induced tree  let  a  labelled tree accepted automaton ad
  plan induced domain defined follows                   n     finite path p  p         a   
     a     n        
   

fithe planning spectrum one  two  three  infinity

following lemma shows definitions       define one to one correspondence valid plans planning domain trees accepted automaton
ad
d 
lemma    let tree accepted automaton ad
let corresponding
induced plan  valid plan domain d  execution tree corresponding
  conversely  let plan domain let corresponding execution
structure  accepted automaton ad
plan induced  
proof  lemma direct consequence definitions       



define parity tree automaton accepts trees correspond
plans domain satisfy goal g      parity tree automaton obtained
combining suitable way tree automaton ae ltl formula g  definition    
tree automaton domain  definition     
definition     instrumented tree automaton  let set arities compatible planning domain d  let ad
g   h  d  q  q      parity tree automaton accepts trees satisfy ae ltl formula g  parity tree
automaton ad
d g corresponding planning domain goal g defined follows 

ad g   ha  d  q   q               i  h q                  qd    i     q        a   d 
hq            qd  q    d  h              r   a          q       q  
following lemmas show solutions planning problem  d  g  one to one
correspondence trees accepted tree automaton ad
d g  
lemma    let  a  labelled tree accepted automaton ad
d g   let
plan induced domain d  plan solution planning problem
 d  g  
proof  according definition     prove execution tree corresponding
satisfies goal g  lemma     amounts proving tree satisfies g 
construction  easy check  a  labeled tree accepted ad
d g  

accepted ag   indeed  rd g   q accepting run ad
d g  

rg   q accepting run ag   rg  x    q whenever rd g    q   
 

lemma    let solution planning problem  d  g   execution tree
accepted automaton ad
d g  
proof  let execution tree   lemma    know accepted ad
d 
moreover  definition solution planning problem  know accepted
ad
g   construction  easy check  a  labeled tree accepted


ad ad
g   accepted ad g   indeed  let rd   accepting

run ad
let rg   q accepting run ag   rd g   q

accepting run ad g   rd g  x     q    rd  x    rg  x    q 

   

fipistore   vardi

consequence  checking whether goal g satisfied domain reduced
problem checking whether automaton ad
d g nonempty 
theorem    let planning domain g ae ltl formula  plan exists
goal g domain tree automaton ad
d g nonempty 
proposition    parity tree automaton ad
d g domain          a  r  goal
g          

o    

states parity index  o      

proof  consequence proposition    definition automaton ad
d g  
    complexity
study time complexity planning algorithm defined subsection     
given planning domain d  planning problem ae ltl goals g    
decided time doubly exponential size formula applying
theorem   tree automaton ad
d g  
lemma    let planning domain  existence plan ae ltl goal g    
o    
domain decided time   
 
proof  theorem    existence plan goal g domain reduced
emptiness problem parity tree automaton ad
d g   proposition     parity tree
o    

 
automaton ad
   states parity index  o       since assume
d g  
domain fixed  theorem    emptiness automaton ad
d g decided time

  

o    

 



doubly exponential time bound tight  indeed  realizability problem
ltl formula   known  exptime complete  pnueli   rosner        
reduced planning problem goal a   realizability problem one assumes
program environment alternate control evolution system 
precisely  execution               states decided program
even  environment odd  say given formula realizable
program executions satisfy independently actions
environment 
theorem    let planning domain  problem deciding existence plan
ae ltl goal g     domain  exptime complete 
proof  realizability formula reduced problem checking exis
tence plan goal a  planning domain    init     p  e    init   e   r  
with 
r init               e  
 

r init  e   

 

r    p            e  

r    p   e   

 

r    e   e           p       

r    e      
   

fithe planning spectrum one  two  three  infinity

     
states    p  program controls evolution actions    
states    e  environment controls evolution  nondeterministic action e performed state  finally  state init used assign initial
move program 
since realizability problem  exptime complete size ltl formula
 pnueli   rosner         planning problem  exptime hard size goal
g       exptime completeness follows lemma    

remark that  case goals form e   algorithm better
complexity defined  case  plan exists e 
infinite sequence               states satisfies i   r i   ai  
action ai   is  planning problem reduced model checking problem
ltl formula   problem known pspace complete  sistla   clarke 
       conjecture that  canonical path quantifiers except e  doubly
exponential bound theorem    tight 
remarks order complexity satisfiability validity problems
ae ltl goals  problems pspace complete  indeed  ae ltl formula
  satisfiable ltl formula satisfiable    latter problem
known pspace complete  sistla   clarke         similar argument holds
validity 
complexity model checking problem ae ltl recently addressed
kupferman vardi         kupferman vardi introduce mctl   variant
ctl   path quantifiers memoryful interpretation  show memoryful quantification express  with linear cost  semantics path quantifiers
ae ltl  example  ae ltl formula ae  expressed mctl  formula
ag e   kupferman vardi show model checking problem new logic
expspace complete  result holds subset mctl  corresponds formulas ae   therefore  model checking problem ae ltl finite
path quantifiers expspace complete  best knowledge complexity
model checking ae ltl formulas  ae     ea    still open problem 

   two specific cases  reachability maintainability goals
section consider two basic classes goals particularly relevant
field planning 
    reachability goals
first class goals reachability goals corresponding ltl formula f q 
q propositional formula  literature planning concentrates
class goals  several works address problem defining plans
different strength kind goals  see  e g   cimatti et al        citations  
   tree satisfies   paths satisfy   path satisfies seen
tree satisfies   

   

fipistore   vardi

context ae ltl  soon player e takes control  immediately achieve
reachability goal possible all  fact control given back player
goal achieved irrelevant  therefore  significant path quantifiers
reachability goals a  e  ae 
proposition    let q propositional formula atomic propositions prop  then 
following results hold every labelled tree      e  f q iff    ea  f q iff    eae  f q
iff     ea    f q  moreover    ae  f q iff    aea  f q iff     ae    f q 
proof  prove    ae  f q iff    aea  f q iff     ae    f q  cases
similar 
let us assume    ae  f q  moreover  let p finite path   know p
extended infinite path p   p       f q  according semantics
ltl   p       f q means node x path p  q  x   clearly 
infinite paths contain node x satisfy ltl formula f q  therefore 
finite extension p   p infinite extensions p   satisfy ltl
formula f q  sufficient take p   finite extension p contains node x  since
property holds every finite path p  conclude    aea  f q 
proven    ae  f q implies    aea  f q  theorem   know
aea
 ae 
ae  hence    aea  f q implies     ae    f q implies    ae  f q 
concludes proof 

following diagram shows implications among significant path quantifiers
reachability goals 
   
 o  o  o   ae  o  o  o   e
remark three goals a  f q  e  f q  ae  f q correspond  respectively 
strong  weak  strong cyclic planning problems cimatti et al         
    maintainability goals
consider another particular case  namely maintainability goals g q  q
propositional formula  maintainability goals properties complementary
properties reachability goals  case  soon player takes control 
violate maintainability goal possible all  fact player e take control
player hence irrelevant  interesting path quantifiers a  e 
ea 
proposition    let q propositional formula atomic propositions prop  then 
following results hold every labelled tree      a  g q iff    ae  g q iff   
aea  g q iff     ae    g q  moreover    ea  g q iff    eae  g q iff     ea    g q 
proof  proof similar proof proposition    



following diagram shows implications among significant path quantifiers
maintainability goals 
 o  o  o   ea  o  o  o   e
   

fithe planning spectrum one  two  three  infinity

goals a  g q  e  g q  ea  g q correspond maintainability variants strong  weak 
strong cyclic planning problems  indeed  correspond requiring condition q
maintained evolutions despite nondeterminism  a  g q   condition q maintained
evolutions  e  g q   possible reach state condition
q always maintained despite nondeterminism  ea  g p  

   related works concluding remarks
paper defined ae ltl  new temporal logic extends ltl
possibility declaring complex path quantifiers define different degrees
ltl formula satisfied computation tree  propose use ae ltl formulas
expressing temporally extended goals nondeterministic planning domains 
defined planning algorithm ae ltl goals based automata theoretic
framework  existence plan reduced checking emptiness suitable parity
tree automaton  studied time complexity planning algorithm  proving
 exptime complete length ae ltl formula 
field planning  several works use temporal logics defining goals 
approaches  bacchus   kabanza              calvanese et al         cerrito   mayer 
      de giacomo   vardi        kvarnstrom   doherty        use linear temporal logics
goal language  able express conditions degree goal
satisfied respect nondeterminism execution  notable exceptions
works described pistore  bettin  traverso         pistore traverso       
dal lago et al          pistore et al         pistore traverso        use ctl
goal language  dal lago et al         define new branching time logic allows
expressing temporally extended goals deal explicitly failure recovery
goal achievement  goal languages  however  path quantifiers interleaved
temporal operators  hence rather different ae ltl 
field temporal logics  work alternating temporal logic  atl   alur 
henzinger    kupferman        related work  atl  path quantifiers
ctl ctl  replaced game quantifiers  nevertheless  obvious way
expressed formulas form    path quantifier ltl formula
atl   expressive logic studied alur et al          conjecture
logic atl incomparable expressiveness 
comments order practical impact  exptime complexity
planning algorithm  first all  many planning problems expect
complex large domains  goals relatively simple  see  e g   experimental
evaluation performed pistore et al         case planning goals expressed ctl
formulas   cases  doubly exponential complexity algorithm size
formula may bottleneck  larger ae ltl goals  doubly exponential time
complexity may feasible  noted worst case complexity 
note improved algorithms plan synthesis active research area  including
analysis simpler ltl goals  alur   la torre        development improved
automata theoretic algorithms  kupferman   vardi        
automata theoretic framework used paper wider applicability ae ltl goals  interesting direction future investigations application
   

fipistore   vardi

framework variants ae ltl allow nesting path quantifiers 
goals combine ae ltl propositional temporal operators  would allow 
instance  specify goals compose requirements different strength  simple
example goals  ae  f p  a  g p   requires achieve condition p strong
cyclic way  maintaining condition q strong way  impossibility define kind
goals is  opinion  strongest limitation ae ltl respect ctl
ctl  
another direction future investigations extension approach proposed
paper case planning partial observability  de giacomo   vardi        
one assumes agent executing plan observe part state
hence choices actions execute may depend part 
plan explore implementation issues and  particular  possibility
exploiting bdd based symbolic techniques planning algorithm ae ltl goals 
cases  techniques shown able deal effectively domains
goals significant complexity  despite exponential worst case time complexity
problems  bertoli  cimatti  pistore  roveri    traverso        pistore et al         

acknowledgments
shorter version paper  without proofs  published pistore vardi
        authors would thank erich gradel comments reduction
ae ltl formulas ctl  formulas 

references
alur  r   henzinger  t     kupferman  o          alternating time temporal logic  journal
acm                 
alur  r     la torre  s          deterministic generators games ltl fragments 
acm trans  comput  log              
bacchus  f     kabanza  f          planning temporally extended goals  ann 
mathematics artificial intelligence          
bacchus  f     kabanza  f          using temporal logic express search control knowledge
planning  artificial intelligence                    
bertoli  p   cimatti  a   pistore  m   roveri  m     traverso  p          mbp  model
based planner  proc  ijcai   workshop planning uncertainty
incomplete information 
berwanger  d   gradel  e     kreutzer  s          upon time west   determinacy  definability  complexity path games  prof    th int  conf logic
programming  artificial intelligence  reasoning  lpar     pp         
calvanese  d   de giacomo  g     vardi  m          reasoning actions planning
ltl action theories  proc   th int  conf  principles knowledge
representation reasoning  kr     pp         
   

fithe planning spectrum one  two  three  infinity

cerrito  s     mayer  m          bounded model search linear temporal logic
application planning  proc   nd int  conf  analytic tableaux related
methods  tableaux     vol       lnai  pp          springer verlag 
cimatti  a   pistore  m   roveri  m     traverso  p          weak  strong  strong cyclic
planning via symbolic model checking   artificial intelligence                  
dal lago  u   pistore  m     traverso  p          planning language extended
goals  proc    th national conf  artificial intelligence  aaai     aaai
press 
daniele  m   traverso  p     vardi  m          strong cyclic planning revisited  proc 
 th european conf  planning  ecp     vol       lnai  pp        springer
verlag 
de giacomo  g     vardi  m          automata theoretic approach planning temporally extended goals  proc   th european conf  planning  ecp     vol 
     lnai  pp          springer verlag 
emerson  e  a          temporal modal logic  van leeuwen  j   ed    handbook
theoretical computer science  volume b  formal models semantics  elsevier 
emerson  e     jutla  c          complexity tree automata logics programs 
proc    th ieee symp  foundations computer science  pp         
emerson  e     jutla  c          tree automata   calculus determinacy  proc 
  nd ieee symp  foundations computer science  pp         
fikes  r     nilsson  n          strips  new approach application theorem
proving problem solving  artificial intelligence                  
ghallab  m   nau  d     traverso  p          automated planning  theory practice 
elsevier 
kupferman  o          augmenting branching temporal logics existential quantification atomic propositions  journal logic computation                
kupferman  o     vardi  m          safraless decision procedures  proc    th ieee
symp  foundations computer science  focs     pp          ieee computer
society 
kupferman  o     vardi  m          memoryful branching time logic  proc 
  th ieee symposium logic computer science  lics        ieee computer
society 
kupferman  o   vardi  m     wolper  p          automata theoretic approach branching time model checking  journal acm         
kvarnstrom  j     doherty  p          talplanner  temporal logic based forward chaining
planner  ann  mathematics artificial intelligence             
moller  f     rabinovich  a          expressive power ctl   proc    th
annual ieee symposium logic computer science  lics     pp         
ieee computer science press 
   

fipistore   vardi

penberthy  j     weld  d          ucpop  sound  complete  partial order planner
adl  proc   rd int  conf  principles knowledge representation
reasoning  kr    
peot  m     smith  d          conditional nonlinear planning  proc   st int  conf 
ai planning systems  aips     pp          morgan kaufmann publisher 
pistore  m   bettin  r     traverso  p          symbolic techniques planning
extended goals non deterministic domains  proc   th european conf 
planning  ecp    
pistore  m     traverso  p          planning model checking extended goals nondeterministic domains  proc    th int  joint conf  artificial intelligence
 ijcai     aaai press 
pistore  m     vardi  m          planning specturm one  two  three  infinity 
proc    th ieee symposium logic computer science  lics        pp 
       
pnueli  a     rosner  r          distributed reactive systems hard synthesize 
proc    st ieee symp  foundation computer science  pp         
sistla  a     clarke  e          complexity propositional linear temporal logic 
journal acm             
warren  d          generating conditional plans programs  proc  summer
conf  artificial intelligence simulation behaviour  aisb     pp         

   


