journal of artificial intelligence research                 

submitted        published      

new inference rules for max sat
chu min li

chu min li u picardie fr

laria  universite de picardie jules verne
   rue st  leu        amiens cedex     france

felip manya

felip iiia csic es

iiia  artificial intelligence research institute
csic  spanish national research council
campus uab        bellaterra  spain

jordi planes

jplanes diei udl es

computer science department  universitat de lleida
jaume ii            lleida  spain

abstract
exact max sat solvers  compared with sat solvers  apply little inference at each
node of the proof tree  commonly used sat inference rules like unit propagation produce
a simplified formula that preserves satisfiability but  unfortunately  solving the max sat
problem for the simplified formula is not equivalent to solving it for the original formula 
in this paper  we define a number of original inference rules that  besides being applied
efficiently  transform max sat instances into equivalent max sat instances which are
easier to solve  the soundness of the rules  that can be seen as refinements of unit resolution
adapted to max sat  are proved in a novel and simple way via an integer programming
transformation  with the aim of finding out how powerful the inference rules are in practice 
we have developed a new max sat solver  called maxsatz  which incorporates those rules 
and performed an experimental investigation  the results provide empirical evidence that
maxsatz is very competitive  at least  on random max  sat  random max  sat  maxcut  and graph   coloring instances  as well as on the benchmarks from the max sat
evaluation      

   introduction
in recent years there has been a growing interest in developing fast exact max sat
solvers  alber  gramm    niedermeier        alsinet  manya    planes      b       
de givry  larrosa  meseguer    schiex        li  manya    planes        xing   zhang 
      zhang  shen    manya        due to their potential to solve over constrained nphard problems encoded in the formalism of boolean cnf formulas  nowadays  max sat
solvers are able to solve a lot of instances that are beyond the reach of the solvers developed
just five years ago  nevertheless  there is yet a considerable gap between the difficulty of the
instances solved with current sat solvers and the instances solved with the best performing
max sat solvers 
the motivation behind our work is to bridge that gap between complete sat solvers
and exact max sat solvers by investigating how the technology previously developed for
sat  goldberg   novikov        li        marques silva   sakallah        zhang       
zhang  madigan  moskewicz    malik        can be extended and incorporated into maxc
    
ai access foundation  all rights reserved 

fili  manya   planes

sat  more precisely  we focus the attention on branch and bound max sat solvers based on
the davis putnam logemann loveland  dpll  procedure  davis  logemann    loveland 
      davis   putnam        
one of the main differences between sat solvers and max sat solvers is that the former
make an intensive use of unit propagation at each node of the proof tree  unit propagation 
which is a highly powerful inference rule  transforms a sat instance  into a satisfiability
equivalent sat instance  which is easier to solve  unfortunately  solving the max sat
problem for  is  in general  not equivalent to solving it for    i e   the number of unsatisfied
clauses in  and  is not the same for every truth assignment  for example  if we apply
unit propagation to the cnf formula     x    x   x    x   x    x   x    x   x     we
obtain            but  and  are not equivalent because any interpretation satisfying
x  unsatisfies one clause of  and two clauses of    therefore  if we want to compute an
optimal solution  we cannot apply unit propagation as in sat solvers 
we proposed in a previous work  li et al         to use unit propagation to compute
lower bounds in branch and bound max sat solvers instead of using unit propagation to
simplify cnf formulas  in our approach  we detect disjoint inconsistent subsets of clauses
via unit propagation  it turns out that the number of disjoint inconsistent subsets detected
is an underestimation of the number of clauses that will become unsatisfied when the current
partial assignment is extended to a complete assignment  that underestimation plus the
number of clauses unsatisfied by the current partial assignment provides a good performing
lower bound  which captures the lower bounds based on inconsistency counts that most of
the state of the art max sat solvers implement  alsinet  manya    planes      a  alsinet
et al       b  borchers   furman        wallace   freuder        zhang et al          as
well as other improved lower bounds  alsinet  manya    planes        alsinet et al        
xing   zhang              
on the one hand  the number of disjoint inconsistent subsets detected is just a conservative underestimation for the lower bound  since every inconsistent subset  increases the
lower bound by one independently of the number of clauses of  unsatisfied by an optimal
assignment  however  an optimal assignment can violate more than one clause of an inconsistent subset  therefore  we should be able to improve the lower bound based on counting
the number of disjoint inconsistent subsets of clauses 
on the other hand  despite the fact that good quality lower bounds prune large parts of
the search space and accelerate dramatically the search for an optimal solution  whenever
the lower bound does not reach the best solution found so far  upper bound   the solver
continues exploring the search space below the current node  during that search  solvers
often redetect the same inconsistencies when computing the lower bound at different nodes 
basically  the problem with lower bound computation methods is that they do not simplify
the cnf formula in such a way that the unsatisfied clauses become explicit  lower bounds
are just a pruning technique 
to overcome the above two problems  we define a set of sound inference rules that
transform a max sat instance  into a max sat instance  which is easier to solve  in
max sat  an inference rule is sound whenever  and  are equivalent 
let us see an example of inference rule  given a max sat instance  that contains
three clauses of the form l    l    l   l    where l    l  are literals  we replace  with the cnf
   

finew inference rules for max sat

formula
       l    l    l   l          l   l    
note that the rule detects a contradiction from l    l    l   l  and  therefore  replaces these
clauses with an empty clause  in addition  the rule adds the clause l   l  to ensure the
equivalence between  and    for any assignment containing either l       l       or
l       l       or l       l       the number of unsatisfied clauses in  l    l    l   l    is   
but for any assignment containing l       l       the number of unsatisfied clauses is   
note that even when any assignment containing l       l      is not the best assignment
for the subset  l    l    l   l     it can be the best for the whole formula  by adding l   l   
the rule ensures that the number of unsatisfied clauses in  and  is also the same when
l       l      
that inference rule adds the new clause l   l    which may contribute to another contradiction detectable via unit propagation  in this case  the rule allows to increase the
lower bound by   instead of    moreover  the rule makes explicit a contradiction among
l    l    l   l    so that the contradiction does not need to be redetected below the current
node 
some of the inference rules defined in the paper are already known in the literature  bansal   raman        niedermeier   rossmanith         others are original for
max sat  the new rules were inspired by different unit resolution refinements applied in
sat  and were selected because they could be applied in a natural and efficient way  in a
sense  we can summarize our work telling that we have defined the max sat counterpart
of sat unit propagation 
with the aim of finding out how powerful the inference rules are in practice  we have
designed and implemented a new max sat solver  called maxsatz  which incorporates those
rules  as well as the lower bound defined in a previous work  li et al          and performed
an experimental investigation  the results provide empirical evidence that maxsatz is very
competitive  at least  on random max  sat  random max  sat  max cut  and graph
  coloring instances  as well as on the benchmarks from the max sat evaluation        
the structure of the paper is as follows  in section    we give some preliminary definitions  in section    we describe a basic branch and bound max sat solver  in section    we
define the inference rules and prove their soundness in a novel and simple way via an integer
programming transformation  we also give examples to illustrate that the inference rules
may produce better quality lower bounds  in section    we present the implementation of
the inference rules in maxsatz  in section    we describe the main features of maxsatz  in
section    we report on the experimental investigation  in section    we present the related
work  in section    we present the conclusions and future work 

   preliminaries
in propositional logic a variable xi may take values    for false  or    for true   a literal li
is a variable xi or its negation xi   a clause is a disjunction of literals  and a cnf formula
 is a conjunction of clauses  the length of a clause is the number of its literals  the size
of   denoted by     is the sum of the length of all its clauses 
   http   www iiia csic es maxsat  

   

fili  manya   planes

an assignment of truth values to the propositional variables satisfies a literal xi if xi
takes the value   and satisfies a literal xi if xi takes the value    satisfies a clause if it
satisfies at least one literal of the clause  and satisfies a cnf formula if it satisfies all the
clauses of the formula  an empty clause  denoted by    contains no literals and cannot be
satisfied  an assignment for a cnf formula  is complete if all the variables occurring in
 have been assigned  otherwise  it is partial 
the max sat problem for a cnf formula  is the problem of finding an assignment
of values to propositional variables that minimizes the number of unsatisfied clauses  or
equivalently  that maximizes the number of satisfied clauses   max sat is called maxksat when all the clauses have k literals per clause  in the following  we represent a cnf
formula as a multiset of clauses  since duplicated clauses are allowed in a max sat instance 
cnf formulas   and   are equivalent if   and   have the same number of unsatisfied
clauses for every complete assignment of   and    

   a basic max sat solver
the space of all possible assignments for a cnf formula  can be represented as a search
tree  where internal nodes represent partial assignments and leaf nodes represent complete
assignments  a basic branch and bound algorithm for max sat explores the search tree in
a depth first manner  at every node  the algorithm compares the number of clauses unsatisfied by the best complete assignment found so far called upper bound  u b  with the
number of clauses unsatisfied by the current partial assignment   emptyclauses  plus an
underestimation of the minimum number of non empty clauses that will become unsatisfied
if we extend the current partial assignment into a complete assignment  underestimation  
the sum  emptyclauses   underestimation is a lower bound  lb  of the minimum
number of clauses unsatisfied by any complete assignment extended from the current partial
assignment  obviously  if lb  u b  a better solution cannot be found from this point in
search  in that case  the algorithm prunes the subtree below the current node and backtracks
to a higher level in the search tree 
if lb   u b  the algorithm tries to find a possible better solution by extending the
current partial assignment by instantiating one more variable  which leads to the creation
of two branches from the current branch  the left branch corresponds to assigning the new
variable to false  and the right branch corresponds to assigning the new variable to true  in
that case  the formula associated with the left  right  branch is obtained from the formula
of the current node by deleting all the clauses containing the literal x  x  and removing all
the occurrences of the literal x  x   i e   the algorithm applies the one literal rule 
the solution to max sat is the value that u b takes after exploring the entire search
tree 
figure   shows the pseudo code of a basic solver for max sat  we use the following
notations 
 simplifyformula   is a procedure that simplifies  by applying sound inference rules 
  emptyclauses   is a function that returns the number of empty clauses in  
   

finew inference rules for max sat

input  max sat   u b    a cnf formula  and an upper bound u b
     simplifyformula   
   if     or  only contains empty clauses then
  
return  emptyclauses   
   end if
   lb   emptyclauses     underestimation   u b  
   if lb  u b then
  
return u b 
   end if
   x  selectvariable   
    u b  min u b  max sat x   u b   
    return min u b  max sat x   u b   
output  the minimal number of unsatisfied clauses of 
figure    a basic branch and bound algorithm for max sat
 lb is a lower bound of the minimum number of unsatisfied clauses in  if the current
partial assignment is extended to a complete assignment  we assume that its initial
value is   
 underestimation   u b  is a function that returns an underestimation of the minimum
number of non empty clauses in  that will become unsatisfied if the current partial
assignment is extended to a complete assignment 
 u b is an upper bound of the number of unsatisfied clauses in an optimal solution 
we assume that its initial value is the total number of clauses in the input formula 
 selectvariable   is a function that returns a variable of  following an heuristic 
 x  x   is the formula obtained by applying the one literal rule to  using the literal
x  x  
state of the art max sat solvers implement the basic algorithm augmented with powerful inference techniques  good quality lower bounds  clever variable selection heuristics 
and efficient data structures 
we have recently defined  li et al         a lower bound computation method in which
the underestimation of the lower bound is the number of disjoint inconsistent subsets that
can be detected using unit propagation  the pseudo code is shown in figure   
example   let  be the following cnf formula 
 x    x    x    x    x   x   x    x    x    x   x    x   x    
with our approach we are able to establish that the number of disjoint inconsistent
subsets of clauses in  is at least    therefore  the underestimation of the lower bound is   
the steps performed are the following ones 
   

fili  manya   planes

input  underestimation   u b    a cnf formula  and an upper bound u b
   underestimation    
   apply the one literal rule to the unit clauses of   unit propagation  until an empty
clause is derived 
   if no empty clause can be derived then
  
return underestimation 
   end if
      without the clauses that have been used to derive the empty clause 
   underestimation    underestimation     
   if underestimation  emptyclauses    u b then
  
return underestimation 
    end if
    go to   
output  the underestimation of the lower bound for 
figure    computation of the underestimation using unit propagation
       x    x    x    x   x    x   x     the first inconsistent subset detected using unit
propagation is  x    x    x    x   x   x     and underestimation     
       x    x  x    x  x     the second inconsistent subset detected using unit propagation
is  x    x     and underestimation     
        the third inconsistent subset detected using unit propagation is  x    x   x    x  
x     and underestimation      since  is empty  the algorithm stops 

   inference rules
we define the set of inference rules considered in the paper  they were inspired by different
unit resolution refinements applied in sat  and were selected because they could be applied
in a natural and efficient way  some of them are already known in the literature  bansal  
raman        niedermeier   rossmanith         others are original for max sat 
before presenting the rules  we define an integer programming transformation of a cnf
formula used to establish the soundness of the rules  the method of proving soundness is
novel in max sat  and provides clear and short proofs 
    integer programming transformation of a cnf formula
assume that     c         cm   is a cnf formula with m clauses over the variables x         xn  
let ci     i  m  be xi        xik  xik         xik r   note that we put all positive literals
in ci before the negative ones 
we consider all the variables in ci as integer variables taking values   or    and define
the integer transformation of ci as
ei  xi         xik   xik          xik r         xi          xik  xik      xik r
   

finew inference rules for max sat

obviously  ei has value   iff at least one of the variables xij s     j  k  is instantiated
to   or at least one of the variables xis s  k      s  k   r  is instantiated to    in other
words  ei    iff ci is satisfied  otherwise ei    
a literal l corresponds to an integer denoted by l itself for our convenience  the intention
of the correspondence is that the literal l is satisfied if the integer l is   and is unsatisfied if
the integer l is    so if l is a positive literal x  the corresponding integer l is x  l is   x   l 
and if l is a negative literal x  l is   x and l is x      x    l  consequently  l   l in any
case 
we now generically write ci as l   l        lk r   its integer programming transformation
is
ei       l       l          lk r   
the integer programming transformation of a cnf formula     c         cm   over the
variables x         xn is defined as
e x         xn    

m
x

ei

   

i  

that integer programming transformation was used  huang   jin        li   huang 
      to design a local search procedure  and is called pseudo boolean formulation by boros
and hammer         here  we extend it to empty clauses  if ci is empty  then ei    
given an assignment a over the variables x         xn   the value of e is the number of
unsatisfied clauses in   if a satisfies all clauses in   then e      obviously  the minimum
number of unsatisfied clauses of  is the minimum value of e 
let   and   be two cnf formulas  and let e  and e  be their integer programming
transformations  it is clear that   and   are equivalent if  and only if  e   e  for every
complete assignment for   and    
    inference rules
we next define the inference rules and prove their soundness using the previous integer
programming transformation  in the rest of the section        and  denote cnf formulas 
and e    e    and e  their integer programming transformations  to prove that   and   are
equivalent  we prove that e    e   
rule    bansal   raman        if     l   l        lk   l   l        lk       then
    l        lk     is equivalent to    
proof  
e        l       l          lk     l      l          lk     e 
      l          lk     e 
  e 



general case resolution does not work in max sat  bansal   raman         rule  
establishes that resolution works when two clauses give a strictly shorter resolvent 
   

fili  manya   planes

rule   is known in the literature as replacement of almost common clauses  we pay
special attention to the case k    where the resolvent is a unit clause  and to the case k   
where the resolvent is the empty clause  we describe this latter case in the following rule 
rule    niedermeier   rossmanith        if     l  l    then        is equivalent
to    
proof   e     l  l e      e   e 



rule    which is known as complementary unit clause rule  can be used to replace two
complementary unit clauses with an empty clause  the new empty clause contributes to
the lower bounds of the search space below the current node by incrementing the number
of unsatisfied clauses  but not by incrementing the underestimation  which means that this
contradiction does not have to be redetected again  in practice  that simple rule gives rise
to considerable gains 
the following rule is a more complicated case 
rule   if     l    l   l    l        then        l   l      is equivalent to    
proof  
e       l    l  l       l    e 
         l    l   l        e 
         l   l      l      e 
          l       l      e 
  e 



rule   replaces three clauses with an empty clause  and adds a new binary clause to
keep the equivalence between   and    
pattern   was considered to compute underestimations by alsinet et al         and shen
and zhang         and is also captured by our method of computing underestimations based
on unit propagation  li et al          larrosa and heras mentioned        that existential
directional arc consistency  de givry  zytnicki  heras    larrosa        can capture this
rule  note that underestimation computation methods by alsinet et al  and shen and
zhang do not add any additional clause as in our approach  they just detect contradictions 
let us define a rule that generalizes rule   and rule    before presenting the rule  we
define a lemma needed to prove its soundness 
lemma   if     l    l   l      and     l    l   l        then   and   are equivalent 
proof  
e       l    l      l      e 
     l    l   l  l    e 
     l    l   l  l    e 
     l        l   l    e 
  e 


   

finew inference rules for max sat

rule   if     l    l  l    l  l         lk lk     lk       then        l   l    l   l         lk 
lk       is equivalent to    
proof   we prove the soundness of the rule by induction on k  when k         l    l  
l    l        by applying rule    we get     l   l        which is   when k      therefore 
  and   are equivalent 
assume that rule   is sound for k   n  let us prove that it is sound for k   n      in
that case 
     l    l   l    l   l         ln  ln     ln    ln     ln        
by applying lemma   to the last two clauses of    before     we get
 l    l   l    l   l         ln  ln     ln     ln    ln        
by applying the induction hypothesis to the first n     clauses of the previous cnf formula 
we get
    l   l    l   l         ln  ln     ln    ln        
which is   when k   n      therefore    and   are equivalent and the rule is sound 

rule   is an original inference rule  it captures linear unit resolution refutations in
which clauses and resolvents are used exactly once  the rule simply adds an empty clause 
eliminates two unit clauses and the binary clauses used in the refutation  and adds new
binary clauses that are obtained by negating the literals of the eliminated binary clauses 
so  all the operations involved can be performed efficiently 
rule   and rule   make explicit a contradiction  which does not need to be redetected in
the current subtree  so  the lower bound computation becomes more incremental  moreover 
the binary clauses added by rule   and rule   may contribute to compute better quality
lower bounds either by acting as premises of an inference rule or by being part of an
inconsistent subset of clauses  as is illustrated in the following example 
example   let   x    x   x    x    x   x    x    x   x    x   x     depending on the ordering
in which unit clauses are propagated  unit propagation detects one of the following three
inconsistent subsets of clauses   x    x   x    x    x   x      x    x    x   x     or  x    x    x  
x     once an inconsistent subset is detected and removed  the remaining set of clauses is
satisfiable  without applying rule   and rule    the lower bound computed is    because the
underestimation computed using unit propagation is   
note that rule   can be applied to the first inconsistent subset  x    x   x    x    x   x    
if rule   is applied  a contradiction is made explicit and the clauses x   x  and x   x  are
added  so   becomes     x   x    x   x    x    x   x    x   x     it turns out that      
is an inconsistent set of clauses detectable by unit propagation  therefore  the lower bound
computed is   
if the inconsistent subset  x    x    x   x    is detected  rule   can be applied  then  a
contradiction is made explicit and the clause x  x  is added  so   becomes     x  x    x  
x    x    x   x    x   x     it turns out that       is an inconsistent set of clauses detectable
by unit propagation  therefore  the lower bound computed is   
   

fili  manya   planes

similarly  if the inconsistent subset  x    x    x   x    is detected and rule   is applied 
the lower bound computed is   
we observe that  in this example  rule   and rule   not only make explicit a contradiction  but also allow to improve the lower bound 
unit propagation needs at least one unit clause to detect a contradiction  a drawback
of rule   and rule   is that they consume two unit clauses for deriving just one contradiction  a possible situation is that  after branching  those two unit clauses could allow
unit propagation to derive two disjoint inconsistent subsets of clauses  as we show in the
following example 
example   let   x    x  x    x  x    x   x  x    x    x  x    x  x    x   x  x    x   x    
rule   replaces x    x    and x   x  with an empty clause and x   x    after that  if x 
is selected as the next branching variable and is assigned    there is no unit clause in 
and no contradiction can be detected via unit propagation  the lower bound is   in this
situation  however  if rule   was not applied before branching   has two unit clauses
after branching  in this case  the propagation of x  allows to detect the inconsistent subset
 x    x   x    x   x    x   x     and the propagation of x  allows to detect the inconsistent
subset  x    x   x    x   x    x   x     so  the lower bound computed after branching is   
on the one hand  rule   and rule   add clauses that can contribute to detect additional
conflicts  on the other hand  each application of rule   and rule   consumes two unit
clauses  which cannot be used again to detect further conflicts  the final effect of these two
factors will be empirically analyzed in section   
finally  we present two new rules that capture unit resolution refutations in which
 i  exactly one unit clause is consumed  and  ii  the unit clause is used twice in the linear
derivation of the empty clause 
rule   if     l    l   l    l   l    l   l        then        l   l   l    l   l   l      is
equivalent to    
proof  
e       l    l      l      l      l      l  l    e 
     l    l   l  l    l   l  l    l  l    e 
      l  l   l  l  l    l   l  l   l  l    l  l  l    e 
          l   l  l    l      l   l    l  l      e 
          l   l  l    l      l       l      e 
  e 



we can combine a linear derivation with rule   to obtain rule   
rule   if     l    l   l    l   l         lk  lk     lk    lk     lk    lk     lk    lk        
then        l   l    l   l         lk  lk     lk    lk    lk     lk    lk    lk       is
equivalent to    
   

finew inference rules for max sat

proof   we prove the soundness of the rule by induction on k  when k   
     l    l   l    l   l    l   l    l   l       
by lemma    we get
by rule    we get

 l   l    l    l   l    l   l    l   l       
 l   l       l   l   l    l   l   l       

which is   when k      therefore    and   are equivalent 
assume that rule   is sound for k   n  let us prove that it is sound for k   n      in
that case 
     l    l   l    l   l         ln    ln     ln    ln     ln    ln     ln    ln        
by lemma    we get
 l   l    l    l   l         ln    ln     ln    ln     ln    ln     ln    ln        
by applying the induction hypothesis  we get
 l   l       l   l         ln    ln     ln    ln    ln     ln    ln    ln        
which is   when k   n      therefore    and   are equivalent and the rule is sound 

similarly to rule   and rule    rule   and rule   make explicit a contradiction  which
does not need to be redetected in subsequent search  therefore  the lower bound computation becomes more incremental  moreover  they also add clauses which can improve the
quality of the lower bound  as illustrated in the following example 
example   let   x    x   x    x   x    x   x    x    x   x    x   x    x   x     depending
on the ordering in which unit clauses are propagated  unit propagation can detect one of the
following inconsistent subsets   x    x   x    x   x    x   x      x    x   x    x   x    x   x    
 x    x   x    x   x    x  x     in which rule   is applicable  if rule   is not applied  the lower
bound computed using the underestimation function of figure   is    since the remaining
clauses of  are satisfiable once the inconsistent subset of clauses is removed  rule   allows
to add two ternary clauses contributing to another contradiction  for example  rule  
applied to  x    x   x    x   x    x   x    adds to  clauses x   x   x  and x   x   x   
which  with the remaining clauses of    x    x   x    x   x    x   x      give the second
contradiction detectable via unit propagation  so the lower bound computed using rule  
is   
in contrast to rule   and rule    rule   and rule   consume exactly one unit clause for
deriving an empty clause  since a unit clause can be used at most once to derive a conflict
via unit propagation  rule   and rule   do not limit the detection of further conflicts via
unit propagation 
   

fili  manya   planes

   implementation of inference rules
in this section  we describe the implementation of all the inference rules presented in section    we suppose that the cnf formula is loaded and  for every literal   a list of clauses
containing  is constructed  the application of a rule means that some clauses in   are
removed from the cnf formula  new clauses in   are inserted into the formula  and the
lower bound is increased by    note that in all the inference rules selected in our approach 
  contains fewer literals and fewer clauses than     so that new clauses of   can be inserted
in the place of the removed clauses of   when an inference rule is applied  therefore  we
do not need dynamic memory management and the implementation can be faster 
rule   for k   and rule   can be applied using a matching algorithm  see  e g   cormen 
leiserson  rivest    stein        for an efficient implementation  over the lists of clauses 
the first has a time complexity of o m   where m is the number of clauses in the cnf
formula  the second has a time complexity of o u   where u is the number of unit clauses
in the cnf formula  these rules are applied at every node  before any lower bound computation or application of other inference rules  rule    k    is applied as many times as
possible to derive unit clauses before applying rule   
the implementation of rule    rule    rule    and rule   is entirely based on unit
propagation  given a cnf formula   unit propagation constructs an implication graph
g  see  e g   beame  kautz    sabharwal         from which the applicability of inference
rules is detected  in this section  we first describe the construction of the implication graph 
and then describe how to determine the applicability of rule    rule    rule    and rule   
then  we analyze the complexity  termination and  in completeness of the application of
the rules  finally we discuss the extension of the inference rules to weighted max sat and
their implementation 
    implication graph
given a cnf formula   figure   shows how unit propagation constructs an implication
graph whose nodes are literals 
note that every node in g corresponds to a different literal  where  and  are considered
as different literals  when the cnf formula contains several copies of a unit clause   the
algorithm adds just one node with label  
example   let   x    x    x  x    x  x    x  x  x    x    x  x    x  x    x  x  x    x  x    
u nitp ropagation constructs the implication graph of figure    in which we add a special
node   to highlight the contradiction 
g is always acyclic because every added edge connects a new node  it is well known
that the time complexity of unit propagation is o      where    is the size of   see  e g  
freeman        
we associate clause c        k  k with node k if node k is added into g because
of c  note that node k does not have any incoming edge if and only if c is unit  k     and
the node has only one incoming edge if and only if c is binary  k     once g is constructed 
if g contains both  and  for some literal   i e   unit propagation deduces a contradiction  
it is easy to identify all nodes from which there exists a path to  or  in g  i e   the clauses
   

finew inference rules for max sat

input  u nitp ropagation      is a cnf formula not containing the complementary unit
clauses  and  for any literal 
initialize g as the empty graph
add a node labeled with  for every literal  in a unit clause c of 
repeat
if              k  are nodes of g  c              k   k is a clause of   and k is
not a node of g  then
add into g a node labeled with k
add into g a directed edge from node i to k for every i     i   k 
end if
until no more nodes can be added or there is a literal  such that both  and  are nodes
of g
return g
output  implication graph g of 
figure    unit propagation for constructing implication graphs

x 
x 

x 
x 
x 
x 

x 
x 
x 

figure    example of implication graph

   

fili  manya   planes

x 
c 
x 
c 

x 
c 
x 
c 

x 
c 
x 
c 

x 
c 

figure    example of implication graph
implying  or   all these clauses constitute an inconsistent subset s of   in the above
example  clauses x    x   x    x   x  and x   x   x  imply x    and clauses x    x   x    x   x 
and x   x   x  imply x    clause x   x  does not contribute to the contradiction  the
inconsistent subset s is  x    x   x    x   x    x   x   x    x    x   x    x   x    x   x   x    
    applicability of rule    rule    rule    and rule  
we assume that unit propagation deduces a contradiction and  therefore  the implication
graph g contains both  and  for some literal   let s be the set of all nodes from which
there exists a path to   let s be the set of all nodes from which there exists a path to
  and let s s  s   as a clause is associated with each node in g  we also use s  s  
and s to denote the set of clauses associated with the nodes in s  s   and s   respectively 
lemma   and lemma   are used to detect the applicability of rule    rule    rule    and
rule   
lemma   rule   and rule   are applicable if
   in s  resp  s    there is one unit clause and all the other clauses are binary 
   nodes in s  resp  s   form an implication chain starting at the unit clause and ending
at   resp    
   s  s is empty 
proof   starting from the node corresponding to the unit clause in s  resp  s    and
following in parallel the two implication chains  we have   in rule   or rule   by writing
down the clause corresponding to each node  
example   let  be the following cnf formula containing clauses c  to c     c    x    c   
x   x    c    x   x    c    x   x    c    x    c    x   x    c    x   x     unit propagation constructs the implication graph shown in figure    which contains the complementary
literals x  and x   
rule   is applicable because  x    s   x   c     x   c     x   c     x   c      and
s   x   c     x   c     x   c      it is easy to verify that the three conditions of lemma   are
satisfied 
remark   can be rewritten as  c    x    c    x   x    c    x   x    c    x   x    c   
x   x    c    x   x    c    x    to be compared with   in rule   
   

finew inference rules for max sat

x 
c 

x 
c 

x 
c 
x 
c 

x 
c 

figure    example of implication graph
the application of rule   and rule   consists of replacing every binary clause c in s
with a binary clause obtained by negating every literal of c  removing the two unit clauses
of s from   and incrementing  emptyclauses   by   
lemma   rule   and rule   are applicable if
   in s s  s   there is one unit clause and all the other clauses are binary  i e   all
nodes in s  except for the node corresponding to the unit clause  have exactly one
incoming edge in g 
   s  s is non empty and contains k  k     nodes forming an implication chain of
the form           k   where k is the last node of the chain 
    s  s    s  s   contains exactly three nodes       and a third one  let k   be
the third literal 
if k    s   then g contains the following implications
k  k    
k  
if k    s   then g contains the following implications
k  
k  k    
proof   assume  without loss of generality  that k    s   the case k    s is symmetric  the implication chain formed by the nodes of s  s corresponds to the clauses     
               k   k    which  together with the three clauses  k  k     k      k   
corresponding to k  k     and k    give   in rule   or rule    
example   let  be the following cnf formula containing clauses c  to c     c    x    c   
x  x    c    x  x    c    x  x    c    x   x     unit propagation constructs the implication
graph shown in figure    which contains the complementary literals x  and x   
we have sx    x   c     x   c     x   c     and sx    x   c     x   c     x   c     x   c      the
nodes in sx   sx  obviously form an implication chain  x   x     sx   sx     sx  
sx     x   c     x   c     x   c      g contains x   x   x  and x   x    rule   is applicable 
the application of rule   and rule   consists of removing the unit clause of s  s
from   replacing each binary clause c in s  s with a binary clause obtained from c by
negating the two literals of c  replacing the three binary clauses in  s  s    s  s   with
two ternary clauses  and incrementing  emptyclauses   by   
   

fili  manya   planes

    complexity  termination  and  in completeness of rule applications
in our branch and bound algorithm for max sat  we combine the application of the inference rules and the computation of the underestimation of the lower bound  given a cnf
formula   function underestimation uses unit propagation to construct an implication
graph g  once g contains two nodes  and  for some literal   g is analyzed to determine
whether some inference rule is applicable  if some rule is applicable  it is applied and  is
transformed into an equivalent max sat instance  otherwise  all clauses contributing to
the contradiction are removed from   and the underestimation is incremented by    this
procedure is repeated until unit propagation cannot derive more contradictions  finally  all
removed clauses  except those removed or replaced due to inference rule applications  are
reinserted into   the underestimation  together with the new   is returned 
it is well known that unit propagation can be implemented with a time complexity linear
in the size of   see  e g   freeman         the complexity of determining the applicability
of the inference rules using lemma   and lemma   is linear in the size of g  bounded by
the number of literals in   if we assume that the graph is represented by doubly linked
lists  the application of an inference rule is obviously linear in the size of g  so  the whole
time complexity of function underestimation with inference rule applications is o d      
where d is the number of contradictions that function underestimation is able to detect
using unit propagation  observe that the factor d is needed because the application of the
rules inserts new clauses in the place of the removed clauses 
since every inference rule application reduces the size of   function underestimation
with inference rule applications has linear space complexity  and it always terminates  recall
that new clauses added by the inference rules can be stored in the place of the old ones 
the data structures for loading  can be statically and efficiently maintained 
we have proved that the inference rules are sound  the following example shows that
the application of the rules is not necessarily complete in our implementation  in the sense
that not all possible applications of the inference rules are necessarily done 
example   let   x    x    x    x   x   x    x   x    x     unit propagation may discover
the inconsistent subset s  x    x    x    x   x   x     in this case  no inference rule is applicable to s  then  the underestimation of the lower bound is incremented by    and 
becomes  x   x    x     unit propagation cannot detect more contradictions in   and function underestimation stops after reinserting  x    x    x    x   x   x    into   the value
  is returned  together with the unchanged   note that rule   is applicable to the subset
 x    x   x    x    of   but is not applied 
actually  function underestimation only applies rule   if unit propagation detects the
inconsistent subset  x    x   x    x    instead of  x    x    x    x   x   x     the detection of
an inconsistent subset depends on the ordering in which unit clauses are propagated in unit
propagation  in this example  the inconsistent subset  x    x   x    x    is discovered if unit
clause x  is propagated before x  and x    further study is needed to define orderings for
unit clauses that maximize the application of inference rules 
observe that our algorithm is deterministic  and always computes the same lower bound
if the order of clauses is not changed 
   

finew inference rules for max sat

    inference rules for weighted max sat
the inference rules presented in this paper can be naturally extended to weighted max sat 
in weighted max sat  every clause is associated with a weight and the problem consists
of finding a truth assignment for which the sum of the weights of unsatisfied clauses is
minimum  for example  the weighted version of rule   could be
rule   if      l    w      l   l    w      l    w         then         w    l   l    w    l    w  
w    l   l    w   w    l    w   w     is equivalent to  
where w    w  and w  are positive integers representing the clause weight  and w min w   
w    w     mandatory clauses  that have to be satisfied in any optimal solution  are specified
with the weight   note that if w     w  and if w   no optimal solution can be
found and the solver should backtrack  clauses with weight   are removed  observe that  
can be rewritten as          where       l    w    l   l    w    l    w    and       l    w  
w    l   l    w   w    l    w   w       then  the weighted inference rule is equivalent to
the unweighted version applied w times to the  unweighted  clauses of     
similarly  the weighted version of rule   could be
rule   if      l    w     l   l    w      l   l    w              lk  lk     wk       lk     wk         
then         w    l   l    w    l   l    w            lk  lk     w    l    w   w    l   l    w  
w    l   l    w   w            lk  lk     wk    w    lk     wk    w     is equivalent to  
where w min w    w            wk      observe that   can also be rewritten as          with
      l    w   l   l    w    l   l    w            lk  lk     w    lk     w    the weighted version of
rule   is equivalent to the unweighted rule   applied w times to the  unweighted  clauses
of     
the current implementation of the inference rules can be naturally extended to weighted
inference rules  if an inconsistent subformula is detected and a rule is applicable  clause
weights are not considered in the detection of the inconsistent subformula and of the applicability of the rule  provided that clauses with weight   have been discarded   then   
and    are separated after computing the minimal weight w of all clauses in the detected
inconsistent subformula  and the rule is applied to      the derived clauses and clauses in
   can be used in subsequent reasoning 

   maxsatz  a new max sat solver
we have implemented a new max sat solver  called maxsatz  that incorporates the lower
bound computation method based on unit propagation defined in section    and applies the
inference rules defined in section    the name of maxsatz comes from the fact that the
implementation of our algorithm incorporates most of the technology that was developed
for the sat solver satz  li   anbulagan      b      a  
maxsatz incorporates the lower bound based on unit propagation  and applies rule   
rule    rule    rule    rule    and rule    in addition  maxsatz applies the following
techniques 
 pure literal rule  if a literal only appears with either positive polarity or negative
polarity  we delete the clauses containing that literal 
   

fili  manya   planes

 empty unit clause rule  alsinet et al       a   let neg  x   pos  x   be the number of
unit clauses in which x is negative  positive   if  emptyclauses     neg  x   u b 
then we assign x to false  if  emptyclauses     pos  x   u b  then we assign x
to true 
 dominating unit clause  duc  rule  niedermeier   rossmanith         if the number of clauses in which a literal x  x  appears is not greater than neg  x   pos  x   
then we assign x to false  true  
 variable selection heuristic  let neg  x   pos  x   be the number of binary clauses
in which x is negative  positive   and let neg  x   pos  x   be the number of clauses
containing three or more literals in which x is negative  positive   we select the
variable x such that  neg  x   neg  x  neg  x    pos  x   pos  x  pos  x  
is the largest  the fact that binary clauses are counted four times more than other
clauses was determined empirically 
 value selection heuristic  let x be the selected branching variable  if neg  x      
neg  x    neg  x    pos  x       pos  x    pos  x   set x to true  otherwise set x
to false  this heuristics was also determined empirically 
in this paper  in order to compare the inference rules defined  we have used three simplified versions of maxsatz 
 maxsat   does not apply any inference rule defined in section   
 maxsat    applies rules   and    but not rules         and   
 maxsat      applies rules         and    but not rules   and   
actually  maxsatz corresponds to maxsat       in our terminology  maxsat   corresponds to an improved version of the solver u p  li et al          using a special ordering
for propagating unit clauses in unit propagation  maxsat   maintains two queues during
unit propagation  q  and q    when maxsat   starts the search for an inconsistent subformula via unit propagation  q  contains all the unit clauses of the cnf formula under
consideration  more recently derived unit clauses are at the end of q     and q  is empty 
the unit clauses derived during the application of unit propagation are stored in q    and
unit propagation does not use any unit clause from q  unless q  is empty  intuitively  this
ordering prefers unit clauses which were non unit clauses before starting the application of
unit propagation  this way  the derived inconsistent subset contains  in general  less unit
clauses  the unit clauses which have not been consumed will contribute to detect further
inconsistent subsets  our experimental results  li  manya    planes        show that the
search tree size of maxsat   is substantially smaller than that of up  and maxsat   is
substantially faster than up  maxsat   maxsat      and maxsatz use the same ordering
as maxsat   for propagating unit clauses in unit propagation 
the source code of maxsat   maxsat    maxsat      and maxsatz can be found at
http   web udl es usuaris m        jair maxsatz solvers zip  and at http   www laria upicardie fr cli maxsatz tar gz 
   

finew inference rules for max sat

   experimental results
we report on the experimental investigation performed for unweighted max sat in order
to evaluate the inference rules defined in section    and to compare maxsatz with the
best performing state of the art solvers that were publicly available when this paper was
submitted  the experiments were performed on a linux cluster with processors   ghz
amd opteron with   gb of ram 
the structure of this section is as follows  we first describe the solvers and benchmarks
that we have considered  then  we present the experimental evaluation of the inference
rules  finally  we show the experimental comparison of maxsatz with other solvers 
    solvers and benchmarks
maxsatz was compared with the following max sat solvers 
 bf   borchers   furman         a branch and bound max sat solver which uses
moms as dynamic variable selection heuristic and does not consider underestimations
in the computation of the lower bound  it was developed by borchers and furman in
     
 agn   alber et al          a branch and bound max  sat solver  it was developed
by alber  gramm and niedermeier in      
 amp   alsinet et al       b   a branch and bound max sat solver based on bf that
incorporates a lower bound of better quality and the jeroslow wang variable selection
heuristic  jeroslow   wang         it was developed by alsinet  manya and planes
and presented at sat      
 toolbar   de givry et al         larrosa   heras         a max sat solver whose
inference was inspired in soft arc consistency properties implemented in weighted csp
solvers  it was developed by de givry  larrosa  meseguer and schiex and was first
presented at cp       we used version     with default parameters 
 maxsolver   xing   zhang         a branch and bound max sat solver that applies a
number of efficient inference rules  it was developed by xing and zhang and presented
at cp       we used the second release of this solver 
 lazy   alsinet et al          a branch and bound max sat solver with lazy data
structures and a static variable selection heuristic  it was developed by alsinet  manya
and planes and presented at sat      
  
  
  
  
  
  

downloaded in october      from http   infohost nmt edu borchers satcodes tar gz
downloaded in october      from http   www fs informatik uni tuebingen de gramm 
available at http   web udl es usuaris m        software html
downloaded in october      from http   carlit toulouse inra fr cgi bin awki cgi toolbarintro
downloaded in october      from http   cic cs wustl edu maxsolver 
available at http   web udl es usuaris m        software html

   

fili  manya   planes

 up   li et al          a branch and bound max sat solver with the lower bound
computation method based on unit propagation  cf  section     it was developed by
li  manya and planes and presented at cp      
we used as benchmarks randomly generated max  sat instances and max  sat instances  graph   coloring instances    as well as max cut instances     we also considered the
unweighted max sat benchmarks submitted to the max sat evaluation       including
max cut  max ones  ramsey numbers  and random max  sat and max  sat instances 
we generated max  sat instances and max  sat instances using the generator mwff c
developed by bart selman  which allows for duplicated clauses  for max cut  we first
generated a random graph of m edges in which every edge is randomly selected among
the set of all possible edges  if the graph is not connected  it is discarded  if the graph
is connected  we used the encoding of shen and zhang        to encode the max cut
instance into a cnf  we created  for each edge  xi   xj    exactly two binary clauses  xi  xj  
and  xi  xj    if  is the collection of such binary clauses  then the max cut instance has
a cut of weight k iff the max sat instance has an assignment under which m   k clauses
are satisfied 
for graph   coloring  we first used culbersons generator to generate a random kcolorable graph of type iid  independent random edge assignment  variability    with
k vertices and a fixed edge density  we then used culbersons converter to sat with standard conversion and three colors to generate a max sat instance  for each vertex xi and
for each color j             a propositional variable xij is defined meaning that vertex i is
colored with color j  for each vertex xi   four clauses are added to encode that the vertex
is colored with exactly one color  xi   xi   xi    xi   xi    xi   xi    and xi   xi    and  for
each edge  xi   xj    three clauses are added to encode that vertex xi and vertex xj do not
have the same color  xi   xj    xi   xj    and xi   xj   
in random max  sat and max  sat instances  clauses are entirely independent to each
other and do not have structure  in the graph   coloring instances and max cut instances
used in this paper  clauses are not independent and have structure  for example  in a
max cut instance  every time we have a clause xi  xj   we also have the clause xi  xj  
the satisfaction of these two clauses means that the corresponding edge is in the cut  in a
graph   coloring instance  every time we have a ternary clause xi   xi   xi  encoding that
vertex i is colored with at least a color  we also have three binary clauses xi   xi    xi   xi   
and xi   xi  encoding that vertex i cannot be colored with two or more colors  maxcut instances only contain binary clauses  but graph   coloring instances contain a ternary
clause for every vertex in the graph  while we can derive an optimal cut from an optimal
assignment of a max sat encoding of any max cut instance  an optimal assignment of a
max sat encoding of a   coloring instance may assign more than one color to some vertices 
   available at http   web udl es usuaris m        software html
   given an undirected graph g    v  e   where v    x            xn   is the set of vertices and e is the set
of edges  and a set of three colors  the graph   coloring problem is the problem of coloring every vertex
with one of the three colors in such a way that  for each edge  xi   xj    e  vertex xi and vertex xj do
not have the same color 
    given an undirected graph g    v  e   let wxi  xj be the weight associated with each edge  xi   xj    e 
p
the weighted max cut problem is to find a subset s of v such that w  s  s    xi s xj s wxi  xj is
maximized  where s   v  s  in this paper  we set weight wxi  xj     for all edges 

   

finew inference rules for max sat

the max cut and ramsey numbers instances from the max sat evaluation      contain different structures  for example  the underlying graphs in the max cut instances
have different origins such as fault diagnosis problems  coding theory problems  and graph
clique problems  max  sat and max  sat instances from the evaluation do not contain
duplicated clauses 
we computed an initial upper bound with a local search solver for each instance  we
did not provide any parameter to any solver except the instance to be solved and the initial
upper bound  in other words  we used the default values for all the parameters  the
instances from the max sat evaluation      were solved in the same conditions as in the
evaluation  i e   no initial upper bound was provided to the solvers  and the maximum time
allowed to solve an instance was    minutes 
    evaluation of the inference rules
in the first experiment performed to evaluate the impact of the inference rules of section   
we solved sets of     random max  sat instances with    and     variables  the number
of clauses ranged from     to      for    variables  and from     to      for     variables 
the results obtained are shown in figure    along the horizontal axis is the number of
clauses  and along the vertical axis is the mean time  left plot   in seconds  needed to solve
an instance of a set  and the mean number of branches of the proof tree  right plot   notice
that we use a log scale to represent both run time and branches 
we observe that the rules are very powerful for max  sat and the gain increases as
the number of variables and the number of clauses increase  for    variables and     
clauses  the clause to variable ratio is      maxsatz is     times faster than maxsat     
and for     variables and      clauses  the clause to variable ratio is      maxsatz is    
times faster than maxsat      the search tree of maxsatz is also substantially smaller
than that of maxsat      rule   and rule   are more powerful than rule   and rule   for
max  sat  the intuitive explanation is that maxsatz and maxsat     detect many more
inconsistent subsets of clauses containing one unit clause than subsets containing two unit
clauses  so that rule   and rule   can be applied many more times than rule   and rule  
in maxsatz 
recall that  on the one hand  every application of rule   and rule   consumes two
unit clauses but only produces one empty clause  limiting unit propagation in detecting
more conflicts in subsequent search  on the other hand  rule   and rule   add clauses
which may contribute to detect further conflicts  depending on the number of clauses  or
more precisely  the clause to variable ratio  in a formula  these two factors have different
importance  when there are relatively few clauses  unit propagation relatively does not
easily derive a contradiction from a unit clause  and the binary clauses added by rule   and
rule   are relatively important for deriving additional conflicts and improving the lower
bound  which explains why the search tree of maxsat     is smaller than the search tree
of maxsat   for instances with     variables and less than     clauses  on the contrary 
when there are many clauses  unit propagation easily derives a contradiction from a unit
clause  so that the two unit clauses consumed by rule   and rule   would probably allow to
derive two disjoint inconsistent subsets of clauses  in addition  the binary clauses added by
rule   and rule   are relatively less important for deriving additional conflicts  considering
   

fili  manya   planes

the large number of clauses in the formula  in this case  the search tree of maxsat    
is larger than the search tree of maxsat    however  in both cases  maxsat     is faster
that maxsat    meaning that the incremental lower bound computation due to rule   and
rule   is very effective  since the redetection of many conflicts is avoided thanks to rule  
and rule   

max  sat      variables
 e   

    

 e   

branches  log scale 

time  logscale 

max  sat      variables
     

   
  
 
maxsat 
maxsat  
maxsat    
maxsatz

   
    
    

    

    

      
     
maxsat 
maxsat  
maxsat    
maxsatz

    
   

    

    

    

number of clauses

    

 e   

   
  
 

    
   

maxsat 
maxsat  
maxsat    
maxsatz
   

   
   
   
number of clauses

    

max  sat       variables
 e   
branches  log scale 

time  logscale 

max  sat       variables
     

   

    

number of clauses

   

 e   
      
     
maxsat 
maxsat  
maxsat    
maxsatz

    
   
   

    

   

   
   
   
number of clauses

   

    

figure    comparison among maxsat    maxsat     and maxsatz on random max  sat instances 

rule   and rule   do not limit unit propagation in detecting more conflicts  since their
application produces one empty clause and consumes just one unit clause  which allows to
derive at most one conflict in any case  the added ternary clauses allow to improve the
lower bound  so that the search tree of maxsatz is substantially smaller than the search
tree of maxsat      the incremental lower bound computation due to rule   and rule  
also contributes to the time performance of maxsatz  for example  while the search tree of
maxsatz for instances with    variables and      clauses is about      times smaller than
the search tree of maxsat      maxsatz is    times faster than maxsat     
in the second experiment  we solved random max  sat instances instead of random
max  sat instances  we solved instances with    and    variables  the number of clauses
ranged from     to      for    variables  and from     to      for    variables  the results
obtained are shown in figure   
   

finew inference rules for max sat

max  sat      variables

max  sat      variables
 e   
branches  log scale 

time  log scale 

    

   

  
maxsat 
maxsat  
maxsat    
maxsatz

 

   
   

   

   
    
number of clauses

 e   

      

    
   

    

max  sat      variables

   
   
    
number of clauses

    

max  sat      variables
 e   
branches  log scale 

     

time  logscale 

maxsat 
maxsat  
maxsat    
maxsatz

     

    

   
maxsat 
maxsat  
maxsat    
maxsatz

  

 
   

   

   
   
number of clauses

   

    

 e   

 e   
maxsat 
maxsat  
maxsat    
maxsatz

      

     
   

   

   
   
number of clauses

   

    

figure    comparison among maxsat    maxsat     and maxsatz on random max  sat instances 

although the rules do not involve ternary clauses  they are also powerful for max  sat 
similarly to max  sat  rule   and rule   slightly improve the lower bound when there
are relatively few clauses  but do not improve the lower bound when the number of clauses
increases  they improve the time performance thanks to the incremental lower bound
computation they allowed  the gain increases as the number of clauses increases  for
example  for problems with    variables  when the number of clauses is      maxsat    
is     faster than maxsat   and  when the number of clauses is       the gain is     
rule   and rule   improve both the lower bound and the time performance of maxsatz 
the gain increases as the number of clauses increases 
in the third experiment we considered the max cut problem for graphs with    vertices
and a number of edges ranging from     to      figure   shows the results of comparing
the inference rules on max cut instances  we observe that the rules allow us to solve
the instances much faster  similarly to random max  sat  rule   and rule   do not
improve the lower bound when there are many clauses  but improve the time performance
due to the incremental lower bound computation they allowed  rule   and rule   are more
powerful than rule   and rule   for these instances  which only contain binary clauses but
have some structure  in addition  the reduction of the tree size due to rule   and rule  
contributes to the time performance of maxsatz more than the incrementality of the lower
bound computation  as for random max  sat  for example  the search tree of maxsatz
for instances with     edges is    times smaller than the search tree of maxsat      and
maxsatz is    times faster 
   

fili  manya   planes

max cut      nodes
 e   

     

 e   
branches  log scale 

time  log scale 

max cut      nodes
      

    
   
  
 

maxsat 
maxsat  
maxsat    
maxsatz

   
    
   

   

   
   
   
number of edges

 e   
 e   
      
     

maxsat 
maxsat  
maxsat    
maxsatz

    
   

   
   

   

   

   
   
   
number of edges

   

   

figure    experimental results for max cut

in the fourth experiment we considered graph   coloring instances with    and    vertices  and with density of edges ranging from     to      figure    shows the results of
comparing the inference rules on graph   coloring instances  we observe that rule   and
rule   are not useful for these instances  the tree size of maxsat  and maxsat   is almost
the same  and maxsat   is slower than maxsat   on the contrary  other rules are very
useful for these instances  especially because they allow to reduce the search tree size by
deriving better lower bounds 

graph   coloring    nodes

graph   coloring    nodes
     
branches  log scale 

time  log scale 

   

    

     
maxsat 
maxsat  
maxsat    
maxsatz

 e   
  

  

  

  
  
  of edges

  

    

   
maxsat 
maxsat  
maxsat    
maxsatz

  
  

  

  

  

graph   coloring    nodes

  
  
  of edges

  

  

  

  

  

graph   coloring    nodes
 e   
branches  log scale 

     

time  log scale 

  

    

   
maxsat 
maxsat  
maxsat    
maxsatz

  

 
  

  

  

  
  
  of edges

  

 e   

 e   
maxsat 
maxsat  
maxsat    
maxsatz

      
  

  

  

  

  

  
  
  of edges

figure     experimental results for graph   coloring
   

  

finew inference rules for max sat

note that rule   and rule   have more impact than rule   and rule   on reducing
the cost of solving the instances  this is probably due to the fact that two unit clauses are
needed to detect a contradiction  so that rule   and rule   are applied many more times 
also note that the instances with    vertices become easier to solve when the density of the
graph is high 
in the fifth experiment  we compared different inference rules on the benchmarks submitted to the max sat evaluation       solvers ran in the same conditions as in the
evaluation  in table    the first column is the name of the benchmark set  the second
column is the number of instances in the set  and the rest of columns display the average
time  in seconds  needed by each solver to solve an instance  the number of solved instances
in brackets   the maximum time allowed to solve an instance was    minutes 
in is clear that maxsat   is better than maxsat   maxsat     is better than maxsat   
and maxsatz is better than maxsat      for example  maxsatz solves three maxcut
johnson instances within the time limit  while the other solvers only solve two instances 
the average time for maxsatz to solve one of these three instances is       seconds  the
third instance needing more time to be solved than the other two instances 
set name
maxcut brock
maxcut c fat
maxcut hamming
maxcut johnson
maxcut keller
maxcut p hat
maxcut san
maxcut sanr
maxcut max cut
maxcut spinglass
maxone
ramsey
max sat    vars
max sat    vars
max sat   vars
max sat discarded
max sat   vars
max sat   vars

 instances
  
 
 
 
 
  
  
 
  
 
  
  
  
  
  
   
  
  

maxsat 
          
        
        
        
         
        
         
         
          
        
         
         
         
          
         
           
         
          

maxsat  
          
        
        
        
         
          
         
         
          
        
         
         
         
         
         
          
         
         

maxsat    
          
        
        
        
         
          
         
         
          
        
         
         
         
         
         
          
         
         

maxsatz
         
       
         
        
       
         
          
        
        
       
        
        
        
        
        
          
        
         

table    evaluation of the rules with benchmarks from the max sat evaluation      
    comparison of maxsatz with other solvers
in the first experiment  that we performed to compare maxsatz with other state of the art
max sat solvers  we solved sets of     random max  sat instances with         and    
variables  the number of clauses ranged from     to      for    variables  from     to
     for     variables  and from     to     for     variables  the results of solving such
instances with bf  agn  amp  lazy  toolbar  maxsolver  up and maxsatz are shown in
figure     along the horizontal axis is the number of clauses  and along the vertical axis is
the mean time  in seconds  needed to solve an instance of a set  when a solver needed too
much time to solve the instances at a point  it was stopped and the corresponding point is
not shown in the figure  that is why for    variable instances  bf has only one point in
the figure  for     clauses   and for     variable instances  bf and amp also have only one
   

fili  manya   planes

point in the figure  for     clauses   the version of maxsolver we used limits the number
of clauses to      in the instances to be solved  we ran it for instances up to      clauses 
we see dramatic differences on performance between maxsatz and the rest of solvers
in figure     for the hardest instances  maxsatz is up to two orders of magnitude faster
than the second best performing solvers  up   for those instances  maxsatz needs   second
to solve an instance while solvers like maxsolver and toolbar are not able to solve these
instances after        seconds 
in the second experiment  we solved random max  sat instances instead of random
max  sat instances  the results obtained are shown in figure     we did not consider
agn because it can only solve max  sat instances  we solved instances with        and
    variables  the number of clauses ranged from     to      for    variables  from    
to      for    variables  and from     to     for     variables  for    variables  amp
has only one point in the figure  for     clauses  and bf is too slow  for     variables 
we compared only the two best solvers  once again  we observe dramatic differences on
the performance profile of maxsatz and the rest of solvers  particularly remarkable are
the differences between maxsatz and toolbar  the second best performing solver on max sat   where we see that maxsatz is up to       times faster than toolbar on the hardest
instances 
in the third experiment  we considered the max cut problem of graphs with    vertices
and a number of edges ranging from     to      figure    shows the results obtained  bf
has only one point in the figure  for     edges   maxsolver solved instances up to     edges
      clauses   we observe that maxsatz is superior to the rest of solvers 
in the fourth experiment  we considered the   coloring problem of graphs with    and
   vertices  and a density of edges ranging from     to      agn was not considered
because it can only solve max  sat instances  for    vertices  we only compared the three
best solvers  of which maxsolver is a different version not limiting the number of clauses
of the instance to be solved  figure    shows the comparative results for different solvers 
maxsatz is the best performing solver  and up and maxsolver are substantially better than
the rest of solvers 

max cut      nodes
     

time  log scale 

    
   
bf
amp
agn
lazy
toolbar
maxsolver
up
maxsatz

  
 
   

    
                       
number of edges

figure     experimental results for max cut
   

finew inference rules for max sat

max  sat      variables
     

time  log scale 

    
   
  

bf
amp
agn
lazy
toolbar
maxsolver
up
maxsatz

 
   
    
     
                   
number of clauses
max  sat       variables
      

time  log scale 

     
    
   

bf
amp
agn
lazy
toolbar
maxsolver
up
maxsatz

  
 
   

    
                            
number of clauses
max  sat       variables
      
     
time  log scale 

    
   
  

bf
amp
agn
lazy
toolbar
maxsolver
up
maxsatz

 
   
    
     
 e   
   

   
   
   
number of clauses

figure     experimental results for    variable      variable and     variable random max sat instances 

   

fili  manya   planes

max  sat      variables
     

time  log scale 

    
   
bf
amp
lazy
toolbar
maxsolver
up
maxsatz

  
 
   
   
   
    
number of clauses

    

max  sat      variables

time  log scale 

     

    

   
amp
lazy
toolbar
maxsolver
up
maxsatz

  

 
                        
number of clauses
max  sat       variables
      

time  log scale 

     
    
   
  
 
   

toolbar
maxsatz

    
   
   
   
number of clauses

   

figure     experimental results for    variable     variable and     variable random max sat instances 

   

finew inference rules for max sat

graph   coloring    nodes
     

time  log scale 

    
   
  
 

bf
amp
lazy
maxsolver
toolbar
up
maxsatz

   
    
     
 e   

                       
  of edges
graph   coloring    nodes
      

time  log scale 

     
    
   
  

maxsolver
up
maxsatz

 

                       
  of edges

figure     experimental results for graph   coloring

in the fifth experiment  we compared the max sat solvers on the benchmarks submitted
to the max sat evaluation       solvers ran in the same conditions as in the evaluation 
in table    the first column is the name of the benchmark set  the second column is the
number of instances of the set  and the rest of columns display the average time  in seconds 
needed by each solver to solve an instance within a time limit of    minutes  the number of
instances solved within the time limit in brackets   a dash means that the corresponding
solver cannot solve the set of instances  it is clear that maxsatz is the best performing
solver for all the sets 

   related work
the simplest method to compute a lower bound consists of just counting the number of
clauses unsatisfied by the current partial assignment  borchers   furman         one step
forward is to incorporate an underestimation of the number of clauses that will become
unsatisfied if the current partial assignment is extended to a complete assignment  the
most basic method was defined by wallace and freuder        
   

fi instances
  
 
 
 
 
  
  
 
  
 
  
  
  
  
  
   
  
  

bf
   
        
   
   
   
         
   
   
   
        
         
         
         
         
        
          
          
         

amp
         
        
         
         
         
         
         
         
   
        
         
         
          
         
          
          
          
          

agn
         
        
         
        
        
        
        
         
          
        
          
          
         
          
 

toolbar
          
        
         
        
         
          
         
         
          
        
         
        
          
          
         
           
          
          

lazy
           
         
          
         
          
           
          
          
           
        
           
          
           
           
          
          
          
           

maxsolver
         
        
   
        
   
        
         
         
   
         
         
         
          
          
         
          
         
          

up
         
        
         
        
         
         
         
         
          
        
         
         
          
         
         
           
         
          

table    experimental results for benchmarks from the max sat evaluation      

maxsatz
         
       
         
        
        
         
          
        
        
       
         
         
         
         
         
          
        
         

   

li  manya   planes

set name
maxcut brock
maxcut c fat
maxcut hamming
maxcut johnson
maxcut keller
maxcut dimacs p hat
maxcut san
maxcut sanr
maxcut max cut
maxcut spinglass
maxone
ramsey ram k
max sat    vars
max sat    vars
max sat   vars
max sat discarded
max sat   vars
max sat   vars

finew inference rules for max sat

lb      emptyclauses    
x

x

occurs in

min ic x   ic x  


where  is the cnf formula associated with the current partial assignment  and ic x   ic x  
inconsistency count of x  x  is the number of unit clauses of  that contain x  x  
the underestimation of the lower bound can be improved by applying to binary clauses
the directional arc consistency  dac  count defined by wallace        for max csp  the
dac count of a value of the variable x in  is the number of variables which are inconsistent
with that value of x  for example  if  contains clauses x  y  x  y  and x  y  the value
  of x is inconsistent with y  note that value   of y is also inconsistent with x  these
two inconsistencies are not disjoint and cannot be summed  wallace defined a direction
from x to y  so that only the inconsistency for value   of x is counted  after defining a
direction between every pair of variables sharing a constraint  one computes the dac count
for all values of x by checking all variables to which a direction from x is defined  the
underestimation considering the dac count of wallace is as follows 

x

x

occurs in

 min ic x   ic x     min dac x   dac x  


where dac x   dac x   is the dac count of the value      of x  wallace statically defined
all directions  so that dac x  and dac x  can be computed in a preprocessing step for every
x and do not need to be recomputed during search  this is improved by larrosa  meseguer
and schiex        by introducing reversible dac  which searches for better directions to
obtain a better lower bound at every node of the search tree  an improvement of dac
counts is the additional incorporation of inconsistencies contributed by disjoint subsets of
variables  based on particular variable partitions  larrosa   meseguer        
inconsistent and dac counts deal with unit and binary clauses  lower bounds dealing
with longer clauses include star rule  shen   zhang        alsinet et al         and up  li
et al         
in the star rule  the underestimation of the lower bound is the number of disjoint
inconsistent subformulas of the form  l            lk   l       lk    the star rule  when k      is
equivalent to the inconsistency counts of wallace and freuder 
up subsumes the inconsistent count method based on unit clauses and the star rule  its
effectiveness for producing a good lower bound can be illustrated with the following example 
let  be a cnf formula containing the clauses x    x  x    x  x    x   x  x    x    x  x    x  
x    x   x   x    up easily detects that inconsistent subset with   clauses and   variables 
in time linear in the size of the formula  note that this subset is not detected by any of the
lower bounds described above  except for the variable partition based approach of larrosa
and meseguer        in the case that the   variables are in the same partition 
we mention two more lower bound computation methods  one is called lb  and was
defined by shen and zhang         it is similar to up but restricted to max  sat instances
and using a static variable ordering  another is based on linear programming and was
defined by xing and zhang        
regin et al         suggested to use arc consistency  instead of unit propagation  to detect
disjoint inconsistent subsets of constraints in weighted constraint networks  however  to the
   

fili  manya   planes

best of our knowledge  this idea has not been incorporated in any lower bound computation
method implemented by the constraint programming community 
a good lower bound computation method has a dramatic impact on the performance of
a max sat solver  another approach to speed up a max sat solver consists of applying
inference rules to transform a max sat instance  into an equivalent but simpler max sat
instance    inference rules that have proven to be useful in practice include   i  the pure
literal rule  alsinet et al       b  xing   zhang        li et al         zhang et al         
 ii  the dominating unit clause rule  first proposed by niedermeier and rossmanith        
and later applied in several solvers  alsinet et al         xing   zhang        li et al  
        iii  the almost common clause rule  first proposed by bansal and raman        and
restated as rule   in this paper  the rule was extended to weighted max sat byalsinet
et al          was called neighborhood resolution by larrosa and heras         and used as a
preprocessing technique by alsinet et al          shen and zhang         and li et al         
 iv  the complementary unit clause rule  niedermeier   rossmanith         restated as rule
  in this paper  and  v  the coefficient determining unit propagation rule  xing   zhang 
      based on integer programming 
the inference rules presented in this paper simplify a max sat formula  and allow
to improve the lower bound computation  since they all transform a max sat formula 
into a simpler and equivalent formula containing more empty clauses  their soundness
 i e   the fact that they transform a formula into an equivalent one  can be proved in several
ways  including  i  checking all possible variable assignments   ii  using integer programming
as done in section    and  iii  using soft local consistency techniques defined for weighted
constraint networks  wcn   max sat can be defined as a subcase of wcn where variables
are boolean and only unit costs are used 
soft local consistency techniques for wcn are based on two basic equivalence preserving
transformations called projection and extension  schiex        cooper   schiex        
given a max sat instance  projection replaces two binary clauses x  y and x  y with
the unit clause x  which is rule   for k    extension is the inverse operation of projection
and replaces a unit clause x with two binary clauses x  y and x  y for a selected variable
y  if the projection operation is rather straightforward for a sat or max sat instance 
the extension operation is very ingenious  to see this  note that rule   can be proved or
applied with an extension followed by a projection 
l    l   l    l    l   l    l   l    l   l    l 
  l   l    l    l 
  l   l     
lemma   can also be proved using an extension followed by a projection 
l    l   l    l   l    l   l    l   l 
  l   l    l 
the extension operation cannot be used in an unguided way because it may cancel a
previous projection  one way to guide its use is to define an ordering between variables to
   

finew inference rules for max sat

enforce directional arc consistency  cooper        cooper   schiex         directional arc
consistency allows to concentrate weights on the same variables by shifting weights from
earlier variables to later ones in a given ordering  for example if x    x  in a given variable
ordering  one can extend unit clause x  to x   x    x   x    but cannot extend unit clause x 
to x   x    x   x    allowing unit clauses to be concentrated on variable x    nevertheless 
how to define the variable ordering to efficiently exploit as much as possible the power of
soft arc consistency techniques in the lower bound computation remains an open problem 
the approach with inference rules for max sat presented in this paper does not need
any predefined ordering among variables  since rule applications combining several projection and extension operations are entirely guided by unit propagation 
the projection and extension operations can be extended to constraints involving more
than two variables to achieve high order consistency in wcn  cooper         for a maxsat instance  the extended projection and extension operations can be stated using rule  
for k    for the two formulas   and   in rule    replacing   with   is a projection and
  with   is an extension  given a unit clause x and three variables x  y  z  the extension
of the unit clause x to the set of three variables can be done as follows   replacing x by
x  y and x  y  and then x  y and x  y by x  y  z  x  y  z  x  y  z and x  y  z 
rule   can be proved or applied by extending the four clauses of   to ternary clauses on
the three variables of l    l  and l    and then applying the projection operation to obtain    
larrosa et al          based on a logical approach  independently and in parallel with
our work  defined and implemented a chain resolution rule and a cycle resolution rule for
weighted max sat  these two rules are extensions of rules   res and   res presented 
also independently and in parallel with our work  heras   larrosa        
the chain resolution could be stated as follows 


 li   mi  mi     ik  

 

 
  li  li     ui    mi     i k  
 
  l    u    
 li  li     mi     i k  
 li  li     ui     i k  
 
 
 

 l   u
 mk     
 lk   uk    


 k k  
    mk    













where  for  ik    ui is the weight of the corresponding clause  mi  min u    u            ui   
and all variables in the literals are different  the weight of a mandatory clause is denoted
by   and the subtraction  is extended so that   ui    the chain resolution rule is
equivalent to rule   if it is applied to unweighted max sat  the main difference between
the chain resolution rule and the weighted version of rule   presented in section     is
that the chain resolution shifts a part of the weight from unit clause  l    m   mk      that
is derived in the weighted version of rule    to create unit clauses  li   mi  mi      ik  
 l    m   mk     itself becoming  l    m   m    
the cycle resolution rule could be stated as follows 
   

fili  manya   planes



 li  li     ui   i k  
 l   lk   uk  



 

















 l   li   mi   mi   ik  
 li  li     ui  mi   i k  
 l   li  li     mi   i k  
 l   li  li     mi   i k  
 l   lk   uk  mk   
 l    mk  

















when a subset of binary clauses have a cyclic structure  the cycle resolution rule allows
to derive a unit clause  note that the detection of the cyclic structure appears rather timeconsuming if it is applied at every node of a search tree and that   k    new ternary
clauses have to be inserted  so  larrosa et al  apply the cycle resolution rule in practice
only for the case k    which is similar to rule    when applied to unweighted max sat 
the cycle resolution rule applied to unweighted max sat for k   can replace rule   and
rule   in maxsatz  but with the following differences compared with rule   and rule   
 the application of rule   and rule   is entirely based on inconsistent subformulas
detected by unit propagation  the detection of the applicability of rule   and rule   is
easy and has very low overhead  since the inconsistent subformulas are always detected
in maxsatz to compute the lower bound  with or without rule   and rule     every
application of rule   or rule   allows to increment the lower bound by   
 the cycle resolution rule needs an extra detection of the cyclic structure  but allows
to derive a unit clause from the cyclic structure  the derived unit clause could then
be used in a unit propagation  and possibly could allow to detect an inconsistent
subformula and increase the lower bound by   
it would be an interesting future research topic to implement the cycle resolution rule in
maxsat      i e   maxsatz without rule   and rule    to evaluate the overhead of detecting
the cyclic structure and the usefulness of the unit clauses and the ternary clauses derived
using the cycle resolution rule  and to compare the implemented solver with maxsatz  it
would be also interesting to compare the chain resolution rule and the cycle resolution rule
with the weighted inference rules presented in section     
a more general max sat resolution rule  where the conclusions were not in clausal
form  was defined by larrosa and heras         independently  bonet et al              
and heras and larrosa        defined a version of the rule with the conclusions in clausal
form  bonet et al               also proved that this rule is complete for max sat  recently 
ansotegui et al       b      a  have shown that max sat resolution for many valued cnf
formulas provides a logical framework for the global and local consistency properties defined
for wcn 

   conclusions and future work
one of the main drawbacks of state of the art max sat solvers is the lack of suitable
inference techniques that allow to detect as much contradictions as possible and to simplify
the formula at each node of the search tree  existing approaches put the emphasis on
computing underestimations of good quality  but the problem with underestimations is
   

finew inference rules for max sat

that the same contradictions are computed once and again  furthermore  it turns out
that u p   one of the currently best performing underestimations consisting of detecting
disjoint inconsistent subsets of clauses in a cnf formula via unit propagation  is still too
conservative  to make the computation of lowers more incremental and to improve the
underestimation  we have defined a number of original inference rules for max sat that 
based on derived contradictions by unit propagation  transform a max sat instance into
an equivalent max sat instance which is easier to solve  the rules were carefully selected
taking into account that they should be applied efficiently  since all these rules are based
on contradiction detection  they should be particularly useful for hard max sat instances
containing many contradictions 
with the aim of finding out how powerful the inference rules are in practice  we have
developed a new max sat solver  called maxsatz  which incorporates those rules  and
performed an experimental investigation  the results of comparing maxsatz with inference
rules and maxsatz without inference rules provide empirical evidence of the usefulness
of these rules in making lower bound computation more incremental and in improving
the quality of lower bounds  the results of comparing maxsatz with a large selection of
the solvers available at the time of submitting this paper provide empirical evidence that
maxsatz  at least for the instances solved  is faster than the other solvers  we observed gains
of several orders of magnitude for the hardest instances  interestingly  for the benchmarks
used  the second best solver was generally different  up for max  sat  toolbar for max sat  maxsolver for max cut  and maxsolver and up for graph   coloring  so  maxsatz
is more robust than the rest of solvers  it is worth mentioning that maxsatz  enhanced with
a lower bound based on failed literal detection  li et al          was the best performing
solver for unweighted max sat instances in the max sat evaluation       the second and
third best performing solvers were  respectively  improved versions of toolbar and lazy    
as future work we plan to study the orderings of unit clauses in unit propagation to
maximize the application of inference rules  and to define new inference rules for ternary
clauses  we are extending the results of this paper to weighted max sat  which is more
suitable for modeling problems such as maximum clique  set covering and combinatorial
auctions  as well as constraint satisfaction problems such as hard instances of model rb  xu 
boussemart  hemery    lecoutre        xu   li         we are also adapting the results
of this paper to the partial max sat solvers developed by argelich and manya             
      

acknowledgments
research partially supported by projects tin           c      and tin           c     funded by the ministerio de educacion y ciencia  the first author was partially supported by national     program of china under grant no      cb        the second
author was supported by a grant ramon y cajal  finally  we would like to thank the referees
for their detailed comments and suggestions 
    see http   www iiia csic es maxsat   for details  note that the results of the max sat evaluation
     can be compared with the results of this paper because they were obtained with the same cluster
under the same conditions 

   

fili  manya   planes

references
alber  j   gramm  j     niedermeier  r          faster exact algorithms for hard problems 
a parameterized point of view  discrete mathematics                
alsinet  t   manya  f     planes  j       a   improved branch and bound algorithms for
max   sat and weighted max   sat  in proceedings of the catalonian conference
on artificial intelligence  ccia      p  mallorca  spain  vol      of frontiers in
artificial intelligence and applications  pp          ios press 
alsinet  t   manya  f     planes  j       b   improved branch and bound algorithms for
max sat  in proceedings of the  th international conference on the theory and
applications of satisfiability testing  sat      portofino  italy  pp         
alsinet  t   manya  f     planes  j          a max sat solver with lazy data structures  in proceedings of the  th ibero american conference on artificial intelligence
 iberamia      puebla  mexico  lncs       pp          springer 
alsinet  t   manya  f     planes  j          improved exact solver for weighted maxsat  in proceedings of the  th international conference on theory and applications
of satisfiability testing  sat      st  andrews  scotland  lncs       pp         
springer 
ansotegui  c   bonet  m  l   levy  j     manya  f       a   inference rules for high order
consistency in weighted csp  in proceedings of the   nd national conference on
artificial intelligence  aaai      vancouver  canada  pp          aaai press 
ansotegui  c   bonet  m  l   levy  j     manya  f       b   the logic behind weighted csp 
in proceedings of the   th international joint conference on artificial intelligence
 ijcai      hyderabad  india  pp        aaai press 
argelich  j     manya  f          solving over constrained problems with sat technology 
in proceedings of the  th international conference on theory and applications of
satisfiability testing  sat      st  andrews  scotland  lncs       pp       springer 
argelich  j     manya  f          exact max sat solvers for over constrained problems 
journal of heuristics                  
argelich  j     manya  f          partial max sat solvers with clause learning  in proceedings of the   th international conference on theory and applications of satisfiability
testing  sat      lisbon  portugal  lncs       pp        springer 
bansal  n     raman  v          upper bounds for maxsat  further improved  in proceedings of   th international symposium on algorithms and computation  isaac     
chennai  india  lncs       pp          springer 
beame  p   kautz  h     sabharwal  a          understanding the power of clause learning 
in proceedings of the   th international joint conference on artificial intelligence
 ijcai      acapulco  mexico  pp        morgan kaufman 
bonet  m  l   levy  j     manya  f          a complete calculus for max sat  in proceedings of the  th international conference on theory and applications of satisfiability
testing  sat      seattle  usa  lncs       pp          springer 
   

finew inference rules for max sat

bonet  m  l   levy  j     manya  f          resolution for max sat  artificial intelligence 
            
borchers  b     furman  j          a two phase exact algorithm for max sat and weighted
max sat problems  journal of combinatorial optimization            
boros  e     hammer  p          pseudo boolean optimization  discrete applied mathematics              
cooper  m  c          reduction operations in fuzzy or valued constraint satisfaction  fuzzy
sets and systems              
cooper  m  c          high order consistency in valued constraint satisfaction  constraints 
           
cooper  m  c     schiex  t          arc consistency for soft constraints  artificial intelligence                   
cormen  t  h   leiserson  c  e   rivest  r  l     stein  c          introduction to algorithms
 second edition   mit press 
davis  m   logemann  g     loveland  d          a machine program for theorem proving 
communications of the acm            
davis  m     putnam  h          a computing procedure for quantification theory  journal
of the acm                
de givry  s   larrosa  j   meseguer  p     schiex  t          solving max sat as weighted
csp  in proceedings of  th international conference on principles and practice
of constraint programming  cp      kinsale  ireland  lncs       pp         
springer 
de givry  s   zytnicki  m   heras  f     larrosa  j          existential arc consistency  getting closer to full arc consistency in weighted csps  in proceedings of the   th international joint conference on artificial intelligence  ijcai      edinburgh  scotland 
pp       
freeman  j  w          improvements to propositional satisfiability search algorithms 
ph d  thesis  department of computer and information science  university of pennsylvania  pa  usa 
goldberg  e     novikov  y          berkmin  a fast and robust sat solver  in proceedings
of design  automation and test in europe  date      paris  france  pp         
ieee computer society 
heras  f     larrosa  j          new inference rules for efficient max sat solving  in proceedings of the   st national conference on artificial intelligence  aaai      boston 
usa  aaai press 
huang  w  q     jin  r  c          solar  a learning from human algorithm for solving
sat  science in china  series e                  
jeroslow  r  g     wang  j          solving propositional satisfiability problems  annals
of mathematics and artificial intelligence            
   

fili  manya   planes

larrosa  j     heras  f          resolution in max sat and its relation to local consistency
in weighted csps  in proceedings of the   th international joint conference on artificial intelligence  ijcai      edinburgh  scotland  pp          morgan kaufmann 
larrosa  j   heras  f     de givry  s          a logical approach to efficient max sat
solving  artificial intelligence   in press  
larrosa  j     meseguer  p          partition based lower bound for max csp  constraints 
               
larrosa  j   meseguer  p     schiex  t          maintaining reversible dac for max csp 
artificial intelligence                  
li  c  m          a constraint based approach to narrow search trees for satisfiability 
information processing letters           
li  c  m     anbulagan      a   heuristics based on unit propagation for satisfiability
problems  in proceedings of   th the international joint conference on artificial
intelligence  ijcai      nagoya  japan  pp          morgan kaufmann 
li  c  m     anbulagan      b   look ahead versus look back for satisfiability problems 
in proceedings of the  rd international conference on principles of constraint programming  cp      linz  austria  lncs       pp          springer 
li  c  m     huang  w  q          diversification and determinism in local search for
satisfiability  in proceedings of the  th international conference on theory and applications of satisfiability testing  sat      st  andrews  scotland  lncs       pp 
        springer 
li  c  m   manya  f     planes  j          exploiting unit propagation to compute lower
bounds in branch and bound max sat solvers  in proceedings of the   th international conference on principles and practice of constraint programming  cp     
sitges  spain  lncs       pp          springer 
li  c  m   manya  f     planes  j          detecting disjoint inconsistent subformulas for
computing lower bounds for max sat  in proceedings of the   st national conference
on artificial intelligence  aaai      boston  usa  pp        aaai press 
marques silva  j  p     sakallah  k  a          grasp  a search algorithm for propositional
satisfiability  ieee transactions on computers                 
niedermeier  r     rossmanith  p          new upper bounds for maximum satisfiability 
journal of algorithms           
regin  j  c   petit  t   bessiere  c     puget  j  f          new lower bounds of constraint
violations for over constrained problems  in  th international conference on principles and practice of constraint programming  cp      paphos  cyprus  lncs      
pp          springer 
schiex  t          arc consistency for soft constraints  in proceedings of the  th international conference on principles of constraint programming  cp      singapore 
lncs       pp          springer 
   

finew inference rules for max sat

shen  h     zhang  h          study of lower bound functions for max   sat  in proceedings
of the national conference on artificial intelligence  aaai      san jose  usa  pp 
        aaai press 
shen  h     zhang  h          improving exact algorithms for max   sat  annals of mathematics and artificial intelligence             
wallace  r  j          directed arc consistency preprocessing  in constraint processing 
selected papers  lncs      pp          springer 
wallace  r  j     freuder  e          comparative studies of constraint satisfaction and
davis putnam algorithms for maximum satisfiability problems  in johnson  d    
trick  m   eds    cliques  coloring and satisfiability  vol      pp          american
mathematical society 
xing  z     zhang  w          efficient strategies for  weighted  maximum satisfiability  in
proceedings of the   th international conference on principles and practice of constraint programming  cp      toronto  canada  lncs       pp          springer 
xing  z     zhang  w          an efficient exact algorithm for  weighted  maximum satisfiability  artificial intelligence                
xu  k   boussemart  f   hemery  f     lecoutre  c          a simple model to generate
hard satisfiable instances  in proceedings of   th international joint conference on
artificial intelligence  ijcai      edinburgh  scotland  pp         
xu  k     li  w          many hard examples in exact phase transitions  theoretical
computer science              
zhang  h          sato  an efficient propositional prover  in proceedings in the conference
on automated deduction  cade      pp         
zhang  h   shen  h     manya  f          exact algorithms for max sat  electronic
notes in theoretical computer science         
zhang  l   madigan  c   moskewicz  m     malik  s          efficient conflict driven learning
in a boolean satisfiability solver  in international conference on computer aided
design  iccad      san jose  usa  pp         

   

fi