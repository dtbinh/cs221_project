journal of artificial intelligence research                  

submitted       published     

on the compilability and expressive power
of propositional planning formalisms
bernhard nebel

nebel   informatik   uni   freiburg   de

institut fur informatik  albert ludwigs universitat  georges kohler allee  d       freiburg  germany

abstract
the recent approaches of extending the graphplan algorithm to handle more expressive
planning formalisms raise the question of what the formal meaning of expressive power is  we
formalize the intuition that expressive power is a measure of how concisely planning domains
and plans can be expressed in a particular formalism by introducing the notion of compilation
schemes between planning formalisms  using this notion  we analyze the expressiveness of a
large family of propositional planning formalisms  ranging from basic strips to a formalism with
conditional effects  partial state specifications  and propositional formulae in the preconditions 
one of the results is that conditional effects cannot be compiled away if plan size should grow
only linearly but can be compiled away if we allow for polynomial growth of the resulting plans 
this result confirms that the recently proposed extensions to the graphplan algorithm concerning
conditional effects are optimal with respect to the compilability framework  another result is that
general propositional formulae cannot be compiled into conditional effects if the plan size should
be preserved linearly  this implies that allowing general propositional formulae in preconditions
and effect conditions adds another level of difficulty in generating a plan 

   introduction
g raphplan  blum   furst        and satplan  kautz   selman        are among the most
efficient planning systems nowadays  however  it is generally felt that the planning formalism
supported by these systems  namely  propositional basic strips  fikes   nilsson         is not
expressive enough  for this reason  much research effort  anderson  smith    weld        gazen
  knoblock        kambhampati  parker    lambrecht        koehler  nebel  hoffmann    dimopoulos        has been devoted in extending graphplan in order to handle more powerful
planning formalisms such as adl  pednault        
there appears to be a consensus on how much expressive power is added by a particular language feature  for example  everybody seems to agree that adding negative preconditions does not
add very much to the expressive power of basic strips  whereas conditional effects are considered
as a significant increase in expressive power  anderson et al         gazen   knoblock       
kambhampati et al         koehler et al          however  it is unclear how to measure the expressive power in a more formal way  related to this problem is the question of whether compilation
approaches to extend the expressiveness of a planning formalism are optimal  for example  gazen
and knoblock        propose a particular method of compiling operators with conditional effects
into basic strips operators  this method  however  results in exponentially larger operator sets 
while most people  anderson et al         kambhampati et al         koehler et al         agree
that we cannot do better than that  nobody has proven yet that a more space efficient method is
impossible 
c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fin ebel

in order to address the problem of measuring the relative expressive power of planning formalisms  we start with the intuition that a formalism  is at least as expressive as another formalism  if planning domains and the corresponding plans in formalism  can be concisely expressed
in the formalism    this  at least  seems to be the underlying intuition when expressive power is
discussed in the planning literature 
backstrom        proposed to measure the expressiveness of planning formalisms using his
esp reductions  these reductions are  roughly speaking  polynomial many one reductions on
planning instances that do not change the plan length  using this notion  he showed that all of
the propositional variants of basic strips not containing conditional effects or arbitrary logical
formulae can be considered as expressively equivalent  however  taking our point of view  espreductions are too restrictive for two reasons  firstly  plans must have identical size  while we might
want to allow a moderate growth  secondly  requiring that the transformation can be computed
in polynomial time is overly restrictive  if we ask for how concisely something can be expressed 
this does not necessarily imply that there exists a polynomial time transformation  in fact  one
formalism might be as expressive as another one  but the mapping between the formalisms might
not be computable at all  this  at least  seems to be the usual assumption made when the term
expressive power is discussed  baader        cadoli  donini  liberatore    schaerf        erol 
hendler    nau        gogic  kautz  papadimitriou    selman        
inspired by recent approaches to measure the expressiveness of knowledge representation formalisms  cadoli et al         gogic et al          we propose to address the questions of how
expressive a planning formalism is by using the notion of compiling one planning formalism into
another one  a compilation scheme from one planning formalism to another differs from a polynomial many one reduction in that it is not required that the compilation is carried out in polynomial
time  however  the result should be expressible in polynomial space  furthermore  it is required
that the operators of the planning instance can be translated without considering the initial state
and the goal  while this restriction might sound unnecessarily restrictive  it turns out that existing
practical approaches to compilation  gazen   knoblock        as well as theoretical approaches
 backstrom        consider only structured transformations where the operators can be transformed
independently from the initial state and the goal description  from a technical point of view this
restriction guarantees that compilations are non trivial  if the entire instance could be transformed 
a compilation scheme could decide the existence of a plan for the source instance and then generate
a small solution preserving instance in the target formalism  which would lead to the unintuitive
conclusion that all planning formalisms have the same expressive power 
as mentioned in the beginning  not only the space taken up by the domain structure is important 
but also the space used by the plans  for this reason  we distinguish between compilation schemes
in whether they preserve plan size exactly  linearly  or polynomially 
using the notion of compilability  we analyze a wide range of propositional planning formalisms  ranging from basic strips to a planning formalism containing conditional effects  arbitrary boolean formulae  and partial state specifications  as one of the results  we identify two
equivalence classes of planning formalisms with respect to polynomial time compilability preserving plan size exactly  this means that adding a language feature to a formalism without leaving
the class does not increase the expressive power and should not affect the principal efficiency of
   we assume that the reader has a basic knowledge of complexity theory  garey   johnson        papadimitriou 
       and is familiar with the notion of polynomial many one reductions and the complexity classes p  np  conp 
and pspace  all other notions will be introduced in the paper when needed 

   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

the planning method  however  we also provide results that separate planning formalisms using
results from computational complexity theory on circuit complexity and non uniform complexity
classes  such separation results indicate that adding a particular language feature adds to the expressive power and to the difficulty of integrating the feature into an existing planning algorithm 
for example  we prove that conditional effects cannot be compiled away and that boolean formulae
cannot be compiled into conditional effectsprovided the plans in the target formalism are allowed
to grow only linearly 
this answers the question posed in the beginning  the compilation approach proposed by gazen
and knoblock        cannot be more space efficient  even if we allow for linear growth of the plans
in the target formalism  allowing for polynomial growth of the plans  however  the compilation
scheme can be more space efficient  interestingly  it seems to be the case that a compilation scheme
that allows for polynomially larger plans is similar to the implementation of conditional effects in
the ipp system  koehler et al          kambhampati and colleagues         planning system  and
anderson and colleagues         planning system 
the rest of the paper is structured as follows  in section    we introduce the range of propositional planning formalisms analyzed in this paper together with general terminology and definitions 
based on that  we introduce the notion of compilability between planning formalisms in section   
in section   we present polynomial time compilation schemes between different formalisms that
preserve the plan size exactly  demonstrating that these formalisms are of identical expressiveness 
for all of the remaining cases  we prove in section   that there cannot be any compilation scheme
preserving plan size linearly  even if there are no bounds on the computational resources of the
compilation process  in section   we reconsider the question of identical expressiveness by using compilation schemes that allow for polynomial growth of the plans  finally  in section   we
summarize and discuss the results 

   propositional planning formalisms
first  we will define a very general propositional planning formalism  which appears almost as
expressive as the propositional variant of adl  pednault         this formalism allows for arbitrary
boolean formulae as preconditions  conditional effects and partial state specifications  subsequently 
we will specialize this formalism by imposing different syntactic restrictions 
    a general propositional planning formalism
let  be the countably infinite set of propositional atoms or propositional variables  finite
subsets of  are denoted by    further    is defined to be the set consisting of the constants 
 denoting truth  and    denoting falsity  as well as atoms and negated atoms  i e   the literals 
over    the language of propositional logic over the logical connectives 
fiff   and  and the
propositional atoms  is denoted by fi   a clause is a disjunction of literals  further  we say that
a formula   is in conjunctive normal form  cnf  if it is a conjunction of clauses  it is in
disjunctive normal form  dnf  if it is a disjunction of conjunctions of literals 
given a set of literals    by fi we refer to the positive literals in    by        we refer to
the negative literals in    and by     to the atoms used in    i e      fi               or    
   note that gazen and knoblock s        translation scheme also generates planning operators that depend on the
initial state and the goal description  however  these operators simply code the initial state and the goal description
and do nothing else  for this reason  we can ignore them here 

   

fin ebel

  

  further  we define   to be the element wise negation of    i e  

                              ba
a state c is a truth assignment for the atoms in    in the following  we also identify a state with
the set of atoms that are true in this state  a state specification d is a subset of     i e   it is a logical
theory consisting of literals only  it is called consistent iff it does not contain complementary literals
or     in general  a state specification describes many states  namely all those that satisfy d   which
are denoted by ef gh d    only in case that d is complete  i e   for each     we have either    d
or   ijd   d has precisely one model  namely k  d    by abusing notation  we will refer to the
inconsistent state specification by     which is the illegal state specification 
operators are pairs lm on pre ff post p   we use the notation pre lb and post lq to refer to the first
and second part of an operator l   respectively  the precondition pre is an element of rkskt   i e  
it is a set of propositional formulae  the set post  which is the set of postconditions  consists of
conditional effects  each having the form

uwv xff
uzy

y

  are called effectv conditions and the elements of 
  are called
where the elements of
u
effects  if or  are singleton sets  e g      h 
        we often omit the curly brackets and write
  v   
example   in order to illustrate the various notions  we will use as a running example planning
problems connected with the production of camera ready manuscripts from latex source files
somewhat simplified  of course  as the set of atoms    we choose the following set 

      bacffed fgcffihqj klffgm no ffgp qgffgrsklrsffgr rsmlffgrsm o fftklu hvfftk hqcfftkwm o
hqj k klu h nxqffihbjsk y k  za nx ba
these propositional atoms have the following intended meaning  the atoms in the first line represent
the presence of the corresponding files  and the atoms in the second line signify that the index and
citations are correct in the dvi file  based on that  we define the following operators  rbkwr  bac   m d  zac  
  d xea kwu h ac   the first of these operators is very simple  the precondition for its execution is that
a rbklr   and an d fgc  file exist  after the successful execution  a r rsm   and a r m o  file will have been
produced 

rbklr  zacm    d fgcffgrbkwr ff v v  brsrsmlffgrsm ov  va

the

  d xea kwu hsac

operator is similar 

  d xea kwu h acm    k hc  ff v v  qkwu h fftklm ov  va
finally  the m d  zac operator is a bit more complicated  as a precondition it needs the presence of the
 bac  file and it produces as its effect d fgc    k hc    hbjsk   and m no  files unconditionally  in addition  we
know that the citations will be correct if a rsr m  file is present and that the index will be correct if an
   

fic ompilability

klu h

 file is present 

and

e xpressive p ower of p lanning f ormalisms

m d  bac    zac  ff
v
  v
rsr m
fir rsv m
klu h

  d f cfftk hqcffihbjsklffgm no  bff
v hbjs k hqy j k  bk a y k n zaxff nxqff
hbjsk klu h nxqff
v
kwu h  hqj k kwu h nx   a

the semantics of operators is given by state transition functions  i e   mappings from states to
states  given a state c and a set of postconditions post  cbff post  denotes the active effects in c  

mcsff post      uwv  

post ffec   

u  ba

the state transition function   induced by the operator l is defined as follows 

  
 c  

r    r 
 c fi      csff post lb    mcsff post lb   if c    pre lb and

 cbff post lq    

undefined

otherwise

in words  if the precondition of the operator is satisfied in state c and the active effects are consistent 
then state c is mapped to the state c  which differs from c in that the truth values of active effects
are forced to become true for positive effects and forced to become false for negative effects  if the
precondition is not satisfied or the set of active effects is inconsistent  the result of the function is
undefined 
in the planning formalism itself  we do not work on states but on state specifications  in general 
this can lead to semantic problems  by restricting ourselves to state specifications that are sets of
literals  however  the syntactic manipulations of the state specifications can be defined in a way such
that they are sound in lifschitz         sense 
similarly to the active effects with respect to states  we define a corresponding function with
respect to state specifications 

 dff post     i  uwv fifi

post ffd    

u  ba

further  we define the potentially active effects as follows 

  dff post    cbff posta
e  


 dff post  
if for a state specification d and an operator l  n pre ff post p   we have  dff post   
it means that the state specification resulting from the application of the state transition functions
might not be representable as a theory consisting of literals only  for this reason  we consider such
an operator application as illegal  resulting in the illegal state specification     we could be more
liberal at this point and consider an operator application to a state specification only as illegal if the
set of states resulting from applying the state transition functions could definitely not be represented
   note that this can only happen if the state specification is incomplete 

   

fin ebel

as a theory consisting of literals only  alternatively  we could consider all atoms mentioned in
  dff post  m d ff post  as unsafe after the application of the operator and delete the literals
    d ff post   dff post   from the state specification  but consider the resulting state specification
still as legal if  dff post  is consistent  since there does not seem to exist a standard model for
the execution of conditional effects in the presence of partial state specifications  we adopt the first
alternative as one arbitrary choice  it should be noted  however  that this decision influences some
of the results we present below 
  dff post  leads to an illegal state specification  we
similarly to the rule that  dff post   
require that if the precondition is not satisfied by all states in ef gh d  or if the state specification
is already inconsistent  the result of applying l to d results in     this leads to the definition of the
function    which defines the outcome of applying an operator l from the set of operators  to a
state specification 

r      r 
 d   dff post lq   m d ff post lb  if d    and

d     pre lb and
j

  d ff post lb   
m
    dand
 d ffilq  

m
 

 
d
ff


b
l
 



 
ff post lb 
post



 

otherwise

example   using the propositional atoms and operators from example    we assume the following
two state specifications 
     zackfftklu hk    and       backfftklu h ffgrsr mffgrsm ov    if we try to apply the
operator m d  bac to    we notice that this results in   because



 ff post zm d  bacb     d fgcfftk hcffihqj klffgm no ffihqj k klu h nx bff
    ff post zm d  bacb    ff post zm d  bacb h    hbjsk y k  za nxqff hqj k y k  ba nx bff



  ff post zm d  bacb a on the other hand  we can apply rbkwr  bac
i e   we have m ff post zm d  bacb   

successfully to     ffgrbkwr  bacb   a



it is easily verified that the syntactic operation on a state specification using the function 
corresponds to state transitions on the states described by the specification 
proposition   let d be a state specification  l be an operator  and   be the induced state transition
function  if  d ffilq      then

ef gh  dffilb     c   gc    c ffec   dfi ba
if  dffilb        then either
  

ef gh d  

  or

   there are two states c
  

 mc  ff post lb    or
 ffec   e g d  such that mc  ff post lb  
there exists a state cwe gh d such that   c  is undefined 
   

fic ompilability

e xpressive p ower of p lanning f ormalisms

and

in other words  whenever  dffilb results in a legal specification  this specification describes the
states that result from the application of the state transition function   to the states that satisfy the
original state specification d   further  if  d ffilq is illegal  there are good reasons for it 

a planning instance is a tuple

  n ffifft pff

where




  n fftp is the domain structure consisting of a finite set of propositional atoms  and a
finite set of operators   

y
    is the initial state specification  and
 y   is the goal specification 



when we talk about the size of an instance  symbolically         in the following  we mean the size
of a  reasonable  encoding of the instance 
in the following  we use the notation  to refer to the set of finite sequences of operators 
elements  of  are called plans  then        denotes the size of the plan  i e   the number of
operators in    we say that  is a   step plan if           the result of applying  to a state
specification d is recursively defined as follows 

  b
 
r      r 
  t dff n p   d
  t  dff nl  iff l  ffgagaga ffil kp        dffil  ff nl  ffgagaga ffil kp 


a sequence of operators  is said to be a plan for or a solution of iff
   x  ffe    and
   x  ffe      
example   let  and  be the propositional
 atoms and operators introduced in example   and
consider the following planning instance 
 n n fftpfft   backffgrbklr ffklu hk bfft  hbjskffihqjsk y k  za nx  pa in
words  given a latex source file   bac   and a bibliography database   rbklr    we want to generate a dvi
file  hbjsk   such that the citations in this file are correct  hbjsk y k  ba nx    furthermore  we do not know
 but we know that there is no index file yet
anything about the existence of a bbl file or aux file etc  
  kwu h    the plan   nzrsklr  bacffgm d  zacsp is a solution of because the plan does not result in an illegal
state specification and the resulting state specification entails hqj k and hbjsk y k  ba nx  
plans satisfying     and     above are sound  in order to state this more precisely  we extend
the notion of state transition functions for operators to state transition functions for plans  let   be
the state transition function corresponding to the composition of primitive state transition functions
induced by the operators in   nl ffgagaga ffil p   i e  



b e   b     eagagaqfi bvff
   we could have been more liberal requiring that  t   we have not done that in order to allow for a fair
comparison with restricted planning formalisms 

   

fin ebel


such that   e      c  is defined iff   e   b c is defined for every        using this
notion  one can easily proveusing induction over the plan lengththat any plan for an instance
is sound in lifschitz         sense  i e   corresponds to the application of state transition functions
to the initial states 


proposition   let  n ffifft p be a planning instance and
   if x  ffe is consistent  then

 nl  gff agaga ffil p

be an element of

e gh x ffe     c   tc    c ffec     ba
if    ffe is inconsistent  then either
  

ef gh   

  or

   there exists a  possibly empty  prefix
x  ff nl ffgagaga ffil  p  and either



 a  there are two states c
or

nl  gff agaga ffil  p  
      of 

 eff c  wef gh d 

such that mc

 b  there exists a state cwe gh d such that  bw

 c 

such that

d 

 c  ff post l      
 ff post l      
is undefined 

    a family of propositional planning formalisms
the propositional variant of standard strips  fikes   nilsson         which we will also call 
in what follows  is a planning formalism that requires complete state specifications  unconditional
effects  and propositional atoms as formulae in the precondition lists  less restrictive planning
formalisms can have the following additional features 
incomplete state specifications      the state specifications may not be complete 
conditional effects      effects can be conditional 
literals as formulae      the formulae in preconditions and effect conditions can be literals 
boolean formulae      the formulae in preconditions and effect conditions can be arbitrary
boolean formulae 
these extensions can also be combined  we will use combinations of letters to refer to such multiple
extensions  for instance   refers to the formalism  extended by literals in the precondition lists 
s
 s refers to the formalism allowing for incomplete state specifications and conditional effects  and
 qb   finally  refers to the general planning formalism introduced in section     



example   when we consider the planning instance from example    it becomes quickly obvious
that this instance has been expressed using  s   the initial state specification is incomplete  the
s
operator m d  zac contains conditional effects and negative literals in some effect conditions  however 
we do not need general boolean formulae to express the instance 
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

  

 

   

 

  

 q

 

 

 



 


figure    planning formalisms partially ordered by syntactic restrictions

figure   displays the partial order on propositional planning formalisms defined in this way  in
the sequel we say that  is a specialization of    written    iff  is identical to  or below
 in the diagram depicting the partial order 
comparing this set of planning formalisms with the one backstrom        analyzed  one notices that despite small differences in the presentation of the planning formalisms 

 

is the same as common propositional strips  cps  

  s is the same as propositional strips with negative goals  psn   and
 s  is the same as ground tweak  gt  
    the computational complexity of planning in the   family

while one would expect that planning in  is much easier than planning in  s   it turns out that
this is not the case  provided one takes a computational complexity perspective 
in analyzing the computational complexity of planning in different formalisms  we consider  as
usual  the problem of deciding whether there exists a plan for a given instancethe plan existence
problem  planex   we will use a prefix referring to the planning formalism if we consider the
existence problem in a particular planning formalism 
theorem  



 planex is pspace complete for all 



with  qb  

   we do not consider planning formalisms identical to the sas formalism  backstrom   nebel         since we do
not allow for multi valued state variables 

   

fin ebel

proof  pspace hardness of   planex follows from a result by bylander        corollary      
membership of  qs  planex in pspace follows because we could  step by step  guess a
sequence of operators  verifying at each step that the operator application leads to a legal follow up
state specification and that the last operator application leads to a state specification that entails the
goal specification  for each step  this verification can be carried out in polynomial space  the reason
for this is that all the conditions in the definition of  are verified by polynomially many calls to an
np oracle  therefore   qs can be decided on a non deterministic machine in polynomial space 
hence it is a member of pspace 
from that it follows that the plan existence problem for all formalisms that are in expressiveness
between  and  s including both formalismsis pspace complete 

   expressiveness and compilability between planning formalisms
although there is no difference in the computational complexity between the formalisms in the
 qb  family  there might nevertheless be a difference in how concisely planning domains and plans
can be expressed  in order to investigate this question  we introduce the notion of compiling planning formalisms 
    compiling planning formalisms
as mentioned in the introduction  we will consider a planning formalism  as expressive as another
formalism  if planning domains and plans formulated in formalism  are concisely expressible
in    we formalize this intuition by making use of what we call compilation schemes  which
are solution preserving mappings with polynomially sized results from  domain structures to 
domain structures  while we restrict the size of the result of a compilation scheme  we do not
require any bounds on the computational resources for the compilation  in fact  for measuring the
expressibility  it is irrelevant whether the mapping is polynomial time computable  exponential time
computable  or even non recursive  at least  this seems to be the idea when the notion of expressive
power is discussed in similar contexts  baader        erol et al         gogic et al         cadoli
et al          if we want to use such compilation schemes in practice  they should be reasonably
efficient  of course  however  if we want to prove that one formalism is strictly more expressive
than another one  we have to prove that there is no compilation scheme regardless of how many
computational resources such a compilation scheme might use 
so far  compilation schemes restrict only the size of domain structures  however  when measuring expressive power  the size of the generated plans should also play a role  in backstrom s
esp reductions         the plan size must be identical  similarly  the translation from   to 
s
s
proposed by gazen and knoblock        seems to have as an implicit prerequisite that the plan
length in the target formalism should be almost the same  when comparing the expressiveness of
different planning formalisms  we might  however  be prepared to accept some growth of the plans
in the target formalism  for instance  we may accept an additional constant number of operators  or
we may even be satisfied if the plan in the target formalism is linearly or polynomially larger  this
leads to the schematic picture of compilation schemes as displayed in figure   
although figure   gives a good picture of the compilation framework  it is not completely
accurate  first of all  a compilation scheme may introduce some auxiliary propositional atoms that
are used to control the execution of newly introduced operators  these atoms should most likely
have an initial value and may appear in the goal specification of planning instances in the target
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms




planning

compilation

i



g



b

planning

 

figure    the compilation framework

formalism  we will assume that the compilation scheme takes care of this and adds some literals to
the initial state and goal specifications 
additionally  some translations of the initial state and goal specifications may be necessary  if
we want to compile a formalism that permits for literals in preconditions and goals to one that requires atoms  some trivial translations are necessary  similarly  if we want to compile a formalism
that permits us to use partial state specification to a formalism that requires complete state specifications  a translation of the initial state specification is necessary  however  such state translation
functions should be very limited  they should depend only on the set of symbols in the source
formalism  should be context independent  i e   the translation of a literal in a state specification
should not depend on the whole specification  and they should be efficiently computable 
while the compilation framework is a theoretical tool to measure expressiveness  it has  of
course  practical relevance  let us assume that we have a reasonably fast planning system for a
planning formalism  and we want to add a new feature to  resulting in formalism    if we
can come up with an efficient compilation scheme from  to    this means we can easily integrate
the new featureeither by using the compilation scheme or by modifying the planning algorithm
minimally  if no compilation scheme exists  we probably would have problems integrating this feature  finally  if only computationally expensive compilation schemes exist  we have an interesting
situation  in this case  the off line compilation costs may be high  however  since the compiled
domain structure can be used for different initial and goal state specifications  the high off line costs
may be compensated by the efficiency gain resulting from using the  planning algorithm  as
it turns  however  this situation does not arise in analyzing compilability between the  qs formalisms  either we can identify a polynomial time compilation scheme or we are able to prove that
no compilation scheme exists 

   this means that compilation schemes between planning formalisms are similar to knowledge compilations  cadoli  
donini         where the fixed part of a computational problem is the domain structure and the variable part consists
of the initial state and goal specifications  the main difference to the knowledge compilation framework is that we
also take the  size of the  result into account  in other words we compile function problems instead of decision
problems 

   

fin ebel



    compilation schemes
assume a tuple of functions m n  ffe  ffe qff
n ffifft p to   instances   as follows 

 ffz p

that induce a function 

from



 instances

 



   n   ffe  h    ffi ffe s  zs fft  pga


if the following three conditions are satisfied  we call  a compilation scheme from



iff there exists a plan for 

   there exists a plan for



 

   the state translation functions z and  are modular  i e   for
d      the functions   for   eff    satisfy






to   

          d y  

  and



 ffd   
      ffdfiff   h       ffdff   ff

and they are polynomial time computable 
   and the size of the results of   ffe    and   is polynomial in the size of the arguments 
condition     states that the function  induced by the compilation scheme  is solutionpreserving  condition     states requirements on the on line state translation functions  the result
of these functions should be computable element wise  provided the state specification is consistent  considering the fact that these functions depend only on the original set of symbols and the
state specification  this requirement does not seem to be very restrictive  since the state translation
functions are on line functions  we also require that the result should be efficiently computable 
finally  condition     formalizes the idea that  is a compilation  for a compilation it is much more
important that the result can be concisely represented  i e   in polynomial space  than that the compilation process is fast  nevertheless  we are also interested in efficient compilation schemes  we say
that  is a polynomial time compilation scheme if   ffe    and   are polynomial time computable
functions 
in addition to the resource requirements on the compilation process  we will distinguish between different compilation schemes according to the effects on the size of the plans solving the
  has the property that for every plan 
instance in the target formalism  if a compilation scheme
solving an instance there exists a plan  solving   such that             
 for some
positive integer constant     is a compilation scheme preserving plan size exactly  up to additive
        for positive integer constants
  and    then  is a compilation
constants   if       k
scheme preserving plan size linearly  and if         i      lff       for some polynomial     then 
is a compilation scheme preserving plan size polynomially  more generally  we say that a planning formalism  is compilable to formalism   in polynomial time  preserving plan size exactly 
linearly  or polynomially   if there exists a compilation scheme with the appropriate properties  we

write 
 in case  is compilable to  or     if the compilation can be done in polynomial time  the super script  can be       or   depending on whether the scheme preserves plan size
exactly  linearly plan  or polynomially  respectively 
as is easy to see  all the notions of compilability introduced above are reflexive and transitive 
   although it is hard to imagine a modular state translation function that is not polynomial time computable  some
pathological function could  e g   output translations that have exponential size in the encoding of the symbols 

   

fic ompilability

proposition   the relations



and



e xpressive p ower of p lanning f ormalisms

and

 



are transitive and reflexive 

furthermore  it is obvious that when moving upwards in the diagram displayed in figure   
there is always a polynomial time compilation scheme preserving plan size exactly  if v denotes
the projection to the   th argument and  the function that returns always the empty set  the generic
compilation scheme for moving upwards in the partial order is  on ffeffeff ff p  
proposition   if j   then  









 

   compilability preserving plan size exactly
proposition   leads to the question of whether there exist other compilation schemes than those
implied by the specialization relation  because of proposition   and proposition    we do not have
to find compilation schemes for every pair of formalisms  it suffices to prove that  is compilable
to    in order to arrive at the conclusion that all formalisms that are below  are compilable to 
and formalisms above   
a preview of the results of this section is given in figure    we will establish two equivalence
classes such that all members of each class are compilable to each other preserving plan size exactly 
these two equivalence classes will be called     and  s  class  in symbols    and   s   
s
s
s
s
naming them after their respective largest elements 

  

  

  

 

  

 q

  

 

 



 


figure    equivalence classes of planning formalisms created by polynomial time compilation
schemes preserving plan size exactly

   

fin ebel

    planning formalisms without conditional effects and boolean formulae
first  we will show that the formalisms analyzed by backstrom         namely         and  are
s
s
polynomial time compilable into each other preserving plan size exactly  in fact  a fourth class can
be added to this set  namely      which lies between   and   
s
in other words  using the notion of compilability  we get the same equivalence class as with
backstrom s esp reductions  having a closer look at the proofs in backstrom s        paper reveals that this is not surprising at all because the esp reductions he used could be reformulated as
compilation schemes  since he used a quite different notation  we will nevertheless prove this claim
from first principles 
the key idea in compiling planning formalisms with literals to formalisms that allow for atoms
only
is to consider   and    as different atoms in the new formalism  for this purpose  we introduce
 
 
y     then    is a set where each negative
copy of    further  if 
j              i e   a disjoint
 
literal    in  is replaced by     i e  
 

  
 

 

 

 
     i       fi      
 j        

if    ff
otherwise 

 

using    as the new set of atoms  one can translate state specifications and preconditions easily  in the postconditions we have to make sure that the intended semantics is taken care of  i e  
 
whenever   is added    must be deleted and vice versa 
finally  we have to deal with the problem of partial state specifications  however  this not
a problem when all effects are unconditional and the preconditions contain only atoms  in this
case  we can safely assume that all atoms with unknown truth value are false without changing the
outcome of the application of an operator  let     fi denote the completion of  with respect
to    i e  

  fi             ff  
   fi  xa

   

using this function  we can transform a partial state specification into a complete specification
without changing the outcome  i e   we get the same plans 
theorem  
exactly 

 s          s

  and  are polynomial time compilable to each other preserving plan size

proof  since   h  and z
s
s  s    it follows from propositions   and   that we only
have to show

that     in order to prove the claim 
s
let  n ffifft p be a    instance with  n fftp   we translate each operator l into
s
the operator
 
l  n   pre lbff   post lq      post lq pa
the set of all such operators is denoted by
n  ffe  ffe qff  ffz p as follows 

  
   
 s 
  ffi  
zs fft  



 

  now we can define the compilation scheme
 

 

 n   ff 
 pff
ff
ff
              ff
   a
   

w 

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

 satisfies conditions     and      all the functions can be computed in polythe scheme  obviously
nomial time  and   is a   instance 
y     then it is obvious that
let d
 

  ff dffilb       ffd ff lba
 

    n  l  ffgagaga ff l   p denote a sequence of operators corresponding to a sequence of operators

  nl  ffgagaga iff l vp   using induction on plan  length  it is easy to show that
 
 is a plan for iff  is a plan for    
i e   condition     on compilation schemes is also satisfied  this means   is in fact a compilation
let

scheme  further  since the plan size does not change  the compilation scheme preserves plan size
exactly  finally  because all functions in  can be computed in time polynomial in their arguments 
 is a polynomial time compilation scheme 
one view on this result is that it does not matter whether  from an expressivity point of view  we
allow for atoms only or for literals and it does not matter whether we have complete or partial state
specificationprovided propositional formulae and conditional effects are not allowed 
    planning formalisms with conditional effects but without boolean formulae
interestingly  the view spelled out above generalizes to the case where conditional effects are allowed  also in this case it does not matter whether only atoms or also literals are allowed and
whether we have partial or complete state specifications  in proving that  however  there are two
additional complications  firstly  one must compile conditional effects over partial state specifications to conditional effects over complete state specifications  this is a problem because the
  d ff post lb  in the definition of the function  must be tested  seccondition  dff post lq  
ondly  when compiling a formalism with literals into a formalism that allows for atoms only  the
condition m dff post lb      in the definition of  must be taken care of  for this reason  we will
prove this result in two steps 
as a first step  we show that  s can be compiled to     the problem in specifying such a
s
s
compilation scheme is that the execution of an operator l on a partial state specification leads to the

 dff post lb   
illegal state if  dff post lb   
when considering our running example  ex      things are quite obvious  when a state specification does not contain the literal or the negation of the literal that is mentioned in the effect
condition  then the illegal state specification results  for example  if a state specification does neither contain r rsm nor  rsrsm   then the result of executing m d  bac is     in the general case  however 
things are less straightforward because effect literals can be produced by more than one conditional
rule and an effect condition can consist of more than one literal 
assuming without loss of generality  using a polynomial transformation  that the effects are
all singleton sets  we have to check the following condition  either one of the conditional effects
with the same effect literal is activatedi e   the effect condition is entailed by the partial state
or all of the conditional effects with the same effect literal are blocked  i e   each effect condition
contains a literal that is inconsistent with the state specification  if this is true  the original operator
  dff post lq    otherwise the resulting state specification is inconsistent 
satisfies  dff post lb  
for example  consider the following  s operator 

l  

s
n fft q   ff     v     h bfft   ff v  v     h q  pa
   

fin ebel

the application of this operator satisfies  dff post lb  
  
  

 

 

and    are true in the state specification  or

  dff post lb 

iff either

and   are true in the state specification  or

   one of   and    is false and one of   and   is false 



in all other cases  we get m d ff post lb   
 dff post lb  and the result is the illegal state  in order
to test for this condition in a formalism with complete states we introduce four new sets of atoms 

   
   

           bff
            bff
                  bff
 
        x  for the   th conditional effect of l   ba
the atom    is true if either   or    is part of the original partial state specification  the atom
   is set true by an operator if one of the conditional effects adds   or if   does not appear as an
effect in the operator  the atom  
    is set true by an operator if one of the conditional effects deletes
  or if    does not appear as an effect in the operator  finally  atoms of the form      are added by
an action if the   th conditional effect in the  th operator is blocked by some effect condition  using
these new atoms  we could translate the above operator to

n ff  h    ffi  ff ff     v v      ff    ff   bff
     ff    ff  ff v          ff    ff  h bff
 
    ff    v        bff
     ffi    v         bff
    ff   h  v         bff
 
    v ff   v          bff
 
 v          i       bff

    x         z
 
   q  pa
let   eff    be a function that returns    or  
      if   or      respectively  is the effect of the   th
conditional effect in the  th operator  assuming now that the atoms from fi are set according to
 
their intended semantics and that the previous operator deleted all atoms from    w 
       the
 l    

following test operator checks whether the original operator would have led to an inconsistent result 
test

 

ffa        ff    iff   e  v        
 

 bdc

a

whenever we have         it means the   th conditional effect in the  th operator  which must be the
previously executed operator  was not blocked  if in addition to that the effect of this conditional
  dff post lb  in the
effect was not activated  i e       iff    is true  we would have  dff post lb   
original formalism  for this reason  we force the illegal state  conversely  if either      is true for all
 and   or if it is false for one     but   eff    is true  we would have  dff post lq     d ff post lb 
in the original formalism and do not need to force the illegal state 
 
we now could force  by using some extra literals  that after each operator l  the test operator is
applied  this would result in a compilation scheme that preserves plan size only linearly  however 
it is possible to do better than that  the key idea is to merge the test operator for the  th step into the
operator of step e  
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

 s s  is polynomial time compilable to  s  preserving plan size exactly 

 n ffifft p be a  s s  instance with   n fftp   without loss of generality  we
proof  let
assume that the postconditions of operators l    have the following form 
v f  ffgagaga ffi    h
g
v f   z bff
post l        




y
f
with     
  and    i   
lemma  



first  we introduce a number of new sets of symbols that are pairwise disjoint and disjoint from
 

   
ji  
   


 

i 

  
 

 

    
    ki
    
    i 
     

i

 
  

 
y

      bff
 z    bff
 z    bff
 z    bff
 z    bff
  ki      for the  
          for the  

th conditional effect of l

  bff
th conditional effect of l   ba

      denotes the set of primed literals  i e            i  z   
for a given set of literals 
   i e   c mv  
            w   and the function cll denotes the successor function modulo
 
mn doqpsrut   further  the functions  wv for  ff  shall be functions from v to jv   jv  such
that
 
v  bfi post l  ff
v   v
 
if     

  v  eff    
  v    v  if      v   b post l a
now let postv

l  

postv
let block v

l  

for  ff  be defined as follows

l             vv     ff  ff  v 
       ff  v v     post l  e   
              ff  ff  v  
      wff 
      post l  e bff

for  ff  be defined as
block v

l     q   ffi     v v  v     q     vxvxf   f    post l  ff    q          
 q    ffi     wv         
      post l  ffi        bff

and let testv be defined as

z
z
z
  z
v    ba
   q  d     v   ff   v    iff   e  v         v   
 
v   now we can
further  let         and  be fresh symbols not appearing in       jv   jv    
define the pair of compiled operators l v    ff    corresponding to the original operator l  w  
l v  on pre l  h     v  bff postv v l     blockv zl     testv  
   v      v ff   ffi v  b q   
   v  v    v    j    v  iff   e q x 
  
  k  
 
v   
   q   
z v   v     z v    
 
v
  
            z v    ba
 c

 y   v

   

fin ebel

this pair of compiled operators achieves the intended effects and keeps track of fully known
atoms using postv   checks which conditional effects are blocked using block v   tests whether the
  dff post lb  using
execution of the previous operator satisfied the condition  dff post lb  
testv   and setup the bookkeeping atoms for the next step  using the atoms  v   it is enforced that
executing and testing is merged by parallelizing the test on step  and execution of step     in
order to check the execution of the last step  we need an extra checking step 

l v  on    v b  ff test v      v    ff  v q    pa
now we can specify a compilation scheme  from 

   

s s to  s  as follows 
 
 
n 
 
 
fi

s

 
 

     ffi i ffi g bff
i        i        
i  
 
  l i ffil    tl     fi    l i ffil     pff
 
 
    ffi ibff        ji  
       ji           i     ff
  v bff
       
                   fft   ff  h jff  
    ff
 a

    
 b  
  ffi   
  fft  

the scheme  obviously satisfies conditions      i e   that the state translation functions are modular 
 polynomially sized results  further  all the functions
and      i e   that the compilation functions have
can be computed in polynomial time  and   is a    instance 
s
y     then it is obvious that
assume d




       x   z  ffd h   bff nl i p  ff  
     ff
  ff  t  dff nl  p   ff  
provided   t  dff nl  p        in case   t  dff nl  p f        either   t     ffd     ff nl i p    
  or m dff post l        dff post l      in the latter case  the application of any operator to
  t     ffd ff nl i p  leads to an inconsistent state because of the conditional effects in test    which
is part of all postconditions of operators applicable in this state  additionally  the same is true for
the relation between zb ffx   dff nl  ffil     and     zi ffd h    ff nl i ffil    p   
let     nl  ffgagaga ffil  p denote a sequence of operators corresponding to a sequence of operators
  nl ffgagaga ffil v p   using induction on the plan length  it can be easily shown that







iff 

is a plan for

further  since any plan solving the instance 



there exists a plan for



a  lav


is a plan for 



 

must have lav as the last operator  it follows that

iff there exists a plan for 



 

from that it follows immediately that  is a polynomial time compilation scheme from 
preserving plan size exactly  which proves the claim 

s s

to 

s

having proved that  s can be compiled to   preserving plan size exactly  it seems worth
s
s
noting that this result depends on the semantics chosen for executing conditional operators on partial state specifications  for example  if we use an alternative semantics that deletes all the literals


in    dff post lb zm dff post lb  provided  dff post lb  is consistent  then there exists probably only a compilation scheme that preserves plan size linearly  if we use a semantics where the
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

resulting state specification is legal when the application of all state transformation functions leads
to a theory that can be represented as a set of literals  it seems unlikely that there exists a scheme
that preserves plan size polynomially  the reason for this pessimistic conjecture is that under this
semantics it appears to be conp hard to determine whether the state specification resulting from
applying a  b  operator is legal 
s
as a second step in showing that partial state specifications and literals can be compiled away 
we show that we can compile   to     the key idea in the proof is the same as in the proof of
s
 
theorem    we replace each negative literal    by a new atom     in order to detect inconsistencies
introduced by conditional effects  we add to each postcondition conditional effects of the form
 
   ff     v     further  to check that the last operator in a plan does not introduce any inconsistencies 
we force the application of a checking operator that contains the same conditional effects 
lemma  

 s


is polynomial time compilable to 



preserving plan size exactly 

proof  let
  n ffifft p be a  s   instance with   n fftp   since
postconditions of all operators l  have the following form 

b

post lb    

y

vxb gff agaga ffi




 

vxb

 



is a

 s

 instance  the

 bff

with   bff  
  
 
as in the proof of theorem     shall be a disjoint copy of    and    is the set of atoms where
 
c lq be the following set
each negative literal    is replaced by the atom     now let post
post
c lb   

    v   

b

 

fi     
 

b

      vxb    fi
 

post lbe ba

further  let cons be the set of conditional effects
cons

   q   ff  h    v        bff
 

let  be an atom not appearing in    let l be

l    n  

let

 

o   m
l   tl   

pre lbff
post
c lbh  cons     

v  v  pff

  and let the operator l  be

l   n ff cons      v     pa

then we can specify a compilation scheme  from 

 q  
    
 s  
  ffi   
zs fft  

s  to   as follows 
 
 
n       v bff  
    l q  pff
      bff
  v bff
     d
    ff
   a

 satisfies conditions     and      all the functions can be computed in polythe scheme  obviously
nomial time  and   is a    instance 
   

fin ebel

assume d

y 

  then it is obvious that
 

  ff dffilb      ffd ff lbff

provided  dffilb   a

 

 

y

 

in case  dffilb        either     ffd ff lb      or    ff    
    ffd ff lb for some       in the
 
latter case  the application of any operator to     ffdff lb leads to an inconsistent state because
of the conditional
effects in cons  which is part of all postconditions 
 
let  n  l ffgagaga ff l   p denote a sequence of operators corresponding to a sequence of operators

  nl ffgagaga ffil vp   using induction on the plan length  it can be easily shown that







iff 

is a plan for

further  since any plan solving the instance 



there exists a plan for



 

 



l 

is a plan for 



 

must have l  as the last operator  it follows that

iff there exists a plan for 

it follows that  is polynomial time compilation scheme from 
which proves the claim 

s

to 





 

preserving plan size exactly 

this result is  of course  not dependent on the semantics because both formalisms deal only with
  dff post lb   
complete state specifications  and hence we always have m dff post lb   
theorem  
size exactly 

 s s     s      s

  and 



are polynomial time compilable to each other preserving plan

proof   b     follows from lemma    lemma   and proposition    using propositions  
s
and   and the fact that    s and   b  s   the claim follows 

s

s

s

   the limits of compilation when preserving plan size linearly
the interesting question is  of course  whether there are other compilation schemes preserving plan
size exactly than those we have identified so far  as it turns out  this is not the case  we will prove
that for all pairs of formalisms for which we have not identified a compilation scheme preserving
plan size exactly  such a compilation scheme is impossible even if we allow for a linear increase of
the plan size  for some pairs of formalisms we are even able to prove that a polynomial increase
of the plan size would not help in establishing a compilation scheme  these results are  however 
 fhe assumption  a preview
conditional based on an assumption that is slightly stronger than the ef g
of the results of this section is given in table    the symbol  means that there exists a compilation
scheme because the first formalism is a specialization of the second one  in all the other cases  we
specify the separation and give the theorem number for this result 
    conditional effects cannot be compiled away
first of all  we will prove that conditional effects cannot be compiled away  the deeper reason
for this is that with conditional effects  one can independently do a number of things in parallel 
which is impossible in formalisms without conditional effects  if we consider  for example  the
operator m d  zac from example    it is clear that it  propagates  the truth value of rsr m and klu h to
hqj k y k  ba nx and hbjsk klu h nx   respectivelyprovided the state specification satisfies the precondition 
   

fic ompilability



 s


 qs


 s





   


 q
j
 i

  


cor    

cor    

cor    

cor    

ji

ji

 i

theo    

cor    

cor    

ji

ji

 i

cor    

cor    

cor    

 





ji



 









cor    









theo    

 i



 

















cor    



theo    






 

cor    

 q



 s s  


cor    



 s



 

 s s k



e xpressive p ower of p lanning f ormalisms

and

 s 












cor    



 i

 

cor    



 

table    separation results

it is obviously possible to come up with a set of exponentially many operators that can do the same
thing in one step  however  it is unclear how to do that with less than exponentially many operators 
in fact  we will show that this is impossible 
in order to illustrate this point  let us generalize the above example  we start with a set of 
propositional atoms        ffgagaga ff     and a disjoint copy of this set  ml       l      fiv   
further  if


d y fi 



  then dnl shall denote the corresponding set of literals over

d
consider now the following 

 
 
 

 

 

o l

  i e  

     l       dfi         l  g     d ba
l

s s

domain structure 

fi   l ff
b
    n fft     v   l ff    v    l      wfiv  p ff
  n    ff    pa
from the construction it follows that for all pairs fft  such that  is a consistent and complete set
y  l   the instance  n  ffifft p has a one step plan  conversely  for all pairs
over fi and 

fft  with gff o l y    l   there does not exist a solution 
trying to define a   domain structure polynomially sized in         with the same property

seems to be impossible  even if we allow for   step plans  however  in trying to prove this  it turns
out that an additional condition on the state translation function is needed 
we say that the state translation functions are local iff for all state specifications
 ff    we have







    ff dpff   qff s   ffdff     a
   

d

and for

fin ebel

with locality as an additional condition on state translation functions we could easily prove that
conditional effects cannot be compiled away  instead of doing so we will show  however  that it
is possible to derive a weaker condition from the definition of compilation schemes that will be
enough to prove the impossibility result  this weaker condition is quasi locality of state translation
functions relative to a given set of symbols    which in turn is based on the notion of universal
f
literals  a literal is called a universal literal for given state translation functions on  iff one of
the following conditions is satisfied 
   for all      

f

   for all      

f

   for all      

f

   for all      

f

   for all      

f

   for all      

f

p       bfft   h     or
p       bfft    h     or
p       bffeb   or
pzs    h bfft   h     or
pzs    h bfft    h     or
pzs    h bffeb  

let r denote the set of universal literals  now we define quasi locality of state translation functions relative to a set of propositional atoms  and the induced set of universal literals r as follows 
y   such that d    and for all pairs  ff y  with  ff      we have
for each d







  y w
r a

    ff dff   sffzs   ffdfiff







in words  the only non local literals in quasi local state translation functions are the universal literals 
lemma    for a given compilation scheme f n  ffe 
y  such that   ut  and  and
exists a set of atoms 



ffe qff  ffz p and natural number 
 are quasi local on   

  there

r v be a function that has as the result the union of all results for all possible
proof  let t
translations of a literal returned by the state translation functions  i e  
gl          h bfft   h         h bfft    h         h bffeb  
s    h bfft     
  zb    h bfft    h  
  zs    h bffeba
set

  
w

and r    now we choose an infinite subset
w



of

w

such that either

   for all   xw    there are only finitely many other atoms  xw  such that  glor if such an infinite subset of w does not exist 
  

w



has a universal literal

f

fi
 r

and we set r   
r   

f

 

aff g q sur  
 

 

 
f

 r must
note that such an infinite subset w  must exist  the reason is that some literal y
occur for infinitely many atoms in over w because we could not find an infinite subset
satisfying condition      because for a single atom there are only six possible ways to generate
f
  there must exist an infinite subset such that this literal occurs in all of either v    h bfft   h    
f
v    h bfft    h     or zv    h bffeb  for   iff    and in this subset is a universal literal 
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

if we can pick a subset satisfying the first condition  we can choose from it a finite subset  with
any desired cardinality such that the state translation functions are quasi local with respect to  and
r  
otherwise we repeat the selection process with w  and r  until condition     is satisfied  this
selection process can only be repeated finitely often because otherwise there are some atoms such that tl   has an infinite result  which is impossible because the state translation functions are
polynomial time computable and can therefore have only finite results 
this demonstrates that there always exists a set of propositional atoms such that the statetranslation functions are quasi local  however  we might not be able to effectively determine this
set 
using this result  we are finally able to prove the non existence of compilation schemes for
compiling conditional effects away when preserving plan size linearly 
theorem   

 s s 

cannot be compiled to   preserving plan size linearly 

proof  assume for contradiction that there exists a compilation scheme  from  s to  q pres
serving plan size linearly  which compiles the domain structure   defined above into the  

domain structure

         on    tff    pa
because of lemma    we can assume that the set of atoms   is chosen such that the translation

functions are quasi local on this set 
let us now consider all initial state specifications  that are consistent and complete over
and do not contain only positive or only negative literals 

obviously  there are
following form

t

  t

 



k
 r  i
   fi ff fik ba

such state specifications  by assumption  each

 q

instance of the

n   ff       ffi h   b   ff      ffi l h        p
has a   step plan  since there are only  i     i  different   step plans  which is a number polyno
mial in the size of     the same plan  is used for different initial statesprovided  is sufficiently

large 
suppose that the plan  is used for the pairs t fft ff t fft    which result from  and   


   
       fi ffi  h      k
         ffi l         
      fi ffi  h      k
    zs fi ffi l     s  k

since   
        and   must differ on at least one atom  say     without loss of generality we
assume     and        since  is a successful plan from   to   and because  is modular 




it follows that

x     ffeh   

zs     l b  fft    l    a

  

   

fin ebel

some of the literals in zs    kl  bfft   klx   may be added by operators in  but none of the literals
in s     l  bfft    l    can be deleted by an operator in  without reestablishing this literal by another
operator after its deletion  because  contains only operators with unconditional effects  it adds
and deletes the same literals regardless of the initial state 
f
let us now assume that there exists a literal zs    kl  bfft   klx   that is not added by    this
f
implies that  t and we have to distinguish three cases 


     k   from which we conclude that f  t  
f
   p     k
  lx bffeb y t    which also implies that f  t  
f
   
that the state z     s bffi  with      k  l and   q   s bfftf     s bffe     because we assumed
f
translation functions are quasi local on     must be a universal literal  if is universal for

f
contain positive and negative
   then we will have it because the possible initial states
f
literals as well as no literal for some elements from     if is universal for    it is present
 f
in  and in  for the same reason  further  because is not added by  and  is a valid


plan from t to    it must also be part of of t  



f
in other words  all literals 
 s   k  lx bfft  k  lx   that are not added by  are already in t  and t  
from that we conclude that
     ffe  y s     l  bfft    l   a
  

f

now let

    
     

          l  bffi l j     l   h       ff
   
  s     l  bfft    l   
  zs    ffi l      l         l   h   b  va
because z is modular  it is clear that      and therefore   t t ffefi      because 




achieves   as well as      klx bfft   klx     it follows that  again because  is modular    achieves

also      

since n  ffi ffi l z   k
  l       e  l   p does not have any plan  there should not be any plan for
 
n   ffi  fft    p   the  fact that  is a plan for this instance implies that  cannot be a compilation
scheme  which is the desired contradiction 
using propositions   and   as well as theorem    this result can be generalized as follows  see
also table    
corollary     qs        and  
preserving plan size linearly 

s s


cannot be compiled to  q or any formalism specializing  

this answers the question of whether more space efficient compilation schemes from   to
s
 than the one proposed by gazen and knoblock        are possible  even assuming unbounded
computational resources for the compilation process  a more space efficient compilation scheme is
impossibleprovided that the compilation should preserve plan size linearly  if we allow polynomially larger plans  then efficient compilation schemes are possible  see section    
   this result demonstrates that the choice of the semantics can be very important  if we interpret conditional effects
sequentially as brewka and hertzberg        do  then there exists an straightforward compilation scheme preserving
plan size exactly 

   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

    non uniform complexity classes
in the next section we make use of so called non uniform complexity classes  which are defined
using advice taking machines  in order to prove the impossibility of a compilation scheme  an
advice taking turing machine is a turing machine with an advice oracle  which is a  not necessarily recursive  function  from positive integers to bit strings  on input    the machine loads the
bit string  i       and then continues as usual  note that the oracle derives its bit string only from the
length of the input and not from the contents of the input  an advice is said to be polynomial if the
oracle string is polynomially bounded by the instance size  further  if  is a complexity class defined in terms of resource bounded machines  e g   p or np  then j pbnm   also called non uniform
x  is the class of problems that can be decided on machines with the same resource bounds and
polynomial advice 
because of the advice oracle  the class p poly appears to be much more powerful than p  howy es pbnm 
ever  it seems unlikely that p poly contains all of np  in fact  one can prove that fje
implies certain relationships between uniform complexity classes that are believed to be very unlikely  for stating this result  we first have to introduce the polynomial hierarchy 
let x be a class of decision problems  then e  denotes the class of decision problems 
that can be decided in polynomial time by a deterministic turing machine that is allowed to use a
procedurea so called oraclefor deciding a problem    whereby executing the procedure
does only cost constant time  similarly  fje  denotes the class of decision problems  such that
 of
 in polynomial time using
there is a nondeterministic turing machine that solves all
instances



are defined as follows 
an oracle for  p   based on these notions  the sets       and










i

 

 v   

 v    

  
v 









v

v

v



 
 eff
e i  ff i

 ff
fje
ygn fje   a

thus    gfhe and

  ygnfje   the set of all classes defined in this way is called the polynomial
hierarchy  denoted by ph  note that

f   
  v i

e 


y 




v


   
 v y i


v

  
v i



y


v



 a

e sekd

further we have  
ff
and  ff
 v     as with other classes  it is unknown whether
v
v
v
v
v
the inclusions between the classes are proper  however  it is strongly believed that this is the case 
i e   that the hierarchy is truly infinite 
based on the firm belief that the polynomial hierarchy is proper  the above mentioned question
y ee pbnm  can be answered  it has been shown that fje y es pbnm  would imply
  that
of whether fje

the polynomial hierarchy collapses on the second level  karp   lipton         i e     
y yg nfhes  pb nthis 
m  or
however  is considered to be quite unlikely  further  it has been shown that fje
y
ygnfje  fj es  pbnm  implies that the polynomial hierarchy collapses at the third level  yap        
i e   
     which again is considered to be very unlikely  we will use these result for proving

that for some pairs of formalisms it is very unlikely that one formalism can be compiled into the
other one 
   the super script  is only used to distinguish these sets from the analogous sets in the kleene hierarchy 

   

fin ebel

    on the expressive power of partial state specifications and boolean formulae
in all the cases considered so far  operators over partial state specifications could be compiled to
operators over complete state specifications  i e   partial state specifications did not add any expressiveness  this is no longer true  however  if we also allow for arbitrary boolean formulae in
preconditions and effect conditions  in this case  we can decide the conp complete problem of
whether a formula is a tautology by deciding whether a one step plan exists  asking  for example 
if the  q  instance n fft  nff kpe bffefft  v  p has a plan is equivalent to asking whether  is a tautology 
let the one step plan existence problem    planex  be the planex problem restricted to
plans of size one  from the above it is evident that  qb    planex and  q    planex are
conp hard  let   be some fixed polynomial  then the polynomial step plan existence problem
    planex  is the planex problem restricted to plans that have length bounded by      if  is
the size of the planning instance  as is easy to see  this problem is in np for all formalisms except
 qb and  q   the reason is that after guessing a sequence of operators and state specifications of
polynomial size  one can verify for each step in polynomial time that the precondition is satisfied
by the current state specification and produces the next state specification  since there are only
polynomially many steps  the overall verification takes only polynomial time 
proposition         planex can be solved in polynomial time on a nondeterministic turing machine for all formalisms different from  s and  q  
from the fact that      planex is conp hard and  e g    s  p planex is in np  it follows
almost immediately that there is no polynomial time compilation scheme from  q to    that
 ygnfje    however  even if we allow for unbounded
preserves plan length polynomially  if fhe 
computational resources of the compilation process  a proof technique first used by kautz and sel
  
man        can be used to show that such a compilation scheme cannot exist  provided    



theorem   

 q

cannot be compiled to    preserving plan size polynomially  unless 



  

 

 

proof  let  be a propositional formula of size  in conjunctive normal form with three literals per
clause  as a first step  we construct for each  a   domain structure   with size polynomial in 
and the following properties  unsatisfiability of an arbitrary  cnf formula  of size  is equivalent
to   step plan existence for the       planex instance n  ffi  fft     p   where   can be computed
in polynomial time from   
given a set of  atoms  denoted by    we define the set of clauses  to be the set containing
all clauses with three literals that can be built using these atoms  the size of   is        i e  
polynomial in    let   be a set of new atoms  e      corresponding one to one to the clauses
in    further  let 
b

    f   f   f  m              f  ff f  ff f   m a
we now construct a   domain structure    n fivfftkp for all formulae of size  as follows 

 
 




 

 

      v bff
  n    v bfft  v  pe ba


   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

let  be a function that determines for all  cnf formulae    which atoms in   correspond to the
clauses in the formula   i e  

                  f  ff f  ff f      ba
now  the initial state for any particular formula  of size  is computed as follows 
  h  h    m   h     v ba
 
from the construction  it follows that there exists a one step plan for n   fft ffi  fft  v  p


iff



is

unsatisfiable 
let us now assume that there exists a compilation scheme  from  q to    preserving plan
size polynomially  further  let us assume that the   domain structure   is compiled to the   
domain structure    n fi fft p   using this compiled domain structure  we can construct the
following advice taking turing machine 
on input of a formula  of size    we load the advice n  ffe     fftffe     fft p   this
advice is polynomial because   is polynomial in the size of  and a compilation scheme generates
only polynomially larger domain structures  because  is a polynomial time function and   can
be computed from  in polynomial time  we can compute

   
     ffi       b   fft  
in polynomial time  also the goal specification

        fft  v         fft  
can be computed in polynomial time  finally  we decide the    planex problem on the resulting
    instance n  ffi  fft  p   from proposition    we know that this can be done in polynomial time

on a nondeterministic turing machine 
because deciding    planex for n  ffi  fft  p is equivalent to deciding   planex for
n  ffi  fft  v  p   which is in turn equivalent to deciding unsatisfiability of    it follows that we can
decide a conp complete problem on a nondeterministic  polynomial advice taking turing machine
y fhe  pbnm    using yap s        result  the
in polynomial time  from that it follows that ygnfje
claim follows 
using proposition   and proposition    the above result generalizes as follows  see also table    

corollary     qs and   cannot
be
  compiled to any of the other planning formalisms preserving

 
plan size polynomially  unless   





if we restrict the form of the formulae  however  we may be able to devise compilation schemes
from  q to  e g       reconsidering the proof of the last theorem  it turns out that it is essential
to use the negation of a cnf formula as a precondition  if we restrict ourselves to cnf formulae
in preconditions  it seems possible to move from partial to complete state descriptions using ideas
similar to the ones used in the proof of lemma   
however  no such compilation scheme will work for  s   the reason is the condition
 dff post lb     dff post lb  in the definition of the function    if this condition is not satisfied  the result of the operator is inconsistent  this condition could be easily employed to reduce
unsatisfiability of cnf formulae to   step plan existence  which enables us to use the same technique as in the proof of the above theorem 
   

fin ebel

    circuit complexity
for the next impossibility result we need the notions of boolean circuits and families of circuits 
a boolean circuit is a directed  acyclic graph    ff   where the nodes  are called gates 
each gate  
 has a type k   k  fifffiff
 ff ffi  f   ff ffgagaga     the gates with k   k
 
 sffiff  ff  ffgagaga   have in degree zero  the gates with k   k    have in degree one  and the
gates with k   k  
fiff  have in degree two  all gates except one have at least one outgoing
edge  the gate with no outgoing edge is called the output gate  the gates with no incoming edges
are called the input gates  the depth of a circuit is the length of the longest path from an input gate
to the output gate  the size of a circuit is the number of gates in the circuit 
given a value assignment to the variables   
output gate in the obvious way  for example  for 
gate of the circuit shown in figure   

 ff   ffgagaga    the circuit computes the value of the
    and     we get the value   at the output







 



figure    example of a boolean circuit

instead of using circuits for computing boolean functions  we can also use them for accepting

words of length  in   ff       a word   h agaga   ff    is now interpreted as a value

assignment to the  input variables  ffgagaga ff  of a circuit  the word is accepted iff the output gate

has value   for this word  in order to deal with words of different length  we need one circuit for
each possible length  a family of circuits is an infinite sequence   o  ff  ffgagagaw   where  has

 input variables  the language accepted by such a family of circuits is thei set of words  such that
    accepts   
usually  one considers so called uniform families of circuits  i e   circuits that can be generated
on a turing machine with a pk   space bound  sometimes  however  also non uniform families are
interesting  for example  the class of languages accepted by non uniform families of polynomiallysized circuits is just the class p poly introduced in section     
using restrictions on the size and depth of the circuits  we can now define new complexity
classes  which in their uniform variants are all subsets of p  one class that is important in the
following is the class of languages accepted by uniform families of circuits with polynomial size
and logarithmic depth  named nc    another class which proves to be important for us is defined
in terms of non standard circuits  namely circuits with gates that have unbounded fan in  instead of
restricting the in degree of each gate to be two at maximum  we now allow an unbounded in degree 
the class of languages accepted by families of polynomially sized circuits with unbounded fan in
and constant depth is called aci  
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

y

from the definition  it follows almost immediately that ac i
nc    moreover  it has been
shown that there are some languages in nc  that are not in the non uniform variant of aci   which
implies that ac i    nc   furst  saxe    sipser        
    boolean formulae cannot be compiled to conditional effects
as we have seen in section      boolean formulae are quite expressive if they are used in combination with partial state specifications  however  what if all state specifications are complete  in
this case  it seems to be possible to simulate the evaluation of cnf formulae by using conditional
effects  in fact  it is possible to compile in polynomial time  for example    to   preserving plan
s
size linearly  provided all formulae are in conjunctive normal form  each operator would have to
be split into two operators  one that evaluates the clauses of all the formulae in the original operator
and one that combines these evaluations and takes the appropriate actions  e g   asserting   if the
precondition is not satisfied  sequencing of these pairs of operators can be achieved by introducing
some extra literals 
what can we say about the general case  however  when trying to simulate the evaluation of
an arbitrary logical formula using conditional effects  it seems to be the case that we need as many
operators as the nesting depth of the formula  which means that we would need plans that cannot be
bounded to be only linearly longer than the original plans 
we will use the results sketched in section     to separate   and     in order to do so  let us
s
view domain structures with fixed size plans as machines that accept languages  for all words 
consisting of  bits  let

  on fi      bfftvpa
assume that the atoms in fi are numbered from   to    then a word 

consisting of  bits could

be encoded by the set of literals

  
        

if the  th bit of  is

  fi          if the  th bit of  is k ba

conversely  for a consistent state specification d fi   let   be a word such that the  th bit is   iff
    d  
we now say that the   bit word  is accepted with a one step or   step plan by   iff there
exists a one step or   step plan  respectively  for the instance

  n n fi     v bfftkpffi        v bfft      pa
similarly to families of circuits  we also define families of domain structures    ffe ffgagaga  

i
the language accepted by such a family with a one step  or   step  plan is the set of words accepted
using the domain structure   for words of length    borrowing the notion of uniformity as well 
we say that a family of domain structures is uniform if it can be generated by a pk  space turing
machine 
papadimitriou has pointed out that the languages accepted by uniform polynomially sized
boolean expressions is identical to nc   papadimitriou        p        as is easy to see  a family of   domain structures is nothing more than a family of boolean expressions  provided we use
one step plans for acceptance 
proposition    the class of languages accepted by uniform families of   domain structures using
one step plan acceptance is identical to nc   
   

fin ebel

if we now have a closer look at what the power of   step plan acceptance for families of  
s
domain structures is  it turns out that it is less powerful than nc    in order to show that  we will first
prove the following lemma that relates   step   plans to circuits with gates of unbounded fan in 

s

y

lemma    let f  n fftp be a   domain structure  let 
    and let  be a   step plan over
s
   then there exists a polynomially sized boolean circuit  with unbounded fan in and depth   fit
such that  is a plan for n ffifft p iff the circuit  has value   for the input   
proof  the general structure of a circuit for a   step



 
 
 



plan is displayed in figure    for each







 

 

     



 
 
 

 
 
 



 
 
 

 

 s







 

 
 
 

     



      s





figure    circuit structure and goal testing for a   step 

s

plan

 

plan step  or level    and each atom      there is a connection      the connections on level  are
the input gates  i e     i      the goal test is performed by an 
  gate that checks that all the goals
are true on level    in our case      ff   ff       further  using the   gate  it is checked that no
 
inconsistency was generated when executing the plan 
for each plan step     it must be computed whether the precondition is satisfied and what the
result of the conditional effects are  figure    a  displays the precondition test for the precondition
     ff   ff        if the conjunction of the precondition literals is not true    v becomes true  which is
connected to the   gate in figure   
without loss of generality  using a polynomial transformation   we assume that all conditional
vgf   whether the effect f is activated on level   is computed by a circuit as
effects have the form 
v      
displayed in figure    b   which shows the circuit for     ff    
 
finally  all activated effects are combined by the circuit shown in figure    c   for all atoms     
we check whether both    and     have been activated  which would set   true  this is again one
of the inputs of the   gate in figure    if neither    nor     have been activated  the value of    on
level  n is determined by the value of    on level     otherwise the value of    on level   is
 
determined by the value of  w   i e   the activation value of the positive effect    on level    
the depths of the circuits in figure    b  and  c  dominate the depth of the circuit necessary to
represent one plan step leading to the conclusion that a plan step can be represented using a circuit
of depth    adding the depth of the goal testing circuit  the claim follows 
the lemma implies that    step plan acceptance is indeed less powerful than     step plan
s
acceptance  which means that a compilation scheme from   to   preserving plan size linearly is
s
impossible 
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms


 



 


 z 



 

 




   







s








  

  



 a 



 



 

 z 

 b 



 z 

 



 c 

figure    circuit structure for precondition testing  a   conditional effects  b   and the computation
of effects  c  for   operators

s

theorem   

   i 

  for all members



s s

of the 

 class 

proof  we show that     i     from which by theorem   and proposition   the claim follows 
s
assume for contradiction that    i     let    ffe ffgagaga be a uniform family of  
s

i
domain structures and     ffe  ffgagagaw be the   domain structures generated by a compilation
s

i
scheme  that preserves plan size linearly  by lemma    we know that for each   domain
s
structure     n   fft  p and given goal   we can generate a polynomially sized  unbounded fanin circuit with depth  t that tests whether a particular   step plan achieves the goal  in order to
decide   step plan existence  we must test  i     ie different plans  which is polynomial in the size
of   because  is a compilation scheme  for each plan  we can generate one test circuit  and by
adding another   gate we can decide   step plan existence using a circuit with depth  w and size
polynomial in the size of     further  since the state translation functions are modular  the results
of  for fixed  can be computed using an additional level of gates  since by proposition    all
languages in nc  are accepted by uniform families of   domain structures using one step plan
acceptance  our assumption   i   implies that we can accept all language in nc  by  possibly
s
non uniform  aci circuits  which is impossible by the result of furst and colleagues        
using the propositions   and   again  we can generalize the above theorem as follows 
corollary   

  

and 



cannot be compiled to



 s b a

or



 s  

preserving plan size linearly 

   compilability preserving plan size polynomially
as has been shown in the previous section  only the compilation schemes induced by propositions  
and   and the ones identified in section   allow for compilation schemes preserving plan size exactly  for all other pairs of formalisms we were able to rule out such compilation schemeseven
   

fin ebel

if we allow linear growth of the resulting plans  nevertheless  there might still be a chance for
compilation schemes preserving plan size polynomially  having shown that  qs and  q cannot
be compiled to the other formalisms even if the plan can grow polynomially  we may still be able
to find compilation schemes preserving plan size polynomially for the  qs    pair and for the
remaining formalisms 
a preview of the results of this section is given in figure    as it can be seen  we are able

   

  

  

 

  

 b

  

 

 



 


figure    equivalence classes of planning formalisms created by polynomial time compilation
schemes preserving plan size polynomially  compilation schemes constructed in this
section are indicated by dashed lines

to establish compilation schemes preserving plan size polynomially for all pairs of formalisms for
which we have not proved the impossibility of such compilation schemes 
    compiling conditional effects away for partial state specifications
the first compilation scheme we will develop is one from  qs to  q   as before  we assume that
the conditional effects have only singleton effect sets  further  since we can use arbitrary boolean
formulae in the effect conditions in  qs   we assume that there is only one rule for each effect literal 
using a simple polynomial transformation  arbitrary sets of operators can be brought into this form 
  dff post lb  considerably  because now
this simplifies checking the condition  dff post lb  
only one rule can activate a particular literal 
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

in order to simulate the parallel behavior of conditional effects  we have to break them up into
individual operators that are executed sequentially  this means that for each conditional effect of
an operator we introduce two new operators  one simulates the successful application of the rule 
the other one simulates the blocking situation of the rule  at least one of these operators must
be executed for each conditional effect in the original operator  this is something we can force
by additional literals that are added to control the execution of operators  all in all this leads to a
sequence of operators that has length bounded by the number of conditional effects in the original
operator 
if we want to simulate the parallel behavior by a sequence of unconditional operators  the effects
of the unconditional operators should not directly influence the state description  but the effect
should be deferred until all operators corresponding to the set of conditional effects have been
executed  for this reason  we will use a sequence of copying operators which copy the activated
effects to the state description after all conditional operators have been executed  these copying
operators can also be used to check that the set of activated effects is consistent 
theorem   

 qs

can be compiled to 

q

in polynomial time preserving plan size polynomially 

proof  assume that   n fftp is the  qb source domain structure and assume further  without
loss of generality  using a polynomial transformation   that all operators have the form

l    n pre l  fft      vxf    ffgagaga ffe     vgf    fiz  pff
f
f
f
with                 and         for x
    
v
let   and    be disjoint copies of    which are used to record the active effects of conditional
be another disjoint copy  which is used to record that an active effect has not
effects  and let 
l
been copied yet  further  let m
 j        zlw   be a new set of atoms corresponding one to one to
 
the operators in  and let be a set of symbols corresponding one to one to all conditional effects
in    i e  
 
v f       post l  ffil     ba
              x
finally  let  be a fresh atom not appearing in            
   that signals that copying
l
the active effects to the state specification is in progress  the set of symbols   for the compiled
domain structure is then

   f      
 

  
l

  m 

 

      ba

for each operator l     the compilation scheme introduces a number of new operators  the
first operator we introduce is one which checks whether the conditional effects of the previous
operators have all been executed  no copying is in progress and the precondition is satisfied  if this
is the case  the execution of the conditional effects for this operator is started 

l pre
   n pre l  h  


 

       bff     b               

   
l

pa

this operator enables all the conditional effect operators  for the activated effects  we introduce
the following operators 

lk       
  n     b 
     q bff                 ffl

   

 z    f               ff l

      f      pa

fin ebel

in words  if the effect condition is entailed  then the activated positive or negative effect as well as
the fact that the rule has been tried is recorded 
since there is at most one effect literal for each conditional effect  a conditional effect is
blocked if the negation of the  effect condition is entailed by the state specification  for all
blocked conditional effects we introduce the following operators 

l      
  n     b 
       bff          pa

in order to check that all conditional effects have been tried  activating the corresponding effect
or not activating it because the conditional effect is blocked   the following operator is used 

l  o
  n     bb fi        

 

      vgf     

post l

 e bff             bb  pa

this operator enables copying of the activated effects to the state specification  which is achieved
with the following set of operators for each atom      


l

l
l



 
 


 

 

n    ff   ff     ff  l b  fft   ff   l    pff
n    ff   ff    ff  l b  fft    ff   l    pff
n    ff   ff    ff  l  bff
  pa

finally  we need an operator that checks that all possible effects have been copied  this operator
also starts the execution cycle again by enabling the execution of another precondition operator 

li  
  n         
l

ff       pa

using these definitions  we can now specify the set of compiled operators 

pre

     l  ffil   l        vhf
  l        l   ff      vxf     fi post l  e   
  l         l     ff     
      post l  e   
  l  ffil   ffil      w fi 
  lait ba
based on that  we specify a compilation scheme  on  ffe zffe  ff zff  p as follows 
     n   fft  p
 
 b         
     l                bff
 s    m
        bff
  ffi    ff
zs fft    a
the scheme  obviously satisfies conditions     and    
 for compilation schemes
 and all the functions can be computed in polynomial time  further    is a  q  instance if is a   s  instance 
let now d   be a legal  s state specification and let d     dffil   for some operator
it is clear that if d      then there exists a sequence  of
l x   from the above discussion 
     and l      followed
pre
operators from   consisting of l    followed by operators of the form l 


by the operator l    followed in turn by operators l    followed finally by the operator l i   such that
d     t  d     ffe  s fff a
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

conversely  if d         then there does not exist any plan that transforms

 d    bffil pre
 
into a legal state specification that contains   and    b  
using
 induction on the plan length  it follows from the arguments above that there exists a plan
 for iff there exists a plan  for   and for every such plan we have       v        m 
t      with  
being the maximum number of conditional effects in operators of    hence  is a
polynomial time compilation scheme preserving plan size polynomially 
an immediate consequence of this theorem is that  s and  q form an equivalence class with
respect to compilability preserving plan size polynomially 
corollary   
polynomially 

 qs

and

 

are polynomial time compilable to each other preserving plan size

further  we know from corollary    that this class cannot become larger 
as in the case of compiling  s to     however  the result depends on the semantics chosen
s
s
for executing conditional effects over partial state specifications  if we use the alternative semantics where the resulting state specification is legal when the application of all state transformation
functions leads to a theory that can be represented as a set of literals  it seems likely that there exists
another scheme that preserves plan size polynomially  however  if we use the alternative semantics


that deletes all the literals in    dff post lb  i dff post lb  if  dff post lb is consistent  then it
appears to be very unlikely that we are able to identify a compilation scheme that preserves plan
size polynomially 
    compiling conditional effects away for complete state specifications
the next compilation scheme compiles    to   and   to    since we deal with complete state
s
s
  d ff post lb    which
specification  we do not have to take care of the condition m d ff post lb m 
is always true for complete states  this makes the compilation scheme somewhat simpler  since
 s does not allow for general boolean formulae  the scheme becomes a little bit more difficult  in
general  however  the compilation scheme we will specify is very similar to the one given in the
proof of theorem    
theorem       can be compiled to
serving plan size polynomially 

 

and 

s

can be compiled to 

s

in polynomial time pre 

proof  as in the proof of theorem     we assume that   n fftp is the     or
domain structure  further  we assume that all operators have the form

v f    b  pff
l    n pre l  fft  u    vxf    ffgagaga ff u     x
f
u y   if  is a    structure or u     y   if  is a  
with    m   and    
s

 s

  source

structure  this means
that we do not assume the effects to be unique for each conditional effect 
in addition  we assume the same set symbols for the compiled domain structure as in the proof
of theorem    

   f      

 

  

   

l

  m 

 

      ba

fin ebel



pre
for each operator l     we introduce the operators l    l    l
theorem    
in addition  the following operators are needed 


lk       
l      e    

  l


 

 l




n     bb    u     ff       q fi       ff   l       f              ff n     bb           e   t    e   u     bff          pa

  and l

l

i

as in the proof of

      f      pff

the
compiled set of operators  contains all of the above operators and the compilation scheme is

identical to the scheme presented in the proof of theorem     this means that the only significant
difference to the compilation scheme presented in the proof of theorem    is the operator scheme
l      e   which tests for each rule whether it contains an effect condition that blocks the rule  since
we have complete state specifications  every conditional effect is either activated or blocked  and
the       s are used to record that the execution of each conditional effect has been tried 
using now similar arguments as in the proof of theorem     it follows that this compilation
scheme is indeed a scheme that leads to the claim made in the theorem 


it follows that  s and   are equivalent with respect to   and all formalisms in   s  and
s

    are equivalent with respect to     these two sets could be merged into one equivalence class 
s
provided we are able to prove that  e g     can be compiled to   

s

    compiling boolean formulae away
in section     we showed that it is impossible to compile boolean formulae to conditional effects if
plans are only allowed to grow linearly  however  we also sketched already the idea of a compilation
scheme that preserves plan size polynomially  here we will now show that we can compile boolean
formulae to    which is expressively equivalent to basic strips  i e   we can compile boolean
s
formulae away completely 
theorem   

 

is polynomial time compilable to 

s

preserving plan size polynomially 

proof  assume that f on fftp is a   domain structure  further assume without loss of generality
y   and       i e   we have just
that all operators l    are of the form l   on  ffi  p   with  
one formula as the precondition instead of a set of formulae  
let m and   be two new sets of atoms corresponding one to one to all sub formulae occurring in preconditions of operators in    these new atoms are denoted by    and     for the
sub formula    atoms of the form    are used to record that the truth value of the sub formula 
has been computed and the atoms of the form    are used to store the computed truth value 
for each operator l    n  ffi  p   we will have in the target operator set the following operator 

l   on    q ffi  b   bffi       pa
the set of all operators generated in this way is denoted by    
further  for each atom       we introduce the following two operators 

l 
l



 

 

 

n     bff       ffi     pff
n     h bff       ff      pa

the set of operators generated in this way is denoted by
   

 

 

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

for each sub formula occurring in preconditions of
operators are introduced 

l 

l   
l     
for sub formulae j 

 
 
l  
l  
l  

of the form  

 
p 

the following

n       ffi    ffi    ffi    b  fft     ffi    pff
n       ff      bfft     ff    h  pff
n       ff       bfft     ff    h  pa
 

 



   the following operators are introduced 
  n       ffi      bfft     ffi     pff
  n       ffi      bfft     ffi     pff
  n       ffi    ff      ff       bfft     ff    h  pa

finally  for j     we have the following operators 

l 
l



 

 

 

n       ff      bfft     iff     pff
n       iff     bfft     ff      pa

the set of operators generated by sub formulae is denoted by
now we can specify the compilation scheme   

  
   
 b 
  ffi  
s fft  



 

 n   m     ff         u pff
  ff
  ff
ff
 a

from the construction it is obvious that all the functions are polynomial time computable  that

 the induced function  is a reduction 
and that for
the state translation functions are modular  that
every plan  for a source planning instance there exists a plan  for   such that       
               with   being the maximum number of sub formulae of preconditions in    from
that  the claim follows 
there might be the question whether compiling boolean formulae away could be done more
efficiently  using the result that boolean expressions can be evaluated by circuits with logarithmic
depth  this should be indeed possible  however  we are satisfied here with the result that there is
a compilation scheme preserving plan size polynomially at all  this result together with theorem    settles the question for compilation schemes preserving plan size polynomially for all pairs
of formalisms 
corollary    all formalisms  with  
s
each other preserving plan size polynomially 

s

or

   

   

are polynomial time compilable to

fin ebel

    parallel execution models and the feasibility of compilation schemes preserving plan
size polynomially
while compilation schemes that preserve plan size exactly or linearly seem to be of immediate use 
a polynomial growth of the plan appears to be of little practical interest  considering the practical
experience that planning algorithms can roughly be characterized by their property of how many
steps they can plan without getting caught by the combinatorial explosion and the fact that this
number is significantly smaller than      polynomial growth does not seem to make much sense 
if we take graphplan  blum   furst        into consideration againthe planning system
that motivated our investigation in the first placeit turns out that this system allows for the parallel
execution of actions  although parallel execution might seem to add to the power of the planning
system considerably  it does not affect our results at all  if a sequential plan can solve a planning
instance with  steps  a parallel plan will also need at least  actions  nevertheless  although the size
of a plan  measured in the number of operations  might be the same  the number of time steps may
be considerably smallerwhich might allow for a more efficient generation of the plan  having a
look at the compilation scheme that compiles conditional effects away  it seems to be the case that
a large number of generated actions could be executed in parallelin particular those actions that
simulate the conditional effects 
however  the semantics of parallel execution in graphplan is quite restrictive  if one action
adds or deletes an atom that a second action adds or deletes or if one action deletes an atom that
a second action has in its precondition  then these two actions cannot be executed in parallel in
graphplan   with this restriction  it seems to be impossible to compile conditional effects away
preserving the number of time steps in a plan  however  a compilation scheme that preserves the
number of time steps linearly seems to be possible  instead of such a compilation scheme  the
approaches so far either used an exponential translation  gazen   knoblock        or modified the
graphplan  algorithm in order to handle conditional effects  anderson et al         koehler et al  
      kambhampati et al          these modifications involve changes in the semantics of parallel
execution as well as changes in the search procedure  while all these implementations are compared
with the straightforward translation gazen and knoblock        used  it would also be interesting
to compare them with a compilation scheme based on the ideas spelled out in theorem    as the
base line 

   summary and discussion
motivated by the recent approaches to extend the graphplan algorithm  blum   furst        to
deal with more expressive planning formalisms  anderson et al         gazen   knoblock       
kambhampati et al         koehler et al          we asked what the term expressive power could
mean in this context  one reasonable intuition seems to be that the term expressive power refers
to how concisely domain structures and the corresponding plans can be expressed  based on this
intuition and inspired by recent approaches in the area of knowledge compilation  gogic et al        
cadoli et al         cadoli   donini         we introduced the notion of compilability in order to
measure the relative expressiveness of planning formalisms  the basic idea is that a compilation
scheme can only transform the domain structure  i e   the symbol set and the operators  while the
initial state and the goal specification are not transformedmodulo some small changes necessary
for technical reasons  further  we distinguish compilation schemes according to whether the plan
in the target formalism has the same size  up to an additive constant   a size bounded linearly by the
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

size of the plan in the source formalism  or a size bounded polynomially by the original planning
instance and the original plan 
although the compilability framework appears to be a straightforward and intuitive tool for
measuring the expressiveness of planning formalisms  it is possible to come up with alternative
measures  backstrom         for instance  proposed to use esp reductions  which are polynomial
many one reductions on planning problems that preserve the plan size exactly  however  requiring
that the transformation should be polynomial time computable seems to be overly restrictive  in
particular  if we want to prove that one formalism is not as expressive as another one  we had better
proven that there exists no compilation scheme regardless of how much computational resources
the compilation process may need  furthermore  there appear to be severe technical problems to
using backstrom s        framework for proving negative results  on the other hand  all of the
positive results reported by backstrom are achievable in the compilation framework because the
transformations he used are in fact compilation schemes  taking all this together  it appears to be
the case that the compilation framework is superior from an intuitive and technical point of view 
another approach to judging the expressiveness of planning formalisms has been proposed by
erol and colleagues               they measure the expressiveness of planning formalisms according to the set of plans a planning instance can have  while this approach contrasts hierarchical task
network planning nicely with strips planning  it does not help us in making distinctions between
the formalisms in the   family 
the compilability framework is mainly a theoretical tool to measure how concisely domain
structures and plans can be expressed  however  it also appears to be a good measure of how
difficult planning becomes when a new language feature is added  polynomial time compilation
schemes that preserve the plan size linearly indicate that it is easy to integrate the feature that is
compiled away  one can either use the compilation scheme as is or mimic the compilation scheme
by extending the planning algorithm  if only a polynomial time compilation scheme leading to a
polynomial growth of the plan is possible  then this is an indication that adding the new feature
requires most probably a significant extension of the planning algorithm  if even a compilation
scheme preserving plan size polynomially can be ruled out  then there is most probably a serious
problem integrating the new feature 
using this framework  we analyzed a large family of planning formalisms ranging from basic
strips to formalisms with conditional effects  boolean formulae  and incomplete state specifications  the most surprising result of this analysis is that we are able to come up with a complete
classification  for each pair of formalisms  we were either able to construct a polynomial time
compilation scheme with the required size bound on the resulting plans or we could prove that compilation schemes are impossibleeven if the computational resources for the compilation process
are unbounded 
in particular  we showed for the formalisms considered in this paper 






incomplete state specifications and literals in preconditions can be compiled to basic strips
preserving plan size exactly 
incomplete state specifications and literals in preconditions and effect conditions can be compiled away preserving plan size exactly  if we have already conditional effects 
and there are no other compilation schemes preserving plan size linearly except those implied
by the specialization relationship and those described above 
   

fin ebel

if we allow for polynomial growth of the plans in the target formalism  then all formalisms not
containing incomplete state specifications and boolean formulae are compilable to each other  incomplete state specifications together with boolean formulae  however  seem to add significantly
to the expressiveness of a planning formalism  since these cannot be compiled away even when
allowing for polynomial growth of the plan and unbounded resources in the compilation process 
it should be noted  however  that some of these results hold only if we use the semantics for
conditional effects over partial state specifications as spelled out in section      for other semantics 
we may get slightly different results concerning the compilability of conditional effects over partial
states 
one question one may ask is what happens if we consider formalisms with boolean formulae
that are syntactically restricted  as indicated at various places in the paper  restricted formulae 
such as cnf or dnf formulae  can sometimes be easily compiled away  however  there are also
cases when this is impossible  for example  it can be shown that cnf formulae cannot be compiled
to basic strips preserving plan size linearly  nebel         which confirms backstrom s       
conjecture that cnf formulae in preconditions add to the expressive power of basic strips 
another question is how reasonable our restrictions on a compilation scheme are  in particular 
one may want to know whether non modular state translation functions could lead to more powerful
compilation schemes  first of all  requiring that the state translation functions are modular seems
to be quite weak considering the fact that a compilation scheme should only be concerned with
the domain structure and that the initial state and goal specification should not be transformed at
all  secondly  considering the fact that the state translation functions do not depend on the operator
set  more complicated functions seem to be useless  from a more technical point of view  we need
modularity in order to prove that conditional effects and boolean formulae cannot be compiled away
preserving plan size linearly  for the conditional effects  modularity or a similar condition seems
to be crucial  for the case of boolean formulae  we could weaken the condition to the point that
we require only that state translation functions are computable by circuits of constant depthor
something similar  in any case  the additional freedom one gets from non modular state translation
functions does not seem to be of any help because these functions do not take the operators into
account  nevertheless  it seems to be an interesting theoretical problem to prove that more powerful
state translation functions do not add to the power of compilation schemes 
although the paper is mainly theoretical  it was inspired by the recent approaches to extend
the graphplan algorithm to handle more powerful planning formalisms containing conditional
effects  so  what are the answers we can give to open problems in the field of planning algorithm
design  first of all  gazen and knoblock s        approach to compiling conditional effects away
is optimal if we do not want to allow plan growth more than by a constant factor  secondly  all of
the other approaches  anderson et al         kambhampati et al         koehler et al         that
modify the graphplan algorithm are using a strategy similar to a polynomial time compilation
scheme preserving plan size polynomially  for this reason  these approaches should be compared
to a pure compilation approach using the ideas from the compilation scheme developed in the
proof of theorem    as the base line  thirdly  allowing for unrestricted boolean formulae adds
again a level of expressivity because they cannot be compiled away with linear growth of the plan
size  in fact  approaches such as the one by anderson and colleagues        simply expand the
formulae to dnf accepting an exponential blow up  again  we cannot do better than that if plan
size should be preserved linearly  fourthly  if we want to add partial state specifications on top of
general boolean formulae  this would amount to an increase of expressivity that is much larger than
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

adding conditional effects or general formulae to basic strips  because in this case there is no way
to compile this away even if we allow for polynomial plan growth 
finally  one may wonder how our results apply to planning approaches that are based on translating  bounded  planning problems to propositional logic such as satplan  kautz   selman       
or blackbox  kautz   selman         since the entire analysis of the relative expressiveness of
planning formalisms uses the assumption that we compile from one planning formalism to another
planning formalism  the results do not tell us anything about the size of representations if we switch
to another formalism  in particular  it seems possible to find an encoding of  bounded  planning
problems with conditional operators in propositional logic which is as concise as an encoding of
unconditional operators  the only advice our results give is that such a concise encoding will not
be found by first translating conditional actions to unconditional actions and then using the standard encoding for unconditional actions  kautz  mcallester    selman        to generate boolean
formulae  however  addressing the problem of determining the conciseness of representation in this
context appears to be an interesting and relevant topic for future research 

acknowledgments
the research reported in this paper was started and partly carried out while the author enjoyed being
a visitor at the ai department of the university of new south wales  many thanks go to norman
foo  maurice pagnucco  and abhaya nayak and the rest of the ai department for the discussions
and cappuccinos  i would also like to thank birgitt jenner and jacobo toran for some clarifications
concerning circuit complexity 

appendix a  symbol index
symbol

explanation
cardinality of a set
size of an instance
symbol used in conditional effects

syntactic specialization relation

compilability relation with restriction  and 

boolean constant denoting falsity  also denoting
 
the illegal state specification

    boolean constant denoting truth
 ll
    advice function
lff ll
        
active effects of an operator in a state or state specification
ac i
    complexity class

    boolean circuit
    family of boolean circuits

conp
    complexity class
conp poly     non uniform conp
closing a set of literals w r t  
     ll    
 
    plan  i e   sequence of operators
    complexity class in the polynomial hierarchy
 

    instance of a problem

 l 
v    l   

page
   
   
   
   
   
   

   

fin ebel




ll
  ffe  ffe 
u


f ffeff


 ff b
 
e ghll
nc 
      ll
np
np poly

l




  ffi ff ff  ff
 l 
ff ll
p
p poly
ph

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

   
   
   
   
 ll
planex
   
post
   
pre
   

pspace
   
 
   
   

   
lff ll
  t lff ll    
c
   
d
   

   
   
 s
 
   
   
 
 
   
 
   
   
  s 
s
  
   
s
   ll
   

   

initial state description
compilation scheme     n  ffe  ffe qff  ffz p  
transformation induced by compilation scheme
components of a compilation scheme
goal of a planning task
set of boolean formulae
boolean formulae
literal
sets of literals
all boolean formulae that use atoms from 
set of all models of a theory
complexity class
negative literals in a set of literals
complexity class
non uniform np
operator     n pre ff post p  
set of operators
set of finite sequences of operators
propositional atoms
potentially active effects of an operator
for a given state specification
complexity class
non uniform p
the polynomial hierarchy
positive literals in a set of literals
plan existence problem
postconditions of an operator
preconditions of an operator
complexity class
planning instance    on ffifft p  
complexity class in the polynomial hierarchy
maps a state specification and an operator to a new state
extension of lff ll to plans
state  or truth assignment 
state specification
the strips planning formalism
strips with literals in preconditions
strips with boolean formulae in preconditions
strips with incomplete state descriptions
strips with conditional effects
strips with combinations of the above extensions
equivalence classes induced by  
equivalence classes induced by   
all propositional atoms used in a set of literals
countably infinite set of propositional atoms
   

fic ompilability







r

 
 ffz



x

  




   
   
   
   
   
   
   
   
   
   

and

e xpressive p ower of p lanning f ormalisms

finite subset of 
set of literals overs 
complexity class in the polynomial hierarchy
state translation functions in a compilation scheme
universal literals
a word over   ff   t
some complexity class
some planning formalisms
domain structure    on fftp  
family of domain structures

references
anderson  c  r   smith  d  e     weld  d  s          conditional effects in graphplan  in proceedings of the  th international conference on artificial intelligence planning systems  aips     pp        aaai press  menlo park 
baader  f          a formal definition for expressive power of knowledge representation languages 
in proceedings of the  th european conference on artificial intelligence  ecai     stockholm  sweden  pitman 
backstrom  c          expressive equivalence of planning formalisms  artificial intelligence      
         
backstrom  c     nebel  b          complexity results for sas  planning  computational intelligence                
blum  a  l     furst  m  l          fast planning through planning graph analysis  artificial
intelligence                  
brewka  g     hertzberg  j          how to do things with worlds  on formalizing actions and
plans   journal logic and computation               
bylander  t          the computational complexity of propositional strips planning  artificial
intelligence                 
cadoli  m     donini  f  m          a survey on knowledge compilation  ai communications 
                
cadoli  m   donini  f  m   liberatore  p     schaerf  m          comparing space efficiency of
propositional knowledge representation formalism  in aiello  l  c   doyle  j     shapiro 
s   eds    principles of knowledge representation and reasoning  proceedings of the  th
international conference  kr      pp         cambridge  ma  morgan kaufmann 
erol  k   hendler  j  a     nau  d  s          htn planning  complexity and expressivity  in
proceedings of the   th national conference of the american association for artificial intelligence  aaai      pp           seattle  wa  mit press 
   

fin ebel

erol  k   hendler  j  a     nau  d  s          complexity results for hierarchical task network
planning  annals of mathematics and artificial intelligence           
fikes  r  e     nilsson  n          strips  a new approach to the application of theorem proving
to problem solving  artificial intelligence            
furst  m   saxe  j  b     sipser  m          parity  circuits  and the polynomial time hierarchy 
mathematical systems theory              
garey  m  r     johnson  d  s          computers and intractabilitya guide to the theory of
np completeness  freeman  san francisco  ca 
gazen  b  c     knoblock  c          combining the expressiveness of ucpop with the efficiency
of graphplan  in steel  s     alami  r   eds    recent advances in ai planning   th european
conference on planning  ecp      vol       of lecture notes in artificial intelligence  pp 
       toulouse  france  springer verlag 
gogic  g   kautz  h  a   papadimitriou  c  h     selman  b          the comparative linguistics
of knowledge representation  in proceedings of the   th international joint conference on
artificial intelligence  ijcai      pp         montreal  canada  morgan kaufmann 
kambhampati  s   parker  e     lambrecht  e          understanding and extending graphplan 
in steel  s     alami  r   eds    recent advances in ai planning   th european conference
on planning  ecp      vol       of lecture notes in artificial intelligence  pp        
toulouse  france  springer verlag 
karp  r  m     lipton  r  j         
mathematique             

turing machines that take advice 

l  ensignement

kautz  h  a   mcallester  d  a     selman  b          encoding plans in propositional logic  in
aiello  l  c   doyle  j     shapiro  s   eds    principles of knowledge representation and
reasoning  proceedings of the  th international conference  kr      pp         cambridge  ma  morgan kaufmann 
kautz  h  a     selman  b          forming concepts for fast inference   in proceedings of the
  th national conference of the american association for artificial intelligence  aaai     
pp         san jose  ca  mit press 
kautz  h  a     selman  b          pushing the envelope  planning  propositional logic  and
stochastic search  in proceedings of the   th national conference of the american association for artificial intelligence  aaai      pp            mit press 
kautz  h  a     selman  b          blackbox  a new approach to the application of theorem
proving to problem solving  in working notes of the aips    workshop on planning as
combinatorial search pittsburgh  pa 
koehler  j   nebel  b   hoffmann  j     dimopoulos  y          extending planning graphs to an
adl subset  in steel  s     alami  r   eds    recent advances in ai planning   th european
conference on planning  ecp      vol       of lecture notes in artificial intelligence  pp 
       toulouse  france  springer verlag 
   

fic ompilability

and

e xpressive p ower of p lanning f ormalisms

lifschitz  v          on the semantics of strips  in georgeff  m  p     lansky  a   eds    reasoning about actions and plans  proceedings of the      workshop  pp     timberline  or 
morgan kaufmann 
nebel  b          what is the expressive power of disjunctive preconditions   in biundo  s     fox 
m   eds    recent advances in ai planning   th european conference on planning  ecp    
durham  uk  springer verlag  to appear 
papadimitriou  c  h          computational complexity  addison wesley  reading  ma 
pednault  e  p          adl  exploring the middle ground between strips and the situation
calculus  in brachman  r   levesque  h  j     reiter  r   eds    principles of knowledge
representation and reasoning  proceedings of the  st international conference  kr     
pp         toronto  on  morgan kaufmann 
yap  c  k          some consequences of non uniform conditions on uniform classes  theoretical
computer science             

   

fi