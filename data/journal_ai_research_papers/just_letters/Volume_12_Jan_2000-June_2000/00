journal artificial intelligence research              

submitted       published     

planning graph  dynamic  csp 
exploiting ebl  ddb csp search techniques graphplan
subbarao kambhampati

rao   asu   edu

department computer science engineering
arizona state university  tempe az           

abstract
paper reviews connections graphplans planning graph dynamic
constraint satisfaction problem motivates need adapting csp search techniques
graphplan algorithm  describes explanation based learning  dependency directed backtracking  dynamic variable ordering  forward checking  sticky values random restart search
strategies adapted graphplan  empirical results provided demonstrate
augmentations improve graphplans performance significantly  up     x speedups on several
benchmark problems  special attention paid explanation based learning dependency
directed backtracking techniques empirically found useful improving
performance graphplan 

   introduction
graphplan  blum   furst        currently one efficient algorithms solving classical planning problems  four five competing systems recent aips    planning competition based graphplan algorithm  mcdermott         extending efficiency
graphplan algorithm thus seems worth while activity   kambhampati  parker   
lambrecht         provided reconstruction graphplan algorithm explicate links
previous work classical planning constraint satisfaction  one specific link discussed
connection process searching graphplans planning graph  solving dynamic constraint satisfaction problem  dcsp   mittal   falkenhainer         seen dcsp
perspective  standard backward search proposed blum furst        lacks variety ingredients thought make efficient csp search mechanisms  frost   dechter       
bayardo   schrag         include forward checking  dynamic variable ordering  dependency directed backtracking explanation based learning  tsang        kambhampati        
 kambhampati et al          suggested would beneficial study impact
extensions effectiveness graphplans backward search 
paper  describe experiences adding variety csp search techniques improve graphplan backward searchincluding explanation based learning  ebl  dependencydirected backtracking capabilities  ddb   dynamic variable ordering  forward checking  sticky
values  random restart search strategies  these  addition ebl ddb capabilities
turned empirically useful  ebl ddb based explaining failures
leaf nodes search tree  propagating explanations upwards search
tree  kambhampati         ddb involves using propagation failure explanations support
intelligent backtracking  ebl involves storing interior node failure explanations  pruning
future search nodes  graphplan use weak form failure driven learning calls mem 

c      ai access foundation morgan kaufmann publishers  rights reserved 

fik ambhampati

oization  shall see paper  graphplans brand learning quite limited
explicit analysis reasons failure  instead explanation failure search node
taken constraints search node  explained  kambhampati        
eliminates opportunities dependency directed backtracking  adversely effects
utility stored memos 
adding full fledged ebl ddb capabilities effect gives graphplan ability
intelligent backtracking  ability learn generalized memos likely
applicable situations  technically  involves generalizing conflict directed backjumping
 prosser         specialized version ebl ddb strategy applicable binary csp problems 
work context dynamic constraint satisfaction problems  as discussed  kambhampati          empirically  ebl ddb capabilities improve graphplans search efficiency quite
dramaticallygiving rise     x speedups  allowing graphplan easily solve several
problems hither to hard unsolvable  particular  report experiments
bench mark problems described kautz selman         well   domains 
used recent aips planning competition  mcdermott        
discuss utility issues involved storing using memos  point graphplan
memoization strategy seen conservative form csp no good learning 
conservative strategy keeps storage retrieval costs no goods usual bane no good
learning strategiesunder control  loses learning opportunities  present use
sticky values way recouping losses  empirical studies show sticky
values lead    x improvement ebl 
addition ebl ddb  investigated utility forward checking dynamic
variable ordering  isolation concert ebl ddb  empirical studies show
capabilities typically lead additional    x speedup ebl ddb 
competitive ebl ddb 
finally  consider utility ebl ddb strategies context random restart search
strategies  gomes  selman    kautz        recently shown good solving hard combinatorial problems  including planning problems  results show ebl ddb
strategies retain advantages even context random restart strategies  specifically 
ebl ddb strategies enable graphplan use backtrack limits effectivelyallowing
achieve higher solvability rates  optimal plans significantly smaller backtrack
restart limits 
paper organized follows  next section  provide background viewing
graphplans backward search  dynamic  constraint satisfaction problem  review
opportunities view presents  section    discuss inefficiencies backtracking
learning methods used normal graphplan motivate need ebl ddb capabilities 
section   describes ebl ddb added graphplan  section   presents empirical studies
demonstrating usefulness augmentations  section   investigates utility forward
checking dynamic variable ordering strategies graphplan  section   investigates utility
ebl ddb strategies context random restart search  section   discusses related work
section    presents conclusions directions work 
   binary csp problems problems initial constraints pairs variables 

 

fip lanning g raph

action list
level k  

proposition list
level k  

action list
level k

proposition list
level k

g      g    p  p 
domains  g    fa  g  g    fa  gg    fa  gg    fa  g
p    fa  gp    fa    a   gp    fa  gp    fa    a  g
p    fa   gp    fa   g
constraints  normal  p    a    p     a 
p    a    p     a 
p    a     p     a 
constraints  activity   g    a    activefp    p    p  g
g    a    activefp  g
g    a    activefp  g
g    a    activefp    p  g
init state  activefg    g    g    g  g

p 
a 

a 

x
a 
a 

p 

  

a 

g 
g 

p 
p 

  

g 

p 

a 

x

csp

variables 

a 

x



a 

g 

p 
a 

 a  planning graph

 b  dcsp

figure    planning graph dcsp corresponding

   review graphplan algorithm connections dcsp
    review graphplan algorithm
graphplan algorithm  blum   furst        seen disjunctive version forward
state space planners  kambhampati et al         kambhampati         consists two interleaved
phases forward phase  data structure called planning graph incrementally extended 
backward phase planning graph searched extract valid plan  planninggraph consists two alternating structures  called proposition lists action lists  figure   shows
partial planning graph structure  start initial state zeroth level proposition list 
given k level planning graph  extension structure level k     involves introducing
actions whose preconditions present k th level proposition list  addition actions
given domain model  consider set dummy persist actions  one condition
k th level proposition list  persist c action c precondition c effect 
actions introduced  proposition list level k     constructed union
effects introduced actions  planning graph maintains dependency links
actions level k     preconditions level k proposition list effects level k    
proposition list  planning graph construction involves computation propagation
mutex constraints  propagation starts level    actions statically interfering
 i e   preconditions effects inconsistent  labeled mutex  mutexes
propagated level forward using two simple rules  two propositions level k
marked mutex actions level k support one proposition mutex actions
support second proposition  two actions level k     mutex statically interfering
one propositions  preconditions  supporting first action mutually exclusive
one propositions supporting second action 
search phase k level planning graph involves checking see sub graph
planning graph corresponds valid solution problem  involves starting
propositions corresponding goals level k  if goals present 
present pair marked mutually exclusive  search abandoned right away 
planning grap grown another level   goal propositions  select action
 

fik ambhampati

g      g    p  p 
g    fa  g  g    fa  gg    fa  gg    fa  g
p    fa  gp    fa    a   gp    fa  gp    fa    a  g
p    fa   gp    fa   g
constraints  normal  p    a    p     a 
p    a    p     a 
p    a     p     a 
constraints  activity   g    a    activefp    p    p  g
g    a    activefp  g
g    a    activefp  g
g    a    activefp    p  g
init state  activefg    g    g    g  g

g      g    p  p 
g    fa     g  g    fa     gg    fa     gg    fa     g
p    fa     gp    fa    a      gp    fa     gp    fa    a     g
p    fa      gp    fa      g
constraints  normal  p    a    p     a 
p    a    p     a 
p    a     p     a 
constraints  activity   g    a    p       p       p     
g    a    p     
g    a    p     
g    a    p       p     
init state  g       g       g       g     

variables 

variables 

domains 

domains 

 a  dcsp

 b  csp

figure    compiling dcsp standard csp
level k action list supports it  two actions selected supporting two
different goals mutually exclusive  if are  backtrack try change selection
actions   point  recursively call search process k     level planning graph 
preconditions actions selected level k goals k     level search 
search succeeds reach level    corresponding initial state  
consider  partial  planning graph shown figure   graphplan may generated
search solution  g  g  top level goals want satisfy 
a  a  actions support goals planning graph  specific actionprecondition dependencies shown straight line connections  actions a  a  
left most level support conditions p  p  planning graph  notice conditions p 
p  level k     supported two actions each  x marked connections
actions a    a    a    a  a    a   denote action pairs mutually exclusive   notice
given mutually exclusive relations alone  graphplan cannot derive mutual exclusion
relations proposition level p  p    
    connections graphplan csp
graphplan algorithm described bears little resemblance previous classical planning
algorithms   kambhampati et al          explicate number important links
graphplan algorithm previous work planning constraint satisfaction communities 
specifically  show planning graph length k thought  to first approximation 
disjunctive  unioned  version k  level search tree generated forward state space refinement 
action lists corresponding union actions appearing k th level  proposition
lists corresponding union states appearing k th level  mutex constraints
seen providing  partial  information subsets proposition list actually
correspond legal states corresponding forward state space search  process searching
planning graph extract valid plan seen dynamic constraint satisfaction
problem  since last link relevant work described paper  review
below 
dynamic constraint satisfaction problem  dcsp   mittal   falkenhainer        generalization constraint satisfaction problem  tsang         specified set variables 
 

fip lanning g raph



csp

activity flags variables  domains variables  constraints legal variablevalue combinations  dcsp  initially subset variables active  objective
find assignments active variables consistent constraints among variables  addition  dcsp specification contains set activity constraints  activity
constraint form  variable x takes value vx   variables y  z  w    become
active 
correspondence planning graph dcsp clear  specifically  propositions various levels correspond dcsp variables    actions supporting correspond variable domains  three types constraints  action mutex
constraints  fact  proposition  mutex constraints subgoal activation constraints 
since actions modeled values rather variables  action mutex constraints
modeled indirectly constraints propositions  two actions a  a  marked mutex
planning graph  every pair propositions p   p   a 
one possible supporting actions p   a  one possible supporting actions
p     constraint 

   p     a    p     a   
fact mutex constraints modeled constraints prohibit simultaneous activation
two facts  specifically  two propositions p   p   marked mutex planning graph 
constraint 

   active p       active p     

subgoal activation constraints implicitly specified action preconditions  supporting
active proposition p action makes propositions previous level corresponding
preconditions active 
finally  propositions corresponding goals problem active beginning  figure   shows dynamic constraint satisfaction problem corresponding example
planning graph discussed 
      olving



dcsp

two ways solving dcsp problem  first  direct  approach  mittal   falkenhainer 
      involves starting initially active variables  finding satisfying assignment
them  assignment may activate new variables  newly activated variables
assigned second epoch  process continues reach epoch new
variables activated  which implies success   unable give satisfying assignment
activated variables given epoch  latter case  backtrack previous epoch
try find alternative satisfying assignment variables  backtracking further 
assignment possible   backward search process used graphplan algorithm  blum  
furst        seen solving dcsp corresponding planning graph direct
fashion 
second approach solving dcsp first compile standard csp  use
standard csp algorithms  compilation process quite straightforward illustrated
   note literal appearing different levels corresponds different dcsp variables  thus  strictly speaking  literal p proposition list level converted dcsp variable pi   keep matters simple 
example figure   contains syntactically different literals different levels graph 

 

fik ambhampati

figure    main idea introduce new null value  denoted    domains
dcsp variables  model inactive dcsp variable csp variable
takes value    constraint particular variable p active modeled p      thus 
activity constraint form

g    a    activefp    p    p  g
compiled standard csp constraint

g    a    p       p       p     
worth noting activation constraints concerned ensuring
propositions preconditions selected action take non   values  thus allow
possibility propositions become active  take non   values  even though
strictly supporting preconditions selected action  although lead inoptimal
plans  mutex constraints ensure unsound plans produced  kautz   selman 
       avoid unnecessary activation variables  need add constraints effect
unless one actions needing variable precondition selected value
variable earlier  higher  level  variable must   value  constraints
typically going high arity  as wind mentioning large number variables
previous level   may thus harder handle search 
finally  mutex constraint two propositions

   active p       active p     
compiled

   p        p         

since action mutex constraints already standard csp form  compilation 
activity constraints converted standard constraints thus entire csp
standard csp  solved standard csp search techniques  tsang         
direct method advantage closely mirrors graphplans planning graph
structure backward search  this  possible implement approach
plan graph structure without explicitly representing constraints  furthermore  discuss section    distinct advantages adopting dcsp view implementing
ebl ddb graphplan  compilation csp requires plan graph first converted
extensional csp  however allow use standard algorithms  well supports nondirectional search  in one follow epoch by epoch approach assigning
variables    since main aim illustrate utility csp search techniques context
graphplan algorithm  adopt direct solution method dcsp  study
tradeoffs offered technique compiling planning graph csp  reader referred
 do   kambhampati        
   possible compile csp problem propositional satisfiability problem  i e   csp problem
boolean variables   accomplished compiling every csp variable p domain fv    v      vn g
n boolean variables form p is v  p is vn   every constraint form p
vj     compiled
p is vj       essentially done blackbox system  kautz   selman        
   compilation csp strict requirement non directional search   zimmerman   kambhampati 
       describe technique allows backward search graphplan non directional  see discussion
section    

 

 

fip lanning g raph



csp

    interpreting mutex propagation csp view
viewing planning graph constraint satisfaction problem helps put mutex propagation
clearer perspective  see  kambhampati et al           specifically  way graphplan constructs planning graph  winds enforcing partial directed   consistency partial directed
  consistency  tsang         partial   consistency ensured graph building procedure
introduces action level l actions preconditions present proposition
list level l     mutually exclusive  partial   consistency ensured mutual
exclusion propagation procedure 
particular  graphplan planning graph construction implicitly derives no good  constraints form 

 active pmi    or pmi     

simply removed  or put into  level i  mutex
case pm
constraints form 




  active pmi     active pni  

pmi      pni     

 

p marked mutually exclusive 
case pm
n
procedures directed use reachability analysis enforcing consistency  partial enforce either full   consistency full   consistency 
lack full   consistency verified fact appearance goal level k
necessarily mean goal actually achievable level k  i e   solution csp
assigns non    value goal level   similarly  lack full   consistency verified fact appearance pair goals level k imply plan
achieving goals level 
another  somewhat less obvious  way consistency enforcement used
graphplan partial  and conservative it concentrates whether single goal variable
pair goal variables simultaneously non    values  be active  solution  may
goal non    value  non    values feasible  similarly  may
pair goals achievable  necessarily achievable every possible pair actions
respective domains 
interpretation mutex propagation procedure graphplan brings fore several possible
extensions worth considering graphplan 
   explore utility directional consistency enforcement procedures based solely
reachability analysis  kambhampati et  al         argue extending analysis using
relevance information  et  al         provide empirical analysis effectiveness
consistency enforcement relevance information 
   explore utility enforcing higher level consistency  pointed  kambhampati
et al         kambhampati         memoization strategies seen failure driven
procedures incrementally enforce partial higher level consistency 
   normally  csp literature  no good seen compound assignment part feasible
     pni     correspond conjunction nogoods
solution  view  mutex constraints form pm


pni  
form pm au   pn av au av values domains pm

 

 

 

 

 

fik ambhampati

   consider relaxing focus non    values alone  allow derivation no goods
form

pmi   au   pni   av

guaranteed winning idea number derived no goods increase
quite dramatically  particular  assuming l levels planning graph 
average goals per level  average actions supporting goal  maximum
number graphplan style pair wise mutexes  l m      size no goods
type discussed  l  m  d           consider similar issue context
graphplan memoization strategy section   

   inefficiencies graphplans backward search
motivate need ebl ddb  shall first review details graphplans backward
search  pinpoint inefficiencies  shall base discussion example planning
graph figure    which reproduced convenience figure     assuming g  g 
top level goals problem interested solving  start level k   select
actions support goals g  g    keep matters simple  shall assume search
assigns conditions  variables  level top bottom  i e   g  first  g 
on   further  choice actions  values  support condition 
consider top actions first  since one choice conditions level 
none actions mutually exclusive other  select actions a    a    a 
a  supporting conditions level k   make sure preconditions
a    a    a    a  satisfied level k      thus subgoal conditions p  p  level
k      recursively start action selection them  select action a  p    p   
two supporting actions  using convention  select a  first  p    a 
choice  get selecting support p    choice  suppose
select a  first  find choice infeasible a  mutually exclusive a 
already chosen  so  backtrack choose a    find mutually exclusive
previously selected action  a    stymied choices p    so 
backtrack undo choices previous conditions  graphplan uses chronological
backtracking approach  whereby  first tries see p  re assigned  p  on 
notice first indication inefficiency failure assign p  nothing
assignment p    yet  chronological backtracking try re assign p  vain hope
averting failure  lead large amount wasted effort case p 
indeed choices 
turns out  find p  choices backtrack it  p  another
choice a     try continue search forward value p    hit impasse p 
since value p    a  mutex a     point  backtrack p    continue
backtracking p  p    remaining choices  backtrack
p    need go back level k try re assign goals level  done 
graphplan search algorithm makes memo signifying fact failed satisfy goals
p  p  level  hope search ever subgoals set goals
future  scuttle right away help remembered memo  second
indication inefficiency remembering subgoals p  p  even though see
problem lies trying assign p    p    p  p  simultaneously  nothing
 

fip lanning g raph

action list
level k  

proposition list
level k  



csp

action list
level k

proposition list
level k

a 
p 
a 

x

a 

x
a 
a 

p 
a 

p 

g 
a 

p 
  

g 

p 

a 

x

g 

g 

p 
a 

  

figure    running example used illustrate ebl ddb graphplan
subgoals  remember fp    p    p    p  g memo fp  p  g 
remembered memo would general  would much better chance useful
future 
memo stored  backtracking continues level k chronological
fashion  trying reassign g    g    g  g  order  see third indication inefficiency caused chronological backtracking g  really role failure encountered
assigning p  p  since spawns condition p  level k      yet  backtracking
scheme graphplan considers reassigning g    somewhat subtle point reassigning
g  going avert failure either  although g  requires p  one conditions taking
part failure  p  required g  unless g  gets reassigned  considering
assignments g  going avert failure 
example  continue backtracking g  g  too  since alternative supports  finally memoize fg    g    g    g  g level  point backward search
fails  graphplan extends planning graph another level re initiating backward
search extended graph 

   improving backward search ebl ddb
describe graphplans backward search augmented full fledged ebl
ddb capabilities eliminate inefficiencies pointed previous section  informally 
ebl ddb strategies involve explanation failures leaf nodes  regression propagation
leaf node failure explanations compute interior node failure explanations  along lines described  kambhampati         specific extensions propose backward search

 

fik ambhampati

essentially seen adapting conflict directed backjumping strategy  prosser         generalizing work dynamic constraint satisfaction problems 
algorithm shown pseudo code form figure    contains two mutually recursive
procedures find plan assign goals  former called level
planning graph  calls assign goals assign values required conditions
level  assign goals picks condition  selects value it  recursively calls
remaining conditions  invoked empty set conditions assigned  calls
find plan initiate search next  previous  level 
order illustrate ebl ddb capabilities added  lets retrace previous example 
pick point assign p  level k      assigned p    p 
p    try assign value a  p   violate mutex constraint a  a  
explanation failure search node set constraints false derived 
complete explanation failure thus stated as 

p    a    p    a     p    a    p     a   
this  part p    a    p     a  stripped explanation since mutual
exclusion relation hold long solving particular problem particular
actions  further  take cue conflict directed backjumping algorithm  prosser 
       represent remaining explanation compactly terms conflict sets  specifically 
whenever search reaches condition c  and find assignment it   conflict
set initialized fcg  whenever one possible assignments c inconsistent  mutually
exclusive  current assignment previous variable c    add c  conflict set c 
current example  start fp  g conflict set p    expand adding p 
find a  cannot assigned p  choice a  support p    informally 
conflict set representation seen incrementally maintained  partial  explanation
failure  indicating conflict current value p  one possible
values p   kambhampati        
consider second possible value p    viz   a    find mutually exclusive
a  currently supporting p    following practice  add p  conflict set
p    point  choices p    backtrack p    passing
conflict set p    viz   fp    p    p  g reason failure  essence  conflict set
shorthand notation following complete failure explanation  kambhampati         
  

p    a       p    a        p    a    p     a       p    a    p     a      p    a    p    a 

worth noting point p  revisited future different assignments
preceding variables  conflict set re initialized fp  g considering assignments it 
first advantage conflict set allows transparent way supporting dependency directed backtracking  kambhampati         current example  failed assign
p    start backtracking  need chronological fashion however 
   strip first  disjunctive  clause since present graph structure  next two implicative clauses
since part mutual exclusion relations change problem  conflict set representation keeps condition  variable  names last two clauses denoting  essence  current
assignments variables p  p  causing failure assign p   

  

fip lanning g raph



csp

find plan g goals  pg   plan graph  k   level 
k      return empty subplan p success 
memo g 
fail  return conflict set
call assign goals g  pg  k     
assign goals fails returns conflict set  
store memo
regress actions selected level k     get r
fail return r conflict set
assign goals succeeds  returns k  level subplan p  
return p success
assign goals g goals  pg   plan graph  k   level  a  actions 
g    
let u union preconditions actions
call find plan u  pg  k     
find plan fails returns conflict set r 
fail return r
find plan succeeds returns subplan p length k    
succeed return k length subplan p
else    g      
select goal g   g
let cs
fgg  ag set actions level k pg support g
l  
ag      fail return cs conflict set
ag  
else  pick action   ag   set ag
mutually exclusive action b  
let l goal b selected support
cs   flg
set cs
goto l 
else  a mutually exclusive action a 
call assign goals g   fg g  pg  k    fag 
call fails returns conflict set c
g   c
set cs   cs   c  conflict set absorption
goto l 
else   g    c  
fail return c conflict set
 dependency directed backjumping

figure    pseudo code description graphplan backward search enhanced ebl ddb capabilities  backward search level k planning graph pg initiated call
find plan g  pg  k   g set top level goals problem 
  

fik ambhampati

instead  jump back recent variable  condition  taking part conflict set p 
case p    so  avoiding considering alternatives p    thus avoiding
one inefficiencies standard backward search  easy see backjumping
sound since p  causing failure p  thus re assigning wont avert failure 
continuing along  whenever search backtracks condition c  backtrack conflict
absorbed current conflict set c  example  absorb fp    p    p  g conflict
set p    currently fp  g  making fp    p    p  g new conflict set p     assign
a     remaining value  p    next try assign p  find value a 
mutex a     thus  set conflict set p  fp    p  g backtrack conflict
set  backtracking reaches p    conflict set absorbed current conflict set
p   as described earlier   giving rise fp    p    p    p  g current combined failure reason
p    step illustrates conflict set condition incrementally expanded collect
reasons failure various possible values condition 
point  p  choices  backtrack p  current conflict set 
fp    p    p    p  g  p    first absorb conflict set fp    p    p    p  g p  current conflict
set  re initiate backtracking since p  choices 
now  reached end current level  k       backtracking p  must
involve undoing assignments conditions k th level  however 
two steps  memoization regression 
    memoization
backtrack first assigned variable given level  store conflict set
variable memo level  store conflict set fp    p    p    p  g p  memo
level  notice memo store shorter  and thus general  one stored
normal graphplan  include p  p    anything
failure 
    regression
backtrack level k     level k   need convert conflict set  the first
assigned variable in  level k     refers conditions level k   conversion
process involves regressing conflict set actions selected k th level  kambhampati 
       essence  regression step computes  smallest  set conditions  variables 
kth level whose supporting actions spawned  activated  dcsp terms  conditions  variables 
conflict set level k      current case  conflict set fp    p    p    p  g 
see p    p  required condition g  level k   condition p  required
condition g   
case condition p    g  g  responsible it  supporting
actions needed p    cases two heuristics computing regression      prefer
choices help conflict set regress smaller set conditions     still choice
multiple conditions level k   pick one assigned earlier  motivation first rule keep failure explanations compact  and thus general  possible 
   current example  memo includes conditions p   which farthest gone
level   even always necessary  verify p  would memo set a  
one supporters p   

  

fip lanning g raph



csp

motivation second rule support deeper dependency directed backtracking 
important note heuristics aimed improving performance ebl ddb
affect soundness completeness approach 
current example  first rules applies  since p  already required g   
requiring p  p    even case  i e   g  required p     still would
selected g  g  regression p    since g  assigned earlier search 
result regressing fp    p    p    p  g actions k th level thus fg    g  g  start
backtracking level k conflict set  jump back g  right away  since
recent variable named conflict set  avoids inefficiency re considering
choices g  g    done normal backward search  g    backtrack conflict set
absorbed  backtracking continues since choices  procedure
repeated g    point  end leveland memoize fg    g  g
memo level k   since levels backtrack to  graphplan called
extend planning graph one level 
notice memos based ebl analysis capture failures may require significant
amount search rediscover  example  able discover fg    g  g failing
goal set despite fact mutex relations choices goals g 
g   
    using memos
end section  couple observations regarding use stored memos 
standard graphplan  memos level stored level specific hash table  whenever
backward search reaches level k set conditions satisfied  consults hash table
see exact set conditions stored memo  search terminated exact hit
occurs  since ebl analysis allows us store compact memos  likely complete goal
set level k going exactly match stored memo  likely stored
memo subset goal set level k  which sufficient declare goal set failure  
words  memo checking routine graphplan needs modified checks
see subset current goal set stored memo  naive way
involves enumerating subsets current goal set checking
hash table  turns costly  one needs efficient data structures  setenumeration trees  rymon         indeed  koehler co workers  koehler  nebel  hoffman 
  dimopoulos        developed data structure called ub trees storing memos 
ub tree structures seen specialized version set enumeration trees 
efficiently check subset current goal set stored memo 
second observation regarding memos often serve failure explanation
themselves  suppose level k   find goal set level subsumes
stored memo   use failure explanation level  regress
back previous level  process provide us valuable opportunities
back jumping levels k   allows us learn new compact memos levels  note
none would possible normal memos stored graphplan 
way memo declare goal set level k failing memo exactly equal goal
set  case regression get us goals level k      buy us
backjumping learning power  kambhampati        

  

fik ambhampati

   empirical evaluation effectiveness ebl ddb
seen way ebl ddb capabilities added backward search maintaining updating conflict sets  noted ebl ddb capabilities avoid variety
inefficiencies standard graphplan backward search  augmentations soundness completeness preserving follows corresponding properties conflict directed
backjumping  kambhampati         remaining  million dollar  question whether capabilities make difference practice  present set empirical results answer
question 
implemented ebl ddb approach described previous section top graphplan
implementation lisp   changes needed code add ebl ddb capability relatively minor two functions needed non trivial changes    added ub tree subset
memo checking code described  koehler et al          ran several comparative experiments
benchmark problems  kautz   selman         well four domains 
specific domains included blocks world  rocket world  logistics domain  gripper domain  ferry
domain  traveling salesperson domain  towers hanoi  domains  including
blocks world  logistics domain gripper domain used recent ai planning
systems competition  specifications problems well domains publicly available 
table   shows statistics times taken number backtracks made normal graphplan  graphplan ebl ddb capabilities   
    run time improvement
first thing note ebl ddb techniques offer quite dramatic speedups    x
blocks world way    x logistics domain  the att log a problem unsolvable
normal graphplan    hours cpu time    note number backtracks
reduces significantly consistently ebl ddb  given lengh runs  time
lisp spends garbage collection becomes important issue  thus report cumulative time
 including cpu time garbage collection time  graphplan ebl ddb  separate
cpu time cumulative time plain graphplan  in cases total time spent
large enough garbage collection time significant fraction   specifically  two
entrys column corresponding total time normal graphplan  first entry
cpu time spent  second entry parenthesis cumulative time  cpu time garbage
collection time  spent  speedup computed respect cumulative time graphplan
ebl ddb cpu time plain graphplan     reported speedups thus seen
conservative estimates 
   original lisp implementation graphplan done mark peot  implementation subsequently
improved david smith 
   assign goals find plan
    earlier versions paper  including paper presented ijcai  kambhampati        reported
experiments sun sparc ultra   running allegro common lisp      linux machine run time statistics
seem approximately    x faster sparc machine 
    interesting note percentage time spent garbage collection highly problem dependent 
example  case att log a     minutes    hours  or    cumulative time  spent
garbage collection  case tower        hours     hours  or     cumulative
time  spent garbage collection 

  

fiproblem

speedup
   x
   x
  x
  x
     x
  x
  x
   x
  x
   x
  x
  x
   x
  x
   x

table    empirical performance ebl ddb  unless otherwise noted  times cpu minutes pentium iii     mhz machine
   meg ra running linux allegro common lisp    compiled speed  tt total time  mt time used checking
memos btks number backtracks done search  times graphplan ebl ddb include cpu
garbage collection time  cpu time separated total time case normal graphplan  numbers
parentheses next problem names list number time steps number actions respectively solution  avln
avfm denote average memo length average number failures detected per stored memo respectively 

csp

avfm
    
    
   
    
   
   
   
   
 
 



normal graphplan
tt  mt 
  btks avln
        
    k
    
         
    k      
          
    k
    
    
         k
    
     hr     hr 
  
   
   
    k
    
        
    
    hr    hr 
               k
    
    hr      hr 
    
      
        k
    
       
        k
  
  hr      hr 
                 k
  
   hr       hr 
 

p lanning g raph

  

huge fact        
bw large b        
rocket ext a       
rocket ext b       
att log a       
gripper          
gripper          
gripper          
tower          
tower          
ferry           
ferry          
ferry         
tsp           
tsp          

graphplan ebl ddb
tt
mt
  btks avln avfm
         
    k
    
    
         
   k      
    
  
   
   k
   
  
  
   
   k
   
   
    
   
    k
          
        
   k
   
   
   
   
    k
 
    
               k      
   
        
   k
   
   
         
    k
   
   
        
   k
   
    
    
   
    k
   
    
     
         k
    
   
        
    k
   
  
               k
   
    

fik ambhampati

    reduction memo length
results highlight fact speedups offered ebl ddb problem domain
dependent quite meager blocks world problems  quite dramatic many
domains including rocket world  logistics  ferry  gripper  tsp hanoi domains  statistics
memos  shown table   shed light reasons variation  particular interest
average length stored memos  given columns labeled avln   general 
expect ebl analysis reduces length stored memos  conditions part
failure explanation stored memo  however  advantage depends
likelihood small subset goals given level actually taking part failure 
likelihood turn depends amount inter dependencies goals given
level  table  note average length reduces quite dramatically rocket world
logistics     reduction much less pronounced blocks world  variation
traced back larger degree inter dependency goals given level blocks
world problems 
reduction average memo length correlated perfectly speedups offered ebl
corresponding problems  let put perspective  fact average length
memos rocket ext a problem     ebl    without
ebl  shows essence
 
normal graphplan re discovering   sized failure embedded   
  possible ways worst
case    sized goal set storing new memo time  incurring increased backtracking
matching costs   thus wonder normal graphplan performs badly compared
graphplan ebl ddb 
    utility stored memos
statistics table   show increased utility memos stored graphplan
ebl ddb  since ebl ddb store general  smaller  memos normal graphplan 
should  theory  generate fewer memos use often  columns labeled avfm
give ratio number failures discovered use memos number memos
generated first place  seen measure average utility stored
memos  note utility consistently higher ebl ddb  example  rocketext b  see average ebl ddb generated memo used discover failures    
times  number     memos generated normal graphplan   
    relative utility ebl vs  ddb
statistics table    see even though ebl make significant improvements
run time  significant fraction run time ebl  as well normal graphplan  spent
memo checking  raises possibility overall savings mostly ddb part
ebl part  i e  part involving storing checking memos  fact net drain
 kambhampati  katukam    qu         see true  ran problems ebl  i e  
memo checking  disabled  ddb capability well standard graphplan memoization
    case att log a  took memo statistics interrupting search   hours
    statistics att log aseem suggest memo usage bad normal graphplan  however 
noted att log a solved normal graphplan begin with  improved usage factor may due
mostly fact search went considerably longer time  giving graphplan opportunity use
memos 

  

fip lanning g raph

problem
att log a
tower  
rocket ext a
gripper  
tsp   
huge fct

ebl ddb
btks
time
    k     
    k     
   k
   
    k     
    k
   
    k     



csp

ddb
btks
time
      k    
     k
   
    k
     
    k
    
    k
   
    k
    

speedup
   x
  x
  x
    x
    x
    x

table    utility storing using ebl memos ddb
strategies left in    results shown table    demonstrate ability store
smaller memos  as afforded ebl  quite helpfulgiving rise    x speedup ddb alone
att log a problem    x speedup tower   problem  course  results show
ddb important capability itself  indeed  att log aand tower   could even solved
standard graphplan  ddb  problems become solvable  summary  results
show ebl ddb net positive utility 
    utility memoization
another minor  well recognized  point brought statistics table  
memo checking sometimes significant fraction run time standard graphplan 
example  case rocket ext a  standard graphplan takes      minutes      minutes 
half time  spent memo checking  in hash tables   raises possibility
disable memoization  perhaps well version ebl ddb 
see case  ran problems memoization disabled  results show
general disabling memo checking leads worsened performance  came across
cases disablement reduces overall run time  run time still much higher
get ebl ddb  example  case rocket ext a  disable memo
checking completely  graphplan takes      minutes  lower      minutes taken
standard graphplan  still much higher    minutes taken version graphplan
ebl ddb capabilities added  add ddb capability  still disabling memochecking  run time becomes     minutes  still   times higher afforded
ebl capability 
    c vs  lisp question
given existing implementations graphplan done c many optimizations 
one nagging doubt whether dramatic speedups due ebl ddb somehow dependent
moderately optimized lisp implementation used experiments  thankfully 
ebl ddb techniques described paper  re implemented maria fox
derek long stan system  stan highly optimized implementation graphplan
fared well recent aips planning competition  found ebl ddb resulted
similar dramatic speedups system  fox        fox   long         example 
    considered removing memoization completely  results even poorer 

  

fik ambhampati

unable solve att log a plain graphplan  could solve easily ebl ddb
added 
finally  worth pointing even ebl ddb capabilities  unable solve
larger problems at t benchmarks  bw large c att log b  however
indictment ebl ddb since knowledge planners solved
problems used either local search strategies gsat  randomized re start strategies 
used additional domain specific knowledge pre processing  least 
aware existing implementations graphplan solve problems 

   utility graphplan memos
one important issue using ebl managing costs storage matching  indeed  discussed  kambhampati         naive implementations ebl ddb known lose gains
made pruning power matching storage costs  consequently  several techniques
invented reduce costs selective learning well selective forgetting 
interesting see costs prominent issue ebl ddb graphplan 
think mostly two characteristics graphplan memoization strategy 
   graphplans memoization strategy provides compact representation no goods 
well selective strategy remembering no goods  seen dcsp  remembers
subsets activated variables satisfying assignment  seen csp  c f 
figure     graphplan remembers no goods form

p i      p i     pmi    
 where superscripts correspond level planning graph proposition
belongs   normal ebl implementations learn no goods form

p i   a    p j   a  pmk  
suppose planning graph contains n propositions divided l levels  proposition
p level j actions supporting it  csp compilation planning graph
n variables      values  the extra one     normal ebl implementation
csp learn  worst case   d     n no goods    contrast  graphplan
n
remembers l   l memos   dramatic reduction  reduction result two
factors 
 a  individual memo stored graphplan corresponds exponentially large set
normal no goods  the memo

p i      p i     pmi    
shorthand notation conjunction dm no goods corresponding possible
i 
non    assignments p i pm

    variable v may either present no good  present one
possibilities n variables 
    level  nl propositions either occurs memo occur

  

  

    possible assignmentsgiving

fip lanning g raph



csp

 b  memos subsume no goods made proposition variables planning graph level 
   matching cost reduced fact considerably fewer no goods ever
learned  fact graphplan stores no goods  memos  separately level 
consults memos stored level j   backwards search level j  
discussion throws light so called ebl utility problem
critical graphplan ebl done normal csps 
    scenarios memoization conservative avoid rediscovery
failures
discussion raises possibility graphplan  even ebl ddb  memoization
conservative may losing useful learning opportunities
required syntactic form  specifically  graphplan learn memo form

p i      p i     pmi     
must case dm possible assignments propositional variables must
no good  even one no good  graphplan avoids learning memo  thus
potentially repeating failing searches later time  although loss made extent
learning several memos lower level  
p
consider example following scenario  set variables p i pm
n
level assigned backward search  suppose search found legal partial asi   domain p contains k values fv  vk g 
signment variables p i pm

  

trying assign variables pm pni   suppose repeatedly fail backtrack variable
pmi   re assigning eventually settling value v   point backtracking
higher level variables  p p   re assigning
occurs  time backtrack pm

 
them  point  would useful remember no goods effect none
going work backtracking repeated 
first   values pm
no goods take form 

pmi   vj   pmi         pmi        pni    
tried found lead failure
j ranges      values pm

assigning later variables  unfortunately  no goods syntactic form memos
memoization procedure cannot remember them  search thus forced rediscover
failures 
    sticky values partial antidote
one way staying standard memoization  avoiding rediscovery failing search
paths  case example above  use sticky values heuristic  frost
  dechter        kambhampati         involves remembering current value variable
skipping ddb  trying value first search comes back
variable  heuristic motivated fact skip variable ddb 
means variable current assignment contributed failure caused
  

fik ambhampati

backtrackingso makes sense restore value upon re visit  example above 
backtracked it  tries
heuristic remember v  current value pm
first value re visited  variation technique re arrange fold
domain variable values precede current value sent back
domain  values tried previously untried values found
fail  makes assumption values led failure likely again 
becomes fv    v  vk   v    v  v  g 
example above  heuristic folds domain pm
notice heuristics make sense employ ddb  otherwise never
skip variable backtracking 
implemented sticky value heuristics top ebl ddb graphplan  statistics
table   show results experiments extension  seen  sticky values
approach able give    x additional speedup ebl ddb depending problem 
further  folding heuristic dominates simple version terms number backtracks 
difference quite small terms run time 

   forward checking   dynamic variable ordering
ddb ebl considered look back techniques analyze failures looking
back past variables may played part failures  different class
techniques known look forward techniques improving search  prominent among
latter forward checking dynamic variable ordering  supporting forward checking involves
filtering conflicting actions domains remaining goals  soon particular
goal assigned  example figure    forward checking filter a  domain p 
soon p  assigned a    dynamic variable ordering  dvo  involves selecting assignment
goal least number remaining establishers    dvo combined forward checking  variables ordered according live domain sizes  where live domain
comprised values domain yet pruned forward checking   experiments   show techniques bring reasonable  albeit non dramatic  improvements
graphplans performance  table   shows statistics benchmark problems  dynamic variable ordering alone  forward checking dynamic variable ordering  note
backtracks reduce    x case dynamic variable ordering   x
case dynamic variable ordering forward checking  speedups time somewhat smaller 
ranging    x    x  times perhaps improved efficient implementation forward checking    results seem suggest amount optimization
going make dynamic variable ordering forward checking competitive ebl ddb
problems  one thing  several problems  including att log a  tsp     ferry   etc 
could solved even forward checking dynamic variable ordering  second 
even problems could solved  reduction backtracks provided ebl ddb far
greater provided fc dvo strategies  example  tsp     fc dvo strategies
    experimented variation heuristic  known brelaz heuristic  gomes et al         
ties among variables sized live domains broken picking variables take part
number constraints  variation however lead appreciable improvement performance 
    study forward checking dynamic variable ordering initiated dan weld 
    current implementation physically removes pruned values variable forward checking phase 
restores values backtracks  better implementations  including use in out flags values well
use indexed arrays  c f   bacchus   van run        

  

fi  

ebl ddb sticky
btks
speedup
   k
   x     x 
   k
   x    x 
     k     x     x 
     k    x     x 
     k     x     x 
    k
 x     x 

ebl ddb sticky fold
time
btks
speedup
   
   k
   x     x 
    
   k
   x     x 
          k     x     x 
           k    x     x 
           k     x     x 
   
   k
   x    x 

table    utility using sticky values along ebl ddb 

csp

time
   
   
    
     
    
   



rocket ext a      
rocket ext b      
gripper          
ferry  
tsp          
att log a       

plain ebl ddb
time
btks
  
   k
  
   k
           k
           k
           k
    
    k

p lanning g raph

problem

fik ambhampati

problem
huge fact        
bw large b        
rocket ext a       
rocket ext b       
att log a       
gripper         
tsp          
tower         

gp
        k 
         k 
          k 
          k 
   hr
        k 
        k 
   hr

gp dvo
          k 
         k 
         k 
         k 
   hr
        k 
        k 
   hr

speedup
   x    x 
   x  x 
   x    x 
   x    x 
   x    x 
    x    x 
 

gp dvo fc
          k 
        k 
         k 
      k 
   hr 
        k 
        k 
   hr 

speedup
    x  x 
     x 
   x    x 
   x  x 
   x    x 
    x    x 

table    impact forward checking dynamic variable ordering routines graphplan  times
cpu minutes measured     mhz pentium iii running linux franz
allegro common lisp    numbers parentheses next times number
backtracks  speedup columns report two factorsthe first speedup time 
second speedup terms number backtracks  fc dvo tend
reduce number backtracks  reduction always seem show
time savings 

reduce number backtracks      k      k     x improvement  however  pales
comparison     k backtracks  or   x improvement  given ebl ddb  see entry
table     notice results say variable ordering strategies make dramatic
difference graphplans backward search  or dcsp compilation planning graph  
make claims utility fc dvo csp compilation planning graph 
    complementing ebl ddb forward checking dynamic variable ordering
although forward checking dynamic variable ordering approaches found particularly effective isolation graphplans backward search  thought would interesting
revisit context graphplan enhanced ebl ddb strategies  part original reasoning underlying expectation goal  variable  ordering significant
effect graphplan performance based fact failing goal sets stored in toto
memos  blum   furst        pp        reason longer holds use ebl ddb 
more  exists difference opinion whether forward checking
ddb fruitfully co exist  results  prosser        suggest domain filteringsuch
one afforded forward checking  degrades intelligent backtracking  recent work
 frost   dechter        bayardo   schrag        however seems suggest however best csp
algorithms capabilities 
adding plain dvo capability top ebl ddb presents difficulties  adding forward
checking require changes algorithm figure    difficulty arises
failure may occurred combined effect forward checking backtracking 
example  suppose four variables v  v  considered assignment
order  suppose v  domain f       g  v  cannot   v  a  cannot   v 
b  suppose v s domain contains d  constraint saying v  cant
  

fip lanning g raph

problem
huge fct
bw large b
rocket ext a
rocket ext b
att log a
tower  
tsp   

ebl
time btks 
         k 
        k 
      k 
      k 
         k 
         k 
        k 



csp

ebl dvo
time btks 
speedup
        k 
 x     x 
        k 
    x    x 
      k 
 x    x 
       k 
    x     x 
         k     x     x 
         k 
   x    x 
         k     x     x 

ebl fc dvo
time btks 
speedup
        k 
   x  x 
        k     x     x 
       k 
    x    x 
       k 
   x    x 
         k    x     x 
        k 
   x    x 
        k 
   x    x 

table    effect complementing ebl ddb dynamic variable ordering forward checking
strategies  speedup columns report two factorsthe first speedup time 
second speedup terms number backtracks  fc dvo tend
reduce number backtracks  reduction always seem show
time savings 

v  v     suppose using forward checking  assigned v    v 
values b  forward checking prunes     v  domain  leaving value   
point  try assign v  fail  use algorithm figure    conflict set v 
would fv    v    v  g  constraint violated v      v        v    d  however
sufficient since failure v  may occurred forward checking stripped
value   domain v    problem handled pushing v  v    variables
whose assignment stripped values v    v  conflict set    specifically  conflict
set every variable v initialized fv g begin with  whenever v loses value
forward checking respect assignment v     v   added conflict set v   whenever
future variable  such v    conflicts v    add conflict set v   rather v   
conflict set v    specifically line
set cs   cs   f l g
procedure figure   replaced line
set cs   cs   conflict set l 
incorporated changes implementation  support support forward checking  dynamic variable ordering well ebl graphplan  table   shows performance version experimental test suite  seen numbers  number
backtracks reduced    x case ebl dvo   x case
ebl fc dvo  cpu time improvements somewhat lower  got    x speedup
    notice possible values stripped v  domain may impact
failure assign v    example  perhaps another constraint says v  cant v  b 
case  strictly speaking  assignment v  cannot really blamed failure v    leads
non minimal explanations  reason expect strict minimization explanations pre requisite
effectiveness ebl ddb  see  kambhampati       

  

fik ambhampati

ebl dvo     x speedup ebl fc dvo  several cases  cpu times increase fc dvo  again  attribute overheads forward checking  and
lesser extent  dynamic variable ordering   importantly  comparing results
tables      see ebl ddb capabilities able bring significant speedups
even graphplan implementation using fc dvo 

   ebl ddb   randomized search
recent years seen increased use randomized search strategies planning  include
purely local search strategies  gerevini        selman  levesque    mitchell        well
hybrid strategies introduce random restart scheme top systematic search strategy
 gomes et al          blackbox planning system  kautz   selman        supports variety
random restart strategies top sat compilation planning graph  empirical
studies show strategies can  probabilistically speaking  scale much better purely
systematic search strategies 
wanted investigate  and much  ebl   ddb techniques help graphplan
even presence newer search strategies  ebl ddb techniques little
applicability purely local search strategies  could theory help random restart systematic
search strategies  random restart strategies motivated attempt exploit heavytail distribution  gomes et al         solution nodes search trees many problems 
intuitively  problems non trivial percentage easy find solutions
well hard find solutions  makes sense restart search find
spending much effort solution  restarting way  hope  probabilistically  hit
easier to find solutions 
implemented random restart strategy top graphplan making following simple
modifications backward search 
   keep track number times backward search backtracks one level
plan graph previous level  a level closer goal state   whenever number
exceeds given limit  called backtrack limit   search restarted  by going back last
level plan graph   assuming number restarts exceeded given
limit  search process two restarts referred epoch 
   supporting actions  values  proposition variable considered randomized
order  randomization ensures search restarted  look
values variable different order   
notice random restart strategy still allows application ebl ddb strategies  since
given epoch  behavior search identical standard backward
search algorithm  indeed  backtrack limit number restarts made larger
larger  whole search becomes identical standard backward search 
    reordering values variable doesnt make whole lot sense blackbox based sat encodings
thus boolean variables  thus  randomization blackbox done order goals
considered assignment  typically tends clash built in goal ordering strategies  such dvo
sat z  li   anbulagan          get around conflict breaking ties among variables randomly 
avoid clashes  decided randomize graphplan reordering values variable  picked inter level
backtracks natural parameter characterizing difficulty problem graphplans backward search 

  

fiproblem

 sol
  
   
   
   
   
  
  
  
  
  
   
   
    

normal graphplan
length
time av  mfsl
       
   
  k    k 
                
   k   k 
         
 
 k   k 
        
 
  k    k 
           
  
  k    k 
  k  k 
   k   k 
       
 
 k    k 
         
   
  k  k 
       
 
   k    k 
           
 
  k  k 
        
   
   k   k 
          
  
  k    k 

table    effect ebl ddb random restart graphplan  time measured cpu minutes allegro common lisp     running
linux    mhz pentium machine  numbers next problem names number steps actions shortest
plans reported problems literature  r b l parameters second column refer limits number
restarts  number backtracks number levels plan graph expanded  statistics averaged
multiple runs  typically          mfsl column gives average number memo based failures per searched level
plan graph  numbers parentheses total number memo based failures averaged runs  plan lengths
averaged successful runs 

csp

graphplan ebl ddb
length
time av  mfsl
      
   
   k   k 
          
   
    k   k 
          
   
    k   k 
        
       k    k 
        
       k    k 
         
    
 k   k 
        
       k    k 
         
       k    k 
               
 k    k 
         
  
  k    k 
          
   
  k    k 
       
       k    k 
       
       k    k 



 sol
   
    
    
    
    
   
   
    
   
    
    
    
    

p lanning g raph

  

att log a       
att log a       
att log a       
att log a       
att log a       
att log b       
att log b       
att log b       
att log c       
att log c       
rocket ext a      
rocket ext a      
rocket ext a      

parameters
r b l
       
         
         
         
         
       
         
         
       
         
         
         
         

fik ambhampati

check intuitions effectiveness ebl ddb randomized search indeed correct  conducted empirical investigation comparing performance random search
standard graphplan well graphplan ebl ddb capabilities  since search randomized  problem solved multiple number times      times cases   runtime  plan length statistics averaged runs  experiments conducted
given backtrack limit  given restart limit  well limit number levels
planning graph extended  last one needed randomized search  solution may
missed first level appears  leading prolonged extension planning graph
 inoptimal  solution found later level  limit number levels expanded 
probability finding solution increases  time  cpu time spent searching
graph increases 
implemented random restart search  first thing noticed improvement
solvability horizon  as expected  given results  gomes et al           table   shows
results  one important point note results table talk average plan
lengths cpu times  needed due randomization potentially run produce
different outcome  plan   secondly  graphplan systematic search guarantees shortest
plans  measured number steps   randomized search guarantee 
particular  randomized version might consider particular planning graph barren
solutions  based simply fact solution could found within confines given
backtrack limit number restarts 
graphplan  without ebl ddb  likely solve larger problems randomized
search strategies  example  logistics domain  att log a problem solvable
 within    hours real time  ebl systematic search  randomization added 
implementation able solve att log b att log c quite frequently  limits
number restarts  backtracks levels increased  likelihood finding solution well
average length solution found improves  example  graphplan ebl ddb able
solve att log b every trial    restarts      backtracks    levels limits  although
plans quite inoptimal  
next  perhaps interesting  question wanted investigate whether ebl
ddb continue useful graphplan uses randomized search  first blush 
seems importantafter even graphplan standard search may
luck able find solutions quickly presence randomization  thought
however suggests ebl ddb may still able help graphplan  specifically 
help graphplan using given backtrack limit judicious fashion  elaborate  suppose
random restart search conducted     backtracks    restarts  ebl
ddb  graphplan able pinpoint cause failure accurately without ebl
ddb  means search backtracks  chance backtrack
 or similar  reasons reduced  turn gives search chance
catching success one number epochs allowed  addition
direct benefit able use stored memos across epochs cut search 
seen data table    given set limits number restarts  number
backtracks  number levels expanded  graphplan ebl ddb able get higher
percentage solvability well significantly shorter length solutions  both terms levels
terms actions   get comparable results standard graphplan  significantly
increase input parameters  restarts  backtracks levels expanded   turn led dra  

fip lanning g raph



csp

matic increases average run time  example  att log a problem    restarts
   backtracks     levels limit  graphplan able solve problem     time 
average plan length    steps    actions  contrast  without ebl ddb  graphplan
able solve problem    cases  average plan length    steps    
actions  double restarts backtracks  ebl ddb version goes      solvability
average plan length       steps       actions  standard graphplan goes    
solvability plan length      steps     actions  increase number levels    
standard graphplan solves     problems average plan length      steps
    actions  takes    restarts     backtracks  well    level limit standard
graphplan able cross     solvability  time  average run time    minutes 
average plan length    steps     actions  contrast     solvability     minutes    step    action plans provided graphplan ebl   restarts
   backtracks significant  similar results observed problems  logistics
 att log b  att log c  domains  rocket ext a  rocket ext b  
results show graphplan ebl ddb able generate reuse memos effectively across different restart epochs  specifically  numbers columns titled av  mfsl
give average number memo based failures per search level    note cases 
average number memo based failures significantly higher graphplan ebl
normal graphplan  shows ebl ddb analysis helping graphplan reduce wasted effort
significantly  thus reap better benefits given backtrack restart limits 

   related work
original implementation graphplan  blum furst experimented variation
memoization strategy called subset memoization  strategy  keep memo generation
techniques same  change way memos used  declaring failure stored memo
found subset current goal set  since complete subset checking costly 
experimented partial subset memoization subsets length n n    
considered n sized goal set 
mentioned earlier  koehler co workers  koehler et al         re visited
subset memoization strategy  developed effective solution complete subset checking
involves storing memos data structure called ub tree  instead hash tables 
results experiments subset memoization mixed  indicating subset memoization seem improve cpu time performance significantly  reason quite
easy understand improved memo checking time ub tree data structure 
still generating storing old long memos  contrast  ebl ddb extension
described supports dependency directed backtracking  reducing average length
stored memos  increases utility significantly  thus offering dramatic speedups 
verify main source power ebl ddb graphplan ebl ddb part
ub tree based memo checking  re ran experiments ebl ddb turned off 
    notice number search levels may different  and smaller than  number planning graph levels 
graphplan initiates search none goals pair wise mutex other  att log a 
att log b att log c  happens starting level    rocket ext a happens starting level    numbers
parentheses total number memo based failures  divide number average number levels
search conducted get av  mfsl statistic 

  

fik ambhampati

problem
huge fact
bw large b
rocket ext a
rocket ext b
att log a

tt
    
    
    
    
    hrs

mt
 
    
    
    
 

 btks
    k
    k
    k
    k
 

ebl x 
    x
    x
  x
   x
    x

 gen
     
     
     
     
 

 fail
     
     
      
      
 

avfm
    
    
   
   
 

avln
     
     
     
     
 

table    performance subset memoization ub tree data structure  without ebl ddb  
tt total cpu time mt time taken checking memos   btks
number backtracks  eblx amount speedup offered ebl ddb subset
memoization  gen lists number memos generated  and stored    fail lists
number memo based failures  avfm average number failures identified per
generated memo avln average length stored memos 

subset memo checking ub tree data structure still enabled  results shown
table    columns labeled avfm show expected subset memoization improve
utility stored memos normal graphplan  since uses memo scenarios
normal graphplan can   however  note subset memoization
dramatic impact performance graphplan  ebl ddb capability significantly
enhance savings offered subset memoization 
 kambhampati         describe general principles underlying ebl ddb techniques
sketch extended dynamic constraint satisfaction problems  development
paper seen application ideas there  readers needing background
ebl ddb thus encouraged review paper  related work includes previous attempts applying ebl ddb planning algorithms  work ucpop ebl system
 kambhampati et al          one interesting contrast ease ebl ddb added
graphplan compared ucpop system  part difference comes fact
search graphplan ultimately propositional dynamic csp  ucpops search
variablized problem solving search 
mentioned section    graphplan planning graph compiled normal csp
representation  rather dynamic csp representation  used dynamic csp representation corresponds quite directly backward search used graphplan  saw
model provides clearer picture mutex propagation memoization strategies  helps us
unearth sources strength graphplan memoization strategyincluding fact
memos conservative form no good learning obviate need no good
management strategies large extent 
dynamic csp model may account peculiarities results
empirical studies  example  widely believed csp literature forward checking
dynamic variable ordering either critical as  perhaps even critical than  ebl ddb
strategies  bacchus   van run        frost   dechter         results however show
graphplan  uses dynamic csp model search  dvo fc largely ineffective
compared ebl ddb standard graphplan  extent  may due fact

  

fip lanning g raph



csp

graphplan already primitive form ebl built memoization strategy  fact  blum
  furst        argue memoization minimal action set selection  an action set
considered minimal possible remove action set still support
goals actions selected   ordering goals little effect  especially
earlier levels contain solution  
another reason ineffectiveness dynamic variable ordering heuristic may
differences csp dcsp problems  dcsp  main aim
quickly find assignment current level variables  rather find assignment
current level likely activate fewer easier assign variables  whose assignment
turn leads fewer easier assign variables on  general heuristic picking
variable smallest  live  domain necessarily make sense dcsp  since variable
two actions supporting may actually much harder handle another many
actions supporting it  actions supporting first one eventually lead activation
many harder assign new variables  may thus worth considering ordering strategies
customized dynamic csp modelse g  orderings based number
 and difficulty  variables get activated given variable  or value  choice 
recently experimented value ordering heuristic picks value assigned variable using distance estimates variables activated choice
 kambhampati   nigenda         planning graph provides variety ways obtaining
distance estimates  simplest idea would say distance proposition p level
p enters planning graph first time  distance estimate used
rank variables values  variables ranked simply terms distancesthe
variables highest distance chosen first  akin fail first principle   value ordering
bit trickierfor given variable  need pick action whose precondition set lowest
distance  distance precondition set computed distance individual
preconditions several ways 





maximum distances individual propositions making preconditions 
sum distances individual propositions making preconditions 
first level set propositions making preconditions present
non mutex 

 kambhampati   nigenda         evaluate goal value ordering strategies based
ideas  show lead quite impressive  upto   orders magnitude
tests  speedups solution bearing planning graphs  relate distances computed
planning graph distance transforms computed planners hsp  bonet  loerincs   
geffner        unpop  mcdermott         idea using planning graph basis
computing heuristic distance metrics investigated context state space search
 nguyen   kambhampati         interesting finding paper even one
using state space instead csp style solution extraction  ebl still useful lazy demanddriven approach discovering n ary mutexes improve informedness heuristic 
specifically  long   kambhampati describe method limited run graphplans backward search  armed ebl ddb used pre processing stage explicate memos  n ary
mutexes  used significantly improve effectiveness heuristic
state search 
  

fik ambhampati

general importance ebl   ddb csp sat problems well recognized  indeed 
one best systematic solvers propositional satisfiability problems relsat  bayardo  
schrag         uses ebl  ddb  forward checking  randomized version relsat
one solvers supported blackbox system  kautz   selman         compiles
planning graph sat encoding  ships various solvers  blackbox thus offers
way indirectly comparing dynamic csp static csp models solving planning
graph  discussed section      main differences blackbox needs compile
planning graph extensional sat representation  makes harder blackbox
exploit results searches previous levels  as graphplan stored memos  
leads memory blowups  latter particularly problematic techniques
condensing planning graphs  bi level representation discussed  fox   long       
smith   weld        effective compile planning graph sat 
flip side  blackbox allows non directional search  opportunity exploit existing sat
solvers  rather develop customized solvers planning graph  present  clear
whether either approaches dominates other  informal experiments  found
certain problems  att log x  easier solve non directional search offered
blackbox  others  gripper x  easier solve graphplan backward
search  results recent aips planning competition inconclusive respect
 mcdermott        
main rationale focusing dynamic csp model planning graph due
closeness graphplans backward search  gelle        argues keeping activity constraints
distinct value constraints several advantages terms modularity representation 
graphplan  advantage becomes apparent activation constraints known
priori  posted dynamically search   case several extensions
graphplan algorithm handle conditional effects  kambhampati et al         anderson  smith 
  weld        koehler et al          incomplete initial states  weld  anderson    smith        
although ebl ddb strategies try exploit symmetry search space improve
search performance  go far enough many cases  example  gripper domain 
real difficulty search gets lost combinatorics deciding hand used
pick ball transfer next rooma decision completely irrelevant
quality solution  or search failures  matter   ebl ddb allow graphplan
cut search bit  allowing transfer    balls one room another 
come beyond    balls  two possible ways scaling further  first
variablize memos  realize certain types failures would occurred irrespective
actual identity hand used  variablization  called generalization part
ebl methods  kambhampati        kambhampati et al          another way scaling
situations would recognize symmetry inherent problem abstract
resources search   srivastava   kambhampati         describe type resource
abstraction approach graphplan 

    conclusion future work
paper  traced connections graphplan planning graph csp  motivated need exploiting csp techniques improve performance graphplan backward search  adapted evaluated several csp search techniques contest graph 

  

fip lanning g raph



csp

plan  included ebl  ddb  forward checking  dynamic variable ordering  sticky values 
random restart search  empirical studies show ebl ddb particularly useful dramatically speeding graphplans backward search  by tp     x instances   speedups
improved  by  x  addition forward checking  dynamic variable ordering sticky values top ebl ddb  showed ebl ddb techniques equally
effective helping graphplan  even random restart search strategies used 
secondary contribution paper clear description connections
graphplan planning graph   dynamic  constraint satisfaction problem  connections
help us understand unique properties graphplan memoization strategy  viewed
csp standpoint  see section    
several possible ways extending work  first would support
use learned memos across problems  or specification problem changes 
case replanning   blum   furst        suggest promising future direction 
ebl framework described makes extension feasible  discussed  kambhampati 
      schiex   verfaillie         supporting inter problem usage involves contextualizing
learned no goods  particular  since soundness memos depends initial state
problem  given operators change problem problem   inter problem usage
memos supported tagging learned memo specific initial state literals
supported memo  memos used corresponding level new problem
long initial state justification holds new problem  initial state justification
memos computed incrementally procedure first justifies propagated mutex
relations terms initial state  justifies individual memos terms justifications
mutexes memos derived 
success ebl ddb approaches graphplan part due high degree redundancy planning graph structure  example  propositions  actions  level l
planning graph superset propositions  actions  level l      mutexes  memos 
level l subset mutexes  memos  level l       ebl ddb techniques help
graphplan exploit redundancy avoiding previous failures  exploitation redundancy pushed further  indeed  search graphplan planning graph size l
almost re play search planning graph size l      with additional
choices    zimmerman   kambhampati         present complementary technique called
explanation guided backward search attempts exploit deja vu property graphplans backward search  technique involves keeping track elaborate trace search
level l  along failure information   termed pilot explanation level l  using
pilot explanation guide search level l      way ebl ddb help process
significantly reduce size pilot explanations need maintained  preliminary
results technique shows complements ebl ddb provides significant
savings search 
acknowledgements
research supported part nsf young investigator award  nyi  iri          arpa rome
laboratory planning initiative grant f         c       army aasert grant daah             afosr grant f                nsf grant iri          thank maria fox derek
long taking time implement experiment ebl ddb stan system 

  

fik ambhampati

would thank them  well terry zimmerman  biplav srivastava  dan weld  avrim
blum steve minton comments previous drafts paper  special thanks due
dan weld  hosted university washington summer       spent time discussing
connections csp graphplan  finally  thank mark peot david smith
clean lisp implementation graphplan algorithm  served basis extensions 

references
anderson  c   smith  d     weld  d          conditional effects graphplan  proc  ai planning
systems conference 
bacchus  f     van run  p          dynamic variable ordering csps  proc  principles
practice constraint programming  cp      published lecture notes artificial intelligence  no       springer verlag 
bayardo  r     schrag  r          using csp look back techniques solve real world sat instances  proc  aaai    
blum  a     furst  m          fast planning planning graph analysis  artificial intelligence 
        
bonet  b   loerincs  g     geffner  h          robust fast action selection mechanism
planning  proc  aaai    
do  b     kambhampati  s          solving planning graph compiling csp  proc   th
international conference ai planning scheduling 
do  b   srivastava  b     kambhampati  s          investigating effect relevance reachability constraints sat encodings planning  proc   th international conference
ai planning scheduling 
fox  m          private correspondence  
fox  m     long  d          efficient implementation plan graph  journal artificial intelligence research     
frost  d     dechter  r          search best constraint satisfactions earch  proc  aaai   
gelle  e          generation locally consistent solution spaces mixed dynamic constraint problems  ph d  thesis  ingenieure informaticienne epfl de nationalite suisse  lausanne  switzerland 
gerevini  a          fast planning greedy planning graphs  proc  aaai    
gomes  c   selman  b     kautz  h          boosting combinatorial search randomization 
proc  aaai     pp         
kambhampati  s          challenges bridging plan synthesis paradigms  proc  ijcai    

  

fip lanning g raph



csp

kambhampati  s          relations intelligent backtracking explanation based
learning planning constraint satisfaction  artifical intelligence           
kambhampati  s          improving graphplans search ebl   ddb techniques  proc  ijcai   
kambhampati  s   katukam  s     qu  y          failure driven dynamic search control partial
order planners  explanation based approach  artificial intelligence                  
kambhampati  s     nigenda  r          distance based goal ordering heuristics graphplan 
proc   th international conference ai planning scheduling 
kambhampati  s   parker  e     lambrecht  e          understanding extending graphplan 
proceedings  th european conference planning  url  rakaposhi eas asu edu ewspgraphplan ps 
kautz  h     selman  b          pushing envelope  plannng  propositional logic stochastic
search  proc  aaai    
kautz  h     selman  b          blackbox  unifying sat based graph based planning  proc 
ijcai    
koehler  j   nebel  b   hoffman  j     dimopoulos  y          extending planning graphs adl
subset  tech  rep      albert ludwigs university 
li  c     anbulagan         heuristics based unit propagation satisfiability problems 
proc  ijcai    
mcdermott 
d 
       
aips   
planning
ftp cs yale edu pub mcdermott aipscomp results html 

competition

results 

mcdermott  d          using regression graphs control search planning  aritificial intelligence                   
mittal  s     falkenhainer  b          dynamic constraint satisfaction problems  proc  aaai    
nguyen  x     kambhampati  s          extracting effective admissible state space heuristics
planning graph  tech  rep  asu cse tr        arizona state university 
prosser  p          domain filtering degrade intelligent backtracking search  proc  ijcai    
rymon  r          set enumeration trees  proc  krr    
schiex  t     verfaillie  g          nogood recording static dynamic constraint satisfaction
problems  proc   th intl  conference tools artificial intelligence 
selman  b   levesque  h     mitchell  d          gsat  new method solving hard satisfiability
problems  proc  aaai    
smith  d     weld  d          temporal planning mutual exclusion reasoning  proc 
ijcai    
  

fik ambhampati

srivastava  b     kambhampati  s          scaling planning teasing resource scheduling 
proc  european conference planning 
tsang  e          foundations constraint satisfaction  academic press  san diego  california 
weld  d   anderson  c     smith  d          extending graphplan handle uncertainty   sensing
actions  proc  aaai    
zimmerman  t     kambhampati  s          exploiting symmetry plan graph via
explanation guided search  proc  aaai    

  


