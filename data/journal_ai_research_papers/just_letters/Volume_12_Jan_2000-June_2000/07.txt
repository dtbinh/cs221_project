journal of artificial intelligence research                  

submitted        published     

on reasonable and forced goal orderings and their use in
an agenda driven planning algorithm

jana koehler ch schindler com

jana koehler
schindler lifts  ltd 
r   d technology management
     ebikon  switzerland
jorg hoffmann
institute for computer science
albert ludwigs university
georges kohler allee  geb    
      freiburg  germany

hoffmann informatik uni freiburg de

abstract

the paper addresses the problem of computing goal orderings  which is one of the
longstanding issues in ai planning  it makes two new contributions  first  it formally
defines and discusses two different goal orderings  which are called the reasonable and the
forced ordering  both orderings are defined for simple strips operators as well as for
more complex adl operators supporting negation and conditional effects  the complexity
of these orderings is investigated and their practical relevance is discussed  secondly  two
different methods to compute reasonable goal orderings are developed  one of them is
based on planning graphs  while the other investigates the set of actions directly  finally 
it is shown how the ordering relations  which have been derived for a given set of goals
g   can be used to compute a so called goal agenda that divides g into an ordered set of
subgoals  any planner can then  in principle  use the goal agenda to plan for increasing
sets of subgoals  this can lead to an exponential complexity reduction  as the solution to a
complex planning problem is found by solving easier subproblems  since only a polynomial
overhead is caused by the goal agenda computation  a potential exists to dramatically speed
up planning algorithms as we demonstrate in the empirical evaluation  where we use this
method in the ipp planner 
   introduction

how to effectively plan for interdependent subgoals has been in the focus of ai planning
research for a very long time  starting with the early work on abstrips  sacerdoti       
or on conjunctive goal planning problems  chapman         quite a number of approaches
have been presented and the complexity of the problems has been studied  but until today 
planners have made only some progress in solving bigger planning instances and scalability
of classical planning systems is still a problem 
in this paper  we focus on the following problem  given a set of conjunctive goals  can
we define and detect an ordering relation over subsets from the original goal set  to arrive
at such an ordering relation over subsets  we first focus on the atomic facts contained in the
goal set  we formally define two closely related ordering relations over such atomic goals 
c      ai access foundation and morgan kaufmann publishers  all rights reserved 

fikoehler   hoffmann
which we call reasonable and forced ordering  and study their complexity  it turns out that
both are very hard to decide 
consequently  we introduce two ecient methods that can both be used to approximate
reasonable goal orderings  the definitions are first given for simple strips domains  where
the desired theoretical properties can be easily proven  afterwards  we extend our definitions
to adl operators  pednault        handling conditional effects and negative preconditions 
and discuss why we do not further invest any effort in trying to find forced orderings 
we show how a set of ordering relations between atomic goals can be used to divide the
goal set into disjunct subsets  and how these subsets can be ordered with respect to each
other  the resulting sequence of subsets comprises the so called goal agenda  which can
then be used to control an agenda driven planning algorithm 
the method  called goal agenda manager  is implemented in the context of the ipp
planning system  where we show its potential of exponentially reducing computation times
on certain planning domains 
the paper is organized as follows  section   introduces and motivates reasonable and
forced goal orderings  starting with simple strips operators  they are formally defined 
and their complexity is investigated  in section    we present two methods  which compute an approximation of the reasonable ordering and discuss both orderings from a more
practical point of view  the section concludes with an extension of our definitions to adl
operators having conditional effects  section   shows how a planning system can benefit
from ordering information by computing a goal agenda that guides the planner  we define
how subsets of goals can be ordered with respect to each other and discuss how a goal
agenda can affect the theoretical properties  in particular the completeness of a planning
algorithm  section   contains the empirical evaluation of our work  showing results that we
obtained using the goal agenda in ipp  in section   we summarize our approach in the light
of related work  the paper concludes with an outlook on possible future research directions
in section   
   ordering relations between atomic goals

for a start  we only investigate simple strips domains just allowing sets of atoms to
describe states  the preconditions  and the add and delete lists of operators 
definition    state  the set of all ground atoms is denoted with p   a state s     is a
p

subset of ground atoms 

note that all states are assumed to be complete  i e   we always know for an atom p whether
p   s or p    s holds  we also assume that all operator schemata are ground  i e   we only
talk about actions 
definition    strips action  a strips action o has the usual form
pre o    add add o  del del o 
where pre o  are the preconditions of o  add o  is the add list of o and del o  is the delete
list of the action  each being a set of ground atoms  we also assume that del o    add o      
the result of applying a strips action to a state is defined as usual 
   

fion reasonable and forced goal orderings

result s  o    



 s   add o   n del o  if pre o   s
otherwise

s

if pre o   s holds  the action is said to be applicable in s  the result of applying a
sequence of more than one action to a state is recursively defined as
result s  ho            o

i     result result s  ho            o   i   o   
definition    planning problem  a planning problem  o  i   g   is a triple where o is
the set of actions  and i  the initial state  and g  the goals  are sets of ground atoms  a
plan p is an ordered sequence of actions  if all actions in a plan are taken out of a certain
action set o  we denote this by writing p o  
n

n

n

note that we define a plan to be a sequence of actions  not a sequence of parallel steps 
as it is done for graphplan  blum   furst         for example  this makes the subsequent
theoretical investigation more readable  the results directly carry over to parallel plans 
given two atomic goals a and b   various ways to define an ordering relation over
them can be imagined  first  one can distinguish between domain specific and domainindependent goal ordering relations  but although domain specific orderings can be very
effective  they need to be redeveloped for each single domain  therefore  one is in particular
interested in domain independent ordering relations having a broader range of applicability 
secondly  following hullem et al          one can distinguish the goal selection and the goal
achievement order  the first ordering determines in which order a planner works on the
various atomic goals  while the second one determines the order  in which the solution
plan achieves the goals  in this paper  we compute an ordering of the latter type  in
the agenda driven planning approach that we propose later in the paper  both orderings
coincide anyway  the goals that are achieved first in the plan are those that the planner
works on first 
the following scenario motivates how an achievement order for goals can be possibly
defined  given two atomic goals a and b   for which a solution plan exists  let us assume
the planner has just achieved the goal a  i e   it has arrived at a state s        in which a
holds  but b does not hold yet  now  if there exists a plan that is executable in s     
and achieves b without ever deleting a  a solution has been found  if no such plan can be
found  then two possible reasons exist 
   the problem is unsolvable achieving a first leads the planner into a deadlock situation  thus  the planner is forced to achieve b before or simultaneously with a 
   the only existing solution plans have to destroy a temporarily in order to achieve b  
but then  a should not be achieved first  instead  it seems to be reasonable to achieve
b before or simultaneously with a for the sake of shorter solution plans 
in the first situation  the ordering  b before or simultaneously with a  is forced by inherent properties of the planning domain  in the second situation  the ordering  b before or
simultaneously with a  appears to be reasonable in order to avoid non optimal plans  consequently  we will define two goal orderings  called the forced and the reasonable ordering 
for the sake of clarity  we first give some more basic definitions 
a 

b

a 

   

b

fikoehler   hoffmann
definition    reachable state  let  o  i   g   be a planning problem and let p be the

set of ground atoms that occur in the problem  we say that a state s  p is reachable  iff
there exists a sequence ho            o i out of actions in o for which s   result i   ho            o i 
holds 
n

n

definition    generic state s        let  o  i   g   be a planning problem  by s   
a 

b

a 

b

 

we denote any reachable state in which a has just been achieved  but b is false 
i e   b    s      and there is a sequence of actions ho            o i such that s       
result i   ho            o i   with a   add o   
a 

n

b

n

a 

b

n

one can imagine s      as a state about which we only have incomplete information 
all the states s it represents satisfy s j  a   b   but the other atoms p   p with p    a  b
can adopt arbitrary truth values 
definition    reduced action set o   let  o  i   g   be a planning problem  and let
a 

b

a

a   g be an atomic goal  by o we denote the set of all actions that do not delete a 
i e   o   fo   o j a    del o g 
a

a

we are now prepared to define what we exactly mean by forced and reasonable goal orderings 
definition    forced ordering    let  o  i   g   be a planning problem  and let a  b  
g be two atomic goals  we say that there is a forced ordering between b and a  written
f

b  a  if and only if
f

     p o   b   result s        p o  
if definition   is satisfied  then each plan achieving a and b must achieve b before
or simultaneously with a  because otherwise it will encounter a deadlock  rendering the
problem unsolvable 
definition    reasonable ordering    let  o  i   g   be a planning problem  and let
a  b   g be two atomic goals  we say that there is a reasonable ordering between b and

  s 

 

a 

b

 

a 

b

r

a  written b  a  if and only if
r

  s           p oa   b   result s        p oa  
definition   gives b  a the meaning that if  after the goal a has been achieved  there
a 

b

a 

b

r

is no plan anymore that achieves b without at least temporarily destroying a  then b
is a goal prior to a 
we remark that obviously b  a implies b  a  but not vice versa  we also make
a slightly less obvious observation at this point  the formulae in definitions   and   use
a universal quantification over states s        if in a planning problem there is no such
state at all  the formulae are satisfied and the goals a and b get ordered  i e   b  a and
b  a follow  respectively  in this case  however  there is not much information gained
by a goal ordering between a and b   because any sequence of actions will achieve b prior
or simultaneously with a a cannot be achieved with b still being false  thus in this
case  the ordering relations b  a and b  a are trivial in the sense that no reasonable
planner would invest much effort in considering the goals a and b ordered the other way
round anyway 
r

f

a 

b

f

r

f

r

   

fion reasonable and forced goal orderings
definition    trivial ordering relation  let  o  i   g   be a planning problem  and let
a  b   g be two atomic goals  an ordering relation b
there is no state s       
a 



f

a or b  a is called
r

trivial iff

b

in this paper  we will usually consider forced and reasonable goal orderings as non trivial
orderings and make the distinction explicit only if we have to do so 
definitions   and   seem to deliver promising candidates for an achievement order 
unfortunately  both are very hard to test  it turns out that their corresponding decision
problems are pspace hard 
theorem   let f order denote the following problem 

given two atomic facts a and b   as well as an action set o and an initial state i   does
b  a hold  
f

deciding f order is pspace hard 

proof  the proof proceeds by polynomially reducing

plansat  bylander        the
decision problem of whether there exists a solution plan for a given arbitrary strips
planning instance to the problem of deciding f order 

let i   g   and o denote the initial state  the goal state  and the action set in an arbitrary
strips instance  let a  b   and c be new atomic facts not contained in the instance so
far  we build a new action set and initial state for our f order instance by setting

 
 
o     o    

o 
o 
o
i
i

g

 
  add fag del fc g   
  add i del fag   
  add fb g del  

  fc g
  fag
 g

and

i      fc g
with these definitions  reaching b from a is equivalent to solving the original problem  the
other way round  unreachability of b from a forced ordering b  a is equivalent to
the unsolvability of the original problem  in order to prove this  we consider the following 
the only way of achieving a is by applying o   to i     consequently  the only state s     
is fag  cf  definition    thus starting with the assumption that b  a is valid  we apply
the following equivalences 
f

i

a 

b

f

b a
f

 
 
 
 

  s           p o    b   result s        p o   
cf  definition  
 
 
   p o   b   result fag  p o  
fag is the only reachable state s     
   p o   g  result i   p o  
with the definition of o  
no solution plan exists for i   g and given o
a 

b

a 

b

a 

   

b

fikoehler   hoffmann
thus  the complement of plansat can be polynomially reduced to f order  as pspace
  co pspace  we are done 
theorem   let r order denote the following problem 

given two atomic facts a and b   as well as an action set o and an initial state i   does
b  a hold  
deciding r order is pspace hard 
r

proof  the proof proceeds by polynomially reducing plansat to r order 

let i   g   and o be the initial state  the goal state  and the action set in an arbitrary
strips planning instance  let a  b   c   and d be new atomic facts not contained in the
instance so far  we define the new action set o  by setting
 
 
o     fc g
  add fa  dg del fc g   
 
o     o     o     fa  dg   add i del fdg 
 
o  g
  add fb g del  
i
i

g

and the new initial state by

i      fc g

as in the proof of theorem    the intention behind these definitions is to make solvability
of the original problem equivalent to reachability of b from a  for reasonable orderings 
reachability is concerned with actions that do not delete a  which is why we need the safety
condition d 
precisely  the only way to achieve a is by applying o   to i    i e   per definition   the
only state s      is fa  dg  as no action in the new operator set o  deletes a  we have
the following sequence of equivalences 
i

a 

b

b a
  s         p oa    b   result s       p oa   
   p oa    b   result fa  dg  p oa   
r

 
 
     p o    b   result fa  dg  p o   
     p o such that g  result i   p o  
  no solution plan exists for i   g   o
a 

b

a 

b

cf  definition

fa  dg is the only reachable state s     
no action in o   deletes a
with the definition of o  
a 

b

thus  the complement of plansat can be polynomially reduced to r order  with
pspace   co pspace  we are done 
consequently  finding reasonable and forced ordering relations between atomic goals is
already as hard as the original planning problem and it appears unlikely that a planner will
gain any advantage from doing that  a possible way out of the dilemma is to define new
ordering relations  which can be decided in polynomial time and which are  ideally  sucient
for the existence of reasonable or forced goal orderings  in the following  we introduce two
such orderings 
   

 

fion reasonable and forced goal orderings
   the computation of goal orderings

in this section  we will
   define a goal ordering    which can be computed using graphplan s exclusivity
information about facts  we prove that this ordering is sucient for  and that it
can be decided in polynomial time  the subscript  e  stands for  ecient   
   define a goal ordering    which is computed based on a heuristic method that is
much faster than the computation based on graphplan  and also delivers powerful
goal ordering information  the subscript  h  stands for  heuristic   
   discuss that most of the currently available benchmark planning domains do not contain forced orderings  i e    will fail in providing a problem decomposition for them 
   show how our orderings can be extended to handle more expressive adl operators 
e

r

h

f

    reasonable goal orderings based on graphplan

a goal ordering is always computed for a specific planning problem involving an initial
state i   a goal set g  fa  b g  and the set o of all ground actions  in order to develop an
ecient computational method  we proceed in two steps now 
   we compute more knowledge about the generic state s       
   we define the relation  and investigate its theoretical properties  in particular  we
prove that  implies   
a 

b

e

e

r

the state s      represents states that are reachable from i   and in which a has
been achieved  but b does not hold  given this information about s        one can derive
additional knowledge about it  in particular  it is possible to determine a subset of atoms f 
of which one definitely knows that f   s          must hold  one method to determine f is
obtained via the computation of invariants  i e   logical formulae that hold in all reachable
states  cf   fox   long         after having determined the invariants  one assumes that a
holds  but b does not  and then computes the logical implications  another possibility is to
simply use graphplan  blum   furst         starting from i with o  the planning graph
is built until the graph has leveled off at some time step  the proposition level at this time
step represents a set of states  which is a superset of all states that are reachable from i
when applying actions from o  all atoms  which are marked as mutually exclusive  blum
  furst        of a in this level can never hold in a state satisfying a  thus  they cannot
hold in s        we denote this set with f  the false set with respect to a returned by
 
graphplan 
f
   fp j p is exclusive of a when the graph has leveled offg
   
note that the planning graph is only grown once for a given i and o  but can be used to
determine the f sets for all atomic goals a   g  
a 

b

a 

a 

a 

b

b

a
gp

b

a
gp

a

gp

   we assume the reader to be familiar with graphplan  because this planning system is very well known in
the planning research community  otherwise   blum   furst        provide the necessary background 

   

fikoehler   hoffmann

  s     holds for all states s
i using actions from o 
lemma  

a

fgp

a

a

satisfying a   s that are reachable from
a

the proof follows immediately from the definitions of  level off  and  two propositions
being mutual exclusive  given in  blum   furst        
we now provide a simple test which is sucient for the existence of a reasonable ordering
b  a between two atomic goals a and b  
definition     ecient ordering    let  o  i   g  fa  b g  be a planning problem 
r

e

let f

a

gp

be the false set for a  the ordering b  a holds if and only if
e

  o   o   b   add o    pre o    f     
a
gp

a

this means  b is ordered before a if the reduced action set only contains actions  which
either do not have b in their add lists or if they do  then they require a precondition which
is contained in the false set  such preconditions can never hold in a state satisfying a and
thus  these actions will never be applicable 
theorem  
b a b a
e

r

proof  assume that b   a  i e   b   result s        p oa   for a reachable state s   
r

a 

b

a 

b

 

with a   s        b    s        and a plan p oa   ho            o i where o   o for    i  n 
as a    del o   for all i  definition     we have
a   result s        ho            o i  for    i  n
and  with lemma   
f
  result s        ho            o i      for    i  n
   
furthermore  as b    s        but b   result s        ho            o i   there must be a
step which makes b true  i e  
    k  n   b    result s       ho            o  i    b   result s       ho            o i 
for this step  we obviously have b   add o   and consequently  with the definition
of b  a  pre o     f       now  as o must be applicable in the state where it
is executed  otherwise it would not add anything to this state   the preconditions of o
must hold  i e   pre o    result s        ho            o   i   this immediately leads to f  
result s        ho            o   i        which is a contradiction to equation     
quite obviously  the ordering  can be decided in polynomial time 
a 

b

a 

n

b

i

a

i

a 

i

b

a

a 

gp

a 

i

b

b

a 

a 

n

b

k

b

a 

b

k

k

e

a
gp

k

k

k

k

a 

b

a 

a
gp

k

b

k

e

theorem   let e order denote the following problem 

given two atomic facts a and b   as well as an initial state i and an action set o  does

b  a hold  
e

then  e order can be decided in polynomial time 
   

e order

  p 

fion reasonable and forced goal orderings
proof  to begin with  we need to show that computing f

takes only polynomial time 
from the results in  blum   furst         it follows directly that building a planning graph
is polynomial in jij  joj  l and t  where l is the maximal length of any precondition  add
or delete list of an action  and t is the number of time steps built  taking l as a parameter
of the input size  it remains to show that a planning graph levels off after a polynomial
number t of time steps  now  a planning graph has leveled off if between some time steps
t and t     neither the set of facts nor the number of exclusion relations change  between
two subsequent time steps  the set of facts can only increase facts already occuring in the
graph remain there and the number of exclusions can only decrease non exclusive facts
will be non exclusive in all subsequent layers  thus  the maximal number of time steps to
be built until the graph has leveled off is dominated by the maximal number of changes
that can occur between two subsequent layers  which is dominated by the maximal number
of facts plus the maximal number of exclusion relations  the maximal number of facts is
o jij   joj  l   and the maximal number of exclusions is o  jij   joj  l      the square of
the maximal number of facts 
having computed f in polynomial time  testing b  a involves looking at all actions
in o  and rejecting them if they either
 delete a  which is decidable in time o l   or
 have a precondition  which is an element of f   decidable in time o l   jij   joj l   
thus we have an additional runtime for the test  which is o joj  l   jij   joj  l   
a
gp

a
gp

e

a
gp

let us consider the following example  which illustrates the computation of  using
a common representational variant of the blocks world with actions to stack  unstack 
pickup  and putdown blocks 
e

pickup  ob 

clear  ob  on table  ob  arm empty  

  add holding  ob 

del clear  ob  on table  ob  arm empty   

putdown  ob 
holding  ob 

  add clear  ob  arm empty   on table  ob 
del holding  ob  

stack  ob  underob 

clear  underob  holding  ob 

unstack  ob  underob 

  add arm empty   clear  ob  on  ob  underob 
del clear  underob  holding  ob  

on  ob  underob  clear  ob  arm empty  

  add holding  ob  clear  underob 

del on  ob  underob  clear  ob  arm empty   

given the simple task of stacking three blocks 
initial state  on table a  on table b  on table c 
goal state  on a b  on b c 
   

fikoehler   hoffmann
is there a reasonable ordering between the two atomic goals  intuitively  the blocks world
domain possesses a very natural goal ordering  namely that the planner should start building
each tower from the bottom to the top and not the other way round  
let us first investigate whether the relation on a  b   on b  c  holds  vividly speaking 
it asks whether it is still possible to stack the block a on b after on b  c  has been achieved 
as a first step  we run graphplan to find out which atoms are exclusive of on b  c  when
the planning graph  which corresponds to this problem  has leveled off  the result is
e

 

 

on b c

fgp

  fclear c   on table b   holding c   holding b   on a c   on c b   on b a g

one observes immediately that these atoms can never be true in a state that satisfies

on b  c  

secondly  we remove all ground actions which delete on b  c   in this case  only the action
    
now we are ready to test if on a  b   on b  c  holds  the only action  which can add
on a  b  is stack a b   it has the preconditions holding a  and clear b   neither of which
is a member of f       the test fails and we get on a  b    on b  c  
as a next step  we test whether on b  c   on a  b  holds  graphplan returns the
following false set 

unstack b c  satisfies this condition  and obtain the reduced action set o

on b c

e

on b c

e

gp

e

 

 

on a b

fgp

  fclear b   on table a   holding b   holding a   on a c   on c b   on b a g

the action unstack a b  is not contained in o     because it deletes on a  b   the
only action which adds on b  c  is stack b c   it needs the preconditions clear c  and
holding b   the second precondition holding b  is contained in the set of false facts 
i e   holding b    f     and thus  we conclude on b  c   on a  b   altogether  we have
on a  b    on b  c  and on b  c   on a  b   which correctly reects the intuition that b
needs to be stacked onto c before a can be stacked onto b 
although  appears to impose very strict conditions on a domain in order to derive a
reasonable goal ordering  it succeeds in finding reasonable goal orderings in all available test
domains in which such orderings exists  for example  in the tyreworld  in bulldozer problems 
in the shopping problem  russel   norvig         the fridgeworld  the glass domain  the
tower of hanoi domain  the link world  and the woodshop  its only disadvantage are the
computational resources it requires  since building planning graphs  while being theoretically
polynomial  is a quite time  and memory consuming thing to do  
therefore  the next section presents a fast heuristic computation of goal orderings  which
analyzes the domain actions directly and does not need to build planning graphs anymore 
on a b

on a b

e

gp

e

e

e

   note that the goals do not specify where the block c has to go  but leave this to the planner 
   more recent implementations of planning graphs  which are for example developed for stan  fox  
long        and ipp      koehler        do not build the graphs explicitly anymore and are orders of
magnitude faster than the original graphplan implementation  but still the computation of the planning
graph takes almost all the time that is needed to determine the e relations 

   

fion reasonable and forced goal orderings
    reasonable goal orderings derived by a fast heuristic method

one can analyze the available actions directly using a method we will call direct analysis
 da   it determines an initial value for f by computing the intersection of all delete lists of
all actions which contain a in their add list  as defined in the following equation 
a

fda

 

  
o

 o  
  a

   

del o 

   

add o

the atoms in this set are all false in a state where a has just been achieved  they are
deleted from the state description independently of the action that is used to add a  as a
short example  let us consider the two actions

  add fag del fc  dg
  add fa  c g del fdg
only the atom d is deleted by both actions  and thus d is the only element initially
contained in f  
however  equation     only says that when a is added then the atoms from f will be
deleted  it does not say anything about whether it might be possible to reestablish atoms
in f   one can easily imagine that actions exist  which leave a true  and at the same
time add such atoms  if this is the case  there are reachable states in which a and atoms
from f hold 
now  our goal is to derive an ordering relation that can be easily computed  and that
ideally  like the  relation  is sucient for the  relation  therefore  we want to make
sure that the atoms in f are really false in any state after a has been achieved  we
arrive at an approximation of atoms that remain false by performing a fixpoint reduction
on the f set  removing those atoms that are achievable in the following sense 
a
da

a
da

a
da

a
da

e

r

a

da

a

da

definition     achievable atoms  an atom p is achievable from a state s given an
action set o  written a s  p  o   if and only if
p s

    o   o   p   add o      p    pre o    a s  p   o 

the definition says that an atom p is achievable from a state s if it holds in s  or if there
exists an action in the domain  which adds p and whose preconditions are all achievable
from s  this is a necessary condition for the existence of a plan p o from s to a state where
p holds 
lemma     p o   p   result s  p o     a s  p  o 
proof  the atom p must either already be contained in the state s  or it has to be added

by a step o out of p o   in the second case  all preconditions of o need to be established by
p o in the same way  thus p and all preconditions of the step  which adds it  are achievable
in the sense of definition    
   

fikoehler   hoffmann
there are two obvious diculties with definition     first  p   s must be tested  with
complete knowledge about the state s  this should not cause any problems  in our case 
however  we only have the generic state s      and cannot decide whether an arbitrary
atom is contained in it or not  secondly  we observe an infinite regression over preconditions 
which must be tested for achievability 
as for the first problem  it turns out that it is a good heuristic to simply assume p    s 
i e   no test is performed at all  as for the second problem  in order to avoid infinite
looping of the  achievable  test  one needs to terminate the regression over preconditions
at a particular level  the point in question is how far to regress  a quick approximation
simply decides  achievable  after the first recursive call 
a 

b

definition     possibly achievable atoms  an atom p is possibly achievable given
an action set o  written pa p  o   if and only if
  o   o   p   add o      p    pre o   

  o    o   p    add o   

holds  i e   there is an action that adds p and all of its preconditions are add effects of other
actions in o 

if the assumption is justified that none of the atoms p is contained in the state s  then
being possibly achievable is a necessary condition for being achievable 
lemma   let s be a state for which p    s and also  o   o   p   add o    pre o    s    

holds  then we have

a s  p  o    pa p  o 
proof  from a s  p  o  and p    s  we know that there is a step o   o  p   add o   with

  p    pre o  a s  p   o   we also know that pre o    s      so for each p    pre o  there
must be an achiever o    o   p    add o    

the condition that all of the facts p must not be contained in the state s seems to be
rather rigid  nevertheless  the condition of being possibly achievable delivers good results
on all of the benchmark domains and it is easy to decide  we can now use this test to both

 perform a fixpoint reduction on the set f and
 decide whether an atomic goal b should be ordered before a 
a
da

the fixpoint reduction  as depicted in figure   below  uses the approximative test pa f  o  
to remove facts from f that can be achieved  it finds all these facts under certain
restrictions  see below  as a side effect of the fixpoint algorithm  we obtain the set o of
actions that our method assumes to be applicable after a state s        we then order b
before a iff it cannot possibly be achieved using these actions 
a
da

a 

   

b

fion reasonable and forced goal orderings
    f
o    o n fo j f   pre o      g
fixpoint reached    false
while  fixpoint reached
fixpoint reached    true
for f   f
if pa f  o   then


f    f n ff g
o    o n fo j f   pre o      g
fixpoint reached    false
f

a

da
a

a

endif
endfor
endwhile
return f   o

figure    quick  heuristic fixpoint reduction of the set f  
a
da

the computation checks whether atoms of f   which is initially set to f   are possibly
achievable using only those actions  which do not delete a and which do not require atoms
from f as a precondition  achievable atoms are removed from f   and o gets updated
accordingly  if in one iteration  f does not change  the fixpoint is reached  i e   f will not
further decrease and o will not further increase the final sets f of false facts and o of
applicable actions are returned 
let us illustrate the fixpoint computation with a short example consisting of the empty
initial state  the goals fa  b g  and the following set of actions
a

da

op  
op  
op   f c g
op   f d g

 
 
 
 

add f a g
add fa  c g
add f d g
add f b g

del f c  d g
del f d g

when assuming that a has been achieved  we obtain f   f   fdg as the initial
value of the false set  since d is the only atom that op  and op  delete when adding a 
figure   illustrates a hypothetical planning process  starting in the empty initial state
and trying to achieve a first  we get two different states s      in which a holds  the
atom d does not hold in any of them and thus in both states  no action is applicable that
requires d as a precondition  this excludes op  from o   yielding the initial action set
o   fop   op   op g  now  op  is the only action that can add b   therefore  if we used
this action set to see if b can still be achieved  we would find that this is not the case 
consequently  without performing the fixpoint computation  we would order b before a 
but as can be seen in figure    this would not be a reasonable ordering  there is the plan
hop   op i that achieves b from the state s        result i  op   without destroying a 
the fixpoint computation works us around this problem as follows  there is the action op   which can add the precondition d of op  without deleting a  when checking
pa d  o   in the first iteration  the fixpoint procedure finds this action  it then checks
a

da

a 

a

a 

   

b

b

fikoehler   hoffmann
whether the preconditions of op  are achievable in the sense that they are added by another action  this is the case since the only precondition c is added by op   thus  d is
removed from f   which becomes empty now  the action op  is put back into the set o  
which now becomes identical with the action set o   this set  in turn  is identical with the
original action set o as no action deletes a  the fixpoint process terminates and b will
not be ordered before a as it can be achieved using the action op   this correctly reects
the fact that there exists a plan from the state s        result i   hop i    fc  ag to a
state that satisfies b without destroying a 
a

a 

b

  

deadlock

op 

op 

a

c  a
op 
c  a  d

d holds in a state satisfying a

op 
c  a  d  b

there is a plan from a to b

figure    an example illustrating why we need the fixpoint computation 
as already pointed out  the intention behind the fixpoint procedure is the following 
starting from a state s        we want to know which facts can become true without
destroying a  and consequently  which actions can become applicable  in the first step 
only actions that do not use any of the facts in f are applicable  as all those facts are
deleted from the state description when a is added  however  such actions may make facts
in f true  so we want to remove those facts from f   if we manage to find all the facts
that can be made true without destroying a  then the final set f will contain only those
facts that do not hold in a state reachable from s      without destroying a  in this case 
the final action set o will contain all the actions that can be applied after s        and we
can safely use this action set to determine whether another goal b can still be achieved or
not 
however  as we only use the approximative test pa f  o  with f   f to find out if
a fact in the current f set is achievable  there may be facts which are achievable without
destroying a  but which remain in the set f   this could exclude actions from the set
o which can be safely applied after s       under certain restrictions  however  we can
prove that this will not happen  in order to do so  we need to impose a restriction on the
particular state s        in which we achieved the goal a  if none of the preconditions of
actions  which add facts contained in f   occur in the state s        then the fixpoint
procedure will remove all facts from f that are achievable without destroying a  we will
use this property of the fixpoint procedure later to show that our heuristic ordering relation
approximates reasonable orderings 
a 

b

a

da

a
da

a
da

a 

b

a 

a 

a 

b

b

a
da

a 

a

da

   

b

b

fion reasonable and forced goal orderings
lemma   let  o  i   g   be a planning problem  and let a   g be an atomic goal  let
s      be a reachable state where a has just been achieved  let p oa   ho            o i be
a sequence of actions not destroying a  let f be the set of facts that is returned by the
fixpoint computation depicted in figure    if we have
a 

n

b

 f   f

a
da

   o   o   f   add o    pre o    s         
a

a 

  

b

then no fact in f holds in the state that is reached by applying p oa   i e  
result s        p oa     f    
a 

b

proof 

let f and o denote the state of the fact and action sets  respectively  after j iterations
of the algorithm depicted in figure    as f only decreases during the computation  we have


f  f for all j   let s            s denote the sequence of states that are encountered when
executing p oa   ho            o i in s        i e   s    s      and s   result s     ho i  for
   i  n  we can assume that each action o is applicable in state s     i e   pre o    s    
otherwise  o does not cause any state transition  and we can skip it from p oa   obviously 
we have s   result s        p oa    so we need to show that s   f      the proof proceeds
by induction over the length n of p oa  
n      p oa   hi and s   s    s        all facts in f are deleted from the state
description when a is added  so we have s   f      as f   f  and f  f    the
proposition follows immediately 
n   n      p oa   ho            o   o    i  from the induction hypothesis  we know that
s   f     for    i  n  what we need to show is s     sf     
let j be the step in the fixpoint iteration where f      s becomes empty  i e   j
denotes the iteration in which the intersection of all the states s   i  n with f is empty
for the first time  such an iteration exists  because all the intersections s   f with i  n
are empty 
now each action o      i  n     is applicable in state s     i e   pre o    s     and
thus pre o     f     for all the actions o in p oa   therefore  all these actions are contained
in o   as this set contains all the actions out of o whose intersection with f is empty 
let us focus on the facts in the state s      all these facts are achieved by executing p oa in
s        in other words  there is a plan from s      to each of these facts  as we have just
seen  this plan consists out of actions in o   applying lemma   to all the facts p   s   
using s      and p oa    p oj    we know that all facts p are achievable using actions from
o  
j

j

n

j

n

a 

b

a 

i

b

i

i

i

i

i

i

i

n

a 

n

b

n

a 

a
da

b

n

n

a

a

da

da

n

i

n

j

i

     n

i

i

j

i

i

i

i

i

i

i

j

a

j

j

n

a 

b

a 

b

n

j

a 

b

j

  a s        p  o  
we will now show that those facts f   s    we are interested in  namely the f facts that are
added by o    and that are still contained in f   are also possibly achievable using actions
from o   let f be a fact f   s      f   f   we apply lemma   using s        f   and

 p   s

  

n

a 

b

j

n

n

j

j

n

j

   

a 

b

fikoehler   hoffmann

o  we can apply lemma   as obviously f    s        and as  o   o   f   add o   
pre o    s          by prerequisite     with a s        p  o    we arrive at
 f   s      f   pa f  o 
a 

j

a 

b

a 

n

b

j

b

j

j

j

what remains to be proven is that all these facts f will be removed from f during the
fixpoint computation  with the argumentation above  it is sucient to show that all the
facts f   s      f will get tested for pa f  o   in iteration j    of the fixpoint computation 
these tests will succeed and lead to s      f        yielding  as desired  s      f     
remember that f    f   there are two cases  which we need to consider 
   j      all intersections s   f  are initially empty  i e   s   f     for    i  n  in
this case  all facts f   s      f are tested for pa f  o    in iteration j         of
the fixpoint computation 
   j      in this case  at least one of the intersections s   f became empty in iteration
j by definition of j   i e   at least one fact was removed from f in this iteration 
therefore  the fixpoint has not been reached yet  and the computation performs at
least one more iteration  namely iteration j      all facts in f will be tested in this
iteration  in particular all facts f   s      f  
with these observations  the induction is complete and the proposition is proven 
as has already been said  we now simply order b before a  if it is not possibly achievable
using the action set that resulted from the fixpoint computation  the ordering relation 
 where h stands for  heuristic   obtained in this way approximates the reasonable goal
ordering   
definition     heuristic ordering    let  o  i   g  fa  b g  be a planning problem 
n

j

j

n

n

j

j

i

n

a

i

da

a
da

i

j

j

n

j

h

r

let o be the set of actions that is obtained from o by performing the fixpoint computation
shown in figure   
the ordering b  a holds if and only if
 pa b  o 
h

h

if a has been reached in a particular state s      where the assumptions made by
the fixpoint computation and by the test for pa b  o   are justified  then being not possibly achievable is a sucient condition for the non existence of a plan to b that does not
temporarily destroy a 
theorem   let  o  i   g   be a planning problem  and let a  b   g be two atomic goals  let
a 

b

s      be a reachable state where a has just been achieved  but b is still false  i e   b   
s        let f and o be the sets of facts and actions  respectively  that are derived by the
fixpoint computation shown in figure    if we have
a 

b

a 

b

 f   f   fb g    o   o   f   add o    pre o    s 
a

da

then we have

a

 pa b  o      p oa  

 

a 

b

b   result s        p oa  

   

a 

b

 

  

  

fion reasonable and forced goal orderings
proof  assume that there is a plan p oa   ho            o i that does not destroy a  but
n

achieves b   i e   b   result s        ho            o i   with the restriction of    to the
facts in f   lemma   can be applied to each action sequence ho            o   i yielding
result s        ho            o   i    f      consequently  each o is either
 not applicable in result s        ho            o  i  
 or its preconditions are contained in result s       ho            o   i   yielding pre o    

f     
in the first case  we simply skip o as it does not have any effects  in the second case 
o   o follows  thus  we have a plan constructed out of actions in o that achieves b
from s        applying lemma   leads us to a s        b  o    we have b    s       
we also know  from    with respect to b   as o  o   that  o   o   b   add o   
pre o    s          holds  therefore  we can now apply lemma   and arrive at pa b  o   
which is a contradiction 
we return to the blocks world example and show how the computation of  proceeds 
let us first investigate whether on a  b   on b  c  holds  the initial value for f     is
obtained from the delete list of the stack b c  action  which is the only one that adds this
goal 
a 

n

b

a

i

da

a 

b

i

i

a 

i

b

a 

i

b

i

i

i

a 

b

a 

b

a 

b

a

a 

b

h

on b c

h

da

  fclear c   holding b g
intuitively  it is immediately clear that neither of these facts can ever hold in a state
where on b  c  is true  if b is on c  then c is not clear and the gripper cannot hold b  it
turns out that the fixpoint computation respects this intuition and leaves the set f    
unchanged  yielding f   fclear c   holding b g  we do not repeat the fixpoint process in
detail here  because it can be reconstructed from figure   and the details are not necessary
for understanding how the correct ordering relations are derived  in short  for both facts
there are achievers in the reduced action set  but all of them need preconditions for which
no achiever is available  for example  holding b  can be achieved by either an unstack or
a pickup action  both either need b to stand on another block or to stand on the table 
all actions that can achieve these facts need holding b  to be true and are thus excluded
from the reduced action set 
after finishing the fixpoint computation  the planner tests pa on a  b   o    where o
contains all actions except those that delete on b  c  and those that use clear c  or holding b 
as a precondition  it finds that the action stack a b  adds on a  b   the preconditions
of this action are holding a  and clear b   these conditions are added by the actions
pickup a  and unstack a b   respectively  which are both contained in o   neither of
them needs c to be clear or b to be in the gripper  thus  the test finds that in fact  on a  b 
is possibly achievable using the actions in o   and no ordering is derived  i e   on a  b   
on b  c  follows 
now  the other way round  on b  c   on a  b  is tested  the initial value for f     is
obtained from the single action stack a b  as
   
  fclear b   holding a g
f
 

 

on b c

fda

on b c
da

h

on a b

h

da

on a b
da

   

fikoehler   hoffmann
again  the fixpoint computation does not cause any changes  resulting in f   fclear b  
holding a g  the process now tests whether pa on b  c   o   holds  where o contains
all actions except those that delete on a  b  and those that use clear b  or holding a  as
a precondition  the only action that can add on b  c  is stack b c   this action needs
as preconditions the facts holding b  and clear c   the process now finds that a crucial
condition for achieving the first fact is violated  each action that can achieve holding b 
has clear b  as a precondition  because b must be clear first before the gripper can hold it 
since clear b  is an element of f   none of the actions achieving holding b  is contained in
o  consequently  the test for pa on b  c   o   fails and we obtain the ordering on b  c  
on a  b   this makes sense as the gripper cannot grasp b and stack it onto c anymore  once
on a  b  is achieved 
h

    on forced goal orderings and invertible planning problems

so far  we have introduced two easily computable ordering relations  and  that both
approximate the reasonable goal ordering    one might wonder why we do not invest any
effort in trying to find forced goal orderings  there are two reasons for that 
h

e

r

   as we have already seen in section    any forced goal ordering is also a reasonable
goal ordering  i e   a method that approximates the latter can also be used as a crude
approximation to the former 
   many benchmark planning problems are invertible in a certain sense  those problems
do not contain forced orderings anyway 
in this section  we elaborate in detail the second argument  the results are a bit more
general than necessary at this point  we want to make use of them later when we show that
the agenda driven planning algorithm we propose is complete with respect to a certain class
of planning problems  we proceed by formally defining this class of planning problems  show
that these problems do not contain forced orderings  and identify a sucient criterion for
the membership of a problem in this class  finally  we demonstrate that many benchmark
planning problems do in fact satisfy this criterion  for a start  we introduce the notion of
a deadlock in a planning problem 
definition     deadlock  let  o  i   g   be a planning problem  a reachable state s is
called a deadlock iff there is no sequence of actions that leads from s to the goal  i e   iff
 
 
s   result i   p o   and    p o   g  result s  p o   

the class of planning problems we are interested in is the class of problems that are

deadlock free  naturally  a problem is called deadlock free if none of its reachable states is

a deadlock in the sense of definition    
non trivial forced goal orderings imply the existence of deadlocks  remember that an
ordering b  a or b  a is called trivial iff there is no state s      at all  
f

r

a 

b

lemma   let  o  i   g   be a planning problem  and let a  b   g be two atomic goals  if
there is a non trivial forced ordering b  a between a and b   then there exists a deadlock
state s in the problem 
f

   

fion reasonable and forced goal orderings
proof  recalling definition   and assuming non triviality of    we know that there is
at least one state s      where a is made true  but b is still false  from definition   
we know that there is no plan in any such state that achieves b   in particular  it is not
possible to achieve all goals starting out from s        thus  the state s    s      must be
a deadlock 
f

a 

b

a 

b

a 

b

we will now investigate deadlocks in more detail and discuss that most of the commonly
used benchmark problems do not contain them  i e   they are deadlock free  with lemma   
we then also know that such domains do not contain non trivial forced goal orderings
either so there is not much point in trying to find them  we do not care about trivial goal
orderings  such orderings force any reasonable planning algorithm to consider the goals in
the correct order 
the existence of deadlocks depends on structural properties of a planning problem 
there must be action sequences  which  once executed  lead into states from which the goals
cannot be reached anymore  these sequences must have undesired effects  which cannot be
inverted by any other sequence of actions in o  changing perspective  one obtains a hint
on how a sucient condition for the non existence of deadlocks might be defined  assume
we have a planning problem where the effects of each action sequence in the domain can
be inverted by executing a certain other sequence of actions  in such an invertible planning
problem  it is in particular possible to get back to the initial state from each reachable state 
therefore  if such a problem is solvable  then it does not contain deadlocks  from any state 
one can reach all goals by going back to the initial state first  and then execute an arbitrary
solution thereafter  we will now formally define the notion of invertible planning problems 
and turn the above argumentation into a proof 
definition     invertible planning problem  let  o  i   g   be a planning problem  and
let s denote the states that are reachable from i with actions from o  the problem is called

invertible if and only if

  s     po     po  

result result s  p o    p

o    s

theorem   let  o  i   g   be an invertible planning problem  for which a solution exists 
then  o  i   g   does not contain any deadlocks 

proof  let s   result i   p o   be an arbitrary reachable state  as the problem is invert 

ible  we know that there is a sequence of actions p o for which result s  p o     i holds 
as the problem is solvable  we have a solution plan p o starting from i and achieving
g  result i   p o    together  we obtain g  result result s  p o    p o    therefore  the
concatenation of p o and p o is a solution plan executable in s and consequently  s is no
deadlock 
s

s

s

s

s

we now know that invertible planning problems  if solvable  do not contain deadlocks and
consequently  they do not contain  non trivial  forced goal orderings  what we will see next
is that  as a matter of fact  most benchmark planning problems are invertible  we arrive
at a sucient condition for invertibility through the notion of inverse actions 
   

fikoehler   hoffmann
definition     inverse action  given an action set o containing an action o of the
form pre o    add o  del o   an action o   o is called inverse to o if and only if o has
the form pre o    add o  del o  and satisfies the following conditions
   pre o   pre o    add o  n del o 
   add o    del o 
   del o    add o 

under certain conditions  applying an inverse action leads back to the state one started
from 
lemma   let s be a state and o be an action  which is applicable in s  if del o   pre o 

and s   add o      hold  then an action o that is inverse to o in the sense of definition   
is applicable in result s  hoi  and result result s  hoi   hoi    s follows 

proof  as o is applicable in s  we have pre o   s  the atoms in add o  are added  and

the atoms in del o  are removed from s  so altogether we have

result s  hoi    pre o    add o   n del o   pre o 

thus  o is applicable in result s  hoi  
furthermore  we have result s  hoi    s   add o  n del o  and with that
result result s  hoi   hoi 
  result s   add o  n del o   hoi 
   s   add o  n del o     add o  n del o 
   s   add o  n del o     del o  n add o 
 cf  definition    
  s   add o  n add o 
 because del o   pre o   s 
  s
 because s   add o      
lemma   states two prerequisites      inclusion of the operator s delete list in its preconditions and     an empty intersection of the operator s add list with the state where it is
applicable  a planning problem is called invertible if it meets both prerequisites and if there
is an inverse to each action 
theorem   given a planning problem  o  i   g   with the set of ground actions o satisfying

del o   pre o  and pre o   s   add o    s     for all actions and reachable states s  if
there is an inverse action o   o for each action o   o  then the problem is invertible 

proof  let s be a reachable state  and let p o   ho          o i be a sequence of actions  we

need to show the existence of a sequence p o

for which

n

result result s  p o    p o     s
   

    

fion reasonable and forced goal orderings
holds  we define p o    ho           o  i  and prove      by induction over n 
o
n      here  we have p o   p   hi  and result result s  hi   hi    s is obvious 
n   n      now p o   ho            o   o    i  from the induction hypothesis we know that
result result s  ho            o i   ho           o  i    s  to make the following a bit more readable 
let s  denote s     result s  ho            o i   we have
n

n

n

n

n

n

result result s  ho            o    i   ho              o  i 
result result s    ho    i   ho              o  i 
result result result s    ho    i   ho    i   ho           o  i 
result s    ho           o  i 
s
n

n

 
 
 
 

n

n

n

n

n

n

 cf  lemma   on s  and o     
 per induction 
n

altogether  we know now that invertible problems  if solvable  do not contain forced
orderings  we also know that problems  where there is an inverse action to each action in
o  are invertible following theorem    theorem   requires del o   pre o  to hold for each
action o  and pre o   s   add o    s     to hold for all actions and reachable states s 
we will see that all conditions   a  inclusion of the delete list in the precondition list   b 
empty intersection of an action s add list with reachable states where it is applicable  and
 c  existence of inverse actions  hold in most currently used benchmark domains  
concerning the condition  a  that actions only delete facts they require as preconditions  one finds this phenomenon in all domains that are commonly used by the planning
community  at least in those that are known to the authors  it is just something that seems
to hold in any reasonable logical problem formulation  some authors even postulate it as
an assumption for their algorithms to work  cf   fox   long        
similarly in the case of conditions  b  and  c   one usually finds inverse actions in
benchmark domains  also  an action s preconditions usually imply by state invariants 
that its add effects are all false  for example in the blocks world  stack and unstack
actions invert each other  and an action s add effects are exclusive of its preconditions 
the former are contained in the union of the false constructed for the preconditions  see
section      similarly in domains that deal with logistics problems  for example logistics 
trains  ferry  gripper etc   one can often find inverse pairs of actions with their preconditions
always excluding the add effects  sometimes  two different ground instances of the same
operator schema yield an inverse pair  for example  in gripper  the two ground instances
move rooma  roomb 
at robby rooma 

  add at robby roomb  del at robby rooma  

and
   in order to avoid reasoning about reachable states in condition  b   one could also postulate that an
action has all of its add effects as negative preconditions  cf   jonsson  haslum    backstrom        
this is  however  not commonly used in the typical planning benchmark problems 

   

fikoehler   hoffmann
move roomb  rooma 
at robby roomb 

  add at robby rooma  del at robby roomb  

of the move  from  to  operator schema invert each other  similarly  in towers of hanoi 
where there is only the single move operator schema  an inverse instance can be found
for each ground instance of the schema  and the add effects are always false when the
preconditions are true 
only very rarely  non invertible actions can be found in benchmark domains  if they
occur  their role in the domain is often quite limited as for example the operators cuss and
inate in russel s tyreworld 
cuss

  del annoyed   

inate  x wheel 

have pump  not inated  x  intact  x 

  add inated  x  del not inated  x  

obviously  there is not much point in defining something like a decuss or a deate
operator  more formally speaking  none of the ground actions to these operators destroys
a goal or a precondition of any other action in the domain  therefore  it does not matter
that their effects cannot be inverted  in particular  no forced goal ordering can be derived
wrt  these actions   
the importance of inverse actions in real world domains has also been discussed by
nayak and williams         who describe the planner burton controlling the cassini
spacecraft  in contrast to these domains  problems such as those for example used by
barrett et al  in        almost never contain inverse actions  consequently  in these domains
plenty of forced goal orderings could be discovered and used by a planner to avoid deadlock
situations  the widespread  although perhaps unconscious use of invertible problems for
benchmarking is a current phenomenon related to strips descending planning systems  as
one of the anonymous reviewers pointed out to us  quite a number of non invertible planning
problems have also been proposed in the planning literature  e g   the register assignment
problem  nilsson         the robot crossing a road problem  sanborn   hendler         some
instances of manufacturing problems  regli  gupta    nau         and the yale shooting
problem  mcdermott   hanks         for these problems  i e   for problems that are not
invertible  one could in the spirit of argument   at the very beginning of this section 
simply use  and  to approximate forced orderings if one is interested in finding at least
those  more precisely   and  are methods that might detect forced orderings as those
are also reasonable but that might also find more  not necessarily forced  orderings  if
one is not interested in finding only the forced orderings  this is a possible way to go  for
example  in a simple blocks world modification where blocks cannot be unstacked anymore
once they are stacked which forces the planner to build the stacks bottom up both 
and  are still capable of finding the correct goal orderings 
e

h

e

h

e

h

   the cuss operator  by the way  is the only one known to the authors that deletes a fact it is not using
as a precondition  it is also the only one we know that could be removed from the domain description
without changing anything 

   

fion reasonable and forced goal orderings
    an extension of goal orderings to adl actions

the orderings  which have been introduced so far  can be easily extended to deal with
ground adl actions having conditional effects and using negation instead of delete lists 
such actions have the following syntactic structure 
o      o    pre   o    eff 
   o   eff   o 
   o    pre   o    eff 
   o   eff   o 
  
 
  o    pre  o    eff   o   eff  o 
all unconditional elements of the action are summarized in    o   the precondition
of the action is denoted with pre   o   and its unconditional positive and negative effects
with eff    o  and eff   o   respectively  each conditional effect   o  consists of an effect
condition  antecedent  pre  o   and the positive and negative effects eff   o  and eff  o  
additionally  we denote with  o  the set of all unconditional and conditional effects 
i e    o    f   o      o             o g 
the computation of  immediately carries over to adl actions when an extension of
planning graphs is used  which can handle conditional effects  e g   ipp  koehler  nebel 
hoffmann    dimopoulos        or sgp  anderson   weld         one simply takes the
set of exclusive facts that is returned by these systems to determine the set f   the test
from definition     which decides whether there is an ordering b  a of two atomic goals
a and b   is extended to adl as follows 
n

n

n

n

i

i

i

i

n

e

a

gp

e

definition     ordering  for adl  let  o  i   g  fa  b g  be a planning problem 
e

be the false set for a  the ordering b  a holds if and only if

let f

a

e

gp

  o   o    o     o    b   eff  o    a    d  o     pre  o    pre  o     f     
i

i

i

a
gp

i

here  d  o  denotes all negative effects that are implied by the conditions of   o  
i

d  o    
i



eff   o   
eff   o 

i

s

pre

j  o   prei  o  effj  o  i     

i  

thus  b is ordered before a if all  unconditional or conditional  effects that add b either
imply an effect that deletes a  or need conditions that cannot be made true together with
a  note that an effect  requires all the conditions in pre  o    pre   o  to be satisfied 
which is impossible in any state where a holds because of the non empty intersection with
f
 
the computation of  requires a little more adaptation effort  in order to obtain the
set f   we now need to investigate the conditional effects as well  for each action that
has a as a conditional or unconditional effect  we determine which atoms are negated by
it  no matter which effect is used to achieve a  we obtain these atoms by intersecting the
appropriate sets d  o  
 
d  o 
d o    
i

i

a
gp

h

a
da

i

 
a   effi  o 

   

i

fikoehler   hoffmann
these are exactly the facts that are always deleted by o when achieving a  no matter which
effect we use 
the intersection of the sets d o  for all actions o yields the desired set f   let us
consider the following small example to clarify the computation 
   o    fu g
  fw g f x g 
   o    fv  w g   fag f x g 
   o    fw g
  fu g f y g
a
da

we obtain d   o    f x g   f y g   f x   y g  because the precondition of    o  is
implied by the first conditional effect    o   as    o  is the only effect that can achieve a 
we get d o    d   o    f x   y g 
we obtain a smaller set d o   if we add a as an unconditional positive effect of the
action 
   o    fu g
  fw  ag f x g 
   o    fv  w g   fag f x g 
   o    fw g
  fu g f y g
in this case  we need to intersect the sets d   o    f x g and d   o    f x   y g 
yielding d o    f x g  this reects the fact that  when achieving a via the unconditional
effect of o  only x gets removed from the state 
the fixpoint computation requires to adapt the computation of o   first  we repeat the
same steps as in the case of simple strips actions and consider the unconditional negative
effects and the intersection of the preconditions with the false set 

o    o n fo j a   eff   o    f   pre  o      g
a
da

then  we additionally remove from each action the conditional effects that either imply the
deletion of a or have an impossible effect condition 

o    red o     fred o jo   og
here  red is a function red o    o    o  such that
 o       o  n f  o  j a   d  o    pre  o    f
k

k

a
da

k

    g

finally  we need to redefine definition     which expresses the conditions under which a
fact is believed to be possibly achievable given a certain set of operators o 
definition     possibly achievable atoms for adl  an atom p is possibly achievable given an action set o  written pa p  o   if and only if

  o   o      o    p   eff  o   
  p     pre  o    pre  o       o    o        o     p    eff    o   
i

i

i

i

i

holds  i e   there is a positive effect for p and all of its conditions and preconditions can be
made true by other effects in the reduced action set 
   

fion reasonable and forced goal orderings
the process  which decides whether an atomic goal b is heuristically ordered before another
goal a  i e   whether b  a holds  proceeds in exactly the same way as described in
section      the false set f for a is reduced by the fixpoint computation  which remains
unchanged  but employs the updated routines for computing o and for deciding pa f  o  
as a result  b is ordered before a  b  a  if and only if it is not possibly achievable
pa b  o   using the action set that results from the fixpoint 
h

a
da

h

   the use of goal orderings during planning

after having determined the ordering relations that hold between pairs of atomic goals
from a given goal set  the question is how to make use of them during planning  several
proposals have been made in the literature  see section   for a detailed discussion  in this
paper  we propose a novel approach that extracts an explicit ordering between subsets of
the goal set called the goal agenda  the planner  in our case ipp  is then run successively
on the planning subproblems represented in the agenda 
    the goal agenda

the first step one has to take for computing the goal agenda is to perform a so called goal
  g of atomic goals must be examined in
order to find out whether an ordering relation a  b   or b  a  or both  or none holds
between them  for the ordering relation   an arbitrary definition can be used  in our
experiments  the relation  was always either  or   
after having determined all ordering relations that hold between atomic goals  we want
to split the goal set into smaller sets based on these relations  and we want to order the
smaller sets  also based on these relations  more precisely  our goal is to have a sequence of
goal sets g            g with
 
g  g
analysis  during goal analysis  each pair a  b

e

h

n

n

i

and

i

  

g

i

 g   
j

for i    j     i  j  n  we also want the sequence of goal sets to respect the ordering
relations that have been derived between atomic goals  to make this explicit  we first
introduce a simple representation for the detected atomic orderings  the goal graph g 
g     v  e  
where
v    g
and
e    f a  b     g  g j a  b g
now  the desired properties  which the sequence of goal sets should possess  can be easily
stated 
   

fikoehler   hoffmann

 goals a  b that lie on a cycle in g belong to the same set  i e   a  b   g  
 if g contains a path from a goal a to a goal b   but not vice versa  then a is ordered
before b   i e   a   g and b   g with i   j  
i

i

j

these are the only properties that appear to be reasonable for a goal set sequence respecting
the atomic orderings  we will now introduce a simple algorithmic method that does produce
a sequence of goal sets which meets these requirements 
first of all  the transitive closure of g is computed  this can be done in at most cubic
time in the size of the goal set  warshall         then  for each node a in the transitive
closure  the ingoing edges a and outgoing edges a are counted  all disconnected nodes
with a   a     are moved into a separate set of goals g sep containing now those
atomic goals  which do not participate in a  relation  for all other nodes a  their degree
d a    a
a is determined as the difference between the number of ingoing edges and
the number of outgoing edges  nodes with identical degree are merged into one set  the
sets are then ordered by increasing degree and yield our desired sequence of goal sets  the
only problem remaining is the set g sep  if it is non empty  it is not clear in which place
to put it 
let us consider a small example of the process  figure   depicts on the left the goal
graph  which results from the goal set g   fa  b  c  d  e g and the ordering relations
a  b  b  c and b  d  and its transitive closure on the right 
in

in

out

out

in

out

b

b
c

c
a

a
d

d
e

e

figure    on the left  the goal graph depicting the  relations between the atomic subgoals 
on the right  the transitive closure of this graph 
in figure    the number of in  and outgoing edges of each goal  the corresponding degrees 
and resulting goal set sequence are shown 
 
 

e

a

 
 

 

 

b 

 

 
 

  
 a 

c

  
 b 

 
 c d 

g sep
e

d

figure    on the left  the number of in  and outgoing edges for each node  on the right 
the degree of the nodes and the merged sets of goals having same degree  the
node e becomes a member of the g sep set and remains unordered 
it is not dicult to verify that the resulting goal sequence respects the atomic goal orderings 
   

fion reasonable and forced goal orderings

 nodes occurring on a cycle in a graph have isomorphic in  and outgoing edges in the

transitive closure of that graph  in particular  they have the same degree and get
merged into the same set g  
 say we have a graph  where there is a path from a to b   but not vice versa  then 
in the transitive closure of that graph  we will have an edge from a to each node
that b has a path to  and additionally the edge from a to b   i e   a   b
follows  similarly  we have an ingoing edge to b for each node that has a path to
a  and additionally  the edge from a to b   which gives us b   a   altogether 
d a    a
a  b
a  b
b   d b   and thus  the degree of a is
smaller than the degree of b and as required  a gets ordered before b  
note that nothing is said in this argumentation about the set of unordered goals  gsep  this set could  in principle  be inserted anywhere in the sequence with the resulting
sequence still respecting the atomic orderings  a possible heuristic may use this goal set as
the first in the sequence  because apparently there is no problem to reach all other goals
after the goals in this set have been achieved  another heuristic could put this set at the end
as there is neither a problem to reach this goal set from all other goals  we have decided to
deal with the problem in a more sophisticated way by trying to derive an ordering relation
between g sep and the other goal sets g that have already been derived  in order to do
so  we need to extend our definitions of goal orderings to sets of goals 
i

out

in

in

out

in

out

in

out

in

out

i

    extension of goal orderings to goal sets

given a set of atomic goals  it has always been a problem which of the exponentially many
subsets should be compared with each other in order to derive a reasonable goal ordering
between goal sets  a consideration of all possible subsets is out of question  because it will
result in an exponential overhead  the partial goal agenda that we have obtained so far
offers one possible answer  it suggests taking the set g sep and trying to order it with
respect to the goal sets emerging from the goal graph 
given a planning problem  o  i  g   and two subsets of atomic goals fa            a g  g
and fb            b g  g   the definition of  and  for sets of atomic goals is straightforward 
for the sake of simplicity  we consider only strips actions here  the definitions can be
directly extended to adl 
to define an ordering    which extends  to sets  we begin by defining a set f f   n g
of all atoms  which are exclusive of at least one atomic goal a in the planning graph
generated for  o  i  g   
f f   n g    fp j p is exclusive of at least one a when the graph has leveled off g
the set of   n g is obtained accordingly by removing from o all actions that delete
at least one of the a   i e   of   n g   fo   o j   i   f           ng   a    del o g 
definition     ordering  over goal sets  let  o  i  g   be a planning problem with
n

e

k

h

a      a

e

e

gp

i

a      a

i

gp

a      a

i

i

a      a

fa            a g  g and fb            b g  g   let ff   ng be the false set for fa            a g 
the ordering fb            b g  fa          a g holds if and only if
  j   f           kg     o   of   ng   b   add o    pre o    ff   ng      
e

a      a

n

k

k

e

n

gp

n

a      a

a      a

j

   

gp

fikoehler   hoffmann
in a similar way   can be extended to    for each a   the sets f i are determined
based on equation      the set ff   n g is simply the union over the individual sets 
f   n g      f i
f
   
a

h

h

i

da

a      a

da

a      a

a

da

da

i

then the fixpoint computation is entered with

o    o n fo   o j   i   f           ng   a   del o    ff   ng   pre o      g    
the recomputation of o in each iteration of the fixpoint algorithm from figure   is done
a      a

i

da

accordingly  apart from this  the algorithm remains unchanged 

definition     ordering    let  o  i  g   be a planning problem with fa            a g 

and fb            b g  g   let o be the set of actions that is obtained by performing
the fixpoint computation shown in figure    modified to handle sets of facts as defined in
equations     and      the ordering fb            b g  fa            a g holds if and only if
  j   f           kg    pa b   o 

g

h

n

k

h

k

n

j

all given goal sets then undergo goal analysis  i e   each pair of sets is checked for an
ordering relation  or    each derived relation defines an edge in a graph with the
subgoal sets as nodes  the transitive closure is determined as before  and the degree of
each node is computed  if the graph contains no disconnected nodes  then a total ordering
over subsets of goals results by ordering the nodes based on their degree  this ordering
defines the goal agenda  in the case of disconnected nodes  we default to the heuristic of
adding the corresponding goals to the last goal set in the agenda 
e

h

    the agenda driven planning algorithm

given a planning problem  o  i   g    let us assume that a goal agenda g    g            g with
k entries has been returned by the analysis  each entry contains a subset g  g   the
basic idea for the agenda driven planning algorithm is now to first feed the planner with
the original initial state i     i and the goals g     g    then execute the solution plan p
in i   yielding the new initial state i    result i   p    then  a new planning problem is
initialized as  o  i    g     after solving this problem  we want the goals in g  to be true 
but we also want the goals in g  to remain true  so we set g     g    g    the continuous
merging of successive entries from the agenda yields a sequence of incrementally growing
goal sets for the planner  namely
 
g    g
k

i

i

i

j

j

  

in a little more detail  the agenda driven planning algorithm we implemented for ipp works
as follows  first  ipp is called on the problem  o  i   g    and returns the plan p    which
achieves the subgoal set g    p  is a sequence of parallel sets of actions  which is returned
by ipp similarly to graphplan  given this plan  the resulting state r i   p      i  is
   

fion reasonable and forced goal orderings
computed based on the operational semantics of the planning actions   in the case of a set
of strips actions  one simply adds all add effects to and deletes all del effects from
a state description in order to obtain the resulting state  following the result function in
definition    for strips  the result function coincides directly with the r function  in
the case of a set of parallel adl actions  one needs to consider all possible linearizations
of the parallel action set and has to deal with the conditional effects separately  for each
linearization  a different resulting state can be obtained  but each of them will satisfy the
goals  to obtain the new initial state i    one takes the intersection of the resulting states
for each possible linearization of the actions in a parallel set  this means to compute n 
linearizations for a parallel action set of n actions in each time step  since n is usually
small  more than   or   adl actions per time step are very rare   the practical costs for
this computation are neglectible 
this way  given a solution to a subproblem  o  i   g    one calculates the new initial
state i    and runs the planner on the subsequent planning problem  o  i      g      until
the planning problem  o  i   g   is solved 
the plan solving the original planning problem  o  i   g   is obtained by taking the
sequence of subplans p    p            p   one could argue that planning for increasing goal
sets can lead to highly non optimal plans  but ipp still uses the  no ops first  strategy to
achieve goals  which was originally introduced in the graphplan system  blum   furst 
       employing this strategy  the graphplan algorithm  in short  first tries to achieve
goals by simply keeping them true  if possible  since all goals g    g            g are already
satisfied in the initial state i      starting from which the planner tries to achieve g      this
strategy ensures that these goals are only destroyed and re established if no solution can
be found otherwise  the no ops first strategy is merely a graphplan feature  but any
reasonable planning strategy should preserve goals that are already true in the initial state
whenever possible 
the soundness of the agenda driven planning algorithm is obvious because g   g and
we have a sequence of sound subplans yielding a state transition from the initial state i to
a state satisfying g  
the completeness of the approach is less obvious and holds only if the planner cannot
make wrong decisions before finally reaching the goals  more precisely  the approach is
complete on problems that do not contain deadlocks as they were introduced in definition    
i

i

i

i

k

i

k

k

i

i

i

k

theorem   given a solvable planning problem  o  i  g    and a goal agenda g    g          g

k

with g  g    and g   g   running any complete planner in the agenda driven manner
described above will yield a solution if the problem is deadlock free 
i

i

k

proof  let us assume the planner does not find a solution in step i of the agenda driven

algorithm  i e   no solution is found for the subproblem  o  i   g    as the planner is assumed
to be complete on each subproblem  this implies unsolvability of  o  i   g    if this problem
is not solvable  then neither is the problem  o  i   g   solvable  since g  g holds  therefore 
the goals cannot be reached from i   furthermore  i is a reachable state it was reached
by executing the partial solution plans p            p   in the initial state  consequently  i
must be a deadlock state in the sense of definition     which is a contradiction 
i

i

i

i

i

i

i

i

i

   see  koehler et al         for the exact definition of r  which we do not want to repeat here 

   

i

fikoehler   hoffmann
this result states the feasibility of our approach  as we have shown  most benchmark
problems that are currently investigated do contain inverse actions  are therefore invertible
 theorem     and are with that also deadlock free  theorem     thus  with theorem   
our approach preserves completeness in these domains 
however in the general case  completeness cannot be guaranteed  the following example
illustrates a situation where the assumption s       j  p  assuming that preconditions of
achieving actions are not contained in the state where a is reached  cf  the derivation of the
ordering  in section    is wrong and yields a goal ordering under which no plan can be
found anymore although the problem is solvable 
given the initial state fc  dg and the goals fa  b g  the planner has the following set
of ground strips actions  
a 

b

h

op  
op  
op  
op  

fc g
fdg
fe g
ff g

 
 
 
 

add fb g del fdg
add fe g
add ff g
add fag

the analysis will return an ordering b  a because b is only added by op   but its
precondition c is not an effect of any of the other actions  thus it concludes that c is
not reachable from a state in which a holds  but in this example  c holds in all reachable
states  the assumption s       j  c as made by the test pa b  o   is wrong  thus  b
can be reached after a  on the other hand  a  b holds  we even have a forced ordering
a  b   but when testing for a  b   this ordering remains undetected  because our
method does not discover that the precondition f of op  is not achievable from the state
in which b holds  we obtain f   fdg  which excludes op  from o   but op  and op 
remain in the set of usable actions  thus  op  is considered a legal achiever of a  and op 
is considered a legal achiever for its precondition f   we could only detect the right ordering
if we regressed over the action chain op   op   op  and found out that  with d being in
the f set of b   all these actions must be excluded from o  
consequently  the goal agenda fb g  fag is fed into the planner  which solves the first
subproblem using op   but then fails in achieving a from the state fb  c g since there is
no inverse action to op  and d cannot be re established in any other way 
h

a 

b

r

f

h

b
da

   empirical results

we implemented both methods to approximate  as a so called goal agenda manager
 gam  for the ipp planning system  koehler et al          gam is activated after the
set of ground actions has been determined and either uses  or  to approximate the
reasonable goal ordering  then it calls the ipp planning algorithm on each entry from the
goal agenda and outputs the solution plan as the concatenation of the solution plans that
have been found for each entry in the agenda  
r

e

h

   the source code of gam  which is based on ipp      and the collection of domains from which
we draw the subsequent examples can be downloaded from http   www informatik uni freiburg de  
koehler ipp gam html  all experiments have been performed on a sparc       

   

fion reasonable and forced goal orderings
the empirical evaluation that we performed uses the ipp domain collection  which contains    domains with more than     planning problems  out of these domains  we were
able to derive goal ordering information in    domains  these domains indeed pose constraints on the ordering in which a planner has to a achieve a set of goals  in all other
domains  where no goal orderings could be derived  we found that either only a single goal
has to be achieved  for example in the manhattan  movie  molgen  and montlake domains
or the goals can be achieved in any order  as for example in the logistics  gripper  and ferry
domains  we found no benchmark domain  in which a natural goal ordering existed  but
our method failed to detect it  as a matter of fact  looking at a goal ordering that seems to
be natural  one usually finds that the ordering is reasonable in the sense of definition    see
for example the blocks world  woodshop  and tyreworld domains  our method finds almost
all of the reasonable orderings  which indicates that both approximation techniques  and
 are appropriate for detecting ordering information 
e

h

in the following  we will first compare the  and  techniques in terms of runtime
and number of goal agenda entries generated  then we take a closer look at the agendas
that are generated in selected domains and investigate how they inuence the performance
of the ipp planning system  the exact definition of all domains can be downloaded from
the ipp webpage  we just give the name of the domain and the name of the particular
planning problem as well as the number of  ground  actions a domain contains  because
this parameter nicely characterizes the size of a domain and with that usually the diculty
to handle it 
e

h

in all examples  the times shown to compute the goal agenda contain the effort to
parse and instantiate the operators  i e   to compute the set of actions  times for parsing
and instantiation are not listed explicitly  because they are  on the test examples used here 
usually very close to zero and do not inuence the performance of the planner in a significant
way 
    comparison of  and 
h

e

we begin our comparison with a summary of results that we obtained in different representational variants of the blocks world  the bw large a to bw large d examples originate from
the satplan test suite  kautz   selman        to which we added the larger examples
bw large e to bw large g  the parcplan example comes from  el kholy   richards       
and uses multiple grippers and limited space on the table  the stack n examples use the
graphplan blocks world representation and simply require to stack n blocks on each other 
which are all on the table in the initial state 
the two methods return exactly the same ordering relations across all blocks world
problems  but as figure   confirms  the computation of  based on planning graphs is
much more time consuming  it hits the computational border when a domain contains more
than       actions  the computation of  is much faster and also scales to larger action
sets 
e

h

   

fikoehler   hoffmann
problem
bw large a
bw large b
bw large c
bw large d
bw large e
bw large f
bw large g
parcplan
stack   
stack   
stack   
stack   

 actions  agenda entries cpu    cpu   
   
 
    
    
   
 
    
    
   
 
    
    
   
  
     
    
   
  
     
    
    
 
     
    
    
 
     
    
    
 
     
    
   
  
    
    
    
  
      
    
    
  
      
    
     
  
     
e

h

figure    comparison of  and  on blocks world problems   actions shows the number
of actions in the set o  from which the planner tries to construct a plan   agenda
entries says how many goal subsets have been detected and ordered by gam 
column   and   display the cpu time that is required by both methods to
compute the agenda when provided with the set o  a dash will always mean
that ipp ran out of memory on a   gbyte machine 
e

h

figure   and figure   show the results for the other domains  in which our method
is able to detect reasonable orderings  figure   lists the domains  in which both methods
return the same goal agendas  the tyreworld  hanoi  and fridgeworld domains originate from
ucpop  penberthy   weld         while the link repeat domain can be found in  veloso
  blythe         the performance results coincide with those shown in figure    figure  
shows the same picture in terms of runtime performance  but in these domains different
agendas are returned by  and   
the woodshop and scheduling domains contain actions with conditional effects  while
the other domains only use strips operators  the computation of  fails to derive goal
orderings for all scheduling world problems  of which we only display the largest problem
sched   and for the wood  problem  the explanation for this behavior can be found in the
different treatment of conditional effects by both methods  ipp does only find a very limited
form of mutex relations between conditional effects when building the planning graph  a
goal  which is achieved with a conditional effect  will not very often be exclusive to a large
number of other facts in the graph  thus  the f sets are very small or sometimes even empty
and consequently  only very few actions can be excluded when performing the reachability
analysis and thus  reasonable orderings may remain undetected  direct analysis investigates
the conditional effects in more detail and is therefore able to derive much larger f sets 
the behavior of the  method in the strips domains bulldozer  glassworld  and
shopping world is caused by the same phenomenon  in these domains  one can derive much
larger f sets using planning graphs and in turn these sets exclude more actions  since direct
analysis finds smaller or empty f sets  it also finds less  relations  the woodshop domain
e

h

e

h

h

   

fion reasonable and forced goal orderings
 actions  agenda entries cpu    cpu   
  
 
    
    
  
 
    
    
   
 
    
    
   
 
    
    
   
 
    
    
   
 
     
    
  
 
    
    
  
 
    
    
   
 
    
    
   
 
    
    
   
 
    
    
   
 
    
    
  
 
    
    
  
 
    
    

domain
tyreworld

problem
fixit 
fixit 
fixit 
fixit 
fixit 
fixit  
hanoi
hanoi 
hanoi 
hanoi 
hanoi 
hanoi 
fridgeworld fridge
link repeat link  
link  

e

h

figure    comparison of  and  on those benchmark domains  in which they return
identical agendas 
e

h

domain
bulldozer
glassworld

problem
bull
glass 
glass 
glass 
shoppingworld shop
scheduling
sched 
woodshop
wood 
wood 
wood 

 actions  agenda entries cpu    cpu   
  
   
    
    
  
   
    
    
   
   
    
    
   
   
    
    
  
   
    
    
   
   
    
    
  
   
    
    
  
   
    
    
  
   
    
    
e

h

figure    domains in which  and  return different goal agendas  which we give in the
form n   n    the number before the slash says how many entries are contained
in the agenda computed by    the number following the slash says how many
entries are contained in the agenda computed by     agenda entries   means
that the agenda contains only a single entry  namely the original goal set  and no
ordering was derived 
e

h

e

h

shows that the results can differ within the same domain  but depending on the specific
planning problem  the problem wood  varies from the problem wood  in the sense that one
goal is slightly different an object needs to be put into a different shape and that two
more goals are present  while there are no goal orderings derived between pairs of the old
   

fikoehler   hoffmann
goals from wood   lots of  relations are derived between mixed pairs of old and new goals
in wood   yielding a detailed goal agenda  the problem wood  contains additional objects
and many more goals  which can also be successfully ordered 
in the subsequent experiments  we decided to solely use the heuristic ordering  because
the computation of  is less costly than the computation of  in all cases  yielding
comparable agendas in most cases  in the three domains that we investigate more closely 
namely the blocks world  tyreworld and hanoi domains  the agendas derived by both methods
are  in fact  exactly the same 
e

h

e

h

    inuence of goal orderings on the performance of ipp and interaction
with rifo

in this section  we analyze the inuence of the goal agenda on the performance of ipp
and combine it with another domain analysis method  called rifo  nebel  dimopoulos   
koehler         rifo is a family of heuristics that enables ipp to exclude irrelevant actions
and initial facts from a planning problem  it can be very effectively combined with gam 
because if ipp plans for only a subset of goals from the original goal set  it is very likely
that also only a subset of the relevant actions is needed to find a plan  more precisely  we
obtain one subproblem for each entry in the agenda  and  for each such subproblem  we
use rifo for preprocessing before planning with ipp  in this configuration  gam reduces
the search space for ipp by decreasing the number of subgoals the planner has to achieve
at each moment  while rifo reduces the search space dramatically by selecting only those
actions that are relevant for this goal subset 
      the blocks world

figure   illustrates the parcplan problem  el kholy   richards        in detail  seven
robot arms can be used to order    blocks into   stacks on   possible positions on the table 

 

  

  

  

  

  

  

  

  

  

  

  

  

 

 

 

  
  

  

  

  

  

  
  

 

 

 

 

figure    the parcplan problem with limited space on the table  seven robot arms  and
several stacks 
the goal agenda derived by ipp orders the blocks into horizontal layers 
  
  
  
  

on table     t     on table     t  
on table     t     on           on        
on           on           on        
on           on        
   

fion reasonable and forced goal orderings
the optimal plan of    actions solving the problem is found by ipp using gam in    s 
where it spends one second on computing the goal agenda  almost    seconds to build the
planning graphs  but only      second to search for a plan  only    actions have to be tried
to find the solution  without the goal analysis  ipp needs approx     s and searches      
actions in more than    seconds 
rifo  nebel et al         fails in detecting a subset of relevant actions when the original
goal set has to be considered  but it succeeds in selecting relevant actions for the subproblems
stated in the agenda  it reduces runtime down to less than   s with   s again spent on the
goal agenda  almost   s spent on the removal of irrelevant actions and initial facts  less
than   s spent on building the planning graphs  as previously  almost no time is spent on
planning 
figure   shows ipp on the satplan blocks world examples from  kautz   selman 
       the bw large e example taken from  dimopoulos  nebel    koehler         and two
very large examples bw large f  containing    blocks and requiring to build   stacks in the
goal state  and bw large g with    blocks   stacks 
satplan
bw large a
bw large b
bw large c
bw large d
bw large e
bw large f
bw large g

  actions plan length ipp  g  g r  g r l
   
       
         
    
    
   
                  
    
    
   
  
      
    
    
   
  
       
    
    
   
  
       
    
    
    
  
     
    
  
        
     

figure    performance on the extended satplan blocks world test suite  the second
column shows the number of ground actions in this domain  the third column
shows the plan length  i e   the number of actions contained in the plan  generated
by gam and in parentheses the plan length generated by ipp without gam given
that ipp without gam is able to solve the corresponding problem   g means
that ipp is using gam   g r means ipp uses gam and rifo   g r l
means that subgoals from the same set in the agenda are arbitrarily linearized 
all runtimes cover the whole planning process starting with parsing the operator
and domain file  performing the gam and rifo analysis  if active   and then
searching the graph until a plan is found 
ipp     without gam can only solve the bw large a and bw large b problems  using a
goal agenda  some plans become slightly longer  but performance is increasing dramatically 
plan length is growing because blocks are accidentally put in positions where they cut off
goals that are still ahead in the agenda and thus  additional actions need to be added to
the plan to remove these blocks from wrong positions  a further speed up is possible when
rifo is additionally used  because it reduces the size of planning graphs dramatically 
finally  goals that belong to the same subset in the agenda can be linearized based on the

   

fikoehler   hoffmann
heuristic assumption that if the analysis found no reasonable goal orderings  then the goals
are achievable in any order  with this option  the problems are solved almost instantly 
the reader may wonder at this point why we use linearization of agenda entries only
as an extra option and do not investigate it further  there are two reasons for that  first 
linearization does have negative side effects in most domains that we investigated  for
example  it yields much longer plans in the logistics domain and all its variants  when
linearizing the single entry that the agenda for a logistics problem contains  all packages get
transported to their goal position one by one  of course  this takes much more planning
steps than simultaneously transporting packages with coinciding destinations 
secondly  the effects of linearization are somewhat unpredictible  even in domains where
it usually tends to yield good results  this is because gam does not recognise all interactions between goals  consider a blocks world problem with four blocks a  b   c and d 
say b is positioned on c initially  the other blocks being each on the table  and the goal is
to have on a  b   and on c  d   the agenda for this problem will comprise a single entry
containing both goals  in fact  there is no reasonable goal ordering here  nevertheless 
stacking a onto b immedeatly is a bad idea  as the planner needs to move c to achieve
on c  d   being not aware of this  gam might linearize the single agenda entry to have
on a  b   up front  which makes the problem harder than it actually is  thus  the runtime
advantages that linearization sometimes yields on the blocks world can be more or less seen
as cases of  good luck  
figure    shows ipp on the stack n problems  ipp without any domain analysis can
handle up to    blocks in less than   minutes  but for    blocks more than    minutes are
needed  using gam     blocks can be stacked in less than   minutes  using gam and
rifo  the   minutes limit is extended to    blocks  while stack    is solved in      min
where      min are spent for both analysis methods and only     min are needed for building
the planning graphs and extracting a plan 
time
in s
   
   

ipp

ipp g
ipp g r

   
   

  

  

figure    

ipp

  

  

  

  

  

  

  

    blocks

    on a simple  but huge stacking problem 

figure    shows the sharing of the overall problem solving time between gam  rifo
and the ipp search algorithm on blocks world problems  similar results are obtained in the
tyreworld  gam takes between   and       rifo takes between    and       and the
search effort is reduced down to approx       the overall problem solving time is clearly
determined by rifo  while the search effort becomes a marginal factor in the determination
of performance  this indicates that a further speed up is possible when improving the
   

fion reasonable and forced goal orderings
performance of gam and rifo  it also indicates that even the hardest planning problems
can become easy if they are structured and decomposed in the right way 
problem
stack   
stack   
stack   
stack   
parcplan

  actions
   
    
    
     
    

gam
rifo
                       
                       
                       
                        
                       

search algorithm
          
          
          
          
           

figure     distribution of problem solving time on blocks world examples between gam 
rifo  and the search algorithm  which comprises the time to build and search
the planning graph  the remaining fraction of total problem solving time  which
is not shown in the table  is spent on parsing and instantiating the operators 

      the tyreworld

the tyreworld problem  originally formulated by stuart russell  asks a planner to find out
how to replace a at tire  it is easily solved by ipp within a few milliseconds  the problem
becomes much harder if the number of at tires is increasing  cf  figure    
tires
 
 
 
 
 
 
 
 
 
  
figure    

  actions
ipp
 g r
 g r l
search space
  
                                      
       
  
                                                   
   
                         
     
   
            
     
   
            
     
   
            
      
   
            
      
   
             
      
   
               
       
   
               
      
in the tyreworld  the numbers in parentheses show the time steps  followed
by the number of actions in the generated plan  the last column compares the
search spaces  the number before the slash shows the  number of actions tried 
parameter for the plain ipp planning algorithm  while the number following
the slash shows the  number of actions tried  for ipp using gam  rifo  and
the linearization of entries in the agenda  a dash means that the  number
of actions tried  is unknown because ipp failed in solving the corresponding
planning problem 

ipp

   

fikoehler   hoffmann
ipp is only able to solve the problem for   and   tires  using gam and rifo   
tires can be handled  solution length under gam is slightly increasing  which is caused
by superuous jack up and jack down actions  in short  this is explained as follows  each
wheel needs to be mounted on its hub  which is expressed by an on  r   h  goal  to mount
a wheel  its hub must be jacked up  after mounting  the nuts are done up  then  the hub
needs to be jacked down again  in order to tighten the nuts achieving a tight  n   h  goal 
now  gam puts all of the on goals into one entry preceeding the tight goals  thus  solving
the entry containing the on goals  each hub is jacked up  the wheel is put on  and the hub
is immediatly jacked down again in order to replace the next wheel  afterwards  solving
the tight goals  each hub must be jacked up and down one more time for doing up the
nuts  solving the problem in this manner  the planner inserts one superuous jack up  and
one superuous jack down action for each wheel  more precisely  superuous actions are
inserted for all but one wheel  namely the wheel that is last mounted when solving the on
goals  after mounting this wheel  all on goals are achieved  and the planner proceeds to
the next agenda entry with this wheel still being jacked up  then  trying to achieve the
tight goals  ipp recognizes that the shortest plan  in terms of the number of parallel steps 
results when the nuts are first done up on the hub that is already jacked up  thus  this hub
is only jacked up one time  achieving the corresponding on goal  and jacked down again one
time  before achieving its tight goal 
in the case of   tires  the following goal subsets are identified and ordered 

  
  
  
  
  
  
  

inated r    inated r    inated r  
on r   hub    on r   hub    on r   hub  
tight n   hub    tight n   hub    tight n   hub  
in w   boot   in pump  boot   in w   boot   in w   boot 
in jack  boot 
in wrench  boot 
closed boot 

the hardest subproblem in the agenda is to achieve the on r   hub   goals in entry   
i e   to mount inated spare wheels on the various hubs  trying to generate a maximum parallelized plan is impossible for ipp for more than   tires  but since the goals are completely
independent of each other  any linearization of them will perfectly work  the resulting
plans become slightly longer due to the way that the tight goals are achieved when using
the  l option  we noticed earlier that for one wheel  the one that is last mounted when
solving the on goals  no superuous jack up and jack down actions need to be inserted into
the plan  linearizing the agenda entries  superuous jack up and jack down actions must
most likely be inserted for all wheels  yielding plans that are two steps longer  the reason
for that is that any tight goal might be the first in the linearization  most likely  this is
not the tight goal corresponding to the hub that is still jacked up  so the planner needs to
insert one superuous jack down action here  later  it must jack up this hub again  yielding
another superuous action  using  g r l in the case of    tires  only      actions need
to be tried until a plan of     actions is found  which takes      s  gam requires      s 
rifo requires       s       s are consumed to generate the planning graphs  and      s are
spent to compute the initial states for all subproblems  the remaining      s are consumed
for parsing and instantiating 
i

   

i

fion reasonable and forced goal orderings
      the tower of hanoi

a surprising result is obtained in the tower of hanoi domain  in this domain  a stack of discs
has to be moved from one peg to a third peg with an auxiliary second peg between them 
but never a larger disc can be put onto a smaller disc  in the case of three discs d   d   d 
of increasing size  the goals are stated as on d  peg    on d  d    on d  d    gam returns
the following agenda  which correctly reects the ordering that the largest disc needs to be
put in its goal position first 
   on d  peg  
   on d  d  
   on d  d  

the goal agenda leads to a partition into subproblems that corresponds to the recursive
formulation of the problem solving algorithm  i e   to solve the problem for n discs  the
planner first has to solve the problem for n   discs  etc  for the first entry  a plan of  
actions  time steps   to   below  is generated  which achieves the goal on d  peg     then
a plan of   actions  time steps   and    achieves the goals on d  peg   and on d  d   with
on d  peg   holding already in the initial state  finally  a one step plan  time step    is
generated that moves the third disc with the other two discs being already in the goal
position 
time
time
time
time

step
step
step
step

  
  
  
  

move d  d  peg  
move d  d  peg  
move d  peg  d  
move d  peg  peg  

time step    move d  d  peg  
time step    move d  peg  d  
time step    move d  peg  d  

surprisingly  ipp is not able to benefit from this information  but runtime of ipp using
gam is exploding dramatically for increasing numbers of discs  see figure    
discs  actions ipp ipp  g
ucpop
ucpop on subproblems
 
       
              
                    
 
       
                                                 
 
       
    
 
        
    
 
        
     
 
                 
figure     runtimes of ipp with and without the goal agenda on hanoi problems compared to ucpop without agenda and ucpop on the agenda subproblems using
zlifo and the ibf control strategy 
   a move action takes as first argument the disc to be moved  as second the disc from which it is moved 
and as third argument the disc or peg to which it is moved 

   

fikoehler   hoffmann
we are not able to provide an explanation for this phenomenon  but the division into
subproblems causes a much larger search space for the planner although the same solution
plans result  rifo cannot improve on the situation because it selects all actions as relevant 
the tower of hanoi domain is the only one we found where ipp s performance is deteriorated by gam  we do currently not see a way of how one can tell in advance whether ipp
will gain an advantage from using gam or not  the overhead caused by the goal analysis
itself is very small  but an  inadequate  split of the goals into subgoal sets can lead to more
search  see also section   
however in this case  the phenomenon seems to be specific to ipp  we simulated the
information that is provided by gam in ucpop and obtained a quite different picture 
the fifth column in figure    shows the runtime of ucpop using zlifo  pollack  joslin 
  paolucci        and the ibf control strategy with the number of explored partial plans
in parentheses  ucpop can only solve the problem for   and   discs  in the last column
of the figure  we show the runtime and number of explored partial plans  which result
when ucpop is run on the subproblems that result from the agenda  these are exactly
the same subproblems which ipp has to solve  but the performance of ucpop improves
significantly  instead of taking   s and exploring      partial plans  ucpop only takes
                    s and explores only            plans  unfortunately  any problems
or subproblems with more than   discs remain beyond the performance of ucpop  the
performance improvement is independent of the search strategies used by ucpop  for
example  if ibf control is used without zlifo  the number of explored partial plans is
reduced from       down to      in the case of the problem with   discs  runtime improves
from    seconds down to   seconds  similarly  when using bf control without zlifo the
number of explored partial plans reduces from      down to     
knoblock        also reports an improvement in performance for the prodigy planner
 fink   veloso        when it is using the abstraction hierarchy generated for this domain
by the alpine module  which provides in essence the same information as the goal agenda  
   summary and comparison to related work

many related approaches have been developed to provide a planner with the ability to
decompose a planning problem by giving it any kind of goal ordering information  subsequently  we discuss the most important of them and review our own work in the light of
these approaches 
our method introduces a preprocessing approach  which derives a total ordering for
subsets of goals by performing a static  heuristic analysis of the planning problem at hand 
the approach works for domains described with strips or adl operators and is based
on polynomial time algorithms  the purpose of this method is to provide a planner with
search control  i e   we opt at deriving a goal achievement order and then successively call
the planner on the totally ordered subsets of goals 
the method preserves the soundness of the planning system  but the completeness
only in the case that the planning domain does not contain deadlocks  we argue that
   however  to find that goal ordering information  alpine requires to represent the tower of hanoi domain
involving several operators  cf   knoblock        

   

fion reasonable and forced goal orderings
benchmark domains quite often possess this property  which is also supported by other
authors  williams   nayak        
the computation of  and  requires only polynomial time  but both methods are
incomplete in the sense that they will not detect all reasonable goal orderings in the general
case  the complexity of deciding on the existence of forced and reasonable goal orderings
has been proven to be pspace hard in section   and therefore  trading completeness for
eciency seems to be an acceptable solution  our complexity results relate to those found
by bylander        who proves the pspace completeness of serial decomposability  korf 
       given a set of subgoals  serial decomposability means that previously satisfied subgoals do not need to be violated later in the solution path  i e   once a subgoal has been
achieved  it remains valid until the goal is reached  the purpose of our method is to derive
constraints that make those orderings explicit under which no serial decomposability of a set
of goals can be found  i e   we consider the complementary problem  which is also reected
in our complexity proofs 
in many cases  we found that the goal agenda manager can significantly improve the
performance of the ipp planning system  but we found at least one domain  namely the
tower of hanoi  where a dramatic decrease in performance can be observed although ipp
still generates the optimal plan when processing the ordered goals from the agenda  so
far  the complexity results of backstrom and jonsson        predicted that planning with
abstraction hierarchies can be exponentially less ecient  but because exponentially longer
plans can be generated 
the idea to analyze the effects and preconditions of operators and to derive ordering
constraints based on the interaction of operators can also be found in a variety of approaches 
while we analyze harmful interactions of operators in our method by studying the delete
effects  the approaches described in  dawsson   siklossy        korf        knoblock 
      concentrate on the positive interactions between operators  the successful matching
of effects to preconditions forms the basis to learn macro operators  see  dawsson   siklossy 
      korf        
the alpine system  knoblock        learns abstraction hierarchies for the prodigy
planner  fink   veloso         the approach is based on an ordering of the preconditions
and the effects of each operator  i e   all effects of an operator must be in the same abstraction
hierarchy and its preconditions must be placed at the same or a lower level than its effects 
this introduces an ordering between the possible subgoals in a domain  which is orthogonal
to the ordering we compute  in alpine  a subgoal a is ordered before a subgoal b if
a enables b   i e   a must be possibly achieved first in order to achieve b   our method
orders a before b if a cannot be achieved without necessarily destroying b   the result of
alpine and gam are a set of binary constraints  in the case of alpine  the constraints
are computed between all atoms in a domain  while gam restricts the analysis to the
goals only  both approaches represent the binary constraints in a graph structure  alpine
merges atomic goals together if they belong to a strongly connected component in the graph 
gam merges sets of goals together if they have identical degree  then they both compute
a topological sorting of the sets that is consistent with the constraints  the resulting goal
orderings can be quite similar as the examples by knoblock        demonstrate  but gam
approximates reasonable goal orderings in domains where alpine fails in finding abstraction
hierarchies  two further examples  knoblock        are the tower of hanoi domain using
h

e

   

fikoehler   hoffmann
only one move operator and the blocks world  in both domains  alpine cannot detect
the orderings because it investigates the operator schemata  not the set of ground actions 
and therefore cannot distinguish the orderings between different instantiations of the same
literal  although alpine could be modified to handle ground actions  this will significantly
increase the amount of computation it requires  gam on the other hand  handles large sets
of ground actions in an ecient way  in particular if direct analysis is used   
an analysis  which is quite similar to alpine  but which is performed in the framework
of htn planning  is described by tsuneto et al          the approach analyzes the external
conditions of methods  which cannot be achieved when decomposing the method further 
this means  such conditions have to be established by the decomposition of those methods 
which precede the method using this external condition  two strategies to determine the
decomposition order of methods are defined and empirically compared  here lies the main
difference to the other approaches described so far  instead of trying to automatically
construct the decomposition orderings  they are predefined and fixed for all domains and
problems 
harmful interactions among operators are studied by smith and peot        and etzioni
        a threat of an operator o to a precondition p occurs if there is an instantiation of
o such that its effects are inconsistent with p  smith   peot         the knowledge about
threats is used to control a plan space planner  in contrast to a state space planner such as
ipp  computing an explicit ordering of goals does not prevent the presence of threats in a
partial plan because the order in which the goals are processed does not determine the order
in which actions occur in the plan  the notion of forced and reasonable goal orderings is
not comparable to that of a threat because a threat still has the potential of being resolved
by adding binding or ordering constraints to the plans  in contrast to this  a forced or
reasonable goal ordering persists under all bindings and enforces a specific ordering of the
subgoals 
given a planning problem  static  etzioni        computes a backchaining tree from the
goals in the form of an and or graph  which it subsequently analyzes for the occurrence
of goal interactions that will necessarily occur  this analysis is much more complicated
than ours  because static has to deal with uninstantiated operators and axioms  which
describe properties of legal states  the result of the analysis are goal ordering rules  which
order goals if certain conditions are satisfied in a state  this is the main difference to gam 
which generates explicit goal orderings independently of a specific state  it does not need to
extract conditions that a specific state has to satisfy because it considers the generic state
s      in the analysis  which represents all states satisfying a  but not b   as gam  static
is incomplete in the sense that it cannot detect all existing goal interactions  the problem
for gam is that deciding reasonable orderings is pspace hard  as we have proven in this
paper  the problem for static is that it has to compute the necessary effects of an operator
in a given state  as etzioni        conjectures and nebel and backstrom        prove  this
a 

b

    abstraction hierarchies are more general than the goal orderings we compute  they cannot only serve
for the purpose of providing a planner with goal ordering information  but also allow to generate plans
at different levels of refinement  see also  bacchus   yang         two other approaches generating
abstraction hierarchies based on numerical criticality values can be found in  sacerdoti        bundy 
giunchiglia  sebastiani    walsh        

   

fion reasonable and forced goal orderings
problem is computationally intractable and therefore  any polynomial time analysis method
must be incomplete 
last  but not least there have been quite a number of approaches in the late eighties 
which focused directly on subgoal orderings  these fall into two categories  the approaches
described in  drummond   currie        hertzberg   horz        focus on the detection of
conicts caused by goal interdependencies to guide a partial order planner during search  we
do not investigate these approaches in more detail here because they do not extract explicit
goal orderings as a preprocess to planning as we do  the works described in  irani   cheng 
      cheng   irani        joslin   roach        implement preprocessing approaches 
which perform a structural analysis of the planning task to determine an appropriate goal
ordering before planning starts  irani and cheng        compute a relation  between
pairs of goals  which roughly speaking orders a goal a after a goal b if b must be
achieved before a can be achieved  their formalism is rather complicated and the theoretical
properties of the relation are not investigated  in  cheng   irani         the approach is
extended such that sets of goals can be ordered with respect to each other  the exact
properties of the formalism remain unclear  in  joslin   roach         a graph theoretical
approach is described that generates a graph with all atoms from a given domain description
as nodes and draws an arc between a node a and a node b if an operator exists that takes
a as precondition and has b as an effect  when assuming that all operators have inverse
counterparts  identifying connected components in the graph is proposed as a means to
order goals  the approach is unlikely to scale to the size of problem spaces today s planners
consider and it is also completely outdated in terms of terminology 
finally  one can wonder how the reasonable and forced goal orderings relate to others
defined in the literature  there is only one attempt of which we know where an ordering
relation is explicitly defined and its properties are studied  see  hullem et al          in
this paper  the notion of necessary goal orderings is introduced  which must be true in
all minimal solution plans  kambhampati           the approach extends operator graphs
 smith   peot        and orders a goal based on three criteria called goal subsumption  goal
clobbering  and precondition violation  goal subsumption a   b holds if every solution plan
achieving a goal b in a state s also achieves a goal a in a state s  preceding s  and no plan
achieving one of the goals in g n fag deletes a  goal clobbering holds if any solution plan
for a deletes b and thus  a   b   precondition violation holds if any solution for b results
in a deadlock from which a cannot be reached anymore  i e   again a   b   a composite
criterion is defined that tests all three criteria simultaneously    a goal a is necessarily
ordered before b if it satisfies the composite criterion 
we remark that precondition violation seems to be equivalent to the forced orderings we
introduced  while goal clobbering appears to be similar to our reasonable orderings  it is not
possible for us to verify this conjecture as the authors of  hullem et al         do not give
exact formal definitions  we have nothing similar to goal subsumption and we argue that
this criterion will be rarely satisfied in natural problems  if a goal a is achieved by every
    a plan is minimal if it contains no subplan that is also a solution plan  we remark that minimality does
not mean that only shortest plans having the least number of actions are considered  in fact  minimal
plans can be highly non optimal as long as no action is truly superuous 
    here  the authors are not very precise about what they mean with this  we argue that this means that
two goals are ordered if they satisfy at least one of the criteria 

   

fikoehler   hoffmann
solution for a goal b anyway  then the goal a can be removed from the goal set without
changing the planning task 
the authors report that they are able to detect necessary orderings in the artificial
domains d s   cf   barrett   weld         but fail in typical benchmark domains such as
the blocks world or the tyreworld  the reason for this seems to be that their operator graphs
do not represent all possible instantiations of operator schemes  as the authors claim  this
makes operator graph analysis very ecient  however  the heuristic ordering  that we
introduced in this paper also takes almost no computation time  and succeeds in finding
the goal orderings in these domains 
i

i

h

   outlook

three promising avenues for future research are the following 
first  one can imagine that goal ordering information is also used during the search
process  i e   by not only ordering the original goal set  but also other goals that emerge
during search  the major challenge seems to balance the effort on computing the goal
ordering information with the savings that can result for the search process  one can
easily imagine that ordering all goal sets that are ever generated can become a quite costly
investment without yielding a major benefit for the planner 
secondly  the refinement of the goal agenda with additional subgoals is another interesting future line of work  a first investigation using so called intermediate goals  these are
facts that the planner must make true before it can achieve an original goal  has been
explored inside gam and the results are reported in  koehler   hoffmann         earlier
work addressing the task of learning intermediate goals can be found in  ruby   kibler 
       but this problem has not been in the focus of ai planning research since then 
a third line of work addresses the interaction of gam with a forward searching planning system  we have seen that gam preserves the correctness of a planner  and that
it preserves the completeness at least on deadlock free planning domains  we have also
seen  however  that solution plans using gam can get longer  i e   gam does not preserve the optimality of a planner  recently  planning systems that do not deliver plans of
guaranteed optimality have demonstrated an impressive performance in terms of runtime
and plan length  e g   hsp  which is first mentioned in  bonet  loerincs    geffner        
grt  refanidis   vlahavas         and in particular ff  hoffmann         these systems
are heuristic search planners searching forward in the state space with non admissible  but
informative heuristics 
the ff planning system developed by one of the authors has been awarded  group a
distinguished performance planning system  and has also won the schindler award for
the best performing planning system in the miconic    elevator domain  adl track  at
the aips      planning competition  the integration of goal agenda techniques into the
planner is one of the factors that enabled the excellent behavior of ff in the competition 
they were crucial for scaling to blocks world problems of    blocks  helped by about a factor  
on schedule and miconic     and never slowed down the algorithm 
forward state space search is a quite natural framework to be driven by the goal agenda 
simply let the planner solve a subproblem  and start the next search from the state where
the last search ended  even more appealing  heuristic forward search planners have a deeper
   

fion reasonable and forced goal orderings
kind of interaction with gam than for example graphplan style planners  in addition
to the smaller problems they are facing when using the goal agenda  their heuristics are
inuenced because they employ techniques for estimating the goal distance from a state 
when using the goal agenda  different goal sets result at each stage of the planning process
and therefore  the goal distance estimate will be different  too  currently a heuristic device
inside the ff search algorithm is being developed  which knows that it is being driven by
a goal agenda  and which has access to the complete set of goals  this information can be
used to further prune unpromising branches from the search space when it discovers that
currently achieved goals will probably have to be destroyed and reachieved later on 
references

allen  j   ed    aips            proceedings of the  th international conference on artificial intelligence planning systems  aaai press  menlo park 
anderson  c     weld  d          conditional effects in graphplan  in allen  allen        
pp        
bacchus  f     yang  q          downward refinement and the eciency of hierarchical
problem solving  artificial intelligence             
backstrom  c     jonsson  p          planning with abstraction hierarchies can be exponentially less ecient  in mellish  mellish         pp            
barrett  a     weld  d          partial order planning  evaluating possible eciency gains 
artificial intelligence             
blum  a     furst  m          fast planning through planning graph analysis  artificial
intelligence                    
bonet  b   loerincs  g     geffner  h          a robust and fast action selection mechanism for planning  in proceedings of the   th national conference of the american
association for artificial intelligence  pp          
bundy  a   giunchiglia  f   sebastiani  r     walsh  t          computing abstraction
hierarchies by numerical simulation  in weld    clancey  weld   clancey         pp 
        
bylander  t          complexity results for serial decomposability  in proceedings of the
  th national conference of the american association for artificial intelligence  pp 
        san jose  ca  mit press 
bylander  t          the computational complexity of propositional strips planning 
artificial intelligence              
chapman  d          planning for conjunctive goals  artificial intelligence                  
cheng  j     irani  k          ordering problem subgoals  in sridharan  sridharan        
pp          
   

fikoehler   hoffmann
dawsson  c     siklossy  l          the role of preprocessing in problem solving systems 
in proceedings of the  th international joint conference on artificial intelligence  pp 
        cambridge  ma 
dimopoulos  y   nebel  b     koehler  j          encoding planning problems in nonmonotonic logic programs  in steel  steel         pp          
drummond  m     currie  k          goal ordering in partially ordered plans  in sridharan
 sridharan         pp          
el kholy  a     richards  b          temporal and resource reasoning in planning  the
parcplan approch  in wahlster  w   ed    proceedings of the   th european conference on artificial intelligence  pp           john wiley   sons  chichester  new
york 
etzioni  o          acquiring search control knowledge via static analysis  artificial intelligence              
fink  e     veloso  m          prodigy planning algorithm  technical report cmu        
carnegie mellon university 
fox  m     long  d          the automatic inference of state invariants in tim  journal
of artificial intelligence research             
fox  m     long  d          ecient implementation of the plan graph in stan  journal
of artificial intelligence research             
hertzberg  j     horz  a          towards a theory of conict detection and resolution in
nonlinear plans  in sridharan  sridharan         pp          
hoffmann  j          a heuristic for domain independent planning and its use in an enforced
hill climbing algorithm  in   th international symposium on methods for intelligent
systems 
hullem  j   munoz avila  h     weberskirch  f          extracting goal orderings to
improve partial order and graphplan based planning  technical report  university of
kaiserslautern 
irani  k     cheng  j          subgoal ordering and goal augmentation for heuristic problem solving  in mcdermott  d   ed    proceedings of the   th international joint
conference on artificial intelligence  pp            milan  italy  morgan kaufmann 
jonsson  p   haslum  p     backstrom  c          towards ecient universal planning  a
randomized approach  artificial intelligence                
joslin  d     roach  j          a theoretical analysis of conjunctive goal problems  artificial
intelligence             
kambhampati  s          admissible pruning strategies based on plan minimality for planspace planning  in mellish  mellish         pp            
   

fion reasonable and forced goal orderings
kautz  h     selman  b          pushing the envelope  planning  propositional logic  and
stochastic search  in weld    clancey  weld   clancey         pp            
knoblock  c          automatically generating abstractions for problem solving  ph d 
thesis  carnegie mellon university 
knoblock  c          automatically generating abstractions for planning  artificial intelligence                  
koehler  j          handling of conditional effects and negative goals in ipp  technical report      university of freiburg  institute of computer science  available at
http   www informatik uni freiburg de   koehler ipp html 
koehler  j     hoffmann  j          planning with goal agendas  technical report
     university of freiburg  available at http   www informatik uni freiburg de  
koehler ipp html 
koehler  j   nebel  b   hoffmann  j     dimopoulos  y          extending planning graphs
to an adl subset  in steel  steel         pp          
korf  r          macro operators  a weak method for learning  artificial intelligence     
      
korf  r          planning as search  a quantitative approach  artificial intelligence     
      
mcdermott  d     hanks  s          nonmonotonic logic and temporal projection  artificial
intelligence              
mellish  c   ed    ijcai            proceedings of the   th international joint conference
on artificial intelligence  morgan kaufmann  san francisco  ca 
nebel  b     backstrom  c          on the computational complexity of temporal projection  planning  and plan validation  journal of artificial intelligence                  
nebel  b   dimopoulos  y     koehler  j          ignoring irrelevant facts and operators in
plan generation  in steel  steel         pp          
nilsson  n          principles of artificial intelligence  tioga publishing company  palo
alto 
pednault  e          adl  exploring the middle ground between strips and the situation
calculus  in brachman  r   levesque  h     reiter  r   eds    proceedings of the  st
international conference on principles of knowledge representation and reasoning 
pp          toronto  canada  morgan kaufmann 
penberthy  j     weld  d          ucpop  a sound  complete  partial order planner
for adl  in nebel  b   swartout  w     rich  c   eds    proceedings of the  rd
international conference on principles of knowledge representation and reasoning 
pp           morgan kaufmann  san mateo 
   

fikoehler   hoffmann
pollack  m   joslin  d     paolucci  m          selection strategies for partial order planning 
journal of artificial intelligence research             
refanidis  i     vlahavas  i          grt  a domain independent heuristic for strips
worlds based on greedy regression tables  in proceedings of the  th european conference on planning  pp          
regli  w   gupta  s     nau  d          ai planning versus manufactoring operation
planning  a case study  in mellish  mellish         pp            
ruby  d     kibler  d          learning subgoal sequences for planning  in sridharan
 sridharan         pp          
russel  s     norvig  p          artificial intelligence   a modern approach  prentice hall 
sacerdoti  e          planning in a hierarchy of abstraction spaces  artificial intelligence 
           
sanborn  j     hendler  j          near term event projection through dynamic simulation
or how did the robot cross the road  in proceedings of the  nd conference on ai and
simulation 
smith  d     peot  m          postponing threats in partial order planning  in proceedings
of the   th national conference of the american association for artificial intelligence 
pp           aaai press  mit press 
sridharan  n   ed    ijcai            proceedings of the   th international joint conference on artificial intelligence  detroit  mi  morgan kaufmann 
steel  s   ed    ecp            proceedings of the  th european conference on planning 
vol       of lnai  springer 
tsuneto  r   hendler  j     nau  d  s          analyzing external conditions to improve
the eciency of htn planning  in allen  allen         pp          
veloso  m     blythe  j          linkability  examining causal link commitments in partialorder planning  in hammond  k   ed    proceedings of the  nd international conference on artificial intelligence planning systems  pp           aaai press  menlo
park 
warshall  j          a theorem on boolean matrices  journal of the acm               
weld  d     clancey  b   eds     aaai            proceedings of the   th national conference of the american association for artificial intelligence  aaai press 
williams  b     nayak  r          a reactive planner for a model based executive  in
proceedings of the   th international joint conference on artificial intelligence  pp 
           morgan kaufmann  san francisco  ca 

   

fi