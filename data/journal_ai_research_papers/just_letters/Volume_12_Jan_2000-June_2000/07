journal artificial intelligence research                  

submitted        published     

reasonable forced goal orderings use
agenda driven planning algorithm

jana koehler ch schindler com

jana koehler
schindler lifts  ltd 
r   technology management
     ebikon  switzerland
jorg hoffmann
institute computer science
albert ludwigs university
georges kohler allee  geb    
      freiburg  germany

hoffmann informatik uni freiburg de

abstract

paper addresses problem computing goal orderings  one
longstanding issues ai planning  makes two new contributions  first  formally
defines discusses two different goal orderings  called reasonable
forced ordering  orderings defined simple strips operators well
complex adl operators supporting negation conditional effects  complexity
orderings investigated practical relevance discussed  secondly  two
different methods compute reasonable goal orderings developed  one
based planning graphs  investigates set actions directly  finally 
shown ordering relations  derived given set goals
g   used compute so called goal agenda divides g ordered set
subgoals  planner then  principle  use goal agenda plan increasing
sets subgoals  lead exponential complexity reduction  solution
complex planning problem found solving easier subproblems  since polynomial
overhead caused goal agenda computation  potential exists dramatically speed
planning algorithms demonstrate empirical evaluation  use
method ipp planner 
   introduction

effectively plan interdependent subgoals focus ai planning
research long time  starting early work abstrips  sacerdoti       
conjunctive goal planning problems  chapman         quite number approaches
presented complexity problems studied  today 
planners made progress solving bigger planning instances scalability
classical planning systems still problem 
paper  focus following problem  given set conjunctive goals 
define detect ordering relation subsets original goal set  arrive
ordering relation subsets  first focus atomic facts contained
goal set  formally define two closely related ordering relations atomic goals 
c      ai access foundation morgan kaufmann publishers  rights reserved 

fikoehler   hoffmann
call reasonable forced ordering  study complexity  turns
hard decide 
consequently  introduce two ecient methods used approximate
reasonable goal orderings  definitions first given simple strips domains 
desired theoretical properties easily proven  afterwards  extend definitions
adl operators  pednault        handling conditional effects negative preconditions 
discuss invest effort trying find forced orderings 
show set ordering relations atomic goals used divide
goal set disjunct subsets  subsets ordered respect
other  resulting sequence subsets comprises so called goal agenda 
used control agenda driven planning algorithm 
method  called goal agenda manager  implemented context ipp
planning system  show potential exponentially reducing computation times
certain planning domains 
paper organized follows  section   introduces motivates reasonable
forced goal orderings  starting simple strips operators  formally defined 
complexity investigated  section    present two methods  compute approximation reasonable ordering discuss orderings
practical point view  section concludes extension definitions adl
operators conditional effects  section   shows planning system benefit
ordering information computing goal agenda guides planner  define
subsets goals ordered respect discuss goal
agenda affect theoretical properties  particular completeness planning
algorithm  section   contains empirical evaluation work  showing results
obtained using goal agenda ipp  section   summarize approach light
related work  paper concludes outlook possible future research directions
section   
   ordering relations atomic goals

start  investigate simple strips domains allowing sets atoms
describe states  preconditions  add delete lists operators 
definition    state  set ground atoms denoted p   state    
p

subset ground atoms 

note states assumed complete  i e   always know atom p whether
p   p    holds  assume operator schemata ground  i e  
talk actions 
definition    strips action  strips action usual form
pre o    add add o  del del o 
pre o  preconditions o  add o  add list del o  delete
list action  set ground atoms  assume del o    add o      
result applying strips action state defined usual 
   

fion reasonable forced goal orderings

result s  o    



 s   add o   n del o  pre o 
otherwise



pre o  holds  action said applicable s  result applying
sequence one action state recursively defined
result s  ho           

i     result result s  ho              i     
definition    planning problem  planning problem  o    g   triple
set actions   the initial state  g  the goals  sets ground atoms 
plan p ordered sequence actions  actions plan taken certain
action set o  denote writing p  
n

n

n

note define plan sequence actions  sequence parallel steps 
done graphplan  blum   furst         example  makes subsequent
theoretical investigation readable  results directly carry parallel plans 
given two atomic goals b   various ways define ordering relation
imagined  first  one distinguish domain specific domainindependent goal ordering relations  although domain specific orderings
effective  need redeveloped single domain  therefore  one particular
interested domain independent ordering relations broader range applicability 
secondly  following hullem et al          one distinguish goal selection goal
achievement order  first ordering determines order planner works
various atomic goals  second one determines order  solution
plan achieves goals  paper  compute ordering latter type 
agenda driven planning approach propose later paper  orderings
coincide anyway  goals achieved first plan planner
works first 
following scenario motivates achievement order goals possibly
defined  given two atomic goals b   solution plan exists  let us assume
planner achieved goal a  i e   arrived state s       
holds  b hold yet  now  exists plan executable s     
achieves b without ever deleting a  solution found  plan
found  two possible reasons exist 
   problem unsolvable achieving first leads planner deadlock situation  thus  planner forced achieve b simultaneously a 
   existing solution plans destroy temporarily order achieve b  
then  achieved first  instead  seems reasonable achieve
b simultaneously sake shorter solution plans 
first situation  ordering  b simultaneously a  forced inherent properties planning domain  second situation  ordering  b
simultaneously a  appears reasonable order avoid non optimal plans  consequently  define two goal orderings  called forced reasonable ordering 
sake clarity  first give basic definitions 
a 

b

a 

   

b

fikoehler   hoffmann
definition    reachable state  let  o    g   planning problem let p

set ground atoms occur problem  say state p reachable  iff
exists sequence ho            actions   result i   ho            i 
holds 
n

n

definition    generic state s        let  o    g   planning problem  s   
a 

b

a 

b

 

denote reachable state achieved  b false 
i e   b    s      sequence actions ho            s       
result i   ho            i     add o   
a 

n

b

n

a 

b

n

one imagine s      state incomplete information 
states represents satisfy j  a   b   atoms p   p p    a  b
adopt arbitrary truth values 
definition    reduced action set   let  o    g   planning problem  let
a 

b



  g atomic goal  denote set actions delete a 
i e     fo   j    del o g 




prepared define exactly mean forced reasonable goal orderings 
definition    forced ordering   let  o    g   planning problem  let a  b  
g two atomic goals  say forced ordering b a  written
f

b a 
f

     p   b   result s        p  
definition   satisfied  plan achieving b must achieve b
simultaneously a  otherwise encounter deadlock  rendering
problem unsolvable 
definition    reasonable ordering   let  o    g   planning problem  let
a  b   g two atomic goals  say reasonable ordering b

  s 

 

a 

b

 

a 

b

r

a  written b a 
r

  s           p oa   b   result s        p oa  
definition   gives b meaning if  goal achieved 
a 

b

a 

b

r

plan anymore achieves b without at least temporarily destroying a  b
goal prior a 
remark obviously b implies b a  vice versa  make
slightly less obvious observation point  formulae definitions     use
universal quantification states s        planning problem
state all  formulae satisfied goals b get ordered  i e   b
b follow  respectively  case  however  much information gained
goal ordering b   sequence actions achieve b prior
simultaneously a a cannot achieved b still false  thus
case  ordering relations b b trivial sense reasonable
planner would invest much effort considering goals b ordered way
round anyway 
r

f

a 

b

f

r

f

r

   

fion reasonable forced goal orderings
definition    trivial ordering relation  let  o    g   planning problem  let
a  b   g two atomic goals  ordering relation b
state s       
a 



f

b called
r

trivial iff

b

paper  usually consider forced reasonable goal orderings non trivial
orderings make distinction explicit so 
definitions     seem deliver promising candidates achievement order 
unfortunately  hard test  turns corresponding decision
problems pspace hard 
theorem   let f order denote following problem 

given two atomic facts b   well action set initial state  
b hold  
f

deciding f order pspace hard 

proof  proof proceeds polynomially reducing

plansat  bylander        the
decision problem whether exists solution plan given arbitrary strips
planning instance to problem deciding f order 

let   g   denote initial state  goal state  action set arbitrary
strips instance  let a  b   c new atomic facts contained instance
far  build new action set initial state f order instance setting

 
 
o        

o 
o 




g

 
  add fag del fc g   
  add del fag   
  add fb g del  

  fc g
  fag
 g



     fc g
definitions  reaching b equivalent solving original problem 
way round  unreachability b a forced ordering b a is equivalent
unsolvability original problem  order prove this  consider following 
way achieving applying       consequently  state s     
fag  cf  definition    thus starting assumption b valid  apply
following equivalences 
f



a 

b

f

b
f

 
 
 
 

  s           p o    b   result s        p o   
cf  definition  
 
 
   p   b   result fag  p  
fag reachable state s     
   p   g result i   p  
definition  
solution plan exists   g given
a 

b

a 

b

a 

   

b

fikoehler   hoffmann
thus  complement plansat polynomially reduced f order  pspace
  co pspace  done 
theorem   let r order denote following problem 

given two atomic facts b   well action set initial state  
b hold  
deciding r order pspace hard 
r

proof  proof proceeds polynomially reducing plansat r order 

let   g   initial state  goal state  action set arbitrary
strips planning instance  let a  b   c   new atomic facts contained
instance far  define new action set o  setting
 
 
    fc g
  add fa  dg del fc g   
 
o             fa  dg   add del fdg 
 
 g
  add fb g del  



g

new initial state

     fc g

proof theorem    intention behind definitions make solvability
original problem equivalent reachability b a  reasonable orderings 
reachability concerned actions delete a  need safety
condition d 
precisely  way achieve applying      i e   per definition  
state s      fa  dg  action new operator set o  deletes a 
following sequence equivalences 


a 

b

b
  s         p oa    b   result s       p oa   
   p oa    b   result fa  dg  p oa   
r

 
 
     p o    b   result fa  dg  p o   
     p g result i   p  
  solution plan exists   g  
a 

b

a 

b

cf  definition

fa  dg reachable state s     
action   deletes
definition  
a 

b

thus  complement plansat polynomially reduced r order 
pspace   co pspace  done 
consequently  finding reasonable forced ordering relations atomic goals
already hard original planning problem appears unlikely planner
gain advantage that  possible way dilemma define new
ordering relations  decided polynomial time are  ideally  sucient
existence reasonable forced goal orderings  following  introduce two
orderings 
   

 

fion reasonable forced goal orderings
   computation goal orderings

section 
   define goal ordering   computed using graphplan s exclusivity
information facts  prove ordering sucient
decided polynomial time  the subscript  e  stands  ecient   
   define goal ordering   computed based heuristic method
much faster computation based graphplan  delivers powerful
goal ordering information  the subscript  h  stands  heuristic   
   discuss currently available benchmark planning domains contain forced orderings  i e   fail providing problem decomposition them 
   show orderings extended handle expressive adl operators 
e

r

h

f

    reasonable goal orderings based graphplan

goal ordering always computed specific planning problem involving initial
state   goal set g fa  b g  set ground actions  order develop
ecient computational method  proceed two steps now 
   compute knowledge generic state s       
   define relation investigate theoretical properties  particular 
prove implies  
a 

b

e

e

r

state s      represents states reachable  
achieved  b hold  given information s        one derive
additional knowledge it  particular  possible determine subset atoms f 
one definitely knows f   s          must hold  one method determine f
obtained via computation invariants  i e   logical formulae hold reachable
states  cf   fox   long         determined invariants  one assumes
holds  b not  computes logical implications  another possibility
simply use graphplan  blum   furst         starting o  planning graph
built graph leveled time step  proposition level time
step represents set states  superset states reachable
applying actions o  atoms  marked mutually exclusive  blum
  furst        level never hold state satisfying a  thus  cannot
hold s        denote set f  the false set respect returned
 
graphplan 
f
   fp j p exclusive graph leveled offg
   
note planning graph grown given o  used
determine f sets atomic goals   g  
a 

b

a 

a 

a 

b

b


gp

b


gp



gp

   assume reader familiar graphplan  planning system well known
planning research community  otherwise   blum   furst        provide necessary background 

   

fikoehler   hoffmann

      holds states
using actions o 
lemma  



fgp





satisfying   reachable


proof follows immediately definitions  level off   two propositions
mutual exclusive  given  blum   furst        
provide simple test sucient existence reasonable ordering
b two atomic goals b  
definition     ecient ordering   let  o    g fa  b g  planning problem 
r

e

let f



gp

false set a  ordering b holds
e

      b   add o    pre o    f     

gp



means  b ordered reduced action set contains actions 
either b add lists do  require precondition
contained false set  preconditions never hold state satisfying
thus  actions never applicable 
theorem  
b a b
e

r

proof  assume b   a  i e   b   result s        p oa   reachable state s   
r

a 

b

a 

b

 

  s        b    s        plan p oa   ho                n 
   del o    definition    
  result s        ho            i    n
and  lemma   
f
  result s        ho            i        n
   
furthermore  b    s        b   result s        ho            i   must
step makes b true  i e  
   k n   b    result s       ho             i    b   result s       ho            i 
step  obviously b   add o   consequently  definition
b a  pre o     f       now  must applicable state
executed  otherwise would add anything state   preconditions
must hold  i e   pre o   result s        ho              i   immediately leads f  
result s        ho              i        contradiction equation     
quite obviously  ordering decided polynomial time 
a 

b

a 

n

b







a 



b



a 

gp

a 



b

b

a 

a 

n

b

k

b

a 

b

k

k

e


gp

k

k

k

k

a 

b

a 


gp

k

b

k

e

theorem   let e order denote following problem 

given two atomic facts b   well initial state action set o 

b hold  
e

then  e order decided polynomial time 
   

e order

  p 

fion reasonable forced goal orderings
proof  begin with  need show computing f

takes polynomial time 
results  blum   furst         follows directly building planning graph
polynomial jij  joj  l t  l maximal length precondition  add
delete list action  number time steps built  taking l parameter
input size  remains show planning graph levels polynomial
number time steps  now  planning graph leveled time steps
    neither set facts number exclusion relations change 
two subsequent time steps  set facts increase facts already occuring
graph remain there and number exclusions decrease non exclusive facts
non exclusive subsequent layers  thus  maximal number time steps
built graph leveled dominated maximal number changes
occur two subsequent layers  dominated maximal number
facts plus maximal number exclusion relations  maximal number facts
o jij   joj l   maximal number exclusions o  jij   joj l      square
maximal number facts 
computed f polynomial time  testing b involves looking actions
o  rejecting either
delete a  decidable time o l  
precondition  element f   decidable time o l  jij   joj l   
thus additional runtime test  o joj l  jij   joj l   

gp


gp

e


gp

let us consider following example  illustrates computation using
common representational variant blocks world actions stack  unstack 
pickup  putdown blocks 
e

pickup  ob 

clear  ob  on table  ob  arm empty  

  add holding  ob 

del clear  ob  on table  ob  arm empty   

putdown  ob 
holding  ob 

  add clear  ob  arm empty   on table  ob 
del holding  ob  

stack  ob  underob 

clear  underob  holding  ob 

unstack  ob  underob 

  add arm empty   clear  ob  on  ob  underob 
del clear  underob  holding  ob  

on  ob  underob  clear  ob  arm empty  

  add holding  ob  clear  underob 

del on  ob  underob  clear  ob  arm empty   

given simple task stacking three blocks 
initial state  on table a  on table b  on table c 
goal state  on a b  on b c 
   

fikoehler   hoffmann
reasonable ordering two atomic goals  intuitively  blocks world
domain possesses natural goal ordering  namely planner start building
tower bottom top way round  
let us first investigate whether relation on a  b  on b  c  holds  vividly speaking 
asks whether still possible stack block b on b  c  achieved 
first step  run graphplan find atoms exclusive on b  c 
planning graph  corresponds problem  leveled off  result
e

 

 

b c

fgp

  fclear c   on table b   holding c   holding b   on a c   on c b   on b a g

one observes immediately atoms never true state satisfies

on b  c  

secondly  remove ground actions delete on b  c   in case  action
    
ready test on a  b  on b  c  holds  action  add
on a  b  stack a b   preconditions holding a  clear b   neither
member f       test fails get on a  b    on b  c  
next step  test whether on b  c  on a  b  holds  graphplan returns
following false set 

unstack b c  satisfies condition  obtain reduced action set

b c

e

b c

e

gp

e

 

 

a b

fgp

  fclear b   on table a   holding b   holding a   on a c   on c b   on b a g

action unstack a b  contained     deletes on a  b  
action adds on b  c  stack b c   needs preconditions clear c 
holding b   second precondition holding b  contained set false facts 
i e   holding b    f     thus  conclude on b  c  on a  b   altogether 
on a  b    on b  c  on b  c  on a  b   correctly ects intuition b
needs stacked onto c stacked onto b 
although appears impose strict conditions domain order derive
reasonable goal ordering  succeeds finding reasonable goal orderings available test
domains orderings exists  example  tyreworld  bulldozer problems 
shopping problem  russel   norvig         fridgeworld  glass domain 
tower hanoi domain  link world  woodshop  disadvantage
computational resources requires  since building planning graphs  theoretically
polynomial  quite time  memory consuming thing do  
therefore  next section presents fast heuristic computation goal orderings 
analyzes domain actions directly need build planning graphs anymore 
a b

a b

e

gp

e

e

e

   note goals specify block c go  leave planner 
   recent implementations planning graphs  example developed stan  fox  
long        ipp      koehler        build graphs explicitly anymore orders
magnitude faster original graphplan implementation  still computation planning
graph takes almost time needed determine e relations 

   

fion reasonable forced goal orderings
    reasonable goal orderings derived fast heuristic method

one analyze available actions directly using method call direct analysis
 da   determines initial value f computing intersection delete lists
actions contain add list  defined following equation 


fda

 

  


 o  
 

   

del o 

   

add

atoms set false state achieved 
deleted state description independently action used add a 
short example  let us consider two actions

  add fag del fc  dg
  add fa  c g del fdg
atom deleted actions  thus element initially
contained f  
however  equation     says added atoms f
deleted  say anything whether might possible reestablish atoms
f   one easily imagine actions exist  leave true 
time add atoms  case  reachable states atoms
f hold 
now  goal derive ordering relation easily computed 
ideally  relation  sucient relation  therefore  want make
sure atoms f really false state achieved 
arrive approximation atoms remain false performing fixpoint reduction
f set  removing atoms achievable following sense 

da


da


da


da

e

r



da



da

definition     achievable atoms  atom p achievable state given
action set  written a s  p  o  
p s

        p   add o      p    pre o    a s  p   o 

definition says atom p achievable state holds s 
exists action domain  adds p whose preconditions achievable
s  necessary condition existence plan p state
p holds 
lemma     p   p   result s  p     a s  p  o 
proof  atom p must either already contained state s  added

step p   second case  preconditions need established
p way  thus p preconditions step  adds it  achievable
sense definition    
   

fikoehler   hoffmann
two obvious diculties definition     first  p   must tested 
complete knowledge state s  cause problems  case 
however  generic state s      cannot decide whether arbitrary
atom contained not  secondly  observe infinite regression preconditions 
must tested achievability 
first problem  turns good heuristic simply assume p    s 
i e   test performed all  second problem  order avoid infinite
looping  achievable  test  one needs terminate regression preconditions
particular level  point question far regress  quick approximation
simply decides  achievable  first recursive call 
a 

b

definition     possibly achievable atoms  atom p possibly achievable given
action set  written pa p  o  
      p   add o      p    pre o   

  o      p    add o   

holds  i e   action adds p preconditions add effects
actions o 

assumption justified none atoms p contained state s 
possibly achievable necessary condition achievable 
lemma   let state p     o     p   add o    pre o       

holds 

a s  p  o    pa p  o 
proof  a s  p  o  p    s  know step   o  p   add o  

  p    pre o  a s  p   o   know pre o         p    pre o 
must achiever o      p    add o    

condition facts p must contained state seems
rather rigid  nevertheless  condition possibly achievable delivers good results
benchmark domains easy decide  use test

perform fixpoint reduction set f
decide whether atomic goal b ordered a 

da

fixpoint reduction  depicted figure   below  uses approximative test pa f   
remove facts f achieved  finds facts certain
restrictions  see below  side effect fixpoint algorithm  obtain set
actions method assumes applicable state s        order b
iff cannot possibly achieved using actions 

da

a 

   

b

fion reasonable forced goal orderings
   f
   n fo j f   pre o      g
fixpoint reached    false
 fixpoint reached
fixpoint reached    true
f   f
pa f   


f    f n g
   n fo j f   pre o      g
fixpoint reached    false
f



da




endif
endfor
endwhile
return f  

figure    quick  heuristic fixpoint reduction set f  

da

computation checks whether atoms f   initially set f   possibly
achievable using actions  delete require atoms
f precondition  achievable atoms removed f   gets updated
accordingly  one iteration  f change  fixpoint reached  i e   f
decrease increase the final sets f false facts
applicable actions returned 
let us illustrate fixpoint computation short example consisting empty
initial state  goals fa  b g  following set actions


da

op  
op  
op   f c g
op   f g

 
 
 
 

add f g
add fa  c g
add f g
add f b g

del f c  g
del f g

assuming achieved  obtain f   f   fdg initial
value false set  since atom op  op  delete adding a 
figure   illustrates hypothetical planning process  starting empty initial state
trying achieve first  get two different states s      holds 
atom hold thus states  action applicable
requires precondition  excludes op    yielding initial action set
  fop   op   op g  now  op  action add b   therefore  used
action set see b still achieved  would find case 
consequently  without performing fixpoint computation  would order b a 
seen figure    would reasonable ordering  plan
hop   op i achieves b state s        result i  op   without destroying a 
fixpoint computation works us around problem follows  action op   add precondition op  without deleting a  checking
pa d    first iteration  fixpoint procedure finds action  checks


da

a 



a 

   

b

b

fikoehler   hoffmann
whether preconditions op  achievable sense added another action  case since precondition c added op   thus 
removed f   becomes empty now  action op  put back set  
becomes identical action set   set  turn  identical
original action set action deletes a  fixpoint process terminates b
ordered achieved using action op   correctly ects
fact exists plan state s        result i   hop i    fc  ag
state satisfies b without destroying a 


a 

b

  

deadlock

op 

op 



c 
op 
c  a 

holds state satisfying

op 
c  a  d  b

plan b

figure    example illustrating need fixpoint computation 
already pointed out  intention behind fixpoint procedure following 
starting state s        want know facts become true without
destroying a  consequently  actions become applicable  first step 
actions use facts f applicable  facts
deleted state description added  however  actions may make facts
f true  want remove facts f   manage find facts
made true without destroying a  final set f contain
facts hold state reachable s      without destroying a  case 
final action set contain actions applied s       
safely use action set determine whether another goal b still achieved
not 
however  use approximative test pa f  o  f   f find
fact current f set achievable  may facts achievable without
destroying a  remain set f   could exclude actions set
safely applied s       certain restrictions  however 
prove happen  order so  need impose restriction
particular state s        achieved goal a  none preconditions
actions  add facts contained f   occur state s        fixpoint
procedure remove facts f achievable without destroying a 
use property fixpoint procedure later show heuristic ordering relation
approximates reasonable orderings 
a 

b



da


da


da

a 

b

a 

a 

a 

b

b


da

a 



da

   

b

b

fion reasonable forced goal orderings
lemma   let  o    g   planning problem  let   g atomic goal  let
s      reachable state achieved  let p oa   ho           
sequence actions destroying a  let f set facts returned
fixpoint computation depicted figure   
a 

n

b

 f   f


da

   o     f   add o    pre o    s         


a 

  

b

fact f holds state reached applying p oa   i e  
result s        p oa     f    
a 

b

proof 

let f denote state fact action sets  respectively  j iterations
algorithm depicted figure    f decreases computation 


f f j   let s            denote sequence states encountered
executing p oa   ho            s        i e   s    s        result s     ho i 
  n  assume action applicable state     i e   pre o      
otherwise  cause state transition  skip p oa   obviously 
  result s        p oa    need show   f      proof proceeds
induction length n p oa  
n      p oa   hi   s    s        facts f deleted state
description added    f      f   f  f f   
proposition follows immediately 
n   n      p oa   ho                 i  induction hypothesis  know
  f       n  need show     sf     
let j step fixpoint iteration f      becomes empty  i e   j
denotes iteration intersection states   n f empty
first time  iteration exists  intersections   f n
empty 
action     n     applicable state     i e   pre o      
thus pre o     f     actions p oa   therefore  actions contained
  set contains actions whose intersection f empty 
let us focus facts state      facts achieved executing p oa
s        words  plan s      facts 
seen  plan consists actions   applying lemma   facts p     
using s      p oa    p oj    know facts p achievable using actions
 
j

j

n

j

n

a 

b

a 



b















n

a 

n

b

n

a 


da

b

n

n





da

da

n



n

j



     n





j















j



j

j

n

a 

b

a 

b

n

j

a 

b

j

  a s        p   
show facts f      interested in  namely f facts
added    still contained f   possibly achievable using actions
  let f fact f        f   f   apply lemma   using s        f  

 p  

  

n

a 

b

j

n

n

j

j

n

j

   

a 

b

fikoehler   hoffmann

o  apply lemma   obviously f    s         o     f   add o   
pre o    s          prerequisite     a s        p     arrive
 f        f   pa f  o 
a 

j

a 

b

a 

n

b

j

b

j

j

j

remains proven facts f removed f
fixpoint computation  argumentation above  sucient show
facts f        f get tested pa f    iteration j    fixpoint computation 
tests succeed lead      f        yielding  desired       f     
remember f   f   two cases  need consider 
   j      intersections   f  initially empty  i e     f       n 
case  facts f        f tested pa f  o    iteration j        
fixpoint computation 
   j      case  least one intersections   f became empty iteration
j definition j   i e   least one fact removed f iteration 
therefore  fixpoint reached yet  computation performs
least one iteration  namely iteration j      facts f tested
iteration  particular facts f        f  
observations  induction complete proposition proven 
already said  simply order b a  possibly achievable
using action set resulted fixpoint computation  ordering relation
 where h stands  heuristic   obtained way approximates reasonable goal
ordering  
definition     heuristic ordering   let  o    g fa  b g  planning problem 
n

j

j

n

n

j

j



n





da


da



j

j

n

j

h

r

let set actions obtained performing fixpoint computation
shown figure   
ordering b holds
 pa b  o 
h

h

reached particular state s      assumptions made
fixpoint computation test pa b    justified  possibly achievable sucient condition non existence plan b
temporarily destroy a 
theorem   let  o    g   planning problem  let a  b   g two atomic goals  let
a 

b

s      reachable state achieved  b still false  i e   b   
s        let f sets facts actions  respectively  derived
fixpoint computation shown figure   
a 

b

a 

b

 f   f   fb g    o     f   add o    pre o    s 


da





 pa b  o      p oa  

 

a 

b

b   result s        p oa  

   

a 

b

 

  

  

fion reasonable forced goal orderings
proof  assume plan p oa   ho            destroy a 
n

achieves b   i e   b   result s        ho            i   restriction   
facts f   lemma   applied action sequence ho              yielding
result s        ho              i    f      consequently  either
applicable result s        ho             i  
preconditions contained result s       ho              i   yielding pre o    

f     
first case  simply skip effects  second case 
  follows  thus  plan constructed actions achieves b
s        applying lemma   leads us a s        b     b    s       
know     respect b      o     b   add o   
pre o    s          holds  therefore  apply lemma   arrive pa b    
contradiction 
return blocks world example show computation proceeds 
let us first investigate whether on a  b  on b  c  holds  initial value f    
obtained delete list stack b c  action  one adds
goal 
a 

n

b





da

a 

b





a 



b

a 



b







a 

b

a 

b

a 

b



a 

b

h

b c

h

da

  fclear c   holding b g
intuitively  immediately clear neither facts ever hold state
on b  c  true  b c  c clear gripper cannot hold b 
turns fixpoint computation respects intuition leaves set f    
unchanged  yielding f   fclear c   holding b g  repeat fixpoint process
detail here  reconstructed figure   details necessary
understanding correct ordering relations derived  short  facts
achievers reduced action set  need preconditions
achiever available  example  holding b  achieved either unstack
pickup action  either need b stand another block stand table 
actions achieve facts need holding b  true thus excluded
reduced action set 
finishing fixpoint computation  planner tests pa on a  b     
contains actions except delete on b  c  use clear c  holding b 
precondition  finds action stack a b  adds on a  b   preconditions
action holding a  clear b   conditions added actions
pickup a  unstack a b   respectively  contained   neither
needs c clear b gripper  thus  test finds fact  on a  b 
possibly achievable using actions   ordering derived  i e   on a  b   
on b  c  follows 
now  way round  on b  c  on a  b  tested  initial value f    
obtained single action stack a b 
   
  fclear b   holding a g
f
 

 

b c

fda

b c
da

h

a b

h

da

a b
da

   

fikoehler   hoffmann
again  fixpoint computation cause changes  resulting f   fclear b  
holding a g  process tests whether pa on b  c     holds  contains
actions except delete on a  b  use clear b  holding a 
precondition  action add on b  c  stack b c   action needs
preconditions facts holding b  clear c   process finds crucial
condition achieving first fact violated  action achieve holding b 
clear b  precondition  b must clear first gripper hold it 
since clear b  element f   none actions achieving holding b  contained
o  consequently  test pa on b  c     fails obtain ordering on b  c 
on a  b   makes sense gripper cannot grasp b stack onto c anymore 
on a  b  achieved 
h

    forced goal orderings invertible planning problems

far  introduced two easily computable ordering relations
approximate reasonable goal ordering   one might wonder invest
effort trying find forced goal orderings  two reasons that 
h

e

r

   already seen section    forced goal ordering reasonable
goal ordering  i e   method approximates latter used crude
approximation former 
   many benchmark planning problems invertible certain sense  problems
contain forced orderings anyway 
section  elaborate detail second argument  results bit
general necessary point  want make use later show
agenda driven planning algorithm propose complete respect certain class
planning problems  proceed formally defining class planning problems  show
problems contain forced orderings  identify sucient criterion
membership problem class  finally  demonstrate many benchmark
planning problems fact satisfy criterion  start  introduce notion
deadlock planning problem 
definition     deadlock  let  o    g   planning problem  reachable state
called deadlock iff sequence actions leads goal  i e   iff
 
 
  result i   p      p   g result s  p   

class planning problems interested class problems

deadlock free  naturally  problem called deadlock free none reachable states

deadlock sense definition    
non trivial forced goal orderings imply existence deadlocks  remember
ordering b b called trivial iff state s      all  
f

r

a 

b

lemma   let  o    g   planning problem  let a  b   g two atomic goals 
non trivial forced ordering b b   exists deadlock
state problem 
f

   

fion reasonable forced goal orderings
proof  recalling definition   assuming non triviality   know
least one state s      made true  b still false  definition   
know plan state achieves b   particular 
possible achieve goals starting s        thus  state    s      must
deadlock 
f

a 

b

a 

b

a 

b

investigate deadlocks detail discuss commonly
used benchmark problems contain them  i e   deadlock free  lemma   
know domains contain non trivial forced goal orderings
either so much point trying find them  care trivial goal
orderings  orderings force reasonable planning algorithm consider goals
correct order 
existence deadlocks depends structural properties planning problem 
must action sequences  which  executed  lead states goals
cannot reached anymore  sequences must undesired effects  cannot
inverted sequence actions o  changing perspective  one obtains hint
sucient condition non existence deadlocks might defined  assume
planning problem effects action sequence domain
inverted executing certain sequence actions  invertible planning
problem  particular possible get back initial state reachable state 
therefore  problem solvable  contain deadlocks  state 
one reach goals going back initial state first  execute arbitrary
solution thereafter  formally define notion invertible planning problems 
turn argumentation proof 
definition     invertible planning problem  let  o    g   planning problem 
let denote states reachable actions o  problem called

invertible

      po     po  

result result s  p    p

o   

theorem   let  o    g   invertible planning problem  solution exists 
 o    g   contain deadlocks 

proof  let   result i   p   arbitrary reachable state  problem invert 

ible  know sequence actions p result s  p     holds 
problem solvable  solution plan p starting achieving
g result i   p    together  obtain g result result s  p    p    therefore 
concatenation p p solution plan executable consequently 
deadlock 










know invertible planning problems  solvable  contain deadlocks
consequently  contain  non trivial  forced goal orderings  see next
that  matter fact  benchmark planning problems invertible  arrive
sucient condition invertibility notion inverse actions 
   

fikoehler   hoffmann
definition     inverse action  given action set containing action
form pre o    add o  del o   action   called inverse
form pre o    add o  del o  satisfies following conditions
   pre o  pre o    add o  n del o 
   add o    del o 
   del o    add o 

certain conditions  applying inverse action leads back state one started
from 
lemma   let state action  applicable s  del o  pre o 

  add o      hold  action inverse sense definition   
applicable result s  hoi  result result s  hoi   hoi    follows 

proof  applicable s  pre o  s  atoms add o  added 

atoms del o  removed s  altogether

result s  hoi   pre o    add o   n del o  pre o 

thus  applicable result s  hoi  
furthermore  result s  hoi      add o  n del o 
result result s  hoi   hoi 
  result s   add o  n del o   hoi 
   s   add o  n del o     add o  n del o 
   s   add o  n del o     del o  n add o 
 cf  definition    
    add o  n add o 
 because del o  pre o  s 
 
 because   add o      
lemma   states two prerequisites      inclusion operator s delete list preconditions     empty intersection operator s add list state
applicable  planning problem called invertible meets prerequisites
inverse action 
theorem   given planning problem  o    g   set ground actions satisfying

del o  pre o  pre o    add o        actions reachable states s 
inverse action   action   o  problem invertible 

proof  let reachable state  let p   ho          sequence actions 

need show existence sequence p



n

result result s  p    p    
   

   

fion reasonable forced goal orderings
holds  define p    ho           o  i  prove     induction n 

n      here  p   p   hi  result result s  hi   hi    obvious 
n   n      p   ho                 i  induction hypothesis know
result result s  ho            i   ho           o  i    s  make following bit readable 
let s  denote s     result s  ho            i  
n

n

n

n

n

n

result result s  ho               i   ho              o  i 
result result s    ho    i   ho              o  i 
result result result s    ho    i   ho    i   ho           o  i 
result s    ho           o  i 

n

n

 
 
 
 

n

n

n

n

n

n

 cf  lemma   s      
 per induction 
n

altogether  know invertible problems  solvable  contain forced
orderings  know problems  inverse action action
o  invertible following theorem    theorem   requires del o  pre o  hold
action o  pre o    add o        hold actions reachable states s 
see conditions   a  inclusion delete list precondition list   b 
empty intersection action s add list reachable states applicable 
 c  existence inverse actions  hold currently used benchmark domains  
concerning condition  a  actions delete facts require preconditions  one finds phenomenon domains commonly used planning
community  least known authors  something seems
hold reasonable logical problem formulation  authors even postulate
assumption algorithms work  cf   fox   long        
similarly case conditions  b   c   one usually finds inverse actions
benchmark domains  also  action s preconditions usually imply by state invariants 
add effects false  example blocks world  stack unstack
actions invert other  action s add effects exclusive preconditions 
former contained union false constructed preconditions  see
section      similarly domains deal logistics problems  example logistics 
trains  ferry  gripper etc   one often find inverse pairs actions preconditions
always excluding add effects  sometimes  two different ground instances
operator schema yield inverse pair  example  gripper  two ground instances
move rooma  roomb 
at robby rooma 

  add at robby roomb  del at robby rooma  


   order avoid reasoning reachable states condition  b   one could postulate
action add effects negative preconditions  cf   jonsson  haslum    backstrom        
is  however  commonly used typical planning benchmark problems 

   

fikoehler   hoffmann
move roomb  rooma 
at robby roomb 

  add at robby rooma  del at robby roomb  

move  from  to  operator schema invert other  similarly  towers hanoi 
single move operator schema  inverse instance found
ground instance schema  add effects always false
preconditions true 
rarely  non invertible actions found benchmark domains 
occur  role domain often quite limited example operators cuss
ate russel s tyreworld 
cuss

  del annoyed   

ate  x wheel 

have pump  not in ated  x  intact  x 

  add ated  x  del not in ated  x  

obviously  much point defining something decuss de ate
operator  formally speaking  none ground actions operators destroys
goal precondition action domain  therefore  matter
effects cannot inverted  particular  forced goal ordering derived
wrt  actions   
importance inverse actions real world domains discussed
nayak williams         describe planner burton controlling cassini
spacecraft  contrast domains  problems example used
barrett et al         almost never contain inverse actions  consequently  domains
plenty forced goal orderings could discovered used planner avoid deadlock
situations  widespread  although perhaps unconscious use invertible problems
benchmarking current phenomenon related strips descending planning systems 
one anonymous reviewers pointed us  quite number non invertible planning
problems proposed planning literature  e g   register assignment
problem  nilsson         robot crossing road problem  sanborn   hendler        
instances manufacturing problems  regli  gupta    nau         yale shooting
problem  mcdermott   hanks         problems  i e   problems
invertible  one could in spirit argument   beginning section 
simply use approximate forced orderings one interested finding least
those  precisely  methods might detect forced orderings as
reasonable but might find more  necessarily forced  orderings 
one interested finding forced orderings  possible way go 
example  simple blocks world modification blocks cannot unstacked anymore
stacked which forces planner build stacks bottom up both
still capable finding correct goal orderings 
e

h

e

h

e

h

   cuss operator  way  one known authors deletes fact using
precondition  one know could removed domain description
without changing anything 

   

fion reasonable forced goal orderings
    extension goal orderings adl actions

orderings  introduced far  easily extended deal
ground adl actions conditional effects using negation instead delete lists 
actions following syntactic structure 
     o    pre   o    eff 
   o   eff   o 
   o    pre   o    eff 
   o   eff   o 
  
 
 o    pre  o    eff   o   eff  o 
unconditional elements action summarized    o   precondition
action denoted pre   o   unconditional positive negative effects
eff    o  eff   o   respectively  conditional effect  o  consists effect
condition  antecedent  pre  o   positive negative effects eff   o  eff  o  
additionally  denote  o  set unconditional conditional effects 
i e    o    f   o      o            o g 
computation immediately carries adl actions extension
planning graphs used  handle conditional effects  e g   ipp  koehler  nebel 
hoffmann    dimopoulos        sgp  anderson   weld         one simply takes
set exclusive facts returned systems determine set f   test
definition     decides whether ordering b two atomic goals
b   extended adl follows 
n

n

n

n









n

e



gp

e

definition     ordering adl  let  o    g fa  b g  planning problem 
e

false set a  ordering b holds

let f



e

gp

    o   o     o    b   eff  o        o     pre  o    pre  o     f     







gp



here   o  denotes negative effects implied conditions  o  


 o    




eff   o   
eff   o 





pre

j  o  prei  o  effj  o      

i  

thus  b ordered  unconditional conditional  effects add b either
imply effect deletes a  need conditions cannot made true together
a  note effect requires conditions pre  o    pre   o  satisfied 
impossible state holds non empty intersection
f
 
computation requires little adaptation effort  order obtain
set f   need investigate conditional effects well  action
conditional unconditional effect  determine atoms negated
it  matter effect used achieve a  obtain atoms intersecting
appropriate sets  o  
 
 o 
d o    





gp

h


da



 
  effi  o 

   



fikoehler   hoffmann
exactly facts always deleted achieving a  matter
effect use 
intersection sets d o  actions yields desired set f   let us
consider following small example clarify computation 
   o    fu g
  fw g f x g 
   o    fv  w g   fag f x g 
   o    fw g
  fu g f y g

da

obtain d   o    f x g   f y g   f x   y g  precondition    o 
implied first conditional effect    o      o  effect achieve a 
get d o    d   o    f x   y g 
obtain smaller set d o   add unconditional positive effect
action 
   o    fu g
  fw  ag f x g 
   o    fv  w g   fag f x g 
   o    fw g
  fu g f y g
case  need intersect sets d   o    f x g d   o    f x   y g 
yielding d o    f x g  ects fact that  achieving via unconditional
effect o  x gets removed state 
fixpoint computation requires adapt computation   first  repeat
steps case simple strips actions consider unconditional negative
effects intersection preconditions false set 

   n fo j   eff   o    f   pre  o      g

da

then  additionally remove action conditional effects either imply
deletion impossible effect condition 

   red o     fred o jo   og
here  red function red o       o 
 o       o  n f  o  j    o    pre  o    f
k

k


da

k

    g

finally  need redefine definition     expresses conditions
fact believed possibly achievable given certain set operators o 
definition     possibly achievable atoms adl  atom p possibly achievable given action set  written pa p  o  

    o     o    p   eff  o   
  p     pre  o    pre  o       o    o       o     p    eff    o   










holds  i e   positive effect p conditions preconditions
made true effects reduced action set 
   

fion reasonable forced goal orderings
process  decides whether atomic goal b heuristically ordered another
goal  i e   whether b holds  proceeds exactly way described
section      false set f reduced fixpoint computation  remains
unchanged  employs updated routines computing deciding pa f  o  
result  b ordered  b a  possibly achievable
pa b    using action set results fixpoint 
h


da

h

   use goal orderings planning

determined ordering relations hold pairs atomic goals
given goal set  question make use planning  several
proposals made literature  see section   detailed discussion 
paper  propose novel approach extracts explicit ordering subsets
goal set called goal agenda  planner  case ipp  run successively
planning subproblems represented agenda 
    goal agenda

first step one take computing goal agenda perform so called goal
  g atomic goals must examined
order find whether ordering relation b   b a  both  none holds
them  ordering relation   arbitrary definition used 
experiments  relation always either  
determined ordering relations hold atomic goals  want
split goal set smaller sets based relations  want order
smaller sets  based relations  precisely  goal sequence
goal sets g            g
 
g  g
analysis  goal analysis  pair a  b

e

h

n

n







  

g



 g   
j

   j    i  j n  want sequence goal sets respect ordering
relations derived atomic goals  make explicit  first
introduce simple representation detected atomic orderings  goal graph g 
g     v  e  

v    g

e    f a  b     g g j b g
now  desired properties  sequence goal sets possess  easily
stated 
   

fikoehler   hoffmann

goals a  b lie cycle g belong set  i e   a  b   g  
g contains path goal goal b   vice versa  ordered
b   i e     g b   g   j  




j

properties appear reasonable goal set sequence respecting
atomic orderings  introduce simple algorithmic method produce
sequence goal sets meets requirements 
first all  transitive closure g computed  done cubic
time size goal set  warshall         then  node transitive
closure  ingoing edges outgoing edges counted  disconnected nodes
      moved separate set goals g sep containing
atomic goals  participate relation  nodes a  degree
d a   
determined difference number ingoing edges
number outgoing edges  nodes identical degree merged one set 
sets ordered increasing degree yield desired sequence goal sets 
problem remaining set g sep  non empty  clear place
put it 
let us consider small example process  figure   depicts left goal
graph  results goal set g   fa  b  c  d  e g ordering relations
b  b c b d  transitive closure right 












b

b
c

c






e

e

figure    left  goal graph depicting relations atomic subgoals 
right  transitive closure graph 
figure    number in  outgoing edges goal  corresponding degrees 
resulting goal set sequence shown 
 
 

e



 
 

 

 

b 

 

 
 

  
 a 

c

  
 b 

 
 c d 

g sep
e



figure    left  number in  outgoing edges node  right 
degree nodes merged sets goals degree 
node e becomes member g sep set remains unordered 
dicult verify resulting goal sequence respects atomic goal orderings 
   

fion reasonable forced goal orderings

nodes occurring cycle graph isomorphic in  outgoing edges

transitive closure graph  particular  degree get
merged set g  
say graph  path b   vice versa  then 
transitive closure graph  edge node
b path to  additionally edge b   i e     b
follows  similarly  ingoing edge b node path
a  additionally  edge b   gives us b     altogether 
d a   
 b
 b
b   d b   thus  degree
smaller degree b required  gets ordered b  
note nothing said argumentation set unordered goals  gsep  set could  principle  inserted anywhere sequence resulting
sequence still respecting atomic orderings  possible heuristic may use goal set
first sequence  apparently problem reach goals
goals set achieved  another heuristic could put set end
neither problem reach goal set goals  decided
deal problem sophisticated way trying derive ordering relation
g sep goal sets g already derived  order
so  need extend definitions goal orderings sets goals 
























    extension goal orderings goal sets

given set atomic goals  always problem exponentially many
subsets compared order derive reasonable goal ordering
goal sets  consideration possible subsets question 
result exponential overhead  partial goal agenda obtained far
offers one possible answer  suggests taking set g sep trying order
respect goal sets emerging goal graph 
given planning problem  o  i  g   two subsets atomic goals fa            g g
fb            b g g   definition sets atomic goals straightforward 
sake simplicity  consider strips actions here  definitions
directly extended adl 
define ordering   extends sets  begin defining set f f   n g
atoms  exclusive least one atomic goal planning graph
generated  o  i  g   
f f   n g    fp j p exclusive least one graph leveled g
set   n g obtained accordingly removing actions delete
least one   i e     n g   fo   j     f           ng      del o g 
definition     ordering goal sets  let  o  i  g   planning problem
n

e

k

h

     a

e

e

gp



     a



gp

     a





     a

fa            g g fb            b g g   let   ng false set fa            g 
ordering fb            b g fa          g holds
  j   f           kg         ng   b   add o    pre o      ng      
e

     a

n

k

k

e

n

gp

n

     a

     a

j

   

gp

fikoehler   hoffmann
similar way  extended     sets f determined
based equation      set   n g simply union individual sets 
f   n g      f
f
   


h

h



da

     a

da

     a



da

da



fixpoint computation entered

   n fo   j     f           ng     del o      ng   pre o      g    
recomputation iteration fixpoint algorithm figure   done
     a



da

accordingly  apart this  algorithm remains unchanged 

definition     ordering   let  o  i  g   planning problem fa            g

fb            b g g   let set actions obtained performing
fixpoint computation shown figure    modified handle sets facts defined
equations          ordering fb            b g fa            g holds
  j   f           kg    pa b   o 

g

h

n

k

h

k

n

j

given goal sets undergo goal analysis  i e   pair sets checked
ordering relation   derived relation defines edge graph
subgoal sets nodes  transitive closure determined before  degree
node computed  graph contains disconnected nodes  total ordering
subsets goals results ordering nodes based degree  ordering
defines goal agenda  case disconnected nodes  default heuristic
adding corresponding goals last goal set agenda 
e

h

    agenda driven planning algorithm

given planning problem  o    g    let us assume goal agenda g    g            g
k entries returned analysis  entry contains subset g g  
basic idea agenda driven planning algorithm first feed planner
original initial state i     goals g     g    execute solution plan p
  yielding new initial state i    result i   p    then  new planning problem
initialized  o  i    g     solving problem  want goals g  true 
want goals g  remain true  set g     g    g    continuous
merging successive entries agenda yields sequence incrementally growing
goal sets planner  namely
 
g    g
k







j

j

  

little detail  agenda driven planning algorithm implemented ipp works
follows  first  ipp called problem  o    g    returns plan p   
achieves subgoal set g    p  sequence parallel sets actions  returned
ipp similarly graphplan  given plan  resulting state r i   p      i 
   

fion reasonable forced goal orderings
computed based operational semantics planning actions   case set
strips actions  one simply adds add effects deletes del effects
state description order obtain resulting state  following result function
definition    strips  result function coincides directly r function 
case set parallel adl actions  one needs consider possible linearizations
parallel action set deal conditional effects separately 
linearization  different resulting state obtained  satisfy
goals  obtain new initial state i    one takes intersection resulting states
possible linearization actions parallel set  means compute n 
linearizations parallel action set n actions time step  since n usually
small  more     adl actions per time step rare   practical costs
computation neglectible 
way  given solution subproblem  o    g    one calculates new initial
state    runs planner subsequent planning problem  o       g     
planning problem  o    g   solved 
plan solving original planning problem  o    g   obtained taking
sequence subplans p    p            p   one could argue planning increasing goal
sets lead highly non optimal plans  ipp still uses  no ops first  strategy
achieve goals  originally introduced graphplan system  blum   furst 
       employing strategy  graphplan algorithm  short  first tries achieve
goals simply keeping true  possible  since goals g    g            g already
satisfied initial state      starting planner tries achieve g     
strategy ensures goals destroyed re established solution
found otherwise  no ops first strategy merely graphplan feature 
reasonable planning strategy preserve goals already true initial state
whenever possible 
soundness agenda driven planning algorithm obvious g   g
sequence sound subplans yielding state transition initial state
state satisfying g  
completeness approach less obvious holds planner cannot
make wrong decisions finally reaching goals  precisely  approach
complete problems contain deadlocks introduced definition    








k



k

k







k

theorem   given solvable planning problem  o  i  g    goal agenda g    g          g

k

g g    g   g   running complete planner agenda driven manner
described yield solution problem deadlock free 




k

proof  let us assume planner find solution step agenda driven

algorithm  i e   solution found subproblem  o    g    planner assumed
complete subproblem  implies unsolvability  o    g    problem
solvable  neither problem  o    g   solvable  since g g holds  therefore 
goals cannot reached   furthermore  reachable state it reached
executing partial solution plans p            p   initial state  consequently 
must deadlock state sense definition     contradiction 


















   see  koehler et al         exact definition r  want repeat here 

   



fikoehler   hoffmann
result states feasibility approach  shown  benchmark
problems currently investigated contain inverse actions  therefore invertible
 theorem     deadlock free  theorem     thus  theorem   
approach preserves completeness domains 
however general case  completeness cannot guaranteed  following example
illustrates situation assumption s       j  p  assuming preconditions
achieving actions contained state reached  cf  derivation
ordering section    wrong yields goal ordering plan
found anymore although problem solvable 
given initial state fc  dg goals fa  b g  planner following set
ground strips actions  
a 

b

h

op  
op  
op  
op  

fc g
fdg
fe g
g

 
 
 
 

add fb g del fdg
add fe g
add g
add fag

analysis return ordering b b added op  
precondition c effect actions  thus concludes c
reachable state holds  example  c holds reachable
states  assumption s       j  c made test pa b    wrong  thus  b
reached a  hand  b holds  even forced ordering
b   testing b   ordering remains undetected 
method discover precondition f op  achievable state
b holds  obtain f   fdg  excludes op    op  op 
remain set usable actions  thus  op  considered legal achiever a  op 
considered legal achiever precondition f   could detect right ordering
regressed action chain op   op   op  found that 
f set b   actions must excluded  
consequently  goal agenda fb g  fag fed planner  solves first
subproblem using op   fails achieving state fb  c g since
inverse action op  cannot re established way 
h

a 

b

r

f

h

b
da

   empirical results

implemented methods approximate so called goal agenda manager
 gam  ipp planning system  koehler et al          gam activated
set ground actions determined either uses approximate
reasonable goal ordering  calls ipp planning algorithm entry
goal agenda outputs solution plan concatenation solution plans
found entry agenda  
r

e

h

   source code gam  based ipp      collection domains
draw subsequent examples downloaded http   www informatik uni freiburg de  
koehler ipp gam html  experiments performed sparc       

   

fion reasonable forced goal orderings
empirical evaluation performed uses ipp domain collection  contains    domains     planning problems  domains 
able derive goal ordering information    domains  domains indeed pose constraints ordering planner achieve set goals 
domains  goal orderings could derived  found either single goal
achieved  example manhattan  movie  molgen  montlake domains
goals achieved order  example logistics  gripper  ferry
domains  found benchmark domain  natural goal ordering existed 
method failed detect it  matter fact  looking goal ordering seems
natural  one usually finds ordering reasonable sense definition    see
example blocks world  woodshop  tyreworld domains  method finds almost
reasonable orderings  indicates approximation techniques
appropriate detecting ordering information 
e

h

following  first compare techniques terms runtime
number goal agenda entries generated  take closer look agendas
generated selected domains investigate uence performance
ipp planning system  exact definition domains downloaded
ipp webpage  give name domain name particular
planning problem well number  ground  actions domain contains 
parameter nicely characterizes size domain usually diculty
handle it 
e

h

examples  times shown compute goal agenda contain effort
parse instantiate operators  i e   compute set actions  times parsing
instantiation listed explicitly  are  test examples used here 
usually close zero uence performance planner significant
way 
    comparison
h

e

begin comparison summary results obtained different representational variants blocks world  bw large bw large examples originate
satplan test suite  kautz   selman        added larger examples
bw large e bw large g  parcplan example comes  el kholy   richards       
uses multiple grippers limited space table  stack n examples use
graphplan blocks world representation simply require stack n blocks other 
table initial state 
two methods return exactly ordering relations across blocks world
problems  figure   confirms  computation based planning graphs
much time consuming  hits computational border domain contains
      actions  computation much faster scales larger action
sets 
e

h

   

fikoehler   hoffmann
problem
bw large
bw large b
bw large c
bw large
bw large e
bw large f
bw large g
parcplan
stack   
stack   
stack   
stack   

 actions  agenda entries cpu    cpu   
   
 
    
    
   
 
    
    
   
 
    
    
   
  
     
    
   
  
     
    
    
 
     
    
    
 
     
    
    
 
     
    
   
  
    
    
    
  
      
    
    
  
      
    
     
  
     
e

h

figure    comparison blocks world problems   actions shows number
actions set o  planner tries construct plan   agenda
entries says many goal subsets detected ordered gam 
column     display cpu time required methods
compute agenda provided set o  dash always mean
ipp ran memory   gbyte machine 
e

h

figure   figure   show results domains  method
able detect reasonable orderings  figure   lists domains  methods
return goal agendas  tyreworld  hanoi  fridgeworld domains originate
ucpop  penberthy   weld         link repeat domain found  veloso
  blythe         performance results coincide shown figure    figure  
shows picture terms runtime performance  domains different
agendas returned  
woodshop scheduling domains contain actions conditional effects 
domains use strips operators  computation fails derive goal
orderings scheduling world problems  of display largest problem
sched   wood  problem  explanation behavior found
different treatment conditional effects methods  ipp find limited
form mutex relations conditional effects building planning graph 
goal  achieved conditional effect  often exclusive large
number facts graph  thus  f sets small sometimes even empty
consequently  actions excluded performing reachability
analysis thus  reasonable orderings may remain undetected  direct analysis investigates
conditional effects detail therefore able derive much larger f sets 
behavior method strips domains bulldozer  glassworld 
shopping world caused phenomenon  domains  one derive much
larger f sets using planning graphs turn sets exclude actions  since direct
analysis finds smaller empty f sets  finds less relations  woodshop domain
e

h

e

h

h

   

fion reasonable forced goal orderings
 actions  agenda entries cpu    cpu   
  
 
    
    
  
 
    
    
   
 
    
    
   
 
    
    
   
 
    
    
   
 
     
    
  
 
    
    
  
 
    
    
   
 
    
    
   
 
    
    
   
 
    
    
   
 
    
    
  
 
    
    
  
 
    
    

domain
tyreworld

problem
fixit 
fixit 
fixit 
fixit 
fixit 
fixit  
hanoi
hanoi 
hanoi 
hanoi 
hanoi 
hanoi 
fridgeworld fridge
link repeat link  
link  

e

h

figure    comparison benchmark domains  return
identical agendas 
e

h

domain
bulldozer
glassworld

problem
bull
glass 
glass 
glass 
shoppingworld shop
scheduling
sched 
woodshop
wood 
wood 
wood 

 actions  agenda entries cpu    cpu   
  
   
    
    
  
   
    
    
   
   
    
    
   
   
    
    
  
   
    
    
   
   
    
    
  
   
    
    
  
   
    
    
  
   
    
    
e

h

figure    domains return different goal agendas  give
form n   n    number slash says many entries contained
agenda computed   number following slash says many
entries contained agenda computed    agenda entries   means
agenda contains single entry  namely original goal set 
ordering derived 
e

h

e

h

shows results differ within domain  depending specific
planning problem  problem wood  varies problem wood  sense one
goal slightly different an object needs put different shape and two
goals present  goal orderings derived pairs old
   

fikoehler   hoffmann
goals wood   lots relations derived mixed pairs old new goals
wood   yielding detailed goal agenda  problem wood  contains additional objects
many goals  successfully ordered 
subsequent experiments  decided solely use heuristic ordering
computation less costly computation cases  yielding
comparable agendas cases  three domains investigate closely 
namely blocks world  tyreworld hanoi domains  agendas derived methods
are  fact  exactly same 
e

h

e

h

    uence goal orderings performance ipp interaction
rifo

section  analyze uence goal agenda performance ipp
combine another domain analysis method  called rifo  nebel  dimopoulos   
koehler         rifo family heuristics enables ipp exclude irrelevant actions
initial facts planning problem  effectively combined gam 
ipp plans subset goals original goal set  likely
subset relevant actions needed find plan  precisely 
obtain one subproblem entry agenda  and  subproblem 
use rifo preprocessing planning ipp  configuration  gam reduces
search space ipp decreasing number subgoals planner achieve
moment  rifo reduces search space dramatically selecting
actions relevant goal subset 
      blocks world

figure   illustrates parcplan problem  el kholy   richards        detail  seven
robot arms used order    blocks   stacks   possible positions table 

 

  

  

  

  

  

  

  

  

  

  

  

  

 

 

 

  
  

  

  

  

  

  
  

 

 

 

 

figure    parcplan problem limited space table  seven robot arms 
several stacks 
goal agenda derived ipp orders blocks horizontal layers 
  
  
  
  

on table     t     on table     t  
on table     t     on           on        
on           on           on        
on           on        
   

fion reasonable forced goal orderings
optimal plan    actions solving problem found ipp using gam    s 
spends one second computing goal agenda  almost    seconds build
planning graphs       second search plan     actions tried
find solution  without goal analysis  ipp needs approx     searches      
actions    seconds 
rifo  nebel et al         fails detecting subset relevant actions original
goal set considered  succeeds selecting relevant actions subproblems
stated agenda  reduces runtime less     spent
goal agenda  almost   spent removal irrelevant actions initial facts  less
  spent building planning graphs  previously  almost time spent
planning 
figure   shows ipp satplan blocks world examples  kautz   selman 
       bw large e example taken  dimopoulos  nebel    koehler         two
large examples bw large f  containing    blocks requiring build   stacks
goal state  bw large g    blocks   stacks 
satplan
bw large a
bw large b
bw large c
bw large d
bw large e
bw large f
bw large g

  actions plan length ipp  g  g r  g r l
   
       
         
    
    
   
                  
    
    
   
  
      
    
    
   
  
       
    
    
   
  
       
    
    
    
  
     
    
  
        
     

figure    performance extended satplan blocks world test suite  second
column shows number ground actions domain  third column
shows plan length  i e   number actions contained plan  generated
gam parentheses plan length generated ipp without gam given
ipp without gam able solve corresponding problem   g means
ipp using gam   g r means ipp uses gam rifo   g r l
means subgoals set agenda arbitrarily linearized 
runtimes cover whole planning process starting parsing operator
domain file  performing gam rifo analysis  if active  
searching graph plan found 
ipp     without gam solve bw large a bw large b problems  using
goal agenda  plans become slightly longer  performance increasing dramatically 
plan length growing blocks accidentally put positions cut
goals still ahead agenda thus  additional actions need added
plan remove blocks wrong positions  speed up possible
rifo additionally used  reduces size planning graphs dramatically 
finally  goals belong subset agenda linearized based

   

fikoehler   hoffmann
heuristic assumption analysis found reasonable goal orderings  goals
achievable order  option  problems solved almost instantly 
reader may wonder point use linearization agenda entries
extra option investigate further  two reasons that  first 
linearization negative side effects domains investigated 
example  yields much longer plans logistics domain variants 
linearizing single entry agenda logistics problem contains  packages get
transported goal position one one  course  takes much planning
steps simultaneously transporting packages coinciding destinations 
secondly  effects linearization somewhat unpredictible  even domains
usually tends yield good results  gam recognise interactions goals  consider blocks world problem four blocks a  b   c d 
say b positioned c initially  blocks table  goal
on a  b   on c  d   agenda problem comprise single entry
containing goals  fact  reasonable goal ordering here  nevertheless 
stacking onto b immedeatly bad idea  planner needs move c achieve
on c  d   aware this  gam might linearize single agenda entry
on a  b   front  makes problem harder actually is  thus  runtime
advantages linearization sometimes yields blocks world less seen
cases  good luck  
figure    shows ipp stack n problems  ipp without domain analysis
handle    blocks less   minutes     blocks    minutes
needed  using gam     blocks stacked less   minutes  using gam
rifo    minutes limit extended    blocks  stack    solved      min
     min spent analysis methods     min needed building
planning graphs extracting plan 
time

   
   

ipp

ipp g
ipp g r

   
   

  

  

figure    

ipp

  

  

  

  

  

  

  

    blocks

    simple  huge stacking problem 

figure    shows sharing overall problem solving time gam  rifo
ipp search algorithm blocks world problems  similar results obtained
tyreworld  gam takes         rifo takes         
search effort reduced approx       overall problem solving time clearly
determined rifo  search effort becomes marginal factor determination
performance  indicates speed up possible improving
   

fion reasonable forced goal orderings
performance gam rifo  indicates even hardest planning problems
become easy structured decomposed right way 
problem
stack   
stack   
stack   
stack   
parcplan

  actions
   
    
    
     
    

gam
rifo
                       
                       
                       
                        
                       

search algorithm
          
          
          
          
           

figure     distribution problem solving time blocks world examples gam 
rifo  search algorithm  comprises time build search
planning graph  remaining fraction total problem solving time 
shown table  spent parsing instantiating operators 

      tyreworld

tyreworld problem  originally formulated stuart russell  asks planner find
replace tire  easily solved ipp within milliseconds  problem
becomes much harder number tires increasing  cf  figure    
tires
 
 
 
 
 
 
 
 
 
  
figure    

  actions
ipp
 g r
 g r l
search space
  
                                      
       
  
                                                   
   
                         
     
   
            
     
   
            
     
   
            
      
   
            
      
   
             
      
   
               
       
   
               
      
tyreworld  numbers parentheses show time steps  followed
number actions generated plan  last column compares
search spaces  number slash shows  number actions tried 
parameter plain ipp planning algorithm  number following
slash shows  number actions tried  ipp using gam  rifo 
linearization entries agenda  dash means  number
actions tried  unknown ipp failed solving corresponding
planning problem 

ipp

   

fikoehler   hoffmann
ipp able solve problem     tires  using gam rifo   
tires handled  solution length gam slightly increasing  caused
super uous jack up jack down actions  short  explained follows 
wheel needs mounted hub  expressed on  r   h  goal  mount
wheel  hub must jacked up  mounting  nuts done up  then  hub
needs jacked again  order tighten nuts achieving tight  n   h  goal 
now  gam puts goals one entry preceeding tight goals  thus  solving
entry containing goals  hub jacked up  wheel put on  hub
immediatly jacked order replace next wheel  afterwards  solving
tight goals  hub must jacked up and down one time
nuts  solving problem manner  planner inserts one super uous jack up 
one super uous jack down action wheel  precisely  super uous actions
inserted one wheel  namely wheel last mounted solving
goals  mounting wheel  goals achieved  planner proceeds
next agenda entry wheel still jacked up  then  trying achieve
tight goals  ipp recognizes shortest plan  in terms number parallel steps 
results nuts first done hub already jacked up  thus  hub
jacked one time  achieving corresponding goal  jacked one
time  achieving tight goal 
case   tires  following goal subsets identified ordered 

  
  
  
  
  
  
  

ated r    ated r    ated r  
on r   hub    on r   hub    on r   hub  
tight n   hub    tight n   hub    tight n   hub  
in w   boot   in pump  boot   in w   boot   in w   boot 
in jack  boot 
in wrench  boot 
closed boot 

hardest subproblem agenda achieve on r   hub   goals entry   
i e   mount ated spare wheels various hubs  trying generate maximum parallelized plan impossible ipp   tires  since goals completely
independent other  linearization perfectly work  resulting
plans become slightly longer due way tight goals achieved using
 l option  noticed earlier one wheel  the one last mounted
solving goals  super uous jack up jack down actions need inserted
plan  linearizing agenda entries  super uous jack up jack down actions must
likely inserted wheels  yielding plans two steps longer  reason
tight goal might first linearization  likely 
tight goal corresponding hub still jacked up  planner needs
insert one super uous jack down action here  later  must jack hub again  yielding
another super uous action  using  g r l case    tires       actions need
tried plan     actions found  takes      s  gam requires      s 
rifo requires       s       consumed generate planning graphs      
spent compute initial states subproblems  remaining      consumed
parsing instantiating 


   



fion reasonable forced goal orderings
      tower hanoi

surprising result obtained tower hanoi domain  domain  stack discs
moved one peg third peg auxiliary second peg them 
never larger disc put onto smaller disc  case three discs d   d   d 
increasing size  goals stated on d  peg    on d  d    on d  d    gam returns
following agenda  correctly ects ordering largest disc needs
put goal position first 
   on d  peg  
   on d  d  
   on d  d  

goal agenda leads partition subproblems corresponds recursive
formulation problem solving algorithm  i e   solve problem n discs 
planner first solve problem n   discs  etc  first entry  plan  
actions  time steps     below  generated  achieves goal on d  peg    
plan   actions  time steps      achieves goals on d  peg   on d  d  
on d  peg   holding already initial state  finally  one step plan  time step   
generated moves third disc two discs already goal
position 
time
time
time
time

step
step
step
step

  
  
  
  

move d  d  peg  
move d  d  peg  
move d  peg  d  
move d  peg  peg  

time step    move d  d  peg  
time step    move d  peg  d  
time step    move d  peg  d  

surprisingly  ipp able benefit information  runtime ipp using
gam exploding dramatically increasing numbers discs  see figure    
discs  actions ipp ipp  g
ucpop
ucpop subproblems
 
       
              
                    
 
       
                                                 
 
       
    
 
        
    
 
        
     
 
                 
figure     runtimes ipp without goal agenda hanoi problems compared ucpop without agenda ucpop agenda subproblems using
zlifo ibf control strategy 
   move action takes first argument disc moved  second disc moved 
third argument disc peg moved 

   

fikoehler   hoffmann
able provide explanation phenomenon  division
subproblems causes much larger search space planner although solution
plans result  rifo cannot improve situation selects actions relevant 
tower hanoi domain one found ipp s performance deteriorated gam  currently see way one tell advance whether ipp
gain advantage using gam not  overhead caused goal analysis
small   inadequate  split goals subgoal sets lead
search  see section   
however case  phenomenon seems specific ipp  simulated
information provided gam ucpop obtained quite different picture 
fifth column figure    shows runtime ucpop using zlifo  pollack  joslin 
  paolucci        ibf control strategy number explored partial plans
parentheses  ucpop solve problem     discs  last column
figure  show runtime number explored partial plans  result
ucpop run subproblems result agenda  exactly
subproblems ipp solve  performance ucpop improves
significantly  instead taking   exploring      partial plans  ucpop takes
                    explores            plans  unfortunately  problems
subproblems   discs remain beyond performance ucpop 
performance improvement independent search strategies used ucpop 
example  ibf control used without zlifo  number explored partial plans
reduced            case problem   discs  runtime improves
   seconds   seconds  similarly  using bf control without zlifo
number explored partial plans reduces          
knoblock        reports improvement performance prodigy planner
 fink   veloso        using abstraction hierarchy generated domain
alpine module  provides essence information goal agenda  
   summary comparison related work

many related approaches developed provide planner ability
decompose planning problem giving kind goal ordering information  subsequently  discuss important review work light
approaches 
method introduces preprocessing approach  derives total ordering
subsets goals performing static  heuristic analysis planning problem hand 
approach works domains described strips adl operators based
polynomial time algorithms  purpose method provide planner
search control  i e   opt deriving goal achievement order successively call
planner totally ordered subsets goals 
method preserves soundness planning system  completeness
case planning domain contain deadlocks  argue
   however  find goal ordering information  alpine requires represent tower hanoi domain
involving several operators  cf   knoblock        

   

fion reasonable forced goal orderings
benchmark domains quite often possess property  supported
authors  williams   nayak        
computation requires polynomial time  methods
incomplete sense detect reasonable goal orderings general
case  complexity deciding existence forced reasonable goal orderings
proven pspace hard section   therefore  trading completeness
eciency seems acceptable solution  complexity results relate found
bylander        proves pspace completeness serial decomposability  korf 
       given set subgoals  serial decomposability means previously satisfied subgoals need violated later solution path  i e   subgoal
achieved  remains valid goal reached  purpose method derive
constraints make orderings explicit serial decomposability set
goals found  i e   consider complementary problem  ected
complexity proofs 
many cases  found goal agenda manager significantly improve
performance ipp planning system  found least one domain  namely
tower hanoi  dramatic decrease performance observed although ipp
still generates optimal plan processing ordered goals agenda 
far  complexity results backstrom jonsson        predicted planning
abstraction hierarchies exponentially less ecient  exponentially longer
plans generated 
idea analyze effects preconditions operators derive ordering
constraints based interaction operators found variety approaches 
analyze harmful interactions operators method studying delete
effects  approaches described  dawsson   siklossy        korf        knoblock 
      concentrate positive interactions operators  successful matching
effects preconditions forms basis learn macro operators  see  dawsson   siklossy 
      korf        
alpine system  knoblock        learns abstraction hierarchies prodigy
planner  fink   veloso         approach based ordering preconditions
effects operator  i e   effects operator must abstraction
hierarchy preconditions must placed lower level effects 
introduces ordering possible subgoals domain  orthogonal
ordering compute  alpine  subgoal ordered subgoal b
enables b   i e   must possibly achieved first order achieve b   method
orders b cannot achieved without necessarily destroying b   result
alpine gam set binary constraints  case alpine  constraints
computed atoms domain  gam restricts analysis
goals only  approaches represent binary constraints graph structure  alpine
merges atomic goals together belong strongly connected component graph 
gam merges sets goals together identical degree  compute
topological sorting sets consistent constraints  resulting goal
orderings quite similar examples knoblock        demonstrate  gam
approximates reasonable goal orderings domains alpine fails finding abstraction
hierarchies  two examples  knoblock        tower hanoi domain using
h

e

   

fikoehler   hoffmann
one move operator blocks world  domains  alpine cannot detect
orderings investigates operator schemata  set ground actions 
therefore cannot distinguish orderings different instantiations
literal  although alpine could modified handle ground actions  significantly
increase amount computation requires  gam hand  handles large sets
ground actions ecient way  particular direct analysis used   
analysis  quite similar alpine  performed framework
htn planning  described tsuneto et al          approach analyzes external
conditions methods  cannot achieved decomposing method further 
means  conditions established decomposition methods 
precede method using external condition  two strategies determine
decomposition order methods defined empirically compared  lies main
difference approaches described far  instead trying automatically
construct decomposition orderings  predefined fixed domains
problems 
harmful interactions among operators studied smith peot        etzioni
        threat operator precondition p occurs instantiation
effects inconsistent p  smith   peot         knowledge
threats used control plan space planner  contrast state space planner
ipp  computing explicit ordering goals prevent presence threats
partial plan order goals processed determine order
actions occur plan  notion forced reasonable goal orderings
comparable threat threat still potential resolved
adding binding ordering constraints plans  contrast this  forced
reasonable goal ordering persists bindings enforces specific ordering
subgoals 
given planning problem  static  etzioni        computes backchaining tree
goals form and or graph  subsequently analyzes occurrence
goal interactions necessarily occur  analysis much complicated
ours  static deal uninstantiated operators axioms 
describe properties legal states  result analysis goal ordering rules 
order goals certain conditions satisfied state  main difference gam 
generates explicit goal orderings independently specific state  need
extract conditions specific state satisfy considers generic state
s      analysis  represents states satisfying a  b   gam  static
incomplete sense cannot detect existing goal interactions  problem
gam deciding reasonable orderings pspace hard  proven
paper  problem static compute necessary effects operator
given state  etzioni        conjectures nebel backstrom        prove 
a 

b

    abstraction hierarchies general goal orderings compute  cannot serve
purpose providing planner goal ordering information  allow generate plans
different levels refinement  see  bacchus   yang         two approaches generating
abstraction hierarchies based numerical criticality values found  sacerdoti        bundy 
giunchiglia  sebastiani    walsh        

   

fion reasonable forced goal orderings
problem computationally intractable therefore  polynomial time analysis method
must incomplete 
last  least quite number approaches late eighties 
focused directly subgoal orderings  fall two categories  approaches
described  drummond   currie        hertzberg   horz        focus detection
con icts caused goal interdependencies guide partial order planner search 
investigate approaches detail extract explicit
goal orderings preprocess planning do  works described  irani   cheng 
      cheng   irani        joslin   roach        implement preprocessing approaches 
perform structural analysis planning task determine appropriate goal
ordering planning starts  irani cheng        compute relation
pairs goals  which roughly speaking orders goal goal b b must
achieved achieved  formalism rather complicated theoretical
properties relation investigated   cheng   irani         approach
extended sets goals ordered respect other  exact
properties formalism remain unclear   joslin   roach         graph theoretical
approach described generates graph atoms given domain description
nodes draws arc node node b operator exists takes
precondition b effect  assuming operators inverse
counterparts  identifying connected components graph proposed means
order goals  approach unlikely scale size problem spaces today s planners
consider completely outdated terms terminology 
finally  one wonder reasonable forced goal orderings relate others
defined literature  one attempt know ordering
relation explicitly defined properties studied  see  hullem et al         
paper  notion necessary goal orderings introduced  must true
minimal solution plans  kambhampati           approach extends operator graphs
 smith   peot        orders goal based three criteria called goal subsumption  goal
clobbering  precondition violation  goal subsumption   b holds every solution plan
achieving goal b state achieves goal state s  preceding s  plan
achieving one goals g n fag deletes a  goal clobbering holds solution plan
deletes b thus    b   precondition violation holds solution b results
deadlock cannot reached anymore  i e     b   composite
criterion defined tests three criteria simultaneously    goal necessarily
ordered b satisfies composite criterion 
remark precondition violation seems equivalent forced orderings
introduced  goal clobbering appears similar reasonable orderings 
possible us verify conjecture authors  hullem et al         give
exact formal definitions  nothing similar goal subsumption argue
criterion rarely satisfied natural problems  goal achieved every
    plan minimal contains subplan solution plan  remark minimality
mean shortest plans least number actions considered  fact  minimal
plans highly non optimal long action truly super uous 
    here  authors precise mean this  argue means
two goals ordered satisfy least one criteria 

   

fikoehler   hoffmann
solution goal b anyway  goal removed goal set without
changing planning task 
authors report able detect necessary orderings artificial
domains   cf   barrett   weld         fail typical benchmark domains
blocks world tyreworld  reason seems operator graphs
represent possible instantiations operator schemes  authors claim 
makes operator graph analysis ecient  however  heuristic ordering
introduced paper takes almost computation time  succeeds finding
goal orderings domains 




h

   outlook

three promising avenues future research following 
first  one imagine goal ordering information used search
process  i e   ordering original goal set  goals emerge
search  major challenge seems balance effort computing goal
ordering information savings result search process  one
easily imagine ordering goal sets ever generated become quite costly
investment without yielding major benefit planner 
secondly  refinement goal agenda additional subgoals another interesting future line work  first investigation using so called intermediate goals  these
facts planner must make true achieve original goal 
explored inside gam results reported  koehler   hoffmann         earlier
work addressing task learning intermediate goals found  ruby   kibler 
       problem focus ai planning research since then 
third line work addresses interaction gam forward searching planning system  seen gam preserves correctness planner 
preserves completeness least deadlock free planning domains 
seen  however  solution plans using gam get longer  i e   gam preserve optimality planner  recently  planning systems deliver plans
guaranteed optimality demonstrated impressive performance terms runtime
plan length  e g   hsp  first mentioned  bonet  loerincs    geffner        
grt  refanidis   vlahavas         particular  hoffmann         systems
heuristic search planners searching forward state space non admissible 
informative heuristics 
planning system developed one authors awarded  group
distinguished performance planning system  schindler award
best performing planning system miconic    elevator domain  adl track 
aips      planning competition  integration goal agenda techniques
planner one factors enabled excellent behavior competition 
crucial scaling blocks world problems    blocks  helped factor  
schedule miconic     never slowed algorithm 
forward state space search quite natural framework driven goal agenda 
simply let planner solve subproblem  start next search state
last search ended  even appealing  heuristic forward search planners deeper
   

fion reasonable forced goal orderings
kind interaction gam example graphplan style planners  addition
smaller problems facing using goal agenda  heuristics
uenced employ techniques estimating goal distance state 
using goal agenda  different goal sets result stage planning process
therefore  goal distance estimate different  too  currently heuristic device
inside search algorithm developed  knows driven
goal agenda  access complete set goals  information
used prune unpromising branches search space discovers
currently achieved goals probably destroyed reachieved later on 
references

allen  j   ed    aips            proceedings  th international conference artificial intelligence planning systems  aaai press  menlo park 
anderson  c     weld  d          conditional effects graphplan  allen  allen        
pp        
bacchus  f     yang  q          downward refinement eciency hierarchical
problem solving  artificial intelligence             
backstrom  c     jonsson  p          planning abstraction hierarchies exponentially less ecient  mellish  mellish         pp            
barrett  a     weld  d          partial order planning  evaluating possible eciency gains 
artificial intelligence             
blum  a     furst  m          fast planning planning graph analysis  artificial
intelligence                    
bonet  b   loerincs  g     geffner  h          robust fast action selection mechanism planning  proceedings   th national conference american
association artificial intelligence  pp          
bundy  a   giunchiglia  f   sebastiani  r     walsh  t          computing abstraction
hierarchies numerical simulation  weld    clancey  weld   clancey         pp 
        
bylander  t          complexity results serial decomposability  proceedings
  th national conference american association artificial intelligence  pp 
        san jose  ca  mit press 
bylander  t          computational complexity propositional strips planning 
artificial intelligence              
chapman  d          planning conjunctive goals  artificial intelligence                  
cheng  j     irani  k          ordering problem subgoals  sridharan  sridharan        
pp          
   

fikoehler   hoffmann
dawsson  c     siklossy  l          role preprocessing problem solving systems 
proceedings  th international joint conference artificial intelligence  pp 
        cambridge  ma 
dimopoulos  y   nebel  b     koehler  j          encoding planning problems nonmonotonic logic programs  steel  steel         pp          
drummond  m     currie  k          goal ordering partially ordered plans  sridharan
 sridharan         pp          
el kholy  a     richards  b          temporal resource reasoning planning 
parcplan approch  wahlster  w   ed    proceedings   th european conference artificial intelligence  pp           john wiley   sons  chichester  new
york 
etzioni  o          acquiring search control knowledge via static analysis  artificial intelligence              
fink  e     veloso  m          prodigy planning algorithm  technical report cmu        
carnegie mellon university 
fox  m     long  d          automatic inference state invariants tim  journal
artificial intelligence research             
fox  m     long  d          ecient implementation plan graph stan  journal
artificial intelligence research             
hertzberg  j     horz  a          towards theory con ict detection resolution
nonlinear plans  sridharan  sridharan         pp          
hoffmann  j          heuristic domain independent planning use enforced
hill climbing algorithm    th international symposium methods intelligent
systems 
hullem  j   munoz avila  h     weberskirch  f          extracting goal orderings
improve partial order graphplan based planning  technical report  university
kaiserslautern 
irani  k     cheng  j          subgoal ordering goal augmentation heuristic problem solving  mcdermott  d   ed    proceedings   th international joint
conference artificial intelligence  pp            milan  italy  morgan kaufmann 
jonsson  p   haslum  p     backstrom  c          towards ecient universal planning 
randomized approach  artificial intelligence                
joslin  d     roach  j          theoretical analysis conjunctive goal problems  artificial
intelligence             
kambhampati  s          admissible pruning strategies based plan minimality planspace planning  mellish  mellish         pp            
   

fion reasonable forced goal orderings
kautz  h     selman  b          pushing envelope  planning  propositional logic 
stochastic search  weld    clancey  weld   clancey         pp            
knoblock  c          automatically generating abstractions problem solving  ph d 
thesis  carnegie mellon university 
knoblock  c          automatically generating abstractions planning  artificial intelligence                  
koehler  j          handling conditional effects negative goals ipp  technical report      university freiburg  institute computer science  available
http   www informatik uni freiburg de   koehler ipp html 
koehler  j     hoffmann  j          planning goal agendas  technical report
     university freiburg  available http   www informatik uni freiburg de  
koehler ipp html 
koehler  j   nebel  b   hoffmann  j     dimopoulos  y          extending planning graphs
adl subset  steel  steel         pp          
korf  r          macro operators  weak method learning  artificial intelligence     
      
korf  r          planning search  quantitative approach  artificial intelligence     
      
mcdermott  d     hanks  s          nonmonotonic logic temporal projection  artificial
intelligence              
mellish  c   ed    ijcai            proceedings   th international joint conference
artificial intelligence  morgan kaufmann  san francisco  ca 
nebel  b     backstrom  c          computational complexity temporal projection  planning  plan validation  journal artificial intelligence                  
nebel  b   dimopoulos  y     koehler  j          ignoring irrelevant facts operators
plan generation  steel  steel         pp          
nilsson  n          principles artificial intelligence  tioga publishing company  palo
alto 
pednault  e          adl  exploring middle ground strips situation
calculus  brachman  r   levesque  h     reiter  r   eds    proceedings  st
international conference principles knowledge representation reasoning 
pp          toronto  canada  morgan kaufmann 
penberthy  j     weld  d          ucpop  sound  complete  partial order planner
adl  nebel  b   swartout  w     rich  c   eds    proceedings  rd
international conference principles knowledge representation reasoning 
pp           morgan kaufmann  san mateo 
   

fikoehler   hoffmann
pollack  m   joslin  d     paolucci  m          selection strategies partial order planning 
journal artificial intelligence research             
refanidis  i     vlahavas  i          grt  domain independent heuristic strips
worlds based greedy regression tables  proceedings  th european conference planning  pp          
regli  w   gupta  s     nau  d          ai planning versus manufactoring operation
planning  case study  mellish  mellish         pp            
ruby  d     kibler  d          learning subgoal sequences planning  sridharan
 sridharan         pp          
russel  s     norvig  p          artificial intelligence   modern approach  prentice hall 
sacerdoti  e          planning hierarchy abstraction spaces  artificial intelligence 
           
sanborn  j     hendler  j          near term event projection dynamic simulation
robot cross road  proceedings  nd conference ai
simulation 
smith  d     peot  m          postponing threats partial order planning  proceedings
  th national conference american association artificial intelligence 
pp           aaai press  mit press 
sridharan  n   ed    ijcai            proceedings   th international joint conference artificial intelligence  detroit  mi  morgan kaufmann 
steel  s   ed    ecp            proceedings  th european conference planning 
vol       lnai  springer 
tsuneto  r   hendler  j     nau  d  s          analyzing external conditions improve
eciency htn planning  allen  allen         pp          
veloso  m     blythe  j          linkability  examining causal link commitments partialorder planning  hammond  k   ed    proceedings  nd international conference artificial intelligence planning systems  pp           aaai press  menlo
park 
warshall  j          theorem boolean matrices  journal acm               
weld  d     clancey  b   eds     aaai            proceedings   th national conference american association artificial intelligence  aaai press 
williams  b     nayak  r          reactive planner model based executive 
proceedings   th international joint conference artificial intelligence  pp 
           morgan kaufmann  san francisco  ca 

   


