journal artificial intelligence research                  

submitted       published     

compilability expressive power
propositional planning formalisms
bernhard nebel

nebel   informatik   uni   freiburg   de

institut fur informatik  albert ludwigs universitat  georges kohler allee  d       freiburg  germany

abstract
recent approaches extending graphplan algorithm handle expressive
planning formalisms raise question formal meaning expressive power is 
formalize intuition expressive power measure concisely planning domains
plans expressed particular formalism introducing notion compilation
schemes planning formalisms  using notion  analyze expressiveness
large family propositional planning formalisms  ranging basic strips formalism
conditional effects  partial state specifications  propositional formulae preconditions 
one results conditional effects cannot compiled away plan size grow
linearly compiled away allow polynomial growth resulting plans 
result confirms recently proposed extensions graphplan algorithm concerning
conditional effects optimal respect compilability framework  another result
general propositional formulae cannot compiled conditional effects plan size
preserved linearly  implies allowing general propositional formulae preconditions
effect conditions adds another level difficulty generating plan 

   introduction
g raphplan  blum   furst        satplan  kautz   selman        among
efficient planning systems nowadays  however  generally felt planning formalism
supported systems  namely  propositional basic strips  fikes   nilsson        
expressive enough  reason  much research effort  anderson  smith    weld        gazen
  knoblock        kambhampati  parker    lambrecht        koehler  nebel  hoffmann    dimopoulos        devoted extending graphplan order handle powerful
planning formalisms adl  pednault        
appears consensus much expressive power added particular language feature  example  everybody seems agree adding negative preconditions
add much expressive power basic strips  whereas conditional effects considered
significant increase expressive power  anderson et al         gazen   knoblock       
kambhampati et al         koehler et al          however  unclear measure expressive power formal way  related problem question whether compilation
approaches extend expressiveness planning formalism optimal  example  gazen
knoblock        propose particular method compiling operators conditional effects
basic strips operators  method  however  results exponentially larger operator sets 
people  anderson et al         kambhampati et al         koehler et al         agree
cannot better that  nobody proven yet space efficient method
impossible 
c      ai access foundation morgan kaufmann publishers  rights reserved 

fin ebel

order address problem measuring relative expressive power planning formalisms  start intuition formalism least expressive another formalism planning domains corresponding plans formalism concisely expressed
formalism   this  least  seems underlying intuition expressive power
discussed planning literature 
backstrom        proposed measure expressiveness planning formalisms using
esp reductions  reductions are  roughly speaking  polynomial many one reductions
planning instances change plan length  using notion  showed
propositional variants basic strips containing conditional effects arbitrary logical
formulae considered expressively equivalent  however  taking point view  espreductions restrictive two reasons  firstly  plans must identical size  might
want allow moderate growth  secondly  requiring transformation computed
polynomial time overly restrictive  ask concisely something expressed 
necessarily imply exists polynomial time transformation  fact  one
formalism might expressive another one  mapping formalisms might
computable all  this  least  seems usual assumption made term
expressive power discussed  baader        cadoli  donini  liberatore    schaerf        erol 
hendler    nau        gogic  kautz  papadimitriou    selman        
inspired recent approaches measure expressiveness knowledge representation formalisms  cadoli et al         gogic et al          propose address questions
expressive planning formalism using notion compiling one planning formalism
another one  compilation scheme one planning formalism another differs polynomial many one reduction required compilation carried polynomial
time  however  result expressible polynomial space  furthermore  required
operators planning instance translated without considering initial state
goal  restriction might sound unnecessarily restrictive  turns existing
practical approaches compilation  gazen   knoblock        well theoretical approaches
 backstrom        consider structured transformations operators transformed
independently initial state goal description  technical point view
restriction guarantees compilations non trivial  entire instance could transformed 
compilation scheme could decide existence plan source instance generate
small solution preserving instance target formalism  would lead unintuitive
conclusion planning formalisms expressive power 
mentioned beginning  space taken domain structure important 
space used plans  reason  distinguish compilation schemes
whether preserve plan size exactly  linearly  polynomially 
using notion compilability  analyze wide range propositional planning formalisms  ranging basic strips planning formalism containing conditional effects  arbitrary boolean formulae  partial state specifications  one results  identify two
equivalence classes planning formalisms respect polynomial time compilability preserving plan size exactly  means adding language feature formalism without leaving
class increase expressive power affect principal efficiency
   assume reader basic knowledge complexity theory  garey   johnson        papadimitriou 
       familiar notion polynomial many one reductions complexity classes p  np  conp 
pspace  notions introduced paper needed 

   

fic ompilability



e xpressive p ower p lanning f ormalisms

planning method  however  provide results separate planning formalisms using
results computational complexity theory circuit complexity non uniform complexity
classes  separation results indicate adding particular language feature adds expressive power difficulty integrating feature existing planning algorithm 
example  prove conditional effects cannot compiled away boolean formulae
cannot compiled conditional effectsprovided plans target formalism allowed
grow linearly 
answers question posed beginning  compilation approach proposed gazen
knoblock        cannot space efficient  even allow linear growth plans
target formalism  allowing polynomial growth plans  however  compilation
scheme space efficient  interestingly  seems case compilation scheme
allows polynomially larger plans similar implementation conditional effects
ipp system  koehler et al          kambhampati colleagues         planning system 
anderson colleagues         planning system 
rest paper structured follows  section    introduce range propositional planning formalisms analyzed paper together general terminology definitions 
based that  introduce notion compilability planning formalisms section   
section   present polynomial time compilation schemes different formalisms
preserve plan size exactly  demonstrating formalisms identical expressiveness 
remaining cases  prove section   cannot compilation scheme
preserving plan size linearly  even bounds computational resources
compilation process  section   reconsider question identical expressiveness using compilation schemes allow polynomial growth plans  finally  section  
summarize discuss results 

   propositional planning formalisms
first  define general propositional planning formalism  appears almost
expressive propositional variant adl  pednault         formalism allows arbitrary
boolean formulae preconditions  conditional effects partial state specifications  subsequently 
specialize formalism imposing different syntactic restrictions 
    general propositional planning formalism
let countably infinite set propositional atoms propositional variables  finite
subsets denoted   further  defined set consisting constants
 denoting truth   denoting falsity  well atoms negated atoms  i e   literals 
  language propositional logic logical connectives
fiff  
propositional atoms denoted   clause disjunction literals  further  say
formula conjunctive normal form  cnf  conjunction clauses 
disjunctive normal form  dnf  disjunction conjunctions literals 
given set literals   refer positive literals          refer
negative literals       atoms used   i e      fi                  
   note gazen knoblock s        translation scheme generates planning operators depend
initial state goal description  however  operators simply code initial state goal description
nothing else  reason  ignore here 

   

fin ebel

  

  further  define   element wise negation   i e  

                              ba
state c truth assignment atoms   following  identify state
set atoms true state  state specification subset   i e   logical
theory consisting literals only  called consistent iff contain complementary literals
  general  state specification describes many states  namely satisfy  
denoted ef gh d    case complete  i e       either    d
  ijd   precisely one model  namely k  d    abusing notation  refer
inconsistent state specification   illegal state specification 
operators pairs lm on pre post p   use notation pre lb post lq refer first
second part operator l   respectively  precondition pre element rkskt   i e  
set propositional formulae  set post  set postconditions  consists
conditional effects  form

uwv xff
uzy



called effectv conditions elements
called
elements
u
effects  singleton sets  e g      h 
        often omit curly brackets write
  v   
example   order illustrate various notions  use running example planning
problems connected production camera ready manuscripts latex source files
somewhat simplified  course  set atoms   choose following set 

      bacffed fgcffihqj klffgm no ffgp qgffgrsklrsffgr rsmlffgrsm o fftklu hvfftk hqcfftkwm
hqj k klu h nxqffihbjsk y k  za nx ba
propositional atoms following intended meaning  atoms first line represent
presence corresponding files  atoms second line signify index
citations correct dvi file  based that  define following operators  rbkwr  bac   d  zac  
  d xea kwu h ac   first operators simple  precondition execution
rbklr   d fgc  file exist  successful execution  r rsm   r m  file
produced 

rbklr  zacm    d fgcffgrbkwr ff v v  brsrsmlffgrsm ov  va



  d xea kwu hsac

operator similar 

  d xea kwu h acm    k hc  ff v v  qkwu h fftklm ov  va
finally  d  zac operator bit complicated  precondition needs presence
 bac  file produces effect d fgc    k hc    hbjsk    files unconditionally  addition 
know citations correct rsr m  file present index correct
   

fic ompilability

klu h

 file present 



e xpressive p ower p lanning f ormalisms

d  bac    zac  ff
v
v
rsr m
fir rsv
klu h

  d f cfftk hqcffihbjsklffgm no  bff
v hbjs k hqy j k  bk y k n zaxff nxqff
hbjsk klu h nxqff
v
kwu h  hqj k kwu h nx  

semantics operators given state transition functions  i e   mappings states
states  given state c set postconditions post  cbff post denotes active effects c  

mcsff post      uwv  

post ffec   

u  ba

state transition function   induced operator l defined follows 

  
 c  

r   r
c fi      csff post lb    mcsff post lb   c    pre lb

cbff post lq   

undefined

otherwise

words  precondition operator satisfied state c active effects consistent 
state c mapped state c  differs c truth values active effects
forced become true positive effects forced become false negative effects 
precondition satisfied set active effects inconsistent  result function
undefined 
planning formalism itself  work states state specifications  general 
lead semantic problems  restricting state specifications sets
literals  however  syntactic manipulations state specifications defined way
sound lifschitz         sense 
similarly active effects respect states  define corresponding function
respect state specifications 

 dff post     i  uwv fifi

post ffd    

u  ba

further  define potentially active effects follows 

 dff post    cbff posta
e  


 dff post  
state specification operator l  n pre post p    dff post  
means state specification resulting application state transition functions
might representable theory consisting literals only  reason  consider
operator application illegal  resulting illegal state specification   could
liberal point consider operator application state specification illegal
set states resulting applying state transition functions could definitely represented
   note happen state specification incomplete 

   

fin ebel

theory consisting literals only  alternatively  could consider atoms mentioned
 dff post  m d ff post unsafe application operator delete literals
   d ff post  dff post   state specification  consider resulting state specification
still legal  dff post consistent  since seem exist standard model
execution conditional effects presence partial state specifications  adopt first
alternative one arbitrary choice  noted  however  decision influences
results present below 
 dff post leads illegal state specification 
similarly rule  dff post  
require precondition satisfied states ef gh d  state specification
already inconsistent  result applying l results   leads definition
function   defines outcome applying operator l set operators
state specification 

r   r
d   dff post lq   m d ff post lb  d  

    pre lb
j

 d ff post lb   

 dand
 d ffilq 


 

 




b
l
 



 
post lb 
post





otherwise

example   using propositional atoms operators example    assume following
two state specifications
    zackfftklu hk        backfftklu h ffgrsr mffgrsm ov    try apply
operator d  bac   notice results



post zm d  bacb     d fgcfftk hcffihqj klffgm no ffihqj k klu h nx bff
post zm d  bacb   post zm d  bacb h    hbjsk y k  za nxqff hqj k y k  ba nx bff



post zm d  bacb a hand  apply rbkwr  bac
i e   post zm d  bacb  

successfully   ffgrbkwr  bacb  



easily verified syntactic operation state specification using function
corresponds state transitions states described specification 
proposition   let state specification  l operator    induced state transition
function   d ffilq    

ef gh  dffilb     c  gc   c ffec   dfi ba
 dffilb       either
  

ef gh d  

 

   two states c
  

mc post lb   
ffec  e g d  mc post lb  
exists state cwe gh d   c  undefined 
   

fic ompilability

e xpressive p ower p lanning f ormalisms



words  whenever  dffilb results legal specification  specification describes
states result application state transition function   states satisfy
original state specification   further   d ffilq illegal  good reasons it 

planning instance tuple

  n ffifft pff






  n fftp domain structure consisting finite set propositional atoms
finite set operators  


initial state specification 
goal specification 



talk size instance  symbolically         following  mean size
 reasonable  encoding instance 
following  use notation refer set finite sequences operators 
elements called plans         denotes size plan  i e   number
operators   say  step plan           result applying state
specification recursively defined follows 

 b
 
r r
  t dff n p  
  t  dff nl iff l ffgagaga ffil kp        dffil ff nl ffgagaga ffil kp 


sequence operators said plan solution iff
   x  ffe  
   x  ffe      
example   let propositional
atoms operators introduced example  
consider following planning instance 
 n n fftpfft   backffgrbklr ffklu hk bfft  hbjskffihqjsk y k  za nx  pa
words  given latex source file   bac   bibliography database   rbklr    want generate dvi
file  hbjsk   citations file correct  hbjsk y k  ba nx    furthermore  know
know index file yet
anything existence bbl file aux file etc  
  kwu h    plan   nzrsklr  bacffgm d  zacsp solution plan result illegal
state specification resulting state specification entails hqj k hbjsk y k  ba nx  
plans satisfying         sound  order state precisely  extend
notion state transition functions operators state transition functions plans  let  
state transition function corresponding composition primitive state transition functions
induced operators   nl ffgagaga ffil p   i e  



b e  b     eagagaqfi bvff
   could liberal requiring   done order allow fair
comparison restricted planning formalisms 

   

fin ebel


e  c  defined iff e  b c defined every       using
notion  one easily proveusing induction plan lengththat plan instance
sound lifschitz         sense  i e   corresponds application state transition functions
initial states 


proposition   let  n ffifft p planning instance
  x  ffe consistent 

 nl gff agaga ffil p

element

e gh x ffe     c  tc   c ffec     ba
   ffe inconsistent  either
  

ef gh   

 

   exists  possibly empty  prefix
x  ff nl ffgagaga ffil p  either



 a  two states c


nl gff agaga ffil  p  
    

eff c wef gh d 

mc

 b  exists state cwe gh d  bw

c 



d 

c post l     
post l     
undefined 

    family propositional planning formalisms
propositional variant standard strips  fikes   nilsson         call
follows  planning formalism requires complete state specifications  unconditional
effects  propositional atoms formulae precondition lists  less restrictive planning
formalisms following additional features 
incomplete state specifications      state specifications may complete 
conditional effects      effects conditional 
literals formulae      formulae preconditions effect conditions literals 
boolean formulae      formulae preconditions effect conditions arbitrary
boolean formulae 
extensions combined  use combinations letters refer multiple
extensions  instance  refers formalism extended literals precondition lists 

 s refers formalism allowing incomplete state specifications conditional effects 
 qb   finally  refers general planning formalism introduced section     



example   consider planning instance example    becomes quickly obvious
instance expressed using   initial state specification incomplete 

operator d  zac contains conditional effects negative literals effect conditions  however 
need general boolean formulae express instance 
   

fic ompilability



e xpressive p ower p lanning f ormalisms

  

 

  



 

 q

 

 








figure    planning formalisms partially ordered syntactic restrictions

figure   displays partial order propositional planning formalisms defined way 
sequel say specialization   written   iff identical
diagram depicting partial order 
comparing set planning formalisms one backstrom        analyzed  one notices despite small differences presentation planning formalisms 



common propositional strips  cps  

propositional strips negative goals  psn  
ground tweak  gt  
    computational complexity planning  family

one would expect planning much easier planning  s   turns
case  provided one takes computational complexity perspective 
analyzing computational complexity planning different formalisms  consider 
usual  problem deciding whether exists plan given instancethe plan existence
problem  planex   use prefix referring planning formalism consider
existence problem particular planning formalism 
theorem  



 planex pspace complete



 qb  

   consider planning formalisms identical sas formalism  backstrom   nebel         since
allow multi valued state variables 

   

fin ebel

proof  pspace hardness  planex follows result bylander        corollary      
membership  qs  planex pspace follows could  step step  guess
sequence operators  verifying step operator application leads legal follow
state specification last operator application leads state specification entails
goal specification  step  verification carried polynomial space  reason
conditions definition verified polynomially many calls
np oracle  therefore   qs decided non deterministic machine polynomial space 
hence member pspace 
follows plan existence problem formalisms expressiveness
 s including formalismsis pspace complete 

   expressiveness compilability planning formalisms
although difference computational complexity formalisms
qb  family  might nevertheless difference concisely planning domains plans
expressed  order investigate question  introduce notion compiling planning formalisms 
    compiling planning formalisms
mentioned introduction  consider planning formalism expressive another
formalism planning domains plans formulated formalism concisely expressible
  formalize intuition making use call compilation schemes 
solution preserving mappings polynomially sized results domain structures
domain structures  restrict size result compilation scheme 
require bounds computational resources compilation  fact  measuring
expressibility  irrelevant whether mapping polynomial time computable  exponential time
computable  even non recursive  least  seems idea notion expressive
power discussed similar contexts  baader        erol et al         gogic et al         cadoli
et al          want use compilation schemes practice  reasonably
efficient  course  however  want prove one formalism strictly expressive
another one  prove compilation scheme regardless many
computational resources compilation scheme might use 
far  compilation schemes restrict size domain structures  however  measuring expressive power  size generated plans play role  backstrom s
esp reductions         plan size must identical  similarly  translation


proposed gazen knoblock        seems implicit prerequisite plan
length target formalism almost same  comparing expressiveness
different planning formalisms  might  however  prepared accept growth plans
target formalism  instance  may accept additional constant number operators 
may even satisfied plan target formalism linearly polynomially larger 
leads schematic picture compilation schemes displayed figure   
although figure   gives good picture compilation framework  completely
accurate  first all  compilation scheme may introduce auxiliary propositional atoms
used control execution newly introduced operators  atoms likely
initial value may appear goal specification planning instances target
   

fic ompilability



e xpressive p ower p lanning f ormalisms




planning

compilation





g



b

planning



figure    compilation framework

formalism  assume compilation scheme takes care adds literals
initial state goal specifications 
additionally  translations initial state goal specifications may necessary 
want compile formalism permits literals preconditions goals one requires atoms  trivial translations necessary  similarly  want compile formalism
permits us use partial state specification formalism requires complete state specifications  translation initial state specification necessary  however  state translation
functions limited  depend set symbols source
formalism  context independent  i e   translation literal state specification
depend whole specification  efficiently computable 
compilation framework theoretical tool measure expressiveness  has 
course  practical relevance  let us assume reasonably fast planning system
planning formalism want add new feature resulting formalism  
come efficient compilation scheme   means easily integrate
new featureeither using compilation scheme modifying planning algorithm
minimally  compilation scheme exists  probably would problems integrating feature  finally  computationally expensive compilation schemes exist  interesting
situation  case  off line compilation costs may high  however  since compiled
domain structure used different initial goal state specifications  high off line costs
may compensated efficiency gain resulting using planning algorithm 
turns  however  situation arise analyzing compilability  qs formalisms  either identify polynomial time compilation scheme able prove
compilation scheme exists 

   means compilation schemes planning formalisms similar knowledge compilations  cadoli  
donini         fixed part computational problem domain structure variable part consists
initial state goal specifications  main difference knowledge compilation framework
take  size the  result account  words compile function problems instead decision
problems 

   

fin ebel



    compilation schemes
assume tuple functions m n  ffe ffe qff
n ffifft p  instances follows 

ffz p

induce function





 instances

 



  n   ffe h   ffi ffe s  zs fft  pga


following three conditions satisfied  call compilation scheme



iff exists plan

   exists plan



 

   state translation functions z modular  i e  
d     functions  for   eff   satisfy






 

       

 



 ffd   
  ffdfiff h    ffdff

polynomial time computable 
   size results   ffe     polynomial size arguments 
condition     states function induced compilation scheme solutionpreserving  condition     states requirements on line state translation functions  result
functions computable element wise  provided state specification consistent  considering fact functions depend original set symbols
state specification  requirement seem restrictive  since state translation
functions on line functions  require result efficiently computable 
finally  condition     formalizes idea compilation  compilation much
important result concisely represented  i e   polynomial space  compilation process fast  nevertheless  interested efficient compilation schemes  say
polynomial time compilation scheme   ffe     polynomial time computable
functions 
addition resource requirements compilation process  distinguish different compilation schemes according effects size plans solving
property every plan
instance target formalism  compilation scheme
solving instance exists plan solving             

positive integer constant   compilation scheme preserving plan size exactly  up additive
       positive integer constants
  compilation
constants         k
scheme preserving plan size linearly        i      lff       polynomial    
compilation scheme preserving plan size polynomially  generally  say planning formalism compilable formalism  in polynomial time  preserving plan size exactly 
linearly  polynomially   exists compilation scheme appropriate properties 

write
case compilable compilation done polynomial time  super script       depending whether scheme preserves plan size
exactly  linearly plan  polynomially  respectively 
easy see  notions compilability introduced reflexive transitive 
   although hard imagine modular state translation function polynomial time computable 
pathological function could  e g   output translations exponential size encoding symbols 

   

fic ompilability

proposition   relations







e xpressive p ower p lanning f ormalisms







transitive reflexive 

furthermore  obvious moving upwards diagram displayed figure   
always polynomial time compilation scheme preserving plan size exactly  v denotes
projection  th argument function returns always empty set  generic
compilation scheme moving upwards partial order  on ffeffeff p  
proposition   j  









 

   compilability preserving plan size exactly
proposition   leads question whether exist compilation schemes
implied specialization relation  proposition   proposition   
find compilation schemes every pair formalisms  suffices prove compilable
  order arrive conclusion formalisms compilable
formalisms  
preview results section given figure    establish two equivalence
classes members class compilable preserving plan size exactly 
two equivalence classes called    class  symbols  




naming respective largest elements 

 

 

 



 

q

 







 


figure    equivalence classes planning formalisms created polynomial time compilation
schemes preserving plan size exactly

   

fin ebel

    planning formalisms without conditional effects boolean formulae
first  show formalisms analyzed backstrom         namely     


polynomial time compilable preserving plan size exactly  fact  fourth class
added set  namely      lies  

words  using notion compilability  get equivalence class
backstrom s esp reductions  closer look proofs backstrom s        paper reveals surprising esp reductions used could reformulated
compilation schemes  since used quite different notation  nevertheless prove claim
first principles 
key idea compiling planning formalisms literals formalisms allow atoms

consider      different atoms new formalism  purpose  introduce
 
 
     set negative
copy   further 
j              i e   disjoint
 
literal    replaced     i e  
 

  
 



 

 
     i       fi      
j        

  
otherwise 

 

using   new set atoms  one translate state specifications preconditions easily  postconditions make sure intended semantics taken care of  i e  
 
whenever   added    must deleted vice versa 
finally  deal problem partial state specifications  however 
problem effects unconditional preconditions contain atoms 
case  safely assume atoms unknown truth value false without changing
outcome application operator  let     fi denote completion respect
  i e  

fi             ff  
  fi  xa

   

using function  transform partial state specification complete specification
without changing outcome  i e   get plans 
theorem  
exactly 

     

  polynomial time compilable preserving plan size

proof  since   h z

  follows propositions    
show

order prove claim 

let  n ffifft p  instance  n fftp   translate operator l

operator
 
l  n   pre lbff   post lq      post lq pa
set operators denoted
n  ffe ffe qff ffz p follows 

  
 
 s 
 ffi  
zs fft  



 

  define compilation scheme
 

 

 n  
pff


              ff
   a
   

w 

fic ompilability



e xpressive p ower p lanning f ormalisms

satisfies conditions          functions computed polythe scheme obviously
nomial time   instance 
  obvious
let
 

 ff dffilb      ffd ff lba
 

   n  l ffgagaga ff l  p denote sequence operators corresponding sequence operators

  nl ffgagaga iff l vp   using induction plan length  easy show
 
plan iff plan  
i e   condition     compilation schemes satisfied  means  fact compilation
let

scheme  further  since plan size change  compilation scheme preserves plan size
exactly  finally  functions computed time polynomial arguments 
polynomial time compilation scheme 
one view result matter whether  expressivity point view 
allow atoms literals matter whether complete partial state
specificationprovided propositional formulae conditional effects allowed 
    planning formalisms conditional effects without boolean formulae
interestingly  view spelled generalizes case conditional effects allowed  case matter whether atoms literals allowed
whether partial complete state specifications  proving that  however  two
additional complications  firstly  one must compile conditional effects partial state specifications conditional effects complete state specifications  problem
 d ff post lb  definition function must tested  seccondition  dff post lq  
ondly  compiling formalism literals formalism allows atoms only 
condition m dff post lb    definition must taken care of  reason 
prove result two steps 
first step  show compiled   problem specifying


compilation scheme execution operator l partial state specification leads

 dff post lb   
illegal state  dff post lb  
considering running example  ex      things quite obvious  state specification contain literal negation literal mentioned effect
condition  illegal state specification results  example  state specification neither contain r rsm  rsrsm   result executing d  bac   general case  however 
things less straightforward effect literals produced one conditional
rule effect condition consist one literal 
assuming without loss generality  using polynomial transformation  effects
singleton sets  check following condition  either one conditional effects
effect literal activatedi e   effect condition entailed partial state
conditional effects effect literal blocked  i e   effect condition
contains literal inconsistent state specification  true  original operator
 dff post lq    otherwise resulting state specification inconsistent 
satisfies  dff post lb  
example  consider following operator 

l  


n fft q   ff     v     h bfft   ff v  v     h q  pa
   

fin ebel

application operator satisfies  dff post lb  
  
  

 

 

   true state specification 

 dff post lb 

iff either

  true state specification 

   one      false one     false 



cases  get m d ff post lb  
 dff post lb  result illegal state  order
test condition formalism complete states introduce four new sets atoms 

 
 

          bff
           bff
                  bff
 
      x    th conditional effect l  ba
atom   true either      part original partial state specification  atom
  set true operator one conditional effects adds     appear
effect operator  atom  
    set true operator one conditional effects deletes
     appear effect operator  finally  atoms form   added
action   th conditional effect th operator blocked effect condition  using
new atoms  could translate operator

n ff  h    ffi  ff ff     v v      ff    ff   bff
       ff v         ff    ff  h bff
 
    ff    v     bff
    ffi    v     bff
    ff   h  v     bff
 
    v ff   v        bff
 
v        i       bff

    x         z
 
  q  pa
let   eff    function returns    
             respectively  effect   th
conditional effect th operator  assuming atoms set according
 
intended semantics previous operator deleted atoms    w 
     
 l    

following test operator checks whether original operator would led inconsistent result 
test

 

ffa      ff    iff   e  v     
 

 bdc



whenever       means   th conditional effect th operator  which must
previously executed operator  blocked  addition effect conditional
 dff post lb 
effect activated  i e       iff    true  would  dff post lb  
original formalism  reason  force illegal state  conversely  either   true
  false one       eff    true  would  dff post lq    d ff post lb 
original formalism need force illegal state 
 
could force  using extra literals  operator l  test operator
applied  would result compilation scheme preserves plan size linearly  however 
possible better that  key idea merge test operator th step
operator step e  
   

fic ompilability



e xpressive p ower p lanning f ormalisms

polynomial time compilable preserving plan size exactly 

 n ffifft p  instance   n fftp   without loss generality 
proof  let
assume postconditions operators l   following form 
v f ffgagaga ffi   h
g
v f  z bff
post l     





f
 
 i  
lemma  



first  introduce number new sets symbols pairwise disjoint disjoint
 

 
ji  
 


 

i 

 
 

 

   
    ki
   
    i 
     



 
 

 


      bff
 z    bff
 z    bff
 z    bff
 z    bff
  ki      
        

th conditional effect l

 bff
th conditional effect l  ba

  denotes set primed literals  i e         i  z   
given set literals
   i e   c mv  
            w   function cll denotes successor function modulo
 
mn doqpsrut   further  functions  wv  ff  shall functions v jv   jv 

 
v  bfi post l
v   v
 
 

  v eff    
  v    v      v   b post l a
let postv

l

postv
let block v

l

 ff  defined follows

l            vv     ff  ff  v
       ff  v v    post l e   
              ff  ff  v 
      wff 
    post l  e bff

 ff  defined
block v

l    q   ffi     v v v    q   vxvxf f    post l ff    q        
 q    ffi    wv      
    post l ffi      bff

let testv defined

z
z
z
  z
v    ba
   q  d   v   ff   v   iff   e  v      v  
 
v  
further  let     fresh symbols appearing      jv   jv    
define pair compiled operators l v    ff    corresponding original operator l w  
l v  on pre l h     v  bff postv v l    blockv zl    testv  
   v      v ff   ffi v  b q   
   v v    v    j    v iff   e q x 
  
  k  
 
v  
  q   
z v   v     z v    
 
v
  
         z v    ba
 c

  v

   

fin ebel

pair compiled operators achieves intended effects keeps track fully known
atoms using postv   checks conditional effects blocked using block v   tests whether
 dff post lb  using
execution previous operator satisfied condition  dff post lb  
testv   setup bookkeeping atoms next step  using atoms  v   enforced
executing testing merged parallelizing test step execution step    
order check execution last step  need extra checking step 

l v  on    v b  test v      v    ff  v q    pa
specify compilation scheme

   

follows 
 
 
n 
 
 




 
 

     ffi ffi g bff
             
 
 
  l ffil  tl    fi    l ffil   pff
 
 
    ffi ibff       ji  
      ji           i   
  v bff
      
               fft   ff  h jff  
   ff
 a

 
 b  
 ffi   
 fft  

scheme obviously satisfies conditions      i e   state translation functions modular 
polynomially sized results  further  functions
     i e   compilation functions
computed polynomial time   instance 

  obvious
assume




    x   z  ffd h   bff nl p  ff 
 
  ff  t  dff nl  p   ff 
provided   t  dff nl p      case   t  dff nl p f      either   t    ffd    ff nl p    
m dff post l     dff post l     latter case  application operator
  t    ffd ff nl p  leads inconsistent state conditional effects test  
part postconditions operators applicable state  additionally  true
relation zb ffx   dff nl  ffil         zi ffd h    ff nl ffil   p   
let   nl ffgagaga ffil p denote sequence operators corresponding sequence operators
  nl ffgagaga ffil v p   using induction plan length  easily shown







iff

plan

further  since plan solving instance



exists plan



a  lav


plan



 

must lav last operator  follows

iff exists plan



 

follows immediately polynomial time compilation scheme
preserving plan size exactly  proves claim 







proved compiled preserving plan size exactly  seems worth


noting result depends semantics chosen executing conditional operators partial state specifications  example  use alternative semantics deletes literals


   dff post lb zm dff post lb  provided  dff post lb  consistent  exists probably compilation scheme preserves plan size linearly  use semantics
   

fic ompilability



e xpressive p ower p lanning f ormalisms

resulting state specification legal application state transformation functions leads
theory represented set literals  seems unlikely exists scheme
preserves plan size polynomially  reason pessimistic conjecture
semantics appears conp hard determine whether state specification resulting
applying b  operator legal 

second step showing partial state specifications literals compiled away 
show compile   key idea proof proof

 
theorem    replace negative literal    new atom     order detect inconsistencies
introduced conditional effects  add postcondition conditional effects form
 
   ff     v   further  check last operator plan introduce inconsistencies 
force application checking operator contains conditional effects 
lemma  




polynomial time compilable



preserving plan size exactly 

proof  let
  n ffifft p  instance   n fftp   since
postconditions operators l  following form 

b

post lb    



vxb gff agaga ffi




 

vxb

 







 instance 

 bff

  bff  
 
 
proof theorem    shall disjoint copy      set atoms
 
c lq following set
negative literal    replaced atom     let post
post
c lb   

    v   

b

 

fi     
 

b

      vxb   
 

post lbe ba

further  let cons set conditional effects
cons

   q   ff  h    v       bff
 

let atom appearing   let l

l    n  

let

 

o  
l   tl   

pre lbff
post
c lbh  cons     

v  v  pff

  let operator l 

l   n ff cons      v     pa

specify compilation scheme

 q  
 
 s  
 ffi   
zs fft  

follows 
 
 
n       v bff  
    l q  pff
      bff
  v bff
     d
   ff
   a

satisfies conditions          functions computed polythe scheme obviously
nomial time   instance 
   

fin ebel

assume



  obvious
 

 ff dffilb     ffd ff lbff

provided  dffilb  

 

 



 

case  dffilb       either    ffd ff lb        ff    
   ffd ff lb      
 
latter case  application operator    ffdff lb leads inconsistent state
conditional
effects cons  part postconditions 
 
let  n  l ffgagaga ff l  p denote sequence operators corresponding sequence operators

  nl ffgagaga ffil vp   using induction plan length  easily shown







iff

plan

further  since plan solving instance



exists plan



 

 



l 

plan



 

must l  last operator  follows

iff exists plan

follows polynomial time compilation scheme
proves claim 









 

preserving plan size exactly 

result is  course  dependent semantics formalisms deal
 dff post lb   
complete state specifications  hence always m dff post lb   
theorem  
size exactly 

     

 



polynomial time compilable preserving plan

proof  b follows lemma    lemma   proposition    using propositions  

  fact  b    claim follows 







   limits compilation preserving plan size linearly
interesting question is  course  whether compilation schemes preserving plan
size exactly identified far  turns out  case  prove
pairs formalisms identified compilation scheme preserving
plan size exactly  compilation scheme impossible even allow linear increase
plan size  pairs formalisms even able prove polynomial increase
plan size would help establishing compilation scheme  results are  however 
fhe assumption  preview
conditional based assumption slightly stronger ef g
results section given table    symbol means exists compilation
scheme first formalism specialization second one  cases 
specify separation give theorem number result 
    conditional effects cannot compiled away
first all  prove conditional effects cannot compiled away  deeper reason
conditional effects  one independently number things parallel 
impossible formalisms without conditional effects  consider  example 
operator d  zac example    clear  propagates  truth value rsr m klu h
hqj k y k  ba nx hbjsk klu h nx   respectivelyprovided state specification satisfies precondition 
   

fic ompilability



 s


qs


 s





  


 q
j


 


cor    

cor    

cor    

cor    

ji

ji

 i

theo    

cor    

cor    

ji

ji

 i

cor    

cor    

cor    

 





ji



 









cor    









theo    





 

















cor    



theo    






 

cor    

 q






cor    







 

k



e xpressive p ower p lanning f ormalisms
















cor    





 

cor    



 

table    separation results

obviously possible come set exponentially many operators
thing one step  however  unclear less exponentially many operators 
fact  show impossible 
order illustrate point  let us generalize example  start set
propositional atoms        ffgagaga ff     disjoint copy set  ml       l     fiv   
further 






  dnl shall denote corresponding set literals


consider following





 



l

  i e  

     l      dfi         l  g    d ba
l



domain structure 

fi   l
b
    n fft    v   l ff   v    l     wfiv  p
  n  ff  pa
construction follows pairs fft  consistent complete set
 l   instance  n  ffifft p one step plan  conversely  pairs


fft  gff l   l   exist solution 
trying define domain structure polynomially sized       property

seems impossible  even allow  step plans  however  trying prove this  turns
additional condition state translation function needed 
say state translation functions local iff state specifications
ff   







  dpff qff s  ffdff   a
   





fin ebel

locality additional condition state translation functions could easily prove
conditional effects cannot compiled away  instead show  however 
possible derive weaker condition definition compilation schemes
enough prove impossibility result  weaker condition quasi locality state translation
functions relative given set symbols   turn based notion universal
f
literals  literal called universal literal given state translation functions iff one
following conditions satisfied 
        

f

        

f

        

f

        

f

        

f

        

f

p     bfft   h    
p     bfft    h    
p     bffeb  
pzs    h bfft   h    
pzs    h bfft    h    
pzs    h bffeb  

let r denote set universal literals  define quasi locality state translation functions relative set propositional atoms induced set universal literals r follows 
d   pairs ff     








w
r

  dff sffzs  ffdfiff







words  non local literals quasi local state translation functions universal literals 
lemma    given compilation scheme f n  ffe
  ut 
exists set atoms



ffe qff ffz p natural number
quasi local  

 

r v function result union results possible
proof  let
translations literal returned state translation functions  i e  
gl        h bfft   h       h bfft    h       h bffeb  
   h bfft     
  zb    h bfft    h  
  zs    h bffeba
set

  
w

r    choose infinite subset
w





w

either

     xw   finitely many atoms  xw   glor infinite subset w exist 
  

w



universal literal

f


r

set r   
r   

f

 

aff g q sur  


 

 
f

r must
note infinite subset w must exist  reason literal
occur infinitely many atoms w could find infinite subset
satisfying condition      single atom six possible ways generate
f
  must exist infinite subset literal occurs either v    h bfft   h    
f
v    h bfft    h     zv    h bffeb  for   iff   subset universal literal 
   

fic ompilability



e xpressive p ower p lanning f ormalisms

pick subset satisfying first condition  choose finite subset
desired cardinality state translation functions quasi local respect
r  
otherwise repeat selection process w r condition     satisfied 
selection process repeated finitely often otherwise atoms tl  infinite result  impossible state translation functions
polynomial time computable therefore finite results 
demonstrates always exists set propositional atoms statetranslation functions quasi local  however  might able effectively determine
set 
using result  finally able prove non existence compilation schemes
compiling conditional effects away preserving plan size linearly 
theorem   



cannot compiled   preserving plan size linearly 

proof  assume contradiction exists compilation scheme  q pres
serving plan size linearly  compiles domain structure defined  

domain structure

     on  tff pa
lemma    assume set atoms chosen translation

functions quasi local set 
let us consider initial state specifications consistent complete
contain positive negative literals 

obviously 
following form



 t





k
 r
  fi ff fik ba

state specifications  assumption 

 q

instance

n ff     ffi h   b ff    ffi l h    p
 step plan  since  i    different  step plans  number polyno
mial size   plan used different initial statesprovided sufficiently

large 
suppose plan used pairs fft ff t fft   result  



   fi ffi h   k
    ffi l    
   fi ffi h   k
  zs fi ffi l     s k

since  
  must differ least one atom  say     without loss generality
assume            since successful plan modular 




follows

x   ffeh 

zs     l b  fft    l   

  

   

fin ebel

literals zs    kl  bfft   klx   may added operators none literals
    l  bfft    l    deleted operator without reestablishing literal another
operator deletion  contains operators unconditional effects  adds
deletes literals regardless initial state 
f
let us assume exists literal zs    kl  bfft   klx   added  
f
implies  t distinguish three cases 


  k   conclude f  t  
f
   p   k
  lx bffeb   implies f  t  
f
  
state z     s bffi      k  l   q   s bfftf     s bffe     assumed
f
translation functions quasi local   must universal literal  universal

f
contain positive negative
  possible initial states
f
literals well literal elements   universal   present
f
reason  further  added valid


plan   must part  



f
words  literals
  k  lx bfft  k  lx   added already  
conclude
    ffe  y     l  bfft    l   a
  

f

let

 
 

      l  bffi l j     l   h  

      l  bfft    l   
  zs   ffi l      l         l   h   b va
z modular  clear   therefore   t t ffefi   




achieves well    klx bfft   klx     follows  again modular   achieves

 

since n ffi ffi l z   k
  l       e  l   p plan  plan

n ffi fft p   fact plan instance implies cannot compilation
scheme  desired contradiction 
using propositions     well theorem    result generalized follows  see
table    
corollary     qs       
preserving plan size linearly 




cannot compiled  q formalism specializing  

answers question whether space efficient compilation schemes

one proposed gazen knoblock        possible  even assuming unbounded
computational resources compilation process  space efficient compilation scheme
impossibleprovided compilation preserve plan size linearly  allow polynomially larger plans  efficient compilation schemes possible  see section    
   result demonstrates choice semantics important  interpret conditional effects
sequentially brewka hertzberg        do  exists straightforward compilation scheme preserving
plan size exactly 

   

fic ompilability



e xpressive p ower p lanning f ormalisms

    non uniform complexity classes
next section make use so called non uniform complexity classes  defined
using advice taking machines  order prove impossibility compilation scheme 
advice taking turing machine turing machine advice oracle   not necessarily recursive  function positive integers bit strings  input   machine loads
bit string i       continues usual  note oracle derives bit string
length input contents input  advice said polynomial
oracle string polynomially bounded instance size  further  complexity class defined terms resource bounded machines  e g   p np  j pbnm  also called non uniform
x  class problems decided machines resource bounds
polynomial advice 
advice oracle  class p poly appears much powerful p  howy es pbnm
ever  seems unlikely p poly contains np  fact  one prove fje
implies certain relationships uniform complexity classes believed unlikely  stating result  first introduce polynomial hierarchy 
let x class decision problems  e  denotes class decision problems
decided polynomial time deterministic turing machine allowed use
procedurea so called oraclefor deciding problem   whereby executing procedure
cost constant time  similarly  fje denotes class decision problems

polynomial time using
nondeterministic turing machine solves
instances



defined follows 
oracle  p   based notions  sets    












 

v  

v  

 
v









v

v

v



 
 eff
e


fje
ygn fje

thus   gfhe

 ygnfje   set classes defined way called polynomial
hierarchy  denoted ph  note

f 
v

e 







v


 
v


v

 
v






v



 a

e sekd

have 


v   classes  unknown whether
v
v
v
v
v
inclusions classes proper  however  strongly believed case 
i e   hierarchy truly infinite 
based firm belief polynomial hierarchy proper  mentioned question
ee pbnm answered  shown fje es pbnm would imply

whether fje

polynomial hierarchy collapses second level  karp   lipton         i e    
yg nfhes  pb nthis 

however  considered quite unlikely  further  shown fje

ygnfje fj es  pbnm implies polynomial hierarchy collapses third level  yap        
i e  
    considered unlikely  use result proving

pairs formalisms unlikely one formalism compiled
one 
   super script used distinguish sets analogous sets kleene hierarchy 

   

fin ebel

    expressive power partial state specifications boolean formulae
cases considered far  operators partial state specifications could compiled
operators complete state specifications  i e   partial state specifications add expressiveness  longer true  however  allow arbitrary boolean formulae
preconditions effect conditions  case  decide conp complete problem
whether formula tautology deciding whether one step plan exists  asking  example 
q  instance n fft  nff kpe bffefft  v  p plan equivalent asking whether tautology 
let one step plan existence problem    planex  planex problem restricted
plans size one  evident  qb    planex  q    planex
conp hard  let   fixed polynomial  polynomial step plan existence problem
    planex  planex problem restricted plans length bounded    
size planning instance  easy see  problem np formalisms except
 qb  q   reason guessing sequence operators state specifications
polynomial size  one verify step polynomial time precondition satisfied
current state specification produces next state specification  since
polynomially many steps  overall verification takes polynomial time 
proposition        planex solved polynomial time nondeterministic turing machine formalisms different  s  q  
fact      planex conp hard and  e g    s  p planex np  follows
almost immediately polynomial time compilation scheme q  
ygnfje    however  even allow unbounded
preserves plan length polynomially  if fhe 
computational resources compilation process  proof technique first used kautz sel
  
man        used show compilation scheme cannot exist  provided  



theorem   

 q

cannot compiled    preserving plan size polynomially  unless



 



 

proof  let propositional formula size conjunctive normal form three literals per
clause  first step  construct   domain structure   size polynomial
following properties  unsatisfiability arbitrary  cnf formula size equivalent
 step plan existence      planex instance n  ffi  fft     p     computed
polynomial time  
given set atoms  denoted   define set clauses set containing
clauses three literals built using atoms  size     i e  
polynomial   let   set new atoms  e   corresponding one to one clauses
  further  let
b

    f f f m         f f f  m
construct   domain structure    n fivfftkp formulae size follows 


 




 

 

      v bff
  n    v bfft  v  pe ba


   

fic ompilability



e xpressive p ower p lanning f ormalisms

let function determines  cnf formulae   atoms   correspond
clauses formula   i e  

             f f f     ba
now  initial state particular formula size computed follows 
 h  h    m   h     v ba
 
construction  follows exists one step plan n   fft ffi  fft  v  p


iff





unsatisfiable 
let us assume exists compilation scheme  q    preserving plan
size polynomially  further  let us assume   domain structure   compiled   
domain structure    n fi fft p   using compiled domain structure  construct
following advice taking turing machine 
input formula size   load advice n  ffe    fftffe     fft p  
advice polynomial   polynomial size compilation scheme generates
polynomially larger domain structures  polynomial time function  
computed polynomial time  compute

 
   ffi      b  fft
polynomial time  goal specification

    fft  v       fft
computed polynomial time  finally  decide    planex problem resulting
    instance n ffi fft p   proposition    know done polynomial time

nondeterministic turing machine 
deciding    planex n ffi fft p equivalent deciding  planex
n  ffi  fft  v  p   turn equivalent deciding unsatisfiability   follows
decide conp complete problem nondeterministic  polynomial advice taking turing machine
fhe  pbnm   using yap s        result 
polynomial time  follows ygnfje
claim follows 
using proposition   proposition    result generalizes follows  see table    

corollary     qs   cannot

compiled planning formalisms preserving

 
plan size polynomially  unless  





restrict form formulae  however  may able devise compilation schemes
 q to  e g       reconsidering proof last theorem  turns essential
use negation cnf formula precondition  restrict cnf formulae
preconditions  seems possible move partial complete state descriptions using ideas
similar ones used proof lemma   
however  compilation scheme work  s   reason condition
 dff post lb    dff post lb  definition function   condition satisfied  result operator inconsistent  condition could easily employed reduce
unsatisfiability cnf formulae   step plan existence  enables us use technique proof theorem 
   

fin ebel

    circuit complexity
next impossibility result need notions boolean circuits families circuits 
boolean circuit directed  acyclic graph    ff   nodes called gates 
gate  
type k   k  fiff fiff
 ff ffi  f   ffgagaga     gates k   k

 sffiff ffgagaga   in degree zero  gates k   k    in degree one 
gates k   k  
fiff   in degree two  gates except one least one outgoing
edge  gate outgoing edge called output gate  gates incoming edges
called input gates  depth circuit length longest path input gate
output gate  size circuit number gates circuit 
given value assignment variables   
output gate obvious way  example 
gate circuit shown figure   

ffgagaga    circuit computes value
     get value   output











figure    example boolean circuit

instead using circuits computing boolean functions  use accepting

words length   ff      word  h agaga   ff    interpreted value

assignment input variables ffgagaga ff  circuit  word accepted iff output gate

value   word  order deal words different length  need one circuit
possible length  family circuits infinite sequence  o  ff  ffgagagaw  

input variables  language accepted family circuits thei set words
  accepts  
usually  one considers so called uniform families circuits  i e   circuits generated
turing machine pk   space bound  sometimes  however  non uniform families
interesting  example  class languages accepted non uniform families polynomiallysized circuits class p poly introduced section     
using restrictions size depth circuits  define new complexity
classes  uniform variants subsets p  one class important
following class languages accepted uniform families circuits polynomial size
logarithmic depth  named nc   another class proves important us defined
terms non standard circuits  namely circuits gates unbounded fan in  instead
restricting in degree gate two maximum  allow unbounded in degree 
class languages accepted families polynomially sized circuits unbounded fan in
constant depth called aci  
   

fic ompilability



e xpressive p ower p lanning f ormalisms



definition  follows almost immediately ac
nc   moreover 
shown languages nc non uniform variant aci  
implies ac   nc  furst  saxe    sipser        
    boolean formulae cannot compiled conditional effects
seen section      boolean formulae quite expressive used combination partial state specifications  however  state specifications complete 
case  seems possible simulate evaluation cnf formulae using conditional
effects  fact  possible compile polynomial time  example    preserving plan

size linearly  provided formulae conjunctive normal form  operator would
split two operators  one evaluates clauses formulae original operator
one combines evaluations takes appropriate actions  e g   asserting
precondition satisfied  sequencing pairs operators achieved introducing
extra literals 
say general case  however  trying simulate evaluation
arbitrary logical formula using conditional effects  seems case need many
operators nesting depth formula  means would need plans cannot
bounded linearly longer original plans 
use results sketched section     separate     order so  let us

view domain structures fixed size plans machines accept languages  words
consisting bits  let

  on fi      bfftvpa
assume atoms numbered     word

consisting bits could

encoded set literals

 
       

th bit

 fi         th bit k ba

conversely  consistent state specification   let word th bit   iff
   d  
say  bit word accepted one step  step plan   iff
exists one step  step plan  respectively  instance

  n n fi     v bfftkpffi       v bfft      pa
similarly families circuits  define families domain structures    ffe ffgagaga  


language accepted family one step  or  step  plan set words accepted
using domain structure   words length   borrowing notion uniformity well 
say family domain structures uniform generated pk  space turing
machine 
papadimitriou pointed languages accepted uniform polynomially sized
boolean expressions identical nc  papadimitriou        p        easy see  family   domain structures nothing family boolean expressions  provided use
one step plans acceptance 
proposition    class languages accepted uniform families   domain structures using
one step plan acceptance identical nc  
   

fin ebel

closer look power  step plan acceptance families

domain structures is  turns less powerful nc   order show that  first
prove following lemma relates  step plans circuits gates unbounded fan in 





lemma    let f  n fftp domain structure  let
  let  step plan

  exists polynomially sized boolean circuit unbounded fan in depth   fit
plan n ffifft p iff circuit value   input  
proof  general structure circuit  step



 
 
 



plan displayed figure   







 

 

     



 
 
 

 
 
 



 
 
 

 









 

 
 
 

     



     





figure    circuit structure goal testing  step



plan

 

plan step  or level    atom     connection     connections level
input gates  i e         goal test performed
 gate checks goals
true level   case      ff   ff      further  using  gate  checked

inconsistency generated executing plan 
plan step     must computed whether precondition satisfied
result conditional effects are  figure    a  displays precondition test precondition
    ff  ff       conjunction precondition literals true  v becomes true 
connected  gate figure   
without loss generality  using polynomial transformation   assume conditional
vgf   whether effect f activated level   computed circuit
effects form
v     
displayed figure    b   shows circuit     ff    

finally  activated effects combined circuit shown figure    c   atoms    
check whether      activated  would set true  one
inputs  gate figure    neither      activated  value  
level  n determined value   level     otherwise value   level  
 
determined value  w   i e   activation value positive effect   level    
depths circuits figure    b   c  dominate depth circuit necessary
represent one plan step leading conclusion plan step represented using circuit
depth    adding depth goal testing circuit  claim follows 
lemma implies  step plan acceptance indeed less powerful     step plan

acceptance  means compilation scheme   preserving plan size linearly

impossible 
   

fic ompilability



e xpressive p ower p lanning f ormalisms









 z










   
















 

 



 a 









z

 b 



z

 



 c 

figure    circuit structure precondition testing  a   conditional effects  b   computation
effects  c  operators



theorem   



  members







 class 

proof  show      theorem   proposition   claim follows 

assume contradiction   let   ffe ffgagaga uniform family



domain structures     ffe  ffgagagaw domain structures generated compilation



scheme preserves plan size linearly  lemma    know domain

structure   n  fft p given goal generate polynomially sized  unbounded fanin circuit depth  t tests whether particular  step plan achieves goal  order
decide  step plan existence  must test  i    ie different plans  polynomial size
  compilation scheme  plan  generate one test circuit 
adding another  gate decide  step plan existence using circuit depth  w size
polynomial size     further  since state translation functions modular  results
fixed computed using additional level gates  since proposition   
languages nc accepted uniform families   domain structures using one step plan
acceptance  assumption   implies accept language nc  possibly

non uniform  aci circuits  impossible result furst colleagues        
using propositions     again  generalize theorem follows 
corollary   

 





cannot compiled



b







preserving plan size linearly 

   compilability preserving plan size polynomially
shown previous section  compilation schemes induced propositions  
  ones identified section   allow compilation schemes preserving plan size exactly  pairs formalisms able rule compilation schemeseven
   

fin ebel

allow linear growth resulting plans  nevertheless  might still chance
compilation schemes preserving plan size polynomially  shown  qs  q cannot
compiled formalisms even plan grow polynomially  may still able
find compilation schemes preserving plan size polynomially  qs    pair
remaining formalisms 
preview results section given figure    seen  able

   

 

 



 

b

 










figure    equivalence classes planning formalisms created polynomial time compilation
schemes preserving plan size polynomially  compilation schemes constructed
section indicated dashed lines

establish compilation schemes preserving plan size polynomially pairs formalisms
proved impossibility compilation schemes 
    compiling conditional effects away partial state specifications
first compilation scheme develop one qs q   before  assume
conditional effects singleton effect sets  further  since use arbitrary boolean
formulae effect conditions qs   assume one rule effect literal 
using simple polynomial transformation  arbitrary sets operators brought form 
 dff post lb  considerably 
simplifies checking condition  dff post lb  
one rule activate particular literal 
   

fic ompilability



e xpressive p ower p lanning f ormalisms

order simulate parallel behavior conditional effects  break
individual operators executed sequentially  means conditional effect
operator introduce two new operators  one simulates successful application rule 
one simulates blocking situation rule  least one operators must
executed conditional effect original operator  something force
additional literals added control execution operators  leads
sequence operators length bounded number conditional effects original
operator 
want simulate parallel behavior sequence unconditional operators  effects
unconditional operators directly influence state description  effect
deferred operators corresponding set conditional effects
executed  reason  use sequence copying operators copy activated
effects state description conditional operators executed  copying
operators used check set activated effects consistent 
theorem   

qs

compiled

q

polynomial time preserving plan size polynomially 

proof  assume   n fftp  qb source domain structure assume further  without
loss generality  using polynomial transformation   operators form

l   n pre l fft   vxf ffgagaga ffe   vgf  fiz  pff
f
f
f
            x
   
v
let   disjoint copies   used record active effects conditional
another disjoint copy  used record active effect
effects  let
l
copied yet  further  let
j        zlw   new set atoms corresponding one to one
 
operators let set symbols corresponding one to one conditional effects
  i e  
 
v f     post l  ffil     ba
            x
finally  let fresh atom appearing           
   signals copying
l
active effects state specification progress  set symbols compiled
domain structure

 f     
 

  
l

  m 

 

      ba

operator l   compilation scheme introduces number new operators 
first operator introduce one checks whether conditional effects previous
operators executed  copying progress precondition satisfied 
case  execution conditional effects operator started 

l pre
  n pre l  h  


 

       bff     b               

   
l

pa

operator enables conditional effect operators  activated effects  introduce
following operators 

lk    
  n     b 
   q bff              ffl

   

 z    f             l

      f    pa

fin ebel

words  effect condition entailed  activated positive negative effect well
fact rule tried recorded 
since one effect literal conditional effect  conditional effect
blocked negation effect condition entailed state specification 
blocked conditional effects introduce following operators 

l    
  n     b
      bff         pa

order check conditional effects tried  activating corresponding effect
activating conditional effect blocked   following operator used 

l
  n     bb fi      

 

    vgf   

post l

e bff             bb  pa

operator enables copying activated effects state specification  achieved
following set operators atom      


l

l
l



 
 


 

 

n    ff  ff     ff  l b  fft   ff   l    pff
n    ff   ff    ff  l b  fft    ff   l    pff
n    ff  ff    ff  l  bff
pa

finally  need operator checks possible effects copied  operator
starts execution cycle enabling execution another precondition operator 

li  
  n         
l

ff       pa

using definitions  specify set compiled operators 

pre

   l ffil  l       vhf
  l    l  ff    vxf   fi post l e   
  l    l   ff   
    post l e   
  l ffil   ffil     w fi 
  lait ba
based that  specify compilation scheme  on  ffe zffe zff p follows 
     n  fft p
 
 b         
    l               bff
 s    m
       bff
 ffi   
zs fft    a
scheme obviously satisfies conditions        
compilation schemes
functions computed polynomial time  further  q  instance  instance 
let legal  s state specification let    dffil operator
clear d     exists sequence
l x   discussion 
  l   followed
pre
operators consisting l   followed operators form l


operator l   followed turn operators l   followed finally operator l  
   t  d    ffe fff
   

fic ompilability



e xpressive p ower p lanning f ormalisms

conversely  d        exist plan transforms

 d    bffil pre

legal state specification contains      b  
using
induction plan length  follows arguments exists plan
iff exists plan every plan       v      
      
maximum number conditional effects operators   hence
polynomial time compilation scheme preserving plan size polynomially 
immediate consequence theorem  s  q form equivalence class
respect compilability preserving plan size polynomially 
corollary   
polynomially 

 qs



 

polynomial time compilable preserving plan size

further  know corollary    class cannot become larger 
case compiling   however  result depends semantics chosen


executing conditional effects partial state specifications  use alternative semantics resulting state specification legal application state transformation
functions leads theory represented set literals  seems likely exists
another scheme preserves plan size polynomially  however  use alternative semantics


deletes literals    dff post lb  i dff post lb   dff post lb consistent 
appears unlikely able identify compilation scheme preserves plan
size polynomially 
    compiling conditional effects away complete state specifications
next compilation scheme compiles        since deal complete state


 d ff post lb   
specification  take care condition m d ff post lb m 
always true complete states  makes compilation scheme somewhat simpler  since
allow general boolean formulae  scheme becomes little bit difficult 
general  however  compilation scheme specify similar one given
proof theorem    
theorem       compiled
serving plan size polynomially 

 





compiled



polynomial time pre 

proof  proof theorem     assume   n fftp    
domain structure  further  assume operators form

v f  b  pff
l   n pre l fft  u vxf ffgagaga ff u   x
f
u    structure u  
 m  




  source

structure  means
assume effects unique conditional effect 
addition  assume set symbols compiled domain structure proof
theorem    

 f     

 

  

   

l

  m 

 

      ba

fin ebel



pre
operator l   introduce operators l   l   l
theorem    
addition  following operators needed 


lk    
l  e    

 l


 

 l




n     bb    u   ff     q fi        l       f            n     bb         e   t  e   u   bff        pa

  l

l



proof

      f    pff


compiled set operators contains operators compilation scheme

identical scheme presented proof theorem     means significant
difference compilation scheme presented proof theorem    operator scheme
l  e   tests rule whether contains effect condition blocks rule  since
complete state specifications  every conditional effect either activated blocked 
   s used record execution conditional effect tried 
using similar arguments proof theorem     follows compilation
scheme indeed scheme leads claim made theorem 


follows equivalent respect formalisms


equivalent respect   two sets could merged one equivalence class 

provided able prove that  e g     compiled  



    compiling boolean formulae away
section     showed impossible compile boolean formulae conditional effects
plans allowed grow linearly  however  sketched already idea compilation
scheme preserves plan size polynomially  show compile boolean
formulae   expressively equivalent basic strips  i e   compile boolean

formulae away completely 
theorem   

 

polynomial time compilable



preserving plan size polynomially 

proof  assume f on fftp domain structure  assume without loss generality
   i e  
operators l   form l  on ffi p  
one formula precondition instead set formulae  
let two new sets atoms corresponding one to one sub formulae occurring preconditions operators   new atoms denoted      
sub formula   atoms form    used record truth value sub formula
computed atoms form    used store computed truth value 
operator l   n ffi p   target operator set following operator 

l  on    q ffi  b  bffi     pa
set operators generated way denoted  
further  atom       introduce following two operators 

l
l



 

 

 

n     bff     ffi    pff
n     h bff     ff     pa

set operators generated way denoted
   



 

fic ompilability



e xpressive p ower p lanning f ormalisms

sub formula occurring preconditions
operators introduced 

l

l  
l    
sub formulae j 



l
l
l  

form  


p

following

n     ffi  ffi   ffi   b  fft    ffi    pff
n     ff     bfft    ff    h  pff
n          bfft    ff    h  pa
 

 



  following operators introduced 
  n     ffi    bfft    ffi     pff
  n     ffi    bfft    ffi     pff
  n     ffi  ff    ff     bfft    ff    h  pa

finally  j     following operators 

l
l



 

 

 

n         bfft    iff     pff
n     iff    bfft    ff      pa

set operators generated sub formulae denoted
specify compilation scheme  

  
 
 b 
 ffi  
s fft  



 

 n   m    ff       u pff



 a

construction obvious functions polynomial time computable 

induced function reduction 

state translation functions modular 
every plan source planning instance exists plan       
                maximum number sub formulae preconditions  
that  claim follows 
might question whether compiling boolean formulae away could done
efficiently  using result boolean expressions evaluated circuits logarithmic
depth  indeed possible  however  satisfied result
compilation scheme preserving plan size polynomially all  result together theorem    settles question compilation schemes preserving plan size polynomially pairs
formalisms 
corollary    formalisms

preserving plan size polynomially 





   

  

polynomial time compilable

fin ebel

    parallel execution models feasibility compilation schemes preserving plan
size polynomially
compilation schemes preserve plan size exactly linearly seem immediate use 
polynomial growth plan appears little practical interest  considering practical
experience planning algorithms roughly characterized property many
steps plan without getting caught combinatorial explosion fact
number significantly smaller      polynomial growth seem make much sense 
take graphplan  blum   furst        consideration againthe planning system
motivated investigation first placeit turns system allows parallel
execution actions  although parallel execution might seem add power planning
system considerably  affect results all  sequential plan solve planning
instance steps  parallel plan need least actions  nevertheless  although size
plan  measured number operations  might same  number time steps may
considerably smallerwhich might allow efficient generation plan 
look compilation scheme compiles conditional effects away  seems case
large number generated actions could executed parallelin particular actions
simulate conditional effects 
however  semantics parallel execution graphplan quite restrictive  one action
adds deletes atom second action adds deletes one action deletes atom
second action precondition  two actions cannot executed parallel
graphplan   restriction  seems impossible compile conditional effects away
preserving number time steps plan  however  compilation scheme preserves
number time steps linearly seems possible  instead compilation scheme 
approaches far either used exponential translation  gazen   knoblock        modified
graphplan  algorithm order handle conditional effects  anderson et al         koehler et al  
      kambhampati et al          modifications involve changes semantics parallel
execution well changes search procedure  implementations compared
straightforward translation gazen knoblock        used  would interesting
compare compilation scheme based ideas spelled theorem   
base line 

   summary discussion
motivated recent approaches extend graphplan algorithm  blum   furst       
deal expressive planning formalisms  anderson et al         gazen   knoblock       
kambhampati et al         koehler et al          asked term expressive power could
mean context  one reasonable intuition seems term expressive power refers
concisely domain structures corresponding plans expressed  based
intuition inspired recent approaches area knowledge compilation  gogic et al        
cadoli et al         cadoli   donini         introduced notion compilability order
measure relative expressiveness planning formalisms  basic idea compilation
scheme transform domain structure  i e   symbol set operators 
initial state goal specification transformedmodulo small changes necessary
technical reasons  further  distinguish compilation schemes according whether plan
target formalism size  up additive constant   size bounded linearly
   

fic ompilability



e xpressive p ower p lanning f ormalisms

size plan source formalism  size bounded polynomially original planning
instance original plan 
although compilability framework appears straightforward intuitive tool
measuring expressiveness planning formalisms  possible come alternative
measures  backstrom         instance  proposed use esp reductions  polynomial
many one reductions planning problems preserve plan size exactly  however  requiring
transformation polynomial time computable seems overly restrictive 
particular  want prove one formalism expressive another one  better
proven exists compilation scheme regardless much computational resources
compilation process may need  furthermore  appear severe technical problems
using backstrom s        framework proving negative results  hand 
positive results reported backstrom achievable compilation framework
transformations used fact compilation schemes  taking together  appears
case compilation framework superior intuitive technical point view 
another approach judging expressiveness planning formalisms proposed
erol colleagues               measure expressiveness planning formalisms according set plans planning instance have  approach contrasts hierarchical task
network planning nicely strips planning  help us making distinctions
formalisms  family 
compilability framework mainly theoretical tool measure concisely domain
structures plans expressed  however  appears good measure
difficult planning becomes new language feature added  polynomial time compilation
schemes preserve plan size linearly indicate easy integrate feature
compiled away  one either use compilation scheme mimic compilation scheme
extending planning algorithm  polynomial time compilation scheme leading
polynomial growth plan possible  indication adding new feature
requires probably significant extension planning algorithm  even compilation
scheme preserving plan size polynomially ruled out  probably serious
problem integrating new feature 
using framework  analyzed large family planning formalisms ranging basic
strips formalisms conditional effects  boolean formulae  incomplete state specifications  surprising result analysis able come complete
classification  pair formalisms  either able construct polynomial time
compilation scheme required size bound resulting plans could prove compilation schemes impossibleeven computational resources compilation process
unbounded 
particular  showed formalisms considered paper 






incomplete state specifications literals preconditions compiled basic strips
preserving plan size exactly 
incomplete state specifications literals preconditions effect conditions compiled away preserving plan size exactly  already conditional effects 
compilation schemes preserving plan size linearly except implied
specialization relationship described above 
   

fin ebel

allow polynomial growth plans target formalism  formalisms
containing incomplete state specifications boolean formulae compilable other  incomplete state specifications together boolean formulae  however  seem add significantly
expressiveness planning formalism  since cannot compiled away even
allowing polynomial growth plan unbounded resources compilation process 
noted  however  results hold use semantics
conditional effects partial state specifications spelled section      semantics 
may get slightly different results concerning compilability conditional effects partial
states 
one question one may ask happens consider formalisms boolean formulae
syntactically restricted  indicated various places paper  restricted formulae 
cnf dnf formulae  sometimes easily compiled away  however 
cases impossible  example  shown cnf formulae cannot compiled
basic strips preserving plan size linearly  nebel         confirms backstrom s       
conjecture cnf formulae preconditions add expressive power basic strips 
another question reasonable restrictions compilation scheme are  particular 
one may want know whether non modular state translation functions could lead powerful
compilation schemes  first all  requiring state translation functions modular seems
quite weak considering fact compilation scheme concerned
domain structure initial state goal specification transformed
all  secondly  considering fact state translation functions depend operator
set  complicated functions seem useless  technical point view  need
modularity order prove conditional effects boolean formulae cannot compiled away
preserving plan size linearly  conditional effects  modularity similar condition seems
crucial  case boolean formulae  could weaken condition point
require state translation functions computable circuits constant depthor
something similar  case  additional freedom one gets non modular state translation
functions seem help functions take operators
account  nevertheless  seems interesting theoretical problem prove powerful
state translation functions add power compilation schemes 
although paper mainly theoretical  inspired recent approaches extend
graphplan algorithm handle powerful planning formalisms containing conditional
effects  so  answers give open problems field planning algorithm
design  first all  gazen knoblock s        approach compiling conditional effects away
optimal want allow plan growth constant factor  secondly 
approaches  anderson et al         kambhampati et al         koehler et al        
modify graphplan algorithm using strategy similar polynomial time compilation
scheme preserving plan size polynomially  reason  approaches compared
pure compilation approach using ideas compilation scheme developed
proof theorem    base line  thirdly  allowing unrestricted boolean formulae adds
level expressivity cannot compiled away linear growth plan
size  fact  approaches one anderson colleagues        simply expand
formulae dnf accepting exponential blow up  again  cannot better plan
size preserved linearly  fourthly  want add partial state specifications top
general boolean formulae  would amount increase expressivity much larger
   

fic ompilability



e xpressive p ower p lanning f ormalisms

adding conditional effects general formulae basic strips  case way
compile away even allow polynomial plan growth 
finally  one may wonder results apply planning approaches based translating  bounded  planning problems propositional logic satplan  kautz   selman       
blackbox  kautz   selman         since entire analysis relative expressiveness
planning formalisms uses assumption compile one planning formalism another
planning formalism  results tell us anything size representations switch
another formalism  particular  seems possible find encoding  bounded  planning
problems conditional operators propositional logic concise encoding
unconditional operators  advice results give concise encoding
found first translating conditional actions unconditional actions using standard encoding unconditional actions  kautz  mcallester    selman        generate boolean
formulae  however  addressing problem determining conciseness representation
context appears interesting relevant topic future research 

acknowledgments
research reported paper started partly carried author enjoyed
visitor ai department university new south wales  many thanks go norman
foo  maurice pagnucco  abhaya nayak rest ai department discussions
cappuccinos  would thank birgitt jenner jacobo toran clarifications
concerning circuit complexity 

appendix a  symbol index
symbol

explanation
cardinality set
size instance
symbol used conditional effects

syntactic specialization relation

compilability relation restriction

boolean constant denoting falsity  denoting

illegal state specification

    boolean constant denoting truth

    advice function
lff ll
        
active effects operator state state specification
ac
    complexity class

    boolean circuit
    family boolean circuits

conp
    complexity class
conp poly     non uniform conp
closing set literals w r t 
     ll    

    plan  i e   sequence operators
    complexity class polynomial hierarchy


    instance problem

 l 
v    l   

page
   
   
   
   
   
   

   

fin ebel





  ffe ffe 
u


f ffeff


 ff b

e ghll
nc
     
np
np poly

l




  ffi ff ff  ff
l 

p
p poly
ph

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

   
   
   
   
 ll
planex
   
post
   
pre
   

pspace
   

   
   

   
lff ll
  t lff ll    
c
   

   

   
   

 
   
   
 

   
 
   
   



   

  
   

   

initial state description
compilation scheme     n  ffe ffe qff ffz p  
transformation induced compilation scheme
components compilation scheme
goal planning task
set boolean formulae
boolean formulae
literal
sets literals
boolean formulae use atoms
set models theory
complexity class
negative literals set literals
complexity class
non uniform np
operator     n pre post p  
set operators
set finite sequences operators
propositional atoms
potentially active effects operator
given state specification
complexity class
non uniform p
polynomial hierarchy
positive literals set literals
plan existence problem
postconditions operator
preconditions operator
complexity class
planning instance    on ffifft p  
complexity class polynomial hierarchy
maps state specification operator new state
extension lff ll plans
state  or truth assignment 
state specification
strips planning formalism
strips literals preconditions
strips boolean formulae preconditions
strips incomplete state descriptions
strips conditional effects
strips combinations extensions
equivalence classes induced
equivalence classes induced
propositional atoms used set literals
countably infinite set propositional atoms
   

fic ompilability







r


ffz



x

 




   
   
   
   
   
   
   
   
   
   



e xpressive p ower p lanning f ormalisms

finite subset
set literals overs
complexity class polynomial hierarchy
state translation functions compilation scheme
universal literals
word   ff   t
complexity class
planning formalisms
domain structure    on fftp  
family domain structures

references
anderson  c  r   smith  d  e     weld  d  s          conditional effects graphplan  proceedings  th international conference artificial intelligence planning systems  aips     pp        aaai press  menlo park 
baader  f          formal definition expressive power knowledge representation languages 
proceedings  th european conference artificial intelligence  ecai     stockholm  sweden  pitman 
backstrom  c          expressive equivalence planning formalisms  artificial intelligence      
         
backstrom  c     nebel  b          complexity results sas planning  computational intelligence                
blum  a  l     furst  m  l          fast planning planning graph analysis  artificial
intelligence                  
brewka  g     hertzberg  j          things worlds  formalizing actions
plans   journal logic computation               
bylander  t          computational complexity propositional strips planning  artificial
intelligence                 
cadoli  m     donini  f  m          survey knowledge compilation  ai communications 
                
cadoli  m   donini  f  m   liberatore  p     schaerf  m          comparing space efficiency
propositional knowledge representation formalism  aiello  l  c   doyle  j     shapiro 
s   eds    principles knowledge representation reasoning  proceedings  th
international conference  kr      pp         cambridge  ma  morgan kaufmann 
erol  k   hendler  j  a     nau  d  s          htn planning  complexity expressivity 
proceedings   th national conference american association artificial intelligence  aaai      pp           seattle  wa  mit press 
   

fin ebel

erol  k   hendler  j  a     nau  d  s          complexity results hierarchical task network
planning  annals mathematics artificial intelligence           
fikes  r  e     nilsson  n          strips  new approach application theorem proving
problem solving  artificial intelligence            
furst  m   saxe  j  b     sipser  m          parity  circuits  polynomial time hierarchy 
mathematical systems theory              
garey  m  r     johnson  d  s          computers intractabilitya guide theory
np completeness  freeman  san francisco  ca 
gazen  b  c     knoblock  c          combining expressiveness ucpop efficiency
graphplan  steel  s     alami  r   eds    recent advances ai planning   th european
conference planning  ecp      vol       lecture notes artificial intelligence  pp 
       toulouse  france  springer verlag 
gogic  g   kautz  h  a   papadimitriou  c  h     selman  b          comparative linguistics
knowledge representation  proceedings   th international joint conference
artificial intelligence  ijcai      pp         montreal  canada  morgan kaufmann 
kambhampati  s   parker  e     lambrecht  e          understanding extending graphplan 
steel  s     alami  r   eds    recent advances ai planning   th european conference
planning  ecp      vol       lecture notes artificial intelligence  pp        
toulouse  france  springer verlag 
karp  r  m     lipton  r  j         
mathematique             

turing machines take advice 

l  ensignement

kautz  h  a   mcallester  d  a     selman  b          encoding plans propositional logic 
aiello  l  c   doyle  j     shapiro  s   eds    principles knowledge representation
reasoning  proceedings  th international conference  kr      pp         cambridge  ma  morgan kaufmann 
kautz  h  a     selman  b          forming concepts fast inference   proceedings
  th national conference american association artificial intelligence  aaai     
pp         san jose  ca  mit press 
kautz  h  a     selman  b          pushing envelope  planning  propositional logic 
stochastic search  proceedings   th national conference american association artificial intelligence  aaai      pp            mit press 
kautz  h  a     selman  b          blackbox  new approach application theorem
proving problem solving  working notes aips    workshop planning
combinatorial search pittsburgh  pa 
koehler  j   nebel  b   hoffmann  j     dimopoulos  y          extending planning graphs
adl subset  steel  s     alami  r   eds    recent advances ai planning   th european
conference planning  ecp      vol       lecture notes artificial intelligence  pp 
       toulouse  france  springer verlag 
   

fic ompilability



e xpressive p ower p lanning f ormalisms

lifschitz  v          semantics strips  georgeff  m  p     lansky  a   eds    reasoning actions plans  proceedings      workshop  pp     timberline  or 
morgan kaufmann 
nebel  b          expressive power disjunctive preconditions   biundo  s     fox 
m   eds    recent advances ai planning   th european conference planning  ecp    
durham  uk  springer verlag  appear 
papadimitriou  c  h          computational complexity  addison wesley  reading  ma 
pednault  e  p          adl  exploring middle ground strips situation
calculus  brachman  r   levesque  h  j     reiter  r   eds    principles knowledge
representation reasoning  proceedings  st international conference  kr     
pp         toronto  on  morgan kaufmann 
yap  c  k          consequences non uniform conditions uniform classes  theoretical
computer science             

   


