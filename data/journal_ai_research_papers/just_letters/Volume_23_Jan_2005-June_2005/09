journal artificial intelligence research                  

submitted        published      

practical use variable elimination constraint
optimization problems  still life case study
javier larrosa
enric morancho
david niso

larrosa lsi upc edu
enricm ac upc edu
niso   casal upc edu

universitat politecnica de catalunya
jordi girona            barcelona  spain

abstract
variable elimination general technique constraint processing  often discarded high space complexity  however  extremely useful
combined techniques  paper study applicability variable elimination challenging problem finding still lifes  illustrate several alternatives 
variable elimination stand alone algorithm  interleaved search  source
good quality lower bounds  show techniques best known option
theoretically empirically  experiments able solve n     
instance  far beyond reach alternative approaches 

   introduction
many problems arising domains resource allocation  cabon  de givry  lobjois 
schiex    warners         combinatorial auctions  sandholm         bioinformatics
probabilistic reasoning  pearl        naturally modeled constraint satisfaction
optimization problems  two main solving schemas search inference  search
algorithms constitute usual solving approach  transform problem set
subproblems selecting one variable instantiating different alternatives 
subproblems solved applying recursively transformation rule  recursion
defines search tree normally traversed depth first manner 
benefit requiring polynomial space  practical efficiency search algorithms
greatly depends ability detect prune redundant subtrees  worst case 
search algorithms need explore whole search tree  nevertheless  pruning techniques
make much effective 
inference algorithms  also known decomposition methods  solve problem sequence transformations reduce problem size  preserving optimal cost 
well known example bucket elimination  be  known variable elimination   bertele
  brioschi        dechter         algorithm proceeds selecting one variable
time replacing new constraint summarizes effect chosen variable  main drawback new constraints may large arities require
exponentially time space process store  however  nice property
worst case time space complexities tightly bounded structural parameter called induced width  exponential space complexity limits severely algorithms
c
    
ai access foundation  rights reserved 

filarrosa  morancho   niso

practical usefulness  thus  constraint satisfaction community variable elimination
often disregarded 
paper consider challenging problem finding still lifes stable
patterns maximum density game life  academic problem recently
included csplib repository  dedicated web page  set maintain
up to date results  bosch trick         still life problem solved using two
different approaches  integer programming constraint programming  based
search  none could solve n     problem within reasonable time 
best results obtained hybrid approach combines two techniques
exploits problem symmetries order reduce search space  algorithm 
solved n      case   days cpu  smith        proposed interesting
alternative using pure constraint programming techniques  solving problem
dual form  work  smith could improve n      limit  although explicitly
 
mentioned  two works use algorithms worst case time complexity o   n     
paper show usefulness variable elimination techniques  first apply
plain be  could expected  observe competitive stateof the art alternatives  next  introduce sophisticated algorithm combines
search variable elimination  following ideas larrosa   dechter        uses
lower bound based mini buckets  following ideas kask   dechter        
algorithm  solve one minute n      instance  able solve
n      instance  far beyond reach previous techniques  readability
reasons  describe main ideas omit algorithmic details  
structure paper following  next section give preliminary
definitions  section   solve problem plain be  section   introduce
hybrid algorithm obtained results reported section    section  
discuss ideas explored article extended domains  besides 
report additional experimental results  finally  section   gives conclusions
lines future work 

   preliminaries
section first define still life problem  next  define weighted csp
framework formulate still life weighted csp  finally  review main
solving techniques weighted csps 
    life still life
game life  gardner        played infinite checkerboard  square
called cell  cell eight neighbors  eight cells share one two corners
it  player places checkers cells  checker it  cell
alive  else dead  state board evolves iteratively according following
three rules      cell exactly two living neighbors state remains
   www csplib org
   www ai sri com   nysmith life
   interested reader find extended version  along source code implementation
www lsi upc edu   larrosa publications

   

fion practical use variable elimination

 

 

 

 

 

 

 

xc

 

 



 

 

b

 



c

e

figure    a      still life  b  constraint graph simple wcsp instance four
variables three cost functions  c  constraint graph assigning variable
x    d  constraint graph clustering variables x  x    e  constraint
graph eliminating variable x   

next iteration      cell exactly three living neighbors alive
next iteration     cell fewer two three living neighbors 
dead next iteration  although defined terms extremely simple rules 
game life proven mathematically rich attracted interest
mathematicians computer scientists 
still life problem sl n  consist finding nn stable pattern maximum density
game life  cells outside pattern assumed dead  considering
rules game  easy see cell  i  j  must satisfy following three
conditions      cell alive  must exactly two three living neighbors     
cell dead  must three living neighbors      cell grid
boundary  i e        n j     j   n   cannot part sequence three
consecutive living cells along boundary  last condition needed three
consecutive living cells boundary would produce living cells outside grid 
example   figure   a shows solution sl     easy verify cells
satisfy previous conditions  hence stable  pattern optimal  
living cells     stable pattern   living cells exists 

    weighted csp
weighted constraint satisfaction problem  wcsp   bistarelli  montanari    rossi       
defined tuple  x  d  f   x    x            xn   set variables taking values
finite domains di d  f set weighted constraints  i e   cost functions  
f f defined subset variables  var f    called scope  objective
function sum functions f 
f  

x

f

f f

goal find instantiation variables minimizes objective function 
example   consider wcsp four variables x    xi   i   domains di         
three cost functions  f   x    x      x    x    f   x    x      x  x  f   x    x      x    x   
   

filarrosa  morancho   niso

objective function f  x    x    x    x      x    x    x  x    x    x    clearly  optimal
cost    obtained every variable taking value   
constraints given explicitly means tables  implicitly mathematical
expressions computing procedures  infeasible partial assignments specified constraints assign cost them  assignment value variable xi noted
xi   a  partial assignment tuple    xi    v    xi    v      xij   vj    extension
xi   noted  xi   a   wcsps instances graphically depicted means
interaction constraint graph  one node per variable one edge connecting two nodes appear scope cost function  instance 
figure   b shows constraint graph problem previous example 
    overview solving techniques
subsection review solving techniques widely used reasoning
constraints 
      search
wcsps typically solved depth first search  search algorithms defined
terms instantiating functions 
definition   let p    x  d  f  wcsp instance  f function f  xi variable
var f    v value di   instantiating f xi   v new function scope
var f    xi   returns tuple t  f  t  xi   v    instantiating p xi   v
new problem p  xi  v    x  xi     di    f      f   obtained instantiating
functions f mention xi xi   v 
instance  instantiating problem example   x       produces new
problem three variables  xi   i   three cost functions  f   x    x         x      
f   x    x      x  x  f   x    x         x       figure   c shows corresponding
constraint graph  obtained original graph removing instantiated variable x 
adjacent edges  observe new graph depends instantiated variable 
depend value assigned it 
search algorithms transform current problem p set subproblems  usually
done selecting one variable xi instantiated different domain values
 p  xi  v    p  xi  v      p  xi  vd    transformation called branching  subproblem process recursively applied  defines tree subproblems  search
algorithms expand subproblems trivial case achieved  variable left 
pruning condition detected  optimization problems  pruning conditions usually
defined terms lower upper bounds  search keeps cost best solution
far  upper bound optimal cost  node  lower bound best
cost obtainable underneath computed  lower bound greater equal
upper bound  safe backtrack 
size search tree o dn    being size largest domain  bounds
time complexity  tree traversed depth first  space complexity polynomial 
   

fion practical use variable elimination

      clustering
well known technique constraint processing clustering  dechter   pearl        
merges several variables one meta variable  preserving problem semantics 
clustering variables xi xj produces meta variable xk   whose domain di dj   cost
functions must accordingly clustered  instance  problem example    clustering variables x  x  produces variable xc domain dc                                    
cost functions f  f  clustered fc  x    xc     f    f    new variable
notation fc   x  xc       x    xc      xc  i  denotes i th component xc   function
f  needs reformulated f   x    xc     x    xc      constraint graph resulting
problem obtained merging clustered variables connecting meta node
nodes adjacent clustered variables  figure   d shows constraint graph clustering x  x    typical use clustering transform
cyclic constraint graph acyclic one  solved efficiently thereafter 
      variable elimination
variable elimination based following two operations 
definition   sum two functions f g  noted  f   g   new function
scope var f   var g  returns tuple sum costs f g 
 f   g  t    f  t    g t 
definition   elimination variable xi f   noted f xi   new function
scope var f    xi   returns tuple cost best extension xi  
 f xi   t    min  f  t  xi   a   
adi

observe f unary function  i e   arity one   eliminating variable
scope produces constant 
definition   let p    x  d  f  wcsp instance  let xi x arbitrary variable
let bi set cost functions xi scope  bi called bucket
xi    define gi
x
gi    
f   xi
f bi

elimination xi transforms p new problem p xi    x  xi     di     f
bi    gi     words  p xi obtained replacing xi functions bucket
gi  
p p xi optimal cost because  construction  gi compensates
absence xi   constraint graph p xi obtained forming clique
nodes adjacent node xi removing xi adjacent edges  example 
eliminating x  problem example   produces new problem three variables
 xi   i   two cost functions  f  g    scope g   x    x    defined as 
   

filarrosa  morancho   niso

g     f    f    x     x    x    x    x    x    x    x    figure   d shows constraint
graph elimination 
previous example  new function g  could expressed mathematical expression  unfortunately  general  result summing functions eliminating variables
cannot expressed intensionally  new cost functions must stored extensionally
tables  consequently  space complexity computing p xi proportional numq
ber entries gi   is    xj var gi    dj     since xj var gi   iff xj adjacent xi
q
constraint graph  previous expression rewritten   xj n  i gp    dj    
gp constraint graph p n  i  gp   set neighbors xi gp  
time complexity computing p xi space complexity multiplied cost
computing entry gi  
bucket elimination  be  works two phases  first phase  eliminates variables
one time reverse order  elimination xi   new gi function computed
added corresponding bucket  elimination x  produces empty scope
function  i e   constant  optimal cost problem  second phase 
considers variables increasing order generates optimal assignment variables 
time space complexity exponential structural parameter
constraint graph  called induced width  captures maximum arity among
gi functions  without additional overhead compute number optimal
solutions  see dechter        details  
      super buckets
cases  may convenient eliminate set variables simultaneously  dechter
  fatah         elimination set variables performed collecting
set functions mentioning least one variable   variables functions
replaced new function gy defined as 
gy    

x

f 

f

set called super bucket  note elimination seen
clustering variables meta variable xy followed elimination 
      mini buckets
space complexity high  approximation  called mini buckets
 dechter   rish         used  consider elimination xi   associated
bucket bi    fi            fik    would compute 
gi    

x

f   xi

f bi

time space complexity computation depends arity gi   beyond
available resources  partition bucket bi so called mini buckets bi            bik
number variables scopes mini bucket bounded parameter 
compute 
x
gij    
f   xi   j      k
f bij

   

fion practical use variable elimination

 

 

 

 

 

 
 
 

 
 

 

 

 

 

 

 

 
 

 

 

 

 

 

 

 

 

 

 
 

 



b

c



figure    constraint graph evolution sequence variable eliminations
instantiations 

gij bounded arity  since 
gij

gi

zx   

 

f bi

 

f   xi

k z x   
x

 

 

f   xi

j   f bij

elimination variables using mini buckets yields lower bound actual optimal
cost 
      combining search variable elimination
plain costly space  combine search  larrosa   dechter 
       consider wcsp whose constraint graph depicted figure   a  suppose
want eliminate variable want compute store constraints
arity higher two  take consideration variables connected
two variables  example  variable x  one selected 
elimination transforms problem another one whose constraint graph depicted
figure   b  x  degree decreased two  eliminated 
new constraint graph depicted figure   c  point  every variable degree
greater two  switch search schema selects variable  say x    branches
values produces set subproblems  one value domain 
constraint graph  depicted figure   d  subproblem 
possible eliminate variable x  x    elimination possible eliminate
x  x    subsequently x  x    eliminations branching done
every subproblem since new constraints eliminated variables replaced
differ one subproblem another  example  one branching made 
therefore  elimination variables reduced search tree size d  d 
size domains  example  bounded arity new constraints
two  generalized arbitrary value 

   solving still life variable elimination
sl n  easily formulated wcsp  natural formulation associates one
variable xij cell  i  j   variable two domain values  xij     cell
   

filarrosa  morancho   niso

x 
j  

j  

j

 

j  

j  

x 

 

x 



x 

i  

x 

  

x 

b



figure    a  structure constraint graph sl n   node center  associated
cell  i  j   linked cells interacts with  shadowed area indicates
scope fij   b  left   constraint graph sl    clustering cells
row variables  b  from left right  evolution constraint graph
execution be 

dead  xij     alive  cost function fij variable xij   scope
fij xij neighbors  evaluates stability xij   xij unstable given
neighbors  fij returns   else fij returns   xij    objective function minimized
is 
f  

n x
n
x

fij

i   j  

instantiation x represents unstable pattern  f  x  returns   else returns
number dead cells  fij stored table    entries evaluated constant
time 
figure   a illustrates structure constraint graph sl n   picture shows
arbitrary node xij linked nodes interacts with  instance  edge
xij xi j   xi j   neighbor xij grid and  consequently 
variables scope fij   edge xij xi  j 
cells neighbors xi  j  grid and  therefore  appear scope
fi  j    shadowed area represents scope fij  namely  xij neighbors  
complete graph obtained extending connectivity pattern nodes
graph 
sake clarity  use equivalent compact sl n  formulation
makes easier describe implement  cluster variables row
single meta variable  thus  xi denotes state cells i th row  namely 
xi    xi    xi            xin   xij          accordingly  takes values sequences
n bits or  equivalently  natural numbers interval      n     cost functions
accordingly clustered  cost function associated row i  defined as 
 

n
x

fij

j  

   recall that  wcsp  task minimize number dead cells  therefore  give cost  
dead cells cost   living cells 

   

fion practical use variable elimination

internal rows  scope  xi    xi   xi      cost function top row  f   
scope  x    x     cost function bottom row  fn   scope  xn    xn   
unstable cell xi    xi    xi   xi         else  returns number dead cells
xi   evaluating  n  bits arguments need checked 
new  equivalent  objective function is 
f  

n
x



i  

figure   b  left  shows constraint graph sl    formulation  arbitrary
variable xi connected two variables two variables below 
sequential structure constraint graph makes intuitive  eliminates variables
decreasing orders  elimination xi produces new function gi    fi    gi     xi
scope  xi    xi     figure   b  from left right  shows evolution constraint
graph along elimination variables  formally  applies recursion transforms
subproblem p p xi   xi variable p highest index  satisfies
following property 
property   let gi function added replace xi   gi  a  b  cost
best extension  xi    a  xi    b  eliminated variables  xi           xn    formally 
gi  a  b   

min

vi di      vn dn

 fi   a  b  vi      b  vi   vi      

 fi    vi   vi     vi            
 fn   vn    vn    vn     fn  vn    vn   
gi  a  b      means pattern a  b cannot extended inferior rows
stable pattern  gi  a  b    k  with k       means a  b extended
optimal extension k dead cells xi  xn  
space complexity  n   n    due space required store n functions
gi extensionally   n  n entries each   regarding time  computing entry gi
cost  n  n    finding minimum  n alternatives  computation one
 n    since gi   n entries  total time complexity  n    n    observe
solving sl n  exponential improvement search algorithms 
 
time complexity o  n   
table   reports empirical results  obtained   ghz pentium iv
machine   gb memory  first columns reports problem size  second
reports optimal cost number dead cells  in parenthesis  number living
cells   third column reports number optimal solutions  count different
two solutions even one transformed problem symmetry 
fourth column reports cpu time seconds  fifth  sixth seventh
columns report results obtained three approaches tried bosch trick
         constraint programming  cp   integer programming  ip   sophisticated
algorithm  cp ip  combines cp ip  exploits problem symmetries 
   corresponding opl code available http   mat gsia cmu edu life 

   

filarrosa  morancho   niso

n
 
 
 
 
 
  
  
  
  
  
  

opt
     
      
      
      
      
      
      
      
      
       
        

n  sol 
 
  
 
 
  
    
  
      
    
  
 


 
 
 
 
 
  
   
    
     
   
 

cp
 
 
 
  
     
 
 
 
 
 
 

ip
 
 
 
  
     
 
 
 
 
 
 

cp ip
 
 
 
 
  
  
   
     
     
     
     

figure    experimental results four different algorithms still life problem  times
seconds 

observed clearly outperforms cp ip orders magnitude 
n      case largest instance could solve due exhausting available
space  comparing cp ip  observe clear winner  additional
observation scales regularly  execution requiring roughly eight times
time four times space previous  clear accordance
algorithm complexity 

   combining search variable elimination
one way overcome high space complexity combine search variable
elimination hybrid approach hyb  larrosa   schiex         idea use search
 i e  instantiations  order break problem independent smaller parts
variable elimination efficiently performed 
let us reformulate problem convenient way hybrid algorithm 
sake simplicity without loss generality consider n even  cluster
r
row variables three meta variables  xc
denotes two central cells row i  xi
n
l
xi denote     remaining cells right left  respectively  see figure   a  
l
r
consequently  xc
takes values range         xi xi take values range
n
 
            cost functions accordingly clustered 
n

fil

 

 
x

fir  

fij  

n
x
j  n
  
 

j  

new  equivalent  objective function is 
f  

n
x

 fil   fir  

i  

   

fij

fion practical use variable elimination

left

x

l
 

center

x

c
 

right

x

left

r
 

center

right

x 

x 

x 
x

l


x

c


x

r


x 

x

l
n

x

c
n

x

x 

r
n

x 

b


left

center

right

left

center

right

x 
x 
x 
x 
x 
x 
x 
x 
x 
x 
x 
x 
c



figure    formulation sl n  used hybrid algorithm  a  row clustered
three variables  b  constraint graph sl     c  constraint graph
c
c
assignment xc
n   xn  xn    d  constraint graph elimination
l
r
xn xn  

   

filarrosa  morancho   niso

c
l c
l
c
scopes internal row functions  fil fir    xl
i    xi    xi   xi   xi     xi    
c
r
c
r
c
r
l
r
l
c
c
 xi    xi    xi   xi   xi     xi      top functions f  f  scopes  x    x    xl
    x   
r c
r
l
r
l
c
l c
 xc
    x    x    x     bottom functions fn fn scopes  xn    xn    xn   xn  
r
c
r
c
 xn    xn    xn   xn    figure   b shows corresponding constraint graph  imporr
tance formulation xl
xi independent  i e  edge
constraint graph connecting left right variables  

hybrid algorithm hyb searches central variables eliminates lateral
variables  variables considered decreasing order index  thus  algorithm
c
c
starts instantiating xc
n   xn  xn    produces subproblem constraint
r
graph shown figure   c  observe variable xl
n  respectively  xn   connected
l
l
r
r
variables xn  xn   respectively  xn  xn     eliminated producing
l
r
r
r
new function gnl scope  xl
n    xn     respectively  gn scope  xn    xn     
figure   d shows resulting constraint graph  lateral variables domains size
n
n
        hence  elimination space   n   time          important note
c
c
eliminations subject current assignment xc
n   xn  xn    therefore 
recomputed value change  elimination xl
n
c
xr
 

algorithm
would
assign
variable
x


make
possible

elimination

n
n 
l
r
c
xn  xn    on  arbitrary level search  algorithm assigns xi  
r
makes xl
i   xi   independent central columns related two
l
variables above  then  eliminates replacing variables functions gi  
r scopes  xl   xl    xr   xr    respectively  formally  hyb applies recursion
gi  

i  

i  
transforms subproblem p   simpler subproblems    p  xc  v   xl   xr   v    

i  
i  
satisfies following property 

property   let gil function computed hyb used replace variable xl
 
l
gil  a  b  cost best extension  xl
 
a 
x
 
b 

eliminated
variables
i 
i 
l
r
 xl
          xn    conditioned current assignment  similarly  right side  gi  a  b 
r
r
r
cost best extension  xi    a  xi    b  eliminated variables  xi           xr
n   
conditioned current assignment 

l  a  b  among coma consequence previous property minimum gi  
binations b lower bound best cost obtained left
l  a  b    
part grid continue current line search  therefore  mina b  gi  
r
mina b  gi    a  b   valid lower bound current node used pruning
purposes 

space complexity algorithm  n  n    due gil gir functions
need explicitly stored  time complexity o n     n    o  n  
nodes may visited  n variables domains size    cost processing
n
node  n        due variable eliminations 
thus  comparing be  time complexity increases  n    n   o n    n   
prize hyb pays space decrement  n   n    n  n   
   

fion practical use variable elimination

    refining lower bound
well known average case efficiency search algorithms depends greatly
lower bound use  algorithm using poor lower bound based gil
gir functions  only 
kask dechter        proposed general method incorporate information
yet unprocessed variables lower bound  roughly  idea run mini buckets
 mb  prior search save intermediate functions future use  mb executed using
reverse order search instantiate variables  execution mb
completed  search algorithm executed  node  uses mini bucket functions
compiled look ahead information  subsection  show adapted
idea sl n  integrated hyb 
c
r
consider sl n  formulated terms left  central right variables  xl
  xi   xi   
l
c
r
exact elimination first row variables  x    x    x    done using super bucket
b     f l   f r   f l   f r   computing function 
c
r
h     f l   f r   f l   f r    xl
    x    x   
c
r l c
r
scope h   xl
    x    x    x    x    x     using mini buckets idea  partition
l
l
l
r
bucket b     f    f    b     f r   f r    then  approximate h  two smaller
r
functions hl
  h   
l
l
l c
hl
     f    f     x    x   
r
r
c
r
hr
     f    f     x    x   
r
l c
l c
c
r c
r
scopes hl
  h   x    x    x    x     x    x    x    x     respectively 
idea repeated row row increasing order  general  processing row i  yields two
functions 
l
l
l c
hl
   hi    fi      xi   xi  
r
r
c
r
hr
   hi    fi      xi   xi  
r
l
c
l
c
c
r
c
r
scopes hl
hi  xi     xi     xi     xi      xi     xi     xi     xi      respecl
 
 
tively  construction  hi  a    b  b   contains cost best extension a  a    b  b 
c
l c
processed variables xl
  xi           x    x  considering left functions only 
 
 
property hr
 a   a  b   b  right functions 
complexity mb space  n n   time  n      n    since complexities
smaller complexity hyb  running pre process affect overall
complexity 
r
mb executed  hyb use information recorded hl
hi functions 
l
r
consider arbitrary node hyb assigns xc
eliminates xi   xi     let
l
l
l  a  b 
b domain values variables xi xi     property   gi  
contains best extension a  b attained left part rows    
n long current assignment x c maintained  additionally 
c
c
hl
i   a  xi   b  xi     contains best extension a  b attained left part
l  a  b    hl  a  xc   b  xc   lower bound a  b x c
rows    therefore  gi  
i 

i  
left part grid  consequently 
l
c
c
mina b      n        gi  
 a  b    hl
i   a  xi   b  xi     

   

filarrosa  morancho   niso

lower bound left part grid current assignment 
reasoning right part that 
l
c
c
mina b      n        gi  
 a  b    hl
i   a  xi   b  xi       
r
c
c
 mina b      n        gi  
 a  b    hr
i   xi   a  xi     b  

lower bound current assignment 
    refining upper bound
efficiency algorithm depends initial value upper bound 
good upper bound facilitates pruning earlier search tree  bosch trick       
suggested modify sl n  adding additional constraint considering symmetric
patterns  only  since space solutions becomes considerably smaller  problem
presumably simpler  clearly  cost optimal symmetric stable pattern upper
bound optimal cost sl n   observed upper bounds
tight 
since motivation work use variable elimination techniques 
considered still lifes symmetric vertical reflection 
efficiently solved using be  symmetric still life problem ssl n  consists finding
n n stable pattern maximum density game life subject vertical reflection
symmetry  namely  state cells  i  j   i  n j      must same  
adapting solve ssl n  extremely simple  need remove symmetrical
values domains  let us assume n even number  the odd case similar  
represent symmetric sequences bits length n considering left side
sequence  i e  first n   bits   right part implicit left part  thus 
n
represent symmetrical sequences n bits integers interval             reversing
sequence bits noted a  hence  sequence n   bits  corresponding
symmetrical sequence n bits 
complexity be  applied ssl n  time  n      n   space  n n   
therefore  executing prior hyb setting upper bound optimal cost
affect overall complexity hybrid 
    exploitation symmetries
sl n  highly symmetric problem  stable pattern  possible create
equivalent pattern by   i  rotating board             degrees   ii  reflecting
board horizontally  vertically along one diagonal  iii  combination
rotations reflections 
symmetries exploited different algorithmic levels  general 
save computation whose outcome equivalent previous computation due
symmetry kept outcome  instance  mb necessary compute
 
 
l
 
 
hr
 a   a  b   b  equal hi  a    b  b   due vertical reflection symmetry 
c
c
another example occurs hyb  let xn   vn   xc
n    vn            xi   vi current
   unlike smiths        work cannot easily exploit larger variety symmetries rotations
diagonal reflections 

   

fion practical use variable elimination

n
  
  
  
  
  
  
  
  
  
  
  
  

opt
      
       
        
        
        
        
        
        
 
 
 
 

opt ssl
  
  
   
   
   
   
   
   
   
   
   
   

cp ip
     
     
     
 
 
 
 
 
 
 
 
 


     
   
 
 
 
 
 
 
 
 
 
 

hyb
 
 
  
 
    
    
     
     
 
 
 
 

hyb lb
    
    
     
     
 
 
 
 
 
 
 
 

hyb ub
 
 
  
  
    
    
     
     
 
 
 
 

figure    experimental results three different algorithms still life problem  times
seconds 

c
c
assignment  reversed assignment xc
n   vn   xn    vn            xi   vi equivalent due
vertical reflection symmetry  thus  already considered  algorithm
backtrack  implementation uses tricks others
report would require much lower level description algorithms 

   experimental results
figure   shows empirical performance hybrid algorithm  first column contains
problem size  second column contains optimal value number dead
cells  in parenthesis corresponding number living cells   third column contains
optimal value symmetrical problem ssl n   obtained executing be 
observed ssl n  provides tight upper bounds sl n   fourth column
reports time obtained cp ip algorithm  bosch   trick         fifth
column reports times obtained be  sixth column contains times obtained
hybrid algorithm hyb  seen  performance hyb spectacular 
n      n      instances  require several days cpu  solved hyb
seconds  instances n      solved less one hour  largest instance
solve n       requires two days cpu  figure   shows optimal
n      n      still lifes   regarding space  computer handle executions
hyb n       however  neither n      n      instance could solved
within week cpu  may seem solving n      instance petty progress
respect previous results problem  clearly case  search space
 
 
n      n      instances size                         respectively  thus 
able solve problem search space      times larger before 
since scales regularly  accurately predict would require      gb
memory   centuries solve n      instance 
   

filarrosa  morancho   niso

figure    maximum density still lifes n      n      

since hyb combines several techniques  interesting assess impact
one  seventh column reports times obtained hyb without using mini buckets
information lower bound  seen  algorithm still better plain be 
performance dramatically affected  information gathered preprocess
improves quality lower bound anticipates pruning  finally  eighth column
reports times obtained hyb without upper bound initialized ssl n  
case see importance technique quite limited  reason
hyb  even bad initial upper bound  finds optimum rapidly and 
moment  quality initial upper bound becomes irrelevant 

   extension domains
sl n  problem well defined structure  hybrid algorithm
proposed makes ad hoc exploitation it  easy find right variables
instantiate eliminate  easy find variable order mini buckets
produces good quality lower bounds  natural question whether possible apply
similar ideas well structured problems  answer often possible 
although need rely naive consequently less efficient exploitation
problems structure  section support claim reporting additional experimental results different benchmarks  particular  consider spot  dimacs
instances  spot  instances optimization problems taken scheduling earth
observation satellite  bensana  lemaitre    verfaillie         dimacs benchmark contains sat instances several domain  since concerned optimization tasks 
selected unsatisfiable instances solved max sat task  i e  given
unsatisfiable sat instance  find maximum number clauses simultaneously
satisfied   modeled wcsp  de givry  larrosa  meseguer    schiex        
consider aim instances  artificially generated random   sat   pret  graph coloring   ssa
bf  circuit fault analysis  
figure   shows constraint graph one instance domain  visualized
leda graph editor  observed graphs obvious pattern
   

fion practical use variable elimination

figure    constraint graph four wcsp instances  top left corner  clockwise 
aim         no    pret       ssa         spot      

exploited  thus  use variable elimination techniques naive way 
solve problems generic wcsp solver toolbar   tb   performs depthfirst branch and bound search enhanced general purpose dynamic variable
value ordering heuristics  modified toolbar combine search variable elimination
follows  arbitrary subproblem  every variable degree less   eliminated 
variables degree larger equal    unassigned variable
heuristically selected domain values heuristically ordered sequentially
instantiated  process recursively applied subproblems  note
generic version hyb algorithm decision variables
instantiated variables eliminated left heuristic  instead establishing
   available http   carlit toulouse inra fr cgi bin awki cgi softcsp 

   

filarrosa  morancho   niso

hand  refer implementation tbhy b   toolbar offers variety
lower bounds based different forms local consistency  larrosa   schiex        
one them  directional arc consistency  dac    essentially equivalent mini buckets
size   and  therefore  similar spirit lower bound computed hyb  however 
unlike hyb mini buckets executed pre process  toolbar executes
dac  every search state  subject current subproblem  shown kask
       approach generally efficient  main difference respect
hyb  toolbar executes dac  subject arbitrary variable ordering  in hyb
good order identified problem structure   lower bounds available
toolbar node consistency  nc   weaker dac   full directional
arc consistency  fdac   seen  stronger  refinement dac  
f dac
b
experimented four algorithms  tbn c   tbdac   tbdac
hy b tbhy b  
denotes algorithm lower bound b 
spot  instances difficult toolbar  therefore  decreased size
letting toolbar make sequence k greedy assignments driven default variable
value ordering heuristics  result subproblem k less variables 
following  ik denotes instance k variables greedily assigned toolbar
default parameters 
table   reports result experiments  first column indicates instances
subsequent columns indicate cpu time  in seconds  required different algorithms  time limit      seconds set execution  observed
toolbar weakest lower bound  tbn c   usually inefficient alternative 
cannot solve spot  instances fails several aim ssa instances 
toolbar enhanced mini buckets lower bound  tbdac   spot  problems
solved  domains  new lower bound produce significant effect  add variable elimination  tbdac
hy b   problems solved 
general  clear speed up  worst improvements pret instances
time divided factor   best ones obtained spot       
ssa         instances solved instantly  typical speed ups range      
dac   limited
finally  observe addition stronger lower bound  tbfhy
b
effect problems  execution instance ssa         clearly accelerated 
therefore  experiments conclude main techniques used
solve still life problem successfully applied domains 

   conclusions
paper studied applicability variable elimination problem
finding still lifes  finding still lifes challenging problem developing new solving
techniques interesting task per se  thus  first contribution paper
observation plain variable elimination  i e  be  competitive practice provides
time complexity exponentially better search based approaches  besides  developed algorithm able solve n      instance 
clearly improved previous results  second contribution paper
deeper insight  algorithm uses recent techniques based variable elimination 
since techniques little known rarely applied constraints community 
   

fion practical use variable elimination

problem
spot      
spot        
spot        
spot        
spot       
spot        
spot        
spot        
aim         no  
aim         no  
aim         no  
aim         no  
aim         no  
aim         no  
aim         no  
aim         no  
bf        
pret     
pret     
ssa        
ssa        
ssa        
ssa        

bn c
    
    
    
    
   
   
  
 

bdac
   
   
   
    
   
    
   
   
    
   
   
    
   
   
  
 

dac
bhy
b
  
  
  
   
 
  
  
   
    
   
    
    
   
   
   
   
    
  
  
 
   
  
 

f dac
bhy
b
  
  
  
   
 
  
  
   
    
   
    
    
   
   
   
   
    
  
  
 
   
 
 

figure    experimental results wcsp instances four different algorithms 
column reports cpu time seconds  symbol   indicates time limit
     seconds reached 

results presented paper add new evidence potential  shown
variable elimination used beyond academic still life problem providing
experimental results unstructured realistic problems different domains 

acknowledgments
authors grateful barbara smith  neil yorke smith anonymous reviewers
useful comments different stages work reported article  marti
sanchez kindly made plots figure    research funded spanish
cicyt project tic           c      

references
bensana  e   lemaitre  m     verfaillie  g          earth observation satellite management 
constraints               
bertele  u     brioschi  f          nonserial dynamic programming  academic press 
   

filarrosa  morancho   niso

bistarelli  s   montanari  u     rossi  f          semiring based constraint satisfaction
optimization  journal acm                 
bosch  r     trick  m          constraint programming hybrid formulations three
life designs  proceedings international workshop integration ai
techniques constraint programming combinatorial optimization problems 
cp ai or    pp       
cabon  b   de givry  s   lobjois  l   schiex  t     warners  j          radio link frequency
assignment  constraints          
de givry  s   larrosa  j   meseguer  p     schiex  t          solving max sat weighted
csp  proc   th cp  pp          kinsale  ireland  lncs       springer
verlag 
dechter  r          bucket elimination  unifying framework reasoning  artificial
intelligence            
dechter  r     pearl  j          tree clustering constraint networks  artificial intelligence             
dechter  r     fatah  y  e          topological parameters time space tradeoff  artificial
intelligence                  
dechter  r     rish  i          mini buckets  general scheme bounded inference 
journal acm                 
gardner  m          fantastic combinations john conways new solitary game  scientific american              
kask  k          new search heuristics max csp  proc   th cp  pp         
singapore  lncs       springer verlag 
kask  k     dechter  r          general scheme automatic generation search
heuristics specification dependencies  artificial intelligence             
larrosa  j     dechter  r          boosting search variable elimination constraint
optimization constraint satisfaction problems  constraints                
larrosa  j     schiex  t          quest best form local consistency
weighted csp  proc    th ijcai  acapulco  mexico 
pearl  j          probabilistic inference intelligent systems  networks plausible inference  morgan kaufmann  san mateo  ca 
sandholm  t          algorithm optimal winner determination combinatorial
auctions  ijcai     pp         
smith  b          dual graph translation problem life  proc  cp       pp 
    ithaca  usa  lncs  springer verlag 

   


