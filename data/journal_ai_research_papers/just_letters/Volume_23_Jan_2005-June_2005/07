journal artificial intelligence research                  

submitted       published     

using memory transform search planning graph
terry zimmerman

wizim cs cmu edu

robotics institute  carnegie mellon university
pittsburgh  pa           

subbarao kambhampati

rao asu edu

department computer science   engineering
arizona state university  tempe az           

abstract
graphplan algorithm generating optimal make span plans containing parallel sets actions remains one effective ways generate plans  however  despite enhancements range fronts  approach currently dominated terms speed  state space
planners employ distance based heuristics quickly generate serial plans  report family strategies employ available memory construct search trace learn various
aspects graphplans iterative search episodes order expedite search subsequent episodes 
planning approaches partitioned two classes according type extent
search experience captured trace  planners using aggressive tracing method
able avoid much graphplans redundant search effort  planners second class trade
aspect favor much higher degree freedom graphplan traversing space
states generated regression search planning graph  tactic favored second approach  exploiting search trace transform depth first  ida  nature graphplans
search iterative state space view  shown powerful  demonstrate
distance based  state space heuristics adapted informed traversal search trace used
second class planners develop augmentation targeted specifically planning graph
search  guided heuristic  step optimal version planner class clearly
dominates even highly enhanced version graphplan  adopting beam search search
trace show virtually optimal parallel plans generated speeds quite competitive
modern heuristic state space planner 

   introduction
graphplan introduced       blum   furst        became one fastest programs
solving benchmark planning problems time and  accounts  constituted radically different approach automated planning  despite recent dominance heuristic state search
planners graphplan style planners  graphplan approach still one effective ways
generate so called optimal parallel plans  state space planners drowned exponential
branching factors search space parallel plans  the exponential branching result fact
planner needs consider subset non interfering actions     years since
introduction  graphplan system enhanced numerous fronts  ranging planning
graph construction efficiencies reduce size build time one orders magnitude  smith   weld        long   fox         search speedup techniques variable
value ordering  dependency directed backtracking  explanation based learning  kambhampati 
       spite advances  graphplan ceded lead planning speed variety heuristic guided planners  bonet   geffner        nguyen   kambhampati        gerevini   serina 
       notably  several exploit planning graph powerful state space heuristics 
     ai access foundation  rights reserved 

fizimmerman   kambhampati

eschewing search graph itself  nonetheless  graphplan approach remains perhaps fastest parallel planning mainly way combines iterative deepening a   ida  
korf        search style highly efficient csp based incremental generation applicable action
subsets 
investigate use available memory surmount graphplans major
drawbacks  redundant search effort need exhaustively search k length planning
graph proceeding k   length graph  time wish retain attractive features graphplans ida  search rapid generation parallel action steps ability
find step optimal plans  approach describe remains rooted iterative search planning
graph greatly expedites search building maintaining concise search trace 
graphplan alternates two phases  one data structure called planning graph
incrementally extended  backward phase planning graph searched extract
valid plan  first regression search phase space explored given episode closely
correlated conducted preceding episode  strategy pursue work employ appropriately designed trace search conducted episode n  which failed find solution  identify avoid aspects search provably unchanged episode n   
focus effort features may evolved  identified precisely features dynamic across graphplan search episodes construct search traces capture exploit features different degrees  depending design search trace may provide benefits   
avoidance much graphplans redundant search effort     learning iterative search experience improve heuristics constraints embodied planning graph    
realizing much higher degree freedom graphplan  traversing space states generated regression search process  show third advantage particularly key
search trace effectiveness  allows planner focus attention promising areas
search space 
issue much memory right amount use boost algorithms performance
cuts across range computational approaches search paging process operating systems  internet browsing database processing operations  investigation explore several alternative search trace based methods differ markedly terms memory demands 
describe four approaches paper  figure   depicts pedigree family search
trace based planners  well primary impetus leading evolution system
predecessor  figure suggests relative degree planner steps away
original ida  search process underlying graphplan  two tracks correspond two genres
search trace developed 


left track  egbg planners  explanation guided backward search graphplan  employ
comprehensive search trace focused minimizing redundant search 



right track  pegg planners  pilot explanation guided graphplan  use skeletal
trace  incurring graphplans redundant search effort exchange reduced memory
demands increased ability exploit state space view search space 

egbg planner  zimmerman   kambhampati        adopts memory intensive structure
search trace seeks primarily minimize redundant consistency checking across graphplans
search iterations  proves effective range smaller problems memory constraints

   

fiusing memory transform search planning graph

xy

search
trace
exploiting graphplan
symmetry   redundancy

exploiting
state space view

egbg
leveraging csp   memory efficiency

so pegg
me egbg
trading step optimality
speedup episodes

pegg

figure    applying available memory step away graphplan search process 
family search trace based planners
impede ability scale up  noting graphplans search process viewed specialized
form csp search  kambhampati         explore middle ground terms memory usage augmenting egbg several methods known effective speedup techniques csp
problems 
primary interest techniques  however  impact memory reduction describe accomplish beyond search speedup benefit afford  implemented planner  me egbg  markedly outperforms egbg speed capabilities  variety
problems still lie beyond planners reach due memory constraints 
search trace structure used pegg track planners trades minimization redundant
search exchange much smaller memory footprint  addition greatly reduced memory
demands  pegg search trace structure exploited intrinsic state space view
essentially graphplans csp oriented search space  significant speedup advantage approach
graphplan egbg track planners derives ability employ distance based
heuristics power many current generation state space planners  bonet   geffner       
nguyen   kambhampati        hoffman         adapt heuristics task identifying
promising states visit search trace implement approach first so pegg
planner  step optimal pegg  zimmerman   kambhampati         so pegg outperforms even
highly enhanced version graphplan two orders magnitude terms speed 
maintaining guarantee finding step optimal plan 
finally explore adoption beam search approach visiting state space implicit
pegg style trace  employ distance based heuristics extracted planning graph
itself  direct order search trace states visited  prune restrict
space heuristically best set states  according user specified metric  show
planning graph leveraged provide measure likelihood previously generated regression state might spawn new search branches higher planning graph level 
   

fizimmerman   kambhampati

term metric flux employ effective filter states skipped even
though might appear promising based distance based heuristic  implemented pegg
system  zimmerman   kambhampati         approach exploiting search trace produces
two fold benefit previous approaches     reduction search trace memory demands
   effective release graphplans exhaustive search planning graph search episodes  pegg exhibits speedups ranging    x enhanced version graphplan
quite competitive recent state space planner using similar heuristics  adopting beam
search pegg necessarily sacrifices guarantee step optimality empirical evidence indicates
secondary heuristics remarkably effective ensuring make span solutions produced
virtually optimal 
fact systems successfully employ search trace noteworthy  general 
tactic adopting search trace algorithms explicitly generate node states iterative
search episodes  found infeasible due memory demands exponential
depth solution  sections     describe tight integration search trace
planning graph permits egbg pegg planners largely circumvent issue 
planning graph structure costly construct  terms memory time 
well known problems even domains problematic planners employ it   postgraphplan planners employ planning graph purpose include stan  long   fox 
      blackbox  kautz   selman        ipp  koehler et al         altalt  nguyen   kambhampati        lpg gerevini   serina         planning systems described share
memory overhead course  interestingly  found search trace memory demands
pegg class planners significantly limited range problems solve 
remainder paper organized follows  section   provides brief overview
planning graph graphplans search process  discussion csp nature manner process viewed ida  search motivates potential employing available memory accelerate solution extraction  section   addresses two primary challenges attempting build use search trace advantage graphplan     done within
reasonable memory constraints given graphplans csp style search planning graph  and    
trace available  effectively used  section briefly describes egbg
 zimmerman   kambhampati         first system use search trace guide graphplans
search  outlines limitations method  details algorithm contained appendix
a   section   summarizes investigations variety memory reduction techniques reports impact combination six performance egbg  pegg planners
discussed section   performance so pegg pegg  using beam search  compared enhanced version graphplan  egbg  modern  serial state space planner  section
  contains discussion findings section   compares work related research  finally 
section   wraps conclusions 
   background   motivation  planning graphs nature direct
graph search
outline graphplan algorithm discuss traits suggesting judicious use additional
memory might greatly improve performance  touch three related views graphplans
search     form csp     ida  search and     state space aspect 
   

fiusing memory transform search planning graph

actions
level  

initial
state
w

planning graph
propositions
propositions
actions
level  
level  
level  
nop
nop

 w
w

nop

a 


actions
level  

 w

nop

 w

w

nop

w

a 

a 

nop

 y


nop

nop

nop

x
 y

z
h

a 

nop



a 

a 

nop

h

nop



nop

 y


nop

h

propositions
level  

a 



a 
a 

a 

nop

j

a 

j

nop

j

domain actions



a 

ihw
hj

a 

x

action descriptions 



a 

 w
ij

a 

z


a 

j  y

action id  effects 
 preconditions 

figure    planning graph representation three levels alpha domain
    construction search planning graph
graphplan algorithm employs two interleaved phases forward phase  data structure
called planning graph incrementally extended  backward phase planning graph
searched extract valid plan  planning graph consists two alternating structures  called
proposition lists action lists  bottom figure   depicted simple domain refer
alpha domain use illustration study  figure shows four action proposition levels planning graph engendered simple initial state given domain  start
initial state zeroth level proposition list  given k level planning graph  extension
graph structure level k   involves introducing actions whose preconditions present
kth level proposition list  addition actions domain model  operation actions
introduced  one condition kth level proposition list  abbreviated nop papers
figures  termed persists others   nop c action c precondition c
effect  given kth level actions  proposition list level k   constructed union
effects introduced actions  planning graph maintains dependency links

   

fizimmerman   kambhampati

actions level k    preconditions level k proposition list  effects level
k   proposition list 
planning graph construction binary  mutex   constraints computed propagated 
figure    arcs denote mutex relations pairs propositions pairs actions 
propagation starts level   labeling mutex pairs actions statically interfering
 static mutex   preconditions effects logically inconsistent  mutexes
propagated level forward using two simple propagation rules  two propositions
level k marked mutex actions level k support one proposition mutex actions support second proposition  two actions level   mutex statically
interfering precondition first action mutually exclusive precondition second    we term latter dynamic mutex  since constraint may relax higher planning graph
level    propositions either static mutex  one negates other  dynamic mutex  all actions supporting one proposition mutex actions supporting other  
reduce figure   clutter mutex arcs propositions negations omitted 
search phase k level planning graph involves checking see sub graph
planning graph corresponds valid solution problem  figure   depicts graphplan search
manner similar csp variable value assignment process  beginning propositions
corresponding goals level k  incrementally select set actions level k action
list support goals  two actions selected supporting two different goals
mutually exclusive  if are  backtrack try change selection actions   essentially csp problem goal propositions level variables  actions establish
proposition values  mutex conditions constitute constraints  search proceeds
depth first fashion  goals level supported  recursively call search process k   level planning graph  preconditions actions selected level k
goals k   level search  search succeeds reach level    the initial state 
solution extracted unwinding recursive goal assignment calls  process viewed
system solving dynamic csps  dcsp   mittal   falkenhainer        kambhampati       
wherein standard csp formalism augmented concept variables appear
 a k a  get activated  variables assigned 
interleaved planning graph extension search phases  graph may extended
stasis condition  changes occur actions  propositions  mutex conditions 
sufficient condition defining level off level new actions introduced
existing mutex conditions propositions go away  refer planning graph levels
level off static levels  note although graph becomes static point  finding
solution may require many episodes composed adding identical static levels conducting
regression search problem goals 
many fielded csp solvers  graphplan s search process benefits simple form nogood learning  set  sub goals level k determined unsolvable  memoized level hash table  subsequently  backward search process later enters level k
set subgoals first checked hash table  match found search
 

static mutex condition called eternal mutex dynamic mutex termed conditional mutex  smith
  weld        

   

fiusing memory transform search planning graph

j nop



a 



a 

w

j



a 



a 

j

a 

yj






a 

w

z nop



j


j

a 

nop

nop

h nop


a 
a 

j


a 

nop



j

nop

a 

x

a 

nop



level  

a 

x




yh j

a 



w

a 

ha  nop

a 



nop

nop

a 



nop


j



a 

nop







a 

z nop

wxyz



h nop


a 

nop j
a 

nop

nop

wyhij

initial state

a 


goal state

nop

a 

a 

a 


a 

nop

h
a 

a 

level  

level  

yhi

icon explanation 
action a  assigned give
assigned action
assigned action
j

goal j
static mutex
dynamic mutex
a 
previous assigned action
previous assigned action
a 
goal already satisfied
set regressed subgoals

previously assigned action a 
satisfied next lower level

figure    csp style trace graphplans regression search figure   planning graph
process backtracks  constitutes one three conditions backtracking  two others arise
attempts assign static mutex actions dynamic mutex actions  see figure   legend  
next discuss graphplans search higher level view abstracts away csp nature 
    graphplan state space search
abstract perspective  graphplan viewed conducting regression state space
search problem goals initial state  view  states generated expanded subgoals result csp process given set subgoals finds consistent
set actions satisfying subgoals planning graph level  c f  kambhampati   sanchez 
       view state generator function effectively graphplans csp style goal assignment routine seeks non mutex set actions given set subgoals within given planning
graph level  view depicted figure    top graph casts csp style search trace
   

fizimmerman   kambhampati

 

init
state

w


 

proposition levels

 

  valid sets action
assignments satisfy
goals wxyz level  

j a 

 

 

init
state

w

 

w
a  a 
h
goal

w
x

z

h a   a 

 

 

proposition levels

s  

s 

s 

s 

s 

 

s 
w

h


s 

s  
s  

s  

 

s  

s  

s  


j

goal

w
x

z


s  

s  

s  


h


s  

s  
 

 

 
s  
s  

s  

w

 

s 

s  

s  

s 

w

h


s  

s  

s  

s  


j


h


s  
s  

s  

 

s 

s  

s  

 

s 

s  
s  

s  

s 
s 

s  

init
state



proposition levels

s  
s  

goal
w
x

z

s  

figure    graphplans regression search space  three consecutive search episodes
figure   high level state space search trace  terms box depict set  positive 
subgoals result action assignment process goals higher level state
box linked  
recognizing state space aspect graphplans search helps understanding connection
ida  search  first noted briefly discussed  bonet   geffner         highlight expand
upon relationship here  three correspondences algorithms 
   graphplans episodic search process nodes generated previous episode regenerated new episode  and possibly new nodes   corresponds ida s iterative
search  graphplan nodes states  sets subgoals  result regres 

figure   facilitates discussion search trace next section  conjuring hypothetical problem
first search episode begins level   planning graph instead level    figure   

   

fiusing memory transform search planning graph

sion search given plan graph level succeeds  perspective node generator
function effectively graphplans csp style goal assignment routine seeks non mutex
set actions given set propositions within given planning graph level 
   state space view graphplans search  ala figure     within given search episode iteration algorithm conducts search depth first fashion ida   ensures
space requirements linear depth solution node 
   upper bound iteratively deepened ala ida  node state heuristic f value 
f   g   h  context h distance terms associated planning graph levels
state generated graphplans regression search initial state  g cost reaching
state goal state terms number csp epochs  i e  numerical difference highest graph level states level  
purposes  perhaps important observation implicit f value bound
given iteration length planning graph associated iteration  is 
node state  associated planning graph level determines distance initial state  h 
cost reach goal state  g   total must always equal length plan graph 
heuristic clearly admissible  shorter distance goal graphplan
exhaustively searches shorter length planning graphs  any  previous iterations  heuristic
implicit graphplan algorithm guarantees step optimal solution returned  note
perspective nodes visited given graphplan search iteration implicitly
f value  g   h   length planning graph  consider implications property
address informed traversal graphplans search space section   
primary shortcoming standard ida  approach search regenerates many
nodes iterations  long recognized ida s difficulties
problem spaces traced using little memory  russell        sen   bagchi        
information carried one iteration next upper bound f value  graphplan partially addresses shortcoming memo caches store no goods  states found
inconsistent successive episodes  however  ida  nature search make inefficient planner problems goal propositions appear non mutex planning graph
many levels valid plan actually extracted 
second shortcoming ida  nature graphplans search node states generated
given graphplan episode f value  i e  length graph   such  within
iteration  search episode  discernible preference visiting one state another 
next discuss use available memory target shortcomings graphplans search 
   efficient use search trace guide planning graph search
search space graphplan explores given search episode defined constrained three
factors  problem goals  plan graph associated episode  cache memoized nogood states created previous search episodes  typical ida  search considerable
 

bonet   geffner define hg  the graphplan h value  somewhat differently first level goals
state appear non mutex memoized  definition  which necessarily first level
sm goals appear non mutex  produces informed admissible estimate cases 
guarantees states generated graphplan f value equal planning graph length 
property primary interest us 

   

fizimmerman   kambhampati

similarity  i e  redundancy  search space successive episodes plan graph extended 
fact  discussed below  backward search conducted level k   graph essentially
replay search conducted previous level k certain well defined extensions 
specifically  essentially every set subgoals generated backward search episode n  starting
level k  regenerated graphplan episode n   starting level k    unless solution
found first   
returning figure   entirety  note depicts state space tree structure corresponding graphplans search three consecutive iterations  top graph  discussed above  represents subgoal states generated course graphplans first attempt satisfy wxyz
goal problem resembling running example   it implied w x y z propositions
present planning graph level   first level pair
mutex   second search episode  the middle figure   graph   states generated again 
one level higher  addition  states expanded generate number children 
shown darker shade   since figure   hypothetical variation alpha domain problem
detailed figures      states created beyond first episode labeled state numbers representing order generated   finally  third episode  graphplan regenerates states previous two episodes attempting satisfy wxyz level    ultimately finds solution  the assigned actions associated figures double outlined subgoal
sets  generating states shown darkest shading bottom graph figure   
noting extent consecutive iterations graphplans search overlap  investigate
application additional memory store trace explored search tree  first implemented
approach  egbg  which summarized following subsection   seeks leverage appropriately designed search trace avoid much inter episode redundant search effort possible
 zimmerman   kambhampati        
    aggressive use memory tracing search  egbg planner
types csp based algorithms  graphplan consumes computational effort
given problem checking constraints  instrumented version planner reveals typically 
         cpu run time spent creating checking action proposition mutexes  both
planning graph construction search process   mutex relations incorporated planning graph primary constraints csp view graphplan  kambhampati       
such  obvious starting point seeking efficiency improvements planner
primary tactic adopted egbg  provide overview approach  referring
interested reader appendix details 
egbg exploits four features planning graph graphplans search process 

 

set actions establish given proposition level k   always superset
establishing proposition level k 

strictly speaking  always case due impact graphplans memoizing process  problems
particular branch search tree generated search episode n rooted planning graph level k may revisited
episode n   level k   due no good proposition set memoized level k    however  memo merely acts
avoid redundant search neglecting relatively rare cases serves simplify visualization symmetry
across graphplans search episodes   

   

fiusing memory transform search planning graph



constraints  mutexes  active level k monotonically decrease increasing
planning graph levels  is  mutex active level k may may continue
active level k   becomes inactive never gets re activated future levels 



two actions level statically mutex  i e  effects preconditions conflict
other  mutex succeeding levels 



problem goal set satisfied level k set searched
level k   planning graph extended  is  subgoal set present level k
two propositions mutex  remain future levels 

given appropriate trace search conducted episode n  which failed find solution 
would ignore aspects search provably unchanged episode n    focus effort features may evolved  previous search failed extract solution
k length planning graph  search k   length graph succeed one
following conditions holds 
   dynamic mutex condition pair actions whose concurrent assignment
attempted episode n longer holds episode n   
   subgoal generated regression search episode n planning graph level
k  action establishes episode n   first appears level k   
   episode n regression state  subgoal set  level k matched cached memo
level memo match generated level k   episode n   
 the discussion appendix formalizes conditions   instance one
conditions hold  complete policy must resume backward search search parameters associated instance previous episode  n  resumed partial search episodes
either find solution generate additional trace subgoal sets augment parent trace  specialized search trace used direct future backward search episodes problem 
viewed explanation failure search process episode  hereafter use
terms pilot explanation  pe  search trace interchangeably  following definitions useful describing search process 
search segment  essentially state  specifically set planning graph level specific subgoals
generated regression search goal state  which first search segment  
egbg search segment sn   generated planning graph level k contains 
subgoal set propositions satisfied
pointer parent search segment  sp     the state level k   gave rise sn 
list actions assigned sp resulted subgoals sn
pointer pe level  as defined below  associated sn
sequential list results action consistency checking process attempt satisfy sns subgoals  possible trace results given consistency check are  static mutex 
dynamic mutex  action consistent prior assigned actions  trace results
stored list bit vectors efficiency 
search segment therefore represents state plus path information  often use search
segment state interchangeably  such  boxes figure    whether state goals
explicitly shown not  viewed search segments 

   

fizimmerman   kambhampati

pilot explanation  pe   search trace  consists entire linked set search segments
representing search space visited graphplan backward search episode  convenient
visualize figure    tiered structure separate caches segments associated search
planning graph level  adopt convention numbering pe levels reverse
order plan graph  top pe level    it contains single search segment whose goals
problem goals  level number incremented move towards initial state 
solution found  pe necessarily extend highest plan graph level initial state 
shown third graph figure   
pe transposition  state first generated search episode n associated specific
planning graph level  say k  premise using search trace guide search episode n  
based idea re associating pe search segment  state  generated  or updated  episode n
next higher planning graph level  is  define transposing pe as  search
segment pe associated planning graph level k search episode n  associate
level k   episode n   
given definitions  note states pe search episode n plan graph
level k  loosely constitute minimal set   states visited backward search conducted episode n   level k     this bound visualized sliding fixed tree search
segments first graph figure   one level  
    conducting search egbg search trace
egbg builds initial pilot explanation first regression search episode tracing
search process augmented version graphplans assign goals routine  solution
possible k length planning graph  pe transposed one level  key features previous search replayed significant new search effort occurs points one
three conditions described holds  new search process pe augmented according search space visited 
egbg search algorithm exploits search trace essentially bi modal fashion  alternates
informed selection state search trace previous experience focused csp type
search states subgoals  discussion egbgs bi modal algorithm revolves around
second mode  minimizing redundant search effort state chosen visitation 
describe peggs use search trace section   see greater potential
dramatic efficiency increases lies first mode  selection promising state
search trace 
choosing state visit  egbg uses trace previous episode focus
aspects entailed search could possibly changed  search segment si
planning graph level k    visitation  step process 
   perform memo check ensure subgoals si valid level k  
   replay previous episodes action assignment sequence subgoals si  using
segments ordered trace vectors  mutex checking conducted pairs actions
dynamic mutex level k  actions longer dynamic mutex  add can 

possible graphplans memoizing process preclude states regenerated subsequent episode 
see footnote   brief explanation conditions may occur 

   

fiusing memory transform search planning graph

didate action sis list consistent assignments resume graphplan style search remaining goals  si  is augmented pe extended process  whenever sis goals
successfully assigned  entailing new set subgoals satisfied lower level k  child
search segment created  linked si   added pe 
   si subgoal replay sequence  check new actions appearing level k  
establish subgoal  new actions inconsistent previously assigned action
logged sis assignments  new actions conflict previously assigned  assign resume graphplan style search point step   
   memoize sis goals level k   solution found via search process steps     
long segments pe visited manner  planner guaranteed find
optimal plan search episode graphplan  hereafter refer pe search segment
visited extended via backward search find valid plan  seed segment  addition 
segments part plan extracted pe call plan segments  thus  third
graph figure    s   apparent seed segment plan segments  in bottom order  are 
s    s    s    s    s    s    labeled segments yh  yhi  goal state wxyz 
principle freedom traverse search states encapsulated pe order
longer restricted  non informed  depth first nature graphplans search process 
unfortunately  egbg incurs high overhead associated visiting search segments order bottom  in terms pe levels   ancestor state represented pe
visited state itself  egbgs search process would regenerate state
descendents  unless first finds solution   non trivial cost associated generating
assignment trace information egbgs search segments  search advantage lies reusing trace data without regenerate it 
hand  top down visitation segments pe levels degenerate mode 
search process essentially mimics graphplans  since episode begins search
problem goal set   with exception replay top level search segments assignments 
regenerates states generated previous episode  plus possibly new states 
regression search  search trace provides significant advantage top down visitation
policy 
bottom up policy  hand  intuitive appeal since lowest levels pe correspond portions search space lie closest initial state  in terms plan steps  
state one lower levels fact extended solution  planner avoids search
effort graphplan would expend reaching state top level problem goals 
adopting bottom up visitation policy amounts layering secondary heuristic primary
ida  heuristic  planning graph length iteratively deepened  recalling section     states pe f value terms primary heuristic  essentially biasing favor states low h values  support policy comes work
heuristic guided state space planning  bonet   geffner        nguyen   kambhampati       
weighting h factor   relative g component heuristic f value generally improved performance  however  unlike state space planning systems  primary heuristic  egbg employs secondary heuristic guarantee step optimality

   

fizimmerman   kambhampati

standard graphplan

speedup ratios

egbg

problem
time

bktrks

mutex
chks

    

   x

   x

   x

      k

    

    x

    x

  x

    k

    k

    

    x

  x

  x

    k

     k

    

   x

   x

   x

total
time

backtracks

mutex
checks

total
time

backtracks

mutex
checks

size
pe

bw large b
       

   

     k

        k

  

    k

       k

rocket ext a
      

   

     k

       k

  

    k

tower  
       

   

     k

      k

  

ferry  
       

   

     k

      k

  

table    comparison egbg standard graphplan 
numbers parentheses give number time steps   number actions respectively  search backtracks
mutex checks performed search shown   size pe  pilot explanation size terms
final number search segments  standard graphplan lisp version smith peot 

depend admissibility  found bottom up visitation efficient mode
egbg default order egbg results reported study 
    egbg experimental results
table   shows performance results reported first version egbg  zimmerman  
kambhampati         amongst search trace designs tried  version memory
intensive records greatest extent search experience  runtime  number search
backtracks  number search mutex checks performed compared lisp implementation original graphplan algorithm  egbg exhibits clear advantage graphplan
small set problems 




total problem runtime            x improvement
number backtracks search          x improvement
number mutex checking operations search          x improvement

since total time is  course  highly dependent machine well coding language  
 egbg performance particularly sensitive available memory   backtrack mutex checking
metrics provide better comparative measure search efficiency  graphplan  mutex checking
far biggest consumer computation time and  such  latter metric perhaps
complete indicator search process improvements  problem to problem variation
egbgs effectiveness attributed static dynamic mutex ratio characterizing graphplans
action assignment routine  action assignments rejected due pair wise statically mutex
actions  greater advantage enjoyed system doesnt need retest them  tower ofhanoi problems fall classification 
noted original study  zimmerman   kambhampati        range problems
 

planners developed report coded allegro lisp run pentium     mhz      ram 
runtimes include plangraph construction time exclude garbage collection time  values table   differ
published      problems re run platform  reflect changes tracking statistics 

   

fiusing memory transform search planning graph

handled implementation significantly restricted amount memory available
program runtime  example  pe consisting almost       search segments 
modest sized bw large b problem challenges available memory limit test machine 
consider next approach  me egbg figure    occupies middle ground terms memory
demands amongst search trace approaches investigated 
   engineering reduce egbg memory requirements  me egbg planner
memory demands associated graphplans search process major concern  since
conducts depth first search search space requirements linear depth solution node 
since seek avoid redundancy inherent ida  episodes graphplans search using
search trace  must deal much different memory demand profile  search trace design
employed egbg memory requirements exponential depth solution  however  search trace grows direct proportion search space actually visited  techniques
prune search act greatly reduce memory demands 
examined variety methods respect issue  eventually implemented suite
seven together proven instrumental helping egbg  and later  pegg  overcome memorybound limitations  six known techniques planning csp fields  variable ordering  value ordering  explanation based learning  ebl   dependency directed backtracking  ddb  
domain preprocessing invariant analysis  transitioning bi partite planning graph  four
six effective methods csp speedup techniques  however interest lies primarily
impact search trace memory demands  challenging aspects adapting
methods planning graph search trace context  focus paper  thus details
motivation implementation methods relegated appendix b 
seventh method  novel variant variable ordering call ebl based reordering  exploits
fact using ebl search trace available  although method readily implemented pegg  strict ordering trace vectors required egbg search trace make
costly implement planner  such  memory efficient egbg  me egbg  use
ebl based reordering defer discussion pegg introduced section   
    impact enhancements egbg memory demands
two major modes first six techniques impact memory demand me egbg 
   reduction size pilot explanation  search trace   either number search segments
 states   average trace content within segments     reduction requirements
structures compete pilot explanation available memory  i e  planning graph
memo caches   admittedly  two dimensions independent  since number
memos  though size  linear number search segments  nonetheless consider
partition discussion facilitate comparison methods impact search
trace 
general  impact enhancements search process depends significantly 
particular problem  presence  or absence  methods 
single configuration techniques proves optimal across wide range problems  indeed  due
computational overhead associated methods  generally possible find class
problems planner performance degrades due presence method  chose
   

fi  
ddb

  

  

  

  

  

six combination
  me egbg  

  

ebl

  

domain preprocess  
invariant analysis
value ordering

  

  reduction pe  search trace  memory requirement

   

zimmerman   kambhampati

variable ordering

  

  

  

bi partite graph

  

  

  

  

  

  

   

  reduction planning graph  memo cache memory requirements

figure    memory demand impact along two dimensions six memory reduction speedup
techniques  plots applied independently suite  within egbg  
set techniques then  based joint average impact me egbg   pegg memory footprint
extensive variety problems 
figure   illustrates method impact memory reduction relative two dimensions above  method operates isolation others  plot reflects results based
twelve problems three domains  logistics  blocksworld  tower of hanoi   chosen include
mix problems entailing large planning graphs  problems requiring extensive search  problems
requiring both  horizontal axis plots percent reduction end of run memory footprint
combined memo caches planning graph  ratios along ordinate assessed based
runs graphplan  no search trace employed  memo cache planning graph
globally defined structures significant size remain lisp interpreted environment
run completion   similarly  vertical axis plots percent reduction space required pe
end egbg runs without method activated  planning graph
memo cache structures purged working memory 
plot crossbars method depict spread reduction values seen across twelve
problems along dimensions  intersection average  bi partite planning
graph  surprisingly  impacts graph aspect  five six methods seen
impact search trace size graph memo cache size  these  ddb greatest influence pe size little impact graph memo cache size  ebl modest influence former larger impact latter  due smaller memos creates
 

allegro common lisp global scavenging function used purge target global data structures
workspace 

   

fiusing memory transform search planning graph

production general memos  engender backtracks   domain preprocessing  invariant analysis major impact graph size pe size due processes
extraction invariants operator preconditions  highly domain dependent  little effect case blocksworld problems  great consequence tower ofhanoi logistics problems 
six methods combined complement evidenced crossbars plotting space reduction six employed once  twelve problems average reduction
pe size approaches     average reduction planning graph memo cache aspect exceeds
     single method isolation averages     reduction along dimensions 
runtime reduction associated methods isolation highly dependent
problem methods active  general  relative time reduction
two methods correlate closely relative memory reduction  however  found
similarly  techniques broadly complement net speedup accrues 
techniques listed  and been  used improve graphplans performance also  terms speed  order focus impact planning search trace  use
version graphplan enhanced six methods comparisons me egbg
pegg study  we hereafter refer enhanced version graphplan gp e  
    experimental results me egbg
table   illustrates impact six augmentations discussed previous section egbgs
 and graphplans  performance  terms space runtime  standard graphplan  gp e 
egbg  me egbg compared across    benchmark problems wide range domains  including problems first three aips planning competitions held date  problems
selected satisfy three objectives  subset standard graphplan egbg could solve
comparison me egbg  different subsets exceed memory limitations three
planners terms either planning graph pe size  subset gives rough impression
search time limitations 
surprisingly  memory efficient egbg clearly outperforms early version problems attempted  importantly  me egbg able solve variety problems beyond reach
standard graphplan egbg     problems  standard graphplan solves     original egbg solves     gp e solves     me egbg solves     wherever me egbg gp e solve
problem  me egbg faster factor   x  averages   x speedup  standard
graphplan  on twelve problems solve   bested me egbg factors ranging  x
    x 
striking improvement memory efficient version egbg first version
simply due speedup associated five techniques discussed previous section 
directly tied impact search trace memory requirements  table   indicates one three reasons instance problem solved planner     s  planner still search
   cpu minutes     pg  memory exhausted exceeded    minutes planning graph building phase     pe  memory exhausted search due pilot explanation extension  third reason clearly favors me egbg size pe  reported terms search segments time
problem solved  indicates generates retains trace    x fewer states
egbg  translates much broader reach me egbg  exhausts memory    
   

fizimmerman   kambhampati

table   problems compared     first version egbg  regardless  gp e solves three
problems me egbg fails    minutes due search trace memory demands
table illustrates dramatic impact speedup techniques graphplan itself 
enhanced version  gp e  well   x faster original version problems
solve    minutes  solve many problems entirely beyond standard graphplans reach 
nonetheless  me egbg modestly outperforms gp e majority problems
solve  since egbg  and pegg  planners derive strength using pe shortcut
graphplans episodic search process  advantage realized problems multiple search
episodes high fraction runtime devoted search  thus  speedup seen grid y  
problems mystery  movie  mprime domains solution extracted
soon planning graph reaches level containing problem goals non mutex state 
bottom up order egbg visits pe search segments turns surprisingly effective many problems  table   problems found great majority pe final
episode contains seed segment  a state search reach initial state  within
deepest two three pe levels  supports intuition discussed section     suggests
advantage low h value bias observed heuristic state space planners  bonet   geffner 
      nguyen   kambhampati        trans lates search planning graph 
results even memory efficient version egbg reveal two primary weaknesses 
   action assignment trace vectors allow egbg avoid redundant search somewhat
costly generate  make significant demands available memory problems elicit large
search  e g  table   problems  log y     puzzle    freecell       difficult revise
search experience alters drastically subsequent visits 
   despite surprising effectiveness many problems  bottom visitation pe search
segments inefficient others  table   problems freecell     essentially
schedule domain problems  planning graph gets extended level
solution extracted  solution arises via new search branch generated root
search segment  i e  problem goal state   thus  seed segment pe topmost search segment  bottom up visitation pe states costly graphplans
top down approach 
first shortcoming particularly manifest problems allow egbg exploit
pe  e g  problems solution extracted first search episode   hit egbg
takes problems relative graphplan closely tied overhead associated building
search trace  compelling tactic address second shortcoming traverse search space
implicit pe according state space heuristics  might wish  example  exploit
variety state space heuristics revolutionized state space planners recent years
 bonet   geffner        nguyen   kambhampati        gerevini   serina         however 
noted section      depart policy visiting egbg search segments level bylevel  bottom up order  face costly bookkeeping high memory management overhead 
informed traversal state space view graphplans search space taken next 
argue perhaps key benefit afforded trace search planning graph 

   

fiusing memory transform search planning graph

problem

 steps actions 

bw large b        
huge fct
       
rocket ext a       
att log a
       
gripper          
tower  
       
tower            
 puzzle          
 puzzle          
tsp   
       
aips     
grid y          
grid y          
gripper x          
gripper x          
gripper x          
log y  
       
mprime x         
movie x         
mysty x          
aips     
blocks             
blocks             
logistics             
logistics             
logistics             
freecell           
schedule           
schedule           
aips     
depot             
depot     a        
driverlog      a        
driverlog      e        
roverprob            
roverprob           
strips sat x         
strips sat x         
ztravel    a       
ztravel    a        

egbg

graphplan
cpu sec

stnd 
   
   

gp e

cpu sec

 enhanced 

    
    

   

    
   
    

    

   
   
    
   
    

   
graphplan
gp e
   
    
pg
pg
   
    

   


pg
   
    
   
  
   
  
    
graphplan
gp e

   

    

    

    



    
pg
    
pg
    
graphplan
gp e
   
   

    
    
   

   

    

   
   
    



   



  
  
    
pe
  
    

pe
pe
pe
   
pg
   
pe
pe
pg
   
   
  

size
pe

    
    
    
    
    

egbg
  
    

 
 
  
egbg

pe
pe

pe
pe
pe
pg
pg
   

   

   
pe
   

pe
pe

egbg
    
    
     
    

me egbg

speedup
 me egbg
vs  gp e 

    
    
   
    
    
  
   
pe
      
    
     
    
    
me egbg
    
  
pg
   
    
    
    
   
     
pe
      
   
 
   
 
    
  
me egbg
    
    
    
    
    
    
    
    
    
    
pe
      
    
 
    
 
me egbg
   
   
    
    
   
   
    
    
    
    
    
     
    
    
    
   
    
    
      
pe

   x
   x
   x
   x
   x
   x
   x
 pe 
   x
   x
speedup
 x
 
   x
   x
   x
 pe 
 x
 x
 x
speedup
   x
   x
   x
   x
   x
 pe 
   x
   x
speedup
    x
   x
   x
 x
   x
   x
   x
   x
  x
 

 memory efficient egbg 
cpu sec
size
pe

   
   
   
   
   
   
    

table    search step optimal plans  egbg  me egbg  standard   enhanced graphplan
standard graphplan  lisp version smith peot
gp e  graphplan enhanced per section     me egbg  memory efficient egbg
size pe final search trace size terms number  search segments 
search failure modes  pg exceeded    mins  memory constraints graph building
pe exceeded memory limit search due size pe
exceeded    mins  search
parentheses adjacent cpu time give    steps     actions  solution 
   

fizimmerman   kambhampati

   focusing state space view  so pegg pegg planners
costs associated egbgs generation use search trace directly attributable
storage  updating  replay csp value assignments search segments subgoals 
therefore investigated stripped version search trace abandons tactic focuses
instead embodied state space information  show pegg planners employing
search trace  both so pegg  step optimal version pegg  version using beam search  
outperform egbg planners larger problems  key difference egbgs pilot explanation pared down  skeletal pe used pegg planners  elimination detailed
mutex checking information contained bit vectors former  i e  last item bullet
list egbg search segment contents section       pegg planners apply state space
heuristics rank pe search segments based associated subgoal sets  states  free
visit state space informed manner  tradeoff pe state visited
planner must regenerate csp effort finding consistent action assignments subgoals 
figure   illustrates pegg advantage small hypothetical search trace final search episode  search segments pe onset episode appear solid lines plan
segments  states extendable valid plan  shown double lined boxes  figure reflects
fact typically may many latent plan segments diverse branches search trace
solution bearing episode  clearly planner discriminate plan segment states
states pe could solve problem quickly planner restricted bottom up traversal  deepest pe level first   state space heuristics endow pegg planners capability 
so pegg planner visits every search segment pe search episode  comparable graphplans exhaustive search given length graph  thereby guaranteeing returned
plans step optimal  such  advantage heuristic guided traversal realized
final episode  many problems  computational effort expended graphplan last search
episode greatly exceeds previous episodes combined  still powerful advantage  however  scale problems larger terms number size search
episodes  cost exhaustive search even intermediate episodes becomes prohibitive 

 
init
state

goal

 

w

w
x

z

 



 
 
 

 
 

 
 

 

 

 

 
 

 
 
 

proposition levels

 

 

figure    pe final search episode hypothetical problem  search segments pe
onset search appear solid lines  double lined boxes represent plan segments 
dashed lined boxes states newly generated regression search episode 
visitation order dictated secondary heuristic shown via numbering 
   

fiusing memory transform search planning graph

planner refer simply pegg employs beam search  applying search trace heuristics
intermediate search episodes visit select subset pe segments  pegg
trades step optimality guarantee often greatly reduced solution times 
several challenges must dealt effectively use pared search trace
employed so pegg pegg  including adaptation augmentation distance based heuristics guide search trace traversal dealing memory management problems induced
tactic skipping search space  describe addressed issues
give complete description algorithm  first present results provide perspective effectiveness planners 
    experimental results so pegg pegg
table   compares graphplan  standard gp e   me egbg  so pegg  pegg
problems table    adds variety larger problems latter two systems
handle  table   problems easily solved gp e me egbg  e g  aips   
movie mystery domains  omitted table    here  planners employ variable
value ordering  i e  except standard graphplan   configured use value ordering based
planning graph level action first appears goal ordering based proposition distance
determined adjusted sum heuristic  which defined below   variety
parameters so pegg pegg planners optimal configurations tend
problem dependent  defer discussion sections               note
table   results following parameter settings used based good performance average
across variety domains problems 
secondary heuristic visiting states  adjusted sum w     eqn     
beam search  visit best      lowest f value  search segments per search episode 
minimum    maximum     search segments flux lower     average
visited regardless heuristic rank   wcf        see section       
focusing first gp e  me egbg  so pegg columns  clearly see impact
tradeoff storing exploiting intra segment action assignment information pe 
set    problems     result me egbg exceeding available memory due size
pe one pushes limit so pegg  seven problems cause me egbg run
memory actually solved so pegg remainder exceed time limit
search  addition  so pegg handles five problems table gp e fails on  problems
typically entail extensive search final episode  pe efficiently shortcuts full graph
search conducted gp e  speedup advantage so pegg relative gp e ranges
modest slowdown three problems almost   x zeno travel problems  average
 x   note speedup values reported table so pegg  
generally  planner using search trace perform gp e single search episode problems grid y    cost building trace recovered  low overhead associated building so peggs search trace means suffers little relative gp e case 
problems me egbg so pegg solve  me egbg upper hand due
ability avoid redundant consistency checking effort  fact me egbgs advantage sopegg greater problems attributable so peggs ability move pe
search space final search episode  versus me egbgs bottom up traversal  lower
   

fizimmerman   kambhampati

graphplan

problem

cpu sec  steps acts 

stnd 
bw large b
bw large c
bw large d
att log a
att log b
gripper  
gripper   
tower  
tower  
 puzzle  
 puzzle  
tsp   
aips     
grid y  
gripper x  
gripper x  
log y  
aips     
blocks     
blocks     
blocks     
logistics     
logistics     
logistics     
freecell    
freecell    
schedule    
aips     
depot     a
depot     
depot     
driverlog      e
driverlog      b
roverprob    
roverprob    
roverprob    
sat x  
sat x  
ztravel    a
ztravel    a

     








    
    

stnd gp
   


pg
stnd gp

 

 


pg
pg
pg
stnd gp








   




gp e

me egbg
cpu sec
 steps acts 

 enhanced  

            
       
       
            

            

             
         
            
            
           
gp e
            


           
gp e
            
            

            


           
           
          
gp e
            


           

          


         

          


   

so pegg
heur istic 
adjsum

cpu sec
 steps acts 

   
    
pe
   
           
pe

   
    
pe

    
    
   
   
pe
    
    
    
    
   
me egbg
so pegg
    
    
   
   
pe

pe
   
me egbg
so pegg
    
    
    
    
pe

    
  
                         
pe

pe
   
pe
   
   
   
me egbg
so pegg
    
    




    
   
pe
            
pe
    
pe

pe

    
    
   
   
    
    
pe

pe
pe

pegg

heur  adjsum u

cpu sec
 steps acts 

speedup
 pegg
vs  gp e 

   
    
   
   
    
   
    
   
    
   
   
   

       
       
       
       
       
       
       
         
         
       
       
       
pegg
            
           
           
            
pegg
           
           
            
           
            
           
           
          
          
pegg
            
            
            
            
           
           
             
             
             
   
        
           
           

   x
    x
     x
    x
    x
   x
      x
  x
    x
   x
   x
  x
speedup
 x
    x
     x
    x
speedup
    x
   x
     x
   x
     x
     x
   x
    x
    x 
speedup
   x
   x
     x
   x
      x
    x
     x
     x
   x
    x
   x
    x

table    so pegg pegg comparison graphplan  gp e  me egbg
gp e  graphplan enhanced per section     me egbg  memory efficient egbg
so pegg  step optimal  search via pe  segments ordered adjusted sum u heuristic
pegg  beam search  best     segments pe ordered adjusted sum u heuristic
parentheses give    steps    actions  plan  boldface values exceed known
step optimal 
see table   definitions s  pg  pe
   

fiusing memory transform search planning graph

overhead due concise search trace  note obvious reason prefer one state
traversal order non solution bearing episodes since step optimal planners visit
states pe search episodes   
turning attention pegg results  apparent beam search greatly extends
size problems handled  pegg solves ten larger problems table   could
solved either so pegg enhanced graphplan  speed wise pegg handily outperforms
planners every problem except schedule      gp e factor    x advantage  indicated tables right hand column  speedup pegg gp e ranges    x
   x  conservative bound peggs maximum advantage relative gp e since speedup
values seventeen problems gp e fails solve conservatively assessed time
limit      seconds 
defer analysis results section   order first describe pegg algorithm
advantages extracts search trace 
    algorithm pegg planners
high level algorithm so pegg pegg given figure    graphplan  search begins planning graph extended level problem goals first appear
binary mutex conditions   the routine  find  st level with goals virtually
graphplans defined here   first search episode conducted graphplan fashion 
except assign goals assign next level goals routines figure   initialize pe
create search segments hold states generated regression search process  assign goals pseudo code outlines process compiling conflict sets  see appendix b  means
implementing ddb ebl action assignment search  assign next level goals
routine illustrates role top level conflict set recording minimal no good search
state completed  ebl  depicts variable ordering need done state
 when search segment created   child segment created linked parent  extending
pe  assign next level goals whenever parent goals successfully assigned  assign next level goals routine determines subgoals child search segment regressing
parents goals actions assigned checks see either initial state
reached remaining goals  so  success signaled returning child search segment used extract ordered actions plan 
subsequent first episode  pegg plan enters outer loop employs pe conduct
successive search episodes  episode  newly generated search segments previous
episode evaluated according state space heuristic  ranked  merged already ordered
pe  inner loop search segment visited turn passing subgoals graphplanlike assign goals routine 
exit conditions inner loop primarily differentiate so pegg pegg 
whereas so pegg visit every search segment whose goals found match memo 
pegg restricts visitation best subset  based user specified criterion  such  expansion
planning graph deferred segment chosen visitation transposes planning graph level exceeding current graph length  consequence  problems pegg
 

fact found advantages respect traversal order even intermediate search episodes problems  however  highly problem dependent  consider study 

   

fizimmerman   kambhampati

pegg plan  ops  init  goals      ops  init  goals  constitutes planning problem   
   build plangraph  pg  level n goals first occur non mutex state  

let pg find  st level with goals  ops  init  goals  
pg reached level off goals present non mutex state return fail
let n number levels pg
reorder goals according variable ordering method
let ss  new search segment fields 
goalsgoals  parent root  pe level    parent actions   
let pe pilot explanation structure fields  ranked segs  ss    new segs   

   conduct graphplan style backward search n length planning graph  storing trace pe    

let search reslt assign goals goals      n  ss   pg  pe 
search reslt search segment    success   
let plan extract plan actions ancestors linked search reslt
return plan
else    n length solution possible    use pe search longer length solution   
loop forever
n n  
   rank newly generated states merge existing ordered pe segments list   
pe ranked segs  merge sort pe ranked segs  u heuristic sort  pe new segs     

loop unvisited search segments pe ranked segs   optionally  segments
heuristic threshold 
let ss highest ranked  unvisited segment pes ranked segs
let k   n  pe level ss 
      planning graph level ss based transposed pe   
k   n pg extend plangraph pg       delays extending graph unavoidable    
optionally  flux metric ss goals   user specified threshold continue loop 
ss goals memos level k pg remove ss pes ranked segs
else    visit search segment ss      
search reslt assign goals  ss goals       k  ss  pg  pe 
search reslt search segment    success     
let plan extract plan actions ancestors linked search reslt
return plan
else search reslt conflict set  
add conflict set level k memos pg    memoize minimal nogood   
reorder ss goals goals conflict set appear first    ebl based reordering   
end
end loop
end

figure    top level algorithm pegg so pegg planners 
planners may able extract step optimal solution building one less level graphplan based planners  

 

interestingly  pegg beam search could conceivably extract optimal solution planning graph arbitrary number levels shorter required graphplan  consider case pe  average  extends least
one level deeper episode subset pe search segments visited always resides deepest levels pe 
arbitrary number search episodes might completed without extending planning graph  based experiments problems date however  advantage seldom saves one planning graph level extension 

   

fiusing memory transform search planning graph

conduct ddb   ebl enhanced graphplan style search building search trace
arguments  g  goals still assigned  a  action set already assigned  k  pg level 
ss   search segment  pg  planning graph  pe  pilot explanation  search trace 
assign goals  g  a  k  ss   pg  pe 
let g goal selected g
let ag actions pg level k support g  ordered value ordering heuristic
let cs  g     initialize conflict set ddb   
loop act ag
let search reslt     
act mutex action
let b goal conflicted action assigned support
cs cs u  b     augment conflict set continue loop  
else    act conflict actions already   
g  g  empty
   continue goal assignment level   
search reslt assign goals  g  g   u act   k  ss   pg  pe 
else    ss  goals left satisfy   setup search next lower level   
search reslt assign next level goals  a u act   k  ss   pg  pe 
search reslt conflict set  check contains current goal  
g search reslt
   absorb returned conflict set   try next action   
cs cs u search reslt
else return search reslt   just return conflict set   
else search reslt search segment     success     
return search reslt
end loop  actions 
return cs    soln reached    compiled conflict set returned  
end if
end
set search graph level k   given ss  goals satisfied actions level k
assign next level goals  a  k  ss   pg  pe 
let nextgoals regress ss  goals  the actions assigned satisfy goals 
nextgoals empty k      its initial state 
return ss     success   
else memos level k   pg nextgoals
return conflict set    backtrack due nogood   
else    initiate search next lower pg level  
let ss  new search segment holding nextgoals  pointer ss     actions assigned ss 
add ss  pe new segs list
let search reslt assign goals  nextgoals      k    ss   pg  pe 
search reslt search segment    success     
return search reslt
else search reslt conflict set    memoize minimal nogood return conflict set   
add conflict set level k   memos pg
reorder ss  goals goals conflict set appear first       ebl based reordering   
return search reslt
end if
end

figure    pegg   so pegg regression search algorithm graphplan style regression search
subgoals concurrently building search trace  pe 
   

fizimmerman   kambhampati

note peggs algorithm combines state space csp based aspects search 
chooses expansion promising state based previous search iteration
state space heuristics  pegg so pegg free traverse states search trace
order 
selected state expanded graphplans csp style  depth first fashion  making full use
csp speedup techniques outlined above 
first aspect clearly distinguishes pegg egbg  traversal state space pe
longer constrained bottom up level by level  egbg  management
memory associated search trace challenge pegg stray bottom up traversal  less daunting  easier outline address first discuss
development adaptation heuristics search trace traversal 
    informed traversal search trace space
hsp hsp r state space planners  bonet   geffner        introduced idea using
reachability propositions sets propositions  states  assess difficulty degree relaxed version problem  concept underlies powerful distance based heuristics selecting promising state visit  subsequent work demonstrated planning graph
function rich source heuristics  nguyen   kambhampati         since planning
graph already available pegg  adapt extend heuristics latter work serve
secondary heuristic role direct peggs traversal search trace states  again  primary heuristic planning graph length iteratively deepened  section       step optimality
guarantee so pegg planner depend admissibility secondary heuristic 
important differences heuristic ranking states generated state space planner ordering search segments  states  peggs search trace  example  state space
planner chooses visit given state pegg planners often must consider whether
revisit state many consecutive search episodes  ideally  heuristic rank states search
trace reflect level by level evolutions planning graph  since transposition process
associates search segment higher level successive episode  higher planning
graph level given state associated with  effective regression search space
changes complex function number new actions appear graph  number
dynamic mutexes relax  no goods memo caches  moreover  unlike state space
planners queue previously unvisited states  states search trace include children
state generated last visited  ideally value visiting state assessed independently value associated children  since assessed turn  referring back search trace depicted figure    desire heuristic can  example  discriminate    ranked search segment ancestor  top goal segment  wxyz  
would heuristic assessment segment wxyz discount value associated children already present trace  ranked based potential generating new local search branches 
next discuss adaptation known planning graph based heuristics effective use
search trace 

   

fiusing memory transform search planning graph

      adoption distance based state space heuristics
heuristic value state  s  generated backward search problem goals expressed as 
    

f       g       w    h   
where  g s  distance problem goals  e g  terms steps 
h s  distance estimate initial state  e g  steps 
w  optional weighting factor

value g state generated search  e g  states pe  easily assessed
cumulative cost assigned actions point  h values consider taken
distance heuristics adapted exploit planning graph  nguyen   kambhampati 
       one heuristic readily extractable planning graph based notion
level set propositions 
set level heuristic  given set propositions  denote lev s  index first level
leveled serial planning graph propositions appear non mutex one another   if singleton  lev s  index first level singleton element
occurs   level exists  lev s     
admissible heuristic embodies lower bound number actions needed achieve
initial state captures negative interactions actions  due planning graph binary mutexes   nguyen   kambhampati       study  set level heuristic
found moderately effective backward state space  bss  planner altalt  tended result many states f value  directing search peggs search trace
somewhat effective  still suffers lower level discrimination
heuristics examined  especially problems engender planning graph relatively
levels  nonetheless  noted appendix b discussion memory efficiency improvements
use planning graph construction default heuristic value ordering  due low
computational cost synergy building using bi partite planning graph 
inadmissible heuristics investigated nguyen   kambhampati       work based
computing heuristic cost h p  single proposition iteratively fixed point follows 
proposition p assigned cost   initial state otherwise  action  a  adds
p  h p  updated as 
     h p     min  h p     h prec a   
h prec a   sum h values preconditions action a 
given estimate propositions h value  variety heuristic estimates state
studied  including summing h values subgoal taking maximum subgoal hvalues  study focus heuristic termed adjusted sum  nguyen   kambhampati         combines set level heuristic measure sum h values states
goals  though powerful heuristic tested them  computationally cheap planning graph based planner found quite effective bss planners tested 
adjusted sum heuristic  define lev p  first level p appears plan graph
lev s  first level plan graph propositions state appear nonmutexed one another  adjusted sum heuristic may stated as 
   

fizimmerman   kambhampati

    

hadjsum       

h  p       lev s   max lev  p    


pi

pi



  part heuristic  summation  estimate cost achieving assumption goals independent  estimate cost incurred negative interactions
amongst actions must assigned achieve goals  latter factor estimated taking
difference planning graph level propositions first become non mutex
level propositions first appear together graph 
complex heuristics proposed include measure positive interactions subgoals state  is  extent action establishes one relevant subgoal  so called relaxed plan distance based heuristics focus positive interactions 
several studies demonstrated power backward forward state space planners
 nguyen   kambhampati        hoffman         however  reported former study  primary advantage adding positive interactions adjusted sum heuristic produce shorter
make span plans expense modest increase planning time  since peggs ida  search
already ensures optimal make span little incentive incur expense relaxed plan
calculation  restricted work simpler adjusted sum heuristic eqn     
adjusted sum heuristic adapted search planning graph leveraging
information peggs search trace  takes form heuristic updating dynamically improve h value estimate states pe  lev s  term adjusted sum heuristic represents
first planning graph level subgoals state appear binary non mutex
other  however  regression search graph level k fails given episode  search
process essentially discovered n ary mutex condition subset goals
level k  this subset conflict set  c  gets memoized pegg algorithm figures  
    point lev s  value updated k    indicating k   conservative estimate
first level goals appear n ary non mutex state  desirable property
ranking search trace states  longer state resides search trace  often h value gets
increased  less appealing becomes candidate visit again  is  heuristic update
biases states visited failed extend solution  use
augmented adjusted sum heuristic pegg runs work refer adjusted sum u 
experimentally  find advantage given heuristic ordering pe states highly
domain dependent  but less sensitive particular domain problem   example  compared
simple bottom up visitation strategy  adjusted sum u heuristic improves so pegg runtimes
order magnitude domains  e g  freecell and  satellite  degrading
factor  x  x others  e g  zenotravel   figure   depicts performance adjusted sum u
heuristic relative bottom up heuristic so pegg several sets problems  heuristics compared terms so peggs average computation time percentage gp es
final search episode  the important measure exhaustive search planning graph 
informed heuristic find seed segment sooner but  event many
 typical logistics domains   find one lies planning graph level closer
initial state  less informed heuristic may cause pegg end conducting search final
episode gp e  may many states pe would regenerated graphplan
final regression search finds solution  direct measure power

   

fiusing memory transform search planning graph

bottom up

adjusted sum u

depot
schedule

problem set

zenotravel
freecell
driverlog
satellite
logistics
blocks
tsp
    

     

     

     

                          

  graphplan s search cost final episode

figure    heuristic accuracy so pegg final search episode   relative gp e
search segment selection heuristic  since performance vary considerably specific problem results figure averages three representative examples domain   
    memory management arbitrary search trace traversal order

return memory management problems induced strategy skipping
search space  consider pe time final search episode figure    search segments visited order deepest pe level first  encounter problem regenerating states already contained pe  visitation order depicted numbered segments
figure could result fairly informed heuristic  the  th segment chooses visit plan
segment   implies many states already resident pe regenerated  includes 
example  yet unvisited descendents third segment visited  unchecked  process
significantly inflate search trace memory demands well overhead associated regenerating search segments  addition  heuristic information state lost state regenerated instead revisited extant pe search segment  due adjustedsum u secondary heuristic pegg learns improved n ary mutex level search segments goals
updates f value accordingly search episode 
address issue hashing every search segment generated associated pe state hash
table according canonically ordered goal set  one hash table built pe level 
prior initiating regression search subgoal set search segment  sn   pegg first checks
planning graph memo caches and  relevant memo found  checks pe state hash table
see sns goals already embodied existing pe search segment relevant pe level 
  

problem sets used  blocksworld  bw large b  blocks           logistics  att log a  logistics             gripper 
gripper   gripper x    x    depot  depotprob                   driverlog  dlog     a        a       e  zenotravel 
ztravel    a      b     b  freecell  freecell                  satellite  strips sat x    x    x   

   

fizimmerman   kambhampati

search segment  se   returned pe state check  se made child sn  if already  establishing link  search proceed se goals   
another search trace memory management issue associated fact pegg visits
subset pe states  a set call active pe  tempting pursue minimal memory
footprint strategy retaining memory active search segments pe  however unlike
graphplan  initial state reached pegg cannot extract solution unwinding complete sequence action assignment calls since may begun regression search arbitrary state branch search trace tree  pegg depends instead link child
search segment parent extract plan actions solution found  must
retain minimum  active search segments ancestor segments root node 
beyond requirement retain search segments tied active pe  many strategies
might used managing inactive portion  study attempted reduce
pe memory requirements manner  instead focusing might termed search space
field view  beam search  heuristic effectiveness depends informed is 
search trace states available rank  reduced memory footprint peggs skeletal
search trace allows us adopt strategy retaining memory search segments generated 
segments f values updated ranked  giving beam search wide selection states contending active status given search episode 
    learning order states subgoals

pegg planners employ ebl search trace  allows overlay yet
sophisticated version variable ordering top distance based ordering heuristic  guiding
principle variable ordering search fail early  failure inevitable  terms graphplan style search regressed state  translates since state goals must assigned action  best attempt satisfy difficult goals first  adjusted sum heuristic described
above  applied single goal  provides estimate difficulty based structure
planning graph  however  ebl provides additional information difficulty goal achievement
based directly search experience  wit  conflict set returned peggs assign goals routine search goal set explicitly identifies goals responsible search failure  intuition behind ebl based reordering technique then 
goals likely difficult assign search segment revisited next
search episode  constitutes dynamic form variable ordering that  unlike distance based
ordering  search segments goals may reordered successive search episodes based
recent search experience 
figure    compares influence adjusted sum variable ordering ebl based reordering
methods memory demand  manner similar figure    impact ebl based reordering egbgs performance reported pegg tightly integrates various csp efficiency methods  independent influence cannot readily assessed    isolate impact
ebl based reordering ebl activating ebl using produced con  
  

interests simplicity  figure   algorithm outline memory management process 
given success various memory efficiency methods within egbg  versions pegg implement
default  graph analogous figure   pegg planner would differ terms actual memory reduction values  confident overall benefits methods would persist  would relative benefit relationship
methods 

   

fi  
  

variable ordering  adjsum    eblreordering
variable ordering
ebl  reordering
  

  reduction pe  search trace  memory requirement

using memory transform search planning graph

  
  
  
  reduction planning graph  memo cache memory requirements

figure     memory demand impact along two dimensions adjusted sum
variable ordering ebl based reordering techniques applied
independently together 
flict sets reordering  memoization  average reduction search trace memory
   problem sample seen     ebl based reordering alone  compares
favorably     average reduction distance based ordering  especially since  unlike
adjusted sum ordering  ebl based reordering takes effect  nd search episode  plot
reveals two modes ordering quite complimentary 
across variety problems domains found following approach effective
combining distance based variable ordering ebl based reordering     newly created search
segments goals ordered according distance based heuristic     visit search
segment  subset goals appear conflict set reordered appear first     goals
conflict set ordered distance based heuristic appended non conflict goals 
set distance based order 
indicated figure     hybrid form variable ordering boosts average memory reduction almost      significantly reduces wide fluctuation performance
either method isolation  re emphasize search experience informed goal ordering
available search algorithm maintains memory states visited  therefore
portable graphplan based planner know of 
    trading guaranteed step optimality speed reach 
pegg beam search

many difficult benchmark problems graphplans ida  style search   
search episodes reaching episode solution extracted  cumulative search time tied episodes large portion total search time and  indicated
table    so pegg exhausts search time limits well reaching episode solution
extracted  strategy exhaustively searching planning graph  episode
solution bearing level  gives step optimal guarantee graphplans solutions exact
   

fizimmerman   kambhampati

high cost ensure is  all  one aspect plan quality  explore pegg  nonexhaustive search version so pegg  extent search episodes truncated
producing plans virtually makespan graphplans solution 
pegg shortcuts time spent search intermediate episodes using secondary
heuristic direct order pe states visited prune search space visited
episode  beam search seeks visit promising pe states  measured
f values user specified limit  addition  beam search important dual benefit
pegg reduces memory demands search trace and  depending
problem  even planning graph  pegg algorithm figure    loop statement
point beam search f value threshold optionally applied pe states candidates visitation  first segment exceeding threshold reached sorted queue
search episode ends 
devise effective threshold test must reconcile competing goals  minimizing search nonsolution bearing episodes maximizing likelihood pe retains visits  preferably
early possible   search segment thats extendable solution graph reaches first
level extant solution  narrower window states visited  difficult
heuristic ranks states ensure includes plan segment  i e  one part stepoptimal plan  pegg return step optimal plan long search strategy leads visit
plan segment  including top  root segment pe  belonging plan latent pe  search first solution bearing planning graph  heuristics job selecting window
search segments visit made less daunting many problems many step optimal
plans latent solution bearing level 
next describe effective planning graph based metric augments state space heuristic
choosing set pe states visit search episode 
      mining planning graph filter beam
beyond heuristic updating introduced section    distance based heuristics virtually
insensitive planning graph evolution search segment transposed successive levels  since
search trace contains children states generated regression search state episode n  heuristic preference include states trace visit episode n  
reflect chance directly generate new promising search branches  child states
search episode n competitors s  ideally heuristics rank reflect
sense value visiting state beyond importance children 
consider sensitivity adjusted sum heuristic  or distance based heuristics 
possible differences implicit regression search space set propositions  s  planning graph level k versus level k    given propositions present binary non mutex
level k  cost summation factor equation     could conceivably change
evaluated level k    would require two conditions  new action must establish one
propositions first time level k   actions precondition costs must sum less
precondition costs establisher proposition  practice happens infrequently since later action appears graph construction process  higher cost tends
be  consequently h values states based distance based heuristics remain remarkably constant planning graph levels beyond propositions appear binary non   

fiusing memory transform search planning graph

mutex    desire means compensating static h value state transposed planning graph level promising new branches regression search open up 
likelihood state visited episode n graph level k give rise new child states
visited episode n   level k   rooted graph dynamics summarized observations a  
a   appendix a  three planning graph memo cache properties determine whether regression search subgoal set evolve successive episodes 
   new actions level k   establish subgoal
   dynamic mutexes level k actions establishing subgoals relax
level k  
   no good memos encountered regression search state episode n
encountered level k    and converse  
set measures potential new search branches result visiting state pe
refer flux  intuition higher flux  likely search
given state differ seen previous search episode  and captured pe   none
three factors applies state consideration  point visiting it  new
search result relative previous episode 
first factor readily assessed state  thanks part bi partite graph structure   second flux factor unfortunately expensive assess  direct measure requires storing
pairs attempted action assignments goals inconsistent episode n retesting new planning graph level  however  graph mechanics relaxation
dynamic mutex two actions level k requires relaxation dynamic mutex condition
pair preconditions level k    one precondition action   relaxation  turn  either due one new establishing actions preconditions level k  
recursively  relaxations existing actions establishing preconditions  such  number new
actions establishing subgoals state pe  factor   above  provide measure
flux s  predictor flux due factor   parent  and higher ancestors  s 
thus  turns simply tracking number new actions state subgoal current level propagating appropriately weighted measure parent  compile useful
estimate flux factors     above 
third flux factor unwieldy costly estimate  exact measure requires
storing child states generated regression search level k caused backtracking due
cached memos  retesting see memos present level k      ignoring
factor  sum two flux measures depend new actions derive filtering metric
used assist largely static adjusted sum distance based heuristic culling
beam  resulting  inexact  metric sensitive evolution search potential state transposed higher planning graph levels 

  

this  part  explains observation  nguyen   kambhampati        altalt state space planner performance
generally degrades little planning graph used extract heuristic values built level problem goals appear non mutex  rather extending level off 
  
note long using ebl ddb  sufficient test whether memo exists child state 
no good goals contribute conflict set used direct search within whenever backtracking occurs 

   

fizimmerman   kambhampati

    

flux     

newacts  p  


pi

 s 

  wcf

childflux s  

si c



where  pi proposition state
newacts pi  number new actions establish proposition pi
associated planning graph level
    normalization factor  number propositions
sc set child states currently represented search trace
childflux si  sum two flux terms eqn     applied child state si
wcf weights contribution flux child states parent state

number new actions establishing subgoals state normalized relative number subgoals state 
report elsewhere  zimmerman        use flux directly augment secondary
heuristic  depending domain weighting flux contribution adjusted sum heuristic  speedups order magnitude observed    however impact highly domain
dependent since primarily concerned performance general purpose planner 
study consider use beam filter 
beam search  flux measure strongly impact every search episode  influences
states actually included active pe  used mode  search segments assessed
flux specified threshold skipped even f value places active pe 
flux proves broadly effective across domains used mode  mentioned
section      use flux cutoff search episode     average flux search segments pe  segment value visited regardless heuristic rank 
setting impact speedup pegg column problems table   ranges nil factor
 x peggs performance without flux filter  higher settings dramatically speed
solution search  often expense greater solution makespan 
      peggs ability find step optimal plans
variety parameters associated beam search approach described admits considerable flexibility biasing pegg towards producing plans different quality  shorter makespan plans
favored extensive search pe states episode heuristically truncated
search tends generate non optimal plans quickly  often containing redundant unnecessary
actions  settings used study clearly bias pegg solutions towards step optimality 
step optimal plan produced enhanced graphplan matched pegg four   
problems reported table    indicated annotated steps actions numbers given parenthesis next successful gp e pegg runs     pegg solutions longer makespan
step optimal boldface step action values   four problems  pegg returns solutions
  

example  compared simple bottom up visitation strategy  flux augmented adjusted sum heuristic improves
so pegg runtimes   x domains  e g  freecell and  satellite  degrading much  x  x
others  e g  zenotravel  

  

one guaranteed step optimal planners  gp e  me egbg so pegg  finds solution steps
actions reported one them  since makespan 

   

fiusing memory transform search planning graph

problem

n best first
pegg
 n      state space search    adjusted sum u heuristic beam search
    best search segments 

satplan
 optimal 

bw large a

 

 

    s 

 

bw large b

  

       s 

 

bw large c

  

         s 

  

bw large d

  

        s 

  

table    quality comparison  in terms plan steps  pegg n best beam search
forward state space planner  bonet et al         
within four steps optimum  spite highly pruned search  proved fairly robust
property peggs beam search settings across problems tested date 
pegg adjusted sum u secondary heuristic often finds plans fewer actions
gp e parallel domains  graphplan hybrid system impressive serial domains
blocksworld  which exactly graphplans forte  
tactic trading optimal plan length favor reduced search effort well known
planning community  comparison  peggs beam search approach biased towards producing
high quality plan possibly expense runtime  example  paper focusing
action selection mechanism planning  bonet et  al  briefly describe work n best
first algorithm  bonet  loerincs    geffner         employ distance based heuristic
conduct beam search forward state space planning  report small set results case
    best states retained queue considered search 
table   reproduces results alongside peggs performance problems using beam
search  here  approximate n best algorithm  pegg run     states visited
intermediate search episode       study compared n best first approach satplan 
produces optimal length plan  make point approach could produce plans reasonably close optimal much less search  n best first code available run
test platform  peggs runtime reported  focusing plan makespan  clear even
serial domain  parallel planner pegg produces much shorter plan n best first
state space approach  fact finds optimum length plan generated satplan cases 
recently lpg  gerevini   serina         another planner whose search tightly integrated
planning graph  awarded top honors aips      planning competition  due
ability quickly produce high quality plans across variety domains currently interest 
figure    scatter plot  solution quality terms steps lpg pegg compared
optimal    problems three domains      aips planning competition  chose
particular problems optimal solution known  interested comparing
quality baseline  lpgs results particularly apt case  planner nonexhaustively searches planning graph level extending it  although search process
differs markedly peggs  lpg  too  biased produce plans higher quality  generally
expense speed  report competition results quality mode  terms
number actions solutions neither planner consistently dominates problems
pegg clearly excels step optimality  maximum deviation optimum four steps
   

fizimmerman   kambhampati

  

lpg  dlog

  

lpg  depot

steps optimal

  

lpg  ztravel

  

pegg  dlog

  

pegg  depot

 

pegg  ztravel

 
 
 
 
 

 

 

 

 

  

problem number

  

  

  

  

figure     makespan comparison pegg lpg  departure step optimal
plan length   lpg data taken aips      competition results  
plot points solutions lie right optimal makespan axis  possible
sets actions within lpgs solutions could conducted parallel algorithms quality
mode heuristic insensitive  
noted lpg produced solutions difficult problems domains
pegg currently solve within reasonable time limit  investigating characteristics
problems make difficult pegg 
      pegg compared heuristic state space search
attempted run pegg head to head speed recent ipc planners  part
due platform difficulties  pegg written lisp competition planners generally
coded c published results based execution competition machines  partly
due focus near optimal makespan parallel plans rather speed  given peggs close
coupling planning graph  relevant comparisons parallel planners
employ graph form  comparisons  would isolate search component runtime planning graph construction  since variety routines produce essentially graph widely different expenditures computational time memory  reported runtimes lpg planner aips    competition generally much
smaller peggs  difficult isolate impact graph construction platform related
effects  mention disparity makespan plans produced 
table   compares pegg lisp version fast distance based heuristic state space planner using problems table    altalt  srivastava et al          pegg  depends
planning graph derive powerful heuristics uses direct regression search
problem goals  facilitates planner performance comparison based differences search without confusing graph construction time issues  last column table   reports altalt performance
 runtime makespan  two effective heuristics developed planner  nguyen  
kambhampati         first adjusted sum heuristic described section       

   

fiusing memory transform search planning graph

problem
bw large b
bw large c
bw large d
rocket ext a
att log a
att log b
gripper  
gripper   
gripper   
tower  
tower  
 puzzle  
 puzzle  
tsp   
aips     
grid y  
gripper x  
gripper x  
log y  
mprime  
aips     
blocks     
blocks     
blocks     
logistics     
logistics     
freecell    
schedule    
aips     
depot     
depot     
driverlog      e
driverlog      
roverprob    
roverprob    
roverprob    
sat x  
sat x  
ztravel    a
ztravel    a

pegg
heuristic  adjusted sum u
cpu sec  steps acts 
   
    
   
   
   
    
   
    
      
   
    
   
   
   

       
       
       
      
       
       
       
       
       
         
         
       
       
       
pegg
            
   
       
   
       
            
         
pegg
           
           
            
            
            
           
   
      
pegg
           
            
            
   
       
  
      
   
         
   
         
           
          
   
       
           

alt alt  lisp version 
cpu sec     acts 
heuristics 
combo
adjusum 
                        
                      
          
 
                       
                       
                     
          
 
           
          
                      
          
 
           
 
                       
           
          
                     
alt alt
          
          
         
         
        
          
        
          
           
          
alt alt
          
         
          
          
          
        
        
         
alt alt
         
         
          
         
          
          
           
         
          
        
          

table    pegg state space planner using variations adjusted sum heuristic
pegg  bounded pe search  best     search segments visited search episode  ordered
adjusted sum u state space heuristic
altalt  lisp version  state space planner two effective planning graph distance based
heuristics  adjusum  combo  combo results reported problems since
adjusum  produces plans competitive pegg terms makespan  

   

fizimmerman   kambhampati

surprisingly  majority problems pegg returns parallel  generally step optimal plan faster
altalt returns serial plan   altalt cannot construct plan parallel actions  however recent
work highly modified version altalt does  fact  construct plans  nigenda   kambhampati         pegg plans seen comparable length  terms number actions  best altalt plans 
   discussion results

distinguishing feature egbg pegg planners relative planners exploit
planning graph  aggressive use available memory learn online episodic search
experience expedite search subsequent episodes  although employ search trace
structure log experience  egbg pegg systems differ content granularity search experience track aggressiveness use memory  differ
confront common problem faced learning systems  utility learned information
versus cost storing accessing needed 
first efforts focused primarily using search trace learn mutex related redundancies
episodic search process  although resulting planners  egbg me egbg  avoid virtually redundant mutex checking based search experience embodied pes  empirically
find limited class problems winning strategy  utility tracking
mutex checking experience search function number times information
subsequently used  specifically 
eps   p  

     u mt   p 

pe

visit

  e 

pe

add

 e 

e   
eps   p  
e   

where  umt utility tracking mutex checking experience
p planning problem
eps p  number search episodes problem p
pevisit  e  number pe search segments visited search episode e
peadd  e is number new search segments added pe episode e
thus payback egbgs incurred overhead tracing consistency checking experience
search depends number times sets revisited relative total number subgoal
sets generated  and added pe  problem run  characteristic explains less
 x speedups observed me egbg many table   problems  approach handicap single search episode problems  ineffectual problems final search episode search generates large number states relative previous episodes seed segment s 
top levels pe  due need bottom up visitation search segments egbgs
search trace  
pe thought snapshot regression search reachable  rs reachable  states
search episode  is  regression search process generates state level k
planning graph  state reachable search higher levels graph future search
episodes  essentially  search segments pe represent rs reachable states 
   

fispeedup wrt enhanced graphplan

using memory transform search planning graph

so pegg  log

      

pegg  log
so pegg  ztravel
pegg ztravel

     

    

   
 
   

 

 

 

 

 

 

search episodes problem

figure     speedup vs  number search episodes  logistics     zenotravel     domains
candidate set partial plans segments state current tail state plan  table     results indicate utility learning states rs reachable given search
episode generally outweighs utility learning details episodes consistency checking 
require much less memory  freed need regenerate rs reachable states ida  fashion search episode  pegg visit states heuristically preferred order 
tables        shed light several classes problems problematic search trace
guided search planning graph 
   domains high branching factors operator descriptions thwart ddb ebl
 e g  larger schedule  satellite  zenotravel domain problems 
   problems significant fraction runtime consumed planning graph construction 
 e g  grid domain   dlog      e  freecell     
   problems one two search episodes   grid y    schedule     
problems first class  graphplan style csp assignment search prone bogging
certain pe states selected visitation  second class search time
reduction dominated large graph construction time  a problem shared planner
builds complete planning graph   problems third class give pegg sufficient
opportunity exploit pe  since built first episode  and first episode pe typically
small  benefit subsequent episodes  aspect peggs behavior illustrated
figure     speedup factors so pegg pegg  under beam search  plotted
series problems ordered according number search episodes graphplan would conduct prior finding solution  data gathered running gp e  so pegg  pegg
planners two different domains  the logistics domain aips    planning competition 
zenotravel domain aips    competition  averaging speedups observed
problems number observed search episodes  downturn pegg  ztravel
curve seven episodes surprising given one problem
many factors beyond number search episodes impact solution time  noting speed   

fizimmerman   kambhampati

ups plotted logarithmic scale  power search trace given multiple search episode problems evident  pegg using beam search handily outperforms so pegg problems three
search episodes  largely shortcuts exhaustive search intermediate episodes 
several avenues addressing above listed limitations pegg explored anticipate investigating  example  unlike n best first state space planner reported
table    pegg enforces user specified limit state f values selecting pe search
segments visit  search segment chosen visitation  graphplan style regression search
state goals continues either solution found sub branches fail  greedy
approach would apply heuristic bound regression search  is  could
backtrack whenever state generated exceeds f value threshold applied search segments
visited  translates greedy best first search  gbfs  algorithm employed
hsp r  bonet   geffner        state space search  form hill climbing search planning graph 
experimentally find pegg adapted enforce pe state f value limit
regression search  improvements unpredictable best  speedups factor    
observed cases  all logistics problems  many cases runtimes increased search failed
entirely within time limit  addition  quality  make span  returned solutions suffered
across broad range problems  two factors may explain result     peggs regression search greatly expedited ddb ebl  regressed conflict set rely
undefined regression search space state fully explored  fvalue limit enforced  without conducting search informed basis returning anything full set subgoals state  essentially forces search towards chronological backtracking     assessing f value newly generated state compare fvalue bound based states generated previous episodes problematic 
heuristic values pe states determine f value bound increased peggs use
search experience improve h value estimates  section        
degradation solution quality shift pegg closer greedy search approach may indicator peggs ability return step optimal plans  as evidenced table   results  rooted
interleaving best state selection pe graphplan style depth first search
states subgoals 
   related work

focus related alternative strategies employing search heuristics planning  generating parallel plans  making use memory expedite search  related work pertaining
search techniques  efficiencies  data structures enable egbg pegg successfully
employ search trace cited arose considered here   
noted section      shortcoming ida  search  and graphplan  inadequate use
available memory  information carried one iteration next upper
bound f value  exploitation search trace directly addresses shortcoming serving
memory states visited search space previous episode order reduce redun  

support methodologies include memory efficient bi partite planning graph models  explanation based learning dependency directed backtracking context planning graph search  variable value ordering strategies  evolution
extraction distance based heuristics planning graph 

   

fiusing memory transform search planning graph

dant regeneration  respect peggs search closely related methods mrec  sen 
anup   bagchi         ma   sma   russell        lie middle ground
memory intensive a  ida s scant use memory  central concern algorithms
using prescribed amount available memory efficiently possible  egbg pegg 
retain much search experience memory permits avoid repeating regenerating
nodes  depend heuristic order nodes memory visitation  unlike search trace
based algorithms though  three algorithms backup deleted nodes f value parent node  ensures deleted branch re expanded promising node remains open list  implemented extended memory management pegg
 though would straight forward so  primarily because  least beam search  pegg
seldom confronted pe related memory limitations 
egbg pegg first planners directly interleave csp state space views problem search  related approaches synthesize different views planning problem 
blackbox system  kautz   selman       constructs planning graph instead exploiting
csp nature  converted sat encoding extension k step solution
sought  gp csp  do   kambhampati         similarly alternates extending planning
graph converting it  transforms graph csp format seeks satisfy constraint
set search phase 
beam search concept employed context propositional satisfiability gsat  selman  levesque    mitchell        option blackbox planner  kautz   selman        
systems greedy local search conducted assessing episode  n best flips
variable values randomly generated truth assignment  where best flips lead
greatest number satisfied clauses   n flips fail find solution  gsat restarts new
random variable assignment tries n best flips  several important differences
relative peggs visitation n best search trace states  search trace captures state aspect engendered graphplans regression search problem goals such  pegg exploits
reachability information implicit planning graph  conducting search purely propositional level  sat solvers leverage global view problem constraints cannot exploit
state space information  whereas gsat  and blackbox  improve performance based
experience one n best search episode next  pegg learns variety modes  improving heuristic estimate states visited  reordering state goals based prior search experience  memorizing general no goods based use ebl 
pegg  lpg system  gerevini   serina        heavily exploits structure planning graph  leverages variety heuristics expedite search  generates parallel plans  however 
lpg conducts greedy local search space composed subgraphs given length planning
graph  pegg combines state space view search experience graphplans csp style
search graph itself  lpg systematically search planning graph heuristically
moving extend it  guarantee step optimality forfeited  pegg operate either
step optimal mode modes trade optimality speed varying degrees 
currently investigating interesting parallel lpgs ability simultaneously consider
candidate partial plans different lengths  principle  nothing prevents pegg
simultaneously considering given pe search segment sn  terms heuristic rankings
transposed onto various levels planning graph  tantamount simultaneously consider   

fizimmerman   kambhampati

ing arbitrary number candidate partial plans different implied lengths extend first
 each partial plan sn tail state   search trace proves useful
regard state contains transposed desired number levels  subject
ability extend planning graph needed  heuristics re evaluated level  referring back figure    first search episode pictured  top   yj state pe could
expanded multiple distinct states transposing graph level   levels       higher 
heuristically evaluating level  graph level indexed instances yj
simultaneously compared  ideally wed move directly visiting yj planning graph level   
since point becomes plan segment problem  bottom graph figure     secondary heuristic discriminate solution potential state sequential levels
transposed to  effective means shortcutting graphplans level bylevel search process  flux adjunct likely one key boosting sensitivity distancebased heuristic regard 
generating assessing arbitrarily large number graph level transposed instances pe
states would prohibitive terms memory requirements store multiple versions
pe  however simply store level specific heuristic information search segments
single pe values indexed associated planning graph levels  challenging issues include
things range plan lengths considered one time potential plans
steps consisting entirely persists actions 
havent examined pegg context real time planning here  use search
trace reflects flavor real time search methods  lrta   korf       
variants b lrta   bonet  loerincs    geffner          a variant applies distance based
heuristic oriented planning problems  real time search algorithms interleave search execution 
performing action limited local search  lrta  employs search heuristic based
finding less than optimal solution improving heuristic estimate series iterations 
associates h value every state estimate goal distance state  similar h values
a    always first updates h value current state uses h values successors move successor believed minimum cost path current state goal 
unlike traditional search methods  act real time amortize learning consecutive planning episodes solves planning task repeatedly  allows find suboptimal plan fast improve plan converges minimum cost plan 
lrta   pegg search process iteratively improves h value estimates states
generated determines optimal make span plan  unlike lrta   pegg doesnt actually
find sub optimal plan first  instead converges minimum cost plan either exhaustively extending candidate partial plans monotonically increasing length  so pegg  extending
promising candidates according secondary heuristic  pegg beam search   realtime version pegg closely related lrta  might based method described above 
search segments simultaneously transposed onto multiple planning graph levels 
mode pegg would biased search quickly plan length  search anytime
fashion progressively shorter length planning graphs lower cost plans 
methodology direct relevance work reported elsewhere multi pegg
 zimmerman   kambhampati        zimmerman        version pegg operates anytime fashion  seeking optimize multiple plan quality criteria  currently multi pegg first re 

   

fiusing memory transform search planning graph

turns optimal make span plan  exploits search trace novel way efficiently
stream plans monotonically improve terms quality metrics  discussed paper 
important step away multi peggs bias towards make span plan quality metric would
modification  co mingling versions state transposed onto multiple planning
graph levels would enable planner concurrently consider visitation candidate search segments might seed segments latent plans various lengths 
   conclusions

investigated presented family methods make efficient use available memory
learn different aspects graphplans iterative search episodes order expedite search
subsequent episodes  motivation  design  performance four different planners build
exploit search trace described  methods differ significantly either information
content trace manner leverage it  however  cases high level
impact transform ida  nature graphplans search capturing aspect search
experience first episode using guide search subsequent episodes  dynamically updating along way 
egbg planners employ aggressive mode tracing search experience pegg
planners  track use action assignment consistency checking performed search
subgoal set  state  minimize effort expended state next visited  egbg approach found memory intensive  motivating incorporation variety techniques
planning csp fields which  apart well known speedup benefits  shown
dramatic impact search trace planning graph memory demands  resulting planner 
me egbg  frequently two orders magnitude faster either standard graphplan egbg
problems handle  generally fastest guaranteed step optimal approaches
investigated  comparisons gp e  version graphplan enhanced space saving
speedup techniques  me egbg solves problems average   times faster 
pegg planners adopt skeletal search trace  design conducive informed traversal search space  ultimately proves powerful approach exploiting
episodic search experience  adapt distance based  state space heuristics support informed traversal states implicit search trace describe metric call flux effectively
focuses search states worth visiting  flux measure sensitive potential search
trace state seed new search branches transposed higher planning graph levels 
describe new techniques leverage search experience captured search trace
demonstrate effectiveness 
so pegg planner  me egbg  produces guaranteed optimal parallel plans similarly
averages  x speedup gp e  greatly reduced memory demands allow so pegg handles
one    problems me egbg exceeds available memory  compelling evidence speedup potential search trace guided planner provided pegg beam
search  since longer exhaustively searches planning graph episode  pegg sacrifices
guarantee returning optimal make span plan  nonetheless  even beam search limited
best     pe states episode  pegg returns step optimal plan almost    
test bed problems comes within steps optimal others  speedups

   

fizimmerman   kambhampati

ranging almost two orders magnitude gp e  quite competitively modern state
space planner  which finds serial plans  
code pegg planners  including gp e  instructions running various
modes available download http   rakaposhi eas asu edu pegg html
acknowledgements

research improved many discussions binh minh do  xuanlong nguyen  romeo
sanchez nigenda william cushing  thanks david smith anonymous reviewers 
whose copious suggestions greatly improved presentation paper  research supported
part nsf grants iri         iis          darpa aasert grant daah            nasa grants nag       ncc      

appendix a  egbg planner

insight behind egbgs use search trace based characterization graphplans
search given beginning section     entailed observations 
observation a    intra level csp style search process conducted graphplan set propositions  subgoals    planning graph level k   episode n   identical search process
level k episode n if 
   mutexes pairs actions establishers propositions level k remain
mutex level k     this concerns dynamic mutexes  static mutexes persist definition 
   actions establishing proposition level k   present level k 
observation a    trace graphplans search episode n    set goals g  planning
graph level m    identical episode n search level if 
   two conditions observation a   hold every subgoal set  state  generated graphplan
episode n   regression search g 
   every subgoal set planning graph level j search episode n matching
level j memo  exists equivalent memo level j   generated episode n   
conversely  every subgoal set level j search episode n matching level j memo
existed time generated  matching memo level j   time generated episode n   

now  suppose search trace states  including no good states  generated graphplans regression search problem goals planning graph level episode n  search
failed extract solution m length planning graph  i e  reach initial state   necessary condition extract solution m   length graph one conditions
observations a   a   fails hold states episode n search trace 
observations a   a   mind  exploit search trace new episode
sound complete manner focusing search effort three situations could lead
solution     state variables newly extended value ranges  i e  search segment goals
least one new establishing action newly associated graph level      points previous search episode backtracked due violation dynamic constraint  i e  two actions
   

fiusing memory transform search planning graph

w

nop a 
ok ok
 



 

nop a 
ok sm

nop a 
ok sm

 

nop a 
ok ok

h

 



 

 

nop a  a 
ok sm ok
  nop a  

j

dm sm

nop a  nop a 
dm sm dm sm

nop a 
dm sm

figure a   bit vector representation search trace wyhij state figure   
semantics  ok   assigned  no action conflicts  sm   action static mutex previous assign
dm   action dynamic mutex previous assign
ng   no conflict action results no good state lower graph level

dynamic mutex      states matched cached memo episode n  assignment mutex checking operations involved satisfying set subgoals static across search
episodes 
experimented several search trace designs capturing key decision points  design
adopted egbg employs ordered sequence bit vectors  vector contains results
graphplans csp style action assignment process related given subgoal search segment 
efficient action assignment replay possible trace uses vectors two bit tags represent
four possible assignment outcomes     dynamic mutex     static mutex     conflict     complete  consistent set assignments rejected next level due memoized no good  figure a  illustrates sequence eight bit vectors used capture search experience search segment state goals wyhij figure   alpha problem  propositional goals  the variables  appear left sets bit vectors  depicted segmented bars 
encode outcome possible action assignment  the values   possible establishing
action goal appears bit vector tag 
numbered edges reflect order trace vectors initially created first
goal action tried  note whenever candidate action goal conflict free respect
previously assigned actions  indicated ok figure   action checking goal suspended  process jumps next goal  new bit vector initialized goals possible
establishers  edge numbering reflects order vectors popped
search segment trace list segment revisited next episode  scheme work 
bit vectors must pushed onto search segment trace list actions goal tried 
reverse numbered edge order  long edges skip one goals indicate
goals already established previously assigned actions 
long order actions appearing establishers list planning graph proposition remains constant  bit vectors used replay search next episode next
higher planning graph level  graph building routine egbg enforces constraint 

   

fizimmerman   kambhampati

egbg algorithm

high level egbg algorithm given figure a   graphplan  search planning
graph occurs extended level problem goals first appear
binary mutex conditions   the call find  st level with goals   first search episode conducted
graphplan fashion except assign goals routines figure a  create search segments
hold states trace information generated regression search process  necessary
trace information search segment captured trace vectors described above  segments stored pe structure indexed according level generated
 where current highest planning graph level corresponds   contains problem goals  
subsequent first episode  egbg plan enters outer loop employs pe conduct
successive episodes  referred search trace guided   search strategy alternates
selection visitation promising state trace previous experience  select searchseg from pe routine   focused csp type search states subgoals  the replay trace goals assign goals routines figures a  a   
episode  inner loop visits pe search segments level by level  bottom up fashion
 for reasons discussed section     extend plangraph routine called state
visited corresponds level beyond current graph length 
replay trace goals routine counterpart graphplans assign goals routine  except
avoids latters full blown mutex checking stepping trace vectors captured
previous search experience given state  unlike assign goals  branch child
states already contained pe  conditional checking trace vectors establishing
actions initiates new search calling assign goals two conditions     dynamic mutexes
previous episodes longer hold    new establishing actions appear subgoal  these
tried establishers replayed   dynamic mutex longer holds new
establishing action considered trace vector modified accordingly egbg resumes graphplans csp style search  adding new trace vectors search segment process 

   

fiusing memory transform search planning graph

egbg plan   ops  init  goals      ops init goals  planning problem   
   build plangraph  pg  level n goals first occur non mutex state  

let pg find  st level with goals  ops  init  goals  
pg reached level off goals present non mutex state return fail
let n number levels pg
let ss  new search segment fields 
goalsgoals  parentroot  pe level    parent actions    trace   
let pe pilot explanation structure fields hold search segments plangraph level
pe     ss        top level pe   
   conduct graphplan style backward search n length plangraph  store trace pe     

let search reslt assign goals goals      n  ss   pg  pe 
search reslt search segment    success   
plan extract plan actions ancestors linked search reslt
return plan
else    n length solution possible    use pe search longer length solution   
loop forever
n n  
loop pe lev ranging number deepest level pe    top level 
let k planning graph level associated pe level pe lev
  n pe lev      essentially translates pe one planning graph level   
pe lev     pg extend plangraph pg       must extend plangraph point   
loop search segments pe pe lev 
ss select searchseg from pe pe lev 
ssassigns ss trace     get ordered  goal by goal trace vectors search segment   
ss trace        clear search segment trace vectors field   
ss goals  memos k  pg    check nogoods level k   
goals match nogood level  loop next search segment
else    use ss trace avoid redundant search effort ss goals     
search reslt replay trace goals  ss goals       k  ssassigns  ss  pg  pe 
search reslt search segment
plan extract plan actions ancestors linked search reslt
return plan
else add ss goals  memos k  pg    memoize nogood   
end loop  search segments 
end loop  pe levels 
end loop  pg level 
end

figure a   egbg planner top level algorithm

   

fizimmerman   kambhampati

conduct graphplan style search subgoal set planning graph level k
arguments  g  goals still assigned  a  actions already assigned  k  pg level 
ss   search segment  pg  planning graph  pe  pilot explanation  search trace 
assign goals  g  a  k  ss   pg  pe 
g empty k      the initial state  return ss     success   
else    goals left satisfy  
let g assigns        trace vector hold ordered action assignment tags   
let g goal selected g
let ag   actions pg level k support g  ordered value ordering heuristic
loop act ag
let search reslt     
action dynamic mutex act append dm tag g assigns
else action static mutex act append sm tag g assigns
else    act conflict actions already   
g empty
   done g goals  setup search next lower level   
search reslt assign next level goals  a u act   k  ss   pg  pe 
search reslt nogood append ng tag g assigns
else append ok tag g assigns    search occurred lower level   
else    search continues level next goal   
append ok tag g assigns
search reslt assign goals  g  g   u act   k  ss   pg  pe 
end if
search reslt search segment return search reslt    success   
   else loop try another action  

end if
end loop  actions 
push g assigns trace field ss 
return nil    solution found   
end if
end

  add trace data search segment   

setup search graph level k   given actions satisfy goals ss  level k
assign next level goals  a  k  ss   pg  pe 
let nextgoals regress ss  goals assigned actions
nextgoals memos pg level k   return nogood    backtrack nogood goals   
else    initiate search next lower pg level  
let ss  new search segment fields 
goalsnextgoals  parentss   parent actionsa  trace  
add ss  pe level   maximum pg level   k   
let search reslt assign goals  nextgoals      k    ss   pg  pe 
search reslt nil    search level k   failed   
add nextgoals memos level k   pg   memoize nogood   
return search reslt
end if
end
assign new actions  g  a  ag  g  g assigns  k  ss  pg  pe 
   routine essentially assign goals  except attempts satisfy goal g actions
new actions  i e  first appearing recent plangraph extension   

figure a   egbgs non guided regression search algorithm

   

fiusing memory transform search planning graph

regression search using search trace  pe  replay
arguments  g  goals still assigned  a  actions already assigned  k  pg level 
ss   search segment  pg  planning graph  pe  pilot explanation  search trace 
replay trace goals  g  a  k  ss   pg  pe 
g empty    ss  goals branch successfully assigned last episode     
return       continue level k replay  ignoring search replay next lower level   
else    goals left satisfy  
let g select goal g
let g assigns pop front trace vector ss trace 
let ag set actions level k pg support g
   replay assignments g previous episode  rechecking may changed    

loop tag g assigns
let search reslt     let act pop action ag
tag   ok    act conflict actions last episode   go next goal   
search reslt replay trace goals  g  g   u act   k  ssassigns  ss   pg  pe 
else if tag  ng loop    last action assign level   act mutex last
episode   so next level regressed goals reside child search segment already visited   

else tag   sm loop    act static mutex action last episode   
else tag   dm    act dynamic mutex action last episode retest it     
dynamic mutex persists loop
else change tag ok g assigns vector    act longer mutex actions   
g  g  empty    resume backward search level   
search reslt assign goals  g  g   u act   k  ss   pg pe 
else    goals left satisfy ss   setup search lower level   
search reslt assign next level goals  a u act   k  ss   pg  pe 
search reslt  nogood change g assigns vector tag ng
end if
search reslt search segment return search reslt  success 
else loop  check next action 
end loop    establishment possibilities prior episode tried   now check new actions   
ag still contains actions    new actions establishing g level    attempt assign   
search reslt assign new actions g  a  ag  g  g assigns  k  ss   pg  pe 
search reslt search segment return search reslt    success   
else push g assigns ss  trace 
return nil    solution found search stemming ss  goals   
end if
end

figure a   egbgs search trace guided algorithm

   

fizimmerman   kambhampati

appendix b  exploiting csp speedup methods reduce memory demands

background implementation details provided six techniques planning
csp fields proved key controlling memory demands search trace based
planners  variable ordering  value ordering  explanation based learning  ebl   dependency
directed backtracking  ddb   domain preprocessing invariant analysis  replacing redundant multi level planning graph bi partite version 
domain preprocessing invariant analysis 
speedups attainable preprocessing domain problem specifications well
documented  fox   long        gerevini   schubert         static analysis prior planning
process used infer certain invariant conditions implicit domain theory and or problem
specification  domain preprocessing me egbg pegg fairly basic  focusing identification extraction invariants action descriptions  typing constructs  subsequent rewrite
domain form efficiently handled planning graph build routines  implementation discriminates static  or permanent  mutex relations dynamic mutex relations
 in mutex condition may eventually relax  actions proposition pairs  information used expedite graph construction me egbgs replay action assignments search segment visited 
domain preprocessing significantly reduce memory requirements extent identifies
propositions need explicitly represented level graph   examples
terms extracted action preconditions  and hence get explicitly represented
planning graph levels  include  smaller  x  y  term move action towers hanoi domain typing terms  auto  x   place  y  logistics domains   benefit
compounded egbg pegg since propositions removed action preconditions directly reduce size subgoal sets generated regression search episodes 
hence size search trace 
bi partite planning graph 
original graphplan maintains level by level action  proposition  mutex information
distinct structures level  thereby duplicating  often many times over  information contained previous levels  multi level planning graph efficiently represented indexed
two part structure finite differencing techniques employed focus aspects
graph structure possibly change extension  leads rapid construction
concise planning graph  fox   long       smith   weld        
me egbg pegg  bi partite graph offers benefit beyond reduced memory demands faster graph construction time  pe transposition process described section     reduced simply incrementing search segments graph level index  straightforward
multi level graph built graphplan  since proposition  and action  referenced
search segments unique data structure itself 
explanation based learning dependency directed backtracking 
application explanation based learning  ebl  dependency directed backtracking  ddb 
investigated preliminary way  zimmerman   kambhampati         primary
interest speedup benefits  techniques shown result modest speedups
   

fiusing memory transform search planning graph

several small problems complexity integrating maintenance pe replay
vectors limited size problem could handled  since succeeded implementing
robust version methods  results reported reflect that 
ebl ddb based explaining failures leaf nodes search tree  propagating explanations upwards search tree  kambhampati         ddb involves using propagation failure explanations support intelligent backtracking  ebl involves
storing interior node failure explanations  pruning future search nodes  approach implements complimentary techniques graphplan reported  kambhampati       
speedups ranged   x blocksworld problems     x ferry domain problems 
refer study full description ebl ddb graphplan context  note aspects particularly relevant me egbg pegg 
conflict directed back jumping  prosser         failure explanations compactly represented terms conflict sets identify specific action goal assignments gave rise
backtracking  liberates search chronological backtracking  allowing jump back
recent variable taking part conflict set  attempts satisfy set subgoals  a
state  fail  conflict set regressed back represents useful minimal no good memoization   see pegg algorithm figures     depiction process   conflict set
memo usually shorter hence general one generated stored standard
graphplan  additionally  ebl augmented graphplan generally requires less memory memo
caches 
less obvious speedup benefit perhaps  role ebl ddb often play dramatically reducing memory footprint pilot explanation  together ebl ddb shortcut
search process steering away areas search space provably devoid solutions 
search trace memory demands decrease proportionally 
me egbg pegg outfitted ebl ddb non pe directed graphplan style search  me egbg however  use ebl ddb replay action assignment results pe search segment due complexity retract parts assignment
vectors whenever conflict set new episode entails new replay order 
value variable ordering 
value variable ordering well known speedup methods csp solvers  context
graphplans regression search given planning graph level k  variables regressed subgoals values possible actions give propositions level k graph 
original paper  blum furst        argue variable value ordering heuristics
particularly useful improving graphplan  mainly exhaustive search required levels
solution bearing level anyway  nonetheless  impact dynamic variable ordering
 dvo  graphplan performance examined  kambhampati         modest speedups
achieved using standard csp technique selecting assignment subgoal  variable 
least number remaining establishers  values   impressive results reported
later study  nguyen   kambhampati        distance based heuristics rooted planning
graph exploited order subgoals goal establishers  configuration  graphplan
exhibits speedups ranging        x  depending particular heuristic problem 

   

fizimmerman   kambhampati

study fix variable ordering according adjusted sum heuristic value ordering
according set level heuristic  found combination reasonably robust across
range test bed problems  heuristics described section   used
direct traversal pe states discussed  section     describes highly problem dependent
performance distance based variable value ordering search trace based planners 
manner egbg pegg builds maintains planning graph search trace
structures actually reduces cost variable value ordering  default order graphplan considers establishers  values  satisfying proposition  variable  given level set
order appear planning graph structure  graph construction me egbg
pegg set order correspond desired value ordering heuristic  ordering computed once  part  pe constructed search record
heuristically best ordering regression states goals  variable ordering done
given state  contrasts versions graphplan outfitted
variable value ordering  kambhampati        ordering reassessed time state
regenerated successive search episodes 

references
blum  a    furst  m l          fast planning planning graph analysis  artificial
intelligence          
bonet  b   loerincs  g     geffner  h          robust fast action selection mechanism
planning  proceedings aaai    
bonet  b    geffner  h          planning heuristic search  new results  proceedings
ecp    
do  m b    kambhampati  s          solving planning graph compiling csp 
proceedings aips    
fox  m     long  d          automatic inference state invariants tim  journal
artificial intelligence research             
frost  d    dechter  r          search best constraint satisfaction search  proceedings
aaai    
gerevini   a     schubert  l          accelerating partial order planners  techniques
effective search control pruning  journal artificial intelligence research           
gerevini  a    serina  i           lpg  planner based local search planning graphs
action costs  proceedings aips    
haslum  p     geffner  h          admissible heuristics optimal planning  proceedings 
aips    
hoffman  j         heuristic domain independent planning use enforced hillclimbing algorithm  technical report no       albert ludwigs university 
kambhampati  s          relations intelligent backtracking failure driven
explanation based learning constraint satisfaction planning  artificial intelligence 
         
kambhampati  s          planning graph  dynamic  csp  exploiting ebl  ddb
csp search techniques graphplan  journal artificial intelligence research           
kambhampati  s    sanchez  r          distance based goal ordering heuristics graphplan 
proceedings aips    
   

fiusing memory transform search planning graph

kambhampati  s   parker  e     lambrecht  e          understanding extending graphplan 
proceedings ecp    
kautz  h    selman  b          pushing envelope 
stochastic search  proceedings aaai    

planning  prepositional logic

kautz  h    selman  b          unifying sat based graph based planning  proceedings
ijcai     vol   
koehler  d   nebel  b   hoffman  j     dimopoulos  y           extending planning graphs
adl subset  proceedings ecp             
korf  r          depth first iterative deepening  optimal admissible tree search  artificial
intelligence                
korf  r          real time heuristic search  artificial intelligence              
long  d    fox  m          efficient implementation plan graph stan  journal
artificial intelligence research             
mittal  s     falkenhainer  b          dynamic constraint satisfaction problems  proceedings
aaai    
mcdermott  d          using regression graphs control search planning  artificial
intelligence                    
nigenda  r     kambhampati  s          altaltp  online parallelization plans heuristic
state search  journal artificial intelligence research              
nguyen  x    kambhampati  s          extracting effective admissible state space heuristics
planning graph  proceedings aaai    
prosser  p          domain filtering degrade intelligent backtracking search  proceedings
ijcai    
russell  s j           efficient memory bounded search methods  proceedings ecai    
sen  a k     bagchi  a           fast recursive formulations best first search allow
controlled use memory  proceedings ijcai    
selman  b  levesque  h     mitchell  d          new method solving hard satisfiability
problems  proceedings aaai    
smith  d   weld  d          incremental graphplan  technical report           univ  wash 
srivastava  b   nguyen  x   kambhampati  s   do  m   nambiar  u  nie  z   nigenda  r  
zimmerman  t          altalt  combining graphplan heuristic state search  ai
magazine         american association artificial intelligence  fall      
zimmerman  t          exploiting memory search high quality plans planning
graph  phd dissertation  arizona state university 
zimmerman  t    kambhampati  s          exploiting symmetry planning graph via
explanation guided search  proceedings aaai    
zimmerman  t   kambhampati  s          generating parallel plans satisfying multiple criteria
anytime fashion  proceedings workshop planning scheduling multiple
criteria  aips    
zimmerman  t    kambhampati  s          using available memory transform graphplans
search  poster paper proceedings ijcai    

   


