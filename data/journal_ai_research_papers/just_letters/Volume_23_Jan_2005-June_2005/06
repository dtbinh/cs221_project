journal artificial intelligence research                  

submitted        published      

keys  nominals  concrete domains
carsten lutz

lutz tcs inf tu dresden de

theoretical computer science  tu dresden
d       dresden  germany

carlos areces

areces loria fr

inria lorraine  nancy
      villers les nancy cedex  france

ian horrocks

horrocks cs man ac uk

department computer science
university manchester
oxford road  manchester m    pl  uk

ulrike sattler

sattler cs man ac uk

department computer science
university manchester
oxford road  manchester m    pl  uk

abstract
many description logics  dls  combine knowledge representation abstract  logical
level interface concrete domains numbers strings built in predicates       prefix of  hybrid dls turned useful several
application areas  reasoning conceptual database models  propose
extend dls key constraints allow expression statements
us citizens uniquely identified social security number  based idea 
introduce number natural description logics perform detailed analysis
decidability computational complexity  turns naive extensions
key constraints easily lead undecidability  whereas careful extensions yield nexptime complete dls variety useful concrete domains 

   motivation
description logics  dls  family formalisms allow representation
reasoning conceptual knowledge structured semantically well understood
manner  baader  calvanese  mcguinness  nardi    patel schneider         central
entities representing knowledge concepts  constructed atomic
concept names  unary predicates  role names  binary relations  means concept
role constructors offered particular dl  example  basic propositionally
closed description logic alc  schmidt schau   smolka         describe company
part time employees full time managers using concept
company u employee parttime u employee  manager parttime  
example  words beginning uppercase letters denote concept names
employee denotes role name 
c
    
ai access foundation  rights reserved 

filutz  areces  horrocks    sattler

rather viewed conceptual entities knowledge base  concepts
can  generally  understood central notion various kinds class centered
formalisms  last decade  observation given rise various new challenging applications description logics reasoning database conceptual models
expressed entity relationship diagrams object oriented schemas  calvanese  lenzerini 
  nardi        calvanese  de giacomo    lenzerini        reasoning ontologies
use semantic web  baader  horrocks    sattler      a  horrocks        horrocks 
patel schneider    van harmelen         new applications have  turn  stimulated
research description logics since expressive power existing dls insufficient
new tasks  one important extension providing expressive means allow
integration numbers datatypes  suppose  example  want
extend earlier descriptions companies employees include founding year
company hiring year employee  then  may want describe companies
founded      state hiring year employees prior
founding year employing company  this  obviously need way talk
natural numbers  such       comparisons natural numbers 
nowadays  standard approach integrate datatypes description logics
extend dls concrete domains  first proposed baader hanschke      a 
recently surveyed lutz         precisely  concrete domain consists set
 such natural numbers  predicates associated fixed extension
set   such unary      binary    ternary     integration
concrete domains into  say  description logic alc achieved adding
   abstract features  i e  functional roles 
   concrete features  i e   partial  functions associating values concrete domain
 e g   natural numbers  logical objects 
   concrete domain based concept constructor 
dl obtained extending alc way called alc d   denotes
concrete domain viewed parameter logic  example  using
suitable concrete domain describe constraints formulated above  concept
employee u employer foundingyear       u hiringyear   employer foundingyear  
describes set employees employed company founded     
hiring year prior companys founding year  example  term
foundingyear       instance concrete domain concept constructor  not
confused existential value restriction employee parttime   third
conjunct        unary predicate thus former instance takes one
concrete feature foundingyear argument  second instance uses binary predicate
requiring two arguments  concrete feature hiringyear sequence features
 employer foundingyear  consisting abstract feature employer concrete feature
foundingyear 
concrete domains rather important many applications dls  including two
mentioned above 
   fixed extension predicates often called built in 

   

fikeys  nominals concrete domains

standard way using description logics reasoning conceptual database
models translate given model dl representation use dl reasoner fact  horrocks        racer  haarslev   moller        compute
consequences information provided explicitly model  includes
detecting inconsistencies inferring additional  implicit containments entities classes  calvanese et al          since databases store concrete data
numbers strings  constraints concerning data usually part
conceptual model thus captured description logic used
reasoning  indeed  example concepts viewed dl encoding
constraints database companies employees  discussed
lutz      c   description logics concrete domains well suited conceptual modeling applications involving concrete datatypes 
so called concrete datatypes play prominent role construction ontologies  horrocks et al          say  example  want construct ontology
used describing car dealers web pages web services 
ontology  concrete datatypes prices  manufacturing years  names car
models doubtlessly important  formulate ontology using dl 
need way represent concrete datatypes  consequently  almost dls
proposed ontology language equipped form concrete
domain  fensel  van harmelen  horrocks  mcguinness    patel schneider        horrocks et al         dean  connolly  van harmelen  hendler  horrocks  mcguinness 
patel schneider    stein         furthermore  since ontology languages provide
inverse abstract roles functional restrictions  users ontology designers
quite surprised find provide inverse concrete functional
featureswhich due fact features correspond concrete key
constraints  reasoning algorithms known whose effect
decidability complexity yet investigated 
paper  propose enhance expressive power description logics
concrete domains extending concrete key constraints  extension
useful knowledge representation two applications sketched above 
following three examples describe basic idea 
   suppose that  knowledge representation application  represent nationalities
concept names us german and  us citizens  store social
security number using concrete feature ssn  would natural state
us citizens uniquely identified social security number  i e  two distinct
instances
human u nationality us
must different values ssn feature  extension dls concrete
domains  expressed using key assertion  
 ssn keyfor human u nationality us  
   readers familiar
vrelationship dls first order logic notice key assertion
equivalent x  x      i       human xi  z  nationality xi   z us z    x    x      ssn x     
ssn x      

   

filutz  areces  horrocks    sattler

   returning database companies employees  could useful
equip every employee  i  concrete feature branch storing branch id
working  ii  concrete feature id storing personnel id  would
natural enforce branch id together personnel id uniquely
identifies employees  even though personnel ids unique 
using composite key assertion
 branch  id keyfor employee  
   car dealers ontology  may assume cars well manufacturers
equipped identification numbers every car uniquely identified
combination identification number manufacturers one  express
this  could employ composite key assertion referring sequences features 
case  manufacturer id  
 id   manufacturer id  keyfor car  
formally  propose extend dls provide concrete domains key boxes 
sets key assertions form
 u            un keyfor c  
ui sequence f  fn g abstract features fj followed single concrete
feature g  c concept  examples illustrate  idea key constraints
natural  since  moreover  keys play important role databases and  mentioned
above  reasoning database conceptual models important  challenging application
description logics  several approaches extend description logics keys already
investigated  borgida   weddell        calvanese  de giacomo    lenzerini       
khizder  toman    weddell         distinguishes approach existing ones 
however  idea using concrete domains constructing key constraints  rather
defining keys abstract  logical level 
goal paper provide comprehensive analysis effects decidability computational complexity adding key boxes description logics concrete
domains  end  extend two description logics alc d  shoq d  key
boxes  way obtaining alck d  shoqk d   respectively  basic dl
concrete domains alc d  already discussed above  shoq d  proposed
ontology language  horrocks   sattler         provides wealth expressive
possibilities general concept inclusion axioms  gcis   transitive roles  role hierarchies  nominals  qualifying number restrictions  moreover  offers restricted variant
concrete domain constructor disallows use sequences features order
avoid undecidability reasoning  main outcome investigations key
constraints dramatic impact decidability complexity reasoning 
example  whereas satisfiability alc d  concepts known pspace complete  lutz 
    b   show satisfiability alck d  concepts w r t  key boxes is  general 
undecidable  decidability regained restrict concepts used key boxes
   

fikeys  nominals concrete domains

boolean combinations concept names  boolean key boxes   interestingly  satisfiability alck d  concepts w r t  boolean key boxes still nexptime complete even
simple concrete domains  case shoq d  shoqk d   leap
complexity somewhat less dramatic since shoq d  concept satisfiability already exptime complete  again  addition key boxes results nexptime complete reasoning
problems 
interesting note exists close connection key assertions
so called nominals  i e  concept names one instance 
pope  nominals standard means expressivity description logics sometimes
appear disguise one of operator  borgida   patel schneider        horrocks
et al          hard see key boxes simulate nominals  if  example 
use concrete domain based natural numbers providing unary predicates
 n equality n   key assertion  g keyfor       stands
logical truth  obviously makes concept g  n behave nominal  n
  reason  consider alco d   extension alc d  nominals 
alcok d   extension alck d  nominals   main result concerning
nominals that  although general lower expressive power key boxes 
already make reasoning nexptime hard combined concrete domains  exist
concrete domains alco d  concept satisfiability nexptime complete 
stress nexptime hardness results obtained
paper accordance observation made  lutz        pspace upper
bound reasoning alc d  robust w r t  extensions logic  exist
several seemingly harmless extensions alc d   for example acyclic tboxes
inverse roles  make complexity reasoning leap pspace completeness
nexptime completeness many natural concrete domains 

n

n

remainder paper organized follows  section    formally introduce
concrete domains  key boxes  dl alcok d  together fragments alck d 
alco d   moreover  define boolean key boxes  allow boolean combinations concept names appear key definitions  additionally  introduce
important properties key boxes  path free key boxes prohibit use sequences
features key assertions  unary key boxes  key assertion involves exactly one
sequence features  composite key boxes simply non unary ones 
section   devoted establishing lower bounds extensions alc d  key
boxes nominals  section      use reduction post correspondence problem
prove alck d  concept satisfiability w r t   non boolean  key boxes undecidable
large class concrete domains  shift attention boolean key boxes
since  section    show restriction restores decidability  section     
introduce nexptime complete variant domino problem three concrete
domains useful reduction problem concept satisfiability dls
boolean key boxes nominals  section      use concrete domains
prove alck d  concept satisfiability w r t  boolean  path free unary key boxes
nexptime hard natural concrete domains  section      prove
exist concrete domains alco d  concept satisfiability without reference
   note logic shoq d  already provides nominals 

   

filutz  areces  horrocks    sattler

key boxes already nexptime hard  show true even concrete
domains computationally simple  ptime  considered isolation 
purpose section   develop reasoning procedures description logics
key boxes prove upper complexity bounds matching nexptime lower bounds
established previous section  start section     tableau algorithm
decides alcok d  concept satisfiability w r t  boolean key boxes  provided concrete domain key admissible  intuitively  concrete domain key admissible
exists algorithm takes finite conjunction c predicates set
variables  decides whether conjunction satisfiable and  so  chooses solution c
returns information variables take values it  call
algorithm d tester  chosen tableau algorithm since type reasoning
procedure potential implemented efficient reasoners shown
behave well practice  horrocks  sattler    tobies        haarslev   moller        
algorithm implies following upper complexity bound  key admissible concrete
domain non deterministic polynomial time d tester exists  alco d concept satisfiability w r t  boolean key boxes nexptime 
section      devise tableau algorithm shoqk d  concept satisfiability
w r t  path free key boxes might involve non boolean concepts  decidability
alcok d   restricted key boxes boolean ones  shoqk d   restriction possible since shoq d  provides tboxes  thus longer distinguish
boolean non boolean concepts  hand  follows undecidability proof baader hanschke        shoq d  undecidable allow
sequences features concrete domain constructors  thus restrict key assertions
analogously path free ones  show yields indeed decidable logic  expressive power orthogonal one alcok d   previous undecidability
results imply combination alcok d  shoqk d  undecidable 
by product correctness proof algorithm  obtain bounded model property shoqk d   implies shoqk d  concept satisfiability w r t  path free
key boxes nexptime key admissible concrete domain nondeterministic polynomial time d tester exists 
section    summarize results obtained give outlook possible future
research 

   description logics concrete domains
following  introduce description logic alcok d   let us start defining
concrete domains 
definition      concrete domain   concrete domain pair  d     
set set predicate names  predicate name p associated
arity n n ary predicate p nd  
based concrete domains  define alcok d  concepts key boxes 
definition      alcok d  syntax   let nc     nr   ncf pairwise disjoint countably infinite sets concept names  nominals  role names  concrete features  furthermore  assume nr contains countably infinite subset naf abstract features 
   

fikeys  nominals concrete domains

path u composition f  fn g n abstract features f            fn  n    concrete
feature g  let concrete domain  set alcok d  concepts smallest set

every concept name every nominal concept 
c concepts  r role name  g concrete feature  u            un paths 
p predicate arity n  following expressions concepts 
c  c u d  c d  r c  r c  u            un  p  g 
key assertion expression
 u            uk keyfor c  
u            uk  k    paths c concept  finite set key assertions
called key box 
usual  use   abbreviation arbitrary propositional tautology 
abbreviation    c abbreviation c d  c abbreviation
 c d  u  d c   throughout paper  consider several fragments
description logic alcok d   dl alco d  obtained alcok d 
admitting empty key boxes  particular  set alco d  concepts set
alcok d  concepts  furthermore  disallowing use nominals  obtain
fragment alc d  alco d  alck d  alcok d  
description logic alcok d  equipped tarski style set theoretic semantics 
along semantics  introduce two standard inference problems  concept
satisfiability concept subsumption 
definition      alcok d  semantics   interpretation pair  i     
non empty set  called domain  interpretation function  interpretation
function maps
concept name c subset c  
nominal n singleton subset n  
role name r subset ri  
abstract feature f partial function f  
concrete feature g partial function g  
   

filutz  areces  horrocks    sattler

u   f  fn g path  ui  d  defined g  fni  f i  d      interpretation
function extended arbitrary concepts follows 
 c i      c
 c u d i    c di
 c d i    c di
 r c i     d   e  d  e  ri e c  
 r c i     d   e    d  e  ri   e c  
 u            un  p  i     d   x            xn   uii  d    xi  x            xn   p  
 g i     d   g  d  undefined  
let interpretation  model concept c iff c      moreover 
satisfies key assertion  u            un keyfor c  if  a  b c  
ui   a    ui   b           uin  a    uin  b  implies   b 
model key box k iff satisfies key assertions k  concept c satisfiable
w r t  key box k iff c k common model  c subsumed concept w r t 
key box k  written c vk d  iff c di models k 
well known that  description logics providing boolean operators  subsumption
reduced  un satisfiability vice versa  c vk iff c u unsatisfiable
w r t  k c satisfiable w r t  k iff c  vk   allows us concentrate concept
satisfiability devising complexity bounds reasoning description logics  lower
upper complexity bounds concept satisfiability imply corresponding bounds
concept subsumptiononly complementary complexity class 
decision procedures description logics concrete domains devised
without committing particular concrete domain  well defined interface
decision procedure concrete domain reasoner needed  usually  interface
based assumption concrete domain admissible  baader   hanschke 
    a  lutz      a        
definition      d conjunction  admissibility   let concrete domain v set
variables  d conjunction  finite  predicate conjunction form
   i 
c 
 x            x i 
ni     pi  
i k
 i 

pi ni  ary predicate   k xj variables v  d conjunction
c satisfiable iff exists function mapping variables c elements
 i 
 i 
  x              xni    pid   k  function called solution c 
say concrete domain admissible iff
   contains unary predicate  d  d
   
   closed negation  i e   n ary predicate p   predicate

p arity n p   nd   p  
   

fikeys  nominals concrete domains

   satisfiability d conjunctions decidable 
refer satisfiability d conjunctions d satisfiability 
shall see  sometimes makes considerable difference w r t  complexity decidability restrict key boxes various ways  example disallow paths length greater
one  therefore  introduce useful notions 
definition      boolean  path free  simple   key box k called
boolean concepts appearing  key assertions in  k boolean combinations
concept names 
path free if  key assertions  u            un keyfor c  k  u            un ncf  
simple path free boolean 
unary key assertions k unary key assertions  i e  form  u keyfor c  
concept c called path free if  subconcepts form u            un  p   u            un
concrete features 
emphasize key box might necessarily boolean path free  sometimes
call key box general  similarly  emphasize key box necessarily
unary key box  sometimes call key box composite 

   lower bounds
section  prove lower complexity bounds description logics concrete domains key boxes and or nominals  section      start showing satisfiability alck d  concepts w r t   general  key boxes undecidable many interesting
concrete domains  discouraging picture painted result mitigated fact
that  section      shall prove restriction boolean key boxes restores decidability  thus interesting look lower complexity bounds apply
restriction  preparation this  introduce section     nexptime complete variant domino problem three concrete domains well suited reductions
problem 
section      prove satisfiability path free alck d  concepts w r t 
simple key boxes nexptime hard large class concrete domains that 
many concrete domains  holds even restrict key boxes unary ones  finally 
consider description logic alco d  section     identify several concrete
domains alco d  concept satisfiability  without key boxes   nexptimehard  already mentioned  key boxes nominals closely related  key boxes
express nominals  general powerful 
    undecidability alck d  general key boxes
prove satisfiability alck d  concepts w r t  key boxes undecidable
large class concrete domains allow complex alck d  concepts occur key
assertions  proof reduction well known undecidable post correspondence
problem  post        hopcroft   ullman        
   

filutz  areces  horrocks    sattler

definition      pcp   instance p post correspondence problem  pcp  given
finite  non empty list       r               k   rk   pairs words alphabet  
sequence integers i            im      called solution p  i   im   ri  rim  
pcp decide whether given instance p solution 
reducing pcp satisfiability dls  need appropriate concrete
domain  obviously natural use concrete domain based words concatenation 
later see results obtained concrete domain carry
concrete domains based numbers arithmetics  following concrete domain
introduced lutz         definition presupposes fixed alphabet least
binary 
definition      concrete domain w   concrete domain w defined setting w   
defining w smallest set containing following predicates 
unary predicates word nword wordw   w nwordw    
w
 
unary predicates       w
           

binary equality predicate   binary inequality predicate    obvious
interpretation 
w     two binary predicates concw nconcw
w
concw
w     u  v    v   uw  nconcw     u  v    v    uw  

readily checked w satisfies properties     admissibility  see definition      
moreover  w satisfiability decidable 
theorem      lutz         w satisfiability ptime 
thus  w admissible even low complexity  important since aim
demonstrate undecidability alck w  concept satisfiability due
presence keys  due high complexity w satisfiability 
discuss reduction pcp  given instance       r               k   rk  
translated alck d  concept cp key box kp defined figure  
p solution iff cp unsatisfiable w r t  kp   idea behind reduction
common model cp kp encodes potential solutions p  i e   sequences i           
integers ij   k  makes sure none fact solution 
figure    f            fk denote abstract features g     r denote concrete features 
definition concept step serves abbreviation confused
so called tboxes  see section     definition tboxes   models cp kp  
one displayed figure    form infinite k ary tree whose root
connected extra node x via role r  intuitively  node tree represents
one partial solution i                successor represents corresponding left concatenation
 i   in   r successor corresponding right concatenation ri  rin  
enforce existence infinite tree  employ key box kp   consider
example root nodes f   successor figure  let us call node y  due line  
   

fikeys  nominals concrete domains

step   

u f   a u g   u    r    
u u     f   conc u r  f r conc


 ik





 ik



 i

ri  

cp        u r  
u r  a u g   u step 
u step
kp     g keyfor step 
figure    alck w  reduction concept cp key box kp  
r
 

conc  

 

r

 

x

fk

concrk

f 


g  

concr  conc k
 
f 



r


fk

f 



r

 


fk



figure    example model cp kp  
cp line   step   g    i   due line   cp  
x  g    i x  step i   x extra node mentioned above  view
key box kp   implies either  i  x    ii  stepi   easy see
 i  impossible since line   cp line   step imply x ai  a i  
hence stepi and  line   step  appropriate  successors   n 
way  construction tree continued ad infinitum  second
line definition step enforces  i  z     i   in ri  z    ri  rin z
fi  fin  successor root node  finally  concept    r    line   step implies
 i  z     ri  z  holds nodes z tree  except root   implies
potential solution solution 
since size cp kp clearly polynomial k key box kp unary
key box  obtain following proposition 
proposition      satisfiability alck w  concepts w r t   non boolean  path free
unary key boxes undecidable 
   

filutz  areces  horrocks    sattler

emphasize undecidability result obtained using simple concrete
domain  let us combine theorem     proposition     
theorem      exists concrete domain d satisfiability ptime
satisfiability alck d  concepts w r t   non boolean  path free unary key boxes
undecidable 
first sight  concrete domain w might look artificial one may question relevance lower bounds obtained using w  however  straightforward
encode words natural numbers define concatenation words rather simple operations natural numbers  baader   hanschke         word w   
alphabet cardinality   interpreted number written base      
symbol   digit occur  hence  use corresponding natural number  e g   base     represent word w  number  
represent empty word  concatenation two words v w expressed
vw   v       w   w   w  denotes length word w  moreover  exponentiation expressed multiple multiplications  multiplication multiple additions 
addition multiple incrementation  shown section      lutz       
case alc d  extended tboxes  c f  section      easily adapted
alc d  non boolean key boxes  observation gives rise following theorem 

n

theorem      let concrete domain   contains unary predicate         d        binary equality inequality predicates  binary predicate
incr incrd   n  x    n x       k  k        k    satisfiability
alck d  concepts w r t   non boolean  path free unary key boxes undecidable 

n

n

    domino problems concrete domains
section  introduce nexptime complete variant well known  undecidable
domino problem  berger        knuth         define three concrete domains d   
d    d    concrete domains used sections         establish
lower bounds reasoning alck d  boolean key boxes  reasoning
alco d  
general  domino problem given finite set tile types  intuitively  tile
types size  type square shape colored edges  unlimited
number tiles type available  nexptime hard variant domino
problem use  task tile  n    n    torus  i e    n    n    rectangle
whose borders glued together  neighboring edges color 

n

definition      domino system   domino system triple  t  h  v     
finite set tile types h  v represent horizontal vertical matching
conditions  let domino system   a            an  initial condition  i e 
n tuple tiles  mapping                n                   n      solution
iff  x     n     following holds 
 x  y     x  n      y    t     t  t    h
 x  y     x   n        t     t  t    v
   

fikeys  nominals concrete domains

 i       ai   n 
denotes addition modulo i 
follows results  borger  gradel    gurevich        variant
domino problem nexptime complete 
define concrete domain d  used reduction nexptimecomplete domino problem alck d    concept satisfiability w r t  boolean key boxes 
definition      concrete domain d     concrete domain d  defined setting
d            d   smallest  set containing following predicates 
unary predicates  d    d   d    d  d   d   d     
unary predicates         i  d     i          
second concrete domain d  used reduction nexptime complete
domino problem alck d    concept satisfiability w r t  boolean unary key boxes 
reduction need store vectors bits single concrete domain elements 

n

definition      concrete domain d     every n   function v               n   
       called bit vector dimension n  use bvn denote thesset bit vectors
dimension n  concrete domain d  defined setting d     i   bvi d 
 smallest  set containing following predicates 
unary predicates  d    d   d    d  d   d   d     
every k 

n   k  unary predicates bit ik bit ik
 bitnik  d     v d    v bvk v i    n  

unary predicates bit ik bit ik  bitnik  d    d     bitnik  d   
last concrete domain d  used reduction nexptime complete domino
problem alco d    concept satisfiability  reduction  concrete domain d 
contains two kinds elements  firstly  elements d  represent
whole  n    n    torus  so called domino arrays  secondly  elements d 
represent positions torus  technical reasons discussed later  elements
vectors natural numbers rather bit vectors  following shall call
vectors  domino array function mapping pair vectors  of certain
length  natural number represents tile type 

n

n

definition      concrete domain d     every k   function v               k   
called vector dimension k  use vek denote set vectors dimension k 
every k   function k   vek vek
called domino array dimension k 
use dak denote setsof domino
arrays
dimension k  concrete domain d 

defined setting d     i   vei i   dai d   smallest  set containing
following predicates 

n

n

unary predicates  d    d   d    d  d   d   d     
   

filutz  areces  horrocks    sattler

every k 

n   k  unary predicates pos ik pos ik
 posnik  d     v d    v vek v i    n 

unary predicates pos ik pos ik  posnik  d    d     posnik  d   
every k 

n  predicate tileik arity  

 tileik  d      vx   vy   d    vx   vy vek   dak   d vx   vy     i 
predicate tileik arity    tileik  d     d        tileik  d   
reason using vectors natural numbers rather bit vectors definition
d  want d   satisfiability low complexity  preferably ptime  consider
d   conjunction
pos     x  pos     y  pos     z 
tile    x  v  d  tile    y  v  d  tile    z  v  d  
use bit vectors rather vectors natural numbers  upper line enforces
least two three variables x  y  z must take value  since
value v fixed  lower line makes conjunction unsatisfiable  tries assign
three different values         two different positions domino array  seems
unlikely kind inconsistency detected polynomial time  problem
circumvented using vectors natural numbers definition d   but enforcing
bit vectors reduction   case  conjunction clearly
satisfiable 
proposition                 concrete domain di admissible satisfiability di  conjunctions ptime 
d    trivial  d    proof found appendix a  d    proof
found  lutz  areces  horrocks    sattler        
    nexptime hardness alck d  boolean key boxes
section  prove two nexptime lower bounds alck d  concept satisfiability
w r t  boolean key boxes reducing nexptime complete domino problem introduced
previous section  first reduction uses simple concrete domain d   
depends composite key assertions  second reduction uses slightly complex
concrete domain d    needs unary key assertions  see  two reductions
yield different  incomparable results 
first reduce nexptime complete domino problem alck d    concept satisfiability w r t  boolean composite key boxes  domino system    t  h  v   initial
condition   a            an  translated alck d    concept cd a displayed
figure    names treex treey used abbreviations only  use ri  c
abbreviation n fold nesting r  r c  names xposi yposi used
figure denote concrete features  definition init concept  n   biti  n 

n

   

fikeys  nominals concrete domains

treex    r x  u r x  u

u r   distx


u r xi u r xi  

i 

i    n

treey    distxn u r y  u r y  u

u r   disty u distx u r y u r y  
distx    u   x r x   u  x r x   
disty    u   y r y   u  y r y   
transxpos    u  x xpos       u  x xpos      
transypos    u  y ypos       u  y ypos      


i 

i    n

k

k



i    k

i    n











i    k



i    n

n













 



 



 





 



succs    rx   transxpos u transypos  u ry   transxpos u transypos 

xsuccok   
 yi rx  yi   u  yi rx  yi  
i    n


xj  xk rx  xk   u  xk rx  xk  

u
u u
u x  x r  x   u  x r  x  

ysuccok    u  x r  x   u  x r  x  
u u  y r  y   u  y r  y  
u  y r  y   u  y r  y  
label    u u  d u  
checkmatch     d u r  d   u  d u r  d  

u x u u x u u
init    u
k    n

j    k

k    n

j    k


i    n

j    k

k    n

j    k



 i j h

i    n 



j



k



j

j    n bitj  i   

x

k





k

x

k



j

i jt i  j



x

k



k    n



j

k



k

k



k

k



k

k

j

 i j v
j





j

j    n bitj  i   

j

j    n

j



ai

cd a    treex u rn    treey
u r  n      transxpos u transypos u succs u xsuccok u ysuccok 
u r  n      label u checkmatch u init 
figure    alck d    reduction concept cd a  
supposed denote ith bit binary representation n  claim cd a
satisfiable w r t  key box
  xpos            xposn   ypos            yposn keyfor    
iff exists solution a  substantiate claim  let us go
reduction explain various parts concept cd a   first step towards under   

filutz  areces  horrocks    sattler

standing structure models cd a  which key understanding reduction
itself  note purpose first line cd a enforce tree structure
depth   n       whose leaves correspond positions  n    n    torus 
precisely  treex concept guarantees that  every model cd a   exists binary
tree depth n      moreover  distxk concepts  there exists one k             n  
ensure leaves tree binarily numbered  from    n      concept
names x            xn   precisely  domain object   set

  xii
n

xpsn d    i    d     d   
  otherwise 
treex distx concepts ensure exist nodes d            d n     level n    
tree xpsn di     i  intuitively  numbering represents horizontal
positions  n    n    torus  vertical positions coded similar way
y            yn concept names  specifically  concepts treey  distx  disty ensure
every di  i  n      root another tree   i  every node
x            xn  configuration root node   ii  leaves numbered binarily
using concept names y            yn  note treey concept appears cd a inside
rn   value restriction   define

  yii
n

ypsn d    i    d     d   
  otherwise 
set leaf nodes trees enforced treey concept  exists 
i  j    n     object  ei j xpsn ei j     ypsn ei j     j  i e   ei j
represents position  i  j   n    n    torus 
next step translate individual bits numbering ei j  objects 
represented concept names  concrete domain values 
done transxpos transypos concepts ensure that    n 
xposi   ei j       ei j x    xposi   ei j       ei j x    similarly ypos  y   
since model key box
  xpos            xposn   ypos            yposn keyfor     
grid positions uniquely represented domain elements  transxpos u transypos i  
i e   d  e  transxpos u transypos i xpsn d    xpsn e  ypsn d    yxpsn e  
  e  fact used concepts succs  xsuccok  ysuccok enforce that 
two roles rx ry i  j n  following holds 
rxi   ei j         ei j   e i n      j  
ryi   ei j         ei j   ei  j n        

  

succs concept ensures that  ei j   exists rx  successor ry successor   transxpos u transypos i   let rx  successor ei j  
xsuccok concept ensures xpsn d     n     ypsn d    j 
   matter one object 

   

fikeys  nominals concrete domains

explain this  let us note that  since ei j  transxpos u transypos i
grid positions uniquely represented elements  transxpos u transypos i  
implies   e i n      j shows upper line    indeed hold 
let us consider xsuccok concept detail  essentially
dl formulation well known propositional formula
n k 
n k 
 
 
 
 
 
xj       xk     x k     
 
xj       xk   x k  
k   j  

k   j  

encodes incrementation modulo  n     i e   number  binarily  encoded
propositional variables x            xn t  number encoded propositional
variables x             x n   t        modulo  n    see borger et al          taking
account rx quantifiers xsuccok  readily checked concept
desired effect  ensure that  every rx  successor ei j   xpsn d   
xpsn e i n      j      n      explanation ysuccok enforces lower
line    analogous xsuccok case 
remains ensure every grid position labeled precisely one tile
initial condition well horizontal vertical matching conditions satisfied 
tiles represented concept names di  where set tiles  
described tasks accomplished standard way concepts label  init 
checkmatch 
worth noting reduction concept path free key box simple 
i e   path free boolean  path freeness concepts often used tame complexity
description logics concrete domains  although largely sacrifices expressive
power  lutz        baader  lutz  sturm    wolter      b  haarslev  moller    wessel       
horrocks   sattler         example  alc d  augmented general tboxes 
reasoning arbitrary concepts undecidable reasoning path free concepts
exptime complete admissible d satisfiability exptime  lutz      a  
taming approach work presence key boxes since 
seen  satisfiability alc d  concepts w r t  key boxes  under natural assumptions 
nexptime hard  even concept key box path free 
since size cd a used key box clearly polynomial n  obtain
following proposition 
proposition      satisfiability path free alck d    concepts w r t  simple key boxes
nexptime hard 
shown  non path free  alc d  concept satisfiability pspace complete
d satisfiability pspace  lutz      b   hence  follows proposition    
alc d    concept satisfiability pspace complete  thus  rather dramatic increase complexity key boxes added alc d     stress increase due
key boxes complexity d   satisfiability  reformulate
proposition     
theorem      exists concrete domain d satisfiability ptime
satisfiability path free alck d  concepts w r t  simple key boxes nexptime hard 
   

filutz  areces  horrocks    sattler

succs     rx  transpos u ry  transpos
transpos   

u
u

i    n
i    n


 xi bv bit i  n      u xi bv bit i  n      u

n i  
n i  
 yi bv bit   n   
  u yi bv bit   n   
 

cd a    treex u rn    treey
u r  n      transpos u succs  u xsuccok u ysuccok 
u r  n      label u checkmatch u init 
figure    alck d    reduction concept cd a  
although  due low expressivity  concrete domain d  natural
knowledge representation  fragment many concrete domains
proposed literature  baader   hanschke        haarslev   moller        lutz       
    b   indeed  presented reduction strategy adapted several standard
concrete domains  let us formulate  very weak  condition concrete domain must
satisfy order presented reduction strategy applicable 
theorem      let concrete domain  exist a  b    b p    p 
p d    a  p d    b   satisfiability path free alck d  concepts
w r t  simple key boxes nexptime hard 
present second nexptime hardness result alck d  concept satisfiability 
time  reduce nexptime complete domino problem satisfiability pathfree alck d    concepts w r t  simple unary key boxes  reduction similar
previous one discuss differences 
first reduction  represented individual bits grid positions individual
concrete features xposi yposi used composite key box ensure point
torus represented one element  second reduction  use single
concrete feature bv represent entire position  i  j  torus using bit vector
concrete domain d    allows us enforce mentioned uniqueness
representations using unary key box 
modified reduction concept cd a found figure    concepts
treex  treey  distxk   distyk   xsuccok  ysuccok  label  checkmatch  init defined
figure    translation position torus encoded x            xn   y            yn
bit vector done transpos concept straightforward manner  given
said first reduction  hard see cd a satisfiable w r t  key
box   bv keyfor     iff exists solution a  thus obtain following
proposition 
proposition      satisfiability path free alck d    concepts w r t  simple unary
key boxes nexptime hard 
again  relate nexptime lower bound complexity d   satisfiability 
determined proposition     
   

fikeys  nominals concrete domains

theorem       exists concrete domain d satisfiability ptime
satisfiability path free alck d  concepts w r t  simple unary key boxes nexptime hard 
since elements d  bit vectors  concrete domain d  cannot considered
natural choice many application areas  but  reduction  d  replaced
several natural concrete domains 
central observation use bit vectors injectively translate sequences
bits values concrete domain  i e   translate sequences   n      bits
 represented concept names x            xn y            yn   elements d 
that  distinct sequences  results translation distinct  due
restricted use bit vectors  several ways replace natural numbers 
example  replace transpos following concept transpos  ensures
that  transpos i   si n    d    xpsn d     n   ypsn d  

u


transpos     zero    u
ti    i u  x  s        u  x  s        u
i      n  


xi  si    zero  si     u xi  si    ti   si     u
i    n



yi n     si    zero  si     u  yi n     si    ti   si    

u
u

i n     n  

n

zero  si   ti concrete features   k  with k   denotes unary predicate
obvious extension    denotes ternary addition predicate that  intuitively 
first two arguments addends third one sum 

easy check that  whenever two objects d  e transpos  agree
interpretation x            xn   y            yn   si n    d     si n    e   thus key
box   s n   keyfor     used reduction  size transpos  obviously
polynomial n numbers k appearing  k predicates coded binary  thus
obtain following theorem 
theorem       let concrete domain
  

n  
n

   contains  k   predicate  k   k  d    k  size  the
representation    k logarithmic k 
   contains predicate      d   k    k    x    k    k 
  k    k    k    k      k    k    

n

n x

   

satisfiability path free alck d  concepts w r t  simple unary key boxes
nexptime hard 
example  theorem yields nexptime lower bounds alck d  instantiated
concrete domains proposed  baader   hanschke        haarslev   moller        lutz 
          b   alternative addition predicate use multiplication injectively
   

filutz  areces  horrocks    sattler

translate sequences bits natural numbers  precisely  let p            p n  
first  n     prime numbers define another version transpos follows 
transpos      one    u

u
u

i    n

u


ti   pi u  x  s        u  x  s        u
i      n  



xi  si    one  si    u xi  si    ti   si    u



yi n     si    one  si    u yi n     si    ti   si   

i n     n  

ternary multiplication predicate 
since factorization natural numbers prime numbers unique 
use key box   s n   keyfor     reduction  moreover  well known
kth prime polynomial k  graham  knuth    patashnik         thus size
concept transpos   polynomial n even numbers k  k predicates coded
unarily  thus obtain another theorem concerning quite natural concrete domains 
theorem       let concrete domain
  

n  

n  predicate  k   k  d    k  
   contains predicate   d   k    k    x    k    k  n x
  k    k    k  k      k    k  n  
   contains  k

   

satisfiability path free alck d  concepts w r t  simple unary key boxes
nexptime hard 
    nexptime hardness alco d 
already pointed section    relationship key boxes nominals
rather close  latter simulated former concrete domain provides
predicates used uniquely describe elements   example  alck d   
concept g    behaves nominal use key assertion  g keyfor    
even define n nominals using n single concrete features unary key assertions 
logics alck d    alck d     single concrete feature unary key assertions
sufficient simulate arbitrary number nominals  example  alck d   
concept c   g bit    u g bit    uniquely describes bit vector        bv  d    i e  
c implies g  a            obviously  bit vector  of length  
described similar way 
illustrates that  non trivial concrete domains d  logic alck d 
 at least  expressive alco d   although converse hold  expressive
power alco d  still sufficient prove nexptime hardness concept satisfiability 
provided suitable concrete domain used  since alco concept satisfiability
pspace complete  areces  blackburn    marx         yet another example dl
even seemingly harmless extension concrete domains dramatic effect
computational complexity  lutz        
   

fikeys  nominals concrete domains

nominal    f n
xsucc   
ysucc   

u u x  x x   u u x  x x  
u u  y   u u  y  

k    n

j    k

k    n

j    k

j

 
k

k

j

 
k

k

k    n

k    n

j

j    k

j    k

j

i    n


n  

 



n  

 



n  

 



n  

i jv

u

i    n 


n  



 


i jh

init    


n  




n  



i    n

i    n


n  



i    n



u

 
k

k

u  x bvx pos    u  x bvx pos   

transypos    u  y bvy pos 
  u  y bvy pos 
 

transxsucc    u  x bvxs pos 
  u  x bvxs pos 
 

transysucc    u  y bvys pos 
  u  y bvys pos 
 
checkhmatch      bvx  bvy  f darr  tile
u  bvxs  bvy  f darr  tile
checkvmatch      bvx  bvy  f darr  tile
u  bvx  bvys  f darr  tile
transxpos   

 
k

k


n  

j
n    


n  

j
n    

xj u

u

u

xj u
yj
j    n
j    n bitj  i   
j    n bitj  i   


 bvx  bvy  f darr  tilean  



cd a    treex u rn    treey u r  n     nominal u
r  n      transxpos u transypos u
xsucc u ysucc u transxsucc u transysucc u
init  u checkhmatch u checkvmatch 
figure    alco d    reduction concept cd a  

section  reduce nexptime complete domino problem alco d   concept satisfiability  again  let    t  h  v   domino system   a            an 
initial condition  modified reduction concept cd a defined figure    bvx 
bvy  bvxs  bvys  darr denote concrete features  n denotes nominal  concepts
treex  treey  distxk   distyk defined figure    previous reductions 
give detailed explanation reduction strategy show cd a satisfiable
iff exists solution a  formal details easily worked
interested reader 
let model cd a   explain structure i  convenient start
first line cd a   previous reductions  treex treey concepts
used ensure contains tree shaped substructure depth n     whose leaf
nodes roots additional trees depth n     set leafs
   

filutz  areces  horrocks    sattler

treex

treey

   

treey

   

   

f

f

treey

   f

n
darr

figure    structure models cd a  
latter trees correspond positions  n    n    torus  i e   position 
leaf node representing it  torus positions binarily encoded concept
names x            xn y            yn use ei j refer leaf xpsn ei j    
ypsn ei j     j  see section      
previous reductions  numbers coded x            xn y            yn
translated concrete domain values  done transxpos transypos
concepts  note that  contrast alck d    reduction  x position yposition stored bit vector  rather two distinct ones bvx
bvy  contrast previous reduction  actual tiling torus
represented leaf nodes ei j   rather domino array  last conjunct
first line cd a ensures every leaf ei j connected via abstract feature f
 unique  element w n  
domain element w associated domino array via concrete feature darr  as
shall see later  guaranteed checkhmatch checkvmatch concepts  
domino array represents tiling  n    n    torus  summing up  structure
roughly shown figure   
since tiling stored domino array  need explain purpose leaf
nodes ei j   nodes used enforce initial condition horizontal
vertical matching condition  let us discuss horizontal matching condition  the vertical
matching condition enforced analogously   xsucc concept dl reformulation
propositional logic formula incrementation modulo  n   ensures that 
ei j   concept names x             xn  encode number  n      i e   horizontal
position ei j horizontal neighbor  addition storage horizontal vertical
position ei j bvx ei j   bvy ei j    store horizontal position i n     ei j
horizontal successor bvxs ei j    finally  checkhmatch verifies tiles positions
   

fikeys  nominals concrete domains

 i  j   i  n      j   stored domino array  compatible
horizontal matching condition 
note checkhmatch ensures domain element w  with  w    n  
domino array attached via concrete feature darr that  position  i  j  
 unique   tile stored domino array set   initial condition ensured
via init  concept similar way   again  use bitj  i  denote jth bit
binary encoding natural number i 
using considerations  correctness reduction readily checked 
moreover  size cd a polynomial n  note cd a path free 
paths length two appear concepts checkhmatch  checkvmatch  init   summing
up  reduction described yields following result 
proposition       satisfiability alco d    concepts nexptime hard 
again  relate nexptime lower bound complexity d   satisfiability 
determined proposition     
theorem       exists concrete domain d satisfiability ptime
satisfiability alco d  concepts nexptime hard 
note reduction uses single nominal n   dramatic increase complexity since shown satisfiability alc d  concepts  i e   without nominals
key boxes  pspace complete provided admissible d satisfiability
pspace  lutz      b  
previous sections  note d  replaced natural concrete
domains nexptime hardness proof presented  idea represent whole
domino array single natural number use arithmetic operations access
individual positions  natural number k viewed domino array partitioning
binary representation  n    n        n    sections length dlog  t  e 
 t denotes cardinality set tile types   section describes tile
single position torus  sections accessed using integer division
reminder operations  k natural number representing torus  tile
posisition computed
 k div  idlog  t  e   mod  dlog  t  e     
thus  introduce ternary predicates div integer division mod computing
remainder division  binary predicate  x expressing exponentiation basis   
modify reduction follows  replace transxpos transypos
transpos  concept section     translate two numbers encoded x            xn
y            yn single natural number stored concrete feature s n    
devise new concept tile i   for   enforcing position identified
feature s n   labeled tile i 
tile i     r  dlog  t  e u s n     r  r    u r    r     x u one    u r  one  t   u t  t    x
u f torus  r     u div u u  t     tile mod u tile  i  
   

filutz  areces  horrocks    sattler

here  r  r    r     t  t    u  one  torus  tile concrete features  torus feature counterpart darr feature original reduction  i e   stores natural number
represents tiling array  use tile i  concept obvious way inside
checkhmatch  checkvmatch  init  concepts  size resulting reduction concept
polynomial n numbers k appearing  k predicates coded binary 
thus obtain following theorem 
theorem       let concrete domain
  

n  

   contains predicates predicate  k  for k
following extensions
  x  d

  k  x    k
   d   k    k    x    k    k 
  d   k    k    x    k    k 
 div d   k    k    x    k    k 
 mod d   k    k    x    k    k 







n
n
n
n
n

  k  d
x  
x  
x  
x  
x  

 
 
 
 
 
 

n    x       div  mod

 k 
  k   k     k  
  k    k    k    k      k    k   
  k    k    k  k      k    k   
  k    k    k  div k      k    k   
  k    k    k  mod k      k    k   

n

n
n
n
n

satisfiability alco d  concepts nexptime hard 

   reasoning procedures
section devoted developing reasoning procedures dls concrete domains 
nominals  keys  start devising tableau algorithm decides satisfiability
alcok d  concepts w r t  boolean key boxes  algorithm yields nexptime upper
complexity bound matching lower bounds established section     
consider rather powerful description logic shoqk d   dl 
extension shoq d   horrocks   sattler        pan   horrocks         provides
wealth expressive means transitive roles  role hierarchies  nominals  qualifying
number restrictions  moreover  shoqk d  equipped restricted variant
concrete domain constructor key boxes  develop tableau algorithm
deciding satisfiability shoqk d  concepts w r t  path free key boxes  due
restrictedness shoqk d s concrete domain constructor  even admit general
rather boolean key boxes  again  algorithm yields tight nexptime upper
complexity bound 
    tableau algorithm alcok d  boolean key boxes
tableau algorithms decide satisfiability input concept  in case w r t  input
key box  attempting construct model it  precisely  tableau algorithm
starts initial data structure induced input concept repeatedly applies so called completion rules it  rule application thought attempting
construct model input concept  finally  either algorithm find obvious contradiction encounter situation contradiction free
   

fikeys  nominals concrete domains

completion rules applicable  former case  input concept unsatisfiable 
satisfiable latter 
devising tableau algorithm description logic concrete domains
without committing particular concrete domain  commonly assumed concrete domain admissible  implies decidability satisfiability d conjunctions 
presence keys  however  enough  d conjunction satisfiable 
want know variables take values arbitrary fixed solution 
example  consider concrete domain n         n   n    n conjunction

n

n

c       v        v        v    
obviously  one solution c satisfies  v       v     another satisfies  v       v    
on  tableau algorithm uses identity information passed concrete domain
reasoner since  presence key boxes  impact structure
constructed model  example  information reveals unsatisfiability
r a u r  a u b  u r  a u b  u r g    w r t   g keyfor    
formalize requirement  strengthen notion admissibility key admissibility 
since tableau algorithm developed section non deterministic  formulate keyadmissibility non deterministic way 
definition      key admissible   concrete domain key admissible iff satisfies
following properties 
   contains name  d  
   closed negation 
   exists algorithm takes input d conjunction c  returns clash c
unsatisfiable  otherwise non deterministically outputs equivalence relation
set variables v used c exists solution c
following property  v  v   v
 v     v     iff v v    
algorithm showing behaviour described item   called d tester 
equivalence relations called concrete equivalences  say extended dsatisfiability np exists d tester running polynomial time 
please note key admissibility less esoteric might seem  concrete domain
admissible provides equality predicate key admissible  due
admissibility  presence equality predicate implies inequality predicate
available  thus construct d tester algorithm d satisfiability 
presented predicate conjunction c  simply guess equivalence relation
set variables
used c  vthen decide  non extended  satisfiability
v
conjunction c vv    v  v     v v     v  v      return clash unsatisfiable
otherwise  rather weak condition equality predicate present
   

filutz  areces  horrocks    sattler

 c u d 
 r c 

c  c d 
r c
 r c 

 u            un  p  
 g 

c u
r c

c

c

u            un  p u  un
g  d

figure    nnf rewrite rules 
satisfied almost concrete domains proposed literature  see  e g   lutz       
baader   hanschke      b  kamp   wache        haarslev  lutz    moller        baader
  sattler         
throughout chapter  assume concrete domain equipped
equality predicate  assumption w l o g  since d conjunction using equality
translated equivalent one without equality identifying variables according
stated equalities  assumption must confused discussed
previous paragraph  even concrete domain admissible set predicates
thus closed negation  assumption imply presence inequality
predicate 
need prerequisites start presentation tableau
algorithm  concept negation normal form  nnf  negation occurs front
concept names nominals  easily seen that  concrete domain admissible 
every alcok d  concept converted equivalent one nnf exhaustively applying rewrite rules displayed figure    use c denote result
converting c nnf  key box nnf concepts occurring key assertions
nnf  follows  generally assume input concepts key boxes nnf 
let c alcok d  concept k key box  use sub c  denote set
subconcepts c  including c itself  con k  denote set concepts appearing

right hand side key assertions k  set concepts   sub   denotes
set c sub c   moreover  write cl c  k  abbreviation set
sub c  sub con k    d
  sub con k    
start presentation tableau algorithm introducing underlying data
structure 
definition      completion system   let oa oc disjoint countably infinite
sets abstract concrete nodes  completion tree alcok d  concept c
key box k finite  labeled tree    va   vc   e  l  nodes va vc va oa  
vc oc   nodes vc leaves  tree labeled follows 
node va labeled subset l a  cl c  k  
edge  a  b  e a  b va labeled role name l a  b  occurring c
k 
edge  a  x  e va x vc labeled concrete feature l a  x 
occurring c k 
   

fikeys  nominals concrete domains

va   use levt  a  denote depth occurs  starting
root node depth     completion system alcok d  concept c key box
k tuple  t  p      
   va   vc   e  l  completion tree c k 
p function mapping p arity n c subset vcn  
linear ordering va levt  a  levt  b  implies b 
equivalence relation vc  
let  va   vc   e  l  completion tree  node b va r successor node va
 a  b  e l a  b    r  node x vc g successor  a  x  e
l a  x    g  path u  notion u successor defined obvious way 
intuitively  relation records equalities concrete nodes found
 non deterministic  model construction process  recording necessary since equalities concrete nodes induce equalities abstract nodes which  turn 
imply equalities concrete nodes  seen following example  assume completion tree contains          abstract node ai
concrete g successor xi concrete g    successor yi   assume key box contains  g keyfor     d tester returns x  x    consequence  a  a 
represent element thus functionality g   implies y  y  represent
 concrete  element  deal effects  define equivalence relation
abstract nodes second equivalence relation c concrete nodes 
definition      a c relations   let    t  p      completion system
concept c key box k    va   vc   e  l   let equivalence relation
va   r nr   node b va r  neighbor node va exists
node c va c b r successor c  similarly  g ncf  
node x vc g  neighbor exists node c va c x
g successor c  paths u  notion u  neighbor defined obvious way 
define sequence equivalence relations  a  a va follows 
 a     a  a  va   
  a  b  va    n n l a  l b  
i  
  ia

  a  b  va    c va f naf
b f  ia  neighbors c 
  a  b  va     u            un keyfor c  k 
ui  ia  neighbors xi   n 
ui  ia  neighbors yi b   n
c l a  l b  xi yi   n  
finally  set  




i   

define

c     x  y  vc    va g ncf
x g a  neighbors a  
   

filutz  areces  horrocks    sattler

definition reflects mentioned tight coupling concrete abstract equalities  d tester finds  or guesses  two concrete nodes equal 
tableau algorithm may use deduce  via computation c   even
equalities concrete nodes 
let key admissible concrete domain  decide satisfiability alcok d concept c  w r t  boolean key box k  both nnf   tableau algorithm started
initial completion tree
tc      a          a     c     
initial completion system
sc     tc    p       
p maps p occurring c    introduce operation
used completion rules add new nodes completion trees 
definition        operation   abstract concrete node called fresh completion tree appear t  let    t  p      completion system
   va   vc   e  l   use following notions 
let va   b oa fresh t  r nr   write  arb denote completion
system   obtained adding b va  a  b  e setting
l a  b    r l b      moreover  b inserted b c implies
levt  b  levt  c  
let va   x oc fresh g ncf   write  agx denote completion
system   obtained adding x vc  a  x  e setting
l a  x    g 
nesting   operation  omit brackets  writing  example    ar  b   br  c
 s   ar  b    br  c  let u   f  fn g path  va x oc fresh t 
use   aux denote completion system obtained taking distinct
nodes b            bn oa fresh setting
  aux      af  b      bn  fn bn   bn gx 
strictly speaking    arb operation non deterministic since specify
precisely node b inserted   however  since dont care non determinism 
view   operation deterministic 
completion rules found figure    note rt rch rules
non deterministic  i e   one possible outcome  this true dont know
non determinism   remarks completion rules order  upper
five rules well known existing tableau algorithms alc d  concept satisfiability
 see  e g   lutz      a   use r   neighbors u   neighbors rules
r  r  rc deserves comment  take example r  intuitively  b
two abstract nodes b completion tree  b describe
domain element constructed model  and similarly c relation concrete
   

fikeys  nominals concrete domains

ru

c  u c  l a   c    c      l a 
l a     l a   c    c   

rt

c  c  l a   c    c    l a   
l a     l a   c  c  c    c   

r

r c l a  r a  neighbor b c l b  
set      arb fresh b oa l b      c 

r

r c l a   b r a  neighbor a  c
  l b 
set l b     l b   c 

rc

u            un  p l a  exist x            xn vc
xi ui  a  neighbor   n  x            xn   p p  
set     s   au  x      aun xn   x            xn oc fresh
p p      p p     x            xn   

rch

 u            un keyfor c  k exist x            xn vc
xi ui  a  neighbor   n  c  c 

l a   
set l a     l a   d   c  c 


rp

l b    l a  va minimal w r t  b
set l a     l a  l b 

figure    completion rules alcok d  
nodes   thus b c r successor a  c r successor
b  however  since want completion tree tree  make latter
successorship explicit  compensate this  r rule talks r a  neighbors
rather r successors 
lower two rules necessary dealing key boxes  rch rule
so called choose rule  hollunder   baader        horrocks et al          intuitively 
guesses whether abstract node satisfies c exists key assertion
 u            un keyfor c  k neighbors paths ui  
necessary since possibilities may ramifications  satisfies c  must
taken account construction relation   satisfy c 
must deal consequences satisfying c
 e g  case c    
rp rule deals equalities abstract nodes recorded relation 
since b means b describe node constructed model 
node labels identical  suffices  however  choose one representative
equivalence class make sure representatives node label contains
labels  equivalent nodes  representative  use node minimal
w r t  ordering   introduced solely reason  rp rule
appropriate copying node labels 
let us formalize means completion system contain contradiction 
definition      clash   let    t  p      completion system concept c
key box k    va   vc        say completion system concrete
   

filutz  areces  horrocks    sattler

define procedure sat s 

contains clash
return unsatisfiable
   test s  
compute
compute c
 
  c
contains clash
return unsatisfiable
complete
return satisfiable
 
   application completion rule
return sat s    
figure    alcok d  tableau algorithm 
domain satisfiable iff conjunction
 
 

 

p  x            xn  

p used c  x       xn  p p  

 

  x  y 

xc

satisfiable  said contain clash iff
   va nc  a  a  l a  
   va x vc g l a  x g a  neighbor a 
   concrete domain satisfiable 
contain clash  called clash free  called complete iff completion
rule applicable s 
tableau algorithm described figure   pseudo code notation  figure  test
calls d tester specified definition      let us say words loop 
obviously exist close relationships relations c predicate
conjunction  
c  note c depend thus recomputed
step loop  
definition d tester  result test s   yields relation containing c
 and thus   
using facts  one may check that  step loop  new tuples added
relation  none deleted  see proof lemma b   appendix  
loop needed  i  defined using    ii   c defined using  
   

fikeys  nominals concrete domains

 iii  new concrete equalities c may imply even concrete and or abstract
equalities  on 
similar concrete abstract interplay takes place course several recursion steps 
equalities concrete nodes provided d tester may make new rules applicable
 for example rp rc  changes p thus   may subsequently lead
detection equalities concrete nodes d tester  on 
considerations show that  presence keys  exists close interplay
concrete domain reasoner tableau algorithm  needed keys
present  without keys  suffices apply concrete domain satisfiability check
completion rules exhaustively applied  baader   hanschke      a  
detailed proof termination  soundness  completeness together complexity analysis tableau algorithm defined section given appendix b 
theorem      let key admissible concrete domain  extended d satisfiability
np  alcok d  concept satisfiability w r t  boolean key boxes nexptime 
note that  way presented here  algorithm leaves considerable
room optimizations  one possible optimization concerns re use f  successors
 for abstract features f    example  applying r rule concept f c l a  
already f  successor b  could simply add c l b  instead adding
new f  successor c recording b c 
another candidate optimizations test function  recall function takes
predicate conjunction c set variables v non deterministically returns concrete
equivalence  i e   relation exists solution c vi vj iff
 vi      vj    see definition       hard devise alc d  concept forces
completion systems exponentially many concrete nodes slightly adapting wellknown alc concepts require models exponential size  halpern   moses        
hence  size input conjunctions c test exponential size input
concept  even trivial d conjunctions
c    d  v     d  vk  
exponential number distinct concrete equivalences   thus  number
possible outcomes call test function may double exponential size
input concept  considering example  natural response problem
require test return minimal concrete equivalences  intuitively  equivalence
minimal variables equivalent whose equality enforced conjunction 
precisely  called minimal exists concrete equivalence  
  x  y    x   y    x  y    x y   conjecture restricting test way
destroy soundness completeness tableau algorithm  however  although
definitely worthwhile optimization  help overcome existence
doubly exponentially many outcomes test worst caseat least concrete
domains d  consider concrete domain n page     conjunctions form
ci    i  v     i  v i   
readily checked that     number minimal concrete equivalences
ci exponential i  moreover  hard devise concept ci size logarithmic
   

filutz  areces  horrocks    sattler

leads completion systems   ci   hence  still doubly
exponentially many possible outcomes test function 
example discussed  exponential branching test clearly due
discreteness natural numbers  indeed  use dense structure defining concrete
domains  seems restriction minimal concrete equivalences desired
effect  namely number tests possible outcomes becomes polynomial size
input thus exponential size input concept  example  consider
concrete domain q  defined follows 
q set

q rational numbers 

q contains unary predicates  q negation q   unary predicates  q   q
q   binary comparison predicates                    ternary addition
predicate    negation    all obvious semantics  

q

readily checked q key admissible  note provides binary equality predicate  thus falls framework  conjecture exists one minimal
concrete equivalence every q predicate conjunction c  intuitively  seems possible
 inductively  determine relation set variables v used c  i  x
implies  x     y  every solution c  ii  exists solution c
v   v   implies  v      v      clearly  minimal concrete equivalence  moreover 
due  i  one 
    tableau algorithm shoqk d 
although alcok d  quite powerful dl  lacks several expressive means
found state of the art description logic systems fact racer  horrocks 
      horrocks et al         haarslev   moller         section  consider
expressive description logic shoqk d  provides concrete domains  key
boxes  nominals  many means expressivity transitive
roles  role hierarchies  qualifying number restrictions  general tboxes  modulo
details  shoqk d  viewed extension dl shoq d  key boxes 
shoq d  proposed horrocks sattler         see pan   horrocks       
tool ontology reasoning context semantic web  berners lee  hendler 
  lassila        baader et al       a  
one important feature shoqk d  so called tboxes  i e  concept equations 
 
form c   used background theory reasoning  since wellknown combining general tboxes concrete domain constructor easily leads
undecidability  baader   hanschke        lutz         shoqk d  offers pathfree variant concrete domain constructori e  concrete features admitted
inside constructor rather paths arbitrary length  restriction indeed regains
decidability  haarslev et al         horrocks   sattler         path freeness concrete
domain constructor obviously renders abstract features unnecessary  thus syntactic
type available shoqk d  
   tbox formalisms allow concept inclusions c v d  re written
equivalent equations  see section          baader et al         

   

fikeys  nominals concrete domains

      description logic shoqk d 
let us define shoqk d  formal way  starting syntax 
definition      shoqk d  syntax   role axiom either role inclusion 
form r v r  nr   transitivity axiom trans r  r nr   role
box r finite set role axioms  let v
  reflexive transitive closure role
inclusions r  role name r called simple v
  r implies trans s 
  r role
names s  let concrete domain  set shoqk d  concepts smallest set

every concept name every nominal concept 
c concepts  r role name  simple role name  n k natural
numbers  g            gn concrete features  p predicate arity n 
following expressions concepts 
c  c u d  c d  r c  r c     k c      k c   g            gn  p  g   
 
concept equation expression c   c concepts  tbox finite set
concept equations 
shoqk d   consider key boxes differ two aspects ones considered alcok d   following  assume key boxes path free  admit
complex concepts occur key assertions  note abstract features paths
occur syntax shoqk d as become clear semantics
defined  former simulated general number restrictions    n r c  
usual description logics shiq shoq family  require role names
number restrictions simple since admitting arbitrary roles yields undecidability
reasoning  horrocks et al         horrocks   sattler         role box r clear
context  usually write trans r  instead trans r  r  introduce
semantics shoqk d  relevant reasoning problems 
definition      shoqk d  semantics   interpretations    i     defined
definition      function extended novel shoqk d  concepts
follows 
   k r c i     d     e    d  e  ri   k 
   k r c i     d     e    d  e  ri   k  
 
let interpretation  satisfies concept equation c   c   di  
model tbox satisfies concept equations   similarly  satisfies role
inclusion r v ri transitivity axiom trans r  ri transitive relation 
model role box r satisfies role inclusions transitivity axioms r 
let tbox  r role box  k key box  concept c satisfiable w r t   
r  k iff c    r  k common model  c subsumed concept w r t 
  r  k  written c vt  r k d  iff c di common models   r  k 
   

filutz  areces  horrocks    sattler

note that  due requirement role names used inside number restrictions
simple  existential universal value restrictions syntactic sugar  contrast
number restrictions  used roles 
well known that  many expressive description logics  reasoning tboxes
reduced reasoning without  schild        horrocks   sattler        
shoqk d   concept c satisfiable w r t    r  k iff concept
r c u r 

u


de u
 
d et

u

r n



nominal n used
c    k

satisfiable w r t  r    k  empty tbox  r fresh role appearing
c  r   
 
 s v r  
r     r  trans r  
role name used
c    r  k

since subsumption reduced satisfiability described section    following
consider satisfiability concepts w r t  role boxes key boxes  without
tboxes  generally assume role boxes r acyclic  i e  satisfy following
condition  role name r  role names r            rk r   r    rk
ri v ri   r     k  hard see restriction since
cycles eliminated  r            rk cycle r  r i     rki
interpretations i  thus simply remove cycle r replace every
occurrence r            rk c  r  k r    add trans r    if  cycle
elimination  trans ri     n 
turn attention construction tableau algorithm shoqk d  
let us comment minor differences shoqk d  introduced
original version shoq d  described  horrocks   sattler         main
difference logic  extensions investigated  haarslev et al         pan  
horrocks         allows n ary predicates horrocks sattler restrict
unary predicates  moreover  shoq d  introduced  horrocks   sattler        uses
concrete roles rather concrete features  difference concrete roles
necessarily functional  due non functionality  original shoq d  admits two
variants t p t p concrete domain constructor  where concrete role
p unary predicate   shoqk d   simulate universal variant writing
g p g since concrete features g interpreted partial functions and  contrast
horrocks sattler  undefinedness constructor g available  except
n ary predicates provide important additional expressivity  view deviations
minor ones since easy see affect decidability complexity
reasoning 
      tableau algorithm shoqk d 
basic intuitions shoqk d  tableau algorithm similar alcok d 
algorithm  one exception  deal various expressive means shoqk d  
   

fikeys  nominals concrete domains

   n r c 
     r c 
   n r c 

    n    r c  n  

    n      r c 

figure     shoqk d  nnf rewrite rules 
convenient introduce certain abstraction models  so called tableaux  main
difference tableaux models that  tableaux  roles declared transitive
necessarily described transitive relations  show exists tableau
given concept key box common model  aim
shoqk d  algorithm construct tableau input rather trying
construct model  this  algorithm employs completion forests underlying
data structure 
first introduce tableaux  let us start discussing preliminaries 
alcok d   assume concepts key boxes nnf  i e  negation occurs
front concept names nominals  use c denote nnf c 
additional nnf rewrite rules shoqk d  found figure    complete
given alcok d  figure   
concept d  role box r  key box k  define
cl d  k     sub d  sub con k    c
  c sub d  sub con k   
cl d  r  k     cl d  k   r c   r v
  s c cl d  k   
obviously  cardinality cl d  r  k  linear size d  r  k 
d k
denote set role names occurring d  r  k  ncf
follows  write nd r k
r
denote sets concrete features occurring k  ready define
tableaux 
definition      tableau   let shoqk d  concept nnf  r role box  k
path free key box nnf  tableau w r t  r k tuple  sa   sc   l  e  e  p 

sa   sc sets abstract concrete individuals 
l   sa  cl d r k  maps abstract individual subset cl d  r  k  
d r k

e   sa sa  nr

maps pairs abstract individuals sets roles 

e   sa nd k
cf sc maps pairs abstract individuals concrete features concrete
individuals 
p maps n ary concrete predicate cl d  r  k  set n tuples sc  
abstract individual s  sa l s    
s  sa   c  c    c  cl d  r  k   r  nd r k
 
r
 s  c      t sa   e s  t  c l t   
case that 
   

filutz  areces  horrocks    sattler

 t   c l s   c
  l s  
 t   c  u c  l s   c  l s  c  l s  
 t   c  c  l s   c  l s  c  l s  
 t   r e s  t  r v
  s  e s  t  
 t   r c l s  r e s  t   c l t  
 t   r c l s   sa r e s  t  c l t  
 t   s c l s  r e s  t  r v
  trans r   r c l t  
 t      n c  l s    s  s  c    n 
 t      n c  l s    s  s  c    n 
 t    either    n c  l s  e s  t   g            gn keyfor c  k e t  gi  
defined   n   c  c  l t      
 t    n l s  l t     t 
 t    g            gn  p l s   x            xn sc e s  gi     xi
 x            xn   p p   
v
v
v
 t    p used d k  x       xn  p p   p  x            xn   x  y x    satisfiable 
 t     g            gn keyfor c  k  c l s  l t   e s  gi     e t  gi     n 
  t 
 t    g l s   e s  g  undefined 
note predicate conjunction  t    uses binary inequality predicate  general 
require concrete domain equipped predicate thus
predicate conjunction necessarily d conjunction  however  nevertheless safe
use  t    given form since tableaux used proofs need
concrete domain reasoner capable deciding satisfiability conjunction 
following lemma  whose proof provided appendix c  shows definition
tableaux provides adequate abstraction models 
lemma      let shoqk d  concept nnf  r role box  k key box
nnf  satisfiable w r t  r k iff tableau w r t  r k 
given lemma      order decide satisfiability shoqk d  concepts w r t  role
key boxes  may use  tableau  algorithm tries construct tableau input 
following  describe algorithm detail 
previous section  algorithm works completion systems  however 
case shoqk d  core component completion systems completion forest
rather completion tree  reason completion rules remove
nodes edges completion system way disconnect one tree
two subtrees 
   

fikeys  nominals concrete domains

definition      completion system   let shoqk d  concept nnf  r role
box  k path free key box nnf  concept    n r c  cl d  r  k 
  n  reserve concept name anrc
appearing cl d  r  k  define

extended closure
nrc
cl   d  r  k     cl d  r  k   anrc
     n r c  cl d  r  k   
           

let oa oc disjoint countably infinite sets abstract concrete nodes 
completion forest d  r  k finite forest f    va   vc   e  l  nodes va vc
va oa   vc oc   nodes vc leaves  forest labelled
follows 
node va labelled subset l a  cl   d  r  k  
edge  a  b  e a  b va labeled non empty set role names
l a  b  occurring d  r  k 
edge  a  x  e va x vc labeled concrete feature l a  x 
occurring d  r  k 
completion system d  r  k tuple    f  p  c    
f    va   vc   e  l  completion forest d  r  k 
p maps n ary concrete predicate cl d  r  k  set n tuples vc  
c equivalence relation vc  
linear ordering va  
node va called r successor node va if  r  r  v
  r 
r  l s  t   node x vc called g successor node va l s  x    g  finally 
 
write  
  r successors node anrc
l s 

nrc
aj
l t     j 
remarks order here  firstly  contrast alcok d  case  relation
longer required respect level node  due fact  a 
enforce termination artificially mentioned property used
ensure automatic termination   b  level node might change since node
might become root node completion rules remove nodes edges 
secondly  relation c returned d tester  used compute
relation used tableau algorithm  however  need
compute relation c alcok d  case since concepts key
boxes assumed path free 
thirdly  new concept names anrc
used ensure successors node

x generated    n r c  l x  merged later due concept   
n  r c     l x   generated successor labelled different concept anrc
 

since merging two nodes means unifying node labels  suffices disallow
   

filutz  areces  horrocks    sattler

occurrence distinct concepts anrc
node label suitable definition

clash 
since shoqk d  provides transitive roles  need cycle detection mechanism
order guarantee termination algorithm  roughly speaking  encounter
node similar already existing one  node need
explored  speaking terms  horrocks et al         baader   sattler        
employ mechanism called subset blocking 
definition       blocked   let reflexive closure   node va blocked
node va l t  l s   s    s  l t  l s    
note that  unlike done  e g    horrocks et al          blocking node
necessarily ancestor blocked node  anywhere forest  may even
blocked nodes unblocked successors  modification used later obtain
nexptime upper bound 
decide satisfiability alcok d  concept w r t  role box r pathfree key box k  where k nnf   tableau algorithm started
initial completion system
sd    fd   p       
fd     s          s     d   
p
maps p occurring k  
algorithm repeatedly applies completion rules  actual rules given 
introduce new notions  firstly  define equivalence relation va
follows  one following conditions satisfied 
n l s  l t  nominal n
 g          gn keyfor c  k  c l s l t   xi   yi gi e s  xi  
e t  yi   xi c yi   n 
intuitively  two abstract nodes related via relation describe individual
tableau 
secondly  use following abbreviations formulation rules  written
italic  
remove abstract node incoming outgoing edges  remove
va  s  t   t  s  e va vc  
adding g successor abstract node means nothing exists
g successor x vc and  otherwise  adding e s  x    g x oc
yet occur completion forest 
update relation c   d tester asked decide satisfiability dconjunction
 
 
  
p  x            xn  
x y
p used d k
 x       xn  p p  

xc

returns  case conjunction satisfiable  updated concrete equivalence c defined definition     
   

fikeys  nominals concrete domains

concerning predicate conjunction used updates  recall w l o g  assume
concrete domain contain equality predicate discussed definition     
completion rules given figure     generally assume new nodes x
introduced completion forest x already existing nodes y 
describing tableau algorithm  comment completion rules 
rules rt  r   rc  rch non deterministic  i e   application one
possible outcome  rc rule  due update operation performed c
using d tester  discussed end section      computing concrete equivalence
given d conjunction may result high degree non determinism  please note that 
contrast alcok d   need call d tester ruleand
rule application 
next  ra rule takes care abstract nodes related via   since nodes
 equivalence class denote individual  choose one representative whose
node label contains labels nodes class  representative simply
 minimal node equivalence class ra rule performs appropriate
copying node labels 
r  rule rule remove nodes edges  removes surplus r successor
node    n r c  l s   since subtree removed  ts successors
new  additional root nodes  behavior reason work completion
forest 
alcok d  case  tableau algorithm stops applying rules finds
obvious contradiction  clash  completion rules applicable 
definition       clash   let    f  p  c     completion system d  r k 
f    va   vc   e  l   said contain clash one following conditions
applies 
 c   concept name nc node va    a  a  l s  
 c   d conjunction defined satisfiable 
 
 c    
  va  
 c   va g ncf   g l s  g successor 
completion system containing clash called clash free  completion system
complete none completion rules applicable 
due simplicity algorithm  refrain describing pseudo code notation  algorithm starts initial completion system repeatedly applies
completion rules  checking clashes rule application  clash detected  returns unsatisfiable  complete clash free completion system found 
algorithm returns satisfiable  note that  since completion rules
non deterministic  algorithm non deterministic 
details proof termination  soundness  completeness given appendix c  unfortunately  leave complexity algorithm open
problem  hard prove runs double exponential time  clear
whether exponential time suffices  however  still use algorithm obtain
   

filutz  areces  horrocks    sattler

ru

c  u c  l s   blocked   c    c      l s  
l s     l s   c    c   

rt

c  c  l s   blocked   c    c    l s     
l s     l s   c  c  c    c   

r

r c l s   blocked  r successor c l t 
create new node t  t  va
set e s  t      r  l t      c 

r 

   n c  l s   blocked  n s successors
 
t            tn c l ti   ti  
  tj     j n 
create n new nodes t            tn s t  t  ti   n t  va  
set e s  ti       s  l ti       c  ansc
    n


r 

   n c  l s   blocked  n     s successors t            tn
c l ti     n 
choose i  j ti tj   set l ti      l ti   l tj   
l s  ti      l s  ti   l s  tj    remove tj incoming
outgoing edges

rc

g            gn  p l s   blocked 
gi  successors xi  x            xn   p p  
add gi  successor   n 
yi gi  successor s  add  y            yn   p p   
update c

r

r c l s   blocked 
r successor c
  l t  
l t     l t   c 

r 

s c l s   blocked  r
trans r  r v
  s  r successor r c
  l t  
l t     l t   r c 

rch

s successor s     n c  l s   
gi  successors xi   n  g          gn keyfor c  k
blocked  c  c  l s     
l s     l s   e  e  c  c 

ra

t  l t    l s   t  blocked 
set l s     l s  l t 
figure     completion rules shoqk d  

   

fikeys  nominals concrete domains

tight complexity bound shoqk d   following corollary easy by product
correctness proofs  for proof see appendix c  
corollary      shoqk d  concept satisfiable w r t  role box r path free
key box k  satisfiable w r t  r k model size  i    m
    cl   d  r  k  
thus following alternative algorithm deciding satisfiability shoqk d concept w r t  role box r path free key box k  first  guess interpretation
cardinality bounded  m   using placeholder variables oc instead
concrete values interpretation concrete features  let vc set variables
oc occuring i  additionally guess interpretation p concrete domain
predicates  completion forests  p maps n ary concrete predicate used
k n ary relation vc   perform standard  polynomial time  model checking
ensure model d  this  treat concepts form g            gn  p using
interpretation predicates p  easily checked polynomial time
model r kfor latter  assume placeholder variables stand different
values  finally  use concrete domain d tester check whether conjunction
 
p  x            xn  
p used ind k
 x       xn  p p  

satisfiable  answer yes otherwise  since algorithm clearly
implemented nexptime provided d tester running non deterministic
polynomial time  obtain following 
theorem      let key admissible concrete domain extended d satisfiability
np  shoqk d  concept satisfiability w r t  tboxes  role boxes  path free
key boxes nexptime 

   conclusion
paper  identified key constraints interesting extension description
logics concrete domains  starting observation  introduced number
natural description logics provided comprehensive analysis decidability
complexity reasoning  main observation investigations key boxes
dramatic consequences complexity reasoning  example  pspacecomplete dl alc d  becomes nexptime complete extended path free  unary 
boolean key boxes undecidable extended path free  unary  non boolean key
boxes  thus effect key boxes complexity quite different effect
key assertions abstract features allowed  calvanese et al         
abstract key assertions said free since increase complexity
expressive description logics 
show restriction boolean key boxes  in alcok d  case 
path free key boxes  in shoqk d  case  yield decidabile nexptime complete
reasoning problems  selected alc d  shoq d  basis analysis since 
   

filutz  areces  horrocks    sattler

opinion  fundamental description logics concrete domains 
going one step further  would interesting combine key boxes extensions
concrete domains  ones presented lutz               name one
possibility  extension alcok d  shoq d  inverse roles seems
natural idea  note inverse roles interact several available means
expressivity  alc inverse roles pspace complete  horrocks  sattler    tobies 
       alco inverse roles exptime complete  areces et al         alc d 
inverse roles even nexptime complete  lutz        
options future research closely related material presented
paper  example  shoqk d  concept satisfiability still decidable drop
requirement key boxes path free  moreover  leave exact time
requirements tableau algorithm open problem  algorithm runs  nondeterministic  exponential time  directly yields theorem     rather via bounded
model property 

acknowledgments
would thank anonymous reviewers valuable comments  paper
extended version  lutz  areces  horrocks    sattler        

appendix a  proofs section    
prove d   satisfiability decided ptime 
proposition a    d   satisfiability ptime 
proof  let c d   conjunction  show c satisfiable iff none following
conditions applies 
   c contains conjunct d   x  
   c contains conjuncts bit ik  x  bit ik  x  
   c contains conjuncts bitnik  x  bitmj   x  k      
   c contains conjuncts bitnik  x  bitnik  x  
   c contains conjuncts bitnik  x   bit jk  x   bit jk  x  
easily seen c unsatisfiable one conditions applies  assume
conditions     apply c let x set variables used c 
x x  set t x    k bitnik  x  c n     bitnik  x 
  c n  i  k  
set t x    r r appearing index r predicate c  mapping
well defined since c finite  condition   apply  predicates available
bitnik     d       d      define solution c follows  x x  set
 x  bit vector v bvt x  ith bit   bit it x   x  c bit it x   x  c 
  otherwise  remains prove indeed solution c 

n

   use p  x  c abbreviation p  x  conjunct c 

   

n

fikeys  nominals concrete domains

let bit ik  x  c  t x    k thus  x  bvk   since condition  
  c  moreover  non applicability condition   implies
apply  bit ik  x 

  c  definition   ith bit  x  thus   
bit k  x 
let bit ik  x  c  t x    k  x  bvk   definition   ith bit
 x    
let bit ik  x  c  t x     k   x 
  bvk   thus  x   bit ik  d 
done  t x    k  ith bit  x    definition thus
 x   bit ik  d   
  bvk done  t x    k 
let bit ik  x  c  t x     k   x 
j
bitnk  x  c n  j   since condition   apply  thus

n

  c  thus 

  c  moreover  non applicability condition   yields bit ik  x 
definition   ith bit  x    

bit ik  x 

obvious listed properties checked polynomial time 

appendix b  proofs section    
prove termination  soundness  completeness alcok d  tableau algorithm
presented section      starting termination  start establishing notions
technical lemmas 
let c concept k key box  use  c  denote
p length c  i e 
number symbols used write down   k  denote  u       uk keyfor c k  c  
path u   f  fk g  use  u  denote k      role depth concepts defined
inductively follows 
rd a    rd n     rd g     
rd u            un  p     max  ui       n   
rd c u d    rd c d    max rd c   rd d  
rd r c    rd r c    rd c      
following series lemmas eventually allow us prove termination 
lemma b    constant k that  tableau algorithm started input
c    k    va   vc   e  l  completion tree constructed run algorithm 
k
k
 va   c     vc   c     
proof  using induction number rule applications case distinction according
applied rule  straightforward show
c l a  implies rd c   c    levt  a 

  

constructed completion trees t  omit details note that      treating
rch rule  one needs employ fact k boolean thus adds concepts
role depth   node labels      treating rp rule  use b implies
levt  a  levt  b  
   

filutz  areces  horrocks    sattler

implies upper bound depth constructed completion trees  first 
r rc rules generate new nodes  application either rule node
va implies l a     thus levt  a   c        second  new  abstract
concrete  node b generated application rules node va clearly satisfies
levt  b  levt  a    max    mpl c      mpl c    denotes maximum length paths
c   note concepts k may contain paths since boolean   since
mpl c     c     observations imply depth constructed completion
trees bounded    c    
out degree  node generated  due application
rule r rc and  initially  one successor  let us analyze number
successors generated later applications rules r rc a  rules
applied concept form r c u            un  p l a  
definition cl c    k  since k boolean  number concepts per node
label bounded  sub c     c     moreover  rule application creates  c   
successors  hence  out degree constructed completion trees bounded  c         

lemma b    constant k that  tableau algorithm started c    k 
k
then  every recursion step  loop terminates   c    steps 
proof  fix argument    t  p         va   vc   e  l  passed sat function 
let               sequence concrete equivalences computed loop  let
 c    c         corresponding c relations  since test s   calls d tester 
calls indeed terminates 
show
         
  
k

implies lemma b    lemma b    exists constant k  vc   c     
k
hence   i    c    which  together     implies number steps
k
performed loop bounded    c     
proof     loop reaches i th step  i     i 
c
step    since i  i 
definition  implies i    ci    definition
c
  easy see i 
   hence i     
c
lemma b    constant k that  tableau algorithm started c    k 
k
number recursive calls bounded    c     k    
proof  obviously suffices establish appropriate upper bound number rule
applications  ru  rt  r  rc rules applied concept
node label  lemma b    number nodes exponential  c       k  
since neither nodes concepts node labels ever deleted  fact node labels
subsets cl c    k  thus implies number applications rules
exponential  c       k   holds rules r rp  applied
every concept c cl c    k  every pair  abstract  nodes  finally 
number rch applications exponential  c       k  since rule
applied every abstract node every key assertion k 
   

fikeys  nominals concrete domains

termination obvious consequence lemmas b   b   
corollary b    termination   tableau algorithm terminates input 
let us prove soundness algorithm 
lemma b    soundness   tableau algorithm returns satisfiable  input concept
c  satisfiable w r t  input key box k 
proof  tableau algorithm returns satisfiable  exists complete clashfree completion system    t  p      c    let    va   vc   e  l   definition
tableau algorithm  completion system      t  p        call
test s     returned   moreover    c s  thus  exists solution
 
 x     y  iff x c y 
  
 
clearly  solution   since
  second
  component p  
solution first part
p  x            xn     moreover 
p used c  x       xn  p p  

conjunct   x  y  second part   x c definition
thus  x     y     
use construct interpretation setting


   a va   b va b b a   w 

ai

   a   l a  

 a   n l a   n l a 
 
 w 
otherwise

ni
ri

    a  b    a    b  va a    b b   
b  r successor a   

gi

    a   x     x g a  neighbor a 

nc   n   r nr   g ncf   first show well defined 
n singleton n   assume exist a  b    b
n l a  l b   definition  definition       n l a  l b  implies
b  this  together a  b   yields b b a  contradicting
linear ordering 
f functional f naf   assume exist a  b  c
  a  b    a  c   f b    c  exist a    a    b    c  va a 
a    b b    c c    b  f  successor a    c  f  successor a   
definition   thus b  c  implying b c  since b  c   yields
b c c b  contradiction 
g functional g ncf   assume exist x  vc
  a   x     a   y    f  x      y   x g a neighbors a  definition c   thus x c implying  x     y     
contradiction 
   

filutz  areces  horrocks    sattler

show following claim  proof  use notion f  fk  a  neighbors
 with f          fk abstract features   defined analogously u a  neighbors paths u 
claim    paths u  ui  a    iff ui    neighbor
x  x     
proof  let u   f  fk g  using induction easily proved that 
b   fii    f i  a       b iff f   a  neighbor b 
b b    thus particular fki    f i  a       b iff f  fk  a neighbor b  b b    prove claim  hence remains use definition
g together    
following claim central showing model c  k 
claim    c cl c    k   c l a   c  
since c  label root node  claim   clearly implies model c   
moreover  use prove satisfies key assertions  u            un keyfor c 
k  fix a  b c uii  a    uii  b    n  non applicability rch yields
 c  c  l a       c l a   claim   implies   c i contradiction
c   thus obtain c l a   analogous way  argue c l b   since
uii  a  uii  b  defined   n  claim   yields ui  a  neighbor xi
 xi     uii  a  b ui  a  neighbor yi  yi     uii  b    n  thus
fact uii  a    uii  b  yields  xi      yi     n     obtain xi c yi
thus xi yi   n  definition   thus get b  since a  b  
obtain   b b   definition thus   b 
remains prove claim    using structural induction 
c concept name nominal  easy construction i 
c   d  since c cl c    k   c nnf concept name  since
clash free  c l a  implies
  l a   thus 
  di construction i 

yields  d   
c   u            un  p   since rc rule applicable  exist x            xn vc
xi ui  a  neighbor   n  x            xn   p p    claim  
yields uii  a     xi     n  since  x            xn   p p   solution
    x              xn    p thus c  
c   g  since clash free  exists x vc x g a  neighbor
a  thus claim    a    g  
c   u e c   e  straightforward using completeness induction
hypothesis 
c   r d  since r rule applicable  r a  neighbor b
l b   let b  minimal w r t  b b    definition i 
 a  b    ri   non applicability rp rule yields l b     induction  get
b  di thus c  
   

fikeys  nominals concrete domains

c   r d  let  a  b  ri   definition i  implies exist a    b  va
minimal w r t  a    b minimal w r t  b b    b 
r successor a    since b  clearly r a  neighbor a  non applicability
r yields l b     implies l b  due non applicability rp 
induction  get b di   since holds independently choice b  obtain
 r d i  

lemma b    completeness   input concept c  satisfiable w r t  input key box
k  tableau algorithm returns satisfiable 
proof  let model c  k  use guide  the non deterministic parts
of  algorithm constructs complete clash free completion system 
completion system    t  p         va   vc   e  l  called i compatible
exist mappings   va   vc
 ca  c l a   a  c
 cb  b r successor   a    b   ri
 cc  x g successor g   a      x 
 cd   x            xn   p p      x              xn    p
 ce  x  x     y  
first establish following claim 
claim    completion system i compatible   i  b implies  a     b 
 ii  x c implies  x     y  
proof  show induction ia b implies  a     b   see definition      
yields  i  
start   a b  exists nominal n n l a  l b    ca 
obtain  a  n  b  n   yields  a     b  definition
semantics 
step  ia b  distinguish three cases 
   i 
b   a     b  induction 

   c va f naf b f  i 
 neighbors
i  c   f  successor
c  hence  exist c    c  va c i 
c

 
 


c    b f  successor c    induction   c     c       c    
thus  cb  yields    c    a      c    b    f   implies  a     b 
definition semantics 
   exist  u            un keyfor c  k  ui  ai   neighbors xi ui  ai  neighbors yi b   n c l a l b  xi yi   n 
 ca  yields a  b c   using induction   cb    cc   straightforward
   

filutz  areces  horrocks    sattler

show uii   a      xi   uii   b      yi     n   ce  
implies uii   a     uii   b     k  since model key box k 
yields  a     b  definition semantics 
part  ii  claim    x c y  either x va g ncf
x g a  neighbors a  former case   ce  yields  x     y  
latter case  part  i  claim  cc  yields    a    x      a    y    g
implies  x     y   finishes proof claim   
show completion rules applied i compatibility
preserved 
claim    completion system i compatible rule r applicable s  r
applied i compatible completion system   obtained 
proof  let i compatible completion system  let functions satisfying
 ca   ce   let r completion rule applicable s  make case distinction
according type r 
ru rule applied concept c  u c  l a    ca   c  u c  l a  implies
 a   c  u c   i hence  a  c i  a  c i   since rule adds c 
c  l a   yields completion system i compatible via  
rt rule applied c  tc  l a   c  tc  l a  implies  a  c i  a  c i  
since rule adds either c  c  l a   applied yields
completion system i compatible via  
r rule applied concept r c l a   generates new r successor b
sets l b     c    ca    a   r c i and  hence  exists
  a   d  ri c   set       b   d   readily checked
resulting completion system i compatible via    
r rule applied concept r c l a  adds c l b  existing
r a  neighbor b a  hence  exists a  a  b rsuccessor a    part  i  claim     a     a     thus   ca 
 a     r c i  cb  yields    a      b   ri   definition semantics 
 b  c thus resulting completion system i compatible via  
 i 

 i 

rc rule applied concept u            un  p l a  ui   f  fki gi
 i 

  n  rule application generates new abstract nodes bj xj   n
  j ki
 i 

 i 

 i 

 i 

b  f   successor   n 
 i 

bj fj  successor bj    n   j ki  
 i 

xi gi  successor bki   n 
 x            xn   p p   
   

fikeys  nominals concrete domains

 i 

 ca    a   u            un  p  i   hence  exist dj   n
  j ki             n
 i 

 i 

 i 

 i 

  a   d     f   i   n 
 i 

 dj    dj    fj  i   n   j ki  
 i 

gii  dki       n 
             n   p  


 i 
 i 
set       in  jki  bj   dj         in  xi     
resulting completion system i compatible via      
rch rule applied abstract node key assertion  u            un keyfor c 
k non deterministically adds either c c  definition semantics 
 a  c  a    c i   hence  rch applied resulting
completion system i compatible via  
rp rule applied concept c l a  adds c label l b  node b
b   ca    a  c   since claim   yields  a     b   follows
resulting completion system i compatible via  
finally  show i compatibility implies clash freeness 
claim    every i compatible completion system clash free 
proof  let    t  p      i compatible completion system  consider three
kinds clash 
due  ca   clash form  a  a  l a  clearly contradicts semantics 
assume va x vc g l a  x g a  neighbor
a  exists b va b x g successor b  claim   
b implies  a     b   thus  g l a   ca  give  b   g i   obtain
contradiction since  cc  yields   b    x   g  
properties  cd   ce  part  ii  claim   imply solution  
thus  concrete domain satisfiable 
describe guidance tableau algorithm model detail 
ensure that  times  considered completion systems i compatible 
obviously holds initial completion system
sc     tc    p       tc      a          a     c    
guide non deterministic test function that  given predicate conjunction
set variables vc oc input  returns relation defined setting x
iff  x     y  x  v   relation concrete equivalence since solution
 see above   guidance   ce  obviously satisfied call test 
properties affected call  according claim    apply
   

filutz  areces  horrocks    sattler

completion rules i compatibility preserved  corollary b    algorithm
always terminates  hence guided way  since  claim    find
clash  algorithm returns satisfiable 
tableau algorithm yields decidability tight upper complexity bound alcok d concept satisfiability w r t  key boxes 
theorem b    theorem     section       let key admissible concrete domain 
extended d satisfiability np  alcok d  concept satisfiability w r t  boolean
key boxes nexptime 
proof  corollary b   lemmas b   b   yield decidability alcok d  concept
satisfiability w r t  boolean key boxes  complexity  lemma b   provides exponential
bound number recursive calls  hence  remains show single recursion
step needs exponential time  lemma b    loop terminates
exponentially many steps  step  compute relations c  
used construction predicate conjunction checking termination
loop  since  lemma b    exists exponential bound number
abstract concrete nodes completion system s  obviously done
exponential time  moreover  lemma b   implies size exponential 
together fact extended d satisfiability np implies call
test needs exponential time  remaining tasks  checking clashes  completeness 
rule applicability  clearly performed exponential time 

appendix c  proofs section    
first provide proof lemma     shows notion tableaux introduced
section     adequate abstraction models 
lemma c    lemma     section       let shoqk d  concept nnf  r
role box  k path free key box nnf  satisfiable w r t  r k iff
tableau w r t  r k 
proof  only if direction  construct tableau common model d 
r  k follows 
sa   
sc     x   g  s    x sa  
l s      c cl d  r  k    c  
e s  t      s nd r k
   s  t   
r
e s  g     g  s  g  s  defined
p p        x            xn   snc    x            xn   p   
easily verified tableau w r t  r k  proof satisfies
 t    t   identical corresponding cases  horrocks et al         horrocks  
sattler          t    holds definition l   t    definition l fact
nominals interpreted singleton sets   t    definition l  e  p together
   

fikeys  nominals concrete domains

semantics concepts g            gn  p    t    since identity function sc clearly
solution listed predicate conjunction   t    definition l e together
semantics key constraints  finally  t    definition l e together
semantics concepts g 
direction  let    sa   sc   l  e  e  p  tableau w r t  r k
let solution predicate conjunction  t     construct model
follows 


   sa

ai

    s   l s  

concept names

ni

    s   n l s   nominals n
 

r nr   ncf trans r 
v
  r   s  t    r e s  t  

s  r
r   
  s  t    r e s  t   
r nr   ncf trans r 

 x 
e s  g    x
g  s    
g ncf  
undefined e s  g  undefined
due  t     interpretation nominals singleton  moreover  interpretation
roles well defined since role boxes acyclic  following claim central proving
indeed model d  r  k 
claim  c cl d  r  k   c l s  implies c  
proof  proceed induction norm   c   c  defined follows 
  a  
  g  
  c  u c    
     n r c   

  
  
  
  

  a  
  u            un  p   
  c  c    
     n r c   

  
  
  
  

  concept name
 
      c         c    
      c  

concept names nominals n   claim follows definition ai n  
negation concept names nominals n  note c nnf   claim follows
definition ai n together  t    concepts c form c  u c  c  c 
treated using  t    t   together induction hypothesis  existential 
universal  number restrictions  proof analogous one shiq  horrocks
et al          concepts form c   g          gn  p l s   c immediate
consequence  t     definition gii   fact  x            xn   p p   implies
  x              xn    p  t     finally  concepts c   g  c immediate
consequence definition g together  t     finishes proof
claim 
definition tableaux  exists s  sa c l s     claim 
s  c thus model c 
next  show model r  definition ri   obvious trans r 
r implies ri transitive relation  let v r r  trans r 
  r 
ri definition ri   let trans r  r  s  t    e s  t  
 t   implies r e s  t   thus  s  t  ri   otherwise    v
 
trans s     r  s  t    u  v      e u  v       t   together   v
  r implies
   

filutz  areces  horrocks    sattler

  u  v      e u  v     u  v    r e u  v    thus trans r  r implies
 s  t  ri  
remains show model k  end  let  g            gn keyfor c  k
s  c gii  s    gii  t    n  since predicate conjunction
 t    contains explicit inequalities distinct concrete individuals  implies
e s  gi     e t  gi     n   t    implies  c  c  l s      c  c  l t      
c l s   claim yields   c i contradicting c   thus obtain
c l s  and  similar way  c l t   finally   t    implies   t  thus
satisfies k 
proceed prove termination  soundness  completeness tableau algorithm
presented section      starting termination  following  use  d  r  k 
denote   cl   d  r  k    recall number polynomial size d  r  k 
lemma c    termination   let key admissible concrete domain  started
shoqk d  concept nnf  role box r  path free key box k nnf 
tableau algorithm terminates 
proof  assume d  r  k tableau algorithm terminate  since key admissible  means infinite sequence s    s         
completion systems  a  s  initial completion system sd  b  si  
result applying completion rule si  
possible r r  rules applied infinitely often  easily seen
rules ru  rt  r   rc  r  r    rch  ra applied finitely often
completion systems whose set abstract nodes va increase since either
add concepts node labels  whose size bounded   add concrete nodes  whose
number bounded linearly number abstract nodes   remove abstract
nodes forest  hence sub sequence si    si          s    s         
sij result applying r r  rule sij     let si  abstract node
r r  rule applied si      since implies
generated s  linear ordering well founded  thus  find infinite subsequence sj    sj          si    si          either sj    sj        sj  sj   
     former  however  possible since r r  rules
applied per node concept cl d  r  k   even node removed 
label copying performed r  rule together clashes type  c   ensures
r  rule re applied concept node  thus second option
remains  subsequence sj    sj          si    si          sj  sj   
     let lj labeling function sj   since abstract node labeled
subset lj cl   d  r  k   nodes sjk sj  k   ljk  sjk     lj   sj    
node labels increase and  node removed  label conjoined
label node t  thus node completion system sj 
sj  lj   sj    lj   t   definition  sj  thus blocked sj    contradicting
assumption r r  rule applied sj  sj   
lemma c    soundness   expansion rules applied shoqk d  concept
nnf  role box r  path free key box k yield complete
clash free completion forest  tableau w r t  r k 
   

fikeys  nominals concrete domains

proof  let     va   vc   e  l   p  c     complete clash free completion system 
find solution  x     y  iff x c y  rc rule updates
predicate conjunction   rule application c relation updated
using concrete equivalence d tester returns  note satisfiable due
clash freeness   according definition      thus find solution required 
  define finite tableau    sa   sc   e  l  p  follows 
sa     s va   occurs blocked 
sc      x     s  x  e g  sa g 
l s     l s  cl d  r  k   the intersection due auxiliary concepts anrc
  

e s  t      r   r successor blocks r successor t  s 

 x 
x g successor
e s  g    
undefined x g successor
p    restriction p sc  
note function e well defined due definition adding g successors 
remains show satisfies  t   t     basically consequence
clash free complete 
 t   satisfied since contain clash  c   
 t   satisfied since ru rule cannot applied  thus c  u c  l s  implies
c    c  l s  
 t   satisfied since rt rule cannot applied  thus c  c  l s  implies
 c    c    l s      
 t    consider s  sa r e s  t  r v
  r    r e s  t  implies
blocks r successor s  definition successor  blocks
r   successor s  thus r  e s  t  
 t    let r c l s  r e s  t   r successor s 
blocked implies c l t  since r rule cannot applied  blocks
r successor t  s  blocked fact r rule cannot
applied yields c l t     blocking condition implies c l t  
cases  thus c l t  
 t    t   satisfied reasons  t   r replaced r
r   
 t    consider    n r c  l s   hence    n r c  l s 
completeness implies existence r successors t            tn c l ti  
 
ti  
  tj    j  latter implies     j  existence integers k   
k       anrc
l ti    anrc
l tj     t   satisfied  remains
k
 
verify
ti block tj   case  blocking condition would imply
 anrc
  anrc
  l ti   
k
 
   

filutz  areces  horrocks    sattler

block ti tj    j  similarly  would imply
 anrc
  anrc
  l t  
k
 
case  would clash  c    contradiction clash free 
 t    consider    n r c  l s   hence    n r c  l s  and  since
r  rule cannot applied  n r successors ti s  since
ti either blocked blocked exactly one node  due linear
ordering   n ui sa r e s  ui   c l ui   
 t     let    n r c  l s  r e s  t   hence    n r c  l s 
either r successor blocks r successor s  first case  nonapplicability rch rule implies  c  c  l t       second case 
 c  c  l t       t  r successor blocked t  thus blocking
condition yields  c  c  l t       cases  implies  c  c  l t      
next  consider  g            gn keyfor c  k e s  gi   defined
i  hence gi  successor i  thus blocked nonapplicability rch rule imply  c  c  l t      
 t     consider n l s  l t   definition  n l s  l t  thus t 
moreover  totality implies assume without loss generality
  t  thus non applicability ra rule implies l t  l s  
thus blocked implies   t 
 t    satisfied since rule rc cannot applied 
 t     clash freeness implies satisfiability
 

 

p  x            xn   

p used d k  x       xn  p p  

choice    x     y  iff x c y  thus  t    satisfied 
 t     let  g            gn keyfor c  k  c l s  l t   e s  gi     e t  gi   
  n  thus c l s  l t  and  choice e   xi c yi
gi e s  xi   e t  yi    hence t  without loss generality  assume
  t  thus non applicability ra rule implies l t  l s  
thus blocked implies   t 
 t    satisfied definition since contain clash  c   

lemma c    completeness   shoqk d  concept nnf tableau w r t 
role box r path free key box k  expansion rules applied d  r 
k yield complete clash free completion forest 
   

fikeys  nominals concrete domains

proof  given tableau    sa   sc   l  e  e  p  w r t  r k  guide
non deterministic rules rt  rch  ra way rule application preserves
clash freeness  together termination lemma c   finishes proof 
along rule application  perform stepwise construction total mapping
takes abstract nodes completion forest elements sa concrete nodes
completion forest elements sc  
l s  cl d  r  k  l  s   va  
r successor s  r e  s    t   
x g successor s  e  s   g     x  
x c iff  x     y  
 
 
  t   s      t  
mapping satisfying four conditions called correct following  note
completion system exists correct mapping contain clash  due
 t   first property  encounter clash  c    clash  c   cannot occur
due last property  first third property together  t    ensure
clash  c   occur  finally  clash  c   cannot occur following reason 
construction p since edges labelled abstract features never removed 
tuple  x            xn   p p    find abstract node paths u            un
u            un  p l s  xi ui  successor   n  thus  first  second 
third property together  t     t    ensure conjunction
 
p   x              xn   
p used ind k
 x       xn  p p  

solution   x        x   iff  x      y   fourth property  setting
   x       x   x vc thus yields solution    
total mapping inductively defined follows  let solution equation
 t     choose node s  l s     set  s       s  s   only  node
initial completion forest  obviously  correct  show completion
rule applied way either still correct extended
correct mapping 
application rule ru preserves correctness due  t   
due  t    rule rt applied correctness preserved 
rule r adds new node r c l s   correctness implies r c
l  s    thus  t   implies existence sa r e  s   t 
c l t   thus extending  t     obviously yields correct mapping 
rule r  adds n nodes ti    n r c  l s   correctness implies
   n r c  l  s    thus  t   implies existence t            tn sa
ti    tj    j  r e  s   ti    c l ti    thus extending  ti      ti
obviously yields correct mapping 
   

filutz  areces  horrocks    sattler

assume r  rule applicable node    n r c  l s 
n r successors ti c l ti    correctness implies    n r c 
l  s    r e  s    ti     c l ti    thus   t       j
 
 ti      tj    again  correctness implies ti  
  tj and  without loss generality  assume ti tj   hence applying rule thereby merging l tj  
l ti   preserves correctness 
rule rc  extended similar way r  new gi  successor xi
added  extending  xi      e  s   gi   yields correct   moreover 
 t    ensures c updated way fourth condition
preserved 
r rule  need extended   t     t    definition
r successors imply correctness preserved 
r  rule similar  difference  t   takes place  t   
due  t     rule rch applied without violating correctness 
ra   consider two reasons ra applicable 
n l s  l t   correctness  t    imply  s     t  
 g            gn keyfor c  k  c l s  l t   gi e s  xi   e t  yi  
xi c yi   n  correctness implies e  s   gi     e  t   gi   
thus  t    together first property correctness imply  s     t  
cases  applying ra preserves correctness 

immediate consequence lemmas      c    c    c    tableau algorithm
always terminates answers satisfiable w r t  r k input
concept satisfiable w r t  input role box r input key box k  since concept
satisfiability w r t  tboxes reduced concept satisfiability without tboxes 
obtain following result 
proposition c    let key admissible concrete domain  tableau algorithm
decides satisfiability shoqk d  concepts w r t  tboxes  role boxes  path free key
boxes 
hard verify proof lemma c   together lemmas     c  
yield bounded model property shoqk d   bound exponential 
corollary c    shoqk d  concept satisfiable w r t  role box r pathfree key box k  satisfiable w r t  r k model size  i    m
    cl   d  r  k  
   

fikeys  nominals concrete domains

proof  shoqk d  concept satisfiable w r t  role box r path free key
box k  lemma c   implies tableau algorithm constructs complete clash free
completion forest d  r  k  definition blocking  number abstract
nodes completion forest blocked bounded  m      va
abstract nodes completion forest l s    l t   either blocks t  blocks s 
blocked another node u  moreover  easily seen number
concrete successors per abstract node bounded number concrete features c  r 
k  now  proof lemma c    abstract nodes tableau constructed
complete clash free completion forest coincide nodes blocked
completion forest  finally  proof lemma     interpretation domain
model constructed tableau coincides abstract nodes tableau 
summing up  shoqk d  concept satisfiable w r t  r k model size
 i    m  

references
areces  c   blackburn  p     marx  m          road map complexity hybrid logics 
flum  j     rodrguez artalejo  m   eds    computer science logic  no      
lecture notes computer science  pp          springer verlag 
baader  f   horrocks  i     sattler  u       a   description logics semantic web  ki
kunstliche intelligenz               
baader  f   lutz  c   sturm  h     wolter  f       b   fusions description logics
abstract description systems  journal artificial intelligence research  jair      
    
baader  f     sattler  u          description logics concrete domains aggregation  prade  h   ed    proceedings   th european conference artificial
intelligence  ecai     pp          john wiley   sons 
baader  f   calvanese  d   mcguinness  d  l   nardi  d     patel schneider  p  f         
description logic handbook  theory  implementation applications  cambridge university press  cambridge  ma  usa 
baader  f     hanschke  p       a   scheme integrating concrete domains concept
languages  proceedings   th international joint conference artificial
intelligence  ijcai      pp          sydney  australia 
baader  f     hanschke  p       b   scheme integrating concrete domains concept
languages  dfki research report rr        german research center artificial
intelligence  dfki  
baader  f     hanschke  p          extensions concept languages mechanical
engineering application  proceedings   th german ai conference  gwai     vol      lecture notes computer science  pp          springer verlag 
baader  f     sattler  u          tableau algorithms description logics  dyckhoff 
r   ed    proceedings international conference automated reasoning
tableaux related methods  tableaux        vol       lecture notes artificial
intelligence  pp       springer verlag 
   

filutz  areces  horrocks    sattler

berger  r          undecidability domino problem  memoirs american
mathematical society          
berners lee  t   hendler  j     lassila  o          semantic web  scientific american 
              
borger  e   gradel  e     gurevich  y          classical decision problem  perspectives
mathematical logic  springer verlag 
borgida  a     patel schneider  p  f          semantics complete algorithm
subsumption classic description logic  journal artificial intelligence research            
borgida  a     weddell  g  e          adding uniqueness constraints description logics
 preliminary report   bry  f   ramakrishnan  r     ramamohanarao  k   eds   
proceedings  th international conference deductive object oriented
databases  dood     vol       lncs  pp         springer 
calvanese  d   de giacomo  g     lenzerini  m          decidability query
containment constraints  proceedings   th acm sigact sigmodsigart symposium principles database systems  pods     pp         
calvanese  d   de giacomo  g     lenzerini  m          keys free description logics 
baader  f     sattler  u   eds    proceedings      international workshop
description logics  dl       no     ceur ws  http   ceur ws org    pp       
calvanese  d   lenzerini  m     nardi  d          description logics conceptual data
modeling  chomicki  j     saake  g   eds    logics databases information
systems  pp          kluwer academic publisher 
dean  m   connolly  d   van harmelen  f   hendler  j   horrocks  i   mcguinness  d  l  
patel schneider  p  f     stein  l  a          web ontology language  owl  reference
version      w c working draft 
fensel  d   van harmelen  f   horrocks  i   mcguinness  d  l     patel schneider  p  f 
        oil  ontology infrastructure semantic web  ieee intelligent
systems               
graham  r  l   knuth  d  e     patashnik  o          concrete mathematics  addison
wesley publ  co   reading  massachussetts 
haarslev  v   lutz  c     moller  r          foundations spatioterminological reasoning
description logics  cohn  a   schubert  l     s c shapiro  eds    proceedings
 th international conference principles knowledge representation
reasoning  kr     pp          morgan kaufman 
haarslev  v     moller  r          racer system description  gore  r   leitsch 
a     nipkow  t   eds    proceedings  st international joint conference
automated reasoning  ijcar     no       lecture notes artificial intelligence 
pp          springer verlag 
haarslev  v   moller  r     wessel  m          description logic alcn hr  extended
concrete domains  practically motivated approach  gore  r   leitsch  a  
   

fikeys  nominals concrete domains

  nipkow  t   eds    proceedings  st international joint conference automated reasoning ijcar    no       lecture notes artificial intelligence  pp 
      springer verlag 
halpern  j  y     moses  y          guide completeness complexity modal
logics knowledge belief  artificial intelligence                 
hollunder  b     baader  f          qualifying number restrictions concept languages 
proceedings  nd international conference principles knowledge representation reasoning  kr     pp          boston  ma  usa 
hopcroft  j  e     ullman  j  d          introduction automata theory  languages
computation  addison wesley 
horrocks  i   sattler  u     tobies  s          practical reasoning expressive description logics  logic journal igpl                
horrocks  i          using expressive description logic  fact fiction   proceedings
 th international conference principles knowledge representation
reasoning  kr     pp         
horrocks  i          reasoning expressive description logics  theory practice 
voronkov  a   ed    proceedings   th international conference automated
deduction  cade        no       lecture notes artificial intelligence  pp      
springer 
horrocks  i   patel schneider  p  f     van harmelen  f          reviewing design
daml oil  ontology language semantic web  proceedings   th
national conference artificial intelligence  aaai        pp         
horrocks  i     sattler  u          ontology reasoning shoq d  description logic 
nebel  b   ed    proceedings   th international joint conference artificial
intelligence  ijcai     pp          morgan kaufmann 
horrocks  i   sattler  u     tobies  s          practical reasoning expressive description
logics  ganzinger  h   mcallester  d     voronkov  a   eds    proceedings
 th international conference logic programming automated reasoning
 lpar     no       lecture notes artificial intelligence  pp          springerverlag 
kamp  g     wache  h          ctl   description logic expressive concrete domains 
tech  rep  lki m        laboratory artificial intelligence  lki   universitity
hamburg  germany 
khizder  v  l   toman  d     weddell  g  e          decidability complexity description logics uniqueness constraints  den bussche  j  v     vianu  v   eds   
proceedings  th international conference database theory  icdt       vol 
     lncs  pp        springer 
knuth  d          art computer programming  vol     addison wesley 
lutz  c          description logics concrete domainsa survey  advances modal
logics volume    pp          world scientific publishing co  pte  ltd 
   

filutz  areces  horrocks    sattler

lutz  c       a   complexity reasoning concrete domains  ph d  thesis 
lufg theoretical computer science  rwth aachen  germany 
lutz  c       b   pspace reasoning description logic alcf d   logic journal
igpl                 
lutz  c       c   reasoning entity relationship diagrams complex attribute
dependencies  horrocks  i     tessaris  s   eds    proceedings international
workshop description logics       dl       no     ceur ws  http   ceurws org    pp         
lutz  c          nexptime complete description logics concrete domains  acm
transactions computational logic                
lutz  c   areces  c   horrocks  i     sattler  u          keys  nominals  concrete
domains  ltcs report        technical university dresden  see http   lat inf tudresden de research reports html 
lutz  c   areces  c   horrocks  i     sattler  u          keys  nominals  concrete
domains  proceedings   th international joint conference artificial intelligence  ijcai     pp          morgan kaufmann publishers 
pan  j  z     horrocks  i          reasoning shoq dn   description logic  horrocks  i     tessaris  s   eds    proceedings international workshop description logics       dl       no     ceur ws  http   ceur ws org    pp       
post  e  m          variant recursively unsolvable problem  bulletin american
mathematical society             
schild  k  d          correspondence theory terminological logics  preliminary report 
mylopoulos  j     reiter  r   eds    proceedings   th international joint
conference artificial intelligence  ijcai      pp          morgan kaufmann 
schmidt schau  m     smolka  g          attributive concept descriptions complements  artificial intelligence              

   


