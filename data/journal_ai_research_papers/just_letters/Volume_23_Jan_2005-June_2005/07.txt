journal of artificial intelligence research                  

submitted       published     

using memory to transform search on the planning graph
terry zimmerman

wizim cs cmu edu

robotics institute  carnegie mellon university
pittsburgh  pa           

subbarao kambhampati

rao asu edu

department of computer science   engineering
arizona state university  tempe az           

abstract
the graphplan algorithm for generating optimal make span plans containing parallel sets of actions remains one of the most effective ways to generate such plans  however  despite enhancements on a range of fronts  the approach is currently dominated in terms of speed  by state space
planners that employ distance based heuristics to quickly generate serial plans  we report on a family of strategies that employ available memory to construct a search trace so as to learn from various
aspects of graphplans iterative search episodes in order to expedite search in subsequent episodes 
the planning approaches can be partitioned into two classes according to the type and extent of
search experience captured in the trace  the planners using the more aggressive tracing method are
able to avoid much of graphplans redundant search effort  while planners in the second class trade
off this aspect in favor of a much higher degree of freedom than graphplan in traversing the space
of states generated during regression search on the planning graph  the tactic favored by the second approach  exploiting the search trace to transform the depth first  ida  nature of graphplans
search into an iterative state space view  is shown to be the more powerful  we demonstrate that
distance based  state space heuristics can be adapted to informed traversal of the search trace used
by the second class of planners and develop an augmentation targeted specifically at planning graph
search  guided by such a heuristic  the step optimal version of the planner in this class clearly
dominates even a highly enhanced version of graphplan  by adopting beam search on the search
trace we then show that virtually optimal parallel plans can be generated at speeds quite competitive
with a modern heuristic state space planner 

   introduction
when graphplan was introduced in       blum   furst        it became one of the fastest programs
for solving the benchmark planning problems of that time and  by most accounts  constituted a radically different approach to automated planning  despite the recent dominance of heuristic state search
planners over graphplan style planners  the graphplan approach is still one of the most effective ways
to generate the so called optimal parallel plans  state space planners are drowned by the exponential
branching factors of the search space of parallel plans  the exponential branching is a result of the fact
that the planner needs to consider each subset of non interfering actions   over the   years since its
introduction  the graphplan system has been enhanced on numerous fronts  ranging from planning
graph construction efficiencies that reduce both its size and build time by one or more orders of magnitude  smith   weld        long   fox         to search speedup techniques such as variable and
value ordering  dependency directed backtracking  and explanation based learning  kambhampati 
       in spite of these advances  graphplan has ceded the lead in planning speed to a variety of heuristic guided planners  bonet   geffner        nguyen   kambhampati        gerevini   serina 
       notably  several of these exploit the planning graph for powerful state space heuristics  while
      ai access foundation  all rights reserved 

fizimmerman   kambhampati

eschewing search on the graph itself  nonetheless  the graphplan approach remains perhaps the fastest in parallel planning mainly because of the way it combines an iterative deepening a   ida  
korf        search style with a highly efficient csp based incremental generation of applicable action
subsets 
we investigate here the use of available memory so as to surmount some of graphplans major
drawbacks  such as redundant search effort and the need to exhaustively search a k length planning
graph before proceeding to the k   length graph  at the same time we wish to retain attractive features of graphplans ida  search such as rapid generation of parallel action steps and the ability to
find step optimal plans  the approach we describe remains rooted in iterative search on the planning
graph but greatly expedites this search by building and maintaining a concise search trace 
graphplan alternates between two phases  one in which a data structure called a planning graph
is incrementally extended  and a backward phase where the planning graph is searched to extract a
valid plan  after the first regression search phase the space explored in any given episode is closely
correlated with that conducted in the preceding episode  the strategy we pursue in this work is to employ an appropriately designed trace of the search conducted in episode n  which failed to find a solution  to identify and avoid those aspects of the search that are provably unchanged in episode n    and
focus effort on features that may have evolved  we have identified precisely which features are dynamic across graphplan search episodes and construct search traces that capture and exploit these features to different degrees  depending on its design a search trace may provide benefits such as   
avoidance of much of graphplans redundant search effort     learning from its iterative search experience so as to improve its heuristics and the constraints embodied in the planning graph  and   
realizing a much higher degree of freedom than graphplan  in traversing the space of states generated during the regression search process  we will show that the third advantage is particularly key to
search trace effectiveness  as it allows the planner to focus its attention on the most promising areas of
the search space 
the issue of how much memory is the right amount to use to boost an algorithms performance
cuts across a range of computational approaches from search to the paging process in operating systems  and internet browsing to database processing operations  in our investigation we explore several alternative search trace based methods that differ markedly in terms of memory demands  we
describe four of these approaches in this paper  figure   depicts the pedigree of this family of search
trace based planners  as well as the primary impetus leading to the evolution of each system from its
predecessor  the figure also suggests the relative degree to which each planner steps away from the
original ida  search process underlying graphplan  the two tracks correspond to two genres of
search trace that we have developed 


left track  the egbg planners  explanation guided backward search for graphplan  employ a
more comprehensive search trace focused on minimizing redundant search 



right track  the pegg planners  pilot explanation guided graphplan  use a more skeletal
trace  incurring more of graphplans redundant search effort in exchange for reduced memory
demands and increased ability to exploit the state space view of the search space 

the egbg planner  zimmerman   kambhampati        adopts a memory intensive structure for
the search trace as it seeks primarily to minimize redundant consistency checking across graphplans
search iterations  this proves to be effective in a range of smaller problems but memory constraints

   

fiusing memory to transform search on the planning graph

xy

search
trace
exploiting graphplan
symmetry   redundancy

exploiting the
state space view

egbg
leveraging csp   memory efficiency

so pegg
me egbg
trading off step optimality for
speedup in all episodes

pegg

figure    applying available memory to step away from the graphplan search process 
a family of search trace based planners
impede its ability to scale up  noting that graphplans search process can be viewed as a specialized
form of csp search  kambhampati         we explore some middle ground in terms of memory usage by augmenting egbg with several methods known to be effective as speedup techniques for csp
problems 
our primary interest in these techniques  however  is the impact on memory reduction and we describe how they accomplish this above and beyond any search speedup benefit they afford  the implemented planner  me egbg  markedly outperforms egbg in speed and capabilities  but a variety
of problems still lie beyond the planners reach due to memory constraints 
the search trace structure used by the pegg track planners trades off minimization of redundant
search in exchange for a much smaller memory footprint  in addition to its greatly reduced memory
demands  the pegg search trace structure can be exploited for its intrinsic state space view of what is
essentially graphplans csp oriented search space  a significant speedup advantage of this approach
over graphplan and the egbg track planners derives from its ability to employ the distance based
heuristics that power many of the current generation of state space planners  bonet   geffner       
nguyen   kambhampati        hoffman         we adapt these heuristics to the task of identifying
the most promising states to visit in the search trace and implement the approach first in the so pegg
planner  step optimal pegg  zimmerman   kambhampati         so pegg outperforms even a
highly enhanced version of graphplan by up to two orders of magnitude in terms of speed  and does
so while maintaining the guarantee of finding a step optimal plan 
finally we explore adoption of a beam search approach in visiting the state space implicit in the
pegg style trace  here we employ the distance based heuristics extracted from the planning graph
itself  not only to direct the order in which search trace states are visited  but also to prune and restrict
that space to only the heuristically best set of states  according to a user specified metric  we show
that the planning graph can be further leveraged to provide a measure of the likelihood that a previously generated regression state might spawn new search branches at a higher planning graph level 
   

fizimmerman   kambhampati

we term this metric flux and employ it in an effective filter for states that can be skipped over even
though they might appear promising based on the distance based heuristic  implemented in the pegg
system  zimmerman   kambhampati         this approach to exploiting a search trace produces a
two fold benefit over our previous approaches     further reduction in search trace memory demands
and    effective release from graphplans exhaustive search of the planning graph in all search episodes  pegg exhibits speedups ranging to more than    x over the enhanced version of graphplan
and is quite competitive with a recent state space planner using similar heuristics  in adopting beam
search pegg necessarily sacrifices the guarantee of step optimality but empirical evidence indicates
the secondary heuristics are remarkably effective in ensuring the make span of solutions produced are
virtually at the optimal 
the fact that these systems successfully employ a search trace at all is noteworthy  in general  the
tactic of adopting a search trace for algorithms that explicitly generate node states during iterative
search episodes  has been found to be infeasible due to memory demands that are exponential in the
depth of the solution  in sections   and   we describe how tight integration of the search trace with
the planning graph permits the egbg and pegg planners to largely circumvent this issue  the
planning graph structure itself can be costly to construct  in terms of both memory and time  there are
well known problems and even domains that are problematic for planners that employ it   postgraphplan planners that employ the planning graph for some purpose include stan  long   fox 
      blackbox  kautz   selman        ipp  koehler et al         altalt  nguyen   kambhampati        lpg gerevini   serina         the planning systems described here share that
memory overhead of course  but interestingly  we have found that search trace memory demands for
the pegg class of planners have not significantly limited the range of problems they can solve 
the remainder of the paper is organized as follows  section   provides a brief overview of the
planning graph and graphplans search process  the discussion of both its csp nature and the manner in which the process can be viewed as ida  search motivates the potential for employing available memory to accelerate solution extraction  section   addresses the two primary challenges in attempting to build and use a search trace to advantage with graphplan     how can this be done within
reasonable memory constraints given graphplans csp style search on the planning graph  and    
once the trace is available  how can it most effectively be used  this section briefly describes egbg
 zimmerman   kambhampati         the first system to use such a search trace to guide graphplans
search  and outlines the limitations of that method  details of the algorithm are contained in appendix
a   section   summarizes our investigations into a variety of memory reduction techniques and reports the impact of a combination of six of them on the performance of egbg  the pegg planners
are discussed in section   and the performance of so pegg and pegg  using beam search  are compared to an enhanced version of graphplan  egbg  and a modern  serial state space planner  section
  contains a discussion of our findings and section   compares this work to related research  finally 
section   wraps up with our conclusions 
   background   motivation  planning graphs and the nature of direct
graph search
here we outline the graphplan algorithm and discuss traits suggesting that judicious use of additional
memory might greatly improve its performance  we touch on three related views of graphplans
search     as a form of csp     as ida  search and     its state space aspect 
   

fiusing memory to transform search on the planning graph

actions
level  

initial
state
w

the planning graph
propositions
propositions
actions
level  
level  
level  
nop
nop

 w
w

nop

a 
y

actions
level  

 w

nop

 w

w

nop

w

a 

a 

nop

 y
y

nop

nop

nop

x
 y
y
z
h

a 

nop

i

a 

a 

nop

h

nop

i

nop

 y
y

nop

h

propositions
level  

a 

i

a 
a 

a 

nop

j

a 

j

nop

j

domain actions

y

a 

ihw
hj

a 

x

action descriptions 

y

a 

y  w
ij

a 

z
y

a 

j  y

action id  effects 
 preconditions 

figure    planning graph representation for three levels in the alpha domain
    construction and search on a planning graph
the graphplan algorithm employs two interleaved phases  a forward phase  where a data structure
called a planning graph is incrementally extended  and a backward phase where the planning graph
is searched to extract a valid plan  the planning graph consists of two alternating structures  called
proposition lists and action lists  at the bottom of figure   is depicted a simple domain we will refer
to as the alpha domain and use for illustration in this study  the figure shows four action and proposition levels of the planning graph engendered by the simple initial state given the domain  we start
with the initial state as the zeroth level proposition list  given a k level planning graph  the extension
of the graph structure to level k   involves introducing all actions whose preconditions are present in
the kth level proposition list  in addition to the actions of the domain model  no operation actions are
introduced  one for each condition in the kth level proposition list  abbreviated as nop in this papers
figures  but also termed persists by others   a nop c action has c as its precondition and c as its
effect  given the kth level actions  the proposition list at level k   is constructed as just the union of
the effects of all the introduced actions  the planning graph maintains the dependency links between

   

fizimmerman   kambhampati

the actions at level k    their preconditions in the level k proposition list  and their effects in the level
k   proposition list 
during planning graph construction binary  mutex   constraints are computed and propagated  in
figure    the arcs denote mutex relations between pairs of propositions and pairs of actions  the
propagation starts at level   by labeling as mutex all pairs of actions that are statically interfering with
each other  static mutex   that is their preconditions or effects are logically inconsistent  mutexes
are then propagated from this level forward using two simple propagation rules  two propositions at
level k are marked mutex if all actions at level k that support one proposition are mutex with all actions that support the second proposition  two actions at level   are then mutex if they are statically
interfering or if a precondition of the first action is mutually exclusive with a precondition of the second    we term the latter dynamic mutex  since this constraint may relax at a higher planning graph
level    the propositions themselves can also be either static mutex  one negates the other  or dynamic mutex  all actions supporting one proposition are mutex with all actions supporting the other  
to reduce figure   clutter mutex arcs for propositions and their negations are omitted 
the search phase on a k level planning graph involves checking to see if there is a sub graph of the
planning graph that corresponds to a valid solution to the problem  figure   depicts graphplan search
in a manner similar to the csp variable value assignment process  beginning with the propositions
corresponding to the goals at level k  we incrementally select a set of actions from the level k action
list that support all the goals  such that no two actions selected for supporting two different goals are
mutually exclusive  if they are  we backtrack and try to change the selection of actions   this is essentially a csp problem where the goal propositions at each level are the variables  actions that establish
a proposition are the values  and the mutex conditions constitute constraints  the search proceeds in
depth first fashion  once all goals for a level are supported  we recursively call the same search process on the k   level planning graph  with the preconditions of the actions selected at level k as the
goals for the k   level search  the search succeeds when we reach level    the initial state  and the
solution is extracted by unwinding the recursive goal assignment calls  this process can be viewed as
a system for solving dynamic csps  dcsp   mittal   falkenhainer        kambhampati       
wherein the standard csp formalism is augmented with the concept of variables that do not appear
 a k a  get activated  until other variables are assigned 
during the interleaved planning graph extension and search phases  the graph may be extended to a
stasis condition  after which no further changes occur in actions  propositions  or mutex conditions  a
sufficient condition defining this level off is a level where no new actions are introduced and no
existing mutex conditions between propositions go away  we will refer to all planning graph levels at
or above level off as static levels  note that although the graph becomes static at this point  finding a
solution may require many more episodes composed of adding identical static levels and conducting
regression search on the problem goals 
like many fielded csp solvers  graphplan s search process benefits from a simple form of nogood learning  when a set of  sub goals for a level k is determined to be unsolvable  they are memoized at that level in a hash table  subsequently  when the backward search process later enters level k
with a set of subgoals they are first checked against the hash table  and if a match is found the search
 

the static mutex condition has also been called eternal mutex and the dynamic mutex termed conditional mutex  smith
  weld        

   

fiusing memory to transform search on the planning graph

j nop

s

a 

s

a 

w

j

d

a 

s

a 

j

a 

yj

y

s
d

a 

w

z nop

s

j

y
j

a 

nop

i nop

h nop
y

i a 
a 

j

i
a 

nop

s

j

nop

a 

x

a 

nop

s

level  

a 

x

y
s

yh i j

a 

s

w

a 

ha  nop

a 

s

nop

nop

a 

i

nop

d
j

s

a 

nop

s

y

i

a 

z nop

wxyz

d

h nop
y

a 

d nop j
a 
s
nop

i nop

wyhij

initial state

a 
s

goal state

d nop

a 

a 

a 
s

a 

nop

h
a 

a 

level  

level  

yhi

icon explanation 
action a  assigned to give
assigned action is
d assigned action is
j
s
goal j
static mutex with a
dynamic mutex with a
a 
previous assigned action
previous assigned action
a 
goal i is already satisfied
set of regressed subgoals
i
by a previously assigned action a 
to be satisfied at next lower level

figure    csp style trace of graphplans regression search on the figure   planning graph
process backtracks  this constitutes one of three conditions for backtracking  the two others arise
from attempts to assign static mutex actions and dynamic mutex actions  see the figure   legend  
we next discuss graphplans search from a higher level view that abstracts away its csp nature 
    graphplan as state space search
from a more abstract perspective  graphplan can be viewed as conducting regression state space
search from the problem goals to the initial state  in this view  the states that are generated and expanded are the subgoals that result when the csp process for a given set of subgoals finds a consistent
set of actions satisfying the subgoals at that planning graph level  c f  kambhampati   sanchez 
       in this view the state generator function is effectively graphplans csp style goal assignment routine that seeks a non mutex set of actions for a given set of subgoals within a given planning
graph level  this view is depicted in figure    where the top graph casts the csp style search trace of
   

fizimmerman   kambhampati

 

init
state

w
y

 

proposition levels

 

  valid sets of action
assignments to satisfy
goals wxyz at level  
y
j a 

 

 

init
state

w

 

w
y a  a 
h
goal
i
w
x
y
z
y
h a   a 
i a
 

 

proposition levels

s  

s 

s 

s 

s 

 

s 
w
y
h
i

s 

s  
s  

s  

 

s  

s  

s  

y
j

goal

w
x
y
z

y
s  

s  

s  

y
h
i

s  

s  
 

 

 
s  
s  

s  

w

 

s 

s  

s  

s 

w
y
h
i

s  

s  

s  

s  

y
j

y
h
i

s  
s  

s  

 

s 

s  

s  

 

s 

s  
s  

s  

s 
s 

s  

init
state

y

proposition levels

s  
s  

goal
w
x
y
z

s  

figure    graphplans regression search space  three consecutive search episodes
figure   as a high level state space search trace  the terms in each box depict the set of  positive 
subgoals that result from the action assignment process for the goals in the higher level state to which
the box is linked  
recognizing the state space aspect of graphplans search helps in understanding its connection to
ida  search  first noted and briefly discussed in  bonet   geffner         we highlight and expand
upon this relationship here  there are three correspondences between the algorithms 
   graphplans episodic search process in which all nodes generated in the previous episode are regenerated in the new episode  and possibly some new nodes   corresponds to ida s iterative
search  here the graphplan nodes are the states  sets of subgoals  that result when its regres 

figure   facilitates discussion of the search trace in the next section  by conjuring up a hypothetical problem in which the
first search episode begins on level   of the planning graph instead of level    as in figure   

   

fiusing memory to transform search on the planning graph

sion search on a given plan graph level succeeds  from this perspective the node generator
function is effectively graphplans csp style goal assignment routine that seeks a non mutex
set of actions for a given set of propositions within a given planning graph level 
   from the state space view of graphplans search  ala figure     within a given search episode iteration the algorithm conducts its search in the depth first fashion of ida   this ensures
that the space requirements are linear in the depth of a solution node 
   the upper bound that is iteratively deepened ala ida  is the node state heuristic f value 
f   g   h  in this context h is the distance in terms of associated planning graph levels between a
state generated in graphplans regression search and the initial state  and g is the cost of reaching
the state from the goal state in terms of number of csp epochs  i e  the numerical difference between the highest graph level and the states level  
for our purposes  perhaps he most important observation is that the implicit f value bound for a
given iteration is just the length of the planning graph associated with that iteration  that is  for any
node state  its associated planning graph level determines both the distance to the initial state  h  and
the cost to reach it from the goal state  g   and the total must always equal the length of the plan graph 
this heuristic is clearly admissible  there can be no shorter distance to the goal because graphplan
exhaustively searches all shorter length planning graphs in  any  previous iterations  it is this heuristic
implicit in the graphplan algorithm which guarantees that a step optimal solution is returned  note
that from this perspective all nodes visited in a given graphplan search iteration implicitly have the
same f value  g   h   length of planning graph  we will consider implications of this property when
we address informed traversal of graphplans search space in section   
the primary shortcoming of a standard ida  approach to search is that it regenerates so many of
the same nodes in each of its iterations  it has long been recognized that ida s difficulties in some
problem spaces can be traced to using too little memory  russell        sen   bagchi         the
only information carried over from one iteration to the next is the upper bound on the f value  graphplan partially addresses this shortcoming with its memo caches that store no goods  states found to
be inconsistent in successive episodes  however  the ida  nature of its search can make it an inefficient planner for problems in which the goal propositions appear non mutex in the planning graph
many levels before a valid plan can actually be extracted 
a second shortcoming of the ida  nature of graphplans search is that all node states generated in
a given graphplan episode have the same f value  i e  the length of the graph   as such  within an
iteration  search episode  there is no discernible preference for visiting one state over another  we
next discuss the use of available memory to target these shortcomings of graphplans search 
   efficient use of a search trace to guide planning graph search
the search space graphplan explores in a given search episode is defined and constrained by three
factors  the problem goals  the plan graph associated with the episode  and the cache of memoized nogood states created in all previous search episodes  typical of ida  search there is considerable
 

bonet   geffner define hg  the graphplan h value  somewhat differently as the first level at which the goals of a
state appear non mutex and have not been memoized  our definition  which is not necessarily the first level at
which the sm goals appear non mutex  produces the most informed admissible estimate in all cases  this
guarantees that all states generated by graphplan have an f value equal to the planning graph length  which is
the property of primary interest to us 

   

fizimmerman   kambhampati

similarity  i e  redundancy  in the search space for successive episodes as the plan graph is extended 
in fact  as discussed below  the backward search conducted at any level k   of the graph is essentially
a replay of the search conducted at the previous level k with certain well defined extensions  more
specifically  essentially every set of subgoals generated in the backward search of episode n  starting at
level k  will be regenerated by graphplan during episode n   starting at level k    unless a solution is
found first   
now returning to figure   in its entirety  note that it depicts a state space tree structure corresponding to graphplans search over three consecutive iterations  the top graph  as discussed above  represents the subgoal states generated in the course of graphplans first attempt to satisfy the wxyz
goal of a problem resembling our running example   it is implied here that the w x y z propositions
are present in the planning graph at level   and that this is the first level at which no pair of them is
mutex   in the second search episode  the middle figure   graph   the same states are generated again 
but each at one level higher  in addition  these states are expanded to generate a number of children 
shown in a darker shade   since figure   is a hypothetical variation of the alpha domain problem
detailed in figures   and    all states created beyond the first episode are labeled only with state numbers representing the order in which they are generated   finally  in the third episode  graphplan regenerates the states from the previous two episodes in attempting to satisfy wxyz at level    and ultimately finds a solution  the assigned actions associated with the figures double outlined subgoal
sets  after generating the states shown with darkest shading in the bottom graph of figure   
noting the extent to which consecutive iterations of graphplans search overlap  we investigate the
application of additional memory to store a trace of the explored search tree  the first implemented
approach  egbg  which is summarized in the following subsection   seeks to leverage an appropriately designed search trace to avoid as much of the inter episode redundant search effort as possible
 zimmerman   kambhampati        
    aggressive use of memory in tracing search  the egbg planner
like other types of csp based algorithms  graphplan consumes most of its computational effort on a
given problem in checking constraints  an instrumented version of the planner reveals that typically 
         of the cpu run time is spent in creating and checking action and proposition mutexes  both
during planning graph construction and the search process   mutex relations incorporated in the planning graph are the primary constraints in the csp view of graphplan  kambhampati        as
such  this is an obvious starting point when seeking efficiency improvements for this planner and is
the primary tactic adopted by egbg  we provide here only an overview of the approach  referring the
interested reader to appendix a for details 
egbg exploits four features of the planning graph and graphplans search process 

 

the set of actions that can establish a given proposition at level k   is always a superset of
those establishing the proposition at level k 

strictly speaking  this is not always the case due to the impact of graphplans memoizing process  for some problems a
particular branch of the search tree generated in search episode n and rooted at planning graph level k may not be revisited in
episode n   at level k   due to a no good proposition set memoized at level k    however  the memo merely acts to
avoid some redundant search and neglecting these relatively rare cases serves to simplify visualization of the symmetry
across graphplans search episodes   

   

fiusing memory to transform search on the planning graph



the constraints  mutexes  that are active at level k monotonically decrease with increasing
planning graph levels  that is  a mutex that is active at level k may or may not continue to be
active at level k   but once it becomes inactive it never gets re activated at future levels 



two actions in a level that are statically mutex  i e  their effects or preconditions conflict with
each other  will be mutex at all succeeding levels 



the problem goal set that is to be satisfied at a level k is the same set that will be searched on at
level k   when the planning graph is extended  that is  once a subgoal set is present at level k
with no two propositions being mutex  it will remain so for all future levels 

given an appropriate trace of the search conducted in episode n  which failed to find a solution  we
would like to ignore those aspects of the search that are provably unchanged in episode n    and focus effort on only features that may have evolved  if previous search failed to extract a solution from
the k length planning graph  search on the k   length graph can succeed only if one or more of the
following conditions holds 
   the dynamic mutex condition between some pair of actions whose concurrent assignment
was attempted in episode n no longer holds in episode n   
   for a subgoal that was generated in the regression search of episode n at planning graph level
k  there is an action that establishes it in episode n   and first appears in level k   
   an episode n regression state  subgoal set  at level k that matched a cached memo at that
level has no memo match when it is generated at level k   in episode n   
 the discussion in appendix a formalizes these conditions   in each instance where one of these
conditions does not hold  a complete policy must resume backward search under the search parameters associated with the instance in the previous episode  n  such resumed partial search episodes will
either find a solution or generate additional trace subgoal sets to augment the parent trace  this specialized search trace can be used to direct all future backward search episodes for this problem  and
can be viewed as an explanation for the failure of the search process in each episode  we hereafter use
the terms pilot explanation  pe  and search trace interchangeably  the following definitions are useful in describing the search process 
search segment  this is essentially a state  specifically a set of planning graph level specific subgoals
generated in regression search from the goal state  which is itself the first search segment   each
egbg search segment sn   generated at planning graph level k contains 
 a subgoal set of propositions to be satisfied
 a pointer to the parent search segment  sp     the state at level k   that gave rise to sn 
 a list of the actions that were assigned in sp which resulted in the subgoals of sn
 a pointer to the pe level  as defined below  associated with the sn
 a sequential list of results of the action consistency checking process during the attempt to satisfy sns subgoals  the possible trace results for a given consistency check are  static mutex 
dynamic mutex  or action is consistent with all other prior assigned actions  trace results are
stored as a list of bit vectors for efficiency 
a search segment therefore represents a state plus some path information  but we often use search
segment and state interchangeably  as such  all the boxes in figure    whether the state goals are
explicitly shown or not  can be viewed as search segments 

   

fizimmerman   kambhampati

pilot explanation  pe   this is the search trace  it consists of the entire linked set of search segments
representing the search space visited in a graphplan backward search episode  it is convenient to
visualize it as in figure    a tiered structure with separate caches for segments associated with search
on each planning graph level  we adopt the convention of numbering the pe levels in the reverse
order of the plan graph  the top pe level is    it contains a single search segment whose goals are the
problem goals  and the level number is incremented as we move towards the initial state  when a
solution is found  the pe will necessarily extend from the highest plan graph level to the initial state 
as shown in the third graph of figure   
pe transposition  when a state is first generated in search episode n it is associated with a specific
planning graph level  say k  the premise of using the search trace to guide search in episode n   is
based on the idea of re associating each pe search segment  state  generated  or updated  in episode n
with the next higher planning graph level  that is  we define transposing the pe as  for each search
segment in the pe associated with a planning graph level k after search episode n  associate it with
level k   for episode n   
given these definitions  we note that the states in the pe after a search episode n on plan graph
level k  loosely constitute the minimal set   of states that will be visited when backward search is conducted in episode n   at level k     this bound can be visualized by sliding the fixed tree of search
segments in the first graph of figure   up one level  
    conducting search with the egbg search trace
egbg builds the initial pilot explanation during the first regression search episode while tracing the
search process with an augmented version of graphplans assign goals routine  if no solution is
possible on the k length planning graph  the pe is transposed up one level  and key features of its previous search are replayed such that significant new search effort only occurs at points where one of the
three conditions described above holds  during any such new search process the pe is augmented according to the search space visited 
the egbg search algorithm exploits its search trace in essentially bi modal fashion  it alternates
informed selection of a state from the search trace of its previous experience with a focused csp type
search on the states subgoals  our discussion here of egbgs bi modal algorithm revolves around
the second mode  minimizing redundant search effort once a state has been chosen for visitation 
when we describe peggs use of the search trace in section   we will see that greater potential for
dramatic efficiency increases lies with the first mode  the selection of a promising state from the
search trace 
after choosing a state to visit  egbg uses the trace from the previous episode to focus on only
those aspects of the entailed search that could possibly have changed  for each search segment si at
planning graph level k    visitation is a  step process 
   perform a memo check to ensure the subgoals of si are valid at level k  
   replay the previous episodes action assignment sequence for all subgoals in si  using the
segments ordered trace vectors  mutex checking is conducted on only those pairs of actions
that were dynamic mutex at level k  for actions that are no longer dynamic mutex  add the can 

it is possible for graphplans memoizing process to preclude some states from being regenerated in a subsequent episode 
see footnote   for an brief explanation of conditions under which this may occur 

   

fiusing memory to transform search on the planning graph

didate action to sis list of consistent assignments and resume graphplan style search on the remaining goals  si  is augmented and the pe extended in the process  whenever sis goals are
successfully assigned  entailing a new set of subgoals to be satisfied at lower level k  a child
search segment is created  linked to si   and added to the pe 
   for each si subgoal in the replay sequence  check also for new actions appearing at level k  
that establish the subgoal  new actions that are inconsistent with a previously assigned action
are logged as such in sis assignments  for new actions that do not conflict with those previously assigned  assign them and resume graphplan style search from that point as for step   
   memoize sis goals at level k   if no solution is found via the search process of steps   and   
as long as all the segments in the pe are visited in this manner  the planner is guaranteed to find an
optimal plan in the same search episode as graphplan  hereafter we refer to a pe search segment that
is visited and extended via backward search to find a valid plan  as a seed segment  in addition  all
segments that are part of the plan extracted from the pe we call plan segments  thus  in the third
graph of figure    s   is the apparent seed segment while the plan segments  in bottom up order  are 
s    s    s    s    s    s    labeled segments yh  yhi  and the goal state wxyz 
in principle we have the freedom to traverse the search states encapsulated in the pe in any order
and are no longer restricted to the  non informed  depth first nature of graphplans search process 
unfortunately  egbg incurs a high overhead associated with visiting the search segments in any order other than bottom up  in terms of pe levels   if an ancestor of any state represented in the pe
were to be visited before the state itself  egbgs search process would regenerate the state and any of
its descendents  unless it first finds a solution   there is a non trivial cost associated with generating
the assignment trace information in each of egbgs search segments  its search advantage lies in reusing that trace data without having to regenerate it 
on the other hand  top down visitation of the segments in the pe levels is the degenerate mode 
such a search process essentially mimics graphplans  since each episode begins with search on the
problem goal set  and  with the exception of the replay of the top level search segments assignments 
regenerates all the states generated in the previous episode  plus possibly some new states  during its
regression search  the search trace provides no significant advantage under a top down visitation
policy 
the bottom up policy  on the other hand  has intuitive appeal since the lowest levels of the pe correspond to portions of the search space that lie closest to the initial state  in terms of plan steps   if a
state in one of the lower levels can in fact be extended to a solution  the planner avoids all the search
effort that graphplan would expend in reaching the state from the top level problem goals 
adopting a bottom up visitation policy amounts to layering a secondary heuristic on the primary
ida  heuristic  which is the planning graph length that is iteratively deepened  recalling from section     that all states in the pe have the same f value in terms of the primary heuristic  we are essentially biasing here in favor of states with low h values  support for such a policy comes from work on
heuristic guided state space planning  bonet   geffner        nguyen   kambhampati        in
which weighting h by a factor of   relative to the g component of the heuristic f value generally improved performance  however  unlike these state space planning systems  for which this is the primary heuristic  egbg employs it as a secondary heuristic so the guarantee of step optimality does not

   

fizimmerman   kambhampati

standard graphplan

speedup ratios

egbg

problem
time

bktrks

mutex
chks

    

   x

   x

   x

      k

    

    x

    x

  x

    k

    k

    

    x

  x

  x

    k

     k

    

   x

   x

   x

total
time

backtracks

mutex
checks

total
time

backtracks

mutex
checks

size of
pe

bw large b
       

   

     k

        k

  

    k

       k

rocket ext a
      

   

     k

       k

  

    k

tower  
       

   

     k

      k

  

ferry  
       

   

     k

      k

  

table    comparison of egbg with standard graphplan 
numbers in parentheses give number of time steps   number of actions respectively  search backtracks and
mutex checks performed during the search are shown   size of pe  is pilot explanation size in terms of the
final number of search segments  standard graphplan is the lisp version by smith and peot 

depend on its admissibility  we have found bottom up visitation to be the most efficient mode for
egbg and it is the default order for all egbg results reported in this study 
    egbg experimental results
table   shows some of the performance results reported for the first version of egbg  zimmerman  
kambhampati         amongst the search trace designs we tried  this version is the most memory
intensive and records the greatest extent of the search experience  runtime  the number of search
backtracks  and the number of search mutex checks performed is compared to the lisp implementation of the original graphplan algorithm  egbg exhibits a clear advantage over graphplan for this
small set of problems 




total problem runtime            x improvement
number of backtracks during search          x improvement
number of mutex checking operations during search          x improvement

since total time is  of course  highly dependent on both the machine as well as the coding language  
 egbg performance is particularly sensitive to available memory   the backtrack and mutex checking
metrics provide a better comparative measure of search efficiency  for graphplan  mutex checking is
by far the biggest consumer of computation time and  as such  the latter metric is perhaps the most
complete indicator of search process improvements  some of the problem to problem variation in
egbgs effectiveness can be attributed to the static dynamic mutex ratio characterizing graphplans
action assignment routine  the more action assignments rejected due to pair wise statically mutex
actions  the greater the advantage enjoyed by a system that doesnt need to retest them  tower ofhanoi problems fall into this classification 
as noted in the original study  zimmerman   kambhampati        the range of problems that can
 

all planners developed for this report were coded in allegro lisp and run on a pentium     mhz  with     m ram 
runtimes include plangraph construction time and exclude garbage collection time  values in table   differ from those
published in      because problems were re run on this platform  they also reflect some changes in the tracking of statistics 

   

fiusing memory to transform search on the planning graph

be handled by this implementation is significantly restricted by the amount of memory available to the
program at runtime  for example  with a pe consisting of almost       search segments  the very
modest sized bw large b problem challenges the available memory limit on our test machine  we
consider next an approach  me egbg in figure    that occupies a middle ground in terms of memory
demands amongst the search trace approaches we have investigated 
   engineering to reduce egbg memory requirements  the me egbg planner
the memory demands associated with graphplans search process itself are not a major concern  since
it conducts depth first search with search space requirements linear in the depth of a solution node 
since we seek to avoid the redundancy inherent in the ida  episodes of graphplans search by using
a search trace  we must deal with a much different memory demand profile  the search trace design
employed by egbg has memory requirements that are exponential in the depth of the solution  however  the search trace grows in direct proportion to the search space actually visited  so that techniques
which prune search also act to greatly reduce its memory demands 
we examined a variety of methods with respect to this issue  and eventually implemented a suite of
seven that together have proven instrumental in helping egbg  and later  pegg  overcome memorybound limitations  six of these are known techniques from the planning and csp fields  variable ordering  value ordering  explanation based learning  ebl   dependency directed backtracking  ddb  
domain preprocessing and invariant analysis  and transitioning to a bi partite planning graph  four of
the six most effective methods are csp speedup techniques  however our interest lies primarily in
their impact on search trace memory demands  while there are challenging aspects to adapting these
methods to the planning graph and search trace context  it is not the focus of this paper  thus details
on the motivation and implementation of these methods is relegated to appendix b 
the seventh method  a novel variant of variable ordering we call ebl based reordering  exploits the
fact that we are using ebl and have a search trace available  although the method is readily implemented in pegg  the strict ordering of the trace vectors required by the egbg search trace make it
costly to implement for that planner  as such  memory efficient egbg  me egbg  does not use
ebl based reordering and we defer further discussion until pegg is introduced in section   
    impact of enhancements on egbg memory demands
there are two major modes in which the first six techniques impact memory demand for me egbg 
   reduction in the size of the pilot explanation  search trace   either in the number of search segments
 states   or the average trace content within the segments  and    reduction in the requirements of
structures that compete with the pilot explanation for available memory  i e  the planning graph and
the memo caches   admittedly  these two dimensions are not independent  since the number of
memos  though not the size  is linear in the number of search segments  we will nonetheless consider
this partition in our discussion to facilitate the comparison of each methods impact on the search
trace 
in general  the impact of each these enhancements on the search process depends significantly  not
only on the particular problem  but also on the presence  or absence  of any of the other methods  no
single configuration of techniques proves to be optimal across a wide range of problems  indeed  due
to computational overhead associated with these methods  it is generally possible to find a class of
problems for which planner performance degrades due to the presence of the method  we chose this
   

fi  
ddb

  

  

  

  

  

all six in combination
  in me egbg  

  

ebl

  

domain preprocess  
invariant analysis
value ordering

  

  reduction in pe  search trace  memory requirement

   

zimmerman   kambhampati

variable ordering

  

  

  

bi partite graph

  

  

  

  

  

  

   

  reduction in planning graph  memo cache memory requirements

figure    memory demand impact along two dimensions for six memory reduction speedup
techniques  plots for each applied independently and as a suite  within egbg  
set of techniques then  based on their joint average impact on the me egbg   pegg memory footprint
over an extensive variety of problems 
figure   illustrates for each method the impact on memory reduction relative to the two dimensions above  when the method operates in isolation of the others  the plot reflects results based on
twelve problems in three domains  logistics  blocksworld  and tower of hanoi   chosen to include a
mix of problems entailing large planning graphs  problems requiring extensive search  and problems
requiring both  the horizontal axis plots percent reduction in the end of run memory footprint of the
combined memo caches and the planning graph  the ratios along this ordinate are assessed based on
runs with graphplan  no search trace employed  where the memo cache and planning graph are the
only globally defined structures of significant size that remain in the lisp interpreted environment at
run completion   similarly  the vertical axis plots percent reduction in the space required for the pe at
the end of egbg runs with and without each method activated  and with the planning graph and
memo cache structures purged from working memory 
the plot crossbars for each method depict the spread of reduction values seen across the twelve
problems along both dimensions  with the intersection being the average  the bi partite planning
graph  not surprisingly  impacts only the graph aspect  but five of the six methods are seen to have an
impact on both search trace size and graph memo cache size  of these  ddb has the greatest influence on pe size but little impact on the graph or memo cache size  while ebl has a more modest influence on the former and a larger impact on the latter  due both to the smaller memos that it creates
 

the allegro common lisp global scavenging function was used to purge all but the target global data structures from
the workspace 

   

fiusing memory to transform search on the planning graph

and the production of more general memos  which engender more backtracks   domain preprocessing  invariant analysis can have a major impact on both the graph size and the pe size due to processes
such as the extraction of invariants from operator preconditions  it is highly domain dependent  having little effect in the case of blocksworld problems  but can be of great consequence in tower ofhanoi and some logistics problems 
that these six methods combined can complement each other is evidenced by the crossbars plotting space reduction when all six are employed at once  over the twelve problems average reduction
in pe size approaches     and average reduction in the planning graph memo cache aspect exceeds
     no single method in isolation averages more than a     reduction along these dimensions 
the runtime reduction associated with each of these methods in isolation is also highly dependent
on the problem and which of the other methods are active  in general  the relative time reduction for
any two methods does not correlate closely with their relative memory reduction  however  we found
that similarly  the techniques broadly complement each other such that net speedup accrues 
all of the techniques listed above can be  and have been  used to improve graphplans performance also  in terms of speed  in order to focus on the impact of planning with the search trace  we use
a version of graphplan that has been enhanced by these six methods for all comparisons to me egbg
and pegg in this study  we hereafter refer to this enhanced version of graphplan as gp e  
    experimental results with me egbg
table   illustrates the impact of the six augmentations discussed in the previous section on egbgs
 and graphplans  performance  in terms of both space and runtime  standard graphplan  gp e 
egbg  and me egbg are compared across    benchmark problems in a wide range of domains  including problems from the first three aips planning competitions held to date  the problems were
selected to satisfy three objectives  a subset that both standard graphplan and egbg could solve for
comparison to me egbg  different subsets that exceed the memory limitations of each of the three
planners in terms of either planning graph or pe size  and a subset that gives a rough impression of
search time limitations 
not surprisingly  the memory efficient egbg clearly outperforms the early version on all problems attempted  more importantly  me egbg is able to solve a variety of problems beyond the reach
of both standard graphplan and egbg  of the    problems  standard graphplan solves     the original egbg solves     gp e solves     and me egbg solves     wherever me egbg and gp e solve
the same problem  me egbg is faster by up to a factor of   x  and averages   x speedup  standard
graphplan  on the twelve problems it can solve   is bested by me egbg by factors ranging from  x to
over     x 
the striking improvement of the memory efficient version of egbg over the first version is not
simply due to the speedup associated with the five techniques discussed in the previous section  but is
directly tied to their impact on search trace memory requirements  table   indicates one of three reasons for each instance where a problem is not solved by a planner     s  planner is still in search after
   cpu minutes     pg  memory is exhausted or exceeded    minutes during the planning graph building phase     pe  memory is exhausted during search due to pilot explanation extension  the third reason clearly favors me egbg as the size of the pe  reported in terms of search segments at the time
the problem is solved  indicates that it generates and retains in its trace up to    x fewer states than
egbg  this translates into a much broader reach for me egbg  it exhausts memory on     of the
   

fizimmerman   kambhampati

table   problems compared to     for the first version of egbg  regardless  gp e solves three
problems on which me egbg fails in    minutes due to search trace memory demands
the table also illustrates the dramatic impact of the speedup techniques on graphplan itself  the
enhanced version  gp e  is well over   x faster than the original version on problems they can both
solve in    minutes  and it can solve many problems entirely beyond standard graphplans reach 
nonetheless  me egbg modestly outperforms gp e on the majority of problems that they both can
solve  since the egbg  and pegg  planners derive their strength from using the pe to shortcut
graphplans episodic search process  their advantage is realized only in problems with multiple search
episodes and a high fraction of runtime devoted to search  thus  no speedup is seen for grid y   and
all problems in the mystery  movie  and mprime domains where a solution can be extracted as
soon as the planning graph reaches a level containing the problem goals in a non mutex state 
the bottom up order in which egbg visits pe search segments turns out to be surprisingly effective for many problems  for table   problems we found that in the great majority the pe for the final
episode contains a seed segment  a state from which search will reach the initial state  within the
deepest two or three pe levels  this supports the intuition discussed in section     and suggests that
the advantage of a low h value bias as observed for heuristic state space planners  bonet   geffner 
      nguyen   kambhampati        trans lates to search on the planning graph 
results for even the memory efficient version of egbg reveal two primary weaknesses 
   the action assignment trace vectors that allow egbg to avoid redundant search are somewhat
costly to generate  make significant demands on available memory for problems that elicit large
search  e g  table   problems  log y     puzzle    freecell       and are difficult to revise when
search experience alters drastically in subsequent visits 
   despite its surprising effectiveness in many problems  the bottom up visitation of pe search
segments is inefficient in others  for table   problems such as freecell     and essentially all
schedule domain problems  when the planning graph gets extended to the level from which a
solution can be extracted  that solution arises via a new search branch generated from the root
search segment  i e  the problem goal state   thus  the only seed segment in the pe is the topmost search segment  and bottom up visitation of the pe states is more costly than graphplans
top down approach 
the first shortcoming is particularly manifest in problems that do not allow egbg to exploit the
pe  e g  problems in which a solution can be extracted in the first search episode   the hit that egbg
takes on such problems relative to graphplan is closely tied to the overhead associated with building
its search trace  a compelling tactic to address the second shortcoming is to traverse the search space
implicit in the pe according to state space heuristics  we might wish  for example  to exploit any of
the variety of state space heuristics that have revolutionized state space planners in recent years
 bonet   geffner        nguyen   kambhampati        gerevini   serina         however  as we
noted in section      when we depart from a policy of visiting egbg search segments in level bylevel  bottom up order  we face more costly bookkeeping and high memory management overhead 
more informed traversal of the state space view of graphplans search space is taken up next  where
we argue that its perhaps the key benefit afforded by a trace of search on the planning graph 

   

fiusing memory to transform search on the planning graph

problem

 steps actions 

bw large b        
huge fct
       
rocket ext a       
att log a
       
gripper          
tower  
       
tower            
 puzzle          
 puzzle          
tsp   
       
aips     
grid y          
grid y          
gripper x          
gripper x          
gripper x          
log y  
       
mprime x         
movie x         
mysty x          
aips     
blocks             
blocks             
logistics             
logistics             
logistics             
freecell           
schedule           
schedule           
aips     
depot             
depot     a        
driverlog      a        
driverlog      e        
roverprob            
roverprob           
strips sat x         
strips sat x         
ztravel    a       
ztravel    a        

egbg

graphplan
cpu sec

stnd 
   
   

gp e

cpu sec

 enhanced 

    
    
s
   
s
    
   
    
s
    
s
   
   
    
   
    
s
   
graphplan
gp e
   
    
pg
pg
   
    
s
   
s
s
pg
   
    
   
  
   
  
    
graphplan
gp e
s
   
s
    
s
    
s
    
s
s
s
    
pg
    
pg
    
graphplan
gp e
   
   
s
    
    
   
s
   
s
    
s
   
   
    
s
s
s
   
s
s

  
  
    
pe
  
    
s
pe
pe
pe
   
pg
   
pe
pe
pg
   
   
  

size of
pe

    
    
    
    
    

egbg
  
    

 
 
  
egbg

pe
pe
s
pe
pe
pe
pg
pg
   
s
   
s
   
pe
   
s
pe
pe

egbg
    
    
     
    

me egbg

speedup
 me egbg
vs  gp e 

    
    
   
    
    
  
   
pe
      
    
     
    
    
me egbg
    
  
pg
   
    
    
    
   
     
pe
      
   
 
   
 
    
  
me egbg
    
    
    
    
    
    
    
    
    
    
pe
      
    
 
    
 
me egbg
   
   
    
    
   
   
    
    
    
    
    
     
    
    
    
   
    
    
      
pe

   x
   x
   x
   x
   x
   x
   x
 pe 
   x
   x
speedup
 x
 
   x
   x
   x
 pe 
 x
 x
 x
speedup
   x
   x
   x
   x
   x
 pe 
   x
   x
speedup
    x
   x
   x
 x
   x
   x
   x
   x
  x
 

 memory efficient egbg 
cpu sec
size of
pe

   
   
   
   
   
   
    

table    search for step optimal plans  egbg  me egbg  standard   enhanced graphplan
standard graphplan  lisp version by smith and peot
gp e  graphplan enhanced per section     me egbg  memory efficient egbg
size of pe is the final search trace size in terms of the number of  search segments 
search failure modes  pg exceeded    mins  or memory constraints during graph building
pe exceeded memory limit during search due to size of pe
s exceeded    mins  during search
parentheses adjacent to cpu time give    of steps     of actions  in the solution 
   

fizimmerman   kambhampati

   focusing on the state space view  the so pegg and pegg planners
the costs associated with egbgs generation and use of its search trace are directly attributable to the
storage  updating  and replay of the csp value assignments for a search segments subgoals  we
therefore investigated a stripped down version of the search trace that abandons this tactic and focuses
instead on the embodied state space information  we will show that the pegg planners employing
this search trace  both so pegg  the step optimal version and pegg  a version using beam search  
outperform the egbg planners on larger problems  the key difference between egbgs pilot explanation and the pared down  skeletal pe used by the pegg planners  is the elimination of the detailed
mutex checking information contained in the bit vectors of the former  i e  the last item in the bullet
list of egbg search segment contents in section       the pegg planners then apply state space
heuristics to rank the pe search segments based on their associated subgoal sets  states  and are free to
visit this state space in a more informed manner  the tradeoff is that for each pe state so visited the
planner must regenerate the csp effort of finding consistent action assignments for the subgoals 
figure   illustrates the pegg advantage in a small hypothetical search trace at the final search episode  here search segments in the pe at the onset of the episode appear in solid lines and all plan
segments  states extendable to a valid plan  are shown as double lined boxes  the figure reflects the
fact that typically there may be many such latent plan segments in diverse branches of the search trace
at the solution bearing episode  clearly a planner that can discriminate plan segment states from other
states in the pe could solve the problem more quickly than a planner restricted to a bottom up traversal  deepest pe level first   state space heuristics endow the pegg planners with this capability 
the so pegg planner visits every search segment in the pe during each search episode  comparable to graphplans exhaustive search on a given length graph  thereby guaranteeing that returned
plans are step optimal  as such  any advantage of heuristic guided traversal is realized only in the
final episode  for many problems  the computational effort expended by graphplan in the last search
episode greatly exceeds that of all previous episodes combined  so this can still be a powerful advantage  however  as we scale up to problems that are larger in terms of the number and size of search
episodes  the cost of exhaustive search in even the intermediate episodes becomes prohibitive  the

 
init
state

goal

 

w

w
x
y
z

 

y

 
 
 

 
 

 
 

 

 

 

 
 

 
 
 

proposition levels

 

 

figure    the pe for the final search episode of a hypothetical problem  search segments in the pe
at onset of search appear in solid lines  double lined boxes represent plan segments 
dashed lined boxes are states newly generated in regression search during the episode 
visitation order as dictated by the secondary heuristic is shown via numbering 
   

fiusing memory to transform search on the planning graph

planner we refer to simply as pegg employs beam search  applying the search trace heuristics in all
intermediate search episodes to visit only a select subset of the pe segments  in so doing pegg
trades off the step optimality guarantee for often greatly reduced solution times 
there are several challenges that must be dealt with to effectively use the pared down search trace
employed by so pegg and pegg  including adaptation and augmentation of distance based heuristics to guide search trace traversal and dealing with memory management problems induced by the
tactic of skipping about the search space  before we describe how we addressed such issues and
give a more complete description of the algorithm  we first present some results that provide perspective on the effectiveness of these planners 
    experimental results with so pegg and pegg
table   compares graphplan  standard and gp e   me egbg  so pegg  and pegg over most of the
same problems as table    and adds a variety of larger problems that only the latter two systems can
handle  table   problems that were easily solved for gp e and me egbg  e g  those in the aips   
movie and mystery domains  are omitted from table    here  all planners that employ variable and
value ordering  i e  all except standard graphplan   are configured to use value ordering based on the
planning graph level at which an action first appears and goal ordering based on proposition distance
as determined by the adjusted sum heuristic  which will be defined below   there are a variety of
other parameters for the so pegg and pegg planners for which optimal configurations tend to be
problem dependent  we defer discussion of these to sections           and     but note here that for
the table   results the following parameter settings were used based on good performance on average
across a variety of domains and problems 
 secondary heuristic for visiting states  adjusted sum with w     eqn     
 beam search  visit the best      lowest f value  search segments per search episode  with a
minimum of    and a maximum of     search segments with flux lower than     of average
are not visited regardless of heuristic rank   wcf        see section       
focusing first on the gp e  me egbg  and so pegg columns  we clearly see the impact of the
tradeoff between storing and exploiting all the intra segment action assignment information in the pe 
in this set of    problems     result in me egbg exceeding available memory due to the size of the
pe while only one pushes that limit for so pegg  seven of the problems that cause me egbg to run
out of memory are actually solved by so pegg while the remainder exceed the time limit during
search  in addition  so pegg handles five problems in the table that gp e fails on  these problems
typically entail extensive search in the final episode  where the pe efficiently shortcuts the full graph
search conducted by gp e  the speedup advantage of so pegg relative to gp e ranges between a
modest slowdown on three problems to almost   x on the zeno travel problems  with an average of
about  x   note that the speedup values reported in the table are not for so pegg  
generally  any planner using a search trace will under perform gp e on single search episode problems such as grid y    in which the cost of building the trace is not recovered  the low overhead associated with building so peggs search trace means it suffers little relative to gp e in this case  on
most problems that both me egbg and so pegg can solve  me egbg has the upper hand due to its
ability to avoid redundant consistency checking effort  the fact that me egbgs advantage over sopegg is not greater for such problems is attributable both to so peggs ability to move about the pe
search space in the final search episode  versus me egbgs bottom up traversal  and its lower
   

fizimmerman   kambhampati

graphplan

problem

cpu sec  steps acts 

stnd 
bw large b
bw large c
bw large d
att log a
att log b
gripper  
gripper   
tower  
tower  
 puzzle  
 puzzle  
tsp   
aips     
grid y  
gripper x  
gripper x  
log y  
aips     
blocks     
blocks     
blocks     
logistics     
logistics     
logistics     
freecell    
freecell    
schedule    
aips     
depot     a
depot     
depot     
driverlog      e
driverlog      b
roverprob    
roverprob    
roverprob    
sat x  
sat x  
ztravel    a
ztravel    a

     
s
s
s
s
s
s
s
s
    
    
s
stnd gp
   
s
s
pg
stnd gp
s
 
s
 
s
s
pg
pg
pg
stnd gp
s
s
s
s
s
s
s
s
   
s
s
s

gp e

me egbg
cpu sec
 steps acts 

 enhanced  

            
s        
s        
            
s
            
s
             
s          
            
            
           
gp e
            
s
s
           
gp e
            
            
s
            
s
s
           
           
          
gp e
            
s
s
           
s
          
s
s
         
s
          
s

   

so pegg
heur istic 
adjsum

cpu sec
 steps acts 

   
    
pe
   
           
pe
s
   
    
pe
s
    
    
   
   
pe
    
    
    
    
   
me egbg
so pegg
    
    
   
   
pe
s
pe
   
me egbg
so pegg
    
    
    
    
pe
s
    
  
                         
pe
s
pe
   
pe
   
   
   
me egbg
so pegg
    
    
s
s
s
s
    
   
pe
            
pe
    
pe
s
pe
s
    
    
   
   
    
    
pe
s
pe
pe

pegg

heur  adjsum u

cpu sec
 steps acts 

speedup
 pegg
vs  gp e 

   
    
   
   
    
   
    
   
    
   
   
   

       
       
       
       
       
       
       
         
         
       
       
       
pegg
            
           
           
            
pegg
           
           
            
           
            
           
           
          
          
pegg
            
            
            
            
           
           
             
             
             
   
        
           
           

   x
    x
     x
    x
    x
   x
      x
  x
    x
   x
   x
  x
speedup
 x
    x
     x
    x
speedup
    x
   x
     x
   x
     x
     x
   x
    x
    x 
speedup
   x
   x
     x
   x
      x
    x
     x
     x
   x
    x
   x
    x

table    so pegg and pegg comparison to graphplan  gp e  and me egbg
gp e  graphplan enhanced per section     me egbg  memory efficient egbg
so pegg  step optimal  search via the pe  segments ordered by adjusted sum u heuristic
pegg  beam search  best     of segments in pe ordered by adjusted sum u heuristic
parentheses give    of steps    of actions  in plan  boldface values exceed a known
step optimal 
see table   for definitions of s  pg  and pe
   

fiusing memory to transform search on the planning graph

overhead due to its more concise search trace  note that there is no obvious reason to prefer one state
traversal order over the other in non solution bearing episodes since these step optimal planners visit
all the states in their pe for these search episodes   
now turning attention to the pegg results  its apparent that the beam search greatly extends the
size of problems that can be handled  pegg solves ten larger problems of table   that could not be
solved by either so pegg or enhanced graphplan  speed wise pegg handily outperforms the other
planners on every problem except schedule      where gp e has a factor of    x advantage  as indicated by the tables right hand column  the speedup of pegg over gp e ranges from    x to over
   x  this is a conservative bound on peggs maximum advantage relative to gp e since speedup
values for the seventeen problems that gp e fails to solve were conservatively assessed at the time
limit of      seconds 
we defer further analysis of these results to section   in order to first describe the pegg algorithm
and the advantages it extracts from its search trace 
    the algorithm for the pegg planners
the high level algorithm for so pegg and pegg is given in figure    as for graphplan  search begins once the planning graph it has been extended to the level where all problem goals first appear
with no binary mutex conditions   the routine  find  st level with goals is virtually the same as
graphplans and is not defined here   the first search episode is then conducted in graphplan fashion 
except that the assign goals and assign next level goals routines of figure   initialize the pe as they
create search segments that hold all states generated during the regression search process  the assign goals pseudo code outlines the process of compiling conflict sets  see appendix b  as a means
of implementing ddb and ebl during the action assignment search  the assign next level goals
routine illustrates the role of the top level conflict set for recording a minimal no good when search on
a state is completed  ebl  and depicts how variable ordering need be done only once for a state
 when the search segment is created   a child segment is created and linked to its parent  extending
the pe  in assign next level goals whenever all parent goals are successfully assigned  the assign next level goals routine determines the subgoals for the child search segment by regressing the
parents goals over the actions assigned and then checks to see if either the initial state has been
reached or there are no remaining goals  if so  success is signaled by returning the child search segment which can then be used to extract the ordered actions in the plan 
subsequent to the first episode  pegg plan enters an outer loop that employs the pe to conduct
successive search episodes  for each episode  the newly generated search segments from the previous
episode are evaluated according to a state space heuristic  ranked  and merged into the already ordered
pe  in an inner loop each search segment is visited in turn by passing its subgoals to the graphplanlike assign goals routine 
it is the exit conditions on the inner loop that primarily differentiate so pegg and pegg 
whereas so pegg will visit every search segment whose goals are not found to match a memo 
pegg restricts visitation to a best subset  based on a user specified criterion  as such  expansion of
the planning graph can be deferred until a segment is chosen for visitation that transposes to a planning graph level exceeding the current graph length  as a consequence  in some problems the pegg
 

we have in fact found advantages with respect to traversal order even in intermediate search episodes for some problems  however  this is highly problem dependent  and we do not consider it in this study 

   

fizimmerman   kambhampati

pegg plan  ops  init  goals      ops  init  goals  constitutes a planning problem   
   build plangraph  pg  until level n where goals first occur in non mutex state  

let pg  find  st level with goals  ops  init  goals  
if pg reached level off and goals are not present in non mutex state then return fail
let n be the number of levels in pg
reorder goals according to variable ordering method
let ss  be a new search segment with fields 
goalsgoals  parent root  pe level    parent actions   
let pe be the pilot explanation structure with fields  ranked segs   ss    new segs   

   conduct graphplan style backward search on the n length planning graph  storing trace in pe    

let search reslt  assign goals goals      n  ss   pg  pe 
if search reslt is a search segment    success   
then let plan  extract plan actions from the ancestors linked to search reslt
return plan
else    no n length solution possible    use the pe to search for a longer length solution   
loop forever
n  n  
   rank newly generated states and merge into existing ordered pe segments list   
pe ranked segs   merge sort pe ranked segs  u heuristic sort  pe new segs     

loop while there are unvisited search segments in pe ranked segs   optionally  for all segments
below the heuristic threshold 
let ss be the highest ranked  unvisited segment from pes ranked segs
let k   n   pe level of ss 
      the planning graph level for ss based on transposed pe   
if k   n then pg  extend plangraph pg       delays extending graph until unavoidable    
optionally  if flux metric for ss goals   user specified threshold then continue loop 
if ss goals  memos for level k of pg then remove ss from pes ranked segs
else    visit search segment ss      
search reslt  assign goals  ss goals       k  ss  pg  pe 
if search reslt is a search segment    success     
then let plan  extract plan actions from the ancestors linked to search reslt
return plan
else search reslt is a conflict set  
add conflict set to level k memos of pg    memoize the minimal nogood   
reorder ss goals so that goals conflict set appear first    ebl based reordering   
end while
end loop
end

figure    top level algorithm for pegg and so pegg planners 
planners may be able to extract a step optimal solution while building one less level than other graphplan based planners  

 

interestingly  pegg under beam search could conceivably extract an optimal solution from a planning graph that is an arbitrary number of levels shorter than that required by graphplan  consider the case where the pe  on average  extends at least
one level deeper in each episode and the subset of pe search segments visited always resides on the deepest levels of the pe 
here an arbitrary number of search episodes might be completed without extending the planning graph  based on experiments with problems to date however  this advantage seldom saves more than one planning graph level extension 

   

fiusing memory to transform search on the planning graph

conduct ddb   ebl enhanced graphplan style search while building search trace
arguments  g  goals still to be assigned  a  action set already assigned  k  pg level 
ss   search segment  pg  planning graph  pe  pilot explanation  search trace 
assign goals  g  a  k  ss   pg  pe 
let g be a goal selected from g
let ag be the actions from pg level k that support g  ordered by value ordering heuristic
let cs   g     initialize a conflict set for ddb   
loop for act  ag
let search reslt     
if act is mutex with an action in a
then let b be the goal that the conflicted action in a was assigned to support
cs  cs u  b     augment the conflict set and continue to loop  
else    act has no conflict with actions already in a   
if g  g  is not empty
then    continue goal assignment at this level   
search reslt  assign goals  g  g   a u act   k  ss   pg  pe 
else    there are no ss  goals left to satisfy   setup for search at the next lower level   
search reslt  assign next level goals  a u act   k  ss   pg  pe 
if search reslt is a conflict set  check if it contains current goal  
if g  search reslt
then    absorb returned conflict set   try next action   
cs  cs u search reslt
else return search reslt   just return this conflict set   
else search reslt is a search segment     success     
return search reslt
end loop  actions 
return cs    no soln reached    compiled conflict set is returned  
end if
end
set up search on graph level k   given that ss  goals have been satisfied by actions in a at level k
assign next level goals  a  k  ss   pg  pe 
let nextgoals regress ss  goals over a  the actions assigned to satisfy goals 
if nextgoals is empty or k      its the initial state 
then return ss     success   
else if there is an m  memos at level k   of pg such that m  nextgoals
then return m as the conflict set    backtrack due to nogood   
else     initiate search on the next lower pg level  
let ss  be a new search segment holding nextgoals  a pointer to ss     actions a assigned in ss 
add ss  to pe new segs list
let search reslt  assign goals  nextgoals      k    ss   pg  pe 
if search reslt is a search segment    success     
then return search reslt
else search reslt is a conflict set    memoize minimal nogood and return conflict set   
add conflict set to level k   memos of pg
reorder ss  goals such that goals  conflict set appear first       ebl based reordering   
return search reslt
end if
end

figure    pegg   so pegg regression search algorithm for graphplan style regression search
on subgoals while concurrently building the search trace  pe 
   

fizimmerman   kambhampati

note that peggs algorithm combines both state space and csp based aspects in its search 
 it chooses for expansion the most promising state based on the previous search iteration and
state space heuristics  pegg and so pegg are free to traverse the states in its search trace in
any order 
 a selected state is expanded in graphplans csp style  depth first fashion  making full use of
all csp speedup techniques outlined above 
the first aspect most clearly distinguishes pegg from egbg  traversal of the state space in the pe is
no longer constrained to be bottom up and level by level  as it was for egbg  management of
memory associated with the search trace is a challenge for pegg once we stray from bottom up traversal  but it is less daunting  it will be easier to outline how we address this if we first discuss the
development and adaptation of heuristics to search trace traversal 
    informed traversal of the search trace space
the hsp and hsp r state space planners  bonet   geffner        introduced the idea of using the
reachability of propositions and sets of propositions  states  to assess the difficulty degree of a relaxed version of a problem  this concept underlies their powerful distance based heuristics for selecting the most promising state to visit  subsequent work demonstrated how the planning graph can
function as a rich source of such heuristics  nguyen   kambhampati         since the planning
graph is already available to pegg  we adapt and extend heuristics from the latter work to serve in a
secondary heuristic role to direct peggs traversal of its search trace states  again  the primary heuristic is the planning graph length that is iteratively deepened  section       so the step optimality
guarantee for the so pegg planner does not depend on the admissibility of this secondary heuristic 
there are important differences between heuristic ranking of states generated by a state space planner and ordering of the search segments  states  in peggs search trace  for example  a state space
planner chooses to visit a given state only once while the pegg planners often must consider whether
to revisit a state in many consecutive search episodes  ideally  a heuristic to rank states in the search
trace should reflect level by level evolutions of the planning graph  since the transposition process
associates a search segment with a higher level in each successive episode  for each higher planning
graph level that a given state is associated with  the effective regression search space below it
changes as a complex function of the number of new actions that appear in the graph  the number of
dynamic mutexes that relax  and the no goods in the memo caches  moreover  unlike a state space
planners queue of previously unvisited states  the states in a search trace include all children of each
state generated when it was last visited  ideally the value of visiting a state should be assessed independently of the value associated with any of its children  since they will be assessed in turn  referring back to the search trace depicted in figure    we desire a heuristic that can  for example  discriminate between the    ranked search segment and its ancestor  top goal segment  wxyz   here we
would like the heuristic assessment of segment wxyz to discount the value associated with its children already present in the trace  so that it is ranked based only on its potential for generating new local search branches 
we next discuss adaptation of known planning graph based heuristics for the most effective use
with the search trace 

   

fiusing memory to transform search on the planning graph

      adoption of distance based state space heuristics
the heuristic value for a state  s  generated in backward search from the problem goals can be expressed as 
    

f   s     g   s     w    h  s  
where  g s  is the distance from s to the problem goals  e g  in terms of steps 
h s  is a distance estimate from s to the initial state  e g  in steps 
w  is an optional weighting factor

the value of g for any state generated during the search  e g  the states in the pe  is easily assessed as
the cumulative cost of the assigned actions up to that point  the h values we consider here are taken
from the distance heuristics adapted to exploit the planning graph by  nguyen   kambhampati 
       one heuristic that is readily extractable from the planning graph is based on the notion of the
level of a set of propositions 
set level heuristic  given a set s of propositions  denote lev s  as the index of the first level in the
leveled serial planning graph in which all propositions in s appear and are non mutex with one another   if s is a singleton  then lev s  is just the index of the first level where the singleton element
occurs   if no such level exists  then lev s     
this admissible heuristic embodies a lower bound on the number of actions needed to achieve s from
the initial state and also captures some of the negative interactions between actions  due to the planning graph binary mutexes   in the nguyen   kambhampati       study  the set level heuristic was
found to be moderately effective for the backward state space  bss  planner altalt  but tended to result in too many states having the same f value  in directing search on peggs search trace it is
somewhat more effective  but still suffers from a lower level of discrimination than some of the other
heuristics they examined  especially for problems that engender a planning graph with relatively few
levels  nonetheless  as noted in the appendix b discussion of memory efficiency improvements we
use it during planning graph construction as the default heuristic for value ordering  due to both its low
computational cost and its synergy with building and using a bi partite planning graph 
the inadmissible heuristics investigated in the nguyen   kambhampati       work are based on
computing the heuristic cost h p  of a single proposition iteratively to fixed point as follows  each
proposition p is assigned cost   if it is in the initial state and  otherwise  for each action  a  that adds
p  h p  is updated as 
     h p     min  h p     h prec a   
where h prec a   is the sum of the h values for the preconditions of action a 
given this estimate for a propositions h value  a variety of heuristic estimates for a state have been
studied  including summing the h values for each subgoal and taking the maximum of the subgoal hvalues  for this study we will focus on a heuristic termed the adjusted sum  nguyen   kambhampati         that combines the set level heuristic measure with the sum of the h values for a states
goals  though not the most powerful heuristic tested by them  it is computationally cheap for a planning graph based planner and was found to be quite effective for the bss planners they tested 
adjusted sum heuristic  define lev p  as the first level at which p appears in the plan graph and
lev s  as the first level in the plan graph in which all propositions in state s appear and are nonmutexed with one another  the adjusted sum heuristic may be stated as 
   

fizimmerman   kambhampati

    

hadjsum   s     

 h  p       lev s    max lev  p    
i

pi s

pi s

i

this is a   part heuristic  a summation  which is an estimate of the cost of achieving s under the assumption that its goals are independent  and an estimate of the cost incurred by negative interactions
amongst the actions that must be assigned to achieve the goals  the latter factor is estimated by taking
the difference between the planning graph level at which the propositions in s first become non mutex
with each other and the level in which these propositions first appear together in the graph 
more complex heuristics have been proposed that include a measure of the positive interactions between subgoals in a state  that is  the extent to which an action establishes more than one relevant subgoal  the so called relaxed plan distance based heuristics focus on the positive interactions  and
several studies have demonstrated their power for backward and forward state space planners
 nguyen   kambhampati        hoffman         however  as reported in the former study  the primary advantage of adding positive interactions to the adjusted sum heuristic is to produce shorter
make span plans at the expense of a modest increase in planning time  since peggs ida  search
already ensures optimal make span there is little incentive to incur the expense of the relaxed plan
calculation  and we restricted our work here to the simpler adjusted sum heuristic of eqn     
the adjusted sum heuristic can be further adapted to search on the planning graph by leveraging the
information in peggs search trace  this takes the form of heuristic updating to dynamically improve the h value estimate of states in the pe  the lev s  term in the adjusted sum heuristic represents
the first planning graph level at which the subgoals in state s appear and are binary non mutex with
each other  however  once regression search on s at graph level k fails in a given episode  the search
process has essentially discovered an n ary mutex condition between some subset of the goals in s at
level k  this subset is the conflict set  c  that gets memoized in the pegg algorithm of figures   and
    at this point the lev s  value can be updated to k    indicating that k   is a conservative estimate
of the first level that the s goals appear in n ary non mutex state  this has a desirable property for
ranking search trace states  the longer a state resides in the search trace  the more often its h value gets
increased  and the less appealing it becomes as a candidate to visit again  that is  this heuristic update
biases against states that have been visited the most and failed to extend to a solution  we use this
augmented adjusted sum heuristic for the pegg runs in this work and refer to it as adjusted sum u 
experimentally  we find that the advantage of any given heuristic for ordering pe states is highly
domain dependent  but less sensitive to a particular domain problem   for example  compared to a
simple bottom up visitation strategy  the adjusted sum u heuristic improves so pegg runtimes by up
to an order of magnitude in some domains  e g  freecell and  satellite  while degrading it by up to a
factor of  x to  x in others  e g  zenotravel   figure   depicts the performance of the adjusted sum u
heuristic relative to a bottom up heuristic in so pegg on several sets of problems  here the heuristics are compared in terms of so peggs average computation time as a percentage of gp es in the
final search episode  the most important measure for exhaustive search on the planning graph  the
more informed heuristic will not only find a seed segment sooner but  in the event there are many
 typical of logistics domains   it will find one that lies on a planning graph level that is closer to the
initial state  a less informed heuristic may cause pegg to end up conducting more search in its final
episode than gp e  as there may be many states in the pe that would not be regenerated by graphplan
in its final regression search before it finds a solution  this is a direct measure of the power of the

   

fiusing memory to transform search on the planning graph

bottom up

adjusted sum u

depot
schedule

problem set

zenotravel
freecell
driverlog
satellite
logistics
blocks
tsp
    

     

     

     

                          

  of graphplan s search cost in final episode

figure    heuristic accuracy in so pegg for the final search episode   relative to gp e
search segment selection heuristic  since performance can vary considerably with the specific problem the results in the figure are averages for three representative examples in each domain   
    memory management under arbitrary search trace traversal order

we return now to the memory management problems induced by the strategy of skipping about the
search space  consider again the pe at the time of the final search episode in figure    if search segments are visited in an order other than deepest pe level first  we encounter the problem of regenerating states that are already contained in the pe  the visitation order depicted by numbered segments in
the figure could result from a fairly informed heuristic  the  th segment it chooses to visit is a plan
segment   but it implies that many states already resident in the pe will be regenerated  this includes 
for example  all the as yet unvisited descendents of the third segment visited  unchecked  this process
can significantly inflate search trace memory demands as well as the overhead associated with regenerating search segments  in addition  heuristic information about a state is lost when the state is regenerated instead of revisited as an extant pe search segment  this is because due to the adjustedsum u secondary heuristic pegg learns an improved n ary mutex level for a search segments goals
and updates its f value accordingly in each search episode 
we address this issue by hashing every search segment generated into an associated pe state hash
table according to its canonically ordered goal set  one such hash table is built for each pe level 
prior to initiating regression search on a subgoal set of a search segment  sn   pegg first checks the
planning graph memo caches and  if no relevant memo is found  it then checks the pe state hash table
to see if sns goals are already embodied in an existing pe search segment at the relevant pe level  if
  

problem sets used  blocksworld  bw large b  blocks      and      logistics  att log a  logistics             gripper 
gripper   gripper x    x    depot  depotprob                   driverlog  dlog     a        a       e  zenotravel 
ztravel    a      b     b  freecell  freecell                  satellite  strips sat x    x    x   

   

fizimmerman   kambhampati

such a search segment  se   is returned by this pe state check  se is made a child of sn  if it is not already  by establishing a link  and search can then proceed on the se goals   
another search trace memory management issue is associated with the fact that pegg only visits a
subset of the pe states  a set we will call the active pe  it is tempting to pursue a minimal memory
footprint strategy by retaining in memory only the active search segments in the pe  however unlike
graphplan  when the initial state is reached pegg cannot extract a solution by unwinding the complete sequence of action assignment calls since it may have begun this regression search from an arbitrary state in any branch of the search trace tree  pegg depends instead on the link between a child
search segment and its parent to extract the plan actions once a solution is found  as such we must
retain as a minimum  the active search segments and all of their ancestor segments up to the root node 
beyond the requirement to retain search segments tied to the active pe  there are many strategies
that might be used in managing the inactive portion  for this study we have not attempted to reduce
pe memory requirements in this manner  instead focusing on what might be termed the search space
field of view  under beam search  heuristic effectiveness depends not only on how informed it is 
but the search trace states available for it to rank  the reduced memory footprint of peggs skeletal
search trace allows us to adopt a strategy of retaining in memory all search segments generated  all
such segments have their f values updated before they are ranked  giving the beam search a wide selection of states contending for active status in a given search episode 
    learning to order a states subgoals

the pegg planners employ both ebl and a search trace  and this allows them to overlay a yet more
sophisticated version of variable ordering on top of the distance based ordering heuristic  the guiding
principle of variable ordering in search is to fail early  when failure is inevitable  in terms of graphplan style search on a regressed state  this translates as since all state goals must be assigned an action  its best to attempt to satisfy the most difficult goals first  the adjusted sum heuristic described
above  applied to a single goal  provides an estimate of this difficulty based on the structure of the
planning graph  however  ebl provides additional information on the difficulty of goal achievement
based directly on search experience  to wit  the conflict set that is returned by the peggs assign goals routine during search on a goal set explicitly identifies which of these goals were responsible for the search failure  the intuition behind the ebl based reordering technique then  is that these
same goals are likely to be the most difficult to assign when the search segment is revisited in the next
search episode  this constitutes a dynamic form of variable ordering in that  unlike the distance based
ordering  a search segments goals may be reordered over successive search episodes based on the
most recent search experience 
figure    compares the influence of adjusted sum variable ordering and ebl based reordering
methods on memory demand  in a manner similar to figure    here the impact of ebl based reordering on egbgs performance is reported because pegg tightly integrates the various csp and efficiency methods  and their independent influence cannot be readily assessed    we isolate the impact
of ebl based reordering from that of ebl itself by activating the ebl but using the produced con  
  

in the interests of simplicity  the figure   algorithm does not outline this memory management process 
given the success of the various memory efficiency methods within egbg  all versions of pegg implement them by
default  a graph analogous to figure   for the pegg planner would differ in terms of the actual memory reduction values  but we are confident that the overall benefits of the methods would persist  as would the relative benefit relationship
between methods 

   

fi  
  

variable ordering  adjsum    eblreordering
variable ordering
ebl  reordering
  

  reduction in pe  search trace  memory requirement

using memory to transform search on the planning graph

  
  
  
  reduction in planning graph  memo cache memory requirements

figure     memory demand impact along two dimensions for adjusted sum
variable ordering and ebl based reordering techniques when applied
independently and together 
flict sets only in reordering  not during memoization  the average reduction in search trace memory
over the    problem sample is seen to be about     for ebl based reordering alone  this compares
favorably with the     average reduction of the distance based ordering  especially since  unlike the
adjusted sum ordering  the ebl based reordering only takes effect in the  nd search episode  the plot
also reveals that the two modes of ordering are quite complimentary 
across a variety of problems and domains we found the following approach to be most effective in
combining distance based variable ordering and ebl based reordering     a newly created search
segments goals are ordered according to the distance based heuristic     after each visit of the search
segment  the subset of its goals that appear in the conflict set are reordered to appear first     the goals
in the conflict set are then ordered by the distance based heuristic and appended to non conflict goals 
which are also set in distance based order 
as indicated in figure     this hybrid form of variable ordering not only boosts the average memory reduction to almost      but also significantly reduces the wide fluctuation in performance of
either method in isolation  we re emphasize here that this search experience informed goal ordering
is only available to a search algorithm that maintains a memory of states it has visited  it is therefore
not portable to any graphplan based planner we know of 
    trading off guaranteed step optimality for speed and reach 
pegg under beam search

many of the more difficult benchmark problems for graphplans ida  style search have    or more
such search episodes before the reaching the episode in which a solution can be extracted  the cumulative search time tied to these episodes can be a large portion of the total search time and  as indicated
in table    so pegg exhausts search time limits well before reaching the episode in which a solution
can be extracted  the strategy of exhaustively searching the planning graph  in each episode up to the
solution bearing level  gives the step optimal guarantee to graphplans solutions but it can exact a
   

fizimmerman   kambhampati

high cost to ensure what is  after all  only one aspect of plan quality  we explore with pegg  a nonexhaustive search version of so pegg  the extent to which search episodes can be truncated while
producing plans with virtually the same makespan as graphplans solution 
pegg shortcuts the time spent in search during these intermediate episodes by using the secondary
heuristic to not only direct the order in which pe states are visited but to prune the search space visited
in the episode  this beam search seeks to visit only the most promising pe states  as measured by
their f values against a user specified limit  in addition  the beam search has an important dual benefit
for pegg in that it further reduces the memory demands of its search trace and  depending on the
problem  even the planning graph  in the pegg algorithm of figure    the loop while statement is
the point at which a beam search f value threshold can be optionally applied to pe states that are candidates for visitation  when the first segment exceeding this threshold is reached on the sorted queue
the search episode ends 
to devise an effective threshold test must reconcile competing goals  minimizing search in nonsolution bearing episodes while maximizing the likelihood that the pe retains and visits  preferably as
early as possible   a search segment thats extendable to a solution once the graph reaches the first
level with an extant solution  the narrower the window of states to be visited  the more difficult it is
for the heuristic that ranks states to ensure it includes a plan segment  i e  one that is part of a stepoptimal plan  pegg will return a step optimal plan as long as its search strategy leads it to visit any
plan segment  including the top  root segment in the pe  belonging to any plan latent in the pe  during search on the first solution bearing planning graph  the heuristics job in selecting the window of
search segments to visit is made less daunting for many problems because there are many step optimal
plans latent at the solution bearing level 
we next describe an effective planning graph based metric that augments the state space heuristic
in choosing the set of pe states to visit in each search episode 
      mining the planning graph to filter the beam
beyond the heuristic updating we introduced in section    the distance based heuristics are virtually
insensitive to planning graph evolution as a search segment is transposed up successive levels  since
the search trace contains all children states that were generated in regression search on a state s in episode n  a heuristic preference to include s over other states in the trace to visit in episode n   should
reflect the chance that it will directly generate new and promising search branches  the child states of
s from search episode n are competitors with s  so ideally a heuristics rank for s should reflect in
some sense the value of visiting the state beyond the importance of its children 
consider now the sensitivity of the adjusted sum heuristic  or any of the distance based heuristics 
to possible differences in the implicit regression search space below a set of propositions  s  at planning graph level k versus level k    given that the propositions are present and binary non mutex
with each other at level k  only the cost summation factor in equation     could conceivably change
when s is evaluated at level k    this would require two conditions  a new action must establish one
of the s propositions for the first time at level k   and the actions precondition costs must sum to less
than the precondition costs of any other establisher of the proposition  in practice this happens infrequently since the later that an action appears in the graph construction process  the higher its cost tends
to be  consequently h values for states based on distance based heuristics remain remarkably constant for planning graph levels beyond that at which the propositions appear and are binary non   

fiusing memory to transform search on the planning graph

mutex    we desire a means of compensating for a static h value when a state is transposed to a planning graph level at which promising new branches of regression search open up 
the likelihood that a state visited in episode n at graph level k will give rise to new child states if
visited in episode n   at level k   is rooted in the graph dynamics summarized by observations a  
and a   of appendix a  three planning graph and memo cache properties determine whether regression search on a subgoal set s will evolve over successive episodes 
   there are new actions at level k   that establish a subgoal of s
   there are dynamic mutexes at level k between actions establishing subgoals of s that relax
at level k  
   there were no good memos encountered in regression search on state s during episode n
that will not be encountered at level k    and also the converse  
this set of measures of the potential for new search branches to result from visiting a state in the pe
we refer to as the flux  the intuition being that the higher the flux  the more likely that search on a
given state will differ from that seen in the previous search episode  and captured in the pe   if none
of the three factors applies to a state under consideration  there is no point in visiting it  as no new
search can result relative to the previous episode 
the first factor above can be readily assessed for a state  thanks in part to the bi partite graph structure   the second flux factor is unfortunately expensive to assess  a direct measure requires storing all
pairs of attempted action assignments for the goals of s that were inconsistent in episode n and retesting them at the new planning graph level  however  the graph mechanics are such that relaxation of a
dynamic mutex between two actions at level k requires the relaxation of a dynamic mutex condition
between some pair of their preconditions at level k    one precondition for each action   this relaxation  in turn  is either due to one or more new establishing actions for the preconditions at level k   or
recursively  relaxations in existing actions establishing the preconditions  as such  the number of new
actions establishing the subgoals of a state s in the pe  factor   above  provide not only a measure of
the flux for s  but also a predictor of the flux due to factor   for the parent  and higher ancestors  of s 
thus  it turns out that by simply tracking the number of new actions for each state subgoal at its current level and propagating an appropriately weighted measure up to its parent  we can compile a useful
estimate of flux for factors   and   above 
the third flux factor above is the most unwieldy and costly to estimate  an exact measure requires
storing all child states of s generated in regression search at level k that caused backtracking due to
cached memos  and retesting them to see if the same memos are present at level k      ignoring this
factor  we sum just the two flux measures that depend on new actions to derive a filtering metric
which is then used to assist the largely static adjusted sum distance based heuristic in culling the
beam  the resulting  inexact  metric is sensitive to the evolution in search potential as a state is transposed to higher planning graph levels 

  

this  in part  explains the observation  nguyen   kambhampati        that the altalt state space planner performance
generally degrades very little if the planning graph used to extract heuristic values is built only to the level where the problem goals appear and are non mutex  rather than extending to level off 
  
note that as long as we are using ebl ddb  it is not sufficient to just test whether some memo exists for each child state 
this is because no good goals themselves contribute to the conflict set used to direct search within s whenever such backtracking occurs 

   

fizimmerman   kambhampati

    

flux  s    

 newacts  p  
i

pi  s

 s 

  wcf 

 childflux s  

si  s c

i

where  pi is a proposition in state s
newacts pi  is the number of new actions that establish proposition pi of s at its
associated planning graph level
  s   is a normalization factor  the number of propositions in s
sc is the set of all child states of s currently represented in the search trace
childflux si  is the sum of the two flux terms in eqn     applied to child state si of s
wcf weights the contribution of flux from child states to the parent state

here the number of new actions establishing the subgoals of a state is normalized relative to the number of subgoals in the state 
we report elsewhere  zimmerman        on the use of this flux to directly augment the secondary
heuristic  depending on the domain and the weighting of flux contribution to the adjusted sum heuristic  speedups of up to an order of magnitude are observed    however its impact is highly domain
dependent and since we are primarily concerned with the performance of a general purpose planner  in
this study we only consider its use as a beam filter 
under beam search  the flux measure can strongly impact every search episode  as it influences the
states actually included in the active pe  when used in this mode  search segments with an assessed
flux below a specified threshold are skipped over even if their f value places them in the active pe 
flux proves to be broadly effective across most domains when used in this mode  as mentioned in
section      we use a flux cutoff in each search episode of     of the average flux for all search segments in the pe  any segment below this value is not visited regardless of its heuristic rank  at this
setting the impact on speedup for the pegg column problems of table   ranges from nil to a factor of
 x over peggs performance without the flux filter  higher settings can dramatically speed up the
solution search  but often at the expense of greater solution makespan 
      peggs ability to find step optimal plans
the variety of parameters associated with the beam search approach described above admits considerable flexibility in biasing pegg towards producing plans of different quality  shorter makespan plans
are favored by more extensive search of the pe states in each episode while heuristically truncated
search tends to generate non optimal plans more quickly  often containing redundant or unnecessary
actions  the settings used in this study clearly bias pegg solutions towards step optimality  the
step optimal plan produced by enhanced graphplan is matched by pegg for all but four of the   
problems reported in table    as indicated by the annotated steps and actions numbers given in parenthesis next to successful gp e and pegg runs     pegg solutions with a longer makespan than the
step optimal have boldface step action values   in these four problems  pegg returns solutions
  

for example  compared to a simple bottom up visitation strategy  the flux augmented adjusted sum heuristic improves
so pegg runtimes by up to   x in some domains  e g  freecell and  satellite  while degrading it by as much as  x to  x in
others  e g  zenotravel  

  

where more than one of the guaranteed step optimal planners  gp e  me egbg and so pegg  finds a solution the steps
and actions are reported only for one of them  since they all will have the same makespan 

   

fiusing memory to transform search on the planning graph

problem

n best first
pegg
 n      state space search    adjusted sum u heuristic with beam search on
the     best search segments 

satplan
 optimal 

bw large a

 

 

    s 

 

bw large b

  

       s 

 

bw large c

  

         s 

  

bw large d

  

        s 

  

table    quality comparison  in terms of plan steps  for pegg and n best beam search
on a forward state space planner  bonet et al         
within four steps of optimum  in spite of its highly pruned search  this proved to be a fairly robust
property of peggs beam search under these settings across all problems tested to date 
pegg under the adjusted sum u secondary heuristic often finds plans with fewer actions than
gp e in parallel domains  and this graphplan hybrid system is also impressive in serial domains such
as blocksworld  which are not exactly graphplans forte  
the tactic of trading off optimal plan length in favor of reduced search effort is well known in the
planning community  by comparison  peggs beam search approach is biased towards producing a
very high quality plan at possibly some expense in runtime  for example  in their paper focusing on
an action selection mechanism for planning  bonet et  al  briefly describe some work with an n best
first algorithm  bonet  loerincs    geffner         here they employ their distance based heuristic
to conduct beam search in forward state space planning  they report a small set of results for the case
where the     best states are retained in the queue to be considered during search 
table   reproduces those results alongside peggs performance on the same problems using beam
search  here  to approximate the n best algorithm  pegg is also run with     states visited in each
intermediate search episode  the      study compared the n best first approach against satplan 
which produces the optimal length plan  to make the point that the approach could produce plans reasonably close to optimal with much less search  the n best first code is not available to run on our
test platform  so only peggs runtime is reported  focusing on plan makespan  its clear that even in
this serial domain  the parallel planner pegg produces a much shorter plan than the n best first
state space approach  and in fact finds the optimum length plan generated by satplan in all cases 
more recently lpg  gerevini   serina         another planner whose search is tightly integrated
with the planning graph  was awarded top honors at the aips      planning competition  due to its
ability to quickly produce high quality plans across a variety of domains currently of interest  in the
figure    scatter plot  solution quality in terms of steps for lpg and pegg are compared against the
optimal for    problems from three domains of the      aips planning competition  we chose these
particular problems because the optimal solution is known  and we are interested in comparing to a
quality baseline  lpgs results are particularly apt in this case  because that planner also nonexhaustively searches the planning graph at each level before extending it  although its search process
differs markedly from peggs  lpg  too  can be biased to produce plans of higher quality  generally
at the expense of speed  and here we report the competition results for its quality mode  in terms of
number of actions in the solutions neither planner consistently dominates for these problems but
pegg clearly excels in step optimality  its maximum deviation from optimum is four steps and most
   

fizimmerman   kambhampati

  

lpg  dlog

  

lpg  depot

steps over optimal

  

lpg  ztravel

  

pegg  dlog

  

pegg  depot

 

pegg  ztravel

 
 
 
 
 

 

 

 

 

  

problem number

  

  

  

  

figure     makespan comparison of pegg and lpg  departure from step optimal
plan length   lpg data taken from the aips      competition results  
of the plot points for its solutions lie right on the optimal makespan axis  it is possible that there are
sets of actions within lpgs solutions that could be conducted in parallel but the algorithms quality
mode heuristic is insensitive to them  
it should be noted that lpg produced solutions for some difficult problems in these domains that
pegg currently does not solve within a reasonable time limit  we are investigating the characteristics
of these problems that make them so difficult for pegg 
      pegg compared to heuristic state space search
we have not attempted here to run pegg head to head for speed against recent ipc planners  in part
due to platform difficulties  pegg is written in lisp while the competition planners are generally
coded in c and published results are based on the execution on the competition machines  and partly
due to our focus on near optimal makespan for parallel plans rather than speed  given peggs close
coupling with the planning graph  the most relevant comparisons are with other parallel planners that
also employ the graph in some form  for such comparisons  we would like to isolate the search component of the runtime from planning graph construction  since there are a variety of routines that produce essentially the same graph with widely different expenditures of computational time and memory  the reported runtimes for the lpg planner in the aips    competition are generally much
smaller than peggs  but its difficult to isolate the impact of graph construction and platform related
effects  not to mention the disparity in the makespan of the plans produced 
table   compares pegg against a lisp version of a fast distance based heuristic state space planner using most of the same problems as table    altalt  srivastava et al          like pegg  depends
on the planning graph to derive the powerful heuristics it uses to direct its regression search on the
problem goals  this facilitates planner performance comparison based on differences in search without confusing graph construction time issues  the last column of table   reports altalt performance
 runtime and makespan  for two of the most effective heuristics developed for that planner  nguyen  
kambhampati         the first of which is the adjusted sum heuristic as described in section       

   

fiusing memory to transform search on the planning graph

problem
bw large b
bw large c
bw large d
rocket ext a
att log a
att log b
gripper  
gripper   
gripper   
tower  
tower  
 puzzle  
 puzzle  
tsp   
aips     
grid y  
gripper x  
gripper x  
log y  
mprime  
aips     
blocks     
blocks     
blocks     
logistics     
logistics     
freecell    
schedule    
aips     
depot     
depot     
driverlog      e
driverlog      
roverprob    
roverprob    
roverprob    
sat x  
sat x  
ztravel    a
ztravel    a

pegg
heuristic  adjusted sum u
cpu sec  steps acts 
   
    
   
   
   
    
   
    
      
   
    
   
   
   

       
       
       
      
       
       
       
       
       
         
         
       
       
       
pegg
            
   
       
   
       
            
         
pegg
           
           
            
            
            
           
   
      
pegg
           
            
            
   
       
  
      
   
         
   
         
           
          
   
       
           

alt alt  lisp version 
cpu sec     acts 
heuristics 
combo
adjusum 
                        
                      
          
 
                       
                       
                     
          
 
           
          
                      
          
 
           
 
                       
           
          
                     
alt alt
          
          
         
         
        
          
        
          
           
          
alt alt
          
         
          
          
          
        
        
         
alt alt
         
         
          
         
          
          
           
         
          
        
          

table    pegg and a state space planner using variations of the adjusted sum heuristic
pegg  bounded pe search  best     of search segments visited in each search episode  as ordered by
adjusted sum u state space heuristic
altalt  lisp version  state space planner with two of the most effective planning graph distance based
heuristics  adjusum  and combo  combo results are not reported for all problems since
adjusum  produces plans that are more competitive with pegg in terms of makespan  

   

fizimmerman   kambhampati

surprisingly  in the majority of problems pegg returns a parallel  generally step optimal plan faster
than altalt returns its serial plan   altalt cannot construct a plan with parallel actions  however recent
work with a highly modified version of altalt does  in fact  construct such plans  nigenda   kambhampati         the pegg plans are also seen to be of comparable length  in terms of number of actions  to the best of the altalt plans 
   discussion of results

a distinguishing feature of the egbg and pegg planners relative to other planners that exploit the
planning graph  is their aggressive use of available memory to learn online from their episodic search
experience so as to expedite search in subsequent episodes  although they each employ a search trace
structure to log this experience  the egbg and pegg systems differ in both the content and granularity of the search experience they track and the aggressiveness in their use of memory  they also differ
in how they confront a common problem faced by learning systems  the utility of learned information
versus the cost of storing and accessing it when needed 
our first efforts focused primarily on using a search trace to learn mutex related redundancies in
the episodic search process  although the resulting planners  egbg and me egbg  can avoid virtually all redundant mutex checking based on search experience embodied in their pes  empirically we
find that its a limited class of problems for which this is a winning strategy  the utility of tracking
the mutex checking experience during search is a function of the number of times that information is
subsequently used  specifically 
eps   p  

      u mt   p  

 pe

visit

  e 

 pe

add

 e 

e   
eps   p  
e   

where  umt is the utility of tracking mutex checking experience
p is a planning problem
eps p  is the number of search episodes in problem p
pevisit  e  is the number of pe search segments visited in search episode e
peadd  e is the number of new search segments added to pe in episode e
thus the payback for egbgs incurred overhead of tracing consistency checking experience during
search depends on the number of times the sets are revisited relative to the total number of subgoal
sets generated  and added to the pe  during the problem run  this characteristic explains the less than
 x speedups observed for me egbg on many table   problems  the approach is a handicap for single search episode problems  it is also ineffectual for problems where final search episode search generates a large number of states relative to previous episodes and when the only seed segment s  are at
the top levels of the pe  due to need for bottom up visitation of the search segments in egbgs
search trace  
the pe can be thought of as a snapshot of the regression search reachable  rs reachable  states
for a search episode  that is  once the regression search process generates a state at level k of the
planning graph  the state is reachable during search at all higher levels of the graph in future search
episodes  essentially  the search segments in the pe represent not just the rs reachable states  but a
   

fispeedup wrt enhanced graphplan

using memory to transform search on the planning graph

so pegg  log

      

pegg  log
so pegg  ztravel
pegg ztravel

     

    

   
 
   

 

 

 

 

 

 

search episodes in problem

figure     speedup vs  number of search episodes  logistics     and zenotravel     domains
candidate set of partial plans with each segments state being the current tail state of such a plan  table   and   results indicate that the utility of learning the states that are rs reachable in a given search
episode generally outweighs the utility of learning details of the episodes consistency checking  and
require much less memory  freed from the need to regenerate the rs reachable states in ida  fashion during each search episode  pegg can visit such states in any heuristically preferred order 
tables      and   shed light on several classes of problems that are problematic for search trace
guided search on the planning graph 
   domains with high branching factors and operator descriptions that thwart ddb and ebl
 e g  the larger schedule  satellite  and zenotravel domain problems 
   problems with a significant fraction of runtime consumed in planning graph construction 
 e g  grid domain   dlog      e  freecell     
   problems with only one or two search episodes   grid y    schedule     
for problems in the first class  the graphplan style csp assignment search is prone to bogging
down after certain pe states are selected for visitation  for those in the second class any search time
reduction can be dominated by the large graph construction time  a problem shared by any planner
that builds the complete planning graph   problems in the third class do not give pegg sufficient
opportunity to exploit the pe  since it is built in the first episode  and the first episode pe is typically
small  and of no benefit until subsequent episodes  this aspect of peggs behavior is illustrated in
figure     here the speedup factors of both so pegg and pegg  under beam search  are plotted for
a series of problems ordered according to the number of search episodes that graphplan would conduct prior to finding a solution  the data was gathered by running the gp e  so pegg  and pegg
planners on two different domains  the logistics domain from the aips    planning competition  and
the zenotravel domain from the aips    competition  and then averaging the speedups observed for
problems with the same number of observed search episodes  the downturn for the pegg  ztravel
curve at seven episodes is not surprising given that there was only one such problem and there are
many factors beyond the number of search episodes that impact solution time  noting that the speed   

fizimmerman   kambhampati

ups are plotted on a logarithmic scale  the power of a search trace given multiple search episode problems is evident  pegg using beam search handily outperforms so pegg for all problems of three or
more search episodes  largely because it shortcuts exhaustive search in the intermediate episodes 
there are several avenues for addressing the above listed limitations of pegg that we have explored or anticipate investigating  for example  unlike the n best first state space planner reported
in table    pegg enforces the user specified limit on state f values only when selecting pe search
segments to visit  once a search segment is chosen for visitation  graphplan style regression search
on the state goals continues until either a solution is found or all sub branches fail  a more greedy
approach would be to also apply the heuristic bound during this regression search  that is  we could
backtrack whenever a state is generated that exceeds the f value threshold applied to search segments
before they are visited  this translates the greedy best first search  gbfs  algorithm employed by
hsp r  bonet   geffner        for state space search  into a form of hill climbing search on the planning graph 
experimentally we find that when pegg is adapted to enforce the pe state f value limit during its
regression search  improvements are unpredictable at best  speedups of up to a factor of     were
observed in a few cases  all logistics problems  but in many cases runtimes increased or search failed
entirely within the time limit  in addition  the quality  make span  of the returned solutions suffered
across a broad range of problems  there are two factors that may explain this result     peggs regression search is greatly expedited by ddb and ebl  but the regressed conflict set that they rely on
is undefined when the regression search space below a state is not fully explored  such as when an fvalue limit is enforced  without conducting such search there is no informed basis for returning anything other than the full set of subgoals in the state  which essentially forces search towards chronological backtracking     assessing an f value for a newly generated state to compare against an fvalue bound that is based on states generated in previous episodes is problematic  this is because the
heuristic values of pe states that determine the f value bound have been increased by peggs use of
search experience to improve h value estimates  section        
degradation of solution quality as we shift pegg closer to a greedy search approach may be an indicator that peggs ability to return step optimal plans  as evidenced by table   results  is rooted in
its interleaving of best state selection from the pe with graphplan style depth first search on the
states subgoals 
   related work

we focus here on related or alternative strategies for employing search heuristics in planning  generating parallel plans  or making use of memory to expedite search  related work pertaining to some of
the search techniques  efficiencies  and data structures that enable egbg and pegg to successfully
employ a search trace were cited as they arose above and are not further considered here   
as noted in section      a shortcoming of ida  search  and graphplan  is its inadequate use of
available memory  the only information carried over from one iteration to the next is the upper
bound on the f value  exploitation of a search trace directly addresses this shortcoming by serving as
a memory of the states in the visited search space of the previous episode in order to reduce redun  

support methodologies include memory efficient bi partite planning graph models  explanation based learning and dependency directed backtracking in the context of planning graph search  variable and value ordering strategies  and the evolution
and extraction of distance based heuristics from the planning graph 

   

fiusing memory to transform search on the planning graph

dant regeneration  in this respect peggs search is closely related to methods such as mrec  sen 
anup   bagchi         ma   and sma   russell        which lie in the middle ground between the
memory intensive a  and ida s scant use of memory  a central concern for these algorithms is
using a prescribed amount of available memory as efficiently as possible  like egbg and pegg 
they retain as much of their search experience as memory permits to avoid repeating and regenerating
nodes  and depend on a heuristic to order the nodes in memory for visitation  unlike our search trace
based algorithms though  all three of the above algorithms backup a deleted nodes f value to the parent node  this ensures the deleted branch is not re expanded until no other more promising node remains on the open list  we have not implemented this extended memory management in pegg
 though it would be straight forward to do so  primarily because  at least under beam search  pegg
has seldom confronted pe related memory limitations 
egbg and pegg are the first planners to directly interleave the csp and state space views in problem search  but there are related approaches that synthesize different views of the planning problem 
the blackbox system  kautz   selman       constructs the planning graph but instead of exploiting
its csp nature  it is converted into a sat encoding after each extension and a k step solution is
sought  gp csp  do   kambhampati         similarly alternates between extending a planning
graph and converting it  but it transforms the graph into csp format and seeks to satisfy the constraint
set in each search phase 
the beam search concept is employed in the context of propositional satisfiability in gsat  selman  levesque    mitchell        and is an option for the blackbox planner  kautz   selman        
for these systems greedy local search is conducted by assessing in each episode  the n best flips of
variable values in a randomly generated truth assignment  where the best flips are those that lead to
the greatest number of satisfied clauses   if n flips fail to find a solution  gsat restarts with a new
random variable assignment and again tries the n best flips  there are several important differences
relative to peggs visitation of the n best search trace states  the search trace captures the state aspect engendered by graphplans regression search on problem goals and as such  pegg exploits
reachability information implicit in its planning graph  in conducting their search on a purely propositional level  sat solvers can leverage a global view of the problem constraints but cannot exploit
state space information  whereas gsat  and blackbox  do not improve their performance based on
the experience from one n best search episode to the next  pegg learns in a variety of modes  improving its heuristic estimate for the states visited  reordering the state goals based on prior search experience  and memorizing the most general no goods based on its use of ebl 
like pegg  the lpg system  gerevini   serina        heavily exploits the structure of the planning graph  leverages a variety of heuristics to expedite search  and generates parallel plans  however 
lpg conducts greedy local search in a space composed of subgraphs on a given length planning
graph  while pegg combines a state space view of its search experience with graphplans csp style
search on the graph itself  lpg does not systematically search the planning graph before heuristically
moving to extend it  so the guarantee of step optimality is forfeited  pegg can operate either in a
step optimal mode or in modes that trade off optimality for speed to varying degrees 
we are currently investigating an interesting parallel to lpgs ability to simultaneously consider
candidate partial plans of different lengths  in principle  there is nothing that prevents pegg from
simultaneously considering a given pe search segment sn  in terms of its heuristic rankings when its
transposed onto various levels of the planning graph  this is tantamount to simultaneously consider   

fizimmerman   kambhampati

ing which of an arbitrary number of candidate partial plans of different implied lengths to extend first
 each such partial plan having sn as its tail state   the search trace again proves to be very useful in
this regard as any state it contains can be transposed up any desired number of levels  subject to the
ability to extend the planning graph as needed  and have its heuristics re evaluated at each level  referring back to figure    after the first search episode pictured  top   the yj state in the pe could be
expanded into multiple distinct states by transposing it up from graph level   to levels       or higher 
and heuristically evaluating it at each level  these graph level indexed instances of yj can now be
simultaneously compared  ideally wed like to move directly to visiting yj at planning graph level   
since at that point it becomes a plan segment for this problem  bottom graph of figure     if our secondary heuristic can discriminate between the solution potential for a state at the sequential levels it
can be transposed to  we should have an effective means for further shortcutting graphplans level bylevel search process  the flux adjunct is likely to be one key to boosting the sensitivity of a distancebased heuristic in this regard 
generating and assessing an arbitrarily large number of graph level transposed instances of pe
states would be prohibitive in terms of memory requirements if we had to store multiple versions of
the pe  however we can simply store any level specific heuristic information in the search segments
of a single pe as values indexed to their associated planning graph levels  challenging issues include
such things as the range of plan lengths to be considered at one time and the potential for plans with
steps consisting entirely of persists actions 
we havent examined pegg in the context of real time planning here  but its use of the search
trace reflects some of the flavor of the real time search methods  such as lrta   korf        and
variants such as b lrta   bonet  loerincs    geffner          a variant that applies a distance based
heuristic oriented to planning problems  real time search algorithms interleave search and execution 
performing an action after a limited local search  lrta  employs a search heuristic that is based on
finding a less than optimal solution then improving the heuristic estimate over a series of iterations  it
associates an h value with every state to estimate the goal distance of the state  similar to the h values
of a    it always first updates the h value of the current state and then uses the h values of the successors to move to the successor believed to be on a minimum cost path from the current state to the goal 
unlike traditional search methods  it can not only act in real time but also amortize learning over consecutive planning episodes if it solves the same planning task repeatedly  this allows it to find a suboptimal plan fast and then improve the plan until it converges on a minimum cost plan 
like lrta   the pegg search process iteratively improves the h value estimates of the states it
has generated until it determines an optimal make span plan  unlike lrta   pegg doesnt actually
find a sub optimal plan first  instead it converges on a minimum cost plan by either exhaustively extending all candidate partial plans of monotonically increasing length  so pegg  or extending only the
most promising candidates according to its secondary heuristic  pegg with beam search   a realtime version of pegg more closely related to lrta  might be based on the method described above 
in which search segments are simultaneously transposed onto multiple planning graph levels  in this
mode pegg would be biased to search quickly for a plan of any length  and then search in anytime
fashion on progressively shorter length planning graphs for lower cost plans 
this methodology is of direct relevance to work we have reported elsewhere on multi pegg
 zimmerman   kambhampati        zimmerman        a version of pegg that operates in an anytime fashion  seeking to optimize over multiple plan quality criteria  currently multi pegg first re 

   

fiusing memory to transform search on the planning graph

turns the optimal make span plan  and then exploits the search trace in a novel way to efficiently
stream plans that monotonically improve in terms of other quality metrics  as discussed in that paper 
an important step away from multi peggs bias towards the make span plan quality metric would be
just such a modification  co mingling versions of the same state transposed onto multiple planning
graph levels would enable the planner to concurrently consider for visitation candidate search segments that might be seed segments for latent plans of various lengths 
   conclusions

we have investigated and presented a family of methods that make efficient use of available memory
to learn from different aspects of graphplans iterative search episodes in order to expedite search in
subsequent episodes  the motivation  design  and performance of four different planners that build
and exploit a search trace are described  the methods differ significantly in either the information
content of their trace or the manner in which they leverage it  however  in all cases the high level
impact is to transform the ida  nature of graphplans search by capturing some aspect of the search
experience in the first episode and using it to guide search in subsequent episodes  dynamically updating it along the way 
the egbg planners employ a more aggressive mode of tracing search experience than the pegg
planners  they track and use the action assignment consistency checking performed during search on
a subgoal set  state  to minimize the effort expended when the state is next visited  the egbg approach was found to be memory intensive  motivating the incorporation of a variety of techniques
from the planning and csp fields which  apart from their well known speedup benefits  are shown to
have a dramatic impact on search trace and planning graph memory demands  the resulting planner 
me egbg  is frequently two orders of magnitude faster than either standard graphplan or egbg and
for problems it can handle  it is generally the fastest of the guaranteed step optimal approaches we
investigated  in comparisons to gp e  a version of graphplan enhanced with the same space saving
and speedup techniques  me egbg solves problems on average   times faster 
the pegg planners adopt a more skeletal search trace  a design more conducive to informed traversal of the search space  ultimately this proves to be a more powerful approach to exploiting the
episodic search experience  we adapt distance based  state space heuristics to support informed traversal of the states implicit in the search trace and describe a metric we call flux which effectively
focuses search on states worth visiting  this flux measure is sensitive to the potential for a search
trace state to seed new search branches as it is transposed to higher planning graph levels  we also
describe some new techniques that leverage the search experience captured in the search trace and
demonstrate their effectiveness 
the so pegg planner  like me egbg  produces guaranteed optimal parallel plans and similarly
averages a  x speedup over gp e  its greatly reduced memory demands allow so pegg to handles all
but one of the    problems for which me egbg exceeds available memory  more compelling evidence of the speedup potential for a search trace guided planner is provided by pegg under beam
search  since it no longer exhaustively searches the planning graph in each episode  pegg sacrifices
the guarantee of returning an optimal make span plan  nonetheless  even under beam search limited
to just the best     of pe states in each episode  pegg returns the step optimal plan in almost    
of the test bed problems and comes within a few steps of optimal in the others  it does so at speedups

   

fizimmerman   kambhampati

ranging to almost two orders of magnitude above gp e  and quite competitively with a modern state
space planner  which finds only serial plans  
the code for the pegg planners  including gp e  with instructions for running them in various
modes is available for download at http   rakaposhi eas asu edu pegg html
acknowledgements

this research was improved by many discussions with binh minh do  xuanlong nguyen  romeo
sanchez nigenda and william cushing  thanks also to david smith and the anonymous reviewers 
whose copious suggestions greatly improved the presentation of this paper  this research is supported
in part by the nsf grants iri         and iis          darpa aasert grant daah            and the nasa grants nag       and ncc      

appendix a  the egbg planner

the insight behind egbgs use of a search trace is based on the characterization of graphplans
search given at the beginning of section     and some entailed observations 
observation a    the intra level csp style search process conducted by graphplan on a set of propositions  subgoals  s   at planning graph level k   in episode n   is identical to the search process on s at
level k in episode n if 
   all mutexes between pairs of actions that are establishers of propositions of s at level k remain
mutex for level k     this concerns dynamic mutexes  static mutexes persist by definition 
   there are no actions establishing a proposition of s at level k   that were not also present at level k 
observation a    the trace of graphplans search during episode n    on a set of goals g  at planning
graph level m    is identical to its episode n search at level m if 
   the two conditions of observation a   hold for every subgoal set  state  generated by graphplan in
the episode n   regression search on g 
   for every subgoal set s at planning graph level j in search episode n for which there was a matching
level j memo  there exists an equivalent memo at level j   when s is generated in episode n   
conversely  for every subgoal set s at level j in search episode n for which no matching level j memo
existed at the time it was generated  there is also no matching memo at level j   at the time s is generated in episode n   

now  suppose we have a search trace of all states  including no good states  generated by graphplans regression search on the problem goals from planning graph level m in episode n  if that search
failed to extract a solution from the m length planning graph  i e  reach the initial state   then a necessary condition to extract a solution from the m   length graph is that one or more of the conditions of
observations in a   or a   fails to hold for the states in the episode n search trace 
with observations a   and a   in mind  we can exploit the search trace in a new episode in a
sound and complete manner by focusing search effort on the only three situations that could lead to a
solution     under state variables with newly extended value ranges  i e  search segment goals that
have at least one new establishing action at their newly associated graph level      at points in the previous search episode that backtracked due to violation of a dynamic constraint  i e  two actions that
   

fiusing memory to transform search on the planning graph

w

nop a 
ok ok
 

y

 

nop a 
ok sm

nop a 
ok sm

 

nop a 
ok ok

h

 

i

 

 

nop a  a 
ok sm ok
  nop a  

j

dm sm

nop a  nop a 
dm sm dm sm

nop a 
dm sm

figure a   bit vector representation of the search trace for the wyhij state in figure   
semantics  ok   assigned  no action conflicts  sm   action is static mutex with previous assign
dm   action is dynamic mutex with previous assign
ng   a no conflict action results in a no good state at lower graph level

were dynamic mutex   and    at states that matched a cached memo in episode n  all other assignment and mutex checking operations involved in satisfying a set of subgoals are static across search
episodes 
we experimented with several search trace designs for capturing key decision points  the design
adopted for egbg employs an ordered sequence of bit vectors  where each vector contains the results
of graphplans csp style action assignment process related to a given subgoal in a search segment 
efficient action assignment replay is possible with a trace that uses vectors of two bit tags to represent
four possible assignment outcomes     dynamic mutex     static mutex     no conflict  and    a complete  consistent set of assignments that is rejected at the next level due to a memoized no good  figure a  illustrates how a sequence of eight such bit vectors can be used to capture the search experience for the search segment with state goals wyhij from our figure   alpha problem  here the propositional goals  the variables  appear to the left of the sets of bit vectors  depicted as segmented bars 
which encode the outcome of all possible action assignment  the values   each possible establishing
action for a goal appears above a bit vector tag 
the numbered edges reflect the order in which the trace vectors are initially created when the first
goal action is tried  note that whenever a candidate action for a goal is conflict free with respect to
previously assigned actions  indicated by the ok in the figure   action checking for the goal is suspended  the process jumps to the next goal  and a new bit vector is initialized for this goals possible
establishers  the edge numbering also reflects the order in which the vectors are popped from the
search segment trace list when the segment is revisited in the next episode  for this scheme to work 
the bit vectors must be pushed onto the search segment trace list after all actions for a goal are tried  in
the reverse of the numbered edge order  long edges that skip over one or more goals indicate that
those goals are already established by previously assigned actions 
as long as the order of actions appearing under the establishers list for a planning graph proposition remains constant  the bit vectors can be used to replay the search in the next episode on the next
higher planning graph level  the graph building routine for egbg enforces this constraint 

   

fizimmerman   kambhampati

the egbg algorithm

the high level egbg algorithm is given in figure a   as for graphplan  search on the planning
graph occurs only after it has been extended to the level where all problem goals first appear with no
binary mutex conditions   the call to find  st level with goals   the first search episode is conducted
in graphplan fashion except that the assign goals routines of figure a  create search segments to
hold the states and trace information generated during the regression search process  the necessary
trace information for a search segment is captured in trace vectors as described above  these segments are stored in the pe structure indexed according to the level at which they where generated
 where the current highest planning graph level corresponds to   and contains the problem goals  
subsequent to the first episode  egbg plan enters an outer loop that employs the pe to conduct
successive episodes  referred to as search trace guided   the search strategy alternates between the
selection and visitation of a promising state from the trace of previous experience  select searchseg from pe routine   with a focused csp type search on the states subgoals  the replay trace goals and assign goals routines of figures a  and a   
for each episode  an inner loop visits the pe search segments in level by level  bottom up fashion
 for the reasons discussed in section     the extend plangraph routine called only when a state being
visited corresponds to a level beyond the current graph length 
the replay trace goals routine is the counterpart to graphplans assign goals routine  except that
it avoids the latters full blown mutex checking by stepping through the trace vectors that captured
previous search experience for a given state  unlike assign goals  it does not branch to any child
states already contained in the pe  the conditional checking of the trace vectors against establishing
actions initiates new search by calling assign goals under two conditions     when dynamic mutexes
from previous episodes no longer hold    when new establishing actions appear for a subgoal  these
are tried after all other establishers are replayed   when a dynamic mutex no longer holds or a new
establishing action is considered the trace vector is modified accordingly and egbg resumes graphplans csp style search  adding new trace vectors to the search segment in the process 

   

fiusing memory to transform search on the planning graph

egbg plan   ops  init  goals      ops init goals  is a planning problem   
   build plangraph  pg  until level n where goals first occur in non mutex state  

let pg  find  st level with goals  ops  init  goals  
if pg reached level off and goals are not present in non mutex state then return fail
let n be the number of levels in pg
let ss  be a new search segment with fields 
goalsgoals  parentroot  pe level    parent actions    trace   
let pe  pilot explanation structure with fields to hold search segments at each plangraph level
pe     ss        is top level of pe   
   conduct graphplan style backward search on the n length plangraph  store trace in the pe     

let search reslt  assign goals goals      n  ss   pg  pe 
if search reslt is a search segment    success   
then plan  extract plan actions from the ancestors linked to search reslt
return plan
else    no n length solution possible    use the pe to search for a longer length solution   
loop forever
n  n  
loop for pe lev ranging from the number of deepest level of pe to    top level 
let k  planning graph level associated with pe level pe lev
  n  pe lev      essentially translates the pe up one planning graph level   
if pe lev     then pg  extend plangraph pg       must extend plangraph at this point   
loop for search segments in pe pe lev 
ss  select searchseg from pe pe lev 
ssassigns  ss trace     get ordered  goal by goal trace vectors from search segment   
ss trace         clear the search segment trace vectors field   
if ss goals   memos k  pg    check for nogoods at level k   
then these goals match a nogood at this level  loop to next search segment
else    use ss trace to avoid redundant search effort on ss goals     
search reslt  replay trace goals  ss goals       k  ssassigns  ss  pg  pe 
if search reslt is a search segment
then plan  extract plan actions from the ancestors linked to search reslt
return plan
else add ss goals  to memos k  pg    memoize nogood   
end loop  search segments 
end loop  pe levels 
end loop  pg level 
end

figure a   egbg planner top level algorithm

   

fizimmerman   kambhampati

conduct graphplan style search on a subgoal set at planning graph level k
arguments  g  goals still to be assigned  a  actions already assigned  k  pg level 
ss   search segment  pg  planning graph  pe  pilot explanation  search trace 
assign goals  g  a  k  ss   pg  pe 
if g is empty or k      the initial state  then return ss     success   
else    there are goals left to satisfy  
let g assigns        trace vector will hold ordered action assignment tags   
let g be a goal selected from g
let ag   actions from pg level k that support g  ordered by value ordering heuristic
loop for act  ag
let search reslt     
if an action in a is dynamic mutex with act then append dm tag to g assigns
else if an action in a is static mutex with act then append sm tag to g assigns
else    act has no conflict with actions already in a   
if g is empty
then    done with g goals  setup for search at next lower level   
search reslt  assign next level goals  a u act   k  ss   pg  pe 
if search reslt is a nogood then append ng tag to g assigns
else append ok tag to g assigns    search occurred at lower level   
else    search continues at this level with the next goal   
append ok tag to g assigns
search reslt  assign goals  g  g   a u act   k  ss   pg  pe 
end if
if search reslt is a search segment then return search reslt    success   
   else we loop and try another action  

end if
end loop  actions 
push g assigns into trace field of ss 
return nil    no solution found   
end if
end

  add trace data to search segment   

setup for search on graph level k   given that the actions in a satisfy the goals of ss  at level k
assign next level goals  a  k  ss   pg  pe 
let nextgoals regress ss  goals over assigned actions in a
if nextgoals  memos at pg level k   then return nogood    backtrack on nogood goals   
else     initiate search on next lower pg level  
let ss  be a new search segment with fields 
goalsnextgoals  parentss   parent actionsa  trace  
add ss  to the pe at level   maximum pg level    k   
let search reslt  assign goals  nextgoals      k    ss   pg  pe 
if search reslt is nil    search at level k   failed   
then add nextgoals to memos to level k   of pg   memoize nogood   
return search reslt
end if
end
assign new actions  g  a  ag  g  g assigns  k  ss  pg  pe 
   routine is essentially the same as assign goals  except it attempts to satisfy goal g actions
with only the new actions  i e  those first appearing in the most recent plangraph extension   

figure a   egbgs non guided regression search algorithm

   

fiusing memory to transform search on the planning graph

regression search using search trace  pe  replay
arguments  g  goals still to be assigned  a  actions already assigned  k  pg level 
ss   search segment  pg  planning graph  pe  pilot explanation  search trace 
replay trace goals  g  a  k  ss   pg  pe 
if g is empty    all ss  goals in this branch were successfully assigned during last episode     
then return       continue with level k replay  ignoring search replay at next lower level   
else    there are goals left to satisfy  
let g  select goal from g
let g assigns  pop the front trace vector from ss trace 
let ag set of actions from level k of pg that support g
   now replay assignments for g from previous episode  rechecking only those that may have changed    

loop for tag  g assigns
let search reslt     let act  pop action from ag
if tag   ok    act had no conflict with actions in a during last episode   go to next goal   
then search reslt  replay trace goals  g  g   a u act   k  ssassigns  ss   pg  pe 
else if tag  ng then loop    its the last action assign at this level   act was not mutex in the last
episode   so the next level regressed goals reside in a child search segment that was already visited   

else if tag   sm then loop    act was static mutex with action in a last episode   
else tag   dm    act was dynamic mutex with action in a last episode retest it     
if dynamic mutex persists then loop
else change tag to ok in g assigns vector    act is no longer mutex with a actions   
if g  g  is not empty    resume backward search at this level   
then search reslt  assign goals  g  g   a u act   k  ss   pg pe 
else    no goals left to satisfy in ss   setup for search at lower level   
search reslt  assign next level goals  a u act   k  ss   pg  pe 
if search reslt  nogood then change g assigns vector tag to ng
end if
if search reslt is a search segment then return search reslt  success 
else loop  check next action 
end loop    all establishment possibilities from prior episode tried   now check for new actions   
if ag still contains actions    they are new actions establishing g at this level    attempt to assign   
then search reslt  assign new actions g  a  ag  g  g assigns  k  ss   pg  pe 
if search reslt is a search segment then return search reslt    success   
else push g assigns  ss  trace 
return nil    no solution found in search stemming from ss  goals   
end if
end

figure a   egbgs search trace guided algorithm

   

fizimmerman   kambhampati

appendix b  exploiting csp speedup methods to reduce memory demands

background and implementation details are provided here for the six techniques from the planning
and csp fields which proved to be key to controlling memory demands in our search trace based
planners  they are variable ordering  value ordering  explanation based learning  ebl   dependency
directed backtracking  ddb   domain preprocessing and invariant analysis  and replacing the redundant multi level planning graph with a bi partite version 
domain preprocessing and invariant analysis 
the speedups attainable through preprocessing of domain and problem specifications are well
documented  fox   long        gerevini   schubert         static analysis prior to the planning
process can be used to infer certain invariant conditions implicit in the domain theory and or problem
specification  the domain preprocessing for me egbg and pegg is fairly basic  focusing on identification and extraction of invariants in action descriptions  typing constructs  and subsequent rewrite
of the domain in a form that is efficiently handled by the planning graph build routines  our implementation discriminates between static  or permanent  mutex relations and dynamic mutex relations
 in which a mutex condition may eventually relax  between actions and proposition pairs  this information is used to both expedite graph construction and during me egbgs replay of action assignments when a search segment is visited 
domain preprocessing can significantly reduce memory requirements to the extent that it identifies
propositions that do not need to be explicitly represented in each level of the graph   examples of
terms that can be extracted from action preconditions  and hence do not get explicitly represented in
planning graph levels  include the  smaller  x  y  term in the move action of the towers of hanoi domain and typing terms such as  auto  x  and  place  y  in logistics domains   this benefit is
further compounded in egbg and pegg since propositions that can be removed from action preconditions directly reduce the size of the subgoal sets generated during the regression search episodes  and
hence the size of the search trace 
bi partite planning graph 
the original graphplan maintains the level by level action  proposition  and mutex information in
distinct structures for each level  thereby duplicating  often many times over  the information contained in previous levels  this multi level planning graph can be efficiently represented as an indexed
two part structure and finite differencing techniques employed to focus on only those aspects of the
graph structure that can possibly change during extension  this leads to more rapid construction of a
more concise planning graph  fox   long       smith   weld        
for me egbg and pegg  the bi partite graph offers a benefit beyond the reduced memory demands and faster graph construction time  the pe transposition process described in section     is reduced to simply incrementing each search segments graph level index  this is not straightforward
with the multi level graph built by graphplan  since each proposition  and action  referenced in the
search segments is a unique data structure in itself 
explanation based learning and dependency directed backtracking 
the application of explanation based learning  ebl  and dependency directed backtracking  ddb 
were investigated in a preliminary way in  zimmerman   kambhampati         where the primary
interest was in their speedup benefits  the techniques were shown to result in modest speedups on
   

fiusing memory to transform search on the planning graph

several small problems but the complexity of integrating them with the maintenance of the pe replay
vectors limited the size of problem that could be handled  we have since succeeded in implementing
a more robust version of these methods  and results reported here reflect that 
both ebl and ddb are based on explaining failures at the leaf nodes of a search tree  and propagating those explanations upwards through the search tree  kambhampati         ddb involves using the propagation of failure explanations to support intelligent backtracking  while ebl involves
storing interior node failure explanations  for pruning future search nodes  an approach that implements these complimentary techniques for graphplan is reported in  kambhampati        where
speedups ranged from   x for blocksworld problems to     x for ferry domain problems  we
refer to that study for a full description of ebl ddb in a graphplan context  but note here some aspects that are particularly relevant for me egbg and pegg 
as for conflict directed back jumping  prosser         the failure explanations are compactly represented in terms of conflict sets that identify the specific action goal assignments that gave rise to
backtracking  this liberates the search from chronological backtracking  allowing it to jump back to
the most recent variable taking part in the conflict set  when all attempts to satisfy a set of subgoals  a
state  fail  the conflict set that is regressed back represents a useful minimal no good for memoization   see the pegg algorithm in figures   and   for a depiction of this process   this conflict set
memo is usually shorter and hence more general than the one generated and stored by standard
graphplan  additionally  an ebl augmented graphplan generally requires less memory for memo
caches 
less obvious than their speedup benefit perhaps  is the role ebl and ddb often play in dramatically reducing the memory footprint of the pilot explanation  together ebl and ddb shortcut the
search process by steering it away from areas of the search space that are provably devoid of solutions 
search trace memory demands decrease proportionally 
both me egbg and pegg have been outfitted with ebl ddb for all non pe directed graphplan style search  me egbg however  does not use ebl ddb in the replay of the action assignment results for a pe search segment due to the complexity of having to retract parts of assignment
vectors whenever the conflict set in a new episode entails a new replay order 
value and variable ordering 
value and variable ordering are also well known speedup methods for csp solvers  in the context of
graphplans regression search on a given planning graph level k  the variables are the regressed subgoals and the values are the possible actions that can give these propositions at level k of the graph  in
their original paper  blum and furst        argue that variable and value ordering heuristics are not
particularly useful in improving graphplan  mainly because exhaustive search is required in the levels
before the solution bearing level anyway  nonetheless  the impact of dynamic variable ordering
 dvo  on graphplan performance was examined in  kambhampati         and modest speedups
were achieved using the standard csp technique of selecting for assignment the subgoal  variable 
that has the least number of remaining establishers  values   more impressive results are reported in
a later study  nguyen   kambhampati        where distance based heuristics rooted in the planning
graph were exploited to order both subgoals and goal establishers  in this configuration  graphplan
exhibits speedups ranging from     to over    x  depending on the particular heuristic and problem 

   

fizimmerman   kambhampati

for this study we fix variable ordering according to the adjusted sum heuristic and value ordering
according the set level heuristic  as we found the combination to be reasonably robust across the
range of our test bed problems  these heuristics are described in section   where they are used to
direct the traversal of the pe states is discussed  section     describes the highly problem dependent
performance of distance based variable and value ordering for our search trace based planners 
the manner in which egbg pegg builds and maintains the planning graph and search trace
structures actually reduces the cost of variable and value ordering  the default order in which graphplan considers establishers  values  for satisfying a proposition  variable  at a given level is set by the
order in which they appear in the planning graph structure  during graph construction in me egbg
and pegg we can set this order to correspond to the desired value ordering heuristic  so that the ordering is only computed once  for its part  the pe that is constructed during search can record the
heuristically best ordering of each regression states goals  so that this variable ordering is also done
only once for the given state  this contrasts with versions of graphplan that have been outfitted with
variable and value ordering  kambhampati        where the ordering is reassessed each time a state is
regenerated in successive search episodes 

references
blum  a    furst  m l          fast planning through planning graph analysis  artificial
intelligence          
bonet  b   loerincs  g     geffner  h          a robust and fast action selection mechanism for
planning  in proceedings of aaai    
bonet  b    geffner  h          planning as heuristic search  new results  in proceedings of
ecp    
do  m b    kambhampati  s          solving planning graph by compiling it into csp  in
proceedings of aips    
fox  m     long  d          the automatic inference of state invariants in tim  journal of
artificial intelligence research             
frost  d    dechter  r          in search of best constraint satisfaction search  in proceedings of
aaai    
gerevini   a     schubert  l          accelerating partial order planners  some techniques for
effective search control and pruning  journal of artificial intelligence research           
gerevini  a    serina  i           lpg  a planner based on local search for planning graphs with
action costs  in proceedings of aips    
haslum  p     geffner  h          admissible heuristics for optimal planning  in proceedings 
of aips    
hoffman  j         a heuristic for domain independent planning and its use in an enforced hillclimbing algorithm  technical report no       albert ludwigs university 
kambhampati  s          on the relations between intelligent backtracking and failure driven
explanation based learning in constraint satisfaction and planning  artificial intelligence 
         
kambhampati  s          planning graph as a  dynamic  csp  exploiting ebl  ddb and other
csp search techniques in graphplan  journal of artificial intelligence research           
kambhampati  s    sanchez  r          distance based goal ordering heuristics for graphplan 
in proceedings of aips    
   

fiusing memory to transform search on the planning graph

kambhampati  s   parker  e     lambrecht  e          understanding and extending graphplan 
in proceedings of ecp    
kautz  h    selman  b          pushing the envelope 
stochastic search  in proceedings of aaai    

planning  prepositional logic and

kautz  h    selman  b          unifying sat based and graph based planning  in proceedings
of ijcai     vol   
koehler  d   nebel  b   hoffman  j     dimopoulos  y           extending planning graphs to an
adl subset  in proceedings of ecp             
korf  r          depth first iterative deepening  an optimal admissible tree search  artificial
intelligence                
korf  r          real time heuristic search  artificial intelligence              
long  d    fox  m          efficient implementation of the plan graph in stan  journal of
artificial intelligence research             
mittal  s     falkenhainer  b          dynamic constraint satisfaction problems  in proceedings
of aaai    
mcdermott  d          using regression graphs to control search in planning  artificial
intelligence                    
nigenda  r     kambhampati  s          altaltp  online parallelization of plans with heuristic
state search  journal of artificial intelligence research              
nguyen  x    kambhampati  s          extracting effective and admissible state space heuristics
from the planning graph  in proceedings of aaai    
prosser  p          domain filtering can degrade intelligent backtracking search  in proceedings
of ijcai    
russell  s j           efficient memory bounded search methods  in proceedings of ecai    
sen  a k     bagchi  a           fast recursive formulations for best first search that allow
controlled use of memory  in proceedings of ijcai    
selman  b  levesque  h     mitchell  d          a new method for solving hard satisfiability
problems  in proceedings of aaai    
smith  d   weld  d          incremental graphplan  technical report           univ  of wash 
srivastava  b   nguyen  x   kambhampati  s   do  m   nambiar  u  nie  z   nigenda  r  
zimmerman  t          altalt  combining graphplan and heuristic state search  in ai
magazine         american association for artificial intelligence  fall      
zimmerman  t          exploiting memory in the search for high quality plans on the planning
graph  phd dissertation  arizona state university 
zimmerman  t    kambhampati  s          exploiting symmetry in the planning graph via
explanation guided search  in proceedings of aaai    
zimmerman  t   kambhampati  s          generating parallel plans satisfying multiple criteria in
anytime fashion  in proceedings of workshop on planning and scheduling with multiple
criteria  aips    
zimmerman  t    kambhampati  s          using available memory to transform graphplans
search  poster paper in proceedings of ijcai    

   

fi