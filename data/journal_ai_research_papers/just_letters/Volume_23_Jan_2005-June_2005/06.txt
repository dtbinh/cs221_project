journal of artificial intelligence research                  

submitted        published      

keys  nominals  and concrete domains
carsten lutz

lutz tcs inf tu dresden de

theoretical computer science  tu dresden
d       dresden  germany

carlos areces

areces loria fr

inria lorraine  nancy
      villers les nancy cedex  france

ian horrocks

horrocks cs man ac uk

department of computer science
university of manchester
oxford road  manchester m    pl  uk

ulrike sattler

sattler cs man ac uk

department of computer science
university of manchester
oxford road  manchester m    pl  uk

abstract
many description logics  dls  combine knowledge representation on an abstract  logical
level with an interface to concrete domains like numbers and strings with built in predicates such as       and prefix of  these hybrid dls have turned out to be useful in several
application areas  such as reasoning about conceptual database models  we propose to
further extend such dls with key constraints that allow the expression of statements like
us citizens are uniquely identified by their social security number  based on this idea 
we introduce a number of natural description logics and perform a detailed analysis of
their decidability and computational complexity  it turns out that naive extensions with
key constraints easily lead to undecidability  whereas more careful extensions yield nexptime complete dls for a variety of useful concrete domains 

   motivation
description logics  dls  are a family of formalisms that allow the representation of and
reasoning about conceptual knowledge in a structured and semantically well understood
manner  baader  calvanese  mcguinness  nardi    patel schneider         the central
entities for representing such knowledge are concepts  which are constructed from atomic
concept names  unary predicates  and role names  binary relations  by means of the concept
and role constructors offered by a particular dl  for example  in the basic propositionally
closed description logic alc  schmidt schau   smolka         we can describe a company
that has part time employees but only full time managers using the concept
company u employee parttime u employee  manager t parttime  
in this example  all words beginning with uppercase letters denote concept names while
employee denotes a role name 
c
    
ai access foundation  all rights reserved 

filutz  areces  horrocks    sattler

rather than being viewed only as conceptual entities in a knowledge base  concepts
can  more generally  be understood as the central notion in various kinds of class centered
formalisms  in the last decade  this observation has given rise to various new and challenging applications of description logics such as reasoning about database conceptual models
expressed in entity relationship diagrams or object oriented schemas  calvanese  lenzerini 
  nardi        calvanese  de giacomo    lenzerini        and reasoning about ontologies
for use in the semantic web  baader  horrocks    sattler      a  horrocks        horrocks 
patel schneider    van harmelen         these new applications have  in turn  stimulated
research in description logics since the expressive power of existing dls was insufficient
for the new tasks  one important extension is by providing expressive means that allow
the integration of numbers and other datatypes  suppose  for example  that we want to
extend our earlier descriptions of companies and employees to include the founding year of
a company and the hiring year of an employee  then  we may want to describe companies
that were founded before      and state that the hiring year of employees is not prior to
the founding year of the employing company  to do this  we obviously need a way to talk
about natural numbers  such as       and comparisons between natural numbers 
nowadays  the standard approach to integrate datatypes into description logics is to
extend dls with concrete domains  as first proposed by baader and hanschke      a  and
recently surveyed by lutz         more precisely  a concrete domain d consists of a set
 such as the natural numbers  and predicates which are associated with a fixed extension
over this set   such as the unary      the binary    and the ternary     the integration of
concrete domains into  say  the description logic alc is achieved by adding
   abstract features  i e  functional roles 
   concrete features  i e   partial  functions associating values from the concrete domain
 e g   natural numbers  with logical objects 
   a concrete domain based concept constructor 
the dl obtained by extending alc in this way is called alc d   where d denotes a
concrete domain that can be viewed as a parameter to the logic  for example  using a
suitable concrete domain d we can describe the constraints formulated above  the concept
employee u employer foundingyear       u hiringyear   employer foundingyear  
describes the set of employees who are employed by a company founded before      and
who have a hiring year not prior to the companys founding year  in this example  the term
foundingyear        is an instance of the concrete domain concept constructor  not to be
confused with the existential value restriction as in employee parttime   and so is the third
conjunct  while       is a unary predicate and thus the former instance only takes one
concrete feature foundingyear as argument  the second instance uses the binary predicate
 requiring two arguments  the concrete feature hiringyear and the sequence of features
 employer foundingyear  consisting of the abstract feature employer and the concrete feature
foundingyear 
concrete domains are rather important in many applications of dls  including the two
mentioned above 
   this fixed extension is why these predicates are often called built in 

   

fikeys  nominals and concrete domains

 the standard way of using description logics for reasoning about conceptual database
models is to translate a given model into a dl representation and then use a dl reasoner such as fact  horrocks        or racer  haarslev   moller        to compute
the consequences of the information provided explicitly in the model  this includes
detecting inconsistencies and inferring additional  implicit containments between entities classes  calvanese et al          since most databases store concrete data
like numbers and strings  constraints concerning such data are usually part of the
conceptual model and should thus also be captured by the description logic used for
reasoning  indeed  the above example concepts can be viewed as the dl encoding
of constraints from a database about companies and their employees  as discussed
by lutz      c   description logics with concrete domains are well suited for conceptual modeling applications involving concrete datatypes 
 so called concrete datatypes play a prominent role in the construction of ontologies  horrocks et al          say  for example  that we want to construct an ontology
which can be used for describing car dealers web pages and web services  in such an
ontology  concrete datatypes such as prices  manufacturing years  and names of car
models will doubtlessly be very important  to formulate this ontology using a dl  we
need a way to represent these concrete datatypes  consequently  almost all dls that
have been proposed as an ontology language are equipped with some form of concrete
domain  fensel  van harmelen  horrocks  mcguinness    patel schneider        horrocks et al         dean  connolly  van harmelen  hendler  horrocks  mcguinness 
patel schneider    stein         furthermore  since these ontology languages provide
inverse abstract roles and functional restrictions  the users and ontology designers
were quite surprised to find that they do not provide inverse concrete functional
featureswhich is due to the fact that such features correspond to concrete key
constraints  for which no reasoning algorithms were known and whose effect on the
decidability complexity was not yet investigated 
in this paper  we propose to further enhance the expressive power of description logics with
concrete domains by extending them with concrete key constraints  this extension is
useful both for knowledge representation and for the two applications sketched above  the
following three examples describe the basic idea 
   suppose that  in a knowledge representation application  we represent nationalities
by concept names such as us and german and  for us citizens  we store the social
security number using a concrete feature ssn  then it would be natural to state that
us citizens are uniquely identified by their social security number  i e  any two distinct
instances of
human u nationality us
must have different values for the ssn feature  in our extension of dls with concrete
domains  this can be expressed by using the key assertion  
 ssn keyfor human u nationality us  
   readers familiar with the
vrelationship between dls and first order logic will notice that this key assertion
is equivalent to x  x      i       human xi  z  nationality xi   z us z    x    x       ssn x     
ssn x      

   

filutz  areces  horrocks    sattler

   returning to our database about companies and employees  it could be useful to
equip every employee with  i  a concrete feature branch storing the branch id in
which she is working and  ii  a concrete feature id storing her personnel id  it would
then be natural to enforce that the branch id together with the personnel id uniquely
identifies employees  even though personnel ids are not unique  we can do this by
using the composite key assertion
 branch  id keyfor employee  
   in the car dealers ontology  we may assume that cars as well as manufacturers are
equipped with identification numbers and that every car is uniquely identified by the
combination of its own identification number and its manufacturers one  to express
this  we could employ a composite key assertion referring to sequences of features  in
this case  manufacturer id  
 id   manufacturer id  keyfor car  
more formally  we propose to extend dls to provide for concrete domains with key boxes 
which are sets of key assertions of the form
 u            un keyfor c  
where each ui is a sequence f     fn g of abstract features fj followed by a single concrete
feature g  and c is a concept  as the above examples illustrate  the idea of key constraints is
very natural  since  moreover  keys play an important role in databases and  as mentioned
above  reasoning about database conceptual models is an important  challenging application
of description logics  several approaches to extend description logics with keys have already
been investigated  borgida   weddell        calvanese  de giacomo    lenzerini       
khizder  toman    weddell         what distinguishes our approach from existing ones 
however  is the idea of using concrete domains for constructing key constraints  rather than
defining keys on an abstract  logical level 
the goal of this paper is to provide a comprehensive analysis of the effects on decidability and computational complexity of adding key boxes to description logics with concrete
domains  to this end  we extend the two description logics alc d  and shoq d  with key
boxes  in this way obtaining alck d  and shoqk d   respectively  while the basic dl
with concrete domains alc d  has already been discussed above  shoq d  was proposed
as an ontology language in  horrocks   sattler         it provides a wealth of expressive
possibilities such as general concept inclusion axioms  gcis   transitive roles  role hierarchies  nominals  and qualifying number restrictions  moreover  it offers a restricted variant
of the concrete domain constructor that disallows the use of sequences of features in order
to avoid undecidability of reasoning  the main outcome of our investigations is that key
constraints can have a dramatic impact on the decidability and complexity of reasoning  for
example  whereas satisfiability of alc d  concepts is known to be pspace complete  lutz 
    b   we will show that satisfiability of alck d  concepts w r t  key boxes is  in general 
undecidable  decidability can be regained if we restrict the concepts used in key boxes
   

fikeys  nominals and concrete domains

to boolean combinations of concept names  boolean key boxes   interestingly  satisfiability of alck d  concepts w r t  boolean key boxes is still nexptime complete even for
very simple concrete domains  in the case of shoq d  and shoqk d   the leap in
complexity is somewhat less dramatic since shoq d  concept satisfiability is already exptime complete  again  the addition of key boxes results in nexptime complete reasoning
problems 
it is interesting to note that there exists a close connection between key assertions
and so called nominals  i e  concept names that can have at most one instance  such as
pope  nominals are a standard means of expressivity in description logics and sometimes
appear in disguise as the one of operator  borgida   patel schneider        horrocks
et al          it is not hard to see that key boxes can simulate nominals  if  for example 
we use a concrete domain based on the natural numbers and providing unary predicates
 n for equality with n    then the key assertion  g keyfor     where   stands for
logical truth  obviously makes the concept g  n behave like a nominal  for each n 
  for this reason  we also consider alco d   the extension of alc d  with nominals 
and alcok d   the extension of alck d  with nominals   our main result concerning
nominals is that  although in general being of lower expressive power than key boxes  they
already make reasoning nexptime hard if combined with concrete domains  there exist
concrete domains d such that alco d  concept satisfiability is nexptime complete  we
should like to stress that this and the other nexptime hardness results obtained in this
paper are in accordance with the observation made in  lutz        that the pspace upper
bound for reasoning with alc d  is not robust w r t  extensions of the logic  there exist
several seemingly harmless extensions of alc d   for example with acyclic tboxes and
with inverse roles  which make the complexity of reasoning leap from pspace completeness
to nexptime completeness for many natural concrete domains 

n

n

the remainder of this paper is organized as follows  in section    we formally introduce
concrete domains  key boxes  and the dl alcok d  together with its fragments alck d 
and alco d   moreover  we define boolean key boxes  which only allow boolean combinations of concept names to appear in key definitions  additionally  we introduce some
other important properties of key boxes  path free key boxes prohibit the use of sequences
of features in key assertions  in unary key boxes  each key assertion involves exactly one
sequence of features  and composite key boxes are simply non unary ones 
section   is devoted to establishing lower bounds for extensions of alc d  with key
boxes or nominals  in section      we use a reduction of the post correspondence problem
to prove that alck d  concept satisfiability w r t   non boolean  key boxes is undecidable
for a large class of concrete domains  we then shift our attention to boolean key boxes
since  in section    we show that this restriction restores decidability  in section     
we introduce a nexptime complete variant of the domino problem and three concrete
domains that are useful for the reduction of this problem to concept satisfiability in dls
with boolean key boxes or nominals  in section      we use these concrete domains to
prove that alck d  concept satisfiability w r t  boolean  path free and unary key boxes
is nexptime hard for some natural concrete domains  in section      we prove that there
exist concrete domains d such that alco d  concept satisfiability without reference to
   note that the logic shoq d  already provides for nominals 

   

filutz  areces  horrocks    sattler

key boxes is already nexptime hard  we show that this is true even for some concrete
domains that are computationally very simple  ptime  when considered in isolation 
the purpose of section   is to develop reasoning procedures for description logics with
key boxes and to prove upper complexity bounds matching the nexptime lower bounds
established in the previous section  we start in section     with a tableau algorithm that
decides alcok d  concept satisfiability w r t  boolean key boxes  provided that the concrete domain d is key admissible  intuitively  a concrete domain d is key admissible if there
exists an algorithm that takes a finite conjunction c of predicates from d over some set of
variables  decides whether this conjunction is satisfiable and  if so  chooses a solution of c
and returns the information on which variables take the same values in it  we call such
an algorithm a d tester  we have chosen a tableau algorithm since this type of reasoning
procedure has the potential to be implemented in efficient reasoners and has been shown to
behave well in practice  horrocks  sattler    tobies        haarslev   moller         our
algorithm implies the following upper complexity bound  if d is a key admissible concrete
domain for which a non deterministic polynomial time d tester exists  then alco d concept satisfiability w r t  boolean key boxes is in nexptime 
in section      we devise a tableau algorithm for shoqk d  concept satisfiability
w r t  path free key boxes which might involve non boolean concepts  for the decidability
of alcok d   we restricted key boxes to boolean ones  for shoqk d   such a restriction is not possible since shoq d  provides tboxes  and we can thus no longer distinguish
between boolean and non boolean concepts  on the other hand  it follows from an undecidability proof by baader and hanschke        that shoq d  is undecidable if we allow
for sequences of features in concrete domain constructors  thus we restrict key assertions
analogously to path free ones  and show that this yields indeed a decidable logic  its expressive power is orthogonal to the one of alcok d   and our previous undecidability
results imply that the combination of alcok d  and shoqk d  is undecidable  as a
by product of the correctness proof of the algorithm  we obtain a bounded model property for shoqk d   which implies that shoqk d  concept satisfiability w r t  path free
key boxes is in nexptime if d is a key admissible concrete domain for which a nondeterministic polynomial time d tester exists 
in section    we summarize the results obtained and give an outlook to possible future
research 

   description logics with concrete domains
in the following  we introduce the description logic alcok d   let us start by defining
concrete domains 
definition      concrete domain   a concrete domain d is a pair  d   d    where d
is a set and d a set of predicate names  each predicate name p  d is associated with
an arity n and an n ary predicate p d  nd  
based on concrete domains  we can now define alcok d  concepts and key boxes 
definition      alcok d  syntax   let nc   no   nr   ncf be pairwise disjoint and countably infinite sets of concept names  nominals  role names  and concrete features  furthermore  we assume that nr contains a countably infinite subset naf of abstract features  a
   

fikeys  nominals and concrete domains

path u is a composition f     fn g of n abstract features f            fn  n     and a concrete
feature g  let d be a concrete domain  the set of alcok d  concepts is the smallest set
such that
 every concept name and every nominal is a concept  and
 if c and d are concepts  r is a role name  g is a concrete feature  u            un are paths 
and p  d is a predicate of arity n  then the following expressions are also concepts 
c  c u d  c t d  r c  r c  u            un  p  and g 
a key assertion is an expression
 u            uk keyfor c  
where u            uk  k     are paths and c is a concept  a finite set of key assertions is
called a key box 
as usual  we use   as an abbreviation for an arbitrary propositional tautology   as an
abbreviation for    c  d as an abbreviation for c t d  and c  d as an abbreviation
for  c  d  u  d  c   throughout this paper  we will also consider several fragments
of the description logic alcok d   the dl alco d  is obtained from alcok d  by
admitting only empty key boxes  in particular  the set of alco d  concepts is just the set
of alcok d  concepts  furthermore  by disallowing the use of nominals  we obtain the
fragment alc d  of alco d  and alck d  of alcok d  
the description logic alcok d  is equipped with a tarski style set theoretic semantics 
along with the semantics  we introduce the two standard inference problems  concept
satisfiability and concept subsumption 
definition      alcok d  semantics   an interpretation i is a pair  i   i    where i is
a non empty set  called the domain  and i is the interpretation function  the interpretation
function maps
 each concept name c to a subset c i of i  
 each nominal n to a singleton subset n i of i  
 each role name r to a subset ri of i  i  
 each abstract feature f to a partial function f i from i to i   and
 each concrete feature g to a partial function g i from i to d  
   

filutz  areces  horrocks    sattler

if u   f     fn g is a path  then ui  d  is defined as g i  fni     f i  d         the interpretation
function is extended to arbitrary concepts as follows 
 c i    i   c i
 c u d i    c i  di
 c t d i    c i  di
 r c i     d  i   there is e  i with  d  e   ri and e  c i  
 r c i     d  i   for all e  i   if  d  e   ri   then e  c i  
 u            un  p  i     d  i   x            xn  d   uii  d    xi and  x            xn    p d  
 g i     d  i   g i  d  undefined  
let i be an interpretation  then i is a model of a concept c iff c i      moreover  i
satisfies a key assertion  u            un keyfor c  if  for any a  b  c i  
ui   a    ui   b           uin  a    uin  b  implies that a   b 
i is a model of a key box k iff i satisfies all key assertions in k  a concept c is satisfiable
w r t  a key box k iff c and k have a common model  c is subsumed by a concept d w r t 
a key box k  written c vk d  iff c i  di for all models i of k 
it is well known that  in description logics providing for all boolean operators  subsumption
can be reduced to  un satisfiability and vice versa  c vk d iff c u d is unsatisfiable
w r t  k and c is satisfiable w r t  k iff c  vk   this allows us to concentrate on concept
satisfiability when devising complexity bounds for reasoning with description logics  lower
and upper complexity bounds for concept satisfiability imply corresponding bounds for
concept subsumptiononly for the complementary complexity class 
if decision procedures for description logics with concrete domains are to be devised
without committing to a particular concrete domain  then a well defined interface between
the decision procedure and a concrete domain reasoner is needed  usually  this interface
is based on the assumption that the concrete domain is admissible  baader   hanschke 
    a  lutz      a        
definition      d conjunction  admissibility   let d be a concrete domain and v a set
of variables  a d conjunction is a  finite  predicate conjunction of the form
   i 
c 
 x            x i 
ni     pi  
i k
 i 

where pi is an ni  ary predicate for i   k and the xj are variables from v  a d conjunction
c is satisfiable iff there exists a function  mapping the variables in c to elements of d such
 i 
 i 
that   x              xni     pid for each i   k  such a function is called a solution for c 
we say that the concrete domain d is admissible iff
   d contains a unary predicate  d such that  d
d   d  
   d is closed under negation  i e   for each n ary predicate p  d   there is a predicate
d
p  d of arity n such that p   nd   p d  
   

fikeys  nominals and concrete domains

   satisfiability of d conjunctions is decidable 
we refer to the satisfiability of d conjunctions as d satisfiability 
as we shall see  it sometimes makes a considerable difference w r t  complexity and decidability to restrict key boxes in various ways  for example to disallow paths of length greater
than one  therefore  we introduce some useful notions 
definition      boolean  path free  simple   a key box k is called
 boolean if all concepts appearing in  key assertions in  k are boolean combinations
of concept names 
 path free if  for all key assertions  u            un keyfor c  in k  u            un  ncf  
 simple if it is both path free and boolean 
 unary if all key assertions in k are unary key assertions  i e  of the form  u keyfor c  
a concept c is called path free if  in all its subconcepts of the form u            un  p   u            un
are concrete features 
to emphasize that a key box might not necessarily be boolean or path free  we sometimes
call such a key box general  similarly  to emphasize that a key box is not necessarily a
unary key box  we sometimes call such a key box composite 

   lower bounds
in this section  we prove lower complexity bounds for description logics with concrete domains and key boxes and or nominals  in section      we start by showing that the satisfiability of alck d  concepts w r t   general  key boxes is undecidable for many interesting
concrete domains  the discouraging picture painted by this result is mitigated by the fact
that  in section      we shall prove that the restriction to boolean key boxes restores decidability  it is thus interesting to look for lower complexity bounds that apply under this
restriction  in preparation for this  we introduce in section     a nexptime complete variant of the domino problem and three concrete domains that are well suited for reductions
of this problem 
in section      we then prove that satisfiability of path free alck d  concepts w r t 
simple key boxes is nexptime hard for a large class of concrete domains d and that  for
many concrete domains  this holds even if we restrict key boxes to unary ones  finally 
we consider the description logic alco d  in section     and identify several concrete
domains such that alco d  concept satisfiability  without key boxes   is nexptimehard  as we already mentioned  key boxes and nominals are closely related  key boxes can
express nominals  but are in general more powerful 
    undecidability of alck d  with general key boxes
we prove that satisfiability of alck d  concepts w r t  key boxes is undecidable for a
large class of concrete domains if we allow complex alck d  concepts to occur in key
assertions  the proof is by a reduction of the well known undecidable post correspondence
problem  post        hopcroft   ullman        
   

filutz  areces  horrocks    sattler

definition      pcp   an instance p of the post correspondence problem  pcp  is given
by a finite  non empty list       r               k   rk   of pairs of words over some alphabet   a
sequence of integers i            im   with m     is called a solution for p if  i      im   ri     rim  
the pcp is to decide whether a given instance p has a solution 
for reducing the pcp to the satisfiability of our dls  we need an appropriate concrete
domain  it is obviously natural to use a concrete domain based on words and concatenation 
we will later see that the results obtained for this concrete domain carry over to other
concrete domains based on numbers and arithmetics  the following concrete domain was
introduced by lutz         its definition presupposes a fixed alphabet  that is at least
binary 
definition      concrete domain w   the concrete domain w is defined by setting w   
 and defining w as the smallest set containing the following predicates 
 unary predicates word and nword with wordw   w and nwordw    
w
 
 unary predicates   and    with  w
      and        

 a binary equality predicate   and a binary inequality predicate    with the obvious
interpretation  and
 for each w      two binary predicates concw and nconcw with
w
concw
w     u  v    v   uw  and nconcw     u  v    v    uw  

it is readily checked that w satisfies properties   and   of admissibility  see definition      
moreover  w satisfiability is decidable 
theorem      lutz         w satisfiability is in ptime 
thus  w is admissible and even of low complexity  this is important since our aim is
to demonstrate that the undecidability of alck w  concept satisfiability is due to the
presence of keys  and not due to the high complexity of w satisfiability 
we can now discuss the reduction of the pcp  a given instance       r               k   rk   is
translated into an alck d  concept cp and key box kp as defined in figure   such that
p has a solution iff cp is unsatisfiable w r t  kp   the idea behind the reduction is that a
common model of cp and kp encodes all potential solutions for p  i e   sequences i            in
of integers ij between   and k  and makes sure that none of them is in fact a solution  in
figure    f            fk denote abstract features while g     and r denote concrete features  the
definition of the concept step just serves as an abbreviation and should not be confused
with so called tboxes  see section     for the definition of tboxes   models of cp and kp  
such as the one displayed in figure    have the form of an infinite k ary tree whose root is
connected to an extra node x via the role r  intuitively  each node of the tree represents
one partial solution i            in   its   successor represents the corresponding left concatenation
 i      in   and its r successor the corresponding right concatenation ri     rin  
to enforce the existence of the infinite tree  we employ the key box kp   consider for
example the root nodes f   successor in figure  let us call this node y  due to line  
   

fikeys  nominals and concrete domains

step   

u f   a u g   u    r    
u u     f   conc u r  f r conc
i

 ik



i

 ik

i

 i

ri  

cp        u r  
u r  a u g   u step 
u step
kp     g keyfor step 
figure    the alck w  reduction concept cp and key box kp  
r
 

conc  

 

r

 

x

fk

concrk

f 

a
g  

concr  conc k
 
f 



r


fk

f 



r

 


fk



figure    an example model of cp and kp  
of cp and line   of step  we have y   g    i   due to line   of cp   we also have
x   g    i and x   step i   where x is the extra node mentioned above  in view of
the key box kp   this implies that either  i  x   y or  ii  y  stepi   it is easy to see that
 i  is impossible since line   of cp and line   of step imply that x  ai and y   a i  
hence y  stepi and  by line   of step  y has the appropriate fi  successors for    i  n 
in the same way  the construction of the tree can be continued ad infinitum  the second
line in the definition of step enforces that  i  z     i      in and ri  z    ri     rin for z an
fi     fin  successor of the root node  finally  the concept    r    in line   of step implies
that  i  z     ri  z  holds at all nodes z of the tree  except for the root   which implies that
no potential solution is a solution 
since the size of cp and kp is clearly polynomial in k and the key box kp is a unary
key box  we obtain the following proposition 
proposition      the satisfiability of alck w  concepts w r t   non boolean  path free
unary key boxes is undecidable 
   

filutz  areces  horrocks    sattler

to emphasize that this undecidability result was obtained using a very simple concrete
domain  let us combine theorem     with proposition     
theorem      there exists a concrete domain d such that d satisfiability is in ptime
and satisfiability of alck d  concepts w r t   non boolean  path free unary key boxes is
undecidable 
at first sight  the concrete domain w might look artificial and one may question the relevance of lower bounds that have been obtained using w  however  it is straightforward
to encode words as natural numbers and to define concatenation of words as rather simple operations on the natural numbers  baader   hanschke         a word w     over
the alphabet  of cardinality   can be interpreted as a number written at base      
in which the symbol that is the   digit does not occur  hence  we can use the corresponding natural number  e g   in base     to represent a word w  and the number   to
represent the empty word  the concatenation of two words v and w can then be expressed
as vw   v       w   w  where  w  denotes the length of the word w  moreover  exponentiation can be expressed as multiple multiplications  multiplication as multiple additions 
and addition as multiple incrementation  this is shown in section     of  lutz        for
the case of alc d  extended with tboxes  c f  section      and can easily be adapted to
alc d  with non boolean key boxes  this observation gives rise to the following theorem 

n

theorem      let d be a concrete domain such that  d   d contains a unary predicate    with      d        binary equality and inequality predicates  and a binary predicate
incr with incrd    n  x    n  and x  d       k  k        k     then satisfiability of
alck d  concepts w r t   non boolean  path free unary key boxes is undecidable 

n

n

    domino problems and concrete domains
in this section  we introduce a nexptime complete variant of the well known  undecidable
domino problem  berger        knuth         and then define three concrete domains d   
d    and d    these concrete domains will be used in sections     and     to establish
lower bounds for reasoning with alck d  and boolean key boxes  and for reasoning with
alco d  
in general  a domino problem is given by a finite set of tile types  intuitively  all tile
types are of the same size  each type having a square shape and colored edges  an unlimited
number of tiles of each type is available  in the nexptime hard variant of the domino
problem that we use  the task is to tile a  n     n    torus  i e   a  n     n    rectangle
whose borders are glued together  where neighboring edges have the same color 

n

definition      domino system   a domino system d is a triple  t  h  v    where t  
is a finite set of tile types and h  v  t  t represent the horizontal and vertical matching
conditions  let d be a domino system and a   a            an  an initial condition  i e  an
n tuple of tiles  a mapping                 n                     n        t is a solution for
d and a iff  for all x  y    n     the following holds 
 if   x  y    t and   x  n      y    t    then  t  t     h
 if   x  y    t and   x  y  n        t    then  t  t     v
   

fikeys  nominals and concrete domains

   i       ai for i   n 
where i denotes addition modulo i 
it follows from results in  borger  gradel    gurevich        that the above variant of the
domino problem is nexptime complete 
we define the concrete domain d  to be used in the reduction of the nexptimecomplete domino problem to alck d    concept satisfiability w r t  boolean key boxes 
definition      concrete domain d     the concrete domain d  is defined by setting
d            and d  to the  smallest  set containing the following predicates 
 unary predicates  d  with   d   d    d  and d  with  d   d     
 unary predicates    and    with   i  d     i   i         
the second concrete domain d  will be used for a reduction of the nexptime complete
domino problem to alck d    concept satisfiability w r t  boolean unary key boxes  for
this reduction we need to store vectors of bits in single concrete domain elements 

n

definition      concrete domain d     for every n    a function v               n     
       is called a bit vector of dimension n  we use bvn to denote thesset of all bit vectors
of dimension n  the concrete domain d  is defined by setting d     i   bvi and d  to
the  smallest  set containing the following predicates 
 unary predicates  d  with   d   d    d  and d  with  d   d     
 for every k  i 

n with i   k  unary predicates bit ik and bit ik with
 bitnik  d     v  d    v  bvk and v i    n  

and unary predicates bit ik and bit ik with  bitnik  d    d     bitnik  d   
the last concrete domain d  is used in the reduction of the nexptime complete domino
problem to alco d    concept satisfiability  in this reduction  the concrete domain d 
contains two kinds of elements  firstly  there are elements of d  that can represent the
whole  n     n    torus  so called domino arrays  secondly  there are elements of d  that
represent positions in the torus  for technical reasons to be discussed later  these elements
are vectors of natural numbers rather than bit vectors  and in the following we shall just call
them vectors  a domino array is then a function mapping each pair of vectors  of certain
length  to a natural number which represents a tile type 

n

n

definition      concrete domain d     for every k    a function v               k     
is called a vector of dimension k  we use vek to denote the set of all vectors of dimension k 
for every k    a function k   vek  vek 
is called a domino array of dimension k 
we use dak to denote the setsof all domino
arrays
of dimension k  the concrete domain d 
s
is defined by setting d     i   vei  i   dai and d  to the  smallest  set containing
the following predicates 

n

n

 unary predicates  d  with   d   d    d  and d  with  d   d     
   

filutz  areces  horrocks    sattler

 for every k  i 

n with i   k  unary predicates pos ik and pos ik with
 posnik  d     v  d    v  vek and v i    n 

and unary predicates pos ik and pos ik with  posnik  d    d     posnik  d   
 for every k  i 

n  a predicate tileik of arity   with

 tileik  d      vx   vy   d    vx   vy  vek   d  dak   and d vx   vy     i 
and a predicate tileik of arity   with  tileik  d     d        tileik  d   
the reason for using vectors of natural numbers rather than bit vectors in the definition of
d  is that we want d   satisfiability to be of low complexity  preferably in ptime  consider
the d   conjunction
pos     x   pos     y   pos     z  
tile    x  v  d   tile    y  v  d   tile    z  v  d  
if we use bit vectors rather than vectors of natural numbers  then the upper line enforces
that at least two out of the three variables x  y  and z must take the same value  since
the value of v is fixed  the lower line makes the conjunction unsatisfiable  it tries to assign
the three different values         to two different positions in the domino array  it seems
unlikely that this kind of inconsistency can be detected in polynomial time  this problem
is circumvented by using vectors of natural numbers in the definition of d   but enforcing
them to be bit vectors in the reduction   in this case  the above conjunction is clearly
satisfiable 
proposition      for each i             the concrete domain di is admissible and satisfiability of di  conjunctions is in ptime 
for d    this is trivial  for d    a proof can be found in appendix a  and for d    a proof
can be found in  lutz  areces  horrocks    sattler        
    nexptime hardness of alck d  with boolean key boxes
in this section  we prove two nexptime lower bounds for alck d  concept satisfiability
w r t  boolean key boxes by reducing the nexptime complete domino problem introduced
in the previous section  the first reduction uses the very simple concrete domain d    but
depends on composite key assertions  the second reduction uses the slightly more complex
concrete domain d    but only needs unary key assertions  as we will see  the two reductions
yield different  incomparable results 
we first reduce the nexptime complete domino problem to alck d    concept satisfiability w r t  boolean composite key boxes  each domino system d    t  h  v   with initial
condition a   a            an  is translated into an alck d    concept cd a as displayed in
figure    names such as treex and treey are used as abbreviations only  we use ri  c as
an abbreviation for the n fold nesting r     r c  the names xposi and yposi used in the
figure denote concrete features  in the definition of the init concept  for each n    biti  n 

n

   

fikeys  nominals and concrete domains

treex    r x  u r x  u

u r   distx
i

u r xi u r xi  

i 

i    n

treey    distxn u r y  u r y  u

u r   disty u distx u r y u r y  
distx    u   x  r x   u  x  r x   
disty    u   y  r y   u  y  r y   
transxpos    u  x  xpos       u  x  xpos      
transypos    u  y  ypos       u  y  ypos      
i

i 

i    n

k

k

i

i    k

i    n

i

i

i

i

i

i    k

i

i    n

n

i

i

i

i

i

i

 

i

 

i

 

i

i

 

i

succs    rx   transxpos u transypos  u ry   transxpos u transypos 

xsuccok   
 yi  rx  yi   u  yi  rx  yi  
i    n


xj   xk  rx  xk   u  xk  rx  xk  

u
u u
u t x    x  r  x   u  x  r  x  

ysuccok    u  x  r  x   u  x  r  x  
u u y    y  r  y   u  y  r  y  
u t y    y  r  y   u  y  r  y  
label    t d u u  d u d  
checkmatch    t  d u r  d   u t  d u r  d  

u x u u x u u y   d
init    u
k    n

j    k

k    n

j    k
i

i    n

j    k

k    n

j    k

i

 i j h

i    n 

i

j

y

k

i

j

j    n bitj  i   

x

k

y

y

k

x

k

i

j

i jt i  j

i

x

k

y

k    n

it

j

k

i

k

k

y

k

k

y

k

k

j

 i j v
j

i

y

j

j    n bitj  i   

j

j    n

j



ai

cd a    treex u rn    treey
u r  n      transxpos u transypos u succs u xsuccok u ysuccok 
u r  n      label u checkmatch u init 
figure    the alck d    reduction concept cd a  
is supposed to denote the ith bit of the binary representation of n  we claim that cd a is
satisfiable w r t  the key box
  xpos            xposn   ypos            yposn keyfor    
iff there exists a solution for d and a  to substantiate this claim  let us go through the
reduction and explain the various parts of the concept cd a   the first step towards under   

filutz  areces  horrocks    sattler

standing the structure of models of cd a  which is the key to understanding the reduction
itself  is to note that the purpose of the first line of cd a is to enforce a tree structure
of depth   n       whose leaves correspond to positions in the  n     n    torus  more
precisely  the treex concept guarantees that  in every model i of cd a   there exists a binary
tree of depth n      moreover  the distxk concepts  there exists one for each k              n  
ensure that the leaves of this tree are binarily numbered  from   to  n       by the concept
names x            xn   more precisely  for a domain object d  i   set

  if d  xii
n
i
xpsn d    i   i  d     where i  d   
  otherwise 
the treex and distx concepts ensure that there exist nodes d            d n     at level n    
of the tree such that xpsn di     i  intuitively  this numbering represents the horizontal
positions in the  n     n    torus  the vertical positions are coded in a similar way by the
y            yn concept names  more specifically  the concepts treey  distx  and disty ensure
that every di  i   n       is the root of another tree  in which  i  every node has the
same x            xn  configuration as its root node  and  ii  the leaves are numbered binarily
using the concept names y            yn  note that the treey concept appears in cd a inside a
rn   value restriction   define

  if d  yii
n
i
ypsn d    i   i  d     where i  d   
  otherwise 
in the set of leaf nodes of all the trees enforced by the treey concept  there exists  for each
i  j    n     an object  ei j  i such that xpsn ei j     i and ypsn ei j     j  i e   each ei j
represents the position  i  j  in the  n     n    torus 
the next step is to translate the individual bits of the numbering of the ei j  objects 
which are up to now represented by concept names  into concrete domain values  this is
done by the transxpos and transypos concepts which ensure that  for all    n  we have
xposi   ei j       if ei j  x    xposi   ei j       if ei j  x    and similarly for ypos  and y   
since i is a model for the key box
  xpos            xposn   ypos            yposn keyfor     
grid positions are uniquely represented by domain elements from  transxpos u transypos i  
i e   if d  e   transxpos u transypos i such that xpsn d    xpsn e  and ypsn d    yxpsn e  
then d   e  this fact is used in the concepts succs  xsuccok  and ysuccok to enforce that 
for the two roles rx and ry and each i  j  n  the following holds 
rxi    ei j    i       ei j   e i n      j  
ryi    ei j    i       ei j   ei  j n        

  

the succs concept ensures that  for each ei j   there exists an rx  successor and an ry successor  and that both are in  transxpos u transypos i   let d be an rx  successor of ei j  
then the xsuccok concept ensures that xpsn d    i  n     and ypsn d    j  before we
   it does not matter if there is more than one such object 

   

fikeys  nominals and concrete domains

explain how it does this  let us note that  since all ei j are in  transxpos u transypos i and
the grid positions are uniquely represented by elements of  transxpos u transypos i   this
implies d   e i n      j which shows that the upper line of    does indeed hold 
let us now consider the xsuccok concept in some more detail  it is essentially the
dl formulation of the well known propositional formula
n k 
n k 
 
 
 
 
 
xj        xk      x k      
 
xj        xk   x k  
k   j  

k   j  

which encodes incrementation modulo  n     i e   if t is the number  binarily  encoded by
the propositional variables x            xn and t  is the number encoded by the propositional
variables x             x n   then we have t    t     modulo  n    see borger et al          taking
into account the rx quantifiers in xsuccok  it is readily checked that this concept has
just the desired effect  to ensure that  for every rx  successor d of ei j   we have xpsn d   
xpsn e i n      j     i  n      the explanation of ysuccok and how it enforces the lower
line of    is analogous to the xsuccok case 
it remains to ensure that every grid position is labeled with precisely one tile and that
the initial condition as well as the horizontal and vertical matching conditions are satisfied 
the tiles are represented by concept names di  where i is from the set of tiles t   and
the described tasks are accomplished in the standard way by the concepts label  init  and
checkmatch 
it is worth noting that the reduction concept is path free and the key box is simple 
i e   path free and boolean  path freeness of concepts is often used to tame the complexity
of description logics with concrete domains  although it largely sacrifices their expressive
power  lutz        baader  lutz  sturm    wolter      b  haarslev  moller    wessel       
horrocks   sattler         for example  if alc d  is augmented with general tboxes  then
reasoning with arbitrary concepts is undecidable while reasoning with path free concepts
is exptime complete if d is admissible and d satisfiability is in exptime  lutz      a  
this taming approach does not work in the presence of key boxes since  as we have just
seen  satisfiability of alc d  concepts w r t  key boxes is  under some natural assumptions 
nexptime hard  even if both concept and key box are path free 
since the size of cd a and of the used key box is clearly polynomial in n  we obtain the
following proposition 
proposition      the satisfiability of path free alck d    concepts w r t  simple key boxes
is nexptime hard 
it has been shown that  non path free  alc d  concept satisfiability is pspace complete
if d satisfiability is in pspace  lutz      b   hence  it follows from proposition     that
alc d    concept satisfiability is pspace complete  thus  there is a rather dramatic increase of complexity if key boxes are added to alc d     to stress that this increase is due
to the key boxes themselves and not to the complexity of d   satisfiability  we reformulate
proposition     
theorem      there exists a concrete domain d such that d satisfiability is in ptime and
satisfiability of path free alck d  concepts w r t  simple key boxes is nexptime hard 
   

filutz  areces  horrocks    sattler

succs     rx  transpos u ry  transpos
transpos   

u
u

i    n
i    n


 xi  bv bit i  n      u xi  bv bit i  n      u

n i  
n i  
 yi  bv bit   n   
  u yi  bv bit   n   
 

cd a    treex u rn    treey
u r  n      transpos u succs  u xsuccok u ysuccok 
u r  n      label u checkmatch u init 
figure    the alck d    reduction concept cd a  
although  due to its very low expressivity  the concrete domain d  itself is not very natural
for knowledge representation  it is a fragment of many concrete domains that have been
proposed in the literature  baader   hanschke        haarslev   moller        lutz       
    b   indeed  the presented reduction strategy can be adapted to several standard
concrete domains  let us formulate a  very weak  condition that a concrete domain must
satisfy in order for the presented reduction strategy to be applicable 
theorem      let d be a concrete domain  if there exist a  b  d with a    b and p    p  
d such that p d    a  and p d    b   then the satisfiability of path free alck d  concepts
w r t  simple key boxes is nexptime hard 
we now present the second nexptime hardness result for alck d  concept satisfiability 
this time  we reduce the nexptime complete domino problem to the satisfiability of pathfree alck d    concepts w r t  simple unary key boxes  the reduction is very similar to
the previous one and we only discuss the differences 
in the first reduction  we represented the individual bits of grid positions by individual
concrete features xposi and yposi and used a composite key box to ensure that each point
in the torus is represented by at most one element  in the second reduction  we use a single
concrete feature bv and represent an entire position  i  j  in the torus using a bit vector
from the concrete domain d    this allows us to enforce the above mentioned uniqueness of
representations using a unary key box 
the modified reduction concept cd a can be found in figure    where the concepts
treex  treey  distxk   distyk   xsuccok  ysuccok  label  checkmatch  and init are defined
as in figure    the translation of the position in the torus encoded by x            xn   y            yn
into a bit vector is done by the transpos concept in a straightforward manner  given what
was said about the first reduction  it is not hard to see that cd a is satisfiable w r t  the key
box   bv keyfor     iff there exists a solution for d and a  we thus obtain the following
proposition 
proposition      the satisfiability of path free alck d    concepts w r t  simple unary
key boxes is nexptime hard 
again  we relate the nexptime lower bound to the complexity of d   satisfiability  which
is determined in proposition     
   

fikeys  nominals and concrete domains

theorem       there exists a concrete domain d such that d satisfiability is in ptime
and the satisfiability of path free alck d  concepts w r t  simple unary key boxes is nexptime hard 
since the elements of d  are bit vectors  the concrete domain d  cannot be considered a
natural choice for many application areas  but  in the reduction  d  can be replaced by
several natural concrete domains 
the central observation is that we use bit vectors only to injectively translate sequences
of bits into values of the concrete domain  i e   we translate sequences of   n      bits
 represented by the concept names x            xn and y            yn   into elements of d  such
that  for distinct sequences  the results of the translation are also distinct  due to this
restricted use of bit vectors  there are several ways to replace them by natural numbers 
for example  we can replace transpos with the following concept transpos  which ensures
that  for each d  transpos i   si n    d    xpsn d     n    ypsn d  

u


transpos     zero    u
ti    i u  x   s        u  x   s        u
 i      n  


xi   si    zero  si     u xi   si    ti   si     u
i    n



yi n      si    zero  si     u  yi n      si    ti   si    

u
u

i n     n  

n

where zero  si   and ti are concrete features   k  with k    denotes a unary predicate with
the obvious extension  and   denotes a ternary addition predicate such that  intuitively 
the first two arguments are the addends and the third one is the sum 
i
it is easy to check that  whenever two objects d  e  transpos  do not agree on the
interpretation of the x            xn   y            yn   then si n    d     si n    e   and thus the key
box   s n   keyfor     can be used for the reduction  the size of transpos  is obviously
polynomial in n if the numbers k appearing in  k predicates are coded in binary  we thus
obtain the following theorem 
theorem       let d be a concrete domain such that
  

n  d  
n

   d contains  for each k    a predicate  k with   k  d    k  where the size of  the
representation of    k is logarithmic in k  and
   d contains a predicate   with    d    k    k    x    k    k  
  k    k    k    k      k    k     

n

n and x

 d    

then the satisfiability of path free alck d  concepts w r t  simple unary key boxes is
nexptime hard 
for example  this theorem yields nexptime lower bounds for alck d  instantiated with
the concrete domains proposed in  baader   hanschke        haarslev   moller        lutz 
          b   an alternative to the addition predicate is to use multiplication to injectively
   

filutz  areces  horrocks    sattler

translate sequences of bits into natural numbers  more precisely  let p            p n   be the
first  n     prime numbers and define another version of transpos as follows 
transpos      one    u

u
u

i    n

u


ti   pi u  x   s        u  x   s        u
i      n  



xi   si    one  si    u xi   si    ti   si    u



yi n      si    one  si    u yi n      si    ti   si   

i n     n  

where  is a ternary multiplication predicate 
since the factorization of natural numbers into prime numbers is unique  we can again
use the key box   s n   keyfor     for the reduction  moreover  it is well known that the
kth prime is polynomial in k  graham  knuth    patashnik         and thus the size of
the concept transpos   is polynomial in n even if the numbers k in  k predicates are coded
unarily  we thus obtain another theorem concerning quite natural concrete domains 
theorem       let d be a concrete domain such that
  

n  d  

n  a predicate  k with   k  d    k   and
   d contains a predicate  with   d    k    k    x    k    k   n and x
  k    k    k   k      k    k   n  
   d contains  for each k 

 d    

then the satisfiability of path free alck d  concepts w r t  simple unary key boxes is
nexptime hard 
    nexptime hardness of alco d 
as we already pointed out in section    the relationship between key boxes and nominals
is rather close  the latter can be simulated by the former if the concrete domain provides
predicates that can be used to uniquely describe elements of d   for example  in alck d   
the concept g    behaves as a nominal if we use the key assertion  g keyfor     we can
even define n nominals using n single concrete features in unary key assertions  in the
logics alck d    and alck d     a single concrete feature and unary key assertions are
sufficient to simulate an arbitrary number of nominals  for example  in alck d    the
concept c   g bit    u g bit    uniquely describes the bit vector         bv   d    i e  
a  c i implies g i  a            obviously  any other bit vector  of any length   can be
described in a similar way 
this illustrates that  for most non trivial concrete domains d  the logic alck d  is
 at least  as expressive as alco d   although the converse does not hold  the expressive
power of alco d  is still sufficient to prove nexptime hardness of concept satisfiability 
provided that a suitable concrete domain d is used  since alco concept satisfiability is
pspace complete  areces  blackburn    marx         this is yet another example of a dl
where an even seemingly harmless extension with concrete domains has a dramatic effect
on the computational complexity  lutz        
   

fikeys  nominals and concrete domains

nominal    f n
xsucc   
ysucc   

u u x    x  x   u u t x    x  x  
u u y    y  y   u u t y    y  y  

k    n

j    k

k    n

j    k

j

 
k

k

j

 
k

k

k    n

k    n

j

j    k

j    k

j

i    n

i
n  

 
i

i
n  

 
i

i
n  

 
i

i
n  

i jv

u

i    n 

i
n  

i

 
i

i jh

init    

i
n  

i

i
n  

i

i    n

i    n

i
n  

i

i    n



u

 
k

k

u  x  bvx pos    u  x  bvx pos   

transypos    u  y  bvy pos 
  u  y  bvy pos 
 

transxsucc    u  x  bvxs pos 
  u  x  bvxs pos 
 

transysucc    u  y  bvys pos 
  u  y  bvys pos 
 
checkhmatch    t   bvx  bvy  f  darr  tile
u  bvxs  bvy  f  darr  tile
checkvmatch    t   bvx  bvy  f  darr  tile
u  bvx  bvys  f  darr  tile
transxpos   

 
k

k

i
n  

j
n    

i
n  

j
n    

xj u

u

u

xj u
yj
j    n
j    n bitj  i   
j    n bitj  i   

i
  bvx  bvy  f  darr  tilean  



cd a    treex u rn    treey u r  n     nominal u
r  n      transxpos u transypos u
xsucc u ysucc u transxsucc u transysucc u
init  u checkhmatch u checkvmatch 
figure    the alco d    reduction concept cd a  

in this section  we reduce the nexptime complete domino problem to alco d   concept satisfiability  again  let d    t  h  v   be a domino system and a   a            an 
an initial condition  the modified reduction concept cd a is defined in figure    where bvx 
bvy  bvxs  bvys  and darr denote concrete features  n denotes a nominal  and the concepts
treex  treey  distxk   and distyk are defined as in figure    as in the previous reductions 
we now give a detailed explanation of the reduction strategy to show that cd a is satisfiable
iff there exists a solution for d and a  formal details can then easily be worked out by the
interested reader 
let i be a model for cd a   to explain the structure of i  it is convenient to start
with the first line of cd a   as in the previous reductions  the treex and treey concepts
are used to ensure that i contains a tree shaped substructure of depth n     whose leaf
nodes are the roots of additional trees of depth n     such that the set of the leafs of the
   

filutz  areces  horrocks    sattler

treex

treey

   

treey

   

   

f

f

treey

   f

n
darr

figure    the structure of models of cd a  
latter trees correspond to the positions in the  n     n    torus  i e   for each position 
there is a leaf node representing it  the torus positions are binarily encoded by the concept
names x            xn and y            yn and we use ei j to refer to the leaf with xpsn ei j     i and
ypsn ei j     j  see section      
as in the previous reductions  the numbers coded by x            xn and y            yn are
translated into concrete domain values  which is done by the transxpos and transypos
concepts  note that  in contrast to the alck d    reduction  the x position and the yposition are not stored in the same bit vector  but rather in the two distinct ones bvx
and bvy  also in contrast to the previous reduction  the actual tiling of the torus is not
represented by the leaf nodes ei j   but rather by a domino array  the last conjunct in the
first line of cd a ensures that every leaf ei j is connected via the abstract feature f to the
 unique  element w  n i  
the domain element w is associated with a domino array via the concrete feature darr  as
we shall see later  this is guaranteed by the checkhmatch and checkvmatch concepts   this
domino array represents the tiling of the  n     n    torus  summing up  the structure of
i is roughly as shown in figure   
since the tiling is stored in a domino array  we need to explain the purpose of the leaf
nodes ei j   these nodes are used to enforce the initial condition and the horizontal and
vertical matching condition  let us discuss the horizontal matching condition  the vertical
matching condition is enforced analogously   the xsucc concept is the dl reformulation
of the propositional logic formula for incrementation modulo  n   and ensures that  for
each ei j   the concept names x             xn  encode the number i  n      i e   the horizontal
position of ei j s horizontal neighbor  in addition to the storage of the horizontal and vertical
position of ei j in bvx ei j   and bvy ei j    we also store the horizontal position i n     of ei j s
horizontal successor in bvxs ei j    finally  checkhmatch verifies that the tiles at positions
   

fikeys  nominals and concrete domains

 i  j  and  i  n      j   which are both stored in the domino array  are compatible with the
horizontal matching condition 
note that checkhmatch also ensures that the domain element w  with  w    n i   has
a domino array attached via the concrete feature darr and that  for each position  i  j   the
 unique   tile stored in the domino array is from the set t   the initial condition is ensured
via the init  concept in a similar way  we  again  use bitj  i  to denote the jth bit of the
binary encoding of the natural number i 
using the above considerations  the correctness of the reduction is readily checked 
moreover  the size of cd a is at most polynomial in n  note that cd a is not path free 
paths of length two appear in the concepts checkhmatch  checkvmatch  and init   summing
up  the reduction described yields the following result 
proposition       the satisfiability of alco d    concepts is nexptime hard 
again  we relate the nexptime lower bound to the complexity of d   satisfiability  which
is determined in proposition     
theorem       there exists a concrete domain d such that d satisfiability is in ptime
and the satisfiability of alco d  concepts is nexptime hard 
note that the reduction uses only a single nominal n   this is a dramatic increase of complexity since it has been shown that satisfiability of alc d  concepts  i e   without nominals
and key boxes  is pspace complete provided that d is admissible and d satisfiability is in
pspace  lutz      b  
as in previous sections  we note that d  can be replaced by more natural concrete
domains in the nexptime hardness proof presented  the idea is to represent the whole
domino array by a single natural number and then to use arithmetic operations to access the
individual positions  a natural number k can be viewed as a domino array by partitioning
its binary representation into  n     n        n    sections of length dlog  t  e  where
 t denotes the cardinality of the set of tile types t   each such section describes the tile
of a single position in the torus  the sections can be accessed by using integer division
and reminder operations  if k is the natural number representing the torus  then the tile of
posisition i is computed by
 k div  idlog  t  e   mod  dlog  t  e     
thus  we introduce ternary predicates div for integer division and mod for computing the
remainder of a division  and a binary predicate  x expressing exponentiation with basis   
then we modify the reduction as follows  we replace transxpos and transypos by the
transpos  concept from section     to translate the two numbers encoded by x            xn
and y            yn into a single natural number that is stored in the concrete feature s n     we
then devise a new concept tile i   for each i  t   enforcing that the position identified by
the feature s n   is labeled with tile i 
tile i     r  dlog  t  e u s n     r  r    u r    r     x u one    u r  one  t   u t  t    x
u f torus  r     u div u u  t     tile mod u tile  i  
   

filutz  areces  horrocks    sattler

here  r  r    r     t  t    u  one  torus  and tile are concrete features  the torus feature is the counterpart of the darr feature in the original reduction  i e   it stores the natural number that
represents the tiling array  we can use the tile i  concept in the obvious way inside the
checkhmatch  checkvmatch  and init  concepts  the size of the resulting reduction concept
is polynomial in n if the numbers k appearing in  k predicates are coded in binary  we
thus obtain the following theorem 
theorem       let d be a concrete domain such that
  

n  d  

   d contains the predicates a predicate  k  for each k 
the following extensions
  x  d

   k  x    k
   d    k    k    x    k    k 
  d    k    k    x    k    k 
 div d    k    k    x    k    k 
 mod d    k    k    x    k    k 







n and
n and
n and
n and
n and

  k  d
x  d  
x  d  
x  d  
x  d  
x  d  

 
 
 
 
 
 

n    x       div  mod with

 k 
  k   k     k   
  k    k    k    k      k    k    
  k    k    k   k      k    k    
  k    k    k  div k      k    k    
  k    k    k  mod k      k    k    

n

n
n
n
n

then the satisfiability of alco d  concepts is nexptime hard 

   reasoning procedures
this section is devoted to developing reasoning procedures for dls with concrete domains 
nominals  and keys  we start with devising a tableau algorithm that decides the satisfiability
of alcok d  concepts w r t  boolean key boxes  this algorithm yields a nexptime upper
complexity bound matching the lower bounds established in section     
then we consider the rather powerful description logic shoqk d   this dl  which is
an extension of shoq d   horrocks   sattler        pan   horrocks         provides a
wealth of expressive means such as transitive roles  role hierarchies  nominals  and qualifying
number restrictions  moreover  shoqk d  is equipped with a restricted variant of the
concrete domain constructor and with key boxes  we develop a tableau algorithm for
deciding the satisfiability of shoqk d  concepts w r t  path free key boxes  due to the
restrictedness of shoqk d s concrete domain constructor  we can even admit general
rather than only boolean key boxes  again  the algorithm yields a tight nexptime upper
complexity bound 
    a tableau algorithm for alcok d  with boolean key boxes
tableau algorithms decide the satisfiability of the input concept  in our case w r t  the input
key box  by attempting to construct a model for it  more precisely  a tableau algorithm
starts with an initial data structure induced by the input concept and then repeatedly applies so called completion rules to it  this rule application can be thought of as attempting
to construct a model for the input concept  finally  either the algorithm will find an obvious contradiction or it will encounter a situation that is contradiction free and in which no
   

fikeys  nominals and concrete domains

more completion rules are applicable  in the former case  the input concept is unsatisfiable 
while it is satisfiable in the latter 
when devising a tableau algorithm for a description logic with concrete domains but
without committing to a particular concrete domain  it is commonly assumed that the concrete domain is admissible  which implies decidability of the satisfiability of d conjunctions 
in the presence of keys  however  this is not enough  if a d conjunction is satisfiable  we also
want to know which of its variables take the same values in an arbitrary but fixed solution 
as an example  consider the concrete domain n         n   n     and the n conjunction

n

n

c       v         v         v    
obviously  one solution  for c satisfies  v       v     another satisfies  v       v     and so
on  our tableau algorithm uses such identity information passed from the concrete domain
reasoner since  in the presence of key boxes  it can have an impact on the structure of the
constructed model  for example  this information reveals the unsatisfiability of
r a u r  a u b  u r  a u b  u r g    w r t   g keyfor    
to formalize this requirement  we strengthen the notion of admissibility into key admissibility 
since the tableau algorithm developed in this section is non deterministic  we formulate keyadmissibility in a non deterministic way 
definition      key admissible   a concrete domain d is key admissible iff it satisfies the
following properties 
   d contains a name  d for d  
   d is closed under negation 
   there exists an algorithm that takes as input a d conjunction c  returns clash if c is
unsatisfiable  and otherwise non deterministically outputs an equivalence relation 
on the set of variables v used in c such that there exists a solution  for c with the
following property  for all v  v    v
 v     v     iff v  v    
an algorithm showing the behaviour described in item   above is called a d tester  and
the equivalence relations  are called concrete equivalences  we say that extended dsatisfiability is in np if there exists a d tester running in polynomial time 
please note that key admissibility is less esoteric than it might seem  any concrete domain
that is admissible and provides for an equality predicate is also key admissible  due to
admissibility  the presence of an equality predicate implies that an inequality predicate is
also available  we can thus construct a d tester from an algorithm for d satisfiability 
when presented with a predicate conjunction c  we simply guess an equivalence relation
 on the set of variables
used in c  vthen we decide the  non extended  satisfiability of
v
the conjunction c  vv    v  v      v v     v  v      return clash if it is unsatisfiable and
 otherwise  the rather weak condition that an equality predicate should be present is
   

filutz  areces  horrocks    sattler

 c u d 
 r c 

c t d  c t d 
r c
 r c 

 u            un  p  
 g 

c u d
r c

c

c

u            un  p t u   t    t un 
g  d

figure    the nnf rewrite rules 
satisfied by almost all concrete domains proposed in the literature  see  e g   lutz       
baader   hanschke      b  kamp   wache        haarslev  lutz    moller        baader
  sattler         
throughout this chapter  we assume that any concrete domain is equipped with an
equality predicate  this assumption is w l o g  since any d conjunction using equality can
be translated into an equivalent one without equality by identifying variables according to
the stated equalities  this assumption must not be confused with what was discussed in the
previous paragraph  even if the concrete domain d is admissible and its set of predicates is
thus closed under negation  this assumption does not imply the presence of an inequality
predicate 
we need some more prerequisites before we can start the presentation of the tableau
algorithm  a concept is in negation normal form  nnf  if negation occurs only in front of
concept names and nominals  it is easily seen that  if the concrete domain d is admissible 
then every alcok d  concept can be converted into an equivalent one in nnf by exhaustively applying the rewrite rules displayed in figure    we use  c to denote the result of
converting c to nnf  a key box is in nnf if all concepts occurring in key assertions are
in nnf  in what follows  we generally assume input concepts and key boxes to be in nnf 
let c be an alcok d  concept and k a key box  we use sub c  to denote the set of
subconcepts of c  including c itself  and con k  to denote the set of concepts appearing
on the
s right hand side of key assertions in k  for a set of concepts   sub   denotes the
set c sub c   moreover  we write cl c  k  as abbreviation for the set
sub c   sub con k     d
   d  sub con k    
we now start the presentation of the tableau algorithm by introducing the underlying data
structure 
definition      completion system   let oa and oc be disjoint and countably infinite
sets of abstract and concrete nodes  a completion tree for an alcok d  concept c and a
key box k is a finite  labeled tree t    va   vc   e  l  with nodes va  vc such that va  oa  
vc  oc   and all nodes from vc are leaves  the tree is labeled as follows 
 each node a  va is labeled with a subset l a  of cl c  k  
 each edge  a  b   e with a  b  va is labeled with a role name l a  b  occurring in c
or k 
 each edge  a  x   e with a  va and x  vc is labeled with a concrete feature l a  x 
occurring in c or k 
   

fikeys  nominals and concrete domains

for a  va   we use levt  a  to denote the depth at which a occurs in t  starting with the
root node on depth     a completion system for an alcok d  concept c and a key box
k is a tuple  t  p       where
 t    va   vc   e  l  is a completion tree for c and k 
 p is a function mapping each p  d of arity n in c to a subset of vcn  
  is a linear ordering of va such that levt  a   levt  b  implies a  b  and
  is an equivalence relation on vc  
let  va   vc   e  l  be a completion tree  a node b  va is an r successor of a node a  va
if  a  b   e and l a  b    r  while a node x  vc is a g successor of a if  a  x   e and
l a  x    g  for a path u  the notion of u successor is defined in the obvious way 
intuitively  the relation  records equalities between concrete nodes found during the
 non deterministic  model construction process  the recording is necessary since equalities between concrete nodes can induce equalities between abstract nodes which  in turn 
can imply more equalities between concrete nodes  this can be seen in the following example  assume the completion tree contains  for i          an abstract node ai with a
concrete g successor xi and a concrete g    successor yi   now assume that the key box contains  g keyfor     and that the d tester returns x   x    as a consequence  a  and a 
represent the same element and thus functionality of g   implies that also y  and y  represent
the same  concrete  element  to deal with such effects  we define an equivalence relation
a on abstract nodes and a second equivalence relation c on concrete nodes 
definition      a and c relations   let s    t  p      be a completion system for
a concept c and a key box k with t    va   vc   e  l   and let  be an equivalence relation
on va   for each r  nr   a node b  va is an r  neighbor of a node a  va if there exists
a node c  va such that a  c and b is an r successor of c  similarly  for each g  ncf   a
node x  vc is a g  neighbor of a if there exists a node c  va such that a  c and x is a
g successor of c  for paths u  the notion of u  neighbor is defined in the obvious way 
we define a sequence of equivalence relations  a   a     on va as follows 
 a     a  a   va    
  a  b   va    there is an n  no such that n  l a   l b  
i  
  ia 
a
  a  b   va    there is a c  va and an f  naf such that
a and b are f  ia  neighbors of c  
  a  b   va    there is a  u            un keyfor c   k 
ui  ia  neighbors xi of a for    i  n  and
ui  ia  neighbors yi of b for    i  n
such that c  l a   l b  and xi  yi for    i  n  
finally  set a  

s

i
i  a  

then define

c       x  y   vc    there is an a  va and a g  ncf such that
x and y are g a  neighbors of a  
   

filutz  areces  horrocks    sattler

this definition reflects the above mentioned tight coupling between the concrete and abstract equalities  if the d tester finds  or guesses  that two concrete nodes are equal  the
tableau algorithm may use this to deduce  via the computation of a and c   even more
equalities between concrete nodes 
let d be a key admissible concrete domain  to decide the satisfiability of an alcok d concept c  w r t  a boolean key box k  both in nnf   the tableau algorithm is started with
the initial completion tree
tc      a          a     c     
in the initial completion system
sc     tc    p       
where p maps each p  d occurring in c  to   we now introduce an operation that is
used by the completion rules to add new nodes to completion trees 
definition        operation   an abstract or concrete node is called fresh in a completion tree t if it does not appear in t  let s    t  p      be a completion system with
t    va   vc   e  l   we use the following notions 
 let a  va   b  oa fresh in t  and r  nr   we write s  arb to denote the completion
system s   that can be obtained from s by adding b to va and  a  b  to e and setting
l a  b    r and l b      moreover  b is inserted into  such that b  c implies
levt  b   levt  c  
 let a  va   x  oc fresh in t and g  ncf   we write s  agx to denote the completion
system s   that can be obtained from s by adding x to vc and  a  x  to e and setting
l a  x    g 
when nesting the   operation  we omit brackets  writing  for example  s   ar  b   br  c for
 s   ar  b    br  c  let u   f     fn g be a path  when a  va and x  oc is fresh in t 
we use s   aux to denote the completion system that is obtained from s by taking distinct
nodes b            bn  oa which are fresh in t and setting
s   aux    s   af  b         bn  fn bn   bn gx 
strictly speaking  the s   arb operation is non deterministic since we did not specify how
precisely the node b is inserted into   however  since this is dont care non determinism 
we will view the   operation as being deterministic 
the completion rules can be found in figure    note that the rt and rch rules are
non deterministic  i e   they have more than one possible outcome  this is true dont know
non determinism   some further remarks on the completion rules are in order  the upper
five rules are well known from existing tableau algorithms for alc d  concept satisfiability
 see  e g   lutz      a   only the use of r  a  neighbors and u  a  neighbors in the rules
r  r  and rc deserves a comment  take for example r  intuitively  if we have a a b
for two abstract nodes a and b of the completion tree  then a and b describe the same
domain element of the constructed model  and similarly for the c relation on concrete
   

fikeys  nominals and concrete domains

ru

if c  u c   l a  and  c    c      l a 
then l a     l a    c    c   

rt

if c  t c   l a  and  c    c     l a    
then l a     l a    c  for some c   c    c   

r

if r c  l a  and there is no r a  neighbor b of a such that c  l b  
then set s    s   arb for a fresh b  oa and l b      c 

r

if r c  l a   b is an r a  neighbor of a  and c 
  l b 
then set l b     l b    c 

rc

if u            un  p  l a  and there exist no x            xn  vc such that
xi is ui  a  neighbor of a for    i  n and  x            xn    p p  
then set s     s   au  x         aun xn   with x            xn  oc fresh
and p p      p p      x            xn   

rch

if  u            un keyfor c   k and there exist x            xn  vc such that
xi is ui  a  neighbor of a for    i  n and  c  c 

 l a    
then set l a     l a    d  for some d   c  c 


rp

if l b    l a  and a  va is minimal w r t   such that a a b
then set l a     l a   l b 

figure    completion rules for alcok d  
nodes   thus if a a b and c is an r successor of a  then c should also be an r successor
of b  however  since we want the completion tree to be a tree  we do not make the latter
successorship explicit  to compensate for this  the r rule talks about r a  neighbors
rather than about r successors 
the lower two rules are necessary for dealing with key boxes  the rch rule is a
so called choose rule  hollunder   baader        horrocks et al          intuitively 
it guesses whether or not an abstract node a satisfies c if there exists a key assertion
 u            un keyfor c   k such that there are neighbors of a for all the paths ui   this is
necessary since both possibilities may have ramifications  if a satisfies c  then it must be
taken into account in the construction of the relation a   if a does not satisfy c  then we
must deal with the consequences of it satisfying c
  e g  in case that c is    
the rp rule deals with equalities between abstract nodes as recorded by the a relation 
since a a b means that a and b describe the same node in the constructed model  their
node labels should be identical  it suffices  however  to choose one representative for each
equivalence class of a and make sure that this representatives node label contains the
labels of all its a  equivalent nodes  as the representative  we use the node that is minimal
w r t  the ordering   which has been introduced solely for this reason  the rp rule does
the appropriate copying of node labels 
let us now formalize what it means for a completion system to contain a contradiction 
definition      clash   let s    t  p      be a completion system for a concept c and
a key box k with t    va   vc        we say that the completion system s is concrete
   

filutz  areces  horrocks    sattler

define procedure sat s 
do
if s contains a clash then
return unsatisfiable
    test s  
compute a
compute c
while   
  c
if s contains a clash then
return unsatisfiable
if s is complete then
return satisfiable
 
s    the application of a completion rule to s
return sat s    
figure    the alcok d  tableau algorithm 
domain satisfiable iff the conjunction
 
s  

 

p  x            xn   

p used in c  x       xn  p p  

 

  x  y 

xc y

is satisfiable  s is said to contain a clash iff
   there is an a  va and an a  nc such that  a  a   l a  
   there are a  va and x  vc such that g  l a  and x is g a  neighbor of a 
   s is not concrete domain satisfiable 
if s does not contain a clash  s is called clash free  s is called complete iff no completion
rule is applicable to s 
the tableau algorithm is described in figure   in pseudo code notation  in this figure  test
calls a d tester as specified in definition      let us say a few words about the while loop 
there obviously exist close relationships between the relations  and c and the predicate
conjunction s  
   c  note that both a and c depend on  and are thus recomputed in each
step of the while loop  
 by definition of s and d tester  the result of test s   yields a relation containing c
 and thus also   
using these facts  one may check that  in each step of the while loop  new tuples are added
to the  relation  but none are deleted  see the proof of lemma b   in the appendix  
the while loop is needed because  i  a is defined using    ii   c is defined using a  
   

fikeys  nominals and concrete domains

and  iii  new concrete equalities in c may then imply even more concrete and or abstract
equalities  and so on 
a similar concrete abstract interplay takes place in the course of several recursion steps 
equalities between concrete nodes provided by the d tester may make new rules applicable
 for example rp and rc  which changes p and thus also s   this may subsequently lead to
the detection of more equalities between concrete nodes by the d tester  and so on  these
considerations show that  in the presence of keys  there exists a close interplay between the
concrete domain reasoner and the tableau algorithm  which is not needed if keys are not
present  without keys  it suffices to apply the concrete domain satisfiability check only once
after the completion rules have been exhaustively applied  baader   hanschke      a  
the detailed proof of termination  soundness  and completeness together with a complexity analysis of the tableau algorithm defined in this section is given in appendix b 
theorem      let d be a key admissible concrete domain  if extended d satisfiability is
in np  then alcok d  concept satisfiability w r t  boolean key boxes is in nexptime 
we should note that  in the way it is presented here  the algorithm leaves considerable
room for optimizations  one possible optimization concerns the re use of f  successors
 for abstract features f    for example  when applying the r rule to a concept f c  l a  
where a already has an f  successor b  we could simply add c to l b  instead of adding a
new f  successor c and recording that b a c 
another candidate for optimizations is the test function  recall that this function takes a
predicate conjunction c with set of variables v and non deterministically returns a concrete
equivalence  i e   a relation  such that there exists a solution  for c with vi  vj iff
 vi      vj    see definition       it is not hard to devise an alc d  concept that forces
completion systems to have exponentially many concrete nodes by slightly adapting wellknown alc concepts that require models of exponential size  halpern   moses        
hence  the size of input conjunctions c to test can be exponential in the size of the input
concept  even for trivial d conjunctions
c    d  v          d  vk  
we have an exponential number of distinct concrete equivalences   thus  the number of
possible outcomes of a call to the test function may be double exponential in the size of
the input concept  considering the above example  a natural response to this problem is
to require test to return only minimal concrete equivalences  intuitively  an equivalence is
minimal if only those variables are equivalent whose equality is enforced by the conjunction 
more precisely   is called minimal if there exists no concrete equivalence   such that
  x  y    x   y     x  y    x  y   we conjecture that restricting test in this way does
not destroy the soundness and completeness of the tableau algorithm  however  although
this definitely is a worthwhile optimization  it does not help to overcome the existence of
doubly exponentially many outcomes of test in the worst caseat least not for all concrete
domains d  consider the concrete domain n from page     and conjunctions of the form
ci    i  v          i  v i   
it is readily checked that  for each i     the number of minimal concrete equivalences for
ci is exponential in i  moreover  it is not hard to devise a concept ci of size logarithmic
   

filutz  areces  horrocks    sattler

in i that leads to completion systems s such that s   ci   hence  there are still doubly
exponentially many possible outcomes of the test function 
in the example just discussed  the exponential branching of test is clearly due to the
discreteness of the natural numbers  indeed  if we use a dense structure for defining concrete
domains  it seems that the restriction to minimal concrete equivalences can have the desired
effect  namely that the number of tests possible outcomes becomes polynomial in the size
of its input and thus exponential in the size of the input concept  for example  consider
the concrete domain q  which is defined as follows 
 q is the set

q of rational numbers 

 q contains unary predicates  q and its negation q   unary predicates  q and   q
for each q    binary comparison predicates                    a ternary addition
predicate    and its negation    all with the obvious semantics  

q

it is readily checked that q is key admissible  note that it provides a binary equality predicate  and thus falls into our framework  we conjecture that there exists only one minimal
concrete equivalence for every q predicate conjunction c  intuitively  it seems possible to
 inductively  determine a relation  on the set of variables v used in c such that  i  x  y
implies that  x     y  for every solution  for c and  ii  there exists a solution  for c such
that v   v   implies  v      v      clearly   is a minimal concrete equivalence  moreover 
due to  i  it is the only one 
    a tableau algorithm for shoqk d 
although alcok d  is a quite powerful dl  it lacks several expressive means that can be
found in most state of the art description logic systems such as fact and racer  horrocks 
      horrocks et al         haarslev   moller         in this section  we consider the
very expressive description logic shoqk d  which provides for concrete domains  key
boxes  and nominals  but also for many other means of expressivity such as transitive
roles  role hierarchies  qualifying number restrictions  and general tboxes  modulo some
details  shoqk d  can be viewed as the extension of the dl shoq d  with key boxes 
shoq d  was proposed by horrocks and sattler         see also pan   horrocks       
as a tool for ontology reasoning in the context of the semantic web  berners lee  hendler 
  lassila        baader et al       a  
one very important feature of shoqk d  are so called tboxes  i e  concept equations 
 
of the form c   d that are used as a background theory in reasoning  since it is wellknown that combining general tboxes and the concrete domain constructor easily leads
to undecidability  baader   hanschke        lutz         shoqk d  only offers a pathfree variant of the concrete domain constructori e  only concrete features are admitted
inside this constructor rather than paths of arbitrary length  this restriction indeed regains
decidability  haarslev et al         horrocks   sattler         path freeness of the concrete
domain constructor obviously renders abstract features unnecessary  and thus this syntactic
type is not available in shoqk d  
   some tbox formalisms also allow for concept inclusions c v d  but these can be re written into
equivalent equations  see section         of  baader et al         

   

fikeys  nominals and concrete domains

      the description logic shoqk d 
let us now define shoqk d  in a formal way  starting with the syntax 
definition      shoqk d  syntax   a role axiom is either a role inclusion  which is of
the form r v s with r  s  nr   or a transitivity axiom trans r  where r  nr   a role
box r is a finite set of role axioms  let v
  be the reflexive transitive closure of the role
inclusions in r  a role name r is called simple if s v
  r implies trans s  
  r for all role
names s  let d be a concrete domain  the set of shoqk d  concepts is the smallest set
such that
 every concept name and every nominal is a concept  and
 if c and d are concepts  r is a role name  s a simple role name  n and k are natural
numbers  g            gn are concrete features  and p  d is a predicate of arity n  then
the following expressions are also concepts 
c  c u d  c t d  r c  r c     k s c      k s c   g            gn  p  and g   
 
a concept equation is an expression c   d with c and d concepts  a tbox is a finite set
of concept equations 
for shoqk d   we consider key boxes that differ in two aspects from the ones we considered for alcok d   in the following  we assume key boxes to be path free  but we admit
complex concepts to occur in key assertions  note that abstract features and paths do
not occur in the syntax of shoqk d as will become clear after the semantics has been
defined  the former can be simulated by the more general number restrictions    n r c  
as usual in description logics of the shiq shoq family  we require role names in
number restrictions to be simple since admitting arbitrary roles yields undecidability of
reasoning  horrocks et al         horrocks   sattler         if the role box r is clear from
the context  we will usually write trans r  instead of trans r   r  we now introduce the
semantics of shoqk d  and the relevant reasoning problems 
definition      shoqk d  semantics   interpretations i    i   i   are defined as in
definition      where the function i is extended to the novel shoqk d  concepts as
follows 
   k r c i     d  i     e    d  e   ri    k  and
   k r c i     d  i     e    d  e   ri    k  
 
let i be an interpretation  then i satisfies a concept equation c   d if c i   di   i is
a model of a tbox t if i satisfies all concept equations in t   similarly  i satisfies a role
inclusion r v s if ri  s i and a transitivity axiom trans r  if ri is a transitive relation 
i is a model of a role box r if i satisfies all role inclusions and transitivity axioms in r 
let t be a tbox  r a role box  and k a key box  a concept c is satisfiable w r t  t  
r  and k iff c  t   r  and k have a common model  c is subsumed by a concept d w r t 
t   r  and k  written c vt  r k d  iff c i  di for all common models i of t   r  and k 
   

filutz  areces  horrocks    sattler

note that  due to the requirement that role names used inside number restrictions should be
simple  existential and universal value restrictions are not just syntactic sugar  in contrast
to number restrictions  they can be used on all roles 
it is well known that  in many expressive description logics  reasoning with tboxes
can be reduced to reasoning without them  schild        horrocks   sattler         for
shoqk d   a concept c is satisfiable w r t  t   r  and k iff the concept
r c u r 

u


de u
 
d et

u

r n



nominal n used
in c  t   or k

is satisfiable w r t  to r    k  and the empty tbox  where r is a fresh role not appearing in
c  r  and t   and
 
 s v r  
r     r   trans r   
role name s used
in c  t   r  or k

since subsumption can be reduced to satisfiability as described in section    in the following
we will only consider satisfiability of concepts w r t  role boxes and key boxes  but without
tboxes  we will also generally assume role boxes r to be acyclic  i e  to satisfy the following
condition  for each role name r  there are no role names r            rk such that r   r    rk
and ri v ri    r for    i   k  it is not hard to see that this is not a restriction since
cycles can be eliminated  if r            rk is a cycle in r  then we have r i        rki
for all interpretations i  thus we can simply remove the cycle from r and replace every
occurrence of r            rk in c  r  and k with r    and add trans r    if  before the cycle
elimination  we had trans ri   for some i with    i  n 
before we turn our attention to the construction of a tableau algorithm for shoqk d  
let us comment on a few minor differences between shoqk d  as introduced here and
the original version of shoq d  as described in  horrocks   sattler         the main
difference is that our logic  like the extensions investigated in  haarslev et al         pan  
horrocks         allows n ary predicates while horrocks and sattler restrict themselves to
unary predicates  moreover  shoq d  as introduced in  horrocks   sattler        uses
concrete roles rather than concrete features  the difference being that concrete roles are not
necessarily functional  due to this non functionality  the original shoq d  admits two
variants t p and t p of the concrete domain constructor  where t is a concrete role and
p a unary predicate   in shoqk d   we can simulate the universal variant by writing
g p t g since concrete features g are interpreted as partial functions and  in contrast to
horrocks and sattler  we have the undefinedness constructor g available  except for the
n ary predicates which provide important additional expressivity  we view these deviations
as minor ones since it is easy to see that they do not affect decidability and complexity of
reasoning 
      a tableau algorithm for shoqk d 
the basic intuitions of the shoqk d  tableau algorithm are similar to the alcok d 
algorithm  with one exception  to deal with the various expressive means of shoqk d  
   

fikeys  nominals and concrete domains

   n r c 
     r c 
   n r c 

    n     r c  if n   

    n      r c 

figure     the shoqk d  nnf rewrite rules 
it is convenient to introduce a certain abstraction of models  so called tableaux  the main
difference between tableaux and models is that  in tableaux  roles declared to be transitive
are not necessarily described by transitive relations  we show that there exists a tableau
for a given concept and key box if and only if they have a common model  the aim of the
shoqk d  algorithm is then to construct a tableau for its input rather than trying to
construct a model  to do this  the algorithm employs completion forests as its underlying
data structure 
we first introduce tableaux  let us start by discussing some preliminaries  as for
alcok d   we assume all concepts and key boxes to be in nnf  i e  negation occurs only
in front of concept names and nominals  we again use  c to denote the nnf of c  the
additional nnf rewrite rules for shoqk d  can be found in figure    and complete those
given for alcok d  in figure   
for a concept d  role box r  and key box k  we define
cl d  k     sub d   sub con k     c
   c  sub d   sub con k   
cl d  r  k     cl d  k    r c   r v
  s and s c  cl d  k   
obviously  the cardinality of cl d  r  k  is linear in the size of d  r  and k  in what
d k
to denote the set of role names occurring in d  r  or k  and ncf
follows  we write nd r k
r
to denote the sets of concrete features occurring in d or k  we are now ready to define
tableaux 
definition      tableau   let d be a shoqk d  concept in nnf  r a role box  and k
a path free key box in nnf  a tableau t for d w r t  r and k is a tuple  sa   sc   l  e  e  p 
such that
 sa   sc are sets of abstract and concrete individuals 
 l   sa   cl d r k  maps each abstract individual to a subset of cl d  r  k  
d r k

 e   sa  sa   nr

maps pairs of abstract individuals to sets of roles 

 e   sa nd k
cf  sc maps pairs of abstract individuals and concrete features to concrete
individuals 
 p maps each n ary concrete predicate in cl d  r  k  to a set of n tuples over sc  
 there is an abstract individual s   sa such that d  l s     and
for all s  t  sa   c  c    c   cl d  r  k   r  s  nd r k
  and for
r
s t  s  c      t  sa   s  e s  t  and c  l t   
it is the case that 
   

filutz  areces  horrocks    sattler

 t   if c  l s   then  c 
  l s  
 t   if c  u c   l s   then c   l s  and c   l s  
 t   if c  t c   l s   then c   l s  or c   l s  
 t   if r  e s  t  and r v
  s  then s  e s  t  
 t   if r c  l s  and r  e s  t   then c  l t  
 t   if r c  l s   then there is some t  sa such that r  e s  t  and c  l t  
 t   if s c  l s  and r  e s  t  for some r v
  s with trans r   then r c  l t  
 t   if    n s c   l s   then  s t  s  c    n 
 t   if    n s c   l s   then  s t  s  c    n 
 t    if either    n s c   l s  and s  e s  t  or  g            gn keyfor c   k and e t  gi  
is defined for all    i  n  then  c   c   l t      
 t    if n  l s   l t   then s   t 
 t    if g            gn  p  l s   then there are x            xn  sc with e s  gi     xi and
 x            xn    p p   
v
v
v
 t    p used in d k  x       xn  p p   p  x            xn    x  y x    y is satisfiable 
 t    if  g            gn keyfor c   k  c  l s   l t   and e s  gi     e t  gi   for all    i  n 
then s   t 
 t    if g  l s   then e s  g  is undefined 
note that the predicate conjunction in  t    uses a binary inequality predicate  in general 
we do not require the concrete domain d to be equipped with such a predicate and thus this
predicate conjunction is not necessarily a d conjunction  however  it is nevertheless safe
to use  t    in the given form since tableaux are only used in proofs and we do not need
a concrete domain reasoner that is capable of deciding the satisfiability of this conjunction 
the following lemma  whose proof is provided in appendix c  shows that our definition of
tableaux provides an adequate abstraction of models 
lemma      let d be a shoqk d  concept in nnf  r a role box  and k a key box in
nnf  then d is satisfiable w r t  r and k iff d has a tableau w r t  r and k 
given lemma      in order to decide satisfiability of shoqk d  concepts w r t  role and
key boxes  we may use a  tableau  algorithm that tries to construct a tableau for the input 
in the following  we will describe such an algorithm in detail 
as in the previous section  the algorithm works on completion systems  however  in
the case of shoqk d  the core component of completion systems is a completion forest
rather than a completion tree  the reason for this is that some completion rules remove
nodes and edges from the completion system and in this way can disconnect one tree into
two subtrees 
   

fikeys  nominals and concrete domains

definition      completion system   let d be a shoqk d  concept in nnf  r a role
box  and k a path free key box in nnf  for each concept    n r c   cl d  r  k  and
   i  n  we reserve a concept name anrc
not appearing in cl d  r  k  and define an
i
extended closure
nrc
cl   d  r  k     cl d  r  k    anrc
     n r c   cl d  r  k   
            an

let oa and oc be disjoint and countably infinite sets of abstract and concrete nodes  a
completion forest for d  r  and k is a finite forest f    va   vc   e  l  with nodes va  vc
such that va  oa   vc  oc   and all nodes from vc are leaves  the forest is labelled as
follows 
 each node a  va is labelled with a subset l a  of cl   d  r  k  
 each edge  a  b   e with a  b  va is labeled with a non empty set of role names
l a  b  occurring in d  r  or k  and
 each edge  a  x   e with a  va and x  vc is labeled with a concrete feature l a  x 
occurring in d  r  or k 
a completion system for d  r  and k is a tuple s    f  p  c     such that
 f    va   vc   e  l  is a completion forest for d  r  and k 
 p maps each n ary concrete predicate in cl d  r  k  to a set of n tuples in vc  
 c is an equivalence relation on vc   and
  is a linear ordering on va  
a node t  va is called an r successor of a node s  va if  for some r  with r  v
  r  we have
r   l s  t   a node x  vc is called a g successor of a node s  va if l s  x    g  finally 
 
we write s  
  t if s and t are r successors of the same node and there is some anrc
 l s 
i
nrc
and aj
 l t  with i    j 
some remarks are in order here  firstly  in contrast to the alcok d  case  the relation
 is no longer required to respect the level of a node  this is due to the fact that  a 
we have to enforce termination artificially and the mentioned property of  was used to
ensure automatic termination  and  b  the level of a node might change since a node
might become a root node because some completion rules will remove nodes and edges 
secondly  the relation c will be returned by a d tester  and is used to compute a
relation a which is then used by the tableau algorithm  however  we do not need to
compute the relation c from a as in the alcok d  case since all concepts and key
boxes are assumed to be path free 
thirdly  the new concept names anrc
will be used to ensure that successors of a node
i
x generated for some    n r c   l x  will not be merged later due to a concept   
n  r c      l x   each generated successor is labelled with a different concept anrc
 
i
since merging two nodes means unifying their node labels  it then suffices to disallow the
   

filutz  areces  horrocks    sattler

occurrence of distinct concepts anrc
in the same node label through a suitable definition
i
of clash 
since shoqk d  provides for transitive roles  we need some cycle detection mechanism
in order to guarantee termination of our algorithm  roughly speaking  if we encounter a
node which is similar to an already existing one  then this node does not need to be
further explored  speaking in terms of  horrocks et al         baader   sattler         we
employ a mechanism called subset blocking 
definition       blocked   let  be the reflexive closure of   a node t  va is blocked
by a node s  va if l t   l s   and s  s    for all s  with l t   l s    
note that  unlike to what is done  e g   in  horrocks et al          the blocking node is not
necessarily an ancestor of the blocked node  but can be anywhere in the forest  it may even
be that blocked nodes have unblocked successors  this modification is used later to obtain
a nexptime upper bound 
to decide the satisfiability of an alcok d  concept d w r t  a role box r and a pathfree key box k  where d and k are in nnf   the tableau algorithm is started with the
initial completion system
sd    fd   p        where
fd     s          s     d    and
p
maps each p  d occurring in d and k to  
then the algorithm repeatedly applies completion rules  before the actual rules are given 
we introduce some new notions  firstly  we define the equivalence relation a over va as
follows  s a t if one of the following conditions is satisfied 
 n  l s   l t  for some nominal n or
  g          gn keyfor c   k  c  l s l t   and there are xi   yi such that gi  e s  xi  
e t  yi   and xi c yi for    i  n 
intuitively  two abstract nodes related via the a relation describe the same individual in
a tableau 
secondly  we use the following abbreviations in the formulation of the rules  written in
italic  
 to remove an abstract node s and all its incoming and outgoing edges  remove s from
va and each  s  t  and  t  s  from e for all t  va  vc  
 adding a g successor of an abstract node s means doing nothing if there exists a
g successor x  vc of s and  otherwise  adding e s  x    g for some x  oc that does
not yet occur in the completion forest 
 to update the relation c   a d tester is asked to decide the satisfiability of the dconjunction
 
 
s   
p  x            xn   
x y
p used in d k
 x       xn  p p  

xc y

and returns  in case that this conjunction is satisfiable  an updated concrete equivalence c as defined in definition     
   

fikeys  nominals and concrete domains

concerning the predicate conjunction used in updates  recall that we can w l o g  assume
the concrete domain to contain an equality predicate as discussed after definition     
the completion rules are given in figure     we generally assume that new nodes x
are introduced into the completion forest such that y  x for all already existing nodes y 
before further describing the tableau algorithm  we comment on the completion rules  the
rules rt  r   rc  and rch are non deterministic  i e   their application has more than one
possible outcome  for the rc rule  this is due to the update operation performed on c
using the d tester  as discussed at the end of section      computing a concrete equivalence
for a given d conjunction may result in a high degree of non determinism  please note that 
in contrast to alcok d   we now only need to call the d tester in this ruleand not after
each rule application 
next  the ra rule takes care of abstract nodes related via a   since all the nodes from
a a  equivalence class denote the same individual  we choose only one representative whose
node label contains the labels of all other nodes in the class  this representative simply
is the  minimal node of the equivalence class and the ra rule performs the appropriate
copying of node labels 
the r  rule is the only rule to remove nodes and edges  it removes a surplus r successor
t of a node s with    n r c   l s   since the subtree below t is not removed  ts successors
are new  additional root nodes  this behavior is the reason why we work on a completion
forest 
as in the alcok d  case  the tableau algorithm stops applying rules if it finds an
obvious contradiction  a clash  or if no more completion rules are applicable 
definition       clash   let s    f  p  c     be a completion system for d  r and k 
and f    va   vc   e  l   then s is said to contain a clash if one of the following conditions
applies 
 c   for some concept name a  nc and some node s  va    a  a   l s  
 c   the d conjunction s defined above is not satisfiable 
 
 c   s  
  s for some s  va  
 c   for some s  va and g  ncf   we have g  l s  and s has a g successor 
a completion system not containing a clash is called clash free  the completion system is
complete if none of the completion rules is applicable 
due to the simplicity of the algorithm  we refrain from describing it in pseudo code notation  the algorithm starts with the initial completion system and then repeatedly applies
the completion rules  checking for clashes after each rule application  if a clash is detected  it returns unsatisfiable  if a complete and clash free completion system is found 
then the algorithm returns satisfiable  note that  since some of the completion rules are
non deterministic  the algorithm is also non deterministic 
details of the proof of termination  soundness  and completeness are given in appendix c  unfortunately  we have to leave the complexity of the algorithm as an open
problem  it is not hard to prove that it runs in double exponential time  but it is not clear
whether exponential time also suffices  however  we can still use the algorithm to obtain a
   

filutz  areces  horrocks    sattler

ru

if c  u c   l s   s is not blocked  and  c    c      l s  
then l s     l s    c    c   

rt

if c  t c   l s   s is not blocked  and  c    c     l s     
then l s     l s    c  for some c   c    c   

r

if r c  l s   s is not blocked  and s has no r successor t with c  l t 
then create a new node t such that t   t for all t   va
and set e s  t      r  and l t      c 

r 

if    n s c   l s   s is not blocked  and there are no n s successors
 
t            tn of s with c  l ti   and ti  
  tj for    i   j  n 
then create n new nodes t            tn s t  t   ti for    i  n and all t   va  
and set e s  ti       s  and l ti       c  ansc
  for    i  n
i

r 

if    n s c   l s   s is not blocked  s has n     s successors t            tn
with c  l ti   for    i  n 
then choose i  j such that ti  tj   set l ti      l ti    l tj   
l s  ti      l s  ti    l s  tj    and remove tj and all its incoming
and outgoing edges

rc

if g            gn  p  l s   s is not blocked  and
there are no gi  successors xi with  x            xn    p p  
then add a gi  successor of s for each    i  n 
for yi the gi  successor of s  add  y            yn   to p p    and
update c

r

if r c  l s   s is not blocked  and
there is an r successor t of s with c 
  l t  
then l t     l t    c 

r 

if s c  l s   s is not blocked  there is some r with
trans r  and r v
  s  and an r successor t of s with r c 
  l t  
then l t     l t    r c 

rch

if s is an s successor of s  and    n s c   l s    or
s has gi  successors xi for all    i  n and  g          gn keyfor c   k and
s is not blocked and  c   c   l s     
then l s     l s    e  for some e   c   c 

ra

if s a t  l t    l s   s  t  and s is not blocked 
then set l s     l s   l t 
figure     the completion rules for shoqk d  

   

fikeys  nominals and concrete domains

tight complexity bound for shoqk d   the following corollary is an easy by product of
the correctness proofs  for a proof see again appendix c  
corollary      if a shoqk d  concept d is satisfiable w r t  a role box r and a path free
key box k  then d is satisfiable w r t  r and k in a model of size at most  i     m for
m     cl   d  r  k  
thus the following is an alternative algorithm for deciding satisfiability of a shoqk d concept d w r t  a role box r and a path free key box k  first  guess an interpretation
i with cardinality of i bounded by  m   using placeholder variables from oc instead of
concrete values in the interpretation of concrete features  let vc be the set of variables
from oc occuring in i  additionally guess an interpretation p for the concrete domain
predicates  just as in completion forests  p maps each n ary concrete predicate used in d or
k to an n ary relation on vc   then perform standard  polynomial time  model checking to
ensure that i is a model of d  in doing this  treat concepts of the form g            gn  p using
the interpretation of predicates p  it is easily checked in polynomial time that i is also a
model of r and kfor the latter  assume that all placeholder variables stand for different
values  finally  use the concrete domain d tester to check whether the conjunction
 
p  x            xn  
p used ind k
 x       xn  p p  

is satisfiable  answer yes if it is and no otherwise  since this algorithm can clearly be
implemented in nexptime provided that there is a d tester running in non deterministic
polynomial time  we obtain the following 
theorem      let d be a key admissible concrete domain such that extended d satisfiability
is in np  then shoqk d  concept satisfiability w r t  tboxes  role boxes  and path free
key boxes is in nexptime 

   conclusion
in this paper  we have identified key constraints as an interesting extension of description
logics with concrete domains  starting from this observation  we introduced a number of
natural description logics and provided a comprehensive analysis of the decidability and
complexity of reasoning  the main observation of our investigations is that key boxes can
have dramatic consequences on the complexity of reasoning  for example  the pspacecomplete dl alc d  becomes nexptime complete if extended with path free  unary 
boolean key boxes and undecidable if extended with path free  unary  non boolean key
boxes  thus the effect of our key boxes on the complexity are quite different from the effect
of key assertions where only abstract features are allowed  calvanese et al          these
abstract key assertions can be said to be for free since they do not increase the complexity
for expressive description logics 
we show that the restriction to boolean key boxes  in the alcok d  case  and to
path free key boxes  in the shoqk d  case  yield decidabile and nexptime complete
reasoning problems  we selected alc d  and shoq d  as the basis for our analysis since 
   

filutz  areces  horrocks    sattler

in our opinion  these are the most fundamental description logics with concrete domains 
going one step further  it would be interesting to combine key boxes with other extensions
of concrete domains  such as the ones presented by lutz               to name only one
possibility  the extension of both alcok d  and shoq d  with inverse roles seems to
be a natural idea  note that inverse roles interact with several of the available means of
expressivity  while alc with inverse roles is pspace complete  horrocks  sattler    tobies 
       alco with inverse roles is exptime complete  areces et al         and alc d 
with inverse roles even nexptime complete  lutz        
other options for future research are more closely related to the material presented in
this paper  for example  is shoqk d  concept satisfiability still decidable if we drop
the requirement of key boxes to be path free  moreover  we had to leave the exact time
requirements of our tableau algorithm as an open problem  if this algorithm runs in  nondeterministic  exponential time  it directly yields theorem     rather than via a bounded
model property 

acknowledgments
we would like to thank the anonymous reviewers for valuable comments  this paper is an
extended version of  lutz  areces  horrocks    sattler        

appendix a  proofs of section    
we prove that d   satisfiability can be decided in ptime 
proposition a    d   satisfiability is in ptime 
proof  let c be a d   conjunction  we show that c is satisfiable iff none of the following
conditions applies 
   c contains a conjunct d   x  
   c contains conjuncts bit ik  x  and bit ik  x  
   c contains conjuncts bitnik  x  and bitmj   x  with k      
   c contains conjuncts bitnik  x  and bitnik  x  
   c contains conjuncts bitnik  x   bit jk  x   and bit jk  x  
it is easily seen that c is unsatisfiable if one of the conditions applies  assume now that
conditions   to   do not apply to c and let x be the set of variables used in c  for each
x  x  set t x    k if bitnik  x   c for some n  i     if bitnik  x  
  c for all n  i  k    then
set t x    r for some r not appearing as an index r to a predicate in c  the mapping t is
well defined since c is finite  condition   does not apply  and the only predicates available
are bitnik     d      and  d      we define a solution  for c as follows  for each x  x  set
 x  to the bit vector v  bvt x  in which the ith bit is   if bit it x   x   c or bit it x   x   c 
and   otherwise  it remains to prove that  is indeed a solution for c 

n

   we use p  x   c as an abbreviation for p  x  is a conjunct in c 

   

n

fikeys  nominals and concrete domains

 let bit ik  x   c  then t x    k and thus  x   bvk   since condition   does
  c  moreover  non applicability of condition   implies
not apply  we have bit ik  x  
i
  c  by definition of   the ith bit of  x  is thus   
bit k  x  
 let bit ik  x   c  then t x    k and  x   bvk   by definition of   the ith bit of
 x  is   
 let bit ik  x   c  if t x     k  then  x  
  bvk   thus  x    bit ik  d  and we are
done  if t x    k  then the ith bit of  x  is   by definition of  and thus again
 x    bit ik  d   
  bvk and we are done  if t x    k  then
 let bit ik  x   c  if t x     k  then  x  
j
bitnk  x   c for some n  j    since condition   does not apply  we thus have

n

  c  thus  by

  c  moreover  non applicability of condition   yields bit ik  x  
definition of   the ith bit of  x  is   

bit ik  x 

it is obvious that the listed properties can be checked in polynomial time 

appendix b  proofs of section    
we prove termination  soundness  and completeness of the alcok d  tableau algorithm
presented in section      starting with termination  we start with establishing a few notions
and technical lemmas 
let c be a concept and k a key box  we use  c  to denote
p the length of c  i e  the
number of symbols used to write it down  and  k  to denote  u       uk keyfor c k  c   for
a path u   f     fk g  we use  u  to denote k      the role depth of concepts is defined
inductively as follows 
rd a    rd n     rd g     
rd u            un  p     max  ui        i  n    
rd c u d    rd c t d    max rd c   rd d  
rd r c    rd r c    rd c      
the following series of lemmas will eventually allow us to prove termination 
lemma b    there is a constant k such that  if the tableau algorithm is started on input
c    k and t    va   vc   e  l  is a completion tree constructed during the run of the algorithm 
k
k
then  va    c    and  vc    c     
proof  using induction on the number of rule applications and a case distinction according
to the applied rule  it is straightforward to show that
c  l a  implies rd c    c     levt  a 

  

for all constructed completion trees t  we omit the details but note that      for treating
the rch rule  one needs to employ the fact that k is boolean and thus only adds concepts
of role depth   to node labels  and     for treating the rp rule  we use that a  b implies
levt  a   levt  b  
   

filutz  areces  horrocks    sattler

this implies an upper bound on the depth of constructed completion trees  first  only
the r and rc rules generate new nodes  and an application of either rule to a node
a  va implies l a      and thus levt  a    c    by     second  each new  abstract or
concrete  node b generated by an application of these rules to a node a  va clearly satisfies
levt  b   levt  a    max    mpl c      where mpl c    denotes the maximum length of paths
in c   note that concepts in k may not contain any paths since it is boolean   since
mpl c      c     the above observations imply that the depth of constructed completion
trees is bounded by     c    
now for the out degree  if a node a is generated  then this is due to the application of
a rule r or rc and  initially  a has at most one successor  let us analyze the number
of successors generated by later applications of the rules r and rc to a  these rules
can be applied at most once for each concept of the form r c or u            un  p in l a  
by definition of cl c    k  and since k is boolean  the number of such concepts per node
label is bounded by  sub c      c     moreover  each rule application creates at most  c   
successors  hence  the out degree of constructed completion trees is bounded by  c         

lemma b    there is a constant k such that  if the tableau algorithm is started with c    k 
k
then  in every recursion step  the while loop terminates after at most   c    steps 
proof  fix an argument s    t  p      with t    va   vc   e  l  passed to the sat function 
let               be the sequence of concrete equivalences computed in the while loop  and let
 c    c         be the corresponding c relations  since test s   calls a d tester  each of these
calls indeed terminates 
we show that
            
  
k

which implies lemma b    by lemma b    there exists a constant k such that  vc    c     
k
hence  we have  i     c    which  together with     implies that the number of steps
k
performed by the while loop is also bounded by    c     
now for the proof of     if the while loop reaches the i th step  then we had i     i 
c
after step i     since i   i 
by definition  this implies i    ci    by definition
c
of s   it is easy to see that i 
 i for i     hence i    i  
c
lemma b    there is a constant k such that  if the tableau algorithm is started with c    k 
k
then the number of recursive calls is bounded by    c     k    
proof  it obviously suffices to establish an appropriate upper bound on the number of rule
applications  the ru  rt  r  and rc rules can be applied at most once for each concept
in a node label  by lemma b    the number of nodes is at most exponential in  c       k  
since neither nodes nor concepts in node labels are ever deleted  the fact that node labels
are subsets of cl c    k  thus implies that the number of applications of these rules is at most
exponential in  c       k   the same holds for the rules r and rp  which can be applied
at most once for every concept c  cl c    k  and every pair of  abstract  nodes  finally 
the number of rch applications is at most exponential in  c       k  since this rule can be
applied at most once for every abstract node and every key assertion in k 
   

fikeys  nominals and concrete domains

termination is now an obvious consequence of lemmas b   and b   
corollary b    termination   the tableau algorithm terminates on any input 
let us now prove soundness of the algorithm 
lemma b    soundness   if the tableau algorithm returns satisfiable  then the input concept
c  is satisfiable w r t  the input key box k 
proof  if the tableau algorithm returns satisfiable  then there exists a complete and clashfree completion system s    t  p      for c    let t    va   vc   e  l   by definition of
the tableau algorithm  there is a completion system s      t  p        such that a call to
test s     returned   moreover  we have    c in s  thus  there exists a solution  for
s   such that
 x     y  iff x c y 
  
 
clearly   is also a solution for s   since
  the second
  component p is the same in s and s  
 is a solution for the first part
p  x            xn   of s   moreover  for
p used in c  x       xn  p p  

each conjunct   x  y  from the second part of s   we have x c y by definition of s and
thus  x     y  by    
we now use s and  to construct an interpretation i by setting
i

   a  va   there is no b  va such that a a b and b  a    w 

ai

   a  i   a  l a  

 a  i   n  l a   if there is an a  i such that n  l a 
 
 w 
otherwise

ni
ri

    a  b   i  i   there are a    b   va such that a a a    b a b    and
b  is an r successor of a   

gi

    a   x    i  d   x is a g a  neighbor of a 

for all a  nc   n  no   r  nr   and g  ncf   we first show that i is well defined 
 n i is a singleton for each n  no   assume that there exist a  b  i such that a    b
and n  l a   l b   by definition of a  definition       n  l a   l b  implies
a a b  this  together with a  b  i   yields a  b and b  a  contradicting  being
a linear ordering 
 f i is functional for each f  naf   assume that there exist a  b  c  i such that
  a  b    a  c    f i and b    c  then there exist a    a    b    c   va such that a a a  a
a    b a b    c a c    b  is an f  successor of a    and c  is an f  successor of a    by
definition of a   we thus have b  a c  implying b a c  since b  c  i   this yields
b  c and c  b  a contradiction 
 g i is functional for each g  ncf   assume that there exist an a  i and x  y  vc
such that   a   x     a   y     f i and  x      y   then x and y are both g a neighbors of a  by definition of c   we thus have x c y implying  x     y  by    
a contradiction 
   

filutz  areces  horrocks    sattler

now we show the following claim  in the proof  we use the notion of f     fk  a  neighbors
 with f          fk abstract features   which is defined analogously to u a  neighbors for paths u 
claim    for all a  i and all paths u  we have ui  a     iff there is a ui   a  neighbor
x of a with  x     
proof  let u   f     fk g  using induction on i it is easily proved that  for all i and all
b  i   we have fii      f i  a          b iff there is a f     fi  a  neighbor b  of a with
b a b    thus we have in particular that fki      f i  a          b iff there is an f     fk  a neighbor b  of a with b a b    to prove the claim  it hence remains to use the definition
of g i together with    
the following claim is central for showing that i is a model for c  and k 
claim    for all a  i and c  cl c    k   if c  l a   then a  c i  
since c  is in the label of the root node  claim   clearly implies that i is a model for c   
moreover  we can use it to prove that i satisfies all key assertions  u            un keyfor c  in
k  fix a  b  c i such that uii  a    uii  b  for    i  n  non applicability of rch yields
 c   c   l a       if  c  l a   then claim   implies a    c i in contradiction to
a  c i   thus we obtain c  l a   in an analogous way  we can argue that c  l b   since
uii  a  and uii  b  are defined for    i  n  claim   yields that a has a ui  a  neighbor xi
with  xi     uii  a  and b a ui  a  neighbor yi with  yi     uii  b  for    i  n  thus the
fact that uii  a    uii  b  yields  xi      yi   for    i  n  by    we obtain xi c yi and
thus xi  yi for    i  n  by definition of a   we thus get a a b  since a  b  i   we
obtain a   b and b   a by definition of i and thus a   b 
it remains to prove claim    which we do using structural induction 
 c is a concept name or a nominal  easy by construction of i 
 c   d  since c  cl c    k   c is in nnf and d is a concept name  since s is
clash free  c  l a  implies d 
  l a   thus  a 
  di by construction of i  which
i
yields a   d   
 c   u            un  p   since the rc rule is not applicable  there exist x            xn  vc
such that xi is a ui  a  neighbor of a for    i  n and  x            xn    p p    claim  
yields uii  a     xi   for    i  n  since  x            xn    p p   and  is a solution for
s   we have   x              xn     p d and thus a  c i  
 c   g  since s is clash free  there exists no x  vc such that x is g a  neighbor of
a  thus by claim   there is no  such that  a     g i  
 c   d u e or c   d t e  straightforward using completeness and the induction
hypothesis 
 c   r d  since the r rule is not applicable  a has an r a  neighbor b such that
d  l b   let b  be minimal w r t   such that b a b    by definition of i  we have
 a  b     ri   non applicability of the rp rule yields d  l b     by induction  we get
b   di and thus a  c i  
   

fikeys  nominals and concrete domains

 c   r d  let  a  b   ri   by definition of i  this implies that there exist a    b   va
such that a is minimal w r t   and a a a    b is minimal w r t   and b a b    and b 
is an r successor of a    since b  is clearly an r a  neighbor of a  non applicability of
r yields d  l b     which implies d  l b  due to the non applicability of rp  by
induction  we get b  di   since this holds independently of the choice of b  we obtain
a   r d i  

lemma b    completeness   if the input concept c  is satisfiable w r t  the input key box
k  then the tableau algorithm returns satisfiable 
proof  let i be a model of c  and k  we use i to guide  the non deterministic parts
of  the algorithm such that it constructs a complete and clash free completion system  a
completion system s    t  p      with t    va   vc   e  l  is called i compatible if there
exist mappings    va  i and    vc  d such that
 ca  c  l a    a   c i
 cb  b is an r successor of a    a    b    ri
 cc  x is a g successor of a  g i   a       x 
 cd   x            xn    p p       x               xn     p d
 ce  x  y    x      y  
we first establish the following claim 
claim    if a completion system s is i compatible  then  i  a a b implies  a     b 
and  ii  x c y implies   x      y  
proof  we show by induction on i that a ia b implies  a     b   see definition      
which yields  i  
 start  if a  a b  then there exists a nominal n such that n  l a   l b   by  ca 
we obtain  a   n i and  b   n i   which yields  a     b  by definition of the
semantics 
 step  for a ia b  we distinguish three cases 
   if a i 
b  then  a     b  by induction 
a
   there is a c  va and an f  naf such that both a and b are f  i 
a  neighbors of
i  c   a is an f  successor
c  hence  there exist c    c   va such that c i 
c

 
 
a
a
of c    and b is an f  successor of c    by induction  we have  c     c       c    
thus  cb  yields    c    a      c    b     f i   which implies  a     b  by
definition of the semantics 
   there exist  u            un keyfor c   k  ui  ai   neighbors xi of a and ui  ai  neighbors yi of b for    i  n such that c  l a l b  and xi  yi for    i  n 
 ca  yields a  b  c i   using induction   cb   and  cc   it is straightforward to
   

filutz  areces  horrocks    sattler

show that uii   a       xi   and uii   b       yi   for    i  n  by  ce   this
implies uii   a     uii   b   for    i  k  since i is a model of the key box k 
this yields  a     b  by definition of the semantics 
now for part  ii  of claim    if x c y  then either x  y or there is an a  va and a g  ncf
such that both x and y are g a  neighbors of a  in the former case   ce  yields   x      y  
in the latter case  part  i  of the claim and  cc  yields    a     x      a     y     g i which
implies   x      y   this finishes the proof of claim   
we can now show that the completion rules can be applied such that i compatibility is
preserved 
claim    if a completion system s is i compatible and a rule r is applicable to s  then r
can be applied such that an i compatible completion system s   is obtained 
proof  let s be an i compatible completion system  let  and  be functions satisfying
 ca  to  ce   and let r be a completion rule applicable to s  we make a case distinction
according to the type of r 
ru the rule is applied to a concept c  u c   l a   by  ca   c  u c   l a  implies
 a    c  u c   i and hence  a   c i and  a   c i   since the rule adds c  and
c  to l a   it yields a completion system that is i compatible via the same  and   
rt the rule is applied to c  tc   l a   c  tc   l a  implies  a   c i or  a   c i  
since the rule adds either c  or c  to l a   it can be applied such that it yields a
completion system that is i compatible via the same  and   
r the rule is applied to a concept r c  l a   generates a new r successor b of a and
sets l b     c   by  ca   we have  a    r c i and  hence  there exists a d  i
such that   a   d   ri and d  c i   set          b   d   it is readily checked
that the resulting completion system is i compatible via    and   
r the rule is applied to a concept r c  l a  and adds c to l b  of an existing
r a  neighbor b of a  hence  there exists an a  such that a a a  and b is an rsuccessor of a    by part  i  of claim    we have  a     a     thus  by  ca  we have
 a      r c i while  cb  yields    a      b    ri   by definition of the semantics 
 b   c i and thus the resulting completion system is i compatible via  and   
 i 

 i 

rc the rule is applied to a concept u            un  p  l a  with ui   f     fki gi for
 i 

   i  n  the rule application generates new abstract nodes bj and xj for    i  n
and    j  ki such that
 i 

 i 

 i 

 i 

 b  is an f   successor of a for    i  n 
 i 

 bj is an fj  successor of bj  for    i  n and    j  ki  
 i 

 xi is gi  successor of bki for    i  n  and
  x            xn    p p   
   

fikeys  nominals and concrete domains

 i 

by  ca   we have  a    u            un  p  i   hence  there exist dj  i for    i  n
and    j  ki and             n  d such that
 i 

 i 

 i 

 i 

   a   d      f   i for    i  n 
 i 

  dj    dj     fj  i for    i  n and    j  ki  
 i 

 gii  dki     i for    i  n  and
              n    p d  
s
s
 i 
 i 
set          in and  jki  bj   dj   and          in  xi   i   
the resulting completion system is i compatible via    and     
rch the rule is applied to an abstract node a and a key assertion  u            un keyfor c 
 k and non deterministically adds either c or  c  by definition of the semantics 
 a   c i or  a     c i   hence  rch can be applied such that the resulting
completion system is i compatible via  and   
rp the rule is applied to a concept c  l a  and adds c to the label l b  of a node b
with a a b  by  ca   we have  a   c i   since claim   yields  a     b   it follows
that the resulting completion system is i compatible via  and   
finally  we show that i compatibility implies clash freeness 
claim    every i compatible completion system is clash free 
proof  let s    t  p      be an i compatible completion system  consider the three
kinds of a clash 
 due to  ca   a clash of the form  a  a   l a  clearly contradicts the semantics 
 assume that there are a  va and x  vc such that g  l a  and x is g a  neighbor
of a  then there exists b  va such that a a b and x is g successor of b  by claim   
a a b implies  a     b   thus  g  l a  and  ca  give  b    g i   we obtain a
contradiction since  cc  yields   b     x    g i  
 properties  cd  and  ce  and part  ii  of claim   imply that  is a solution for s  
thus  s is concrete domain satisfiable 
we can now describe the guidance of the tableau algorithm by the model i in detail 
we ensure that  at all times  the considered completion systems are i compatible  this
obviously holds for the initial completion system
sc     tc    p       with tc      a          a     c    
we guide the non deterministic test function such that  when given a predicate conjunction
s with set of variables vc  oc as input  it returns the relation  defined by setting x  y
iff   x      y  for all x  y  v   the relation  is a concrete equivalence since  is a solution
for s  see above   with this guidance   ce  is obviously satisfied after each call to test  and
the other properties are not affected by such a call  according to claim    we can apply the
   

filutz  areces  horrocks    sattler

completion rules such that i compatibility is preserved  by corollary b    the algorithm
always terminates  hence also when guided in this way  since  by claim    we will not find
a clash  the algorithm returns satisfiable 
the tableau algorithm yields decidability and a tight upper complexity bound for alcok d concept satisfiability w r t  key boxes 
theorem b    theorem     of section       let d be a key admissible concrete domain 
if extended d satisfiability is in np  then alcok d  concept satisfiability w r t  boolean
key boxes is in nexptime 
proof  corollary b   and lemmas b   and b   yield decidability of alcok d  concept
satisfiability w r t  boolean key boxes  for complexity  lemma b   provides an exponential
bound on the number of recursive calls  hence  it remains to show that each single recursion
step needs at most exponential time  by lemma b    the while loop terminates after at most
exponentially many steps  in each such step  we compute the relations a and c   which
are used in the construction of the predicate conjunction s and for checking termination
of the while loop  since  by lemma b    there exists an exponential bound on the number
of abstract and concrete nodes in the completion system s  this can obviously be done in
exponential time  moreover  lemma b   implies that the size of s is at most exponential 
this together with the fact that extended d satisfiability is in np implies that the call to
test needs at most exponential time  all remaining tasks  checking for clashes  completeness 
and rule applicability  can clearly also be performed in exponential time 

appendix c  proofs of section    
we first provide the proof of lemma     which shows that the notion of tableaux introduced
in section     is an adequate abstraction of models 
lemma c    lemma     in section       let d be a shoqk d  concept in nnf  r a
role box  and k a path free key box in nnf  then d is satisfiable w r t  r and k iff d has
a tableau w r t  r and k 
proof  for the only if direction  we construct a tableau t from a common model i of d 
r  and k as follows 
sa    i
sc     x  d   g i  s    x for some s  sa  
l s      c  cl d  r  k    s  c i  
e s  t      s  nd r k
   s  t   s i  
r
e s  g     g i  s  if g i  s  is defined
p p        x            xn    snc    x            xn    p d   
it can be easily verified that t is a tableau for d w r t  r and k  the proof that t satisfies
 t     t   is identical to the corresponding cases in  horrocks et al         horrocks  
sattler          t    holds by definition of l   t    by definition of l and the fact that
nominals are interpreted as singleton sets   t    by definition of l  e  and p together with
   

fikeys  nominals and concrete domains

the semantics of concepts g            gn  p    t    since the identity function on sc is clearly a
solution for the listed predicate conjunction   t    by definition of l and e together with
the semantics of key constraints  and finally  t    by definition of l and e together with
the semantics of concepts g 
for the if direction  let t    sa   sc   l  e  e  p  be a tableau for d w r t  r and k and
let  be a solution for the predicate conjunction in  t     we construct a model i for d
as follows 
i

   sa

ai

    s  i   a  l s  

for concept names a

ni

    s  i   n  l s   for nominals n
  s
i
for r  nr   ncf with not trans r 
s v
  r s    s  t    r  e s  t  
i
s  r
r   
  s  t    r  e s  t   
for r  nr   ncf with trans r 

 x 
if e s  g    x
g i  s    
for g  ncf  
undefined if e s  g  is undefined
due to  t     the interpretation of nominals is a singleton  moreover  the interpretation of
roles is well defined since role boxes are acyclic  the following claim is central for proving
that i is indeed a model for d  r  and k 
claim  for each c  cl d  r  k   c  l s  implies s  c i  
proof  we proceed by induction on the norm   c   of c  which is defined as follows 
  a  
  g  
  c  u c    
     n r c   

  
  
  
  

  a  
  u            un  p   
  c  t c    
     n r c   

  
  
  
  

  for a concept name
 
      c         c    
      c  

for concept names a and nominals n   the claim follows by definition of ai and n i   for the
negation of concept names a and nominals n  note that c is in nnf   the claim follows by
definition of ai and n i together with  t    concepts c of the form c  u c  and c  t c 
can be treated using  t   and  t   together with the induction hypothesis  for existential 
universal  and number restrictions  the proof is analogous to the one for shiq in  horrocks
et al          for concepts of the form c   g          gn  p  l s   s  c i is an immediate
consequence of  t     the definition of gii   and the fact that  x            xn    p p   implies
  x              xn     p d by  t     finally  for concepts c   g  s  c i is an immediate
consequence of the definition of g i together with  t     this finishes the proof of the
claim 
by definition of tableaux  there exists an s   sa such that c  l s     by the claim 
s   c i and thus i is a model of c 
next  we show that i is a model of r  by definition of ri   it is obvious that trans r  
r implies that ri is a transitive relation  now let s v r  r  if trans r  
  r  then we
have s i  ri by definition of ri   now let trans r   r and  s  t   s i   if s  e s  t  
then  t   implies r  e s  t   and thus  s  t   ri   otherwise  there is an s   v
  s with
trans s      r and  s  t     u  v    s    e u  v      now  t   together with s   v
  r implies
   

filutz  areces  horrocks    sattler

that   u  v    s    e u  v      u  v    r  e u  v    and thus trans r   r implies that
 s  t   ri  
it remains to show that i is a model of k  to this end  let  g            gn keyfor c   k
and s  t  c i such that gii  s    gii  t  for    i  n  since the predicate conjunction in
 t    contains explicit inequalities for all distinct concrete individuals  this implies that
e s  gi     e t  gi   for    i  n   t    implies  c   c   l s      and  c   c   l t      
if  c  l s   then the claim yields s    c i contradicting s  c i   thus we obtain
c  l s  and  in a similar way  c  l t   finally   t    implies that s   t  and thus i
satisfies k 
we now proceed to prove termination  soundness  and completeness of the tableau algorithm
presented in section      starting with termination  in the following  we use  d  r  k  to
denote   cl   d  r  k    recall that this number is polynomial in the size of d  r  k 
lemma c    termination   let d be a key admissible concrete domain  when started
with a shoqk d  concept d in nnf  a role box r  and a path free key box k in nnf 
the tableau algorithm terminates 
proof  assume that there are d  r  and k such that the tableau algorithm does not terminate  since d is key admissible  this means that there is an infinite sequence s    s         
of completion systems such that  a  s  is the initial completion system sd and  b  si   is
the result of applying a completion rule to si  
this is only possible if the r or the r  rules are applied infinitely often  it is easily seen
that the rules ru  rt  r   rc  r  r    rch  and ra can only be applied finitely often
to completion systems whose set of abstract nodes va does not increase since they either
add concepts into node labels  whose size is bounded   or they add concrete nodes  whose
number is bounded linearly by the number of abstract nodes   or they remove abstract
nodes from the forest  hence there is a sub sequence si    si          of s    s          such that
sij is the result of applying the r or the r  rule to sij     let si  be the abstract node
to which the r or the r  rule was applied in si      since s  t implies that t was not
generated before s  the linear ordering  is well founded  thus  we find an infinite subsequence sj    sj          of si    si          such that either sj    sj    for each      or sj   sj   
for each       the former  however  is not possible since the r and the r  rules are
applied at most once per node and concept in cl d  r  k   even if a node is removed  the
label copying performed by the r  rule together with clashes of type  c   ensures that
the r  rule is not re applied to the same concept and node  thus only the second option
remains  there is a subsequence sj    sj          of si    si          such that sj   sj    for each
      let lj be the labeling function in sj   since each abstract node is labeled with a
subset lj of cl   d  r  k   there are nodes sjk  sj  with k fi   and ljk  sjk     lj   sj    
now node labels can only increase and  if a node t is removed  its label is conjoined to the
label of a node t with t  t  thus there is a node t in the completion system sj  with
t  sj  and lj   sj     lj   t   by definition  sj  is thus blocked in sj    contradicting the
assumption that the r or the r  rule is applied to sj  in sj   
lemma c    soundness   if the expansion rules can be applied to a shoqk d  concept
d in nnf  a role box r  and a path free key box k such that they yield a complete and
clash free completion forest  then d has a tableau w r t  r and k 
   

fikeys  nominals and concrete domains

proof  let s     va   vc   e  l   p  c     be a complete and clash free completion system 
we can find a solution  for s such that  x     y  iff x c y  only the rc rule updates
the predicate conjunction s   and after each rule application the c relation is updated
using the concrete equivalence that a d tester returns for s  note that s is satisfiable due
to clash freeness   according to definition      we can thus find a solution  as required 
from s and   we define a finite tableau t    sa   sc   e  l  p  as follows 
sa     s  va   s occurs in s and is not blocked 
sc      x     s  x   e g  for some s  sa and some g 
l s     l s   cl d  r  k   the intersection is due to the auxiliary concepts anrc
  
i
e s  t      r   t is an r successor of s or t blocks an r successor t  of s 

 x 
if x is a g successor of s
e s  g    
undefined if x has no g successor
p    the restriction of p to sc  
note that the function e is well defined due to the definition of adding g successors  it
remains to show that t satisfies  t   t     which is basically a consequence of s being
clash free and complete 
  t   is satisfied since s does not contain a clash  c   
  t   is satisfied since the ru rule cannot be applied  and thus c  u c   l s  implies
c    c   l s  
  t   is satisfied since the rt rule cannot be applied  and thus c  t c   l s  implies
 c    c     l s      
 for  t    consider s  t  sa with r  e s  t  and r v
  r    then r  e s  t  implies
that t is or blocks an r successor of s  by definition of successor  t is or blocks an
r   successor of s  and thus r   e s  t  
 for  t    let r c  l s  and r  e s  t   if t is an r successor of s  then s not
being blocked implies c  l t  since the r rule cannot be applied  if t blocks an
r successor t  of s  then s not being blocked and the fact that the r rule cannot be
applied yields c  l t     and the blocking condition implies c  l t  
in both cases  we thus have c  l t  
  t   and  t   are satisfied for the same reasons as  t   with r replaced with r
and r   
 for  t    consider s with    n r c   l s   hence    n r c   l s  and
completeness of s implies the existence of r successors t            tn of s with c  l ti  
 
and ti  
  tj for i    j  the latter implies  for each i    j  the existence of integers k   
such that k       anrc
 l ti    and anrc
 l tj    for  t   to be satisfied  it remains
k
 
to verify that
 no ti can block a tj   if this was the case  the blocking condition would imply that
 anrc
  anrc
   l ti   
k
 
   

filutz  areces  horrocks    sattler

 no t can block both ti and tj with i    j  similarly  this would imply that
 anrc
  anrc
   l t  
k
 
in each case  we would have a clash  c    in contradiction to s being clash free 
 for  t    consider s with    n r c   l s   hence    n r c   l s  and  since
the r  rule cannot be applied  there are at most n r successors ti of s  since each
ti is either not blocked or blocked by exactly one other node  due to  being a linear
ordering   there are at most n ui  sa with r  e s  ui   and c  l ui   
 for  t     let    n r c   l s  and r  e s  t   hence    n r c   l s  and
t either is an r successor of s or blocks an r successor of s  in the first case  nonapplicability of the rch rule implies that  c   c   l t       in the second case 
 c   c   l t        for t  the r successor of s blocked by t  and thus the blocking
condition yields  c   c   l t       in both cases  this implies  c   c   l t      
next  consider  g            gn keyfor c   k and s such that e s  gi   is defined for each
i  hence s has a gi  successor for each i  and thus s not being blocked and the nonapplicability of the rch rule imply that  c   c   l t      
 for  t     consider n  l s   l t   by definition  n  l s   l t  and thus s a t 
moreover  totality of  implies that we can assume without loss of generality that
s  t or s   t  thus non applicability of the ra rule implies that l t   l s   and
thus t not being blocked implies s   t 
  t    is satisfied since the rule rc cannot be applied 
 for  t     clash freeness implies the satisfiability of
 

 

p  x            xn   

p used in d k  x       xn  p p  

by choice of    x     y  iff x c y  and thus  t    is satisfied 
 for  t     let  g            gn keyfor c   k  c  l s   l t   and e s  gi     e t  gi    for
all    i  n  thus c  l s   l t  and  by choice of e and   we have xi c yi
for gi  e s  xi    e t  yi    hence s a t  without loss of generality  we assume that
s  t or s   t  thus non applicability of the ra rule implies that l t   l s   and
thus t not being blocked implies s   t 
  t    is satisfied by definition of t and since s does not contain a clash  c   

lemma c    completeness   if a shoqk d  concept d in nnf has a tableau w r t  a
role box r and a path free key box k  then the expansion rules can be applied to d  r  and
k such that they yield a complete and clash free completion forest 
   

fikeys  nominals and concrete domains

proof  given a tableau t    sa   sc   l  e  e  p  for d w r t  r and k  we can guide the
non deterministic rules rt  rch  and ra in such a way that each rule application preserves
clash freeness  this together with termination from lemma c   finishes the proof 
along with rule application  we perform a stepwise construction of a total mapping 
that takes abstract nodes of the completion forest to elements of sa and concrete nodes of
the completion forest to elements of sc  
 l s   cl d  r  k   l  s   for each s  va  
 if t is an r successor of s  then r  e  s    t   
 if x is a g successor of s  then e  s   g     x  
 x c y iff  x     y   and
 
 if s  
  t  then  s      t  
a mapping satisfying these four conditions is called correct in the following  note that a
completion system for which there exists a correct mapping does not contain a clash  due to
 t   and the first property  we do not encounter a clash  c    a clash  c   cannot occur
due to the last property  the first and the third property together with  t    ensure that
a clash  c   does not occur  finally  a clash  c   cannot occur for the following reason 
by construction of p and since edges labelled with abstract features are never removed  for
each tuple  x            xn    p p    we find an abstract node s and paths u            un such that
u            un  p  l s  and xi is a ui  successor of s for    i  n  thus  the first  second 
and third property together with  t    and  t    ensure that the conjunction
 
p   x              xn   
p used ind k
 x       xn  p p  

has a solution  with   x        x   iff  x      y   by the fourth property  setting
    x       x   for all x  vc thus yields a solution    for s  
the total mapping  is inductively defined as follows  let  be a solution for the equation
in  t     choose a node s  with d  l s     and set  s       s  for s  the  only  node of the
initial completion forest  obviously   is correct  we will now show that each completion
rule can be applied in such a way that  either is still correct or that  can be extended to
a correct mapping 
 an application of the rule ru preserves correctness of  due to  t   
 due to  t    the rule rt can be applied such that correctness is preserved 
 if the rule r adds a new node t for r c  l s   then correctness implies r c 
l  s    and thus  t   implies the existence of some t  sa with r  e  s   t  and
c  l t   thus extending  with  t     t obviously yields a correct mapping 
 if the rule r  adds n nodes ti for    n r c   l s   then correctness implies
   n r c   l  s    and thus  t   implies the existence of t            tn  sa with
ti    tj for i    j  r  e  s   ti    and c  l ti    thus extending  with  ti      ti
obviously yields a correct mapping 
   

filutz  areces  horrocks    sattler

 assume that the r  rule is applicable to a node s with    n r c   l s  and more
than n r successors ti with c  l ti    then correctness implies that    n r c  
l  s    r  e  s    ti     and c  l ti    thus  by  t    there are i    j with
 
 ti      tj    again  correctness implies that not ti  
  tj and  without loss of generality  we can assume that ti  tj   hence applying the rule and thereby merging l tj  
into l ti   preserves correctness 
 for the rule rc   can be extended in a similar way as for r  if a new gi  successor xi
of s is added  then extending  with  xi      e  s   gi   yields a correct   moreover 
 t    ensures that c can be updated in such a way that the fourth condition is
preserved 
 for the r rule   does not need to be extended  and  t     t    and the definition
of r successors imply that correctness is preserved 
 the r  rule is similar  with the only difference that  t   takes the place of  t   
 due to  t     the rule rch can be applied without violating correctness 
 for ra   we consider two reasons for ra to be applicable 
 n  l s   l t   then correctness of  and  t    imply that  s     t  
  g            gn keyfor c   k  c  l s   l t   and gi  e s  xi    e t  yi   and
xi c yi for    i  n  then correctness implies that e  s   gi     e  t   gi    and
thus  t    together with the first property of correctness imply that  s     t  
in both cases  applying ra to s and t preserves correctness 

as an immediate consequence of lemmas      c    c    and c    the tableau algorithm
always terminates and answers d is satisfiable w r t  r and k if and only if the input
concept d is satisfiable w r t  the input role box r and the input key box k  since concept
satisfiability w r t  tboxes can be reduced to concept satisfiability without tboxes  we
obtain the following result 
proposition c    let d be a key admissible concrete domain  the tableau algorithm
decides satisfiability of shoqk d  concepts w r t  tboxes  role boxes  and path free key
boxes 
it is not hard to verify that the proof of lemma c   together with lemmas     and c  
yield a bounded model property for shoqk d   where the bound is exponential 
corollary c    if a shoqk d  concept d is satisfiable w r t  a role box r and a pathfree key box k  then d is satisfiable w r t  r and k in a model of size at most  i     m
for m     cl   d  r  k  
   

fikeys  nominals and concrete domains

proof  if a shoqk d  concept d is satisfiable w r t  a role box r and a path free key
box k  lemma c   implies that the tableau algorithm constructs a complete and clash free
completion forest for d  r  and k  by the definition of blocking  the number of abstract
nodes in a completion forest that are not blocked is bounded by  m   if s    t  va are
abstract nodes in a completion forest and l s    l t   then either s blocks t  t blocks s  or
they are both blocked by another node u  moreover  it is easily seen that the number of
concrete successors per abstract node is bounded by the number of concrete features in c  r 
and k  now  in the proof of lemma c    the abstract nodes in the tableau constructed from
a complete and clash free completion forest coincide with the nodes that are not blocked
in the completion forest  finally  in the proof of lemma     the interpretation domain
of a model constructed from a tableau coincides with the abstract nodes in the tableau 
summing up  a shoqk d  concept that is satisfiable w r t  r and k has a model of size
 i     m  

references
areces  c   blackburn  p     marx  m          a road map on complexity for hybrid logics 
in flum  j     rodrguez artalejo  m   eds    computer science logic  no       in
lecture notes in computer science  pp          springer verlag 
baader  f   horrocks  i     sattler  u       a   description logics for the semantic web  ki
 kunstliche intelligenz               
baader  f   lutz  c   sturm  h     wolter  f       b   fusions of description logics and
abstract description systems  journal of artificial intelligence research  jair      
    
baader  f     sattler  u          description logics with concrete domains and aggregation  in prade  h   ed    proceedings of the   th european conference on artificial
intelligence  ecai     pp          john wiley   sons 
baader  f   calvanese  d   mcguinness  d  l   nardi  d     patel schneider  p  f         
the description logic handbook  theory  implementation and applications  cambridge university press  cambridge  ma  usa 
baader  f     hanschke  p       a   a scheme for integrating concrete domains into concept
languages  in proceedings of the   th international joint conference on artificial
intelligence  ijcai      pp          sydney  australia 
baader  f     hanschke  p       b   a scheme for integrating concrete domains into concept
languages  dfki research report rr        german research center for artificial
intelligence  dfki  
baader  f     hanschke  p          extensions of concept languages for a mechanical
engineering application  in proceedings of the   th german ai conference  gwai     vol      of lecture notes in computer science  pp          springer verlag 
baader  f     sattler  u          tableau algorithms for description logics  in dyckhoff 
r   ed    proceedings of the international conference on automated reasoning with
tableaux and related methods  tableaux        vol       of lecture notes in artificial
intelligence  pp       springer verlag 
   

filutz  areces  horrocks    sattler

berger  r          the undecidability of the domino problem  memoirs of the american
mathematical society          
berners lee  t   hendler  j     lassila  o          the semantic web  scientific american 
              
borger  e   gradel  e     gurevich  y          the classical decision problem  perspectives
in mathematical logic  springer verlag 
borgida  a     patel schneider  p  f          a semantics and complete algorithm for
subsumption in the classic description logic  journal of artificial intelligence research            
borgida  a     weddell  g  e          adding uniqueness constraints to description logics
 preliminary report   in bry  f   ramakrishnan  r     ramamohanarao  k   eds   
proceedings of the  th international conference on deductive and object oriented
databases  dood     vol       of lncs  pp         springer 
calvanese  d   de giacomo  g     lenzerini  m          on the decidability of query
containment under constraints  in proceedings of the   th acm sigact sigmodsigart symposium on principles of database systems  pods     pp         
calvanese  d   de giacomo  g     lenzerini  m          keys for free in description logics 
in baader  f     sattler  u   eds    proceedings of the      international workshop in
description logics  dl       no     in ceur ws  http   ceur ws org    pp       
calvanese  d   lenzerini  m     nardi  d          description logics for conceptual data
modeling  in chomicki  j     saake  g   eds    logics for databases and information
systems  pp          kluwer academic publisher 
dean  m   connolly  d   van harmelen  f   hendler  j   horrocks  i   mcguinness  d  l  
patel schneider  p  f     stein  l  a          web ontology language  owl  reference
version      w c working draft 
fensel  d   van harmelen  f   horrocks  i   mcguinness  d  l     patel schneider  p  f 
        oil  an ontology infrastructure for the semantic web  ieee intelligent
systems               
graham  r  l   knuth  d  e     patashnik  o          concrete mathematics  addison
wesley publ  co   reading  massachussetts 
haarslev  v   lutz  c     moller  r          foundations of spatioterminological reasoning
with description logics  in cohn  a   schubert  l     s c shapiro  eds    proceedings
of the  th international conference on principles of knowledge representation and
reasoning  kr     pp          morgan kaufman 
haarslev  v     moller  r          racer system description  in gore  r   leitsch 
a     nipkow  t   eds    proceedings of the  st international joint conference on
automated reasoning  ijcar     no       in lecture notes in artificial intelligence 
pp          springer verlag 
haarslev  v   moller  r     wessel  m          the description logic alcn hr  extended
with concrete domains  a practically motivated approach  in gore  r   leitsch  a  
   

fikeys  nominals and concrete domains

  nipkow  t   eds    proceedings of the  st international joint conference on automated reasoning ijcar    no       in lecture notes in artificial intelligence  pp 
      springer verlag 
halpern  j  y     moses  y          a guide to completeness and complexity for modal
logics of knowledge and belief  artificial intelligence                 
hollunder  b     baader  f          qualifying number restrictions in concept languages 
in proceedings of the  nd international conference on principles of knowledge representation and reasoning  kr     pp          boston  ma  usa 
hopcroft  j  e     ullman  j  d          introduction to automata theory  languages and
computation  addison wesley 
horrocks  i   sattler  u     tobies  s          practical reasoning for very expressive description logics  logic journal of the igpl                
horrocks  i          using an expressive description logic  fact or fiction   in proceedings
of the  th international conference on the principles of knowledge representation
and reasoning  kr     pp         
horrocks  i          reasoning with expressive description logics  theory and practice  in
voronkov  a   ed    proceedings of the   th international conference on automated
deduction  cade        no       in lecture notes in artificial intelligence  pp      
springer 
horrocks  i   patel schneider  p  f     van harmelen  f          reviewing the design of
daml oil  an ontology language for the semantic web  in proceedings of the   th
national conference on artificial intelligence  aaai        pp         
horrocks  i     sattler  u          ontology reasoning in the shoq d  description logic  in
nebel  b   ed    proceedings of the   th international joint conference on artificial
intelligence  ijcai     pp          morgan kaufmann 
horrocks  i   sattler  u     tobies  s          practical reasoning for expressive description
logics  in ganzinger  h   mcallester  d     voronkov  a   eds    proceedings of the
 th international conference on logic for programming and automated reasoning
 lpar     no       in lecture notes in artificial intelligence  pp          springerverlag 
kamp  g     wache  h          ctl   a description logic with expressive concrete domains 
tech  rep  lki m        laboratory for artificial intelligence  lki   universitity of
hamburg  germany 
khizder  v  l   toman  d     weddell  g  e          on decidability and complexity of description logics with uniqueness constraints  in den bussche  j  v     vianu  v   eds   
proceedings of the  th international conference on database theory  icdt       vol 
     of lncs  pp        springer 
knuth  d          the art of computer programming  vol     addison wesley 
lutz  c          description logics with concrete domainsa survey  in advances in modal
logics volume    pp          world scientific publishing co  pte  ltd 
   

filutz  areces  horrocks    sattler

lutz  c       a   the complexity of reasoning with concrete domains  ph d  thesis 
lufg theoretical computer science  rwth aachen  germany 
lutz  c       b   pspace reasoning with the description logic alcf d   logic journal
of the igpl                 
lutz  c       c   reasoning about entity relationship diagrams with complex attribute
dependencies  in horrocks  i     tessaris  s   eds    proceedings of the international
workshop in description logics       dl       no     in ceur ws  http   ceurws org    pp         
lutz  c          nexptime complete description logics with concrete domains  acm
transactions on computational logic                
lutz  c   areces  c   horrocks  i     sattler  u          keys  nominals  and concrete
domains  ltcs report        technical university dresden  see http   lat inf tudresden de research reports html 
lutz  c   areces  c   horrocks  i     sattler  u          keys  nominals  and concrete
domains  in proceedings of the   th international joint conference on artificial intelligence  ijcai     pp          morgan kaufmann publishers 
pan  j  z     horrocks  i          reasoning in the shoq dn   description logic  in horrocks  i     tessaris  s   eds    proceedings of the international workshop in description logics       dl       no     in ceur ws  http   ceur ws org    pp       
post  e  m          a variant of a recursively unsolvable problem  bulletin of the american
mathematical society             
schild  k  d          a correspondence theory for terminological logics  preliminary report 
in mylopoulos  j     reiter  r   eds    proceedings of the   th international joint
conference on artificial intelligence  ijcai      pp          morgan kaufmann 
schmidt schau  m     smolka  g          attributive concept descriptions with complements  artificial intelligence              

   

fi