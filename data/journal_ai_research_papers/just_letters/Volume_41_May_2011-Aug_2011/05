journal artificial intelligence research                  

submitted        published      

analyzing search topology without running search 
connection causal graphs h 
jorg hoffmann

joerg hoffmann inria fr

inria
nancy  france

abstract
ignoring delete lists relaxation paramount importance satisficing
optimal planning  earlier work  observed optimal relaxation heuristic
h  amazing qualities many classical planning benchmarks  particular pertaining
complete absence local minima  proofs hand made  raising
question whether proofs lead automatically domain analysis techniques 
contrast earlier disappointing results analysis method exponential runtime
succeeds two extremely simple benchmark domains herein answer
question affirmative  establish connections causal graph structure
h  topology  results low order polynomial time analysis methods  implemented
tool call torchlight     domains absence local minima
proved  torchlight gives strong success guarantees   domains  empirically  analysis
exhibits strong performance   domains  plus   domains
local minima may exist rare  way  torchlight distinguish easy domains
hard ones  summarizing structural reasons analysis failure  torchlight
provides diagnostic output indicating domain aspects may cause local minima 

   introduction
ignoring delete lists relaxation since decade  still is  paramount
importance effective satisficing planning  e g   mcdermott        bonet   geffner       
hoffmann   nebel      a  gerevini  saetti    serina        helmert        richter  
westphal         recently  heuristics making relaxation shown
boost optimal planning  karpas   domshlak        helmert   domshlak        
planners using relaxation approximate  variety ways  optimal relaxation
heuristic h  np hard compute  bylander         observed
earlier work  hoffmann         h  rather amazing qualities many classical
planning benchmarks  figure   gives overview results  
results divide domains classes along two dimensions  herein ignore horizontal dimension  pertaining dead ends  domain analysis already available 
easy to test powerful criteria implying task undirected harmless known
 e g   hoffmann         vertical dimension divides domains three classes 
respect behavior exit distance  defined   distance state
strictly smaller h  value  easiest bottom class  exist constant upper
   omit adl domains  add recent ipc benchmarks elevators transport  without
action costs   properties trivial prove based earlier results  blocksworld arm
classical blocksworld  blocksworld noarm variant allowing move b c directly 
c
    
ai access foundation  rights reserved 

fihoffmann

pipesworldtank
pipesworldnotank
psr

rovers
opticaltelegraph

mystery
mprime
freecell
airport

hanoi    
blocksworldnoarm    
grid    
transport    
bench ed    c

local minima ed    c

blocksworldarm
depots
driverlog

elevators      
logistics      
ferry      
gripper      
undirected

tyreworld      
satellite      
zenotravel      
miconicstrips      
movie      
simpletsp      
harmless

diningphil         

recognized

unrecognized

figure    overview h  topology  hoffmann        
bounds exit distance both  states local minima states benches  flat regions   figure  bounds given square brackets  example  logistics 
bound local minima   meaning local minima exist bound
benches    middle class  bound exists local minima  bound
   no local minima all  domains shown  hardest top class  local
minima benches may take arbitrarily many steps escape 
proofs underlying figure   hand made  dealing unseen domains 
question arises whether design domain analysis methods leading proofs
automatically  potential uses analysis methods manifold  discuss
end paper  now  note addressing question formidable challenge 
trying automatically infer properties characterizing informativeness  or lack
thereof   heuristic function  wish based static analysis  actually
running search  formally characterizing informativeness heuristic function
is  cases  hardly possible even experienced researchers  explains perhaps
no one far even attempted automatically  single exception 
best authors knowledge  analysis method mentioned side
authors earlier work  hoffmann         analysis method builds exponentially
large tree structure summarizing ways relaxed plans may generate facts 
tree size  therewith analysis runtime  explodes quickly task size  worse 
analysis succeeds movie simple tsp arguably two simplistic planning
benchmarks existence  
contrast  torchlight tool developed herein low order polynomial runtime
usually terminates split seconds  distinguishing global  per task  local  per
state  analysis  proves global absence local minima movie  simple tsp  logistics 
miconic strips  gives strong guarantee local analysis succeed every state
ferry  gripper  elevators  transport  taking success rate fraction
states local analysis succeeds  torchlight empirically exhibits strong performance
delivering high success rates zenotravel  satellite  tyreworld  grid  driverlog 
   simple tsp encodes tsp fully connected graph uniform edge cost  domain
introduced fox long        benchmark symmetry detection 

   

fianalyzing search topology without running search

rovers  thus torchlights success rates tend high easy domains figure   
low hard ones  serving automatically distinguish two
groups   summarizing structural reasons analysis failure  torchlight finally provides
diagnostic output indicating problematic aspects domain  i e   operator effects
potentially cause local minima h   
key performance boost  consider logistics blocksworld arm 
level pddl domain descriptions  difference evident
delete effects  blocksworld arm hurt logistics dont 
trick move finite domain variable representation  e g   jonsson  
backstrom        helmert              consider associated structures  notably
causal graph  e g   knoblock        jonsson   backstrom        domshlak   dinitz 
      helmert        capturing precondition effect dependencies variables 
causal graph blocksworld arm contains cycles  logistics doesnt  looking
this  surprisingly easy derive following basic result 
causal graph acyclic  every variable transition invertible 
local minima h   
result certainly interesting that  first time  establishes connection
causal graph structure h  topology  however  result much
weak domain analysis considered benchmarks  applies logistics  devise generalizations approximations yielding analysis results described
above  aside significance domain analysis  techniques interesting
respect research causal graphs  whereas traditional methods  e g   jonsson  
backstrom        brafman   domshlak        jonsson        gimenez   jonsson      a 
seek execution paths solving overall task  seek execution paths decreasing
value h    local analysis  enables us consider small fragments causal
graph  creating potential successfully analyze states tasks whose causal graphs
otherwise arbitrarily complex 
next section gives brief background planning finite domain variables 
associated notions causal graphs definition h  topology  section   gives illustrative example explaining basic result  section   provides
synopsis full technical results relating causal graphs h  topology  sections  
  present results detail  explaining first analyze state
provided given optimal relaxed plan input  thereafter providing
criteria causal graph structure implying analysis always succeed  evaluate domain analysis technique proving number domain specific performance
guarantees section    reporting large scale experiment torchlight section    point related work within context appropriate  discuss details
section    close paper discussion future work section     improve
readability  main text omits many technical details outlines proofs 
full details including proofs appendix a 
   extent  particular result achieved simpler means  limited search probing  
discuss along experiments section   

   

fihoffmann

   background
adopt terminology notation helmert         number modifications
suiting purposes   finite domain variable  planning task   tuple  x  si   sg   o   x
finite set variables  x x associated finite domain dx   partial
state x function subset xs x  s x  dx x xs   state
xs   x  initial state si state  goal sg partial state  finite set
operators  pair    preo   eff   partial states  called precondition
effect  simple non restricting sanity conditions  assume  dx       x x 
preo  x     eff  x  x xpreo xeff  
identify partial states sets variable value pairs  often refer
facts  state space task directed graph whose vertices states
x  arc  s  s    iff exists preo s  eff s    s x    s   x 
x x   xeff   plan path leading si state sg s 
next define two basic structures analysis  domain transition graphs
causal graphs  former  diverge helmerts definition  only 
introduce additional notations indicating operator responsible transition  well
side effects transition  i e   variable values set executing
responsible operator  detail  let x x  domain transition graph dt gx x
labeled directed graph vertex set dx following arcs 
x xpreo xeff c    preo  x  c     eff  x   dt gx contains arc  c  c    labeled
responsible operator rop c  c       o  conditions cond c  c       preo     x  c   
side effects seff c  c       eff     x  c      x xeff   xpreo
c     eff  x   every c dx c    c    dt gx contains arc  c  c    labeled
rop c  c       o  cond c  c       preo   seff c  c       eff     x  c     
reader familiar causal graphs may wondered introduced notion
side effects  seeing causal graphs acyclic operators unary  affect
single variable   reason handle cases operators nonunary  variant causal graphs use still acyclic cases  indeed
happens benchmark domains  specifically simple tsp  movie  miconicstrips  satellite  define support graph sg directed graph vertex
set x  arc  x  y  iff dt gy relevant transition  c  c   
x xcond c c     
 
 
here  transition  c  c   variable x called relevant iff  x  c   sg oo preo  
definition modifies commonly used one uses relevant transitions
only  introduce arcs variables co occurring operator
effect  unless variables occur precondition   transitions side effects
handled separately analysis  note irrelevant transitions occur naturally 
domains non unary operators  example  unstacking block induces irrelevant
transition making arm non empty  departing passenger miconic strips makes
passenger not boarded  
consider definition h    common boolean variable setting
pddl  defined length shortest plan solving problem ignoring
   remark relevant transitions correspond called requestable values
works   e g   jonsson   backstrom        haslum         fast downwards implementation 
causal graph includes precondition effect arcs  similarly support graph defined here 

   

fianalyzing search topology without running search

delete lists  i e   negative operator effects  bylander        mcdermott        bonet
  geffner         raises question h  actually is  finite domain variable
planning  delete lists  question easily answered  ignoring
deletes essentially means act true remain true forever 
finite domain variable setting  simply means over write values
variables previously  knowledge  generalization first described
helmert         consider directed graph   whose vertices sets s  variable 
 
value pairs x  arc  s 
    s    iff exists preo s 
 
 
 
s    s  eff   state  relaxed plan path leading
s  sg s    h   s  denote length shortest relaxed plan s 
h   s    plan exists  easy see definition corresponds
common boolean one  translate finite domain variables boolean ones
creating one boolean variable is  x  c  true  every fact  x  c   standard h 
boolean task identical h  finite domain variable task 
bylander        proved intractable compute h    many state of the art
planners approximate h    variety ways  e g   mcdermott        bonet   geffner 
      hoffmann   nebel      a  gerevini et al         helmert        richter  helmert 
  westphal        richter   westphal         popular approximation satisficing
planning gives guarantees quality relaxed plan returned
so called relaxed plan heuristic first proposed system  hoffmann   nebel      a  
approximates h  terms length necessarily shortest relaxed plan 
relaxed plans computed low order polynomial time using techniques inspired
graphplan  blum   furst        
next introduce relevant notations pertaining search space topology h   
let state     h   s      exit state s  reachable
s  h   s      h   s  exists neighbor s   s  h   s       h   s   
 and thus h   s       h   s    exit distance ed s  length shortest path
exit  ed s    exit exists  path called monotone iff exist
two consecutive states s  s  h   s      h   s     say local
minimum exists monotone path exit 
topology definitions  adapted authors previous work  hoffmann        
specific h  sake simplicity  we herein consider heuristics
h      states infinite heuristic value ignored correctly
identified  heuristic  dead ends  relaxed plan based approximations
identify cases   heuristic value   already reached
goal  case safely ignored  note force exit paths
monotone  i e   talk exit distances situations may
local minimum  necessary capture structure domains satellite
zenotravel  local minima exist exit distance bounded  also 
analysis methods guarantee upper bound length exit path only 
heuristic values path decrease monotonically 
   remark original definitions significantly involved  e g   defining local minima
based individual states based strongly connected sub graphs state space  none
complications relevant results herein 

   

fihoffmann

finally  let us say words domain analysis  generally speaking  domain analysis
aims automatically obtaining non trivial information domain planning task 
analysis long tradition planning  e g   nebel  dimopoulos    koehler       
fox   long        gerevini   schubert        edelkamp   helmert        rintanen 
       often  information sought pertains reachability relevance properties 
i e   entities combinations thereof reachable initial state relevant
goal  notable exception work long fox        automatically
recognizes certain generic types domains  transportation  however  exists
prior work trying automatically infer topological properties heuristic function 
single exception aforementioned disappointing results reported  as aside 
authors previous work  hoffmann         method builds structure called
fact generation tree  enumerating ways facts may support
non redundant relaxed plan  conflict h  exact solution distance 
clearly  far strong property applicable reasonably complex domain 
considered benchmarks  property applies simple tsp  slightly
general property  identified work  applies movie well trivial logistics
tasks   locations    truck    package 
worth noting analyzing topology h  computationally hard 
theorem    pspace complete decide whether state space given
planning task contains local minimum  given integer k pspace complete
decide whether states ed s  k  further  pspace complete
decide whether given state local minimum  given integer k
pspace complete decide whether ed s  k 
results hardly surprising  stated anywhere yet  membership results theorem   easy prove based guess and check arguments similar
given bylander         exploiting fact npspace pspace  hardness results still hold restricting input solvable tasks states  proofs work
reducing plan existence  respectively bounded plan existence  with bound non unary
representation   given task whose plan existence wish decide  flatten h 
new operator always achieve goal fatal side effect  give
planner choice solving task  solving new alternative task  latter task designed local minimum exists that exit distance exceeds bound
iff planner must choose alternative task  i e   iff original task unsolvable iff
cannot solved within given number steps  full proof appendix a   
practice  computational hardness particularly challenging because 
applications domain analysis  willing run worst case exponential search 
all  analysis actually solve problem  consequently  present
research  restrict analysis methods low order polynomial runtime 
reader noticed state specific analysis problems theorem   
distinguish global analysis per task  local analysis per state  precisely 
herein devise three kinds analyses 
 i  guaranteed global analysis  taking input planning task description 
analysis returns yes  state space contain local minima
exit distance state bounded d 
   

fianalyzing search topology without running search

 ii  guaranteed local analysis  taking input planning task description
state s  analysis returns yes  local minimum  exit
distance bounded d 
 iii  approximate local analysis  taking input planning task description
state s  analysis returns yes  indicate local minimum 
exit distance bounded d  may wrong  i e   analysis
guaranteed sound  compared analysis  ii   trades soundness
ability successfully analyze states 
domain analysis traditionally considers global variant  i   even generalizing
variants looking pddl domain file  global once and for all analysis
holy grail work  local analysis strong advantages  planning task
contain local minima one would expect typically case interesting
domains analysis  i  useless  simply answer no  contrast  local analysis
 ii iii  may still detect individual states  sample randomly experiments 
local minima  percentage states  refer success rate 
deliver useful information matter structure planning task is  note
that  contrast pspace hard problem low order polynomial
analysis runtime necessarily implies analyses incomplete  local analyses
chance ameliorate averaging outcome set sample states 

   illustrative example
basic connection identify causal graphs h  topology precisely 
support graphs  domain transition graphs  h  topology quite simple 
instructive understand first  delving full results  figure   shows
fragments domain transition graphs  dtgs  three variables x    x    x   
dtg transitions assumed invertible  side effects 
t 

x 
g 
t 

t 

x 

l 

l 

l 

s  r 

r 

r 

x 
c 

c 

s 

figure    example illustrating basic result 
imaginative reader invited think x  car whose battery currently
empty therefore requires help two people  x  x    order push start
it  people may  solve different parts task  required purposes too 
consider sub problem achieving goal x    g    wish take
   

fihoffmann

x  transition t    two conditions c  c    conditions currently
fulfilled  state hand  x  s  x  s    must move different
state  s    x    c  x    c    happen h  along way 
say optimal relaxed plan p    s  moves x  c  along path marked t   
moves x  c  along path marked t  clearly  paths taken
p    s   key observation     similar phenomenon known transportation
benchmarks  moving x  x    whichever state s  in  long s  remains
within boundaries values traversed t  t    construct relaxed plan
p    s    s   p    s      p    s    namely  obtain p    s     simply replace


respective move sequence
p    s           inverse
  example  say


 
got     hr   r   r i moving x  c    indicated figure    wlog
p    s  form hr   r   r i p   define p    s       hl   l   l i p   postfix p
relaxed plans same  end prefix  set values achieved x   
namely s    c    two values between  same  thus p    s    relaxed

plan s     true general  i e  
  necessarily applicable s    achieve 

 
 
within relaxed execution p  s    set facts achieved
  p    s   thus
h   s    h   s  state s    including state s  after 
key observation     pertains leaf variable  x    say x  moves
sake  i e   car position important goal  executing t 
s  delete anything needed anywhere else  thus remove rop t   
relaxed plan p    s    s  constructed per observation     obtain relaxed plan
state s  results executing t  s    hence h   s      h   s   observation
     heuristic values along path s  h   s   know least one
state s   path heuristic value strictly smaller h   s   happens
latest s     s    may happen earlier case relaxed plan p    s     constructed
optimal  cf  footnote     let s   earliest state h   s       h   s 
path  let s  state preceding s     s  exit s  path
exit monotone  thus local minimum  exit distance  worst
case s     s  s    s    ed s  bounded length path s   
difficult imagine works preconditions need
established recursively  long cyclic dependencies exist  third person may
needed first persuade x  x    third person may need take bus  on 
length path s  may grow exponentially x  depends x 
move x  may require several moves x    forth still able
construct p    s    inverting moves variables individually  further  inverting
transitions may conditions  too  provided conditions required
original moves  example  above  inverting operator l  may
arbitrary condition p condition required r    conditions
required original moves  like p r    established p    s   thus
established p    s    time inverse moves  like l    
   note p    s    may optimal relaxed plan s    p    s  move x  anything
attaining c    postfix p alone relaxed plan s    need insert
inverted prefix hl   l   l i  cases this  obtain exit state already path s    get
back below 

   

fianalyzing search topology without running search

now  say support graph acyclic  transitions invertible
side effects  given state s  unless already goal state  variable x 
moving sake necessarily exists  then  within optimal relaxed plan
s  situation exists  therefore monotone exit path  q e d 
local minima h   
execution path construction discussed different known results
exploiting causal graph acyclicity notions connectedness invertibility domain
transition graphs  e g   jonsson   backstrom        williams   nayak        
new connection h   
remark hand made analysis h   hoffmann        uses notion operators respected relaxation  operator respected relaxation iff 
whenever starts optimal plan s  starts optimal relaxed plan s 
core property many hand made proofs operators respected
relaxation  motivated speculation recognizing property automatically
could key domain analysis recognizing absence local minima h   
explore option herein  however note even basic result outlined
contains cases covered property  even acyclic support graph invertible
transitions without side effects  examples operator respected
relaxation  give construction example    appendix a   

   synopsis technical results
technical results follows structured way similar proof argument
outlined previous section  results structured two parts   a   b  
 a   section    identify circumstances deduce optimal
relaxed plan monotone exit path exists   b   section    devise support graph
based sufficient criteria implying analysis  a  always succeed  technique  b 
underlies torchlights conservative analysis methods  i e   guaranteed global analysis  i 
guaranteed local analysis  ii  described end section    feeding technique
 a  usual relaxed plans computed  e g   ffs heuristic function  obtain
torchlights approximate local analysis  iii   analysis give guarantee 
 and because  ffs relaxed plans guaranteed optimal 
ease reading  give brief synopsis results obtained  a 
 b   provide analysis methods  i  iii   synopsis contains sufficient
information understand rest paper  reader may choose skip sections  
   moving directly evaluation 
analysis method based particular kind sub graph support graph 
table   overviews these  role parts  a   b  follows 
 a  given optimal relaxed plan p    s  state s  optimal rplan dependency graph
odg  sub graph sg single leaf variable x  transition t 
example  rop t    frequently referred o     arc  x  x    odg 
p    s  relies x  achieve conditions t    p    s  relies x moving x   
say odg  successful acyclic  involved transitions usable
exit path construction  e g   harmful side effects   deletes t 
   

fihoffmann

name
support graph

symbol
sg

analysis

approximate
local analysis  iii 
theorem  

optimal rplan
dependency graph

odg 

local
dependency graph

ldg

guaranteed
local analysis  ii 
theorem  

global
dependency graph

gdg

guaranteed
global analysis  i 
theorem  

leaves

single leaf x  s t  applying
t  affect
remainder p    s 
single leaf x  xsg  
s x       sg  x    x 
transitive sg successor
property
single leaf x  xsg

arcs

 x  x    x used
p    s  support x 
obtaining cond t   
 x  x   
s x     cond t    x  
 x  x    x  ldg
 x  x    sg
 x  x    x    x   
 x  x    x  gdg
 x  x    sg

table    overview different support graph sub graphs underlying results 
either relevant p    s  all  recovered inside p    s   main
result  theorem    states local minimum exists successful odg 
s  derives exit distance bound odg    approximating theorem  
applying relaxed plan computed ffs heuristic yields analysis  iii  
 b  given state s  local dependency graph ldg sub graph sg single leaf
variable x    whose goal value yet unachieved  whose transitive successors
sg already attained goal values  setting  x  moves
sake example  graph ldg simply includes sg predecessors x   
single exception pertaining arcs  x  x    x  itself  inserted
corresponding condition t  already satisfied s  say ldg successful
acyclic  involved transitions usable exit path construction  t 
relevant deletes  implies exists successful odg 
contained ldg  thus theorem    stating local minimum
giving corresponding exit distance bound  result underlies analysis  ii  
global dependency graph gdg sub graph sg identifies goal variable
x    includes sg predecessors x    successful defined
way ldgs  gdgs successful  theorem   apply every state
ldg contained successful gdg  thus theorem    stating
state space contain local minima  exit distance bound
obtained maximizing gdgs  result underlies analysis  i  
understanding practical performance torchlight  important note
 a  minimal result would suffice prove  b   cases identified
theorem   much richer actually infer support graphs 
reason  analysis  iii   sound due use potentially non optimal relaxed
plans  able analyze much larger class states analysis  ii   little detail 
difference two methods pertains     whether p    s  relies values
x moving x        whether deletes t  recovered inside p    s  
neither         visible support graph  rely details
form relaxed plan p    s   example  consider gripper domain  notion    
important support graph contains arcs  carry ball b  free gripper 
due dropping ball b  free gripper  carry ball b  due picking ball b 
thus  looking sg  seems carry ball b may support  free gripper
   

fianalyzing search topology without running search

dropping ball want pick up   course  doesnt happen optimal
relaxed plan  notion     important operators  picking ball 
harmful side effects  making gripper hand non empty   side effects always
recovered inside relaxed plan  when dropping ball later on   remains future
work extend analyses  i ii  detect kinds phenomenona 

   analyzing optimal relaxed plans
consider state optimal relaxed plan p    s  s  describe circumstances
monotone exit path guaranteed exist  need number notations
pertaining properties transitions etc  introduce notations along way 
rather front  hope makes easier digest 
 
 
given o  p    s   p  
 s  p  
 s  denote parts p    s  front o 
 
behind o    respectively  p  s  x  denote sub sequence p    s  affecting
x  capture dependencies variables used p    s  achieving
precondition o    follows 
definition    let  x  si   sg   o  planning task  let     h   s      let
p    s  optimal relaxed plan s  let x  x  let o  p    s  operator
taking relevant transition form t     s x     c  
optimal rplan dependency graph p    s   x  o    optimal rplan dependency
graph p    s  brief  graph odg     v  a  unique leaf vertex x   
x v  x  x    either  x    x    x xpreo   preo   x     s x   x    x 
 
 
 s  taking relevant transition x  x xpreo
v    x    exists p  
preo  x     s x  
x v    x     odt g 
x denote sub graph dt gx includes
 
 s  x   relevant transitions using operator
values true point p  
 
p    s  x   least one relevant inverse relevant inverse exists 
 
 s  x  transitions original  inverse transitions induced 
refer p  
transition t  responsible operator o  candidate reaching
exit state  t  figure    odg  collects variables x connected variable x 
 
insofar p  
 s  uses operator preconditioned x order move x   
variables need move  x  x  figure    obtain state s  t 
taken  variable x  odt g 
x captures domain transition graph fragment
 
p  
 s  traverses within stay  t  t  figure   
 
note need consider operators p  
 s  behind o    simply
operators used order establish o  precondition  paramount
importance practice  example gripper situation mentioned above  o  picks
 
ball b gripper  p    s  contain behind o    i e   p  
 s 
 
 
 
operator dropping b  considered definition    odg would contain
mentioned cycle assuming o  used making gripper hand free picking b 
torchlights approximate local analysis  whenever consider operator o   
build odg  re order p    s  moving operators behind o  possible  minimizes
 
p  
 s   odg  thus indeed contains necessary variables arcs 
   

fihoffmann

circumstances t  actually job  sufficient criterion
identify rather complex  provide overview criterion  next state definition  items definition explained below 
definition    let  x  si   sg   o   s  p    s   x    o    t    odg     v  a  definition    say odg  successful following holds 
    odg  acyclic 
    either 
 
 a  odg   relevant deletes t  p  
 s  recoverable 
 
 b  s x    odg  relevant  t  replaceable side effect deletes 
 c  s x    odg   relevant  t  recoverable side effect deletes 

    x v    x     odt g 
x transitions either self irrelevant deletes 
invertible induced irrelevant side effect deletes side effects v   x    
already outlined  exit path construction works staying within ranges
odt g 
x   x v    x     reached state s  transition t 
taken  make little precise  consider topological order xk           x  v    x   
respect odg  order exists due definition   condition       if
cycles  moving variable may involve moving first place 
covered exit path construction   consider    k  d abstracted
task  original task except that  every transition one graphs
odt g 
xi d  remove condition  xj   c  cond t  j   d  exit
path construction understood induction d  proving existence


execution path
whose end t  taken  construct
exclusively
 

x

v
 
 x
  


base case 
operators responsible transitions odt g 
 
x
  abstracted task  t  directly applicable  inductive case  constructed


suitable path
d abstracted task  suitable path
d      
abstracted task constructed follows  assume operator
 


precondition  xd     c  true current state  then  d    
front simply insert path odt g 
xd   ends c  note that 
construction   xd     c  condition transition odt g 
xi         
 
 
taken p  
 s  x    xd     c  must achieved p  
 s  thus c node
 
odt g 
xd     induced transition inverting transition taken p    s  x 
case unless inverse may introduce new outside conditions  thus need
exclude case  leading following definition invertibility 
let    c  c    transition variable x  say invertible iff exists
transition  c    c  dt gx cond c    c  cond c  c    
transition invertible go back without introducing new conditions  e g  
driving trucks logistics   subtle differences previous definitions invertible
operators  authors  hoffmann         allow new conditions even

actually established operator rop t  responsible t  because 
 
necessarily execute executing inverse may got endpoint
via different path odt g 
x   hand  definition generous
   

fianalyzing search topology without running search

common ones because  per se  care side effects inverse
transition may  side effects constrained separately stated definition    
consider definition   condition      apart constraints conditions induced


transitions  odt g 
x transitions taken   must make sure
harmful side effects  obviously  case if  example section   
transitions side effects all  however  easily generalize condition  let
   c  c    transition variable x 
context set ctx t  facts may deleted side effects t 
 y  d  seff t    y  cond t  y   ctx t  condition defined  else
dy values    inserted 

say irrelevant side effect deletes iff ctx t   sg oo preo      

say self irrelevant side effect deletes iff ctx t   sg rop t   oo preo    
 
say tshas self irrelevant deletes iff self irrelevant side effect deletes
 x  c    sg rop t   oo preo  
irrelevant side effect deletes capture case side effect delete occurs goal
precondition operator  self irrelevant side effect deletes slightly
generous allow delete conditions needed responsible operator
rop t  itself  self irrelevant deletes  finally  extend latter notion ts delete 
nutshell  need postulate irrelevant side effect deletes transitions may
executed again  path  examples irrelevant side effect deletes transitions
side effects all  move simple tsp  whose side effect  x   at 
deletes target locations not visited  example operator selfirrelevant side effect deletes  irrelevant side effect deletes  departing passenger
miconic strips  whose side effect  x   served  deletes boarded passenger 
used purpose departure  fact  transition selfirrelevant deletes effect deletes not served passenger  obviously
irrelevant  another example self irrelevant deletes inflating spare wheel tyreworld
wheel longer not inflated 


clearly  odt g 
x transitions may using irrelevant side effect
deletes  then  far invalidating facts needed elsewhere concerned 
good side effects all  understand need require ts
side effect used move another variable x  v    x     recall that  states s 

visited
  construct relaxed plans p    s     p    s      p    s   inverting
transitions t  now  say ts side effect used move another variable x  v    x    
may invert transitions separately  with different operators   thus
would  p    s        p    s   
regarding delete t  may important two reasons  first  deleted
fact may needed relaxed plan s    second  x may traverse odt g 
x several
times  thus may need traverse deleted value later on  covered
invertible  earlier assumed transitions  now  invertible 
constitute problem case self irrelevant deletes  case 
   

fihoffmann

deletes irrelevant except maybe responsible operator itself  therefore 
obtain p    s     simply remove rop t  relaxed plan constructed
predecessor state s     thus  p    s        p    s   reached exit

need continue construction
  example  consider inflates spare wheel
w tyreworld  deletes not inflated w   thus self irrelevant deletes
 not inflated w  irrelevant goal operator   say
state s   relaxed plan p    s     constructed described   p    s       p    s   
rop t   inflate w p    s      inflate w p    s  
inflate w executed yet path  hence removed
relaxed plan  applying inflate w s     get state s  identical s   except w
inflated  clearly  relaxed plan s  longer needs apply inflate w 
rest relaxed plan p    s     still works unchanged  thus p    s    obtained
removing inflate w p    s      yielding  p    s        p    s   desired 
consider endpoint transition t  responsible operator o    previously
demanded x  moves sake  i e   x  goal value
important achieving goal  unnecessarily restrictive  example 
miconic strips  board passenger h  decreases remove
boarding operator relaxed plan  however  boarding means serving
passenger later on  variable x  goal  driverlog  driver may
goal needed drive vehicles  still t  moving driver results
decreased h  location moved away actually needed anymore  latter
example immediately leads definition capturing first one  want
deletes t  needed rest relaxed plan  remove o 
relaxed plan s    reached exit desired 
make precise  recall situation addressing  reached state s 
t     s x     c  applied  yielding state s    relaxed plan p    s   
s   p    s      p    s    p    s    constructed p    s  replacing
 
 s  operators responsible induced odt g 
operators p  
x transitions
x v    x     construct p   removing o  p    s     need p  
relaxed plan s    facts possibly needed p     safe approximation
union sg   precondition o     p    s   odt g 
x values needed
  denote set r    values potentially deleted
induced odt g 
transitions 
x
 
t  contained c       x    s x      ctx t     thus r   c   
fine  simple examples given already  miconic strips 
delete o  boarding passenger p not boarded p   contained
operator precondition goal thus intersection r   c     notboarded p   empty  driverlog  c     at d a   delete o  moving driver
away location a  location irrelevant rest task 
at d a   r   thus  again  r   c     

sharpen further  consider set facts f     op    s  eff
  

 
true relaxed execution p  
 s   say p   f    p needed

   understand latter two items  note first operators preceding o  p    s   i e   operators
 
p  
 s   may still contained p   thus suffice include preconditions
 
 
operators p  
 s   odt g 
x values needed induced odt gx transitions  may needed
 
 
p  p  
 s  

   

fianalyzing search topology without running search

p   relaxed plan s    see this  note first p needed part
 
 
p   pertaining p  
 s   precisely  p cannot operator precondition p  
 s 
 
condition would satisfied  relaxed  execution p  s   also  p
cannot start value induced odt g 
x transition because  definition 
 
values added operators p    s   now  part p   pertaining
 
 
p  
 s   assume p either goal  operator precondition p  
 s   then 
 
 
since p   f  p  s  relaxed plan  either o  operator p    s  must establish
 
p  o    effects true s  anyway  p  
 s   remains unchanged
 
p  thus part covered  too  altogether  thus suffices r   c  f     
example helps satellite domain  say o  switches instrument i 
deletes calibration  i e   calibrated i  c    purpose switching
take images it  thus calibrated i  r   c    however  instrument
may actually calibrated s  so  need switch
calibrated calibration operator requires power
thus calibrated i  false relaxed execution p    s   least o   
particular  calibrated i   f  thus r   c  f     
even condition r   c  f    still sharpened  say exists


 
 s 
o  guaranteed applicable
 possibly empty  sub sequence
o  p  


 
start p    o  re achieves facts r   c  f   both easy

define test   moving
o  start p   job  say case
 
 
 s  recoverable definition   condition   a  
odg  relevant deletes t  p  
example  consider o  picks ball b gripper domain  operator deletes
fact p  free gripper may needed remainder relaxed plan  thus

 
 s  necessarily contain sub sequence
o  moves
p r   c  f    however  p  


 
another room puts b again  re order p  put o  right
start  re achieving p  similar patterns occur transportation domain capacity
constraints  generally domains renewable resources 
finally  identified two simple alternative sufficient conditions t 
suitable  definition   conditions   b    c   sake brevity  sketch
here  require s x     i e   start value t    contained r  
defined above  say case s x    odg   relevant  note that  then 
r   c    unless t  side effects  side effects hurt t  replaceable side
effect deletes  i e   operator whose precondition may deleted replaced
alternative operator o  applicable effect  this happens  e g  
simple tsp   another possibility t  recoverable side effect deletes 
exists operator o  necessarily applicable directly execution t   
recovers relevant side effect deletes  happens quite frequently  example rovers
taking rock soil sample fills store  free store simply
emptying anywhere  replace o  o  obtain relaxed plan p   s   and
thus h   s    h   s    apply o    yielding state s  h   s      h   s 
obtain relaxed plan s  removing o  p    
length exit path be  one move x    nonleaf variable x must provide new value every move variable x 
depending it  i e    x  x    a  new value reached odt g 
x
traversal  denote maximum length traversal  i e   diameter odt g 
x 
   

fihoffmann

  now  may diam odt g      diam dt g   odt g 
diam odt g 
x
x   
x
x
removes vertices arcs  may short cuts traversed p    s  
certain circumstances safe take short cuts  namely if 

    odt g 
x transitions invertible induced irrelevant side effect deletes
side effects v    x     dt gx transitions either irrelevant 
empty conditions irrelevant side effect deletes 
traversing short cut condition  soon reach end shortcut  back region states s  relaxed plan p    s    constructed
before  rest exit path construction remains unaffected  thus 
denote v
p
subset v    x        holds  define costd  odg       xv costd  x  
costd  x    

 



p
 
diam odt g 
x 
x    x x   a cost  x  


min diam odt g     diam dt g    p
x

x

x   x 
x    x    x   v
x    x x   a cost

 x   

x    x    x v

note costd     exponential depth graph  artifact
length estimation  easy construct examples exit distance exponential
parameter  because  hinted  variable may move several times
value required variables depending it  see example   appendix a  
construction  following earlier construction domshlak   dinitz        
said  course costd     may over estimate length shortest exit path 
assumes that  whenever variable x   x  x    makes move  x must move
entire odt g  respectively dt g  conservative      may
move x  actually condition x      even condition exists 
x may need less steps order reach it  one might able ameliorate     making
fine grained distinctions part costd  x    pertains moves conditioned
x  leave open future work  now  note over estimation
exponential even due      i e   costd  odg    may exponentially larger
length shortest exit path even if   x  x    a  moves x  depend x 
shown simple variant example    discuss appendix a   
exit paths using short cuts described way may non monotone  example  
appendix a   contains construction showing this  intuitive understanding 
imagine line l            ln current task  achieve precondition another
operator  move l  ln   say locations line need visited 
relaxed plan  e g  need load unload something locations 
say shortcut via l  needs visited  move l  h 
increases made   step costly relaxed plan reach
locations l            ln   reason  costd  odg    upper bound length
shortest monotone exit path  shown example    construct
   precisely  diam    diameter graph maximum distance vertex v vertex
v   exists path v v    

   

fianalyzing search topology without running search

situation shortest monotone exit path longer costd  odg      obtain
bound monotone exit paths  simply set v    definition costd  
definition   condition   a    b   exit distance bounded
costd  odg      costd  odg    counts last step reducing h   
definition   condition   c   last step need   additional operator reduce
h    exit distance bounded costd  odg     putting pieces together yields
main result section 
theorem    let  x  si   sg   o   s  p    s   odg  definition    odg  successful  local minimum  ed s  costd  odg     definition  
condition   a    b   ed s  costd  odg      
full proof appendix a    pointed earlier  approximate local analysis
 iii  simply feed theorem   relaxed plans returned ffs heuristic function
 hoffmann   nebel      a   important note that  way  give
guarantees  i e   theorem   hold p    s  optimal  even p    s 
non redundant parallel optimal computed ff  end exit
path may obtain relaxed plan shorter p    s  shorter h   s  
nutshell  reason parallel optimal relaxed plan generally  relaxed
plan minimizing number operators may take different decisions
sequentially optimal relaxed plan  thus constructing exit path leading wrong
direction  example   appendix a   gives full construction proving this 
feeding theorem   non optimal relaxed plans course imprecise
direction  i e   theorem   may apply although apply optimal
relaxed plan  thus good cases may go unrecognized  demonstrate simple
modification example    explained example appendix a    importantly 
point section    empirical results suggest weakness
tend occur practice  least far represented benchmarks 

   conservative approximations
identify sufficient criteria guaranteeing prerequisites theorem   hold
true  consider local case particular state given  global
case criterion implies prerequisites theorem   every state task
hand  approximate optimal rplan dependency graphs follows 
definition    let  x  si   sg   o  planning task  let     h   s      let
x  xsg   let t     s x     c  relevant transition dt gx  o     rop t    
local dependency graph s  x    o    local dependency graph brief 
graph ldg    v  a  unique leaf vertex x    x v  x  x    either 
x    x    x xpreo   preo   x     s x   x  v    x     x  x    arc sg 
 
global dependency graph x  o    global dependency graph brief 
graph gdg    v  a  unique leaf vertex x    x v  x  x    either 
x    x  x     x xpreo   x  v    x     x  x    arc sg
 

   remark that  due mentioned sources over estimation costd   constructing example
requires fairly awkward constructs appear likely occur practice 

   

fihoffmann

optimal relaxed plan p    s  contains o    odg  per definition  
sub graph ldg gdg defined here  simply optimal rplan
dependency graph arcs  x  x    contained support graph task   
previously indicated  support graph may contain lot arcs actually necessary 
sg captures may ever support else  support else optimal
relaxed plan  consider earlier point that  constructing odg    take account
operators front o  p    s   information contained sg  thus
gripper get aforementioned cycle dropping ball support free gripper
picking ball 
reader waded cumbersome details previous section
delighted hear defining ldg respectively gdg successful
involve additional notation 
definition    let  x  si   sg   o   s  x    t    o    g   ldg g   gdg
definition    say g    v  a  successful following hold 
    g acyclic 
    g   ldg sg  x       s x     exists transitive successor x  x 
sg x  xsg sg  x       s x    
    t  either 
 a  self irrelevant side effect deletes 
 b  replaceable side effect deletes 
 c  recoverable side effect deletes 
    x v    x     dt gx transitions either irrelevant  self irrelevant
deletes  invertible irrelevant side effect deletes side effects
v    x    
consider first local dependency graphs g   ldg  discuss g   gdg below 
assume optimal relaxed plan p    s  contains o    thus odg 
sub graph ldg  condition     obviously implies definition   condition     
condition     implies definition   condition     odt g 
x contain
irrelevant transitions  condition     implies     s x    odg   relevant  i e   s x   
needed rest relaxed plan  simply un achieved
goal depends x         condition   a  implies definition   condition   a  
r   c      notation introduced previously  conditions   b  definition  
condition   b   respectively   c  definition   condition   c   equivalent given     
regarding exit distance  know parts domain transition graphs
variables x v    x    traversed p    s   obvious bound diam odt g 
x 
length maxpath dt gx   longest non redundant path graph  a path
visiting vertex once   unfortunately  cannot compute maxpath    efficiently  hamiltonian path  garey   johnson        exists graph g    v  a  iff
    gdg  note preo   x     defined    s x    thus x  need recorded
predecessor 

   

fianalyzing search topology without running search

maxpath g     v      thus corresponding decision problem np hard  torchlight over approximates maxpath g  simply  v      however  sometimes use
diam dt gx   instead maxpath dt gx    namely certain x one
variables v used definition costd  odg     certain if 
     dt gx transitions either irrelevant  invertible empty
conditions  irrelevant side effect deletes  side effects v    x    
note strictly stronger requirement definition   condition      clearly 
implies definition   condition     well condition     sectionp   denote v
subset v    x         holds  define costd  g     xv costd  x  
costd  x    

 
x   x 



p

 
maxpath dt gx   x    x x   a cost  x   x    x    x   v


diam dt g   p
costd  x   
x    x   x v
x

 

x    x x   a

x  must move attain goal every optimal relaxed plan must take
least one transition leaving s x     thus  theorem   above  that 
theorem    let  x  si   sg   o  planning task  let state     h   s   
  say x  x that  every o    rop s x     c  dt gx   s x     c 
relevant  ldgo  successful local dependency graph  local minimum 
ed s  maxo  costd  ldgo     if  every ldgo    definition   condition   a 
  b   ed s  maxo  costd  ldgo      
theorem   tool guaranteed local analysis  ii   guaranteed global analysis
 i   simply look set global dependency graphs gdg  requiring
successful  particular  gdg acyclic  difficult deduce
non goal state variable x  fulfilling definition        x   
apply theorem   thus get 
theorem    let  x  si   sg   o  planning task  say global dependency graphs
gdg successful  contain local minima and  state
    h   s      ed s  maxgdg costd  gdg   if  every gdg  definition  
condition   a    b   ed s  maxgdg costd  gdg    
full proofs theorems     appendix a    sg acyclic
transitions invertible side effects  theorem   applies  whereby
particular proved basic result  vice versa  note that  theorem   applies 
sg acyclic  far local minima concerned  one may thus reformulate theorem  
simpler terms relying notion successful dependency graphs  apart
allowing determine exit distance bound  present formulation already paves
way future research  gdg defined relative concrete variable x  operator
o    may thus allow accurate analysis variables may actually
become important x  o    optimal relaxed plan 
use diam dt gx   instead maxpath dt gx   costd      variables
v   rather significant effect quality bounds computed many
   

fihoffmann

benchmarks  typical example transportation domain vehicle positions leaf
variables sg whose transitions side effects  variables qualify v   using
maxpath dt gx   instead  would obtain exceedingly large bounds even trivial road
maps  example  consider logistics road map fully connected 
diam dt gx       thus costd     delivers correct bound    using maxpath dt gx  
instead get bound n    n total number locations dt gx  
note that  within scope theorem    i e   class planning tasks
theorem   applies  plan existence tractable  namely  exists plan task iff
exists relaxed plan initial state  because  starting optimal
relaxed plan  guaranteed able construct exit path  iterating argument
gets us goal  view  tractability weakness form global
analysis  analysis apply intractable classes tasks contain
local minima  note classes exist  cf  theorem    hand  plan
existence tractable known benchmark domains local minima absent 
practice appear major limitation  also  note plan construction 
well optimal planning  still intractable within scope theorem    plan
construction intractable plans may exponentially long  cf  example  
appendix a    optimal planning  consider logistics miconic strips 
see shortly  proposition    next section  fully covered theorem   
however  them  deciding bounded plan existence np hard  helmert        
interestingly  fact theorem    therewith indirectly theorem    rely
optimal relaxed plans source intractability plan construction here  theorem  
applies  non redundant relaxed plan p   successful odg    enabling us
construct path state particular relaxed plan  although necessarily
optimal relaxed plan  shortened  iterating argument gives us constructive
method obtaining plan  worst case exponential behavior lies
length individual path segments  said  course plan constructed
way may highly non optimal  indeed  shown example   appendix a   
plan may exponentially longer optimal plan  thus  even theorem   applies
need optimality guarantee  running planner still makes sense 
discuss relation scope theorem   known tractable classes
section    basic fact one construct local minima even small examples
involving two variables complying basic result except either
support graph cyclic  example    appendix a     non invertible transition
whose delete relevant  example    appendix a     transition
relevant side effect delete  example    appendix a     examples contained
many known tractable classes  thus underlining automatic analysis h  topology
identification tractable classes different  although related  enterprises 

   benchmark performance guarantees
state guarantees analyses  i  iii  give benchmark domains 
underlying finite domain variable formalizations straightforward  correspond
   

fianalyzing search topology without running search

formulations found automatically fast downward  listed
appendix a    give proofs following two simple observations   
four benchmark domains  guaranteed global analysis  i  always succeed  
proposition    let  x  si   sg   o  planning task logistics  miconic strips 
movie  simple tsp domain  theorem   applies  bound delivered
           respectively 
follows trivially proposition   guaranteed local analysis  ii  succeeds
domains well  state one four listed domains  theorem  
applies s  bound delivered stated 
note bounds logistics movie correct ones  i e   tight 
miconic strips  over estimation actual bound  which       arises
analysis realize boarding passenger used leaf
variable x    simple tsp  correct bound    since h  exact goal distance  
over estimation arises because  every goal variable x   visited location   gdg
includes variable at  realizing value matter
location visited one 
transportation benchmarks involving capacity constraints  approximate local
analysis  iii  always succeed  provided suitable optimal relaxed plans 
proposition    let  x  si   sg   o  planning task elevators  ferry  gripper 
transport domain  let s  ferry gripper  every optimal relaxed plan
p    s  exists odg  theorem   applies  bound    elevators
transport  exists least one p    s  odg  theorem   applies 
bound   elevators road map diameter transport 
relevant deletes t    cases  due effects decreasing remaining vehicle capacity  free gripper gripper domain  decrease capacity
always due load type operator  matched unload type operator
later inside relaxed plan  thus deletes always recovered inside p    s   we
definition   condition   a    further  relaxed plans never use unload action
free capacity loading object  thus odg  cycle free  hence
odg  successful  theorem   applies  elevators transport  proposition  
slightly weaker vehicle may capacity      allowing forcing
relaxed plans use unloading operators recovering capacity actually present 
note similar patterns likely occur domain renewable resources 
recognized definition   condition   a  way 
proposition   hold theorems      i e   ldgs gdgs  due
two deficiencies  cf  discussion end section     first  sg contains cycles
unloading object order free capacity loading it  second  definition  
condition   a  restrictive definition   condition   a   postulating deletes
t  entirely irrelevant  way removing deficiencies 
guaranteed analyses  i ii  would succeed four domains proposition   
    say found automatically fast downwards translator deterministic  i e  
may return different finite domain variable encodings even run several times planning
task  encodings correspond domain formalizations  elevators 
give full definition because  without action costs  merely variant transport 

   

fihoffmann

   experiments
report large scale experiment torchlight  fill details torchlights implementation  describe simple alternative analysis technique based
search probing  explain experiments set up  report runtime results different
stages torchlight  describe torchlights analysis results per domain basis 
assess quality analysis terms predictive capability  finally summarize
outcome torchlights diagnosis facility benchmarks 
    torchlight
torchlight implemented c based ff    torchlight currently handles strips only 
i e   adl domains  uses fast downwards translator  helmert        find finitedomain variables  establishing correspondence variables  respectively
values  ffs internally used ground facts mostly straightforward 
details take care of  omit brevity 
parsing fast downwards variables  torchlight creates data structures representing support graph domain transition graphs  enters phase refer
static analysis  determines fixed properties as  every transition t 
whether irrelevant  invertible  etc  next step guaranteed global analysis  i  
checking preconditions theorem   enumerating global dependency graphs
testing whether successful  able report percentage successful gdgs 
stop first unsuccessful one 
local analysis techniques guaranteed local analysis  ii  using theorem  
approximate local analysis  iii  using theorem   run set ls states comprising
initial state well number r sample states obtained random walks starting
si   set ls identical analyses  run technique state
ls regardless outcome running respective technique is 
given s  analysis  ii  checks theorem   constructing local dependency graph
every suitable variable x  every transition t  leaving s x     find non successful
t    stop considering x    minimize exit distance bounds across different x   
analysis  iii  checks theorem   relaxed plan p    s  computed ffs heuristic
function  case relaxed plan exists s  analysis reports failure  otherwise 
analysis proceeds operators o  p    s   start end  variables
x  affected o    pair o    x  build optimal rplan dependency graph odg 
per definition    skip variables x  eff o   x    actually used precondition
goal  rest p    s   odg  successful  stop   relaxed plans big
large examples  continuing analysis exit bound minimization sometimes
costly   mentioned section    build odg  re order p    s  moving
operators behind o  possible  paramount importance avoids including
unnecessary variables odg    re ordering process straightforward  starts
direct predecessor o    tests whether p    s  still relaxed plan moving
directly behind o    yes  arrangement kept  iterate predecessor
o  forth  easy see that  way  odg  contain exactly variables
    source code torchlight online appendix paper  available download
http   www loria fr  hoffmanj torchlight zip 

   

fianalyzing search topology without running search

transitions used p    s  achieve preo    finally  check whether odg   
relevant deletes t  p  
 s  recoverable  use simple technique allowing recognize
situations failure due one operator avoided replacing alternative
operator  example  transport o  loading operator reducing capacity level k
k    p    s  may still contain unloading operator relying level k  thus level k
contained r   c    causing failure  however  unloading well
performed based capacity level k    removing difficulty  catch cases
construction r     whenever find whose precondition overlaps c    test
whether replace similar operator 
local analyses return simple statistics  namely minimum  mean  maximal
exit distance bound found  well success rate  i e   fraction sample states
guaranteed local analysis  ii  approximate local analysis  iii  succeeded  analysis
 iii  success rates main focus  turn informative 
run r                    experiment  length random walk
chosen uniformly     hff  si    i e     times heuristic value
initial state  play parameter    important  however 
parameter chosen small  domains many dead ends one may
things fatally wrong likely bad things happen
sufficiently large number random choices  consequently  dead end rate  i e  
fraction sample states relaxed plan exists  tends larger longer
random walks  since analysis  iii  fails states relaxed plan  exerts
important influence analysis  iii  success rates  illustrate comparing
results sampled states results obtained using initial states only 
    search probing
approximate analysis sample states  exists simple  and rather obvious  alternative torchlights causal graph based technology  one use search determine
whether given sample state local minimum  exit distance is  since
cannot compute h  effectively  search based analysis necessarily approximate 
straightforward method replace h  relaxed plan based approximation 
herein  replace h  hff   i e   ffs heuristic function  precisely  given state
s  run single iteration ffs enforced hill climbing  i e   breadth first search
state better heuristic value  search  does  use helpful actions
pruning avoid huge search spaces  unlike ff  focus detection states
local minima  allow monotone paths  thus restricting search space states s 
hff  s      hff  s    refer technique search probing  sp brief 
experiment variant imposing   second runtime cut off search  refer
limited search probing  sp s brief  sp sp s run set ls
states torchlights local analyses  ii iii  
turns out  empirically present benchmarks sp sp s competitive torchlights analysis  iii   since analysis main focus experiments 
relevant understand commonalities differences techniques 
far analysis quality guarantees concerned    techniques analysis  iii  
sp  sp s similar properties  guarantees whatsoever  may report
   

fihoffmann

success although local minimum  false positives   may fail although
local minimum  false negatives   cases  false positives due use
non optimal relaxed plans  hff instead h     false negatives inherent analysis  iii 
covers certain special cases  inherent sp s due search
limit  sp false negatives due helpful actions pruning  however could
principle turned off  fundamental source false negatives non optimal
relaxed plans  responsible lack connections across techniques 
implication trivial one sp s success state implies sp success
s  particular  analysis  iii  correctly identifies local minimum 
imply sp well  causal graph analysis may less affected
irregularities hff surface  happens  example  transport domain
ipc       resulting higher success rates analysis  iii  
obvious important differences regarding runtime performance
danger false negatives  sp runtime worst case exponential size
 grounded  input  whereas analysis  iii  sp s runtime low order polynomial
size  sp  decreasing number r sample states merely reduces chance hitting
bad state  a sample state large flat region   whereas analysis  iii  sp s scale
linearly r  hand  analysis  iii  sp s buy efficiency
incompleteness  i e   increased danger false negatives  analysis  iii  simply recognizes
special cases  sp s effectively bounds lookahead depth  i e   search depth
exit states detected 
indicated  sp sp s turn competitive benchmarks  large search
spaces rare sp  success rates sp sp s similar  far predictive
capability concerned similarly informative analysis  iii   thus goodquality success rates obtained much simpler techniques torchlight   
notwithstanding   a  torchlight functions guaranteed analyses  i ii 
well diagnosis cannot simulated   b  results benchmarks ever
pertain examples  torchlights analysis  iii  offers unlimited lookahead depth
low order polynomial cost  appear matter much present benchmarks 
natural cases matter  get back below 
    experiments set up
run experiments set    domains  include domains investigated
hand made analysis h  topology  hoffmann         shown figure   
include domains international planning competitions  ipc  ipc      
remaining domains strips  versions the  domains ipc      ipc
      except ipc      cyber security omit due parsing difficulties    test
instances collected ipc collection s  applicable  removing action cost
constructs ipc      domains   randomly generated elsewhere  total 
test set contains      instances 
    particular  search probing appears rather useful technique  raising question
techniques yet used performance prediction purposes  roberts howe        
example  use simple features only  get back conclusion 
    instances large ffs parser standard configuration  tweaking bison allow
larger parse trees  obtained segmentation fault even smallest instance ipc      

   

fianalyzing search topology without running search

tool phase
fd translator
sg dtg
static analysis
analysis  i 
sample states
analysis  ii 
analysis  iii 
torchlight total
torchlight  iii 
torchlight  iii  fd
sp
sp total
sp s
sp s total

lama

single shot r    
mean
max
    
      
    
    
    
     
    
     
    
    
    
    
    
    
    
      
    
      
    
     
    
     
    
     
    
    
    
    
      

      


r     
mean
max

    
    
    
    
    
    
    
    
    
    

    
    
    
      
      
     
      
      
    
    

r      
mean
max

    
    
    
    
    
    
    
    
    
    

     
    
     
      
      
      


     
      

r       
mean
max

    
    
    
     
     
     
     
     
    
     

      
     
      
       
       
      


      
      

table    summary runtime data  mean max instances domains 
empty fields  respective tool phase single shot  i e   depend r 
dash means time out       seconds  inserted runtime respective instance mean computation  rows fd translator       analysis
 iii  time different stages torchlight  torchlight total overall runtime  torchlight  iii  run analyses  ii   iii   torchlight  iii 
fd latter disregarding translation costs  sp determines success rate  fraction sample states deemed local minima  via search
probing  i e   search around sample state  sp s imposes   second time out
searches  sp total sp s total include time generating
sample states 
experiments run     ghz cpu     minute runtime   gb
memory cut off  run   different planners tools  apart torchlight  and sp sp s   
include  hoffmann   nebel      a   lama  richter et al         richter
  westphal         purpose running planners assess extent
torchlights output particular analysis  iii  success rate predict planner success
failure  examine plain planner  run version uses
goal ordering techniques  runs enforced hill climbing  without resorting
best first search fails  refer planner ehc follows 
    runtime
code currently optimized much readability speed  still  torchlight
fast  r        bottleneck fast downwards translator  r              
actual analysis takes much time translator                
       instances respectively  assess detail  consider table  
gives timing different stages torchlight  planners tools 
translation runtime sometimes hurts considerably  peak        seconds
costly instance scanalyzer domain  rather exceptional  however 
second costly domain blocksworld noarm  peak        seconds 
   

fihoffmann

      domains  costly instance translated less    seconds 
       instances  fast downwards translator takes   second 
static analysis  peak behavior       seconds  also scanalyzer  even
exceptional         instances  static analysis takes   second  second
highest domain peak      seconds pipesworld tankage  similarly  analysis  i 
takes peak       seconds blocksworld noarm        instances
completes   second  domain blocksworld noarm
peak instance takes    seconds airport  peak       seconds  next
highest domain peaks pipesworld tankage        scanalyzer         logistics        
woodworking         domains  analysis  i  always completes within second 
turning focus local analyses  see even effective  particular  concentrate mostly approximate local analysis  iii   see
r        offer advantages r     far information obtained
goes  mostly concentrate r      r               analysis  iii  completes   second                        instances respectively 
r        still holds        instances  peak runtime       seconds
r       occurs scanalyzer  next highest domain peaks blocksworld noarm
        pipesworld tankage         ferry        logistics         blocksworld arm        
optical telegraph         airport            domains  analysis  iii 
r       always completes within second 
bottleneck local analysis generation sample states  costly
involves repeated computation applicable operators random
walks  r     peak       seconds scanalyzer domain  however 
again  peak behavior exceptional  r               sampling completes
within   second                      instances respectively 
main competitor torchlight analysis  iii  success rates search probing  i e  
sp sp s   consider moment analysis methods themselves  i e   row
analysis  iii  vs  rows sp sp s table    compared sp s   analysis  iii 
consistently advantage  except maximum runtime r       difference
dramatic  expected  given sp s trades completeness small
fixed maximum runtime  compared complete search sp  analysis  iii  consistently
significant advantage  however  r    mean runtime sp tolerable 
even maximum runtime bad  further  bad runtime behavior exceptional 
r          sp completes   second               instances
respectively      r      respectively     r          domains even maximum
runtime   second  r        sp two time outs  blocksworld arm 
r            time outs  blocksworld arm  blocksworld noarm  freecell 
pipesworld notankage  r        maximum runtime    seconds
  domains  r             however  r              sp still completes
  second               instances respectively  compared       
       analysis  iii   cf  above  
neither analysis  iii  search probing stand alone methods  former requires
torchlight except analyses  i ii   latter requires sampling random states 
respective total data given rows torchlight  iii  sp total  sp s total
table    picture changes dramatically favor sp especially sp s  
   

fianalyzing search topology without running search

noted  though  mostly due overhead translation finite domain
variables  overhead artifact implementation  approach defined
finite domain variables  benchmarks not  even though finite domain
representation cases natural boolean one  further  many planners
 notably fast downward quickly growing set derivatives  use translation
anyway  runtimes without translation given row torchlight  iii  fd 
one would hope expect  analysis methods much faster actual planners  lama     time outs test suite      
    analyzing domains
discuss actual analysis outcomes  per domain basis  first consider
torchlight  give details comparison analysis  iii  success rates
obtained search probing  begin  words order regarding
comparison sp sp s   r                     success rates identical
                                   benchmark instances respectively         
                       instances  success rates differ     thus 
small runtime cut off adversely affect success rates search probing  because
long searches rare   so  henceforth discuss data sp vs 
sp s separately  compare torchlights analysis  iii  success rates sp only 
guarantees proposition   confirmed  i e   guaranteed global analysis  i  succeeds described logistics  miconic strips  movie  simple tsp  never succeeds
domain  though  domains  fractions gdgs successful  precisely  maximum fraction successful gdgs     satellite      ferry        
tpp         driverlog      depots         tyreworld        blocksworldarm  however  fraction      nothing proved  data may
best used give indication aspects domain good natured 
guaranteed local analysis  ii  generally much applicable global analysis 
thus concentrate approximate local analysis  iii  exclusively 
proposition   backed impressively  even r         analysis  iii  succeeds
every single sample state ferry  gripper  elevators  transport    indicates
strongly potentially sub optimal relaxed plans result loss information
here  indeed  analysis yields high success rates almost domains local minima
non present limited  case domains  thus torchlight
distinguish domains easy h  topology hard ones  consider figure   
showing mean analysis  iii  success rates per domain r       the picture similar
r                  cf  table   below  
domains whose h  topology known shown separately right hand
side figure    domains  see quite nicely harder domains tend
lower success rates  particular  easiest domains bottom class
     success rates      case zenotravel   whereas hardest domains
top right corner around     less  latter domains  extent
    historically  observation preceded proposition    well h  topology categorization elevators transport per figure    is  hand made analyses motivated observing
torchlights analysis outcome 

   

fihoffmann

pipestank     
pipesnotank     
psr     

rovers      
opttele    

mystery     
mprime     
freecell     
airport    

hanoi    
blocksnoarm     
grid     
transport        
bench ed    c

local minima ed    c

blocksarm     
depots     
driverlog      

elevators        
logistics        
ferry        
gripper        
undirected

woodwork     
trucks    
tpp     
storage     
sokoban     
scanalyzer     

tyreworld      
dinphil     
satellite      
zenotravel     
miconicstr        
movie        
simpletsp        
harmless

recognized

pegsol    
pathways     
parcprinter    
openstacks    
unrecognized

figure    overview torchlight domain analysis results     guaranteed global analysis
 i  always succeeds     approximate local analysis  iii  always succeeds
provided optimal relaxed plan  numbers shown mean success rates per
domain  approximate local analysis  iii  r      i e   sampling
single state per domain instance 
low success rates result recognition dead ends ffs heuristic function 
example  random sampling make random vehicle moves consuming fuel 
mystery mprime  course chances end state fuel
scarce even relaxed plan exist anymore  pronounced
airport  sample states infinite heuristic values  however  capabilities
analysis go far beyond counting states recognized dead ends  blocksworld arm 
example  dead ends still success rate      clearly
indicating domain difficult topology 
extent  based success rates even distinguish pipesworld tankage
pipesworld notankage  mprime mystery  in mprime  fuel transferred
locations   relatively high success rate depots probably relates transportation aspects  grid      cases analysis strong enough recognize
reasons behind non existence local minima  reasons quite complicated
 hoffmann         dining philosophers really favorable h  topology 
rather excessive bound    due particular domain structure philosophers
behave strictly symmetrical ways  hoffmann         apart this  strong
outliers driverlog  rovers  hanoi  blocksworld noarm  problems hand made analysis torchlights  driverlog rovers  deep local
minima exist  awkward situations dont tend arise ipc instances  thus hand made analysis  worst case nature  pessimistic
here  opposite happens hanoi blocksworld noarm  absence local
minima due rather idiosyncratic reasons  example  hanoi reason h 
always equal number discs yet goal position relaxation  one
always accomplish remaining goals one by one  regardless constraints entailed
positioning  hanoi blocksworld noarm actually easy solve
   

fianalyzing search topology without running search

domain
airport
blocks arm
blocks noarm
depots
din phil
driverlog
elevators
ferry
freecell
grid
gripper
hanoi
logistics
miconic
movie
mprime
mystery
opt tele
pipes notank
pipes tank
psr
rovers
satellite
simple tsp
transport
tyreworld
zenotravel
openstacks
parc printer
pathways
peg sol
scanalyzer
sokoban
storage
tpp
trucks
woodworking

si
 iii 
    
    
    
   
   
   
   
   
    
    
   
   
   
   
   
    
    
 
    
    
    
   
  
   
   
   
  
   
   
   
 
 
    
   
   
    
   

r  
 iii 
sp
   
   
         
    
   
    
   
         
   
   
   
   
   
   
         
    
   
   
   
        
   
   
   
   
   
   
         
         
        
         
         
         
   
   
   
   
   
   
        
   
   
  
   
 
   
   
   
         
 
  
         
         
         
         
 
 
         

r     
 iii 
sp
   
   
         
    
   
         
         
    
   
   
   
   
   
         
         
   
   
         
   
   
   
   
   
   
         
         
   
   
         
         
         
        
    
   
   
   
        
    
   
         
         
   
   
   
   
         
         
         
         
         
   
   
         

r      
 iii 
sp
   
   
         
         
         
         
         
   
   
   
   
         
         
   
   
         
   
   
   
   
   
   
         
         
   
   
         
         
         
        
    
   
   
   
        
    
   
         
         
   
   
   
   
         
         
         
         
         
   
   
         

 iii 
   
    
    
    
    
    
   
   
    
    
   
    
   
   
   
    
    
   
    
    
    
   
    
   
   
    
    
    
   
   
    
    
    
    
    
   
    

r       
sp
   
    
    
    
    
    
   
   
    
    
   
    
   
   
   
    
    
   
    
    
    
    
    
   
    
   
    
    
   
   
    
    
    
    
    
   
    

de
    
 
 
 
    
 
 
 
    
 
 
 
 
 
 
   
    
    
 
   
 
 
 
 
 
 
 
    
    
    
    
 
    
 
    
    
    

table    mean success rates per domain  upper part  domains whose h  topology previously examined hand  hoffmann        trivial examine based
results  lower part  ipc           domains case  columns
si show data analyzing initial state only  columns r                   
analyzing respective number sample states  columns  iii  give data
approximate local analysis  iii   columns sp give data search probing 
column de gives dead end rates r        
ff  sense  practical perspective  low success rates torchlights
analysis  iii  provide accurate picture 
table   gives complete account per domain averaged success rates data  including
domains  values r  rates obtained initial states  using sp instead
torchlight  serves answer three questions 
    important sample random states  rather analyzing initial state 
    important sample many random states 
   

fihoffmann

    competitive analysis  iii  respect search based analysis 
answer question     clear yes  importantly  pertains domains
dead ends  cf  brief discussion above  clear table   that  domains 
analyzing si results tendency optimistic  see this  consider entries
airport  dining philosophers  freecell  mystery  openstacks  parc printer  pathways 
tpp  trucks  woodworking  domains dead ends  variety reasons 
dead ends occur frequently initial state level  occur frequently
random walks cf  column de table     interestingly  domains notably
two pipesworlds opposite happens  i e   success rates lower si
sample states  clear us causes phenomenon  
simply compare si column r        column analysis  iii  
find result lot different           domains 
extent  difference initial states sample states may due
way benchmarks designed  often  initial states every instance similar
certain ways  no package loaded yet  etc   hand  seems quite natural 
least offline problems  initial state different states deeper
state space  consider transportation problems card games  example  
answer question     clear no  example  compare r    
r        columns analysis  iii   difference greater      
   domains  peak difference openstacks        r        vs    
r      average difference domains        similarly  comparing r    
r        columns sp results      domains difference greater
     peak openstacks        r        vs       r     
average difference domains      
answer question     bit complicated  look columns analysis
 iii  respectively sp r         number domains difference larger
           peak       difference scanalyzer  one
hand  still means       domains analysis result get close
search  average difference         without actually running search 
hand  happens    domains  these  success rate sp
higher torchlight  surprising basically means torchlights
analysis strong enough recognize states local minima 
interestingly  weakness turn unexpected advantage     domains
question    domains blocksworld arm  depots  mprime  pipesworld tankage  pipesworldnotankage  psr  scanalyzer  sokoban contain deep local minima    thus 
  domains  would wish analysis return small success rates  torchlight grants
wish much sp does  consider happens using sp instead analysis
 iii  figure    mystery  psr  sokoban  change dramatic  however 
blocksworld arm marked average success rate    instead     putting almost
par very simple topology domains bottom class  similarly  pipesworldtankage  pipesworld notankage  scanalyzer put almost par these  depots
    sokoban unrecognized dead ends  in relaxation  blocks pushed across other 
therefore local minima  scanalyzer  analyzing plants misplaces side effect  bringing
back start position  across large circle conveyor belts  may take arbitrarily many steps 
see figure     domains 

   

fianalyzing search topology without running search

actually receives      putting exactly par them  thus sp analysis outcome
actually looks quite bit worse    domains 
causes undesirably high success rates sp  authors best guess that 
many domains  chance randomly finding state local minimum low 
large scale experiments measuring statistics search space surface ffs heuristic
function  hoffmann         observed many sampled states local minima
themselves  contained valleys  within valley  monotonically
decreasing path goal state  state may local minimum because 
because  one descend deeper valley  seems sp correctly identifies
valley states local minima  thus counting good many states actually
located difficult regions search space  weakness sp  success
rate search space feature    weakness manifest much
analysis  iii   analysis picky takes good states
qualify particular special cases  tend occur often difficult domains 
course  easy construct examples turning discussed strength real
weakness torchlights analysis quality  seem happen lot
present benchmarks  now  said that  present benchmarks arent well suited
bring theoretical advantage analysis  iii  either  analysis offers unlimited
lookahead depth low order polynomial cost  however  even r              
domains highest exit distance bound returned    i e   every exit path identified consists
single operator  cases could handled much simpler variant analysis
 iii   looking operators o  directly applicable s  thus removing
entire machinery pertaining sg predecessors x    still  machinery matter
cases quite natural  highest exit distance bound returned    grid  
transport  generally  transportation domain non trivial road map 
easy construct relevant situations  example  say road map transport forms n
cities  diameter least one vehicle  distances cities large
relative d  then  typical state  around n vehicle moves considered helpful
ff  least   per city since local vehicles preferred relaxed plan 
successor states identical h  package loaded unloaded  typical
number steps required grow d  if  example  vehicle
outskirts packages city center  around d   steps required 
finding exit takes runtime around n d     small values n already
render search probing either devoid information  if runtime cut off small  
computationally infeasible  recall probing quick pre process
actual planning   contrast  analysis  iii  easily delivers correct success rate      
    predicting planner performance
direct measure predictive quality success rates  conducted preliminary
experiments examining behavior primitive classifiers  runtime distributions
large vs  small success rates  consider first classifiers  predict  given
planning task  whether ehc ff lama succeed solving task  within given
    note cannot use valley rate instead  cheap domain analysis  since determining whether
lies valley implies finding plan thus solving task side effect 

   

fihoffmann

time memory limits  classifiers answer yes iff success rate threshold
                    obviously  this  need r      consider follows
r      r       because  shown above  r        costly 
ehc  torchlight analysis  iii  sp deliver fairly good quality predictions 
considering actual machine learning involved  prediction quality torchlight good sometimes slightly better search  whether use
r      r       make big difference  ehc solves        instances 
rate correct predictions trivial baseline classifier always answering yes 
r       best rate correct predictions        torchlight  with      
       sp  with        r        numbers         t      
        t         dead end rate bad predictor  best prediction
baseline classifier      second best classifier  t               correct 
interestingly  major differences different sets domains 
domains previously analyzed hand  hoffmann        figure   without elevators
transport   best prediction        correct torchlight      
       correct sp        vs  baseline         ipc      domains 
numbers               vs  baseline              cases  i e  
best classifier close baseline  ipc       hand  appears
exceptionally good natured  numbers         t               t       vs 
baseline         clear us causes phenomena   
summary  quality prediction always clearly baseline  around    
looking domains  even     looking ipc      domains
only  comparison  using state of the art classification techniques simple features  roberts howe        get        correctness vs  baseline      for saying no  
unseen testing domains ff  said that  setting considered
learning  actually distinguish learning data
testing data  roberts howes unseen testing domains ipc       in
different setting including adl test suites   set
domains       figure   without elevators transport   get
best prediction      torchlight       sp  setting  
prediction correctness ipc      suite        respectively        only  vs 
baseline         hand  seems pertain ipc      specifically 
ipc            respectively       good settings  giving        respectively
       correctness vs  baseline        
importantly  roberts howe predicting performance ehc
ff  complex algorithm  lama  prediction quality
torchlight sp rather bleak  using described primitive classifiers  cases 
best prediction correctness obtained always answering yes  best
said success rate still predicts much better dead end rate  give
example data  r      across domains ff  baseline        correct 
      goes        torchlight         sp         dead end
rate  lama  baseline        correct       goes       
    bad prediction quality ipc      domains might related fact fully grounded 
potentially impeding ability fast downwards translator find useful finite domain variables 

   

fianalyzing search topology without running search

torchlight         sp         dead end rate  lama 
growing prediction quality decreases monotonically cases 
prediction quality much worse ehc 
main building block ff  whereas ehc typically fails tasks whose h  topology
favorable  ffs lamas complete search algorithms able solve many
cases  too  example  torchlight success rates r       ehc solves
       tasks success rate    solves less     success rate     
contrast  lama solve        respectively        tasks success rate
   solve least     success rates 
despite this  success rates far devoid information lama  setting
threshold                  look distribution planner runtime instance
subset  a  success rate     vs  instance subset  b  success rate  
taking null hypothesis means two runtime distributions
same  run students t test unequal sample sizes determine confidence
null hypothesis rejected  is  determine confidence
distribution  b  lower mean distribution  a   using torchlights success rate
runtimes  r      r           settings   get confidence
least        difference means data  i e   mean runtime
 a  minus mean runtime  b   tends grow   peaks     respectively    
seconds r      respectively r        average difference values    
respectively      likewise  lama runtimes settings r yield confidence
       average differences     respectively      results sp comparable
lama  slightly worse ff  though  r      confidence      
          confidence     values   difference peaks    
seconds  vs      torchlight   average     seconds  vs        r       
thresholds                   yield       confidence  average difference     
perhaps little surprisingly  simpler planner ehc runtime distributions behave differently  torchlight success rates  get several cases
confidence        average differences around    seconds  sp  cases
get       confidence mean  b  larger  a   again  reason
simple  many tasks unfavorable h  topology  enforced hill climbing quickly exhausts space states reachable ffs helpful actions  ehc gives solving
task  although consumed little runtime peculiar behavior one would
certainly expect planner trying competitive 
summing up  success rates planning task feature provide good coverage
predictor ehc even without significant learning  lama  things
easy  however consideration runtime distributions clearly shows
feature highly informative  exploiting informativeness predicting planner performance presumably requires combination features  actual machine learning
techniques  along lines roberts howe         topic future research 
    diagnosis
let us finally consider torchlights diagnosis facility  idea behind facility
summarize reasons analysis failure  testing sufficient criteria absence local
   

fihoffmann

minima  diagnosis guaranteed identify domain features causing presence 
still  least analysis using theorem    diagnosis quite accurate 
current diagnosis facility merely first shot implementation based reporting
pairs  operator o    variable x  caused odg  o  successful  is 
report pair  o    x  o  effect x  context fact  x  c  transition
t  taken o  contained r   c  f    recoverable sub sequence
 
p  
 s   brief  record  o    x  o  harmful effect x  perform test
whether main effect o    i e   x    invertible  case record
x  since problem appear side effects  avoid redundancies reporting 
record grounded operator o  name action schema  load
instead load package  truck     similarly  option record x name
predicate underlying fact  x  c   configuration  diagnosis comes
form action name  predicate name  direct match high level pddl
input files  measure parts diagnosis important 
associate pair count occurrences  weigh pairs frequency 
zenotravel  diagnosis output always form fly  fuel level zoom 
fuel level  indicating correctly fuel consumption causing local
minima  mprime mystery  cause local minima same  however
diagnosis reliable specific structure domain  associating fuel
locations instead vehicles  sometimes causes diagnosis conclude
effect changing locations causing trouble  concretely  r       
mystery  fuel consumption top weighted diagnosis       tasks 
mprime  happens       tasks  satellite rovers  diagnosis
always takes form switch on  calibrated respectively take image  calibrated  thus
reporting problem switching instrument  respectively taking image 
deletes calibration  precisely reason local minima exist here   
tyreworld  often diagnosis reports problem jacking hub results
longer jack  which needed elsewhere  too   actually
cause local minima  there none   indeed appears crucial aspect domain 
similarly  grid frequent diagnosis picking key results arm
longer empty again  actually cause local minima  critical resource
domain  blocksworld arm  dominant diagnoses block longer
clear stack something top it  hand longer empty picking
block  similarly  freecell  dominant diagnoses send to free  cellspace
send to new col  colspace 
one could make list much longer  however seems clear already
diagnosis facility  although yet primitive  potential identify interesting aspects
domain  note making use one information sources
torchlight  many things recorded  pertaining reasons
analysis failure  support graph cycles etc  reasons analysis success 
successful gdgs x    o  pairs yielding successful odg  s  appears promising try
improve diagnosis combining information sources  combination
    since analysis failure rare two domains  often diagnosis give output all 
r         output non empty    instances satellite   instances rovers  r      
reduces   instances satellite  single one rovers 

   

fianalyzing search topology without running search

domain analysis techniques  landmarks invariants extraction  could
useful  direction future work   

   related work
prior work aforementioned one author  hoffmann       
trying automatically infer topological properties heuristic function  thus work
relate strongly domain analysis techniques  closest relation
techniques relying causal graphs  follows discuss detail  along
connections arising context 
local analysis succeeds  construct path exit identified  this 
work relates work macro actions  e g   botea  muller    schaeffer        vidal 
       distinguishing feature macro action  would be  constructed
targeted analytical way  even giving guarantee  conservative case  make
progress towards goal  machinery behind analysis based causal graphs 
shares similarities known causal graph based execution path generation methods
 e g   jonsson   backstrom        williams   nayak        brafman   domshlak        
distinguishing feature focus h  individual states rather
whole task  allows us consider small fragments otherwise arbitrarily complex
planning tasks look odg  instead sg  note ability quite powerful
far applicability goes  seen section    success rate  local 
approximate analysis therewith fraction states would able
generate macro action non zero almost benchmark domains  course 
broad applicability comes prize  traditional causal graph methods guarantee
reach goal  worst case macro actions may lead h  local minima  still 
may interesting look whether other  traditional  causal graph based methods
localized  or similar  manner well 
global analysis  focus whole planning task thus whole causal
graph  even closely related research causal graphs based tractability analysis 
major difference tractability analysis h  topology analysis  principle 
tractability absence local minima orthogonal properties general 
neither one implies other  now  pointed end section    global
analysis imply tractability  of plan existence   vice versa  restrictions made
known tractable classes imply absence local minima  many cases  answer
question definite no  interesting questions open  single case
corresponding basic result answer yes 
example   appendix a   shows one construct local minimum  
variables domain size      arc sg  unary operators  strongly connected dtgs
single non invertible transition  example  and various scaling extensions breaking
respective conditions  falls variety known tractable classes  example
    particular  fast downwards translator always perfect detecting finite domain variables
underlying benchmarks  example  satellite often detect electricity available
exactly one instruments mounted satellite  lead pointless diagnosis output 
handled using simple notion predicates exchanged every operator 
things principled manner  invariants analysis would useful 

   

fihoffmann

tractable class f
n identified domshlak dinitz         every transition
dependent variable depends variable  example helmerts       
      sas     class strongly connected dtgs  example solved  i e   reduced
empty task  haslums        simplification techniques  also  techniques
solve tasks satellite domain  contain local minima   example
fork inverted fork causal graph  bounded domain size   dependent actions
 actions   prevail condition   thus qualifies tractable classes
identified katz domshlak      b   examples causal graph chain 
thus particular polytree bounded indegree  corresponding tractable class
identified brafman domshlak        except that  there  variables restricted
binary  domain size     open question whether plan existence chain causal
graphs domain size   tractable  strongest known result np hard
domain size    gimenez   jonsson      b     similarly  example fits prerequisites
stated katz domshlak      a  except binary variables only 
open question whether local minima exist tractable classes identified there 
finally  example  suitable scaling extension  obviously qualifies two theorems
stated chen gimenez         theorem      more precisely  first part
theorem  requires constant bound size connected components
undirected graph induced causal graph  first part theorem    
requires constant bound size strongly connected components causal
graph  pertains notion reversible tasks requiring always go back
initial state 
next  consider line works restricting causal graph dtgs
task  backstrom   klein        backstrom   nebel        jonsson   backstrom        
simplest class identified here  contained classes  sas   pubs
fact achieved one operator  post unique  p   operators unary
 u   variables binary  b   variables one value required
condition transition variable  single valued  s   now  example  
appendix a   shows local minimum example u properties 
example two variables  x y  local minimum arises cyclic
dependency prevents attaining goal value dn via shortest path taken
optimal relaxed plan  remove two values domain y  remove
alternative way reaching dn     example still contains local minimum
p b properties  remark modified example unsolvable 
remains open question whether solvable sas   pubs tasks local minima exist 
generally  question open even larger sas   pus class   yet larger 
sas   iao class identified jonsson backstrom        
another open question whether  s class jonsson backstrom       
contains local minima  class works binary variables only  requires unary operators
acyclic causal graphs  however allows facts splitting instead reversible 
p splitting then  intuitively  task decomposed three independent subtasks respect p  open question whether local minima constructed
    although  course  clear that  dtgs strongly connected case  deciding
plan existence tractable matter domain size is 
    modification given detail example appendix a   

   

fianalyzing search topology without running search

satisfying property  disallowing splitting option  s  obtain single
positive case  known tractable class contain local minima 
class corresponds basic result acyclic causal graphs invertible transitions
except variables restricted binary  williams nayak        mention
restrictions  but make formal claims regarding tractability  corresponding exactly
basic result except allow irreversible repair actions  latter actions
defined relative specialized formal framework control systems  spirit
similar term transitions self irrelevant deletes herein 
finally  easy see that  bylanders        three tractability criteria  two
allowing several effects imply absence local minima  third criterion 
restricting action effects single literal preconditions positive literals  but allowing
negative goals   leave open question whether local minima exist 
remark criterion apply benchmark aware of 
close section  certainly wish claim identification
tractable classes contribution work  note scope theorem  
tractable class  cf  covered known tractable classes   
tractable cases identified bylander        obviously cover logistics 
miconic strips  movie  simple tsp  many causal graph based tractability results
require unary operators  jonsson   backstrom        domshlak   dinitz        brafman   domshlak        helmert              katz   domshlak      a      b  jonsson 
      gimenez   jonsson            a   cover miconic strips  movie 
simple tsp  work chen gimenez         theorem     requires reversibility given either movie  miconic strips  simple tsp 
theorem     requires constant bound size connected components
undirected graph induced causal graph  given none logistics  miconicstrips  simple tsp  known tractability results make different restrictions
dtgs  backstrom   klein        backstrom   nebel        jonsson   backstrom 
       even general tractable class identified there  sas   iao  covers none
miconic strips  logistics  simple tsp  because vehicle variables acyclic
respect requestable values   neither cover movie  because rewinding
movie neither unary irreplaceable  side effect un setting counter 
breaking dtg counter two disjoint components  
far coverage benchmarks goes  strongest competitor theorem  
haslums        simplification techniques  iteratively remove variables
paths relevant attaining required conditions free  i e   traversed using transitions neither conditions side effects  haslums theorem   states
removal done without jeopardizing solution existence  i e   plan original
task reconstructed easily plan simplified task  particular 
task solved simplified completely  empty task plan constructed
polynomial time  haslum combines basic technique number domain reformulation techniques  e g   replacing action sequences macros certain conditions 
choice combination techniques apply fully automated  parts
    true basic result  explained essentially covered works jonsson
backstrom        williams nayak         formally  prerequisites imply  the
first part of  theorem     work chen gimenez         namely  postulated bound   

   

fihoffmann

techniques fully described  making comparison theorem   difficult 
haslum reports techniques solve tasks logistics  miconic strips  movie 
plus gripper satellite  haslum experiment simple tsp  theorem   
stated form  solve simple tsp  transitions root
variable side effects  with irrelevant deletes   extending theorem cover
irrelevant deletes straightforward  subtle weakness haslums theorem   relative theorem   pertains reaching required values externally caused
values  haslum requires moves free  whereas  definition recoverable
side effect deletes  theorem   allows recovering operators affect several variables
take precondition prevails effects o   

    conclusion
identified connection causal graphs h    devised tool allowing
analyze search space topology without actually running search  tool yet
automatic hoffmann  analysis quality impressive even compared
unlimited search probing 
generic level  conclusion work that  sometimes  possible
automatically infer topological properties heuristic function  interesting question
future work whether done heuristics h   cf 
comments regarding causal graph research below   methodologically  noteworthy
analysis based syntactic restrictions problem description  traditionally used identify tractable fragments  of planning computationally
hard problems   present work showcases similar techniques apply
analysis search spaces general problem solvers 
main open question whether global analysis tightly approximate scope
theorem    indicated  good starting point appears trying include  gdg
operator o    variable dependencies induced operators may actually precede
o  optimal relaxed plan  approach automatically recognizing operators could
possibly developed along lines hoffmann nebel      b   using simplified
version aforementioned fact generation tree analysis technique  hoffmann        
additionally  would great recognize situations harmful side effects o 
making hand non empty pick ball gripper necessarily
recovered inside relaxed plan  possibly  analysis could based variant
action landmarks  hoffmann  porteous    sebastia        karpas   domshlak        
another interesting line research start results given individual states
local analysis  extract reasons success s  generalize reasons
determine generic property success guaranteed  taken extreme 
might possible automatically identify domain sub classes  i e   particular combinations
initial state goal state  absence local minima proved 
work highlights two new aspects causal graph research  first  shows that 
certain situations  one localize causal graph analysis  consider causal
graph fragment relevant solving particular state  second  one use causal graphs
constructing paths global goal  state value heuristic h
decreased  former enables analysis succeed tasks whose causal graphs
   

fianalyzing search topology without running search

otherwise arbitrarily complex  thus potential greatly broaden scope
applicability  latter necessarily limited h  simple example 
obvious similar constructions made trivial heuristic counting number
unsatisfied goals thus opens completely new avenue causal graph research 
another possibility planner performance prediction  along lines roberts
howe         experimental results indicate torchlights problem features 
search probing  highly informative  potential significantly
improve results roberts howe unseen domains currently use
simple features  counts predicates action schemes  hardly capture domainindependent structure relevant planner performance  limited search probing  sp s   
torchlight generates features without jeopardizing runtime  thus enabling automatic
planner configuration  unlike search probing  may even work on line search 
single relaxed plan already deliver interesting information  example  one might
make search less greedy choosing different search strategy  switching helpful
actions off  etc  depending outcome checking theorem   
mentioned section    direction worth trying use local analysis generating
macro actions  domains high success rate  seems likely macro actions
would lead goal search all  priori clear  though  whether
approach would significantly strengthen  least present benchmarks  existing
techniques executing  parts of  relaxed plan  e g   vidal        
one could use torchlights diagnosis facility basis abstraction technique
deriving search guidance  much currently done relaxation abstraction
techniques  diagnosis pin point operator effects causing problems
search  remove enough harmful effects end task theorem  
applies  abstracted problem tractable  example  transportation domains 
process could abstract away fuel consumption  abstract much 
information provided may still outweigh effort abstract planning  i e  
using actual planner inside heuristic function  example  grid abstract task
could problem variant allowing carry several keys once  one could focus
construction different heuristics based ignoring deletes harmful effects 
finally  interesting research line domain reformulation  well known 
domain formulation make huge difference planner performance  however 
difficult choose good formulation  given planner  black art even
reformulation done developer planner question  lack guidance
one main open problems identified haslum        automatic reformulation
approach  frequent question author asked non expert users
model domain handle easily 
torchlights diagnosis facility  pin pointing problematic effects  might instrumental
addressing difficulties  case reformulation done computer 
one possibility use analysis outcome could produce macro actions hiding
within operators harmful effects  another possibility could precompose variable subsets touched harmful effects 
case reformulation done human user  sky limit 
name one example  local minima satellite could removed allowing
switch instrument pointing direction instrument
   

fihoffmann

calibrated  generally  note end user pddl modeling writing pddl
non expert user wanting solve problem using off the shelf planners quite
different pddl modeling planning experts developing benchmarks 
example  expert models transportation benchmark fuel consumption 
may seem quite pointless torchlight determine fuel consumption hurt
planner performance  indeed may reason fuel consumption included
first place  contrast  end user  a  information may come surprise 
 b  user may actually choose omit fuel consumption may yield
better point trade off planner performance plan usability  generally
speaking  approach could give user guidance designing natural hierarchy
increasingly detailed increasingly problematic domain formulations  could
help making planning technology accessible  thus contribute challenge
taken much seriously planning community 

acknowledgments
would thank anonymous reviewers both  article hand icaps
     short version  constructive comments  particular  one reviewers
proved completeness results theorem    another reviewer suggested future
research line trying generalize reasons success local analysis 
thank carmel domshlak discussions  feedback early stages work contributing particular d abstracted task construction proof lemma  
executive summary status quo causal graph research 
special thanks goes carlos areces luciana benotti  inspiring
work first place  long ago given problem  carlos
lucianas insistence finally made see connection causal graphs trying
convince analysis impossible 

appendix a  technical details proofs
give full proofs and  needed  fill technical definitions  first
prove complexity result  appendix a    theorem     result pertaining
analysis optimal relaxed plans  appendix a    theorem     result pertaining
conservative approximations  appendix a    theorems       construct number
examples relevant kinds analysis  appendix a     giving proofs
domain specific performance guarantees  appendix a    propositions      
a   computational complexity
theorem    pspace complete decide whether state space given
planning task contains local minimum  given integer k pspace complete
decide whether states ed s  k  further  pspace complete
decide whether given state local minimum  given integer k
pspace complete decide whether ed s  k 
   

fianalyzing search topology without running search

proof  throughout proof  since pspace closed complementation 
distinguish mentioned pspace complete decision problems complements 
membership results easy prove  note first that  given state s 
compute h   s  within polynomial space  generate potentially non optimal relaxed plan 
length n  known methods  iteratively decrement n test value
whether relaxed plan length still exists  stop test answers no 
test bounded relaxed plan existence np thus pspace  here 
prove membership results simple modifications guess and check argument
showing plansat  problem deciding whether given planning task solvable 
npspace hence pspace  bylander         argument works
starting initial state  guessing actions  terminating successfully goal state
reached  unsuccessful termination occurs guessed path longer trivial
upper bound b    xx  dx   number different states  able check
condition polynomial space  path length maintained binary counter 
decide whether given state  not  local minimum  run guess and check
algorithm s  modified to  compute h  encountered state  terminate unsuccessfully bound b exceeded h  increases operator application 
terminate successfully h  decreases operator application  decide whether
ed s  k  use algorithm except bound b replaced bound k 
increases h  permitted  success occurs h  decreases h   s  h   s   
decide whether state space entire planning task contains local minima  whether
states state space ed s  k  simply run bylanders guess and check
algorithm way enumerating reachable states  individual state
run modified guess and check algorithms described  clearly  algorithms
run non deterministic polynomial space  shows part claim 
show pspace hardness results  first consider problem deciding whether given state local minimum  proof works reducing
plansat  known pspace hard propositional strips  bylander 
       trivially follows plansat pspace hard finitedomain variable planning tasks use herein 
let  x  si   sg   o  planning task whose solvability wish decide  design
modified task  x     s i   s g   o    starting  x  si   sg   o  making following
modifications 
add new variable chooset ask x    
s i  chooset ask    nil  s g  chooset ask  undefined 

domain

 nil  org  alt  

role variable give planner choice whether solve
original task  x  si   sg   o   whether solve alternative task custom designed
proof 
add new variable distalt x     domain         s i  distalt      
s g  distalt      
variable simply serves control length solution alternative task 
solution length   plus number steps needed bring distalt
   

fihoffmann

value   goal value   here    step needed so  later
proof  increase distance  
add two new operators oorg      chooset ask  nil      chooset ask  org   
oalt      chooset ask  nil      chooset ask  alt    distalt       
implements choice planning task  note that  choose alternative
task  distalt set    thus forcing solution bridge distance 
contrast  original task  variable keeps residing goal value
already assigned s i  distalt  
add new operator odistalt      chooset ask  alt    distalt         distalt       
allows bridge distance intended solution alternative task 
add new operator osg alt      chooset ask  alt    distalt       sg   
allows us accomplish original goal  final step solving alternative task 
add  chooset ask  org  new precondition original operators  i e  
taken o 
forces planner choose original task  executing operators 
add new variable stillalive x  domain  yes  no   s i  stillalive    yes 
sg  stillalive    yes  add new operator osg dead      sg   stillalive  no    
osg dead operator allows us accomplish original goal single step 
matter task chosen solve  new initial state s i already 
however  operator sets new variable stillalive value no  whereas
goal value variable yes  value cannot re achieved  thus
operator leads dead end  function proof flatten value
h  original task  s i   constantly   unless goal state 
extreme flattening happen alternative task because  there 
distance variable distalt needs handled 
summary   x     s i   s g   o    designed setting 
x      x  chooset ask  distalt  stillalive 
s i    si   chooset ask  nil    distalt       stillalive  yes  
s g    sg   distalt       stillalive  yes  
o       pre   chooset ask  org    eff     pre  eff  o   oorg   oalt   odistalt   osg alt  
osg dead  
consider new initial state s i   exactly three successor states  sdead produced osg dead   sorg produced oorg   salt produced oalt   h   sdead    
sdead  stillalive    no  h   s i     h   sorg       due relaxed
   

fianalyzing search topology without running search

plan hosg dead i  finally  h   salt       oalt sets distalt variable  
whereas goal    thus shortest relaxed plan salt hodistalt   osg alt i 
this  clearly follows s i local minimum iff sorg monotone
path state h   s    h   sorg    since h   sorg        latter equivalent
existence monotone path sorg goal state  i e   path goal state
h  constantly    since  states reachable sorg   single step sequence
hosg dead relaxed plan  equivalent existence path sorg goal
state  clearly  latter equivalent solvability original task  x  si   sg   o   thus
s i local minimum iff  x  si   sg   o  solvable  shows part claim 
next prove pspace hardness deciding whether given planning task
contains local minimum  follows easily above  observe alternative
task contain local minima  described  h   salt        apply
odistalt salt   obtain state saltdist h   saltdist       relaxed
plan hosg alt i  applying osg alt saltdist yields goal state  thus salt saltdist
better evaluated neighbors  states descending salt must produced
osg dead thus h  value   so   x     s i   s g   o    contains local minimum iff
part state space descended sorg does  since states h  value   unless
goal states  cf  above  latter equivalent unsolvability  x  si   sg   o 
shows part claim 
assume given integer k need decide individual state
whether ed s  k  reduce bounded plansat  problem deciding whether
given planning task solvable within given number steps  bounded plansat
known pspace complete bound given non unary representation 
modify task  x     s i   s g   o    given above  way increases solution length
alternative task k  introduce binary counter using dlog   k   e new binary
variables biti   si   introduce operator bit  allowing set
bit   lower bits already    effect setting lower bits back
o  operator additional precondition  chooset ask  alt  
effect modifying bits  modify operator odistalt adding new
preconditions encoding counter position k    construction  clearly h   salt       
distance goal salt k  plan count k    apply odistalt  
apply osg alt   thus  shortest exit path si via oalt length k      then 
above  ed si   k iff  x  si   sg   o  plan length k   
concludes part claim 
finally  say need decide whether not  s  ed s  k  note
first salt successors necessarily exit distance k  the goal
reached many steps   exit distance sorg successors
equal length shortest plan corresponding state  x  si   sg   o  
latter length may  states  x  si   sg   o   longer k even shortest
plan  x  si   sg   o   i e   original initial state  length k  thus introduce
another binary counter  time counting k    conditioned  chooset ask  org  
new operator whose precondition demands new counter k  
achieves goals  then  clearly  sorg descendants exit distance
k  thus state may exit distance greater k s i precisely 
   

fihoffmann

ed s i     k     iff new counter shortest plan sorg   obviously
case iff  x  si   sg   o  plan length k    concludes argument 
a   analyzing optimal relaxed plans
need fill notations  sake self containedness section  first
re state definitions given section   
definition    let  x  si   sg   o  planning task  let     h   s      let
p    s  optimal relaxed plan s  let x  x  let o  p    s  operator taking
relevant transition form t     s x     c  
optimal rplan dependency graph p    s   x  o    optimal rplan dependency
graph p    s  brief  graph odg     v  a  unique leaf vertex x   
x v  x  x    either  x    x    x xpreo   preo   x     s x   x    x 
 
 
 s  taking relevant transition x  x xpreo
v    x    exists p  
preo  x     s x  
x v    x     odt g 
x denote sub graph dt gx includes
 
 s  x   relevant transitions using operator
values true point p  
 
p    s  x   least one relevant inverse relevant inverse exists 
 
 s  x  transitions original  inverse transitions induced 
refer p  
definition    let  x  si   sg   o   s  p    s   x    t    odg     v  a  definition   
say odg  successful following holds 
    odg  acyclic 
    either 
 
 s  recoverable 
 a  odg   relevant deletes t  p  
 
 b  s x    odg  relevant  t  replaceable side effect deletes 
 c  s x    odg   relevant  t  recoverable side effect deletes 

    x v    x     odt g 
x transitions either self irrelevant deletes 
invertible induced irrelevant side effect deletes side effects v   x    
next define two general notions helpful state proofs 
prevail condition prevo operator results restricting preo
set variables xpreo   xeff  
let x x  let  c  c    transition dt gx   let  y  d  seff c  c    side
effect transition  context  y  d   c  c    ctx c  c    y  d    
 
 y  prerop c c     y  
xprerop c c   
  y  d      d  dy   d     d    xprerop c c   
context  c  c    set ctx c  c    partial variable assignments that 
every  y  d  seff c  c     x  y   y   ctx c  c    y  d   identify ctx c  c   
set facts occur assignments 
   

fianalyzing search topology without running search

note definition ctx c  c    over writes previous one section   
sense distinguish possible tuples context values 
rather collecting overall set  need fine grained definition
precisely formulate definition   condition   c   i e   conditions transition
recoverable side effect deletes  namely  definition   conditions   b    c 
formalized follows 
transition  c  c    replaceable side effect deletes iff ctx c  c   sg   and  every
rop c  c       preo ctx c  c       exists o  eff o    eff
preo  prevrop c c    eff rop c c     
transition  c  c    recoverable side effect deletes iff following two conditions
hold 
either  c  c    irrelevant side effect deletes or  every ctx c  c    
exists recovering
operator preo prevrop c c    eff rop c c    eff  
eff  sg rop c c     o  preo    
every  y  d  seff c  c    goal appears operator precondition
possibly recovering operators 
t  replaceable side effect deletes  upon execution remove o 
relaxed plan operator relying deleted facts replaced  t 
recoverable side effect deletes  then  due first clause definition  matter
state s  apply t  matter context holds s 
recovering operator applicable t  re achieves relevant facts  due
second clause  delete facts relevant elsewhere relaxed plan  note
anything deleted must side effect t    
finally  formally define notion used definition   condition   a  odg   
 s  recoverable assume surroundings pertaining
relevant deletes t  p  
theorem    i e    x  si   sg   o  planning task  state  p    s  optimal relaxed
plan s  odg     v  a  optimal rplan dependency graph leaf variable x 
transition t     s x     c  responsible operator o    considering state s 
t  executed  reaching state s    examining relaxed plan p   s 
 
constructed p    s  removing o    replacing operators p  
 s 
 
operators responsible induced odt gx transitions x v    x    
c       x    s x      ctx t    denote values potentially deleted t   
r   denote union sg   precondition p    s  operator
o    precondition operator responsible operator
induced transition odt g 
x   x v    x     discussed section   
super set facts possibly needed p    

f     op    s  eff denote set facts true relaxed execution
  

 
p  
 s  s  discussed section    p   f  p needed s  p  
relaxed plan 

   

fihoffmann

s  denote union of      prevo  eff o        set facts  x  c 
 
exists x xeff either o  p  
 s  responsible
 
operator induced transition odt gx   x v    x         set f defined
f      x  c     x  c  f    x v    x     xeff o   v    x         else f      here 
        facts certain true s        set
facts able achieve start p     appropriately re ordering
operators 

   s   relaxed plan macro precondition

  ho            sub sequence
p
sn
i 


 
defined pre
   i    preoi   j  
eff oj    relaxed plan macro effect


n




 
defined eff
   i   eff oi   empty sets default empty


set  notions simply capture outside needs effects relaxed plan
sub sequence 
 
 
 s  recoverable iff p  
 s  contains sub odg   relevant deletes t  p  


 
 
 
sequence o  pre



eff

c

f
 

first condition

r



 
 
 
 
o 
o 


ensures o  applicable appropriate point within p     second

o   
clause ensures facts relevant p   re achieved

proceed exit path construction  follows  first consider
part path leading s    i e   move non leaf variables x v   x    
show construct relaxed plans p    s    states s  visited path 
first  note assume p    s  sorted according optimal rplan
dependency graph odg     v  a   precisely  let xk           x  topological ordering
v    x    according arcs a  due construction  v  a  per definition   
previous values never removed relaxed state space  re order
 
 
 s  x    p   is  perform moves
 s  xk   p  
p    s  take form p  
 
within odt gx front  order conforming a  henceforth assume 
wlog  p    s  form 
 
recall follows original odt g 
x transitions taken p    s  
whereas induced odt g 
x transitions included inverse original tran

sition  path
p invertible transitions traversing hc            cn i  inverse path
p


traverses hcn           c  replacing transition inverse  rop  p   denote
operator sequence responsible path 
say state s  invertible surroundings according odg  s 

reachable executing sequence
responsible operators invertible induced
 
transitions odt gx x v    x     adapted relaxed plan s    denoted
p    ss     constructed follows  let xk           x  topological ordering v    x   
according a  denote p    s    p    s  xk   p    s  x    p   initialize p    ss      

p    s   then  xi v    x     let
p path original invertible transitions

 
 
odt gxi leading s xi    xi   clearly  path must exist  remove rop 
p  


 
 
 
 
p  ss    insert rop  p   start p  ss   xi   
next show adapted relaxed plans indeed relaxed plans  restricting
conditions correspondence definition   condition     
lemma    let  x  si   sg   o  planning task  let state     h   s     
let p    s  optimal relaxed plan s  say odg     v  a  optimal rplan
   

fianalyzing search topology without running search

dependency graph p    s  where  every x v    x     invertible induced odt g 
x
transitions irrelevant side effect deletes side effects v    x     let s 
state invertible surroundings according odg    p    ss    relaxed
plan s     p    ss      p    s   
 
 
proof  definition  know p    s  takes form p  
 s  xk   p  
 s  x    p  
 
 
 
 
 
 
p  ss   takes form p    s   xk   p    s   x    p   xk           x 
topological ordering v   p operator sequence common both 
whose content important proof  simplicity  denote rest
proof p    ss    p    s     leave away     subscripts 

consider first  relaxed  execution p    s  xk   p    s    xk    say
p
   s     i e   path original invertible
path odt g 
considered


definition

p
xk


 
transitions odt g 
xi leading s xk    xk    clearly  ho               rop  p  

sub sequence p    s  xk    say
p visits vertices s xk     c            cn   s   xk    denote
c     c            cn    assume wlog p    s  xk   starts ho            note
re order p    s  xk    and relaxed plans general  way want long
violate operator preconditions  latter case because  ho           
constitutes path odt g 
xk   operators depending value c

ordered occur later p    s  xk    because  since transitions
p side
effects v   x     construction  v  a  per definition   operators ho           
support way  p    s   affecting variable xk  
given above  wlog p    s  xk   form ho            p    construction 



 
p  s    xk   form rop 
ps
  p     h

n           o  ps
    consider endpoints
n
 
 
 
prefixes  i e   s     i   eff oi s      i n eff
oi   clearly  since

transitions
p irrelevant side effect deletes  relevant part
contained s    then  far variables outside v    x    xk   concerned 
 
relevant part s 
  contained s    relevant side effects ho            already
 
contained   values c obviously true s 
    induced transitions side


 

effects  increase fact set s    further  sequence h
n           o 
applicable relaxation  see this  note first preconditions xk


satisfied definition  h

n           o  constitutes path dt gxk   side effects 
occur  harmful old values over written relaxation 
preconditions variables  due invertibility outside conditions
oi contained oi subset ho            i  hence  definition  
since xk incoming edges odg    preconditions satisfied s 
satisfied s   vk root odg    variables x
contained v hence s   x    s x  prerequisite note precondition facts
cannot deleted side effects whose deletes irrelevant prerequisite 
shown relevant part outcome relaxed execution
p    s  xk   contained outcome relaxed execution p    s    xk   s   
variables outside v    x    xk    iterate argument  assume induction
hypothesis already shown relevant part outcome relaxed
execution p    s  xk         p    s  xi     contained outcome relaxed execution
p    s    xk   p    s    xi     s    variables outside v    x    xk           xi     
consider p    s  xi   p    s    xi    thing changes respect xk
may preconditions variables xj true s  j  

   

fihoffmann

preconditions must belong predecessors xi odg  definition   
since p    s    p    s  xk   p    s  x    p relaxed plan s  conditions
established relaxed execution p    s  xk   p    s  xi     s  given this 
induction hypothesis conditions clearly irrelevant established
relaxed execution p    s    xk   p    s    xi     s    concludes argument
inductive case       follows relevant part outcome relaxed
execution p    s  xk   p    s  x    contained  on variables  outcome
relaxed execution p    s    xk   p    s    x    s    this  claim follows trivially
p    s  relaxed plan s  remainder p operator sequences
identical 
second part claim follows because     j  original
transitions use xi respectively xj operators common  because 
argued above  relevant operators side effects v    x     since
operators affects variable xi   cannot affect variable v    x     thus 
inverse transition introduce via inverse operator  p    s  contains separate
operator  this  obviously get  p    ss      p    s   
lemma   captures second case definition   condition      transitions
invertible induced irrelevant side effect deletes side effects v    x    
next lemma captures first case definition   condition     
lemma    let  x  si   sg   o  planning task  let state     h   s     
let p    s  optimal relaxed plan s  say odg     v  a  optimal rplan
dependency graph p    s  where  every x v    x     invertible induced odt g 
x
transitions irrelevant side effect deletes side effects v    x     let s 
state invertible surroundings according odg    let s   state reached
s  p    ss    x  operator constituting transition  c  c    x v   s   x    c 
self irrelevant deletes  removing p    ss    yields relaxed plan
s    
proof  lemma    p    ss    relaxed plan s    now  upon execution o  s    
effects true  i e    x  c    side effects  if present   hand 
obviously facts  z  e  true s  s   ctx c  c     x  c    since 
prerequisite  transition  c  c    self irrelevant deletes  facts ctx c  c     x  c  
either irrelevant rop c  c    only relevant  meaning goal occur
operator precondition than  possibly  itself  claim follows directly
that 
remark much easily formulated  general  version lemma  
could proved simply associating notion self irrelevant deletes operators
rather transitions  postulating used p    s   argument
corresponds part  a  proof lemma   authors previous work  hoffmann 
       state argument particular form since form
need below 
almost ready prove main lemma behind exit path construction 
need one last notation  capturing simpler form cost function costd  odg   
   

fianalyzing search topology without running search

considered section    simpler function make use shortcut construction pthat construction introduced separately below  define
costd  odg       xv costd  x   costd  x    
 
 
x   x 
p
 

 
diam odt gx   x    x x   a cost  x   x    x 
lemma    let  x  si   sg   o  planning task  let state     h   s     
let p    s  optimal relaxed plan s  say odg     v  a  successful

optimal rplan dependency graph p    s   exists operator sequence

that 

 i 
constitutes monotone path state s  h   s    h   s    

 ii  length
costd  odg    definition   condition   a 
  b   costd  odg        definition   condition   c  
proof  let xk           x  topological ordering v   x    according arcs a  consider
state s  every x v    x    s   x  vertex odt g 
x  
every variable x outside v    x    s   x    s x  unless s x  irrelevant  say
preo  s    note first state s  exists  definition  either
preo   x    undefined preo   x      s x      s   x      note every variable
x outside v    x    s   x    s x  unless s x  irrelevant covers
case transition v    x    side effect x    whose delete must
prerequisite irrelevant thus either side effect x     s x    o  actually
preconditioned x     definition   p    s  relaxed plan s 
variable x xpreo contained v unless preo   x    s x   reasons 
 
 
construction odt g 
x   preo   x  vertex odt gx  
now  consider state s  results applying o  s    first consider
situation s  invertible surroundings according odg    opposite
case discussed below  apply lemma   s    hence relaxed
 
 s  x   x
plan p    ss    s  results replacing  p    s   moves p  
 
 
 
 
v    x     inverses  particular  h  s  h  s     p  ss    x     p    s  x   
x    v   relaxed plan s    distinguish definition   condition    
cases  a    b    c  

 
case  a   definition p  
 s  contains sub sequence
o  pre 



o 
 
 
 
s  eff
r  c  f    implies remove o  p  s s   

o 
obtain relaxed plan p   s    thus getting h   s    h   s     precisely  construct

p   by  removing o  p    ss     xeff o   v    x        moving
o  occur


 
 
start p    xeff o   v    x       moving o  occur start p  
 s 
 
 which unchanged p  ss     

observe first o  p    s s   
o  sub sequence p    s s    since
adaptation pertains exclusively operators precede o  p    s   second  course
values established o  true s   

third 
o  applicable  in relaxation  assigned point p     see this 
consider first case xeff o   v    x          then  definition s    pre 




 

   

fihoffmann

contained  prevo  eff o    set facts  x  c  exists
 
x xeff either o  p  
 s  responsible operator inverse
 
 
transition taken operator p  
 s   facts true s   
obvious prevo  eff o  follows facts true
cannot affected operator path s    consider case
xeff o   v    x         definition s    pre 
contained previous sets facts 


o 
plus   x  c     x  c  f    x v    x      latter facts  far relevant  true

start
o  p     execution o  affect execution
 
p  ss     thus p     point  then  argued lemma   
outcome execution s  contains  variables v    x    
 
relevant part outcome p  
 s  is  relevant part f    since o 
affect variables  true s    concludes point 
finally  consider facts  z  e  true s  s    may

needed p   behind
o    i e   either goal precondition
operators  observe that  since inverse operators performed transitions
variables v    x     since include new outside preconditions 
 z  e  contained r       now  say first  z  e  f    then  above 
 z  e   ctx s x     c   x    s x      f  r   thus  z  e  eff  
prerequisite


o 
 
 s  else 
done   z  e    f    note that  then   z  e    preo p  
 
precondition would true relaxed execution p  s  thus p    s  would
 
 s   thus  z  e  needed
relaxed plan  neither  z  e  added p  
 
precondition inverse operator used p  s s    operators
introduce new outside preconditions  course use own preconditions previously
added operators affecting respective variable  thus reason  z  e 
 
could needed p   either  z  e  sg  z  e  preo p  
 s  
 
 z  e  sg certainly  since p  s  relaxed plan  achieved operator
p    s   cannot   o  since effect o  true s    cannot
 
 
 s   thus contained p  
 s  since  z  e    f    thus p  
p  
 
 s   arguments apply  i e   must
done   z  e  preo  o  p  
 
 
p    s   ordered   adds  z  e   concludes proof case  a  
consider case  b   s x      r     transition  s x     c  replaceable
side effect deletes  i e   ctx s x     c  sg   and  every o     preo
ctx s x     c     exists o  eff o    eff preo  prevo  eff o   
obtain relaxed plan p   removing o  p    s s     replacing
operators respective o  needed  precisely  say  z  e  true s 
s    z   x  e   s x    needed p   construction  every z 
must  z  e  ctx s x     c    z  e  goal prerequisite  operator
p    z  e  precondition  replace postulated operator o 
obviously applicable s  effect  concludes case 
consider last case  c   definition s x      r     transition  s x     c 
recoverable side effect deletes  here  guarantee decrease h  obtained s 
    note particular special case inverse transitions non leaf variables x  may
precondition x added by  needed prerequisite of  operators p    s  x  
preconditions preconditions may needed p    ss    thus p    
p    s   reason include facts definition r    

   

fianalyzing search topology without running search

itself  successor state s  s    namely  let o  operator recovering relevant
side effect deletes  s x     c   precisely  let ctx s x     c  s   such exists
definition ctx s x     c    then 
let o  operator preo   prevo  eff o   
eff o    eff o   sg o    o  preo     such operator exists case  b    say
obtain p   replacing  p    ss     o  o    p   relaxed plan
s    see this  note first o  applicable s  virtue preo   prevo  eff o    
further  note values deleted o  plus  x    s   x      since
s   x      s x     s x      r   know s   x     sr   thus delete
consequence    virtue eff o   sg o    o  preo    facts could
possibly relevant re achieved o    finally  values established o  true
s   
now  say obtain s  applying o  s    removing o  p   yields relaxed
plan s    simply established effects true s    virtue
eff o  facts deletes side effects transition  s x     c   case  c  
relevant anything except possibly recovering operators  recovering
operator o  removed p     recovering
operators
could still contained p     since eff eff o   sg o    o  preo    
relevant facts could possibly achieve already true s  thus remove
well  hence  overall  h   s    h   s    
cases  a   b  prove  i  constructing monotone path s    case  c 
true s     of course  show  ii   constructing path
specified length  ignore issue moment   difficulty
constructing path achieving preconditions o    preconditions may
satisfied s  need reach state s  satisfied  need
without ever increasing value h    note that  decrease value h  somewhere
along way  already reached exit monotone path  done  thus
follows show upper bound h   s   lemma    bounding
accomplished starting s  always taking odt g 
x transitions variables
x v pertaining second case definition   condition      i e   transitions
invertible induced irrelevant side effect deletes side effects v    x    
follows will  brevity  refer transitions case   note that 
way  reach states invertible surroundings according odg   

operator sequence
  lemma   know h   s  h   s    states
 
along way  now  cannot reach s  using sequence  i e  
 
would take non case  odt g 
x transition  c  c   variable x  state
s    prerequisite know transition  c  c    self irrelevant deletes  apply
lemma   because  s  invertible surroundings according odg    since
following transition path  clearly s   x    c  i e   value relevant variable s 
start value last transition taking  construction  p    ss    changes
p    s  case  transitions  thus responsible operator rop c  c     which
case   guaranteed contained p    ss     note rop c  c    cannot
used case  transitions v    x    variable might taken
path s    prerequisite transitions side effects v    x    
contradiction constituting transition variable x hand  thus know
h   s    h   s    already constructed desired monotone path exit
   

fihoffmann



stop  else  reach s  sequence
  above 
ho 


 respectively ho    o  i  case  c   constitutes desired path 

remains show exactly construct operator sequence
  consider
topological ordering v   xk           x    follows  consider depth indices k
   say variable x v depth d  written depth x    d  iff x   xd  
characterizes d abstracted planning task identical original planning
task except  and only  outside preconditions  odt g 
x transitions
variables x depth x  d  removed pertain values variables x 
depth x      d  prove induction that 

    d abstracted task  exists operator sequence
that 


 a  either    
ho  execution path applicable s     
execution path

 
applicable s  last transition  c  c   variable x taken
relevant 
self irrelevant deletes  responsible operator contained adapted relaxed
plan state s  applied to  s   x    c 

 b 
  except last step case      a   uses case  odt g 
x transitions
variables x   depth x  d 

 c  number operators
ho  pertaining x v costd  x  

desired path
results setting    k  see this  note kabstracted planning task identical original planning task  claim follows
discussion above   a   b  together mean h  decreases monotonically




 

p less dthan h  s  end  given  c   length bounded
xv depth x d cost  x   proves claim adding trivial observation that 
definition   condition     case  c  discussed above  need add one
additional operator end path 

give proof      base case       trivial  set
  empty 
construction  v  a  per definition    construction   abstracted
task  outside preconditions o  either true removed   a 
 case        b    c  obvious 

inductive case       exploiting induction hypothesis  let
operator




sequence per      turn requested sequence d      abstracted planning task 
remainder proof  consider odt g 
x   x v    x    
contain irrelevant transitions  i e   omit restriction definition   
simplify argumentation show  odt g 
x paths consider
contain irrelevant transitions  hence contained actual odt g 
x per
definition   

let first operator
ho  i  may applicable s   
  abstracted planning task  reason that  however  may precondition
removed d abstracted planning task removed    abstracted planning task  construction  precondition must pertain xd     say
precondition  xd     c   induction hypothesis  know contained
 
p  
 s   responsible inverse transition operator  cases  since
inverse transitions introduce new outside preconditions   xd     c  precondition
   

fianalyzing search topology without running search

 
operator p  
 s   thus c vertex odt g 
xd   trivial  xd     c  true
 which actually cannot case else would applicable
    abstracted planning task    xd     c  true follows p    s 
relaxed plan must thus achieve  xd     c  needed precondition 

 
hence  p  
 s  xd     must contain shortest path
q odt g 
xd   s xd     c 
transitions path irrelevant  see this  note first endpoint
operator precondition construction  thus last transition  c    c  irrelevant 
then  neither previous transition   c    c     was   xd     c    would
 
operator precondition  then  rop c    c  contained p  
 s  construction

 
would constitute transition  c    c  odt gxd   thus
q would


shortest path contradiction  iterating argument  q contain irrelevant
transitions  thus  since depth xd            definition    which includes nonsatisfied preconditions relevant transitions  construction     abstracted

planning task  outside preconditions used rop 
q   either true


removed  hence execute rop  q    either reached end
sequence  last transition taken odt g 
xd   case   hence
self irrelevant deletes prerequisite  latter case  since following path
since discussed adapted relaxed plan exchanges operators pertaining
case  transitions thus last one executed  clearly attained  a 

case     stop part rop 
q   executed is  own  operator

sequence
d   desired  former case  reach state s  s   xd       c  and
nothing else relevance deleted  due non existence relevant side effect
deletes   s    applied  leading state s    

let o  second operator
ho i  above  o  applicable s    


 

reason may unsatisfied precondition form  xd     c     above 
 
 s   hence c  vertex odt g 
o  inverse contained p  
xd     likewise 
  
 
 xd       c vertex odt gxd     now  yet used non case 
transition odt g 
xd     else wouldnt get here  means still
invertible surroundings around s xd     odt g 
xd     clearly  implies
 
 
exists path odt gxd   c c  we could simply go back s xd     move

c  there   taking shortest path
q   clearly path length bounded
 
diameter odt gxd     path contain irrelevant transitions
endpoint c  selected operator precondition  values
part shortest path odt g 
xd     thus argument given applies 

thus outside preconditions used operators constituting
q either true
removed follows construction  v  a  per definition  
 
construction     abstracted planning task operators p  
 s   follows
inverses thereof inverse operators introduce new outside preconditions  hence

execute
q s     either reached end path 
last transition taken case   hence self irrelevant deletes prerequisite 
consider latter case  state s  last transition reached
case  transitions  since transition odt g 
xd   case   responsible
 
operator must contained p  s  adapted relaxed plan p    ss   
s  recall that  pointed above  since case  transitions postulated
   

fihoffmann

side effects v   x     responsible operator cannot used them  further 
clearly since following path transitions  value xd   s 
start value transition  hence attained  a  case     stop 
former case  reached state o  applied  and nothing relevance
deleted  due postulated non existence relevant side effect deletes  case 

transitions   iterating argument  get state last operator
ho 
applied  induction hypothesis reaching state s  desired  a  case     
properties  a   b  clear construction  property  c   support

operator
ho  i  clearly apply diam odt g 
xd     operators
pertaining xd    or stop sequence earlier that   note that 

operators
ho  unsatisfied preconditions xd   above  pertains
variable x  xd     x  a  consequence construction  v  a 
per definition    fact inverse transitions introduce new outside

preconditions  thus  comparison
ho  i  overall execute
x
diam odt g 
k x 
xd    
x  xd    x a



additional operators
d   ho  i  k x  number operators
ho 
pertaining variable x  induction hypothesis  property  c       k x 
costd  x   x depth x         thus x  xd     x  a  hence
get  newly inserted steps affecting xd     upper bound
x
diam odt g 
 

costd  x 
xd  
x  xd    x a

identical costd  xd      concludes argument 
next note improve exit distance bound case insist
monotone exit paths 
lemma    let  x  si   sg   o  planning task  let state     h   s     
let p    s  optimal relaxed plan s  say odg     v  a  successful
optimal rplan dependency graph p    s   let v v    x    that  every x v  
odt g 
x transitions invertible induced irrelevant side effect deletes
side effects v   x     dt gx transitions either irrelevant  empty

conditions irrelevant side effect deletes  exists operator sequence

that 

 i 
constitutes path state s  h   s    h   s    

 ii  length
costd  odg    definition   condition   a 
  b   costd  odg        definition   condition   c  
proof  simple adaptation lemma    adopt follows terminology proof lemma  thing changes bound imposed
exit path length sharper  insist path monotone 
level proof mechanics  happens that  whenever xd   v   choose
   

fianalyzing search topology without running search


path
q achieve next open precondition operator already chosen participate


ho  i  restrict paths within odt g 
xd     allow
shortest path dt gxd     shortest path dt gxd   value occurs

operator precondition 
q contains irrelevant transitions  same argument

proof lemma     further 
q executable prerequisite alternative
 non odt g 
 
transitions


outside conditions  original induced transitions 
x
precondition achievement works exactly before  note important property
open preconditions achieved xd   ever pertain values contained
odt g 
xd     trivial see induction alternative transitions
outside preconditions  since prerequisite deletes alternative transitions
irrelevant  executing harm need minor extension lemma   
allowing s  identical state s   invertible surroundings s  modulo
set irrelevant values hold s   s  obvious extension
valid  extension  obvious arguments pertaining s  s 

remain valid  finally  consider case
q involves non case  odt g 
xd   transition 
state transition applied invertible surroundings s 
holds x   v construction remains same  holds
x v because  first  alternative transitions outside conditions  hence cause
higher depth transitions inserted between  hence value lower depth
 
variables x odt g 
x   second  prerequisite  odt gx contain non case 
transitions  thus value x clearly reached case  transitions 
theorem    let  x  si   sg   o   s  p    s   odg  definition    odg  successful  local minimum  ed s  costd  odg     definition  
condition   a    b   ed s  costd  odg      
proof  direct consequence lemmas     
note prerequisites lemma   could weakened allowing  x v  
outside conditions already true s  extension obviously break
proof arguments  omitted make lemma prerequisite even
awkward already is 
indicated  exit path constructed lemma   necessarily monotone  example   appendix a   contains construction showing this 
a   conservative approximations
sake self containedness section  re state definitions given section   
definition    let  x  si   sg   o  planning task  let     h   s      let
x  xsg   let t     s x     c  relevant transition dt gx  o     rop t    
local dependency graph s  x    o    local dependency graph brief 
graph ldg    v  a  unique leaf vertex x    x v  x  x    either 
x    x    x xpreo   preo   x     s x   x  v    x     x  x    arc sg 
 

   

fihoffmann

global dependency graph x  o    global dependency graph brief 
graph gdg    v  a  unique leaf vertex x    x v  x  x    either 
x    x  x     x xpreo   x  v    x     x  x    arc sg 
 

definition    let  x  si   sg   o   s  t    o    g   ldg g   gdg definition   
say g    v  a  successful following holds 
    g acyclic 
    g   ldg sg  x       s x     exists transitive successor x  x 
sg x  xsg sg  x       s x    
    t  either 
 a  self irrelevant side effect deletes 
 b  replaceable side effect deletes 
 c  recoverable side effect deletes 
    x v    x     dt gx transitions either irrelevant  self irrelevant
deletes  invertible irrelevant side effect deletes side effects
v    x    
lemma    let  x  si   sg   o  planning task  let state     h   s   
  say x  x and  every o    rop s x     c  dt gx  t     s x     c 
relevant  ldgo  successful local dependency graph s  x    o    then  least
one o    exist optimal relaxed plan p    s  s  successful optimal rplan
dependency graph odg  p    s   x    o    odg  sub graph ldgo   
proof  observe first definition   property     forces relaxed plan p    s  move
x    i e   p    s  x    non empty  particular  p    s  x    takes path

dt gx  s x    sg  x     let
q shortest path taken p    s  x     let

o  responsible operator first transition
q   clearly  transition
form  s x     c   i e   o  one operators o  claim  lying shortest path
s x    sg  x    sub graph dt gx  taken p    s  x     transition  s x     c 
irrelevant  seen exactly argument given proof

lemma   transitions paths
q constructed there  except endpoint
goal instead operator precondition 
next  observe optimal p    s  contains one operator x  xpreo
preo  x      s x     follows definition   property      x  cannot become important non achieved goal  i e   p    s  operator outside p    s  x    relies precondition x    see this  assume operator exist 
then  since p    s  optimal  exists reason inclusion o  precisely 
must achieve least one fact needed terms hoffmann nebel
     b   fact either goal precondition another operator o 
behind p    s   iterating argument o   if necessary   obtain sequence
  o     x    c     o     x    c                xn   cn    xn   cn   goal fact satisfied
oi achieves  xi   ci   p    s   obviously  sg contains path x  xn  
xn xsg sg  xn      s xn    contradiction definition   property      thus
exist  argument  follows every operator p    s  x   
   

fianalyzing search topology without running search

either side effect used elsewhere relaxed plan  precondition x   
thus operators p    s  x    preconditioned x  serve transform
s x    sg  x     course  then  single one operators relies s x   
else p    s  optimal 
say follows ldgo     v  a   denote  v     a    result backchaining
 
definition   o  p  
 s   definition   include variables arcs included
definition    see this  note arcs  x  x    included definition   due
relevant transitions  hence  v     a    sub graph  v  a   particular  since  v  a 
acyclic   v     a    acyclic well 
next observation that  assuming definition   condition     holds true  definition   condition   a  implies definition   condition   a   definition   condition   b  implies
definition   condition   b   definition   condition   c  implies definition   condition
  c  
consider first case  a  t  self irrelevant side effect deletes  show
 
r  c      recall notations appendix a   c      x    s x      ctx t    
r   super set set facts need relaxed plan removing o   
variables except x    clear fact intersection  facts
ctx t    irrelevant o   only relevant prerequisite  thus contained r    
hence   x    s x     remains possible content r   c    show follows
 x    s x       r     thus  x    s x       r   c  latter intersection empty 
desired  recall r   denotes union sg   precondition o     p    s  
precondition operator responsible operator induced
transition odt g 
x   x v    x     definition   condition       x    s x       sg  
argued above  o  operator p    s  may preconditioned s x   
thus precondition o     p    s   lastly  say p precondition
responsible operator induced transition odt g 
x   corresponding original
transition t  then  since inverse transitions introduce new conditions 
 
 s   then  since
p cond t  thus p prerop t  where  definition  rop t  p  
 
o     rop t  p  s    x    s x       prerop t    implies p     x    s x     
thus  x    s x       r   needed show 
consider case  b  t  recoverable side effect deletes  show definition  
condition   b  o    rop t     need prove s x    odg   relevant 
i e   s x      r     already shown above 
case  c   t  replaceable side effect deletes  again  show definition   condition
  c  t     need prove s x    odg   relevant 
consider finally conditions imposed non leaf variables x v    x     i e   definition   condition     definition   condition      definition   condition     
dt gx transitions every x v    x    either irrelevant  self irrelevant deletes 
invertible irrelevant side effect deletes side effects v    x    
dt gx transitions irrelevant cannot odt g 
x   thus  nd  rd case
 
 
true odt gx transitions every x v    x     concludes argument 
theorem    let  x  si   sg   o  planning task  let state    
h   s      say x  x that  every o    rop s x     c  dt gx 
 s x     c  relevant  ldgo  successful local dependency graph  local
   

fihoffmann

minimum  ed s  maxo  costd  ldgo     if  every ldgo    definition  
condition   a    b   ed s  maxo  costd  ldgo      
proof  lemma    choice o    rop s x     c  exists optimal relaxed
plan p    s  successful optimal rplan dependency graph odg     v     a    p    s  
odg  sub graph ldgo  unique leaf vertex x    apply
lemma   obtain local minimum 
see part claim  let v defined section    i e   v subset
v    x    dt gx transitions either irrelevant  invertible
empty conditions  irrelevant side effect deletes  side effects v    x     then 
dt gx transition x v   satisfies restriction required lemma  
 
odt g 
x transitions irrelevant  cannot odt gx   else invertible
irrelevant side effect deletes side effects v    x    restriction
required lemma   transitions either irrelevant  empty conditions
irrelevant side effect deletes  hence apply lemma   odg    obtain  not
necessarily monotone  path exit  length bound costd  odg     s x     c 
irrelevant side effect deletes replaceable side effect deletes  costd  odg       
 s x     c  recoverable side effect deletes  thus suffices show costd  ldgo   
costd  odg     that  however  obvious v v     costd  x    x 
 
maxpath dt gx   diam odt g 
x   x v  
theorem    let  x  si   sg   o  planning task  say global dependency graphs
gdg successful  contain local minima and  state
    h   s      ed s  maxgdg costd  gdg   if  every gdg  definition  
condition   a    b   ed s  maxgdg costd  gdg    
proof  let state  need prove local minimum  h   s     
h   s      nothing show  else  assume variables x topologically
ordered according strongly connected components sg  let x  x
uppermost variable x  xsg sg  x       s x     obviously  x  exists  clearly 
chance x  satisfy definition   condition     exists transitive
successor x  x  sg x  xsg sg  x       s x    exists x 
strongly connected sg component  x  xsg  and sg  x       s x     
then  exists transition t  dt gx  outside condition eventually leading 
backwards chaining sg  x    let gdg  global dependency graph x 
rop t     such gdg  exists x  xsg    since definition   includes transitive
sg predecessors x  pertaining conditions t    gdg  includes x    then  since
x  x  lie strongly connected component  definition   eventually reaches
x    thus gdg  contains cycle  contradiction prerequisite  follows
strongly connected sg component x  contains x    thus definition   condition
    holds true 
now  say o  responsible relevant transition form  s x     c  dt gx   
exists local dependency graph ldg s  x    o  ldg sub graph
gdg  follows simple observation definition   include  gdg 
variables arcs include ldg   note precondition o 
   

fianalyzing search topology without running search

x    present  satisfied o    rop s x     c   thus definition  
include x  predecessor achieving o  preconditions ldg  
obviously  given above  ldg successful  since works choice notirrelevant  s x     c   apply theorem    claim follows directly
fact costd  gdg  costd  ldg   latter obvious costd increases
monotonically adding additional variables 
a   example constructions
first example shows that  even within scope basic result  operators
necessarily respected relaxation  i e   operator may start optimal real plan yet
occur optimal relaxed plan 
example    consider planning task figure    variables shown  in dark green 
left hand side respective dtg  circles represent variable values  lines
represent dtg transitions  transitions condition longer lines  condition
inscribed line  in blue   variable  dashed arrow indicates value
initial state si   goal value defined  indicated circled value 
needed  refer operators responsible transition terms respective
variable followed indices start end value  example  operator moving
x c  c  referred x    abbreviate states   x  c    y  d    c  d  
stick conventions throughout section 

x

d 

c 

c 

d 

c 

d 


d 

d 

d 

d 

figure    planning task underlying example   
shown figure    dtg x consists three vertices whose connection requires
conditions d  d    alternatively d  shortcut  domain line
length   requiring conditions 
clearly  support graph planning task acyclic  transitions dtgs
side effects invertible  however  operator y    for example  respected
relaxation  see this  note first h   si        optimal relaxed plan
hy    y    x    x  i relaxed plan ignores need move back d  operator x    hand  optimal  real  plan si hy    y    y    y    x  i 
choose use y   instead  optimal relaxed plan does  end
sequence hy    y    x    y    y    x  i   step longer  hence  si   y   starts
optimal plan  start optimal relaxed plan 
   

fihoffmann

next give three examples showing local minima arise simple situations generalizing basic result minimally  consider  order  cyclic support
graphs  non invertible transitions  transitions side effects 
example    consider planning task figure   

x
c 

d 

c 


d 

d 

dn 

dn

c 

figure    planning task underlying example   
dtg x two vertices whose connection requires condition d   
domain line length n requiring conditions  shortcut d 
dn requires c  condition  clearly  transitions dtgs side effects
invertible  however  sg contains cycle x mutually
depend other  show mutual dependence causes initial state
si     x  c      y  d     local minimum  n    abbreviate  before  states
  x  c    y  d    c  d   h   si        optimal relaxed plan hx    y ni 
consider operators applicable si    c    d    
execute x    leading s     c    d    h   s        due hx    y ni  here 
new state reached via y    giving s     c    d    h   s        due
hy    x    y ni   note n     prerequisite  relaxed plan composed
yi i      operators   steps   h   s      h   si   way
cannot reach exit monotone path 
execute y    leading s     c    d    h   s        due hy    x    y ni   note
n     prerequisite  relaxed plan moving ypp operators
  steps   again  path monotone 
execute y n  leading s     c    dn   h   s        due hyn   x  i  here 
new state reached via yn n    giving s     c    dn    h   s       
due hy n  n  yn   x  i   note n    prerequisite  relaxed plan
moving d  via dn            d        steps   again  path monotone 
operators applicable si   thus explored states reachable si
monotone paths  none states exit  proving si local minimum  as
s  s     is  fact  single state h   s       namely    c    dn    
clearly  reaching si takes n   steps  first apply x    traverse d            dn   
exit distance si n    thus distance unbounded 
   

fianalyzing search topology without running search

section    following modification example   considered  set n       i e  
domain reduced two values d    d    remove line d            dn   
i e   move via previously short cut  modified example falls
sas   pubs tractable class identified backstrom klein         still
contains local minimum  the example unsolvable  though  
example    consider planning task figure   

x
c 

d 

c 

d 

c 


d 

d 

dn

figure    planning task underlying example    arrow d  d  indicates
respective dtg transition directed  i e   exists transition d 
d   
dtg x three vertices whose connection requires  starting initial value
c    first condition d    condition d    domain circle length n requiring
conditions  invertible except arc d  d   
clearly  support graph acyclic transitions dtgs side effects 
however  non invertible arc d  d  causes initial state si    c    d   
local minimum n    easy see  h   si       due
optimal relaxed plan hy    x    x  i  note relaxed plan
move back  y  d    still true executing y    now  operators applicable
si y   y n  latter  reaching state sn    c    dn    immediately increases
value h    because  n    y n get closer d    moving
farther away d   both need achieved   shortest relaxed sn
hyn   y    x    x  i  alternatively  say apply y   si   reaching state s     c    d    
h   s      n      need apply  relaxation  x    n   steps complete
circle d  back d    x    thus  n    s  larger h  value si  
follows si local minimum  nearest exit si sn     c    dn     sn 
relaxed plan hy n   n  yn   x  i length    applying y n   n get h 
value    reaching sn  si takes   step moving x n   steps moving y 
exit distance si n    thus distance unbounded 
example    consider planning task figure   
dtg x consists two kinds transitions  first  line c            cn
transitions requiring conditions  second  direct links  called short cuts
follows  cn every ci   conditioned value d  y  dtg contains
two vertices connected unconditionally  moving d  d  side effect
cn    that side effect responsible towards cn direction short cuts
dtg x  
   

fihoffmann

d 
d 

x
c 

c 

cn

cn


d 

d 

figure    planning task underlying example     red  inscription cn line
d  d  indicates transition d  d  side effect
cn  
support graph acyclic  arc goes x  due short cuts
dtg x  due operator y   effect x precondition y 
transitions invertible  particular short cut both  direction towards
cn vice versa  however  side effect y   causes initial state si    c    d   
local minimum n   
h   si       due optimal relaxed plan hy  i  note
relaxed plan care side effect y    c  still true afterward 
now  apply operator si leaves c    clearly increase h    
matter move make  relaxed plan must include y   move back c   
available option si apply y    get state s     cn   d     there 
h   s        well  relaxed plan needs re achieve c    since n   
via unconditional sequence cn           c  takes   steps  alternative use
short cut xn  cn c    involves applying y   first place  giving us
relaxed plan length    hence direct successors si heuristic value     
si local minimum  note exit distance si grows n  nearest
exit state goal reached single step  clearly 
state  c    d     shortest path state  si   applies y   moves along
unconditional line cn           c    taking      n      n   steps 
next show exit path constructed using short cuts  leading improved
bound costd instead costd   may non monotone  improved bound may
indeed under estimate length shortest monotone exit path 
example    consider planning task figure   
example  optimal relaxed plan initial state moves z along
path e            e n note values needed moving moves
d k  n   moves x c    gives total h   si      n     k    n         n    k    
steps 
operators applicable si move z  move along line e            e n  
h  remains constant  always need include moves back order achieve
goal z  reach e n   move one step  need move z back 
etc  moves  state   d k  n   long z stays within
   

fianalyzing search topology without running search

x
c 


d 

e  n

d 

e 

e 

e  n

d 

d k  n

c 

d k

e 

d k   e 

e  n

d k  n

z
e 

e 

e  n 

e  n

e

figure    planning task underlying example   
e            e n   h  remains constant  see this  observe first course suffices
relaxed plan reach once  z  values line  taking  n moves wherever
line  moves before  second  observe indeed moves
needed  wherever line d            d k  n   needs move d k  n order
suit x  needs move d  suit goal  every value e            e n appears
condition least one moves  thus  si   nearest exit reached
way state   d k  n z   e n   there  move x c 

decreases h   n    k  length exit path
described  si s 
obviously  k   n         n      kn    k    n 
happens move z e    consider first si   h  increases
 n    k      need reach values line e            e n   e  takes one

step more  argument applies state traversed
  because  argued 

state still need reach values line e            e n   thus

shortest monotone path exit 
optimal rplan dependency graph odg  si entire sg  odt g 
z
contains dt gz except e    global dependency graph gdg entire sg 
clearly  si   next required value reach variable e n   construction
proof theorem   first try reach value  using short cuts
accounted costd      exit path constructed move e n via e  rather via
line e            e n   thus claimed exit path monotone 
finally  consider bound returned costd  odg     obviously  costd  odg     
costd  gdg   obtain bound       costd  odg              costd  x         k  

 n  costd  x  diam odt g 
       k    n   n      cost  y  diam dt gz     note
diam dt gz     n     dt gz circle  n     nodes  overall 
    costd  odg        k  n  n       kn  k  n    n  sufficiently large k 
less  kn  k   n  claimed  detail   kn  k   n    kn  k   n    n
n 
iff  kn  k    n  iff kn k   n  iff k   n 
  holds  example  set n     
k      
reader noticed example   contrived  reason need
complicated unrealistic example costd   costd   contains two
sources over estimation  cf  discussion section    particular  every move non   

fihoffmann

leaf variables supposed take whole odt g   dt g diameter  show costd
general upper bound length monotone exit path  thus need presented
construction around k under estimation considering diam dt gz   instead
diam odt g 
z   outweighs over estimation  importantly  constructing examples
short cuts temporarily increase h   but costd nevertheless delivers upper bound
monotone exit path length  much easier  needs happen that  whatever
reason  variable z here  currently required value  e n example   
reached odt g 
z values along unnecessarily long path whose values needed
relaxed plan  happens quite naturally  e g   transportation domains
vehicle needs load unload objects along longer path 
demonstrate that  case analyses apply  exit distance may
exponential 
example    consider planning task figure   

x 
c   

x 
c   

c   

c   

c   

c   

c   

c   

c   

c   

c   

c   

xn
c  n

c  n

c  n

c  n

c  n

figure    planning task underlying example   
dtg x  two vertices whose connection conditioned c    
variables xi   five vertices line  alternatingly requiring last vertex ci  

 
i  
xi   first vertex c  xi     clearly  optimal rplan dependency graph
odg  si   global dependency graph gdg task full support
graph sg  acyclic  transitions invertible side effects  thus
analyses apply 
h   si   ed si    relaxed plan  need move x  c     due
conditioning  variable extreme values left right hand side
required need   moves xi   n  thus h   si          n 
now  consider state s x      c     construct relaxed plan  obviously
still need   move x    still need   moves variable  consider x   
s x      c   need move c   order able move x    s x      c  
need move c   order able move x    c   goal 
forth  cases  four transitions must taken relaxed plan  due
conditioning  recursively true variables  thus  h   s         n 
   

fianalyzing search topology without running search

means nearest exit state s  x  value c   x  value c    
s    move x  afterward  definitely   n steps suffice relaxed plan 
distance state s    need move x  four times  lets denote d x        
move requires   moves x    d x          sequence moves x  inverses
direction three times  points  x  need move d x       d x         
generalizing this  get d xi        d xi     d x             d xi        growth
n exponential 
obviously  example   shows plan length exponential cases
theorem   applies  remark example   similar example given
domshlak dinitz         difference domshlak dinitzs example
uses different conditions transitions left to right  enables
use smaller dtgs   nodes  setting  cannot use different conditions
need transitions invertible  causes loss exit path steps
situations next lower variable inverses direction thus relies
outside condition previous step  indeed  dtgs size    loss
steps results polynomially bounded exit distance  recursive formula d xi  
becomes d xi        d xi     d x            d xi        resulting ed si     n    n 
hand  costd costd still remain exponential case 
consider loss incurred inversing
directions  precisely  easy see
p
costd  odg      costd  gdg        ni    i    n      proves bounds
over estimate exponential amount 
next example shows exit path constructed  implicitly  analyses may
exponentially longer optimal plan task 
example    consider planning task figure    

x 
c   

c   

c   

c  

x 
c   

c   

c   

 
c n  

c   

c   

c   

c   

c   

xn
c  n

c  n

c  n

c  n

c  n

figure     planning task underlying example   
   

c   

fihoffmann

example  optimal relaxed plan initial state
example    alternative route via c              c    n    takes      n        n      
 n     steps  thus exit path constructed remains same  too  length exponential
n  however  length shortest plan  n     
note example   observed weakness guided wrong direction
caused weakness optimal relaxed planning  rather weakness
analysis  relaxation overlooks fact moving via x            xn incur high costs
due need repeatedly undo re do conditions achieved beforehand  note
that  example too  get exponential over estimation exit distance 
finally show feeding theorem   non optimal relaxed plans give
guarantees 
example    consider planning task figure    

x
c 
g  

d 

c 

g n  

c

v 


d 

en

d 

g  

g  

g n  

g n  

v n  

z
e 

e n 

en

figure     planning task underlying example    arrow en  en indicates
respective dtg transition directed  i e   exists transition
en en   
two ways achieve goal c    either via moving z  moving
v            vn     optimal relaxed plan chooses former option  giving h   si     n   
soon n    however  parallel optimal relaxed plan p    si   chooses latter
option moving z results n     sequential moves  whereas v            vn  
moved parallel  giving parallel length   
consider happens h  either options  move z  h  remains
constant need move z back goal  soon reach z   en  
h    last transition uni directional longer achieve
goal z  thus exit path  particular monotone exit path  via
option 
say move v            vn   instead  first move  whichever vi choose   h 
increases shortest option undo move go via z  takes
n     steps whereas completing vi moves going via c  takes  n            n     steps 
   

fianalyzing search topology without running search

thus monotone exit path via option either  si local minimum 
completing n     moves vi moving x   c    h     n          due
shortest relaxed plan moves back vi moves x   c    reduce heuristic
value initial value h   si     n      need execute   steps 
state reached better evaluated neighbor  exit distance n     
consider effect feeding theorem   parallel optimal plan p    si   
clearly  optimal rplan dependency graph odg  constructed p    si   consists x
vi variables  include z  thus theorem applies 
wrongly concludes si local minimum 
exit distance bound computed
p
  

   costd  x  diam dt gvi      n     
      costd  odg              costd  x     n  
i  
less actual distance ed si     n      thus result wrong 
say modify example   making last transition z undirected  making
one vi transitions unidirectional right  v            vn   option leads
dead end  whereas y  z option succeeds  particular  theorem   apply
odg  constructed parallel optimal relaxed plan p    si    thus example
using non optimal relaxed plans results loss information 
a   benchmark performance guarantees
give definitions   domains mentioned propositions      domain 
explain respective property claimed holds true  domains 
assume static properties used pddl capture unchanging things
shape road network transportation domain  assume follows
static predicates removed prior analysis  i e   prior testing
prerequisites theorem   
definition    logistics domain set planning tasks    v  o  si   sg   whose
components defined follows  v   p v p set package location variables
p  dp   l v l set representing possible locations  v set
vehicle location variables v  dv   lv subset lv l locations  contains
three types operators  move  load  unload  move v  l   l       v  
l     v   l    l     l   load v  l  p      v   l  p   l    p   v    unload v  l  p   
  v   l  p   v    p   l    si assigns arbitrary value variables  sg
assigns arbitrary value subset variables 
every global dependency graph gdg logistics either package p leaf
variable x    vehicle variable v leaf variable x    latter case gdg
consists x    arcs  former case  o  preconditioned single vehicle
v only  leading single non leaf variable v  cases  gdg acyclic  involved
transitions side effects  involved transitions invertible  thus
apply theorem    costd  gdg            packages costd  gdg     
vehicles  thus overall obtain correct bound   
definition    miconic strips domain set planning tasks  
 v  o  si   sg   whose components defined follows  v   b  e 
 o     d     b     s  and  set passenger origin variables o    l l
   

fihoffmann

set representing possible locations  floors   set passenger destination
variables dd   l  b set passenger boarded variables b db          
set passenger served variables ds           e elevator location variable
de   l  contains three types operators  move  board  depart 
move l   l       e   l     e   l    l     l   board l  i      e   l  oi   l    bi       
depart l  i      e   l  di   l  bi        bi      si        si assigns arbitrary locations
variables o  d  e  assigns   variables b s  sg assigns   variables
s 
passenger origin passenger destination variables static  i e   affected
operator  thus common pre processes remove variables  using
statically prune set operators reachable  assume follows
removal taken place 
every global dependency graph gdg miconic strips passenger served variable
si leaf variable x    leads non leaf variables bi e  arcs e
variables bi si   clearly  gdg acyclic  transitions e
invertible side effects  transition        bi  is invertible since
departing different condition e but  irrelevant own delete bi    
occur anywhere goal preconditions side effects thus irrelevant
side effect deletes  transition        bi  is invertible but  irrelevant bi    
doesnt occur anywhere  transition        leaf variable si self irrelevant side
effect deletes bi     occurs precondition transitions responsible
operator rop         depart ld   i   hence apply theorem    delivers bound
costd  gdg            si           costd  si   maxpath dt gbi             costd  si    
costd  bi    diam dt ge        
definition    simple tsp domain set planning tasks    v  o  si   sg  
whose components defined follows  v    p  v where  p position variable 
dp   l l set representing possible locations  v    v      l  
set location visited variables v  dv           contains single type
operators  move l   l       p   l     p   l   vl        l     l   si assigns arbitrary
value p assigns   variables v   sg assigns   variables v  
every global dependency graph gdg simple tsp location visited variable vi
leaf variable x    leads single non leaf variable p  clearly  gdg acyclic 
every transition        vi considered  induced o    move l   li   replaceable side
effect deletes  operator   move l   x  replaced equivalent operator
move li  x  unless x   li  latter case  o    excluded
definition replaceable side effect deletes  every transition  l   l   p clearly invertible 
irrelevant side effect delete vl       side effect vl 
non leaf variable gdg  hence apply theorem    delivers bound
costd  gdg            vi           costd  vi   diam dt gp        
consider extended version movie domain  sense that  whereas
original domain version considers fixed range snacks  and thus state space
constant across domain instances   allow scale number different snacks   
    original domain version allows scale number operators adding snack 
operators identical  removed trivial pre processes 

   

fianalyzing search topology without running search

definition    movie domain set planning tasks    v  o  si   sg  
whose components defined follows  v    c   c   re  h  here  c  counterat zero variable  dc            c  counter at two hours variable 
dc            movie rewound variable  dre           h have snack
variables h dh           contains four types operators  rewindtwo  rewindother  resetcounter  getsnack  rewindt wo     c         re       
rewindother     c         re      c         resetcounter       c        
getsnack i        hi        si assigns arbitrary value variables  sg assigns
re  c   h variables   
note that  depending value static variable c   operator set
different  si  c       rewindother removed  si  c       rewindt wo
removed  refer former case  a  latter case  b  
every global dependency graph gdg consists single  leaf  variable  transitions
h variable side effects thus irrelevant side effect deletes 
transition        c  side effects thus irrelevant side effect deletes 
transition        c  irrelevant  case  a   transition        side
effects thus irrelevant side effect deletes apply theorem    case  b  
transition        side effect c       observe     fact
irrelevant      ctx        c           resetcounter satisfies
  preo  prevrop      eff rop           re      c         c 
       eff    c       
 c         eff   y  d     y  d     y  d  sg rop c c     o  preo       c       
thus transition recoverable side effect deletes  apply theorem   
case  a   gdgs bound costd  gdg    applies  obviously  costd  gdg     
thus obtain correct bound    case  b   bound costd  gdg  applies 
costd  gdg      obtain correct bound   
definition    ferry domain set planning tasks    v  o  si   sg   whose
components defined follows  v   c  f  e  where  c set car location
variables c  dc   l  f   l set representing possible locations  f
ferry location variable df   l  e ferry empty variable de          
contains three types operators  sail  board  debark  sail l   l    
  f   l     f   l    l     l   board l  c      f   l  c   l  e        c   f  e       
debark l  c      f   l  c   f     c   l  e        si assigns   variable e  assigns
arbitrary value variable f   assigns arbitrary value f variables
c  sg assigns arbitrary value    f  some subset   variables c f  
let arbitrary reachable state     h   s      let p    s 
arbitrary optimal relaxed plan s  always apply theorem    show this 
distinguish three cases   a  s e       o    board l  c  first board operator p    s  
set x    c   b  s e       o    debark l  c  first debark operator p    s  
set x    c   c  p    s  contains board debark operator set o 
first operator  sail l   l    p    s   x    f   obviously  exactly one cases
hold s  let odg     v  a  sub graph sg including x  variables arcs
included per definition    let t  transition taken o   
case  a   obviously reorder p    s  either board l  c  first operator
p    s   predecessors sail operators  odg  either     includes new
   

fihoffmann

 non leaf  variables all      includes f   f   clearly transitions
invertible side effects  transition t  effect  c  f   deleting  c  l 
clearly needed rest p    s   side effect e     deleting e     
latter fact may needed board operators p    s   however  necessarily
p    s  contains operator form debark l    c   applicable board l  c 
sequence moves p    s  must contain l l    debark l    c  recovers e     
 
thus odg   relevant deletes t  p  
 s  recoverable  case  b   similarly
 
reorder p  s  either     debark l  c  first operator p    s      
predecessors sail operators  transition t  effect  c  l  deleting  c  f  
clearly needed rest p    s   side effect e     deleting e    
clearly needed rest p    s   thus  again  odg   relevant deletes
 
 
t  p  
 s  recoverable  the recovering sub sequence p  
 s  empty
 
recovery required   case  c   finally  odg contains f   t  side effects 
delete  f  l   needed anymore  in fact  case l  must goal
f   p    s  contains single operator o     hence  cases  apply
theorem    costd  odg        cases  a     b     c  get bound   
costd  odg          diam dt gf       cases  a    b   get bound   
definition     gripper domain set planning tasks    v  o  si   sg  
whose components defined follows  v    ro  f    f    b  here  ro robotlocation variable  dro    l  r   f    f  gripper free variables  df    df   
        b ball location variables  db    l  r         contains three types
operators  move  pickup  drop  move l   l       ro   l     ro   l   
l     l   pickup g  b  l      ro   l  b   l  fg        b   g  fg        drop g  b  l      ro  
l  b   g    b   l  fg        si assigns l ro  assigns   f  f    assigns l
variables b  sg assigns r variables b 
let arbitrary reachable state     h   s      let p    s 
arbitrary optimal relaxed plan s  always apply theorem    distinguish
two cases   a  exists b b s b    g g         o    drop g  b  r  
set x    b   b  exists b b s b    g g         o    pickup g  b  l 
b b p    s   set x    b  obviously  exactly one cases
hold s  let odg     v  a  sub graph sg including x  variables arcs
included per definition    let t  transition taken o   
case  a   obviously reorder p    s  either drop g  b  r  first
operator p    s   predecessor move l  r   odg  either     includes
new  non leaf  variables all      includes ro  ro  clearly transitions
invertible side effects  transition t  effect  b  r  deleting
 b  g  clearly needed rest p    s   side effect fg     deleting
fg     clearly needed rest p    s   thus odg   relevant deletes
 
t  p  
 s  recoverable  case  b   similarly reorder p    s  either    
pickup g  b  l  first operator p    s       predecessor move r  l  
transition t  effect  b  g  deleting  b  l  clearly needed rest
p    s   side effect fg     deleting fg      latter fact may needed
pickup operators p    s   however  necessarily p    s  contains operators move l  r 
drop g  b  r   applicable board l  c   drop g  b  r  recovers fg      thus 
   

fianalyzing search topology without running search

 
again  odg   relevant deletes t  p  
 s  recoverable  hence  cases 

 
apply theorem    cost  odg       cases  a    b    get bound   
costd  odg          diam ro      cases  a    b   get bound   

definition     transport domain set planning tasks    v  o  si   sg  
whose components defined follows  v   p v e c where  p set packagelocation variables p  dp   l v e l set representing possible
locations  v e set vehicle location variables v  dv   l  c set
vehicle capacity variables cv   dcv               k  k maximum capacity 
contains three types operators  drive  pickup  drop  where  drive v  l   l    
  v   l     v   l     l   l   r gr    l  r  undirected graph roads
l  pickup v  l  p  c      v   l  p   l  cv   c    p   v  cv   c      drop v  l  p  c   
  v   l  p   v  cv   c    p   l  cv   c        si assigns arbitrary value l
variables p v e  assigns k variables c  sg assigns arbitrary value
l subset variables p v e 
note use numbers addition subtraction  are  course  part
planning language consider here  however  easily encoded  on
finite set number             k   via static predicates  pre processing  effect
resulting task isomorphic one obtained simple arithmetic above 
thus choose reduce notational clutter 
let arbitrary reachable state     h   s      exists
optimal relaxed plan p    s  apply theorem    distinguish three
cases   a  exists p p s p    v v v e  o    drop v  l  p  c 
s cv     c p    s   set x    p   b  exists p p s p    v
v v e  o    pickup v  l  p  k  p p p    s   set x    p   c  p    s 
contains drop pickup operator set o  first operator  drive v  l   l   
p    s   x    v  obviously  choose p    s  exactly one cases
hold  the choice p    s  arbitrary  b   c    a  may exist optimal
relaxed plans s cv      c   let odg     v  a  sub graph sg including x 
variables arcs included per definition    let t  transition taken o   
case  a   obviously reorder p    s  either o    drop v  l  p  c  first
operator p    s   predecessors drive operators  odg  either     includes
new  non leaf  variables all      includes v  v  clearly transitions
invertible side effects  transition t  effect  p  v  deleting
 p  l  clearly needed rest p    s   side effect cv   c   deleting
cv   c  latter fact may needed operators p    s   either taking form
drop v  l    p    c  form pickup v  l    p    c   clearly  p    s  contains operators
replace drop v  l    p    c      pickup v  l    p    c      respectively
value  cv   c      true point  relaxed  execution  thus
choose p    s  p    s  relevant deletes t  p    s  recoverable v    x    
case  b   similarly reorder p    s  either     o    pickup v  l  p  k 
first operator p    s       predecessors drive operators  transition t 
effect  p  v  deleting  p  l  clearly needed rest p    s  
side effect cv   k   deleting cv   k  latter fact may needed
operators p    s   taking form pickup v  l    p    k   however  necessarily p    s 
   

fihoffmann

contains operator form drop v  l    p  c     c     k   replace
operator drop v  l    p  k    since  clearly  value  cv   k    true
point  relaxed  execution  now  drop v  l    p  k    applicable pickup v  l  p  k 
sequence drive operators p    s  must contain l l    drop v  l    p  k   
recovers cv   k  thus  again  choose p    s  p    s  relevant deletes
t  p    s  recoverable v    x     case  c   finally  odg  contains v  t 
side effects  delete  v  l   needed anymore  hence  cases 
apply theorem    costd  odg        cases  a     b     c  get bound
   costd  odg          min diam odt g 
v    diam dt gv    cases  a    b  
bound diameter road map gr  
ignoring action costs  elevators domain ipc      essentially variant
transport  variant general  a  vehicle  each elevator  may
maximal capacity   b  vehicle reach subset locations  i e  
vehicle individual road map  hand  elevators restricted
transport  c  vehicle road map fully connected  every reachable floor
navigated directly every reachable floor    d  goals exist
packages  passengers  is   vehicles  even ignoring restrictions  c   d  
trivial see arguments given transport still hold true  therefore 
whenever reachable state     h   s      exists optimal relaxed plan
p    s  apply theorem    before  bound diameter
road map  due  c   diameter   

references
backstrom  c     klein  i          planning polynomial time  sas pubs class 
computational intelligence        
backstrom  c     nebel  b          complexity results sas  planning  computational
intelligence                 
blum  a  l     furst  m  l          fast planning planning graph analysis  artificial
intelligence                   
bonet  b     geffner  h          planning heuristic search  artificial intelligence        
        
botea  a   muller  m     schaeffer  j          using component abstraction automatic
generation macro actions  koenig et al   koenig  zilberstein    koehler        
pp         
brafman  r     domshlak  c          structure complexity planning unary
operators  journal artificial intelligence research             
bylander  t          computational complexity propositional strips planning 
artificial intelligence                  
cesta  a     borrajo  d   eds    ecp           recent advances ai planning   th
european conference planning  ecp     lecture notes artificial intelligence 
toledo  spain  springer verlag 
   

fianalyzing search topology without running search

chen  h     gimenez  o          causal graphs structurally restricted planning  journal computer system sciences                 
domshlak  c     dinitz  y          multi agent offline coordination  structure complexity  cesta   borrajo  cesta   borrajo         pp       
edelkamp  s     helmert  m          exhibiting knowledge planning problems minimize state encoding length  biundo  s     fox  m   eds    recent advances ai
planning   th european conference planning  ecp     lecture notes artificial
intelligence  pp          durham  uk  springer verlag 
fox  m     long  d          automatic inference state invariants tim  journal
artificial intelligence research            
fox  m     long  d          detection exploitation symmetry planning
problems  pollack  m   ed    proceedings   th international joint conference artificial intelligence  ijcai     pp          stockholm  sweden  morgan
kaufmann 
garey  m  r     johnson  d  s          computers intractabilitya guide
theory np completeness  freeman  san francisco  ca 
gerevini  a   howe  a   cesta  a     refanidis  i   eds    icaps           proceedings
  th international conference automated planning scheduling  icaps   
thessaloniki  greece  aaai 
gerevini  a   saetti  a     serina  i          planning stochastic local search
temporal action graphs  journal artificial intelligence research             
gerevini  a     schubert  l          inferring state constraints domain independent
planning  mostow  j     rich  c   eds    proceedings   th national conference american association artificial intelligence  aaai     pp         
madison  wi  usa  mit press 
gimenez  o     jonsson  a          complexity planning problems simple
causal graphs  journal artificial intelligence research             
gimenez  o     jonsson  a       a   influence k dependence complexity
planning  gerevini et al   gerevini  howe  cesta    refanidis         pp         
gimenez  o     jonsson  a       b   planning chain causal graphs variables
domains size   np hard  journal artificial intelligence research             
haslum  p          reducing accidental complexity planning problems  veloso  m 
 ed    proceedings   th international joint conference artificial intelligence
 ijcai     pp            hyderabad  india  morgan kaufmann 
helmert  m          complexity results standard benchmark domains planning 
artificial intelligence              
helmert  m          planning heuristic based causal graph analysis   koenig et al 
 koenig et al          pp         
helmert  m          fast downward planning system  journal artificial intelligence
research             
   

fihoffmann

helmert  m          concise finite domain representations pddl planning tasks  artificial intelligence                    
helmert  m     domshlak  c          landmarks  critical paths abstractions  whats
difference anyway  gerevini et al   gerevini et al          pp         
hoffmann  j          utilizing problem structure planning  local search approach 
vol       lecture notes artificial intelligence  springer verlag 
hoffmann  j          ignoring delete lists works  local search topology planning
benchmarks  journal artificial intelligence research             
hoffmann  j     nebel  b       a   planning system  fast plan generation
heuristic search  journal artificial intelligence research             
hoffmann  j     nebel  b       b   rifo revisited  detecting relaxed irrelevance  cesta
  borrajo  cesta   borrajo         pp         
hoffmann  j   porteous  j     sebastia  l          ordered landmarks planning  journal
artificial intelligence research             
jonsson  a          role macros tractable planning  journal artificial intelligence research             
jonsson  p     backstrom  c          incremental planning  european workshop
planning 
jonsson  p     backstrom  c          state variable planning structural restrictions 
algorithms complexity  artificial intelligence                    
karpas  e     domshlak  c          cost optimal planning landmarks  boutilier  c 
 ed    proceedings   st international joint conference artificial intelligence
 ijcai     pp            pasadena  ca  usa  morgan kaufmann 
katz  m     domshlak  c       a   new islands tractability cost optimal planning 
journal artificial intelligence research             
katz  m     domshlak  c       b   structural patterns heuristics via fork decomposition 
rintanen  j   nebel  b   beck  j  c     hansen  e  a   eds    proceedings
  th international conference automated planning scheduling  icaps    
pp          sydney  australia  aaai 
knoblock  c          automatically generating abstractions planning  artificial intelligence                 
koenig  s   zilberstein  s     koehler  j   eds    icaps           proceedings
  th international conference automated planning scheduling  icaps    
whistler  canada  aaai 
long  d     fox  m          automatic synthesis use generic types planning 
chien  s   kambhampati  r     knoblock  c   eds    proceedings  th international conference artificial intelligence planning systems  aips     pp         
breckenridge  co  aaai press  menlo park 
mcdermott  d  v          using regression match graphs control search planning 
artificial intelligence                    
   

fianalyzing search topology without running search

nebel  b   dimopoulos  y     koehler  j          ignoring irrelevant facts operators
plan generation  steel  s     alami  r   eds    recent advances ai planning   th
european conference planning  ecp     vol       lecture notes artificial
intelligence  pp          toulouse  france  springer verlag 
richter  s   helmert  m     westphal  m          landmarks revisited  fox  d     gomes 
c   eds    proceedings   rd national conference american association
artificial intelligence  aaai     pp          chicago  illinois  usa  mit press 
richter  s     westphal  m          lama planner  guiding cost based anytime
planning landmarks  journal artificial intelligence research             
rintanen  j          iterative algorithm synthesizing invariants  kautz  h  a  
  porter  b   eds    proceedings   th national conference american
association artificial intelligence  aaai     pp          austin  tx  usa 
mit press 
roberts  m     howe  a          learning planner performance  artificial intelligence 
            
vidal  v          lookahead strategy heuristic search planning  koenig et al 
 koenig et al          pp         
williams  b  c     nayak  p  p          reactive planner model based executive 
pollack  m   ed    proceedings   th international joint conference artificial
intelligence  ijcai     pp            nagoya  japan  morgan kaufmann 

   


