journal artificial intelligence research                 

submitted        published     

provably bounded optimal agents
stuart j  russell

computer science division  university california
berkeley  ca        usa

devika subramanian

computer science department  cornell university
ithaca  ny        usa

russell cs berkeley edu
devika cs cornell edu

abstract

since inception  artificial intelligence relied upon theoretical foundation centred around perfect rationality desired property intelligent systems  argue 
others done  foundation inadequate imposes fundamentally
unsatisfiable requirements  result  arisen wide gap theory
practice ai  hindering progress field  propose instead property called bounded
optimality  roughly speaking  agent bounded optimal program solution
constrained optimization problem presented architecture task environment  show construct agents property simple class machine
architectures broad class real time environments  illustrate results using
simple model automated mail sorting facility  define weaker property 
asymptotic bounded optimality  abo   generalizes notion optimality classical
complexity theory  construct universal abo programs  i e   programs
abo matter real time constraints applied  universal abo programs
used building blocks complex systems  conclude discussion
prospects bounded optimality theoretical basis ai  relate similar trends
philosophy  economics  game theory 

   introduction

since beginning artificial intelligence  philosophers  control theorists
economists looked satisfactory definition rational behaviour  needed
underpin theories ethics  inductive learning  reasoning  optimal control  decision making 
economic modelling  doyle        proposed ai defined computational study rational behaviour effectively equating rational behaviour intelligence  role definitions ai ensure theory practice correctly
aligned  define property p   hope able design system
provably possesses property p   theory meets practice systems exhibit p reality  furthermore  exhibit p reality something actually care
about  sense  choice p study determines nature field 
number possible choices p  
perfect rationality  classical notion rationality economics philosophy 
perfectly rational agent acts every instant way maximize
expected utility  given information acquired environment  since
action selection requires computation  computation takes time  perfectly rational
agents exist non trivial environments 
c      ai access foundation morgan kaufmann publishers  rights reserved 

firussell   subramanian

calculative rationality  notion rationality studied ai  calculatively rational

agent eventually returns would rational choice beginning
deliberation  exist systems uence diagram evaluators exhibit
property decision theoretic definition rational choice  systems
nonlinear planners exhibit logical definition rational choice 
assumed interesting property system exhibit since constitutes
 in principle  capacity right thing  calculative rationality limited
value practice  actual behaviour exhibited systems absurdly
far rational  example  calculatively rational chess program choose
right move  may take      times long so  result  ai systembuilders often ignore theoretical developments  forced rely trial and error
engineering achieve goals  even simple domains chess  little
theory designing analysing high performance programs 
metalevel rationality  natural response problems calculative rationality 
metalevel rational system optimizes object level computations performed service selecting actions  words  decision finds
optimal combination computation sequence plus action  constraint
action must selected computation  full metalevel rationality
seldom useful metalevel computations take time  metalevel decision problem often dicult object level problem  simple
approximations metalevel rationality proved useful practice for example  metalevel policies limit lookahead chess programs but engineering
expedients merely serve illustrate lack theoretical basis agent design 
bounded optimality  bounded optimal agent behaves well possible given
computational resources  bounded optimality specifies optimal programs rather
optimal actions optimal computation sequences  former approach
avoid placing constraints intelligent agents cannot met
program  actions computations are  all  generated programs 
programs designers control 
make three claims 
   system exhibits bounded optimality desirable reality 
   possible construct provably bounded optimal programs 
   artificial intelligence usefully characterized study bounded optimality 
particularly context complex task environments reasonably powerful
computing devices 
first claim unlikely controversial  paper supports second claim
detail  third claim may  may not  stand test time 
begin section   necessarily brief discussion relationship
bounded optimality earlier notions rationality  note particular important distinctions missed without precise definitions terms  thus section  
provide formal definitions agents  programs  behaviour rationality 
   

fiprovably bounded optimal agents

together formal descriptions task environments  elements allow us prove
given agent exhibits bounded optimality  section   examines class agent architectures problem generating bounded optimal configurations eciently
soluble  solution involves class interesting practically relevant optimization
problems appear addressed scheduling literature  illustrate results showing throughput automated mail sorting facility
might improved  section   initiates discussion bounded optimal configurations
might learned experience environment  section    define weaker property  asymptotic bounded optimality  abo   may robust tractable
strict version bounded optimality  particular  construct universal abo
programs  program universally abo abo regardless specific form
time dependence utility function   universal abo programs therefore used
building blocks complex systems  conclude assessment prospects
development approach artificial intelligence 

   historical perspective
classical idea perfect rationality  developed aristotle s theories ethics 
work arnauld others choice uncertainty  mill s utilitarianism  put
formal footing decision theory ramsey        vonneumann morgernstern
        stipulates rational agent always act maximize expected utility 
expectation taken according agent s beliefs  thus  perfect rationality
require omniscience 
artificial intelligence  logical definition rationality  known philosophy
 practical syllogism   put forward mccarthy         reiterated strongly
newell         definition  agent take action believes
guaranteed achieve goals  ai said theoretical foundation  definition rationality provided it  mccarthy believed  probably
correctly  early stages field important concentrate  epistemological adequacy   heuristic adequacy    is  capability principle rather
practice  methodology resulted involves designing programs exhibit
calculative rationality  using various speedup techniques approximations
hope getting close possible perfect rationality  belief  albeit unproven 
simple agent designs fulfill specification calculative rationality may
provide good starting points approach bounded optimality  moreover  theoretical foundation based calculative rationality cannot provide necessary guidance
search 
clear ai would embarked quest calculative rationality
operating halcyon days formal intractability results discovered 
one response spectre complexity rule bounds  levesque
brachman        suggest limiting complexity environment calculative
perfect rationality coincide  doyle patil        argue strongly position 
   usage term  universal  derives use scheduling randomized algorithms
luby  sinclair zuckerman        

   

firussell   subramanian

economists used perfect rationality abstract model economic entities 
purposes economic forecasting designing market mechanisms  makes
possible prove theorems properties markets equilibrium  unfortunately 
simon        pointed out  real economic entities limited time limited powers
deliberation  proposed study bounded rationality  investigating        shape
system effectiveness computation one important weapons
survival   simon s work focussed mainly satisficing designs  deliberate
reaching solution satisfying preset  aspiration level   results descriptive value modelling various actual entities policies  general prescriptive
framework bounded rationality developed  although proved possible calculate
optimal aspiration levels certain problems  structural variation allowed
agent design 
theory games  bounds complexity players become topic
intense interest  example  troubling fact defection equilibrium
strategy unbounded agents playing fixed number rounds prisoners  dilemma
game  neyman s theorem  neyman         recently proved papadimitriou yannakakis         shows essentially cooperative equilibrium exists agent
finite automaton number states less exponential number
rounds  essentially bounded optimality result  bound space rather
speed computation  type result made possible shift
problem selecting actions problem selecting programs 
i  j  good        distinguished perfect  type i  rationality  metalevel
 type ii  rationality  defines  the maximization expected utility taking
account deliberation costs   simon        says   the global optimization problem
find least cost best return decision  net computational costs   although type ii
rationality seems step right direction  entirely clear whether
made precise way respects desirable intuition computation important 
try one interpretation  although may others   key issue space
 maximization   optimization  occurs  good simon seem
referring space possible deliberations associated particular decision 
conceptually   object level machine  executes sequence computations
control  meta level machine   outcome sequence selection
external action  agent exhibits type ii rationality end deliberation
subsequent action  utility maximized compared possible deliberate act pairs
could engaged  example  good discusses one possible application type
ii rationality chess programs  case  object level steps node expansions
game tree  followed backing leaf node evaluations show best move 
simplicity assume per move time limit  type ii rational agent execute
whichever sequence node expansions chooses best move  finish
   example  conceivable good simon really intended refer finding agent design
minimizes deliberation costs general  discussions  however  seem couched terms
finding right deliberation decision  thus  type ii metalevel rationality coincides
bounded optimality bounded optimal agent designed single decision single
situation 

   

fiprovably bounded optimal agents

time limit   unfortunately  computations required  metalevel machine 
select object level deliberation may extremely expensive  good actually proposes
fairly simple  and nearly practical  metalevel decision procedure chess  far
optimal  hard see type ii rational agent could justify executing suboptimal
object level computation sequence limit scope optimization problem
single decision  diculty resolved thinking design
agent program  generates unbounded set possible deliberations response
unbounded set circumstances may arise life agent 
philosophy seen gradual evolution definition rationality 
shift consideration act utilitarianism   rationality individual acts  
rule utilitarianism  rationality general policies acting  shift caused
diculties individual versus societal rationality  rather consideration
diculty computing rational acts  consideration given recently
tractability general moral policies  view making understandable
usable persons average intelligence  brandt         cherniak        suggested
definition  minimal rationality   specifying lower bounds reasoning powers
rational agent  instead upper bounds  philosophical proposal generally consistent
notion bounded optimality found dennett s  moral first aid manual 
        dennett explicitly discusses idea reaching equilibrium within space
decision procedures  uses example phd admissions procedure philosophy
department  concludes  we  best procedure may neither elegant
illuminating  existence procedure  process reaching it 
main points interest 
many researchers ai  whose work discussed below  worked
problem designing agents limited computational resources       aaai symposium ai limited rationality  fehling   russell        contains interesting
variety work topic  much work concerned metalevel rationality 
metareasoning   reasoning reasoning   important technique area 
since enables agent control deliberations according costs benefits 
combined idea anytime  dean   boddy        exible algorithms  horvitz 
       return better results time goes by  simple form metareasoning allows
agent behave well real time environment  simple example provided
iterative deepening algorithms used game playing  breese fehling        apply similar ideas controlling multiple decision procedures  russell wefald        give
general method precompiling certain aspects metareasoning system eciently estimate effects individual computations intentions  giving fine grained
control reasoning  techniques seen approximating metalevel rationality  provide useful insights general problem control reasoning 
reason suppose approximations used optimal sense 
intuitive notion bounded optimality seems become current ai
community mid      s  horvitz        uses term bounded optimality refer
 the optimization computational utility given set assumptions expected
   one would imagine cases move selected move selected type
agent  sense  accidental  deliberation might cause program
abandon it 

   

firussell   subramanian

problems constraints reasoning resources   russell wefald        say
agent exhibits bounded optimality given task environment  if program solution
constrained optimization problem presented architecture   recent work
etzioni        russell zilberstein        seen optimizing welldefined set agent designs  thereby making notion bounded optimality precise 
next section  build suitable set general definitions ground up 
begin demonstrate examples provably bounded optimal agents 

   agents  architectures programs
intuitively  agent physical entity wish view terms perceptions
actions  counts first instance does  necessarily thinks 
even whether thinks all  initial refusal consider constraints
internal workings agent  such reason logically  example  helps
three ways  first  allows us view  cognitive faculties  planning reasoning
occurring service finding right thing do  second  makes room
among us  agre   chapman        brooks        take position systems
right thing without cognitive faculties  third  allows freedom consider
various specifications  boundaries interconnections subsystems 
begin defining agents environments terms actions percepts
exchange  sequence states go through  agent described
agent function percept sequences actions  treatment fairly standard
 see  e g   genesereth   nilsson         go  inside  agent look agent
program generates actions  define  implementation  relationship
program corresponding agent function  consider performance measures
agents  problem designing agents optimize performance measure 

    specifying agents environments

agent described abstractly mapping  the agent function  percept
sequences actions  let set percepts agent receive instant 
set possible actions agent carry external world  since
interested behaviour agent time  introduce set time points
instants  t  set totally ordered   relation unique least element 
without loss generality  let set non negative integers 
percept history agent sequence percepts indexed time  define
set percept histories ot   fot     og  prefix history ot   ot
till time denoted ot projection ot     t   define set
percept history prefixes ot   fot j   t  ot   otg  similarly  define set
action histories   fat     ag  set action history prefixes at  defined
set projections histories    

definition   agent function  mapping
f   ot  
   

fiprovably bounded optimal agents



at t    f  ot 
note agent function entirely abstract entity  unlike agent program
implements it  note  output  agent function given percept sequence
may null action  example agent still thinking do  agent
function specifies agent time step  crucial distinction
perfect rationality calculative rationality 
agents live environments  states environment e drawn set x 
set possible state trajectories defined xt   fx     xg  agent
necessarily full access current state x t t   percept received agent
depend current state perceptual filtering function fp  effects
agent s actions represented environment s transition function fe 
specifies next state given current state agent s action  environment
therefore defined follows 

definition   environment e   set states x distinguished initial state x  
transition function fe perceptual filter function fp

x       x 
x t t        fe at  t   x t t  
ot t    fp x t t  
state history x thus determined environment agent function 
use notation effects f  e   denote state history generated agent function
f operating environment e   use notation  e    denote
state history generated applying action sequence starting initial state
environment e  
notice environment discrete deterministic formulation 
extend definitions cover non deterministic continuous environments 
cost additional complexity exposition  none results depend significant
way discreteness determinism 

    specifying agent implementations

consider physical agent consisting architecture program 
architecture responsible interfacing program environment 
running program itself  architecture   associate finite programming
language lm   set programs runnable architecture  agent
program program l   lm takes percept input internal state drawn
set initial state i    the initial internal state depends program l 
usually suppress argument   set possible internal state histories
      ig  prefix internal state history   till time denoted
projection     t  
   

firussell   subramanian

definition   architecture fixed interpreter agent program runs

program single time step  updating internal state generating action 
  lm  

hi t t       at t i    l  t t   ot t  
thus  architecture generates stream actions according dictates program 
physical properties architecture  running program single
time step results execution finite number instructions  program may
often fail reach  decision  time step  result action produced
architecture may null  or previous action  depending program
design  

    relating agent specifications implementations

relate agent programs corresponding agent functions  say
agent program l running machine implements agent function agent l    
agent function constructed following definition specifying action sequences
produced l running possible percept sequences  note importance
 markovian  construction using internal state agent ensure actions
based past  future 

definition   program l running implements agent function f   agent l    
defined follows  environment e    x  fe  fp   f  ot     t 
hi t t       at t i    l  t t   ot t  
ot  t 
x t t     
x t   
t   

 
 
 
 

fp x t t  
fe at t   x t t  
x 
i 

although every program l induces corresponding agent function agent l    
action follows given percept necessarily agent s  response  percept 
delay incurred deliberation  may ect percepts occurring much
earlier sequence  furthermore  possible map every agent function
implementation l   lm   define subset set agent functions f
implementable given architecture language lm  
feasible m     j  l   lm   f   agent l   g
feasibility related to  clearly distinct from  notion computability  computability refers existence program eventually returns output specified
function  whereas feasibility refers production output appropriate
point time  set feasible agent functions therefore much smaller set
computable agent functions 
   

fiprovably bounded optimal agents

    performance measures agents

evaluate agent s performance world  define real valued utility function u
state histories 
u   xt    
utility function seen external agent environment  defines
problem solved designer agent  agent designs may incorporate
explicit representation utility function  means required 
use term task environment denote combination environment utility
function 
recall agent s actions drive environment e particular sequence
states accordance function effects f  e    define value agent
function f environment e utility state history generates 
v  f  e     u  effects f  e   
designer set e environments probability distribution p them 
instead single environment e   value agent e defined
expected value elements e  slight abuse notation 

v  f  e   

x

e e

p e  v  f  e  

assign value v  l  m  e   program l executed architecture
environment e simply looking effect agent function implemented
program 
v  l  m  e     v  agent l     e     u  effects agent l     e   
above  extend set possible environments follows 

v  l  m  e   

x

e e

p e  v  l  m  e  

    perfect rationality bounded optimality

discussed section    perfectly rational agent selects action maximizes
expected utility  given percepts far  framework  amounts agent
function maximizes v  f  e  possible agent functions 
definition   perfectly rational agent set e environments agent function
fopt
fopt   argmaxf  v  f  e  
definition persuasive specification optimal agent function given
set environments  underlies several recent projects intelligent agent design  dean
  wellman       doyle        hansson   mayer         direct implementation
specification  ignores delay incurred deliberation  yield reasonable
   

firussell   subramanian

solution problem   calculation expected utilities takes time real agent 
terms simple formal description agents introduced above  easy see
diculty arisen  designing agent program  logicists decision theorists
concentrated specifying optimal agent function fopt order guarantee
selection best action history  function fopt independent architecture  
unfortunately  real program lm implements function non trivial environment 
optimal actions cannot usually computed next percept arrives 
is  quite frequently  fopt    feasible m   
suppose environment consists games chess tournament rules
population human grandmasters  suppose standard personal computer 
fopt describes agent always plays way maximize total
expected points opposition  maximization moves makes 
claim possible program play way  quite possible  using depth first
alpha beta search termination  execute program chooses  say  optimal
minimax move situation  agent function induced program
fopt  particular  ignores percepts dropping ag indicating
loss time 
trouble perfect rationality definition arose unconstrained optimization space f  s determination fopt   without regard feasibility 
 similarly  metalevel rationality assumes unconstrained optimization space deliberations   escape quandary  propose machine dependent standard rationality  maximize v implementable set agent functions feasible m   
is  impose optimality constraints programs rather agent functions
deliberations 

definition   bounded optimal agent architecture set e environments
agent program lopt
lopt   argmaxl lm v  l  m  e 

see immediately specification avoids obvious problems
type type ii rationality  consider chess example 
suppose computer
  
 
total program memory   megabytes    possible programs
represented machine  much smaller number play legal chess 
tournament conditions  one programs best expected performance  suitable candidate lopt  thus bounded optimality is  definition 
feasible specification  moreover  program achieves highly desirable 
yet ready announce identity lopt chess eight megabyte pc 
begin restricted problem 

   provably bounded optimal agents

order construct provably bounded optimal agent  must carry following
steps 
specify properties environment actions taken 
utility function behaviours 
   

fiprovably bounded optimal agents

specify class machines programs run 
propose construction method 
prove construction method succeeds building bounded optimal agents 
methodology similar formal analysis used field optimal control 
studies design controllers  agents  plants  environments   optimal control
theory  controller viewed essentially instantaneous implementation optimal
agent function  contrast  focus computation time required agent 
relation computation time dynamics environment 

    episodic  real time task environments

section  consider restricted class task environments call episodic
environments  episodic task environment  state history generated actions
agent considered divided series episodes  terminated
action  let a  distinguished set actions terminate episode 
utility complete history given sum utilities episode 
determined turn state sequence    a   environment
 resets  state chosen random stationary probability distribution pinit  
order include effects choice utility episode  notionally
divide environment state  configuration  part  value  part 
configuration part determines state transitions value part determines
utility state sequence  actions a  reset configuration part   value 
recorded value part  restrictions mean episode treated
separate decision problem  translate following property  agent program l 
higher expected utility individual episodes agent l   higher expected
utility corresponding episodic task environment 
real time task environment one utility action depends
time executed  usually  dependence suciently strong make
calculative rationality unacceptably bad approximation perfect rationality 
automated mail sorter  provides illustrative example episodic task environment  see figure     machine scans handwritten printed addresses  zipcodes 
mail pieces dispatches appropriate bins  episode starts arrival
new mail piece terminates execution physical action recommended
sorter  routing piece specific bin   configuration part  environment corresponds letter feeder side  provides new  randomly selected letter
previous letter sorted   value part  state corresponds state
receiving bins  determines utility process  aim maximize
accuracy sorting minimizing reject percentage avoiding jams  jam occurs
current piece routed appropriate bin  rejected  arrival
next piece 
provide formal definitions three varieties real time task environments 
fixed deadlines  fixed time cost stochastic deadlines 
   see  sackinger et al        boser et al        details actual system  application
suggested us bernhard boser early presentation work      nec symposium 

   

firussell   subramanian

camera
sacks mail

zipcode
buckets

reject

figure    automated mail sorting facility provides simple example episodic 
real time task environment 
      fixed deadlines

simplest commonly studied kind real time task environment contains
deadline known time  work real time systems  deadlines described
informally systems built meet deadline  here  need formal specification
order connect description deadline properties agents running
deadline task environments  one might think deadlines part environment
description  fact mainly realized constraints utility function  one
see considering opposite deadline    starter s pistol   two
distinguished differing constraints utilities acting specific
time 
definition   fixed deadline  task environment he  u fixed deadline time td
following conditions hold 
taking action a  time deadline results utility 

u   e  at      u   e  a  td     at   t   
   denotes sequence concatenation  td   at   t    a    a  t    a  td    
contain action a  
actions taken td effect utility 

u   e  at    u   e  at    u   e  at d    u   e  at d    td
      fixed time cost

task environments approximately fixed time cost common  examples
include consultations lawyers  keeping taxi waiting  dithering invest
one s money  define task environment fixed time cost c comparing
utilities actions taken different times 
   

fiprovably bounded optimal agents

definition   fixed time cost 
task environment he  u fixed time cost if 


action history prefixes a   a   satisfying
    at   t     a  at   t     at   t  
    a  t      a  t      contain action a 
utilities differ difference time cost 
u   e  at        u   e  at        c t    t  

strictly speaking  task environments fixed time cost  utility values
finite range  one cannot continue incurring time costs indefinitely  reasonably short
times reasonably small costs  linear utility penalty useful approximation 
      stochastic deadlines

fixed deadline fixed cost task environments occur frequently design
real time systems  uncertainty time dependence utility function
common  turns interesting  see below 
stochastic deadline represented uncertainty concerning time occurrence
fixed deadline  words  agent probability distributionppd deadline
time td   assume deadline must come eventually  t t pd  t      
define cumulative deadline distribution pd  
deadline occur known time  need distinguish
two cases 
agent receives percept  called herald  dean   boddy         announces
impending deadline  model using distinguished percept od  

ot td     od
agent responds immediately   meets deadline  
percept available  case agent walking blindfolded towards
utility cliff  deliberating further  agent risks missing deadline may
improve decision quality  example familiar readers deciding
whether publish paper current form  embellish risk
 scooped   treat case current paper 
formally  stochastic deadline case similar fixed deadline case  except td
drawn distribution pd   utility executing action history prefix e
expectation utilities state history prefix possible deadline times 
definition   stochastic deadline  task environment class he  u fixed deadline task
environments stochastic deadline distributed according pd if  action history
prefix  
x
u   e       pd  t  u   et     
 t

 

 

het   u task environment he  u fixed deadline t  
 

   

firussell   subramanian

mail sorter example well described stochastic deadline  time
arrival mail pieces image processing station distributed according density
function pd   usually poisson 

    agent programs agent architecture

consider simple agent programs episodic task environments  constructed elements set r   fr            rn g decision procedures rules  decision procedure
recommends  but execute  action ai   a   agent program fixed
sequence decision procedures  purposes  decision procedure black box
two parameters 

run time ti    integer represents time taken procedure
compute action 

quality qi    real number  gives expected reward resulting
executing action ai start episode 

qi   u   e  ai  

   

let mj denote agent architecture executes decision procedures language j  
let tm denote maximum runtime decision procedures accommodated
  example  runtime feedforward neural network proportional
size  tm runtime largest neural network fits  
architecture executes agent program   s        sm running decision
procedure turn  providing input obtained initial percept 
deadline arrives  at fixed time td   heralded percept od   
entire sequence completed  agent selects action recommended
highest quality procedure executed 

 s  t td   ot td     hi   action i t td   i
 s  t ts   ot ts     hi   action i t ts  i ts   psi s ti
 s  t t   od    hi   action i t t  i

   

updates agent s internal state history t t  action i t t  
action recommended completed decision procedure highest quality 
action executed  internal state agent re initialized i    agent
design works three task environment categories described above 
next derive value v  s  m  e   agent program environment e running
three real time regimes show construct bounded optimal agents
task environments 

    bounded optimality fixed deadlines

equation    know agent picks action a  recommended
decision procedure r highest quality executed deadline td arrives 
   

fiprovably bounded optimal agents

p

let s        sj longest prefix program ji   ti td   definition  
equation    follows
v  s  m  e     qj
   
qi   maxfq           qi g  given expression value agent program 
easily show following 
theorem   let r   arg maxri   r titd qi   singleton sequence r bounded optimal
program episodic task environment known deadline td 
is  best program single decision procedure maximum quality whose runtime
less deadline 

    bounded optimality fixed time cost

equation    know agent picks action a  recommended best
decision procedure sequence  since runs entire sequence   s        sm
deadline  definition   equation   

v  s  m  e     qm   c


x
i  

ti

   

given expression value agent program  easily show following 
theorem   let r   arg maxri   r qi   cti   singleton sequence r bounded optimal
program episodic task environment fixed time cost c 
is  optimal program single decision procedure whose quality  net time
cost  highest 

    bounded optimality stochastic deadlines

stochastic deadline distributed according pd  value agent program
    sm expectation  definition    calculate
p ps  t  v s s    m 
et   het  u task environment fixed deadline t  aft t
ter substituting v  s  m  et  equation    expression simplifies summation 
procedures sequence  probability interruption ith procedure
sequence multiplied quality best completed decision procedure 

x
pi
v  s  v  s  m  e     pd pij  
   
   tj     pd   j    tj   qi
i  
rt
pd  t      
pd t  dt  pd  t      pmi   ti 
simple example serves illustrate value function  consider r   fr    r    r g 
rule r  quality     needs   seconds run  represent r             
rules r              r              deadline distribution function pd
uniform distribution      seconds  value sequence r  r r 
v  r  r r                                                
geometric intuition given notion performance profile  shown figure   

   

firussell   subramanian

q

   
   
   

p t 


 

 

 

figure    performance profile r r  r   pd superimposed 

definition    performance profile  sequence s  performance profile qs  t  gives
quality action returned agent interrupted t 

qs t    maxfqi  


x

j   

tj tg

uniform deadline density function  value sequence proportional
area performance profile last possible interrupt time  note
height profile interval length ti rule running quality
best previous rules 
definition     following obvious property 
lemma   performance profile sequence monotonically nondecreasing 
case sequence higher quality decisions times better
sequence 
lemma    t qs   t  qs   t   v  s   v  s    
case say qs  dominates qs   
use idea performance profiles establish useful properties optimal
sequences 
lemma   exists optimal sequence sorted increasing order q s 

p

without lemma    ni   i  possible sequences consider  ordering constraint eliminates  n sequences  means proofs properties sequences  need consider ordered sequences  addition  replace qi
equation   qi  
following lemma establishes sequence always improved addition
better rule end 
lemma   every sequence   s        sm sorted increasing order quality  single
step z qz qsm   v  sz   v  s  
   

fiprovably bounded optimal agents

corollary   exists optimal sequence ending highest quality rule r 
following lemma ects obvious intuition one get better result
less time  there s point spending time get worse result 
lemma   exists optimal sequence whose rules nondecreasing order ti  
apply preparatory results derive algorithms construct bounded
optimal programs various deadline distributions 
      general distributions

general deadline distribution  dynamic programming method used obtain
optimal sequence decision rules pseudo polynomial time  construct optimal
sequence using definition v  s  m  e   equation    optimal sequences generated
methods ordered qi  accordance lemma   
construct table  i  t   entry table highest value
sequence ends rule ri time t  assume rule indices arranged

p
increasing order quality  ranges start time   end time l   ri  r ti  
update rule is 

 i  t    maxk      i    s  k    ti      qi   qk       pd  t   
boundary condition
 i         rule     t      time
corollary    read best sequence highest value row n
matrix  
theorem   dp algorithm computes optimal sequence time o n l  n
number decision procedures r 

dependence l time complexity dp algorithm means algorithm polynomial input size  using standard rounding scaling methods 
however  fully polynomial approximation scheme constructed  although
hardness proof problem  john binder        shown deadline
distribution used constant time oracle finding values p  t   algorithm
require exponential number calls oracle worst case 
      long uniform distributions

deadline uniformly distributed time interval greater sum
running times rules  call distribution long uniform distribution  consider
rule sequence   s        sm drawn rule set r  long uniform distribution 
probability deadline arrives rule si sequence independent
time si starts  permits simpler form equation   

v  s  m  e    pmi     pd  ti   qi   qm      pmi   pd  ti  
   

   

firussell   subramanian

derive optimal sequence long uniform distribution  obtain recursive
specification value sequence   r   s        sm sequence
r 

v  as  m  e    v  s  m  e    qapd  t     qmpd  ta 

   

allows us define dynamic programming scheme calculating optimal sequence
using state function  i  j   denoting highest value rule sequence starts
rule ends rule j   lemma   equation    update rule is 

 i  j     maxi kj  s  k  j     pd  tk  qi   pd  ti qj  

   

boundary condition

 i  i         pd  ti  qi

   

corollary    know optimal sequence long uniform distribution ends
rn   rule highest quality r  thus  need examine  i  n    
n  entry requires o n  computation  n entries compute  thus 
optimal sequence long uniform case calculated o n    

theorem   optimal sequence decision procedures long uniform deadline distribution determined o n   time n number decision procedures
r 
      short uniform distributions

p

ni   pd  ti       uniform deadline distribution pd  call short  means
sequences longer last possible deadline time  therefore rules
sequences possibility executing deadline  sequences 
cannot use equation   calculate v  s   however  sequence truncated
removing rules would complete execution last possible deadline 
value sequence unaffected truncation  truncated sequences use
equation   justified  furthermore  optimal sequence truncated
sequence 
since update rule   correctly computes  i  j   truncated sequences  use
short uniform distributions provided add check ensure sequences
considered truncated  unlike long uniform case  however  identity last rule
optimal sequence unknown  need compute n  entries  i  j   table 
entry computation takes o n  time  thus time compute optimal sequence
o n   

theorem   optimal sequence decision procedures short uniform deadline distribution determined o n   time n number decision procedures
r 
   

fiprovably bounded optimal agents

      exponential distributions

exponential distribution  pd t      e fit   exponential distributions allow optimal
sequence computed polynomial time  let pi stand probability rule
interrupted  assuming starts    pi   pd ti         e fiti   exponential
distribution  v  s  m  e  simplifies as 

v  s  m  e   



h
ij        pj   pi  qi   mj       pj   qm

mx
   h
i  

yields simple recursive specification value v  as  m  e  sequence
begins rule a 

v  as  m  e         pa  p qa        pa v  s  m  e 
use state function  i  j   represents highest value rule sequence
starting ending j  

 i  j     maxi kj       pi  pk qi        pi s  k  j   
boundary condition  i  i    qi     pi   given j    i  j   calculated
o n    corollary    know optimal sequence whose last element
highest valued rule r 

theorem   optimal sequence decision procedures exponentially distributed
stochastic deadline determined o n   time n number decision
procedures r 

proof similar long uniform distribution case 

    simulation results mail sorter

preceding results provide set algorithms optimizing construction agent
program variety general task environment classes  section  illustrate
results possible gains realized specific task environment  namely 
simulated mail sorter 
first  let us precise utility function u episodes  four
possible outcomes  utility outcome ui 
   zipcode successfully read letter sent correct bin delivery 
   zipcode misread letter goes wrong bin 
   letter sent reject bin 
   next letter arrives recognizer finished  jam  since
letter arrival heralded  jams cannot occur machine architecture given
equation   
   

firussell   subramanian

 

 
mu  

   

   

   

   
p t 

accuracy

lambda    

   

   

   

   

 

 
 

 

 
 
computation time  sec 

 

  

 

 

 
 
time  sec 

 

  

figure     a  accuracy profile      e x            b  poisson arrival distribution 
mean     sec
without loss generality  set u        u         probability rule
recommending correct destination bin pi  qi   piu         pi u    pi   assume
u  u   hence threshold probability letter sent
reject bin instead  therefore include rule set r rule rreject
zero runtime recommends rejection  sequence construction algorithm
automatically exclude rules quality lower qreject   u   overall utility
episode chosen linear combination quality sorting  qi    probability
rejection rejection rate  given p  t    t  runtime first non reject
rule executed   speed sorting  measured arrival time mean  
agent program  boser et al        uses single neural network chip 
show variety conditions optimized sequence networks
significantly better single network terms throughput accuracy  examine
following experimental conditions 
assume network executes time recognition accuracy p
depends t  consider p     e t   particular choice irrelevant
scale chosen arbitrary  choose        convenience  figure   a   
include rreject qreject   u  treject     
consider arrival time distributions poisson varying means  figure   b  shows three example distributions  means         seconds 
create optimized sequences sets    networks execution times taken
equal intervals        
compare
 a  bo sequence  bounded optimal sequence 
 b  best singleton  best single rule 
 c      rule  rule whose execution time mean distribution  i e  
complete     cases  
   

fiprovably bounded optimal agents

 
bo sequence
best singleton
    rule
    rule

average utility per second

   

   

   

   

 
 

  

  

  
  
mean arrival time

  

  

  

figure    graph showing achievable utility per second function average time
per letter  four program types        
 d      rule  rule whose execution time guarantees complete    
cases 
last three cases  add rreject initial step  bo sequence include
automatically 
measure utility per second function mean arrival rate  figure    
shows optimal setting sorting machinery   letters per
minute  inter arrival time      seconds  bounded optimal program  given
fixed     
finally  investigate effect variance arrival time relative
performance four program types  purpose  use uniform distribution
centered around    seconds different widths vary variance without
affecting mean  figure    
notice several interesting things results 
policy choosing rule     probability completion performs poorly
rapid arrival rates       catches performance best single
rule slower arrival rates         artifact exponential accuracy
profile        difference quality rules run times
greater   seconds quite small 
policy choosing rule     probability completion fares well
best single rule high arrival rates       rapidly diverges
thereafter  performing far worse arrival time means greater   seconds 
   

firussell   subramanian

 
bo sequence
best singleton
    rule
    rule

average utility per second

   

   

   

   

 
 

  

  

  
  
variance arrival time

   

   

figure    graphs showing utility gain per second function arrival time
variance  four program types uniform distribution mean
   seconds 

best sequence best single rule give best overall performance
arrival rate around   letters per minute  performance advantage
optimal sequence best single rule    arrival rate 
noted significant performance advantage obtainable
extra computational resources  slower arrival rates       difference
performance best rule best sequence arises decreased
rejection rate best sequence  exponential accuracy profile       
advantage running rule shorter completion time ahead longer rule
ability reduce probability rejecting letter  high arrival rates
 inter arrival times     seconds   useful short rules instead
longer single rule 

figure   shows best sequence performs better best single rule

variance arrival time increases   performance optimal sequence
appears largely unaffected variance  exactly behaviour expect
observe   ability run sequence rules instead committing single
one gives robustness face increasing variance  since realistic environments
involve unexpected demands many kinds  possession variety default
behaviours graded sophistication would seem optimal design choice
bounded agent 

   performance     rule uniform distributions used experiment
fixed mean symmetric      rule always rule runs    seconds 
    rule changes variance  curve exhibits discretization effects  could
eliminated using finer grained set rules 

   

fiprovably bounded optimal agents

   learning approximately bounded optimal programs

derivations assume suitable rule set r available ab initio  correct
qualities qi runtimes ti   deadline distribution known  section 
study ways information learned  implications
bounded optimality resulting system  concentrate learning rules
qualities  leaving runtimes deadline distributions future work 
basic idea learning algorithms converge  time  set
optimal components   accurate rules accurate quality estimates
them  happens  value agent constructed rules  using quality
estimates  converges value lopt  thus two sources suboptimality
learned agent 
rules r may best possible rules   may recommend actions
lower utility would recommended rules 
may errors estimating expected utility rule  cause
algorithms given construct suboptimal sequences  even best rules
available 
notional method constructing bounded optimal agents     learns sets individual decision procedures episodic interactions      arranges sequence
using one algorithms described earlier performance agent using
sequence least good agent  assume parameterized learning algorithm lj  k used learn one rule possible runtime
k   f           tm g  since never need include two rules runtime
r  obviates need consider entire rule language j optimization
process 
setting places somewhat unusual requirements learning algorithm 
learning algorithms  lj  k works observing collection training episodes e 
including utility obtained episode  not  however  make assumptions
form correct decision rule  instead  make assumptions
hypotheses  namely come finite language jk   set programs
j complexity k  setting called agnostic learning setting
kearns  schapire sellie         assumptions made environment
all  shown  theorems     kearns  schapire sellie        that 
languages j   error learned approximation bounded within
best rule jk fits examples  probability       sample size needed
guarantee bounds polynomial complexity parameter k  well      
addition constructing decision procedures  lj  k outputs estimates
quality qi   standard chernoff hoeffding bounds used limit error quality
estimate within q probability     q   sample size estimation quality
polynomial  q  q  
thus error agnostically learned rule bounded within best rule
complexity class probability       error quality estimation
rules bounded q probability     q   bounds  calculate bound
utility deficit agent program construct  comparison lopt  
   

firussell   subramanian

theorem   assume architecture mj executes sequences decision procedures
agnostically learnable language j whose runtimes range     tm    real time task

environments fixed time cost  fixed deadline  stochastic deadline  construct
program l
v  lopt   m  e    v  l  m  e     q
probability greater     m    q    number decision procedures
lopt  

proof  prove theorem stochastic deadline regime  bounded

optimal program sequence decision procedures  proofs fixed cost
fixed deadline regimes  bounded optimal program singleton  follow
special case  let best decision procedures e set r   fr            rn g 
let lopt   s        sm optimal sequence constructed r  let r   fr          rng
set decision procedures returned learning algorithm  probability greater
    m  qi   qi i  qi refers true quality ri   error
estimated quality q i decision procedure ri bounded  probability greater
    mq   jq i   qi j q i 
let   s        sm rules r come runtime classes
rules s        sm r   then  equation   
v  lopt   m  e    v  s  m  e 
error v weighted average errors individual qi   similarly 

jv   s  m  e    v  s  m  e j q
suppose sequence construction algorithm applied r produces sequence
l   s        sl   definition  sequence appears optimal according estimated
value function v    hence
v   l  m  e  v   s  m  e 
before  bound error estimated value 
jv   l  m  e    v  l  m  e j q
combining inequalities 
v  lopt   m  e    v  l  m  e     q
 

 

 

although theorem practical applications  mainly intended illustration
learning procedure converge bounded optimal configuration 
additional work  general error bounds derived case rule
execution times ti real time utility variation  time cost  fixed deadline  deadline
distribution  estimated training episodes  obtain error bounds
case rule language j divided smaller number coarser
runtime classes  rather potentially huge number currently use 
   

fiprovably bounded optimal agents

   asymptotic bounded optimality

strict notion bounded optimality may useful philosophical landmark
explore artificial intelligence  may strong allow many interesting  general
results obtained  observation made ordinary complexity theory 
although absolute eciency aim  asymptotic eciency game  sorting
algorithm o n log n  rather o n   considered significant  replacing  multiply
    shift left   bit  considered real advance  slack allowed
definitions complexity classes essential building earlier results  obtaining robust
results restricted specific implementations  analysing complexity
algorithms use algorithms subroutines  section  begin reviewing
classical complexity  propose definitions asymptotic bounded optimality
advantages  show classical optimality special case
asymptotic bounded optimality  lastly  report preliminary investigations
use asymptotic bounded optimality theoretical tool constructing universal
real time systems 

    classical complexity

problem  classical sense  defined pair predicates output
z solution input x  x   x  z   hold  problem instance
input satisfying   algorithm problem class always terminates output
z satisfying  x  z   given input x satisfying  x   asymptotic complexity describes
growth rate worst case runtime algorithm function input size 
define formally follows  let ta  x  runtime algorithm input x 
let ta  n  maximum runtime input size n  algorithm
complexity o f  n  
 k  n   n n   n    ta  n  kf  n 
intuitively  classically optimal algorithm one lowest possible complexity 
purposes constructing asymptotic notion bounded optimality 
useful definition classical optimality mention complexity
directly  done follows 
definition    classically optimal algorithm  algorithm classically optimal

 k  n   a   n n   n    ta  n  kta  n 
relate classical complexity framework  need define special case task
environments traditional programs appropriate  task environments 
input provided program initial percept  utility function
environment histories obeys following constraint 
definition    classical task environment  hep   u classical task environment
problem p
 
l outputs correct solution p
v  l  m  ep     u   t  l  m  ep    ifotherwise
 

   

firussell   subramanian

 l  m  ep   running time l ep   universal turing machine 
u positive decreasing function 
notion problem class classical complexity theory thus corresponds class
classical task environments unbounded complexity  example  traveling salesperson problem contains instances arbitrarily large numbers cities 

    varieties asymptotic bounded optimality

first thing need complexity measure environments  let n e   suitable
measure complexity environment  assume existence environment
classes unbounded complexity  then  analogy definition classical
optimality  define worst case notion asymptotic bounded optimality  abo  
letting v  l  m  n  e  minimum value v  l  m  e   e e complexity n 

definition    worst case asymptotic bounded optimality  agent program l timewise
 or spacewise  worst case asymptotically bounded optimal e iff
 k  n   l   n n   n    v  l  km  n  e  v  l   m  n  e 
km denotes version machine speeded factor k  or k times
memory  
english  means program basically along right lines needs
faster  larger  machine worst case behaviour good program
environments 
probability distribution associated environment class e  use
expected value v  l  m  e  define average case notion abo 
definition    average case asymptotic bounded optimality  agent program l timewise
 or spacewise  average case asymptotically bounded optimal e iff
 k  l  v  l  km  e  v  l    m  e 
worst case average case definitions abo  would happy
program abo nontrivial environment nontrivial architecture   unless
k enormous   rest paper  use worst case definition abo 
almost identical results obtained using average case definition 
first observation made abo programs classically optimal
programs special case abo programs  
   classical definitions allow optimality constant factor k runtime algorithms 
one might wonder chose use constant factor expand machine capabilities  rather
increase time available program  context ordinary complexity theory 
two alternatives exactly equivalent  context general time dependent utilities 
former appropriate  would possible simply  let l run k times longer   programs
wish consider control execution time  trading solution quality  one could
imagine slowing entire environment factor k  merely less realistic version
propose 
   connection suggested bart selman 

   

fiprovably bounded optimal agents

theorem   program classically optimal given problem p
timewise worst case abo corresponding classical task environment class hep   u i 
observation follows directly definitions            
summary  notion abo provide degree theoretical robustness
machine independence study bounded systems asymptotic complexity
classical programs  set basic framework  begin exercise
definitions 

    universal asymptotic bounded optimality

asymptotic bounded optimality defined respect specific value function v  
constructing real time systems  would prefer certain degree independence
temporal variation value function  achieve defining family v value
functions  differing temporal variation  mean value function
preserves preference ordering external actions time  value functions
family preference ordering  
example  fixed cost regime vary time cost c generate family
value functions  stochastic deadline case  vary deadline distribution pd
generate another family  also  since three regimes uses quality measure
actions  union three corresponding families family 
show single program  call universal program  asymptotically
bounded optimal regardless value function chosen within particular family 
definition    universal asymptotic bounded optimality  uabo   agent program l
uabo environment class e family value functions v iff l abo e
every vi   v  
uabo program must compete abo programs every individual value function
family  uabo program therefore universal real time solution given task 
uabo programs exist  so  construct them 
turns use scheduling construction  russell   zilberstein 
      design uabo programs  construction designed reduce task environments unknown interrupt times case known deadlines  insight
applies here  construction requires architecture provide program concatenation  e g   lisp prog construct   conditional return construct  null program
  universal program lu form concatenation individual programs
increasing runtime  appropriate termination test each  written
lu    l  l  lj  
lj consists program termination test  program part lj
program lm abo e value function vj corresponds fixed deadline
td    j   time increment smaller execution time non null
program lm  
   value function must therefore separable  russell   wefald         since preservation rank
order allows separate time cost defined  see chapter    keeney   raiffa        thorough
discussion time dependent utility 

   

firussell   subramanian

q

l u  m

   

l opt

   
   

p t 


 

  

figure    performance profiles lu running  m   lopt running
proceeding statement lu indeed uabo  let us look example 
consider simple  sequential machine architecture described earlier  suppose
select rules three rule set r              r             r              since
shortest runtime rules   seconds  let      look optimal
programs l    l   l   l          fixed deadline task environments td                     
are 

l      l    r   l    r   l    r         
hence sequence programs lu    r   r    r          
consider task environment class value function vi specifies stochastic
deadline uniformly distributed range              class  lopt   r  r 
bounded optimal sequence   turns lu higher utility lopt provided
run machine four times faster  see plotting two performance
profiles  qu lu  m qopt lopt   qu dominates qopt  shown figure   
establish lu construction yields uabo programs general  need
define notion worst case performance profile  let q  t  l  m  n  e  minimum
value obtained interrupting l t  e e complexity n  know
lj lu satisfies following 

 l   n n   nj   vj lj   kj m  n  e  vj l    m  n  e 
constants kj   nj   aim prove

 vi   v  k  n   l   n n   n    vi lu   km  n  e  vi l   m  n  e 
given definition worst case performance profile  fairly easy show following
lemma  the proof essentially identical proof theorem   russell zilberstein 
      
   notice that  simple model  output quality rule depends execution time
input complexity  means worst case average case behaviour same 

   

fiprovably bounded optimal agents

 
bo sequence
abo sequence

average utility per second

   

   

   

   

 
 

  

  

  
  
mean arrival time

  

  

  

  function mean
figure    throughput accuracy improvement lu lopt
arrival time         poisson arrivals 

lemma   lu universal program e v   li abo e vi   v  
q t  lu   km  n  e  dominates q t  li   m  n  e  k   maxj kj   n   maxj nj  
lemma establishes that  small constant penalty  ignore specific realtime nature task environment constructing bounded optimal programs  however 
still need deal issue termination  possible general lu
terminate appropriate time without access information concerning timedependence utility function  example  fixed time cost task environment 
appropriate termination time depends value time cost c 
general case deterministic time dependence  help lu supplying  vi    aspiration level  qi  ti  li   m  n  e   ti time
li acts  lu terminates completed lj qj qi  ti   li  m  n  e  
construction  happen later ti lemma   

theorem   task environments deterministic time dependence  lu suitable
aspiration level uabo e  
deadline heralds  termination test somewhat simpler require
additional input lu  
theorem    task environment stochastic deadlines  lu uabo e
terminates herald arrives 
returning mail sorting example  fairly easy see lu  which consists
sequence networks  optimal programs stochastic deadline case 
abo fixed deadline regime  obvious abo particular
   

firussell   subramanian

stochastic deadline case   recall regimes considered single family 
programmed constructor function universal programs  applied
mail sorter environment class  varying letter arrival distribution gives us different value
functions vi   v   figure   shows lu  on  m   higher throughput accuracy
across entire range arrival distributions 
lopt
given existence uabo programs  possible consider behaviour compositions thereof  simplest form composition functional composition 
output one program used input another  complex  nested compositional structures entertained  including loops conditionals  zilberstein        
main issue constructing uabo compositions allocate time among
components  provided solve time allocation problem know
total runtime allowed  use construction technique used generate composite uabo programs  optimality among possible compositions
components  zilberstein russell         show allocation problem
solved linear time size composite system  provided composition tree
bounded degree 

   conclusions work
examined three possible formal bases artificial intelligence  concluded
bounded optimality provides appropriate goal constructing intelligent systems 
noted similar notions arisen philosophy game theory
less reason  mismatch classically optimal actions
called feasible behaviours those generated agent program running
computing device finite speed size 
showed careful specification task environment computing
device one design provably bounded optimal agents  exhibited simple
agents  likely bounded optimality strict sense dicult goal
achieve larger space agent programs considered  relaxed notions
asymptotic bounded optimality  abo  may provide theoretically robust tools
progress  particular  abo promises yield useful results composite agent
designs  allowing us separate problem designing complex abo agents discrete
structural problem continuous temporal optimization problem tractable
many cases  hence  reason optimistic artificial intelligence
usefully characterized study bounded optimality  may speculate provided
computing device neither small  so small changes speed size cause
significant changes optimal program design  powerful  so classically
optimal decisions computed feasibly   abo designs stable reasonably
wide variations machine speed size environmental complexity  details
optimal designs may rather arcane  learning processes play large part
discovery  expect focus type research questions
convergence optimality various structural classes end result itself 
perhaps important implication  beyond conceptual foundations field
itself  research bounded optimality applies  design  practice artificial
intelligence way idealized  infinite resource models may not  given 
   

fiprovably bounded optimal agents

way illustrating definition  bounded optimal agent  design simple system
consisting sequences decision procedures provably better program
class  theorem exhibits bounded optimal design translates  definition 
agent whose actual behaviour desirable 
appear plenty worthwhile directions continue exploration
bounded optimality  foundational point view  one interesting
questions concept applies agents incorporate learning component 
 note section    learning algorithm external agent  
case  necessarily largely stable bounded optimal configuration
agent program large enough  instead  agent adapt shorter term
horizon rewrite becomes obsolete 
results preservation abo composition  start examine
much interesting architectures simple production system studied above 
example  look optimal search algorithms  algorithm constrained
apply metalevel decision procedure step decide node expand 
 russell   wefald         extend work asymptotic bounded optimality
provide utility based analogue  big o  notation describing performance
agent designs  including suboptimal 
context computational learning theory  obvious stationarity
requirement environment  necessary satisfy preconditions pac
results  restrictive  fact agent learns may effect
distribution future episodes  little known learning cases  aldous  
vazirani         could relax deterministic episodic requirement allow
non immediate rewards  thereby making connections current research reinforcement
learning 
computation scheduling problem examined interesting itself 
appear studied operations research combinatorial optimization literature  scheduling algorithms usually deal physical rather computational tasks 
hence objective function usually involves summation outputs rather picking
best  would resolve formal question tractability general case 
look cases solution qualities individual processes interdependent
 such one use results another   practical extensions include computation
scheduling parallel machines multiple agents  scheduling combinations computational physical  e g   job shop ow shop  processes  objective functions
combination summation maximization  latter extension broadens scope
applications considerably  industrial process  designing manufacturing
car  consists computational steps  design  logistics  factory scheduling  inspection
etc   physical processes  stamping  assembling  painting etc    one easily imagine
many applications real time financial  industrial  military contexts 
may turn bounded optimality found wanting theoretical framework 
case  hope refuted interesting way  better framework
created process 
   

firussell   subramanian

appendix  additional proofs
appendix contains formal proofs three subsidiary lemmata main body
paper 

lemma   exists optimal sequence sorted increasing order q s 
proof  suppose case  optimal sequence  must

two adjacent rules i      qi   qi    see figure     removal rule     yields
sequence s  qs  t  qs  t   lemma   fact ti   ti     ti    
lemma    s  must optimal  repeat removal process s  ordered
qi   proving theorem reductio ad absurdum  
 

lemma   every sequence   s        sm sorted increasing order quality  single
step z qz qsm   v  sz   v  s  
proof  calculate v  sz     v  s  using equation   show non negative 
v  sz     v  s    qz      pd   pmj   tj     tz      qm     pd   pmj   tj     tz   
p
   qz   qm       pd    mj   tj     tz   

non negative since qz qm   
q

i  

qi  
qi
qi  
qi  



ti

i  

figure    proof ordering qi  lower dotted line indicates original profile  upper dotted
line indicates profile removal rule     

lemma   exists optimal sequence whose rules nondecreasing order ti  
proof  suppose case  optimal sequence  must
two adjacent rules i      qi qi   ti   ti    see figure     removal rule
yields sequence s  qs  t  qs  t   lemma    lemma    s  must
 

optimal  repeat removal process s  ordered ti  proving theorem
reductio ad absurdum  
   

fiprovably bounded optimal agents

q

qi  
qi

i  

qi  



i  

ti

figure    proof ordering ti   dotted line indicates profile removal rule i 

acknowledgements

would acknowledge stimulating discussions michael fehling  michael genesereth  russ greiner  eric horvitz  henry kautz  daphne koller  bart selman
subject bounded optimality  dorit hochbaum  nimrod megiddo  kevin glazebrook subject dynamic programming scheduling problems  nick
littlestone michael kearns subject agnostic learning  would
thank reviewers many constructive suggestions  many early ideas
work based arose discussions late eric wefald  thanks
ron parr work uniform distribution case  rhonda righter extending
results exponential distribution  patrick zieske help implementing dynamic programming algorithm  first author supported nsf grants iri         
iri         iri          visiting fellowship serc sabbatical
uk  nec research institute  second author supported nsf
grant iri         

references

agre  p     chapman  d          pengi  implementation theory activity 
proc   th national conference artificial intelligence  seattle  wa  morghan kaufmann 
aldous  d     vazirani  u          markovian extension valiant s learning model 
proc    st annual symposium foundations computer science  st  louis  mo 
ieee comput  soc  press 
binder  j          complexity deliberation scheduling stochastic deadlines  
boser  b  e   sackinger  e   bromley  j     lecun  y          hardware requirements
neural network pattern classifiers   case study implementation  ieee micro 
          
brandt  r          search credible form rule utilitarianism  nakhnikian  g    
castaneda  h   eds    morality language conduct 
   

firussell   subramanian

breese  j  s     fehling  m  r          control problem solving  principles architecture  shachter  r  d   levitt  t   kanal  l     lemmer  j   eds    uncertainty
artificial intelligence    north holland  amsterdam 
brooks  r  a          robust  layered control system mobile robot  ieee journal
robotics automation           
cherniak  c          minimal rationality  mit press  cambridge 
dean  t     boddy  m          analysis time dependent planning  proc  aaai    pp        
dean  t  l     wellman  m  p          planning control  morgan kaufmann  san
mateo  ca 
dennett  d          moral first aid manual  tanner lectures human values  university
michigan 
doyle  j          rational psychology  toward modern mental philosophy  ai
magazine           
doyle  j          artificial intelligence rational self government  tech  rep   technical
report cmu cs        
doyle  j     patil  r          two theses knowledge representation  language restrictions  taxonomic classification  utility representation services  artificial
intelligence              
etzioni  o          tractable decision analytic control  proc   st international conference knowledge representation reasoning  pp          
fehling  m     russell  s  j          proceedings aaai spring symposium limited
rationality  aaai 
genesereth  m  r     nilsson  n  j          logical foundations artificial intelligence 
morgan kaufmann  mateo  ca 
good  i  j          twenty seven principles rationality  godambe  v  p     sprott 
d  a   eds    foundations statistical inference  pp           holt  rinehart  winston   toronto 
hansson  o     mayer  a          heuristic search evidential reasoning  proceedings
fifth workshop uncertainty artificial intelligence  windsor  ontario 
horvitz  e  j          reasoning beliefs actions computational resource
constraints  levitt  t   lemmer  j     kanal  l   eds    uncertainty artificial
intelligence    north holland  amsterdam 
kearns  m   schapire  r     sellie  l          toward ecient agnostic learning  proc   th
ann  workshop computational learning theory  pittsburgh  pa  morgan kaufmann 
   

fiprovably bounded optimal agents

keeney  r     raiffa  h          decisions multiple objectives  preferences value
tradeoffs  wiley  new york 
levesque  h     brachman  r          expressiveness tractability knowledge representation reasoning  computational intelligence           
luby  m   sinclair  a     zuckerman  d          optimal speedup las vegas algorithms 
information processing letters             
mccarthy  j          programs common sense  proceedings symposium
mechanization thought processes  teddington  england  hmso 
newell  a          knowledge level  ai magazine          
neyman  a          bounded complexity justifies cooperation finitely repeated prisoners  dilemma  economics letters              
papadimitriou  c     yannakakis  m          complexity bounded rationality 
proc  acm symposium theory computation 
ramsey  f  p          truth probability  braithwaite  r   ed    foundations
mathematics logical essays  harcourt brace jovanovich  new york 
russell  s  j     wefald  e  h       a   optimal game tree search using rational metareasoning  proc  ijcai    
russell  s  j     wefald  e  h       b   principles metareasoning  proc  kr    
russell  s  j     wefald  e  h          right thing  studies limited rationality 
mit press  cambridge  ma 
russell  s  j     zilberstein  s          composing real time systems  proc  ijcai    
sydney 
sackinger  e   boser  b  e   bromley  j     lecun  y          application anna
neural network chip high speed character recognition  ieee transactions neural
networks             
simon  h  a          decide do  models bounded rationality 
volume   
simon  h  a          models bounded rationality  volume    mit press  cambridge 
von neumann  j     morgenstern  o          theory games economic behavior 
princeton university press  princeton 
zilberstein  s          operational rationality compilation anytime algorithms 
ph d  thesis  computer science division  university california  berkeley 
zilberstein  s     russell  s          optimal composition real time systems  submitted
artificial intelligence 
   


