journal of artificial intelligence research                 

submitted       published     

pac learning recursive logic programs 
ecient algorithms
william w  cohen

at t bell laboratories
    mountain avenue  murray hill  nj       usa

wcohen research att com

abstract

we present algorithms that learn certain classes of function free recursive logic programs in polynomial time from equivalence queries  in particular  we show that a single
k ary recursive constant depth determinate clause is learnable  two clause programs consisting of one learnable recursive clause and one constant depth determinate non recursive
clause are also learnable  if an additional  basecase  oracle is assumed  these results immediately imply the pac learnability of these classes  although these classes of learnable
recursive programs are very constrained  it is shown in a companion paper that they are
maximally general  in that generalizing either class in any natural way leads to a computationally dicult learning problem  thus  taken together with its companion paper  this
paper establishes a boundary of ecient learnability for recursive logic programs 

   introduction
one active area of research in machine learning is learning concepts expressed in firstorder logic  since most researchers have used some variant of prolog to represent learned
concepts  this subarea is sometimes called inductive logic programming  ilp   muggleton 
      muggleton   de raedt        
within ilp  researchers have considered two broad classes of learning problems  the
first class of problems  which we will call here logic based relational learning problems 
are first order variants of the sorts of classification problems typically considered within
ai machine learning community  prototypical examples include muggleton et al  s       
formulation of ff helix prediction  king et al  s        formulation of predicting drug activity  and zelle and mooney s        use of ilp techniques to learn control heuristics for
deterministic parsers  logic based relational learning often involves noisy examples that reect a relatively complex underlying relationship  it is a natural extension of propositional
machine learning  and has already enjoyed a number of experimental successes 
in the second class of problems studied by ilp researchers  the target concept is a prolog
program that implements some common list processing or arithmetic function  prototypical
problems from this class might be learning to append two lists  or to multiply two numbers 
these learning problems are similar in character to those studied in the area of automatic
programming from examples  summers        biermann         and hence might be appropriately called automatic logic programming problems  automatic logic programming
problems are characterized by noise free training data and recursive target concepts  thus a
problem that is central to the enterprise of automatic logic programming but not  perhaps 
logic based relational learning is the problem of learning recursive logic programs 
c      ai access foundation and morgan kaufmann publishers  all rights reserved 

ficohen

the goal of this paper is to formally analyze the learnability of recursive logic programs
in valiant s        model of pac learnability  thus hopefully shedding some light on the
task of automatic logic programming  to summarize our results  we will show that some
simple recursive programs are pac learnable from examples alone  or from examples plus a
small number of additional  hints   the largest learnable class we identify in a standard
learning model is the class of one clause constant depth determinate programs with at most
a constant number of  closed  recursive literals  the largest learnable class we identify
that requires extra  hints  is the class of constant depth determinate programs consisting
of a single nonrecursive base clause and a single recursive clause from the class described
above  all of our results are proved in the model of identification from equivalence queries
 angluin               which is somewhat stronger than pac learnability  identification from
equivalence queries requires that the target concept be exactly identified  in polynomial
time  and using only a polynomial number of equivalence queries   an equivalence query
asks if a hypothesis program h is equivalent to the target program c   the answer to a
query is either  yes  or an adversarily chosen example on which h and c differ  this
model of learnability is arguably more appropriate for automatic logic programming tasks
than the weaker model of pac learnability  as it is unclear how often an approximately
correct recursive program will be useful 
interestingly  the learning algorithms analyzed are different from most existing ilp
learning methods  they all employ an unusual method of generalizing examples called forced
simulation   forced simulation is a simple and analytically tractable alternative to other
methods for generalizing recursive programs against examples  such as n th root finding
 muggleton         sub unification  aha  lapointe  ling    matwin        and recursive
anti unification  idestam almquist         but it has been only rarely used in experimental
ilp systems  ling        
the paper is organized as follows  after presenting some preliminary definitions  we
begin by presenting  primarily for pedagogical reasons  a procedure for identifying from
equivalence queries a single non recursive constant depth determinate clause  then  in
section    we extend this learning algorithm  and the corresponding proof of correctness 
to a simple class of recursive clauses  the class of  closed  linear recursive constant depth
determinate clauses  in section    we relax some assumptions made to make the analysis
easier  and present several extensions to this algorithm  we extend the algorithm from linear
recursion to k ary recursion  and also show how a k ary recursive clause and a non recursive
clause can be learned simultaneously given an additional  basecase  oracle  we then discuss
related work and conclude 
although the learnable class of programs is large enough to include some well known
automatic logic programming benchmarks  it is extremely restricted  in a companion paper
 cohen         we provide a number of negative results  showing that relaxing any of these
restrictions leads to dicult learning problems  in particular  learning problems that are
either as hard as learning dnf  an open problem in computational learning theory   or as
hard as cracking certain presumably secure cryptographic schemes  thus  taken together
with the results of the companion paper  our results delineate a boundary of learnability
for recursive logic programs 
although the two papers are independent  we suggest that readers wishing to read both
this paper and the companion paper read this paper first 
   

fipac learning recursive logic programs  efficient algorithms

   background

in this section we will present the technical background necessary to state our results  we
will assume  however  that the reader is familiar with the basic elements of logic programming  readers without this background are referred to one of the standard texts  for example
 lloyd        

    logic programs

our treatment of logic programs is standard  except that we will usually consider the body
of a clause to be an ordered set of literals 
for most of this paper  we will consider logic programs without function symbols 
i e   programs written in datalog   the purpose of such a logic program is to answer
certain questions relative to a database   db   which is a set of ground atomic facts   when
convenient  we will also think of db as a conjunction of ground unit clauses   the simplest
use of a datalog program is to check the status of a simple instance   a simple instance
 for a program p and a database db   is a fact f   the pair  p  db   is said to cover f iff
db   p   f   the set of simple instances covered by  p  db   is precisely the minimal model
of the logic program p   db  
in this paper  we will primarily consider extended instances which consist of two parts 
an instance fact f   which is simply a ground fact  and a description d  which is a finite set
of ground unit clauses  an extended instance e    f  d  is covered by  p  db   iff
db   d   p   f

if extended instances are allowed  then function free programs are expressive enough to
encode surprisingly interesting programs  in particular  many programs that are usually
written with function symbols can be re written as function free programs  as the example
below illustrates 

example  consider the usual program for appending two lists 
append    ys ys  
append  xjxs   ys  xjzs   

append xs  ys zs   

one could use this program to classify atomic facts containing function symbols
such as append                     this program can be rewritten as a datalog
program that classifies extended instances as follows 

program p  

append xs ys ys 
null xs  
append xs ys zs 
components xs x xs    
components zs x zs    
   this assumption is made primarily for convenience  in section     we describe how this assumption can
be relaxed 

   

ficohen

append xs  ys zs   

database db  
null nil  

the predicate components a b c  means that a is a list with head b and tail
c  thus an extended instance equivalent to append                    would be

instance fact f  

append list   list  list     

description d 

components list     list   
components list    nil  
components list      list    
components list     list   
components list    nil  
we note that using extended instances as examples is closely related to using ground
clauses entailed by the target clause as examples  specifically  the instance e    f  d  is
covered by p  db iff p   db    f d   as the example above shows  there is also a close
relationship between extended instances and literals with function symbols that have been
removed by  attening   rouveirol        de raedt   dzeroski         we have elected
to use datalog programs and the model of extended instances in this paper for several
reasons  datalog is relatively easy to analyze  there is a close connection between datalog
and the restrictions imposed by certain practical learning systems  such foil  quinlan 
      quinlan   cameron jones         focl  pazzani   kibler         and golem
 muggleton   feng        
finally  using extended instances addresses the following technical problem  the learning problems considered in this paper involve restricted classes of logic programs  often  the
restrictions imply that the number of simple instances is polynomial  we note that with only
a polynomial size domain  questions about pac learnability are usually trivial  requiring
learning algorithms to work over the domain of extended instances precludes trivial learning
techniques  however  as the number of extended instances of size n is exponential in n even
for highly restricted programs 

    restrictions on logic programs

in this paper  we will consider the learnability of various restricted classes of logic programs  below we will define some of these restrictions  however  we will first introduce
some terminology 
if a b            br is an  ordered  definite clause  then the input variables of the literal
bi are those variables appearing in bi which also appear in the clause a b            bi    
all other variables appearing in bi are called output variables   also  if a b            br is a
definite clause  then bi is said to be a recursive literal if it has the same predicate symbol
and arity as a  the head of the clause 
   

fipac learning recursive logic programs  efficient algorithms

      types of recursion

the first set of restrictions concern the type of recursion that is allowed in a program 
if every clause in a program has at most one recursive literal  then the program is linear
recursive   if every clause in a program has at most k recursive literals  then the program is
k ary recursive   finally  if every recursive literal in a program contains no output variables 
then we will say that the program is closed recursive 
      determinacy and depth

the second set of restrictions are variants of restrictions originally introduced by muggleton
and feng         if a b            br is an  ordered  definite clause  the literal bi is
determinate iff for every possible substitution  that unifies a with some fact e such that
db   b             bi   

there is at most one maximal substitution  so that db   bi   a clause is determinate
if all of its literals are determinate  informally  determinate clauses are those that can be
evaluated without backtracking by a prolog interpreter 
we also define the depth of a variable appearing in a clause a b            br as follows 
variables appearing in the head of a clause have depth zero  otherwise  let bi be the first
literal containing the variable v   and let d be the maximal depth of the input variables of
bi   then the depth of v is d     the depth of a clause is the maximal depth of any variable
in the clause 
muggleton and feng define a logic program to be ij  determinate if it is is determinate 
of constant depth i  and contains literals of arity j or less  in this paper we use the phrase
 constant depth determinate  instead to denote this class of programs  below are some
examples of constant depth determinate programs  taken from dzeroski  muggleton and
russell        

example  assuming successor is functional  the following program is determinate  the maximum depth of a variable is one  for the variable c in the second
clause  and hence the program is of depth one 
less than a b 
less than a b 

successor a b  
successor a c    less than c b  
 
a
the following program  which computes c   is determinate and of depth
two 
choose a b c 
zero b   
one c  
choose a b c 
decrement b d   
decrement a e   
   

ficohen

multiply b c g   
divide g a f   
choose e d f  
the program golem  muggleton   feng        learns constant depth determinate
programs  and related restrictions have been adopted by several other practical learning
systems  quinlan        lavrac   dzeroski        cohen      c   the learnability of
constant depth determinate clauses has also received some formal study  which we will
review in section   
      mode constraints and declarations

we define the mode of a literal l appearing in a clause c to be a string s such that the initial
character of s is the predicate symbol of l  and for j     the j  th character of s is a     if
the  j      th argument of l is an input variable and a     if the  j      th argument of l
is an output variable   this definition coincides with the usual definition of prolog modes
only when all arguments to the head of a clause are inputs  this simplification is justified 
however  as we are considering only how clauses behave in classifying extended instances 
which are ground   a mode constraint is simply a set of mode strings r   fs           sk g  and
a clause c is said to satisfy a mode constraint r for p if for every literal l in the body of
c   the mode of l is in r 

example  in the following append program  every literal has been annotated
with its mode 

append xs ys ys 
null xs  
append xs ys zs 
components xs x xs    
components zs x zs    
append xs  ys zs   

  mode  null 
  mode  components     
  mode  components     
  mode  append     

the clauses of this program satisfy the following mode constraint 
f components       components       components      
components       components       null  
append      
append      
append      
append     
g
mode constraints are commonly used in analyzing prolog code  for instance  they are
used in many prolog compilers  we will sometimes use an alternative syntax for mode
constraints that parallels the syntax used in most prolog systems  for instance  we may
write the mode constraint  components       as  components            
we define a declaration to be a tuple  p  a   r  where p is a predicate symbol  a  is an
integer  and r is a mode constraint  we will say that a clause c satisfies a declaration if
the head of c has arity a  and predicate symbol p  and if for every literal l in the body of
c the mode of l appears in r 
   

fipac learning recursive logic programs  efficient algorithms

    a model of learnability

in this section  we will present our model of learnability  we will first review the necessary
definitions for a standard learning model  the model of learning from equivalence queries
 angluin               and discuss its relationship to other learning models  we will then
introduce an extension to this model which is necessary for analyzing ilp problems 
      identification from equivalence queries

let x be a set  we will call x the domain   and call the elements of x instances   define a
concept c over x to be a representation of some subset of x   and define a language lang
to be a set of concepts  in this paper  we will be rather casual about the distinction between
a concept and the set it represents  when there is a risk of confusion we will refer to the set
represented by a concept c as the extension of c   two concepts c  and c  with the same
extension are said to be  semantically  equivalent  
associated with x and lang are two size complexity measures   for which we will use
the following notation 

 the size complexity of a concept c   lang is written j c j  
 the size complexity of an instance e   x is written j ej  
 if s is a set  sn stands for the set of all elements of s of size complexity no greater
than n  for instance  xn   fe   x   j ej  ng and langn   fc   lang   j c j  ng 
we will assume that all size measures are polynomially related to the number of bits needed
to represent c or e 
the first learning model that we consider is the model of identification with equivalence
queries   the goal of the learner is to identify some unknown target concept c   lang 
that is  to construct some hypothesis h   lang such that h  c   information about the
target concept is gathered only through equivalence queries   the input to an equivalence
query for c is some hypothesis h   lang  if h  c   then the response to the query is
 yes   otherwise  the response to the query is an arbitrarily chosen counterexample  an
instance e that is in the symmetric difference of c and h  
a deterministic algorithm identify identifies lang from equivalence queries iff for
every c   lang  whenever identify is run  with an oracle answering equivalence queries
for c   it eventually halts and outputs some h   lang such that h  c   identify
polynomially identifies lang from equivalence queries iff there is a polynomial poly  nt  ne  
such that at any point in the execution of identify the total running time is bounded by
poly  nt   ne    where nt   j c j and ne is the size of the largest counterexample seen so far  or
  if no equivalence queries have been made 
      relation to pac learnability

the model of identification from equivalence queries has been well studied  angluin       
       it is known that if a language is learnable in this model  then it is also learnable
in valiant s        model of pac learnability   the basic idea behind this result is that
an equivalence query for the hypothesis h can be emulated by drawing a set of random
   

ficohen

examples of a certain size  if any of them is a counterexample to h   then one returns
the found counterexample as the answer to the equivalence query  if no counterexamples
are found  one can assume with high confidence that h is approximately equivalent to the
target concept   thus identification from equivalence queries is a strictly stronger model
than pac learnability 
most existing positive results on the pac learnability of logic programs rely on showing
that every concept in the target language can be emulated by a boolean concept from
some pac learnable class  dzeroski et al         cohen         while such results can be
illuminating  they are also disappointing  since one of the motivations for considering firstorder representations in the first place is that they allow one to express concepts that cannot
be easily expressed in boolean logic  one advantage of studying the exact identification
model and considering recursive programs is that it essentially precludes use of this sort of
proof technique  while many recursive programs can be approximated by boolean functions
over a fixed set of attributes  few can be be exactly emulated by boolean functions 
      background knowledge in learning

the framework described above is standard  and is one possible formalization of the usual
situation in inductive concept learning  in which a user provides a set of examples  in
this case counterexamples to queries  and the learning system attempts to find a useful
hypothesis  however  in a typical ilp system  the setting is slightly different  as usually
the user provides clues about the target concept in addition to the examples  in most ilp
systems the user provides a database db of  background knowledge  in addition to a set
of examples  in this paper  we will assume that the user also provides a declaration  to
account for these additional inputs it is necessary to extend the framework described above
to a setting where the learner accepts inputs other than training examples 
to formalize this  we introduce the following notion of a  language family   if lang is
a set of clauses  db is a database and dec is a declaration  we will define lang db   dec 
to be the set of all pairs  c  db   such that c   lang and c satisfies dec   semantically 
such a pair will denote the set of all extended instances  f  d  covered by  c  db    next 
if db is a set of databases and dec is a set of declarations  then define
lang db   dec     flang db   dec     db

  db and dec   decg

this set of languages is called a language family  
we will now extend the definition of identification from equivalence queries to language families as follows  a language family lang db  dec   is identifiable from equivalence
queries iff every language in the set is identifiable from equivalence queries  a language
family lang db  dec   is uniformly identifiable from equivalence queries iff there is a single
algorithm identify  db   dec  that identifies any language lang db   dec   in the family
given db and dec  
uniform polynomial identifiability of a language family is defined analogously 
lang db  dec   is uniformly polynomially identifiable from equivalence queries iff there is a
polynomial time algorithm identify  db   dec   that identifies any language lang db   dec 
in the family given db and dec   note that identify must run in time polynomial in the
size of the inputs dec and db as well as the target concept 
   

fipac learning recursive logic programs  efficient algorithms

      restricted types of background knowledge

we will now describe a number of restricted classes of databases and declarations 
one restriction which we will make throughout this paper is to assume that all of the
predicates of interest are of bounded arity  we will use the notation a db for the set of all
databases that contain only facts of arity a or less  and the notation a dec for the set of
all declarations  p  a   r  such that every string s   r is of length a     or less 
for technical reasons  it will often be convenient to assume that a database contains an
equality predicate  that is  a predicate symbol equal such that equal  ti   ti    db for every
constant ti appearing in db   and equal  ti   tj      db for any ti    tj   similarly  we will
often wish to assume that a declaration allows literals of the form equal x y   where x
and y are input variables  if db  respectively dec   is any set of databases  declarations 
we will use db    dec     to denote the corresponding set  with the additional restriction
that the database  declaration  must contain an equality predicate  respectively the mode
equal         
it will sometimes also be convenient to assume that a declaration  p  a   r  allows only
a single valid mode for each predicate  i e   that for each predicate q there is in r only
a single mode constraint of the form qff  such a declaration will be called a unique mode
declaration  if dec is any set of declarations we will use dec   to denote the corresponding
set of declarations with the additional restriction that the declaration is unique mode 
finally  we note that in a typical setting  the facts that appear in a database db and
descriptions d of extended instances are not arbitrary  instead  they are representative of
some  real  predicate  e g   the relationship of a list to its components in the example above  
one way of formalizing this is assume that all facts will be drawn from some restricted set f  
using this assumption one can define the notion of a determinate mode   if f   p t           tk  
is a fact with predicate symbol p and pff is a mode  then define inputs  f  pff  to be the
tuple hti           tik i  where i           ik are the indices of ff containing a      also define
outputs  f  pff  to be the tuple htj           tjl i  where j            jl are the indices of ff containing
a      a mode string pff for a predicate p is determinate for f iff the relation

fhinputs  f  pff   outputs  f  pff i   f   fg
is a function  informally  a mode is determinate if the input positions of the facts in f
functionally determine the output positions 
the set of all declarations containing only modes determinate for f will be denoted
detdec f   however  in this paper  the set f will be assumed to be fixed  and thus we will
generally omit the subscript 
a program consistent with a determinate declaration dec   detdec must be determinate  as defined above  in other words  consistency with a determinate declaration is a
sucient condition for semantic determinacy  it is also a condition that can be verified with
a simple syntactic test 
      size measures for logic programs

assuming that all predicates are arity a or less for some constant a also allows very simple
size measures to be used  in this paper  we will measure the size of a database db by its
cardinality  the size of an extended instance  f  d  by the cardinality of d  the size of a
   

ficohen

declaration  p  a   r  by the cardinality of r  and the size of a clause a b            br by
the number of literals in its body 

   learning a nonrecursive clause

the learning algorithms presented in this paper all use a generalization technique which
we call forced simulation  by way of an introduction to this technique  we will consider a
learning algorithm for non recursive constant depth clauses  while this result is presented
primarily for pedagogical reasons  it may be of interest on its own  it is independent of
previous proofs of the pac learnability of this class  dzeroski et al          and it is also
somewhat more rigorous than previous proofs 
although the details and analysis of the algorithm for non recursive clauses are somewhat involved  the basic idea behind the algorithm is quite simple  first  a highlyspecific  bottom clause  is constructed  using two operations that we call deepen and
constrain   second  this bottom clause is generalized by deleting literals so that it covers the positive examples  the algorithm for generalizing a clause to cover an example is
 roughly  to simulate the clause on the example  and delete any literals that would cause
the clause to fail  in the remainder of this section we will describe and analyze this learning
algorithm in detail 

    constructing a  bottom clause 

let dec    p  a   r  be a declaration and let a b            br be a definite clause  we
define
 
deepen dec  a b            br    a b            br    
li  
li  ld

where ld is a maximal set of literals li that satisfy the following conditions 
 the clause a b            br   li satisfies the mode constraints given in r 
 if li   ld has the same mode and predicate symbol as some other lj   ld   then the
input variables of li are different from the input variables of lj  
 every li has at least one output variable  and the output variables of li are all
different from each other  and are also difference from the output variables of any
other lj   ld  
as an extension of this notation  we define deepen idec  c   to be the result of applying
the function deepen dec repeatedly i times to c   i e  
 
if i    
i
deepen dec  c    c
i 
 
deepen dec  deepen dec  c    otherwise
we define the function constrain dec as
 
constrain dec  a b            br    a b            br    
li  
li  lc

where lc is the set of all literals li such that a b            br   li satisfies the mode
constraints given in r  and li contains no output variables 
   

fipac learning recursive logic programs  efficient algorithms

example  let d  be the declaration  p     r  where r contains the mode
constraints mother         father         male      female      and equal        

then

deepen d  p x y    
p x y  mother x xm  father x xf   mother y ym  father y yf 
deepen  d  p x y     deepen d   deepen d   p x y     
p x y 
mother x xm  father x xf   mother y ym  father y yf  
mother xm xmm  father xm xmf   mother xf xfm  father xf xff  
mother ym ymm  father ym ymf   mother yf yfm  father yf yff 
constrain d  deepen d  p x y     
p x y 
mother x xm  father x xf   mother y ym  father y yf  
male x  female x  male y  female y  
male xm  female xm  male xf  female xf  
male ym  female ym  male yf  female yf  
equal x x  equal x xm  equal x xf  
equal x y  equal x ym  equal x yf  
equal xm x  equal xm xm  equal xm xf  
equal xm y  equal xm ym  equal xm yf  
equal xf x  equal xf xm  equal xf xf  
equal xf y  equal xf ym  equal xf yf  
equal y x  equal y xm  equal y xf  
equal y y  equal y ym  equal y yf  
equal ym x  equal ym xm  equal ym xf  
equal ym y  equal ym ym  equal ym yf  
equal yf x  equal yf xm  equal yf xf  
equal yf y  equal yf ym  equal yf yf 

let us say that clause c  is a subclause of clause c  if the heads of c  and c  are
identical  if every literal in the body of c  also appears in c    and if the literals in the
body of c  appear in the same order as they do in c   the functions deepen and
constrain allow one to easily describe a clause with an interesting property 
theorem   let dec    p  a   r  be a declaration in a detdec    let x          xa be distinct
variables  and define the clause bottom d as follows 
bottom d  dec    constrain dec  deepen ddec  p x          xa     
for any constants d and a  the following are true 
 the size of bottom d dec  is polynomial in j decj  
 every depth d clause that satisfies dec  and hence  is determinate  is  semantically 
equivalent to some subclause of bottom d  dec   
 

 

   

ficohen

begin algorithm force nr  d   dec  db   

  below bottom d is the most specific possible clause
let h bottom d dec 

repeat

ans answer to the query  is h correct  
if ans   yes  then return h
elseif ans is a negative example then
return  no consistent hypothesis 
elseif ans is a positive example e  then
  generalize h minimally to cover e 
let  f  d  be the components of the extended instance e 
h forcesimnr  h   f   dec   db   d   
if h   failure then
return  no consistent hypothesis 

end

endif
endif
endrepeat

figure    a learning algorithm for nonrecursive depth d determinate clauses

proof  see appendix a  a related result also appears in muggleton and feng        
example  below c  and d  are equivalent  as are c  and d   notice that d 
and d  are subclauses of bottom    d   

c    p a b  mother a c  father a d   mother b c  father b d  male a 
d    p x y  mother x xm  father x xf   mother y ym  father y yf  
male x  equal xm ym  equal xf yf 
c    p a b  father a b  female a 
d    p x y  father x xf  female x  equal xf y 
for c  and d   p x y  is true when x is y  s brother  for c  and d   p x y 
is true when x is y  s daughter  and y is x  s father 

    the learning algorithm

theorem   suggests that it may be possible to learn non recursive constant depth determinate clauses by searching the space of subclauses of bottom d in some ecient
manner  figures   and   present an algorithm called force  nr that does this when dec is
a unique mode declaration 
figure   presents the top level learning algorithm  force  nr   force  nr takes as
input a database db and a declaration dec   and begins by hypothesizing the clause
bottom d  dec    after each positive counterexample e    the current hypothesis is generalized as little as possible in order to cover e    this strategy means that the hypothesis is
   

fipac learning recursive logic programs  efficient algorithms

begin subroutine forcesimnr h   f   dec  db   

   forcibly simulate  h on fact f
if f   db then return h
elseif the head of h and f cannot be unified then
return failure

else

let h   h
let  be the mgu of f and the head of h  
for each literal l in the body of h   do
if there is a substitution   such that l    db then
      where    is the most general such substitution
else
delete l from the body of h     together with
all literals l  supported  directly or indirectly  by l

end

endif
endfor
return h  
endif

figure    forced simulation for nonrecursive depth d determinate clauses
always the least general hypothesis that covers the positive examples  hence  if a negative
counterexample e  is ever seen  the algorithm will abort with a message that no consistent
hypothesis exists 
to minimally generalize a hypothesis h   the function forcesimnr is used  this subroutine is shown in figure    in the figure  the following terminology is used  if some
output variable of l is an input variable of l    then we say that l directly supports l   we
will say that l supports l  iff l directly supports l   or if l directly supports some literal
l   that supports l    thus  supports  is the transitive closure of  directly supports   
forcesim nr deletes from h the minimal number of literals necessary to let h cover e    to
do this  forcesim nr simulates the action of a prolog interpreter in evaluating h   except
that whenever a literal l in the body of h would fail  that literal is deleted  along with all
literals l  supported by l 
the idea of learning by repeated generalization is an old one  in particular  previous
methods exist for learning a definite clause by generalizing a highly specific one  for example  clint  de raedt   bruynooghe        generalizes a  starting clause  guided
by queries made to the user  progol  srinivasan  muggleton  king    sternberg       
guides a top down generalization process with a known bottom clause  and rouveirol       
describes a method for generalizing bottom clauses created by saturation  the force  nr algorithm is thus of interest not for its novelty  but because it is provably correct and ecient 
as noted in the theorem below 
   

ficohen

in particular  let d depthnonrec be the language of nonrecursive clauses of depth
d or less  and hence i depthnonrec db  j  detdec   is the language of nonrecursive ij determinate clauses   we have the following result 

theorem   for any constants a and d  the language family
d depthnonrec db    a detdec    
is uniformly identifiable from equivalence queries 

proof  we will show that force  nr uniformly identifies this language family with a polyno 

mial number of queries  we begin with the following important lemma  which characterizes
the behavior of forcesimnr  

lemma   let dec declaration in detdec      let db be a database  let f be a fact  and let

h be a determinate nonrecursive clause that satisfies dec  then one of following conditions

must hold 
 forcesimnr h   f   dec  db   returns failure  and no subclause h   of h satisfies
both dec and the constraint h     db   f   or 
 forcesimnr h   f   dec  db   returns a clause h    and h   is the unique syntactically
largest subclause of h that satisfies both dec and the constraint h     db   f  

proof of lemma  to avoid repetition  we will refer to the syntactically maximal subclauses
h   of h that satisfy both dec and the constraint h     db   f as  admissible subclauses 

in the proof below 
clearly the lemma is true if h or failure is returned by forcesim nr   in the remaining
cases the for loop of the algorithm is executed  and we must establish these two claims
 under the assumptions that a and f unify  and that f    db   
claim    if l is retained  then every admissible subclause contains l 
claim    if l is deleted  then no admissible subclause contains l 
first  however  observe that deleting a literal l may cause the mode of some other
literals to violate the mode declarations of dec   it is easy to see that if l is deleted from
a clause c   then the mode of all literals l  directly supported by l will change  thus if c
satisfies a unique mode declaration prior to the deletion of l  then after the deletion of l
all literals l  that are directly supported by l will have invalid modes 
now  to see that claim   is true  suppose instead that it is false  then there must
be some maximal subclause c   of h that satisfies dec   covers the fact f   and does not
contain l  by the argument above  if c   does not contain l but satisfied dec   then c  
contains no literals l  from h that are supported by l  hence the output variables of l
are disjoint from the variables appearing in c    this means that if l were to be added to
c   the resulting clause would still satisfy dec and cover f   which leads to a contradiction
since c   was assumed to be maximal 
to verify claim    let us introduce the following terminology  if c    a b            br  
is a clause and db is a database  we will say that the substitution  is a  db   f   witness
   

fipac learning recursive logic programs  efficient algorithms

for c iff  is associated with a proof that c   db   f  or more precisely  iff a   f and
 i      i  r  bi   db    we claim that the following condition is an invariant of the for
loop of the forcesim nr algorithm 
invariant    let c be any admissible subclause that contains all the literals in h   preceding l  i e   that contains all those literals of h that were retained on previous
iterations of the algorithm   then every  db   f   witness for c is a superset of   
this can be easily established by induction on the number of iterations of the for loop  the
condition is true when the loop is first entered  since  is initially the most general unifier
of a and f   the condition remains true after an iteration in which l is deleted  since 
is unchanged  finally  the condition remains true after an iteration in which l is retained 
because    is maximally general  it may only assign values to the output variables of l  and
by determinacy only one assignment to the output variables of l can make l true  hence
every  db   f   witness for c must contain the bindings in   
next  with an inductive argument and claim   one can show that every admissible
subclause c must contain all the literals that have been retained in previous iterations of
the loop  leading to the following strengthening of invariant   
invariant     let c be any admissible subclause  then every  db   f   witness for c is a
superset of   
now  notice that only two types of literals are deleted   a  literals l such that no superset
of  can make l true  and  b  literals l  that are supported by a literal l of the preceding
type  in case  a   clearly l cannot be part of any admissible subclause  since no superset
of  makes l succeed  and only such supersets can be witnesses of admissible clauses  in
case  b   again l  cannot be part of any admissible subclause  since its declaration is invalid
unless l is present in the clause  and by the argument above l cannot be in the clause 
this concludes the proof of the lemma 
to prove the theorem  we must now establish the following properties of the identification
algorithm 
correctness  by theorem    if the target program is in d depthnonrec db   dec  
then there is some clause ct that is equivalent to the target  and is a subclause of
bottom d  dec    h is initially bottom  d and hence a superclause of ct   now consider
invoking forcesim nr on any positive counterexample e    by lemma    if this invocation
is successful  h will be replaced by h    the longest subclause of h that covers e    since
ct is a subclause of h that covers e    this means that h   will again be a superclause of
ct   inductively  then  the hypothesis is always a superclause of the target 
further  since the counterexample e  is always an instance that is not covered by the
current hypothesis h   every time the hypothesis is updated  the new hypothesis is a proper
subclause of the old  this means that force  nr will eventually identify the target clause 
eciency  the number of queries made is polynomial in j decj and j db j   since h is
initially of size polynomial in j dec j   and is reduced in size each time a counterexample is
provided  to see that each counterexample is processed in time polynomial in nr   ne   and
nt  notice that since the length of h is polynomial  the number of repetitions of the for
loop of forcesim nr is also polynomial  further  since the arity of literals l is bounded by
   

ficohen

a  only anb   ane constants exist in db   d  and hence there are at most  anb   ane  a
substitutions    to check inside the for loop  which is again polynomial  thus each execution

of forcesim nr requires only polynomial time 
this concludes the proof 

   learning a linear closed recursive clause

recall that if a clause has only one recursive literal  then the clause is linear recursive  
and that if no recursive literal contains output variables  then the clause is closed linear
recursive  in this section  we will describe how the force  algorithm can be extended to
learn a single linear closed recursive clause   before presenting the extension  however  we
would first like to discuss a reasonable sounding approach that  on closer examination  turns
out to be incorrect 

    a remark on recursive clauses

one plausible first step toward extending force  to recursive clauses is to allow recursive
literals in hypotheses  and treat them the same way as other literals that is  to include
recursive literals in the initial clause bottom d   and delete these literals gradually as
positives examples are received  a problem with this approach is that there is no simple
way to check if a recursive literal in a clause succeeds or fails on a particular example  this
makes it impossible to simply run forcesimnr on clauses containing recursive literals 
a straightforward  apparent  solution to this problem is to assume that an oracle exists
which can be queried as to the success or failure of any recursive literal  for closed recursive
clauses  it is sucient to assume that there is an oracle memberct  db   f   that answers
the question
does db   p   f  
where ct is the unknown target concept  f is a ground fact  and db is a database  given
such an oracle  one can determine if a closed recursive literal lr should be retained by
checking if memberct  db   lr    is true  such an oracle is very close to the notion of a
membership query as used in computational learning theory 
this is a natural extension of the force nr learning algorithm to recursive clauses in
fact an algorithm based on similar ideas has been been previously conjectured to pac learn
closed recursive constant depth determinate clauses  dzeroski et al          unfortunately 
this algorithm can fail to return a clause that is consistent with a positive counterexample 
to illustrate this  consider the following example 

example  consider using the extension of force nr described above to learn
following target program 
append xs ys zs 
   the reader may object that useful recursive programs always have at least two clauses a recursive
clause and a nonrecursive base case  in posing the problem of learning a single recursive clause  we are
thus assuming the non recursive  base case  of the target program is provided as background knowledge 
either in the background database db   or in the description atoms d of extended instances 

   

fipac learning recursive logic programs  efficient algorithms

components xs x xs   
components zs z zs   
x  z  
append xs  ys zs   
this program is determinate  has depth    and satisfies the following set of
declarations 
components        
null    
equal      
odd    
append        
we will assume also a database db that defines the predicate null to be true
for empty lists  and odd to be true for the constants   and   
to see how the forced simulation can fail  consider the following positive instance
e    f  d  

f   append  l     l    l     
d   f cons l      l     cons l     l    cons l    nil  
cons l     l    cons l    nil  
append nil l  l   g

this is simply a  attened  form of append                     together with the
appropriate base case append              now consider beginning with the clause
bottom   and generalizing it using forcesimnr to cover this positive instance 
this process is illustrated in figure    the clause on the left in the figure is
bottom d  dec    the clause on the right is the output of forcibly simulating
this clause on f with forcesimnr    for clarity we ve assumed that only the
single correct recursive call remains after forced simulation  
the resulting clause is incorrect  in that it does not cover the given example e 
this can be easily seen by stepping through the actions of a prolog interpreter
with the generalized clause of figure    the nonrecursive literals will all succeed  leading to the subgoal append l  l  l     or in the usual prolog notation 
append                  this subgoal will fail at the literal odd x    because x 
is bound to   for this subgoal  and the fact odd    is not true in db   d 
this example illustrates a pitfall in the policy of treating recursive and non recursive
literals in a uniform manner  for more discussion  see also  bergadano   gunetti        de
raedt  lavrac    dzeroski          unlike nonrecursive literals  the truth of the fact lr 
 corresponding to the recursive literal lr   does not imply that a clause containing lr will
succeed  it may be that while the first subgoal lr  succeeds  deeper subgoals fail 
   

ficohen

bottom    dec   
forcesimnr  bottom   dec   f  dec  db   d   
append xs ys zs 
append xs ys zs 
components xs x  xs   
components xs x  xs   
components ys y  ys   
components ys y  ys   
components zs z  zs   
components zs z  zs   
null xs  
null ys   
null ys  
equal x  z   
  
odd x   
 
odd y   
null ys   
odd z   
null zs   
append xs  ys zs   
equal xs xs  
  
 
equal x  z   
  
 
equal zs  zs   
odd xs  
  
 
odd x   
odd y   
odd z   
  
 
odd zs   
append xs xs xs  
  
 
append zs  zs  zs   

figure    a recursive clause before and after generalization with forcesimnr

    forced simulation for recursive clauses
a solution to this problem is to replace the calls to the membership oracle in the algorithm
sketched above with a call to a routine that forcibly simulates the actions of a top down
theorem prover on a recursive clause  in particular  the following algorithm is suggested 
first  build a nonrecursive  bottom clause   as was done in forcesimnr   second  find some
recursive literal lr such that appending lr to the bottom clause yields a recursive clause
that can be generalized to cover the positive examples 
as in the nonrecursive case  a clause is generalized by deleting literals  using a straightforward generalization of the procedure for forced simulation of nonrecursive clauses  during
forced simulation  any failing nonrecursive subgoals are simply deleted  however  when a
recursive literal lr is encountered  one forcibly simulates the hypothesis clause recursively
   

fipac learning recursive logic programs  efficient algorithms

begin subroutine forcesim  h   f   dec  db   h   

   forcibly simulate  recursive clause h on f
     check for infinite loops
if h     then return failure
     check to see if f is already covered
elseif f   db then return h
     check to see if f cannot be covered
elseif the head of h and f cannot be unified then
return failure

else

let lr be the recursive literal of h
let h   h   flrg

     delete failing non recursive literals as in forcesimnr
let a be the head of h  
let  be the mgu of a and e
for each literal l in the body of h   do
if there is a substitution   such that l    db
then       where   is the most general such substitution

else

delete l from the body of h     together with
all literals l  supported  directly or indirectly  by l

endif
endfor

     generalize h   on the recursive subgoal lr 
if lr  is ground then return forcesim h     flr g  lr  dec  db   h     
else return failure

end

endif
endif

figure    forced simulation for linear closed recursive clauses

   

ficohen

on the corresponding recursive subgoal  an implementation of forced simulation for linear
closed recursive clauses is shown in figure   
the extended algorithm is similar to forcesimnr   but differs in that when the recursive
literal lr is reached in the simulation of h   the corresponding subgoal lr  is created  and
the hypothesized clause is recursively forcibly simulated on this subgoal  this ensures that
the generalized clause will also succeed on the subgoal  for reasons that will become clear
shortly  we would like this algorithm to terminate  even if the original clause h enters an
infinite loop when used in a top down interpreter  in order to ensure termination  an extra
argument h is passed to forcesim   the argument h represents a depth bound for the forced
simulation 
to summarize  the basic idea behind the algorithm of figure   is to simulate the hypothesized clause h on f   and generalize h by deleting literals whenever h would fail on
f or on any subgoal of f  

example 

consider using forcesim to forcibly simulate the following recursive clause
bottom   dec     lr
append xs ys zs 
components xs x  xs   components ys y  ys   components zs z  zs   
null xs         null zs   
odd xs         odd zs   
equal xs xs         equal zs  zs   
append xs  ys zs  
here the recursive literal lr is append xs  ys zs    we will also assume that f
is taken from the extended query e    f  d   which is again the attened version
of the instance append                    used in the previous example  that dec
is the set of declarations of in the previous example  and that the database db
is d   null  nul   
after executing steps     of forcesim  a number of failing literals are deleted 
leading to the substitution   of fxs           ys        zs              x      
xs         y       ys        z       zs          g and the following reduced
clause 
append xs ys zs 
components xs x  xs   components ys y  ys   components zs z  zs   
null ys   odd x   odd y   odd z   equal x  z   
append xs  ys zs  
hence the recursive subgoal is

lr    append  xs    ys   zs      append                   
   note that for readability  we are using the term notation rather than the attened notation of xs   l   
ys   l   etc 

   

fipac learning recursive logic programs  efficient algorithms

recursively applying forcesim to this goal produces the substitution fxs       
ys        zs           x       xs        y       ys        z       zs       g
and also results in deleting the additional literals odd x   and odd z    the
next recursive subgoal is lr    append                 since this clause is included
in the database db   forcesim will terminate  the final clause returned by
forcesim in this case is the following 
append xs ys zs 
components xs x  xs   components ys y  ys   components zs z  zs   
null ys   odd y   equal x  z   
append xs  ys zs  
notice that this clause does cover e 
as in section   we begin our analysis by showing the correctness of the forced simulation
algorithm i e   by showing that forced simulation does indeed produce a unique maximally
specific generalization of the input clause that covers the example 
this proof of correctness uses induction on the depth of a proof  let us introduce again
some additional notation  and write p   db  h f if the prolog program  p  db   can be
used to prove the fact f in a proof of depth h or less   the notion of depth of a proof is the
usual one  we will define looking up f in the database db to be a proof of depth zero   we
have the following result concerning the forcesim algorithm 

theorem   let dec be a declaration in detdec     let db be a database  let f be a fact 

and let h be a determinate closed linear recursive clause that satisfies dec  then one of
the following conditions must hold 

 forcesim h  f  dec  db   h  returns failure  and no recursive subclause h   of h
satisfies both dec and the constraint h     db  h f   or 
 forcesim h  f  dec  db   h  returns a clause h    and h   is the unique syntactically
largest recursive subclause of h that satisfies both dec and the constraint h   db  h f  

proof  again to avoid repetition  we will refer to syntactically maximal recursive  nonrecursive  subclauses h   of h that satisfy both dec and the constraint h     db  h f as

 admissible recursive  nonrecursive  subclauses  respectively 
the proof largely parallels the proof of lemma   in particular  similar arguments
show that the clause returned by forcesim satisfies the conditions of the theorem whenever
failure is returned and whenever h is returned  note that the correctness of forcesim
when h is returned establishes the base case of the theorem for h     
for the case of depth h      let us assume the theorem holds for depth h     and
proceed using mathematical induction  the arguments of lemma   show that the following
condition is true after the for loop terminates 

invariant     h   is the unique maximal nonrecursive admissible subclause of h   and every
 db   f   witness for h   is a superset of   
   

ficohen

begin algorithm force   d   dec  db   

  below bottom d is the most specific possible clause
let lr           lrp be all possible closed recursive literals for bottom d dec 
choose an unmarked recursive literal lri
let h bottom d dec    flri g

repeat

answer to the query  is h correct  

ans

if ans   yes  then return h
elseif ans is a negative example e  then
h

failure

elseif ans is a positive example e  then

  generalize h minimally to cover e 
let  f  d  be the components of e 
h forcesim  h   f   dec   db   d     a j dj   a j dbj  a  
where a  is the arity of the clause head as given in dec
 

endif
if h   failure then
if all recursive literals are marked then
return  no consistent hypothesis 
else

mark lri
choose an unmarked recursive literal lrj
let h bottom d dec    flrj g

end

endif
endif
endrepeat

figure    a learning algorithm for nonrecursive depth d determinate clauses
now  let us assume that there is some admissible recursive subclause h   clearly h  must
contain the recursive literal lr of h   since lr is the only recursive literal of h   further 
the nonrecursive clause h    h    flr g must certainly satisfy dec and also h    db   f  
so it must  by the maximality of h    be a subclause of h    hence h  must be a subclause
of h     flr g  finally  if lr  is ground  i e   if lr is closed in the clause h     lr   then by
invariant     the clause h  must also satisfy h    db   lr  by a proof of depth h     
 this is simply equivalent to saying that the recursive subgoal of lr  generated in the proof
must succeed  
by the inductive hypothesis  then  the recursive call must return the unique maximal
admissible recursive subclause of h     lr   which by the argument above must also be the
unique maximal admissible recursive subclause of h  
thus by induction the theorem holds 
   

fipac learning recursive logic programs  efficient algorithms

    a learning algorithm for linear recursive clauses

given this method for generalizing recursive clauses  one can construct a learning algorithm for recursive clauses as follows  first  guess a recursive literal lr   and make
h   bottom d   lr the initial hypothesis of the learner  then  ask a series of equivalence
queries  after a positive counterexample e    use forced simulation to minimally generalize
h to cover e    after a negative example  choose another recursive literal l r   and reset the
hypothesis to h   bottom d   l r  
figure   presents an algorithm that operates along these lines  let d depthlinrec
denote the language of linear closed recursive clauses of depth d or less  we have the
following result 
theorem   for any constants a and d  the language family
d depthlinrec db   a detdec    
is uniformly identifiable from equivalence queries 
proof  we will show that force  uniformly identifies this language family with a polynomial number of queries 
correctness and query eciency  there are at most aj dj   aj dbj constants in
any set db   d  at most  aj dj   aj db j  a a   tuples of such constants  and hence at most
 aj dj   aj db j  a distinct recursive subgoals lr  that might be produced in proving that a
linear recursive clause c covers an extended instance  f  d   thus every terminating proof
of a fact f using a linear recursive clause c must be of depth  aj dj   aj db j  a or less  i e  
for h    aj dj   aj db j  a  
c   db   d  h f iff c   db   d   f
thus theorem   can be strengthened  for the value of h used in force   the subroutine
forcesim returns the syntactically largest subclause of h that covers the example  f  d 
whenever any such a subclause exists  and returns failure otherwise 
we now argue the correctness of the algorithm as follows  assume that the hypothesized recursive literal is  correct  i e   that the target clause ct is some subclause of
bottom d   lr   in this case it is easy to see that force  will identify ct   using an argument that parallels the one made for force  nr   again by analogy to force  nr   it is easy to
see that only a polynomial number of equivalence queries will be made involving the correct
recursive literal 
next assume that lr is not the correct recursive literal  then ct need not be a subclause
of bottom d   lr   and the response to an equivalence query may be either a positive or
negative counterexample  if a positive counterexample e  is received and forcesim is
called  then the result may be failure  or it may be a proper subclause of h that covers
e    thus the result of choosing an incorrect lr will be a  possibly empty  sequence of
positive counterexamples followed by either a negative counterexample or failure  since
all equivalence queries involving the correct recursive literal will be answered by either
a positive counterexample or  yes    then if a negative counterexample or failure is
obtained  it must be that lr is incorrect 
 

 

 

 

   recall that an answer of  yes  to an equivalence query means the hypothesis is correct 

   

ficohen

the number of variables in bottom d can be bounded by aj bottom d  dec  j   and
as each closed recursive literal is completely defined by an a  tuple of variables  the number
of possible closed recursive literals lr can be bounded by

p    aj bottom d  dec  j  a

 

since j bottom d  dec  j is polynomial in j dec j   p is also polynomial in j dec j   this means
that only a polynomial number of incorrect lr  s need to be discarded  further since each
successive hypothesis using a single incorrect lr is a proper subclause of the previous hypothesis  only a polynomial number of equivalence queries are needed to discard an incorrect
lr   thus only a polynomial number of equivalence queries can be made involving incorrect
recursive literals 
thus force  needs only a polynomial number of queries to identify ct 
eciency  forcesim runs in time polynomial in its arguments h   f   dec  db   d
and h  when forcesim is called from force   h is always polynomial in ne and j db j   and
h is always no larger than j bottom d dec j      which in turn is polynomial in the size
of dec   hence every invocation of forcesim requires time polynomial in ne   dec   and db  
and hence force  processes each query in polynomial time 
this completes the proof 
this result is somewhat surprising  as it shows that recursive clauses can be learned
even given an adversarial choice of training examples  in contrast  most implemented ilp
systems require well choosen examples to learn recursive clauses 
this formal result can also be strengthened in a number of technical ways  one of
the more interesting strengthenings is to consider a variant of force  that maintains a
fixed set of positive and negative examples  and constructs the set of all least general
clauses that are consistent with these examples  this could be done by taking each of the
clauses bottom d   lr            bottom d   lrp   forcibly simulating them on each of the
positive examples in turn  and then discarding those clauses that cover one of more negative
examples  this set of clauses could then be used to tractably encode the version space of
all consistent programs  using the  s  n   representation for version spaces  hirsh        

   extending the learning algorithm

we will now consider a number of ways in which the result of theorem   can be extended 

    the equality predicate and unique mode assumptions
theorem   shows that the language family

d depthlinrec db   a detdec    
is identifiable from equivalence queries  it is natural to ask if this result can be extended
by dropping the assumptions that an equality predicate is present and that the declaration
contains a unique legal mode for each predicate  that is  if the result can be extended to
the language family
d depthlinrec db  a detdec  
   

fipac learning recursive logic programs  efficient algorithms

this extension is in fact straightforward  given a database db and a declaration dec  
 p  a   r  that do not satisfy the equality predicate and unique mode assumptions  one can
modify them as follows 
   for every constant c appearing in db   add the fact equal  c   c   to db  
   for every predicate q that has k valid modes qs            qsk in r 
 a  remove the mode declarations for q   and replace them with k mode strings for
the k new predicates qs            qsk   letting qsi si be the unique legal mode for the
predicate qsi  
 b  remove every fact q  t           ta  of the predicate q from db   and replace it with
the k facts qs   t           ta            qsk  t           ta  
note that if the arity of predicates is bounded by a constant a  then the number of modes
k for any predicate q is bounded by the constant  a   and hence these transformations can
be performed in polynomial time  and with only a polynomial increase in the size of dec
and db  
clearly any target clause ct   d depthlinrec db   dec   is equivalent to some clause
ct    d depthlinrec db    dec    where db   and dec   are the modified versions of db
and dec constructed above  using force  it is possible to identify ct     in learning ct   one
must also perform steps   and  b above on the description part d of every counterexample
 f  d    finally  one can convert ct  to an equivalent clause in d depthlinrec db   dec 
by repeatedly resolving against the clause equal x x    and also replacing every predicate
symbol qsi with q  
this leads to the following strengthening of theorem   

proposition   for any constants a and d  the language family
d depthlinrec db  a detdec  
is uniformly identifiable from equivalence queries 

    the datalog assumption

so far we have assumed that the target program contains no function symbols  and that the
background knowledge provided by the user is a database of ground facts  while convenient
for formal analysis  these assumptions can be relaxed 
examination of the learning algorithm shows that the database db is used in only two
ways 

 in forcibly simulating a hypothesis on an extended instance  f  d   it is necessary to
find a substitution    that makes a literal l true in the database db   d  while this
can be done algorithmically if db and d are sets of ground facts  it is also plausible
to assume that the user has provided an oracle that answers in polynomial time any
mode correct query l to the database db   specifically  the answer of the oracle will
be either
   

ficohen

  the  unique  most general substitution   such that db   d   l  and l  is
ground  or
   no  if no such   exists 

such an oracle would presumably take the form of an ecient theorem prover for db  

 when calling forcesim  the top level learning algorithm uses db and d to determine

a depth bound on the length of a proof made using the hypothesis program  again 
it is reasonable to assume that the user can provide this information directly  in the
form of an oracle  specifically  this oracle would provide for any fact f a polynomial
upper bound on the depth of the proof for f in the target program 

finally we note that if ecient  but non ground  background knowledge is allowed  then
function symbols always can be removed via attening  rouveirol         this transformation also preserves determinacy  although it may increase depth in general  the depth of
a attened clause depends also on term depth in the original clause  thus  the assumption
that the target program is in datalog can be replaced by assumptions that the term depth
is bounded by a constant  and that two oracles are available  an oracle that answers queries
to the background knowledge  and a depth bound oracle  both types of oracles have been
frequently assumed in the literature  shapiro        page   frisch        dzeroski et al  
      

    learning k ary recursive clauses

it is also natural to ask if theorem   can be extended to clauses that are not linear recursive 
one interesting case is the case of closed k ary recursive clauses for constant k  it is
straightforward to extend force  to guess a tuple of k recursive literals lr            lrk   and
then to extend forcesim to recursively generalize the hypothesis clause on each of the facts
lr             lrk    the arguments of theorems   and   can be modified to show that this
extension will identify the target clause after a polynomial number of equivalence queries 
unfortunately  however  it is no longer the case that forcesim runs in polynomial time 
this is easily seen if one considers a tree of all the recursive calls made by forcesim  in
general  this tree will have branching factor k and polynomial depth  and hence exponential
size  this result is unsurprising  as the implementation of forcesim described forcibly
simulates a depth bounded top down interpreter  and a k ary recursive program can take
exponential time to interpret with such an interpreter 
there are at least two possible solutions to this problem  one possible solution is to
retain the simple top down forced simulation procedure  and require the user to provide
a depth bound tighter than  aj dj   aj db j  a   the maximal possible depth of a tree  for
example  in learning a   ary recursive sort such as quicksort  the user might specify a logarithmic depth bound  thus guaranteeing that forcesim is polynomial time  this requires
additional input from the user  but would be easy to implement  it also has the advantage
 not shared by the approach described below  that the hypothesized program can be executed using a simple depth bounded prolog interpreter  and will always have shallow proof
trees  this seems to be a plausible bias to impose when learning k ary recursive prolog
programs  as many of these tend to have shallow proof trees 
 

   

fipac learning recursive logic programs  efficient algorithms

a second solution to the possible high cost of forced simulation for k ary recursive
programs is to forcibly simulate a  smarter  type of interpreter one which can execute
k ary recursive program in polynomial time   one sound and complete theorem prover for
closed k ary recursive programs can be implemented as follows 
construct a top down proof tree in the usual fashion  i e   using a depth first left to right
strategy  but maintain a list of the ancestors of the current subgoal  and also a list visited
that records  for each previously visited node in the tree  the subgoal associated with that
node  now  suppose that in the course of constructing the proof tree one generates a subgoal
f that is on the visited list  since the traversal of the tree is depth first left to right  the
node associated with f is either an ancestor of the current node  or is a descendant of some
left sibling of an ancestor of the current node  in the former case  the proof tree contains
a loop  and cannot produce a successful proof  in this case the theorem prover should exit
with failure  in the latter case  a proof must already exist for f     and hence nodes below the
current node in the tree need not be visited  instead the theorem prover can simply assume
that f is true 
this top down interpreter can be easily extended into a forced simulation procedure 
one simply traverses the tree in the same order  generalizing the current hypothesis h as
needed to justify each inference step in the tree  the only additional point to note is that
if one is performing forced simulation and revisits a previously proved subgoal f at a node
n  the current clause h need not be further generalized in order to prove f   and hence it is
again permissible to simply skip the portion of the tree below n  we thus have the following
result 

theorem   let d depth k rec be the set of k ary closed recursive clauses of depth d 
for any constants a  d  and k the language family
d depth k rec db  a detdec 
is uniformly identifiable from equivalence queries 

proof  omitted  but following the informal argument made above 
note that we give this result without the restrictions that the database contains an
equality relation and that the declaration is unique mode  since the tricks used to relax
these restrictions in proposition   are still applicable 

    learning recursive and base cases simultaneously

so far  we have analyzed the problem of learning single clauses  first a single nonrecursive
clause  and then a single recursive clause  however  every useful recursive program contains
at least two clauses  a recursive clause  and a nonrecursive base case  it is natural to ask
if it is possible to learn a complete recursive program by simultaneously learning both a
recursive clause  and its associated nonrecursive base case 
in general  this is not possible  as is demonstrated elsewhere  cohen         however 
there are several cases in which the positive result can be extended to two clause programs 
   note that it is plausible to believe that such a theorem prover exists  as there are only a polynomial
number of possible theorem proving goals namely  the  aj dj   aj db j  a possible recursive subgoals 
 

   

ficohen

begin algorithm force   d   dec  db   
let lr           lrp be all possible recursive literals for bottom d dec 
choose an unmarked recursive literal lri
let hr bottom d dec    flri g
let hb bottom d dec 
let p    hr  hb 

repeat

ans answer to query  is hr   hb correct  
if ans   yes  then return hr   hb
elseif ans is a negative example e  then
p failure
elseif ans is a positive example e  then
let  f  d  be the components of e 
p forcesim   hr  hb   f   dec   db   d     a j dj   a j dbj  a  
 

endif
if p   failure then
if all recursive literals lrj are marked then
return  no consistent hypothesis 
else

mark lri
choose an unmarked recursive literal lrj
let hr bottom d dec    flrj g
let hb bottom d  dec 
let p    hr   hb  

end

endif
endif
endrepeat

figure    a learning algorithm for two clause recursive programs

   

fipac learning recursive logic programs  efficient algorithms

begin subroutine forcesim   hr  hb   f   dec  db   h   

   forcibly simulate  program hr   hb on f
if h     then return failure
  check to see if f should be covered by hb
elseif basecase  f   then
return current hr and generalized hb
return  hr  forcesimnr hb   f   dec  db   
elseif the head of hr and f cannot be unified then
return failure

else

let lr be the recursive literal of hr
let h   h   flrg
let a be the head of h  
let  be the mgu of a and e
for each literal l in the body of h   do
if there is a substitution   such that l    db
then       where   is the most general such substitution
else
delete l from the body of h     together with
all literals l  supported  directly or indirectly  by l

endif
endfor

  generalize h    hb on the recursive subgoal lr 
if lr  is ground then
  continue the simulation of the program
return forcesim  h     flr g  hb  lr  dec  db   h     
else return failure

end

endif
endif

figure    forced simulation for two clause recursive programs

   

ficohen

in this section  we will first discuss learning a recursive clause and base clause simultaneously  assuming that any determinate base clause is possible  but also assuming that an
additional  hint  is available  in the form of a special  basecase  oracle  we will then
discuss various alternative types of  hints  
let p be a target program with base clause cb and recursive clause cr  a basecase
oracle for p takes as input an extended instance  f  d  and returns  yes  if cb   db   d   f  
and  no  otherwise  in other words  the oracle determines if f is covered by the nonrecursive
base clause alone  as an example  for the append program  the basecase oracle should return
 yes  for an instance append xs ys zs  when xs is the empty list  and  no  otherwise 
given the existence of a basecase oracle  the learning algorithm can be extended as
follows  as before  all possible recursive literals lri of the clause bottom d are generated 
however  in this case  the learner will test two clause hypotheses that are initially of the
form  bottom d   lri   bottom d    to forcibly simulate such a hypothesis on a fact f  
the following procedure is used  after checking the usual termination conditions  the forced
simulator checks to see if basecase f  is true  if so  it calls forcesimnr  with appropriate
arguments  to generalize the current hypothesis for the base case  if basecase f  is
false  then the recursive clause hr is forcibly simulated on f   a subgoal lr  is generated
as in before  and the generalized program is recursively forcibly simulated on the subgoal 
figures   and   present a learning algorithm force  for two clause programs consisting of
one linear recursive clause cr and one nonrecursive clause cb   under the assumption that
both equivalence and basecase oracles are available 
it is straightforward to extend the arguments of theorem   to this case  leading to the
following result 

theorem   let d depth   clause be the set of   clause programs consisting of one

clause in d depthlinrec and one clause in d depthnonrec  for any constants a
and d the language family

d depth   clause db  a detdec  
is uniformly identifiable from equivalence and basecase queries 

proof  omitted 
a companion paper  cohen        shows that something like the basecase oracle is
necessary  in particular  without any  hints  about the base clause  learning a two clause
linear recursive program is as hard as learning boolean dnf  however  there are several
situations in which the basecase oracle can be dispensed with 
case    the basecase oracle can be replaced by a polynomial sized set of possible base
clauses  the learning algorithm in this case is to enumerate pairs of base clauses cbi
and  starting clauses  bottom    lrj   generalize the starting clause with forced
simulation  and mark a pair as incorrect if overgeneralization is detected 
case    the basecase oracle can be replaced by a fixed rule that determines when the base
clause is applicable  for example  consider the rule that says that the base clause is
applicable to any atom p x          xa  such that no xi is a non null list  adopting
   

fipac learning recursive logic programs  efficient algorithms

such a rule leads immediately to a learning procedure that pac learns exactly those
two clause linear recursive programs for which the rule is correct 
case    the basecase oracle can be also be replaced by a polynomial sized set of rules for
determining when a base clause is applicable  the learning algorithm in this case is
pick a unmarked decision rule and run force  using that rule as a basecase oracle  if
force  returns  no consistent hypothesis  then the decision rule is marked incorrect 
and a new one is choosen  this algorithm will learn those two clause linear recursive
programs for which any of the given decision rules is correct 
even though the general problem of determining a basecase decision rule for an arbitrary
datalog program may be dicult  it may be that a small number of decision procedures
apply to a large number of common prolog programs  for example  the recursion for most
list manipulation programs halts when some argument is reduced to a null list or to a
singleton list  thus case   above seems likely to cover a large fraction of the automatic
logic programming programs of practical interest 
we also note that heuristics have been proposed for finding such basecase decision rules
automatically using typing restrictions  stahl  tausend    wirth        

    combining the results

finally  we note that all of the extensions described above are compatible  this means
that if we let kd maxreclang be the language of two clause programs consisting of one
clause cr that is k ary closed recursive and depth d determinate  and one clause cb that
is nonrecursive and depth d determinate  then the following holds 

proposition   for any constants a  k and d the language family
kd maxreclang db  a detdec  
is uniformly identifiable from equivalence and basecase queries 
      further extensions
the notation kd maxreclang may seem at this point to be unjustified  although it is the

most expressive language of recursive clauses that we have proven to be learnable  there are
numerous extensions that may be eciently learnable  for example  one might generalize
the language to allow an arbitrary number of recursive clauses  or to include clauses that are
not determinate  these generalizations might very well be pac learnable given the results
that we have presented so far 
however  a companion paper  cohen        presents a series of negative results showing
that most natural generalizations of kd maxreclang are not eciently learnable  and
further that kd maxreclang itself is not eciently learnable without the basecase oracle  specifically  the companion paper shows that eliminating the basecase oracle leads
to a problem that is as hard as learning boolean dnf  an open problem in computational
learning theory  similarly  learning two linear recursive clauses simultaneously is as hard
as learning dnf  even if the base case is known  finally  the following learning problems
are all as hard as breaking certain  presumably  secure cryptographic codes  learning n
   

ficohen

linear recursive determinate clauses  learning one n ary recursive determinate clause  or
learning one linear recursive  k local  clause  all of these negative results hold not only
for the model of identification from equivalence queries  but also for the weaker models of
pac learnability and pac predictability 

   related work
in discussing related work we will concentrate on previous formal analyses that employ a
learning model similar to that considered here  namely  models that  a  require all computation be polynomial in natural parameters of the problem  and  b  assume either a neutral
source or adversarial source of examples  such as equivalence queries or stochastically presented examples  we note  however  that much previous formal work exists that relies on
different assumptions  for instance  there has been much work in which member or subset
queries are allowed  shapiro        de raedt   bruynooghe         or where examples are
choosen in some non random manner that is helpful to the learner  ling        de raedt
  dzeroski         there has also been some work in which the eciency requirements
imposed by the pac learnability model are relaxed  nienhuys cheng   polman         if
the requirement of eciency is relaxed far enough  very general positive results can be obtained using very simple learning algorithms  for example  in model of learnability in the
limit  gold         any language that is both recursively enumerable and decidable  which
includes all of datalog  can be learned by a simple enumeration procedure  in the model
of u learnability  muggleton   page        any language that is polynomially enumerable
and polynomially decidable can be learned by enumeration 
the most similar previous work is that of frazier and page      a      b   they analyze
the learnability from equivalence queries of recursive programs with function symbols but
without background knowledge  the positive results they provide are for program classes
that satisfy the following property  given a set of positive examples s   that requires all
clauses in the target program to prove the instances in s     only a polynomial number of
recursive clauses are possible  further the base clause must have a certain highly constrained
form  thus the concept class is  almost  bounded in size by a polynomial  the learning
algorithm for such a program class is to interleave a series of equivalence queries that
test every possible target program  in contrast  our positive results are for exponentially
large classes of recursive clauses  frazier and page also present a series of negative results
suggesting that the learnable languages that they analyzed are dicult to generalize without
sacrificing ecient learnability 
previous results also exist on the pac learnability of nonrecursive constant depth determinate programs  and on the pac learnability of recursive constant depth determinate
programs in a model that also allows membership and subset queries  dzeroski et al  
      
the basis for the intelligent search used in our learning algorithms is the technique
of forced simulation   this method finds the least implicant of a clause c that covers
an extended instance e  although when we developed this method we believed it to be
original  subsequently we discovered that this was not the case an identical technique had
been previously proposed by ling         since an extended instance e can be converted
 via saturation  to a ground horn clause  there is also a close connection between forced
   

fipac learning recursive logic programs  efficient algorithms

simulation and recent work on  inverting implication  and  recursive anti unification   for
instance  muggleton        describes a nondeterministic procedure for finding all clauses
that imply a clause c   and idestam almquist        describes a means of constraining such
an implicant generating procedure to produce the least common implicant of two clauses 
however  while both of these techniques have obvious applications in learning  both are
extremely expensive in the worst case 
the crustacean system  aha et al         uses inverting implication in constrained
settings to learn certain restricted classes of recursive programs  the class of programs
eciently learned by this system is not formally well understood  but it appears to be
similar to the classes analyzed by frazier and page  experimental results show that these
systems perform well on inferring recursive programs that use function symbols in certain
restricted ways  this system cannot  however  make use of background knowledge 
finally  we wish to direct the reader to several pieces of our own research that are relevant  as noted above  a companion paper exists which presents negative learnability results
for several natural generalizations of the language kd maxreclang  cohen         another related paper investigates the learnability of non recursive prolog programs  cohen 
    b   this paper also contains a number of negative results which strongly motivate the
restriction of constant depth determinacy  a final prior paper which may be of interest
presents some experimental results with a prolog implementation of a variant of the force 
algorithm  cohen      a   this paper shows that forced simulation can be the basis of a
learning program that outperforms state of the art heuristic methods such as foil  quinlan        quinlan   cameron jones        in learning from randomly chosen examples 

   conclusions
just as it is often desirable to have guarantees of correctness for a program  in many
plausible contexts it would be highly desirable to have an automatic programming system
offer some formal guarantees of correctness  the topic of this paper is the learnability of
recursive logic programs using formally well justified algorithms  more specifically  we have
been concerned with the development of algorithms that are provably sound and ecient in
learning recursive logic programs from equivalence queries  we showed that one constantdepth determinate closed k ary recursive clause is identifiable from equivalent queries  this
implies immediately that this language is also learnable in valiant s        model of paclearnability  we also showed that a program consisting of one such recursive clause and
one constant depth determinate nonrecursive clause is identifiable from equivalence queries
given an additional  basecase oracle   which determines if a positive example is covered by
the non recursive base clause of the target program alone 
in obtaining these results  we have introduced several new formal techniques for analyzing the learnability of recursive programs  we have also shown the soundness and
eciency of several instances of generalization by forced simulation   this method may have
applications in practical learning systems  the force  algorithm compares quite well experimentally with modern ilp systems on learning problems from the restricted class that
it can identify  cohen      a   thus sound learning methods like force  might be useful as
a filter before a more general ilp system like foil  quinlan        quinlan   cameronjones         alternatively  forced simulation could be used in heuristic programs  for
   

ficohen

example  although forced simulation for programs with many recursive clauses is nondeterministic and hence potentially inecient  one could introduce heuristics that would make
the forced simulation ecient  at the cost of completeness 
a companion paper  cohen        shows that the positive results of this paper are not
likely to be improved  either eliminating the basecase oracle for the language above or
learning two recursive clauses simultaneously is as hard as learning dnf  and learning n
linear recursive determinate clauses  one n ary recursive determinate clause  or one linear
recursive  k local  clause is as hard as breaking certain cryptographic codes  with the positive results of this paper  these negative results establish the boundaries of learnability for
recursive programs function free in the pac learnability model  these results thus not only
give a prescription for building a formally justified system for learning recursive programs 
taken together  they also provide upper bounds on what one can hope to achieve with an
ecient  formally justified system that learns recursive programs from random examples
alone 

appendix a  additional proofs

theorem   states  let dec    p  a   r  be a declaration in   a detdec     let nr   j rj   let
x          xa be distinct variables  and define the clause bottom d as follows 
 

bottom d  dec    constrain dec  deepen ddec  p x          xa     
 

for any constants d and a  the following are true 

 the size of bottom d dec  is polynomial in nr  
 every depth d clause that satisfies dec is equivalent to some subclause of
bottom d  dec   

proof  let us first establish the polynomial bound on the size of bottom d  let c be a
clause of size n  as the number of variables in c is bounded by an  the size of the set ld

is bounded by

thus for any clause c
by a similar argument

nr 
  z 

  an z a   

   modes     tuples of input variables 

j deepen dec  c  j  n    an a  nr

   

j constrain dec  c  j  n    an anr

   

since both of the functions deepen dec and constrain dec give outputs that are polynomially larger in size than their inputs  if follows that composing these functions a constant
number of times  as was done in computing bottom d for constant d  will also produce
only a polynomial increase in the size 
next  we wish to show that every depth d determinate clause c that satisfies dec is
equivalent to some subclause of bottom d   let c be some depth d determinate clause 
   

fipac learning recursive logic programs  efficient algorithms

and without loss of generality let us assume that no pair of literals li and lj in the body
of c have the same mode  predicate symbol  and sequence of input variables  
given c   let us now define the substitution c as follows 
   initially set
c fx    x          xa   xa g
where x          xa are the arguments to the head of bottom d and x           xa are
the arguments to the head of c  
notice that because the variables in the head of bottom d are distinct  this mapping
is well defined 
   next  examine each of the literals in the body of c in left to right order  for each
literal l  let variables t        tk be its input variables  for each literal l in the
body bottom d with the same mode and predicate symbol whose input variables
t          tk are such that  i      i  r  tjc   tj   modify c as follows 
 

 

 

 

c   fu    u           ul   ul g
where u           ul are the output variables of l and u          ul are the output variables
of l  
notice that because we assume that c contains only one literal l with a given predc

icate symbol and sequence of input variables  and because the output variables of
literals l in bottom d are distinct  this mapping is again well defined  it is also
easy to verify  by induction on the length of c   that in executing this procedure some
variable in bottom d is always mapped to each input variable ti   and that at least
one l meeting the requirements above exists  thus the mapping c is onto the
variables appearing in c   
let a be the head of bottom d   and consider the clause c   which is defined as follows 
 the head of c   is a 
 the body of c   contains all literals l from the body of bottom d such that either
  lc is in the body of c
  l is the literal equal  xi  xj  and xic   xjc  
we claim that c   is a subclause of bottom d that is equivalent to c   certainly c  
is a subclause of bottom d   one way to see that it is equivalent to c is to consider
the clause c  and the substitution  c which are generated as follows  initially  let c    c  
and let  c   c   then  for every literal l   equal  xi  xj  in the body of c    delete l
  ij and replace  c with   c  ij   where ij is the
from c    and finally replace c  with c
substitution fxi   xij   xj   xij g and xij is some new variable not previously appearing
   this assumption can be made without loss of generality since for a determinate clause c   the output
variables of li and lj will necessarily be bound to the same values  and hence li or lj could be unified
together and one of them deleted without changing the semantics of c  
   recall that a function f   x y is onto its range y if  y   y  x   x   f  x    y 

   

ficohen

in c     note  by   c  ij we refer to the substitution formed by replacing every occurrence
of xi or xj appearing in  c with xij    c  is semantically equivalent to c   because the
operation described above is equivalent to simply resolving each possible l in the body of
c   against the clause  equal x x    
the following are now straightforward to verify 
  c is a one to one mapping 
to see that this is true  notice that for every pair of assignments xi   y and xj  
y in c there must be a literal equal  xi  xj  in c    hence following the process
described above the assignments xi   y and xj   y in  c would eventually be
replaced with xij   y and xij   y  

  c is onto the variables in c  
notice that c was onto the variables in c   and for every assignment xi   y in c
there is some assignment in  c with a right hand side of y  and this assignment is
either of the form xi   y or xij   y    thus  c is also onto the variables in c  
 a literal l  is in the body of c  iff l  c is in the body of c  
this follows from the definition of c   and from the fact that for every literal l from
c   that is not of the form equal  xi  xj  there is a corresponding literal in c   
thus c  is an alphabetic variant of c   and hence is equivalent to c   since c  is also equivalent
to c    it must be that c   is equivalent to c   which proves our claim 

acknowledgements
the author wishes to thank three anonymous jair reviewers for a number of useful suggestions on the presentation and technical content 

references
aha  d   lapointe  s   ling  c  x     matwin  s          inverting implication with small
training sets  in machine learning  ecml    catania  italy  springer verlag  lecture
notes in computer science       
angluin  d          queries and concept learning  machine learning        
angluin  d          equivalence queries and approximate fingerprints  in proceedings of
the      workshop on computational learning theory santa cruz  california 
bergadano  f     gunetti  d          an interactive system to learn functional logic programs  in proceedings of the   th international joint conference on artificial intelligence chambery  france 
   

fipac learning recursive logic programs  efficient algorithms

biermann  a          the inference of regular lisp programs from examples  ieee transactions on systems  man and cybernetics        
cohen  w  w       a   a pac learning algorithm for a restricted class of recursive logic
programs  in proceedings of the tenth national conference on artificial intelligence
washington  d c 
cohen  w  w       b   pac learning non recursive prolog clauses  to appear in artificial
intelligence 
cohen  w  w       c   rapid prototyping of ilp systems using explicit bias  in proceedings
of the      ijcai workshop on inductive logic programming chambery  france 
cohen  w  w          pac learning nondeterminate clauses  in proceedings of the eleventh
national conference on artificial intelligence seattle  wa 
cohen  w  w          pac learning recursive logic programs  negative results  journal of
ai research             
de raedt  l     bruynooghe  m          interactive concept learning and constructive
induction by analogy  machine learning        
de raedt  l     dzeroski  s          first order jk clausal theories are pac learnable 
in wrobel  s   ed    proceedings of the fourth international workshop on inductive
logic programming bad honnef bonn  germany 
de raedt  l   lavrac  n     dzeroski  s          multiple predicate learning  in proceedings
of the third international workshop on inductive logic programming bled  slovenia 
dzeroski  s   muggleton  s     russell  s          pac learnability of determinate logic
programs  in proceedings of the      workshop on computational learning theory
pittsburgh  pennsylvania 
frazier  m     page  c  d       a   learnability in inductive logic programming  some
basic results and techniques  in proceedings of the tenth national conference on
artificial intelligence washington  d c 
frazier  m     page  c  d       b   learnability of recursive  non determinate theories 
some basic results and techniques  in proceedings of the third international workshop
on inductive logic programming bled  slovenia 
gold  m          language identification in the limit  information and control     
hirsh  h          polynomial time learning with version spaces  in proceedings of the tenth
national conference on artificial intelligence san jose  california  mit press 
idestam almquist  p          generalization under implication by recursive anti unification 
in proceedings of the ninth international conference on machine learning amherst 
massachusetts  morgan kaufmann 
   

ficohen

king  r  d   muggleton  s   lewis  r  a     sternberg  m  j  e          drug design by
machine learning  the use of inductive logic programming to model the structureactivity relationships of trimethoprim analogues binding to dihydrofolate reductase 
proceedings of the national academy of science     
lavrac  n     dzeroski  s          background knowledge and declarative bias in inductive
concept learning  in jantke  k  p   ed    analogical and inductive inference  international workshop aii     springer verlag  daghstuhl castle  germany  lectures in
artificial intelligence series      
ling  c          inventing necessary theoretical terms in scientific discovery and inductive
logic programming  tech  rep       university of western ontario 
ling  c          logic program synthesis from good examples  in inductive logic programming  academic press 
lloyd  j  w          foundations of logic programming  second edition  springer verlag 
muggleton  s          inverting implication  to appear in artificial intelligence 
muggleton  s     de raedt  l          inductive logic programming  theory and methods 
journal of logic programming                     
muggleton  s     feng  c          ecient induction of logic programs  in inductive logic
programming  academic press 
muggleton  s   king  r  d     sternberg  m  j  e          protein secondary structure
prediction using logic based machine learning  protein engineering                 
muggleton  s     page  c  d          a learnability model for universal representations 
in wrobel  s   ed    proceedings of the fourth international workshop on inductive
logic programming bad honnef bonn  germany 
muggleton  s  h   ed            inductive logic programming  academic press 
nienhuys cheng  s     polman  m          sample pac learnability in model inference 
in machine learning  ecml    catania  italy  springer verlag  lecture notes in
computer science       
page  c  d     frisch  a  m          generalization and learnability  a study of constrained
atoms  in inductive logic programming  academic press 
pazzani  m     kibler  d          the utility of knowledge in inductive learning  machine
learning        
quinlan  j  r     cameron jones  r  m          foil  a midterm report  in brazdil  p  b 
 ed    machine learning  ecml    vienna  austria  springer verlag  lecture notes
in computer science       
quinlan  j  r          learning logical definitions from relations  machine learning        
   

fipac learning recursive logic programs  efficient algorithms

quinlan  j  r          determinate literals in inductive logic programming  in proceedings
of the eighth international workshop on machine learning ithaca  new york  morgan
kaufmann 
rouveirol  c          flattening and saturation  two representation changes for generalization  machine learning         
shapiro  e          algorithmic program debugging  mit press 
srinivasan  a   muggleton  s  h   king  r  d     sternberg  m  j  e          mutagenesis 
ilp experiments in a non determinate biological domain  in wrobel  s   ed    proceedings of the fourth international workshop on inductive logic programming bad
honnef bonn  germany 
stahl  i   tausend  b     wirth  r          two methods for improving inductive logic
programming  in proceedings of the      european conference on machine learning
vienna  austria 
summers  p  d          a methodology for lisp program construction from examples 
journal of the association for computing machinery                  
valiant  l  g          a theory of the learnable  communications of the acm          
zelle  j  m     mooney  r  j          inducing deterministic prolog parsers from treebanks 
a machine learning approach  in proceedings of the twelfth national conference on
artificial intelligence seattle  washington  mit press 

   

fi