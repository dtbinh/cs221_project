journal artificial intelligence research                 

submitted       published     

pac learning recursive logic programs 
negative results
william w  cohen

at t bell laboratories
    mountain avenue  murray hill  nj       usa

wcohen research att com

abstract

companion paper shown class constant depth determinate k ary
recursive clauses eciently learnable  paper present negative results showing
natural generalization class hard learn valiant s model paclearnability  particular  show following program classes cryptographically
hard learn  programs unbounded number constant depth linear recursive
clauses  programs one constant depth determinate clause containing unbounded
number recursive calls  programs one linear recursive clause constant locality 
results immediately imply non learnability general class programs 
show learning constant depth determinate program either two linear
recursive clauses one linear recursive clause one non recursive clause hard
learning boolean dnf  together positive results companion paper 
negative results establish boundary ecient learnability recursive function free
clauses 

   introduction
inductive logic programming  ilp   muggleton        muggleton   de raedt       
active area machine learning research hypotheses learning system
expressed logic programming language  many different learning problems
considered ilp  including great practical interest  muggleton  king 
  sternberg        king  muggleton  lewis    sternberg        zelle   mooney       
cohen      b   class problems frequently considered reconstruct simple
list processing arithmetic functions examples  prototypical problem sort
might learning append two lists  often  sort task attempted using
randomly selected positive negative examples target concept 
based similarity problems studied field automatic programming
examples  summers        biermann          informally  call class
learning tasks automatic logic programming problems  number experimental
systems built  quinlan   cameron jones        aha  lapointe  ling    matwin 
       experimental success automatic logic programming systems limited 
one common property automatic logic programming problems presence recursion   goal paper explore analytic methods computational limitations
learning recursive programs valiant s model pac learnability          in brief 
model requires accurate approximation target concept found polynomial time using polynomial sized set labeled examples  chosen stochastically  
surprise nobody limitations exist  far obvious previous
c      ai access foundation morgan kaufmann publishers  rights reserved 

ficohen

research limits lie  provably fast methods learning recursive
logic programs  even fewer meaningful negative results 
starting point investigation series positive learnability results appearing companion paper  cohen         results show single constant depth
determinate clause constant number  closed  recursive calls pac learnable 
show two clause constant depth determinate program consisting one nonrecursive clause one recursive clause type described pac learnable 
additional  hints  target concept provided 
paper  analyze number generalizations learnable languages 
show relaxing restrictions leads dicult learning problems  particular  learning problems either hard learning dnf  an open problem
computational learning theory   hard cracking certain presumably secure cryptographic schemes  main contribution paper  therefore  delineation
boundaries learnability recursive logic programs 
paper organized follows  section   define classes logic programs
learnability models used paper  section   present cryptographic
hardness results two classes constant depth determinate recursive programs  programs
n linear recursive clauses  programs one n ary recursive clause 
analyze learnability clauses constant locality  another class clauses paclearnable nonrecursive case  show even single linearly recursive local
clause cryptographically hard learn  turn  section    analysis
even restricted classes recursive programs  show two different classes
constant depth determinate programs prediction equivalent boolean dnf  class
programs containing single linear recursive clause single nonrecursive clause 
class programs containing two linearly recursive clauses  finally  summarize
results paper companion  discuss related work  conclude 
although paper read independently companion paper suggest
readers planning read papers begin companion paper  cohen        

   background

completeness  present technical background needed state results 
however  aside sections          introduce polynomial predictability
prediction preserving reducibilities  respectively  background closely follows presented companion paper  cohen         readers encouraged skip section
already familiar material 

    logic programs

assume reader familiarity logic programming  such
obtained reading one standard texts  lloyd          treatment logic
programs differs usually consider body clause ordered
set literals  consider logic programs without function symbols i e  
programs written datalog 
semantics datalog program p defined relative database   db  
set ground atomic facts   when convenient  think db
   

fipac learning recursive logic programs  negative results

conjunction ground unit clauses   particular  interpret p db subset
set extended instances   extended instance pair  f  d 
instance fact f ground fact  description set ground unit clauses 
extended instance  f  d  covered  p  db   iff
db     p   f
extended instances allowed  function free programs encode many computations usually represented function symbols  example  function free
program tests see list append two lists written follows 

program p  

append xs ys ys 
null xs  
append xs ys zs 
components xs x xs    
components zs x zs    
append xs  ys zs   

database db  

null nil  
predicate components a b c  means list head b tail c  thus
extended instance equivalent append                    would instance fact
f   append  list     list    list      description containing atoms 
components list     list    components list    nil  
components list      list     components list     list   
components list    nil 
use extended instances function free programs closely related   attening 
 rouveirol        de raedt   dzeroski         experimental learning systems
impose similar restriction  quinlan        pazzani   kibler         another motivation
using extended instances technical   sometimes quite severe  syntactic
restrictions considered paper  often polynomial number possible
ground facts i e   herbrand base polynomial  hence programs interpreted
usual model theoretic way would possible learn program equivalent
given target simply memorizing appropriate subset herbrand base  however 
programs interpreted sets extended instances  trivial learning algorithms
become impossible  even extremely restricted program classes still exponential number extended instances size n  discussion found
companion paper  cohen        
define terminology logic programs used
paper 
      input output variables

b            br  ordered  definite clause  input variables literal bi
variables appear clause b            bi     variables
appearing bi called output variables  
   

ficohen

      types recursion

literal body clause recursive literal predicate symbol
arity head clause  every clause program one recursive
literal  program linear recursive   every clause program k recursive
literals  program k ary recursive   every recursive literal program contains
output variables  program closed recursive 
      depth

depth variable appearing  ordered  clause b            br defined follows 
variables appearing head clause depth zero  otherwise  let bi first
literal containing variable v   let maximal depth input variables
bi   depth v     depth clause maximal depth variable
clause 
      determinacy

literal bi clause b            br determinate iff every possible substitution
unifies fact e
db   b            bi  

one maximal substitution db   bi   clause determinate
literals determinate  informally  determinate clauses
evaluated without backtracking prolog interpreter 
term ij  determinate  muggleton   feng        sometimes used programs
depth i  determinate  contain literals arity j less  number experimental systems exploit restrictions associated limited depth determinacy  muggleton
  feng        quinlan        lavrac   dzeroski        cohen      c   learnability constant depth determinate clauses received formal study  dzeroski 
muggleton    russell        cohen      a  
      mode constraints declarations

mode declarations commonly used analyzing prolog code describing prolog code 
instance  mode declaration  components            indicates predicate components used first argument input second third arguments
outputs  formally  define mode literal l appearing clause c
string initial character predicate symbol l  j    
j  th character      j      th argument l input variable
     j      th argument l output variable   this definition assumes
arguments head clause inputs  justified since considering
clauses behave classifying extended instances  ground   mode constraint
set mode strings r   fs           sk g  clause c said satisfy mode constraint
r p every literal l body c   mode l r 
define declaration tuple  p  a   r  p predicate symbol  a 
integer  r mode constraint  say clause c satisfies declaration
   

fipac learning recursive logic programs  negative results

head c arity a  predicate symbol p  every literal l body
c mode l appears r 
      determinate modes

typical setting  facts database db extended instances arbitrary 
instead  representative  real  predicate  may obey certain restrictions  let us assume database extended instance facts drawn
 possibly infinite  set f   informally  mode determinate input positions
facts f functionally determine output positions  formally  f   p t           tk  
fact predicate symbol p pff mode  define inputs  f  pff  hti           ti i 
i            ik indices containing      define outputs  f  pff 
htj           tj i  j           jl indices containing      define mode
string pff predicate p determinate f iff
k

l

fhinputs  f  pff   outputs  f  pff i   f   fg
function  clause satisfies declaration dec   detdec must determinate 
set declarations containing modes determinate f denoted
detdec f   since paper set f assumed fixed  generally omit
subscript 
      bounds predicate arity

use notation a db set databases contain facts arity
less  a dec set declarations  p  a   r  every string   r
length     less 
      size measures

learning models presented following section require learner use resources polynomial size inputs  assuming predicates arity
less constant allows simple size measures used  paper 
measure size database db cardinality  size extended instance  f  d 
cardinality d  size declaration  p  a   r  cardinality r 
size clause b            br number literals body 

    model learnability
      preliminaries

let x set  call x domain   call elements x instances   define
concept c x representation subset x   define language lang
set concepts  paper  rather casual distinction
concept set represents  risk confusion refer
set represented concept c extension c   two sets c  c 
extension said equivalent   define example c pair  e  b  b    
e   c b     otherwise  probability distribution function  sample c
   

ficohen

x drawn according pair multisets       drawn domain x according
d    containing positive examples c     containing negative ones 
associated x lang two size complexity measures   use
following notation 

size complexity concept c   lang written j c j  
size complexity instance e   x written j ej  
set  sn stands set elements size complexity greater
n  instance  xn   fe   x   j ej ng langn   fc   lang   j c j ng 
assume size measures polynomially related number bits needed
represent c e  holds  example  size measures logic programs
databases defined above 
      polynomial predictability

define polynomial predictability follows  language lang polynomially
predictable iff algorithm pacpredict polynomial function m          ne   nt 
every nt      every ne      every c   langn   every            every
           every probability distribution function d  pacpredict following
behavior 


   given sample       c xn drawn according containing least
m          ne   nt  examples  pacpredict outputs hypothesis h
e

prob d h   c     d c   h        
probability taken possible samples      if pacpredict
randomized algorithm  coin ips made pacpredict 
   pacpredict runs time polynomial         ne   nt   number examples 

   hypothesis h evaluated polynomial time 
algorithm pacpredict called prediction algorithm lang  function m          ne   nt   called sample complexity pacpredict  sometimes
abbreviate  polynomial predictability   predictability  
first condition definition merely states error rate hypothesis
must  usually  low  measured probability distribution
training examples drawn  second condition  together stipulation
sample size polynomial  ensures total running time learner polynomial 
final condition simply requires hypothesis usable weak sense
used make predictions polynomial time  notice worst case
learning model  definition allows adversarial choice inputs learner 
   

fipac learning recursive logic programs  negative results

      relation models

model polynomial predictability well studied  pitt   warmuth        
weaker version valiant s        criterion pac learnability   language lang
pac learnable iff algorithm paclearn
   paclearn satisfies requirements definition polynomial predictability 

   inputs       paclearn always outputs hypothesis h   lang 
thus language pac learnable predictable 
companion paper  cohen         positive results expressed model
identifiability equivalence queries  strictly stronger pac learnability 
is  anything learnable equivalence queries necessarily pac learnable  
since paper contains negative results  use relatively weak model
predictability  negative results model immediately translate negative results
stronger models  language predictable  cannot pac learnable 
identifiable equivalence queries 
      background knowledge learning

typical ilp system  setting slightly different  user usually provides clues
target concept addition examples  form database db
 background knowledge  set declarations  account additional inputs
necessary extend framework described setting learner accepts
inputs training examples  following formalization used companion
paper  cohen         adopt notion  language family  
lang set clauses  db database dec declaration  define
lang db   dec  set pairs  c  db   c   lang c satisfies dec  
semantically  pair denote set extended instances  f  d  covered
 c  db    next  db set databases dec set declarations  define
lang db   dec     flang db   dec     db

  db dec   decg

set languages called language family  
extend definition predictability queries language families follows 
language family lang db  dec   polynomially predictable iff every language set
predictable  language family lang db  dec   polynomially predictable iff
single algorithm identify db   dec   predicts every lang db   dec  family
given db dec  
usual model polynomial predictability worst case choices target
concept distribution examples  notion polynomial predictability
language family extends model natural way  extended model worstcase possible choices database db   db dec   dec   worst case
   equivalence query question form  is h equivalent target concept   answered
either  yes  counterexample  identification equivalence queries essentially means
target concept exactly identified polynomial time using polynomial queries 

   

ficohen

model may seem unintuitive  since one typically assumes database db provided
helpful user  rather adversary  however  worst case model reasonable
learning allowed take time polynomial size smallest target concept
set lang db   dec    means database given user
target concept cannot encoded succinctly  or all  learning allowed take
time 
notice language family lang db   dec  polynomially predictable  every
language family must polynomially predictable  thus show family
polynomially predictable sucient construct one language family
learning hard  proofs paper form 

    prediction preserving reducibilities

principle technical tool used negative results notion prediction preserving
reducibility   introduced pitt warmuth         prediction preserving reducibilities
method showing one language harder predict another  formally 
let lang  language domain x  lang  language domain x  
say predicting lang  reduces predicting lang   denoted lang  lang   
function   x    x    henceforth called instance mapping   function
fc   lang    lang    henceforth called concept mapping   following hold 
   x   c  x    fc  c     i e   concept membership preserved
mappings 
   size complexity fc  c   polynomial size complexity c  i e   size
concept representations preserved within polynomial factor 
    x  computed polynomial time 
note fc need computable  also  since computed polynomial time 
fi x  must preserve size within polynomial factor 
intuitively  fc  c   returns concept c    lang   emulate  c  i e   make
decisions concept membership on examples  preprocessed 
function   predicting lang  reduces predicting lang  learning
algorithm lang  exists  one possible scheme learning concepts lang 
would following  first  convert examples unknown concept c 
domain x  examples domain x  using instance mapping  
conditions definition hold  since c  consistent original examples 
concept fc  c   consistent image   thus running learning
algorithm lang  produce hypothesis h good approximation
fc  c    course  may possible map h back original language lang  
computing fc    may dicult impossible  however  h still used predict
membership c   given example x original domain x   one simply predict
x   c  true whenever  x    h  
pitt warmuth        give rigorous argument approach leads
prediction algorithm lang    leading following theorem 
   

fipac learning recursive logic programs  negative results

theorem    pitt warmuth  assume lang  lang   lang  polynomially predictable  lang  polynomially predictable 

   cryptographic limitations learning recursive programs

theorem   allows one transfer hardness results one language another 
useful number languages  known prediction hard breaking
cryptographic schemes widely assumed secure  example  known
predicting class languages accepted deterministic finite state automata
 cryptographically hard   class languages accepted log space bounded turing
machines 
section make use theorem   previous cryptographic hardness
results show certain restricted classes recursive logic programs hard learn 

    programs n linear recursive clauses

companion paper  cohen        showed single linear closed recursive clause
identifiable equivalence queries  section show program
polynomial number clauses identifiable equivalence queries  even
polynomially predictable 
specifically  let us extend notion  family languages  slightly  let
dlog n  s  represent language log space bounded deterministic turing machines
states accepting inputs size n less  usual semantics complexity
measure   let d depthlinrecprog denote family logic programs containing
depth d linear closed recursive clauses  containing number clauses 
following result 
theorem   every n s  exists database db n s     db declaration
dec n s     detdec sizes polynomial n
dlog n  s    depthlinrecprog db n s   dec n s  
hence      d depthlinrecprog db  a detdec   uniformly polynomially predictable cryptographic assumptions  
proof  recall log space bounded turing machine  tm  input tape length
n  work tape length log  n initially contains zeros  finite state control
state set q  simplify proof  assume without loss generality tape
input alphabets binary  single accepting state qf   q 
machine always erase work tape position work tape head far left
decides accept input 
time step  machine read tape squares input tape head
work tape head  based values current state q  
   i e   machine represents set inputs accepts  complexity number states 
   specifically  language uniformly polynomially predictable unless following cryptographic problems solved polynomial time  solving quadratic residue problem  inverting
rsa encryption function  factoring blum integers  result holds cryptographic problems reduced learning dlog turing machines  kearns   valiant        

   

ficohen






write either     work tape 
shift input tape head left right 
shift work tape head left right 
transition new internal state q  
deterministic machine thus specified transition function

  f    g f    g q    f    g fl  rg fl  rg q
let us define internal configuration tm consist string symbols
written worktape  position tape heads  internal state q
machine  thus configuration element set
con f    glog  n f          log  ng f          ng q

simplified specification machine transition function

    f    g con   con
component f    g represents contents input tape square
input tape head 
notice machine whose worktape size bounded log n  cardinality
con p   jqjn  log  n  polynomial n   jqj  use fact
constructions 
background database db n s follows  first              p  atom
form coni ci   present  constant ci represent different internal configuration
turing machine  arbitrarily select c  represent  unique  accepting
configuration  add db n s atom accepting c    thus
db n s fcon  ci gpi     faccepting  c  g

next  define instance mapping  instance turing machine s domain
binary string x   b       bn   mapped extended instance  f  d 

f accepting  c   
ftruei gb  x  b      ffalsei gb  x  b   








description atoms effect defining predicate truei true iff i th
bit x      defining predicate falsei true iff i th bit x
     constant c  represent start configuration turing machine 
predicate accepting c  defined true iff turing machine accepts input
x starting state c 
let dec n s    accepting      r  r contains modes coni     coni     
            p  truej falsej j             n 
finally  concept mapping fc   let us assume arbitrary one to one mapping
internal configurations turing machine predicate names
   

fipac learning recursive logic programs  negative results

con         conp   start configuration   log  n      q   maps con  accepting configuration   log  n      qf   maps con   construct program fc  m  
follows  transition      c    c     c c  con   construct
clause form

accepting c 

conj  c    truei   conj    c     accepting c   

position input tape head encoded c  con j    c  
con j      c    transition      c     c     construct analogous clause 
truei replaced falsei 
now  claim program p   machine accept started
configuration ci iff
db n s     p   accepting  ci  
hence construction preserves concept membership  perhaps easiest see considering action top down theorem prover given goal
accepting  c    sequence subgoals accepting  ci    accepting  ci             generated
theorem prover precisely parallel sequence configurations ci         entered turing
machine 
easily verified size program polynomial n s 
clauses linear recursive  determinate  depth one  completing proof 
number ways result strengthened  precisely
construction used used reduce class nondeterministic log space
bounded turing machines constant depth determinate linear recursive programs 
further  slight modification construction used reduce class log space
bounded alternating turing machines  chandra  kozen    stockmeyer        constantdepth determinate   ary recursive programs  modification emulate configurations
corresponding universal states turing machine clauses form
accepting c 
conj  c    truei  
conj     c     accepting c    
conj     c     accepting c   
conj    conj    two successors universal configuration conj  
strong result  since log space bounded alternating turing machines known
able perform every polynomial time computation 

    programs one n ary recursive clause

consider learning single recursive clause arbitrary closed recursion 
again  key result section observation expressive power 
background database allows every log space deterministic turing machine
emulated single recursive constant depth determinate clause  leads
following negative predictability result 
   

ficohen

theorem   every n s  exists database db n s     db declaration
dec n s     detdec sizes polynomial n
dlog n  s    depthrec db n s   dec n s  
hence      d depthrec db n   a detdec   uniformly polynomially
predictable cryptographic assumptions 

proof  consider dlog machine   proof theorem    assume without
loss generality tape alphabet f    g  unique starting configura 

tion c   unique accepting configuration c   assume without
loss generality unique  failing  configuration cf ail  exactly
one transition form
  b  cj    c j
every combination   f          ng  b   f    g  cj   con   fc   cf ailg  thus
input x   x       xn machine starts config c    executes transitions
reaches config c  config cf ail  point x accepted rejected
 respectively   use p number configurations   recall p polynomial
n s  
emulate   convert example x   b       bn extended instance
fi x      f  d 

f accepting  c   
fbit  bi gni  
thus predicate bit  x   binds x i th bit tm s input tape 
define following predicates background database db n s  

every possible b   f    g j     j p n   predicate statusb j  b c y 
defined given bindings variables b c   statusb j  b c y  fail
c   cf ail  otherwise succeed  binding active b   b c   cj
binding inactive otherwise 
j     j p n   predicate nextj  y c  succeed iff bound
either active inactive      c bound cj   otherwise  c
bound accepting configuration c  
database contains fact accepting  c    
easy show size database polynomial n s 
declaration dec n s defined  accepting      r  r includes modes
status bj            next j         bit     b   f    g  j             p              n 
now  consider transition rule   b  cj     c j   corresponding conjunction
transibj biti  bibj     statusb j  c bibj  yibj     nextj    yibj  c ibj     accepting c ibj  
   

fipac learning recursive logic programs  negative results

given db n s d  assuming c bound configuration c  conjunction
fail c   cf ail  succeed xi    b c    cj   case yibj bound
inactive  c ibj bound c   recursive call succeeds accepting c  
db n s   finally  xi   b c   cj   transibj succeed atom accepting cj    
provable  case  yibj bound active c ibj bound cj    
clear clause fc  m  
 
accepting c 
transibj


 f      ng  b f   g
j  f      pg

correctly emulate machine examples preprocessed
function described above  hence construction preserves concept membership 
easily verified size program polynomial n s 
clause determinate depth three 

    one k local linear closed recursive clause

far considered one class extensions positive result given
companion paper  cohen        namely  relaxing restrictions imposed recursive
structure target program  another reasonable question ask linear closed
recursive programs learned without restriction constant depth determinacy 
earlier papers  cohen      a      a      b  studied conditions
constant depth determinacy restriction relaxed still allowing learnability nonrecursive clauses  turns generalizations constant depth
determinate clauses predictable  even without recursion  however  language
nonrecursive clauses constant locality pac learnable generalization constant depth
determinate clauses  below  define language  summarize relevant previous
results  address question learnability recursive local clauses 
define variable v appearing clause c free appears body c
head c   let v  v  two free variables appearing clause  v  touches v 
appear literal  v  uences v  either touches v   touches
variable v  uences v   locale free variable v set literals
either contain v   contain free variable uenced v   informally  variable
v  uences variable v  choice binding v  affect possible choices
bindings v  
locality clause size largest locale  let k localnonrec denote
language nonrecursive clauses locality k less   that is  k localnonrec
set logic programs containing single nonrecursive k local clause   following facts
known  cohen      b  
fixed k a  language family k localnonrec a db  a dec  uniformly
pac learnable 
every constant d  every constant a  every database db   a db  every declaration
dec   a detdec   every clause c   d depthnonrec db   dec   
   

ficohen

equivalent clause c   k localnonrec db   dec  size bounded kj c j   k
function  and hence constant constants  
hence
k localnonrec db  a dec 
pac learnable generalization

d depthnonrec db  a detdec  
thus plausible ask recursive programs k local clauses pac learnable 
facts learnability k local programs follow immediately previous results 
example  immediate consequence construction theorem   programs
polynomial number linear recursive k local clauses predictable k   
similarly  theorem   shows single recursive k local clause predictable k   
still reasonable ask  however  positive result bounded depth determinate
recursive clauses  cohen        extended k ary closed recursive k local clauses 
unfortunately  following negative result  shows even linear closed
recursive clauses learnable 

theorem   let dfa s  denote language deterministic finite automata states 

let k locallinrec set linear closed recursive k local clauses  constant exists database db     db declaration dec     dec   size
polynomial s 
dfa s    locallinrec db   dec  

hence k      k locallinrec a db   dec  uniformly polynomially
predictable cryptographic assumptions 

proof  following hopcroft ullman        represent dfa alphabet

tuple  q   q  f    q  initial state  q set states  f set
accepting states    q   q transition function  which sometimes
think subset q q   prove theorem  need construct database
db size polynomial every s state dfa emulated linear
recursive k local clause db  
rather directly emulating   convenient emulate instead modification   let m  dfa state set q  q   fq      qe   qf g  q       qe qf
new states found q  initial state m  q       final state m 
qf   transition function m 
 
    f q      a  q     qe  c  qf  g  
f qi  b  qe g
 

qi f

a  b  c new letters   note m  dfa alphabet
  fa  b  cg  and  described  need complete dfa alphabet   that
is  may pairs  qi   a    qi   a  undefined   however  m  easily
   

fipac learning recursive logic programs  negative results



 


q


 

 

 

m 

 



q



   

 

 

 

 







q
q
q
q
q


  

 

 



 

 

m 




 

 

 

 

b c    








 







b

 

a b c
 

 

c

e


q

 

r

a b c

 

f

a b c    
a b c    


 

a b 
   







q
q
q
q
q









  





 

 

 



 
 

 

 

 





 
 

 
  b  



e

c

 

f

figure    dfa modified emulation local clause

   

ficohen

made complete introducing additional rejecting state qr   making every undefined
transition lead qr   precisely  let   defined
      f qi  x  qr  j qi   q    x     fa  b  cg       qj    qi   x  qj       g
thus      q      q   fqr g  fqf g      completed  version m    q    q   fqr g 
use   construction below  let q    q    fqr g       fa  b  cg 
examples   m    shown figure    notice aside arcs
rejecting state qr   state diagram   nearly identical  
differences   new initial state q     single outgoing arc
labeled old initial state q    every final state   outgoing arc
labeled b new state qe   turn single outgoing arc labeled c final
state qf   easy show

x   l m   iff axbc   l m   
now  given set states q  define database db contains following
predicates 
arcq   q  s x t  true   q     q   x      unless   qi 
x        qj  
state s  true   q  
accept c nil qe qf   true 
motivation arc predicates  observe emulating   clearly useful
able represent transition function    usefulness arc predicates
transition function   represented using conjunction arc literals  particular 
conjunction
 
arc q   q  s  x   


j



 q   q    


j

j

succeeds    s  x       fails otherwise 
let us define instance mapping  x     f  d 

f   accept  a  xbc  q      q  
set facts defines components relation list corresponds
string xbc  words  x          n   set facts
components        n bc            n bc 
components        n bc            n bc 
  
 
components c c nil 
declaration dec n dec n    accept      r  r contains modes
components            state      arc q   q           qi   qj q         
finally  define concept mapping fc  m   machine clause


j

   

fipac learning recursive logic programs  negative results

accept x ys s t 
v
 q   q     arcq   q  s x t 
  components ys x  ys     state u    accept x  ys  t u  
  transition function corresponding machine   defined above 
easy show construction polynomial 
clause x letter    ys list letters  states
q    intent construction predicate accept succeed exactly
 a  string xys accepted     started state    b  first action
taken   string xys go state state  
since initial transitions   q     q  input a 
predicate accept claimed behavior  clearly proposed mapping satisfies requirements theorem    complete proof  therefore  must verify
predicate accept succeeds iff xys accepted   state initial transition
t 
definition dfas string xys accepted   state initial
transition iff one following two conditions holds 
  s  x       ys empty string final state    or 
  s  x       ys nonempty string  and hence head x   tail
ys   ys  accepted   state   initial transition 
base fact accept c nil qe qf   succeeds precisely first case holds  since
  transition one final state  second case  conjunction
arc conditions fc  m   clause succeeds exactly  s  x      as noted above  
second conjunction clause succeeds ys nonempty string
head x   tail ys  x ys  accepted   state initial transition
state u   corresponds exactly second case above 
thus concept membership preserved mapping  completes proof 


j



j

   dnf hardness results recursive programs

summarize previous results determinate clauses  shown single
k ary closed recursive depth d clause pac learnable  cohen         set n linear closed
recursive depth d clauses not  further  even single n ary closed recursive depth d clauses
pac learnable  still large gap positive negative results 
however  particular  learnability recursive programs containing constant number
k ary recursive clauses yet established 
section investigate learnability classes programs 
show programs either two linear closed recursive clauses one linear closed recursive clause one base case hard learn boolean functions disjunctive
normal form  dnf   pac learnability dnf long standing open problem computational learning theory  import results  therefore  establishing
learnability classes require substantial advance computational learning
theory 
   

ficohen

    linear recursive clause plus base clause

previous work established two clause constant depth determinate programs consisting one linear recursive clause one nonrecursive clause identified  given
two types oracles  standard equivalence query oracle   basecase oracle   cohen 
        the basecase oracle determines example covered nonrecursive clause
alone   section show absence basecase oracle  learning
problem hard learning boolean dnf 
discussion below  dnf n  r  denotes language r term boolean functions
disjunctive normal form n variables 

theorem   let d depth   clause set   clause programs consisting one

clause d depthlinrec one clause d depthnonrec  n
r exists database db n r     db declaration dec n r     dec   sizes
polynomial n r 
dnf n  r    depth   clause db n r   dec n r  

hence     language family d depth   clause db  a detdec  
uniformly polynomially predictable dnf polynomially predictable 

proof  produce db n r   db dec n r     detdec predicting
dnf reduced predicting   depth   clause db n r   dec n r    construction
makes use trick first used theorem    cohen      a   dnf formula
emulated conjunction containing single variable existentially quantified
restricted range 
begin instance mapping   assignment   b       bn converted
extended instance  f  d 
f p   
fbit  bi gni  
next  define database db n r contain binary predicates true    false           truer  
falser behave follows 

truei x y  succeeds x        f          rg   fig 
falsei x y  succeeds x        f          rg   fig 
further  db n r contains facts define predicate succ y z  true whenever
z        z numbers   r  clearly size db n r
polynomial r 
let dec n r    p     r  r contains modes bit                  n  true j       
false j         j             r  succ        
let r term dnf formula    ri    sj    lij variables v           vn 
may assume without loss generality contains exactly r terms  since dnf
formula fewer r terms padded exactly r terms adding terms


   

fipac learning recursive logic programs  negative results

background database 

            r
truei  b    b    b       f          rg   
falsei  b    b    b       f          rg   
succ y z 
z         f          rg z   f          rg

dnf formula   v    v    v      v    v      v    v  
equivalent program 
p y  succ y z  p z  
p y  bit   x      bit   x      bit   x      bit   x     
true   x  y    false   x   y    true  x   y   
false   x  y    false   x  y  
true   x  y    false   x   y  
instance mapping  fi          p     fbit      bit       bit      bit    g 
figure    reducing dnf recursive program
form v  v   define concept mapping fc    program cr  cb cr
linear recursive depth   determinate clause

p y   succ y  z     p z  
cb nonrecursive depth   determinate clause

n
 
 r  
p y  
bit k  xk    
bij


i   j   

k   

bij defined follows 

bij

 

truei  xk  y  lij   vk
falsei  xk  y  lij   vk

example construction shown figure    suggest reader refer
figure point  basic idea behind construction first  clause
cb succeed variable bound i th term succeeds  the
definitions truei falsei designed ensure property holds   second 
recursive clause cr constructed program fc    succeeds iff cb succeeds
bound one values           n 
argue rigorously correctness construction  clearly     
fc    size respectively  since db n r polynomial
size  reduction polynomial 
figure   shows possible proofs constructed program fc    
notice program fc    succeeds exactly clause cb succeeds value
   

ficohen

p   

a 
a 
aa  
 
b   





succ      p   


 



a 


aa  
 
b   

succ      p   



 


a 


aa  
 
b   
   

p n   

b  i  v bit  x     v v b




ij



 


a 


aa  
b n   
 

succ n   n  p n 
b n 

figure    space proofs possible program fc   
vs l must true 

 

r
 
now 



true


term

 
j    ij
v
v
s 

case j    bij succeeds bound value j    bi  j every i    
succeeds bound i  hand  false assignment  ti
fails  hence every possible binding generated repeated use recursive
clause cr base clause cb fail  thus concept membership preserved
mapping 
concludes proof 






    two linear recursive clauses

recall single linear closed recursive clause identifiable equivalence
queries  cohen         construction similar used theorem   used
show result cannot extended programs two linear recursive clauses 
theorem   let d depth   clause  set   clause programs consisting two
clauses d depthlinrec   thus assume base case recursion given
background knowledge   constants n r exists database db n r  
  db declaration dec n r     dec   sizes polynomial n 
dnf n  r    depth   clause  db n r   dec n r  
hence constants     language family
d depth   clause   db  a detdec  
   

fipac learning recursive logic programs  negative results

uniformly polynomially predictable dnf polynomially predictable 

proof  before  proof makes use prediction preserving reducibility dnf

d depth   clause  db   dec   specific db dec   let us assume dnf
r terms  assume r    k    again  assumption made without
loss generality  since number terms increased padding vacuous
terms   consider complete binary tree depth k      k th level tree
exactly r nodes  let us label nodes            r  give nodes arbitrary labels 

construct database db n r theorem    except following changes 
predicates truei  b y  falsei b y  succeed label node
level k 
rather predicate succ  database contains two predicates leftson
rightson encode relationship nodes binary tree 
database includes facts p              p   r                 r leaves
binary tree  used base cases recursive program
learned 
let label root binary tree  define instance mapping

 b       b    p    fbit   b           bit n  bn  g 
note except use rather    identical instance mapping
used theorem    let dec n r    p     r  r contains modes bit       
          n  true j        false j         j             r  leftson         rightson        
concept mapping fc    pair clauses r   r   r  clause

n
 
 r  
p y  
bit k  xk    
bij   leftson y  z     p z  


k   

r  clause

p y  

n
 
k   

bit k  xk    

i   j   


 r  


i   j   

bij   rightson  y  z     p z  

note clause linear recursive  determinate  depth    also 
construction clearly polynomial  remains show membership preserved 
figure   shows space proofs
v constructed
v v program fc    
figure    b  i  abbreviates conjunction bit  xi    bij   notice program
succeed recursive calls manage finally recurse one base cases
p              p   r    correspond leaves binary tree  clauses
succeed first k     levels tree  however  reach base cases
recursion leaves tree  recursion must pass k th level tree 
is  one clauses must succeed node binary tree 
k th level tree  hence label number   r 
program thus succeeds     precisely number  
   

ficohen

p  

 
  b
 b
 

h

 h
 
 bb
 
   
  b
   
  bb
 
 
b
 
 
 
b
 
 
 
b
 
b
 
 
b   p l 
b  
p r 
z
z
 
   
z
x   
z

x
 

z

z

  z

  z


  z
 
  z


e
x
x
x
ex


e


e


e

   

   

   

b
b
b




b
b

   

   

b    p ll      l  b    p ll      r 

p     

   



j
j

j


j

j

b
b
b

b

b

b n  p rr      lr  b n  p rr      r 

p     

p        
r

p     
r

figure    proofs possible program fc   

r conjunction b i  succeeds   by argument given theorem   
happen satisfied assignment   thus  mappings preserve

concept membership  completes proof 

notice programs fc    used proof property depth
every proof logarithmic size instances  means hardness
result holds even one additionally restricts class programs logarithmic
depth bound 

    upper bounds diculty learning

previous sections showed several highly restricted classes recursive programs
least hard predict dnf  section show restricted
classes harder predict dnf 
wish restrict depth proof constructed target program  thus  let
h n  function  use langh n  set programs class lang
proofs extended instance  f  d  depth bounded h j dj   
   

fipac learning recursive logic programs  negative results

theorem   let dnf n    language dnf boolean functions  with number

terms   recall d depth   clause language   clause programs consisting one clause d depthlinrec one clause d depthnonrec 
d depth   clause  language   clause programs consisting two clauses
d depthlinrec 
constants a  databases db   db declarations dec   a detdec  
polynomial function poly  n 

d depth   clause db   dec  dnf poly  j db j     
d depth   clause h n   db   dec  dnf poly  j db j      h n  bounded c log n
constant c 
hence either language families uniformly polynomially predictable  dnf n   
polynomially predictable 

proof  proof relies several facts established companion paper  cohen        
every declaration dec  clause bottom d dec  every nonrecursive depth d determinate clause c equivalent subclause bottom  
further  size bottom polynomial dec   means language subclauses bottom normal form nonrecursive constant depth
determinate clauses 

every linear closed recursive clause cr constant depth determinate equivalent subclause bottom plus recursive literal lr   further 
polynomial number possible recursive literals lr  
constants a  a   d  database db   a db  declaration dec  
 p  a   r   database db   a db   program p d depth   clause db   dec   
depth terminating proof constructing using p hmax 
hmax polynomial size db dec  
assumed without loss generality database db decsriptions
contain equality predicate   equality predicate simply predicate
equal x y  true exactly x    
idea proof contruct prediction preserving reduction two
classes recursive programs listed dnf  begin two lemmas 

lemma   let dec   a detdec   let c nonrecursive depth d determinate clause

consistent dec  let subclausec denote language subclauses c   let
monomial u  denote language monomials u variables  polynomial poly   database db   db 
subclausec  db   dec  monomial poly   j db j   

   

ficohen

proof lemma  follows immediately construction used theorem  

dzeroski  muggleton  russell  dzeroski et al           the basic idea construction introduce propositional variable representing  success  connected
chain literals c   subclause c represented conjunction
propositions  
lemma extended follows 

lemma   let dec   a detdec   let   fc          crg set r nonrecursive depth 

determinate clauses consistent dec  length n less  let subclauses denote
set programs form p    d          ds  di subclause
cj    
polynomial poly   database db   db 
subclauses  db   dec  dnf poly    j db j   r    

proof lemma  lemma    ci     set variables vi size
polynomial j db j
every clause subclausec emulated monomial
sr

v
v
 
clearly 
jv j polynomial n r  every clause
  let v  

i  





subclausec emulated monomial v   further  every disjunction

r clauses represented disjunction monomials 
since ci  s satisfy single declaration dec    p  a  r   heads
principle function arity  further  may assume  without loss generality  since
equality predicate assumed  variables appearing heads clauses
distinct  since ci s nonrecursive  every program
p   subclauses

represented disjunction d            dr i  di     subclausec    hence
every p   subclauses represented r term dnf set variables v  




let us introduce additional notation  c clauses  use
c u denote result resolving c together  c denote result
resolving c times  note c u unique c linear recursive c
predicate heads  since one pair complementary
literals  
now  consider target program

p    cr  cb     d depth   clause db   dec 
cr recursive clause cb base  proof extended instance
 f  d  must use clause cr repeatedly h times use clause cb resolve away
final subgoal  hence nonrecursive clause crh u cb could used cover
instance  f  d  
since depth proof class programs bounded number hmax
polynomial j db j ne   nonrecursive program

p     fcrh u cb     h hmax g
   

fipac learning recursive logic programs  negative results

equivalent p extended instances size ne less 
finally  recall assume cb subclause bottom   also 
polynomial sized set lr   lr           lr closed recursive literals
lr   lr   clause cr subclause bottom   lr   means let
polynomial sized set
s    f bottom   lr  h u bottom j   h hmax lr   lr g
p     subclauses    thus lemma    d depth   clause dnf  concludes
proof first statement theorem 
show
d depth   clause h n   db   dec  dnf poly  j db j    
similar argument applies  let us introduce notation  define
meshh n  cr    cr    set clauses form
p









cr   u cr   u       u cr  
j   cr   cr  cr   cr    h  h n   notice functions
h n  c log n number clauses polynomial n 
let p predicate appearing heads cr  cr    let c   respectively
    version c  db   every instance predicate p replaced
db
new predicate p   p recursive program p   fcr    cr  g d depth   clause 
   
database db   p   db equivalent  nonrecursive program p     db
i 

ij



i 

i h

ij

p     fc  j c   meshh n  cr    cr   g
e

recall polynomial number recursive literals lr   hence
polynomial number pairs recursive literals lr   lr   means set clauses
 
s   
fc  j c   meshh n  bottom   lr   bottom   lr  g




 l

ri

e

 

 lrj   lr lr

j



j

polynomial sized  furthermore  program p language d depth   clause 
p     subclauses    second part theorem follows application lemma   
immediate corollary result theorems     strengthened
follows 
corollary    constants      language family
d depth   clause db  a detdec  
uniformly polynomially predictable dnf polynomially predictable 
constants      language family
d depth   clause   db  a detdec  
uniformly polynomially predictable dnf polynomially predictable 
   extended instances size n less 
e

   

ficohen

thus important sense learning problems equivalent learning boolean
dnf  resolve questions learnability languages 
show learnability dicult formal problem  predictability boolean dnf
long standing open problem computational learning theory 

   related work
work described paper differs previous formal work learning logic programs simultaneously allowing background knowledge  function free programs  recursion  focused exclusively computational limitations ecient learnability
associated recursion  considered languages known paclearnable nonrecursive case  since results paper negative 
concentrated model polynomial predictability  negative results model immediately imply negative result stronger model pac learnability  imply
negative results strictly expressive languages 
among closely related prior results negative results previously
obtained certain classes nonrecursive function free logic programs  cohen      b  
results similar character results described here  apply nonrecursive
languages  similar cryptographic results obtained frazier page       
certain classes programs  both recursive nonrecursive  contain function symbols
disallow background knowledge 
prior negative results obtained learnability firstorder languages using proof technique consistency hardness  pitt   valiant        
haussler        showed language  existential conjunction concepts  paclearnable showing hard find concept language consistent
given set examples  similar results obtained two restricted languages
horn clauses  kietz         simple description logic  cohen   hirsh        
language sorted first order terms  page   frisch         results  however 
specific model pac learnability  none easily extended polynomial
predictability model considered here  results extend languages
expressive specific constrained languages  finally  none languages allow
recursion 
knowledge  negative learnability results first order languages  discussion prior positive learnability results first order languages
found companion paper  cohen        

   summary
paper companion  cohen        considered large number different
subsets datalog  aim comprehensive  systematic  particular  wished find precisely boundaries learnability lie various syntactic
restrictions imposed relaxed  since easy reader  miss forest
trees   brie summarize results contained paper  together
positive results companion paper  cohen        
   

fipac learning recursive logic programs  negative results

local
clauses

constant depth determinate
clauses

ncr 

ncr 

ncr jcb 

ncr   cb 

k ncr 

n ncr 

kcr 

kcr 

kcrjcb 

kcr  cbdnf

k k crdnf

n kcr 

 cr 

 cr 

 crjcb 

 cr  cb dnf

   cr dnf

n  cr 

table    summary learnability results
throughout papers  assumed polynomial amount background
knowledge exists  programs learned contain function symbols 
literals body clause small arity  assumed recursion
closed   meaning output variables appear recursive clause  however  believe
restriction relaxed without fundamentally changing results paper 
companion paper  cohen        showed single nonrecursive constantdepth determinate clause learnable strong model identification equivalence
queries   learning model  one given access oracle counterexamples that
is  oracle find  unit time  example current hypothesis
incorrect and must reconstruct target program exactly polynomial number
counterexamples  result implies single nonrecursive constant depth determinate clause pac learnable  as counterexample oracle emulated drawing
random examples pac setting   result novel  dzeroski et al          however
proof given independent  independent interest  notably  somewhat
rigorous earlier proofs  proves result directly  rather via reduction propositional learning problem  proof introduces simple version
forced simulation technique  variants used positive results 
showed learning algorithm nonrecursive clauses extended
case single linear recursive constant depth determinate clause  leading
result restricted class recursive programs identifiable equivalence
queries  bit effort  algorithm extended learn single
k ary recursive constant depth determinate clause 
considered extended learning algorithm learn recursive programs consisting one constant depth determinate clauses  interesting extension
simultaneously learn recursive clause cr base clause cb   using equivalence
queries  basecase oracle  indicates counterexamples covered
base clause cb   model  possible simultaneously learn recursive clause
nonrecursive base case situations recursive clause learned
   

ficohen

language family
d depthnonrec a db  a detdec 
d depthlinrec a db  a detdec 
d depth k rec a db  a detdec 
d depth   clause a db  a detdec 
kd maxreclang a db  a detdec  
d depth   clause a db  a detdec 
d depth   clause  a db  a detdec  
d depthlinrecprog a db  a detdec  
d depthrec a db  a detdec  
k locallinrec a db  a dec  
 

b
 
 
 
 
 
 
 
 
 
 

r
 
 
 
 
 
 
 

l r oracles
  eq
 
eq
k
eq
 
eq base
k
eq base
 
eq
 
eq
n  
eq
  n
eq
   
eq

notation learnable
cb
yes
 cr
yes
kcr
yes
 crjcb yes
kcrjcb
yes
 cr  cb  dnf
   cr  dnf
n  cr
ncr

 cr


table    summary language learnability results  column b indicates number
base  nonrecursive  clauses allowed program  column r indicates number recursive clauses  l r indicates number recursive literals allowed
single recursive clause  eq indicates oracle equivalence queries base
indicates basecase oracle  languages except k locallinrec  clauses
must determinate depth d 
alone  instance  one learn k ary recursive clause together nonrecursive
base case  strongest positive result 
results summarized tables      table    program one rary recursive clause denoted rcr  program one r ary recursive clause one
nonrecursive basecase denoted rcr  cb   rcrjcb  basecase  oracle 
program different r ary recursive clauses denoted rcr   boxed results
associated one theorems paper  companion paper 
unmarked results corollaries results      program class indicates
identifiable equivalence queries  thus positive results described
summarized four     entries lower left hand corner section table
concerned constant depth determinate clauses 
table   presents information slightly different format  relates
notation table   terminology used elsewhere paper 
paper considered learnability various natural generalizations
languages shown learnable companion paper  consider moment single
clauses  companion paper showed fixed k single k ary recursive constantdepth determinate clause learnable  showed restrictions
necessary  particular  program n constant depth linear recursive clauses
polynomially predictable  hence restriction single clause necessary  also  single
clause n recursive calls hard learn  hence restriction k ary recursion
necessary  showed restriction constant depth determinate clauses
necessary  considering learnability constant locality clauses   constant locality
clauses known generalization constant depth determinate clauses
pac learnable nonrecursive case  however  showed recursion allowed 
   

fipac learning recursive logic programs  negative results

language learnable  even single linear recursive clause polynomially
predictable 
again  results summarized table        program class means
polynomially predictable  cryptographic assumptions  hence neither
pac learnable identifiable equivalence queries 
negative results based cryptographic hardness give upper bound expressiveness learnable recursive languages  still leave open learnability programs
constant number k ary recursive clauses absence basecase oracle 
final section paper  showed following problems are  model
polynomial predictability  equivalent predicting boolean dnf 
predicting two clause constant depth determinate recursive programs containing one
linear recursive clause one base case 
predicting two clause recursive constant depth determinate programs containing two
linear recursive clauses  even base case known 
note program classes nearly simplest classes multi clause
recursive programs one imagine  pac learnability dnf longstanding open problem computational learning theory  results suggest  therefore 
pac learning multi clause recursive logic programs dicult  least 
show finding provably correct pac learning algorithm require substantial advances
computational learning theory  table       dnf   respectively dnf  means
corresponding language prediction equivalent dnf  respectively least hard
dnf  
summarize table    sort recursion  programs containing
constant depth determinate clauses learnable  constant depth determinate
recursive programs learnable contain single k ary recursive clause
 in standard equivalence query model  single k ary recursive clause plus base
case  if  basecase oracle  allowed   classes recursive programs either
cryptographically hard  hard boolean dnf 

   conclusions

inductive logic programming active area research  one broad class learning
problems considered area class  automatic logic programming  problems 
prototypical examples genre problems learning append two lists 
multiply two numbers  target concepts automatic logic programming recursive
programs  often  training data learning system simply examples
target concept  together suitable background knowledge 
topic paper pac learnability recursive logic programs random
examples background knowledge  specifically  wished establish computational
limitations inherit performing task  began positive results established
companion paper  results show one constant depth determinate closed k ary
recursive clause pac learnable  further  program consisting one recursive
clause one constant depth determinate nonrecursive clause pac learnable given
additional  basecase oracle  
   

ficohen

paper showed positive results likely improved 
particular  showed either eliminating basecase oracle learning two recursive clauses simultaneously prediction equivalent learning dnf  even case
linear recursion  showed following problems hard breaking  presumably  secure cryptographic codes  pac learning n linear recursive determinate clauses 
pac learning one n ary recursive determinate clause  pac learning one linear recursive
k local clause 
results contribute machine learning several ways  point view
computational learning theory  several results technically interesting  one
prediction equivalence several classes restricted logic programs boolean dnf 
result  together others  cohen      b   reinforces importance learnability problem dnf  paper gives dramatic example adding recursion
widely differing effects learnability  constant depth determinate clauses
remain pac learnable linear recursion added  constant locality clauses become cryptographically hard 
negative results show systems apparently learn larger class recursive
programs must taking advantage either special properties target concepts
learn  distribution examples provided with  believe
likely opportunity obtaining positive formal results area
identify analyze special properties  example  many examples
foil learned recursive logic programs  made use  complete example sets  
datasets containing examples certain size  rather sets randomly
selected examples  quinlan   cameron jones         possible complete datasets
allow expressive class programs learned random datasets  fact 
progress recently made toward formalizing conjecture  de raedt   dzeroski 
      
finally  importantly  paper established boundaries learnability
determinate recursive programs pac learnability model  many plausible automatic programming contexts would highly desirable system offered
formal guarantees correctness  results paper provide upper bounds
one hope achieve ecient  formally justified system learns recursive
programs random examples alone 

acknowledgements
author wishes thank three anonymous jair reviewers number useful suggestions presentation technical content 

references
aha  d   lapointe  s   ling  c  x     matwin  s          inverting implication small
training sets  machine learning  ecml    catania  italy  springer verlag  lecture
notes computer science       
   

fipac learning recursive logic programs  negative results

biermann  a          inference regular lisp programs examples  ieee transactions systems  man cybernetics        
chandra  a  k   kozen  d  c     stockmeyer  l  j          alternation  journal
acm              
cohen  w  w       a   cryptographic limitations learning one clause logic programs 
proceedings tenth national conference artificial intelligence washington 
d c 
cohen  w  w       b   pac learning non recursive prolog clauses  appear artificial
intelligence 
cohen  w  w       c   rapid prototyping ilp systems using explicit bias  proceedings
     ijcai workshop inductive logic programming chambery  france 
cohen  w  w       a   pac learning nondeterminate clauses  proceedings eleventh
national conference artificial intelligence seattle  wa 
cohen  w  w       b   recovering software specifications inductive logic programming  proceedings eleventh national conference artificial intelligence
seattle  wa 
cohen  w  w          pac learning recursive logic programs  ecient algorithms  journal
ai research             
cohen  w  w     hirsh  h          learnability description logics equality
constraints  machine learning           
de raedt  l     dzeroski  s          first order jk clausal theories pac learnable 
wrobel  s   ed    proceedings fourth international workshop inductive
logic programming bad honnef bonn  germany 
dzeroski  s   muggleton  s     russell  s          pac learnability determinate logic
programs  proceedings      workshop computational learning theory
pittsburgh  pennsylvania 
frazier  m     page  c  d          learnability recursive  non determinate theories 
basic results techniques  proceedings third international workshop
inductive logic programming bled  slovenia 
haussler  d          learning conjunctive concepts structural domains  machine learning        
hopcroft  j  e     ullman  j  d          introduction automata theory  languages 
computation  addison wesley 
kearns  m     valiant  l          cryptographic limitations learning boolean formulae
finite automata    th annual symposium theory computing  acm
press 
   

ficohen

kietz  j  u          computational lower bounds computational complexity
inductive logic programming  proceedings      european conference
machine learning vienna  austria 
king  r  d   muggleton  s   lewis  r  a     sternberg  m  j  e          drug design
machine learning  use inductive logic programming model structureactivity relationships trimethoprim analogues binding dihydrofolate reductase 
proceedings national academy science     
lavrac  n     dzeroski  s          background knowledge declarative bias inductive
concept learning  jantke  k  p   ed    analogical inductive inference  international workshop aii     springer verlag  daghstuhl castle  germany  lectures
artificial intelligence series      
lloyd  j  w          foundations logic programming  second edition  springer verlag 
muggleton  s     de raedt  l          inductive logic programming  theory methods 
journal logic programming                     
muggleton  s     feng  c          ecient induction logic programs  inductive logic
programming  academic press 
muggleton  s   king  r  d     sternberg  m  j  e          protein secondary structure
prediction using logic based machine learning  protein engineering                 
muggleton  s  h   ed            inductive logic programming  academic press 
page  c  d     frisch  a  m          generalization learnability  study constrained
atoms  inductive logic programming  academic press 
pazzani  m     kibler  d          utility knowledge inductive learning  machine
learning        
pitt  l     warmuth  m  k          reductions among prediction problems  difficulty predicting automata  proceedings  rd annual ieee conference
structure complexity theory washington  d c  computer society press
ieee 
pitt  l     valiant  l          computational limitations learning examples  journal
acm                  
pitt  l     warmuth  m          prediction preserving reducibility  journal computer
system sciences              
quinlan  j  r     cameron jones  r  m          foil  midterm report  brazdil  p  b 
 ed    machine learning  ecml    vienna  austria  springer verlag  lecture notes
computer science       
quinlan  j  r          learning logical definitions relations  machine learning        
   

fipac learning recursive logic programs  negative results

quinlan  j  r          determinate literals inductive logic programming  proceedings
eighth international workshop machine learning ithaca  new york  morgan
kaufmann 
rouveirol  c          flattening saturation  two representation changes generalization  machine learning         
summers  p  d          methodology lisp program construction examples 
journal association computing machinery                  
valiant  l  g          theory learnable  communications acm          
zelle  j  m     mooney  r  j          inducing deterministic prolog parsers treebanks 
machine learning approach  proceedings twelfth national conference
artificial intelligence seattle  washington  mit press 

   


