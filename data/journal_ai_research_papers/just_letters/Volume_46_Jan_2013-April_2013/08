journal artificial intelligence research                 

submitted        published      

boolean equi propagation concise efficient sat
encodings combinatorial problems
amit metodi
michael codish

amit metodi gmail com
mcodish cs bgu ac il

department computer science
ben gurion university negev  israel

peter j  stuckey

pjs csse unimelb edu au

department computer science software engineering
nicta victoria laboratory
university melbourne  australia

abstract
present approach propagation based sat encoding combinatorial problems  boolean equi propagation  constraints modeled boolean functions
propagate information equalities boolean literals  information
applied simplify cnf encoding constraints  key factor considering
small fragment constraint model one time enables us apply stronger 
even complete  reasoning detect equivalent literals fragment  detected 
equivalences apply simplify entire constraint model facilitate reasoning
fragments  equi propagation combination partial evaluation constraint simplification provide foundation powerful approach sat based finite
domain constraint solving  introduce tool called bee  ben gurion equi propagation
encoder  based ideas demonstrate variety benchmarks approach leads considerable reduction size cnf encodings subsequent
speed ups sat solving times 

   introduction
recent years  boolean sat solving techniques improved dramatically  todays sat
solvers considerably faster able manage larger instances yesterdays  moreover  encoding modeling techniques better understood increasingly innovative 
sat currently applied solve wide variety hard practical combinatorial problems  often outperforming dedicated algorithms  general idea encode  typically 
np  hard problem instance    boolean formula    satisfying assignments correspond solutions   given encoding  sat solver
applied solve  
tailgating success sat technology variety tools applied
specify compile problem instances corresponding sat instances  general
objective tools facilitate process providing high level descriptions
 constraint  problem hand solved  typically  constraint based modeling
language introduced used model instances  drawing analogy programming languages  given description  compiler provide low level executable
c
    
ai access foundation  rights reserved 

fimetodi  codish    stuckey

underlying machine  namely  context  formula underlying sat
smt solver 
example  cadoli schaerf        introduce np spec  logic based specification
language allows specifying combinatorial problems declarative way  core
system component translates specifications cnf formula  similarly sugar
 tamura  taga  kitagawa    banbara        sat based constraint solver  solve
finite domain constraint satisfaction problem first modeled constraint language
 also called sugar  encoded cnf formula solved using minisat
solver  een   sorensson         minizinc  nethercote  stuckey  becket  brand  duck   
tack        constraint modeling language compiled variety solvers
low level target language flatzinc exist many solvers  particular 
flatzinc instances solved fzntini  huang        encoding cnf
fzn smt encoding smt lib  barrett  stump    tinelli        
simplifying cnf formulae prior application sat solving utmost
importance wide range techniques applied achieve
goal  see example work li         een biere         heule  jarvisalo 
biere         manthey         references therein work 
techniques exhibit clear trade off amount simplification obtained
time requires  moreover  stronger techniques become prohibitive sat model
involves hundreds thousands variables millions clauses  cnf simplification
tools  time limits simplification techniques imposed and or approximations used 
paper takes new approach cnf simplification  typically  cnf random collection clauses  rather structure derived application specific
problem domain  sat solving applied encode solve finite domain constraint
problems  original constraint model manifest structure  usually  constraints discarded encoded cnf  advocate maintaining constraints
provides important structural information applied drive process cnf
simplification  specific  constraints model induce partitioning cnf
encoding conjunction sub formulae call portions 
novelty approach cnf simplification instead considering cnf
whole  assume partitioned conjunction smaller portions 
simplification repeatedly applied individual portions  facilitates propagationbased process simplification one portion propagates information
portions information may trigger simplification portions 
portions typically much smaller entire cnf effectively apply
stronger simplification algorithms  introduce notion equi propagation  similar
unit propagation inferring unit clauses applied simplify
cnf formulae  equi propagation inferring equational consequences literals
 and boolean constants  
wide body research cnf simplification applied implement
equi propagation sometimes called equivalent literal substitution  example
gelder         techniques typically involve binary clause based simplifications using  among
others  hyper binary resolution binary implication graphs  see example  work
heule et al         references therein  guiding principle works
   

fiboolean equi propagation

techniques must simple efficient prohibitive size cnf
must apply 
approach different focus far richer forms inference even related
cnf structure formula  one extreme apply complete equi propagation
detects equivalences implied formula  clearly complete equi propagation
np hard  however  complete equi propagators feasible apply small
portions formula  complete equi propagation slow consider ad hoc
techniques  forms equi propagation common driven
cnf structure  e g  binary clauses  rather underlying constraint structure
cnf was  being  generated 
rest paper structured follows  section   introduces modeling language
finite domain constraints consists   constraint constructs sufficient
illustrate contribution paper  argue constraints model induce
natural partition cnf encoding smaller portions partition
used drive simplification cnf encoding  section   presents equi propagation
first ingredient contribution  equi propagation learning information apply simplify cnf encodings  section   describes practical basis
implementing equi propagation  section   introduces second ingredient  partial evaluation  given information derived using equi propagation  partial evaluation applies
simplify constraints particular remove boolean variables cnf
encodings  section   describes tool  called bee  metodi   codish         ben gurion
equi propagation encoder  based equi propagation partial evaluation 
introduce full constraint language similar sugar subset
flatzinc relevant finite domain constraint problems  spell special
treatment all different constraint bee  section   demonstrates application
bee  section   presents experimental evaluation  finally section   presents
conclusion 
paper extends earlier work presented metodi  codish  lagoon  stuckey
        first introduced equi propagation  bee tool paper  metodi  
codish         bee tool available download  metodi        

   constraint based boolean modeling
section provides basis contribution  constraint based modeling language 
together boolean interpretation constraint language  enables us
view constraint model conjunction boolean formulae provides structure
drives subsequent encoding cnf 
first introduce simple small fragment typical finite domain constraint based
modeling language  serves illustrate approach  later  section    show
full language  discuss several options boolean representation integers 
paper adopt particular unary representation  called order encoding 
contribution independent choice  although equi propagation works well it 
finally finish section constraints language fragment
viewed boolean formula  constraint model conjunction 
   

fimetodi  codish    stuckey

   
   
   
   
   

new int i  c    c   
int neq i    i   
alldiff  i              
int plus i    i    i 
int array plus  i               i 

  c  c 
i     i 
v
i j ii    ij
i    i   
i       

figure    core constraint language
    constraint language fragment
focus small fragment typical constraint modeling language detailed figure   
serves present main ideas paper  constraint     declaring finite
domain integer variables range  c     c     simplicity presentation
assume c     constraints      difference integer variables 
constraints      sums integer variables  syntactic sugar allow
writing integer constants constraints  example  int neq i     short
new int i           int neq i  i    
    modeling kakuro  example
kakuro puzzle n board black white cells  black cells contain hints
white cells filled numbers      the bound   often
generalized larger value r   hints specify constraints sums values
blocks white cells right and or hint  numbers assigned white
cells block required different  figure   illustrates     kakuro
puzzle  left  solution  right  
model kakuro puzzle view set blocks  of white cells  block
b set integer variables associated corresponding integer value  hint b  
block b associated two constraints  integers b must sum hint b 
must all different  figure   illustrates constraints corresponding kakuro
instance figure   
    representing integers
fundamental design choice encoding finite domain constraints concerns representation integer variables  gavanelli        surveys several possible choices  the

figure        kakuro puzzle  right  solution  left  
   

fiboolean equi propagation

new
new
new
new
new
new
new

int i         
int i         
int i         
int i         
int i         
int i         
int i         

int
int
int
int
int
int

array
array
array
array
array
array

plus  i    i        
plus  i    i       
plus  i    i    i        
plus  i    i    i        
plus  i    i       
plus  i    i       

alldiff  i    i    
alldiff  i    i    
alldiff  i    i    i    
alldiff  i    i    i    
alldiff  i    i    
alldiff  i    i    

figure    constraints kakuro instance figure   

direct   support  log  encodings  introduces log support encoding  given choice
representation constraints bit blasted interpreted boolean formulae  focus
use unary representation  so called  order encoding  see  e g  crawford
  baker        bailleux   boufkhad        many nice properties applied
small finite domains 
order encoding  integer variable x domain             n  represented
bit vector x    x            xn    bit xi interpreted x particular bit
sequence x constitutes monotonic non increasing boolean sequence  example 
value   interval        represented   bits                 
important property boolean representation finite domain integers
ability represent changes set values variable take  well known
order encoding facilitates propagation bounds  consider integer variable
x    x            xn   values interval     n   restrict x take values range
 a  b   for   b n   sufficient assign xa     xb        if b   n  
variables xa  xb    a    b   b  n determined true false 
respectively  unit propagation  example  given x    x            x     assigning x     
x      propagates give x             x    x                 signifying dom x              
observe additional property order encoding x    x            xn    ability
specify variable cannot take specific value   v n domain equating
two variables  xv   xv     indicates order encoding well suited
propagate lower upper bounds  represent integer variables arbitrary 
finite set  domain  example  given x    x            x     equating x    x  imposes
x       likewise x    x  x    x  impose x      x       applying
equalities x gives  x    x    x    x    x    x    x    x    x    x     note repeated literals  
signifying dom x                          
order encoding many additional nice features exploited simplify
constraints encodings cnf  illustrate one  consider constraint form
  b     b integer values range     represented
order encoding  bit level  in order encoding  have     a            a   
b    b            b     constraint satisfied precisely b    a            a     instead
encoding constraint cnf  substitute bits b            b  literals a            a   
remove constraint  section   formalize process discovering equalities
literals implied constraint using simplify cnf encodings 
   

fimetodi  codish    stuckey

    bit blasting
given constraint model decision represent finite domain integer variables
bit level  we chose order encoding   bit blasting process instantiating integer variables corresponding bit vectors interpreting constraints boolean
formulae 
integer variable  i  declared constraint form new int i  c    c   
  c  c  represented bit vector                  xc               xc     so  may view
constraint model consisting boolean variables constraint c corresponds
boolean formula denoted   c    bit blasted version c  specific definition
     important  illustration  note one could define
 
  new int i  c    c       
 xi   xi  
c  i c 

                 xc               xc    well
  int neq i    i       

n
 

 xi xor yi  

i  

simplify presentation assume i     x            xn   i     y            yn  
represented number bits  mapping      extends natural way apply
conjunctions constraints  so  given constraint model one figure   
integer variables instantiated unary  order encoding  bit vectors constraint
viewed boolean formula  constraint model takes boolean representation
conjunction formulae 

   boolean equi propagation
section present approach propagation based sat encoding  boolean equipropagation  propagates information equalities boolean literals  and
constants   prove boolean equi propagation stronger unit propagation
determines least many fixed literals unit propagation  demonstrate 
example  power equi propagation show leads considerable reduction
size cnf encoding 
    boolean equi propagation
let b set boolean variables  literal boolean variable b b negation
b  negation literal    denoted    defined b     b b     b 
boolean constants     represent true false  respectively  set literals
denoted l l      l         set  free  boolean variables appear
boolean formula denoted vars    extend vars function sets formulae
natural way 
assignment  a  partial mapping
boolean
constants  often


variables


viewed following set literals  b a b      b a b        formula
b b  denote  b   likewise  b   formula obtained substituting
   

fiboolean equi propagation

occurrences b b true  false   notation extends natural way
sets literals  say satisfies vars   vars a   a  evaluates true 
boolean satisfiability  sat  problem consists boolean formula determines
exists assignment satisfies  
boolean equality constraint              l      equi formula e set
boolean equalities understood conjunction  set boolean equalities denoted
leq
    set equi formulae denoted e 
example    suppose b    x  y  z   l             x  x  y  y  z  x   example
assignment    x  z   b    x  y  z  y  assignment  since includes
 y  y    given formula   x  y z   x  formula    y z 
equivalently z  formula  a       y    equivalent true 
satisfy since vars      x  y  z     x  z    vars a   example equi formula b
 x        z  equivalently x  y z  
      equi propagation
process inferring equational consequences boolean formula given equational information  equi propagator formula extensive function   e e
defined e e 

n


e  e  e leq
    e    e
is  conjunction equalities  least strong
true e  say
n e  made
eq fifi
equi propagator complete  e    e l    e    e   denote
complete equi propagator   assume equi propagators monotonic 
e  e   e     e     particular  follows  definition  complete
equi propagators  section     discuss several methods implement complete
incomplete equi propagators 
example    consider constraint
c   new int x        new int y        int neq x  y 
corresponding boolean representation     c   bit representation
x    x    x    x    x       y    y    y    y   
assume setting
e 



y       y       y       y     



signifying      then   e    e  x    x    indicating x       occurs
since e equivalent  x  x     x  x     x  x     x  x  x  x   
e    x    x   
following theorem states complete equi propagation least powerful
unit propagation 
   

fimetodi  codish    stuckey

theorem    let complete equi propagator boolean formula   then 
literal made true unit propagation clausal representation using
equations e determined true  e  
proof  let boolean formula  e equi formula  let c ce clausal
representations e respectively  clearly    c e    ce   let b
positive literal determined unit propagation c ce   correctness unit
propagation  c ce    b  hence  e    b thus  e     b      case
negative literal b same  except infer b     
following example illustrates equi propagation powerful unit
propagation 
example    consider    x  x     x  x     x  x  x     clausal
representation  x  x    x  x    x  x    x  x  x    unit propagation
possible  since unit clauses  equi propagation  with additional equational
information  gives        x       x       x       
      boolean unifiers
sometimes convenient view equi formula e generic solved form boolean
substitution  e    most general  unifier equations e  boolean substitutions generalize assignments variables bound literals fi boolean

substitution idempotent mapping   b l    dom     b b  b     b
finite  note particular idempotence implies  b     b every b b 
note defined b domain  dom    includes elements

non identity 
boolean substitution    viewed set  



b    b  b dom  
 


apply another substitution     obtain substifi

tution         b       b   b dom   dom       unifier equi formula e
substitution     e   e e  most general unifier e
substitution unifier   e  exists substitution      
example    consider equi formula e  b    b    b    b    b    b    b    b    b   
   b    b    unifier e  b    b    b    b    b    b    b    b    b       b       
note  e  trivially true equi formula  b    b    b    b    b    b    b    b       
          
consider enumeration l             b    b    b    b           let total  strict 
order l        b  b  b  b    define canonical most general
unifier unifye satisfiable equi formula e where 



unifye  b    min   l    e    b    
is  substitution unifye maps b smallest literal equivalent b given
e  compute unifye almost linear  amortized  time using variation
union find algorithm  tarjan        
example    equi formula e substitution example  
unifye    
   

fiboolean equi propagation

following proposition provides foundation equi propagation based boolean
simplification  allows us apply equational information simplify given formula 
particular  e equi formula literals occurring unifye    smaller
contains fewer variables 
proposition    let boolean formula e e satisfiable equi formula  then 
a  e unifye    e 
b  e satisfiable unifye    satisfiable 
c  satisfying assignment unifye    unifye satisfying assignment
e 
proof   a  let   unifye assume satisfying assignment e 
view substitution  unifier e  hence  since general unifier 
exists substitution     clearly  b     b  variables b range
  hence  agree variables    implies            
meaning            so  satisfying assignment    e
satisfying assignment e   b     direction follows  a 
   direction  c    c  assume satisfying assignment unifye     clearly
unifye satisfies construction  unifye satisfies e since unifye  e 
trivial  hence unifye satisfying assignment e 
      equi propagation process
equi propagation process presented central theme paper  let  
  n partitioning boolean formula n portions  let             n corresponding equi propagators  take initial e     satisfiability determined
follows 
   long possible  select  e    e update e    e  
   finally  equi propagators apply more  check unifye    satisfiable 
   satisfying assignment unifye    unifye satisfying assignment
 
typically apply equi propagation theme boolean representation  
  n constraint model c   c  cn     ci     require
ci small conjunction constraints  typically  integer variables referred
ci declared ci  sometimes requires duplicating variable
declarations   individual constraint c denote c  conjunction constraints
including c declarations integer variables refers to  specifics
declarations clear context 
example    let c following constraint model 

new int x        new int y        new int z       
c 
int plus x  y     int plus y  z     int neq y  z 

   



fimetodi  codish    stuckey

   int plus   x  y       int plus x  y     new int x        new int y        
   int plus   y  z       int plus y  z     new int y        new int z        
   int neq   y  z    int neq y  z  new int y        new int z        
basis equi propagation take               int plus   x  y       
      int plus   y  z              int neq   y  z     denoting x       x    x      
    y    y     z       z    z    applying corresponding complete equi propagators
starting e    have 
   e       e      e   x       y       x    y    
   e       e      e   z       y    z    
   e       e      e   y       
point equi propagation applies more  unifye     x       x       y   
   y       z       z         now  unifye     tautology  all boolean variables
determent equi propagation  
following theorem clarifies order equi propagators applied
equi propagation process influence final result 
theorem    equi propagation process confluent 
proof  let     n boolean formula             n corresponding equipropagators  let e    ir  ir         i             e    js  js         j            
two different applications equi propagation process  construction 
given equi propagators  property       e      e   e      e   
assume  contradiction  e     e    w l o g  exists e e  e
e   swap roles e  e  e  e     e    e    let us focus first
step equi propagation process leading e  introduced equation e e 
introduced e    so  exists     e   j   j          j             e 
e      e  e   e    but  e e    monotonicity      
     e       e    hence e      e    contradiction construction
property     
following proposition provides alternative  efficient implement  definition
complete equi propagation 
proposition    let boolean formula complete equi propagator  
define e e 
n


unify       e
 e    e e leq
e
   
then   e     e   is  implements complete equi propagator  
   

fiboolean equi propagation

proof  forthefi first direction     
definition   e  e 
 e  e unifye       e
proposition   a  e    unifye     so 
 e   e   direction      let e  e   e e proof
straightforward  otherwise  let unifye       e assume contrary e    e  
words e     e  means exists assignment
satisfies e satisfy e  lemma   a   satisfies unifye    e
particular satisfies unifye     assumption unifye       e
satisfies e  contradiction 
computing considerably efficient since simply examine
formula application unifye determine new boolean equality consequences 
finally comment  intention equi propagation process applied
make sat instance smaller obtain easier solve representation 
however  decreasing size cnf main objective  fact  often explicitly
introduce redundancies improve sat encoding  example  consider if thenelse construct  xite s t f   propositional variable  indicates selector 
indicates true branch  f indicates false branch  x indicates result 
corresponding cnf   s  t  x    s  t  x    s  f  x    s  f  x    een sorensson
       propose add redundant clauses   t  f  x   t  f  x   comment
improves encoding observe redundant clauses often introduced
achieve arc consistency sat encoding  show given clausal encoding
formula   application equi propagation strengthen unit propagation 
theorem    let c set clauses  suppose c    e e equi formula 
unit propagation unifye  c  least strong unit propagation c 
proof  unit propagation c starting assignment a  repeatedly chooses clause
c  l  c  l    l  c  ai sets ai      ai  l   unit propagation terminates
ak clauses occur  note failure detected ak contains
literal negation 
show using order unit propagation unifye  c  determined
occurs c starting assignment b    unifye  a    always obtain assignment
bi bi unifye  ai    proof induction unit propagation steps c 
base case holds construction 
assume c  l  c  l    l  c  ai   induction bi unifye  ai  
 unifye  l      l  c   either unifye  l  bi case set bi     bi
induction holds  unifye  l    bi   since c  l  c  unifye  l      l 
c  unifye  l   unifye  c   hence unit propagation unifye  c  bi obtain
bi      bi  unifye  l    hence induction holds 
given unit propagation reaches unique fixpoint unit propagation order
unifye  a    end assignment b b bk unify ak  
    power equi propagation
illustrate impact equi propagation come back kakuro example
section      recall figure     fact solving puzzles via sat encodings quite easy 
without equi propagation  example viewed illustrating
   

fimetodi  codish    stuckey

a   

b   

c   

figure    applying complete equi propagation kakuro instance using different models

impact equi propagation size encoding  compare   different models
problem  give different equi propagation 
consider  baseline discussion  following boolean representation
derived constraint model declarations specified explicitly
form new int i     h  h smallest hint block includes
number   smaller 
 
 
   
  int neq   ii   ij    
  int array sum   b  hint b    
 i            ik   blocks
 i j k

b blocks

notice one int neq conjunct pair white cells block 
one int array sum conjunct block  applying equi propagation process
  complete equi propagators determines six integer values depicted figure   a  
figure   b  illustrates impact applying equi propagation process
equi propagators alldiff constraints instead individual int neq constraints  determines seven integer variables formalized taking following
boolean representation constraint model  and introducing equi propagator
conjunct  
 
 
   
  alldiff   b   
  int array sum   b  hint b    
b blocks

b blocks

figure   c  illustrates impact applying equi propagation process equipropagators pairs  consisting alldiff constraint together corresponding sum constraint  form equi propagation powerful  fixes integer
values white cells  in example   stress equi propagation reasons
equalities boolean literals constants  take model as 
 

   
  alldiff   b      int array sum   b  hint b    
b blocks

demonstrate impact equi propagation  table   provides data   
additional instances   categorized as  easy  medium hard  first two columns
table indicate instance category id  five columns headed integer
   instances available http    c ucc ie  hcambaza page  page  page  html  generated helmut
simonis  

   

fihard

medium

easy

boolean equi propagation

id
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

integer variables
init       bee
init
           
          
           
          
           
          
           
          
           
          
           
          
           
           
           
          
                        
                        
           
          
           
           
                        
           
          
           
           
average compilation time sec 

boolean variables
 
 
 
    
   
 
         
 
         
 
         
 
         
 
         
 
         
  
         
 
         
   
         
   
         
 
         
  
         
   
         
 
         
  
                 

bee
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
     

table    applying sat based complete equi propagation kakuro encoding
variables  first four specify number unassigned white cells initial stage
three complete equi propagation processes described above  five
columns headed boolean variables  first four indicate corresponding information
regarding number boolean variables bit representations integers  so 
smaller number table  variables removed due equipropagation  particular    model completely solves      instances  two
columns titled bee show corresponding information obtained using weaker form
equi propagation described section   below  last row table indicates
average time takes perform equi propagation  in seconds  using three
schemes              weaker scheme titled bee  come back discuss
later detailing equi propagation performed  results table indicate
clear benefit performing equi propagation based coarser portions model 
    implementing equi propagators
implement complete equi propagators need infer boolean equalities implied
given boolean formula    equi formula  e  based proposition    sufficient
test condition
unifye               
   
consider three techniques  using sat solver  using bdds  using ad hoc rules
applied boolean representations individual constraints 
straightforward implement complete equi propagator using sat solver 
test condition     consider formula               satisfiable 
condition     holds  way  condition     checked relevant equations
   

fimetodi  codish    stuckey

involving variables unifye     and constants       major obstacle satbased approach testing single equivalence          least hard testing
satisfiability   fact testing unsatisfiability typically expensive 
hence importance assumption small fragment cnf
interest  practice sat based equi propagation surprisingly fast  illustration 
last row table   average times sat based complete equi propagation
different models indicated columns             interesting observe
strongest technique  using     fastest  fewer  but
larger  conjuncts hence fewer queries sat solver 
implement complete equi propagator using binary decision diagrams  bdds 
follows  construct bdd formula beginning equi propagation 
new equational information e   added e simplify bdd conjoining
bdd bdd e   projecting variables longer appear
unifye     note simplification increase size bdd  practice 
rather two steps  use restrict operation coudert madre
        bdd simplify somenzi        create new bdd efficiently 
given bdd unifye     explicitly test condition     using standard
bdd containment test  e g   bddleq somenzi         sat based approach  test performed relevant equations involving variables unifye   
 and constants       alternately use method bagnara schachte       
 extended extract literal equalities opposed variable equalities  extract
fixed literals equivalent literal consequences bdd 
example     consider bdd shown figure   a  represents formula 
new int a        new int b        int neq a  b   figure   b  depicts bdd
unifye    e    b       b       b         easy see equipropagation determines a    a    let e     e  a    a     figure   c  shows
simplified bdd unifye      
major obstacle bdd based approach concerns size formula
unifye     constraints  corresponding bdd guaranteed polynomial  in size constraint   following result holds arbitrary constraint
  holds unifye    
proposition    let c constraint k integer variables represented n bits
order encoding  then  number nodes bdd representing   c   bound
o nk   
proof   sketch  n     legitimate states n bit unary variable 
bdd cannot nodes possible states 
constraints new int  int neq  int plus involve   integer variables
hence bdd based complete equi propagators polynomially bounded  however 
case global constraints alldiff int array plus
arity fixed  moreover  well known alldiff constraint
polynomial sized bdd  bessiere  katsirelos  narodytska    walsh        
   

fiboolean equi propagation
    
    
a  

 

 
    
    
    
    
b 
b 




    
    
         
    
    
r   rrr a   a 
r
r
 
r r
rr
rrr rrrr
 
r
         
    
    
    
    
    
b  l     
b 
b       
b       
  llb  

  
l
 
l
 
 
lll
  
 
  l
    
    
    
    
    
 
a   a  l     
a 
    l  ll
  l l   l
    
    
    
    
b 
b        
s  

    
    
a 
 
 
 

 

 

    
    
    
    
a 
a 
 

 

 
 
 
    
    
    
a  
a        
  
    
    
    
  
  

    
    
a 
 
 







 



 

 
    
    
a 







 a  bdd int nequ  a  b 

 b  simpld wrt b          

 c  simpld wrt a   a 

figure    bdds  a  new int   a          new int   b          int neq a  b   b 
unifye    e    b      b      b       c  unifye      e    
e  a   a     full  dashed  lines correspond true  false  edges  edges
false node f omitted brevity 

given potential exponential run time performing sat based equi propagation 
potential exponential size bdd based equi propagators  consider third
approach implement equi propagation collection ad hoc transition rules
type constraint  approach complete equations
implied constraint detected implementation fast  works well
practice  topic next section 

   ad hoc equi propagation
consider rule based approach define equi propagators  definition given
set ad hoc rules specified type constraint  novelty approach
based cnf  previous works  rather driven bit blasted constraints
encoded cnf  presentation focuses case finite domain
integers represented order encoding  integer x    x            xn    often
write  x denote equation xi      x   denote equation xi      x   
denote equation xi   xi     x   denote pair equations xi      xi       
moreover  simplify notation specifying rules below  view x    x            xn  
larger vector padded sentinel cells cells left x  take value  
cells right xn take value    basically facilitates specification
end cases formalism  consider   constraints
language fragment presented section   
   

fimetodi  codish    stuckey

c   new int  x            xn       n 
e
add c  e 
xi     x               xi     
xi     xi                xn    

 a 

c   int neq x   
x    x            xn      y            yn  

e
add c  e 
x i
  
xi   yi     yi   xi  
x    i    
xi   yi     yi   xi  
x    i    
 b 

figure    ad hoc rules  a  new int  b  int neq
c   int plus x  y  z  x    x            xn   
   y            ym    z    z            zn m  

c   alldiff  z    z    z            zn   
e
add c  e 
z    z   i  j 

z   
  z    zk   
zk  
  j  k     

e
x i  j
x   i    j
z k  x  
z   k  x
x i
z k

 a 

add c  e 
z i j
z  i j 
ki
 ki
zi     y            zi m   ym
x    yk           xk   y 
 b 

figure    ad hoc rules  a  alldiff  b  int plus

    two rules figure   a  derive monotonicity order encoding
representation  basically correspond unit propagation  constraint level 
    first rule figure   b  considers cases x constant  the symmetric
case handled exchanging x    two rules capture templates
commonly arise equi propagation process  illustrate justification
third rule consider possible truth values variables xi xi      a  xi    
xi       integers relation take form                       violating
specification ordered  possible   b  xi     xi      
numbers take form                              equal  violating neq constraint 
possible bindings xi xi   xi   xi    
    figure   a  illustrate single rule alldiff constraint considers
hall sets size    zi represents integer order encoding focus
case z  z  restricted equations e take two possible
values  j  expressed e  x            xn    i  j   for   j  means
xk     k   i  xk   xk   k   j  xk     j   k n  z     z 
means adding single equation xi   yi  because z  z  take two values  
addition rule  apply rules int neq zi   zj   pair integers zi
zj constraint 
   

fiboolean equi propagation




z              z     
e   
z              z     
x    x            x    x    x            x    
   y            y    y    y            y    
z                             
e    e   y              y     
x    x            x    x    x            x    
   y            y                  
z                             
e    e   x              x     
x    x            x                  
   y            y                  
z                             

x   y   
y   x 


int neq

z    x 


int plus

z     


int plus

z  


int plus

e    e   y     
x    x            x    x    x            x    
   y            y       y            y    
z                             

e    e   x     
x    x            x       x            x    
   y            y                  
z                             

e    e   x   y            x   y   
x    x    x    x    x                  
   x    x    x    x                  
z                             

y    


new int

x   

 
new int



e    e   x   x   
x    x    x    x    x                  
   x    x    x    x                  
z                             

figure    ad hoc equi propagation described example   
    first four rules figure   b  capture standard propagation behavior
interval arithmetics  last two rules apply one integers relation
constant  symmetric cases replacing role x  
    special ad hoc rules equi propagation int array plus constraint  simply viewed decomposition set int plus constraints 
simplification performed level using rules int plus  decomposition
int array plus explained section   
example     ad hoc equi propagation   consider following  partial  constraint model 
context kakuro example section      represent variables x 
z x    x            x        y            y    z    z            z     assume previous equi propagation  on constraints  determined current equi formula e 
specify integer variable z     

c 

new int x        new int y        new int z        
int plus x  y  z  int neq x  y 



figure   illustrates  step by step  equi propagation process c using ad hoc rules
defined above  step corresponds application one defined ad hoc
equi propagation rules indicated label transition  stage illustrate
derived equations  top part  application  as unifier  state variables
x  z  lower part  
   

fimetodi  codish    stuckey

c   ordered  x            xn     new int 

replace
n 
true
x     
ordered     x          xn   
xn    
ordered  x            xn       
          xn   

xi   xi   ordered  x            xi  
xi  
figure    simplification rules new int  crossed elements removed  
summarize  let us come back table    numbers presented two columns
headed bee specify number variables remaining application ad hoc equipropagation  observe definition ad hoc equi propagation trivially
monotonic 

   constraint model partial evaluation
partial evaluation  together equi propagation  second important component
approach compile constraint models cnf  partial evaluation simplifying given constraint model view information becomes available due equipropagation  typically  constraint simplification process  apply alternating steps
equi propagation partial evaluation  examples partial evaluation include constant
elimination removing constraints tautologies  section detail
partial evaluation rules apply five constraint types defined language
fragment presented section   
    new int i  c    c    constraint specifies integer    x            xn   represented
order encoding particular corresponding bit sequence sorted  not
increasing   denote ordered  x            xn     partial evaluation focuses
aspect constraint ignores bounds c    c  specified constraint  table
figure   specifies four simplification rules apply  first rule identifies tautologies 
second third rules remove leading ones trailing zeros  fourth removes
 one two  equated bits  figure  subsequent  crossed element
sequence  indicates removed sequence 
    simplification rules int neq constraint shown figure    a  symmetric
exchanging role x   first two rules identify tautologies  third
rule x equal bit position i  corresponding bits
removed representation x   resulting shorter list bits
representations  last two rules removing leading ones trailing zeroes
illustrated following example 
example     figure    b  shows two steps partial evaluation  int neq constraint 
first removing leading ones  removing trailing zeroes 

   

fiboolean equi propagation

c   int neq x   
x    x            xn      y            yn  

replace
x   i    
true
xi   yi
true
int neq 
x
 x           
xi   yi
          xn   
yi           yn   
 y           
int neq     xi             xn   
xi 
 yi   yi             yn   
int neq  x            xi      
xi
 y            yi   yi     




int neq 
 x            x              p e

int neq
          y            y    


int neq 
 x    x              p e

int neq
    y            y    


int neq 
 x    x       
    y    y    

 a 

 b 

figure      a  simplification rules int neq  b  example application 
c   alldiff  z            zn   
zi    zi             zi m      n 

replace
n 
true
  dom z   
alldiff  z            zn   
dom zk    
k    
 
dom zi       
alldiff  z            zn   
i     

 
k

zk   

alldiff 
 z             
z  i  
          z  m  
   
 zn            
zn i  
          zn m   

figure     simplification rules alldiff

    four rules simplifying alldiff constraints illustrated figure     first 
detecting tautologies  second  identifies cases one integers
constraint  assume z    domain disjoint others  rule captures
case z  constant  third rule removes hall set size    assume  z    z    
constraint  note corresponding equi propagation rule detects
values z            zn different values  z    z    next fourth rule
applies  fourth rule case none integers constraint take
certain value i  rule captures case numbers leading
ones trailing zeroes  last two rules illustrated example    
        simplification rules shown figure    symmetric exchanging
role x   first two apply  at least  one x  z constant 
already applied equi propagation constraint  tautology  see
example     last two rules apply remove leading ones trailing zeroes 
   

fimetodi  codish    stuckey

c   int plus x  y  z  x    x            xn   
   y            ym    z    z            zn m  

replace
x i
true
z k
true
int plus  xi             xn    y 
x i  z
 zi             zn m   
int plus  x            xi    y 
x i  z  
 z            zi m   

figure     simplification rules int plus 
 a  int plus i    i    k 
 b  alldiff  i    i    i    i    i    i    i    i    
 c  int array plus  i    i    i    i     k 
figure     constraint model examples     
simplification rules int array plus constraint straightforward generalizations
ones int plus  see example    
summarise rule based approach apply equi propagation partial evaluation
present following sequence three examples focus simplification
three constraints given figure    integer variables i            i  defined
range     k      
example     consider equi propagation constraint  a  figure    e  specifies
k      




k              k     
k        k      
i        i              i      
i        i              i      
k                          
   z  



  

i                i       

i                i       


i     i      i     i   
i                       i      i      
i                       i      i      
k                          
   z  
e    e 

e   

k   


int plus

  

given e    constraint tautology removed partial evaluation 



int plus 

p e


                   i      i      

int plus
                   i      i          



example     consider equi propagation constraint  b  figure    given e 
example    
e 
i                       i      i      
i                       i      i     

i     i     
i     i   


int neq

   

e    e   i     i     
i                       i      i      
i                       i      i     

fiboolean equi propagation

given e    equi propagation rule alldiff detects  i    i    hall set  where
two variables take values       adds e  set equations  e     specify
i    i    i    i    i    i           result e    e  e   result step gives
following bindings  where impact e   underlined  
i 
i 
i 
i 

                     i      i     
                     i      i     
      i      i      i      i      i      i        
      i      i      i      i      i      i        

i 
i 
i 
i 

      i      i      i      i      i      i        
      i      i      i      i      i      i        
      i      i      i      i      i      i        
      i      i      i      i      i      i        

given e    partial evaluation constraint first removes hall set 
p e

 alldiff  i    i    i    i    i    i    i    i       alldiff  i    i    i    i    i    i     
alldiff

applies remove three redundant bits underlying representation
remaining integer  which equal          











alldiff  
    i      i      i      i      i      i         
    i      i      i      i      i      i         
    i      i      i      i      i      i         
    i      i      i      i      i      i         
    i      i      i      i      i      i         
    i      i      i      i      i      i          









p e

alldifferent














alldiff  
 i      i      i      i      i      
 i      i      i      i      i      
 i      i      i      i      i      
 i      i      i      i      i      
 i      i      i      i      i      
 i      i      i      i      i       












example     consider equi propagation constraint  c  figure    given e 
example     rules apply derive decomposition int array plus
constraint int plus parts  dictate i    i    i    
e 
i 
i 
i 
i 

                     i      i      
      i      i      i      i      i      i         
      i      i      i      i      i      i         
      i      i      i      i      i      i        


int array
plus

e 
i 
i 
i 
i 

  e   i        i        i       
                     i      i      
      i      i      i      i               
      i      i      i      i               
      i      i      i      i              

applying partial evaluation simplifies constraint follows 







int array plus  
                   i      i      
    i      i      i      i               
    i      i      i      i               
    i      i      i      i                     







p e


int array
plus








int array plus  
 i      i      
 i      i      i      i      
 i      i      i      i      
 i      i      i      i           








summarize examples      observe initial constraint model   constraints
  integers represented    bits  constraint simplification   constraints
remain   integers represented using    bits 
i 
i 
i 
i 

                     i      i     
                     i      i     
      i      i      i      i              
      i      i      i      i              

i 
i 
i 
i 
   

      i      i      i      i              
      i      i      i      i      i      i        
      i      i      i      i      i      i        
      i      i      i      i      i      i        

fimetodi  codish    stuckey

   compiling constraints bee
bee  ben gurion equi propagation encoder  tool applies encode finite domain
constraint models cnf  bee first introduced metodi codish        
encoding process  bee performs optimizations based equi propagation partial
evaluation improve quality target cnf  bee implemented  swi  prolog
applied conjunction cryptominisat solver  soos       
prolog interface  codish  lagoon    stuckey         cryptominisat offers direct support
xor clauses  bee takes advantage feature  bee downloaded  metodi 
      one find examples paper others 
source language bee compiler called bee  constraint modeling
language similar flatzinc  nethercote et al          focus subset
language relevant finite domain constraint problems  five constraint constructs
bee language introduced section      full language presented
table   
bee boolean constants true false viewed  integer  values     
constraints represented  a list of  prolog terms  boolean integer variables
represented prolog variables  may instantiated simplifying constraints 
table    x xs  possibly subscripts  denote literal  a boolean variable
negation  vector literals   possibly subscript  denotes integer variable 
c  possibly subscript  denotes integer constant  right column
table brief explanations regarding constraints  table introduces    constraint
templates 
constraints       variable declarations  booleans integers  constraint    
expresses boolean integer value  constraints       boolean  and reified
boolean  statements  special cases constraint     bool array or  x            xn   
bool array xor  x            xn    facilitate specification clauses xor clauses
 supported directly cryptominisat solver soos         constraint     specifies
sorting bit pair  x    x     decreasing order  results pair  x    x     basic
building block construction sorting networks  batcher        used encode cardinality  linear boolean  constraints compilation described asn  nieuwenhuis 
oliveras  rodrguez carbonell        codish zazon ivry         constraints        integer relations operations  constraints        
linear  boolean  pseudo boolean  integer  operations  constraints        
lexical orderings boolean integer arrays 
main design choice bee integer variables represented orderencoding  so  bee suitable problems integer variables take small
medium sized values  compilation constraint model cnf using bee goes
three phases 
   unary bit blasting  integer variables  and constants  represented bit vectors
order encoding 
   constraint simplification  three types actions applied  equi propagation  partial
evaluation  decomposition constraints  simplification applied repeatedly
rule applicable 
   

fiboolean equi propagation

declaring variables
   
   
   

declare boolean x
declare integer i  c  c 
 x       x     

new bool x 
new int i  c    c   
bool int x  i 

op  or  and  xor  iff 

boolean  reified  statements
   
   
   
   
   

bool eq x    x    bool eq x    x   
bool array op  x            xn   
bool array op reif  x            xn    x 
bool op reif x    x    x 
comparator x    x    x    x   

x    x  x    x 
x  op x  op xn
x  op x  op xn x
x  op x  x
sort  x    x        x    x   

integer relations  reified 
rel  leq  geq  eq  lt  gt  neq 
arithmetic
op  plus  times  div  mod  max  min   op   plus  times  max  min 
   
    
    
    
    
    

int
int
int
int
int
int

rel i    i   
rel reif i    i    x 
array alldiff  i              
abs i    i 
op i    i    i 
array op    i               i 

i  rel i 

v  rel i  x
i j ii    ij
 i     
i  op i   
i  op  op   

linear constraints
    
    
    
    
    
    

rel leq  geq  eq  lt  gt 

bool array sum rel  x            xn    i 
bool array pb rel  c            cn     x            xn    i 
bool array sum modk  x            xn    c  i 
int array sum rel  i               i 
int array lin rel  c            cn     i               i 
int array sum modk  i               c  i 

  xi   rel
  ci xi   rel
   xi   mod c   
  ii   rel
  ci ii   rel
   ii   mod c   

lexical order
    
    
    
    
    
    

bool arrays lex xs    xs   
bool arrays lexlt xs    xs   
bool arrays lex reif xs    xs    x 
bool arrays lexlt reif xs    xs    x 
int arrays lex is    is   
int arrays lexlt is    is   

xs  precedes  leq  xs  lex order
xs  precedes  lt  xs  lex order
x xs  precedes  leq  xs  lex order
x xs  precedes  lt  xs  lex order
is  precedes  leq  is  lex order
is  precedes  lt  is  lex order

table    syntax bee constraints 
   cnf encoding  best suited encoding technique applied simplified constraints 
bit blasting equi propagation bee follow general descriptions sections          bit blasting implemented prolog unification  declaration form new int i  c    c    triggers unification                  xc               xc     to
ease presentation assume integer variables represented positive interval
starting   limitation practice bee supports negatives
integers   bee applies ad hoc equi propagators described section    equality
form x   l  between variable literal constant  detected  equipropagation implemented unifying x l  unification applies occurrences
x sense propagates constraints involving x 
decomposition replacing complex constraints  for example arrays 
simpler constraints  for example array elements   consider  instance  constraint int array plus as  sum   decomposed list int plus constraints applying
straightforward divide conquer recursive definition  base case  as  a 
   

fimetodi  codish    stuckey

c   alldiff   z    z    z            zn   
e
add c  e 
dom z   

  dom zk    k     

z    authors

 i  j  dom zk    
 k     

dom z     i  j 
dom z     i  j 
z     z 
zk    i  zk    j
 k     

figure     simplification rules alldiff  
constraint replaced constraint form int eq a sum  equates bits
sum     a    a    replaced int plus a    a    sum   general
case split two halves  constraints generated sum halves 
additional int plus constraint introduced sum two sums 
another example  consider int plus a    a    a  constraint  one approach  supported bee  decomposes constraint odd even merger  from context
odd even sorting networks   batcher         here  sorted sequences bits a  a 
merged obtain sum a  results model o n log n  comparator
constraints  and later encoding o n log n  clauses   another approach 
supported bee  decompose constraint encodes directly cnf
size o n     context so called totalizers  bailleux   boufkhad         hybrid
approach  leaves choice bee  depending size domains variables
involved  finally  note user configure bee fix way compiles
constraint  and others  
cnf encoding last phase compilation constraint model 
remaining simplified  bit blasted  constraints encoded directly cnf  encodings
standard similar applied various tools  bee encodings similar
applied sugar  tamura et al         
    all different constraint bee
all different constraint specifies set integer variables take different values
specified domains  constraint received much attention literature
 see example survey van hoeve         bee provides special treatment
constraint 
many applications  all different constraints applied model special case
constraint permutation  namely   i              different may
take precisely n different values  bee identifies special case applies two additional
ad hoc equi propagation rules case  table figure    illustrates rules 
annotate constraint   emphasize detected
permutation  first rule case one integer  assume z   
take value i  second rule case variables except two  assume z   
z    cannot take two values  assume i  j  now  constraint permutation 
   

fiboolean equi propagation

determine z  z  must take two values j  illustrate second
rule consider following example 
example     consider constraint alldiff i            i      integer variables taking values interval         exactly   values  e  specifies i    i  i  cannot take
values      therefore introduce equations restrict i  i  take
values      corresponding ad hoc rule permutation applies 
e 
i 
i 
i 
i 
i 



x        x       
x        x       
 


x        x      
   x              x      
   x              x      
         x      x      
         x      x      
         x      x     

dom ik          
k  




alldiff

e 
i 
i 
i 
i 
i 



x                x       
x                x      
  e 


x     x   
   x                    
   x                    
         x      x      
         x      x      
         x      x     

facilitate implementation ad hoc equi propagation all different constraints 
bee adopts dual representation integer variables occurring constraints combining order encoding the  so called  direct encoding  essentially
encoding proposed gent nightingale         declaring integer variable i  bit blast order encoding applies corresponding unification
   x            xn    encountering alldiff constraint  additional bit blast
introduces i     d            dn   direct encoding  channeling formula channel i  i   
introduced 
direct encoding unary representation i     d            dn   bit di true
i    i  so  exactly one bits takes value true  example  value
  interval        represented   bits                     dual representation
following channeling formula captures relation two representations
integer variable    x            xn   i     d            dn   

channel  x            xn     d            dn     

d    x 
dn   xn




n 
 

 di xi xi    

i  

consider alldiff constraint integer variables take different values   n  constraint simplification  alldiff  i            im    constraint
viewed direct encoding bit matrix row consists bits
 di            din   ii direct encoding  element dij true iff ii takes value j 
j th column specifies ii take value j hence  one variable
column may take value true  representation one main advantage 
direct encoding decompose alldiff  i            im     conjunction n     constraints  one column   j n  form bool array sum leq  d j           dmj       
arc consistent  soon di j      ii   j  di j        ii    j    
 
j     j  contrast
order encoding alone decomposition o m   constraints
int neq ii   ij     j
arc consistent  illustrate advantage dual
encoding alldiff constraint section     
   

fimetodi  codish    stuckey

   use module bee compiler   bcompile     
   use module sat solver   sat     
solve instance  solution   encode instance  map  constraints  
bcompile constraints  cnf  
sat cnf  
decode map  solution  

figure     generic application bee 

   using bee
typical bee application form depicted figure    predicate solve  
takes problem instance provides solution  specifics application
call encode   given instance generates constraints solve
together map relating instance variables constraint variables  calls
bcompile   sat   compile constraints cnf solve applying sat solver 
instance solution  sat solver binds constraint variables accordingly 
then  call decode    using map  provides solution terms instance
variables  definitions encode   decode   application dependent provided user  predicates bcompile   sat   part tool provide
interface bee underlying sat solver 
    example bee application  magic graph labeling
illustrate application bee using prolog modeling language solve graph
labeling problem  graph labeling finding assignment integers vertices
edges graph subject certain conditions  graph labellings introduced
  s hundreds papers wide variety related problems published
since then  see example survey gallian             references 
graph labellings many applications  instance radars  x ray crystallography 
coding theory  etc 
focus vertex magic total labeling  vmtl  problem one
find graph g    v  e  labeling one to one map v e                 v    
 e   property sum labels vertex incident edges
constant k independent choice vertex  problem instance takes form
vmtl g  k  specifying graph g constant k  context figure    
query solve vmtl g  k   solution  poses question  exist vmtl labeling
g magic constant k  binds solution indicate labeling one exists 
unsat otherwise  figure    illustrates example problem instance together
solution 
figure    illustrates prolog program implements encode   predicate
vmtl problem  call predicate declareints   introduces constraints
declare integer variables vertex edge graph  generates
map  call predicate sumtok   introduces constraints require sum
labels vertex incident edges equals k  auxiliary predicate
   

fiboolean equi propagation

instance
instance   vmtl g  k  
g    v  e  
v                
e                   
                
k     

graph
 

 

  
   



solution


 

v 
v 

v 
v 

    
    
    
    

e     
e     
e     
e     


    
    

    
  

figure     vmtl instance solution 
encode vmtl  vs es  k  map constraints  append vs es ves   length ves n  
declareints ves n map constraints cs   
sumtok vs es map k cs  cs   
getvars ves map vars  
cs   int array alldiff vars   
declareints        cs cs  
declareints  id ids  n   id x  map   new int x   n  csh  cst  declareints ids n map csh cst  
sumtok          cs cs  
sumtok  vid vs  es map k  int array plus vars k  csh  cst  findall  x y   member  x y  es   x vid   y vid   esids  
getvars  vid esids  map vars  
sumtok vs es map k csh cst  
getvars          
getvars  id ids  map  var vars   member  id var  map  
getvars ids map vars  

figure     encode   predicate vmtl application bee
map
         e        v    
         e        v    
         e        v    
         e        v   

constraints
new int v           new int e           int array plus  v    e    e     k  
new int v           new int e           int array plus  v    e    e     k  
new int v           new int e           int array plus  v    e    e    e     k  
new int v           new int e           int array plus  v    e     k  
new int k           alldiff  v    v    v    v    e    e    e    e    

figure     vmtl instance constraints map generated encode   

getvars   receives list identifiers  vertices edges  extracts corresponding
list integer variables map 
given vmtl instance figure     call predicate encode   figure   
generates map constraints detailed figure    
   

fimetodi  codish    stuckey

solving constraints figure    binds map follows  indicating solution
 in unary order encoding  


   
   
 
   
   

                          
                          
                          
                          

        
        
        
        



                          
                          
                          
                         

using bee compile constraints figure    generates cnf contains    
clauses    boolean variables  encoding set constraints without applying
simplification rules generates larger cnf contains     clauses    boolean
variables 
section     report using bee enables us solve interesting instances
vmtl problem previously solvable techniques 
    bumblebee
bee distribution includes command line solver  call bumblebee 
bumblebee enables one specify bee model input file line contains
single constraint model last line specifies type goal  bumblebee
reads input file  compiles constraint model cnf  solves cnf using
embedded cryptominisat solver  soos        outputs set bindings declared
variables model  or message indicating constraints satisfiable  
figure    contains left bumblebee input file vmtl instance
figure    right bumblebee output  solution constraint
model  example  last line input file specifies goal solver 
options are 
   solve satisfy  solve single satisfying assignment constraint model 
   solve satisfy c   solve  at most  c satisfying assignments constraint model
c integer value  c   option solve solutions 
   solve minimize i   solve solution minimizes value integer
variable i  solver outputs intermediate solutions  with decreasing values
i  encountered search minimum value i 
   solve maximize i   similar minimize  maximizes 
details examples found bee distribution  metodi   codish 
      

   experiments
report experience applying bee  appreciate ease use reader
encouraged view example encodings available tool  metodi   codish 
       experiments run intel core   duo e         ghz cpu  gb memory
linux  ubuntu lucid  kernel           generic   bee written prolog run
   

fiboolean equi propagation

content bumblebee input file
new int v        
new int v        
new int v        
new int v        
new int e        
new int e        
new int e        
new int e        
int array plus  v   e   e       
int array plus  v   e   e       
int array plus  v   e   e   e       
int array plus  v   e       
int array alldiff  v   v   v   v   e   e   e   e   
solve satisfy

bumblebee output

v     
v     
v     
v     
e     
e     
e     
e     

          

figure     solving vmtl instance using bumblebee 

using swi prolog v         bits  comparisons sugar  v        based use
identical constraint models  apply sat solver  cryptominisat v        run
machine  times reported seconds 
    quasigroup completion problems
quasigroup completion problem  qcp  proposed gomes  selman  crato       
constraint satisfaction benchmark  given n n board integer variables  in
range     n   assigned integer values  task assign values
variables  column row contains value twice  constraint model
conjunction alldiff constraints  ansotegui  del val  dotu  fernandez  manya
       argue advantage direct encoding qcp 
consider    instances      csp competition   table   considers three
settings  bee dual encoding alldiff constraints  bee using order
encoding  equivalent using int neq constraints instead alldiff   sugar 
table shows  instance identifier  sat unsat   compilation time  comp  seconds 
clauses encoding  clauses   variables encoding  vars   sat solving time
 sat  seconds 
results indicate that      application bee using dual representation
alldiff    times faster produces    times fewer clauses  in average 
using order encoding alone  despite need maintain two encodings       without
dual representation  solving encodings generated bee slightly faster
sugar bee still generates cnf encodings   times smaller  on average 
generated sugar  observe   instances found unsatisfiable bee  indicated
   http   www cril univ artois fr cpai     competition instances specified using binary disequalities  use model alldiff 

   

fimetodi  codish    stuckey

instance

         sat
         sat
         sat
         sat
         sat
         sat
         sat
         sat
         sat
         sat
          unsat
          unsat
          unsat
          unsat
          unsat
total

bee  dual
comp clauses
 sec 
         
         
         
         
         
         
         
         
         
         
         
    
 
    
 
    
 
         

encoding 
vars
sat
 sec 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 
    
 
    
 
    
    
    
    

bee  order
comp clauses
 sec 
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          

encoding 
vars
sat
 sec 
   
    
   
     
   
    
   
     
   
     
   
     
   
     
   
     
   
     
   
     
   
     
   
    
   
    
   
    
   
     
      

clauses

sugar
vars

      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

sat
 sec 
     
     
    
     
     
     
     
    
    
     
     
    
    
    
     
      

table    qcp results       instances     holes
cnf single clause variables   comment sugar pre processing
times higher bee indicated table 
    word design dna
problem     csplib seeks largest parameter n  exists
set n eight letter words alphabet    a  c  g    following
properties      word exactly   symbols  c  g       pair
distinct words differ least   positions      every x  s  xr  the reverse
x  c  the word obtained replacing   c g  vice versa 
differ least   positions 
mancini  micaletto  patrizi  cadoli        provide comparison several stateof the art solvers applied dna word problem variety encoding techniques 
best reported result solution    dna words  obtained     seconds  using
opl  van hentenryck        model lexicographic order break symmetry  frutos 
liu  thiel  sanner  condon  smith  corn        present strategy solve problem
four letters modeled bit pairs  t  m   eight letter word
viewed combination t part   t            t     bit vector  m part 
 m            m     bit vector  authors report solution composed two pairs
 t part m part  sets   t    m     t    m     t          m           t        
 m         forms set                      dna words  marc van dongen
reports larger solution     words  
building approach described frutos et al          pose conditions sets
t parts m parts    cartesian product  
satisfy requirements original problem  three conditions below 
required satisfy              required satisfy              set
   notions t part m part slightly different ours 
   see http   www cs st andrews ac uk  ianm csplib  

   

fiboolean equi propagation

bit vectors v   conditions are        bit vector v sums          pair
distinct bit vectors v differ least   positions        pair bit vectors
 not necessarily distinct  u  v v   ur  the reverse u  v c  the complement v 
differ least   positions  equivalent requiring  ur  c differs v
least   positions 
strategy model bee encoding  instance takes form
dna n    n    signifying numbers bit vectors  n  n  sets   without
loss generality  impose  remove symmetries  lexicographically
ordered  solution cartesian product    
using bee  find  fraction second  sets t parts size    m parts
size    provides solution size            dna word problem  running
comet  v       find     word solution    seconds using model hakan
kjellerstrand   using bee  prove exist set    t parts      
seconds   set   m parts       seconds   facts unknown prior bee 
proving solution dna word problem     words 
without restriction two part t m strategy  still open problem 
    vertex magic total labeling
macdougall  miller  slamin  wallis        conjecture n vertex complete graph 
kn   n   vertex magic total labeling magic constants specific range
values k  determined n  conjecture proved correct odd n verified
brute force n      address cases n     n      involve    instances
 different values k  n          different values k  n       starting
simple constraint model  illustrated example figure      add additional
constraints exploit fact graphs symmetric      assume edge
smallest label e          assume labels edges incident v 
ordered hence introduce constraints e      e        e  n       assume
label edge e    smaller labels edges incident v   except e     
introduce constraints accordingly  setting bee solve except   instances
  hour timeout sugar solve except   
table   gives results    hardest instances k     hardest instances k  
  hour time out  bee compilation times order     sec instance k 
    sec instance k     sugar encoding times slightly larger  instances
indicated magic constant  k  columns bee sugar indicate sat solving
times  in seconds   bottom two lines indicate average encoding sizes  numbers clauses
variables  
results indicate sugar encodings  in average      larger 
average sat solving time bee encodings   times faster  average excluding instances sugar times out  
address two vmtl instances solvable using bee models described
 k   magic labels           partition problem fixing values e   
e    maintaining constraints  analysis symmetry breaking
constraints indicates results     new instances two cases 
   see http   www hakank org comet word design dna  co 

   

fimetodi  codish    stuckey

instance
bee
k 
k
sat  sec 
   
    
   
     
   
    
   
     
   
     
   
     
   
     
   
     
   
      
   
      
average cnf size 
clauses
      
vars
    

sugar
sat  sec 
    
    
    
    
    
    
      
      
      


instance
bee
k  
k
sat  sec 
   
    
   
    
   
     
   
    
   
     
   
     
   
    
   
    
   
    
   
     
   
     
   
      
   
       
   
      
   
      
   
       
   
       
   
       
   

   

average cnf size 
clauses
       
vars
     

      
    

sugar
sat  sec 
    
    
     
    
    
     
    
     
     
      
      
      
      
      
      
       
       



       
     

table    vmtl results k  k      hour timeout 

original vmtl instance solved one     instances solved  so  solve
parallel  fixing e    e    fuels compiler encodings considerably
smaller  instance k       solved         seconds e        e        
compilation time      seconds encoding consists   million clauses
   thousand variables 
best knowledge  hard instances suite beyond reach
previous approaches program search magic labels  sat based approach
presented jager        cannot handle these   comparison sugar indicates
impact compiler 
    balanced incomplete block designs
problem     csplib  bibd  instance defined   tuple positive
integers  v  b  r  k    requires partition v distinct objects b blocks
block contains k different objects  exactly r objects occur block  every two
distinct objects occur exactly blocks 
   personal communication  gerold jager   march      

   

fiboolean equi propagation

figure     bibd symmetry breaking 
naive model bibd instance  v  b  r  k    introduces following constraints
v b boolean incidence matrix      exactly r ones row      exactly k ones
column      exactly ones scalar product two  different  rows 
model contain sufficient degree information trigger equipropagation process  order take advantage bee simplifications added
symmetry breaking described frisch  jefferson  miguel        illustrated
figure     row viewed sequence four parts       sizes    r   
 r     b  r      first row fixed assigning parts b ones
 marked black  parts c zeros  marked white   second row
fixed assign parts c ones  marked black  parts b zeros
 marked white   third subsequent rows  marked gray   sum constraints decomposed summing part  a       d  summing results
follows    b       c     c     r   b     r   ensures
row contains exactly r ones scalar product first  and second  row
  denote constraint model symb  for symmetry breaking  
instance
 v  b  r  k   
                    
                    
                   
                   
                  
                  
                 
                 
                 
                 
                 
total  sec 

comp
 sec 
    
    
    
    
    
    
    
    
    
    
    

bee  symb 
clauses
sat
 sec 
      
    
             
      
    
      
    
     
    
      
    
     
    
      
    
 
    
     
    
     
    
     

sugar  symb 
comp
clauses
sat
 sec 
 sec 
                   
                   
             
    
    
      

     
      
    
     
      
    
    
      
    



     
    
    
     
      
    
     
     
    
        

satelite  symb 
comp
clauses sat
 sec 
 sec 
    
           
                 
    
           
    
      

    
          
    
           
   
          
     
           
    
      
    
          
   
          
        

table    bibd results      sec  timeout 
table   shows results comparing bee  compilation time  clauses encoding  sat
solving time  sugar using symb model  compare bee satelite  een
   

fimetodi  codish    stuckey

  biere         cnf minimizer  input satelite cnf encoding
symb model generated bee without applying simplifications  compilation
time  comp  indicates satelite pre processing time  final row indicates total
compilation sat solving time entire suite approach  cases
time measured seconds 
experiment indicates bee generates significantly smaller cnf sugar
affects sat solving time  moreover  sugar compilation time extremely
long  comparing bee satelite see output cnf
similar size satelite applied entire cnf  instances
compilation time significantly longer solving time 
instance
 v  b  r  k   
                    
                    
                   
                   
                  
                  
                 
                 
                 
                 
                 
total

bee  symb 
comp
sat
    
    
          
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
     

 m   
    
    
    

     
      
     

    


       

minion
symb
    
    


    
     
     
    
    

    
       

symb 
    
    
    
     
    
    
    
    
    
    
    
     

table    bibd results  comparison minion  times seconds      sec  timeout  
table   shows results comparing bee using symb model minion constraint
solver  gent  jefferson    miguel         consider three different models minion 
 m    indicates results using bibd model described gent et al          symb uses
model use sat approach  symb    enhanced symmetry breaking
model tricks applied  m    model  columns
timeouts show total times  for bee includes compile time sat solving   note
using clever modeling problem improved previous run times
minion 
experiment indicates bee significantly faster minion bibd
models   m      tailoring symb model  minion becomes competitive
ours 
    combining bee satelite
demonstrate impact combining bee satelite  describe experiments involving two benchmarks satelite applied simplify output
bee  idea first apply powerful  local  techniques  performed bee 
reduces size cnf fast  apply satelite takes global
considerations cnf whole  wish determine smaller  simplified 
   

fiboolean equi propagation

cnf amenable simplification using satelite  results indicate
although cnf size slightly decreased  solving times often increased  sometimes
drastically 
tables     show results  tables four columns bee
heading indicate  bee compilation time  size encoding  clauses variables  
subsequent sat solving time  similarly  four columns satelite heading
indicate application satelite output bee  satelite processing time 
size resulting cnf  clauses variables   subsequent sat solving time 
table   illustrates results bibd benchmark section     table    results
   hardest vmtl instances k  k   described section      observe
applying satelite output bee decreases cnf size slightly
improve sat solving time  fact  contrary  cases renders cnf
takes time solve  several cases  sat solving time increases drastically
introduce timeout 
instance
 v  b  r  k   
                    
                    
                   
                   
                  
                  
                 
                 
                 
                 
                 

comp
 sec 
    
    
    
    
    
    
    
    
    
    
    

bee
clauses
vars
      
       
      
      
     
      
     
      
 
     
     

     
     
     
     
     
     
    
    
 
     
    

sat
 sec 
    
     
    
    
    
    
    
    
    
    
    

comp
 sec 
    
    
    
    
    
    
    
     
    
    
    

satelite
clauses
vars
      
       
      
      
     
      
     
      
 
     
     

     
     
     
     
     
     
    
    
 
     
    

sat
 sec 
    
    
    

    
    
    
    
    
     
    

table    bibd results  bee combined satelite      sec  timeout 
results demonstrate application satelite remove redundancies
cnf often non beneficial  presumably difference see application
satelite cnf benchmarks results fact bee produces highly
optimized cnf output  many cnf benchmarks significant inefficiency
original encoding  bee removes variable cnf  instantiates
variable  either constant equivalent variable  remove
potential propagations encoding  captured theorem   

   conclusion
considerable body work cnf simplification techniques clear trade off
amount reduction achieved invested time  approaches determine binary clauses implied cnf  certainly enough determine boolean
equalities  problem determining binary clauses implied cnf
prohibitive sat model may involve many  hundreds of  thousands variables 
   

fimetodi  codish    stuckey

instance

k 

k  

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

comp
 sec 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

bee
clauses
vars
      
      
      
      
      
      
      
      
      
      
       
       
       
       
       
       
       
       
       
       

    
    
    
    
    
    
    
    
    
    
     
     
     
     
     
     
     
     
     
     

sat
 sec 
    
     
    
     
    
     
     
     
      
     
     
     
       
      
      
      
      
       



comp
 sec 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

satelite
clauses
vars
      
      
      
      
      
      
      
      
      
      
       
       
       
       
       
       
       
       
       
       

    
    
    
    
    
    
    
    
    
    
     
     
     
     
     
     
     
     
     
     

sat
 sec 
    
    
     
    
    
     
     
     
      

      
      
      
     
       
       





table    vtml results  bee combined satelite    hour timeout 

typically implied binary clauses determined  visible
unit propagation  trade off regulated choice techniques applied infer
binary clauses  considering power cost  see example work een biere
       references therein  approaches  li        detect use
boolean equalities run time  complementary approach 
approach  beast tamed introducing notion locality 
consider full cnf  instead  maintaining original representation  conjunction
constraints  viewed boolean formula  apply powerful reasoning techniques
separate parts model maintain efficient pre processing 
end  introduce bee  compiler follows approach encode finite
domain constraints cnf  applying optimizations based ad hoc equi propagation
partial evaluation rules high level view problem allows us simplify problem
aggressively possible cnf representation  resulting cnf models
significantly smaller resulting straight translation 
well understood making cnf smaller ultimate goal  often smaller
cnfs harder solve  indeed  one often introduces redundancies improve sat
encodings  removing counterproductive  experience bee reduces
size encoding way productive subsequent sat solving 
particular  removing variables determined compile time definitely
equal  or definitely different  solution 
   

fiboolean equi propagation

bee uses ad hoc equi propagation partial evaluation rules keeps compilation
times typically small  measured seconds  even instances result several millions
cnf clauses  reduction sat solving time larger orders magnitude 
hence  believe boolean equi propagation makes important contribution
encoding csps sat 
bee currently tuned represent integers order encoding  ongoing work
aims extend bee binary additional number representations mixed radix
bases considered een sorensson        codish  fekete  fuhs 
schneider kamp        
acknowledgments
thank vitaly lagoon many insightful discussions concerning research 
nicta funded australian government represented department
broadband  communications digital economy australian research council ict centre excellence program 

references
ansotegui  c   del val  a   dotu  i   fernandez  c     manya  f          modeling choices
quasigroup completion  sat vs  csp  mcguinness  d  l     ferguson  g   eds   
aaai  pp          san jose  california  usa  aaai press   mit press 
asn  r   nieuwenhuis  r   oliveras  a     rodrguez carbonell  e          cardinality
networks  theoretical empirical study  constraints                 
bagnara  r     schachte  p          factorizing equivalent variable pairs robddbased implementations pos  haeberer  a  m   ed    algebraic methodology
software technology   th international conference  amast     amazonia  brasil 
january            proceedings  vol       lecture notes computer science  pp 
       
bailleux  o     boufkhad  y          efficient cnf encoding boolean cardinality constraints  rossi  f   ed    cp  vol       lncs  pp          kinsale  ireland 
springer 
barrett  c   stump  a     tinelli  c          satisfiability modulo theories library
 smt lib   www smt lib org 
batcher  k  e          sorting networks applications  afips spring joint
computing conference  vol     afips conference proceedings  pp          atlantic city  nj  usa  thomson book company  washington d c 
bessiere  c   katsirelos  g   narodytska  n     walsh  t          circuit complexity
decompositions global constraints  proceedings ijcai       pp         
cadoli  m     schaerf  a          compiling problem specifications sat  artificial
intelligence                   
   

fimetodi  codish    stuckey

codish  m   fekete  y   fuhs  c     schneider kamp  p          optimal base encodings
pseudo boolean constraints  abdulla  p  a     leino  k  r  m   eds    tacas 
vol       lecture notes computer science  pp          springer 
codish  m   lagoon  v     stuckey  p  j          logic programming satisfiability 
tplp                
codish  m     zazon ivry  m          pairwise cardinality networks  clarke  e  m    
voronkov  a   eds    lpar  dakar   vol       lecture notes computer science 
pp          springer 
coudert  o     madre  j  c          unified framework formal verification
sequential circuits  iccad  pp         
crawford  j  m     baker  a  b          experimental results application satisfiability algorithms scheduling problems  hayes roth  b     korf  r  e   eds   
aaai  vol     pp            seattle  wa  usa  aaai press   mit press 
een  n     biere  a          effective preprocessing sat variable clause
elimination  bacchus  f     walsh  t   eds    sat  vol       lecture notes
computer science  pp        springer 
een  n     sorensson  n          extensible sat solver  giunchiglia  e     tacchella  a   eds    sat  vol       lecture notes computer science  pp         
springer 
een  n     sorensson  n          translating pseudo boolean constraints sat  jsat 
             
frisch  a  m   jefferson  c     miguel  i          symmetry breaking prelude implied
constraints  constraint modeling pattern  proc    th euro  conf  ai         
pp          press 
frutos  a  g   liu  q   thiel  a  j   sanner  a  m  w   condon  a  e   smith  l  m    
corn  r  m          demonstration word design strategy dna computing
surfaces  journal nucleic acids research                    
gallian  j  a          dynamic survey graph labeling  electronic journal
combinatorics     
gavanelli  m          log support encoding csp sat  bessiere  c   ed   
cp  vol       lncs  pp          providence  ri  usa  springer 
gelder  a  v          toward leaner binary clause reasoning satisfiability solver  ann 
math  artif  intell                  
gent  i  p   jefferson  c     miguel  i          minion  fast scalable constraint solver 
brewka  g   coradeschi  s   perini  a     traverso  p   eds    ecai  vol     
frontiers artificial intelligence applications  pp         ios press 
gent  i  p     nightingale  p          new encoding alldifferent sat  proceedings
 rd international workshop modeling reformulating constraint satisfaction problems  http   www users cs york ac uk frisch reformulation    
proceedings pdf 
   

fiboolean equi propagation

gomes  c  p   selman  b     crato  n          heavy tailed distributions combinatorial
search  smolka  g   ed    cp  vol       lncs  pp          springer 
heule  m   jarvisalo  m     biere  a          efficient cnf simplification based binary
implication graphs  sakallah  k  a     simon  l   eds    sat  vol       lecture
notes computer science  pp          springer 
huang  j          universal booleanization constraint models  cp      vol      
lecture notes computer science  pp         
jager  g          effective sat encoding magic labeling  faigle  u   schrader  r  
  herrmann  d   eds    ctw  pp        
li  c          equivalent literal propagation dll procedure  discrete applied
mathematics                  
macdougall  j   miller  m   slamin  m     wallis  w          vertex magic total labelings
graphs  utilitas mathematica          
mancini  t   micaletto  d   patrizi  f     cadoli  m          evaluating asp commercial
solvers csplib  constraints                 
manthey  n          coprocessor       flexible cnf simplifier    tool presentation  
cimatti  a     sebastiani  r   eds    sat  vol       lecture notes computer
science  pp          springer 
metodi  a          bee  http   amit metodi me research bee  
metodi  a     codish  m          compiling finite domain constraints sat bee 
tplp                   
metodi  a   codish  m   lagoon  v     stuckey  p  j          boolean equi propagation
optimized sat encoding  lee  j  h  m   ed    cp  vol       lncs  pp         
springer 
nethercote  n   stuckey  p  j   becket  r   brand  s   duck  g  j     tack  g         
minizinc  towards standard cp modeling language  bessiere  c   ed    cp     
vol       lecture notes computer science  pp          providence  ri  usa 
springer verlag 
somenzi  f          cudd  colorado university decision diagram package   online 
accessed    april        http   vlsi colorado edu  fabio cudd  
soos  m          cryptominisat  v       http   www msoos org cryptominisat  
tamura  n   taga  a   kitagawa  s     banbara  m          compiling finite linear csp
sat  constraints                 
tarjan  r          efficiency good linear set union algorithm  jacm         
       
van hentenryck  p          opl optimization programming language  mit press 
van hoeve  w  j          alldifferent constraint  survey   corr http   arxiv org 
abs cs pl         

   


