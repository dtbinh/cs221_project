journal of artificial intelligence research                  

submitted        published      

numvc  an efficient local search algorithm
for minimum vertex cover
shaowei cai

shaoweicai   cs   gmail   com

key laboratory of high confidence software technologies
peking university  beijing  china

kaile su

k   su   griffith   edu   au

institute for integrated and intelligent systems
griffith university  brisbane  australia

chuan luo

chuanluosaber   gmail   com

key laboratory of high confidence software technologies
peking university  beijing  china

abdul sattar

a   sattar   griffith   edu   au

institute for integrated and intelligent systems
griffith university  brisbane  australia

abstract
the minimum vertex cover  mvc  problem is a prominent np hard combinatorial
optimization problem of great importance in both theory and application  local search has proved
successful for this problem  however  there are two main drawbacks in state of the art mvc local
search algorithms  first  they select a pair of vertices to exchange simultaneously  which is timeconsuming  secondly  although using edge weighting techniques to diversify the search  these
algorithms lack mechanisms for decreasing the weights  to address these issues  we propose two
new strategies  two stage exchange and edge weighting with forgetting  the two stage exchange
strategy selects two vertices to exchange separately and performs the exchange in two stages  the
strategy of edge weighting with forgetting not only increases weights of uncovered edges  but also
decreases some weights for each edge periodically  these two strategies are used in designing a
new mvc local search algorithm  which is referred to as numvc 
we conduct extensive experimental studies on the standard benchmarks  namely dimacs
and bhoslib  the experiment comparing numvc with state of the art heuristic algorithms
show that numvc is at least competitive with the nearest competitor namely pls on the
dimacs benchmark  and clearly dominates all competitors on the bhoslib benchmark  also 
experimental results indicate that numvc finds an optimal solution much faster than the current
best exact algorithm for maximum clique on random instances as well as some structured ones 
moreover  we study the effectiveness of the two strategies and the run time behaviour through
experimental analysis 

   introduction
the minimum vertex cover  mvc  problem consists of  given an undirected graph g    v  e  
finding the minimum sized vertex cover  where a vertex cover is a subset s  v such that every
edge in g has at least one endpoint in s  mvc is an important combinatorial optimization problem
with many real world applications  such as network security  scheduling  vlsi design and industrial
machine assignment  it is equivalent to two other well known combinatorial optimization problems 
the maximum independent set  mis  problem and the maximum clique  mc  problem  which
c
    
ai access foundation  all rights reserved 

fic ai   s u   l uo   s attar

have a wide range of applications in areas such as information retrieval  experimental design  signal
transmission  computer vision  and also bioinformatics problems such as aligning dna and protein
sequences  johnson   trick         indeed  these three problems can be seen as three different
forms of the same problem  from the viewpoint of practical algorithms  algorithms for mvc
can be directly used to solve the mis and mc problems  due to their great importance in theory
and applications  these three problems have been widely investigated for the last several decades
 carraghan   pardalos        evans        pullan   hoos        richter  helmert    gretton 
      cai  su    chen        li   quan      b  cai  su    sattar        
theoretical analyses indicate that these three problems mvc  mis  and mc are computationally
hard  they are all np hard and the associated decision problems are np complete  garey  
johnson         moreover  they are hard to solve approximately  it is np hard to approximate
mvc within any factor smaller than         dinur   safra         although one can achieve an
approximation ratio of    o     halperin        karakostas         besides the inapproximability
of mvc  hastad shows that both mis and mc are not approximable within  v    for any      
unless np zpp   hastad               recently  this conclusion has been enhanced that mc is
not approximable within  v    for any      unless np p  zuckerman         derived from a
derandomization of hastads result  moreover  the currently best polynomial time approximation
algorithm for mc is only guaranteed to find a clique within a factor of o n loglogn     logn     of
optimum  feige        
the algorithms to solve mvc  mis  mc  fall into two types  exact algorithms and heuristic
algorithms  exact methods which mainly include branch and bound algorithms  carraghan  
pardalos        fahle        ostergard        regin        tomita   kameda        li  
quan      b      a   guarantee the optimality of the solutions they find  but may fail to give a
solution within reasonable time for large instances  heuristic algorithms  which mainly include local
search algorithms  cannot guarantee the optimality of their solutions  but they can find optimal or
satisfactory near optimal solutions for large and hard instances within reasonable time  therefore 
it is appealing to use local search algorithms to solve large and hard mvc  mc  mis  instances 
early heuristic methods for maximum clique have been designed as initial responses to the
second dimacs implementation challenge  johnson   trick         where maximum clique is
one of the three challenge problems  after that  a huge amount of effort was devoted to designing
local search algorithms for mvc  mc and mis problems  aggarwal  orlin    tai        battiti  
protasi        busygin  butenko    pardalos        shyu  yin    lin        barbosa   campos 
      pullan        richter et al         andrade  resende    werneck        cai et al        
       a review of heuristic algorithms for these three problems can be found in a recent paper on
mvc local search  cai et al         
this work is devoted to a more efficient local search algorithm for mvc  typically  local search
algorithms for mvc solve the problem by iteratively solving the k vertex cover problem  to solve
the k vertex cover problem  they maintain a current candidate solution of size k  and exchange
two vertices iteratively until it becomes a vertex cover  however  we observe two drawbacks in
state of the art mvc local search algorithms  first  they select a pair of vertices for exchanging
simultaneously according to some heuristic  richter et al         cai et al                which is
rather time consuming  as will be explained in section    the second drawback is about the edge
weighting techniques  the basic concept of edge weighting is to increase weights of uncovered
   zpp is the class of problems that can be solved in expected polynomial time by a probabilistic algorithm with zero
error probability 

   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

edges to diversify the search  previous mvc local search algorithms utilize different edge weighting
schemes  for example  cover  richter et al         increases weights of uncovered edges at each
step  while ewls  cai et al         and ewcc  cai et al         increase weights of uncovered
edges only when reaching local optima  however  all these algorithms do not have a mechanism to
decrease the weights  we believe this is deficient because the weighting decisions made too long
ago may mislead the search 
to address these two issues in mvc local search algorithms  this paper proposes two new
strategies  namely two stage exchange and edge weighting with forgetting  the two stage exchange
strategy decomposes the exchanging procedure into two stages  i e   the removing stage and the
adding stage  and performs them separately  it first selects a vertex and removes it from the current
candidate solution  and then selects a vertex in a random uncovered edge and adds it  the twostage exchange strategy yields an efficient two pass move operator for mvc local search  in which
the first pass is a linear time search for the vertex to remove  while the second pass is a lineartime search for the vertex to add  this is in contrast to the standard quadratic  all at once move
operator  moreover  the two stage exchange strategy renders the algorithm more flexible in that
we can employ different heuristics in different stages  indeed  the numvc algorithm utilizes a
highly greedy heuristic for the removing stage  while for the adding stage  it makes good use of a
diversifying heuristic within a framework similar to focused random walk  papadimitriou        
the second strategy we propose is edge weighting with forgetting  it increases weights of
uncovered edges by one at each step  moreover  when the averaged edge weight achieves a
threshold  it reduces weights of all edges by multiplying a constant factor             to forget
the earlier weighting decisions  to the best of our knowledge  this is the first time a forgetting
mechanism is introduced into local search algorithms for mvc 
the two strategies are combined to design a new local search algorithm called numvc  we
carry out a detailed experimental study to investigate the performance of numvc  and compare
it with pls  pullan         cover  richter et al         and ewcc  cai et al          which
are leading heuristic algorithms for mvc  mc  mis   experimental results show that numvc
competes well with other solvers on the dimacs benchmark  and shows a dramatic improvement
over existing results on the whole bhoslib benchmark  these parts of work have been published
in an early version of this paper  cai  su    sattar        
in this paper  we additionally carry out more experimental analyses and provides further
insights about the two strategies in numvc  we compare numvc with the exact algorithm
maxclqdyn efl scr  li   quan      a   which is the best exact maximum clique algorithm
we found in the literature  experimental results indicate that numvc finds an optimal solution
much faster than the exact algorithm on random instances as well as some structured ones  more
importantly  we conduct experimental investigations to study the run time behaviour of numvc
and the effectiveness of the two new strategies in numvc 
the remainder of this paper is organized as follows  in the next section  we introduce some
definitions and notations used in this paper  we then present the two strategies  two stage exchange
and edge weighting with forgetting  in section    we describe the numvc algorithm  section  
presents the experimental study of numvc and comparative results to other algorithms  including
heuristic and exact algorithms  this is followed by more detailed investigations about the run time
behaviour of numvc and the effectiveness of the two new strategies in section    finally  we
conclude the paper by summarizing the main contributions and some future directions 
   

fic ai   s u   l uo   s attar

   preliminaries
an undirected graph g    v  e  consists of a vertex set v and an edge set e  v  v   where
each edge is a   element subset of v   for an edge e    u  v   we say that vertices u and v are the
endpoints of edge e  two vertices are neighbors if and only if they both belong to some common
edge  we denote n  v     u  v   u  v   e   the set of neighbors of a vertex v 
for an undirected graph g    v  e   an independent set is a subset of v with pairwise nonadjacent elements and a clique is a subset of v with pairwise adjacent elements  the maximum
independent set and maximum clique problems are to find the maximum sized independent set
and clique in a graph  respectively 
we note that these three problems mvc  mis and mc can be seen as three different forms of
the same problem  from the viewpoint of experimental algorithms  a vertex set s is an independent
set of g if and only if v  s is a vertex cover of g  a vertex set k is a clique of g if and only if v  k
is a vertex cover of the complementary graph g  to find the maximum independent set of a graph
g  one can find the minimum vertex cover cmin for g and return v  cmin   similarly  to find the

maximum clique of a graph g  one can find the minimum vertex cover cmin
for the complementary

graph g  and return v  cmin
 
given an undirected graph g    v  e   a candidate solution for mvc is a subset of vertices 
an edge e  e is covered by a candidate solution x if at least one endpoint of e belongs to
x  during the search procedure  numvc always maintains a current candidate solution  for
convenience  in the rest of this paper  we use c to denote the current candidate solution  the state
of a vertex v is denoted by sv          such that sv     means v  c  and sv     means v 
  c 
the step to a neighboring candidate solution consists of exchanging two vertices  a vertex u  c is
removed from c  and a vertex v 
  c is put into c  the age of a vertex is the number of steps since
its state was last changed 
as with most state of the art mvc local search algorithms  numvc utilizes an edge weighting
scheme  for edge weighting local search  we follow the definitions and notations in ewcc  cai
et al          an edge weighted undirected graph is an undirected graph g    v  e  combined with
a weighting function w so that each edge e  e is associated with a non negative integer number
w e  as its weight  we use w to denote the mean value of all edge weights 
let w be a weighting function for g  for a candidate solution x  we set the cost of x as
x

cost g  x   

w e 

ee and e is not covered by x

which indicates the total weight of edges uncovered by x  we take cost g  x  as the evaluation
f unction  and numvc prefers candidate solutions with lower costs 
for a vertex v  v  
dscore v    cost g  c   cost g  c   
where c    c  v  if v  c  and c    c   v  otherwise  measuring the benefit of changing the
state of vertex v  obviously  for a vertex v  c  we have dscore v      and the greater dscore
indicates the less loss of covered edges by removing it out of c  for a vertex v 
  c  we have
dscore v      and the higher dscore indicates the greater increment of covered edges by adding
it into c 
   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

   two stage exchange
in this section  we introduce the two stage exchange strategy  which is adopted by the numvc
algorithm to exchange a pair of vertices 
as with most state of the art mvc local search algorithms  numvc is an iterated k vertex
cover algorithm  when finding a k vertex cover  numvc removes one vertex from the current
candidate solution c and goes on to search for a  k     vertex cover  in this sense  the core of
numvc is a k vertex cover algorithm  given a positive integer number k  searching for a k sized
vertex cover  to find a k vertex cover  numvc begins with a candidate solution c of size k  and
exchanges two vertices iteratively until c becomes a vertex cover 
most local search algorithms for mvc select a pair of vertices to exchange simultaneously
according to a certain heuristic  for example  cover selects a pair of vertices that maximize
gain u  v   richter et al          while ewls  cai et al         and ewcc  cai et al         select
a random pair of vertices with score u  v       this strategy of selecting two vertices to exchange
simultaneously leads to a quadratic neighborhood for candidate solutions  moreover  the evaluation
of a pair of vertices not only depends on the evaluations  such as dscore  of the two vertices  but also
involves the relationship between the two vertices  like do they belong to a same edge  therefore 
it is rather time consuming to evaluate all candidate pairs of vertices 
in contrast to earlier mvc local search algorithms  numvc selects the two vertices for
exchanging separately and exchanges the two selected vertices in two stages  in each iteration 
numvc first selects a vertex u  c with the highest dscore and removes it  after that  numvc
selects a uniformly random uncovered edge e  and chooses one endpoint v of e with the higher
dscore under some restrictions and adds it into c  note that this two stage exchange strategy
resembles in some respect the min conflicts hill climbing heuristic for csp  minton  johnston 
philips    laird         which shows surprisingly good performance for the n queens problem 
selecting the two vertices for exchanging separately may in some cases miss some greedier
vertex pairs which consist of two neighboring vertices  however  as is usual in local search
algorithms  there is a trade off between the accuracy of heuristics and the complexity per step 
let r and a denote the set of candidate vertices for removing and adding separately  the time
complexity per step for selecting the exchanging vertex pair simultaneously is  r    a   while the
complexity per step for selecting the two vertices separately  as in numvc  is only  r     a   it
is worthy to note that  as heuristics in a local search algorithm are often based on intuition and
experience rather than on theoretically or empirically derived principles and insights  we cannot say
for certain that being less greedy is not a good thing  hoos   stutzle         on the other hand  a
lower time complexity is always desirable 

   edge weighting with forgetting
in this section  we present a new edge weighting technique called edge weighting with forgetting 
which plays an important role in numvc 
the proposed strategy of edge weighting with forgetting works as follows  each edge is
associated with a positive integer number as its weight  and each edge weight is initialized as one 
then in each iteration  edge weights of the uncovered edges are increased by one  moreover  when
the average weight achieves a threshold  all edge weights are reduced to forget the earlier weighting
decisions using the formula w e       w e   where  is a constant factor between   and   
   

fic ai   s u   l uo   s attar

note that edge weighting techniques in mvc local search  including the one in this work 
fall in the more general penalty idea for optimization problems  which dates back to morris s
breakout method  morris        and has been widely used in local search algorithms for constraint
optimization problems such as sat  yugami  ohta    hara        wu   wah        schuurmans 
southey    holte        hutter  tompkins    hoos         our results therefore provide further
evidence for the effectiveness and general applicability of this algorithmic technique 
edge weighting techniques have been successfully used to improve mvc local search
algorithms  for example  cover  richter et al         updates edge weights at each step  while
ewls  cai et al         and ewcc  cai et al         update edge weights only when reaching local
optima  however  all previous edge weighting techniques do not have a mechanism to decrease the
weights  which limits their effectiveness  the strategy of edge weighting with forgetting in this
work introduces a forgetting mechanism to reduce edge weights periodically  which contributes
considerably to the numvc algorithm 
the intuition behind the forgetting mechanism is that the weighting decisions made too long ago
are no longer helpful and may mislead the search  and hence should be considered less important
than the recent ones  for example  consider two edges e  and e  with w e           and w e     
    at some step  we use w e  to denote the increase of w e   according to the evaluation
function  in the next period of time  the algorithm is likely to cover e  more frequently than e    and
we may assume that during this period w e         and w e           which makes w e     
                 and w e                       without a forgetting mechanism  the algorithm
would still prefer e  to e  to be covered in the future search  this is not reasonable  as during this
period e  is covered in much fewer steps than e  is  thus  e  should take priority to be covered for
the sake of diversification  now let us consider the case with the forgetting mechanism  assuming
       which is the setting in our experiments   suppose w e           and w e         
when the algorithm performs the forgetting  the forgetting mechanism reduces the edge weights as
w e                    and w e                   after a period of time  with w e        
and w e           we have w e                     and w e                      in this case 
the algorithm prefers to cover e  rather than cover e  in the future search  as we expect 
although being inspired by smoothing techniques in clause weighting local search algorithms
for sat  the forgetting mechanism in numvc differs from those smoothing techniques in sat
local search algorithms  according to the way that clause weights are smoothed  there are three
main smoothing techniques in clause weighting local search algorithms for sat to the best of our
knowledge  the first is to pull all clause weights to their mean value using the formula wi   
  wi          w  as in esg  schuurmans et al          saps  hutter et al         and swcca
 cai   su         the second is to subtract one from all clause weights which are greater than
one  as in dlm  wu   wah        and paws  thornton  pham  bain    jr          and the last
is employed in ddwf  ishtaiwi  thornton  sattar    pham         which transfers weights from
neighbouring satisfied clauses to unsatisfied ones  it is obvious that the forgetting mechanism in
numvc is different from all these smoothing techniques 
recently  a forgetting mechanism was proposed for vertex weighting technique in the significant
mc local search algorithm dls mc  pullan   hoos         which is an important sub algorithm in
pls  pullan        and cls  pullan  mascia    brunato         the dls mc algorithm employs
a vertex weighting scheme which increases the weights of vertices  by one  not in the current clique
when reaching a local optimum  and periodically decreases weights  by one  for all vertices that
currently have a penalty  specifically  it utilizes a parameter pd  penalty delay  to specify the
   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

number of penalty increase iterations that must occur before the algorithm performs a forgetting
operation  however  pullan and hoos also observed that dls mc is very sensitive to the pd
parameter  and the optimal value of pd varies considerably among different instances  indeed 
the performance of dls mc in is given by optimizing the pd parameter  in contrast  the forgetting
mechanism in numvc is much less sensitive to its parameters  as will be shown in section      
and thus is more robust 
we also notice that the formula used in the forgetting mechanism in numvc has been adopted
in long term frequency based learning mechanisms for tabu search  taillard         however  in
taillars algorithm  the parameter   using the term in this work  is always greater than one  and the
formula is used for penalizing a move rather than forgetting the penalties 

   the numvc algorithm
in this section  we present the numvc algorithm  which utilizes the strategies of two stage
exchange and edge weighting with forgetting 
algorithm    numvc
 

 
 
 
 
 
 
 
 
  
  
  

  
  
  

  
  
  
  
  

numvc  g cutoff 
input  graph g    v  e   the cutoff time
output  vertex cover of g
begin
initialize edge weights and dscores of vertices 
initialize the confchange array as an all   array 
construct c greedily until it is a vertex cover 
c     c 
while elapsed time   cutoff do
if there is no uncovered edge then
c     c 
remove a vertex with the highest dscore from c 
continue 
choose a vertex u  c with the highest dscore  breaking ties in favor of the oldest
one 
c    c  u   confchange u       and confchange z       for each z  n  u  
choose an uncovered edge e randomly 
choose a vertex v  e such that confchange v      with higher dscore  breaking ties
in favor of the older one 
c    c   v   confchange z       for each z  n  v  
w e     w e      for each uncovered edge e 
if w   then w e       w e  for each edge e 
return c   
end

for better understanding the algorithm  we first describe a strategy called configuration checking
 cc   which is used in numvc  the cc strategy  cai et al         was proposed for handling the
   

fic ai   s u   l uo   s attar

cycling problem in local search  i e   revisiting a candidate solution that has been visited recently
 michiels  aarts    korst         this strategy has been successfully applied in local search
algorithms for mvc  cai et al         as well as sat  cai   su              
the cc strategy in numvc works as follows  for a vertex v 
  c  if all its neighboring vertices
never change their states since the last time v was removed from c  then v should not be added
back to c  the cc strategy can be seen as a prohibition mechanism  which shares the same spirit
but differs from the well known prohibition mechanism called tabu  glover        
an implementation of the cc strategy is to maintain a boolean array confchange for vertices 
during the search procedure  those vertices which have a confchange value of   are forbidden to
add into c  the confchange array is initialized as an all   array  after that  when a vertex v is
removed from c  confchange v  is reset to    and when a vertex v changes its state  for each
z  n  v   confchange z  is set to   
we outline the numvc algorithm in algorithm    as described below  in the beginning  all edge
weights are initialized as    and dscores of vertices are computed accordingly  confchange v  is
initialized as   for each vertex v  then the current candidate solution c is constructed by iteratively
adding the vertex with the highest dscore  ties are broken randomly   until it becomes a vertex
cover  finally  the best solution c  is initialized as c 
after the initialization  the loop  lines       is executed until a given cutoff time is reached 
during the search procedure  once there is no uncovered edge  which means c is a vertex cover 
numvc updates the best solution c  as c  line     then it removes one vertex with the highest
dscore from c  line      breaking ties randomly  so that it can go on to search for a vertex cover
of size  c     c        we note that  in c  the vertex with the highest dscore has the minimum
absolute value of dscore since all these dscores are negative 
in each iteration of the loop  numvc swaps two vertices according to the strategy of two stage
exchange  lines         specifically  it first selects a vertex u  c with the highest dscore to
remove  breaking ties in favor of the oldest one  after removing u  numvc chooses an uncovered
edge e uniformly at random  and selects one of es endpoints to add into c as follows  if there is
only one endpoint whose confchange is    then that vertex is selected  if the confchange values
of both endpoints are    then numvc selects the vertex with the higher dscore  breaking ties in
favor of the older one  the exchange is finished by adding the selected vertex into c  along with
exchanging the two selected vertices  the confchange array is updated accordingly 
at the end of each iteration  numvc updates the edge weights  lines         first  weights of
all uncovered edges are increased by one  moreover  numvc utilizes the forgetting mechanism to
decrease the weights periodically  in detail  if the averaged weight of all edges achieves a threshold
  then all edge weights are multiplied by a constant factor             and rounded down to an
integer as edge weights are defined as integers in numvc  the forgetting mechanism forgets the
earlier weighting decision to some extent  as these past effects are generally no longer helpful and
may mislead the search 
we conclude this section by the following observation  which guarantees the executability of
line    
proposition    for an uncovered edge e  there is at least one endpoint v of edge e such that
confchange v      
proof  let us consider an arbitrary uncovered edge e    v    v     the proof includes two cases 
 a  there is at least one of v  and v  which never changes its state after initialization  without
   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

loss of generality  we assume v  is such a vertex  in the initialization  confchange v    is set to
   after that  only removing v  from c  which corresponds to vs state sv changing to   from
   can make confchange v    be    but v  never changes its state after initialization  so we have
confchange v       
 b  both v  and v  change their states after initialization  as e is uncovered  we have v  
  c and
v  
  c  without loss of generality  we assume the last removing of v  happens before the last
removing of v    the last time v  is removed  v   c holds  afterwards  v  is removed  which
means v  changes its state  so confchange v    is set to   as v   n  v    

   empirical results
in this section  we present a detailed experimental study to evaluate the performance of numvc
on standard benchmarks in the literature  i e   the dimacs and bhoslib benchmarks  we first
introduce the dimacs and bhoslib benchmarks  and describe some preliminaries about the
experiments  then  we divide the experiments into three parts  the purpose of the first part is to
demonstrate the performance of numvc in detail  the second is to compare numvc with state ofthe art heuristic algorithms  finally  the last part is to compare numvc with state of the art exact
algorithms 
    the benchmarks
having a good set of benchmarks is fundamental to demonstrate the effectiveness of new solvers 
we use the two standard benchmarks in mvc  mis  mc  research  the dimacs benchmark and
the bhoslib benchmark  the dimacs benchmark includes instances from industry and those
generated by various models  while the bhoslib instances are random ones of high difficulty 
      dimacs b enchmark
the dimacs benchmark is taken from the second dimacs implementation challenge for the
maximum clique problem                thirty seven graphs were selected by the organizers for
a summary to indicate the effectiveness of algorithms  comprising the second dimacs challenge
test problems  these instances were generated from real world problems such as coding theory 
fault diagnosis  kellers conjecture and the steiner triple problem  etc  and random graphs in
various models  such as the brock and p hat families  these instances range in size from less
than    vertices and       edges to greater than       vertices and           edges  although being
proposed two decades ago  the dimacs benchmark remains the most popular benchmark and has
been widely used for evaluating heuristic algorithms for mvc  richter et al         pullan       
cai et al         gajurel   bielefeld         mis  andrade et al         pullan        and mc
algorithms  pullan        katayama  sadamatsu    narihisa        grosso  locatelli    pullan 
      pullan et al         wu  hao    glover         in particular  the dimacs benchmark has
been used for evaluating cover and ewcc  it is convenient for us to use this benchmark also
to conduct experiments comparing numvc with cover and ewcc  note that as the dimacs
graphs were originally designed for the maximum clique problem  mvc algorithms are tested on
their complementary graphs 
   ftp   dimacs rutgers edu pub challenges

   

fic ai   s u   l uo   s attar

      bhoslib b enchmark
the bhoslib   benchmarks with hidden optimum solutions  instances were generated randomly
in the phase transition area according to the model rb  xu  boussemart  hemery    lecoutre 
       generally  those phase transition instances generated by model rb have been proved to
be hard both theoretically  xu   li        and practically  xu   li        xu  boussemart 
hemery    lecoutre         the sat version of the bhoslib benchmark is extensively used
in the sat competitions    nevertheless  sat solvers are much weaker than mvc solvers on these
problems  which remains justifiable when referring to the results of sat competition      on this
benchmark  the bhoslib benchmark is famous for its hardness and influential enough to be
strongly recommended by the mvc  mc  mis  community  grosso et al         cai et al         
it has been widely used in the recent literature as a reference point for new local search solvers to
mvc  mc and mis    besides these    instances  there is a large instance frb       with      
vertices and         edges  which is designed for challenging mvc  mc  mis  algorithms 
the bhoslib benchmark was designed for mc  mvc and mis  and all the graphs in this
benchmark are expressed in two formats  i e   the clq format and the mis format  for a bhoslib
instance  the graph in clq format and the one in mis format are complementary to each other  mc
algorithms are tested on the graphs in clq format  while mvc and mis algorithms are tested on
those in mis format 
    experiment preliminaries
before we discuss the experimental results  let us introduce some preliminary information about our
experiments 
numvc is implemented in c    the codes of both numvc and ewcc are publicly available
on the first authors homepage    the codes of cover are downloaded online    and those of pls
are kindly provided by its authors  all the four solvers are compiled by g   with the  o  option 
all experiments are carried out on a machine with a   ghz intel core   duo cpu e     and  gb
ram under linux  to execute the dimacs machine benchmarks    this machine requires     
cpu seconds for r            cpu seconds for r      and      cpu seconds for r      
for numvc  we set        v   and        for all runs  except for the challenging instance
frb        where         and         note that there are also parameters in other state ofthe art mvc  mc  mis  algorithms  such as dls mc  pullan   hoos        and ewls  cai et al  
       moreover  the parameters in dls mc and ewls vary considerably on different instances 
for each instance  each algorithm is performed     independent runs with different random seeds 
where each run is terminated upon reaching a given cutoff time  the cutoff time is set to     
seconds for all instances except for the challenging instance frb        for which the cutoff
time is set to      seconds due to its significant hardness 
for numvc  we report the following information for each instance 
 the optimal  or minimum known  vertex cover size  v c    
  
  
  
  
  
  

http   www nlsde buaa edu cn kexu benchmarks graph benchmarks htm
http   www satcompetition org
http   www nlsde buaa edu cn kexu benchmarks list graph papers htm
http   www shaoweicai net research html
http   www informatik uni freiburg de srichter 
ftp   dimacs rutgers edu pub dsj clique 

   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

 the number of successful runs  suc   a run is said successful if a solution of size v c  is
found 
 the vc size which shows the min  average  max  vertex cover size found by numvc in
    runs 
 the averaged run time over all     runs  time   the run time of a successful run is the
time to find the v c  solution  and that of a failed run is considered to be the cutoff time  for
instances where numvc does not achieve a      success rate  we also report the averaged
run time over only successful runs  suc time   the run time is measured in cpu seconds 
 the inter quartile range  iqr  of the run time for     runs  the iqr is the difference between
the   th percentile and the   th percentile of a sample  iqr is one of the most famous robust
measures in data analysis  hoaglin  mosteller    tukey         and has been recommended
as a measurement of closeness of the sampling distribution by the community of experimental
algorithms  bartz beielstein  chiarandini  paquete    preuss        
 the number of steps averaged over all     runs  steps   the steps of a successful run is
those needed to find the v c  solution  while the steps of a failed run are those executed
before the running is cut off  for instances where numvc does not achieve a      success
rate  we also report the averaged steps over only successful runs  suc steps  
if there are no successful runs for an instance  the time and steps columns are marked with
n a  when the success rate of a solver on an instance is less than      the   th percentile of the
run time sample is just the cutoff time and does not represent the real   th percentile  in this case 
we do not report the iqr  and instead we mark with n a on the corresponding column  actually 
if the success rate of a solver on a certain instance is less than      the solver should be considered
not robust on that instance given the cutoff time 
    performance of numvc
in this section  we report a detailed performance of numvc on the two benchmarks 
      p erformance of n u mvc

on

dimacs b enchmark

the performance results of numvc on the dimacs benchmark are displayed in table    numvc
finds optimal  or best known  solutions for    out of    dimacs instances  note that the   failed
instances are both brock graphs  furthermore  among the    successful instances  numvc does
so consistently  i e   in all     runs  for    instances     of which are solved within   second 
overall  the numvc algorithm exhibits excellent performance on the dimacs benchmark except
for the brock graphs  remark that the brock graphs are artificially designed to defeat greedy
heuristics by explicitly incorporating low degree vertices into the optimal vertex cover  indeed 
most algorithms preferring higher degree vertices such as grasp  rls  k opt  cover and ewcc
also failed in these graphs 
      p erformance of n u mvc

on

bhoslib b enchmark

in table    we illustrate the performance of numvc on the bhoslib benchmark  numvc
successfully solves all bhoslib instances in terms of finding an optimal solution  and the size
   

fic ai   s u   l uo   s attar

graph
instance vertices
brock     
brock     
brock     
brock     
brock     
brock     
c     
c     
c     
c      
c      
c      
c      
dsjc     
dsjc      
gen    p      
gen    p      
gen    p      
gen    p      
gen    p      
hamming   
hamming    
keller 
keller 
keller 
mann a  
mann a  
mann a  
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat      
p hat      
p hat      

   
   
   
   
   
   
   
   
   
    
    
    
    
   
    
   
   
   
   
   
   
    
   
   
    
   
    
    
   
   
   
   
   
   
    
    
    

v c

suc

vc size

   

   
   
  
   
 
 
   
   
   
   
   
 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
  
   
   
   
   
   
   
   
   
   

   
   
               
   
   
   
  
   
   
   
    
                  
    
   
   
   
   
   
   
   
   
   
   
   
    
   
   
                  
   
   
   
   
   
   
    
    
    

   
   
   
   
   
  
   
   
   
    
    
    
   
   
   
   
   
   
   
   
   
   
   
    
   
   
    
   
   
   
   
   
   
    
    
    

numvc
time suc time 
     
     
                
     
n a
n a
       
       

     
     
     
                  
       
     
     
       
       

     
       
       
       

     
       

     
    
       

      
                 
     
       

     
     
     
     
     
     
     

steps suc steps 
      
       
                    
       
n a
n a
   
    
      
       
      
                    
       
    
      
    
  
     
    
   
 
     
  
     
      
    
        
                    
   
  
    
    
    
    
      
    
     

table    numvc performance results  averaged over     independent runs  for the dimacs
benchmark instances  the vc column marked with an asterisk means that the minimum
known vertex cover size has been proved optimal 

   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

of the worst solution it finds never exceeds v c       numvc finds optimal solutions with     
success rate for    out of these    instances  and the averaged success rate over the remaining  
instances is         these results are dramatically better than existing results in the literature on
this benchmark  also  numvc finds a sub optimal solution of size v c      for all bshoslib
instances very quickly  always in less than    seconds  this indicates numvc can be used to
approximate the mvc problem efficiently even under very limited time 
besides the    bhoslib instances in table    there is a challenging instance frb       
which has a hidden minimum vertex cover of size       the designer of the bhoslib benchmark
conjectured that this instance will not be solved on a pc in less than a day within the next two
decades    the latest record for this challenging instance is a      sized vertex cover found by
ewls  and also ewcc 
we run numvc     independent trials within      seconds on frb        with        
and         this parameter setting yields the best performance among all combinations from
                         and                         among these     runs    runs find a      sized
solution with the averaged time of      seconds  and    runs find a      sized solution  including
     sized  with the averaged time of      seconds  also  it is interesting to note that numvc
can locate a rather good approximate solution for this hard instance very quickly  the size of vertex
covers that numvc finds within     seconds is between      and      
generally  finding a  k    vertex cover is much easier than a k vertex cover  hence  for
numvc  as well as most other mvc local search algorithms which also solve the mvc problem
by solving the k vertex cover problem iteratively  the majority of running time is used in finding
the best vertex cover c   of the run   and in trying  without success  to find a vertex cover of size
  c        
    comparison with other heuristic algorithms
in the recent literature there are five leading heuristic algorithms for mvc  mc  mis   including
three mvc algorithms cover  richter et al          ewls  cai et al         and ewcc  cai
et al          and two mc algorithms dls mc  pullan   hoos        and pls  pullan        
note that ewcc and pls are the improved versions of ewls and dls mc respectively  and show
better performance over their original versions on dimacs and bhoslib benchmarks  therefore 
we compare numvc only with pls  cover and ewcc 
when comparing numvc with other heuristic algorithms  we report v c    suc  time as well
as iqr  the averaged run time over only successful runs  suc time  cannot indicate comparative
performance of algorithms correctly unless the evaluated algorithms have close success rates  and
f     suc 
can be calculated by time   cutof
  so we do not report these statistics  the results
suc
in bold indicate the best performance for an instance 
      c omparative r esults

on

dimacs b enchmark

the comparative results on the dimacs benchmark are shown in table    most dimacs instances
are so easy that they can be solved by all solvers with      success rate within   seconds  and thus
are not reported in the table  actually  the fact that the dimacs benchmark has been reduced to   
useful instances really emphasizes the need to make a new benchmark 
   http   www nlsde buaa edu cn kexu benchmarks graph benchmarks htm

   

fic ai   s u   l uo   s attar

graph
instance vertices
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

v c
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

suc

vc size

numvc
time  suc time 

steps  suc steps 

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
  
   
   
  
   
   
   
   
   
  
   
   
   
  
  
  
  
   

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
    
                  
    
    
                  
    
    
    
    
    
                  
    
    
    
                  
                  
                  
                  
    

     
     
     
     
     
     
     
     
     
     
     
     
     
     
      
     
     
      
     
      
      
       
                
    
      
                
       
      
       
      
       
                
       
      
      
                
                  
                
                 
      

     
     
      
     
      
      
      
      
      
      
      
       
      
       
       
       
       
        
       
       
        
         
                    
       
        
                    
         
        
         
        
         
                    
        
        
        
                    
                    
                    
                    
        

table    numvc performance results  averaged over     independent runs  for the bhoslib
benchmark instances  all these bhoslib instances have a hidden optimal vertex cover 
whose size is shown in the vc column 

as indicated in table    numvc outperforms cover and ewcc on all instances  and is
competitive with and complementary to pls  for the eight hard instances on which at least one
solver fails to achieve a      success rate  pls dominates on the brock graphs while numvc
dominates on the others  including the two putatively hardest instances c       and mann a  
 richter et al         grosso et al         cai et al          as well as keller  and mann a   
   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

graph
instance

v c

suc

pls
time  iqr 

suc

brock     
brock     
brock     
brock     
c      
c      
gen    p      
keller 
mann a  
mann a  
p hat      

   
   
   
   
    
    
   
    
   
    
    

   
   
   
   
 
   
   
  
 
 
   

           
           
           
           
n a
       
          
         
      n a 
n a
           

 
  
 
 
 
   
   
   
  
 
   

cover
time  iqr 
      n a 
         
n a
n a
n a
         
          
      
         
      n a 
             

suc

ewcc
time  iqr 

suc

numvc
time  iqr 

  
   
 
 
 
   
   
   
  
 
   

      n a 
             
n a
n a
n a
         
           
           
         
      n a 
           

  
   
 
 
 
   
   
   
   
  
   

         
           
n a
n a
      n a 
        
           
           
       
      n a 
           

table    comparison of numvc with other state of the art heuristic algorithms on the dimacs
benchmark  the vc column marked with an asterisk means that the minimum known
vertex cover size has been proved optimal 

for c        only numvc finds a      sized solution  and it also finds a      sized solution in
   runs  while this number is       and    for pls  cover  and ewcc respectively  note that
pls performs well on the brock family because it comprises three sub algorithms  one of which
favors the lower degree vertices 
table   indicates that c       and mann a   remain very difficult for modern algorithms 
as none of the algorithms can solve them with a good success rate in reasonable time  on the other
hand  other instances can be solved quickly  in less than     seconds  by at least one algorithm  pls
or numvc  with a low iqr value  always less than       which indicates quite stable performance 
      c omparative r esults

on

bhoslib b enchmark

in table    we present comparative results on the bhoslib benchmark  for concentrating on the
considerable gaps in comparisons  we do not report the results on the two groups of small instances
 frb   and frb     which can be solved within several seconds by all solvers 
the results in table   illustrate that numvc significantly outperforms the other algorithms
on all bhoslib instances  in terms of both success rate and averaged run time  which are also
demonstrated in figure    we take a further look at the comparison between numvc and ewcc 
as ewcc performs obviously better than pls and cover on this benchmark  numvc solves   
instances out of    with      success rate    more instances than ewcc does  for those instances
solved by both algorithms with      success rate  the overall averaged run time is    seconds
for numvc and    seconds for ewcc  for other instances  the averaged success rate is     for
numvc  compared to     for ewcc 
the excellent performance of numvc is further underlined by the large gaps between numvc
and the other solvers on the hard instances  for example  on the instances where all solvers fail
to find an optimal solution with      success rate  numvc achieves an overall averaged success
rate of         dramatically better than those of pls  cover and ewcc  which are       
       and        respectively  obviously  the experimental results show that numvc delivers
   

fic ai   s u   l uo   s attar

graph
instance

v c

suc

pls
time  iqr 

suc

frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       

   
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

   
   
   
   
  
   
   
  
   
   
  
 
 
   
  
 
 
  
  
  
 
 
 
  
  
 
 
 
 
  

             
             
            
             
            
            
           
      n a 
         
         
          
      n a 
      n a 
       
          
      n a 
      n a 
      n a 
      n a 
      n a 
      n a 
n a
n a
      n a 
      n a 
n a
n a
      n a 
n a
          

   
   
   
   
   
   
   
   
   
   
   
  
  
   
   
  
  
  
  
  
  
  
  
  
   
  
 
  
 
  

cover
time  iqr 
           
             
        
            
         
            
         
         
       
          
         
      n a 
      n a 
       
         
      n a 
      n a 
         
      n a 
         
      n a 
      n a 
         
         
         
      n a 
      n a 
      n a 
      n a 
         

suc

ewcc
time  iqr 

suc

   
   
   
   
   
   
   
   
   
   
   
  
  
   
   
  
  
   
  
   
  
  
   
   
   
  
 
  
  
   

           
             
           
             
             
          
         
         
         
         
         
          
      n a 
       
       
      n a 
           
         
          
         
      n a 
      n a 
         
         
       
      n a 
      n a 
      n a 
      n a 
         

   
   
   
   
   
   
   
   
   
   
   
   
  
   
   
  
   
   
   
   
   
  
   
   
   
  
  
  
  
   

numvc
time  iqr 
           
           
           
           
             
          
       
         
       
         
       
         
         
     
       
          
         
       
         
       
         
         
         
       
       
         
      n a 
         
           
       

table    comparison of numvc with other state of the art local search algorithms on the
bhoslib benchmark  all these bhoslib instances have a hidden optimal vertex cover 
whose size is shown in the vc column 

   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

   

    

  

    

  

    

  

    
average run time  s 

average success rate

the best performance for this hard random benchmark  vastly improving the existing performance
results  we also observe that  numvc always has the minimum iqr value for all instances  which
indicates that apart from its efficiency  the robustness of numvc is also better than other solvers 

  
  
  
  
  

    
    
   

pls
cover
ewcc
numvc

   
   

  
 
    frb   

pls
cover
ewcc
numvc

   
    frb   

 
    frb   

     frb        frb         frb         frb   
number of vertices in graph

    frb   

     frb        frb         frb         frb   
number of vertices in graph

figure    comparison of numvc and other local search algorithms on the bhoslib benchmark
in terms of success rate  left  and averaged run time  right 
we also compare numvc with cover and ewcc on the challenging instance frb       
given the failure of pls on large bhoslib instances  we do not run pls on this instance 
the comparative results on frb       are shown in table    which indicates that numvc
significantly outperforms cover and ewcc on this challenging instance 
finally  we would like to remark that the performance of numvc on the bhoslib benchmark
is better than a four core version of cls  pullan et al          even if we do not divide the run time
of numvc by    the number of cores utilized by cls   if we consider the machine speed ratio and
divide the run time of numvc by    then numvc would be dramatically better than cls on the
bhoslib benchmark 
size
of vc
    
     

suc
 
  

cover
avg suc time
n a
    

suc
 
  

ewcc
avg suc time
    
    

suc
 
  

numvc
avg suc time
    
    

table    comparative results on the frb       challenging instance  each solver is executed
    times on this instance with a timeout of      seconds 

    comparison with exact algorithms
in this section  we compare numvc with a state of the art exact maximum clique algorithm 
generally  exact algorithms and heuristic algorithms are somewhat complementary in their
applications  usually  exact algorithms find solutions for structured instances faster while heuristic
algorithms are faster on random ones 
   

fic ai   s u   l uo   s attar

compared to mvc and mis  many more exact algorithms are designed for the maximum clique
problem  carraghan   pardalos        fahle        ostergard        regin        tomita  
kameda        li   quan      b      a   the recent branch and bound mc algorithm maxclq
 li   quan      b  which utilizes maxsat inference technologies  li  manya    planes       
to improve upper bounds shows considerable progress  experimental results of maxclq  li  
quan      b  on some random graphs and dimacs instances indicate that maxclq significantly
outperforms previous exact mc algorithms  the maxclq algorithm is further improved using two
strategies called extended failed literal detection and soft clause relaxation  resulting in a better
algorithm denoted by maxclqdyn efl scr  li   quan      a   due to the great success of
maxclqdyn efl scr  we compare our algorithm only with maxclqdyn efl scr 
we compare numvc with maxclqdyn efl scr on the dimacs benchmark instances 
the results of maxclqdyn efl scr are taken from the previous work  li   quan      a  
maxclqdyn efl scr is not evaluated on the bhoslib benchmark which is much harder and
requires more effective technologies for exact algorithms  li   quan      a  
the run time results of maxclqdyn efl scr are obtained on a      ghz intel core   duo
cpu with linux and   gb memory  which required       seconds for r             seconds for
r      and       seconds for r      to execute the dimacs machine benchmarks  li   quan 
    a   the corresponding run time for our machine is            and      seconds  so  we multiply
the reported run time of maxclqdyn efl scr by                                          the
average of the two largest ratios   this normalization is based on the methodology established in
the second dimacs implementation challenge for cliques  coloring  and satisfiability  and is
widely used for comparing different maxclique algorithms  pullan   hoos        pullan        li
  quan      b      a  
graph
instance
brock     
brock     
brock     
brock     
brock     
brock     
keller 
mann a  
mann a  

v c

   
   
   
   
   
   
   
   
   

numvc
suc
time
  
   
   
 
 
 
   
   
   

      
    
    
n a
n a
n a
    
      
     

maxclqdyn efl
 scr time
      
      
      
       
       
       
       
    
      

graph
instance

v c

numvc
suc
time

p hat     
p hat     
p hat     
p hat      
p hat      
p hat      
p hat      
sanr       
sanr       

   
   
   
   
   
    
    
   
   

   
   
   
   
   
   
   
   
   

     
     
     
     
     
    
     
      
     

maxclqdyn efl
 scr time
    
    
       
      
         
    
      
    
     

table    comparison of numvc with the state of the art exact maxclique algorithm maxclqdyn efl scr for the dimacs benchmark 

in table    we present the performance of numvc and maxclqdyn efl scr on the
dimacs instances  the results indicate that numvc finds an optimal solution much faster
than maxclqdyn efl scr on random instances such as the p hat and sanr instances  we
believe that similar results would hold for other hard random benchmarks like bhoslib ones  as
maxclqdyn efl scr is not evaluated on these instances due to their high hardness  li   quan 
    a   while numvc performs very well on them 
for structured instances  we note that maxclqdyn efl scr is mainly evaluated on the
brock instances where numvc performs worst  but not on the open dimacs instances such
   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

as mann a    johnson       and keller   which remain very difficult to solve by exact
algorithms  li   quan      a   although maxclqdyn efl scr overall performs better 
numvc also finds an optimal solution significantly faster than maxclqdyn efl scr on some
structured instances  such as the two brock instances and keller  
finally  we would like to note that although heuristic solvers can find optimal solutions fast  they
are unable to prove the optimality of the solutions they find  on the other hand  the run time of an
exact algorithm is spent not only on finding an optimal solution but also on proving its optimality 
in this sense  heuristic and exact algorithms cannot be compared in a fair way  nevertheless  our
experiments suggest that heuristic approaches are appealing for solving large instances in reasonable
short time 

   discussions
in this section  we first explore the run time distribution of numvc on some representative
instances  and then investigate the effectiveness of the two stage exchange strategy and the
forgetting mechanism in numvc  finally  we analyze the performance of numvc with different
settings to its two parameters for the forgetting mechanism  which shows that numvc is not
sensitive to the parameters 
    run time distributions of numvc
in this subsection  we conduct an empirical study to gain deeper insights of the run time behavior of
numvc  more specifically  we study the run time distribution of numvc on several representative
instances  for the purpose of comparison  we also report the run time distribution of ewcc  which
is the best competing mvc local search solver 
consider a randomized algorithm solving a given optimization problem instance  and halting
as soon as an optimal solution is found  the run time of the algorithm can be viewed as a
random variable  which is fully described by its distribution  commonly referred to as the run time
distribution  rtd  in the literature about algorithm performance modeling  hoos   stutzle       
bartz beielstein et al          the methodology of studying the run time behavior of algorithms
based on rtds has been widely used in empirical analysis of heuristic algorithms  hoos   stutzle 
      finkelstein  markovitch    rivlin        watson  whitley    howe        pullan   hoos 
       we also follow the same methodology in our study here 
for studying typical run time behaviour  we choose instances where numvc reaches an optimal
solution in all     runs  and are of appropriate difficulty  for the dimacs benchmark  we select
brock      and mann a    both of which are of reasonable size and hardness  also  these two
instances represent two typical instance classes for numvc  as numvc has poor performance on
the brock instances  while it dominates other heuristic algorithms on the mann instances  for
the bhoslib benchmark  frb        and frb        are selected  these are appropriate
instances for studying the run time behavior of numvc  since they are neither too easy that can be
solved in a short time nor too difficult to reach a      success rate 
the empirical rtd graphs of numvc and ewcc are shown in figure    the rtd for each
instance is based on     independent runs that all reach a respective optimal solution   according to
the graphs  numvc shows a large variability in run time  further investigation indicates that these
rtds are quite well approximated by exponential distributions  labeled ed m  x        x m  
where m is the median of the distribution  to test the goodness of the approximations  we use a
   

fic ai   s u   l uo   s attar

empirical rtd of numvc and ewcc on mann a  

empirical rtd of numvc and ewcc on brock     
 
   
   
   

 
   

rtd for numvc
ed     
rtd for ewcc
ed    

   
   
   
p solve 

p solve 

   
   

   

   

   

   

   

   

   

   

   

 
 
  

 

 

  

 

 

  
  
runtime  cpu sec 

  

 
 
  

 

  

empirical rtd of numvc and ewcc on frb     

   
   

   

rtd for numvc
ed    
rtd for ewcc
ed    

   
   

 

 

  

 

  

rtd for numvc
ed    
rtd for ewcc
ed     

   
p solve 

p solve 

 

  
  
runtime  cpu sec 

 

   
   

   

   

   

   

   

   

   

   

   

 
 
  

 

  

empirical rtd of numvc and ewcc on frb     

 
   

rtd for numvc
ed    
rtd for ewcc
ed     

 

  

 

  
runtime  cpu sec 

 

  

 
 
  

 

  

 

  

 

  
runtime  cpu sec 

 

  

 

  

figure    run time distributions  rtds  of numvc and ewcc applied to two dimacs instances
 top  and two bhoslib instances  bottom   these empirical rtds are well approximated
by exponential distributions  labeled ed m  x        x m in the plots 

kolmogorov smirnov test  which fails to reject the null hypothesis that the sampled run time
stems from the exponential distributions shown in the figures at a standard confidence level of
        with p values between      and       for ewcc  the kolmogorov smirnov test
shows its rtds on mann a   and the two bhoslib instances are also exponential distributions 
while its rtd on brock      is not from an exponential distribution 
the observation of exponential rtds of numvc is consistent with similar results for other
high performance sls algorithms  e g   for maxclique  pullan   hoos         for sat  hoos  
stutzle         for maxsat  smyth  hoos    stutzle         and for scheduling problems  watson
et al          by the arguments  hoos   stutzle        hoos   stutzle        made for stochastic
local search algorithms characterized by an exponential rtd  we conclude that  for numvc  the
probability of finding an optimal solution within a fixed amount of time  or steps  does not depend
on the run time in the past  consequently  it is very robust w r t  the cutoff time and thus  the restart
   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

time  therefore  performing multiple independent runs of numvc in parallel will result in closeto optimal parallelization speedup  similar observations were made for most of the other dimacs
instances and bhoslib instances 
of practical interest is also the rtd analysis for numvc on difficult instances for which all
algorithms in our experiments fail to achieve a high success rate  i e         the rtds in these
cases would show where the algorithm stagnates and suggest an a posteriori restart time for the
algorithm  for this purpose  we select mann a   and frb        for analysis  the rtds of
numvc on these two instances are illustrated in figure    interestingly  from these rtds we do not
observe any obvious stagnation  which again confirms that numvc is robust w r t  the cutoff time
and thus the restart time  therefore  by increasing the cutoff time  we can expect a higher success
rate of the algorithm on these difficult instances 
empirical rtd of numvc on mann a   and frb     
 
   
rtd of numvc on mann a  
   
rtd of numvc on frb     
   

p solve 

   
   
   
   
   
   
 
 
  

 

 

  

  

 

  

runtime  cpu sec 

figure    run time distributions  rtds  of numvc on mann a   and frb        instances 
for which numvc finds an optimal  or best known  solution in less than half runs 

    effectiveness of two stage exchange
to study the effectiveness of the two stage exchange strategy  we compare numvc with its
alternative algorithm numvc  which selects two vertices for exchanging simultaneously  in each
step  numvc  first chooses an uncovered edge e uniformly at random  and then evaluates each pair
of vertices u and v where u is in the current candidate solution and v is one endpoint of e such
that conf change v       for evaluating the benefit  i e   the decrement of the cost function 
of exchanging a vertex pair u and v  numvc  first checks whether they are neighbors  if u
and v are neighbors  the benefit is dscore u    dscore v    w e u  v    otherwise  the benefit
is dscore u    dscore v   numvc  selects the vertex pair with the greatest benefit to exchange 
in the numvc  and also numvc    algorithm  there are only two candidate vertices to add to
the current candidate solution c  i e   the endpoints of the selected uncovered edge   hence  in
the worst case  numvc performs      c  evaluations  while numvc  has to evaluate     c 
pairs of vertices  moreover  numvc only needs to check the dscore of a vertex in each  vertex 
   

fic ai   s u   l uo   s attar

evaluation  while numvc  performs a vertex pair evaluation which involves a pair of vertices and
their relationship  and thus is more time consuming  based on the above analysis  we conjecture
that the complexity per step of numvc is at least   times lower than that of numvc    also  as we
have mentioned in section    the two stage exchange strategy is less greedy than the one selecting
two vertices for exchanging simultaneously  as numvc  does 
the investigation is carried out on   dimacs instances from different families as well as
   bhoslib instances  for the dimacs benchmark  we select brock       c       
mann a    and p hat         these instances have different characteristics  as described
below  pullan et al          note that the following conclusions on dimacs instances are for
the complementary dimacs graphs 
 the dimacs brock instances have minimum vertex covers that consist of medium to lower
degree vertices  and are designed to defeat greedy heuristics 
 the dimacs c and p hat        instances have minimum vertex covers that consist of
higher degree vertices and can be effectively solved by greedy heuristics 
 the dimacs mann instances have a large proportion of plateaus in the instance searchspace  and thus greedy heuristics are unsuitable to solve them 
 the bhoslib instances have minimum vertex covers consisting of vertices whose
distribution of vertex degree closely matches that for the complete graph  these are difficult
instances for both greedy and diversification heuristics 
graph
instance
brock     
c      
mann a  
p hat       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       

v c
   
    
   
    
    
    
    
    
    
    
    
    
    
    
    
    

suc
  
   
   
   
   
   
  
  
   
   
   
  
   
  
  
  

time
   
   
  
    
  
   
   
   
   
  
   
   
   
   
    
   

numvc
steps
         
       
        
      
        
         
         
         
         
        
         
         
        
         
         
         

 steps sec       
    
   
    
   
   
   
   
   
   
   
   
   
   
   
   
   

suc
  
   
   
   
   
   
  
  
   
   
  
  
   
  
  
  

time
    
   
   
     
  
   
    
    
   
   
    
    
   
    
    
    

numvc 
steps
         
       
         
      
        
         
         
         
         
        
         
         
        
         
         
         

 steps sec       
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

table    comparative performance of numvc and numvc  which selects two vertices for
exchanging simultaneously  the results are based on     independent runs for each solver
on each instance 
the comparative results of numvc and numvc  are presented in table    the results show
that numvc significantly outperforms numvc  in terms of averaged run time  primarily due to
its much lower complexity per step  in each second  numvc performs     times more steps than
   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

numvc    which supports our conjecture that the complexity per step of numvc is more than  
times lower than that of numvc   
now we turn our attention to comparing numvc and numvc  in terms of step performance 
which is independent from the complexity per step  for brock and mann graphs which are difficult
for greedy heuristics  numvc has a significantly better step performance than numvc    on the
other hand  for greedy friendly graphs such as c       and p hat         numvc needs
more steps to converge to an optimal solution than numvc  does  these observations support our
argument that the two stage exchange strategy is less greedy than the one that selects two vertices
for exchanging simultaneously  as numvc  does 
we also observe that the step performance of numvc  is better than that of numvc on
bhoslib instances  for instance  on those bhoslib instances where both algorithms have a
     success rate  numvc needs about     times more steps than numvc  to find an optimal
solution  this is what we do not expect and cannot yet explain  nevertheless  as numvc makes
rather rapid modifications to a solution  a little degrade in step performance does not hurt 
graph
instance
c      
mann a  
p hat       
frb       
frb       
frb       

pls
 steps sec
      
         
       
       
       
       

cover
 steps sec
     
       
      
       
       
       

ewcc
 steps sec
      
       
      
       
       
       

numvc
 steps sec
      
         
       
       
       
       

table    complexity per step on selected instances
to further demonstrate the low complexity per step of numvc  we compare the number
of search steps per second between numvc and other state of the art heuristic solvers on
representative instances  as indicated in table    numvc executes many more steps in each second
than the other two mvc local search solvers cover and ewcc do  for the instances in table
   each second numvc executes     times more steps than cover  and     times more steps
than ewcc  this indicates that the two stage exchange strategy can significantly accelerate mvc
local search algorithms  although pls performs more steps per second than numvc  it is an mc
local search algorithm whose search scheme is essentially different from those of mvc local search
algorithms 
    effectiveness of the forgetting mechanism
to study the effectiveness of the forgetting mechanism in numvc  we compare numvc with its
two alternative algorithms numvc  and numvc    which are obtained from numvc by modifying
the edge weighting scheme as below 
 numvc  works in the same way as numvc  except for not using the forgetting mechanism 
that is  deleting line    from algorithm   
 numvc  adopts the forgetting mechanism used in dls mc  pullan   hoos        for the
weighting scheme  more specifically  numvc  increases all weights of uncovered edges by
   

fic ai   s u   l uo   s attar

one at the end of each step  and performs a forgetting operation every pd steps by decreasing
weights by one for all edges whose weights are greater than one  note that pd is an instancedependent parameter 
the experiments were carried out with some representative instances from both benchmarks 
for the dimacs benchmark  we select brock       c        keller   and mann a   
which are from different classes and of appropriate difficulty  for the bhoslib benchmark  we
select three instances for each of the three largest sized instance groups respectively 
graph
instance vertices
brock     
   
c      
    
keller 
    
mann a  
    
frb       
    
frb       
    
frb       
    
frb       
    
frb       
    
frb       
    
frb       
    
frb       
    
frb       
    

c

v
   
    
    
   
    
    
    
    
    
    
    
    
    

numvc
suc time
  
   
   
   
        
   
  
  
   
   
   
   
  
   
   
  
   
   
   
  
   
       
  
   

numvc 
suc time
       
   
   
        
       
  
   
   
   
   
  
  
   
       
   
   
       
       
  
   

numvc 
pd        suc time
      
  
      
   
            
     
   
   
  
   
       
   
       
  
   
  
   
   
  
   
       
   
   
  
   
   
       
   
  
   

table    comparative performance of numvc and its two alternatives numvc  and numvc   
each algorithm is performed     times on each instance 

an apparent observation from table   is that the two algorithms with a forgetting mechanisms
 i e   numvc and numvc    outperform numvc  on almost all instances  particularly  due to
the missing of a forgetting mechanism  numvc  performs significantly worse than the other two
algorithms on brock and mann graphs  on the other hand  table   demonstrates that numvc and
numvc  exhibit competitive performance on the bhoslib benchmark  and dominate on different
types of dimacs instances  more specifically  numvc outperforms numvc  on c       
keller  and mann a    but performs significantly worse than numvc  on brock       in
order to find out the genuine performance of numvc  on brock instances  we test numvc  on
the larger brock      and brock      instances  the results show that these two large brock
instances are substantially more difficult than the two brock    instances  and numvc  also fails
to solve neither of them 
although numvc  shows competitive performance with numvc  its performance is given by
optimizing the pd parameter for each instance  moreover  as with dls mc  pullan   hoos        
numvc  is considerably sensitive to the pd parameter  for example  our experiments show that on
the frb      instances  numvc  performs quite well with pd          but it fails to find an
optimal solution when pd is set to be a value less than       comparatively  numvc with the same
   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

parameter setting performs quite well on all types of instances but the brock family  actually  we
will show in the next section that numvc is not sensitive to its parameters 
it is also interesting to compare numvc with its alternatives which replace the forgetting
mechanism with the smoothing techniques similar to those in local search for sat  indeed  earlier
versions of numvc did use the smoothing techniques similar to those in sat local search  and
they did not have good performance compared with numvc  it would be interesting to find out the
reasons for the success of the forgetting mechanism and the failure of those smoothing techniques
in mvc edge weighting local search algorithms such as numvc 
    parameters for the forgetting mechanism

     v        
     v        
     v        
     v        
     v        

brock     
          
          
          
         
         

mann a  
          
          
          
          
         

c      
          
          
          
          
          

frb       
         
         
          
         
          

frb       
          
          
          
          
          

frb       
          
         
         
          
          

frb       
         
          
         
          
         

     v        
     v        
     v        
     v        
     v        

          
         
          
         
         

          
          
          
          
          

          
          
          
          
          

         
         
          
          
          

          
          
          
          
          

         
         
         
         
         

          
         
          
          
          

     v        
     v        
     v        
     v        
     v        

          
         
         
         
         

          
         
         
          
          

          
          
          
          
          

          
          
         
         
         

          
          
          
          
          

         
         
          
         
         

          
          
         
          
         

     v        
     v        
     v        
     v        
     v        

          
         
         
          
         

          
          
         
          
          

          
          
          
          
          

          
         
          
         
         

          
          
          
          
          

          
         
         
          
          

         
          
         
          
          

     v        
     v        
     v        
     v        
     v        

          
         
         
          
         

         
          
          
          
         

          
          
          
          
          

          
          
         
         
          

          
          
          
          
          

          
         
         
          
         

         
         
         
         
          

table     comparative performance of numvc with various parameter combinations      for
the forgetting mechanism  for each instance  numvc is performed    times with each
parameter combination  except for the one adopted in this work      v          where the
results are based on     runs  for keller   numvc performs almost the same with
various parameters  having the same success rate        and tiny difference of averaged
run time  less than   second   and thus the results are not reported in the table 

   

fic ai   s u   l uo   s attar

the numvc algorithm has two parameters  and   which specify the forgetting mechanism 
specifically  when the averaged weight of all edges achieves a threshold   all edge weights are
multiplied by a constant factor              in this subsection  we investigate how numvc
performs with different settings to these two parameters  the investigation is carried out on both
dimacs and bhoslib benchmarks  for the dimacs benchmark  we select the four instances
used in the preceding subsection for the same reasons  for the bhoslib benchmark  we select
frb         frb         frb        and frb         which are of different sizes
and appropriate hardness 
table    presents the performance of numvc with various parameter combinations of  and
 on the representative instances  as we can see from table     the parameter combination
     v         yields relatively good performance for all instances  and exhibits a better robustness
over the instances than other parameter combinations do 
on the other hand  we observe that numvc with various parameter combinations performs
comparably on these tested instances  for example  for all parameter settings  numvc achieves
a success rate of      for keller   mann a    c       as well as frb         and
the averaged run time difference on these instances is not so significant  for other instances  the
difference of success rate never exceeds     between any two parameter settings  this observation
indicates that numvc seems not sensitive to the two parameters  actually  as we have mentioned
before  numvc exhibits very good performance for both dimacs and bhoslib benchmarks
with a fixed parameter setting  this is an advantage compared to other forgetting mechanisms
such as the one used in dls mc  pullan   hoos         which is sensitive to its parameter  for
algorithms that are sensitive to their parameters  considerable parameter tuning is required in order
to get a good performance for a certain instance  which usually costs much more time than solving
the instance 

   conclusions and future work
in this paper  we presented two new local search strategies for the minimum vertex cover  mvc 
problem  namely two stage exchange and edge weighting with forgetting  the two stage exchange
strategy yields an efficient two pass move operator for mvc local search algorithms  which
significantly reduces the time complexity per step  the forgetting mechanism enhances the
edge weighting scheme by decreasing weights when the averaged weight reaches a threshold 
to periodically forget earlier weighting decisions  based on these two strategies  we designed
a slight  yet effective mvc local search algorithm called numvc  the numvc algorithm was
evaluated against the best known heuristic algorithms for mvc  mc  mis  on standard benchmarks 
i e   the dimacs and bhoslib benchmarks  the experimental results show that numvc is
largely competitive on the dimacs benchmark and dramatically outperforms other state of the art
heuristic algorithms on all bhoslib instances 
furthermore  we showed that numvc is characterized by exponential rtds  which means it is
robust w r t  the cutoff parameters and the restart time  and hence has close to optimal parallelization
speedup  we also performed further investigations to provide further insights into the two new
strategies and their effectiveness  finally  we conducted an experiment to study the performance of
numvc with different parameter settings  and the results indicate that numvc is not sensitive to
its parameters 
   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

the two stage exchange strategy not only has a lower time complexity per step  but also has
the flexibility to allow us to employ specific heuristics in different stages  an interesting research
direction is thus to apply this idea to other combinatorial problems whose essential tasks are also to
seek for an optimal subset with some fixed cardinality 

acknowledgments
this work is supported by     program     cb        arc future fellowship ft        
national natural science foundation of china                     and            and
fundamental research funds for the central universities of china             we would like
to thank the editor and anonymous reviewers for their valuable comments on earlier versions of this
paper  we would also like to thank yanyan xu for proofreading this paper 

references
aggarwal  c   orlin  j     tai  r          optimized crossover for the independent set problem 
operations research             
andrade  d  v   resende  m  g  c     werneck  r  f  f          fast local search for the maximum
independent set problem  in workshop on experimental algorithms  pp         
barbosa  v  c     campos  l  c  d          a novel evolutionary formulation of the maximum
independent set problem  j  comb  optim                
bartz beielstein  t   chiarandini  m   paquete  l     preuss  m   eds            experimental
methods for the analysis of optimization algorithms  springer  berlin  heidelberg  new
york 
battiti  r     protasi  m          reactive local search for the maximum clique problem 
algorithmica                
busygin  s   butenko  s     pardalos  p  m          a heuristic for the maximum independent set
problem based on optimization of a quadratic over a sphere  j  comb  optim                
cai  s     su  k          local search with configuration checking for sat  in proc  of ictai    
pp       
cai  s     su  k          configuration checking with aspiration in local search for sat  in proc 
of aaai     pp         
cai  s   su  k     chen  q          ewls  a new local search for minimum vertex cover  in proc 
of aaai     pp       
cai  s   su  k     sattar  a          local search with edge weighting and configuration checking
heuristics for minimum vertex cover  artif  intell                       
cai  s   su  k     sattar  a          two new local search strategies for minimum vertex cover  in
proc  of aaai     pp         
carraghan  r     pardalos  p          an exact algorithm for the maximum clique problem 
operations research letters               
   

fic ai   s u   l uo   s attar

dinur  i     safra  s          on the hardness of approximating minimum vertex cover  annals of
mathematics                 
evans  i          an evolutionary heuristic for the minimum vertex cover problem  in proceedings
of the seventh international conference on evolutionary programming ep   pp         
fahle  t          simple and fast  improving a branch and bound algorithm for maximum clique 
in proc  of european symposium on algorithms  esa      pp         
feige  u          approximating maximum clique by removing subgraphs  siam j  discrete math  
              
finkelstein  l   markovitch  s     rivlin  e          optimal schedules for parallelizing anytime
algorithms  the case of shared resources  j  artif  intell  res   jair             
gajurel  s     bielefeld  r          a fast near optimal vertex cover algorithm  novca  
international journal of experimental algorithms  ijea          
garey  m     johnson  d          computers and intractability  a guide to the theory of npcompleteness  freeman  san francisco  ca  usa 
glover  f          tabu search  part i  orsa journal on computing               
grosso  a   locatelli  m     pullan  w  j          simple ingredients leading to very efficient
heuristics for the maximum clique problem  j  heuristics                
halperin  e          improved approximation algorithms for the vertex cover problem in graphs
and hypergraphs  siam journal on computing                  
hastad  j          clique is hard to approximate within n    acta math              
hastad  j          some optimal inapproximability results  j  acm                
hoaglin  d  c   mosteller  f     tukey  j  w   eds            understanding robust and exploratory
data analysis  wiley classics library  wiley  new york  ny 
hoos  h     stutzle  t          stochastic local search  foundations and applications  morgan
kaufmann  san francisco  ca  usa 
hoos  h  h     stutzle  t          towards a characterisation of the behaviour of stochastic local
search algorithms for sat  artif  intell                    
hutter  f   tompkins  d  a  d     hoos  h  h          scaling and probabilistic smoothing  efficient
dynamic local search for sat  in proc  of cp     pp         
ishtaiwi  a   thornton  j   sattar  a     pham  d  n          neighbourhood clause weight
redistribution in local search for sat  in proc  of cp     pp         
johnson  d  s     trick  m   eds            cliques  coloring  and satisfiability  second dimacs
implementation challenge        vol     of dimacs series in discrete mathematics and
theoretical computer science  american mathematical society  providence  ri  usa 
karakostas  g          a better approximation ratio for the vertex cover problem  in proc  of
icalp     pp           
katayama  k   sadamatsu  m     narihisa  h          iterated k opt local search for the maximum
clique problem  in proc  of evocop     pp       
   

fin u mvc  a n e fficient l ocal s earch a lgorithm for m inimum v ertex c over

li  c  m   manya  f     planes  j          new inference rules for max sat  j  artif  intell  res 
 jair              
li  c  m     quan  z       a   combining graph structure exploitation and propositional reasoning
for the maximum clique problem  in proc  of ictai     pp         
li  c  m     quan  z       b   an efficient branch and bound algorithm based on maxsat for the
maximum clique problem  in proc  of aaai     pp         
michiels  w   aarts  e  h  l     korst  j  h  m          theoretical aspects of local search  springer 
minton  s   johnston  m  d   philips  a  b     laird  p          minimizing conflicts  a heuristic
repair method for constraint satisfaction and scheduling problems  artif  intell               
    
morris  p          the breakout method for escaping from local minima  in proc  of aaai     pp 
     
ostergard  p  r  j          a fast algorithm for the maximum clique problem  discrete applied
mathematics                   
papadimitriou  c  h          on selecting a satisfying truth assignment  in proc  of focs     pp 
       
pullan  w          phased local search for the maximum clique problem  j  comb  optim         
       
pullan  w          optimisation of unweighted weighted maximum independent sets and minimum
vertex covers  discrete optimization            
pullan  w     hoos  h  h          dynamic local search for the maximum clique problem  j  artif 
intell  res   jair              
pullan  w   mascia  f     brunato  m          cooperating local search for the maximum clique
problem  j  heuristics                
regin  j  c          using constraint programming to solve the maximum clique problem  in proc 
of cp     pp         
richter  s   helmert  m     gretton  c          a stochastic local search approach to vertex cover 
in proc  of ki     pp         
schuurmans  d   southey  f     holte  r  c          the exponentiated subgradient algorithm for
heuristic boolean programming  in proc  of ijcai     pp         
shyu  s  j   yin  p     lin  b  m  t          an ant colony optimization algorithm for the minimum
weight vertex cover problem  annals of or                   
smyth  k   hoos  h  h     stutzle  t          iterated robust tabu search for max sat  in proc  of
canadian conference on ai     pp         
taillard  e  d          parallel taboo search techniques for the job shop scheduling problem 
informs journal on computing               
thornton  j   pham  d  n   bain  s     jr   v  f          additive versus multiplicative clause
weighting for sat  in proc  of aaai     pp         
   

fic ai   s u   l uo   s attar

tomita  e     kameda  t          an efficient branch and bound algorithm for finding a maximum
clique with computational experiments  j  global optimization             
watson  j  p   whitley  l  d     howe  a  e          linking search space structure  run time
dynamics  and problem difficulty  a step toward demystifying tabu search  j  artif  intell 
res   jair              
wu  q   hao  j  k     glover  f          multi neighborhood tabu search for the maximum weight
clique problem  annals of or                 
wu  z     wah  b  w          an efficient global search strategy in discrete lagrangian methods
for solving hard satisfiability problems  in proc  of aaai iaai     pp         
xu  k   boussemart  f   hemery  f     lecoutre  c          a simple model to generate hard
satisfiable instances  in proc  of ijcai     pp         
xu  k   boussemart  f   hemery  f     lecoutre  c          random constraint satisfaction  easy
generation of hard  satisfiable  instances  artif  intell                    
xu  k     li  w          exact phase transitions in random constraint satisfaction problems  j 
artif  intell  res   jair             
xu  k     li  w          many hard examples in exact phase transitions  theoretical computer
science              
yugami  n   ohta  y     hara  h          improving repair based constraint satisfaction methods
by value propagation  in aaai  pp         
zuckerman  d          linear degree extractors and the inapproximability of max clique and
chromatic number  in proc  of stoc     pp         

   

fi