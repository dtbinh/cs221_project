journal of artificial intelligence research                

submitted        published      

short and long supports for constraint propagation
peter nightingale
ian p  gent
christopher jefferson
ian miguel

pwn  st andrews ac uk
ian gent st andrews ac uk
caj   st andrews ac uk
ijm st andrews ac uk

school of computer science  university of st andrews 
st andrews  fife ky    sx  uk

abstract
special purpose constraint propagation algorithms frequently make implicit use of short
supports  by examining a subset of the variables  they can infer support  a justification
that a variable value pair may still form part of an assignment that satisfies the constraint 
for all other variables and values and save substantial work  but short supports have not
been studied in their own right  the two main contributions of this paper are the identification of short supports as important for constraint propagation  and the introduction of
haggisgac  an efficient and effective general purpose propagation algorithm for exploiting short supports  given the complexity of haggisgac  we present it as an optimised
version of a simpler algorithm shortgac  although experiments demonstrate the efficiency of shortgac compared with other general purpose propagation algorithms where
a compact set of short supports is available  we show theoretically and experimentally
that haggisgac is even better  we also find that haggisgac performs better than
gac schema on full length supports  we also introduce a variant algorithm haggisgacstable  which is adapted to avoid work on backtracking and in some cases can be faster
and have significant reductions in memory use  all the proposed algorithms are excellent
for propagating disjunctions of constraints  in all experiments with disjunctions we found
our algorithms to be faster than constructive or and gac schema by at least an order of
magnitude  and up to three orders of magnitude 

   introduction
constraint solvers typically employ a systematic backtracking search  interleaving the choice
of an assignment of a decision variable with the propagation of the constraints to determine
the consequences of the assignment made  propagation algorithms can broadly be divided
into two types  the first are specialised to reason very efficiently about constraint patterns
that occur frequently in models  examples include the global cardinality constraint  regin 
      and the element constraint  gent  jefferson    miguel      b   it is not feasible to
support every possible constraint expression with a specialised propagator in this way  in
which case general purpose constraint propagators  such as gac schema  bessiere   regin 
       gac          bessiere  regin  yap    zhang         str   lecoutre        or
mddc  cheng   yap        are used  these are typically more expensive than specialised
propagators but are an important tool when no specialised propagator is available 
a support in a constraint for a domain value of a variable is a justification that the value
may still form part of an assignment that satisfies the constraint  it is usually given in terms
of a set of literals  variable value pairs corresponding to possible assignments to the other
c
    
ai access foundation  all rights reserved 

finightingale  gent  jefferson    miguel

variables in the constraint  one of the efficiencies typically found in specialised propagators
is the use of short supports  by examining a subset of the variables  they can infer support
for all other variables and values and save substantial work  this use is typically implicit 
i e  achieved through a specialised algorithm which does not examine all variables in all
cases  one of our contributions is to highlight the general importance of short supports 
as an example  consider the element constraint xy   z  with x    x    x    y              
z               this constraint is satisfied iff the element in position y of vector  x    x    x   
equals z  consider the set of literals s    x       y      z       this set clearly satisfies
the definition of the constraint xy   z  but it does not contain a literal for each variable 
any extension of s with valid literals for variables x  and x  is a support  s is an example
of a short support 
in our previous work we introduced shortgac  nightingale  gent  jefferson    miguel 
       a general purpose propagation algorithm that exploits short supports  until the introduction of shortgac  general purpose propagators relied upon supports involving all
variables  in this paper we develop the concept further and introduce a new algorithm
haggisgac   which is consistently more efficient than shortgac  where available  the
use of compact sets of short supports allows haggisgac to outperform greatly existing general purpose propagation algorithms  in some cases  haggisgac even approaches
the performance of special purpose propagators  haggisgac is also very well suited to
propagating disjunctions of constraints  and outperforms the traditional constructive or
algorithm  lagerkvist   schulte        wurtz   muller        by orders of magnitude 
haggisgac is also more efficient than gac schema on full length supports  we also
describe a variant  haggisgac stable  in which supports do not need to be deleted on
backtracking  applied to full length supports  this version has greatly reduced memory
usage 
shortgac  haggisgac and haggisgac stable are all instantiated with a function named findnewsupport  and are similar to gac schema in this way   this function
can be specific to a constraint  and generate short supports procedurally  alternatively  a
generic findnewsupport can retrieve short supports from a data structure 
section   presents the necessary background  and section   introduces the concept
of short support  section   outlines the basic idea used to deal with implicit supports
throughout the paper  section   gives full details of shortgac  including the complexity of
key operations and alternative implementations for when short supports are provided in list
form  section   presents the new algorithm haggisgac as a development of shortgac 
both shortgac and haggisgac are evaluated experimentally in section    section  
describes haggisgac stable  with corresponding experiments in section    finally 
sections    and    discuss related work and present our conclusions 

   haggisgac is named for the legendary wild haggis of scotland  which has both short legs and long
legs for walking around hills  like its namesake  haggisgac copes with both full length and shorter
supports and originates in scotland  details of the wild haggis can be found on wikipedia  http 
  en wikipedia org wiki wild haggis  and in the veterinary record  king  cromarty  paterson   
boyd        

 

fishort and long supports for constraint propagation

   supports  gac  triggers
a constraint satisfaction problem  csp  is defined as a set of variables x  a function that
maps each variable to its domain  d   x   z where each domain is a finite set  and a set
of constraints c  a constraint c  c is a relation over a subset of the variables x  the
scope of a constraint c  named scope c   is the set of variables that c constrains 
a solution to a csp is a function s   x  z that maps each variable x  x to a value
from d x   such that for every constraint c  c  the values of scope c  form a tuple that is
in c  i e  the constraint is satisfied   
during a systematic search for a solution to a csp  values are progressively removed
from the domains d  therefore  we distinguish between the initial domains and the current
domains  the function d refers to the current domains unless stated otherwise  a literal
is defined as a variable value pair  and is written x   v  a literal x   v is valid if v is in
the current domain of x  i e  v  d x   
definition       support  a support s for constraint c and domains d is defined as
a set of valid literals that contains exactly one valid literal for each variable in scope c 
and satisfies c  where necessary for disambiguation  we call such a support a full length
support or simply long support  to contrast with short supports as defined later 
a property commonly established by constraint propagation algorithms is generalised
arc consistency  gac   mackworth         a constraint c is gac if and only if there exists
a full length support for every valid literal of every variable in scope c   gac is established
by identifying all literals x   v for which no full length support exists and removing v from
the domain of x  we consider only algorithms for establishing gac in this paper 
a gac propagation algorithm is usually situated in a systematic search  hence  it
must operate in three contexts  initialisation  at the root node   where support is established
from scratch  following the deletion of one or more domain values  as a result of a branching
decision and or the propagation of other constraints   where support must be re established
selectively  and upon backtracking  where data structures must be restored to the correct
state for this point in search  our primary focus will be on the second context  operation
following value deletion  although we will discuss efficient backtracking in section    a
gac propagation algorithm would typically be called for each deleted domain value in
turn  once the algorithm has been called for each such domain value  the constraint will
be gac 
the propagation algorithms we present have the concept of active support  inspired by
gac schema  bessiere   regin         an active support is a support that is currently
in use to support a set of literals  each literal has a set of active supports that support
it  when an active support is found to be invalid  it is removed  when the set for some
literal is empty  we say the literal has lost support  a new support is sought for the literal 
and if found the new support becomes active  if no new support is found  the literal has no
support and it is deleted 
in the propagation algorithms we present  for efficiency we make use of watched literals
as provided in minion  gent et al       b   because propagators need not be called for every
deleted domain value to establish gac  we say that propagators attach and remove triggers
on literals  when a domain value v for variable x is deleted  the propagator is called if and
 

finightingale  gent  jefferson    miguel

only if it has a trigger attached to the literal x   v  doing so means that when a literal
is deleted which is not attached to a trigger  zero work is incurred  we should emphasise
that the use of watched literals is not fundamental to our work  if they are not available
in a given solver  our algorithms only need a minor adaptation  when called on any literal
removal  we may just return immediately if the literal is not in any active support  which
can be checked in time o     thus our algorithms fit the traditional fine grained scheme
 bessiere   regin        except that in some cases they will not be invoked because they
use watched literals 

   short supports
the concept of a short support is a generalisation of full length support  it is defined below 
definition       short support  a short support s for constraint c and domains d is
defined as a set of valid literals x   v such that x  scope c   x occurs only once in s 
and every superset of s that contains one valid literal for each variable in scope c  is a
full length support  a strict short support is a short support that is not a full length
support 
the definition of short support includes both extremes  the empty set is a short support when the constraint is entailed  i e  every tuple on scope c  within d satisfies the
constraint   similarly  every full length support s is necessarily a short support  because
the only superset of s is itself  in our case studies we will see examples of both empty short
supports and short supports that also happen to be full length 
short supports can be used to maintain gac  just as with a full length support  a
short support provides gac support for each literal contained within it  we call this
explicit support for those literals  the new feature is that a short support also provides
support for all valid literals of all variables not contained in the short support  this is
because  by definition  every valid extension of the short support to cover all variables in
scope c  is a full length support  we say that a short support gives implicit gac support
for all valid literals of variables not in the short support 
we also define the concept of a complete set of short supports for a constraint 
definition       short support set  a short support set s c  d  is a set of short supports
for constraint c under domains d  such that every full length support s of c under d is a
 not necessarily strict  superset of at least one short support s    s c  d  
a constraint may have many short support sets  this gives us some latitude to implement one that is efficient to compute 
it is natural to ask how we can identify correct short supports given a constraint c  a
simple but fundamental result is given in lemma     
lemma      given a constraint c and domains d  the empty set    is a short support for
c iff gac propagation for the constraint not c  leads to an empty domain 
proof     is a short support if and only if every valid assignment to variables in scope c 
satisfies c  every assignment satisfies c iff every assignment violates not c   if every assignment violates not c   then gac propagation for the constraint not c  leads to an empty
 

fishort and long supports for constraint propagation

domain  to complete this last equivalence  note that if any assignment does not violate
not c   all literals in that assignment are supported  so gac propagation cannot cause an
empty domain 
this lemma has two important consequences  first  we can check any short support for
correctness  not just the empty support  to check a short support s    x    v            xk  
vk    we can simply set d x       v             d xk      vk    all assignments now extend s  so
s is a short support iff    is  lemma     applies so we can check the correctness of s by
propagating not c  and seeing if a domain is emptied 
the second consequence is negative  however  determining whether gac propagation
will empty a domain is polynomially equivalent to actually performing gac propagation
 bessiere  hebrard  hnich    walsh         since some constraints are np hard to gac
propagate  it follows that it is not easy even to check if the empty set is a short support 
thus we cannot expect to find a method which is both fast and general for finding short
supports for a constraint 
given the provable difficulty of finding short supports from a set of full length supports 
we construct sets of short supports specifically for each of three experimental case studies
in section    the focus of this paper is to show the value of strict short supports if they
are given to the system  the situation is analogous with that in an important area of
constraints  namely that of exploiting symmetries in constraint problems  gent  petrie 
  puget         a large majority of research has assumed that sets of symmetries are
provided to the system  even though finding such sets is hard  this has not inhibited
research in exploiting symmetry  within which the automated detection of symmetry has
become an important subarea  mears        puget         however we leave the automated
construction of compact short support sets to future research  analogously to patterns such
as matrix symmetries  flener  frisch  hnich  kiziltan  miguel  pearson    walsh        
we can at least identify a pattern which often lets us identify strict short supports  as we
now describe 
    short supports and disjunction
strict short supports arise naturally from disjunctions  if a constraint can be expressed as
a disjunction of shorter constraints  then a set of strict short supports can be constructed
for it  suppose we have the following constraint 
c x    x    x    x     c   x    x     c   x    x     c   c    x   
suppose also that a    x       x       is a valid assignment that satisfies c    if we satisfy
c    we satisfy c regardless of the values of x  and x    therefore a    x       x       is a
strict short support for c 
lemma      given constraint c  a domain set d  and a set of constraints  c        ck   where
ci   c        ck     scope ci    scope c  and c  c       ck   the following is a short support
set  where we write fls ci   d  to mean the full length supports of ci w r t  domains d  
s c  d     s   s  fls c    d       s  fls ck   d  
 

finightingale  gent  jefferson    miguel

proof   a  each element of s c  d  is a short support according to definition     by the
semantics of disjunction   b  s c  d  is a short support set by definition      every fulllength support of c must satisfy some disjunct ci   therefore the full length support contains
a full length support for ci that is included in s c  d  
lemma     allows a short support set to be created for any disjunction  given the initial
domains  we do this for two of our three case studies  for the third  the set is prohibitively
large  
using a similar approach to lemma     we can create a function that generates short
supports on demand  the function takes a valid literal x   v and the current domains
d  and returns a short support that supports x   v  explicitly or implicitly   or null if
none exists  the function can be constructed as follows  we create new domains d  where
d   x     v   and otherwise d  is identical to d  if no disjunct is satisfiable under d    then
the function returns null  otherwise  the function picks any disjunct ck that is satisfiable
under d    and returns a satisfying assignment of ck that is valid under d    for each of the
three case studies in section    we created a function that follows this scheme with some
optimisations 
propagating disjunctions is recognised to be an important topic  many papers have
been published in this area  wurtz   muller        lhomme        lagerkvist   schulte 
      jefferson  moore  nightingale    petrie         exploiting strict short supports in the
algorithms shortgac  haggisgac and haggisgac stable allows us to outperform
the traditional constructive or algorithm  wurtz   muller        by orders of magnitude 
    backtrack stability of short supports
within a search tree  propagation algorithms often spend significant time backtracking
data structures  reducing or eliminating backtracking can improve efficiency  for example 
avoiding backtracking triggers can speed up a simple table propagator by more than   times
 gent et al       b   and mac   and mac   can be much more efficient  in both space
and time  if backtracking is avoided  regin         there are two potential advantages
of reducing use of backtracking state  it saves time restoring data structures  and it saves
space by avoiding storing supports on the backtrack stack 
definition       backtrack stable  a short support of constraint c with current domains d
is backtrack stable iff it always remains a short support  according to definition      after
backtracking up the search tree 
a short support s may support some variable x implicitly  and as we backtrack we may
add values back into the domain of x that are not consistent with s  meaning that s no
longer meets the definition of a short support  we give an example below 
example      consider the constraint b  m  x    y  for a boolean variable b  array of
variables m and variables x and y  when b is assigned false  this constraint is entailed 
and so the empty short support can be used to support all literals in m  x and y  this
support is not backtrack stable  as on backtracking when true is restored to the domain of
b  the empty set is no longer a short support 
 

fishort and long supports for constraint propagation

any support that is full length is backtrack stable  whenever the support is valid it
supports all literals it contains  backtrack stable supports always exist because we can use
full length supports in all cases  as in gac schema   although these may be much longer
than necessary 
in section   we exploit backtrack stability to define a new algorithm 

   shortgac  an overview
this section summarises the key ideas of the shortgac propagation algorithm  along
with an illustrative example  
shortgac maintains a set of short supports sufficient to support all valid literals of
the variables in the scope of the constraint it is propagating  we refer to these as the active
supports  the algorithm rests on exploiting the observation that  using short supports 
support can be established for a literal in two ways  first  as usual  a short support that
contains a literal supports that literal  second  a literal x   v is supported by a short
support that contains no literal of variable x  hence  the only short supports that do not
support x   v are those which contain a literal x   w for some other value w    v 
the following data structures are central to the operation of the shortgac algorithm 
numsupports is the total number of active short supports 
supportspervar is an array  indexed by  x   indicating the number of active short supports
containing each variable x 
supportlistperlit is an array  indexed by  x   v   of lists of active short supports containing each literal x   v 
if the number of supports containing some variable x is less than the total number of
supports then there exists a support s that does not contain x  therefore  s supports all
literals of x  the algorithm spends no time processing variables all of whose literals are
known to be supported in this way  only for variables involved in all active supports do we
have to seek support for literals with no active supports 
to illustrate  we consider the element example from the introduction  xy   z  with
x    x    x    y               and z               this constraint is satisfied iff the element in
position y of vector  x    x    x    equals z  suppose in the current state shortgac is storing
just one support  a    x       y      z       the data structures are as follows  where
 indicates that a literal is not valid  
   the details we present here are different from those we presented previously  nightingale et al          as
we have optimised the data structures and algorithms compared with our previous work  the two most
significant changes are  we no longer keep a count of supports per literal  saving overhead in maintaining
this  and data is stored in a one dimensional vector by literal  instead of a two dimensional array by
variable value  saving space if variables in a constraint have very different domain sizes  experiments in
appendix a demonstrate that the algorithms and data structures presented here perform better than
our previous implementation 
   for clarity  we have presented the one dimensional array supportlistperlit in a two dimensional format 

 

finightingale  gent  jefferson    miguel

supports 
supportlistperlit 
value
 
 
 
 
supportspervar 
numsupports 

x  
     y      z
variable
x  x 
y
       a 
     
  
     
  
 

 
 
 
 

a 
x 
  
 a 
  

 

   
z
  
 a 
  
  
 

all values of x  and x  have support  since their supportspervar counters are both
less than numsupports  therefore the shortgac algorithm can ignore x  and x  and
only look for new supports of x    y and z  consider finding a new support for literals
in z  shortgac can ignore the literals with at least one support  in this case z     
the algorithm looks for literals z   a where supportlistperlit z  a        here  z    
is such a literal  so shortgac seeks a new support for it  a possible new support is
b    x       y      z       following its discovery  we update the data structures 
supports 
supportlistperlit 
value
 
 
 
 
supportspervar 
numsupports 

a 
b 
x 
  
 a 
  

 

x  
     y      z
x  
     y      z
variable
x 
x 
y
 b      a 
  
    b 
  
  
  



 
 
 
 

   
   
z
 b 
 a 
  
  
 

now variable x  is also fully supported  since supportspervar x      numsupports  there
remain three literals for which support has not been established  y      z     and z     
for the first two shortgac finds supports such as c    x       y      z      and
d    x       y      z       no support exists for z      so   will be deleted  giving 
supports 

supportlistperlit 
value
 
 
 
 
supportspervar 
numsupports 

a 
b 
c 
d 
x 
  
 a 
 c 

 

     y      z
     y      z
     y      z
     y      z
variable
x 
y
 d   a  c 
  
 b 
  
 d 


 
 
 

x 
x 
x 
x 
x 
 b 
  
  

 

   
   
   
   
z
 b  d 
 a 
 c 

 

all valid literals are now supported  nothing further need be done until a change in
state  such as the removal of a value by a branching decision or propagation 
 

fishort and long supports for constraint propagation

   shortgac  details
the key tasks in implementing shortgac are  data structure update  iteration over
variables where supportspervar equals numsupports  and iteration over the unsupported
values of a variable  this section describes the infrastructure that allows us to perform
each of these tasks efficiently 
    shortgac data structures
an active short support s of arity k provides explicit support for each of the k literals it
contains  therefore  a reference to s must appear in k of the lists of supportlistperlit  to
do this  we represent s with two types of object  shortsupport and shortsupportcell  the
shortsupport object contains k shortsupportcell objects  each of which contains a literal
x   v   and a reference to the parent shortsupport  the elements of the array supportlistperlit are doubly linked lists of shortsupportcells  through the reference to the parent
shortsupport  we can iterate through all active short supports for a given literal 
the algorithm iterates over all variables x where supportspervar x  equals numsupports 
the following data structure represents a partition of the variables by the number of supports  it allows constant time size checking and linear time iteration of each cell in the
partition  and allows any variable to be moved into an adjacent cell  i e  if the number
of supports increases or decreases by    in constant time  it is inspired by the indexed
dependency array in gecode  schulte   tack        
varsbysupport is an array containing a permutation of the variables  variables are ordered
by non decreasing number of active supports  supportspervar x   
supportnumlowidx is an array of integers  indexed from   to the number of literals  that
being the maximum number of active supports possible  either supportnumlowidx i  is
the smallest index in varsbysupport with i or more active supports  or  when there are
no such variables  supportnumlowidx i   k where k is the total number of variables 
k acts as a sentinel value  the set of variables with i supports is 
varsbysupport supportnumlowidx i        supportnumlowidx i         
initially  all variables have   active supports  so supportnumlowidx        and the rest
of the array is set to k 
the following table illustrates how the partition data structure works  on a different
example with    variables   suppose supportspervar x    changed from   to    x  and y 
 boxed  are swapped in varsbysupport and the cell boundary is moved so that x  is in the
lower cell  consequently  supportnumlowidx    is incremented by   
varsbysupport  
supportspervar
x  updated

w 
 
w 

w 
 
w 

y 
 
x 

x 
 
x 

x 
 
y 

y 
 
y 

y 
 
y 

x 
 
x 

z 
 
z 

z 
 
z 

z 
 
z 

   a literal x   v is represented using a single integer i  there is a mapping between x   v and i  which
allows o    access to x and v from i and vice versa 

 

finightingale  gent  jefferson    miguel

require  sup  a shortsupport
   for all sc  shortsupportcell  sup do
  
 x   v   sc literal
  
if supportlistperlit x   v       then
  
attachtrigger x   v 
  
add sc to doubly linked list supportlistperlit x   v 
  
supportspervar x   
  
sx  supportspervar x 
  
cellend  supportnumlowidx sx   
  
swap x  varsbysupport cellend   
   
supportnumlowidx sx       numsupports  

procedure    addsupport sup 
for a variable x with supportspervar x    numsupports  shortgac iterates over the
values with zero explicit supports  to avoid iterating over all values  we use a set data
structure 
zerolits is an array  indexed by  x   of stacks containing the literals of variable x with zero
explicit support  in no particular order 
inzerolits is an array  indexed by  x   v   of booleans indicating whether literal x  
v  zerolits x  
when supportlistperlit x   v  is reduced to the empty list  if inzerolits x   v  is
false then x   v is pushed onto zerolits x   and inzerolits x   v  is set to true   as an
optimisation  values are not eagerly removed from the set  they are only removed lazily when
the set is iterated  also  the set is not backtracked  during iteration  a non zero value is
removed by swapping it to the top of the stack  and popping  this lazy maintenance never
costs work overall because  if the value would have been removed eagerly  then it will be
removed the next time the set is iterated  costing o     it can save work  because we may
never iterate over the list before the value would have been restored to the set again 
we use a free list to manage the set of shortsupport objects to avoid the cost of unnecessary object construction destruction  the shortsupport object retrieved from the free list
may contain too few shortsupportcell objects  so we use a resizable vector data structure 
the size is only ever increased 
    adding and deleting supports
when a support is added or deleted  all the data structures described above must be
updated  this is done by procedures    addsupport  and    deletesupport   both these
procedures iterate through the given short support  and for each literal in it they update
supportlistperlit  supportspervar  varsbysupport and supportnumlowidx  procedure   also
inserts the literal into zerolits if necessary  we briefly explain the maintenance of varsbysupport as it will become important in section      suppose we are adding support for
literal x   v in procedure    because it has an additional support  x must be moved to the
next cell in varsbysupport  line   finds the end of the cell that x is in  then we swap x to the
  

fishort and long supports for constraint propagation

require  sup  a shortsupport
   for all sc  shortsupportcell  sup do
  
 x   v   sc literal
  
remove sc from doubly linked list supportlistperlit x   v 
  
supportspervar x    
if supportlistperlit x   v       then
  
removetrigger x   v 
  
if inzerolits x   v  then
  
inzerolits x   v   true
  
zerolits x  push x   v 
   
sx  supportspervar x 
   
cellend  supportnumlowidx sx    
   
swap x  varsbysupport cellend   
   
supportnumlowidx sx      
    numsupports  

procedure    deletesupport sup 

require  x    v  where v has been pruned from the domain of x 
   while supportlistperlit x   v        do
  
deletesupport supportlistperlit x   v  pop   
   repeat
  
continueloop  false
  
for all i   supportnumlowidx numsupports       supportnumlowidx numsupports       do
  
y  varsbysupport i 
  
if shortgac variableupdate y    true then
  
continueloop  true
  
break out of for loop line  
    until continueloop   false

procedure    shortgac propagate  propagate x    v 

end of its cell using a subroutine swap xi   xj    this simple procedure  not given  locates
and swaps the two variables in varsbysupport  leaving other variables unaffected  to do so
it makes use of a second array  varsbysupinv  which is the inverse mapping of varsbysupport 
having done this  the cell boundary is decremented so that  in its new position   x is now
in the higher cell  another point to note is that addsupport will add a trigger for x   v
if sup is the only active explicit support to contain that literal  while deletesupport will
remove the trigger if the deleted support is the only support 
finally  we note that we do not have special purpose methods to undo these changes
on backtracking  on backtracking past the point where a support is added  we simply
call deletesupport  and similarly we call addsupport when we backtrack past a supports
deletion 
  

finightingale  gent  jefferson    miguel

require  variable x
   for all  x   v   zerolits x  do
  
if supportlistperlit x   v        then
  
remove  x   v  from zerolits x 
  
else
  
if v  d x  then
  
sup  findnewsupport x   v 
  
if sup   null then
  
prune x   v 
  
else
   
addsupport sup 
   
if supportlistperlit x   v        then
   
remove  x   v  from zerolits x 
   
return true
    return false

procedure    shortgac variableupdate   x   here and in other pseudocode we abstract
the detailed maintenance of the zerolits and inzerolits data structures  it might seem that
the test on line    must always succeed  however  although sup must support x   v  it
does not have to contain x   v as it might be an implicit support  the findnewsupport
function is discussed in section     
    the propagation algorithm
the shortgac propagator  procedure    is only invoked when a literal contained in
one or more active short supports is pruned   it first deletes all supports involving the
pruned literal  then it checks all variables y which are not implicitly supported  i e  where
supportspervar y  numsupports  line     each such variable y is checked by procedure  
 shortgac variableupdate  described below   if this call results in a new support being
found  then the data structures will have changed  shortgac variableupdate y  returns
true to indicate this  and we must break out of the for all loop  line    and go round again 
iteration therefore continues until either no new support is necessary or no new support
can be found 
shortgac variableupdate  procedure    is used to check the status of every variable
lacking implicit support  it iterates over zerolits  i e  the literals for a variable which might
have zero explicit supports  since zerolits is maintained lazily  on each iteration we first
check that the literal does indeed have no explicit support  and correct zerolits if necessary
 lines      the important case is that the literal indeed has no support  then  provided
that v is in the current domain of x  we must seek a new support by calling findnewsupport
for the constraint  if there is no support  value v must be pruned from the domain of x  or
if we have found a support we update data structures by calling addsupport 
to initialise data structures at the root of search  lines     of procedure   are invoked 
notice that these lines do not refer to the parameter x    v  and on first calling there are
no supports at all so the initial iteration at line   is over all variables 
   as we noted earlier  if watched literals are not available in a solver  a simple check can be made at the
start of the procedure  to return immediately if the removed literal is in no active support 

  

fishort and long supports for constraint propagation

    complexity analysis of shortgac
in this section we provide a complexity analysis of shortgac as it is used incrementally during search in a constraint solver  the analysis has as parameters the arity of the
constraint n  the maximum domain size d  and the cost f of calling findnewsupport  we
assume that both attaching and removing a trigger to a literal are o     this is the case
in minion      
first we observe that the swap procedure executes in o    time  each operation in swap
is o    and it does not loop  secondly we establish the time complexity of the procedures
addsupport and deletesupport  which are key to the algorithm 
lemma      procedure    addsupport  has time complexity o n  
proof  the outer loop on line   iterates over the literals in the short support  in the worst
case  there are n literals  we now consider the steps within this loop  the list test on
line   is o     as is the call to attachtrigger on line    adding the shortsupportcell to
the doubly linked list on line   is o     as are the following five array dereferences  as
established above  the swap procedure is also o     hence  addsupport is o n  
lemma      procedure    deletesupport  has time complexity o n  
proof  similarly to the add support procedure  the outer loop on line   has at most n
iterations  the removal from the doubly linked list on line   is o     as are the array
dereferences on line   and subsequently  the list test on line   and the call to removetrigger on line   are both o     as is the stack push operation on line    recalling once again
that the swap procedure is o     deletesupport is o n  
theorem      procedure    shortgac propagate  has time complexity in o n  d   ndf   
the upper bound can be obtained  i e  the worst case time complexity is in  n  d    ndf   
proof  analysis for the first statement breaks down into three parts 
first  the loop on line   is over the elements of supportlistperlit  the worst case occurs
when nd literals have an explicit support  of these supports  a maximum of  n    d    
can involve a particular literal  because this literal may be in the short support for every
literal of every other variable   n    d   and itself      the cost of the body of this loop is
o n  from lemma      so the total is o n  d   this will be dominated by the next part 
the second part is the loop from lines      the maximum number of iterations in
line   is n when all supports are full length and so the iteration in line   contains all n
variables  successive calls to procedure   at line   can add at most o d  new supports 
but each support addition triggers a restart of the loop beginning on line   over all n
variables  for a total of at most o n  d  calls to procedure    each such call involves o d 
iterations of the loop on line   of procedure    therefore the innermost loop is run at most
o n  d    times 
to complete the proof of the first statement  we consider the cost of the innermost loop
of procedure    within this loop  most operations are o     the exceptions being the call
to findnewsupport on line    cost f   and the call to addsupport on line     cost n from
lemma       but f is the dominating cost  since it must at least traverse the new support to
record it  however  of the n  d  iterations  there can be at most nd calls to findnewsupport 
  

finightingale  gent  jefferson    miguel

after which time all valid literals will have an explicit support  so the cost is either o n  d   
or o ndf    whichever is greater  in any case the cost is o n  d    ndf   
the upper bounds of ndf and n  d  can be attained in the worst case  if each literal
needs a new support  we have  ndf   calls to findnewsupport  we can have cost  n  d   
if there are nd literals with explicit support  each of size n  and each variable ends up
with  for example  d   values supported and d   values deleted  the worst case is thus
 n  d    ndf   
procedure   can be invoked at most n d     times in one branch of the search tree 
therefore the complexity for one branch is o n  d    n  d  f   
      a second complexity analysis
the analysis above can be very conservative when the total number  and maximum size  of
short supports is small  therefore  we give another complexity analysis with two additional
parameters  the maximum length l of short supports returned by findnewsupport  and
the total number s of distinct short supports that may be returned by findnewsupport 
this analysis also pertains to a branch of search rather than a single call to the propagate
algorithm 
the first part of this complexity analysis concerns the s short supports of length l 
each short support may be added to the active set once  and may be deleted once down a
branch  each short support must also be found by calling findnewsupport  with cost o f   
lemma     shows that the addsupport procedure takes o n  time  the same lemma can
be re stated in terms of l  because the loop in addsupport will iterate o l  times  giving a
total time of o l   this also applies to deletesupport  since there are s short supports  the
cost of finding  adding and deleting  collectively processing  short supports is o s l   f   
down a branch 
secondly  the algorithm may make calls to findnewsupport that return null  this can
happen at most n d         times  because this is the maximum number of domain values
that may be deleted  therefore the cost is o ndf   
in addition  shortgac does some operations that have not been charged to either of
the above categories  to analyse these  we must do a top down analysis of algorithm 
procedure   is invoked o s  times  each time a short support is invalidated   lines   
are already charged to processing short supports  the body of the loop on lines     may
be executed s times when a new support is found  and a further s times when no new
support is found  therefore o s  times in total down a branch of search 
now we come to the inner loop on lines     from lemma      below   unless a domain
is empty there is always one or more active short support  therefore  at most l variables
will be contained in all active short supports  so at most l variables are in the relevant
partition of varsbysupport  and the loop body will be executed o l  times 
lemma      after initialisation  procedure   always has at least one active short support
or a variable domain is empty 
proof  suppose the opposite  the algorithm is invoked each time a literal in an active short
support is pruned  therefore to delete all active short supports they must all contain one
literal x   v  if all active short supports contain variable x  then all values in the domain
  

fishort and long supports for constraint propagation

of x are not implicitly supported and must be explicitly supported  therefore v must be
the last remaining value in d x   now to prune x   v empties the domain and we have a
contradiction 
down a branch  this causes o sl  calls to shortgac variableupdate  on line    each
call to shortgac variableupdate takes o d  time because there may be d    invalid
literals or d explicitly supported literals in zerolits  other time spent in this procedure is
charged to processing short supports  or to pruning domains  therefore in the top down
analysis the cost is o sld  
overall  the time complexity is o s l   f     ndf   sld   a tighter bound in some cases
than the one given in the section above  for example  a sat clause has s   n  f   n  l    
and d      giving a time complexity of o n    for a branch of search 
    instantiation of findnewsupport
similarly to gac schema  bessiere   regin         shortgac must be instantiated with
a findnewsupport function  the function takes a valid literal  and returns a support if one
exists  otherwise returns null  one way to do this is to write a specialist findnewsupport
function for each constraint  we do this in each of the empirical case studies below  in
each case  the findnewsupport function is much simpler than a propagator for the same
constraint  we use lemma     to build the findnewsupport functions  which reduces the
task to finding satisfying tuples of simple constraints like x   y and x   y 
the alternative is to write a generic version of findnewsupport for the case where all
short supports are given as a list  we now detail two generic instantiations of findnewsupport for lists  and in our case studies below we compare them with the specialist functions 
      findnewsupport list
we provide a generic instantiation named findnewsupport list  procedure    that takes a
list of short supports for each literal  supportlist   including both the explicit and implicit
short supports for that literal  this is analogous to the positive instantiation of gacschema  bessiere   regin         findnewsupport list has persistent state  listpos  an
array of integers indexed by variable and value  initially    this indicates the current
position in the supportlist  the algorithm simply iterates through the list of supports 
seeking one where all literals are valid  listpos is not backtracked  with the consequence
that when the end of the list is reached  we cannot fail immediately and must search again
from the start back to listpos  down a branch of the search tree  any particular element
of the list may be looked at more than once  however  this algorithm is optimal in both
time and space across the search tree  gent         this surprising result is achieved by
amortizing the cost across all branches  practically  using listpos stops the algorithm always
starting from the first element of the list  and it seems to be a good tradeoff between avoiding
provably unnecessary work and doing too much data structure maintenance 
a constraint specific findnewsupport can sometimes find shorter supports than findnewsupport list  this is because a specific findnewsupport can take advantage of current
domains whereas the supportlist may only contain supports given the initial domains  for
example  if the constraint becomes entailed  the specific findnewsupport can return the
  

finightingale  gent  jefferson    miguel

require  x  v  supportlist
   for all j   listpos x  v       supportlist x  v  size     do
  
sup  supportlist x  v  j 
  
if all literals in sup are valid then
  
listpos x  v   j
  
return sup
   for all j          listpos x  v    do
  
sup  supportlist x  v  j 
  
if all literals in sup are valid then
  
listpos x  v   j
   
return sup
    return null

procedure    findnewsupport list  findnewsupport x  v   the first block searches from
the location of the previous support to the end of the support list  if it is unsuccessful the
search restarts from the start of the list in the second block  this circular approach removes
the need to backtrack listpos 
empty support whereas the list version we have presented cannot  we exploit this fact in
case study   below 
      findnewsupport ndlist
the list instantiation has two major disadvantages  first  it can be inefficient because it
is unable to skip over sets of invalid tuples  the literature contains many solutions to
this problem in the context of full length supports  for example binary search  lecoutre  
szymanek        or tries  gent  jefferson  miguel    nightingale         second  it can
require a large amount of memory  for each short support s  there are potentially nd
pointers to s  because there is a pointer to it for each literal that s implicitly supports 
in this section we give a second generic list instantiation based on nextdifference lists
 gent et al          we have a single list  named supportlist  containing all short supports  indexed by an integer   and a second list named ndlist where for each support
s  supportlist j   for each literal in the support s k   ndlist j  k  is the index of the next
support that does not contain literal s k   thus  when searching the list  the algorithm
is able to jump over sets of short supports that all contain the same invalid literal  the
version of findnewsupport for nextdifference lists is given in procedure   
this approach solves both of the problems with the list instantiation  it is able to jump
over sets of invalid short supports  and usually requires substantially less memory  in fact
it it is optimal in space  unlike the list instantiation   given t short supports of length at
most l  the nextdifference list is o tl   however it uses only one list of supports  therefore
it can spend time searching through short supports that do not support the desired literal 
    literals of assigned variables
suppose shortgac discovers a new support s that contains a literal x   v  and x is assigned to v  since x can take no value other than v  it is sound to remove x   v from s and
save the overhead of adding it  we apply this minor optimisation in all cases when using
shortgac  and also in all cases when using haggisgac  described in section     how  

fishort and long supports for constraint propagation

require  x  v  supportlist  ndlist
   j  listpos x  v 
   while j   supportlist size do
  
sup  supportlist j 
  
nextdiff  ndlist j 
  
for k           sup size     do
  
 y   b   sup k 
  
if b 
  d y  or  x   y and v    b  then
  
j  nextdiff  k   jump to next short support where y is assigned a different value  
  
continue while loop at line  
   
listpos x  v   j
   
return sup
    j   
    while j   listpos x  v  do
   
sup  supportlist j 
   
nextdiff  ndlist j 
   
for k           sup size     do
   
 y   b   sup k 
   
if b 
  d y  or  x   y and v    b  then
   
j  nextdiff  k   jump to next short support where y is assigned a different value  
   
continue while loop at line   
   
listpos x  v   j
   
return sup
    return null

procedure    findnewsupport ndlist  findnewsupport x  v 

ever this optimisation cannot be used with haggisgac stable  described in section   
because that algorithm retains active supports as it backtracks  and after backtracking the
literal x   v may no longer be assigned 

   haggisgac  dealing with both full length and strict short supports
we now introduce haggisgac  we show that it has better theoretical properties than
shortgac  furthermore  experiments show it runs substantially faster in many cases on
strict short supports than shortgac  which is specialised for strict short supports   and
substantially faster on full length supports than gac schema 
    introduction and motivating example
shortgac is designed to exploit the concept of implicit support  but has some inefficiencies when dealing with explicit supports and especially full length supports  consider for
example the constraint alldifferentexceptzero  in which the constraint is that all non zero
values in the array must be different  but that zero may occur freely  this constraint might
be used  for example  in a timetabling problem where classes taking place in different rooms
must be different  but we use zero to represent a room being unused and this can occur
multiple times  suppose we have alldifferentexceptzero  w  x  y  z    each variable with initial domain               supports for the constraint are full length supports in which every
  

finightingale  gent  jefferson    miguel

non zero value is different  or any three variables equalling zero where the last variable may
take any value  suppose we execute shortgac and reach the following situation 
supports 

supportlistperlit 
value
 
 
 
 
supportspervar 
numsupports 

a 
b 
c 
d 
e 
w
 a  b  e 
  
  
 c 
 

w
     x      y      z    
w
     x      y      z    
w
     x      y      z    
x      y      z    
w      x      y      z    
variable
x
y
z
 c  d 
 d 
 d 
 e 
 c 
 a  b 
 a 
 b  e 
 c 
 b 
 a 
 e 
 
 
 
 

notice that the lack of explicit supports for w     and w     is acceptable because we
have supportspervar w        numsupports      now suppose the literal y     is deleted
by some other constraint  this causes support d to be deleted  causing the following state 
supports 

supportlistperlit 
value
 
 
 
 
supportspervar 
numsupports 

a 
b 
c 
e 

     x      y
     x      y
     x      y
     x      y
variable
x
y
 c 

 e 
 c 
 a   b  e 
 b 
 a 
 
 
 

w
w
w
w

w
 a  b  e 
  
  
 c 
 

     z
     z
     z
     z

   
   
   
   

z
  
 a  b 
 c 
 e 
 

at this point shortgac iterates through the zerolits lists for all variables where
supportspervar   numsupports  in this case all four variables  it will discover that we must
find new supports for w      w     and z      however  this is inefficient for two reasons 
first  we should not need to check zerolits z  to discover z      because the support list for
z     became empty during the deletion of support d  so we could have discovered it then 
second  we should only need to look at zerolits w  because the deletion of d has caused
w to lose its implicit support  we should not need to check zerolits for x  y  z because
these variables were not implicitly supported prior to ds deletion  removing these two
reasons for inefficiency is the motivation behind our development of haggisgac  in this
example  it can focus directly on the literal z     and the set zerolits w  as the only literals
potentially needing new support 
the fundamental problem with shortgac is that it cannot efficiently detect when a
literal loses its last support  every variable with no implicit support is checked every time
any support is deleted  so shortgac can take o nd  time to find a single literal that needs
a new support or to discover that there is no such literal  to improve upon this  we wish
  

fishort and long supports for constraint propagation

i
varsbysupport i 
supportspervar
x  updated
x  updated
z  updated
x  updated
z  updated
z  updated
supportspervar

 
w 
 
w 
w 
w 
w 
w 
w 
 

 
w 
 
w 
w 
w 
w 
w 
w 
 

 
y 
 
x 
x 
x 
x 
x 
x 
 

 
x 
 
x 
x 
x 
x 
x 
x 
 

 
x 
 
y 
y 
y 
x 
x 
x 
 

 
y 
 
y 
y 
y 
y 
y 
y 
 

 
y 
 
y 
y 
y 
y 
y 
y 
 

 
x 
 
x 
x 
x 
y 
y 
y 
 

 
z 
 
z 
z 
z 
z 
z 
z 
 

 
z 
 
z 
z 
z 
z 
z 
z 
 

  
z 
 
z 
z 
z 
z 
z 
z 
 

figure    illustration of how deletesupport concentrates all variables that have just lost
their last implicit support  see main text for the full description 

haggisgac to be able to detect the loss of a literals last explicit support in time o    
and the loss of a variables last implicit support in time o     perhaps surprisingly  both
these goals are achievable by the use of data structures already existing in shortgac 
    finding literals with no support efficiently
of the two types of support  detecting when the last explicit support for a literal is lost
is the simpler task  when we delete a support  procedure   iterates through the literals
in a short support  for each literal it removes a shortsupportcell from the corresponding
supportlistperlit and updates data structures appropriately  if the list is empty  tested at
line   of procedure    the literal has lost its last explicit support  we now add this literal
to a scratch list of literals which have lost their last explicit support  we describe below
how we process the scratch list  the additional cost is o    when we detect an empty list 
because we are inside an existing test  there is zero additional cost when the literal has not
lost its last support  this contrasts with shortgac which tests  in procedure    every
variable with no implicit support  for a worst case cost of o n  even when no literal has
lost its last explicit support 
the more subtle task is to detect when a variable  and thus all literals involving it 
has lost its last implicit support  the reason this is more difficult is that we are seeking
variables that are not involved in the support being deleted  but in procedure   we iterate
through the literals that are in the support being deleted  the variables we seek are
those x which have supportspervar x    numsupports after the support deletion  while they
had supportspervar x    numsupports before the support deletion   variables that have
supportspervar x    numsupports both before and after the deletion have no implicit support
now  but did not lose implicit support because of this deletion   fortunately  our existing
maintenance of data structures happens to compact exactly these variables into a particular
region of varsbysupport  so we can find them very easily and efficiently  the compaction
happens through the sequence of calls to the procedure swap made by procedure    we
first show a worked example and we then prove the general properties we need 
in figure    we suppose there are    variables in a constraint  there are currently  
supports  and we are deleting a support involving variables x    x    x    z    z  and z    with
  

finightingale  gent  jefferson    miguel

the literals deleted in an arbitrary order from top  start  to bottom  finish   before we
start  the z variables already have supportspervar   numsupports      variables x and y
have supportspervar      and variables w have supportspervar      as we process literals
in deletesupport  pairs of variables are swapped  marked by boxes in each line  and the
boundaries move between cells  marked by vertical lines  of variables with equal supportspervar  at the end  w and x variables still have supportspervar       numsupports     
the z variables have supportspervar numsupports both before and after deletion  the only
variables that have lost their last implicit support are the y variables  the crucial point
is that at the end they lie precisely between the final boundary between   and   supports
 from i       and the initial boundary between   and   supports  from i       the following
simple results show that variables losing their last implicit support are always compacted
in a similar way 
lemma      suppose  before we delete a support s  that numsupports   p  and so numsupports   p    afterwards   for a variable x to lose its last implicit support  it has p   
explicit supports both before and after the deletion of s 
proof  if x initially has fewer than p  explicit supports  then x has more than one implicit
support and deleting s removes at most one of these  if x initially has p explicit supports 
then it is involved in s  since it is involved in all supports  and so has no implicit support
to lose  hence  x must initially have p    explicit supports and one implicit support and
s must be that one implicit support  therefore after the deletion of s  x has p    explicit
supports and no implicit supports 
lemma      we set p as in lemma      i as the value of supportnumlowidx p  when
deletesupport is called  and j as the value of supportnumlowidx p     when deletesupport
exits  when deletesupport finishes  the variables that lost their last implicit support during
the call to deletesupport are exactly the set of variables at indices in the range  j  i  in
varsbysupport 
proof  all variables with no implicit supports when deletesupport exits lie at index j or
greater in varsbysupport  this establishes the lower bound on the index range 
any variable z that has no implicit support at the start of the call must have p explicit
supports and so must be at index i or higher  z must be in the support being deleted 
because it is in all supports  when z is updated by deletesupport  it is always swapped with
the variable at index supportnumlowidx p   the index supportnumlowidx p  only increases
during deletesupport  so z stays at index i or higher throughout  thus the variables from
index i upwards at the finish are a permutation of those at the start  meaning that variables
which lost their last implicit support must be in the range  j  i   finally  any variable in
the range  j  i  has no implicit support at the end of the call  as it is at index j or above 
but had an implicit support at the start  as it is before i   therefore all and only variables
which lost their last implicit support lie at indices in the range  j  i  
from lemma      after we run deletesupport it is trivial to enumerate all variables
which have lost their last implicit support as a result  they are exactly the variables
varsbysupport k  for k   j  j         i    with i and j as defined in the lemma  enumerating
this list is the only additional work over that already done by procedure    so we have 
  

fishort and long supports for constraint propagation

corollary      given a constraint on n variables  the additional work to identify variables
which have lost their last implicit support is o    for each such variable where there are
some  and o    if there are none 
proof  we have already argued the case where there are variables which have lost implicit
support  if there are no such variables  there is still o    work to check that the range is
empty 
this low level of complexity contrasts very favourably with shortgac  when a support is deleted  procedure   iterates over all variables with numsupports explicit supports 
in the worst case this is o n  work even if no variable has lost its last implicit support  compared to the o    work that we now have  we now move on to the details of incorporating
these optimisations into a full suite of procedures for maintaining gac 
    haggisgac  details
two issues complicate the implementation of haggisgac compared with shortgac 
first  the lemmas above depend on all literals in a support being deleted in a single pass 
therefore  instead of acting immediately on finding a literal with no supports  we keep a list
of literals with lost supports for later treatment  second  we now have two cases in which
we might detect lost support  when the lost support is explicit or implicit  compared to
the single case in shortgac  where all lost supports are detected in the same way 
we introduce two simple data structures for storing literals and variables that have lost
explicit or implicit support as we find them 
litslostexplicitsupport is a set containing literals that have lost their final explicit support
and are not supported implicitly 
varslostimplicitsupport is a set containing variables that have lost their final implicit
support 
we have to adapt the deletesupport procedure from procedure    the new version is
shown as procedure    when we find a literal which has no explicit support  we immediately
check if it has an implicit support instead  line     if it does not  then we add it to the
set litslostexplicitsupport for later processing to find a new support or delete it  variables
which have no implicit support are detected after all literals have been deleted  this is done
by lines        which are justified by lemma     
the new propagate procedure is shown in procedure    like the earlier procedure   
we first delete all supports involving the literal to be deleted  but the rest of the procedure
is very different  we first iterate through all literals which lost their last explicit support 
and then the variables which lost their last implicit support 
for the lost explicit supports  we call haggisgac literalupdate  procedure     this
procedure has no analogue in shortgac  but is straightforward  the only point of interest
is that we still check whether a literal is supported  even though it was only added to
litslostexplicitsupport if it was not  the reason is that some support found by an unrelated
call to findnewsupport might also support this literal  if so we are done  but if not then
procedure   calls findnewsupport  if a new support is found it is added  but if not then
we have to prune the literal as being no longer supported 
  

finightingale  gent  jefferson    miguel

require  short support sup
   oldindex  supportnumlowidx numsupports 
   for all  x   v   sup do
  
remove sup from supportlistperlit x   v 
  
if supportlistperlit x   v       then
  
detachtrigger x v 
  
if  x   v    zerolits x  then
  
add  x   v  to zerolits x 
  
if supportspervar x    numsupports then
  
add  x   v  to litslostexplicitsupport
   
spv  supportspervar x 
   
swap x  varsbysupport spv  
   
supportnumlowidx spv   supportnumlowidx spv   
   
supportspervar x   spv 
    numsupports     for all i   supportnumlowidx numsupports        oldindex     do
   
add varsbysupport i  to varslostimplicitsupport

procedure    haggisgac deletesupport   sup   one subtlety is that we must add  x  
v  to zerolits  line    even if we also add it to litslostexplicitsupport  line     the only
case where this matters is that we seek and find a new implicit support  i e  not containing
x   v  but this is later lost  at the later point procedure    requires x   v to be in zerolits
because x   v might still have no explicit support 
require  x    v  where v has been pruned from domain of x 
   litslostexplicitsupport    
   varslostimplicitsupport    
   while supportlistperlit x   v        do
  
sup  first element of supportlistperlit x   v 
  
deletesupport sup 
   for all  y   b   litslostexplicitsupport do
  
haggisgac literalupdate y   b 
   for all z  varslostimplicitsupport do
  
haggisgac variableupdate z 

procedure    haggisgac propagate  propagate x    v 
for variables with lost implicit supports  we call haggisgac variableupdate  procedure      which is similar to procedure    the differences are that the return statements
from procedure   are omitted  we check at every iteration whether a new implicit support
has been found for x and if so exit the loop  and we do not remove x   v from zerolits if a
new explicit support has been found  allowing this to be done lazily in a later call at line   
we gain efficiency over shortgac for two reasons  first  variableupdate is only
called for variables that have just lost implicit support  second  there is no outer loop in
haggisgac propagate which must be restarted when a new support is found  as there
is in procedure    if we write m for the number of variables which have lost their last
implicit support  we have reduced the worst case number of calls to variableupdate from
haggisgac propagate from o n  d  where n is the arity of the constraint to m  since
m  n and m can often be much smaller than n or even zero  this is a significant gain 
  

fishort and long supports for constraint propagation

require  x   v  where last explicit support of x   v has been deleted
   if v  d x  and supportspervar x    numsupports and
supportlistperlit x   v       then
  
sup  findnewsupport x  v 
  
if sup   null then
  
prune x   v 
  
else
  
addsupport sup 

procedure    haggisgac literalupdate x   v 

require  variable x
   for all  x   v   zerolits x  do
  
if supportspervar x    numsupports then
  
return
  
if supportlistperlit x   v        then
  
remove  x   v  from zerolits x 
  
else
  
if v  d x  then
  
sup  findnewsupport x   v 
  
if sup   null then
   
prune x   v 
   
else
   
addsupport sup 

procedure     haggisgac variableupdate x 

    dealing efficiently with full length supports
when a full length support is added  shortgac increments numsupports and supportspervar for every variable  since we are only interested in the condition numsupports  
supportspervar x   a full length support cannot change this status for any variable  therefore we can save overheads in the case where we add a full length support  this is achieved
through a case split in haggisgacs versions of addsupport and deletesupport  if a
support is full length we do not update numsupports  supportspervar  and related data
structures  note that the test we apply is not that the final support is of arity n  but
the initial one before the omission of any assigned literals as the optimisation is correct
even if assigned literals are omitted  we omit the pseudocode for this optimisation  as the
changes are straightforward  this optimisation often improves performance on instances
with all full length supports by      and has no important effect on our other instances
with runtimes all within      with or without it  this optimisation is also applicable to
shortgac  but we did not implement it in that case because it does not address the key
inefficiency that algorithm has  i e  the repeated checking of variables which cannot have
lost their last implicit support  this does not affect our experimental results dramatically 
in most cases we found that the improved performance of haggisgac was larger than
this optimisation provides 
  

finightingale  gent  jefferson    miguel

   experimental evaluation of shortgac and haggisgac
the minion solver       gent  jefferson    miguel      a  was used for our experiments 
with the only changes being the additional propagators  in all experiments  all the compared
methods maintain gac  therefore  the solver explores the same search space in each case 
since the number of nodes searched is invariant  we compare the rate of search exploration 
measured in search nodes per second  
we used an   core machine with     ghz intel xeon e     cpus and   gb memory 
running ubuntu linux  where possible we ran    processes in parallel  for each combination of problem instance and propagator  we report the median of    runs   in some cases it
is not possible to run    processes in parallel because they exceed  gb memory  for these 
we ran just one process at a time  and we report the median of   runs  these instances
are marked with a  in the tables of results  if one method exceeded  gb  we sometimes
ran other comparable methods in series as well  this allows consistent comparison between
list and ndlist  and different propagation algorithms  it also means that  in the tables
does not necessarily indicate that the method uses more than  gb memory  we find the
median to be a very robust measure of performance  for reasons described in appendix b 
in all cases  we imposed a time limit of one hour  and a limit of           search nodes
 whichever is first   to avoid short runs when the solver can find a solution easily  we
searched for all solutions  we report complete cpu times  i e  we have not attempted to
measure the time attributable to the given propagator and we include any initialisation 
this has the advantage that we automatically take account of all factors affecting runtime 
including aspects  e g  cache usage  that we may not realise affect runtime  it does however
mean that our results tend to understate the difference between methods being studied 
for each case study  we implemented a findnewsupport method for shortgac and
haggisgac specific to the constraint  we also used the generic list instantiation  section        and the next difference list instantiation  section        for comparison where
possible  we compare shortgac and haggisgac with the special purpose propagator
 when available  
we also compare with shortgac long  shortgac with full length supports   with
haggisgac long  and with gac schema  bessiere   regin        as the closest equivalent algorithm without strict short supports  we discuss gac schema further in section     
gac schema  shortgac long and haggisgac long use the same  constraint specific 
findnewsupport as shortgac  and subsequently extend the short support to full length
using the minimum value for each extra variable 
in each case  the constraint can be compactly represented as a disjunction  therefore
we compare shortgac and haggisgac with constructive or  the algorithm used is
based on lagerkvist and schultes         without the rule for entailment detection  the

   source code for the solver with the three algorithms is available at http   www cs st andrews ac 
uk  pn haggisgac source tgz and problem instances and experimental results at http   www cs 
st andrews ac uk  pn haggisgac data instances tgz 
   in preliminary investigations  we found that running    processes in parallel gives consistent cpu time
results  and this consistency is improved by taking the median 

  

fishort and long supports for constraint propagation

 

element
element long
element list
element ndlist
lex
lex long
squarepack
squarepack long
squarepack list
squarepack ndlist

   

 

   

    
   
 
   
 

  

   

    

     

      

figure    summary comparison of shortgac and haggisgac  the x axis is median
nodes per second for shortgac  the y axis is speedup  or slowdown  of haggisgac  i e  the ratio of shortgac nodes per second to that of haggisgac 
hence   represents equal behaviour  while above   means that haggisgac was
faster 

implementation in minion is fully incremental  each disjunct is propagated incrementally
down a branch of search and backtracked as the search backtracks  
we do not compare with table constraints  as described by  for example  gent et al 
        because the constraints are too large  for example  the smallest element constraints
reported below have     allowed tuples  making it impossible even to generate and store the
list of allowed tuples 
to aid comparison between haggisgac and shortgac  in addition to the tables we
compare them graphically in figure    this figure shows the relative speedup  or in some
cases slowdown  of using haggisgac compared with shortgac 
    case study    element
we use the quasigroup existence problem qg   colton   miguel        to evaluate shortgac and haggisgac on the element constraint  the problem class has one parameter
n  specifying the size of an n  n table  qg  of variables with domains          n      rows 
columns and one diagonal have gac alldifferent constraints  following colton and miguels
model  the element constraints represent the qg  property that  i  j    j  i    i  where
i and j are members of the quasigroup and  is the quasigroup operator   this translates
as i  j   element qg  aux i  j   i   and aux i  j   n  qg i  j    qg j  i   where aux i  j  has
domain          n  n     
   personal communication with pascal van hentenryck indicated that there is an unpublished optimisation
of constructive or whereby some disjuncts need not be propagated in some cases  we did not implement
this optimisation 

  

finightingale  gent  jefferson    miguel

n
 
 
 
 
  

watch
elt 
      
      
      
      
      

specific
     
     
     
     

     

shortgac
list ndl
           
           
     
   
     
   


     
   

long
    

   

   

   

   

specific
      
     
     
     

     

haggisgac
list ndl
           
           
     
   
     
   


     
   

long
    

    

   

   

   

gac
sch 
    
   

   

   
mem

con
or
    
    
   

   

   

table    nodes searched per second for quasigroup existence problems  mem indicates
running out of memory      gb   columns correspond to propagation algorithms 
watch elt is the special purpose propagator  both shortgac and haggisgac
have four instantiations  specific  special purpose findnewsupport function for the
constraint   list  ndl  next difference list   and long  as described in the text  
gac sch is gac schema  and con or is constructive or 

for the constraint element x  y  z   the findnewsupport method for shortgac returns
tuples of the form hxi   j  y   i  z   ji  where i is an index into the vector x and j is a
common value of z and xi   shortgac list has all supports of this form  for constructive
or  we used  x    z  y        x    z  y           
we compare shortgac and haggisgac with the special purpose watched element
propagator  gent et al       b   gac schema and constructive or  table   presents our
results on qg   of the general purpose methods  using short supports  with specific  list or
ndlist instantiations  is dramatically better than any alternative  for example at n      
even the haggisgac list method  which is slower than haggisgac specific  is more
than     times faster than constructive or  the best of the other methods 
shortgac long runs about       faster than gac schema for n     to    slower at
n     but better at n      because gac schema uses more memory  recall that they both
use the same findnewsupport method  so this is a fair comparison of how efficiently they
exploit these supports  this is in contrast to our results reported previously  nightingale
et al          where shortgac was about half the speed of gac schema  two substantial differences account for the improvement  the improved data structures described in
section    and that we remove assigned literals from the full length supports as described
in section      haggisgac long is consistently faster than both shortgac long and
gac schema 
while much faster than methods using full length supports  list variants haggisgaclist and haggisgac ndlist are both slower than haggisgac element  and the same
is true for shortgac   this is to be expected as neither is specialised to the element
constraint  and both have to deal with data structures containing the lists of tuples  of the
two list variants  the ndlist variant runs much more slowly  however  its memory usage is 
as we expected  much less than haggisgac list  it used less than half as much memory
at n      improving to almost    times less memory at n      
haggisgac element is approximately twice as fast as shortgac element on these
instances  we believe this is because two variables are in all short supports  the index
and result variables  meaning that they are always supported explicitly  as can be seen
  

fishort and long supports for constraint propagation

n

gaclex

 
 
 
 
 
 
 
  
  
  
  
  
  
  
  

       
       
      
      
      
      
      
      
      
      
      
      
      
      
     

shortgac
specific long
            
            
            
            
            
            
      
   
      
   
      
   
      
   
      
    
      
    
      
    
     
    
     
    

haggisgac
specific long
            
             
            
            
            
            
      
   
      
   
      
   
      
   
      
    
      
    
      
    
     
    
     
    

gacschema
     
     
     
     
     
   
   
   
   
    
    
    
    
    

   

con
or
     
     
     
     
     
   
   
   
   

    

    

    

    

    

    

table    nodes searched per second for bibds  gaclex is the special purpose propagator 
and other columns are named as in table   

in figure    list  ndlist and long instantiations of haggisgac are also faster than
the same instantiations of shortgac but by a smaller margin  the special purpose
watched element propagator is the fastest method  being     times faster when n      
watched element also appears to be scaling better as n increases  constructive or is
much slower than all the methods that exploit strict short supports  however it is faster
than haggisgac long  overall it is clear that exploiting strict short supports is very
beneficial compared with other general purpose methods 
    case study    lex ordering
we use the bibd problem to evaluate shortgac and haggisgac on the lexicographic
ordering constraint  the lex constraint is placed on both the rows and columns  to perform
the double lex symmetry breaking method  flener et al          we use the bibd model
given by frisch  hnich  kiziltan  miguel  and walsh         and the gaclex propagator given by frisch  hnich  kiziltan  miguel  and walsh         we use bibds with the
parameter values   n       n       n       n      n  
for the constraint lexleq x  y   on arrays x and y   we define mxi   min dom xi   
and myi   max dom yi     the findnewsupport method for shortgac finds the lowest
index i           n  such that mxi   myi   or i   n  the case i   n arises when x cannot
be lexicographically less than y   so a support is sought for x   y   if i   n  the support
contains xi   mxi   yi   myi   for each index j   i  if mxj   myj   then the short support
contains xj   mxj   yj   myj otherwise there is no valid support and null is returned 
the lex constraint on two arrays of length n and domain size d has more than dn short
supports in any short support set  because all assignments where the two arrays are equal
satisfy the constraint and cannot be reduced  shortgac list and shortgac ndlist
  

finightingale  gent  jefferson    miguel

are not practical for any substantial constraint so we omit them from the comparison  for
constructive or we use the following representation with n     disjuncts   x    y      x   
y   x    y          including the final case where all pairs are equal 
table   presents the results of our experiments on non list based methods with values of
n from   to     it is clear that the best method is the special purpose gaclex propagator 
with haggisgac coming second  on this problem  haggisgac and shortgac perform similarly  haggisgac and shortgac are by far the best general purpose methods 
for the largest instances they run about     times slower than the special purpose method 
while outperforming the next best method by almost     times  again  haggisgac long
and shortgac long outperform gac schema  and on these instances the difference is
even more marked 
haggisgac long can be substantially faster than shortgac long  as can be seen
in figure    this is largely explained by the optimisation of section     
to summarise  these experiments on the lex constraint clearly show the benefit of
haggisgac and shortgac compared with other general purpose propagation methods 
their speed even approaches that of the special purpose gaclex propagator 
    case study    rectangle packing
the rectangle packing problem  simonis   osullivan         with parameters n  width and
height  consists of packing all squares from size      to n  n into the rectangle of size
width  height  this is modelled as follows  we have variables x        xn and y        yn   where
 xi   yi   represents the cartesian coordinates of the lower left corner of the i  i square 
domains of xi variables are          width  i   and for yi variables are          height  i  
variables are branched on in decreasing order of i  to place the largest square first   with
xi before yi   smallest value first  the only type of constraint is non overlap of squares i
and j   xi   i  xj     xj   j  xi     yi   i  yj     yj   j  yi    minion does not
have the special purpose non overlap constraint  simonis   osullivan         so we only
report a comparison of general purpose methods  for the experiment we used the optimum
rectangle sizes reported by simonis and osullivan 
the domains of xn and yn are reduced to break flip symmetries as described by simonis
and osullivan         our focus is performance of the non overlap constraint  and so we
did not implement the commonly used implied constraints 
the findnewsupport function for shortgac is as follows  if any of the four disjuncts
above are entailed given the current domains  return the empty support  indicating entailment   otherwise  return a support with two literals to satisfy one of the four disjuncts 
the list used for shortgac list and shortgac ndlist has all supports of size   
in table    we compare haggisgac and shortgac with other general purpose
methods  we can see that haggisgac is the fastest method  with shortgac second 
haggisgac list and haggisgac ndlist  as well as shortgac list and shortgacndlist  performed well compared to gac schema and constructive or  however at
n       haggisgac list consumes    mb memory and haggisgac ndlist    mb 
and with n      it was not possible to run these methods with    processes in parallel 
interestingly  the performance of the two list variants of haggisgac is reversed from
case study    here  ndlist is significantly faster than list in most cases  as expected 
  

fishort and long supports for constraint propagation

n w h
        
        
        
        
        
        
        
         
        
         

specific
      
      
      
     
     
      
      
     
      
     

shortgac
list
ndl
     
     
     
     
     
     

            

            

            

            


     
   


   
     


     
   

long
     
     
   
   
   
   
   
   
   
   

specific
      
      
      
      
      
      
      
      
      
     

haggisgac
list
ndl
     
     
     
     
     
     

            

            

            

            

            

            

            

long
     
     
     
   
   
   
   
   
   
   

gac
sch 
     
     
   
   
   
   
   
   
   
   

con
or
   
   
   
   
   
   
   
  
   
  

table    nodes searched per second for rectangle packing instances  all columns are named
as in table   

ndlist used less memory  though less dramatically than before  it used from about    
to     of the memory of haggisgac list 
of the other methods  all are always at least    times slower than haggisgac 
haggisgac long is faster than gac schema in all cases  also shortgac long is
faster than gac schema on all instances except            this contradicts the result we
previously reported  nightingale et al          and some explanation of this is given in the
first case study  
table   shows that haggisgac  with the squarepack instantiation  is substantially
faster than shortgac on most of the instances  with the exception of n      and n     
where shortgac is slightly faster  when compared with shortgac for list  ndlist 
and long instantiations in figure    we see that haggisgac is mostly between    and
    faster  in summary  these results very clearly show the benefits of using strict short
supports 
    comparing haggisgac with gac schema
across all the above experiments  haggisgac long runs significantly faster than gacschema  from a minimum of about     faster to more than three times faster  even
though our code contains overhead for dealing with strict short supports  we compared
memory usage across all experiments  and found very similar performance across all instances  we found that haggisgac long uses less than    more memory on all except
bibd instances  and on bibd it uses less than     more memory than gac schema 
however  the comparison has been only on functional instantiations of full length supports  and on constraints that admit strict short supports  in this section  we broaden the
comparison by using the list instantiations rather than functional ones  and using problem
instances that have been used previously for comparing table constraints 
we compared against gac schema because it is very similar to haggisgac and
shortgac conceptually  all three algorithms maintain a list of supports for each literal 
which is updated and backtracked during search  gac schema was carefully implemented
  

finightingale  gent  jefferson    miguel

sports
carseq
graceful
pqueens
bibd

  

  

 

 

 

   
   

    

     

      

figure    comparison of gac schema and haggisgac list on full length table constraints  x axis is nodes per second for gac schema  y axis is speedup of
haggisgac list 

following the pseudocode of the original paper  bessiere   regin         while some code
is shared among all three algorithms  each was optimised independently  for example 
gac schema has a different implementation of supportlistperlit  named sc in  bessiere  
regin         which is specialised to full length supports 
in contrast to gac schema  other table constraint propagators such as str   lecoutre 
      and mddc  cheng   yap        are entirely different to haggisgac  and it would
be difficult to create truly comparable implementations of them 
we report on the use of haggisgac list only  because it searches for supports in the
same way as gac schema  with one difference we discuss below   we used the structured
instances from gent et al          except the semigroup class  in addition  we used car
sequencing instances from nightingale         specifically model b instances numbered
       these instances contain a large number of ternary table constraints 
figure   shows that haggisgac list is almost always faster than gac schema on
these problems  for bibds it is not clear which algorithm is better  haggisgac is
always at least marginally faster on the sports scheduling  prime queens and graceful
graphs instances  in most cases in the range        faster  haggisgac is substantially
faster on car sequencing  to seek new supports  haggisgac calls procedure    and when
it finds a new support it stores the index of it in listpos  haggisgac does not backtrack
listpos as described in section        gac schema is similar  but it does backtrack listpos 
and it ensures optimality down a branch of search by iterating only from listpos to the
end of the list  bessiere   regin         profiling shows that gac schema is hindered by
backtracking listpos  by block copying memory  on car sequencing  where there are a very
large number of table constraints       on instance     and large domains  some of size
  

fishort and long supports for constraint propagation

over        alternative memory management techniques might speed up gac schema  so
we do not claim that haggisgac is fundamentally    times faster than gac schema 
    results summary
to summarise the three case studies  haggisgac does indeed outperform shortgac
on many instances  sometimes by more than two times and commonly by more than     
shortgac is only rarely faster  but only on one instance by as much as      overall  in
our experiments  haggisgac is clearly a better algorithm than shortgac  furthermore 
haggisgac and shortgac perform very well compared to constructive or and gacschema  a result which validates the idea of strict short supports 
finally  we have shown experimentally that haggisgac can outperform gac schema
on problems containing only full length supports  we discuss why this should be in appendix c as it is not a major focus of this paper 

   backtrack stability and short supports
within a search tree  haggisgac often spends significant time backtracking data structures  reducing or eliminating backtracking can improve efficiency  for example mac  
and mac   can be much more efficient  in both space and time  if backtracking is avoided
 regin         in this section we present a new algorithm that saves time by not deleting
short supports on backtrack  and saves memory by bounding the total number of stored
short supports  including those on the backtrack stack  
the new algorithm requires that short supports have the backtrack stability property 
a short support is backtrack stable iff it remains a short support after backtracking  section      
in our three case studies  we find that the short supports we construct for the element and
lex constraints are backtrack stable  but for rectangle packing they are not  for rectangle
packing  we generate the empty support when the constraint is entailed  the empty support
is not backtrack stable unless the constraint is entailed at the root node of search 
we introduce the algorithm haggisgac stable where we know all short supports
are backtrack stable  the key change is that we do not delete supports when we backtrack
past their point of introduction  because they are stable  they are still correct at ancestors
of the node they were introduced at  this can save time over the previous algorithms  since
we sometimes need to do no work at all on backtracking  also  as we show below  we obtain
very tight limits on space usage of stored supports 
to present haggisgac stable  we introduce the notion of a prime support of a
deleted literal  a prime support of a deleted literal is a support  either explicit or implicit 
which will be a valid support for that literal when the literal is restored on backtracking 
the invariant we maintain after deleting a literal is that either we have labelled a deleted
support on the backtrack stack as its prime support or the literals variable is currently
implicitly supported  with this invariant  we guarantee that when we backtrack to the
point where the literal is restored  it must be supported again  either by the prime support
which we can restore  or by the known implicit support 
the task of finding the prime support for a literal naturally splits into three cases  the
simplest case is that haggisgac stable itself deletes literals when not able to find a
  

finightingale  gent  jefferson    miguel

necessary new support  the prime support is then just the implicit or explicit support
whose deletion caused the fruitless search for a new support 
the second case is where a literal is pruned by some other constraint or the search
procedure  and the pruned literal had an explicit support in this constraint  all its explicit
supports must be deleted as no longer valid  and we can label an arbitrary one to be the
literals prime support  we simply choose the last one to be deleted 
the third case is unfortunately complicated  it is that a literal is pruned outside the
current constraint  and the literal had an implicit support but no explicit support  this is
difficult precisely because the pruned literal does not have any link to its implicit support 
providing and maintaining such a link throughout search would negate the efficiencies we
have gained  our solution to this problem is to be lazy  the variable of the pruned
literal is implicitly supported  while we have any implicit support for the variable  we are
maintaining the invariant described above  so when the literal is pruned we need do nothing
in this case  we only need do any work when this variable loses its last implicit support 
if it ever does  when this happens  an invalid literal which had no explicit support must
by definition be in the relevant zerolits list  whereas previously we ignored invalid literals
when iterating through zerolits  we now can label the deleted implicit support as a prime
support for the invalid literal 
we will show in lemma     that haggisgac stable stores at any time at most
o z  supports  where z is the total number of literals  this can save a lot of memory
because haggisgac and shortgac may store o z     supports  because there can be
o z  deletions of literals down a branch  and for each deletion a new set of o z  supports
may be stored  our experiments later will show that this difference in memory usage can
be significant in practice  at its most effective  memory usage was reduced by    times 
    details of haggisgac stable
in haggisgac stable  we have to control with great care the deletion and restoration of
supports  instead of  as in the rest of this paper  simply reversing the addition or deletion
of a support at a node by respectively deleting or adding it back when we backtrack past
that node  in short we never delete an active support on backtracking  and only add back
in a deleted support if it is a prime support for a literal with no current active support 
when deleting a support  we setup a counter numprimesupported  it is initially    and
is incremented each time we find the support is a prime support  when the propagation
algorithm finishes  for any support with numprimesupported      the support can be destroyed and its space reclaimed  otherwise  we place numprimesupported new pairs on the
backtrack stack  each pair consists of the deleted support and the literal it is a prime
support for  on backtracking  when we pop a pair  we first check if any current support
already supports the literal  if so  we simply decrement numprimesupported  and if this
reduces to    again we reclaim the supports space  if the literal is not supported  then we
restore the support via a call to addsupport  in this way all literals the support was prime
for are now guaranteed to be supported 
a relatively minor difference is that when we iterate through zerolits we now delete invalid literals from zerolits  we can do this because on backtracking we can restore them into
  

fishort and long supports for constraint propagation

require  x   v  where last explicit support of x   v has been deleted
   if v  d x  then
  
if supportspervar x    numsupports and supportlistperlit x   v       then
  
sup  findnewsupport x  v 
  
if sup   null then
  
prune x   v 
  
increment lastsupportperlit x   v  numprimesupported
  
push hx   v  lastsupportperlit x   v i onto backtrackstack
  
else
  
addsupport sup 
    else
   
increment lastsupportperlit x   v  numprimesupported
   
push hx   v  lastsupportperlit x   v i onto backtrackstack

procedure     haggisgac stable literalupdate   x   v   in comparison to procedure    we update numprimesupported and backtrackstack 

zerolits because they are on the backtrack stack  and doing so enables the space complexity
result in lemma     
haggisgac stable is similar to haggisgac  where appropriate we simply describe
differences to save space  the procedure haggisgac stable propagate is almost the
same as procedure    calling the backtrack stable variants of deletesupport  literalupdate
 procedure     and variableupdate  procedure      in addition  at the end of this algorithm
we destroy and reclaim the space for any deleted support for which numprimesupported     
the procedure haggisgac stable deletesupport  called with support s  is also very
similar to its predecessor  procedure    with some additions  first  it initialises numprimesupported for s to    second  we have new data structures lastsupportperlit for a deleted
literal x   a and lastsupportpervar for a variable x  in terms of procedure    these are
both assigned to s at line   and line     respectively   note these assignments do not
make s a prime support  this will be checked later 
procedure    is analogous to procedure   but with enough differences that we show it
in detail here  it identifies prime supports  and when necessary increments numprimesupported and pushes invalid literal support pairs onto the backtrack stack  we also present
procedure    in detail  the analogue to procedure     again it identifies prime supports 
increments the counter and adds pairs to backtrackstack  one difficult case arises  from
line     here  x   a has been pruned  but externally to this constraint  if it had been
pruned by procedure     it would not be in zerolits  when x   a is restored on backtracking we still need to make sure it has support  since it has no explicit support  it is in
zerolits   its last support must be this implicit support we are deleting  therefore we store
the support on backtrackstack  a minor change to note is that we remove literals from
zerolits  at lines    and    
whenever a new search node  including the root  is entered  a null is pushed onto
the backtrackstack  this is used as a marker for the procedure haggisgac stablebacktrack  procedure      which processes literal support pairs until it reaches the null 
this restores prime supports for literals being put back into the domain on backtracking 
but only if no other support is currently known  if the numprimesupported counter for
  

finightingale  gent  jefferson    miguel

require  variable x
   for all  x   v   zerolits x  do
  
if supportspervar x    numsupports then
  
return
  
if supportlistperlit x   v        then
  
remove  x   v  from zerolits x 
  
else
  
if v  d x  then
  
sup  findnewsupport x  v 
  
if sup   null then
   
prune x   v 
   
increment lastsupportpervar x  numprimesupported
   
push hx   v  lastsupportpervar x i onto backtrackstack
   
remove  x   v  from zerolits x 
   
else
   
addsupport sup 
   
else
   
increment lastsupportpervar x  numprimesupported
   
push hx   v  lastsupportpervar x i onto backtrackstack
   
remove  x   v  from zerolits x 
procedure     haggisgac stable variableupdate   x   this is similar to procedure   
with the addition of maintenance of numprimesupported and backtrackstack 
   while the top element of backtrackstack is not null do
  
pop hx   v  supi from backtrackstack
  
if sup has not yet been restored then
  
if supportspervar x    numsupports and supportlistperlit x   v       then
  
haggisgac stable addsupport sup 
  
else
  
 another support exists for x   v 
  
decrement sup numprimesupported
  
if sup numprimesupported     then
   
destroy sup and reclaim space
   
if supportlistperlit x   v       then
   
add  x   v  to zerolits x 
    pop null from backtrackstack

procedure     haggisgac stable backtrack  performs backtracking using backtrackstack 

a support becomes zero  the support can be destroyed as it is no longer necessary  note
that literals are put back into zerolits if necessary at line     reversing their deletion in
procedure    
we cannot use the optimisation described in section      of deleting literals in supports
for variables that are assigned  because this may break the backtrack stability property 
  

fishort and long supports for constraint propagation

however  we retain the optimisation of section     for full length supports  but again omit
pseudocode showing this in the interest of focusing on the essential aspects of the algorithms 
    improved space complexity of haggisgac stable
our approach improves the space complexity of haggisgac stable compared with haggisgac  as the following lemma shows 
lemma      for a constraint involving z literals  at most  z supports are stored  either as
active or as deleted supports on the backtrack stack 
proof  we define a function from supports to literals  if the support is still active  it was
found from a call to findnewsupport for a specific literal  and we map the support to this
literal  similarly  if the support is on the backtrack stack  then it is in a pair with at least
one literal it is a prime support for  map the support to any one of these literals  every
stored support falls into one of these two categories  because if a support is deleted and it
is not put onto the backtrack stack  its space is reclaimed  no three supports are mapped
to the same literal because 
 for valid literals  findnewsupport will not be called again if an existing active support
exists for that literal 
 for invalid literals  each literal appears in a pair on the backtrack stack at most
twice  the only case where a literal appears as often as twice is that a literal with a
prime support already on the stack is processed when its variable loses its last implicit
support  in this case  the literal must be in zerolits  and the newly deleted implicit
support will be added to the backtrack stack for this literal  but this can only happen
once because we delete the literal from zerolits the first time it happens 
thus the number of supports is bounded above by  z 
the bound  z in lemma     would improve to z if we maintained zerolits eagerly
instead of lazily  but at the expense of higher overheads elsewhere 

   experimental evaluation of haggisgac stable
we compare haggisgac stable to haggisgac using the same experimental setup as
in section    as well as tables of results  we provide a graphical comparison of runtimes of
haggisgac stable and haggisgac in figure    and of their memory usage in figure   
table   and figure   shows results for the instances of section      we present all
four instantiations of haggisgac stable  along with the fastest instantiation of haggisgac  the watched element special purpose propagator  and constructive or  which
was faster than gac schema in table     for element  we observe about a     slowdown 
and again a slight slowdown for both list variants  for full length supports  we see almost
identical performance 
table   shows the results for instances of section      haggisgac stable lex performs slightly worse than haggisgac lex  though is in fact never more than     worse
and very slightly faster on the largest instances  this might be because supports found
  

finightingale  gent  jefferson    miguel

deep in search are likely to contain more literals than supports found earlier  meaning that
when we backtrack the longer supports are retained instead of replaced by the earlier and
more efficient short supports  if so  this advantage disappears for the long variants  indeed  haggisgac stable long performs much better than haggisgac long  and the
improvement increases with n  being about     times for n      
the rectangle packing instantiation of shortgac described in section   generates an
empty support when the constraint becomes entailed  causing all variables to be implicitly
supported from that point on  this empty support is not backtrack stable  so cannot
be used with haggisgac stable  we implemented a new backtrack stable variant of
findnewsupport  in which the empty support is not returned  but is otherwise the same
as before  the list and long variants are not affected because they do not return the
empty support in this case  in table    we use the instances from section      results show
significant slowdowns by using backtrack stability for rectangle packing  more than   times
for n       this is probably because of the inability to return the empty support  on the
other hand  we see speedups of about     for the list variants  and in some cases a factor
of   speedup for full length supports 
we see in figure   that the memory usage goes down greatly when stability is used
on full length supports  possibly contributing to speedups in these cases  the greatest
reductions are in the case of element  in two cases more than    times less memory  on the
other hand  there is no significant reduction in memory usage in any non long variant 
we also tested haggisgac stable against gac schema as in section      this gave
very similar performance to haggisgac and was therefore better than gac schema  we
omit detailed results  there was no significant memory advantage compared to haggisgac  with the stable variant saving less than      we therefore do not seem to gain the
advantages we saw earlier from backtrack stability on full length supports 
we conclude that backtrack stability can speed up haggisgac significantly  and
greatly reduce memory usage when using full length supports  however  care must be
used  because backtrack stability can be harmful if insisting on backtrack stability increases
the size of returned supports 

    related work
our use of counters to count supports is inspired by ac   mohr   henderson         there
has been some study of compressing the tuples of a constraint into a compact data structure
in order to make propagation more efficient  for example  gent et al         used tries  and
cheng and yap        applied mdds  there has also been extensive study of searching
the list of tuples to find the first valid tuple  approaches include binary search  lecoutre  
szymanek         trie search  gent et al          and approaches similar to skip lists such as
ndlists  gent et al         and hologram tuples  lhomme        lhomme   regin        
all these techniques are orthogonal to the main focus of this paper because they assist in
finding supports  not in maintaining the set of active supports  we have adapted ndlists
to contain short supports in section        it may also be interesting to adapt some of the
other approaches 
str  maintains a sparse set of all valid satisfying tuples of the constraint  lecoutre 
       updated variable domains are computed from this set each time the algorithm is
  

fishort and long supports for constraint propagation

n

watchelt

 
 
 
 
  

      
      
      
      
      

haggisgac
specific
      
     
     
     

     

haggisgac stable
specific
list ndlist long
      
     
     
    
     
     
           

     
     
   
   

     
     
   
   



            
   
   

con
or
    
    
   

   

   

table    nodes searched per second for quasigroup existence problems  all columns are
named as in table   
n

gaclex

 
 
 
 
 
 
 
  
  
  
  
  
  
  
  

       
       
      
      
      
      
      
      
      
      
      
      
      
      
     

haggisgac
specific long
            
             
            
            
            
            
      
   
      
   
      
   
      
   
      
    
      
    
      
    
     
    
     
    

haggisgac stable
specific
long
      
      
       
     
      
     
      
     
      
     
      
     
      
     
      
   
      
   
      
   
      
   
      
   
      
   
     
   
     
  

gacschema
     
     
     
     
     
   
   
   
   
    
    
    
    
    

   

con
or
     
     
     
     
     
   
   
   
   

    

    

    

    

    

    

table    nodes searched per second for bibds  gaclex is the special purpose propagator
for lex  and all other columns are named as in table   
n w h
        
        
        
        
        
        
        
         
        
         

haggisgac
specific
      
      
      
      
      
      
      
      
      
     

haggisgac stable
specific
list ndlist
      
     
     
      
     
     
      
     
     

     
            

            
     


      
     
     

            
     

            
     


      
     
     

            
     

long
     
     
     
   
   
     
     
     
   
   

gacschema
     
     
   
   
   
   
   
   
   
   

table    nodes searched per second for rectangle packing instances  all columns are named
as in table   

  

finightingale  gent  jefferson    miguel

element
element long
element list
element ndlist
lex
lex long
squarepack
squarepack long
squarepack list
squarepack ndlist

 
 
 
 
 
   
   
 
   
   
   
   
   
 

  

   

    

     

      

 e   

figure    summary comparison of haggisgac and haggisgac stable  the x axis is
median nodes per second for haggisgac  the y axis is speedup  or slowdown 
of haggisgac stable 

 

 

   

   

   

    

    
    

element
element long
element list
element ndlist
lex
lex long
squarepack
squarepack long
squarepack list
squarepack ndlist
     

      

 e   

 e   

 e   

figure    summary comparison of memory usage  kib  of haggisgac and haggisgacstable  the x axis is median memory usage for haggisgac  the y axis is
reduction  or increase  in usage of haggisgac stable  i e  the ratio of haggisgac memory usage to that of haggisgac stable  hence   represents
equal behaviour  while below   means that haggisgac stable used less memory 

  

fishort and long supports for constraint propagation

invoked  there is no concept of maintaining support  or seeking new support for a literal 
it would be interesting to investigate adapting str  to handle short supports  this would
result in an entirely different algorithm to the ones presented in this paper  possibly with
complementary strengths 
the mdd propagator mddc  cheng   yap        maintains an mdd incrementally
during search  the mdd is a compressed representation of the satisfying tuples of the
constraint  the time complexity of mddc is linear in the initial size of the mdd  therefore
the degree of compression is vital to the efficiency of the algorithm  in some cases  if a
constraint is amenable to strict short supports  it will also compress well into an mdd
 given an appropriate variable ordering   for example  the lex constraint compresses well
partly because  given the variable order x    y    x    y           the constraint can be satisfied by
assigning a prefix of the variables  lex is amenable to short supports for the same reason 
however  some constraints have a small set of short supports but cannot be compressed
effectively into an mdd  suppose we have a disjunction of equality constraints for each pair
of n variables of domain size d  after n    variables  the mdd must have d cn  states 
another property of mdd compression might indicate an interesting direction for future
work  lex also compresses well into an mdd because multiple assignments to a prefix of the
variables lead to the same subsequent vertex  e g   x       y       and  x       y        
this is something that our short support algorithms are not currently able to exploit 
katsirelos and walsh        proposed a different generalisation of support  named ctuples  a c tuple contains a set of values for each variable in the scope of the constraint  any
valid tuple whose values are drawn from the c tuple is a  full length  support  katsirelos and
walsh give an outline of a modified version of gac schema which directly stores c tuples 
they also present experiments based on a different propagator  gac   r  demonstrating
a modest speed improvement for c tuples compared to conventional full length supports 
when a c tuple contains all values of some variable  it will nevertheless be recorded  in sc  
as support for each value individually  katsirelos   walsh         the algorithm has no
concept of implicit support 
in the context of constructive or  lhomme        observed that a support for one
disjunct a will support all values of any variable not contained in a  the concept is similar
to a short support albeit less general  because the length of the supports is fixed to the
length of the disjuncts  he presented a non incremental constructive or algorithm for two
disjuncts 
our algorithms have a similar flavour to gac schema  bessiere   regin         so it
was natural to compare them to gac schema  however there are other gac algorithms
such as gac          bessiere et al         and it would be interesting to compare these
to our algorithms 

    conclusions
we have introduced and detailed three general purpose propagation algorithms for short
supports  they each can either be given a specialised function to find new supports for each
constraint  or used with a function that accepts an explicit list of short supports  where
strict short supports are available  all three algorithms perform very well  and provide much
  

finightingale  gent  jefferson    miguel

better performance than the general purpose methods gac schema and constructive or 
this shows the value of using strict short supports 
the first algorithm we studied was shortgac  for which we described improvements
compared to our earlier report on this algorithm  nightingale et al          we identified a significant inefficiency with shortgac when dealing with explicit supports  we
introduced a new algorithm  haggisgac which corrects this flaw  has better theoretical
complexities  and performs much better than shortgac in our experiments  in three
case studies  haggisgac is far faster than the general purpose methods  in the best case
it even achieved speeds more than     of that of a special purpose propagator  perhaps
remarkably  while able to deal with both strict short and full length supports  haggisgac outperformed shortgac on strict short supports and gac schema on full length
supports  i e  the cases which those algorithms are respectively specialised for 
our third algorithm  haggisgac stable  can retain supports on backtracking  it can
be less effective than haggisgac if it invalidates the use of certain strict short supports 
but it can also be significantly faster on problems with only full length supports  and reduce
memory usage greatly in those cases 
all the proposed algorithms are excellent for propagating disjunctions of constraints  in
all experiments with disjunctions we found our algorithms to be faster than constructive or
and gac schema by at least an order of magnitude  and up to three orders of magnitude 
to summarise  we have shown the value of the explicit use of strict short supports in
general purpose propagation algorithms for generalised arc consistency  when strict short
supports are available  exploiting them yields orders of magnitude improvements for generic
propagation algorithms  in some cases  we even found that a generic algorithm can come
close to the performance of a specialised propagator  previously  short supports do not
seem to have been recognised as important in their own right  our overall contribution is
to correct this and focus on short supports as first class objects 

acknowledgments
we would like to thank anonymous reviewers and bilal syed hussain for their comments 
and epsrc for funding this work through grants ep h         and ep e         

appendix a  comparison of shortgac and shortgac ijcai
in section    we noted that we have optimised data structures and algorithms for shortgac  compared with our previous presentation  nightingale et al          to demonstrate
that these are indeed improvements  we compared the two implementations of shortgac
on the three case studies used in this paper  we use the name shortgac ijcai for the
previous version  we are not quoting results from our previous work  nightingale et al  
       but have rerun all experiments using the environment described in section    we
also updated the codebase to minion      instead of minion      in our earlier paper  for
each algorithm and instance  we report nodes searched per second and peak memory use 
table   shows results for the instances of section      it is clear from the results that
shortgac makes much better use of memory and is also faster than shortgac ijcai
  

fishort and long supports for constraint propagation

    

low memory  sections   and  
high memory  sections   and  
list   ndlist  section    
gac schema   constructive or

    
    
   
    
    
    
    
 
   

 

  

   

    

     

      

 e   

figure    scatterplot of median nodes per second  x axis  against the median absolute
deviation of this divided by the median  y axis   we distinguish between the
main experiments of sections   and    the cases where medians were of only  
runs  the list variants used on table constraints in section      and data in the
paper for gac schema and constructive or 

on these instances  table   shows the results for instances of section      as with element 
shortgac makes better use of memory and is faster than shortgac ijcai  although
improvements are not as great as before  in table    we use the instances from section     
as in the previous two case studies  shortgac is consistently better in both speed and
memory use  we conclude that the algorithms and data structures used in this paper are
indeed superior to those we used previously  nightingale et al         

appendix b  median absolute deviation of our experiments
in our experiments we report the median of either    or   runs  to assess how robust the
median was as a measure we looked  for each combination of instances and algorithm  at
the median absolute deviation  mad   i e  the median of the absolute difference of data
points from the median  figure   shows the mad for all algorithm instance combinations
as a fraction of the median for that case  this shows     algorithm instance combinations
we tested  including some combinations not reported in detail in this paper   for nodes per
second  the maximum mad we found is always less than     of the median  with a worst
case of        this was haggisgac long for n     in table    there were only four
more cases with mad above    of the median  figures for memory usage were even more
consistent  with only two cases  at      and       showing mad above    of the median
and and no others above     any major conclusions we draw do not regard a     change
of behaviour between one method and another as significant  and therefore we can say that
the median is a robust measure of performance 
  

finightingale  gent  jefferson    miguel

n
 
 
 
 
  

shortgac
node rate
     
     
     
     

     

shortgac ijcai
node rate
     
     
     
     

     

shortgac
memory
     
     
     
      

      

shortgac ijcai
memory
      
      
       
       

       

table    nodes searched per second and memory use  kib  for quasigroup existence problems  comparison of shortgac with shortgac ijcai 

n
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  

shortgac
node rate
      
      
      
      
      
      
      
      
      
      
      
      
      
     
     

shortgac ijcai
node rate
      
      
      
      
      
      
      
      
      
      
      
      
     
     
     

shortgac
memory
     
      
      
      
      
      
      
      
       
       
       
       
       
       
       

shortgac ijcai
memory
     
      
      
      
      
      
      
      
       
       
       
       
       
       
       

table    nodes searched per second and memory use for bibd problems  comparison of
shortgac with shortgac ijcai 

n w h
        
        
        
        
        
        
        
         
        
         

shortgac
node rate
      
      
      
     
     
      
      
     
      
     

shortgac ijcai
node rate
      
      
      
     
     
      
     
     
      
     

shortgac
memory
      
      
      
      
      
      
      
      
      
      

shortgac ijcai
memory
      
      
      
      
      
      
      
      
      
       

table    nodes searched per second and memory use for rectangle packing  comparison of
shortgac with shortgac ijcai 

  

fishort and long supports for constraint propagation

appendix c  comparison of gac schema and haggisgac
we showed in section     that haggisgac outperforms gac schema when dealing with
full length supports  this is despite the fact that haggisgac has small overheads for
dealing with strict short supports even when none exist  we now discuss briefly why this
may be so 
gac schema has the concept of current supports  each literal has one current support 
which is one of the active supports that contain the literal  there is an additional data
structure s     for each active support    s    is a list of all literals that have  as their
current support  hence when  is invalidated  gac schema finds a new current support
for each literal in s     or deletes the literal   in haggisgac we dispensed with this
entirely  the sign that a literal needs a new support is not that it lost its current support 
but that its support list  supportlistperlit  is empty  there is a small potential saving from
not maintaining s    
a second  possibly more important  difference is that gac schema is more eager than
haggisgac  when a literal x   v loses its current support  gac schema will check if
other active supports containing x   v are valid  an o n  operation for each one  if they
are all invalid  gac schema then calls findnewsupport  if this returns null then x   v
is deleted  haggisgac does none of this  avoiding completely the cost of checking validity  this is safe because if every support is invalid  the literal deletion from each support
will cause a call to deletesupport and the last will result in the empty list  causing a call
to findnewsupport  both approaches are correct  but gac schemas is wasteful because
it performs unnecessary validity checks  however  one cannot guarantee time saving  because gac schema can perform deletions sooner  possibly affecting the way the propagator
interacts with the other propagators 

references
bessiere  c   hebrard  e   hnich  b     walsh  t          the complexity of reasoning with
global constraints  constraints                 
bessiere  c     regin  j  c          arc consistency for general constraint networks  preliminary results  in proceedings ijcai       pp         
bessiere  c   regin  j  c   yap  r  h  c     zhang  y          an optimal coarse grained
arc consistency algorithm  artificial intelligence                  
cheng  k  c  k     yap  r  h  c          an mdd based generalized arc consistency
algorithm for positive and negative table constraints and some global constraints 
constraints                 
colton  s     miguel  i          constraint generation via automated theory formation  in
proceedings cp       pp         
flener  p   frisch  a  m   hnich  b   kiziltan  z   miguel  i   pearson  j     walsh  t         
breaking row and column symmetries in matrix models  in proceedings cp       pp 
       
frisch  a  m   hnich  b   kiziltan  z   miguel  i     walsh  t          global constraints
for lexicographic orderings  in proceedings cp       pp        
  

finightingale  gent  jefferson    miguel

frisch  a  m   hnich  b   kiziltan  z   miguel  i     walsh  t          propagation algorithms
for lexicographic ordering constraints  artificial intelligence                   
gent  i  p          an optimality result on maintaining list pointers during backtracking
search  tech  rep  circa preprint         university of st andrews 
gent  i  p   jefferson  c     miguel  i       a   minion  a fast scalable constraint solver 
in proceedings ecai       pp        
gent  i  p   jefferson  c     miguel  i       b   watched literals for constraint propagation
in minion  in proceedings cp       pp         
gent  i  p   jefferson  c   miguel  i     nightingale  p          data structures for generalised
arc consistency for extensional constraints  in proceedings aaai       pp         
gent  i  p   petrie  k     puget  j  f          handbook of constraint programming  foundations of artificial intelligence   chap  symmetry in constraint programming  pp 
        elsevier science inc   new york  ny  usa 
jefferson  c   moore  n  c  a   nightingale  p     petrie  k  e          implementing logical
connectives in constraint programming  artificial intelligence                        
katsirelos  g     walsh  t          a compression algorithm for large arity extensional
constraints  in proceedings cp       pp         
king  a   cromarty  l   paterson  c     boyd  j          applications of ultrasonography
in the reproductive management of dux magnus gentis venteris saginati  veterinary
record              
lagerkvist  m  z     schulte  c          propagator groups  in proceedings cp       pp 
       
lecoutre  c          str   optimized simple tabular reduction for table constraints  constraints                 
lecoutre  c     szymanek  r          generalized arc consistency for positive table constraints  in proceedings cp       pp         
lhomme  o     regin  j  c          a fast arc consistency algorithm for n ary constraints 
in proceedings aaai       pp         
lhomme  o          an efficient filtering algorithm for disjunction of constraints  in
proceedings cp       pp         
lhomme  o          arc consistency filtering algorithms for logical combinations of constraints  in integration of ai and or techniques in constraint programming for
combinatorial optimization problems  cp ai or     pp         
mackworth  a  k          on reading sketch maps  in reddy  r   ed    ijcai  pp         
william kaufmann 
mears  c  d          automatic symmetry detection and dynamic symmetry breaking for
constraint programming  ph d  thesis  clayton school of information technology 
monash university 
mohr  r     henderson  t  c          arc and path consistency revisited  artificial intelligence                 
  

fishort and long supports for constraint propagation

nightingale  p          the extended global cardinality constraint  an empirical survey 
artificial intelligence                  
nightingale  p   gent  i  p   jefferson  c     miguel  i          exploiting short supports
for generalised arc consistency for arbitrary constraints  in proceedings ijcai      
pp         
puget  j  f          automatic detection of variable and value symmetries  in proceedings
cp       pp         
regin  j  c          generalized arc consistency for global cardinality constraint  in proceedings aaai       pp         
regin  j  c          maintaining arc consistency algorithms during the search without
additional space cost  in proceedings cp       pp         
rossi  f   van beek  p     walsh  t   eds            handbook of constraint programming 
elsevier 
schulte  c     tack  g          implementing efficient propagation control  in proceedings of
trics  techniques for implementing constraint programming systems  a conference
workshop of cp       st andrews  uk 
simonis  h     osullivan  b          search strategies for rectangle packing  in proceedings
cp       pp       
wurtz  j     muller  t          constructive disjunction revisited  in proceedings of
the   th annual german conference on artificial intelligence  advances in artificial
intelligence  ki     pp          springer verlag 

  

fi