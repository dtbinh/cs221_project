journal of artificial intelligence research                

submitted        published      

optimal rectangle packing 
an absolute placement approach
eric huang

ehuang parc com

palo alto research center
     coyote hill road
palo alto  ca       usa

richard e  korf

korf cs ucla edu

ucla computer science department
    e boelter hall
university of california  los angeles
los angeles  ca            usa

abstract
we consider the problem of finding all enclosing rectangles of minimum area that can
contain a given set of rectangles without overlap  our rectangle packer chooses the xcoordinates of all the rectangles before any of the y coordinates  we then transform the
problem into a perfect packing problem with no empty space by adding additional rectangles  to determine the y coordinates  we branch on the different rectangles that can be
placed in each empty position  our packer allows us to extend the known solutions for a
consecutive square benchmark from    to    squares  we also introduce three new benchmarks  avoiding properties that make a benchmark easy  such as rectangles with shared
dimensions  our third benchmark consists of rectangles of increasingly high precision  to
pack them efficiently  we limit the rectangles coordinates and the bounding box dimensions
to the set of subset sums of the rectangles dimensions  overall  our algorithms represent
the current state of the art for this problem  outperforming other algorithms by orders of
magnitude  depending on the benchmark 

   introduction
given a set of rectangles  our problem is to find all enclosing rectangles of minimum area
that will contain them without overlap  we refer to an enclosing rectangle as a bounding box 
to avoid confusion  the optimization problem is np hard  while the problem of deciding
whether a set of rectangles can be packed in a given bounding box is np complete  via a
reduction from bin packing  korf         the consecutive square benchmark is a simple set
of increasingly difficult benchmarks for this problem  where the task is to find the bounding
boxes of minimum area that contain a set of squares of dimensions                  up
to n  n  korf         for example  figure   is an optimal solution for n      we will
use this benchmark to explain many of the ideas in this paper  but our techniques are not
limited to packing squares  and apply to all rectangles 
rectangle packing has many practical applications  including modeling some scheduling problems where tasks require resources that are allocated in contiguous chunks  for
example  consider the task of scheduling and allocating contiguous memory addresses to
programs  the width of a rectangle represents the length of time a program runs  and the
c
    
ai access foundation  all rights reserved 

fihuang   korf

figure    an optimal solution for n     of the consecutive square benchmark  packing
squares of dimensions                          and        in a bounding box of minimum
area  which is         

  

fioptimal rectangle packing  an absolute placement approach

height represents the amount of contiguous memory it needs  a rectangle packing solution
tells us both when programs should be run  as well as which memory addresses they should
be assigned  similar problems include scheduling when and where ships of different length
can be berthed along a single  long wharf  li  leong    quek         as well as the allocation and scheduling of radio frequency spectra usage  mitola   maguire         rectangle
packing also appears when loading a set of rectangular objects on a pallet without stacking
them  some cutting stock and layout problems also contain rectangle packing subproblems 
    overview
the remainder of this article is organized as follows  we first introduce various benchmarks in section   that specifically define the rectangle packing instances we will solve 
in section    we review the state of the art rectangle packers and their techniques  which
provides a foundation upon which we present our new work  we follow in section   with the
data collected and compare our work against the previous state of the art using previous
benchmarks  we also compare the difficulty of previous benchmarks with our new ones 
in section    we present a benchmark of rectangles of successively higher precision
dimensions  new solution techniques to handle this  and follow with experimental results 
then we compare our methods to the competing search spaces used for packing highprecision rectangles  and show that our methods remain competitive 
sections   and   explain various avenues for future work  concluding this article by
summarizing all of our contributions and results  we have previously published much of
this work in several conference papers  huang   korf                    

   benchmarks
there are several reasons motivating our benchmarks  first  our benchmarks describe
instances with a single parameter n   allowing researchers to easily reproduce the instances 
second  because the instances are unique  optimal solutions that are reported can be easily
validated by others  these are advantages over many real world instance libraries and
randomly generated ones  third  our benchmarks define an infinite set of instances where
each successive instance is harder than the previous  a solver is superior to another solver
if it can solve the same instance faster  or a larger instance in the same amount of time 
by contrast  comparison using a library of instances may require counting the number of
instances that are completed within a given time limit  furthermore  with instance libraries 
often one solver performs well on one subset of instances while a competing solver performs
well on a different subset  making such comparisons inconclusive 
we believe our benchmarks capture some of the more difficult instances a rectangle
packer may face so we do not investigate the modeling and generation of random problems 
although clautiaux et al         and others have used random instances  the non random
benchmarks used by korf        and simonis and osullivan        have better facilitated
the comparison of state of the art packers  however  for more comprehensive overviews 
we refer the reader to the numerous surveys available  lodi  martello    vigo        lodi 
martello    monaci        dowsland   dowsland        sweeney   paternoster        
  

fihuang   korf

    previous benchmarks
several of the previous benchmarks used in the literature can be shown to be easier than the
benchmarks that we propose  part of this is due to the fact that benchmarks  like solvers 
may also be improved with further research  to ensure that they cover various properties of
rectangles  in addition to providing an easy way to compare performance among different
packers and measure progress 
the consecutive square benchmark  korf         is a simple set of increasingly difficult
instances  where the task is to find all bounding boxes of minimum area that contain a set
of squares of sizes                  up to n  n   prior to our work  many of the recent stateof the art packers used this popular benchmark to measure performance  including that of
moffitt and pollack         korf  moffitt  and pollack         and simonis and osullivan
        to date  the largest instance solved for this problem is n      shown in figure   
using our packer  huang   korf         we do not consider the problem of packing squares
in a square because this benchmark gets much easier as the problem size increases  due to
large differences in the areas of consecutive square bounding boxes 
in the unoriented consecutive rectangle benchmark  korf et al          an instance is
a set of rectangles of sizes                  up to n   n       and rectangles may be
rotated by    degrees  as we will subsequently explain  the fact that there are many pairs
of rectangles in this instance which share equal dimensions causes the optimal solutions to
leave no empty space  making this benchmark easy to solve  we include this benchmark for
completeness  but note that it is not an effective measure for comparing different packers 
finding only the first optimal solution is another benchmark simonis and osullivan
       have used in conjunction with problem instances from the unoriented consecutiverectangle benchmark  in contrast to our problem of finding all optimal solutions  they
measure the time it takes to find only the first optimal solution  which makes it much more
difficult to reliably compare against other solvers unless the focus of the research is on value
ordering and tie breaking among bounding boxes of equal area 
for example  simonis and osullivan        report that to find the first solution to
n     takes            hours     minutes  and    seconds   as shown in table   on page
    there are six solutions for n                                                         
each requiring our solver cpu times of                                       and         
respectively  there are no smaller bounding boxes we needed to test because the optimal
solution has no empty space  so if we used simonis and osullivans termination criteria and
just returned the first optimal solution  we would only need    seconds  therefore  finding
all minimum bounding boxes instead of just the first one is a benchmark which produces
harder problems for larger n   and better facilitates program comparisons 
    properties of easy benchmarks to avoid
to motivate our new benchmarks  we will now explain why the previous benchmarks tended
to be much easier in comparison  and why we have constructed our new benchmarks to
describe instances consisting of rectangles with unique dimensions  without duplicates  and
without most of the area being occupied by only a few rectangles 
  

fioptimal rectangle packing  an absolute placement approach

 a  solution in a        bounding
box for the unoriented instance      
                          

 b  solution in a        bounding
box for the unoriented instance   
                             

figure    examples of solutions for instances of rectangles with equal dimensions 

      rectangles with equal dimensions
in the unoriented consecutive rectangle benchmark  all rectangles share a dimension with
another rectangle  for example  figure  a is an optimal solution for n      in optimal
solutions  rectangles of equal dimensions tend to line up next to each other  forming larger
rectangles and leaving little empty space  in figure  a  the      and      line up  as
do the      with the       and the      with the       in fact  the solutions to this
benchmark all have a much smaller percentage of empty space than similar sized instances
from the consecutive square benchmark  where all rectangles have unique dimensions  we
also notice that benchmarks with duplicate rectangles  such as that in figure  b  are solved
quickly 
      rectangles with small area and small dimensions
figure  b is also an example of a perfect packing  because there is no empty space in the
solution  problems with perfect packings tend to be easy for two reasons  one is that if
we test bounding boxes in increasing order of area  we test fewer boxes  since we never test
a box with more than the minimum area required  the second is that for these problems 
rather than deciding for each rectangle where it should go in the bounding box  a more
efficient algorithm is to decide for each cell of empty space which rectangle should occupy
  

fihuang   korf

it  as soon as a small region of empty space is created that cant accomodate any remaining
rectangles  the algorithm can backtrack 
in both the consecutive square and the unoriented rectangle benchmarks  a few large
rectangles capture much of the total area in an instance  thus  the packer does not search
too deeply before using up the allowable empty space  with little empty space  early
backtracking is very likely since we cannot find a place for the next rectangle  therefore 
small rectangles in these benchmarks have an insignificant impact on the search effort 
in previous benchmarks  such as the consecutive square benchmark  the retangles with
the largest area also have the largest dimensions  making it obvious which rectangles to
place first  because the largest rectangles are the most constrained  and impose the most
constraints on the remaining rectangles 
by contrast  in our new benchmarks there is a trade off between rectangles with large
dimensions and those with large area  the widest rectangle in our oriented equal perimeter benchmark  described below  has the smallest branching factor as we search for xcoordinates  however  it also has the least area  so during search it wont constrain the
placement of the remaining rectangles much  this raises the non trivial question of the best
variable ordering for non square rectangles 
    new benchmarks
we propose several new benchmarks that are more difficult when comparing instances
with the same number of rectangles  our experimental results make use of the following
benchmarks  in addition to the consecutive square and unoriented consecutive rectangle
benchmarks described above 
      equal perimeter rectangles
first  we present the oriented equal perimeter rectangle benchmark  where each instance is a
set of rectangles of sizes    n       n            n         n     and rectangles may not be
rotated  see figure     given n   all rectangles are unique and have a perimeter of  n     in
our experiments  this benchmark is much more difficult than either the consecutive square
benchmark or the unoriented consecutive rectangle benchmark  korf et al         for the
same number of rectangles  we tested our state of the art packer  huang   korf       
on both old and new benchmarks  n     from our oriented equal perimeter benchmark
took over nine hours to solve  while n     from the consecutive square and unoriented
consecutive rectangle benchmarks took only one second and six seconds  respectively 
second  we present the unoriented double perimeter rectangle benchmark  where instances are described as a set of rectangles      n           n            n       n      
n  n   and rectangles may be rotated by    degrees  all rectangles here are unique and
have a perimeter of  n   not only is this benchmark more difficult than the benchmarks
used previously in the literature  but this benchmark also is more difficult than the oriented
one we introduced in the previous paragraph  in our experiments using all of our techniques 
n     took over two days to solve 
so far  the benchmarks that we have discussed all have low precision integer dimensions 
this property poses no problem for our packer  which enumerates the various integer coordinate locations where a rectangle may be placed  with high precision values  however 
  

fioptimal rectangle packing  an absolute placement approach

figure    an optimal solution for n     of the oriented equal perimeter benchmark  packing
oriented rectangles of dimensions                           and       in a bounding box
of minimum area  which is        

  

fihuang   korf

the number of distinct positions increases dramatically  this motivates our study of packing rectangles with high precision dimensions  in particular  we propose the unoriented
high precision rectangle benchmark  where instances are described as a set of rectangles
 
   
 
 
 
                   up to n  n      the methods used to solve this benchmark are quite
different from those used in the low precision case 

   solution techniques
in this section we describe previous solution strategies as well as the various new techniques
we use in our rectangle packer  we first describe our techniques as they apply to the consecutive square benchmark  the oriented equal perimeter benchmark  and the unoriented
double perimeter benchmark  our work on the unoriented high precision rectangle benchmark is not included here because the methods are significantly different  and is deferred
to section   
    previous work
some of the earlier work that focused on optimal methods for packing a set of rectangles in
a given bounding box were motivated by the problem of pallet loading  dowsland       
used depth first search on an abstract graph representation of the search space to solve
the problem optimally on problem sets modeled after real world pallet and box dimensions 
although her problem instances contained an average of    rectangles and up to     her
benchmarks were far easier than those we consider here  as all of the rectangles were the
same size  and there was a significant amount of empty space in the solutions  bhattacharya
et al         extended the work with additional lower bounds and pruning techniques based
on dominance conditions and demonstrated their work on the same benchmarks 
in examining rectangle packing instances where rectangles are of different dimensions 
onodera et al         used depth first search  in which each branching point in their search
space was a commitment to a particular non overlap constraint between two rectangles 
lower bound and graph reduction techniques were applied to prune the search space  allowing them to optimally solve problems with up to six rectangles 
chan and markovs blobb        packer used branch and bound in order to find the
minimum area bounding box that can contain a set of rectangles  their solver could handle
up to eleven rectangles  and they observed that instances with duplicate rectangles were
much easier  causing their packer to cluster such rectangles together in an optimal solution 
lesh et al s solver        used depth first search  placing each rectangle first in the bottommost and left most position in which it fit  the bottom left heuristic  see chazelle         to
determine whether or not a set of rectangles can be packed in a given enclosing rectangle 
they were able to handle about twenty nine rectangles in ten minutes on average  but their
testbed consisted only of instances whose optimal solutions had no empty space 
clautiaux et al         presented a branch and bound method in which all the x coordinates for the rectangles were computed prior to any of the y coordinates  while assigning
x coordinates  their method uses a relaxation similar to the cumulative constraint  aggoun
  beldiceanu        which requires that the sum of the heights of all rectangles overlapping
a particular x coordinate cannot exceed the height of the bounding box  the y coordinates
are then determined using a search space derived from the bottom left heuristic  chazelle 
  

fioptimal rectangle packing  an absolute placement approach

       using optimized data structures from martello and vigo         beldiceanu and
carlsson        applied the plane sweep algorithm used in computational geometry to detect violations of the non overlap constraints  and later adapted the technique to a geometric
constraint kernel  beldiceanu  carlsson  poder  sadek    truchet         lipovetskii       
proposed a branch and bound algorithm that placed rectangles in the lower left hand positions 
the prior state of the art  due to korf              and simonis and osullivan        
both divide the rectangle packing problem into the containment problem and the minimal
bounding box problem  the former tries to pack a given set of rectangles in a given bounding
box  while the latter finds the bounding box of least area that can contain the given set of
rectangles  in both packers the algorithm for the minimal bounding box problem calls the
algorithm for the containment problem as a subroutine 
    our overall search strategy
like korf et al s        algorithm  we have a minimum bounding box solver which calls a
containment problem solver  and like simonis and osullivan         we assign x coordinates
prior to any of the y coordinates 
although we use some of simonis and osullivans        ideas  we do not take a
constraint programming approach in which all constraints are specified to a general purpose
solver like prolog  instead  we implemented our program from scratch in c    allowing us
to more flexibly choose which constraints to use at what time and to naturally encode the
search space we use for the y coordinates  we implemented a chronological backtracking
algorithm with dynamic variable ordering  our algorithm works in five stages as it goes
from the root of the search tree down to the leaves 
   the minimum bounding box algorithm generates an initial candidate set of bounding
boxes of various widths and heights 
   the containment solver is called for each bounding box in order of increasing area 
and for each infeasible bounding box  we insert another back into the candidate set of
bounding boxes with a height one unit greater  if a packing was found  we continue
testing boxes of equal area to find all optimal solutions before terminating 
   the containment solver first works on the x coordinates in a model where variables
are rectangles and values are x coordinate locations  using dynamic variable ordering
and a constraint that detects infeasible subtrees 
   for each x coordinate solution found  the problem is transformed into a perfect packing instance 
   it then searches for a set of y coordinates in a model where variables are empty corners
and values are rectangles 
we now describe in detail each of these steps 
  

fihuang   korf

    minimum bounding box problem
one way to solve the minimum bounding box problem is to find the minimum and maximum
areas describing the set of candidate and potentially optimal bounding boxes  boxes of all
sizes are generated with areas within this range  and then tested in non decreasing order
of area until all solutions of smallest area are found  a lower bound on the area is the
sum of the areas of the given rectangles  an upper bound on the area is determined by
the bounding box of a greedy solution found by setting the bounding box height to that
of the tallest rectangle  and then placing the rectangles in the first available position when
scanning from left to right  and for each column scanning from bottom to top 
there are several techniques  korf              that we use to prune the set of bounding
boxes  which we review here  we first generate a set of widths for our bounding boxes 
starting with the width of the widest rectangle up to the width of the greedy solution
described above  then for each width  we generate a feasible height using lower bounds
which we will subsequently describe  the resulting bounding boxes are used to initialize
a min heap sorted in non decreasing order of area  the search proceeds by calling the
containment solver on the bounding box of minimal area in this heap  if the box is infeasible 
then we increase the height of the box by one  and insert the new box back into the min heap 
for a given bounding box width  we initialize its height to the maximum of the following
lower bounds  first  the height must be at least the height of the tallest rectangle in the
instance  second  the height must be large enough to accommodate the total area of the
rectangles in the instance  third  for every pair of rectangles  if the sum of their widths
exceed the width of the bounding box  then the bounding box height must be at least
the sum of their heights  since they cant appear side by side  but one must be on top of
the other  fourth  the set of rectangles whose widths are greater than half the width of
the bounding box must all be stacked vertically  including the rectangle of smallest height
whose width is exactly half the width of the bounding box  finally  if certain properties
exist for a given rectangle packing instance  we force the height to be greater than or equal
to the width to break symmetry  for example  one sufficient property is having an instance
consisting of just squares  since a solution in a w  h bounding box easily transforms into
another one in a h  w bounding box  another sufficient property is when every rectangle
of dimensions w  h can correspond to another one of dimensions h  w 
for unoriented instances  given a bounding box width  certain rectangles may be forced
into one orientation  improving the lower bound on the bounding box height  note that we
can also break the symmetry on the bounding box dimensions for every unoriented instance 
      anytime algorithm
in a problem instance with many rectangles  or when an immediate solution is required 
korf        provides an anytime algorithm for the bounding box problem  replacing the one
described above  which also calls the containment problem solver  we first find a greedy
solution on a bounding box whose height is equal to the tallest rectangle  as described in the
previous section  we then repeatedly call the containment problem solver in the following
way  if the previous attempt for a given bounding box resulted in a packing or if its area
is greater than the area of the best solution seen so far  then we decrease the width by
one unit and attempt to solve the resulting bounding box problem  if instead the previous
  

fioptimal rectangle packing  an absolute placement approach

attempt were infeasible  then we increase the height of the bounding box by one unit  the
algorithm terminates when the width of the current bounding box is less than the width of
the widest rectangle 
    containment problem
korfs        absolute placement approach modeled rectangles as variables and positions in
the bounding box as values  rectangles were placed in turn with a depth first search  and
all possible locations were tested for each rectangle  by contrast  simonis and osullivans
       packer assigned the x coordinates of all the rectangles before any of the y coordinates 
as suggested by clautiaux et al          as well as using the cumulative constraint  aggoun
  beldiceanu         improving performance by orders of magnitude  the cumulative
constraint adds the height of all the rectangles that overlap a given x coordinate location 
pruning if any of these values exceed the height of the bounding box  this constraint was
checked while exploring x coordinates and also while exploring y coordinates later on  we
improved on this by exploring the y coordinates differently  modeling candidate locations
as variables  and rectangles as values  huang   korf         which made our packer over
an order of magnitude faster than that of simonis and osullivans 
simonis and osullivan        furthermore applied the least commitment principle  yap 
      from constraint processing  by first committing the placement of rectangles to an
interval of x coordinates instead of just a single x coordinate value  these x intervals are
explored in turn  and constrain the candidate individual x coordinates explored later  this
works because committing to an x interval can induce pruning via the cumulative constraint 
for example  picking an x interval of  a  b  with a size that is smaller than the width of the
rectangle wr   implies that regardless of which x coordinate the rectangle eventually takes 
it must contribute its height to each x coordinate within the interval  b  a   wr    finally 
the height of the bounding box constrains the cumulative heights of all rectangles for any
given x coordinate  similar to the ideas of beldiceanu et al          larger intervals result in
weaker constraint propagation  less pruning  but a smaller branching factor  while smaller
intervals result in stronger constraint propagation but a larger branching factor  the size
of the intervals are experimentally determined 
for example  a      rectangle with x coordinates restricted to the interval       contributes a height of   at x coordinates   and   even prior to deciding its exact x coordinate
value  this compulsory part  lahrichi        constrains the cumulative height of the rectangles that may overlap x coordinates   and   in the solution  if these interval assignments
were all infeasible  then searching for individual x values is futile  however  if we do find
a set of interval assignments  then we still have to search for a set of single x coordinate
values  simonis and osullivan        assigned x intervals  single x coordinates  y intervals 
and single y coordinates  in that order 
    assigning x intervals and x coordinates
for the x coordinates  we propose a pruning constraint adapted from korfs        wastedspace pruning heuristic  a dynamic variable order to replace beldiceanus        fixed ordering  and a method to optimize the values assigned to our x interval variables 
  

fihuang   korf

figure    to test for violations of the cumulative constraint  the remaining space after
placing a      rectangle at x   is represented as the vector h                i 

      pruning infeasible subtrees
we present a constraint based formulation of korfs        two dimensional wasted space
pruning algorithm  adapted to the one dimensional case  given a partial solution  korfs
algorithm computed a lower bound on the amount of wasted space  which was then used
to prune against an upper bound  by contrast  we do not compute any numerical bounds
and instead detect infeasibility with a single constraint 
as rectangles are placed in the bounding box  the remaining empty space gets chopped
up into small irregular regions  eventually the empty space is segmented into small enough
chunks such that they cannot accommodate any of the remaining unplaced rectangles  at
which point we backtrack  while assigning x coordinates in a bounding box of height h 
we keep a histogram hv    v            vh i  where vi is the number of empty cells  units of empty
space  that are in empty columns of height i  for example  assume that in figure   we
assigned only the x coordinates of a      rectangle in a      bounding box  the resulting
histogram would be h       i  since there are   cells in empty columns of height    no empty
cells in columns of height    and   cells in empty columns of height   
assume now that we only have left to place a      and a      rectangle  we can assign
the six cells of the      rectangle to the empty cells of v      leaving us with the remaining
empty cells h       i  at this point  we cannot assign the area of the       because we only
have   empty cells that can accommodate its height and we need    so we can prune 
in general  for a set of unplaced rectangles r and a bounding box of height h 

h  

x

wr hr 

rr hr h

h
x


vi   

   

i h

where a rectangle r  r has dimensions wr  hr   that is  for every given height h  the
amount of space that can accommodate rectangles of height h or greater must be at least
the cumulative area of rectangles of height h or greater  we check this constraint after each
x coordinate assignment 
  

fioptimal rectangle packing  an absolute placement approach

 a  x   is a dominated position for
the      square 

 b  x   is an undominated position
for the      square 

figure    example of dominance conditions 

      pruning with dominance conditions
korf        introduced a set of dominance conditions to prune positions where large rectangles are too close to the sides of the bounding box  for example  imagine that we must pack
the squares             and     in figure  a  the placement of the    square leaves
a      gap against the left side of the bounding box in which the      square cannot fit 
only the      and      squares can fit within the gap  and in fact they both can be placed
entirely within the gap  notice that in any solution with an arrangement as in figure  a 
we can always rearrange them as in figure  b without disturbing any other squares  thus 
there is no need to try placing the      square at x   so long as we have tried placing it at
x    in general  a rectangle placement is dominated if it leaves a gap in which all rectangles
that can individually fit can also be packed together in the gap without protruding from
it  although korf hard coded dominance rules for the consecutive square benchmark  we
dynamically generate them for every instance with insignificant preprocessing overhead 
      variable ordering
in the following subsections we consider two variable orders that work together in our packer 
we use a fixed ordering that governs which rectangle is assigned next  this ordering is used
for the x intervals independently from its use on the single x coordinate variables  at
any point in time  we also must choose whether to assign the next x interval or the next
single x coordinate variable  since the ordering between x intervals and single x coordinate
variables is simpler  we present this technique first 
ordering between x intervals and x coordinates by area our variable order
is based on the observation that placing rectangles of larger area is more constraining
than placing those of smaller area  at all times we can either choose to assign a single
x coordinate to a rectangle for which we previously had assigned an x interval  or we can
assign an x interval to a rectangle we have not yet made any assignments for  as shown in
figure    either of these assignments will decrease the amount of empty space represented
in the cumulative constraint vector  we always pick next the variable that results in the
least remaining space 
  

fihuang   korf

ordering among rectangles by branching factor there is a natural variable order
that arises from both the consecutive square and unoriented consecutive rectangle benchmarks when using the strategy of picking the most constrained variable next  for example 
in the consecutive square benchmark  the largest rectangle is clearly the largest in height 
width  and area  however  in our new benchmarks the rectangle of largest width has the
smallest height  but not the largest area  making a good variable ordering non obvious 
we propose a variable order over rectangles of various aspect ratios by picking the
variable with the fewest number of values first  to favor a smaller branching factor closer
to the root of the search tree  for the oriented equal perimeter benchmark  recall that we
assign intervals to the x coordinates before the individual x coordinates  and like simonis
and sullivan        we use a constant factor times the rectangle width to define the interval
size  the branching factor for the x interval variables for a given rectangle is
 
bw  rw
 
bw  
b 
  
   
 
crw
c rw
c
where bw is the bounding box width  rw is the rectangle width  and c is a constant chosen
experimentally  the numerator bw  rw is the number of x coordinate values that the
rectangle can have while still fitting in the bounding box  and the denominator crw is the
size of the interval we will be assigning to the given rectangle  for example  if c      then
we would assign intervals of size three to a      rectangle 
we may drop the translational constant   c as well as the positive scalar bw  c since
we are only interested in a relative ordering for the rectangles  leaving us with   rw which
means that for the oriented benchmark we should place the rectangles in order of decreasing
width  for the unoriented double perimeter benchmark  our packer first tries all values for
a particular x interval  and then rotates the rectangle    degrees before trying another set
of x interval values  in this case the branching factor is


bw  rw
bw  
bw  rh
 
 
b 
 
 
 
  
   
crw
crh
c rw
rh
c
as mentioned before  we can drop the scalar and translational constant  giving us
 
rw   rh
 
 
 
 
   
rw
rh
rw rh
because all rectangles in a given instance have the same perimeter by definition  the
numerator of the result in equation   is constant  therefore for our unoriented benchmark 
we place the rectangles in order of decreasing area 
      determining sizes of x intervals
on the consecutive square benchmark  our packer used an interval size that is      times
the width of a given rectangle  we found that larger interval sizes improve the performance
of our packer on the new equal perimeter benchmarks  and use a value of c      instead 
as we assign larger intervals to the short and wide rectangles  the x interval variables
for these rectangles tend to have branching factors of three or less  we should balance the
sizes of these intervals so that the values assigned are equally constraining on their subtrees 
for example  consider c       a rectangle of width     and its set of possible x coordinate
  

fioptimal rectangle packing  an absolute placement approach

values         without balancing the sizes of the intervals  our packer would explore interval
sizes of   c       such as x         x          and finally the remaining domain values
with a small interval of x          this results in small compulsory parts and therefore
large search subtrees in the first two branches  but a very large compulsory part and thus
a small search subtree in the third 
since we must explore three branches anyway  we can balance the sizes of these interval
assignments by exploring x        x         and x          the eventual effect is a better
balance on the size of the search subtrees amongst branches  our packer first computes the
branching factor induced by the global interval parameter c      for each rectangle  and
then it balances the number of values in each interval assignment 
interactions between interval assignment and dominance conditions on consecutive square instances  for most of the squares there are several positions following x  
that are dominated  therefore  our packer first branches by assigning the degenerate interval x       before exploring interval assignments for the undominated positions  although
this technique increased the performance of our packer fivefold compared to leaving it out 
the same strategy slowed the performance fivefold on the oriented and unoriented doubleperimeter benchmark  the reason for this degradation of performance is as follows 
in our equal perimeter benchmarks  the    n rectangle can always partially fit in gaps
left by other rectangles  but it must always protrude out of those gaps  thereby eliminating
the dominance conditions we previously described  without any dominated positions to
account for  simply applying the same strategy used for consecutive squares on our new
benchmarks results in our packer committing to single x coordinate values in situations
where it is more desirable to include those positions in a larger interval assignment  to
avoid this  our packer detects when there are no dominated positions and dynamically
chooses whether to assign the degenerate interval as the x coordinate assignment  or to
immediately begin with interval assignments 
    perfect packing transformation
for every complete x coordinate solution  we transform the problem instance into a perfect
packing problem instance before working on the y coordinates  a perfect packing instance
is a rectangle packing problem with the property that the solution has no empty space 
the transformation is done by adding to the original set of rectangles a number of     
rectangles necessary to increase the total area of the rectangles to that of the bounding box 
although the new      rectangles increase the problem size  the hope is that the ease of
solving perfect packing instances will offset the difficulty of packing more rectangles  next
we describe our search space for perfect packing  as we will show  our methods rely on the
perfect packing property of having no empty space 
    assigning y coordinates
an alternative to asking where should this rectangle go  is to ask which rectangle
should go here  in the former model  rectangles are variables and empty locations are
values  whereas in the latter  empty locations are variables and rectangles are values  for
y coordinates  we search the latter model  we use a  d bitmap to draw in placed rectangles
  

fihuang   korf

to test for overlap  and we backtrack on positions that cannot accommodate any remaining
rectangles  or as required by korfs        wasted space pruning rule 
      empty corner model
in all perfect packing solutions  every rectangles lower left corner fits in some lower left
empty corner formed by other rectangles  the sides of the bounding box  or a combination
of both  in this model  we have one variable per empty corner  in the final solution  since
each rectangle goes into exactly one empty corner  the number of empty corner variables is
equal to the number of rectangles in the perfect packing instance  the set of values is just
the set of unplaced rectangles 
this search space has the interesting property that variables are dynamically created
during search because the x  and y coordinates of an empty corner are known only after the
rectangles that create it are placed  furthermore  placing a rectangle in an empty corner
assigns both its x  and y coordinates 
note that the empty corner model can describe all perfect packing solutions  given any
perfect packing solution  we can list a unique sequence of all the rectangles by scanning
left to right  bottom to top for the lower left corners of the rectangles  this sequence
corresponds to a sequence of assignments from the root of this search space to a leaf in the
tree  this property also bounds the maximum size of the search space by n     where n   is
the number of rectangles after we have performed the perfect packing transformation 
      duplicate rectangles
due to the additional      rectangles from the perfect packing transformation  we have
introduced additional redundancy into the problem  a simple way to handle this is as
follows  for a particular empty corner  we never place a rectangle that is a duplicate of one
we have already tried at that position  this method of handling duplicates also applies to
duplicate rectangles in the original problem instance 

   experimental results
we benchmarked our packers in linux on a  ghz amd opteron     with  gb of ram 
the packer we call kmp    korf et al         was benchmarked on the same machine 
so we quote their published results  we do not include data for their relative placement
packer because it was not competitive  results for simonis and osullivans packer        
which we call ss    are also quoted  obtained from sicstus prolog       for windows on a
 ghz intel xeon      with     gb of ram  since their machine is faster than ours  these
comparisons are a conservative estimate of our relative performance 
    previous benchmarks
because both the consecutive square benchmark and the unoriented consecutive rectangle
benchmarks  korf et al         have been used in the literature to measure performance 
we include data collected using these two benchmarks 
  

fioptimal rectangle packing  an absolute placement approach

size
n

kmp  
time

ss  
time

fixedorder
time

  
  
  
  
  
  
  
  
  
  
  
  
  

    
    
     
       
        
          
          
           

   
   
   
    
    
     
       
        

   
   
   
   
   
    
     
       
          

hk  
time
   
   
   
   
   
    
    
     
       
       
          
          
           

table    cpu times required by various packers on the consecutive square benchmark 
where the task is to pack squares from      up to n  n  

      consecutive squares
table   compares the cpu runtimes of four packers on the consecutive square benchmark 
the first column specifies the instance size  which is both the number of squares and the
size of the largest one  the remaining columns specify the cpu times required by various
algorithms to find all the optimal solutions in the format of days  hours  minutes  and
seconds  when there are multiple boxes of minimum area  as for n     as listed in table
  of appendix      we report the total time required to find all optimal bounding boxes 
we do this for two reasons  first  finding all minimum area bounding boxes removes the
question of which bounding box to test first if more than one have the same area  second 
by providing all optimal solutions  other researchers working on rectangle packing can use
this information to verify the correctness of their programs 
hk   includes our wasted space pruning rule for the x coordinates  dynamic variable
ordering between x intervals and x coordinates  the perfect packing transformation  and
its related search space and inference rules  we have named this packer to be consistent
with our previous work  huang   korf         ss   refers to the previous state of the art
packer  simonis   osullivan         the largest problem previously solved was n    
and took ss   over    hours  we solved the same problem in    minutes and solved five
more open problems up to n      kmp   refers to korf et al s        absolute placement
packer  fixedorder assigns all x intervals before any single x coordinates  but includes all
of our other ideas  hk  s dynamic variable ordering for the x coordinates was an order
of magnitude faster than fixedorder by n      the order of magnitude improvement
of fixedorder over ss   is likely due to our use of perfect packing for assigning the ycoordinates  we do not include the timing for a packer with perfect packing disabled
because it was not competitive  e g   n     took over     hours  
  

fihuang   korf

size
n
  
  
  
  
  
  
  
  
  
  
  
  

x coordinate
solutions
   
   
   
   
   
     
   
     
      
      
      
      

seconds
in x
    
    
    
     
     
      
        
        
         
          
          
            

seconds
in y
    
    
    
    
    
    
    
     
     
     
      
      

ratio
x y
   
   
    
    
     
     
       
     
     
       
     
        

table    cpu times spent searching for x  and y coordinates for the consecutive square
benchmark

in table   the second column is the number of complete x coordinate assignments our
packer found over the entire run of a particular problem instance  the third column is the
total time spent in searching for the x coordinates  the fourth column is the total time
spent in performing the perfect packing transformation and searching for the y coordinates 
both columns represent the total cpu time over an entire run for a given problem instance 
the last column is the ratio of time in the third column to that of the fourth  interestingly 
almost all of the time is spent on the x coordinates as opposed to the y coordinates  which
suggests that if we could efficiently enumerate the x coordinate solutions  we could also
efficiently solve rectangle packing  this is confirmed by the relatively few x coordinate
solutions that exist even for large instances  the data in table   was obtained on a linux
    ghz intel core   duo e     machine in a separate experiment from that of table   
which is why the total time spent on a given instance is different 
      unoriented consecutive rectangles
table   compares the cpu times of our packer on the unoriented consecutive rectangles
benchmark with that of korf et al          although the techniques due to simonis and
osullivan        outperform those of korf et al  on the consecutive square benchmark 
there were no previously published results on this benchmark besides that of korf et al 
because this benchmark is easier than the consecutive square benchmark  we do not break
down the contributions of each of our techniques  as these differences were delineated more
clearly in the previous section  the primary differentiating feature of this benchmark is
that rectangles are unoriented 
the first column gives the size of the problem instance  the second column gives the
performance of the previous state of the art packer on this benchmark  using korf et al s
code         the third column gives the performance of our packer on this benchmark  all
  

fioptimal rectangle packing  an absolute placement approach

size
n

kmp  
time

hk  
time

  
  
  
  
  
  
  
  
  
  
  
  
  
  

   
   
   
   
    
     
       
       
        
          

   
   
   
   
   
   
   
   
     
       
       
          
          
          

table    cpu times required by two packers on the unoriented consecutive rectangle benchmark  where the task is to pack unoriented rectangles of sizes              and n  n     

of the data in this table was collected on a linux     ghz intel core   duo e     machine 
except for n     and n      which were collected on a linux     ghz intel xeon e    
with   gb of ram  and which our experiments revealed to be     faster than the former
machine 
for this benchmark our techniques have allowed us to extend the known solutions from
n     to n     and allowed us to solve n     about    times faster than the previous
state of the art on this benchmark 
    oriented equal perimeter and unoriented double perimeter rectangles
this section uses our new benchmarks to compare the techniques we have developed for
non square instances  the techniques we discuss here  including the dynamic adjustment
of interval sizes and the generalized variable order based on branching factor  largely do
not affect the performance of our packer on the consecutive square benchmark  in fact  we
tested this packer on that benchmark to see the effects of any extra overhead added by
our improvements  our new packer resulted in only a five percent speedup compared to
our packer without these changes on the consecutive square benchmark  likely due to minor
improvements in data structures  and balancing interval sizes  therefore  we compare the
effects of these techniques only on our new benchmarks  because the techniques we have
developed for our new benchmarks improve performance in both the oriented and unoriented
cases  we discuss them together 
table   compares the performance of our packers on the oriented equal perimeter benchmark while table   compares the same packers using our unoriented double perimeter
benchmark  the first column refers to the problem size of the instance  which is the number
  

fihuang   korf

size
n

boxes
tested

hk  
time

optdom
time

brfactor
time

c     
time

hk  
time

  
  
  
  
  
  
  
  
  
  
  

 
 
  
 
 
  
  
  
 
  
  

   
   
   
   
    
       
       
          
          

   
   
   
   
    
     
       
       
        

   
   
   
   
   
    
     
       
       

   
   
   
   
   
   
    
     
     
        

   
   
   
   
   
   
    
    
     
       
          

table    cpu times required by various packers on the oriented equal perimeter rectangle
benchmark  where the task is to pack oriented rectangles of sizes    n       n          
 n         and n    

size
n

boxes
tested

hk  
time

optdom
time

brfactor
time

c     
time

hk  
time

  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  

   
   
    
     
       
          

   
   
   
    
     
       
          

   
   
   
    
     
       
          

   
   
   
    
    
       
       

   
   
   
    
    
       
       
          

table    cpu times required by various packers on the unoriented double perimeter rectangle benchmark  where the task is to pack unoriented rectangles of sizes      n     
     n            n       n       and n  n  

  

fioptimal rectangle packing  an absolute placement approach

of rectangles  the second column gives the number of bounding boxes tested in order to
find all optimal solutions  the remaining columns represent the cpu times for different
versions of our packer in the format of days  hours  minutes  and seconds  we wrote our
packer in c   and collected our data on a linux     ghz intel core   duo e     machine 
from left to right  each successive packer improves on the previous one by including an
additional technique  the column called hk   is data collected using only the techniques
developed specifically for consecutive square packing  which include the perfect packing
transformation and its related inference rules  dynamic variable ordering between single
x coordinates and x intervals  and the wasted space pruning rule for the x coordinates
 huang   korf         to compare against our new variable ordering over rectangles of
various aspect ratios  we used the order of decreasing area by default in hk   
optdom improves upon hk   by dynamically detecting when dominance rules apply or
are inapplicable  and optimizes the x interval assignments with this knowledge  brfactor
improves upon optdom in that it orders the oriented equal perimeter benchmark by decreasing width and the unoriented double perimeter benchmark by decreasing area  c     
improves upon brfactor in that we use an interval size of      instead of c      as we
did for the consecutive square benchmark  finally  hk   improves upon c      by using
knowledge of the branching factor to rebalance the sizes of the interval assignments for the
x coordinates 
notice that optdom  brfactor  and c      introduce techniques that reduce the
branching factor  and so they have a greater effect on performance than hk    whose
new technique seeks to make the intervals assigned equally constraining  our experiments
reveal that these techniques interact with one another  and we note that without including
dominated positions in the intervals  the performance gained from the other techniques
appears muted  this interaction is also why we tune the global interval parameter c only
after including the other techniques that affect the branching factor 
ordering by branching factor improved performance for our oriented equal perimeter
benchmark but not for our unoriented benchmark  in the latter case  as seen in table   
our technique of ordering by branching factor prescribes ordering by decreasing area  which
is what we gave the packer as a reasonable default  therefore  there is no difference in the
algorithm nor in its performance between the optdom and brfactor columns of table   
note that the unoriented double perimeter benchmark requires our packer to try over
twice as many bounding boxes for a given parameter n than that required for our oriented benchmark  this is due to having  n    as the largest dimension in the unoriented
benchmark while having n as the largest dimension in the oriented benchmark  the larger
rectangles introduce a higher precision into the problem  and so we must try more bounding
boxes  the containment problem for an unoriented instance has a problem space that is
a factor of  n larger than that of an oriented instance due to the two orientations of each
rectangle  thus  an instance with n rectangles in this benchmark is incomparable to an
instance of n squares from the consecutive square benchmark when evaluating benchmark
difficulty 
in summary  using all of our techniques together  we can solve n     of the oriented
equal perimeter benchmark about     times faster and n     of the unoriented doubleperimeter benchmark about    times faster than the techniques we presented optimized
only for consecutive squares 
  

fihuang   korf

size

boxes tested

cpu time

n

squares

perimeter

squares

perimeter

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

 
 
  
  
  
 
  
  

   
   
   
   
   
   
   
   
   
    
    
     
       
       
          
          
           

   
   
   
    
    
     
       
          

table    number of bounding boxes tested and cpu time required to solve a given instance
in the consecutive square and the oriented equal perimeter benchmarks 

  

fioptimal rectangle packing  an absolute placement approach

    comparing easy and hard benchmarks
the following tables compare the difficulty of various benchmarks using our packer  huang
  korf        with all optimizations enabled 
      consecutive squares vs  equal perimeter rectangles
in table    the first column indicates the number of rectangles in the instance  the second
and third columns labeled boxes tested give the number of bounding boxes that were
tested when finding all optimal solutions for the consecutive square benchmark and the
oriented equal perimeter benchmark  respectively  the fourth and fifth columns give the
performance of our rectangle packer on both benchmarks as well  each data point in this
table was collected using a linux     ghz intel core   duo e     using one process  one
thread  and one core 
notice that for a given instance with the same number of rectangles  the oriented equalperimeter benchmark is significantly harder than the consecutive square benchmark  this
is due to the fact that for a given problem size  the consecutive square benchmark contains
many little squares that are typically easy to place  a property missing in the equalperimeter benchmark  in fact  by n     our packer requires over four orders of magnitude
more time to find the optimal solutions to our new benchmark compared to an instance
with the same number of items from the consecutive square benchmark 
      unoriented consecutive rectangles vs  unoriented double perimeter
rectangles
table   shows how removing certain properties results in successively more difficult benchmarks  we start with the unoriented consecutive rectangle benchmark  korf et al        
which contains many easy properties  in the doubly scaled column we pack            
           n    n     rectangles  which simply scales up the unoriented consecutive rectangle benchmark by a factor of two  this benchmark is more difficult because integers of
higher magnitude lead to more x coordinates to search  which in turn increases the branching factor of the problem  in the unique dimensions column we now pack rectangles of
sizes                          n        n    which differs from the previous benchmark in
that all dimensions are unique  the last column distributes the area among the rectangles
more uniformly to avoid consolidating most of the area in the first few rectangles  this
column is also the culmination of all of the difficult properties which we have identified for
a rectangle packing benchmark  which we call our unoriented double perimeter benchmark 
all data points in this table were collected using a linux     ghz intel core   duo e    
machine without any parallelization  except for n     and n      which were collected on
a linux     ghz intel xeon e     machine with   gb of ram  which we estimate to be
thirty percent faster 
    bounding boxes of minimum area
in this section we list all of the optimal bounding boxes on various benchmarks found by
our program with all optimizations enabled  notice that we do not duplicate the data for
  

fihuang   korf

size
n
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

unoriented
consecutiverectangles
   
   
   
   
   
   
   
   
   
   
   
   
     
       
       
          
          
          

doubly
scaled
   
   
   
   
   
   
   
   
   
   
   
    
     
       
          

unique
dimensions
   
   
   
   
   
   
   
   
   
    
     
       
        

unoriented
doubleperimeter
   
   
    
    
       
       
          

table    cpu time required for our optimized packer on various benchmarks of increasing
difficulty 

  

fioptimal rectangle packing  an absolute placement approach

the unoriented high precision rectangle benchmark  and leave it in table     section       
since the discussion there refers to this data 
the first column in tables   and   refer to the size of the problem instance for their
respective benchmarks  the columns called optimal solution give the dimensions of the
optimal bounding boxes for a given instance  the next column called empty space gives
the percent of empty space in the optimal solution  the next column gives the number of
bounding boxes that were tested in order to find all optimal solutions for a given instance 

   absolute placement on high precision instances
meir and moser        first proposed the problem of finding the smallest square that can
contain an infinite series of rectangles of sizes                                 etc  the rectangles
cannot overlap and are unoriented  the unit square has exactly enough area since the total
area of the rectangles in the infinite series is one  on the other hand  no space can be
wasted  suggesting that the task is infeasible  inspired by this problem  we propose our last
benchmark and developed several new techniques 
we introduce the unoriented high precision rectangle benchmark  where the task is to find
all bounding boxes of minimum area that can contain a finite set of unoriented rectangles
of sizes                        up to n   n       for example  for n    one must pack rectangles of
sizes                            and          alternatively  one may try to pack rectangles of sizes
                        and        into a        square  which is just the original instance
scaled up by a factor of     the least common multiple of the rectangle denominators  this
strategy is required for the broad class of recent rectangle packers that explore the domain
of integer x  and y coordinates for the rectangles and quickly break down at higher n  
for example  the optimal solution of n     has over     billion unique coordinate pairs
that rectangles can be assigned to  our benchmark complements rather than replaces the
current low precision benchmarks  which until now have neglected high precision instances 
the remainder of this section is organized as follows  we first review some of the previous
work proposing solution techniques that may be unaffected by the precision of the rectangle
dimensions  then we describe several adaptations of our low precision techniques to the
high precision case  along with some new techniques developed specifically for high precision
rectangle instances  and finally follow with experimental results 
    previous work
the relative placement approach of moffitt and pollack        for rectangle packing  and
similar types of search spaces used in resource constrained scheduling  weglarz        
promises to be immune to the problem of high precision rectangle instances  however  since
there are so many techniques that we have described in the previous sections that cannot
be extended to a packer working in the relative placement search space  we have decided
to stay within the absolute placement framework and attempt to mitigate the problems
introduced by high precision numbers 
  

fihuang   korf

consecutive squares

consecutive rectangles

size
n

optimal
solutions

empty
space

boxes
tested

optimal
solutions

empty
space

boxes
tested

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
   
   
         
    
    
    
    
    
    
    
    
          
    
    
    
    
    
    
    
    
     
    

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
  
 
  
  
  
  
  
  
  
  
  

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

  
  
  
  
  
  

           
     
     
     
     
     

     
     
     
     
     
     

  
  
  
  
  
  

  
  
  
       
   
   
    
    
          
    
    
    
    
          
    
    
    
    
          
                
    
    
            
                  
                 
                    
                 
     
            
     

     
     
     

 
 
 

table    the optimal solutions for the consecutive square benchmark  where the task is to
pack squares of sizes              and n n   and for the unoriented consecutive rectangle
benchmark  where the task is to pack unoriented rectangles of sizes                  and
n   n      

  

fioptimal rectangle packing  an absolute placement approach

oriented equal perimeter

unoriented double perimeter

size
n

optimal
solutions

empty
space

boxes
tested

optimal
solutions

empty
space

boxes
tested

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  

  
  
  
  
  
   
   
   
    
    
    
    
    
          
    
    

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

 
 
 
 
 
 
  
 
  
 
  
  
  
  
  
  

  
  
  
  
  
  
  

    
    
          
    
    
    
    

     
     
     
     
     
     
     

 
  
  
  
 
  
  

  
  
  
  
   
   
    
    
    
    
    
    
    
           
    
           
          
          
    

     
     

  
  

table    the optimal solutions to the oriented equal perimeter rectangle benchmark  where
the task is to pack oriented rectangles of sizes    n       n            n         and
n     and to the unoriented double perimeter rectangle benchmark  where the task is to
pack unoriented rectangles of sizes      n           n            n       n       and
n  n 

  

fihuang   korf

 a 

 b 

figure    examples of mapping solutions to one where rectangles are in their left most 
bottom most positions 

    overall strategy
given an instance from our high precision benchmark described in rational numbers  we
multiply all values by the least common multiple of the denominators to get an instance
with integer dimensions  we then apply the absolute placement solution techniques  with
improvements we will subsequently explain  in order to find the optimal solutions  once
found  we divide all x  and y coordinates describing the optimal solutions by the initial
scaling constant in order to obtain the optimal solutions for the original problem 
note that we can map every solution to one where all rectangles are slid over to the
left and to the bottom as much as possible  chazelle         for example  the solution in
figure  a can be transformed into that of figure  b  since all rectangles are now propped
up from the left and below by other rectangles  each rectangles x coordinate is the sum
of a subset of the widths of the other rectangles and each rectangles y coordinate is the
sum of a subset of the heights of the other rectangles  similarly  the width and height of
the bounding box must be the sum of a subset of the widths and heights of the rectangles 
respectively 
in the following subsections we first explain our techniques with respect to oriented
instances  and then follow with how to handle the unoriented case 
    minimum bounding box problem
since we build the initial set of bounding boxes from all pairwise combinations of widths
and heights within given ranges  the space is pruned by considering only bounding box
widths and heights equal to the subset sums of the rectangle widths  and the subset sums
of the rectangle heights  respectively  recall from section     that for every bounding box
width  we compute a lower bound on the height  we further modify this by rounding the
resulting bound up to the next subset sum of the rectangle heights 
  

fioptimal rectangle packing  an absolute placement approach

      precomputing subset sums
we compute the set of all subset sums prior to searching  for oriented rectangles which
cannot be rotated we compute two sets  one based only on the heights of the rectangles
representing the candidate y coordinates  and one based just on their widths representing
the candidate x coordinates  this distinction generates fewer subset sums compared to a
single set of subset sums generated from both widths and heights 
      pruning combinations of widths and heights
we can reject some bounding boxes for which certain width and height combinations are
infeasible  this pruning technique relies on the observation that in certain cases  there may
be only one unique set of rectangles that generate a specific width  height  for the bounding
box 
for example  consider a bounding box width which can only be generated by a unique
set of rectangles  now assume that the heights of the same set of rectangles also uniquely
determine the subset sum for a specific bounding box height  we say that this combination
of bounding box width and height is incompatible  the reason is that this set of rectangles
is the only way we can have a bounding box of the given width  and that implies this set
of rectangles must appear in the solution laid out horizontally to one another  thus  the
same set of rectangles cannot appear stacked vertically in the solution  this contradicts the
implications of a bounding box of the given height  note that in this particular example 
the only compatible height is the maximum height of the rectangles 
      learning from infeasible attempts
recall that the algorithm for solving the minimal bounding box problem repeatedly calls
the algorithm to solve the containment problem  bounding boxes are tested in order of
non decreasing area until the first boxes with solutions are found  we can learn from the
infeasible attempts 
for example  consider having to pack n rectangles  r    r         rn    note that we use a
pre computed variable order for the rectangles  let rd   d   n be the rectangle corresponding
to the deepest in the search tree our depth first search was able to go  during the entire
search effort for a given bounding box  if the containmnet solver says this bounding box
is infeasible  then the next bounding box height that we should consider can be the next
greatest subset sum based on the smaller set  r    r         rd     instead of considering all n
rectangles  the intuition behind this is that since our containment solver failed to even
find an arrangement for the first d     rectangles  it doesnt make sense to involve any of
the remaining rectangles  rd        rn   in the next largest subset sum for the bounding box
height 
this method resembles conflict directed backtracking  in our implementation  we also
consider the effect of pruning using the wasted space heuristic as well 
    containment problem
similar to our low precision methods  we first assign x coordinates for the rectangles  then
conduct a perfect packing transformation  and finally work on the y coordinates  huang
  

fihuang   korf

  korf         the main difference between our high precision methods and our lowprecision methods are that instead of considering all possible integers as the domain of
x  and y coordinates  we consider the smaller set of subset sums of the widths and heights
of the rectangles  the methods for using x intervals remain unchanged and so we only
describe how we search individual x coordinates here 
      assigning x coordinates
for oriented rectangles  we choose x coordinates from the set of subset sums of rectangle
widths  instead of precomputing the set as we did in the minimal bounding box problem 
here we generate it dynamically at every node during the search prior to branching on
various x coordinate value assignments  the set is computed as follows 
   initialize the set with the value    as this represents placing a rectangle against the
left side of the bounding box 
   for every rectangle r already assigned an x coordinate at this point of the search 
insert into the set the sum of its x coordinate and its width  this represents placing
a rectangle against the right side of r 
   for every rectangle with its x coordinate still unassigned  add its width to every
element in our set  and insert the new sums back into the set 
      perfect packing transformation
after assigning x coordinates  we create a number of      rectangles to account for all
empty space in the original instance  the transformation results in a new instance  with no
empty space  and consists of the original rectangles plus the new      rectangles  then for
a given empty corner in a partial solution  we ask which of the original unplaced rectangles
might fit there  or a      rectangle  essentially modeling empty corners as variables and
rectangles as values 
in our high precision benchmark  solving n     requires creating over     billion     
rectangles because we scaled the problem up by a very large number  here our packer
simply requires too much memory and time  we avoid this problem by creating fewer and
much larger rectangles to account for the empty space 
widening existing rectangles assume in figure  a that the task is to pack three
rectangles  here we have a                 and a        rectangle in a        bounding
box  and assume we have assigned x coordinates but not y coordinates  given that the
x coordinates are already assigned  in any resulting packing solution the space to the right
of the        rectangle must always be empty  thus  we replace the        rectangle with
a        rectangle  effectively widening the original rectangle  likewise  we replace the
       rectangle with a        rectangle  and the        rectangle by a        rectangle 
as in figure  b  our packer greedily attempts to widen the rectangles towards the right
before widening them towards the left  after solving the problem we can just return the
rectangles back to their original widths  this avoids creating many      rectangles during
the perfect packing transformation to represent empty space 
  

fioptimal rectangle packing  an absolute placement approach

 a  a partial solution where only xcoordinates are known 

 b  the result of widening the rectangles 

figure    widening existing rectangles 

 b  a solution without       rectangles for empty space 

 a  a partial solution where only xcoordinates are known 

figure    consolidating empty space into horizontal strips 

turning empty space into large rectangles in the partial solution of figure  a  we
have assigned only the x coordinates of the rectangles in a        bounding box  instead
of creating three hundred      rectangles to represent the empty space indicated by the
single hash marks  we can use ten       rectangles without losing any packing solutions 
similarly  we represent the doubly hashed empty space with twenty     rectangles instead
of six hundred      rectangles  note that we cannot use       rectangles for the empty
space since we would inadvertently prune out the potential solution in figure  b 
      assigning y coordinates
after the perfect packing transformation  we assign y coordinates by asking which rectangle
can be placed in a given empty corner  as before  we enforce the constraint that the ycoordinate of each rectangle must be a subset sum of the rectangle heights  note that the
rectangles we create via the perfect packing transformation are not included in the subset
sum calculations  since they represent empty space 
      handling unoriented instances
for unoriented instances  when computing the initial bounding box widths and heights 
we generate a single set of subset sums using both widths and heights from all rectangles
in the instance instead of keeping the widths separated from the heights  likewise  when
generating the set of candidate x  and y coordinates  we must add a fourth step to the
  

fihuang   korf

size
n

optimal
solution

lcm

bits of
precision

hk  
boxes

subsets
boxes

mutex
boxes

hk  
boxes

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  

    
      
        
            
        
         
         
         
         
           
            
        
         
         
        

 
 
  
  
  
   
   
     
     
      
      
       
       
       
       

 
 
 
  
  
  
  
  
  
  
  
  
  
  
  

 
 
 
  
  
     
     
      
      
         

 
 
 
 
 
  
   
   
     
     
      
      
       
       
         

 
 
 
 
 
  
   
   
   
     
      
      
       
       
       

 
 
 
 
 
  
  
   
   
   
     
     
     
     
      

table     the minimum area bounding boxes and number of bounding boxes tested when
packing unoriented rectangles                                 and n   n      

bulleted list in subsection       where we add the height of every rectangle which has not
yet been placed  to every element in the set of subset sums  as this represents the possibility
of rotating the rectangle 
    experimental results
we present two different data tables  one relating to improvements in the minimal bounding
box problem measured by the number of bounding boxes tested  and another one on the
overall cpu time for solving the entire rectangle packing problem  we can separate our
experiments this way because our solution schema decouples the minimal bounding box
problem from the containment problem 
      minimum bounding box problem
table    shows the optimal solutions for our unoriented high precision rectangle benchmark
along with various properties of the corresponding instances  the first two columns give the
problem size and the dimensions of the optimal solutions  respectively  the third gives the
least common multiple of the first n    integers  the fourth is the number of bits required
to represent the area of the minimal bounding box  note that all but one of the optimal
solutions have a width of      since the first rectangle is much larger than any of the others 
for n     and larger  the required precision exceeds that of a    bit integer 
the fifth through eighth columns compare the number of bounding boxes that various
packers test to find all optimal solutions on our unoriented high precision rectangle bench  

fioptimal rectangle packing  an absolute placement approach

size
n
 
 
 
 
  
  
  
  
  
  

hk  
time

empty space
time

dynamic
time

hk  
time

   
   
    
    

   
   
   
   
    
     
       

   
   
   
   
   
   
    
       
          

   
   
   
   
   
   
   
     
     
       

table     cpu times of various packers to find all minimum area bounding boxes containing
unoriented rectangles                                 and n   n      
mark  for each column going from left to right  we add one new technique for the minimal
bounding box problem 
hk   is the number of bounding boxes required when simply scaling up the problem
to an instance described completely in integers  the column called subsets improves upon
the second by testing only those bounding boxes whose dimensions are constrained by our
subset sums technique  the column called mutex improves upon the third by rejecting
bounding boxes if the subset sum corresponding to its width is mutually exclusive to the
subset sum corresponding to its height  hk   improves upon the previous packer by using
information learned from an infeasible attempt to reject future bounding boxes 
using all improvements  by n     we test       times fewer bounding boxes compared
to the previous state of the art  on this instance hk   ran out of memory on the last
bounding box because of the sheer number of      rectangles created during the perfect
packing transformation  the introduction of the prime number    as a denominator in the
problem instance is responsible for the increased difficulty between n    and n     
      containment problem
table    compares the performance of various packers using our techniques  because we
have decoupled the minimal bounding box problem from the containment problem  in this
table we use all of our optimizations for the minimal bounding box problem  and only
compare the individual techniques applied to the containment problem  therefore  the
performance data reported is what is required to solve the overall problem using various
containment problem packers 
the first column gives the size of the problem instance from our high precision rectangle
benchmark  as in previous tables  each successive column from left to right improves upon
the previous column by an additional technique  the column called hk   corresponds to
using the previous state of the art with our improved minimal bounding box algorithm 
the column called empty space improves upon hk   by precomputing all of the subset
  

fihuang   korf

sums prior to searching for the x coordinates  and uses our techniques to consolidate empty
space in the y coordinates  the column called dynamic improves upon the previous one
by dynamically computing subset sums  finally  the last column called hk   adds the
ability to learn which unplaced rectangles to exclude from the subset sums computation
after exploring an infeasible subtree  this data was collected using a linux eight core  ghz
intel xeon x     without parallelization 
at n      the problem was scaled up        times in both dimensions  requiring hk  
to create                units of empty space during the perfect packing transformation
and causing it to run out of memory  empty space could not complete n     within a
day because of the sheer number of subset sums that must be explored for both x  and
y coordinates  a problem avoided by dynamic 
      comparison to relative placement
it is interesting to note that the number of bounding boxes appears to be increasing exponentially  mostly likely due to the exponential growth of the number of subset sums
introduced by each successive rectangle in our high precision benchmark  the difficulty of
our unoriented high precision rectangle benchmark is compounded by the fact that as the
precision increases  the branching factor for the single x  and y coordinate values in the
containment problem also increases 
in contrast to our absolute placement technique  moffitt and pollacks        relative
placement techniques do not enumerate the different exact locations for the rectangles  and
therefore promise to be immune to the problem of high precision rectangles  they used a
variable for every pair of rectangles to represent the relations above  below  left  and right 
their search algorithm then required at least one of these non overlapping constraints to
be true for every pair of rectangles  their meta csp approach was modeled after work
by dechter  meiri  and pearl        on solving binary constraint satisfaction problems 
and included various pruning techniques such as model reduction  symmetry breaking  and
graph based pruning heuristics  korf et al          they solve the minimum bounding box
problem with a branch and bound algorithm  evaluating the size of the bounding box when
all non overlapping relationships have been determined  and keeping track of the bounding
box of smallest area seen so far 
note that by contrast  our solver tests bounding boxes in order of non decreasing area 
also  the size of their formulation uses n   variables while we use only n   finally  their
packer only returns one optimal solution as opposed to ours  which does more work by
returning all of the optimal solutions 
we have been able to benchmark their code on our machine in order to provide some
kind of comparison between their methods and ours  this is a crude comparison  because
we cannot run their packer on our unoriented high precision rectangle benchmark since they
have hard coded into their packer the unoriented consecutive rectangle benchmark  a much
easier benchmark as we have shown in table   
the first column in table    refers to the problem size  the second column called mp  
gives the cpu time required for moffitt and pollacks code on problem instances from the
unoriented consecutive rectangle benchmark  which uses low precision rectangles  the third
column called hk   gives the cpu time required by our packer on problem instances from
  

fioptimal rectangle packing  an absolute placement approach

size
n

mp  
time

hk  
time

  
  
  
  
  
  

   
   
    
     
       
       

   
   
   
     
     
       

table     cpu times required by moffitt and pollacks packer on the unoriented consecutiverectangle and our packer on the unoriented high precision rectangle benchmarks 

the unoriented high precision rectangle benchmark  each data point in this table was
collected using an eight core  ghz intel xeon x     in linux without parallelization  note
that our algorithm packs the same number of rectangles somewhat faster than that of moffit
and pollacks 
    summary of high precision rectangles
in this section we proposed a new benchmark consisting of instances with rectangles of
high precision dimensions as well as techniques for using subset sums to limit the number of
positions that must be considered  rules to filter out these subset sums for both the minimal
bounding box and containment problems  methods to learn from infeasible subtrees  and
ways to reduce the number of rectangles created during the perfect packing transformation 
these techniques exploit no special properties of the benchmark  but are most useful for
rectangles with high precision dimensions 
using all of our methods  we solved six more problems up to n     on our new benchmark compared to using our low precision packer on a scaled up instance  our packer is
over two orders of magnitude faster at n    than the previous state of the art  and tests
      times fewer bounding boxes  a cursory comparison between the state of the art using
the relative placement search space and our own shows that we perform slightly faster than
moffitt and pollacks packer  on a benchmark which we have previously shown in section
      to be significantly more difficult than the unoriented consecutive rectangle benchmark
that moffitt and pollacks program was run on 

   future work
humans solve jigsaw puzzles both by asking where a particular piece should go  as well
as asking what piece should go in some empty region  our packer makes use of both
models  the former for the x coordinates and the latter for the y coordinates  it would
be interesting to see how applicable this dual formulation is in other packing  layout  and
scheduling problems  currently  we work on the x coordinates by asking where does this
go   and we work on the y coordinates by asking what goes in this location  our
method has reduced the time spent in the y coordinates so much that now the time spent
  

fihuang   korf

working on the x coordinates is orders of magnitude greater than the time spent working
on the y coordinates  this suggests that performance might be improved by considering
both models simultaneously 
as another direction for continued work  the data indicates that the number of bounding
boxes explored by our minimum bounding boxes solver is the main bottleneck to solving
larger instances of our unoriented high precision rectangle benchmark  an observation we
can make is that across many of these bounding boxes  the same partial solutions are being
explored  resulting in much redundant computation  consequently  a branch and bound
method that starts with a large bounding box  and gradually reduces its dimensions while
various packings are explored would be a promising avenue of further research 

   conclusions
we have presented several new improvements to the previous state of the art in optimal
rectangle packing  within the schema of assigning x coordinates prior to y coordinates  we
introduced a dynamic variable order for the x coordinates  and a constraint that adapts
korfs        wasted space pruning heuristic to the one dimensional case  for the ycoordinates we work on the perfect packing transformation of the original problem  by
using a model that assigns rectangles to empty corners  and inference rules to reduce the
models variables 
our improvements in the search for y coordinates helped us solve n     of the consecutive square benchmark over an order of magnitude faster than the previous state ofthe art  and our improvements in the search for x coordinates also gave us another order
of magnitude speedup by n      compared to leaving those optimizations out  with all
our techniques  we are over    times faster than the previous state of the art on the largest
problem solved to date  allowing us to extend the known solutions for the consecutive square
benchmark from n     to n      furthermore  the data show that very little time is spent
searching for y coordinates  suggesting that rectangle packing may be largely reduced to
the problem of determining the x coordinates 
all of the techniques presented to pick y coordinates are tightly coupled with the dual
view of asking what must go in an empty location  furthermore  while searching for xcoordinates  our pruning rule is based on the analysis of irregular regions of empty space 
and our dynamic variable order also rests on the observation that less empty space leads
to a more constrained problem  the success of these techniques in rectangle packing make
them worth exploring in many other packing  layout  and scheduling problems 
we have also introduced two new benchmarks  one oriented and one unoriented  that
include rectangles of various aspect ratios  these new benchmarks avoid various properties
of easy instances  which we have identified  and were shown to be much harder through a
side by side comparison between various benchmarks using the same state of the art packer 
we have also proposed several search strategies to improve performance on our new benchmarks  we improved upon our strategies used to handle dominance conditions  proposed
a variable ordering heuristic based on increasing branching factor that generalizes previous
strategies  tuned a global interval parameter  and introduced a method to balance the sizes
of the intervals assigned to the x coordinate variables 
  

fioptimal rectangle packing  an absolute placement approach

our experiments revealed that it takes orders of magnitude more time to solve our new
benchmarks compared to instances from the consecutive square benchmark with the same
number of rectangles  we therefore advocate the inclusion of these new  more difficult
benchmarks in the suite of benchmarks used for research in optimal rectangle packing  finally  using all of our techniques together  we solved n     of the oriented equal perimeter
benchmark about     times faster  and n     of the unoriented double perimeter benchmark about    times faster than simply using methods tuned for consecutive squares 
in order to test the limits of our rectangle packer  we presented a new high precision benchmark specifically capturing the pathological case where each successive rectangle
quickly increases the precision required to represent coordinate locations  we presented
various techniques to adapt the absolute placement approach to handle these types of instances  including dynamically using subset sums to limit the number of coordinate values
that must be tested  mutex reasoning that allows us to reject certain combinations of subset
sums used for a bounding boxs width and height  a general method for rejecting future subset sums based on a previously infeasible search  and finally a memory efficient adaptation
of our perfect packing transformation to high precision rectangle instances 
we solved n     of the high precision benchmark in half a minute      times faster than
a basic version of our packer augmented with only the high precision version of our perfect
packing inference rules so that it did not run out of memory  this was also the first instance
requiring precision exceeding the capacity of a    bit integer  our techniques allowed us
to solve up to n     compared to n     the largest instance our low precision techniques
alone could solve  our methods also reduced the number of bounding boxes generated by
a factor of        at this point we are solving problems that require a minimum of    bits
of precision  which should meet the requirements of many real world problems 
we then provided a comparison to the state of the art relative placement packer showing
that our absolute placement packer remains competitive even on rectangles of high precision  and reported on promising avenues of research which may potentially give the absolute
placement approach a clear competitive edge over relative placement methods 
although we have mainly focused on obtaining optimal solutions in our benchmarks 
our work may be easily adapted to applications requiring quick suboptimal solutions by
simply replacing our algorithm for the minimum bounding box problem with alternatives
such as the anytime algorithm that we described in section       
    comparison to constraint programming methodologies
there are clearly tradeoffs between taking our ground up programming approach in c  
and taking a constraint programming approach  while the latter provides quick prototyping
and reuse of constraint libraries that other researchers have already implemented  it also
forces the problem to be expressed in the abstract constraint language  such an abstract
layer turns out to add unnecessary overhead for the algorithms and data structures that
one naturally uses to solve our problem of optimal rectangle packing 
for example  as we previously described  for the cumulative constraint  we simply add
a constant to a consecutive range in an integer array when we assign an x coordinate to a
rectangle  when we backtrack  we scan the same array and just subtract the same constant 
scanning and manipulating arrays  iteration  and fast pushing and popping of the program
  

fihuang   korf

stack in recursive algorithms are precisely the operations that modern computer hardware
has been optimized for  this is significant as we explore over two trillion search nodes
for n     in the square packing benchmark  and in fact our solver spends about     of
its time on just these array manipulation operations alone  this is how we explain the
orders of magnitude speedup for processing just the x coordinate solutions in a  d array
instead of the  d bitmap by korf         as we move from  d arrays  to  d bitmaps  to
abstract representations of variables and values in constraint programming  the patterns
of computation and data structures simply become too distant from what the underlying
hardware is optimized for 
for optimal rectangle packing  it happens that the algorithms and data structures that
naturally solve the problem map very nicely in form and function to the hardware of modern
computers  note that one may always port this code into a constraint module that may be
called by a constraint solver  but there is still some computational indirection between this
module and the backtracking control logic of the constraint solver  the sacrifice we make
in our approach  however  is the fact that our solver is tailored specifically to the rectangle
packing problem as we have defined it  and it would require more implementation effort to
reconfigure our algorithms and heuristics for a slightly different rectangle packing problem 
we hope  however  that this latter problem is ameliorated by disciplined object oriented 
modular software design 

   broader lessons
beyond the specific problem of rectangle packing  what broader lessons can we learn from
this work  we believe there are several 
one of the main applications of rectangle packing is to scheduling  as described in the
introduction  the rectangle packing problem is an abstraction of a scheduling problem where
different tasks take different amounts of time  and all require different amounts of a onedimensional resource that must be allocated contiguously  such as memory on a computer 
the width of the bounding box becomes the total time  the height the total amount of the
resource available  and each job becomes a rectangle with width equal to time duration 
and height equal to the amount of the resource required 
what we found  however  is that vast majority of the time used by our rectangle packer
is in assigning just the x coordinates of the rectangles  subject to the cumulative constraint 
which is that for every x coordinate in the bounding box  the sum of the heights of the rectangles that overlap that x coordinate cannot exceed the height of the bounding box  this
important subpart of the rectangle packing problem models a much more general problem
known as the resource constrained scheduling problem  this is the same as the scheduling
problem described above  but without the constraint that the resource be allocated contiguously  for example  in scheduling tasks on a planetary rover with a limited power budget 
the sum of the power requirements of all the tasks that are active at any given time cannot
exceed the total power budget of the rover  thus  this subpart of our rectangle packer can
be used to tackle this more general scheduling problem 
another general lesson that can be learned from this work is that the absolute placement
approach to various packing problems in two  three  or more dimensions may be effective
even on problems with high precision dimensions  one might expect that absolute placement
  

fioptimal rectangle packing  an absolute placement approach

would not be competitive with relative placement approaches on these problems  but the
key to our success in this area is that instead of considering all possible placements  we
only consider placements that correspond to subset sums of the relevant dimensions  while
there is no guarantee that this approach will work in other high precision packing problems 
we have shown that it is at least worth considering  and may be effective 
perhaps the largest lesson to be learned here is both encouraging and discouraging  the
problem of rectangle packing is extremely simple  and can be understood by and played
as a game by children  yet the research over the last decade described here shows that
the most efficient algorithms are quite complex  if the best algorithms for such a simple
problem are so complex  it is likely that the best algorithms for more complex problems
are even more complex  which is the discouraging part  the encouraging part is that the
history of this research has shown that each new idea can result in an order of magnitude
improvement over the previous state of the art on larger problems  suggesting that there is
still very significant progress to be made on this problem  and by extension others like it 

acknowledgments
we wish to thank reza ahmadi  adnan darwiche  and adam meyerson for their advice
on this work  we also thank michael moffitt for making his packer available  this research was funded in part by the national science foundation under grant number iis         the source code of our optimal rectangle packer is open sourced and available at
http   code google com p rectpack 

references
aggoun  a     beldiceanu  n          extending chip in order to solve complex scheduling
and placement problems  mathematical and computer modelling               
beldiceanu  n     carlsson  m          sweep as a generic pruning technique applied to the
non overlapping rectangles constraint  in cp     proceedings of the  th international
conference on principles and practice of constraint programming  pp          london  uk  springer verlag 
beldiceanu  n   carlsson  m     poder  e          new filtering for the cumulative constraint
in the context of non overlapping rectangles  in perron  l     trick  m  a   eds   
cpaior  vol       of lecture notes in computer science  pp        springer 
beldiceanu  n   carlsson  m   poder  e   sadek  r     truchet  c          a generic geometrical constraint kernel in space and time for handling polymorphic k dimensional
objects  in bessiere  c   ed    cp  vol       of lecture notes in computer science 
pp          springer 
bhattacharya  s   roy  r     bhattacharya  s          an exact depth first algorithm for the
pallet loading problem  european journal of operational research                  
chan  h  h     markov  i  l          practical slicing and non slicing block packing without
simulated annealing  in glsvlsi     proceedings of the   th acm great lakes
symposium on vlsi  pp          new york  ny  usa  acm 
  

fihuang   korf

chazelle  b          the bottomn left bin packing heuristic  an efficient implementation 
ieee transactions on computers  c                
clautiaux  f   carlier  j     moukrim  a          a new exact method for the twodimensional orthogonal packing problem  european journal of operational research 
                  
dechter  r   meiri  i     pearl  j          temporal constraint networks  artificial intelligence                 
dowsland  k  a          an exact algorithm for the pallet loading problem  european
journal of operational research               
dowsland  k  a     dowsland  w  b          packing problems  european journal of
operational research              
huang  e     korf  r  e          new improvements in optimal rectangle packing  in
boutilier  c   ed    ijcai  pp         
huang  e     korf  r  e          optimal rectangle packing on non square benchmarks  in
aaai    proceedings of the   th national conference on artificial intelligence  pp 
        aaai press 
huang  e     korf  r  e          optimal packing of high precision rectangles  in burgard 
w     roth  d   eds    aaai  aaai press 
korf  r  e          optimal rectangle packing  initial results  in giunchiglia  e   muscettola 
n     nau  d  s   eds    icaps  pp          aaai 
korf  r  e          optimal rectangle packing  new results  in zilberstein  s   koehler  j  
  koenig  s   eds    icaps  pp          aaai 
korf  r  e   moffitt  m  d     pollack  m  e          optimal rectangle packing  annals of
operations research                  
lahrichi  a          scheduling  the notions of hump  compulsory parts and their use in
cumulative problems  comptes rendus de academie des sciences  paris              
lesh  n   marks  j   mcmahon  a     mitzenmacher  m          exhaustive approaches to
 d rectangular perfect packings  information processing letters              
li  s  c   leong  h  w     quek  s  k          new approximation algorithms for some dynamic storage allocation problems  in chwa  k  y     munro  j  i   eds    cocoon 
vol       of lecture notes in computer science  pp          springer 
lipovetskii  a  i          a geometrical approach to computation of the optimal solution
of the rectangle packing problem  american mathematical society translations      
      
lodi  a   martello  s     monaci  m          two dimensional packing problems  a survey 
european journal of operational research                  
lodi  a   martello  s     vigo  d          recent advances on two dimensional bin packing
problems  discrete applied mathematics                    
martello  s     vigo  d          exact solution of the two dimensional finite bin packing
problem  management science                 
  

fioptimal rectangle packing  an absolute placement approach

meir  a     moser  l          on packing of squares and cubes  journal of combinatorial
theory                
mitola  j     maguire  g          cognitive radio  making software radios more personal 
ieee personal communications magazine              
moffitt  m  d     pollack  m  e          optimal rectangle packing  a meta csp approach 
in long  d   smith  s  f   borrajo  d     mccluskey  l   eds    icaps  pp        
aaai 
onodera  h   taniguchi  y     tamaru  k          branch and bound placement for building
block layout  in dac     proceedings of the   th acm ieee design automation
conference  pp          new york  ny  usa  acm 
simonis  h     osullivan  b          search strategies for rectangle packing  in stuckey 
p  j   ed    cp  vol       of lecture notes in computer science  pp        springer 
simonis  h     osullivan  b          almost square packing  in achterberg  t     beck 
j  c   eds    cpaior  vol       of lecture notes in computer science  pp         
springer 
sweeney  p  e     paternoster  e  r          cutting and packing problems  a categorized 
application orientated research bibliography  the journal of the operational research
society                 
weglarz  j          project scheduling  recent models  algorithms and applications  springer 
kluwer 
yap  r  h  c          constraint processing by rina dechter  morgan kaufmann publishers 
      hard cover  isbn                xx       pages  theory pract  log  program  
                

  

fi