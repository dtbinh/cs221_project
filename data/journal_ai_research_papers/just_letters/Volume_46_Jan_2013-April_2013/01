journal artificial intelligence research                

submitted        published      

optimal rectangle packing 
absolute placement approach
eric huang

ehuang parc com

palo alto research center
     coyote hill road
palo alto  ca       usa

richard e  korf

korf cs ucla edu

ucla computer science department
    e boelter hall
university california  los angeles
los angeles  ca            usa

abstract
consider problem finding enclosing rectangles minimum area
contain given set rectangles without overlap  rectangle packer chooses xcoordinates rectangles y coordinates  transform
problem perfect packing problem empty space adding additional rectangles  determine y coordinates  branch different rectangles
placed empty position  packer allows us extend known solutions
consecutive square benchmark       squares  introduce three new benchmarks  avoiding properties make benchmark easy  rectangles shared
dimensions  third benchmark consists rectangles increasingly high precision 
pack efficiently  limit rectangles coordinates bounding box dimensions
set subset sums rectangles dimensions  overall  algorithms represent
current state of the art problem  outperforming algorithms orders
magnitude  depending benchmark 

   introduction
given set rectangles  problem find enclosing rectangles minimum area
contain without overlap  refer enclosing rectangle bounding box 
avoid confusion  optimization problem np hard  problem deciding
whether set rectangles packed given bounding box np complete  via
reduction bin packing  korf         consecutive square benchmark simple set
increasingly difficult benchmarks problem  task find bounding
boxes minimum area contain set squares dimensions               
n n  korf         example  figure   optimal solution n     
use benchmark explain many ideas paper  techniques
limited packing squares  apply rectangles 
rectangle packing many practical applications  including modeling scheduling problems tasks require resources allocated contiguous chunks 
example  consider task scheduling allocating contiguous memory addresses
programs  width rectangle represents length time program runs 
c
    
ai access foundation  rights reserved 

fihuang   korf

figure    optimal solution n     consecutive square benchmark  packing
squares dimensions                             bounding box minimum
area         

  

fioptimal rectangle packing  absolute placement approach

height represents amount contiguous memory needs  rectangle packing solution
tells us programs run  well memory addresses
assigned  similar problems include scheduling ships different length
berthed along single  long wharf  li  leong    quek         well allocation scheduling radio frequency spectra usage  mitola   maguire         rectangle
packing appears loading set rectangular objects pallet without stacking
them  cutting stock layout problems contain rectangle packing subproblems 
    overview
remainder article organized follows  first introduce various benchmarks section   specifically define rectangle packing instances solve 
section    review state of the art rectangle packers techniques 
provides foundation upon present new work  follow section  
data collected compare work previous state of the art using previous
benchmarks  compare difficulty previous benchmarks new ones 
section    present benchmark rectangles successively higher precision
dimensions  new solution techniques handle this  follow experimental results 
compare methods competing search spaces used packing highprecision rectangles  show methods remain competitive 
sections     explain various avenues future work  concluding article
summarizing contributions results  previously published much
work several conference papers  huang   korf                    

   benchmarks
several reasons motivating benchmarks  first  benchmarks describe
instances single parameter n   allowing researchers easily reproduce instances 
second  instances unique  optimal solutions reported easily
validated others  advantages many real world instance libraries
randomly generated ones  third  benchmarks define infinite set instances
successive instance harder previous  solver superior another solver
solve instance faster  larger instance amount time 
contrast  comparison using library instances may require counting number
instances completed within given time limit  furthermore  instance libraries 
often one solver performs well one subset instances competing solver performs
well different subset  making comparisons inconclusive 
believe benchmarks capture difficult instances rectangle
packer may face investigate modeling generation random problems 
although clautiaux et al         others used random instances  non random
benchmarks used korf        simonis osullivan        better facilitated
comparison state of the art packers  however  comprehensive overviews 
refer reader numerous surveys available  lodi  martello    vigo        lodi 
martello    monaci        dowsland   dowsland        sweeney   paternoster        
  

fihuang   korf

    previous benchmarks
several previous benchmarks used literature shown easier
benchmarks propose  part due fact benchmarks  solvers 
may improved research  ensure cover various properties
rectangles  addition providing easy way compare performance among different
packers measure progress 
consecutive square benchmark  korf         simple set increasingly difficult
instances  task find bounding boxes minimum area contain set
squares sizes                n n   prior work  many recent stateof the art packers used popular benchmark measure performance  including
moffitt pollack         korf  moffitt  pollack         simonis osullivan
        date  largest instance solved problem n      shown figure   
using packer  huang   korf         consider problem packing squares
square benchmark gets much easier problem size increases  due
large differences areas consecutive square bounding boxes 
unoriented consecutive rectangle benchmark  korf et al          instance
set rectangles sizes                n  n       rectangles may
rotated    degrees  subsequently explain  fact many pairs
rectangles instance share equal dimensions causes optimal solutions
leave empty space  making benchmark easy solve  include benchmark
completeness  note effective measure comparing different packers 
finding first optimal solution another benchmark simonis osullivan
       used conjunction problem instances unoriented consecutiverectangle benchmark  contrast problem finding optimal solutions 
measure time takes find first optimal solution  makes much
difficult reliably compare solvers unless focus research value
ordering tie breaking among bounding boxes equal area 
example  simonis osullivan        report find first solution
n     takes            hours     minutes     seconds   shown table   page
    six solutions n                                                   
requiring solver cpu times                                               
respectively  smaller bounding boxes needed test optimal
solution empty space  used simonis osullivans termination criteria
returned first optimal solution  would need    seconds  therefore  finding
minimum bounding boxes instead first one benchmark produces
harder problems larger n   better facilitates program comparisons 
    properties easy benchmarks avoid
motivate new benchmarks  explain previous benchmarks tended
much easier comparison  constructed new benchmarks
describe instances consisting rectangles unique dimensions  without duplicates 
without area occupied rectangles 
  

fioptimal rectangle packing  absolute placement approach

 a  solution       bounding
box unoriented instance     
                       

 b  solution       bounding
box unoriented instance  
                          

figure    examples solutions instances rectangles equal dimensions 

      rectangles equal dimensions
unoriented consecutive rectangle benchmark  rectangles share dimension
another rectangle  example  figure  a optimal solution n      optimal
solutions  rectangles equal dimensions tend line next other  forming larger
rectangles leaving little empty space  figure  a          line up 
                  fact  solutions
benchmark much smaller percentage empty space similar sized instances
consecutive square benchmark  rectangles unique dimensions 
notice benchmarks duplicate rectangles  figure  b  solved
quickly 
      rectangles small area small dimensions
figure  b example perfect packing  empty space
solution  problems perfect packings tend easy two reasons  one
test bounding boxes increasing order area  test fewer boxes  since never test
box minimum area required  second problems 
rather deciding rectangle go bounding box 
efficient algorithm decide cell empty space rectangle occupy
  

fihuang   korf

it  soon small region empty space created cant accomodate remaining
rectangles  algorithm backtrack 
consecutive square unoriented rectangle benchmarks  large
rectangles capture much total area instance  thus  packer search
deeply using allowable empty space  little empty space  early
backtracking likely since cannot find place next rectangle  therefore 
small rectangles benchmarks insignificant impact search effort 
previous benchmarks  consecutive square benchmark  retangles
largest area largest dimensions  making obvious rectangles
place first  largest rectangles constrained  impose
constraints remaining rectangles 
contrast  new benchmarks trade off rectangles large
dimensions large area  widest rectangle oriented equal perimeter benchmark  described below  smallest branching factor search xcoordinates  however  least area  search wont constrain
placement remaining rectangles much  raises non trivial question best
variable ordering non square rectangles 
    new benchmarks
propose several new benchmarks difficult comparing instances
number rectangles  experimental results make use following
benchmarks  addition consecutive square unoriented consecutive rectangle
benchmarks described above 
      equal perimeter rectangles
first  present oriented equal perimeter rectangle benchmark  instance
set rectangles sizes   n      n           n       n    rectangles may
rotated  see figure     given n   rectangles unique perimeter  n    
experiments  benchmark much difficult either consecutive square
benchmark unoriented consecutive rectangle benchmark  korf et al        
number rectangles  tested state of the art packer  huang   korf       
old new benchmarks  n     oriented equal perimeter benchmark
took nine hours solve  n     consecutive square unoriented
consecutive rectangle benchmarks took one second six seconds  respectively 
second  present unoriented double perimeter rectangle benchmark  instances described set rectangles     n         n           n     n      
n n   rectangles may rotated    degrees  rectangles unique
perimeter  n   benchmark difficult benchmarks
used previously literature  benchmark difficult oriented
one introduced previous paragraph  experiments using techniques 
n     took two days solve 
far  benchmarks discussed low precision integer dimensions 
property poses problem packer  enumerates various integer coordinate locations rectangle may placed  high precision values  however 
  

fioptimal rectangle packing  absolute placement approach

figure    optimal solution n     oriented equal perimeter benchmark  packing
oriented rectangles dimensions                             bounding box
minimum area        

  

fihuang   korf

number distinct positions increases dramatically  motivates study packing rectangles high precision dimensions  particular  propose unoriented
high precision rectangle benchmark  instances described set rectangles
 
   
 
 
 
                 n n      methods used solve benchmark quite
different used low precision case 

   solution techniques
section describe previous solution strategies well various new techniques
use rectangle packer  first describe techniques apply consecutive square benchmark  oriented equal perimeter benchmark  unoriented
double perimeter benchmark  work unoriented high precision rectangle benchmark included methods significantly different  deferred
section   
    previous work
earlier work focused optimal methods packing set rectangles
given bounding box motivated problem pallet loading  dowsland       
used depth first search abstract graph representation search space solve
problem optimally problem sets modeled real world pallet box dimensions 
although problem instances contained average    rectangles    
benchmarks far easier consider here  rectangles
size  significant amount empty space solutions  bhattacharya
et al         extended work additional lower bounds pruning techniques based
dominance conditions demonstrated work benchmarks 
examining rectangle packing instances rectangles different dimensions 
onodera et al         used depth first search  branching point search
space commitment particular non overlap constraint two rectangles 
lower bound graph reduction techniques applied prune search space  allowing optimally solve problems six rectangles 
chan markovs blobb        packer used branch and bound order find
minimum area bounding box contain set rectangles  solver could handle
eleven rectangles  observed instances duplicate rectangles
much easier  causing packer cluster rectangles together optimal solution 
lesh et al s solver        used depth first search  placing rectangle first bottommost left most position fit  the bottom left heuristic  see chazelle        
determine whether set rectangles packed given enclosing rectangle 
able handle twenty nine rectangles ten minutes average 
testbed consisted instances whose optimal solutions empty space 
clautiaux et al         presented branch and bound method x coordinates rectangles computed prior y coordinates  assigning
x coordinates  method uses relaxation similar cumulative constraint  aggoun
  beldiceanu        requires sum heights rectangles overlapping
particular x coordinate cannot exceed height bounding box  y coordinates
determined using search space derived bottom left heuristic  chazelle 
  

fioptimal rectangle packing  absolute placement approach

       using optimized data structures martello vigo         beldiceanu
carlsson        applied plane sweep algorithm used computational geometry detect violations non overlap constraints  later adapted technique geometric
constraint kernel  beldiceanu  carlsson  poder  sadek    truchet         lipovetskii       
proposed branch and bound algorithm placed rectangles lower left hand positions 
prior state of the art  due korf              simonis osullivan        
divide rectangle packing problem containment problem minimal
bounding box problem  former tries pack given set rectangles given bounding
box  latter finds bounding box least area contain given set
rectangles  packers algorithm minimal bounding box problem calls
algorithm containment problem subroutine 
    overall search strategy
korf et al s        algorithm  minimum bounding box solver calls
containment problem solver  simonis osullivan         assign x coordinates
prior y coordinates 
although use simonis osullivans        ideas  take
constraint programming approach constraints specified general purpose
solver prolog  instead  implemented program scratch c    allowing us
flexibly choose constraints use time naturally encode
search space use y coordinates  implemented chronological backtracking
algorithm dynamic variable ordering  algorithm works five stages goes
root search tree leaves 
   minimum bounding box algorithm generates initial candidate set bounding
boxes various widths heights 
   containment solver called bounding box order increasing area 
infeasible bounding box  insert another back candidate set
bounding boxes height one unit greater  packing found  continue
testing boxes equal area find optimal solutions terminating 
   containment solver first works x coordinates model variables
rectangles values x coordinate locations  using dynamic variable ordering
constraint detects infeasible subtrees 
   x coordinate solution found  problem transformed perfect packing instance 
   searches set y coordinates model variables empty corners
values rectangles 
describe detail steps 
  

fihuang   korf

    minimum bounding box problem
one way solve minimum bounding box problem find minimum maximum
areas describing set candidate potentially optimal bounding boxes  boxes
sizes generated areas within range  tested non decreasing order
area solutions smallest area found  lower bound area
sum areas given rectangles  upper bound area determined
bounding box greedy solution found setting bounding box height
tallest rectangle  placing rectangles first available position
scanning left right  column scanning bottom top 
several techniques  korf              use prune set bounding
boxes  review here  first generate set widths bounding boxes 
starting width widest rectangle width greedy solution
described above  width  generate feasible height using lower bounds
subsequently describe  resulting bounding boxes used initialize
min heap sorted non decreasing order area  search proceeds calling
containment solver bounding box minimal area heap  box infeasible 
increase height box one  insert new box back min heap 
given bounding box width  initialize height maximum following
lower bounds  first  height must least height tallest rectangle
instance  second  height must large enough accommodate total area
rectangles instance  third  every pair rectangles  sum widths
exceed width bounding box  bounding box height must least
sum heights  since cant appear side by side  one must top
other  fourth  set rectangles whose widths greater half width
bounding box must stacked vertically  including rectangle smallest height
whose width exactly half width bounding box  finally  certain properties
exist given rectangle packing instance  force height greater equal
width break symmetry  example  one sufficient property instance
consisting squares  since solution w h bounding box easily transforms
another one h w bounding box  another sufficient property every rectangle
dimensions w h correspond another one dimensions h w 
unoriented instances  given bounding box width  certain rectangles may forced
one orientation  improving lower bound bounding box height  note
break symmetry bounding box dimensions every unoriented instance 
      anytime algorithm
problem instance many rectangles  immediate solution required 
korf        provides anytime algorithm bounding box problem  replacing one
described above  calls containment problem solver  first find greedy
solution bounding box whose height equal tallest rectangle  described
previous section  repeatedly call containment problem solver following
way  previous attempt given bounding box resulted packing area
greater area best solution seen far  decrease width
one unit attempt solve resulting bounding box problem  instead previous
  

fioptimal rectangle packing  absolute placement approach

attempt infeasible  increase height bounding box one unit 
algorithm terminates width current bounding box less width
widest rectangle 
    containment problem
korfs        absolute placement approach modeled rectangles variables positions
bounding box values  rectangles placed turn depth first search 
possible locations tested rectangle  contrast  simonis osullivans
       packer assigned x coordinates rectangles y coordinates 
suggested clautiaux et al          well using cumulative constraint  aggoun
  beldiceanu         improving performance orders magnitude  cumulative
constraint adds height rectangles overlap given x coordinate location 
pruning values exceed height bounding box  constraint
checked exploring x coordinates exploring y coordinates later on 
improved exploring y coordinates differently  modeling candidate locations
variables  rectangles values  huang   korf         made packer
order magnitude faster simonis osullivans 
simonis osullivan        furthermore applied least commitment principle  yap 
      constraint processing  first committing placement rectangles
interval x coordinates instead single x coordinate value  x intervals
explored turn  constrain candidate individual x coordinates explored later 
works committing x interval induce pruning via cumulative constraint 
example  picking x interval  a  b  size smaller width
rectangle wr   implies regardless x coordinate rectangle eventually takes 
must contribute height x coordinate within interval  b    wr    finally 
height bounding box constrains cumulative heights rectangles
given x coordinate  similar ideas beldiceanu et al          larger intervals result
weaker constraint propagation  less pruning  smaller branching factor  smaller
intervals result stronger constraint propagation larger branching factor  size
intervals experimentally determined 
example      rectangle x coordinates restricted interval       contributes height   x coordinates     even prior deciding exact x coordinate
value  compulsory part  lahrichi        constrains cumulative height rectangles may overlap x coordinates     solution  interval assignments
infeasible  searching individual x values futile  however  find
set interval assignments  still search set single x coordinate
values  simonis osullivan        assigned x intervals  single x coordinates  y intervals 
single y coordinates  order 
    assigning x intervals x coordinates
x coordinates  propose pruning constraint adapted korfs        wastedspace pruning heuristic  dynamic variable order replace beldiceanus        fixed ordering  method optimize values assigned x interval variables 
  

fihuang   korf

figure    test violations cumulative constraint  remaining space
placing     rectangle x   represented vector h                i 

      pruning infeasible subtrees
present constraint based formulation korfs        two dimensional wasted space
pruning algorithm  adapted one dimensional case  given partial solution  korfs
algorithm computed lower bound amount wasted space  used
prune upper bound  contrast  compute numerical bounds
instead detect infeasibility single constraint 
rectangles placed bounding box  remaining empty space gets chopped
small irregular regions  eventually empty space segmented small enough
chunks cannot accommodate remaining unplaced rectangles 
point backtrack  assigning x coordinates bounding box height h 
keep histogram hv    v            vh i  vi number empty cells  units empty
space  empty columns height i  example  assume figure  
assigned x coordinates     rectangle     bounding box  resulting
histogram would h       i  since   cells empty columns height    empty
cells columns height      cells empty columns height   
assume left place         rectangle  assign
six cells     rectangle empty cells v      leaving us remaining
empty cells h       i  point  cannot assign area     
  empty cells accommodate height need    prune 
general  set unplaced rectangles r bounding box height h 

h 

x

wr hr

rr hr h

h
x


vi  

   

i h

rectangle r r dimensions wr hr   is  every given height h 
amount space accommodate rectangles height h greater must least
cumulative area rectangles height h greater  check constraint
x coordinate assignment 
  

fioptimal rectangle packing  absolute placement approach

 a  x   dominated position
    square 

 b  x   undominated position
    square 

figure    example dominance conditions 

      pruning dominance conditions
korf        introduced set dominance conditions prune positions large rectangles close sides bounding box  example  imagine must pack
squares                 figure  a  placement    square leaves
    gap left side bounding box     square cannot fit 
        squares fit within gap  fact placed
entirely within gap  notice solution arrangement figure  a 
always rearrange figure  b without disturbing squares  thus 
need try placing     square x   long tried placing
x    general  rectangle placement dominated leaves gap rectangles
individually fit packed together gap without protruding
it  although korf hard coded dominance rules consecutive square benchmark 
dynamically generate every instance insignificant preprocessing overhead 
      variable ordering
following subsections consider two variable orders work together packer 
use fixed ordering governs rectangle assigned next  ordering used
x intervals independently use single x coordinate variables 
point time  must choose whether assign next x interval next
single x coordinate variable  since ordering x intervals single x coordinate
variables simpler  present technique first 
ordering x intervals x coordinates area variable order
based observation placing rectangles larger area constraining
placing smaller area  times either choose assign single
x coordinate rectangle previously assigned x interval 
assign x interval rectangle yet made assignments for  shown
figure    either assignments decrease amount empty space represented
cumulative constraint vector  always pick next variable results
least remaining space 
  

fihuang   korf

ordering among rectangles branching factor natural variable order
arises consecutive square unoriented consecutive rectangle benchmarks using strategy picking constrained variable next  example 
consecutive square benchmark  largest rectangle clearly largest height 
width  area  however  new benchmarks rectangle largest width
smallest height  largest area  making good variable ordering non obvious 
propose variable order rectangles various aspect ratios picking
variable fewest number values first  favor smaller branching factor closer
root search tree  oriented equal perimeter benchmark  recall
assign intervals x coordinates individual x coordinates  simonis
sullivan        use constant factor times rectangle width define interval
size  branching factor x interval variables given rectangle

bw rw
 
bw  
b 
 
   
 
crw
c rw
c
bw bounding box width  rw rectangle width  c constant chosen
experimentally  numerator bw rw number x coordinate values
rectangle still fitting bounding box  denominator crw
size interval assigning given rectangle  example  c     
would assign intervals size three     rectangle 
may drop translational constant   c well positive scalar bw  c since
interested relative ordering rectangles  leaving us   rw
means oriented benchmark place rectangles order decreasing
width  unoriented double perimeter benchmark  packer first tries values
particular x interval  rotates rectangle    degrees trying another set
x interval values  case branching factor


bw rw
bw  
bw rh
 
 
b 
 
 
 
 
   
crw
crh
c rw
rh
c
mentioned before  drop scalar translational constant  giving us
 
rw   rh
 
 
 
 
   
rw
rh
rw rh
rectangles given instance perimeter definition 
numerator result equation   constant  therefore unoriented benchmark 
place rectangles order decreasing area 
      determining sizes x intervals
consecutive square benchmark  packer used interval size      times
width given rectangle  found larger interval sizes improve performance
packer new equal perimeter benchmarks  use value c      instead 
assign larger intervals short wide rectangles  x interval variables
rectangles tend branching factors three less  balance
sizes intervals values assigned equally constraining subtrees 
example  consider c       rectangle width     set possible x coordinate
  

fioptimal rectangle packing  absolute placement approach

values         without balancing sizes intervals  packer would explore interval
sizes   c       x         x          finally remaining domain values
small interval x          results small compulsory parts therefore
large search subtrees first two branches  large compulsory part thus
small search subtree third 
since must explore three branches anyway  balance sizes interval
assignments exploring x        x         x          eventual effect better
balance size search subtrees amongst branches  packer first computes
branching factor induced global interval parameter c      rectangle 
balances number values interval assignment 
interactions interval assignment dominance conditions consecutive square instances  squares several positions following x  
dominated  therefore  packer first branches assigning degenerate interval x       exploring interval assignments undominated positions  although
technique increased performance packer fivefold compared leaving out 
strategy slowed performance fivefold oriented unoriented doubleperimeter benchmark  reason degradation performance follows 
equal perimeter benchmarks    n rectangle always partially fit gaps
left rectangles  must always protrude gaps  thereby eliminating
dominance conditions previously described  without dominated positions
account for  simply applying strategy used consecutive squares new
benchmarks results packer committing single x coordinate values situations
desirable include positions larger interval assignment 
avoid this  packer detects dominated positions dynamically
chooses whether assign degenerate interval x coordinate assignment 
immediately begin interval assignments 
    perfect packing transformation
every complete x coordinate solution  transform problem instance perfect
packing problem instance working y coordinates  perfect packing instance
rectangle packing problem property solution empty space 
transformation done adding original set rectangles number    
rectangles necessary increase total area rectangles bounding box 
although new     rectangles increase problem size  hope ease
solving perfect packing instances offset difficulty packing rectangles  next
describe search space perfect packing  show  methods rely
perfect packing property empty space 
    assigning y coordinates
alternative asking rectangle go  ask rectangle
go here  former model  rectangles variables empty locations
values  whereas latter  empty locations variables rectangles values 
y coordinates  search latter model  use  d bitmap draw placed rectangles
  

fihuang   korf

test overlap  backtrack positions cannot accommodate remaining
rectangles  required korfs        wasted space pruning rule 
      empty corner model
perfect packing solutions  every rectangles lower left corner fits lower left
empty corner formed rectangles  sides bounding box  combination
both  model  one variable per empty corner  final solution  since
rectangle goes exactly one empty corner  number empty corner variables
equal number rectangles perfect packing instance  set values
set unplaced rectangles 
search space interesting property variables dynamically created
search x  y coordinates empty corner known
rectangles create placed  furthermore  placing rectangle empty corner
assigns x  y coordinates 
note empty corner model describe perfect packing solutions  given
perfect packing solution  list unique sequence rectangles scanning
left right  bottom top lower left corners rectangles  sequence
corresponds sequence assignments root search space leaf
tree  property bounds maximum size search space n     n  
number rectangles performed perfect packing transformation 
      duplicate rectangles
due additional     rectangles perfect packing transformation 
introduced additional redundancy problem  simple way handle
follows  particular empty corner  never place rectangle duplicate one
already tried position  method handling duplicates applies
duplicate rectangles original problem instance 

   experimental results
benchmarked packers linux  ghz amd opteron      gb ram 
packer call kmp    korf et al         benchmarked machine 
quote published results  include data relative placement
packer competitive  results simonis osullivans packer        
call ss    quoted  obtained sicstus prolog       windows
 ghz intel xeon          gb ram  since machine faster ours 
comparisons conservative estimate relative performance 
    previous benchmarks
consecutive square benchmark unoriented consecutive rectangle
benchmarks  korf et al         used literature measure performance 
include data collected using two benchmarks 
  

fioptimal rectangle packing  absolute placement approach

size
n

kmp  
time

ss  
time

fixedorder
time

  
  
  
  
  
  
  
  
  
  
  
  
  

    
    
     
       
        
          
          
           

   
   
   
    
    
     
       
        

   
   
   
   
   
    
     
       
          

hk  
time
   
   
   
   
   
    
    
     
       
       
          
          
           

table    cpu times required various packers consecutive square benchmark 
task pack squares     n n  

      consecutive squares
table   compares cpu runtimes four packers consecutive square benchmark 
first column specifies instance size  number squares
size largest one  remaining columns specify cpu times required various
algorithms find optimal solutions format days  hours  minutes 
seconds  multiple boxes minimum area  n     listed table
  appendix      report total time required find optimal bounding boxes 
two reasons  first  finding minimum area bounding boxes removes
question bounding box test first one area  second 
providing optimal solutions  researchers working rectangle packing use
information verify correctness programs 
hk   includes wasted space pruning rule x coordinates  dynamic variable
ordering x intervals x coordinates  perfect packing transformation 
related search space inference rules  named packer consistent
previous work  huang   korf         ss   refers previous state of the art
packer  simonis   osullivan         largest problem previously solved n    
took ss      hours  solved problem    minutes solved five
open problems n      kmp   refers korf et al s        absolute placement
packer  fixedorder assigns x intervals single x coordinates  includes
ideas  hk  s dynamic variable ordering x coordinates order
magnitude faster fixedorder n      order magnitude improvement
fixedorder ss   likely due use perfect packing assigning ycoordinates  include timing packer perfect packing disabled
competitive  e g   n     took     hours  
  

fihuang   korf

size
n
  
  
  
  
  
  
  
  
  
  
  
  

x coordinate
solutions
   
   
   
   
   
     
   
     
      
      
      
      

seconds
x
    
    
    
     
     
      
        
        
         
          
          
            

seconds

    
    
    
    
    
    
    
     
     
     
      
      

ratio
x y
   
   
    
    
     
     
       
     
     
       
     
        

table    cpu times spent searching x  y coordinates consecutive square
benchmark

table   second column number complete x coordinate assignments
packer found entire run particular problem instance  third column
total time spent searching x coordinates  fourth column total time
spent performing perfect packing transformation searching y coordinates 
columns represent total cpu time entire run given problem instance 
last column ratio time third column fourth  interestingly 
almost time spent x coordinates opposed y coordinates 
suggests could efficiently enumerate x coordinate solutions  could
efficiently solve rectangle packing  confirmed relatively x coordinate
solutions exist even large instances  data table   obtained linux
    ghz intel core   duo e     machine separate experiment table   
total time spent given instance different 
      unoriented consecutive rectangles
table   compares cpu times packer unoriented consecutive rectangles
benchmark korf et al          although techniques due simonis
osullivan        outperform korf et al  consecutive square benchmark 
previously published results benchmark besides korf et al 
benchmark easier consecutive square benchmark  break
contributions techniques  differences delineated
clearly previous section  primary differentiating feature benchmark
rectangles unoriented 
first column gives size problem instance  second column gives
performance previous state of the art packer benchmark  using korf et al s
code         third column gives performance packer benchmark 
  

fioptimal rectangle packing  absolute placement approach

size
n

kmp  
time

hk  
time

  
  
  
  
  
  
  
  
  
  
  
  
  
  

   
   
   
   
    
     
       
       
        
          

   
   
   
   
   
   
   
   
     
       
       
          
          
          

table    cpu times required two packers unoriented consecutive rectangle benchmark  task pack unoriented rectangles sizes              n  n     

data table collected linux     ghz intel core   duo e     machine 
except n     n      collected linux     ghz intel xeon e    
  gb ram  experiments revealed     faster former
machine 
benchmark techniques allowed us extend known solutions
n     n     allowed us solve n        times faster previous
state of the art benchmark 
    oriented equal perimeter unoriented double perimeter rectangles
section uses new benchmarks compare techniques developed
non square instances  techniques discuss here  including dynamic adjustment
interval sizes generalized variable order based branching factor  largely
affect performance packer consecutive square benchmark  fact 
tested packer benchmark see effects extra overhead added
improvements  new packer resulted five percent speedup compared
packer without changes consecutive square benchmark  likely due minor
improvements data structures  balancing interval sizes  therefore  compare
effects techniques new benchmarks  techniques
developed new benchmarks improve performance oriented unoriented
cases  discuss together 
table   compares performance packers oriented equal perimeter benchmark table   compares packers using unoriented double perimeter
benchmark  first column refers problem size instance  number
  

fihuang   korf

size
n

boxes
tested

hk  
time

optdom
time

brfactor
time

c     
time

hk  
time

  
  
  
  
  
  
  
  
  
  
  

 
 
  
 
 
  
  
  
 
  
  

   
   
   
   
    
       
       
          
          

   
   
   
   
    
     
       
       
        

   
   
   
   
   
    
     
       
       

   
   
   
   
   
   
    
     
     
        

   
   
   
   
   
   
    
    
     
       
          

table    cpu times required various packers oriented equal perimeter rectangle
benchmark  task pack oriented rectangles sizes   n      n         
 n       n   

size
n

boxes
tested

hk  
time

optdom
time

brfactor
time

c     
time

hk  
time

  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  

   
   
    
     
       
          

   
   
   
    
     
       
          

   
   
   
    
     
       
          

   
   
   
    
    
       
       

   
   
   
    
    
       
       
          

table    cpu times required various packers unoriented double perimeter rectangle benchmark  task pack unoriented rectangles sizes     n    
    n           n     n       n n  

  

fioptimal rectangle packing  absolute placement approach

rectangles  second column gives number bounding boxes tested order
find optimal solutions  remaining columns represent cpu times different
versions packer format days  hours  minutes  seconds  wrote
packer c   collected data linux     ghz intel core   duo e     machine 
left right  successive packer improves previous one including
additional technique  column called hk   data collected using techniques
developed specifically consecutive square packing  include perfect packing
transformation related inference rules  dynamic variable ordering single
x coordinates x intervals  wasted space pruning rule x coordinates
 huang   korf         compare new variable ordering rectangles
various aspect ratios  used order decreasing area default hk   
optdom improves upon hk   dynamically detecting dominance rules apply
inapplicable  optimizes x interval assignments knowledge  brfactor
improves upon optdom orders oriented equal perimeter benchmark decreasing width unoriented double perimeter benchmark decreasing area  c     
improves upon brfactor use interval size      instead c     
consecutive square benchmark  finally  hk   improves upon c      using
knowledge branching factor rebalance sizes interval assignments
x coordinates 
notice optdom  brfactor  c      introduce techniques reduce
branching factor  greater effect performance hk    whose
new technique seeks make intervals assigned equally constraining  experiments
reveal techniques interact one another  note without including
dominated positions intervals  performance gained techniques
appears muted  interaction tune global interval parameter c
including techniques affect branching factor 
ordering branching factor improved performance oriented equal perimeter
benchmark unoriented benchmark  latter case  seen table   
technique ordering branching factor prescribes ordering decreasing area 
gave packer reasonable default  therefore  difference
algorithm performance optdom brfactor columns table   
note unoriented double perimeter benchmark requires packer try
twice many bounding boxes given parameter n required oriented benchmark  due  n    largest dimension unoriented
benchmark n largest dimension oriented benchmark  larger
rectangles introduce higher precision problem  must try bounding
boxes  containment problem unoriented instance problem space
factor  n larger oriented instance due two orientations
rectangle  thus  instance n rectangles benchmark incomparable
instance n squares consecutive square benchmark evaluating benchmark
difficulty 
summary  using techniques together  solve n     oriented
equal perimeter benchmark     times faster n     unoriented doubleperimeter benchmark    times faster techniques presented optimized
consecutive squares 
  

fihuang   korf

size

boxes tested

cpu time

n

squares

perimeter

squares

perimeter

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

 
 
  
  
  
 
  
  

   
   
   
   
   
   
   
   
   
    
    
     
       
       
          
          
           

   
   
   
    
    
     
       
          

table    number bounding boxes tested cpu time required solve given instance
consecutive square oriented equal perimeter benchmarks 

  

fioptimal rectangle packing  absolute placement approach

    comparing easy hard benchmarks
following tables compare difficulty various benchmarks using packer  huang
  korf        optimizations enabled 
      consecutive squares vs  equal perimeter rectangles
table    first column indicates number rectangles instance  second
third columns labeled boxes tested give number bounding boxes
tested finding optimal solutions consecutive square benchmark
oriented equal perimeter benchmark  respectively  fourth fifth columns give
performance rectangle packer benchmarks well  data point
table collected using linux     ghz intel core   duo e     using one process  one
thread  one core 
notice given instance number rectangles  oriented equalperimeter benchmark significantly harder consecutive square benchmark 
due fact given problem size  consecutive square benchmark contains
many little squares typically easy place property missing equalperimeter benchmark  fact  n     packer requires four orders magnitude
time find optimal solutions new benchmark compared instance
number items consecutive square benchmark 
      unoriented consecutive rectangles vs  unoriented double perimeter
rectangles
table   shows removing certain properties results successively difficult benchmarks  start unoriented consecutive rectangle benchmark  korf et al        
contains many easy properties  doubly scaled column pack          
           n    n     rectangles  simply scales unoriented consecutive rectangle benchmark factor two  benchmark difficult integers
higher magnitude lead x coordinates search  turn increases branching factor problem  unique dimensions column pack rectangles
sizes                       n      n    differs previous benchmark
dimensions unique  last column distributes area among rectangles
uniformly avoid consolidating area first rectangles 
column culmination difficult properties identified
rectangle packing benchmark  call unoriented double perimeter benchmark 
data points table collected using linux     ghz intel core   duo e    
machine without parallelization  except n     n      collected
linux     ghz intel xeon e     machine   gb ram  estimate
thirty percent faster 
    bounding boxes minimum area
section list optimal bounding boxes various benchmarks found
program optimizations enabled  notice duplicate data
  

fihuang   korf

size
n
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

unoriented
consecutiverectangles
   
   
   
   
   
   
   
   
   
   
   
   
     
       
       
          
          
          

doubly
scaled
   
   
   
   
   
   
   
   
   
   
   
    
     
       
          

unique
dimensions
   
   
   
   
   
   
   
   
   
    
     
       
        

unoriented
doubleperimeter
   
   
    
    
       
       
          

table    cpu time required optimized packer various benchmarks increasing
difficulty 

  

fioptimal rectangle packing  absolute placement approach

unoriented high precision rectangle benchmark  leave table     section       
since discussion refers data 
first column tables     refer size problem instance
respective benchmarks  columns called optimal solution give dimensions
optimal bounding boxes given instance  next column called empty space gives
percent empty space optimal solution  next column gives number
bounding boxes tested order find optimal solutions given instance 

   absolute placement high precision instances
meir moser        first proposed problem finding smallest square
contain infinite series rectangles sizes                              etc  rectangles
cannot overlap unoriented  unit square exactly enough area since total
area rectangles infinite series one  hand  space
wasted  suggesting task infeasible  inspired problem  propose last
benchmark developed several new techniques 
introduce unoriented high precision rectangle benchmark  task find
bounding boxes minimum area contain finite set unoriented rectangles
sizes                      n  n       example  n    one must pack rectangles
sizes                                 alternatively  one may try pack rectangles sizes
                                 square  original instance
scaled factor     least common multiple rectangle denominators 
strategy required broad class recent rectangle packers explore domain
integer x  y coordinates rectangles quickly break higher n  
example  optimal solution n         billion unique coordinate pairs
rectangles assigned to  benchmark complements rather replaces
current low precision benchmarks  neglected high precision instances 
remainder section organized follows  first review previous
work proposing solution techniques may unaffected precision rectangle
dimensions  describe several adaptations low precision techniques
high precision case  along new techniques developed specifically high precision
rectangle instances  finally follow experimental results 
    previous work
relative placement approach moffitt pollack        rectangle packing 
similar types search spaces used resource constrained scheduling  weglarz        
promises immune problem high precision rectangle instances  however  since
many techniques described previous sections cannot
extended packer working relative placement search space  decided
stay within absolute placement framework attempt mitigate problems
introduced high precision numbers 
  

fihuang   korf

consecutive squares

consecutive rectangles

size
n

optimal
solutions

empty
space

boxes
tested

optimal
solutions

empty
space

boxes
tested

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
   
   
         
    
    
    
    
    
    
    
    
          
    
    
    
    
    
    
    
    
     
    

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
  
 
  
  
  
  
  
  
  
  
  

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

  
  
  
  
  
  

           
     
     
     
     
     

     
     
     
     
     
     

  
  
  
  
  
  

  
  
  
       
   
   
    
    
          
    
    
    
    
          
    
    
    
    
          
                
    
    
            
                  
                 
                    
                 
     
            
     

     
     
     

 
 
 

table    optimal solutions consecutive square benchmark  task
pack squares sizes              n n   unoriented consecutive rectangle
benchmark  task pack unoriented rectangles sizes               
n  n      

  

fioptimal rectangle packing  absolute placement approach

oriented equal perimeter

unoriented double perimeter

size
n

optimal
solutions

empty
space

boxes
tested

optimal
solutions

empty
space

boxes
tested

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  

  
  
  
  
  
   
   
   
    
    
    
    
    
          
    
    

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

 
 
 
 
 
 
  
 
  
 
  
  
  
  
  
  

  
  
  
  
  
  
  

    
    
          
    
    
    
    

     
     
     
     
     
     
     

 
  
  
  
 
  
  

  
  
  
  
   
   
    
    
    
    
    
    
    
           
    
           
          
          
    

     
     

  
  

table    optimal solutions oriented equal perimeter rectangle benchmark 
task pack oriented rectangles sizes   n      n           n      
n    unoriented double perimeter rectangle benchmark  task
pack unoriented rectangles sizes     n         n           n     n      
n n 

  

fihuang   korf

 a 

 b 

figure    examples mapping solutions one rectangles left most 
bottom most positions 

    overall strategy
given instance high precision benchmark described rational numbers 
multiply values least common multiple denominators get instance
integer dimensions  apply absolute placement solution techniques 
improvements subsequently explain  order find optimal solutions 
found  divide x  y coordinates describing optimal solutions initial
scaling constant order obtain optimal solutions original problem 
note map every solution one rectangles slid
left bottom much possible  chazelle         example  solution
figure  a transformed figure  b  since rectangles propped
left rectangles  rectangles x coordinate sum
subset widths rectangles rectangles y coordinate
sum subset heights rectangles  similarly  width height
bounding box must sum subset widths heights rectangles 
respectively 
following subsections first explain techniques respect oriented
instances  follow handle unoriented case 
    minimum bounding box problem
since build initial set bounding boxes pairwise combinations widths
heights within given ranges  space pruned considering bounding box
widths heights equal subset sums rectangle widths  subset sums
rectangle heights  respectively  recall section     every bounding box
width  compute lower bound height  modify rounding
resulting bound next subset sum rectangle heights 
  

fioptimal rectangle packing  absolute placement approach

      precomputing subset sums
compute set subset sums prior searching  oriented rectangles
cannot rotated compute two sets  one based heights rectangles
representing candidate y coordinates  one based widths representing
candidate x coordinates  distinction generates fewer subset sums compared
single set subset sums generated widths heights 
      pruning combinations widths heights
reject bounding boxes certain width height combinations
infeasible  pruning technique relies observation certain cases  may
one unique set rectangles generate specific width  height  bounding
box 
example  consider bounding box width generated unique
set rectangles  assume heights set rectangles uniquely
determine subset sum specific bounding box height  say combination
bounding box width height incompatible  reason set rectangles
way bounding box given width  implies set
rectangles must appear solution laid horizontally one another  thus 
set rectangles cannot appear stacked vertically solution  contradicts
implications bounding box given height  note particular example 
compatible height maximum height rectangles 
      learning infeasible attempts
recall algorithm solving minimal bounding box problem repeatedly calls
algorithm solve containment problem  bounding boxes tested order
non decreasing area first boxes solutions found  learn
infeasible attempts 
example  consider pack n rectangles  r    r         rn    note use
pre computed variable order rectangles  let rd     n rectangle corresponding
deepest search tree depth first search able go  entire
search effort given bounding box  containmnet solver says bounding box
infeasible  next bounding box height consider next
greatest subset sum based smaller set  r    r         rd     instead considering n
rectangles  intuition behind since containment solver failed even
find arrangement first     rectangles  doesnt make sense involve
remaining rectangles  rd        rn   next largest subset sum bounding box
height 
method resembles conflict directed backtracking  implementation 
consider effect pruning using wasted space heuristic well 
    containment problem
similar low precision methods  first assign x coordinates rectangles 
conduct perfect packing transformation  finally work y coordinates  huang
  

fihuang   korf

  korf         main difference high precision methods lowprecision methods instead considering possible integers domain
x  y coordinates  consider smaller set subset sums widths heights
rectangles  methods using x intervals remain unchanged
describe search individual x coordinates here 
      assigning x coordinates
oriented rectangles  choose x coordinates set subset sums rectangle
widths  instead precomputing set minimal bounding box problem 
generate dynamically every node search prior branching
various x coordinate value assignments  set computed follows 
   initialize set value    represents placing rectangle
left side bounding box 
   every rectangle r already assigned x coordinate point search 
insert set sum x coordinate width  represents placing
rectangle right side r 
   every rectangle x coordinate still unassigned  add width every
element set  insert new sums back set 
      perfect packing transformation
assigning x coordinates  create number     rectangles account
empty space original instance  transformation results new instance 
empty space  consists original rectangles plus new     rectangles 
given empty corner partial solution  ask original unplaced rectangles
might fit there      rectangle  essentially modeling empty corners variables
rectangles values 
high precision benchmark  solving n     requires creating     billion    
rectangles scaled problem large number  packer
simply requires much memory time  avoid problem creating fewer
much larger rectangles account empty space 
widening existing rectangles assume figure  a task pack three
rectangles                      rectangle       bounding
box  assume assigned x coordinates y coordinates  given
x coordinates already assigned  resulting packing solution space right
      rectangle must always empty  thus  replace       rectangle
      rectangle  effectively widening original rectangle  likewise  replace
      rectangle       rectangle        rectangle       rectangle 
figure  b  packer greedily attempts widen rectangles towards right
widening towards left  solving problem return
rectangles back original widths  avoids creating many     rectangles
perfect packing transformation represent empty space 
  

fioptimal rectangle packing  absolute placement approach

 a  partial solution xcoordinates known 

 b  result widening rectangles 

figure    widening existing rectangles 

 b  solution without      rectangles empty space 

 a  partial solution xcoordinates known 

figure    consolidating empty space horizontal strips 

turning empty space large rectangles partial solution figure  a 
assigned x coordinates rectangles       bounding box  instead
creating three hundred     rectangles represent empty space indicated
single hash marks  use ten      rectangles without losing packing solutions 
similarly  represent doubly hashed empty space twenty     rectangles instead
six hundred     rectangles  note cannot use      rectangles empty
space since would inadvertently prune potential solution figure  b 
      assigning y coordinates
perfect packing transformation  assign y coordinates asking rectangle
placed given empty corner  before  enforce constraint ycoordinate rectangle must subset sum rectangle heights  note
rectangles create via perfect packing transformation included subset
sum calculations  since represent empty space 
      handling unoriented instances
unoriented instances  computing initial bounding box widths heights 
generate single set subset sums using widths heights rectangles
instance instead keeping widths separated heights  likewise 
generating set candidate x  y coordinates  must add fourth step
  

fihuang   korf

size
n

optimal
solution

lcm

bits
precision

hk  
boxes

subsets
boxes

mutex
boxes

hk  
boxes

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  

    
      
        
            
        
         
         
         
         
           
            
        
         
         
        

 
 
  
  
  
   
   
     
     
      
      
       
       
       
       

 
 
 
  
  
  
  
  
  
  
  
  
  
  
  

 
 
 
  
  
     
     
      
      
         

 
 
 
 
 
  
   
   
     
     
      
      
       
       
         

 
 
 
 
 
  
   
   
   
     
      
      
       
       
       

 
 
 
 
 
  
  
   
   
   
     
     
     
     
      

table     minimum area bounding boxes number bounding boxes tested
packing unoriented rectangles                              n  n      

bulleted list subsection       add height every rectangle
yet placed  every element set subset sums  represents possibility
rotating rectangle 
    experimental results
present two different data tables  one relating improvements minimal bounding
box problem measured number bounding boxes tested  another one
overall cpu time solving entire rectangle packing problem  separate
experiments way solution schema decouples minimal bounding box
problem containment problem 
      minimum bounding box problem
table    shows optimal solutions unoriented high precision rectangle benchmark
along various properties corresponding instances  first two columns give
problem size dimensions optimal solutions  respectively  third gives
least common multiple first n    integers  fourth number bits required
represent area minimal bounding box  note one optimal
solutions width      since first rectangle much larger others 
n     larger  required precision exceeds    bit integer 
fifth eighth columns compare number bounding boxes various
packers test find optimal solutions unoriented high precision rectangle bench  

fioptimal rectangle packing  absolute placement approach

size
n
 
 
 
 
  
  
  
  
  
  

hk  
time

empty space
time

dynamic
time

hk  
time

   
   
    
    

   
   
   
   
    
     
       

   
   
   
   
   
   
    
       
          

   
   
   
   
   
   
   
     
     
       

table     cpu times various packers find minimum area bounding boxes containing
unoriented rectangles                              n  n      
mark  column going left right  add one new technique minimal
bounding box problem 
hk   number bounding boxes required simply scaling problem
instance described completely integers  column called subsets improves upon
second testing bounding boxes whose dimensions constrained
subset sums technique  column called mutex improves upon third rejecting
bounding boxes subset sum corresponding width mutually exclusive
subset sum corresponding height  hk   improves upon previous packer using
information learned infeasible attempt reject future bounding boxes 
using improvements  n     test       times fewer bounding boxes compared
previous state of the art  instance hk   ran memory last
bounding box sheer number     rectangles created perfect
packing transformation  introduction prime number    denominator
problem instance responsible increased difficulty n    n     
      containment problem
table    compares performance various packers using techniques 
decoupled minimal bounding box problem containment problem 
table use optimizations minimal bounding box problem 
compare individual techniques applied containment problem  therefore 
performance data reported required solve overall problem using various
containment problem packers 
first column gives size problem instance high precision rectangle
benchmark  previous tables  successive column left right improves upon
previous column additional technique  column called hk   corresponds
using previous state of the art improved minimal bounding box algorithm 
column called empty space improves upon hk   precomputing subset
  

fihuang   korf

sums prior searching x coordinates  uses techniques consolidate empty
space y coordinates  column called dynamic improves upon previous one
dynamically computing subset sums  finally  last column called hk   adds
ability learn unplaced rectangles exclude subset sums computation
exploring infeasible subtree  data collected using linux eight core  ghz
intel xeon x     without parallelization 
n      problem scaled        times dimensions  requiring hk  
create               units empty space perfect packing transformation
causing run memory  empty space could complete n     within
day sheer number subset sums must explored x 
y coordinates  problem avoided dynamic 
      comparison relative placement
interesting note number bounding boxes appears increasing exponentially  mostly likely due exponential growth number subset sums
introduced successive rectangle high precision benchmark  difficulty
unoriented high precision rectangle benchmark compounded fact
precision increases  branching factor single x  y coordinate values
containment problem increases 
contrast absolute placement technique  moffitt pollacks        relative
placement techniques enumerate different exact locations rectangles 
therefore promise immune problem high precision rectangles  used
variable every pair rectangles represent relations above  below  left  right 
search algorithm required least one non overlapping constraints
true every pair rectangles  meta csp approach modeled work
dechter  meiri  pearl        solving binary constraint satisfaction problems 
included various pruning techniques model reduction  symmetry breaking 
graph based pruning heuristics  korf et al          solve minimum bounding box
problem branch and bound algorithm  evaluating size bounding box
non overlapping relationships determined  keeping track bounding
box smallest area seen far 
note contrast  solver tests bounding boxes order non decreasing area 
also  size formulation uses n   variables use n   finally 
packer returns one optimal solution opposed ours  work
returning optimal solutions 
able benchmark code machine order provide
kind comparison methods ours  crude comparison 
cannot run packer unoriented high precision rectangle benchmark since
hard coded packer unoriented consecutive rectangle benchmark  much
easier benchmark shown table   
first column table    refers problem size  second column called mp  
gives cpu time required moffitt pollacks code problem instances
unoriented consecutive rectangle benchmark  uses low precision rectangles  third
column called hk   gives cpu time required packer problem instances
  

fioptimal rectangle packing  absolute placement approach

size
n

mp  
time

hk  
time

  
  
  
  
  
  

   
   
    
     
       
       

   
   
   
     
     
       

table     cpu times required moffitt pollacks packer unoriented consecutiverectangle packer unoriented high precision rectangle benchmarks 

unoriented high precision rectangle benchmark  data point table
collected using eight core  ghz intel xeon x     linux without parallelization  note
algorithm packs number rectangles somewhat faster moffit
pollacks 
    summary high precision rectangles
section proposed new benchmark consisting instances rectangles
high precision dimensions well techniques using subset sums limit number
positions must considered  rules filter subset sums minimal
bounding box containment problems  methods learn infeasible subtrees 
ways reduce number rectangles created perfect packing transformation 
techniques exploit special properties benchmark  useful
rectangles high precision dimensions 
using methods  solved six problems n     new benchmark compared using low precision packer scaled instance  packer
two orders magnitude faster n    previous state of the art  tests
      times fewer bounding boxes  cursory comparison state of the art using
relative placement search space shows perform slightly faster
moffitt pollacks packer  benchmark previously shown section
      significantly difficult unoriented consecutive rectangle benchmark
moffitt pollacks program run on 

   future work
humans solve jigsaw puzzles asking particular piece go  well
asking piece go empty region  packer makes use
models  former x coordinates latter y coordinates  would
interesting see applicable dual formulation packing  layout 
scheduling problems  currently  work x coordinates asking
go   work y coordinates asking goes location 
method reduced time spent y coordinates much time spent
  

fihuang   korf

working x coordinates orders magnitude greater time spent working
y coordinates  suggests performance might improved considering
models simultaneously 
another direction continued work  data indicates number bounding
boxes explored minimum bounding boxes solver main bottleneck solving
larger instances unoriented high precision rectangle benchmark  observation
make across many bounding boxes  partial solutions
explored  resulting much redundant computation  consequently  branch and bound
method starts large bounding box  gradually reduces dimensions
various packings explored would promising avenue research 

   conclusions
presented several new improvements previous state of the art optimal
rectangle packing  within schema assigning x coordinates prior y coordinates 
introduced dynamic variable order x coordinates  constraint adapts
korfs        wasted space pruning heuristic one dimensional case  ycoordinates work perfect packing transformation original problem 
using model assigns rectangles empty corners  inference rules reduce
models variables 
improvements search y coordinates helped us solve n     consecutive square benchmark order magnitude faster previous state ofthe art  improvements search x coordinates gave us another order
magnitude speedup n      compared leaving optimizations out 
techniques     times faster previous state of the art largest
problem solved date  allowing us extend known solutions consecutive square
benchmark n     n      furthermore  data show little time spent
searching y coordinates  suggesting rectangle packing may largely reduced
problem determining x coordinates 
techniques presented pick y coordinates tightly coupled dual
view asking must go empty location  furthermore  searching xcoordinates  pruning rule based analysis irregular regions empty space 
dynamic variable order rests observation less empty space leads
constrained problem  success techniques rectangle packing make
worth exploring many packing  layout  scheduling problems 
introduced two new benchmarks  one oriented one unoriented 
include rectangles various aspect ratios  new benchmarks avoid various properties
easy instances  identified  shown much harder
side by side comparison various benchmarks using state of the art packer 
proposed several search strategies improve performance new benchmarks  improved upon strategies used handle dominance conditions  proposed
variable ordering heuristic based increasing branching factor generalizes previous
strategies  tuned global interval parameter  introduced method balance sizes
intervals assigned x coordinate variables 
  

fioptimal rectangle packing  absolute placement approach

experiments revealed takes orders magnitude time solve new
benchmarks compared instances consecutive square benchmark
number rectangles  therefore advocate inclusion new  difficult
benchmarks suite benchmarks used research optimal rectangle packing  finally  using techniques together  solved n     oriented equal perimeter
benchmark     times faster  n     unoriented double perimeter benchmark    times faster simply using methods tuned consecutive squares 
order test limits rectangle packer  presented new high precision benchmark specifically capturing pathological case successive rectangle
quickly increases precision required represent coordinate locations  presented
various techniques adapt absolute placement approach handle types instances  including dynamically using subset sums limit number coordinate values
must tested  mutex reasoning allows us reject certain combinations subset
sums used bounding boxs width height  general method rejecting future subset sums based previously infeasible search  finally memory efficient adaptation
perfect packing transformation high precision rectangle instances 
solved n     high precision benchmark half minute      times faster
basic version packer augmented high precision version perfect
packing inference rules run memory  first instance
requiring precision exceeding capacity    bit integer  techniques allowed us
solve n     compared n     largest instance low precision techniques
alone could solve  methods reduced number bounding boxes generated
factor        point solving problems require minimum    bits
precision  meet requirements many real world problems 
provided comparison state of the art relative placement packer showing
absolute placement packer remains competitive even rectangles high precision  reported promising avenues research may potentially give absolute
placement approach clear competitive edge relative placement methods 
although mainly focused obtaining optimal solutions benchmarks 
work may easily adapted applications requiring quick suboptimal solutions
simply replacing algorithm minimum bounding box problem alternatives
anytime algorithm described section       
    comparison constraint programming methodologies
clearly tradeoffs taking ground up programming approach c  
taking constraint programming approach  latter provides quick prototyping
reuse constraint libraries researchers already implemented 
forces problem expressed abstract constraint language  abstract
layer turns add unnecessary overhead algorithms data structures
one naturally uses solve problem optimal rectangle packing 
example  previously described  cumulative constraint  simply add
constant consecutive range integer array assign x coordinate
rectangle  backtrack  scan array subtract constant 
scanning manipulating arrays  iteration  fast pushing popping program
  

fihuang   korf

stack recursive algorithms precisely operations modern computer hardware
optimized for  significant explore two trillion search nodes
n     square packing benchmark  fact solver spends    
time array manipulation operations alone  explain
orders magnitude speedup processing x coordinate solutions  d array
instead  d bitmap korf         move  d arrays   d bitmaps 
abstract representations variables values constraint programming  patterns
computation data structures simply become distant underlying
hardware optimized for 
optimal rectangle packing  happens algorithms data structures
naturally solve problem map nicely form function hardware modern
computers  note one may always port code constraint module may
called constraint solver  still computational indirection
module backtracking control logic constraint solver  sacrifice make
approach  however  fact solver tailored specifically rectangle
packing problem defined it  would require implementation effort
reconfigure algorithms heuristics slightly different rectangle packing problem 
hope  however  latter problem ameliorated disciplined object oriented 
modular software design 

   broader lessons
beyond specific problem rectangle packing  broader lessons learn
work  believe several 
one main applications rectangle packing scheduling  described
introduction  rectangle packing problem abstraction scheduling problem
different tasks take different amounts time  require different amounts onedimensional resource must allocated contiguously  memory computer 
width bounding box becomes total time  height total amount
resource available  job becomes rectangle width equal time duration 
height equal amount resource required 
found  however  vast majority time used rectangle packer
assigning x coordinates rectangles  subject cumulative constraint 
every x coordinate bounding box  sum heights rectangles overlap x coordinate cannot exceed height bounding box 
important subpart rectangle packing problem models much general problem
known resource constrained scheduling problem  scheduling
problem described above  without constraint resource allocated contiguously  example  scheduling tasks planetary rover limited power budget 
sum power requirements tasks active given time cannot
exceed total power budget rover  thus  subpart rectangle packer
used tackle general scheduling problem 
another general lesson learned work absolute placement
approach various packing problems two  three  dimensions may effective
even problems high precision dimensions  one might expect absolute placement
  

fioptimal rectangle packing  absolute placement approach

would competitive relative placement approaches problems 
key success area instead considering possible placements 
consider placements correspond subset sums relevant dimensions 
guarantee approach work high precision packing problems 
shown least worth considering  may effective 
perhaps largest lesson learned encouraging discouraging 
problem rectangle packing extremely simple  understood played
game children  yet research last decade described shows
efficient algorithms quite complex  best algorithms simple
problem complex  likely best algorithms complex problems
even complex  discouraging part  encouraging part
history research shown new idea result order magnitude
improvement previous state art larger problems  suggesting
still significant progress made problem  extension others it 

acknowledgments
wish thank reza ahmadi  adnan darwiche  adam meyerson advice
work  thank michael moffitt making packer available  research funded part national science foundation grant number iis         source code optimal rectangle packer open sourced available
http   code google com p rectpack 

references
aggoun  a     beldiceanu  n          extending chip order solve complex scheduling
placement problems  mathematical computer modelling               
beldiceanu  n     carlsson  m          sweep generic pruning technique applied
non overlapping rectangles constraint  cp     proceedings  th international
conference principles practice constraint programming  pp          london  uk  springer verlag 
beldiceanu  n   carlsson  m     poder  e          new filtering cumulative constraint
context non overlapping rectangles  perron  l     trick  m  a   eds   
cpaior  vol       lecture notes computer science  pp        springer 
beldiceanu  n   carlsson  m   poder  e   sadek  r     truchet  c          generic geometrical constraint kernel space time handling polymorphic k dimensional
objects  bessiere  c   ed    cp  vol       lecture notes computer science 
pp          springer 
bhattacharya  s   roy  r     bhattacharya  s          exact depth first algorithm
pallet loading problem  european journal operational research                  
chan  h  h     markov  i  l          practical slicing non slicing block packing without
simulated annealing  glsvlsi     proceedings   th acm great lakes
symposium vlsi  pp          new york  ny  usa  acm 
  

fihuang   korf

chazelle  b          bottomn left bin packing heuristic  efficient implementation 
ieee transactions computers  c                
clautiaux  f   carlier  j     moukrim  a          new exact method twodimensional orthogonal packing problem  european journal operational research 
                  
dechter  r   meiri  i     pearl  j          temporal constraint networks  artificial intelligence                 
dowsland  k  a          exact algorithm pallet loading problem  european
journal operational research               
dowsland  k  a     dowsland  w  b          packing problems  european journal
operational research              
huang  e     korf  r  e          new improvements optimal rectangle packing 
boutilier  c   ed    ijcai  pp         
huang  e     korf  r  e          optimal rectangle packing non square benchmarks 
aaai    proceedings   th national conference artificial intelligence  pp 
        aaai press 
huang  e     korf  r  e          optimal packing high precision rectangles  burgard 
w     roth  d   eds    aaai  aaai press 
korf  r  e          optimal rectangle packing  initial results  giunchiglia  e   muscettola 
n     nau  d  s   eds    icaps  pp          aaai 
korf  r  e          optimal rectangle packing  new results  zilberstein  s   koehler  j  
  koenig  s   eds    icaps  pp          aaai 
korf  r  e   moffitt  m  d     pollack  m  e          optimal rectangle packing  annals
operations research                  
lahrichi  a          scheduling  notions hump  compulsory parts use
cumulative problems  comptes rendus de academie des sciences  paris              
lesh  n   marks  j   mcmahon  a     mitzenmacher  m          exhaustive approaches
 d rectangular perfect packings  information processing letters              
li  s  c   leong  h  w     quek  s  k          new approximation algorithms dynamic storage allocation problems  chwa  k  y     munro  j  i   eds    cocoon 
vol       lecture notes computer science  pp          springer 
lipovetskii  a  i          geometrical approach computation optimal solution
rectangle packing problem  american mathematical society translations      
      
lodi  a   martello  s     monaci  m          two dimensional packing problems  survey 
european journal operational research                  
lodi  a   martello  s     vigo  d          recent advances two dimensional bin packing
problems  discrete applied mathematics                    
martello  s     vigo  d          exact solution two dimensional finite bin packing
problem  management science                 
  

fioptimal rectangle packing  absolute placement approach

meir  a     moser  l          packing squares cubes  journal combinatorial
theory                
mitola  j     maguire  g          cognitive radio  making software radios personal 
ieee personal communications magazine              
moffitt  m  d     pollack  m  e          optimal rectangle packing  meta csp approach 
long  d   smith  s  f   borrajo  d     mccluskey  l   eds    icaps  pp        
aaai 
onodera  h   taniguchi  y     tamaru  k          branch and bound placement building
block layout  dac     proceedings   th acm ieee design automation
conference  pp          new york  ny  usa  acm 
simonis  h     osullivan  b          search strategies rectangle packing  stuckey 
p  j   ed    cp  vol       lecture notes computer science  pp        springer 
simonis  h     osullivan  b          almost square packing  achterberg  t     beck 
j  c   eds    cpaior  vol       lecture notes computer science  pp         
springer 
sweeney  p  e     paternoster  e  r          cutting packing problems  categorized 
application orientated research bibliography  journal operational research
society                 
weglarz  j          project scheduling  recent models  algorithms applications  springer 
kluwer 
yap  r  h  c          constraint processing rina dechter  morgan kaufmann publishers 
      hard cover  isbn                xx       pages  theory pract  log  program  
                

  


