journal of artificial intelligence research                 

submitted        published      

boolean equi propagation for concise and efficient sat
encodings of combinatorial problems
amit metodi
michael codish

amit metodi gmail com
mcodish cs bgu ac il

department of computer science
ben gurion university of the negev  israel

peter j  stuckey

pjs csse unimelb edu au

department of computer science and software engineering
and nicta victoria laboratory
the university of melbourne  australia

abstract
we present an approach to propagation based sat encoding of combinatorial problems  boolean equi propagation  where constraints are modeled as boolean functions which
propagate information about equalities between boolean literals  this information is then
applied to simplify the cnf encoding of the constraints  a key factor is that considering
only a small fragment of a constraint model at one time enables us to apply stronger  and
even complete  reasoning to detect equivalent literals in that fragment  once detected 
equivalences apply to simplify the entire constraint model and facilitate further reasoning
on other fragments  equi propagation in combination with partial evaluation and constraint simplification provide the foundation for a powerful approach to sat based finite
domain constraint solving  we introduce a tool called bee  ben gurion equi propagation
encoder  based on these ideas and demonstrate for a variety of benchmarks that our approach leads to a considerable reduction in the size of cnf encodings and subsequent
speed ups in sat solving times 

   introduction
in recent years  boolean sat solving techniques have improved dramatically  todays sat
solvers are considerably faster and able to manage larger instances than yesterdays  moreover  encoding and modeling techniques are better understood and increasingly innovative 
sat is currently applied to solve a wide variety of hard and practical combinatorial problems  often outperforming dedicated algorithms  the general idea is to encode a  typically 
np  hard problem instance    to a boolean formula     such that the satisfying assignments of  correspond to the solutions of   given such an encoding  a sat solver can be
applied to solve  
tailgating the success of sat technology are a variety of tools which can be applied to
specify and then compile problem instances to corresponding sat instances  the general
objective of such tools is to facilitate the process of providing high level descriptions of how
the  constraint  problem at hand is to be solved  typically  a constraint based modeling
language is introduced and used to model instances  drawing on the analogy to programming languages  given such a description  a compiler can then provide a low level executable
c
    
ai access foundation  all rights reserved 

fimetodi  codish    stuckey

for the underlying machine  namely  in our context  a formula for the underlying sat or
smt solver 
for example  cadoli and schaerf        introduce np spec  a logic based specification
language which allows specifying combinatorial problems in a declarative way  at the core of
this system is a component which translates specifications to cnf formula  similarly sugar
 tamura  taga  kitagawa    banbara        is a sat based constraint solver  to solve
a finite domain constraint satisfaction problem it is first modeled in a constraint language
 also called sugar  and then encoded to a cnf formula and solved using the minisat
solver  een   sorensson         minizinc  nethercote  stuckey  becket  brand  duck   
tack        is a constraint modeling language that is compiled by a variety of solvers to
the low level target language flatzinc for which there exist many solvers  in particular 
flatzinc instances are solved by fzntini  huang        by encoding them to cnf and
in fzn smt by encoding to smt lib  barrett  stump    tinelli        
simplifying cnf formulae prior to the application of sat solving is of the utmost
importance and there are a wide range of techniques that can be applied to achieve this
goal  see for example the work of li         een and biere         heule  jarvisalo  and
biere         and manthey         and the references therein their work  all of these
techniques exhibit a clear trade off between the amount of simplification obtained and the
time it requires  moreover  the stronger techniques become prohibitive when the sat model
involves hundreds of thousands of variables and millions of clauses  so in cnf simplification
tools  time limits on simplification techniques are imposed and or approximations are used 
this paper takes a new approach to cnf simplification  typically  a cnf is not a random collection of clauses  but rather has a structure derived from an application or specific
problem domain  when sat solving is applied to encode and solve finite domain constraint
problems  the original constraint model is a manifest of this structure  usually  the constraints are discarded once encoded to cnf  we advocate that maintaining the constraints
provides important structural information that can be applied to drive the process of cnf
simplification  to be specific  the constraints in a model induce a partitioning of their cnf
encoding to a conjunction of sub formulae which we call portions 
the novelty in our approach to cnf simplification is that instead of considering the cnf
as a whole  we assume that it is partitioned into a conjunction of smaller portions  then
simplification is repeatedly applied to individual portions  this facilitates a propagationbased process because the simplification of one portion propagates information to all of the
portions and this information may trigger further simplification in other portions 
because portions are typically much smaller than the entire cnf we can effectively apply
stronger simplification algorithms  we introduce the notion of equi propagation  similar to
how unit propagation is about inferring unit clauses which can then be applied to simplify
cnf formulae  equi propagation is about inferring equational consequences between literals
 and boolean constants  
there is a wide body of research on cnf simplification that can be applied to implement
equi propagation which is sometimes called equivalent literal substitution  for example by
gelder         techniques typically involve binary clause based simplifications using  among
others  hyper binary resolution and binary implication graphs  see for example  the work
of heule et al         and the references therein  the guiding principle in all of these works
   

fiboolean equi propagation

is that techniques must be simple and efficient because of the prohibitive size of the cnf
to which they must apply 
our approach is different and we focus on far richer forms of inference not even related
to the cnf structure of a formula  at one extreme we apply complete equi propagation
which detects all equivalences implied by a formula  clearly complete equi propagation is
np hard  however  complete equi propagators are feasible as we apply them only to small
portions of the formula  when complete equi propagation is too slow we consider ad hoc
techniques  all of these forms of equi propagation have in common that they are not driven
by the cnf structure  e g  binary clauses  but rather by the underlying constraint structure
from which a cnf was  or is being  generated 
the rest of this paper is structured as follows  section   introduces a modeling language
for finite domain constraints which consists of just   constraint constructs and is sufficient
to illustrate the contribution of the paper  we argue that the constraints in a model induce
a natural partition of their cnf encoding to smaller portions and that this partition can be
used to drive the simplification of the cnf encoding  section   presents equi propagation
which is the first ingredient for our contribution  equi propagation is about learning information that will apply to simplify cnf encodings  section   describes a practical basis for
implementing equi propagation  section   introduces the second ingredient  partial evaluation  given the information derived using equi propagation  partial evaluation applies
to simplify the constraints and in particular to remove boolean variables from their cnf
encodings  section   describes a tool  called bee  metodi   codish         ben gurion
equi propagation encoder  that is based on equi propagation and partial evaluation  we
introduce here our full constraint language which is similar to sugar and to the subset
of flatzinc relevant for finite domain constraint problems  we also spell out the special
treatment of the all different constraint in bee  section   demonstrates the application of
bee  section   presents an experimental evaluation  and finally section   presents our
conclusion 
this paper extends earlier work presented by metodi  codish  lagoon  and stuckey
        which first introduced equi propagation  and also the bee tool paper  metodi  
codish         the bee tool is available for download  metodi        

   constraint based boolean modeling
this section provides the basis for our contribution  a constraint based modeling language 
together with a boolean interpretation for each constraint in the language  this enables us
to view a constraint model as a conjunction of boolean formulae and provides a structure
which drives the subsequent encoding to cnf 
we first introduce a simple and small fragment of a typical finite domain constraint based
modeling language  this serves to illustrate our approach  later  in section    we show
the full language  we then discuss several options for boolean representation of integers 
in this paper we adopt a particular unary representation  called the order encoding  our
contribution is independent of this choice  although equi propagation works well with it 
finally we finish the section so that each of the constraints in the language fragment can
be viewed as a boolean formula  and a constraint model as their conjunction 
   

fimetodi  codish    stuckey

   
   
   
   
   

new int i  c    c   
int neq i    i   
alldiff  i            in   
int plus i    i    i 
int array plus  i            in    i 

   c   i  c 
i     i 
v
i j ii    ij
i    i    i
i         in   i

figure    a core constraint language
    constraint language fragment
we focus on a small fragment of a typical constraint modeling language detailed in figure   
this serves to present the main ideas of the paper  constraint     is about declaring finite
domain integer variables in the range  c     c     for simplicity in the presentation we will
further assume that c      constraints      are about difference of integer variables 
and constraints      are about sums of integer variables  as syntactic sugar we also allow
writing integer constants in constraints  for example  int neq i     which is short for
new int i           int neq i  i    
    modeling kakuro  an example
a kakuro puzzle is an n  m board of black and white cells  the black cells contain hints
and the white cells are to be filled by numbers between   and    the bound   is often
generalized by a larger value r   the hints specify constraints on the sums of the values in
blocks of white cells to the right and or below the hint  the numbers assigned to the white
cells in such a block are required to be all different  figure   illustrates a      kakuro
puzzle  left  and its solution  right  
to model a kakuro puzzle we view it as a set of blocks  of white cells  where each block
b is a set of integer variables and is associated with a corresponding integer value  hint b  
each block b is associated with two constraints  the integers in b must sum to hint b 
and must be all different  figure   illustrates the constraints corresponding to the kakuro
instance in figure   
    representing integers
a fundamental design choice when encoding finite domain constraints concerns the representation of integer variables  gavanelli        surveys several of the possible choices  the

figure    a      kakuro puzzle  right  and its solution  left  
   

fiboolean equi propagation

new
new
new
new
new
new
new

int i         
int i         
int i         
int i         
int i         
int i         
int i         

int
int
int
int
int
int

array
array
array
array
array
array

plus  i    i        
plus  i    i       
plus  i    i    i        
plus  i    i    i        
plus  i    i       
plus  i    i       

alldiff  i    i    
alldiff  i    i    
alldiff  i    i    i    
alldiff  i    i    i    
alldiff  i    i    
alldiff  i    i    

figure    constraints for the kakuro instance of figure   

direct   support  and log  encodings  and introduces the log support encoding  given a choice
of representation constraints are bit blasted and interpreted as boolean formulae  we focus
for now on the use a unary representation  the so called  order encoding  see  e g  crawford
  baker        bailleux   boufkhad        which has many nice properties when applied
to small finite domains 
in the order encoding  an integer variable x in the domain             n  is represented by
a bit vector x    x            xn    each bit xi is interpreted as x  i so in particular the bit
sequence x constitutes a monotonic non increasing boolean sequence  for example  the
value   in the interval        is represented in   bits as                 
an important property of a boolean representation for finite domain integers is the
ability to represent changes in the set of values a variable can take  it is well known
that the order encoding facilitates the propagation of bounds  consider an integer variable
x    x            xn   with values in the interval     n   to restrict x to take values in the range
 a  b   for    a  b  n   it is sufficient to assign xa     and xb        if b   n   the
variables xa  and xb  for    a    a and b   b   n are then determined true and false 
respectively  by unit propagation  for example  given x    x            x     assigning x      and
x      propagates to give x             x    x                 signifying that dom x              
we observe an additional property of the order encoding for x    x            xn    its ability
to specify that a variable cannot take a specific value    v  n in its domain by equating
two variables  xv   xv     this indicates that the order encoding is well suited not only to
propagate lower and upper bounds  but also to represent integer variables with an arbitrary 
finite set  domain  for example  given x    x            x     equating x    x  imposes that
x       likewise x    x  and x    x  impose that x      and x       applying
these equalities to x gives  x    x    x    x    x    x    x    x    x    x     note the repeated literals  
signifying that dom x                          
the order encoding has many additional nice features that can be exploited to simplify
constraints and their encodings to cnf  to illustrate one  consider a constraint of the form
a   b     where a and b are integer values in the range between   and   represented in
the order encoding  at the bit level  in the order encoding  we have  a    a            a    and
b    b            b     the constraint is satisfied precisely when b    a            a     instead of
encoding the constraint to cnf  we substitute the bits b            b  by the literals a            a   
and remove the constraint  in section   we formalize this process of discovering equalities
between literals implied by a constraint and using them to simplify cnf encodings 
   

fimetodi  codish    stuckey

    bit blasting
given a constraint model and the decision on how to represent finite domain integer variables
at the bit level  we chose the order encoding   bit blasting is the process of instantiating integer variables by corresponding bit vectors and interpreting constraints as boolean
formulae 
each integer variable  i  declared by a constraint of the form new int i  c    c    where
   c   c  is represented as a bit vector i                  xc               xc     so  we may view a
constraint model as consisting only of boolean variables and each constraint c corresponds
to a boolean formula denoted as   c    the bit blasted version of c  the specific definition
of      is not important  just for illustration  note that one could define
 
  new int i  c    c       
 xi    xi  
c  i c 

where i                  xc               xc    as well as
  int neq i    i       

n
 

 xi xor yi  

i  

where to simplify presentation we assume that i     x            xn   and i     y            yn   are
represented in the same number of bits  the mapping      extends in the natural way to apply
to conjunctions of constraints  so  given a constraint model such as the one in figure   
integer variables are instantiated to unary  order encoding  bit vectors and each constraint
is viewed as a boolean formula  the constraint model takes a boolean representation as
the conjunction of these formulae 

   boolean equi propagation
in this section we present an approach to propagation based sat encoding  boolean equipropagation  which propagates information about equalities between boolean literals  and
constants   we prove that boolean equi propagation is stronger than unit propagation as
it determines at least as many fixed literals as unit propagation  we demonstrate  with an
example  the power of equi propagation and show that it leads to a considerable reduction
in the size of the cnf encoding 
    boolean equi propagation
let b be a set of boolean variables  a literal is a boolean variable b  b or its negation
b  the negation of a literal    denoted    is defined as b if     b and as b if     b 
the boolean constants   and   represent true and false  respectively  the set of literals
is denoted l and l      l          the set of  free  boolean variables that appear in a
boolean formula  is denoted vars    we extend the vars function to sets of formulae in
the natural way 
an assignment  a  is a partial mapping
from boolean
to  constants  often
fi
 fi
   variables
fi
fi
viewed as the following set of literals  b a b       b a b        for a formula
 and b  b  we denote by  b   likewise  b   the formula obtained by substituting all
   

fiboolean equi propagation

occurrences of b  b in  by true  false   this notation extends in the natural way for
sets of literals  we say that a satisfies  if vars    vars a  and  a  evaluates to true 
a boolean satisfiability  sat  problem consists of a boolean formula  and determines if
there exists an assignment which satisfies  
a boolean equality is a constraint        where        l      an equi formula e is a set
of boolean equalities understood as a conjunction  the set of boolean equalities is denoted
leq
    and the set of equi formulae is denoted e 
example    suppose b    x  y  z   then l             x  x  y  y  z  x   an example
assignment is a    x  z   while b    x  y  z  y  is not an assignment  since it includes
 y  y    given the formula    x   y  z  then  x  is the formula     y  z  or
equivalently y  z  the formula  a        y     which is equivalent to true  but a does
not satisfy  since vars      x  y  z     x  z    vars a   an example equi formula for b
is  x      y   z  or equivalently x   y  z  
      equi propagation
is a process of inferring equational consequences from a boolean formula and given equational information  an equi propagator for a formula  is an extensive function    e  e
defined such that for all e  e 
o
n
fi
fi
e    e   e  leq
      e    e
that is  a conjunction of equalities  at least as strong
true by o e  we say
n as e  made
eq fifi
that an equi propagator  is complete if   e    e  l      e    e   we denote
a complete equi propagator for  as    we assume that equi propagators are monotonic 
e   e     e       e     in particular  this follows  by definition  for complete
equi propagators  in section     we discuss several methods to implement complete and
incomplete equi propagators 
example    consider the constraint
c   new int x         new int y         int neq x  y 
and its corresponding boolean representation      c   on the bit representation where
x    x    x    x    x    and y    y    y    y    y   
assume the setting where
e 



y       y       y       y     

 

signifying that y      then    e    e   x    x    indicating that x       this occurs
since   e is equivalent to  x   x      x   x      x   x      x   x   x   x    and
  e    x    x   
the following theorem states that complete equi propagation is at least as powerful as
unit propagation 
   

fimetodi  codish    stuckey

theorem    let  be a complete equi propagator for a boolean formula   then  any
literal that is made true by unit propagation for any clausal representation of  using the
equations in e is also determined true by   e  
proof  let  be a boolean formula  e an equi formula  and let c and ce be any clausal
representations of  and of e respectively  clearly     c and e    ce   let b be a
positive literal determined by unit propagation of c  ce   then by correctness of unit
propagation  c  ce    b  hence    e    b and thus   e     b      the case for a
negative literal b is the same  except that we infer b     
the following example illustrates that equi propagation can be more powerful than unit
propagation 
example    consider     x   x      x   x      x   x   x     the clausal
representation is  x  x    x  x    x  x    x  x  x    and no unit propagation
is possible  since there are no unit clauses  equi propagation  with no additional equational
information  gives         x       x       x       
      boolean unifiers
it is sometimes convenient to view an equi formula e in a generic solved form as a boolean
substitution  e   which is a  most general  unifier for the equations in e  boolean substitutions generalize assignments in that variables can be bound also to literals fi a boolean
 
substitution is an idempotent mapping    b  l    where dom     b  b fi  b     b
is finite  note in particular that idempotence implies that  b     b for every b  b 
note also that  is defined for all b and that its domain  dom    includes those elements
for which
it is non identity 
a boolean substitution    is viewed as the set   
fi

 
b    b  fi b  dom  
 
we
can
apply  to another  substitution     to obtain substifi

tution          b       b   fi b  dom    dom       a unifier for equi formula e
is a substitution  such that     e   for each e  e  a most general unifier for e is a
substitution  such that for any unifier   of e  there exists substitution  where        
example    consider the equi formula e   b    b    b    b    b    b    b    b    b   
   b    b    then a unifier  for e is  b    b    b    b    b    b    b    b    b       b       
note that  e  is the trivially true equi formula  b    b    b    b    b    b    b    b       
          
consider the enumeration l             b    b    b    b           and let  be the total  strict 
order on l    such that       b   b   b   b       we define a canonical most general
unifier unifye for any satisfiable equi formula e where 
fi

 
unifye  b    min    l    fi e    b    
that is  the substitution unifye maps each b to the smallest literal equivalent to b given
e  we can compute unifye in almost linear  amortized  time using a variation of the
union find algorithm  tarjan        
example    for the equi formula e and substitution  from example   we have that
unifye    
   

fiboolean equi propagation

the following proposition provides the foundation for equi propagation based boolean
simplification  it allows us to apply equational information to simplify a given formula  in
particular  if e is an equi formula about literals occurring in  then unifye    is smaller
than  in that it contains fewer variables 
proposition    let  be a boolean formula and e  e be a satisfiable equi formula  then 
a    e  unifye     e 
b    e is satisfiable if and only if unifye    is satisfiable  and
c  if  is a satisfying assignment for unifye    then unifye is a satisfying assignment
for   e 
proof   a  let    unifye and assume that  is a satisfying assignment of e  then we can
view  as a substitution  and as a unifier of e  hence  since  is a most general unifier  there
exists a substitution  such that       clearly  b     b  for all variables b in the range
of   hence   and  agree on all variables in    which implies that            
meaning that            so   is a satisfying assignment of     e if and only
if  is a satisfying assignment of   e   b  the    direction follows from  a  and the
   direction from  c    c  assume  is a satisfying assignment of unifye     clearly
  unifye satisfies  by construction  also   unifye satisfies e since unifye  e  is
trivial  hence   unifye is a satisfying assignment of   e 
      the equi propagation process
the equi propagation process presented now is a central theme in this paper  let   
       n be a partitioning of a boolean formula to n portions  let             n be corresponding equi propagators  and take initial e     satisfiability of  can be determined
as follows 
   so long as possible  select i such that i  e    e and update e   i  e  
   finally  when the equi propagators apply no more  check if unifye    is satisfiable 
   if  is a satisfying assignment for unifye    then unifye  is a satisfying assignment
for  
we typically apply this equi propagation theme to the boolean representation   
       n of a constraint model c   c       cn where i     ci     here we require that
each ci is a small conjunction of constraints  typically  the integer variables referred
to in each ci are also declared in ci  sometimes this requires duplicating the variable
declarations   for an individual constraint c we denote by c  the conjunction of constraints
including c and the declarations for integer variables it refers to  the specifics of these
declarations will be clear from the context 
example    let c be the following constraint model 

new int x         new int y         new int z        
c 
int plus x  y      int plus y  z      int neq y  z 
we have
   



fimetodi  codish    stuckey

   int plus   x  y       int plus x  y      new int x         new int y        
   int plus   y  z       int plus y  z      new int y         new int z        
   int neq   y  z    int neq y  z   new int y         new int z        
as a basis for equi propagation we take            where       int plus   x  y       
      int plus   y  z        and       int neq   y  z     denoting x       x    x     y  
    y    y     and z       z    z    and applying corresponding complete equi propagators and
starting with e     we have 
   e       e      e    x       y       x    y    
   e       e      e    z       y    z    
   e       e      e    y       
at this point equi propagation applies no more  and unifye     x       x       y   
   y       z       z         now  unifye     is a tautology  all of the boolean variables
are determent by equi propagation  
the following theorem clarifies that the order in which equi propagators are applied in
the equi propagation process does not influence the final result 
theorem    the equi propagation process is confluent 
proof  let           n be a boolean formula and             n corresponding equipropagators  let e    ir  ir         i             and e    js  js         j            
be two different applications of the equi propagation process  so by construction  for each
of the given equi propagators  we have a property      i  e      e  and i  e      e   
now assume  in contradiction  that e     e    then w l o g  there exists e  e  where e
not  e   swap the roles of e  and e  if e   e     e    e    let us focus on the first
step in the equi propagation process leading to e  that introduced the equation e  e  not
introduced to e    so  there exists an     s such that e   j   j          j              e 
and e       e  but e   e    but  if e  e    then by the monotonicity of       we have
that      e        e    and hence e       e    in contradiction to the construction
with property     
the following proposition provides an alternative  more efficient to implement  definition
for complete equi propagation 
proposition    let  be a boolean formula and  a complete equi propagator for  
define for e  e 
n
o
fi
fi unify       e
  e    e  e  leq
e
   
then    e      e   that is   implements a complete equi propagator for  
   

fiboolean equi propagation

proof  forthefi first direction     
  by definition  we have that   e   e  we also have
  e   e fi unifye       e
because by proposition   a    e    unifye     so 
  e     e   for the other direction      let e    e   if e  e then the proof
is straightforward  otherwise  let unifye       e and assume in contrary that e     e  
or in other words that   e     e  this means that there exists an assignment  that
satisfies   e but does not satisfy e  by lemma   a    also satisfies unifye     e and in
particular  satisfies unifye     from our assumption that unifye       e we now have
that  satisfies e  contradiction 
computing  is considerably more efficient than  since we can simply examine the
formula  after the application of unifye to determine new boolean equality consequences 
finally we comment  our intention is that the equi propagation process be applied not
only to make a sat instance smaller but also to obtain an easier to solve representation 
however  decreasing the size of the cnf is not the main objective  in fact  often we explicitly
introduce redundancies to improve a sat encoding  for example  consider an if thenelse construct  xite s t f   where propositional variable  s indicates the selector  t
indicates the true branch  f indicates the false branch  and x indicates the result  the
corresponding cnf is   s  t  x    s  t  x    s  f  x    s  f  x    een and sorensson
       propose to add redundant clauses   t  f  x  and  t  f  x   they comment that
this improves the encoding and they observe that redundant clauses are often introduced
to achieve arc consistency in the sat encoding  we show that given a clausal encoding of
some formula   application of equi propagation can only strengthen unit propagation 
theorem    let c be a set of clauses  and suppose c    e where e is an equi formula 
then unit propagation on unifye  c  is at least as strong as unit propagation on c 
proof  unit propagation on c starting from assignment a  repeatedly chooses a clause
c   l   c where  l    l   c   ai and sets ai      ai   l   unit propagation terminates
with ak when no such clauses occur  note that failure is detected when ak contains both
a literal and its negation 
we show that using a order of unit propagation on unifye  c  determined by that which
occurs on c starting from assignment b    unifye  a    we always obtain an assignment
bi where bi  unifye  ai    the proof is by induction on the unit propagation steps in c 
the base case holds by construction 
assume c   l   c where  l    l   c   ai   then by induction bi  unifye  ai   
 unifye  l      l   c   either unifye  l   bi in which case we set bi     bi and the
induction holds  or unifye  l    bi   now since c   l   c we have that  unifye  l      l  
c  unifye  l    unifye  c   hence by unit propagation on unifye  c  and bi we obtain
bi      bi   unifye  l    hence the induction holds 
given that unit propagation reaches a unique fixpoint then any unit propagation order
on unifye  a    will end up with an assignment b where b  bk  unify ak  
    the power of equi propagation
to illustrate the impact of equi propagation we come back to the kakuro example from
section      recall figure     in fact solving such puzzles via sat encodings is quite easy 
with and without equi propagation  so the example should only be viewed as illustrating
   

fimetodi  codish    stuckey

a   

b   

c   

figure    applying complete equi propagation to a kakuro instance using different models

the impact of equi propagation on the size of the encoding  we compare   different models
of the problem  which each give different equi propagation 
we consider  as a baseline for this discussion  the following boolean representation
derived from a constraint model where the declarations which are not specified explicitly
are of the form new int i     h  where h is the smallest hint for a block that includes i or
the number   if that is smaller 
 
 
   
  int neq   ii   ij     
  int array sum   b  hint b    
 i            ik    blocks
 i j k

b  blocks

notice that there is one int neq conjunct for each pair of white cells in the same block 
and one int array sum conjunct for each block  applying the equi propagation process to
  with complete equi propagators determines six integer values as depicted in figure   a  
figure   b  illustrates the impact of applying the equi propagation process where the
equi propagators are for alldiff constraints instead of for the individual int neq constraints  this determines seven integer variables and is formalized taking the following
boolean representation of the constraint model  and introducing an equi propagator for
each conjunct  
 
 
   
  alldiff   b    
  int array sum   b  hint b    
b  blocks

b  blocks

figure   c  illustrates the impact of applying the equi propagation process where the equipropagators are for pairs  each consisting of an alldiff constraint together with its corresponding sum constraint  this form of equi propagation is most powerful  it fixes integer
values for all of the white cells  in this example   we stress that equi propagation reasons
only about equalities between boolean literals and constants  here we take the model as 
 

   
  alldiff   b       int array sum   b  hint b    
b  blocks

to further demonstrate the impact of equi propagation  table   provides data for   
additional instances   categorized as  easy  medium and hard  the first two columns
in the table indicate the instance category and id  from the five columns headed integer
   instances available from http    c ucc ie  hcambaza page  page  page  html  generated by helmut
simonis  

   

fihard

medium

easy

boolean equi propagation

id
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

integer variables
init       bee
init
           
          
           
          
           
          
           
          
           
          
           
          
           
           
           
          
                        
                        
           
          
           
           
                        
           
          
           
           
average compilation time in sec 

boolean variables
 
 
 
    
   
 
         
 
         
 
         
 
         
 
         
 
         
  
         
 
         
   
         
   
         
 
         
  
         
   
         
 
         
  
                 

bee
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
     

table    applying sat based complete equi propagation on kakuro encoding
variables  the first four specify the number of unassigned white cells in the initial stage and
after each of the three complete equi propagation processes described above  from the five
columns headed boolean variables  the first four indicate the corresponding information
regarding the number of boolean variables in the bit representations of the integers  so 
the smaller the number in the table  the more variables have been removed due to equipropagation  in particular  the   model completely solves   of the    instances  the two
columns titled bee show the corresponding information obtained using a weaker form of
equi propagation that is described in section   below  the last row of the table indicates
the average time it takes to perform equi propagation  in seconds  using each of the three
schemes              and the weaker scheme titled bee  we will come back to discuss this
later after detailing how equi propagation is performed  the results in the table indicate
the clear benefit in performing equi propagation based on coarser portions of the model 
    implementing equi propagators
to implement complete equi propagators we need to infer boolean equalities implied by a
given boolean formula    and equi formula  e  based on proposition    it is sufficient to
test for the condition
unifye                
   
we consider three techniques  using a sat solver  using bdds  and using ad hoc rules
applied to the boolean representations of individual constraints 
it is straightforward to implement a complete equi propagator using a sat solver  to
test condition     we consider the formula                  if  is not satisfiable  then
condition     holds  in this way  condition     can be checked for all relevant equations
   

fimetodi  codish    stuckey

involving variables from unifye     and constants       a major obstacle with this satbased approach is that testing for a single equivalence           is at least as hard as testing
for the satisfiability of   in fact testing for unsatisfiability is typically more expensive 
hence the importance of our assumption that  is only a small fragment of the cnf of
interest  in practice sat based equi propagation is surprisingly fast  for illustration  in
the last row of table   the average times for sat based complete equi propagation for the
different models are indicated in the columns         and     it is interesting to observe
that the strongest technique  using     is the fastest  this is because there are fewer  but
larger  conjuncts and hence fewer queries to the sat solver 
we can implement a complete equi propagator using binary decision diagrams  bdds 
as follows  we construct a bdd for formula  at the beginning of equi propagation  when
new equational information e   is added to e we simplify the bdd for  by conjoining
the bdd with a bdd for e   and then projecting out the variables that no longer appear in
unifye     note that this simplification can increase the size of the bdd  in practice 
rather than these two steps  we can use the restrict operation of coudert and madre
        bdd simplify in somenzi        to create the new bdd more efficiently 
given the bdd for unifye     we can explicitly test condition     using a standard
bdd containment test  e g   bddleq in somenzi         just as in the sat based approach  this test is performed for all relevant equations involving variables from unifye   
 and constants       alternately we can use the method of bagnara and schachte       
 extended to extract literal equalities as opposed to just variable equalities  to extract all
the fixed literals and equivalent literal consequences of the bdd 
example     consider the bdd shown in figure   a  which represents the formula 
  new int a         new int b         int neq a  b   figure   b  depicts the the bdd
for unifye    where e    b       b       b         here it is easy to see that equipropagation determines that a    a    let e     e   a    a     then figure   c  shows
the simplified bdd for unifye      
a major obstacle with this bdd based approach concerns the size of the formula
unifye     for some constraints  the corresponding bdd is guaranteed to be polynomial  in the size of the constraint   the following result holds for an arbitrary constraint
  so it also holds for unifye    
proposition    let c be a constraint about k integer variables each represented with n bits
in the order encoding  then  the number of nodes in the bdd representing   c   is bound by
o nk   
proof   sketch  there are only n     legitimate states for each n bit unary variable  and
the bdd cannot have more nodes than possible states 
constraints like new int  int neq  and int plus involve at most   integer variables and
hence their bdd based complete equi propagators are polynomially bounded  however 
this is not the case for global constraints such as alldiff and int array plus where the
arity is not fixed  moreover  it is well known that the alldiff constraint does not have a
polynomial sized bdd  bessiere  katsirelos  narodytska    walsh        
   

fiboolean equi propagation
    
    
a  

 

 
    
    
    
    
b 
b 


 

    
    
         
    
    
r a   rrr a   a 
r
r
 
r r
rr
rrr rrrr
  
r
         
    
    
    
    
    
b  l     
b 
b       
b       
  llb  

  
l
 
l
 
 
 lll
  
 
   l
    
    
    
    
    
 
a   a  l     
a 
      l  ll
    l l   l
    
    
    
    
b  s
s s b      s s   
s s  

    
    
a 
 
   
 

 
 
 

    
    
    
    
a 
a 
 

 

 
  
  
    
    
    
a  
a        
  
    
    
    
  
  

    
    
a 
 
 

t





 



 

 
    
    
a 



t

t

 a  bdd for int nequ  a  b 

 b  simpld wrt b          

 c  simpld wrt a   a 

figure    bdds for  a    new int   a           new int   b           int neq a  b   b 
unifye    where e    b      b      b      and  c  unifye      where e    
e   a   a     full  dashed  lines correspond to true  false  edges  edges to the
false node f are omitted for brevity 

given the potential exponential run time when performing sat based equi propagation 
and the potential exponential size of bdd based equi propagators  we consider a third
approach where we implement equi propagation by a collection of ad hoc transition rules
for each type of constraint  while this approach is not complete  there are equations
implied by a constraint that are not detected  the implementation is fast  and works well
in practice  this is the topic of the next section 

   ad hoc equi propagation
we consider a rule based approach to define equi propagators  the definition is given as a
set of ad hoc rules specified for each type of constraint  the novelty is that the approach
is not based on cnf  as in previous works  but rather driven by the bit blasted constraints
that are to be encoded to cnf  our presentation focuses on the case where finite domain
integers are represented in the order encoding  for an integer x    x            xn    we often
write  x  i to denote the equation xi      x   i to denote the equation xi      x    i to
denote the equation xi   xi     and x   i to denote the pair of equations xi      xi       
moreover  to simplify notation when specifying the rules below  we view x    x            xn   as
a larger vector padded with sentinel cells such that all cells to the left of x  take value  
and all cells to the right of xn take the value    basically this facilitates the specification
of the end cases in our formalism  we now consider each of the   constraints in the
language fragment presented in section   
   

fimetodi  codish    stuckey

c   new int  x            xn       n 
if in e
then add in c  e 
xi     x               xi     
xi     xi                xn    

 a 

c   int neq x  y   where
x    x            xn   and y    y            yn  

if in e
then add in c  e 
x i
y    i
xi   yi     yi   xi  
x    i  y    i
xi   yi     yi   xi  
x    i  y    i
 b 

figure    ad hoc rules for  a  new int and  b  int neq
c   int plus x  y  z  where x    x            xn   
y    y            ym    and z    z            zn m  

c   alldiff  z    z    z            zn   
if in e
then add in c  e 
z    z    i  j 

z   
  z    zk    i
zk  
  j  k     

if in e
x  i  y  j
x   i  y   j
z  k  x   i
z   k  x  i
x i
z k

 a 

then add in c  e 
z i j
z  i j 
y ki
y  ki
zi     y            zi m   ym
x    yk           xk   y 
 b 

figure    ad hoc rules for  a  alldiff and  b  int plus

    the two rules in figure   a  derive from the monotonicity in the order encoding
representation  these basically correspond to unit propagation  but at the constraint level 
    the first rule in figure   b  considers cases when x is a constant  the symmetric
case can be handled by exchanging x and y    the other two rules capture templates
that commonly arise in the equi propagation process  to illustrate the justification of the
third rule consider all possible truth values for the variables xi and xi      a  if xi    
and xi       then both integers in the relation take the form                       violating their
specification as ordered  so this is not possible   b  if xi     and xi       then both
numbers take the form                              and are equal  violating the neq constraint  the
only possible bindings for xi and xi   are those where xi   xi    
    in figure   a  we illustrate a single rule for the alldiff constraint which considers
hall sets of size    here each zi represents an integer in the order encoding and we focus
on the case when z  and z  are restricted by the equations in e to take only two possible
values  i or j  this can be expressed in e because  x            xn     i  j   for i   j  means
that xk     for k   i  xk   xk   for i  k   j  and xk     for j   k  n  z     z  then
means adding the single equation xi   yi  because z  and z  can take only two values  
in addition to this rule  we apply the rules for int neq zi   zj   for each pair of integers zi
and zj in the constraint 
   

fiboolean equi propagation




z              z     
e   
z              z     
x    x            x    x    x            x    
y    y            y    y    y            y    
z                             
e    e    y              y     
x    x            x    x    x            x    
y    y            y                  
z                             
e    e    x              x     
x    x            x                  
y    y            y                  
z                             

x   y   
y   x 


int neq

z    x 


int plus

z    y  


int plus

z  


int plus

e    e    y     
x    x            x    x    x            x    
y    y            y       y            y    
z                             

e    e    x     
x    x            x       x            x    
y    y            y                  
z                             

e    e    x   y            x   y   
x    x    x    x    x                  
y    x    x    x    x                  
z                             

y    


new int

x   

 
new int



e    e    x   x   
x    x    x    x    x                  
y    x    x    x    x                  
z                             

figure    ad hoc equi propagation described in example   
    the first four rules of figure   b  capture the standard propagation behavior for
interval arithmetics  the last two rules apply when one of the integers in the relation is a
constant  there are symmetric cases when replacing the role of x and y  
    there are no special ad hoc rules for equi propagation of an int array plus constraint  these are simply viewed as a decomposition to a set of int plus constraints  then
simplification is performed at that level using the rules for int plus  the decomposition
of int array plus is explained in section   
example     ad hoc equi propagation   consider the following  partial  constraint model 
from the context of the kakuro example of section      where we represent variables x  y
and z as x    x            x     y    y            y    and z    z            z     and assume some previous equi propagation  on other constraints  has determined the current equi formula e  to
specify that integer variable z     

c 

new int x         new int y         new int z         
int plus x  y  z   int neq x  y 



figure   illustrates  step by step  the equi propagation process on c using the ad hoc rules
defined above  each step corresponds to the application of one of the above defined ad hoc
equi propagation rules as indicated by the label on the transition  at each stage we illustrate
the derived equations  top part  and their application  as a unifier  to the state variables
x  y and z  lower part  
   

fimetodi  codish    stuckey

c   ordered  x            xn     new int 
if
then replace with
n 
true
x     
ordered     x          xn   
xn    
ordered  x            xn       
          xn   

xi   xi   ordered  x            xi   
xi  
figure    simplification rules for new int  crossed out elements have been removed  
to summarize  let us come back to table    the numbers presented in the two columns
headed bee specify the number of variables remaining after application of ad hoc equipropagation  we also observe that our definition of ad hoc equi propagation is trivially
monotonic 

   constraint model partial evaluation
partial evaluation  together with equi propagation  is the second important component in
our approach to compile constraint models to cnf  partial evaluation is about simplifying a given constraint model in view of information that becomes available due to equipropagation  typically  in the constraint simplification process  we apply alternating steps
of equi propagation and partial evaluation  examples of partial evaluation include constant
elimination and removing constraints which are tautologies  in this section we detail the
partial evaluation rules that apply for the five constraint types defined in the language
fragment presented in section   
    a new int i  c    c    constraint specifies that an integer i    x            xn   is represented
in the order encoding and in particular that the corresponding bit sequence is sorted  not
increasing   we denote this as ordered  x            xn     partial evaluation focuses on this
aspect of the constraint and ignores the bounds c    c  specified in the constraint  the table
in figure   specifies four simplification rules that apply  the first rule identifies tautologies 
the second and third rules remove leading ones and trailing zeros  and the fourth removes
 one of two  equated bits  in this figure  and in the subsequent  a crossed out element in a
sequence  indicates that it has been removed from the sequence 
    the simplification rules for a int neq constraint shown in figure    a  are symmetric
when exchanging the role of x and y   the first two rules identify tautologies  the third
rule is about x and y which have an equal bit at position i  the corresponding bits can
be removed from the representation of x and y   resulting in a shorter list of bits in their
representations  the last two rules are about removing leading ones and trailing zeroes and
are illustrated by the following example 
example     figure    b  shows two steps of partial evaluation  for a int neq constraint 
first removing leading ones  then removing trailing zeroes 

   

fiboolean equi propagation

c   int neq x  y   where
x    x            xn   and y    y            yn  
if
then replace with
x   i  y    i
true
xi   yi
true
int neq 
x
 x            
xi   yi
i           xn   
yi           yn   
 y            
int neq     xi             xn   
xi 
 yi   yi             yn   
int neq  x            xi      
xi
 y            yi   yi     




int neq 
  x            x               p e

int neq
          y            y    


int neq 
  x    x               p e

int neq
    y            y    


int neq 
  x    x        
    y    y    

 a 

 b 

figure      a  simplification rules for int neq and  b  an example of their application 
c   alldiff  z            zn    where
zi    zi             zi m       i  n 
if
then replace with
n 
true
   dom z     
alldiff  z            zn   
dom zk     
k    
 
dom zi       
alldiff  z            zn   
i     

 
k

zk    i

alldiff 
 z              
z  i  
          z  m  
   
 zn             
zn i  
          zn m   

figure     simplification rules for alldiff

    four rules for simplifying alldiff constraints are illustrated in figure     the first 
is about detecting tautologies  the second  identifies cases when one of the integers in the
constraint  assume z    has a domain disjoint from all of the others  this rule also captures
the case when z  is a constant  the third rule removes a hall set of size    assume  z    z    
from the constraint  note that the corresponding equi propagation rule detects that the
values of z            zn are different from the values of  z    z    and then the next fourth rule
applies  the fourth rule is for the case when none of the integers in the constraint can take
a certain value i  this rule also captures the case when all of the numbers have leading
ones or trailing zeroes  the last two rules are illustrated in example    
        the simplification rules shown in figure    are symmetric when exchanging the
role of x and y   the first two apply where  at least  one of x  y and z is a constant 
because we have already applied equi propagation to the constraint  it is a tautology  see
example     the last two rules apply to remove leading ones and trailing zeroes  the
   

fimetodi  codish    stuckey

c   int plus x  y  z  where x    x            xn   
y    y            ym    and z    z            zn m  
if
then replace with
x i
true
z k
true
int plus  xi             xn    y 
x  i  z  i
 zi             zn m   
int plus  x            xi    y 
x  i  z  i   m
 z            zi m   

figure     simplification rules for int plus 
 a  int plus i    i    k 
 b  alldiff  i    i    i    i    i    i    i    i    
 c  int array plus  i    i    i    i     k 
figure     constraint model for examples     
simplification rules of an int array plus constraint are straightforward generalizations of
the ones for int plus  see example    
to summarise the rule based approach to apply equi propagation and partial evaluation
we present the following sequence of three examples which focus on the simplification of the
three constraints given as figure    where the integer variables i            i  are defined in the
range between   and   and where k      
example     consider equi propagation of constraint  a  from figure    where e  specifies
that k      




k              k     
k        k      
i        i              i      
i        i              i      
k                          
   z  



  

 i                i       

i                i       


i     i      i     i   
i                       i      i      
i                       i      i      
k                          
   z  
e    e  

e   

k   


int plus

  

given e    the constraint is a tautology and removed by partial evaluation 



int plus 

p e

 
                   i      i      

int plus
                   i      i          



example     consider equi propagation of constraint  b  from figure    given e  from
example    
e 
i                       i      i      
i                       i      i     

i     i     
i     i   


int neq

   

e    e    i     i     
i                       i      i      
i                       i      i     

fiboolean equi propagation

given e    the equi propagation rule for alldiff detects that  i    i    is a hall set  where
the two variables take values   and     and adds to e  the set of equations  e     that specify
that i    i    i    i    i    i           the result is e    e   e   and the result of this step gives
the following bindings  where the impact of e   is underlined  
i 
i 
i 
i 

                     i      i     
                     i      i     
      i      i      i      i      i      i        
      i      i      i      i      i      i        

i 
i 
i 
i 

      i      i      i      i      i      i        
      i      i      i      i      i      i        
      i      i      i      i      i      i        
      i      i      i      i      i      i        

given e    partial evaluation of the constraint first removes the hall set 
p e

 alldiff  i    i    i    i    i    i    i    i        alldiff  i    i    i    i    i    i     
alldiff

and then applies to remove three redundant bits in the underlying representation of each
remaining integer  which is not equal to          











alldiff  
    i      i      i      i      i      i         
    i      i      i      i      i      i         
    i      i      i      i      i      i         
    i      i      i      i      i      i         
    i      i      i      i      i      i         
    i      i      i      i      i      i          









 p e

 alldifferent














alldiff  
 i      i      i      i      i      
 i      i      i      i      i      
 i      i      i      i      i      
 i      i      i      i      i      
 i      i      i      i      i      
 i      i      i      i      i       












example     consider equi propagation of constraint  c  from figure    given e  from
example     the rules that apply derive from the decomposition of the int array plus
constraint to it int plus parts  these dictate that i    i    i     
e 
i 
i 
i 
i 

                     i      i      
      i      i      i      i      i      i         
      i      i      i      i      i      i         
      i      i      i      i      i      i        


int array
plus

e 
i 
i 
i 
i 

  e    i        i        i       
                     i      i      
      i      i      i      i               
      i      i      i      i               
      i      i      i      i              

applying partial evaluation simplifies the constraint as follows 







int array plus  
                   i      i      
    i      i      i      i               
    i      i      i      i               
    i      i      i      i                     







p e
 

 int array
plus








int array plus  
 i      i      
 i      i      i      i      
 i      i      i      i      
 i      i      i      i           








to summarize examples      observe that in the initial constraint model   constraints
about   integers are represented in    bits  after constraint simplification   constraints
remain and the   integers are represented using    bits 
i 
i 
i 
i 

                     i      i     
                     i      i     
      i      i      i      i              
      i      i      i      i              

i 
i 
i 
i 
   

      i      i      i      i              
      i      i      i      i      i      i        
      i      i      i      i      i      i        
      i      i      i      i      i      i        

fimetodi  codish    stuckey

   compiling constraints with bee
bee  ben gurion equi propagation encoder  is a tool which applies to encode finite domain
constraint models to cnf  bee was first introduced by metodi and codish         during
the encoding process  bee performs optimizations based on equi propagation and partial
evaluation to improve the quality of the target cnf  bee is implemented in  swi  prolog
and can be applied in conjunction with the cryptominisat solver  soos        through a
prolog interface  codish  lagoon    stuckey         cryptominisat offers direct support
for xor clauses  and bee takes advantage of this feature  bee can be downloaded  metodi 
      where one can also find the examples from this paper and others 
the source language for the bee compiler is also called bee  it is a constraint modeling
language similar to flatzinc  nethercote et al          but with a focus on a subset of the
language relevant for finite domain constraint problems  five of the constraint constructs
in the bee language are those introduced in section      the full language is presented in
table   
in bee boolean constants true and false are viewed as  integer  values   and   
constraints are represented as  a list of  prolog terms  boolean and integer variables are
represented as prolog variables  which may be instantiated when simplifying constraints 
in table    x and xs  possibly with subscripts  denote a literal  a boolean variable or its
negation  and a vector of literals  i  possibly with subscript  denotes an integer variable 
and c  possibly with subscript  denotes an integer constant  on the right column of the
table are brief explanations regarding the constraints  the table introduces    constraint
templates 
constraints       are about variable declarations  booleans and integers  constraint    
expresses a boolean as an integer value  constraints       are about boolean  and reified
boolean  statements  the special cases of constraint     for bool array or  x            xn   
and bool array xor  x            xn    facilitate the specification of clauses and of xor clauses
 supported directly in the cryptominisat solver by soos         constraint     specifies
that sorting a bit pair  x    x     decreasing order  results in the pair  x    x     this is a basic
building block for the construction of sorting networks  batcher        used to encode cardinality  linear boolean  constraints during compilation as described by asn  nieuwenhuis 
oliveras  and rodrguez carbonell        and by codish and zazon ivry         constraints        are about integer relations and operations  constraints         are about
linear  boolean  pseudo boolean  and integer  operations  constraints         are about
lexical orderings of boolean and integer arrays 
a main design choice of bee is that all integer variables are represented in the orderencoding  so  bee is suitable for problems in which the integer variables take small or
medium sized values  the compilation of a constraint model to a cnf using bee goes
through three phases 
   unary bit blasting  integer variables  and constants  are represented as bit vectors in
the order encoding 
   constraint simplification  three types of actions are applied  equi propagation  partial
evaluation  and decomposition of constraints  simplification is applied repeatedly until
no rule is applicable 
   

fiboolean equi propagation

declaring variables
   
   
   

declare boolean x
declare integer i  c   i  c 
 x  i        x  i     

new bool x 
new int i  c    c   
bool int x  i 

op   or  and  xor  iff 

boolean  reified  statements
   
   
   
   
   

bool eq x    x    or bool eq x    x   
bool array op  x            xn   
bool array op reif  x            xn    x 
bool op reif x    x    x 
comparator x    x    x    x   

x    x  or x    x 
x  op x     op xn
x  op x     op xn  x
x  op x   x
sort  x    x        x    x   

integer relations  reified 
rel   leq  geq  eq  lt  gt  neq 
and arithmetic
op   plus  times  div  mod  max  min   op    plus  times  max  min 
   
    
    
    
    
    

int
int
int
int
int
int

rel i    i   
rel reif i    i    x 
array alldiff  i            in   
abs i    i 
op i    i    i 
array op    i            in    i 

i  rel i 
i
v  rel i   x
i j ii    ij
 i      i
i  op i    i
i  op     op  in   i

linear constraints
    
    
    
    
    
    

rel leq  geq  eq  lt  gt 

bool array sum rel  x            xn    i 
bool array pb rel  c            cn     x            xn    i 
bool array sum modk  x            xn    c  i 
int array sum rel  i            in    i 
int array lin rel  c            cn     i            in    i 
int array sum modk  i            in    c  i 

  xi   rel i
  ci  xi   rel i
   xi   mod c    i
  ii   rel i
  ci  ii   rel i
   ii   mod c    i

lexical order
    
    
    
    
    
    

bool arrays lex xs    xs   
bool arrays lexlt xs    xs   
bool arrays lex reif xs    xs    x 
bool arrays lexlt reif xs    xs    x 
int arrays lex is    is   
int arrays lexlt is    is   

xs  precedes  leq  xs  in the lex order
xs  precedes  lt  xs  in the lex order
x  xs  precedes  leq  xs  in the lex order
x  xs  precedes  lt  xs  in the lex order
is  precedes  leq  is  in the lex order
is  precedes  lt  is  in the lex order

table    syntax of bee constraints 
   cnf encoding  the best suited encoding technique is applied to the simplified constraints 
bit blasting and equi propagation in bee follow the general descriptions from sections     and      bit blasting is implemented through prolog unification  each declaration of the form new int i  c    c    triggers a unification i                  xc               xc     to
ease presentation we assume that integer variables are represented in a positive interval
starting from   but there is no such limitation in practice as bee also supports negatives
integers   bee applies ad hoc equi propagators as described in section    when an equality
of the form x   l  between a variable and a literal or a constant  is detected  then equipropagation is implemented by unifying x and l  this unification applies to all occurrences
of x and in this sense propagates to other constraints involving x 
decomposition is about replacing complex constraints  for example about arrays  with
simpler constraints  for example about array elements   consider  for instance  the constraint int array plus as  sum   it is decomposed to a list of int plus constraints applying
a straightforward divide and conquer recursive definition  at the base case  if as  a  then
   

fimetodi  codish    stuckey

c   alldiff   z    z    z            zn   
if in e
then add in c  e 
i  dom z   
i
  dom zk    k     

z    i the authors

 i  j   dom zk     
 k     

dom z      i  j 
dom z      i  j 
z     z 
zk    i  zk    j
 k     

figure     simplification rules for alldiff  
the constraint is replaced by a constraint of the form int eq a sum  which equates the bits
of a and sum  or if as    a    a    then it is replaced by int plus a    a    sum   in the general
case as is split into two halves  then constraints are generated to sum these halves  and
then an additional int plus constraint is introduced to sum the two sums 
as another example  consider the int plus a    a    a  constraint  one approach  supported by bee  decomposes the constraint as an odd even merger  from the context of
odd even sorting networks   batcher         here  the sorted sequences of bits a  and a 
are merged to obtain their sum a  this results in a model with o n log n  comparator
constraints  and later in an encoding with o n log n  clauses   another approach  also
supported in bee  does not decompose the constraint but encodes it directly to a cnf of
size o n     as in the context of so called totalizers  bailleux   boufkhad         a hybrid
approach  leaves the choice to bee  depending on the size of the domains of the variables
involved  finally  we note that the user can configure bee to fix the way it compiles this
constraint  and others  
cnf encoding is the last phase in the compilation of a constraint model  each of the
remaining simplified  bit blasted  constraints is encoded directly to a cnf  these encodings
are standard and similar to those applied in various tools  the bee encodings are similar
to those applied in sugar  tamura et al         
    the all different constraint in bee
the all different constraint specifies that a set of integer variables take all different values
from their specified domains  this constraint has received much attention in the literature
 see for example the survey in van hoeve         bee provides special treatment for this
constraint 
in many applications  all different constraints are applied to model the special case when
the constraint is about permutation  namely  when  i            in   are all different but may
take precisely n different values  bee identifies this special case and applies two additional
ad hoc equi propagation rules for this case  the table of figure    illustrates these rules 
we annotate the constraint with a   to emphasize that it has been detected that it is
about permutation  the first rule is about the case when only one integer  assume z    can
take the value i  the second rule is about the case where all variables except two  assume z   
z    cannot take two values  assume i  j  now  because the constraint is about permutation 
   

fiboolean equi propagation

we can determine that z  and z  must take the two values i and j  to illustrate the second
rule consider the following example 
example     consider a constraint alldiff i            i    on   integer variables taking values in the interval         exactly   values  where e  specifies that i    i  and i  cannot take
the values   and    therefore we introduce equations which restrict i  and i  to take the
values   and    and the corresponding ad hoc rule for permutation applies 
e 
i 
i 
i 
i 
i 



 x        x        
x        x       
 


x        x      
   x              x      
   x              x      
         x      x      
         x      x      
         x      x     

dom ik           
k  




alldiff

e 
i 
i 
i 
i 
i 



 x                x        
x                x      
  e  


x     x   
   x                    
   x                    
         x      x      
         x      x      
         x      x     

to facilitate the implementation of ad hoc equi propagation of all different constraints 
bee adopts a dual representation for integer variables occurring in these constraints combining the order encoding and the  so called  direct encoding  this is essentially the
same as the encoding proposed by gent and nightingale         when declaring an integer variable i  the bit blast in the order encoding applies the corresponding unification
i    x            xn    when encountering i in an alldiff constraint  an additional bit blast
introduces i     d            dn   in the direct encoding  and a channeling formula channel i  i   
is introduced 
the direct encoding is a unary representation i     d            dn   where each bit di is true
if and only if i    i  so  exactly one of the bits takes the value true  for example  the value
  in the interval        is represented in   bits as                     in the dual representation
the following channeling formula captures the relation between the two representations of
an integer variable i    x            xn   and i     d            dn   

channel  x            xn     d            dn     

d    x 
 dn   xn




n 
 

 di  xi  xi    

i  

consider an alldiff constraint about m integer variables that can take different values between   and n  during constraint simplification  the alldiff  i            im    constraint
is viewed through its direct encoding as a bit matrix where each row consists of the bits
 di            din   for ii in the direct encoding  the element dij is true iff ii takes the value j 
the j th column specifies which of the ii take the value j and hence  at most one variable
in a column may take the value true  this representation has one main advantage  in the
direct encoding we can decompose alldiff  i            im     to a conjunction of n     constraints  one for each column    j  n  of the form bool array sum leq  d j           dmj       
which is arc consistent  as soon as di j      ii   j  we have di j        ii    j     for all
 
j     j  in contrast
fi in the  order encoding alone the decomposition to o m   constraints
int neq ii   ij   fi i   j
is not arc consistent  we illustrate the advantage of the dual
encoding for the alldiff constraint in section     
   

fimetodi  codish    stuckey

   use module bee compiler   bcompile     
   use module sat solver   sat     
solve instance  solution   encode instance  map  constraints  
bcompile constraints  cnf  
sat cnf  
decode map  solution  

figure     a generic application of bee 

   using bee
a typical bee application has the form depicted as figure    where the predicate solve  
takes a problem instance and provides a solution  the specifics of the application are
in the call to encode   which given the instance generates the constraints that solve
it together with a map relating instance variables with constraint variables  the calls to
bcompile   and sat   compile the constraints to a cnf and solve it applying a sat solver 
if the instance has a solution  the sat solver binds the constraint variables accordingly 
then  the call to decode    using the map  provides a solution in terms of the instance
variables  the definitions of encode   and decode   are application dependent and provided by the user  the predicates bcompile   and sat   are part of the tool and provide
the interface to bee and the underlying sat solver 
    example bee application  magic graph labeling
we illustrate the application of bee using prolog as a modeling language to solve a graph
labeling problem  graph labeling is about finding an assignment of integers to the vertices
and edges of a graph subject to certain conditions  graph labellings were introduced in
the   s and hundreds of papers on a wide variety of related problems have been published
since then  see for example the survey by gallian        with more than      references 
graph labellings have many applications  for instance in radars  x ray crystallography 
coding theory  etc 
we focus here on the vertex magic total labeling  vmtl  problem where one should
find for the graph g    v  e  a labeling that is a one to one map v  e                  v    
 e   with the property that the sum of the labels of a vertex and its incident edges is
a constant k independent of the choice of vertex  a problem instance takes the form
vmtl g  k  specifying the graph g and a constant k  in the context of figure     the
query solve vmtl g  k   solution  poses the question  does there exist a vmtl labeling
for g with magic constant k  it binds solution to indicate such a labeling if one exists 
or to unsat otherwise  figure    illustrates an example problem instance together with
its solution 
figure    illustrates a prolog program that implements the encode   predicate for the
vmtl problem  the call to predicate declareints   introduces the constraints which
declare the integer variables for each vertex and edge in the graph  and generates the
map  the call to predicate sumtok   introduces the constraints that require the sum of
the labels for each vertex with its incident edges to equals k  the auxiliary predicate
   

fiboolean equi propagation

an instance
instance   vmtl g  k  
g    v  e  
v                
e                   
                
k     

the graph
 

 

  
    



a solution


 

v 
 v 

 v 
v 

    
    
    
    

e     
e     
e     
e     


    
     

     
  

figure     a vmtl instance with a solution 
encode vmtl  vs es  k  map constraints  append vs es ves   length ves n  
declareints ves n map constraints cs   
sumtok vs es map k cs  cs   
getvars ves map vars  
cs   int array alldiff vars   
declareints        cs cs  
declareints  id ids  n   id x  map   new int x   n  csh  cst  declareints ids n map csh cst  
sumtok          cs cs  
sumtok  vid vs  es map k  int array plus vars k  csh  cst  findall  x y   member  x y  es   x vid   y vid   esids  
getvars  vid esids  map vars  
sumtok vs es map k csh cst  
getvars          
getvars  id ids  map  var vars   member  id var  map  
getvars ids map vars  

figure     encode   predicate for the vmtl application of bee
the map
         e        v    
         e        v    
         e        v    
         e        v   

the constraints
new int v           new int e           int array plus  v    e    e     k  
new int v           new int e           int array plus  v    e    e     k  
new int v           new int e           int array plus  v    e    e    e     k  
new int v           new int e           int array plus  v    e     k  
new int k           alldiff  v    v    v    v    e    e    e    e    

figure     a vmtl instance with the constraints and map generated by encode   

getvars   receives a list of identifiers  vertices and edges  and extracts the corresponding
list of integer variables from the map 
given the vmtl instance from figure     the call to predicate encode   from figure   
generates the map and the constraints detailed in figure    
   

fimetodi  codish    stuckey

solving the constraints from figure    binds the map as follows  indicating a solution
 in unary order encoding  


   
    
m  
   
   

                          
                          
                          
                          

        
        
        
        



                          
                           
                           
                         

using bee to compile the constraints from figure    generates a cnf which contains    
clauses and    boolean variables  encoding the same set of constraints without applying
simplification rules generates a larger cnf which contains     clauses and    boolean
variables 
in section     we report that using bee enables us to solve interesting instances of the
vmtl problem not previously solvable by other techniques 
    bumblebee
the bee distribution includes also a command line solver  which we call bumblebee 
bumblebee enables one to specify a bee model in an input file where each line contains
a single constraint from the model and the last line specifies the type of goal  bumblebee
reads the input file  compiles the constraint model to cnf  solves the cnf using the
embedded cryptominisat solver  soos        and outputs a set of bindings to the declared
variables in the model  or a message indicating that the constraints are not satisfiable  
figure    contains on the left the bumblebee input file for the vmtl instance from
figure    and on the right the bumblebee output  which is a solution for the constraint
model  in the example  the last line of the input file specifies the goal to the solver  the
options are 
   solve satisfy  solve for a single satisfying assignment to the constraint model 
   solve satisfy c   solve for  at most  c satisfying assignments to the constraint model
where c is an integer value  when c    this option will solve for all solutions 
   solve minimize i   solve for a solution which minimizes the value of the integer
variable i  the solver outputs the intermediate solutions  with decreasing values of
i  encountered during the search for the minimum value of i 
   solve maximize i   similar to minimize  but maximizes 
further details and more examples can be found in the bee distribution  metodi   codish 
      

   experiments
we report on our experience in applying bee  to appreciate the ease in its use the reader
is encouraged to view the example encodings available with the tool  metodi   codish 
       all experiments run on an intel core   duo e         ghz cpu with  gb memory
under linux  ubuntu lucid  kernel           generic   bee is written in prolog and run
   

fiboolean equi propagation

content of bumblebee input file
new int v        
new int v        
new int v        
new int v        
new int e        
new int e        
new int e        
new int e        
int array plus  v   e   e       
int array plus  v   e   e       
int array plus  v   e   e   e       
int array plus  v   e       
int array alldiff  v   v   v   v   e   e   e   e   
solve satisfy

bumblebee output

v     
v     
v     
v     
e     
e     
e     
e     
        
          

figure     solving vmtl instance using bumblebee 

using swi prolog v         bits  comparisons with sugar  v        are based on the use of
identical constraint models  apply the same sat solver  cryptominisat v        and run
on the same machine  times are reported in seconds 
    quasigroup completion problems
a quasigroup completion problem  qcp  proposed by gomes  selman  and crato       
as a constraint satisfaction benchmark  is given as an n  n board of integer variables  in
the range     n   in which some are assigned integer values  the task is to assign values to
all variables  so that no column or row contains the same value twice  the constraint model
is a conjunction of alldiff constraints  ansotegui  del val  dotu  fernandez  and manya
       argue the advantage of the direct encoding for qcp 
we consider    instances from the      csp competition   table   considers three
settings  bee with its dual encoding for alldiff constraints  bee using only the order
encoding  equivalent to using int neq constraints instead of alldiff   and sugar  the
table shows  the instance identifier  sat or unsat   compilation time  comp  in seconds 
clauses in the encoding  clauses   variables in the encoding  vars   and sat solving time
 sat  in seconds 
the results indicate that      application of bee using the dual representation for
alldiff is    times faster and produces    times fewer clauses  in average  than when
using the order encoding alone  despite the need to maintain two encodings       without
the dual representation  solving encodings generated by bee is only slightly faster than
sugar but bee still generates cnf encodings   times smaller  on average  than those
generated by sugar  observe that   instances are found unsatisfiable by bee  indicated
   http   www cril univ artois fr cpai     the competition instances are specified using binary disequalities  but here we use the model with alldiff 

   

fimetodi  codish    stuckey

instance

         sat
         sat
         sat
         sat
         sat
         sat
         sat
         sat
         sat
         sat
          unsat
          unsat
          unsat
          unsat
          unsat
total

bee  dual
comp clauses
 sec 
         
         
         
         
         
         
         
         
         
         
         
    
 
    
 
    
 
         

encoding 
vars
sat
 sec 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 
    
 
    
 
    
    
    
    

bee  order
comp clauses
 sec 
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          

encoding 
vars
sat
 sec 
   
    
   
     
   
    
   
     
   
     
   
     
   
     
   
     
   
     
   
     
   
     
   
    
   
    
   
    
   
     
      

clauses

sugar
vars

      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

sat
 sec 
     
     
    
     
     
     
     
    
    
     
     
    
    
    
     
      

table    qcp results for        instances with     holes
by a cnf with a single clause and no variables   we comment that sugar pre processing
times are higher than those of bee and not indicated in the table 
    word design for dna
this is problem     of csplib which seeks the largest parameter n  such that there exists
a set s of n eight letter words over the alphabet     a  c  g  t   with the following
properties      each word in s has exactly   symbols from  c  g       each pair of
distinct words in s differ in at least   positions  and     for every x  y  s  xr  the reverse
of x  and y c  the word obtained by replacing each a by t   each c by g  and vice versa 
differ in at least   positions 
mancini  micaletto  patrizi  and cadoli        provide a comparison of several stateof the art solvers applied to the dna word problem with a variety of encoding techniques 
their best reported result is a solution with    dna words  obtained in     seconds  using
an opl  van hentenryck        model with lexicographic order to break symmetry  frutos 
liu  thiel  sanner  condon  smith  and corn        present a strategy to solve this problem
where the four letters are modeled by bit pairs  t  m   each eight letter word can then be
viewed as the combination of a t part   t            t     which is a bit vector  and a m part 
 m            m     also a bit vector  the authors report a solution composed from two pairs
of  t part and m part  sets   t    m    and  t    m    where  t          m           t        
 m         this forms a set s with                        dna words  marc van dongen
reports a larger solution with     words  
building on the approach described by frutos et al          we pose conditions on sets
of t parts and m parts  t and m   so that their cartesian product s   t  m will
satisfy the requirements of the original problem  from the three conditions below  t is
required to satisfy       and        and m is required to satisfy       and        for a set of
   their notions of t part and m part are slightly different than ours 
   see http   www cs st andrews ac uk  ianm csplib  

   

fiboolean equi propagation

bit vectors v   the conditions are        each bit vector in v sums to          each pair of
distinct bit vectors in v differ in at least   positions  and       for each pair of bit vectors
 not necessarily distinct  u  v  v   ur  the reverse of u  and v c  the complement of v 
differ in at least   positions  this is equivalent to requiring that  ur  c differs from v in at
least   positions 
it is this strategy that we model in our bee encoding  an instance takes the form
dna n    n    signifying the numbers of bit vectors  n  and n  in the sets t and m   without
loss of generality  we impose  to remove symmetries  that t and m are lexicographically
ordered  a solution is the cartesian product s   t  m  
using bee  we find  in a fraction of a second  sets of t parts of size    and m parts of
size    this provides a solution of size             to the dna word problem  running
comet  v       we find a     word solution in about    seconds using a model by hakan
kjellerstrand   using bee  we also prove that there does not exist a set of    t parts      
seconds   nor a set of   m parts       seconds   these facts were unknown prior to bee 
proving that there is no solution to the dna word problem with more than     words 
without the restriction to the two part t m strategy  is still an open problem 
    vertex magic total labeling
macdougall  miller  slamin  and wallis        conjecture that the n vertex complete graph 
kn   for n    has a vertex magic total labeling with magic constants for a specific range of
values of k  determined by n  this conjecture is proved correct for all odd n and verified by
brute force for n      we address the cases for n     and n      which involve    instances
 different values of k  for n      and     different values of k  for n       starting from
the simple constraint model  illustrated by the example in figure      we add additional
constraints to exploit the fact that the graphs are symmetric      we assume that the edge
with the smallest label is e          we assume that the labels of the edges incident to v 
are ordered and hence introduce constraints e      e           e  n       we assume that
the label of edge e    is smaller than the labels of the edges incident to v   except e      and
introduce constraints accordingly  in this setting bee can solve all except   instances with
a   hour timeout and sugar can solve all except   
table   gives results for the    hardest instances for k  the    hardest instances for k  
with a   hour time out  bee compilation times are on the order of     sec instance for k 
and     sec instance for k     sugar encoding times are slightly larger  the instances are
indicated by the magic constant  k  the columns for bee and sugar indicate sat solving
times  in seconds   the bottom two lines indicate average encoding sizes  numbers of clauses
and variables  
the results indicate that the sugar encodings are  in average  about     larger  while
the average sat solving time for the bee encodings is about   times faster  average excluding instances where sugar times out  
to address the two vmtl instances not solvable using the bee models described above
 k   with magic labels     and       we partition the problem fixing the values of e   
and e    and maintaining all of the other constraints  analysis of the symmetry breaking
constraints indicates that this results in     new instances for each of the two cases  the
   see http   www hakank org comet word design dna  co 

   

fimetodi  codish    stuckey

instance
bee
k 
k
sat  sec 
   
    
   
     
   
    
   
     
   
     
   
     
   
     
   
     
   
      
   
      
average cnf size 
clauses
      
vars
    

sugar
sat  sec 
    
    
    
    
    
    
      
      
      


instance
bee
k  
k
sat  sec 
   
    
   
    
   
     
   
    
   
     
   
     
   
    
   
    
   
    
   
     
   
     
   
      
   
       
   
      
   
      
   
       
   
       
   
       
   

   

average cnf size 
clauses
       
vars
     

      
    

sugar
sat  sec 
    
    
     
    
    
     
    
     
     
      
      
      
      
      
      
       
       



       
     

table    vmtl results for k  and k      hour timeout 

original vmtl instance is solved if any one of of these     instances is solved  so  we solve
them in parallel  fixing e    and e    fuels the compiler so the encodings are considerably
smaller  the instance for k       is solved in         seconds where e        and e        
the compilation time is      seconds and the encoding consists in just over   million clauses
and    thousand variables 
to the best of our knowledge  the hard instances from this suite are beyond the reach of
all previous approaches to program the search for magic labels  the sat based approach
presented by jager        cannot handle these   the comparison with sugar indicates the
impact of the compiler 
    balanced incomplete block designs
this is problem     of csplib  bibd  where an instance is defined by a   tuple of positive
integers  v  b  r  k    and requires to partition v distinct objects into b blocks such that each
block contains k different objects  exactly r objects occur in each block  and every two
distinct objects occur in exactly  blocks 
   personal communication  gerold jager   march      

   

fiboolean equi propagation

figure     bibd symmetry breaking 
the naive model for a bibd instance  v  b  r  k    introduces the following constraints
on a v by b boolean incidence matrix      exactly r ones in each row      exactly k ones in
each column  and     exactly  ones in each scalar product of two  different  rows 
this model does not contain a sufficient degree of information to trigger the equipropagation process  in order to take advantage of the bee simplifications we added
symmetry breaking as described by frisch  jefferson  and miguel        and illustrated
in figure     each row is viewed as sequence of four parts a       d with sizes    r    
 r     and  b   r      the first row is fixed by assigning parts a and b with ones
 marked in black  and parts c and d with zeros  marked in white   the second row is
fixed by assign parts a and c with ones  marked in black  and parts b and d with zeros
 marked in white   for the third and all subsequent rows  marked in gray   the sum constraints are decomposed into summing each part  a       d  and then summing the results as
follows  a   b     a   c     c   d   r    and b   d   r    this ensures that the
row contains exactly r ones and that the scalar product with the first  and second  row is
  we denote this constraint model symb  for symmetry breaking  
instance
 v  b  r  k   
                    
                    
                   
                   
                  
                  
                 
                 
                 
                 
                 
total  sec 

comp
 sec 
    
    
    
    
    
    
    
    
    
    
    

bee  symb 
clauses
sat
 sec 
      
    
             
      
    
      
    
     
    
      
    
     
    
      
    
 
    
     
    
     
    
     

sugar  symb 
comp
clauses
sat
 sec 
 sec 
                   
                   
             
    
    
      

     
      
    
     
      
    
    
      
    



     
    
    
     
      
    
     
     
    
        

satelite  symb 
comp
clauses sat
 sec 
 sec 
    
           
                 
    
           
    
      

    
          
    
           
   
          
     
           
    
      
    
          
   
          
        

table    bibd results      sec  timeout 
table   shows results comparing bee  compilation time  clauses in encoding  and sat
solving time  with sugar using the symb model  we also compare bee with satelite  een
   

fimetodi  codish    stuckey

  biere         a cnf minimizer  where the input to satelite is the cnf encoding for
the symb model generated by bee without applying any simplifications  here compilation
time  comp  indicates the satelite pre processing time  the final row indicates the total
of compilation and sat solving time over the entire suite for each approach  in all cases
time is measured in seconds 
this experiment indicates that bee generates a significantly smaller cnf than sugar
which affects the sat solving time  moreover  the sugar compilation time is extremely
long  when comparing bee with satelite we can see that both output a cnf which
is similar in size but as satelite is applied on the entire cnf  for some instances its
compilation time is significantly longer than its solving time 
instance
 v  b  r  k   
                    
                    
                   
                   
                  
                  
                 
                 
                 
                 
                 
total

bee  symb 
comp
sat
    
    
          
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
     

 m   
    
    
    

     
      
     

    


       

minion
symb
    
    


    
     
     
    
    

    
       

symb 
    
    
    
     
    
    
    
    
    
    
    
     

table    bibd results  comparison with minion  times in seconds      sec  timeout  
table   shows results comparing bee using the symb model with the minion constraint
solver  gent  jefferson    miguel         we consider three different models for minion 
 m    indicates results using the bibd model described by gent et al          symb uses
the same model we use for the sat approach  symb    is an enhanced symmetry breaking
model with all of the tricks applied also in the  m    model  for the columns with no
timeouts we show total times  for bee this includes compile time and sat solving   note
that by using a clever modeling of the problem we have improved also the previous run times
for minion 
this experiment indicates that bee is significantly faster than minion on its bibd
models   m      only when tailoring our symb model  does minion becomes competitive
with ours 
    combining bee with satelite
we now demonstrate the impact of combining bee and satelite  we describe experiments involving two of the benchmarks where satelite is applied to simplify the output of
bee  the idea is to first apply the more powerful  but local  techniques  performed by bee 
this reduces the size of the cnf and is fast  then we apply satelite which takes global
considerations on the cnf as a whole  we wish to determine if the smaller  simplified 
   

fiboolean equi propagation

cnf is more amenable to further simplification using satelite  the results indicate that
although cnf size is slightly decreased  solving times are most often increased  sometimes
drastically 
tables   and   show our results  in both tables the four columns under the bee
heading indicate  bee compilation time  size of the encoding  clauses and variables   and the
subsequent sat solving time  similarly  the four columns under the  satelite heading
indicate the application of satelite to the output of bee  the satelite processing time 
the size of the resulting cnf  clauses and variables   and the subsequent sat solving time 
table   illustrates the results for the bibd benchmark of section     and table    the results
for the    hardest vmtl instances for k  and for k   described in section      observe
that applying satelite to the output of bee decreases the cnf size only slightly and does
not improve the sat solving time  in fact  to the contrary  in most cases it renders a cnf
which takes more time to solve  in several cases  sat solving time increases drastically to
introduce a timeout 
instance
 v  b  r  k   
                    
                    
                   
                   
                  
                  
                 
                 
                 
                 
                 

comp
 sec 
    
    
    
    
    
    
    
    
    
    
    

bee
clauses
vars
      
       
      
      
     
      
     
      
 
     
     

     
     
     
     
     
     
    
    
 
     
    

sat
 sec 
    
     
    
    
    
    
    
    
    
    
    

comp
 sec 
    
    
    
    
    
    
    
     
    
    
    

 satelite
clauses
vars
      
       
      
      
     
      
     
      
 
     
     

     
     
     
     
     
     
    
    
 
     
    

sat
 sec 
    
    
    

    
    
    
    
    
     
    

table    bibd results  bee combined with satelite      sec  timeout 
our results demonstrate that the application of satelite to remove redundancies
from a cnf is often non beneficial  presumably the difference we see from our application
of satelite to other cnf benchmarks results from the fact that bee produces highly
optimized cnf output  while many cnf benchmarks have significant inefficiency in their
original encoding  if bee removes a variable from the cnf  then it also instantiates that
variable  either to a constant or to an equivalent variable  and as such does not remove
potential propagations from the encoding  as captured by theorem   

   conclusion
there is a considerable body of work on cnf simplification techniques with a clear trade off
between amount of reduction achieved and invested time  most of these approaches determine binary clauses implied by the cnf  which is certainly enough to determine boolean
equalities  the problem is that determining all binary clauses implied by the cnf is
prohibitive when the sat model may involve many  hundreds of  thousands of variables 
   

fimetodi  codish    stuckey

instance

k 

k  

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

comp
 sec 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

bee
clauses
vars
      
      
      
      
      
      
      
      
      
      
       
       
       
       
       
       
       
       
       
       

    
    
    
    
    
    
    
    
    
    
     
     
     
     
     
     
     
     
     
     

sat
 sec 
    
     
    
     
    
     
     
     
      
     
     
     
       
      
      
      
      
       



comp
 sec 
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

 satelite
clauses
vars
      
      
      
      
      
      
      
      
      
      
       
       
       
       
       
       
       
       
       
       

    
    
    
    
    
    
    
    
    
    
     
     
     
     
     
     
     
     
     
     

sat
 sec 
    
    
     
    
    
     
     
     
      

      
      
      
     
       
       





table    vtml results  bee combined with satelite    hour timeout 

typically only some of the implied binary clauses are determined  such as those visible by
unit propagation  the trade off is regulated by the choice of the techniques applied to infer
binary clauses  considering the power and cost  see for example the work of een and biere
       and the references therein  there are also approaches  li        that detect and use
boolean equalities during run time  which are complementary to our approach 
in our approach  the beast is tamed by introducing a notion of locality  we do not
consider the full cnf  instead  by maintaining the original representation  a conjunction of
constraints  each viewed as a boolean formula  we can apply powerful reasoning techniques
to separate parts of the model and maintain efficient pre processing 
to this end  we introduce bee  a compiler that follows this approach to encode finite
domain constraints to cnf  applying optimizations based on ad hoc equi propagation and
partial evaluation rules on a high level view of the problem allows us to simplify the problem
more aggressively than is possible with a cnf representation  the resulting cnf models
can be significantly smaller than those resulting from straight translation 
it is well understood that making a cnf smaller is not the ultimate goal  often smaller
cnfs are harder to solve  indeed  one often introduces redundancies to improve sat
encodings  so removing them is counterproductive  our experience is that bee reduces
the size of an encoding in a way that is productive for the subsequent sat solving  in
particular  by removing variables that can be determined at compile time to be definitely
equal  or definitely different  in any solution 
   

fiboolean equi propagation

bee uses ad hoc equi propagation and partial evaluation rules which keeps compilation
times typically small  measured in seconds  even for instances which result in several millions
of cnf clauses  and the reduction in sat solving time can be larger by orders of magnitude 
hence  we believe that boolean equi propagation makes an important contribution to the
encoding of csps to sat 
bee is currently tuned to represent integers in the order encoding  ongoing work
aims to extend bee for binary and additional number representations such as mixed radix
bases as considered by een and sorensson        and further by codish  fekete  fuhs  and
schneider kamp        
acknowledgments
we thank vitaly lagoon for the many insightful discussions concerning this research 
nicta is funded by the australian government as represented by the department of
broadband  communications and the digital economy and the australian research council through the ict centre of excellence program 

references
ansotegui  c   del val  a   dotu  i   fernandez  c     manya  f          modeling choices in
quasigroup completion  sat vs  csp  in mcguinness  d  l     ferguson  g   eds   
aaai  pp          san jose  california  usa  aaai press   the mit press 
asn  r   nieuwenhuis  r   oliveras  a     rodrguez carbonell  e          cardinality
networks  a theoretical and empirical study  constraints                 
bagnara  r     schachte  p          factorizing equivalent variable pairs in robddbased implementations of pos  in haeberer  a  m   ed    algebraic methodology and
software technology   th international conference  amast     amazonia  brasil 
january            proceedings  vol       of lecture notes in computer science  pp 
       
bailleux  o     boufkhad  y          efficient cnf encoding of boolean cardinality constraints  in rossi  f   ed    cp  vol       of lncs  pp          kinsale  ireland 
springer 
barrett  c   stump  a     tinelli  c          the satisfiability modulo theories library
 smt lib   www smt lib org 
batcher  k  e          sorting networks and their applications  in afips spring joint
computing conference  vol     of afips conference proceedings  pp          atlantic city  nj  usa  thomson book company  washington d c 
bessiere  c   katsirelos  g   narodytska  n     walsh  t          circuit complexity and
decompositions of global constraints  in proceedings of ijcai       pp         
cadoli  m     schaerf  a          compiling problem specifications into sat  artificial
intelligence                   
   

fimetodi  codish    stuckey

codish  m   fekete  y   fuhs  c     schneider kamp  p          optimal base encodings
for pseudo boolean constraints  in abdulla  p  a     leino  k  r  m   eds    tacas 
vol       of lecture notes in computer science  pp          springer 
codish  m   lagoon  v     stuckey  p  j          logic programming with satisfiability 
tplp                
codish  m     zazon ivry  m          pairwise cardinality networks  in clarke  e  m    
voronkov  a   eds    lpar  dakar   vol       of lecture notes in computer science 
pp          springer 
coudert  o     madre  j  c          a unified framework for the formal verification of
sequential circuits  in iccad  pp         
crawford  j  m     baker  a  b          experimental results on the application of satisfiability algorithms to scheduling problems  in hayes roth  b     korf  r  e   eds   
aaai  vol     pp            seattle  wa  usa  aaai press   the mit press 
een  n     biere  a          effective preprocessing in sat through variable and clause
elimination  in bacchus  f     walsh  t   eds    sat  vol       of lecture notes in
computer science  pp        springer 
een  n     sorensson  n          an extensible sat solver  in giunchiglia  e     tacchella  a   eds    sat  vol       of lecture notes in computer science  pp         
springer 
een  n     sorensson  n          translating pseudo boolean constraints into sat  jsat 
             
frisch  a  m   jefferson  c     miguel  i          symmetry breaking as a prelude to implied
constraints  a constraint modeling pattern  in proc    th euro  conf  on ai         
pp          press 
frutos  a  g   liu  q   thiel  a  j   sanner  a  m  w   condon  a  e   smith  l  m    
corn  r  m          demonstration of a word design strategy for dna computing on
surfaces  journal of nucleic acids research                    
gallian  j  a          a dynamic survey of graph labeling  the electronic journal of
combinatorics     
gavanelli  m          the log support encoding of csp into sat  in bessiere  c   ed   
cp  vol       of lncs  pp          providence  ri  usa  springer 
gelder  a  v          toward leaner binary clause reasoning in a satisfiability solver  ann 
math  artif  intell                  
gent  i  p   jefferson  c     miguel  i          minion  a fast scalable constraint solver 
in brewka  g   coradeschi  s   perini  a     traverso  p   eds    ecai  vol      of
frontiers in artificial intelligence and applications  pp         ios press 
gent  i  p     nightingale  p          a new encoding of alldifferent into sat  proceedings
of the  rd international workshop on modeling and reformulating constraint satisfaction problems  http   www users cs york ac uk frisch reformulation    
proceedings pdf 
   

fiboolean equi propagation

gomes  c  p   selman  b     crato  n          heavy tailed distributions in combinatorial
search  in smolka  g   ed    cp  vol       of lncs  pp          springer 
heule  m   jarvisalo  m     biere  a          efficient cnf simplification based on binary
implication graphs  in sakallah  k  a     simon  l   eds    sat  vol       of lecture
notes in computer science  pp          springer 
huang  j          universal booleanization of constraint models  in cp      vol       of
lecture notes in computer science  pp         
jager  g          an effective sat encoding for magic labeling  in faigle  u   schrader  r  
  herrmann  d   eds    ctw  pp        
li  c          equivalent literal propagation in the dll procedure  discrete applied
mathematics                  
macdougall  j   miller  m   slamin  m     wallis  w          vertex magic total labelings
of graphs  utilitas mathematica          
mancini  t   micaletto  d   patrizi  f     cadoli  m          evaluating asp and commercial
solvers on the csplib  constraints                 
manthey  n          coprocessor       a flexible cnf simplifier    tool presentation   in
cimatti  a     sebastiani  r   eds    sat  vol       of lecture notes in computer
science  pp          springer 
metodi  a          bee  http   amit metodi me research bee  
metodi  a     codish  m          compiling finite domain constraints to sat with bee 
tplp                   
metodi  a   codish  m   lagoon  v     stuckey  p  j          boolean equi propagation for
optimized sat encoding  in lee  j  h  m   ed    cp  vol       of lncs  pp         
springer 
nethercote  n   stuckey  p  j   becket  r   brand  s   duck  g  j     tack  g         
minizinc  towards a standard cp modeling language  in bessiere  c   ed    cp     
vol       of lecture notes in computer science  pp          providence  ri  usa 
springer verlag 
somenzi  f          cudd  colorado university decision diagram package   online 
accessed    april        http   vlsi colorado edu  fabio cudd  
soos  m          cryptominisat  v       http   www msoos org cryptominisat  
tamura  n   taga  a   kitagawa  s     banbara  m          compiling finite linear csp
into sat  constraints                 
tarjan  r          efficiency of a good but not linear set union algorithm  jacm         
       
van hentenryck  p          the opl optimization programming language  mit press 
van hoeve  w  j          the alldifferent constraint  a survey   corr http   arxiv org 
abs cs pl         

   

fi