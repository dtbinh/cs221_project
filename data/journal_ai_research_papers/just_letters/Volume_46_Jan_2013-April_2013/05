journal artificial intelligence research                  

submitted        published      

numvc  efficient local search algorithm
minimum vertex cover
shaowei cai

shaoweicai   cs   gmail   com

key laboratory high confidence software technologies
peking university  beijing  china

kaile su

k   su   griffith   edu   au

institute integrated intelligent systems
griffith university  brisbane  australia

chuan luo

chuanluosaber   gmail   com

key laboratory high confidence software technologies
peking university  beijing  china

abdul sattar

  sattar   griffith   edu   au

institute integrated intelligent systems
griffith university  brisbane  australia

abstract
minimum vertex cover  mvc  problem prominent np hard combinatorial
optimization problem great importance theory application  local search proved
successful problem  however  two main drawbacks state of the art mvc local
search algorithms  first  select pair vertices exchange simultaneously  timeconsuming  secondly  although using edge weighting techniques diversify search 
algorithms lack mechanisms decreasing weights  address issues  propose two
new strategies  two stage exchange edge weighting forgetting  two stage exchange
strategy selects two vertices exchange separately performs exchange two stages 
strategy edge weighting forgetting increases weights uncovered edges 
decreases weights edge periodically  two strategies used designing
new mvc local search algorithm  referred numvc 
conduct extensive experimental studies standard benchmarks  namely dimacs
bhoslib  experiment comparing numvc state of the art heuristic algorithms
show numvc least competitive nearest competitor namely pls
dimacs benchmark  clearly dominates competitors bhoslib benchmark  also 
experimental results indicate numvc finds optimal solution much faster current
best exact algorithm maximum clique random instances well structured ones 
moreover  study effectiveness two strategies run time behaviour
experimental analysis 

   introduction
minimum vertex cover  mvc  problem consists of  given undirected graph g    v  e  
finding minimum sized vertex cover  vertex cover subset v every
edge g least one endpoint s  mvc important combinatorial optimization problem
many real world applications  network security  scheduling  vlsi design industrial
machine assignment  equivalent two well known combinatorial optimization problems 
maximum independent set  mis  problem maximum clique  mc  problem 
c
    
ai access foundation  rights reserved 

fic ai   u   l uo   attar

wide range applications areas information retrieval  experimental design  signal
transmission  computer vision  bioinformatics problems aligning dna protein
sequences  johnson   trick         indeed  three problems seen three different
forms problem  viewpoint practical algorithms  algorithms mvc
directly used solve mis mc problems  due great importance theory
applications  three problems widely investigated last several decades
 carraghan   pardalos        evans        pullan   hoos        richter  helmert    gretton 
      cai  su    chen        li   quan      b  cai  su    sattar        
theoretical analyses indicate three problems mvc  mis  mc computationally
hard  np hard associated decision problems np complete  garey  
johnson         moreover  hard solve approximately  np hard approximate
mvc within factor smaller         dinur   safra         although one achieve
approximation ratio   o     halperin        karakostas         besides inapproximability
mvc  hastad shows mis mc approximable within  v        
unless np zpp   hastad               recently  conclusion enhanced mc
approximable within  v        unless np p  zuckerman         derived
derandomization hastads result  moreover  currently best polynomial time approximation
algorithm mc guaranteed find clique within factor o n loglogn     logn    
optimum  feige        
algorithms solve mvc  mis  mc  fall two types  exact algorithms heuristic
algorithms  exact methods mainly include branch and bound algorithms  carraghan  
pardalos        fahle        ostergard        regin        tomita   kameda        li  
quan      b      a   guarantee optimality solutions find  may fail give
solution within reasonable time large instances  heuristic algorithms  mainly include local
search algorithms  cannot guarantee optimality solutions  find optimal
satisfactory near optimal solutions large hard instances within reasonable time  therefore 
appealing use local search algorithms solve large hard mvc  mc  mis  instances 
early heuristic methods maximum clique designed initial responses
second dimacs implementation challenge  johnson   trick         maximum clique
one three challenge problems  that  huge amount effort devoted designing
local search algorithms mvc  mc mis problems  aggarwal  orlin    tai        battiti  
protasi        busygin  butenko    pardalos        shyu  yin    lin        barbosa   campos 
      pullan        richter et al         andrade  resende    werneck        cai et al        
       review heuristic algorithms three problems found recent paper
mvc local search  cai et al         
work devoted efficient local search algorithm mvc  typically  local search
algorithms mvc solve problem iteratively solving k vertex cover problem  solve
k vertex cover problem  maintain current candidate solution size k  exchange
two vertices iteratively becomes vertex cover  however  observe two drawbacks
state of the art mvc local search algorithms  first  select pair vertices exchanging
simultaneously according heuristic  richter et al         cai et al               
rather time consuming  explained section    second drawback edge
weighting techniques  basic concept edge weighting increase weights uncovered
   zpp class problems solved expected polynomial time probabilistic algorithm zero
error probability 

   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

edges diversify search  previous mvc local search algorithms utilize different edge weighting
schemes  example  cover  richter et al         increases weights uncovered edges
step  ewls  cai et al         ewcc  cai et al         increase weights uncovered
edges reaching local optima  however  algorithms mechanism
decrease weights  believe deficient weighting decisions made long
ago may mislead search 
address two issues mvc local search algorithms  paper proposes two new
strategies  namely two stage exchange edge weighting forgetting  two stage exchange
strategy decomposes exchanging procedure two stages  i e   removing stage
adding stage  performs separately  first selects vertex removes current
candidate solution  selects vertex random uncovered edge adds it  twostage exchange strategy yields efficient two pass move operator mvc local search 
first pass linear time search vertex to remove  second pass lineartime search vertex to add  contrast standard quadratic  all at once move
operator  moreover  two stage exchange strategy renders algorithm flexible
employ different heuristics different stages  indeed  numvc algorithm utilizes
highly greedy heuristic removing stage  adding stage  makes good use
diversifying heuristic within framework similar focused random walk  papadimitriou        
second strategy propose edge weighting forgetting  increases weights
uncovered edges one step  moreover  averaged edge weight achieves
threshold  reduces weights edges multiplying constant factor           forget
earlier weighting decisions  best knowledge  first time forgetting
mechanism introduced local search algorithms mvc 
two strategies combined design new local search algorithm called numvc 
carry detailed experimental study investigate performance numvc  compare
pls  pullan         cover  richter et al         ewcc  cai et al         
leading heuristic algorithms mvc  mc  mis   experimental results show numvc
competes well solvers dimacs benchmark  shows dramatic improvement
existing results whole bhoslib benchmark  parts work published
early version paper  cai  su    sattar        
paper  additionally carry experimental analyses provides
insights two strategies numvc  compare numvc exact algorithm
maxclqdyn efl scr  li   quan      a   best exact maximum clique algorithm
found literature  experimental results indicate numvc finds optimal solution
much faster exact algorithm random instances well structured ones 
importantly  conduct experimental investigations study run time behaviour numvc
effectiveness two new strategies numvc 
remainder paper organized follows  next section  introduce
definitions notations used paper  present two strategies  two stage exchange
edge weighting forgetting  section    describe numvc algorithm  section  
presents experimental study numvc comparative results algorithms  including
heuristic exact algorithms  followed detailed investigations run time
behaviour numvc effectiveness two new strategies section    finally 
conclude paper summarizing main contributions future directions 
   

fic ai   u   l uo   attar

   preliminaries
undirected graph g    v  e  consists vertex set v edge set e v v  
edge   element subset v   edge e    u  v   say vertices u v
endpoints edge e  two vertices neighbors belong common
edge  denote n  v     u v   u  v  e   set neighbors vertex v 
undirected graph g    v  e   independent set subset v pairwise nonadjacent elements clique subset v pairwise adjacent elements  maximum
independent set maximum clique problems find maximum sized independent set
clique graph  respectively 
note three problems mvc  mis mc seen three different forms
problem  viewpoint experimental algorithms  vertex set independent
set g v  s vertex cover g  vertex set k clique g v  k
vertex cover complementary graph g  find maximum independent set graph
g  one find minimum vertex cover cmin g return v  cmin   similarly  find

maximum clique graph g  one find minimum vertex cover cmin
complementary

graph g  return v  cmin
 
given undirected graph g    v  e   candidate solution mvc subset vertices 
edge e e covered candidate solution x least one endpoint e belongs
x  search procedure  numvc always maintains current candidate solution 
convenience  rest paper  use c denote current candidate solution  state
vertex v denoted sv         sv     means v c  sv     means v
  c 
step neighboring candidate solution consists exchanging two vertices  vertex u c
removed c  vertex v
  c put c  age vertex number steps since
state last changed 
state of the art mvc local search algorithms  numvc utilizes edge weighting
scheme  edge weighting local search  follow definitions notations ewcc  cai
et al          edge weighted undirected graph undirected graph g    v  e  combined
weighting function w edge e e associated non negative integer number
w e  weight  use w denote mean value edge weights 
let w weighting function g  candidate solution x  set cost x
x

cost g  x   

w e 

ee e covered x

indicates total weight edges uncovered x  take cost g  x  evaluation
f unction  numvc prefers candidate solutions lower costs 
vertex v v  
dscore v    cost g  c  cost g  c  
c   c  v  v c  c   c  v  otherwise  measuring benefit changing
state vertex v  obviously  vertex v c  dscore v     greater dscore
indicates less loss covered edges removing c  vertex v
  c 
dscore v     higher dscore indicates greater increment covered edges adding
c 
   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

   two stage exchange
section  introduce two stage exchange strategy  adopted numvc
algorithm exchange pair vertices 
state of the art mvc local search algorithms  numvc iterated k vertex
cover algorithm  finding k vertex cover  numvc removes one vertex current
candidate solution c goes search  k    vertex cover  sense  core
numvc k vertex cover algorithm given positive integer number k  searching k sized
vertex cover  find k vertex cover  numvc begins candidate solution c size k 
exchanges two vertices iteratively c becomes vertex cover 
local search algorithms mvc select pair vertices exchange simultaneously
according certain heuristic  example  cover selects pair vertices maximize
gain u  v   richter et al          ewls  cai et al         ewcc  cai et al         select
random pair vertices score u  v       strategy selecting two vertices exchange
simultaneously leads quadratic neighborhood candidate solutions  moreover  evaluation
pair vertices depends evaluations  such dscore  two vertices 
involves relationship two vertices  belong edge  therefore 
rather time consuming evaluate candidate pairs vertices 
contrast earlier mvc local search algorithms  numvc selects two vertices
exchanging separately exchanges two selected vertices two stages  iteration 
numvc first selects vertex u c highest dscore removes it  that  numvc
selects uniformly random uncovered edge e  chooses one endpoint v e higher
dscore restrictions adds c  note two stage exchange strategy
resembles respect min conflicts hill climbing heuristic csp  minton  johnston 
philips    laird         shows surprisingly good performance n queens problem 
selecting two vertices exchanging separately may cases miss greedier
vertex pairs consist two neighboring vertices  however  usual local search
algorithms  trade off accuracy heuristics complexity per step 
let r denote set candidate vertices removing adding separately  time
complexity per step selecting exchanging vertex pair simultaneously  r   a  
complexity per step selecting two vertices separately  numvc   r     a  
worthy note that  heuristics local search algorithm often based intuition
experience rather theoretically empirically derived principles insights  cannot say
certain less greedy good thing  hoos   stutzle         hand 
lower time complexity always desirable 

   edge weighting forgetting
section  present new edge weighting technique called edge weighting forgetting 
plays important role numvc 
proposed strategy edge weighting forgetting works follows  edge
associated positive integer number weight  edge weight initialized one 
iteration  edge weights uncovered edges increased one  moreover 
average weight achieves threshold  edge weights reduced forget earlier weighting
decisions using formula w e     w e   constant factor     
   

fic ai   u   l uo   attar

note edge weighting techniques mvc local search  including one work 
fall general penalty idea optimization problems  dates back morris
breakout method  morris        widely used local search algorithms constraint
optimization problems sat  yugami  ohta    hara        wu   wah        schuurmans 
southey    holte        hutter  tompkins    hoos         results therefore provide
evidence effectiveness general applicability algorithmic technique 
edge weighting techniques successfully used improve mvc local search
algorithms  example  cover  richter et al         updates edge weights step 
ewls  cai et al         ewcc  cai et al         update edge weights reaching local
optima  however  previous edge weighting techniques mechanism decrease
weights  limits effectiveness  strategy edge weighting forgetting
work introduces forgetting mechanism reduce edge weights periodically  contributes
considerably numvc algorithm 
intuition behind forgetting mechanism weighting decisions made long ago
longer helpful may mislead search  hence considered less important
recent ones  example  consider two edges e  e  w e           w e     
    step  use w e  denote increase w e   according evaluation
function  next period time  algorithm likely cover e  frequently e   
may assume period w e         w e           makes w e     
                 w e                       without forgetting mechanism  algorithm
would still prefer e  e  covered future search  reasonable 
period e  covered much fewer steps e  is  thus  e  take priority covered
sake diversification  let us consider case forgetting mechanism  assuming
      setting experiments   suppose w e           w e         
algorithm performs forgetting  forgetting mechanism reduces edge weights
w e                    w e                   period time  w e        
w e           w e                     w e                      case 
algorithm prefers cover e  rather cover e  future search  expect 
although inspired smoothing techniques clause weighting local search algorithms
sat  forgetting mechanism numvc differs smoothing techniques sat
local search algorithms  according way clause weights smoothed  three
main smoothing techniques clause weighting local search algorithms sat best
knowledge  first pull clause weights mean value using formula wi   
wi        w  esg  schuurmans et al          saps  hutter et al         swcca
 cai   su         second subtract one clause weights greater
one  dlm  wu   wah        paws  thornton  pham  bain    jr          last
employed ddwf  ishtaiwi  thornton  sattar    pham         transfers weights
neighbouring satisfied clauses unsatisfied ones  obvious forgetting mechanism
numvc different smoothing techniques 
recently  forgetting mechanism proposed vertex weighting technique significant
mc local search algorithm dls mc  pullan   hoos         important sub algorithm
pls  pullan        cls  pullan  mascia    brunato         dls mc algorithm employs
vertex weighting scheme increases weights vertices  by one  current clique
reaching local optimum  periodically decreases weights  by one  vertices
currently penalty  specifically  utilizes parameter pd  penalty delay  specify
   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

number penalty increase iterations must occur algorithm performs forgetting
operation  however  pullan hoos observed dls mc sensitive pd
parameter  optimal value pd varies considerably among different instances  indeed 
performance dls mc given optimizing pd parameter  contrast  forgetting
mechanism numvc much less sensitive parameters  as shown section      
thus robust 
notice formula used forgetting mechanism numvc adopted
long term frequency based learning mechanisms tabu search  taillard         however 
taillars algorithm  parameter  using term work  always greater one 
formula used penalizing move rather forgetting penalties 

   numvc algorithm
section  present numvc algorithm  utilizes strategies two stage
exchange edge weighting forgetting 
algorithm    numvc
 

 
 
 
 
 
 
 
 
  
  
  

  
  
  

  
  
  
  
  

numvc  g cutoff 
input  graph g    v  e   cutoff time
output  vertex cover g
begin
initialize edge weights dscores vertices 
initialize confchange array all   array 
construct c greedily vertex cover 
c    c 
elapsed time   cutoff
uncovered edge
c    c 
remove vertex highest dscore c 
continue 
choose vertex u c highest dscore  breaking ties favor oldest
one 
c    c  u   confchange u       confchange z       z n  u  
choose uncovered edge e randomly 
choose vertex v e confchange v      higher dscore  breaking ties
favor older one 
c    c  v   confchange z       z n  v  
w e     w e      uncovered edge e 
w w e     w e  edge e 
return c  
end

better understanding algorithm  first describe strategy called configuration checking
 cc   used numvc  cc strategy  cai et al         proposed handling
   

fic ai   u   l uo   attar

cycling problem local search  i e   revisiting candidate solution visited recently
 michiels  aarts    korst         strategy successfully applied local search
algorithms mvc  cai et al         well sat  cai   su              
cc strategy numvc works follows  vertex v
  c  neighboring vertices
never change states since last time v removed c  v added
back c  cc strategy seen prohibition mechanism  shares spirit
differs well known prohibition mechanism called tabu  glover        
implementation cc strategy maintain boolean array confchange vertices 
search procedure  vertices confchange value   forbidden
add c  confchange array initialized all   array  that  vertex v
removed c  confchange v  reset    vertex v changes state 
z n  v   confchange z  set   
outline numvc algorithm algorithm    described below  beginning  edge
weights initialized    dscores vertices computed accordingly  confchange v 
initialized   vertex v  current candidate solution c constructed iteratively
adding vertex highest dscore  ties broken randomly   becomes vertex
cover  finally  best solution c initialized c 
initialization  loop  lines       executed given cutoff time reached 
search procedure  uncovered edge  means c vertex cover 
numvc updates best solution c c  line     removes one vertex highest
dscore c  line      breaking ties randomly  go search vertex cover
size  c     c      note that  c  vertex highest dscore minimum
absolute value dscore since dscores negative 
iteration loop  numvc swaps two vertices according strategy two stage
exchange  lines         specifically  first selects vertex u c highest dscore
remove  breaking ties favor oldest one  removing u  numvc chooses uncovered
edge e uniformly random  selects one es endpoints add c follows 
one endpoint whose confchange    vertex selected  confchange values
endpoints    numvc selects vertex higher dscore  breaking ties
favor older one  exchange finished adding selected vertex c  along
exchanging two selected vertices  confchange array updated accordingly 
end iteration  numvc updates edge weights  lines         first  weights
uncovered edges increased one  moreover  numvc utilizes forgetting mechanism
decrease weights periodically  detail  averaged weight edges achieves threshold
  edge weights multiplied constant factor           rounded
integer edge weights defined integers numvc  forgetting mechanism forgets
earlier weighting decision extent  past effects generally longer helpful
may mislead search 
conclude section following observation  guarantees executability
line    
proposition    uncovered edge e  least one endpoint v edge e
confchange v      
proof  let us consider arbitrary uncovered edge e    v    v     proof includes two cases 
 a  least one v  v  never changes state initialization  without
   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

loss generality  assume v  vertex  initialization  confchange v    set
   that  removing v  c  which corresponds vs state sv changing  
   make confchange v       v  never changes state initialization 
confchange v       
 b  v  v  change states initialization  e uncovered  v 
  c
v 
  c  without loss generality  assume last removing v  happens last
removing v    last time v  removed  v  c holds  afterwards  v  removed 
means v  changes state  confchange v    set   v  n  v    

   empirical results
section  present detailed experimental study evaluate performance numvc
standard benchmarks literature  i e   dimacs bhoslib benchmarks  first
introduce dimacs bhoslib benchmarks  describe preliminaries
experiments  then  divide experiments three parts  purpose first part
demonstrate performance numvc detail  second compare numvc state ofthe art heuristic algorithms  finally  last part compare numvc state of the art exact
algorithms 
    benchmarks
good set benchmarks fundamental demonstrate effectiveness new solvers 
use two standard benchmarks mvc  mis  mc  research  dimacs benchmark
bhoslib benchmark  dimacs benchmark includes instances industry
generated various models  bhoslib instances random ones high difficulty 
      dimacs b enchmark
dimacs benchmark taken second dimacs implementation challenge
maximum clique problem                thirty seven graphs selected organizers
summary indicate effectiveness algorithms  comprising second dimacs challenge
test problems  instances generated real world problems coding theory 
fault diagnosis  kellers conjecture steiner triple problem  etc  random graphs
various models  brock p hat families  instances range size less
   vertices       edges greater       vertices           edges  although
proposed two decades ago  dimacs benchmark remains popular benchmark
widely used evaluating heuristic algorithms mvc  richter et al         pullan       
cai et al         gajurel   bielefeld         mis  andrade et al         pullan        mc
algorithms  pullan        katayama  sadamatsu    narihisa        grosso  locatelli    pullan 
      pullan et al         wu  hao    glover         particular  dimacs benchmark
used evaluating cover ewcc  convenient us use benchmark
conduct experiments comparing numvc cover ewcc  note dimacs
graphs originally designed maximum clique problem  mvc algorithms tested
complementary graphs 
   ftp   dimacs rutgers edu pub challenges

   

fic ai   u   l uo   attar

      bhoslib b enchmark
bhoslib   benchmarks hidden optimum solutions  instances generated randomly
phase transition area according model rb  xu  boussemart  hemery    lecoutre 
       generally  phase transition instances generated model rb proved
hard theoretically  xu   li        practically  xu   li        xu  boussemart 
hemery    lecoutre         sat version bhoslib benchmark extensively used
sat competitions    nevertheless  sat solvers much weaker mvc solvers
problems  remains justifiable referring results sat competition     
benchmark  bhoslib benchmark famous hardness influential enough
strongly recommended mvc  mc  mis  community  grosso et al         cai et al         
widely used recent literature reference point new local search solvers
mvc  mc mis    besides    instances  large instance frb            
vertices         edges  designed challenging mvc  mc  mis  algorithms 
bhoslib benchmark designed mc  mvc mis  graphs
benchmark expressed two formats  i e   clq format mis format  bhoslib
instance  graph clq format one mis format complementary other  mc
algorithms tested graphs clq format  mvc mis algorithms tested
mis format 
    experiment preliminaries
discuss experimental results  let us introduce preliminary information
experiments 
numvc implemented c    codes numvc ewcc publicly available
first authors homepage    codes cover downloaded online    pls
kindly provided authors  four solvers compiled g    o  option 
experiments carried machine   ghz intel core   duo cpu e      gb
ram linux  execute dimacs machine benchmarks    machine requires     
cpu seconds r            cpu seconds r           cpu seconds r      
numvc  set       v         runs  except challenging instance
frb                      note parameters state ofthe art mvc  mc  mis  algorithms  dls mc  pullan   hoos        ewls  cai et al  
       moreover  parameters dls mc ewls vary considerably different instances 
instance  algorithm performed     independent runs different random seeds 
run terminated upon reaching given cutoff time  cutoff time set     
seconds instances except challenging instance frb        cutoff
time set      seconds due significant hardness 
numvc  report following information instance 
optimal  or minimum known  vertex cover size  v c   
  
  
  
  
  
  

http   www nlsde buaa edu cn kexu benchmarks graph benchmarks htm
http   www satcompetition org
http   www nlsde buaa edu cn kexu benchmarks list graph papers htm
http   www shaoweicai net research html
http   www informatik uni freiburg de srichter 
ftp   dimacs rutgers edu pub dsj clique 

   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

number successful runs  suc   run said successful solution size v c
found 
vc size shows min  average  max  vertex cover size found numvc
    runs 
averaged run time     runs  time   run time successful run
time find v c solution  failed run considered cutoff time 
instances numvc achieve      success rate  report averaged
run time successful runs  suc time   run time measured cpu seconds 
inter quartile range  iqr  run time     runs  iqr difference
  th percentile   th percentile sample  iqr one famous robust
measures data analysis  hoaglin  mosteller    tukey         recommended
measurement closeness sampling distribution community experimental
algorithms  bartz beielstein  chiarandini  paquete    preuss        
number steps averaged     runs  steps   steps successful run
needed find v c solution  steps failed run executed
running cut off  instances numvc achieve      success
rate  report averaged steps successful runs  suc steps  
successful runs instance  time steps columns marked
n a  success rate solver instance less        th percentile
run time sample cutoff time represent real   th percentile  case 
report iqr  instead mark n a corresponding column  actually 
success rate solver certain instance less      solver considered
robust instance given cutoff time 
    performance numvc
section  report detailed performance numvc two benchmarks 
      p erformance n u mvc



dimacs b enchmark

performance results numvc dimacs benchmark displayed table    numvc
finds optimal  or best known  solutions       dimacs instances  note   failed
instances brock graphs  furthermore  among    successful instances  numvc
consistently  i e       runs     instances     solved within   second 
overall  numvc algorithm exhibits excellent performance dimacs benchmark except
brock graphs  remark brock graphs artificially designed defeat greedy
heuristics explicitly incorporating low degree vertices optimal vertex cover  indeed 
algorithms preferring higher degree vertices grasp  rls  k opt  cover ewcc
failed graphs 
      p erformance n u mvc



bhoslib b enchmark

table    illustrate performance numvc bhoslib benchmark  numvc
successfully solves bhoslib instances terms finding optimal solution  size
   

fic ai   u   l uo   attar

graph
instance vertices
brock     
brock     
brock     
brock     
brock     
brock     
c     
c     
c     
c      
c      
c      
c      
dsjc     
dsjc      
gen    p      
gen    p      
gen    p      
gen    p      
gen    p      
hamming   
hamming    
keller 
keller 
keller 
mann a  
mann a  
mann a  
p hat     
p hat     
p hat     
p hat     
p hat     
p hat     
p hat      
p hat      
p hat      

   
   
   
   
   
   
   
   
   
    
    
    
    
   
    
   
   
   
   
   
   
    
   
   
    
   
    
    
   
   
   
   
   
   
    
    
    

v c

suc

vc size

   

   
   
  
   
 
 
   
   
   
   
   
 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
  
   
   
   
   
   
   
   
   
   

   
   
               
   
   
   
  
   
   
   
    
                  
    
   
   
   
   
   
   
   
   
   
   
   
    
   
   
                  
   
   
   
   
   
   
    
    
    

   
   
   
   
   
  
   
   
   
    
    
    
   
   
   
   
   
   
   
   
   
   
   
    
   
   
    
   
   
   
   
   
   
    
    
    

numvc
time suc time 
     
     
                
     
n a
n a
       
       

     
     
     
                  
       
     
     
       
       

     
       
       
       

     
       

     
    
       

      
                 
     
       

     
     
     
     
     
     
     

steps suc steps 
      
       
                    
       
n a
n a
   
    
      
       
      
                    
       
    
      
    
  
     
    
   
 
     
  
     
      
    
        
                    
   
  
    
    
    
    
      
    
     

table    numvc performance results  averaged     independent runs  dimacs
benchmark instances  vc column marked asterisk means minimum
known vertex cover size proved optimal 

   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

worst solution finds never exceeds v c      numvc finds optimal solutions     
success rate       instances  averaged success rate remaining  
instances         results dramatically better existing results literature
benchmark  also  numvc finds sub optimal solution size v c     bshoslib
instances quickly  always less    seconds  indicates numvc used
approximate mvc problem efficiently even limited time 
besides    bhoslib instances table    challenging instance frb       
hidden minimum vertex cover size       designer bhoslib benchmark
conjectured instance solved pc less day within next two
decades    latest record challenging instance      sized vertex cover found
ewls  ewcc 
run numvc     independent trials within      seconds frb              
       this parameter setting yields best performance among combinations
                                               among     runs    runs find      sized
solution averaged time      seconds     runs find      sized solution  including
     sized  averaged time      seconds  also  interesting note numvc
locate rather good approximate solution hard instance quickly  size vertex
covers numvc finds within     seconds           
generally  finding  k    vertex cover much easier k vertex cover  hence 
numvc  well mvc local search algorithms solve mvc problem
solving k vertex cover problem iteratively  majority running time used finding
best vertex cover c  of run   trying  without success  find vertex cover size
  c      
    comparison heuristic algorithms
recent literature five leading heuristic algorithms mvc  mc  mis   including
three mvc algorithms cover  richter et al          ewls  cai et al         ewcc  cai
et al          two mc algorithms dls mc  pullan   hoos        pls  pullan        
note ewcc pls improved versions ewls dls mc respectively  show
better performance original versions dimacs bhoslib benchmarks  therefore 
compare numvc pls  cover ewcc 
comparing numvc heuristic algorithms  report v c   suc  time well
iqr  averaged run time successful runs  suc time  cannot indicate comparative
performance algorithms correctly unless evaluated algorithms close success rates 
f     suc 
calculated time   cutof
  report statistics  results
suc
bold indicate best performance instance 
      c omparative r esults



dimacs b enchmark

comparative results dimacs benchmark shown table    dimacs instances
easy solved solvers      success rate within   seconds  thus
reported table  actually  fact dimacs benchmark reduced   
useful instances really emphasizes need make new benchmark 
   http   www nlsde buaa edu cn kexu benchmarks graph benchmarks htm

   

fic ai   u   l uo   attar

graph
instance vertices
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

v c
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

suc

vc size

numvc
time  suc time 

steps  suc steps 

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
  
   
   
  
   
   
   
   
   
  
   
   
   
  
  
  
  
   

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
    
    
                  
    
    
                  
    
    
    
    
    
                  
    
    
    
                  
                  
                  
                  
    

     
     
     
     
     
     
     
     
     
     
     
     
     
     
      
     
     
      
     
      
      
       
                
    
      
                
       
      
       
      
       
                
       
      
      
                
                  
                
                 
      

     
     
      
     
      
      
      
      
      
      
      
       
      
       
       
       
       
        
       
       
        
         
                    
       
        
                    
         
        
         
        
         
                    
        
        
        
                    
                    
                    
                    
        

table    numvc performance results  averaged     independent runs  bhoslib
benchmark instances  bhoslib instances hidden optimal vertex cover 
whose size shown vc column 

indicated table    numvc outperforms cover ewcc instances 
competitive complementary pls  eight hard instances least one
solver fails achieve      success rate  pls dominates brock graphs numvc
dominates others  including two putatively hardest instances c       mann a  
 richter et al         grosso et al         cai et al          well keller  mann a   
   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

graph
instance

v c

suc

pls
time  iqr 

suc

brock     
brock     
brock     
brock     
c      
c      
gen    p      
keller 
mann a  
mann a  
p hat      

   
   
   
   
    
    
   
    
   
    
    

   
   
   
   
 
   
   
  
 
 
   

           
           
           
           
n a
       
          
         
      n a 
n a
           

 
  
 
 
 
   
   
   
  
 
   

cover
time  iqr 
      n a 
         
n a
n a
n a
         
          
      
         
      n a 
             

suc

ewcc
time  iqr 

suc

numvc
time  iqr 

  
   
 
 
 
   
   
   
  
 
   

      n a 
             
n a
n a
n a
         
           
           
         
      n a 
           

  
   
 
 
 
   
   
   
   
  
   

         
           
n a
n a
      n a 
        
           
           
       
      n a 
           

table    comparison numvc state of the art heuristic algorithms dimacs
benchmark  vc column marked asterisk means minimum known
vertex cover size proved optimal 

c        numvc finds      sized solution  finds      sized solution
   runs  number          pls  cover  ewcc respectively  note
pls performs well brock family comprises three sub algorithms  one
favors lower degree vertices 
table   indicates c       mann a   remain difficult modern algorithms 
none algorithms solve good success rate reasonable time 
hand  instances solved quickly  in less     seconds  least one algorithm  pls
numvc  low iqr value  always less       indicates quite stable performance 
      c omparative r esults



bhoslib b enchmark

table    present comparative results bhoslib benchmark  concentrating
considerable gaps comparisons  report results two groups small instances
 frb   frb     solved within several seconds solvers 
results table   illustrate numvc significantly outperforms algorithms
bhoslib instances  terms success rate averaged run time 
demonstrated figure    take look comparison numvc ewcc 
ewcc performs obviously better pls cover benchmark  numvc solves   
instances         success rate    instances ewcc does  instances
solved algorithms      success rate  overall averaged run time    seconds
numvc    seconds ewcc  instances  averaged success rate    
numvc  compared     ewcc 
excellent performance numvc underlined large gaps numvc
solvers hard instances  example  instances solvers fail
find optimal solution      success rate  numvc achieves overall averaged success
rate         dramatically better pls  cover ewcc        
              respectively  obviously  experimental results show numvc delivers
   

fic ai   u   l uo   attar

graph
instance

v c

suc

pls
time  iqr 

suc

frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       

   
   
   
   
   
   
   
   
   
   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

   
   
   
   
  
   
   
  
   
   
  
 
 
   
  
 
 
  
  
  
 
 
 
  
  
 
 
 
 
  

             
             
            
             
            
            
           
      n a 
         
         
          
      n a 
      n a 
       
          
      n a 
      n a 
      n a 
      n a 
      n a 
      n a 
n a
n a
      n a 
      n a 
n a
n a
      n a 
n a
          

   
   
   
   
   
   
   
   
   
   
   
  
  
   
   
  
  
  
  
  
  
  
  
  
   
  
 
  
 
  

cover
time  iqr 
           
             
        
            
         
            
         
         
       
          
         
      n a 
      n a 
       
         
      n a 
      n a 
         
      n a 
         
      n a 
      n a 
         
         
         
      n a 
      n a 
      n a 
      n a 
         

suc

ewcc
time  iqr 

suc

   
   
   
   
   
   
   
   
   
   
   
  
  
   
   
  
  
   
  
   
  
  
   
   
   
  
 
  
  
   

           
             
           
             
             
          
         
         
         
         
         
          
      n a 
       
       
      n a 
           
         
          
         
      n a 
      n a 
         
         
       
      n a 
      n a 
      n a 
      n a 
         

   
   
   
   
   
   
   
   
   
   
   
   
  
   
   
  
   
   
   
   
   
  
   
   
   
  
  
  
  
   

numvc
time  iqr 
           
           
           
           
             
          
       
         
       
         
       
         
         
     
       
          
         
       
         
       
         
         
         
       
       
         
      n a 
         
           
       

table    comparison numvc state of the art local search algorithms
bhoslib benchmark  bhoslib instances hidden optimal vertex cover 
whose size shown vc column 

   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

   

    

  

    

  

    

  

    
average run time  s 

average success rate

best performance hard random benchmark  vastly improving existing performance
results  observe that  numvc always minimum iqr value instances 
indicates apart efficiency  robustness numvc better solvers 

  
  
  
  
  

    
    
   

pls
cover
ewcc
numvc

   
   

  
 
    frb   

pls
cover
ewcc
numvc

   
    frb   

 
    frb   

     frb        frb         frb         frb   
number vertices graph

    frb   

     frb        frb         frb         frb   
number vertices graph

figure    comparison numvc local search algorithms bhoslib benchmark
terms success rate  left  averaged run time  right 
compare numvc cover ewcc challenging instance frb       
given failure pls large bhoslib instances  run pls instance 
comparative results frb       shown table    indicates numvc
significantly outperforms cover ewcc challenging instance 
finally  would remark performance numvc bhoslib benchmark
better four core version cls  pullan et al          even divide run time
numvc    the number cores utilized cls   consider machine speed ratio
divide run time numvc    numvc would dramatically better cls
bhoslib benchmark 
size
vc
    
    

suc
 
  

cover
avg suc time
n a
    

suc
 
  

ewcc
avg suc time
    
    

suc
 
  

numvc
avg suc time
    
    

table    comparative results frb       challenging instance  solver executed
    times instance timeout      seconds 

    comparison exact algorithms
section  compare numvc state of the art exact maximum clique algorithm 
generally  exact algorithms heuristic algorithms somewhat complementary
applications  usually  exact algorithms find solutions structured instances faster heuristic
algorithms faster random ones 
   

fic ai   u   l uo   attar

compared mvc mis  many exact algorithms designed maximum clique
problem  carraghan   pardalos        fahle        ostergard        regin        tomita  
kameda        li   quan      b      a   recent branch and bound mc algorithm maxclq
 li   quan      b  utilizes maxsat inference technologies  li  manya    planes       
improve upper bounds shows considerable progress  experimental results maxclq  li  
quan      b  random graphs dimacs instances indicate maxclq significantly
outperforms previous exact mc algorithms  maxclq algorithm improved using two
strategies called extended failed literal detection soft clause relaxation  resulting better
algorithm denoted maxclqdyn efl scr  li   quan      a   due great success
maxclqdyn efl scr  compare algorithm maxclqdyn efl scr 
compare numvc maxclqdyn efl scr dimacs benchmark instances 
results maxclqdyn efl scr taken previous work  li   quan      a  
maxclqdyn efl scr evaluated bhoslib benchmark much harder
requires effective technologies exact algorithms  li   quan      a  
run time results maxclqdyn efl scr obtained      ghz intel core   duo
cpu linux   gb memory  required       seconds r             seconds
r            seconds r      execute dimacs machine benchmarks  li   quan 
    a   corresponding run time machine                 seconds  so  multiply
reported run time maxclqdyn efl scr                                         
average two largest ratios   normalization based methodology established
second dimacs implementation challenge cliques  coloring  satisfiability 
widely used comparing different maxclique algorithms  pullan   hoos        pullan        li
  quan      b      a  
graph
instance
brock     
brock     
brock     
brock     
brock     
brock     
keller 
mann a  
mann a  

v c

   
   
   
   
   
   
   
   
   

numvc
suc
time
  
   
   
 
 
 
   
   
   

      
    
    
n a
n a
n a
    
      
     

maxclqdyn efl
 scr time
      
      
      
       
       
       
       
    
      

graph
instance

v c

numvc
suc
time

p hat     
p hat     
p hat     
p hat      
p hat      
p hat      
p hat      
sanr       
sanr       

   
   
   
   
   
    
    
   
   

   
   
   
   
   
   
   
   
   

     
     
     
     
     
    
     
      
     

maxclqdyn efl
 scr time
    
    
       
      
         
    
      
    
     

table    comparison numvc state of the art exact maxclique algorithm maxclqdyn efl scr dimacs benchmark 

table    present performance numvc maxclqdyn efl scr
dimacs instances  results indicate numvc finds optimal solution much faster
maxclqdyn efl scr random instances p hat sanr instances 
believe similar results would hold hard random benchmarks bhoslib ones 
maxclqdyn efl scr evaluated instances due high hardness  li   quan 
    a   numvc performs well them 
structured instances  note maxclqdyn efl scr mainly evaluated
brock instances numvc performs worst  open dimacs instances
   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

mann a    johnson       keller   remain difficult solve exact
algorithms  li   quan      a   although maxclqdyn efl scr overall performs better 
numvc finds optimal solution significantly faster maxclqdyn efl scr
structured instances  two brock instances keller  
finally  would note although heuristic solvers find optimal solutions fast 
unable prove optimality solutions find  hand  run time
exact algorithm spent finding optimal solution proving optimality 
sense  heuristic exact algorithms cannot compared fair way  nevertheless 
experiments suggest heuristic approaches appealing solving large instances reasonable
short time 

   discussions
section  first explore run time distribution numvc representative
instances  investigate effectiveness two stage exchange strategy
forgetting mechanism numvc  finally  analyze performance numvc different
settings two parameters forgetting mechanism  shows numvc
sensitive parameters 
    run time distributions numvc
subsection  conduct empirical study gain deeper insights run time behavior
numvc  specifically  study run time distribution numvc several representative
instances  purpose comparison  report run time distribution ewcc 
best competing mvc local search solver 
consider randomized algorithm solving given optimization problem instance  halting
soon optimal solution found  run time algorithm viewed
random variable  fully described distribution  commonly referred run time
distribution  rtd  literature algorithm performance modeling  hoos   stutzle       
bartz beielstein et al          methodology studying run time behavior algorithms
based rtds widely used empirical analysis heuristic algorithms  hoos   stutzle 
      finkelstein  markovitch    rivlin        watson  whitley    howe        pullan   hoos 
       follow methodology study here 
studying typical run time behaviour  choose instances numvc reaches optimal
solution     runs  appropriate difficulty  dimacs benchmark  select
brock      mann a    reasonable size hardness  also  two
instances represent two typical instance classes numvc  numvc poor performance
brock instances  dominates heuristic algorithms mann instances 
bhoslib benchmark  frb        frb        selected  appropriate
instances studying run time behavior numvc  since neither easy
solved short time difficult reach      success rate 
empirical rtd graphs numvc ewcc shown figure    the rtd
instance based     independent runs reach respective optimal solution   according
graphs  numvc shows large variability run time  investigation indicates
rtds quite well approximated exponential distributions  labeled ed m  x       x m  
median distribution  test goodness approximations  use
   

fic ai   u   l uo   attar

empirical rtd numvc ewcc mann a  

empirical rtd numvc ewcc brock     
 
   
   
   

 
   

rtd numvc
ed     
rtd ewcc
ed    

   
   
   
p solve 

p solve 

   
   

   

   

   

   

   

   

   

   

   

 
 
  

 

 

  

 

 

  
  
runtime  cpu sec 

  

 
 
  

 

  

empirical rtd numvc ewcc frb     

   
   

   

rtd numvc
ed    
rtd ewcc
ed    

   
   

 

 

  

 

  

rtd numvc
ed    
rtd ewcc
ed     

   
p solve 

p solve 

 

  
  
runtime  cpu sec 

 

   
   

   

   

   

   

   

   

   

   

   

 
 
  

 

  

empirical rtd numvc ewcc frb     

 
   

rtd numvc
ed    
rtd ewcc
ed     

 

  

 

  
runtime  cpu sec 

 

  

 
 
  

 

  

 

  

 

  
runtime  cpu sec 

 

  

 

  

figure    run time distributions  rtds  numvc ewcc applied two dimacs instances
 top  two bhoslib instances  bottom   empirical rtds well approximated
exponential distributions  labeled ed m  x       x m plots 

kolmogorov smirnov test  fails reject null hypothesis sampled run time
stems exponential distributions shown figures standard confidence level
       p values            ewcc  kolmogorov smirnov test
shows rtds mann a   two bhoslib instances exponential distributions 
rtd brock      exponential distribution 
observation exponential rtds numvc consistent similar results
high performance sls algorithms  e g   maxclique  pullan   hoos         sat  hoos  
stutzle         maxsat  smyth  hoos    stutzle         scheduling problems  watson
et al          arguments  hoos   stutzle        hoos   stutzle        made stochastic
local search algorithms characterized exponential rtd  conclude that  numvc 
probability finding optimal solution within fixed amount time  or steps  depend
run time past  consequently  robust w r t  cutoff time thus  restart
   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

time  therefore  performing multiple independent runs numvc parallel result closeto optimal parallelization speedup  similar observations made dimacs
instances bhoslib instances 
practical interest rtd analysis numvc difficult instances
algorithms experiments fail achieve high success rate  i e         rtds
cases would show algorithm stagnates suggest a posteriori restart time
algorithm  purpose  select mann a   frb        analysis  rtds
numvc two instances illustrated figure    interestingly  rtds
observe obvious stagnation  confirms numvc robust w r t  cutoff time
thus restart time  therefore  increasing cutoff time  expect higher success
rate algorithm difficult instances 
empirical rtd numvc mann a   frb     
 
   
rtd numvc mann a  
   
rtd numvc frb     
   

p solve 

   
   
   
   
   
   
 
 
  

 

 

  

  

 

  

runtime  cpu sec 

figure    run time distributions  rtds  numvc mann a   frb        instances 
numvc finds optimal  or best known  solution less half runs 

    effectiveness two stage exchange
study effectiveness two stage exchange strategy  compare numvc
alternative algorithm numvc  selects two vertices exchanging simultaneously 
step  numvc  first chooses uncovered edge e uniformly random  evaluates pair
vertices u v u current candidate solution v one endpoint e
conf change v       evaluating benefit  i e   decrement cost function 
exchanging vertex pair u v  numvc  first checks whether neighbors  u
v neighbors  benefit dscore u    dscore v    w e u  v    otherwise  benefit
dscore u    dscore v   numvc  selects vertex pair greatest benefit exchange 
numvc  and numvc    algorithm  two candidate vertices add
current candidate solution c  i e   endpoints selected uncovered edge   hence 
worst case  numvc performs      c  evaluations  numvc  evaluate    c 
pairs vertices  moreover  numvc needs check dscore vertex  vertex 
   

fic ai   u   l uo   attar

evaluation  numvc  performs vertex pair evaluation involves pair vertices
relationship  thus time consuming  based analysis  conjecture
complexity per step numvc least   times lower numvc    also 
mentioned section    two stage exchange strategy less greedy one selecting
two vertices exchanging simultaneously  numvc  does 
investigation carried   dimacs instances different families well
   bhoslib instances  dimacs benchmark  select brock       c       
mann a    p hat         instances different characteristics  described
 pullan et al          note following conclusions dimacs instances
complementary dimacs graphs 
dimacs brock instances minimum vertex covers consist medium lower
degree vertices  designed defeat greedy heuristics 
dimacs c p hat        instances minimum vertex covers consist
higher degree vertices effectively solved greedy heuristics 
dimacs mann instances large proportion plateaus instance searchspace  thus greedy heuristics unsuitable solve them 
bhoslib instances minimum vertex covers consisting vertices whose
distribution vertex degree closely matches complete graph  difficult
instances greedy diversification heuristics 
graph
instance
brock     
c      
mann a  
p hat       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       
frb       

v c
   
    
   
    
    
    
    
    
    
    
    
    
    
    
    
    

suc
  
   
   
   
   
   
  
  
   
   
   
  
   
  
  
  

time
   
   
  
    
  
   
   
   
   
  
   
   
   
   
    
   

numvc
steps
         
       
        
      
        
         
         
         
         
        
         
         
        
         
         
         

 steps sec       
    
   
    
   
   
   
   
   
   
   
   
   
   
   
   
   

suc
  
   
   
   
   
   
  
  
   
   
  
  
   
  
  
  

time
    
   
   
     
  
   
    
    
   
   
    
    
   
    
    
    

numvc 
steps
         
       
         
      
        
         
         
         
         
        
         
         
        
         
         
         

 steps sec       
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

table    comparative performance numvc numvc  selects two vertices
exchanging simultaneously  results based     independent runs solver
instance 
comparative results numvc numvc  presented table    results show
numvc significantly outperforms numvc  terms averaged run time  primarily due
much lower complexity per step  second  numvc performs     times steps
   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

numvc    supports conjecture complexity per step numvc  
times lower numvc   
turn attention comparing numvc numvc  terms step performance 
independent complexity per step  brock mann graphs difficult
greedy heuristics  numvc significantly better step performance numvc   
hand  greedy friendly graphs c       p hat         numvc needs
steps converge optimal solution numvc  does  observations support
argument two stage exchange strategy less greedy one selects two vertices
exchanging simultaneously  numvc  does 
observe step performance numvc  better numvc
bhoslib instances  instance  bhoslib instances algorithms
     success rate  numvc needs     times steps numvc  find optimal
solution  expect cannot yet explain  nevertheless  numvc makes
rather rapid modifications solution  little degrade step performance hurt 
graph
instance
c      
mann a  
p hat       
frb       
frb       
frb       

pls
 steps sec
      
         
       
       
       
       

cover
 steps sec
     
       
      
       
       
       

ewcc
 steps sec
      
       
      
       
       
       

numvc
 steps sec
      
         
       
       
       
       

table    complexity per step selected instances
demonstrate low complexity per step numvc  compare number
search steps per second numvc state of the art heuristic solvers
representative instances  indicated table    numvc executes many steps second
two mvc local search solvers cover ewcc do  instances table
   second numvc executes     times steps cover      times steps
ewcc  indicates two stage exchange strategy significantly accelerate mvc
local search algorithms  although pls performs steps per second numvc  mc
local search algorithm whose search scheme essentially different mvc local search
algorithms 
    effectiveness forgetting mechanism
study effectiveness forgetting mechanism numvc  compare numvc
two alternative algorithms numvc  numvc    obtained numvc modifying
edge weighting scheme below 
numvc  works way numvc  except using forgetting mechanism 
is  deleting line    algorithm   
numvc  adopts forgetting mechanism used dls mc  pullan   hoos       
weighting scheme  specifically  numvc  increases weights uncovered edges
   

fic ai   u   l uo   attar

one end step  performs forgetting operation every pd steps decreasing
weights one edges whose weights greater one  note pd instancedependent parameter 
experiments carried representative instances benchmarks 
dimacs benchmark  select brock       c        keller   mann a   
different classes appropriate difficulty  bhoslib benchmark 
select three instances three largest sized instance groups respectively 
graph
instance vertices
brock     
   
c      
    
keller 
    
mann a  
    
frb       
    
frb       
    
frb       
    
frb       
    
frb       
    
frb       
    
frb       
    
frb       
    
frb       
    

c

v
   
    
    
   
    
    
    
    
    
    
    
    
    

numvc
suc time
  
   
   
   
        
   
  
  
   
   
   
   
  
   
   
  
   
   
   
  
   
       
  
   

numvc 
suc time
       
   
   
        
       
  
   
   
   
   
  
  
   
       
   
   
       
       
  
   

numvc 
pd        suc time
      
  
      
   
            
     
   
   
  
   
       
   
       
  
   
  
   
   
  
   
       
   
   
  
   
   
       
   
  
   

table    comparative performance numvc two alternatives numvc  numvc   
algorithm performed     times instance 

apparent observation table   two algorithms forgetting mechanisms
 i e   numvc numvc    outperform numvc  almost instances  particularly  due
missing forgetting mechanism  numvc  performs significantly worse two
algorithms brock mann graphs  hand  table   demonstrates numvc
numvc  exhibit competitive performance bhoslib benchmark  dominate different
types dimacs instances  specifically  numvc outperforms numvc  c       
keller  mann a    performs significantly worse numvc  brock      
order find genuine performance numvc  brock instances  test numvc 
larger brock      brock      instances  results show two large brock
instances substantially difficult two brock    instances  numvc  fails
solve neither them 
although numvc  shows competitive performance numvc  performance given
optimizing pd parameter instance  moreover  dls mc  pullan   hoos        
numvc  considerably sensitive pd parameter  example  experiments show
frb      instances  numvc  performs quite well pd          fails find
optimal solution pd set value less       comparatively  numvc
   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

parameter setting performs quite well types instances brock family  actually 
show next section numvc sensitive parameters 
interesting compare numvc alternatives replace forgetting
mechanism smoothing techniques similar local search sat  indeed  earlier
versions numvc use smoothing techniques similar sat local search 
good performance compared numvc  would interesting find
reasons success forgetting mechanism failure smoothing techniques
mvc edge weighting local search algorithms numvc 
    parameters forgetting mechanism

     v        
     v        
     v        
     v        
     v        

brock     
          
          
          
         
         

mann a  
          
          
          
          
         

c      
          
          
          
          
          

frb       
         
         
          
         
          

frb       
          
          
          
          
          

frb       
          
         
         
          
          

frb       
         
          
         
          
         

     v        
     v        
     v        
     v        
     v        

          
         
          
         
         

          
          
          
          
          

          
          
          
          
          

         
         
          
          
          

          
          
          
          
          

         
         
         
         
         

          
         
          
          
          

     v        
     v        
     v        
     v        
     v        

          
         
         
         
         

          
         
         
          
          

          
          
          
          
          

          
          
         
         
         

          
          
          
          
          

         
         
          
         
         

          
          
         
          
         

     v        
     v        
     v        
     v        
     v        

          
         
         
          
         

          
          
         
          
          

          
          
          
          
          

          
         
          
         
         

          
          
          
          
          

          
         
         
          
          

         
          
         
          
          

     v        
     v        
     v        
     v        
     v        

          
         
         
          
         

         
          
          
          
         

          
          
          
          
          

          
          
         
         
          

          
          
          
          
          

          
         
         
          
         

         
         
         
         
          

table     comparative performance numvc various parameter combinations     
forgetting mechanism  instance  numvc performed    times
parameter combination  except one adopted work      v         
results based     runs  keller   numvc performs almost
various parameters  success rate        tiny difference averaged
run time  less   second   thus results reported table 

   

fic ai   u   l uo   attar

numvc algorithm two parameters   specify forgetting mechanism 
specifically  averaged weight edges achieves threshold   edge weights
multiplied constant factor            subsection  investigate numvc
performs different settings two parameters  investigation carried
dimacs bhoslib benchmarks  dimacs benchmark  select four instances
used preceding subsection reasons  bhoslib benchmark  select
frb         frb         frb        frb         different sizes
appropriate hardness 
table    presents performance numvc various parameter combinations
representative instances  see table     parameter combination
     v         yields relatively good performance instances  exhibits better robustness
instances parameter combinations do 
hand  observe numvc various parameter combinations performs
comparably tested instances  example  parameter settings  numvc achieves
success rate      keller   mann a    c       well frb        
averaged run time difference instances significant  instances 
difference success rate never exceeds     two parameter settings  observation
indicates numvc seems sensitive two parameters  actually  mentioned
before  numvc exhibits good performance dimacs bhoslib benchmarks
fixed parameter setting  advantage compared forgetting mechanisms
one used dls mc  pullan   hoos         sensitive parameter 
algorithms sensitive parameters  considerable parameter tuning required order
get good performance certain instance  usually costs much time solving
instance 

   conclusions future work
paper  presented two new local search strategies minimum vertex cover  mvc 
problem  namely two stage exchange edge weighting forgetting  two stage exchange
strategy yields efficient two pass move operator mvc local search algorithms 
significantly reduces time complexity per step  forgetting mechanism enhances
edge weighting scheme decreasing weights averaged weight reaches threshold 
periodically forget earlier weighting decisions  based two strategies  designed
slight  yet effective mvc local search algorithm called numvc  numvc algorithm
evaluated best known heuristic algorithms mvc  mc  mis  standard benchmarks 
i e   dimacs bhoslib benchmarks  experimental results show numvc
largely competitive dimacs benchmark dramatically outperforms state of the art
heuristic algorithms bhoslib instances 
furthermore  showed numvc characterized exponential rtds  means
robust w r t  cutoff parameters restart time  hence close to optimal parallelization
speedup  performed investigations provide insights two new
strategies effectiveness  finally  conducted experiment study performance
numvc different parameter settings  results indicate numvc sensitive
parameters 
   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

two stage exchange strategy lower time complexity per step 
flexibility allow us employ specific heuristics different stages  interesting research
direction thus apply idea combinatorial problems whose essential tasks
seek optimal subset fixed cardinality 

acknowledgments
work supported     program     cb        arc future fellowship ft        
national natural science foundation china                               
fundamental research funds central universities china             would
thank editor anonymous reviewers valuable comments earlier versions
paper  would thank yanyan xu proofreading paper 

references
aggarwal  c   orlin  j     tai  r          optimized crossover independent set problem 
operations research             
andrade  d  v   resende  m  g  c     werneck  r  f  f          fast local search maximum
independent set problem  workshop experimental algorithms  pp         
barbosa  v  c     campos  l  c  d          novel evolutionary formulation maximum
independent set problem  j  comb  optim                
bartz beielstein  t   chiarandini  m   paquete  l     preuss  m   eds            experimental
methods analysis optimization algorithms  springer  berlin  heidelberg  new
york 
battiti  r     protasi  m          reactive local search maximum clique problem 
algorithmica                
busygin  s   butenko  s     pardalos  p  m          heuristic maximum independent set
problem based optimization quadratic sphere  j  comb  optim                
cai  s     su  k          local search configuration checking sat  proc  ictai    
pp       
cai  s     su  k          configuration checking aspiration local search sat  proc 
aaai     pp         
cai  s   su  k     chen  q          ewls  new local search minimum vertex cover  proc 
aaai     pp       
cai  s   su  k     sattar  a          local search edge weighting configuration checking
heuristics minimum vertex cover  artif  intell                       
cai  s   su  k     sattar  a          two new local search strategies minimum vertex cover 
proc  aaai     pp         
carraghan  r     pardalos  p          exact algorithm maximum clique problem 
operations research letters               
   

fic ai   u   l uo   attar

dinur  i     safra  s          hardness approximating minimum vertex cover  annals
mathematics                 
evans  i          evolutionary heuristic minimum vertex cover problem  proceedings
seventh international conference evolutionary programming ep   pp         
fahle  t          simple fast  improving branch and bound algorithm maximum clique 
proc  european symposium algorithms  esa      pp         
feige  u          approximating maximum clique removing subgraphs  siam j  discrete math  
              
finkelstein  l   markovitch  s     rivlin  e          optimal schedules parallelizing anytime
algorithms  case shared resources  j  artif  intell  res   jair             
gajurel  s     bielefeld  r          fast near optimal vertex cover algorithm  novca  
international journal experimental algorithms  ijea          
garey  m     johnson  d          computers intractability  guide theory npcompleteness  freeman  san francisco  ca  usa 
glover  f          tabu search part i  orsa journal computing               
grosso  a   locatelli  m     pullan  w  j          simple ingredients leading efficient
heuristics maximum clique problem  j  heuristics                
halperin  e          improved approximation algorithms vertex cover problem graphs
hypergraphs  siam journal computing                  
hastad  j          clique hard approximate within n    acta math              
hastad  j          optimal inapproximability results  j  acm                
hoaglin  d  c   mosteller  f     tukey  j  w   eds            understanding robust exploratory
data analysis  wiley classics library  wiley  new york  ny 
hoos  h     stutzle  t          stochastic local search  foundations applications  morgan
kaufmann  san francisco  ca  usa 
hoos  h  h     stutzle  t          towards characterisation behaviour stochastic local
search algorithms sat  artif  intell                    
hutter  f   tompkins  d  a  d     hoos  h  h          scaling probabilistic smoothing  efficient
dynamic local search sat  proc  cp     pp         
ishtaiwi  a   thornton  j   sattar  a     pham  d  n          neighbourhood clause weight
redistribution local search sat  proc  cp     pp         
johnson  d  s     trick  m   eds            cliques  coloring  satisfiability  second dimacs
implementation challenge        vol     dimacs series discrete mathematics
theoretical computer science  american mathematical society  providence  ri  usa 
karakostas  g          better approximation ratio vertex cover problem  proc 
icalp     pp           
katayama  k   sadamatsu  m     narihisa  h          iterated k opt local search maximum
clique problem  proc  evocop     pp       
   

fin u mvc  n e fficient l ocal earch lgorithm inimum v ertex c

li  c  m   manya  f     planes  j          new inference rules max sat  j  artif  intell  res 
 jair              
li  c  m     quan  z       a   combining graph structure exploitation propositional reasoning
maximum clique problem  proc  ictai     pp         
li  c  m     quan  z       b   efficient branch and bound algorithm based maxsat
maximum clique problem  proc  aaai     pp         
michiels  w   aarts  e  h  l     korst  j  h  m          theoretical aspects local search  springer 
minton  s   johnston  m  d   philips  a  b     laird  p          minimizing conflicts  heuristic
repair method constraint satisfaction scheduling problems  artif  intell               
    
morris  p          breakout method escaping local minima  proc  aaai     pp 
     
ostergard  p  r  j          fast algorithm maximum clique problem  discrete applied
mathematics                   
papadimitriou  c  h          selecting satisfying truth assignment  proc  focs     pp 
       
pullan  w          phased local search maximum clique problem  j  comb  optim         
       
pullan  w          optimisation unweighted weighted maximum independent sets minimum
vertex covers  discrete optimization            
pullan  w     hoos  h  h          dynamic local search maximum clique problem  j  artif 
intell  res   jair              
pullan  w   mascia  f     brunato  m          cooperating local search maximum clique
problem  j  heuristics                
regin  j  c          using constraint programming solve maximum clique problem  proc 
cp     pp         
richter  s   helmert  m     gretton  c          stochastic local search approach vertex cover 
proc  ki     pp         
schuurmans  d   southey  f     holte  r  c          exponentiated subgradient algorithm
heuristic boolean programming  proc  ijcai     pp         
shyu  s  j   yin  p     lin  b  m  t          ant colony optimization algorithm minimum
weight vertex cover problem  annals or                   
smyth  k   hoos  h  h     stutzle  t          iterated robust tabu search max sat  proc 
canadian conference ai     pp         
taillard  e  d          parallel taboo search techniques job shop scheduling problem 
informs journal computing               
thornton  j   pham  d  n   bain  s     jr   v  f          additive versus multiplicative clause
weighting sat  proc  aaai     pp         
   

fic ai   u   l uo   attar

tomita  e     kameda  t          efficient branch and bound algorithm finding maximum
clique computational experiments  j  global optimization             
watson  j  p   whitley  l  d     howe  a  e          linking search space structure  run time
dynamics  problem difficulty  step toward demystifying tabu search  j  artif  intell 
res   jair              
wu  q   hao  j  k     glover  f          multi neighborhood tabu search maximum weight
clique problem  annals or                 
wu  z     wah  b  w          efficient global search strategy discrete lagrangian methods
solving hard satisfiability problems  proc  aaai iaai     pp         
xu  k   boussemart  f   hemery  f     lecoutre  c          simple model generate hard
satisfiable instances  proc  ijcai     pp         
xu  k   boussemart  f   hemery  f     lecoutre  c          random constraint satisfaction  easy
generation hard  satisfiable  instances  artif  intell                    
xu  k     li  w          exact phase transitions random constraint satisfaction problems  j 
artif  intell  res   jair             
xu  k     li  w          many hard examples exact phase transitions  theoretical computer
science              
yugami  n   ohta  y     hara  h          improving repair based constraint satisfaction methods
value propagation  aaai  pp         
zuckerman  d          linear degree extractors inapproximability max clique
chromatic number  proc  stoc     pp         

   


