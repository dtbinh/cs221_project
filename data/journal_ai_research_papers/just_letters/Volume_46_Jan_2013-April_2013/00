journal artificial intelligence research               

submitted        published      

short long supports constraint propagation
peter nightingale
ian p  gent
christopher jefferson
ian miguel

pwn  st andrews ac uk
ian gent st andrews ac uk
caj   st andrews ac uk
ijm st andrews ac uk

school computer science  university st andrews 
st andrews  fife ky    sx  uk

abstract
special purpose constraint propagation algorithms frequently make implicit use short
supports examining subset variables  infer support  a justification
variable value pair may still form part assignment satisfies constraint 
variables values save substantial work short supports
studied right  two main contributions paper identification short supports important constraint propagation  introduction
haggisgac  efficient effective general purpose propagation algorithm exploiting short supports  given complexity haggisgac  present optimised
version simpler algorithm shortgac  although experiments demonstrate efficiency shortgac compared general purpose propagation algorithms
compact set short supports available  show theoretically experimentally
haggisgac even better  find haggisgac performs better
gac schema full length supports  introduce variant algorithm haggisgacstable  adapted avoid work backtracking cases faster
significant reductions memory use  proposed algorithms excellent
propagating disjunctions constraints  experiments disjunctions found
algorithms faster constructive gac schema least order
magnitude  three orders magnitude 

   introduction
constraint solvers typically employ systematic backtracking search  interleaving choice
assignment decision variable propagation constraints determine
consequences assignment made  propagation algorithms broadly divided
two types  first specialised reason efficiently constraint patterns
occur frequently models  examples include global cardinality constraint  regin 
      element constraint  gent  jefferson    miguel      b   feasible
support every possible constraint expression specialised propagator way 
case general purpose constraint propagators  gac schema  bessiere   regin 
       gac          bessiere  regin  yap    zhang         str   lecoutre       
mddc  cheng   yap        used  typically expensive specialised
propagators important tool specialised propagator available 
support constraint domain value variable justification value
may still form part assignment satisfies constraint  usually given terms
set literals  variable value pairs corresponding possible assignments
c
    
ai access foundation  rights reserved 

finightingale  gent  jefferson    miguel

variables constraint  one efficiencies typically found specialised propagators
use short supports  examining subset variables  infer support
variables values save substantial work  use typically implicit 
i e  achieved specialised algorithm examine variables
cases  one contributions highlight general importance short supports 
example  consider element constraint xy   z  x    x    x                
z              constraint satisfied iff element position vector  x    x    x   
equals z  consider set literals    x            z       set clearly satisfies
definition constraint xy   z  contain literal variable 
extension valid literals variables x  x  support  example
short support 
previous work introduced shortgac  nightingale  gent  jefferson    miguel 
       general purpose propagation algorithm exploits short supports  introduction shortgac  general purpose propagators relied upon supports involving
variables  paper develop concept introduce new algorithm
haggisgac   consistently efficient shortgac  available 
use compact sets short supports allows haggisgac outperform greatly existing general purpose propagation algorithms  cases  haggisgac even approaches
performance special purpose propagators  haggisgac well suited
propagating disjunctions constraints  outperforms traditional constructive
algorithm  lagerkvist   schulte        wurtz   muller        orders magnitude 
haggisgac efficient gac schema full length supports 
describe variant  haggisgac stable  supports need deleted
backtracking  applied full length supports  version greatly reduced memory
usage 
shortgac  haggisgac haggisgac stable instantiated function named findnewsupport  and similar gac schema way   function
specific constraint  generate short supports procedurally  alternatively 
generic findnewsupport retrieve short supports data structure 
section   presents necessary background  section   introduces concept
short support  section   outlines basic idea used deal implicit supports
throughout paper  section   gives full details shortgac  including complexity
key operations alternative implementations short supports provided list
form  section   presents new algorithm haggisgac development shortgac 
shortgac haggisgac evaluated experimentally section    section  
describes haggisgac stable  corresponding experiments section    finally 
sections       discuss related work present conclusions 

   haggisgac named legendary wild haggis scotland  short legs long
legs walking around hills  namesake  haggisgac copes full length shorter
supports originates scotland  details wild haggis found wikipedia  http 
  en wikipedia org wiki wild haggis  veterinary record  king  cromarty  paterson   
boyd        

 

fishort long supports constraint propagation

   supports  gac  triggers
constraint satisfaction problem  csp  defined set variables x  function
maps variable domain    x  z domain finite set  set
constraints c  constraint c c relation subset variables x 
scope constraint c  named scope c   set variables c constrains 
solution csp function   x z maps variable x x value
d x   every constraint c c  values scope c  form tuple
c  i e  constraint satisfied   
systematic search solution csp  values progressively removed
domains d  therefore  distinguish initial domains current
domains  function refers current domains unless stated otherwise  literal
defined variable value pair  written x   v  literal x   v valid v
current domain x  i e  v d x   
definition       support  support constraint c domains defined
set valid literals contains exactly one valid literal variable scope c 
satisfies c  necessary disambiguation  call support full length
support simply long support  contrast short supports defined later 
property commonly established constraint propagation algorithms generalised
arc consistency  gac   mackworth         constraint c gac exists
full length support every valid literal every variable scope c   gac established
identifying literals x   v full length support exists removing v
domain x  consider algorithms establishing gac paper 
gac propagation algorithm usually situated systematic search  hence 
must operate three contexts  initialisation  at root node   support established
scratch  following deletion one domain values  as result branching
decision and or propagation constraints   support must re established
selectively  upon backtracking  data structures must restored correct
state point search  primary focus second context  operation
following value deletion  although discuss efficient backtracking section   
gac propagation algorithm would typically called deleted domain value
turn  algorithm called domain value  constraint
gac 
propagation algorithms present concept active support  inspired
gac schema  bessiere   regin         active support support currently
use support set literals  literal set active supports support
it  active support found invalid  removed  set
literal empty  say literal lost support  new support sought literal 
found new support becomes active  new support found  literal
support deleted 
propagation algorithms present  efficiency make use watched literals
provided minion  gent et al       b   propagators need called every
deleted domain value establish gac  say propagators attach remove triggers
literals  domain value v variable x deleted  propagator called
 

finightingale  gent  jefferson    miguel

trigger attached literal x   v  means literal
deleted attached trigger  zero work incurred  emphasise
use watched literals fundamental work  available
given solver  algorithms need minor adaptation  called literal
removal  may return immediately literal active support 
checked time o     thus algorithms fit traditional fine grained scheme
 bessiere   regin        except cases invoked
use watched literals 

   short supports
concept short support generalisation full length support  defined below 
definition       short support  short support constraint c domains
defined set valid literals x   v x scope c   x occurs s 
every superset contains one valid literal variable scope c 
full length support  strict short support short support full length
support 
definition short support includes extremes  empty set short support constraint entailed  i e  every tuple scope c  within satisfies
constraint   similarly  every full length support necessarily short support 
superset itself  case studies see examples empty short
supports short supports happen full length 
short supports used maintain gac  full length support 
short support provides gac support literal contained within it  call
explicit support literals  new feature short support provides
support valid literals variables contained short support 
because  definition  every valid extension short support cover variables
scope c  full length support  say short support gives implicit gac support
valid literals variables short support 
define concept complete set short supports constraint 
definition       short support set  short support set s c  d  set short supports
constraint c domains d  every full length support c
 not necessarily strict  superset least one short support   s c  d  
constraint may many short support sets  gives us latitude implement one efficient compute 
natural ask identify correct short supports given constraint c 
simple fundamental result given lemma     
lemma      given constraint c domains d  empty set    short support
c iff gac propagation constraint not c  leads empty domain 
proof     short support every valid assignment variables scope c 
satisfies c  every assignment satisfies c iff every assignment violates not c   every assignment violates not c   gac propagation constraint not c  leads empty
 

fishort long supports constraint propagation

domain  complete last equivalence  note assignment violate
not c   literals assignment supported  gac propagation cannot cause
empty domain 
lemma two important consequences  first  check short support
correctness  empty support  check short support    x    v            xk  
vk    simply set d x       v             d xk      vk    assignments extend s 
short support iff    is  lemma     applies check correctness
propagating not c  seeing domain emptied 
second consequence negative  however  determining whether gac propagation
empty domain polynomially equivalent actually performing gac propagation
 bessiere  hebrard  hnich    walsh         since constraints np hard gac
propagate  follows easy even check empty set short support 
thus cannot expect find method fast general finding short
supports constraint 
given provable difficulty finding short supports set full length supports 
construct sets short supports specifically three experimental case studies
section    focus paper show value strict short supports
given system  situation analogous important area
constraints  namely exploiting symmetries constraint problems  gent  petrie 
  puget         large majority research assumed sets symmetries
provided system  even though finding sets hard  inhibited
research exploiting symmetry  within automated detection symmetry
become important subarea  mears        puget         however leave automated
construction compact short support sets future research  analogously patterns
matrix symmetries  flener  frisch  hnich  kiziltan  miguel  pearson    walsh        
least identify pattern often lets us identify strict short supports 
describe 
    short supports disjunction
strict short supports arise naturally disjunctions  constraint expressed
disjunction shorter constraints  set strict short supports constructed
it  suppose following constraint 
c x    x    x    x    c   x    x    c   x    x    c   c    x   
suppose    x       x       valid assignment satisfies c    satisfy
c    satisfy c regardless values x  x    therefore    x       x      
strict short support c 
lemma      given constraint c  domain set d  set constraints  c        ck  
ci  c        ck     scope ci   scope c  c c  ck   following short support
set  where write fls ci   d  mean full length supports ci w r t  domains d  
s c  d     s   fls c    d  fls ck   d  
 

finightingale  gent  jefferson    miguel

proof   a  element s c  d  short support according definition    
semantics disjunction   b  s c  d  short support set definition      every fulllength support c must satisfy disjunct ci   therefore full length support contains
full length support ci included s c  d  
lemma     allows short support set created disjunction  given initial
domains  two three case studies  for third  set prohibitively
large  
using similar approach lemma     create function generates short
supports demand  function takes valid literal x   v current domains
d  returns short support supports x   v  explicitly implicitly   null
none exists  function constructed follows  create new domains d 
d   x     v   otherwise d  identical d  disjunct satisfiable d   
function returns null  otherwise  function picks disjunct ck satisfiable
d    returns satisfying assignment ck valid d   
three case studies section    created function follows scheme
optimisations 
propagating disjunctions recognised important topic  many papers
published area  wurtz   muller        lhomme        lagerkvist   schulte 
      jefferson  moore  nightingale    petrie         exploiting strict short supports
algorithms shortgac  haggisgac haggisgac stable allows us outperform
traditional constructive algorithm  wurtz   muller        orders magnitude 
    backtrack stability short supports
within search tree  propagation algorithms often spend significant time backtracking
data structures  reducing eliminating backtracking improve efficiency  example 
avoiding backtracking triggers speed simple table propagator   times
 gent et al       b   mac   mac   much efficient  in space
time  backtracking avoided  regin         two potential advantages
reducing use backtracking state  saves time restoring data structures  saves
space avoiding storing supports backtrack stack 
definition       backtrack stable  short support constraint c current domains
backtrack stable iff always remains short support  according definition     
backtracking search tree 
short support may support variable x implicitly  backtrack may
add values back domain x consistent s  meaning
longer meets definition short support  give example below 
example      consider constraint b  x    y  boolean variable b  array
variables variables x y  b assigned false  constraint entailed 
empty short support used support literals m  x y 
support backtrack stable  backtracking true restored domain
b  empty set longer short support 
 

fishort long supports constraint propagation

support full length backtrack stable  whenever support valid
supports literals contains  backtrack stable supports always exist use
full length supports cases  as gac schema   although may much longer
necessary 
section   exploit backtrack stability define new algorithm 

   shortgac  overview
section summarises key ideas shortgac propagation algorithm  along
illustrative example  
shortgac maintains set short supports sufficient support valid literals
variables scope constraint propagating  refer active
supports  algorithm rests exploiting observation that  using short supports 
support established literal two ways  first  usual  short support
contains literal supports literal  second  literal x   v supported short
support contains literal variable x  hence  short supports
support x   v contain literal x   w value w    v 
following data structures central operation shortgac algorithm 
numsupports total number active short supports 
supportspervar array  indexed  x   indicating number active short supports
containing variable x 
supportlistperlit array  indexed  x   v   lists active short supports containing literal x   v 
number supports containing variable x less total number
supports exists support contain x  therefore  supports
literals x  algorithm spends time processing variables whose literals
known supported way  variables involved active supports
seek support literals active supports 
illustrate  consider element example introduction  xy   z 
x    x    x                 z              constraint satisfied iff element
position vector  x    x    x    equals z  suppose current state shortgac storing
one support     x            z       data structures follows 
indicates literal valid  
   details present different presented previously  nightingale et al         
optimised data structures algorithms compared previous work  two
significant changes are  longer keep count supports per literal  saving overhead maintaining
this  data stored one dimensional vector literal  instead two dimensional array
variable value  saving space variables constraint different domain sizes  experiments
appendix demonstrate algorithms data structures presented perform better
previous implementation 
   clarity  presented one dimensional array supportlistperlit two dimensional format 

 

finightingale  gent  jefferson    miguel

supports 
supportlistperlit 
value
 
 
 
 
supportspervar 
numsupports 

x 
          z
variable
x  x 

       a 
     
  
     
  


 
 
 
 

a 
x 
  
 a 
  

 

   
z
  
 a 
  
  
 

values x  x  support  since supportspervar counters
less numsupports  therefore shortgac algorithm ignore x  x 
look new supports x    z  consider finding new support literals
z  shortgac ignore literals least one support case z     
algorithm looks literals z   supportlistperlit z  a        here  z    
literal  shortgac seeks new support it  possible new support
b    x            z       following discovery  update data structures 
supports 
supportlistperlit 
value
 
 
 
 
supportspervar 
numsupports 

a 
b 
x 
  
 a 
  

 

x 
          z
x 
          z
variable
x 
x 

 b      a 
  
    b 
  
  
  



 
 
 
 

   
   
z
 b 
 a 
  
  
 

variable x  fully supported  since supportspervar x      numsupports 
remain three literals support established       z     z     
first two shortgac finds supports c    x            z     
   x            z       support exists z        deleted  giving 
supports 

supportlistperlit 
value
 
 
 
 
supportspervar 
numsupports 

a 
b 
c 
d 
x 
  
 a 
 c 

 

          z
          z
          z
          z
variable
x 

 d   a  c 
  
 b 
  
 d 


 
 
 

x 
x 
x 
x 
x 
 b 
  
  

 

   
   
   
   
z
 b  d 
 a 
 c 

 

valid literals supported  nothing need done change
state  removal value branching decision propagation 
 

fishort long supports constraint propagation

   shortgac  details
key tasks implementing shortgac are  data structure update  iteration
variables supportspervar equals numsupports  iteration unsupported
values variable  section describes infrastructure allows us perform
tasks efficiently 
    shortgac data structures
active short support arity k provides explicit support k literals
contains  therefore  reference must appear k lists supportlistperlit 
this  represent two types object  shortsupport shortsupportcell 
shortsupport object contains k shortsupportcell objects  contains literal
x   v   reference parent shortsupport  elements array supportlistperlit doubly linked lists shortsupportcells  reference parent
shortsupport  iterate active short supports given literal 
algorithm iterates variables x supportspervar x  equals numsupports 
following data structure represents partition variables number supports  allows constant time size checking linear time iteration cell
partition  allows variable moved adjacent cell  i e  number
supports increases decreases    constant time  inspired indexed
dependency array gecode  schulte   tack        
varsbysupport array containing permutation variables  variables ordered
non decreasing number active supports  supportspervar x   
supportnumlowidx array integers  indexed   number literals 
maximum number active supports possible  either supportnumlowidx i 
smallest index varsbysupport active supports   when
variables  supportnumlowidx i   k k total number variables 
k acts sentinel value  set variables supports is 
varsbysupport supportnumlowidx i        supportnumlowidx i        
initially  variables   active supports  supportnumlowidx        rest
array set k 
following table illustrates partition data structure works  on different
example    variables   suppose supportspervar x    changed      x  y 
 boxed  swapped varsbysupport cell boundary moved x 
lower cell  consequently  supportnumlowidx    incremented   
varsbysupport  
supportspervar
x  updated

w 
 
w 

w 
 
w 

y 
 
x 

x 
 
x 

x 
 
y 

y 
 
y 

y 
 
y 

x 
 
x 

z 
 
z 

z 
 
z 

z 
 
z 

   literal x   v represented using single integer i  mapping x   v i 
allows o    access x v vice versa 

 

finightingale  gent  jefferson    miguel

require  sup  shortsupport
   sc  shortsupportcell sup
  
 x   v  sc literal
  
supportlistperlit x   v      
  
attachtrigger x   v 
  
add sc doubly linked list supportlistperlit x   v 
  
supportspervar x   
  
sx supportspervar x 
  
cellend supportnumlowidx sx   
  
swap x  varsbysupport cellend   
   
supportnumlowidx sx       numsupports  

procedure    addsupport sup 
variable x supportspervar x    numsupports  shortgac iterates
values zero explicit supports  avoid iterating values  use set data
structure 
zerolits array  indexed  x   stacks containing literals variable x zero
explicit support  particular order 
inzerolits array  indexed  x   v   booleans indicating whether literal x  
v zerolits x  
supportlistperlit x   v  reduced empty list  inzerolits x   v 
false x   v pushed onto zerolits x   and inzerolits x   v  set true  
optimisation  values eagerly removed set  removed lazily
set iterated  also  set backtracked  iteration  non zero value
removed swapping top stack  popping  lazy maintenance never
costs work overall because  value would removed eagerly 
removed next time set iterated  costing o     save work  may
never iterate list value would restored set again 
use free list manage set shortsupport objects avoid cost unnecessary object construction destruction  shortsupport object retrieved free list
may contain shortsupportcell objects  use resizable vector data structure 
size ever increased 
    adding deleting supports
support added deleted  data structures described must
updated  done procedures    addsupport     deletesupport  
procedures iterate given short support  literal update
supportlistperlit  supportspervar  varsbysupport supportnumlowidx  procedure  
inserts literal zerolits necessary  briefly explain maintenance varsbysupport become important section      suppose adding support
literal x   v procedure    additional support  x must moved
next cell varsbysupport  line   finds end cell x in  swap x
  

fishort long supports constraint propagation

require  sup  shortsupport
   sc  shortsupportcell sup
  
 x   v  sc literal
  
remove sc doubly linked list supportlistperlit x   v 
  
supportspervar x    
supportlistperlit x   v      
  
removetrigger x   v 
  
inzerolits x   v 
  
inzerolits x   v  true
  
zerolits x  push x   v 
   
sx supportspervar x 
   
cellend supportnumlowidx sx    
   
swap x  varsbysupport cellend   
   
supportnumlowidx sx      
    numsupports  

procedure    deletesupport sup 

require  x    v  where v pruned domain x 
   supportlistperlit x   v       
  
deletesupport supportlistperlit x   v  pop   
   repeat
  
continueloop false
  
 supportnumlowidx numsupports       supportnumlowidx numsupports      
  
varsbysupport i 
  
shortgac variableupdate y    true
  
continueloop true
  
break loop line  
    continueloop   false

procedure    shortgac propagate  propagate x    v 

end cell using subroutine swap xi   xj    simple procedure  not given  locates
swaps two variables varsbysupport  leaving variables unaffected 
makes use second array  varsbysupinv  inverse mapping varsbysupport 
done this  cell boundary decremented  in new position   x
higher cell  another point note addsupport add trigger x   v
sup active explicit support contain literal  deletesupport
remove trigger deleted support support 
finally  note special purpose methods undo changes
backtracking  backtracking past point support added  simply
call deletesupport  similarly call addsupport backtrack past supports
deletion 
  

finightingale  gent  jefferson    miguel

require  variable x
    x   v  zerolits x 
  
supportlistperlit x   v       
  
remove  x   v  zerolits x 
  
else
  
v d x 
  
sup findnewsupport x   v 
  
sup   null
  
prune x   v 
  
else
   
addsupport sup 
   
supportlistperlit x   v       
   
remove  x   v  zerolits x 
   
return true
    return false

procedure    shortgac variableupdate   x   pseudocode abstract
detailed maintenance zerolits inzerolits data structures  might seem
test line    must always succeed  however  although sup must support x   v 
contain x   v might implicit support  findnewsupport
function discussed section     
    propagation algorithm
shortgac propagator  procedure    invoked literal contained
one active short supports pruned   first deletes supports involving
pruned literal  checks variables implicitly supported  i e 
supportspervar y  numsupports  line     variable checked procedure  
 shortgac variableupdate  described below   call results new support
found  data structures changed  shortgac variableupdate y  returns
true indicate this  must break for all loop  line    go round again 
iteration therefore continues either new support necessary new support
found 
shortgac variableupdate  procedure    used check status every variable
lacking implicit support  iterates zerolits  i e  literals variable might
zero explicit supports  since zerolits maintained lazily  iteration first
check literal indeed explicit support  correct zerolits necessary
 lines      important case literal indeed support  then  provided
v current domain x  must seek new support calling findnewsupport
constraint  support  value v must pruned domain x 
found support update data structures calling addsupport 
initialise data structures root search  lines     procedure   invoked 
notice lines refer parameter x    v  first calling
supports initial iteration line   variables 
   noted earlier  watched literals available solver  simple check made
start procedure  return immediately removed literal active support 

  

fishort long supports constraint propagation

    complexity analysis shortgac
section provide complexity analysis shortgac used incrementally search constraint solver  analysis parameters arity
constraint n  maximum domain size d  cost f calling findnewsupport 
assume attaching removing trigger literal o     case
minion      
first observe swap procedure executes o    time  operation swap
o    loop  secondly establish time complexity procedures
addsupport deletesupport  key algorithm 
lemma      procedure    addsupport  time complexity o n  
proof  outer loop line   iterates literals short support  worst
case  n literals  consider steps within loop  list test
line   o     call attachtrigger line    adding shortsupportcell
doubly linked list line   o     following five array dereferences 
established above  swap procedure o     hence  addsupport o n  
lemma      procedure    deletesupport  time complexity o n  
proof  similarly add support procedure  outer loop line   n
iterations  removal doubly linked list line   o     array
dereferences line   subsequently  list test line   call removetrigger line   o     stack push operation line    recalling
swap procedure o     deletesupport o n  
theorem      procedure    shortgac propagate  time complexity o n  d   ndf   
upper bound obtained  i e  worst case time complexity  n  d    ndf   
proof  analysis first statement breaks three parts 
first  loop line   elements supportlistperlit  worst case occurs
nd literals explicit support  supports  maximum  n   d    
involve particular literal  literal may short support every
literal every variable   n   d        cost body loop
o n  lemma      total o n  d   dominated next part 
second part loop lines      maximum number iterations
line   n supports full length iteration line   contains n
variables  successive calls procedure   line   add o d  new supports 
support addition triggers restart loop beginning line   n
variables  total o n  d  calls procedure    call involves o d 
iterations loop line   procedure    therefore innermost loop run
o n  d    times 
complete proof first statement  consider cost innermost loop
procedure    within loop  operations o     exceptions call
findnewsupport line    cost f   call addsupport line     cost n
lemma       f dominating cost  since must least traverse new support
record it  however  n  d  iterations  nd calls findnewsupport 
  

finightingale  gent  jefferson    miguel

time valid literals explicit support  cost either o n  d   
o ndf    whichever greater  case cost o n  d    ndf   
upper bounds ndf n  d  attained worst case  literal
needs new support   ndf   calls findnewsupport  cost  n  d   
nd literals explicit support  size n  variable ends
 for example  d   values supported d   values deleted  worst case thus
 n  d    ndf   
procedure   invoked n d    times one branch search tree 
therefore complexity one branch o n  d    n  d  f   
      second complexity analysis
analysis conservative total number  maximum size 
short supports small  therefore  give another complexity analysis two additional
parameters  maximum length l short supports returned findnewsupport 
total number distinct short supports may returned findnewsupport 
analysis pertains branch search rather single call propagate
algorithm 
first part complexity analysis concerns short supports length l 
short support may added active set once  may deleted
branch  short support must found calling findnewsupport  cost o f   
lemma     shows addsupport procedure takes o n  time  lemma
re stated terms l  loop addsupport iterate o l  times  giving
total time o l   applies deletesupport  since short supports 
cost finding  adding deleting  collectively processing  short supports o s l   f   
branch 
secondly  algorithm may make calls findnewsupport return null 
happen n d        times  maximum number domain values
may deleted  therefore cost o ndf   
addition  shortgac operations charged either
categories  analyse these  must top down analysis algorithm 
procedure   invoked o s  times  each time short support invalidated   lines   
already charged processing short supports  body loop lines     may
executed times new support found  times new
support found  therefore o s  times total branch search 
come inner loop lines     lemma      below   unless domain
empty always one active short support  therefore  l variables
contained active short supports  l variables relevant
partition varsbysupport  loop body executed o l  times 
lemma      initialisation  procedure   always least one active short support
variable domain empty 
proof  suppose opposite  algorithm invoked time literal active short
support pruned  therefore delete active short supports must contain one
literal x   v  active short supports contain variable x  values domain
  

fishort long supports constraint propagation

x implicitly supported must explicitly supported  therefore v must
last remaining value d x   prune x   v empties domain
contradiction 
branch  causes o sl  calls shortgac variableupdate  line   
call shortgac variableupdate takes o d  time may   invalid
literals explicitly supported literals zerolits  time spent procedure
charged processing short supports  pruning domains  therefore top down
analysis cost o sld  
overall  time complexity o s l   f     ndf   sld   tighter bound cases
one given section above  example  sat clause   n  f   n  l    
     giving time complexity o n    branch search 
    instantiation findnewsupport
similarly gac schema  bessiere   regin         shortgac must instantiated
findnewsupport function  function takes valid literal  returns support one
exists  otherwise returns null  one way write specialist findnewsupport
function constraint  empirical case studies below 
case  findnewsupport function much simpler propagator
constraint  use lemma     build findnewsupport functions  reduces
task finding satisfying tuples simple constraints x   x   y 
alternative write generic version findnewsupport case
short supports given list  detail two generic instantiations findnewsupport lists  case studies compare specialist functions 
      findnewsupport list
provide generic instantiation named findnewsupport list  procedure    takes
list short supports literal  supportlist   including explicit implicit
short supports literal  analogous positive instantiation gacschema  bessiere   regin         findnewsupport list persistent state  listpos 
array integers indexed variable value  initially    indicates current
position supportlist  algorithm simply iterates list supports 
seeking one literals valid  listpos backtracked  consequence
end list reached  cannot fail immediately must search
start back listpos  branch search tree  particular element
list may looked once  however  algorithm optimal
time space across search tree  gent         surprising result achieved
amortizing cost across branches  practically  using listpos stops algorithm always
starting first element list  seems good tradeoff avoiding
provably unnecessary work much data structure maintenance 
constraint specific findnewsupport sometimes find shorter supports findnewsupport list  specific findnewsupport take advantage current
domains whereas supportlist may contain supports given initial domains 
example  constraint becomes entailed  specific findnewsupport return
  

finightingale  gent  jefferson    miguel

require  x  v  supportlist
   j  listpos x  v       supportlist x  v  size    
  
sup supportlist x  v  j 
  
literals sup valid
  
listpos x  v  j
  
return sup
   j         listpos x  v   
  
sup supportlist x  v  j 
  
literals sup valid
  
listpos x  v  j
   
return sup
    return null

procedure    findnewsupport list  findnewsupport x  v   first block searches
location previous support end support list  unsuccessful
search restarts start list second block  circular approach removes
need backtrack listpos 
empty support whereas list version presented cannot  exploit fact
case study   below 
      findnewsupport ndlist
list instantiation two major disadvantages  first  inefficient
unable skip sets invalid tuples  literature contains many solutions
problem context full length supports  example binary search  lecoutre  
szymanek        tries  gent  jefferson  miguel    nightingale         second 
require large amount memory  short support s  potentially nd
pointers s  pointer literal implicitly supports 
section give second generic list instantiation based nextdifference lists
 gent et al          single list  named supportlist  containing short supports  indexed integer   second list named ndlist support
 supportlist j   literal support s k   ndlist j  k  index next
support contain literal s k   thus  searching list  algorithm
able jump sets short supports contain invalid literal 
version findnewsupport nextdifference lists given procedure   
approach solves problems list instantiation  able jump
sets invalid short supports  usually requires substantially less memory  fact
optimal space  unlike list instantiation   given short supports length
l  nextdifference list o tl   however uses one list supports  therefore
spend time searching short supports support desired literal 
    literals assigned variables
suppose shortgac discovers new support contains literal x   v  x assigned v  since x take value v  sound remove x   v
save overhead adding it  apply minor optimisation cases using
shortgac  cases using haggisgac  described section     how  

fishort long supports constraint propagation

require  x  v  supportlist  ndlist
   j listpos x  v 
   j   supportlist size
  
sup supportlist j 
  
nextdiff ndlist j 
  
k          sup size   
  
 y   b  sup k 
  
b
  d y   x   v    b 
  
j nextdiff  k   jump next short support assigned different value  
  
continue loop line  
   
listpos x  v  j
   
return sup
    j  
    j   listpos x  v 
   
sup supportlist j 
   
nextdiff ndlist j 
   
k          sup size   
   
 y   b  sup k 
   
b
  d y   x   v    b 
   
j nextdiff  k   jump next short support assigned different value  
   
continue loop line   
   
listpos x  v  j
   
return sup
    return null

procedure    findnewsupport ndlist  findnewsupport x  v 

ever optimisation cannot used haggisgac stable  described section   
algorithm retains active supports backtracks  backtracking
literal x   v may longer assigned 

   haggisgac  dealing full length strict short supports
introduce haggisgac  show better theoretical properties
shortgac  furthermore  experiments show runs substantially faster many cases
strict short supports shortgac  which specialised strict short supports  
substantially faster full length supports gac schema 
    introduction motivating example
shortgac designed exploit concept implicit support  inefficiencies dealing explicit supports especially full length supports  consider
example constraint alldifferentexceptzero  constraint non zero
values array must different  zero may occur freely  constraint might
used  example  timetabling problem classes taking place different rooms
must different  use zero represent room unused occur
multiple times  suppose alldifferentexceptzero  w  x  y  z    variable initial domain               supports constraint full length supports every
  

finightingale  gent  jefferson    miguel

non zero value different  three variables equalling zero last variable may
take value  suppose execute shortgac reach following situation 
supports 

supportlistperlit 
value
 
 
 
 
supportspervar 
numsupports 

a 
b 
c 
d 
e 
w
 a  b  e 
  
  
 c 
 

w
     x           z    
w
     x           z    
w
     x           z    
x           z    
w      x           z    
variable
x

z
 c  d 
 d 
 d 
 e 
 c 
 a  b 
 a 
 b  e 
 c 
 b 
 a 
 e 
 
 
 
 

notice lack explicit supports w     w     acceptable
supportspervar w        numsupports      suppose literal     deleted
constraint  causes support deleted  causing following state 
supports 

supportlistperlit 
value
 
 
 
 
supportspervar 
numsupports 

a 
b 
c 
e 

     x     
     x     
     x     
     x     
variable
x

 c 

 e 
 c 
 a   b  e 
 b 
 a 
 
 
 

w
w
w
w

w
 a  b  e 
  
  
 c 
 

     z
     z
     z
     z

   
   
   
   

z
  
 a  b 
 c 
 e 
 

point shortgac iterates zerolits lists variables
supportspervar   numsupports  case four variables  discover must
find new supports w      w     z      however  inefficient two reasons 
first  need check zerolits z  discover z      support list
z     became empty deletion support d  could discovered then 
second  need look zerolits w  deletion caused
w lose implicit support  need check zerolits x  y  z
variables implicitly supported prior ds deletion  removing two
reasons inefficiency motivation behind development haggisgac 
example  focus directly literal z     set zerolits w  literals
potentially needing new support 
fundamental problem shortgac cannot efficiently detect
literal loses last support  every variable implicit support checked every time
support deleted  shortgac take o nd  time find single literal needs
new support discover literal  improve upon this  wish
  

fishort long supports constraint propagation


varsbysupport i 
supportspervar
x  updated
x  updated
z  updated
x  updated
z  updated
z  updated
supportspervar

 
w 
 
w 
w 
w 
w 
w 
w 
 

 
w 
 
w 
w 
w 
w 
w 
w 
 

 
y 
 
x 
x 
x 
x 
x 
x 
 

 
x 
 
x 
x 
x 
x 
x 
x 
 

 
x 
 
y 
y 
y 
x 
x 
x 
 

 
y 
 
y 
y 
y 
y 
y 
y 
 

 
y 
 
y 
y 
y 
y 
y 
y 
 

 
x 
 
x 
x 
x 
y 
y 
y 
 

 
z 
 
z 
z 
z 
z 
z 
z 
 

 
z 
 
z 
z 
z 
z 
z 
z 
 

  
z 
 
z 
z 
z 
z 
z 
z 
 

figure    illustration deletesupport concentrates variables lost
last implicit support  see main text full description 

haggisgac able detect loss literals last explicit support time o    
loss variables last implicit support time o     perhaps surprisingly 
goals achievable use data structures already existing shortgac 
    finding literals support efficiently
two types support  detecting last explicit support literal lost
simpler task  delete support  procedure   iterates literals
short support  literal removes shortsupportcell corresponding
supportlistperlit updates data structures appropriately  list empty tested
line   procedure   literal lost last explicit support  add literal
scratch list literals lost last explicit support  describe
process scratch list  additional cost o    detect empty list 
inside existing test  zero additional cost literal
lost last support  contrasts shortgac tests  in procedure    every
variable implicit support  worst case cost o n  even literal
lost last explicit support 
subtle task detect variable  and thus literals involving it 
lost last implicit support  reason difficult seeking
variables involved support deleted  procedure   iterate
literals support deleted  variables seek
x supportspervar x    numsupports support deletion 
supportspervar x    numsupports support deletion   variables
supportspervar x    numsupports deletion implicit support
now  lose implicit support deletion   fortunately  existing
maintenance data structures happens compact exactly variables particular
region varsbysupport  find easily efficiently  compaction
happens sequence calls procedure swap made procedure   
first show worked example prove general properties need 
figure    suppose    variables constraint  currently  
supports  deleting support involving variables x    x    x    z    z  z   
  

finightingale  gent  jefferson    miguel

literals deleted arbitrary order top  start  bottom  finish  
start  z variables already supportspervar   numsupports      variables x
supportspervar      variables w supportspervar      process literals
deletesupport  pairs variables swapped  marked boxes line 
boundaries move cells  marked vertical lines  variables equal supportspervar  end  w x variables still supportspervar       numsupports     
z variables supportspervar numsupports deletion 
variables lost last implicit support variables  crucial point
end lie precisely final boundary     supports
 from       initial boundary     supports  from       following
simple results show variables losing last implicit support always compacted
similar way 
lemma      suppose  delete support s  numsupports   p  and numsupports   p   afterwards   variable x lose last implicit support  p  
explicit supports deletion s 
proof  x initially fewer p  explicit supports  x one implicit
support deleting removes one these  x initially p explicit supports 
involved  since involved supports  implicit support
lose  hence  x must initially p   explicit supports one implicit support
must one implicit support  therefore deletion s  x p   explicit
supports implicit supports 
lemma      set p lemma      value supportnumlowidx p 
deletesupport called  j value supportnumlowidx p    deletesupport
exits  deletesupport finishes  variables lost last implicit support
call deletesupport exactly set variables indices range  j  i 
varsbysupport 
proof  variables implicit supports deletesupport exits lie index j
greater varsbysupport  establishes lower bound index range 
variable z implicit support start call must p explicit
supports must index higher  z must support deleted 
supports  z updated deletesupport  always swapped
variable index supportnumlowidx p   index supportnumlowidx p  increases
deletesupport  z stays index higher throughout  thus variables
index upwards finish permutation start  meaning variables
lost last implicit support must range  j  i   finally  variable
range  j  i  implicit support end call  as index j above 
implicit support start  as i   therefore variables
lost last implicit support lie indices range  j  i  
lemma      run deletesupport trivial enumerate variables
lost last implicit support result  exactly variables
varsbysupport k  k   j  j         i   j defined lemma  enumerating
list additional work already done procedure    have 
  

fishort long supports constraint propagation

corollary      given constraint n variables  additional work identify variables
lost last implicit support o    variable
some  o    none 
proof  already argued case variables lost implicit
support  variables  still o    work check range
empty 
low level complexity contrasts favourably shortgac  support deleted  procedure   iterates variables numsupports explicit supports 
worst case o n  work even variable lost last implicit support  compared o    work have  move details incorporating
optimisations full suite procedures maintaining gac 
    haggisgac  details
two issues complicate implementation haggisgac compared shortgac 
first  lemmas depend literals support deleted single pass 
therefore  instead acting immediately finding literal supports  keep list
literals lost supports later treatment  second  two cases
might detect lost support lost support explicit implicit compared
single case shortgac  lost supports detected way 
introduce two simple data structures storing literals variables lost
explicit implicit support find them 
litslostexplicitsupport set containing literals lost final explicit support
supported implicitly 
varslostimplicitsupport set containing variables lost final implicit
support 
adapt deletesupport procedure procedure    new version
shown procedure    find literal explicit support  immediately
check implicit support instead  line     not  add
set litslostexplicitsupport later processing find new support delete it  variables
implicit support detected literals deleted  done
lines        justified lemma     
new propagate procedure shown procedure    earlier procedure   
first delete supports involving literal deleted  rest procedure
different  first iterate literals lost last explicit support 
variables lost last implicit support 
lost explicit supports  call haggisgac literalupdate  procedure    
procedure analogue shortgac  straightforward  point interest
still check whether literal supported  even though added
litslostexplicitsupport not  reason support found unrelated
call findnewsupport might support literal  done 
procedure   calls findnewsupport  new support found added 
prune literal longer supported 
  

finightingale  gent  jefferson    miguel

require  short support sup
   oldindex supportnumlowidx numsupports 
    x   v  sup
  
remove sup supportlistperlit x   v 
  
supportlistperlit x   v      
  
detachtrigger x v 
  
 x   v    zerolits x 
  
add  x   v  zerolits x 
  
supportspervar x    numsupports
  
add  x   v  litslostexplicitsupport
   
spv supportspervar x 
   
swap x  varsbysupport spv  
   
supportnumlowidx spv  supportnumlowidx spv   
   
supportspervar x  spv 
    numsupports      supportnumlowidx numsupports        oldindex   
   
add varsbysupport i  varslostimplicitsupport

procedure    haggisgac deletesupport   sup   one subtlety must add  x  
v  zerolits  line    even add litslostexplicitsupport  line    
case matters seek find new implicit support  i e  containing
x   v  later lost  later point procedure    requires x   v zerolits
x   v might still explicit support 
require  x    v  where v pruned domain x 
   litslostexplicitsupport   
   varslostimplicitsupport   
   supportlistperlit x   v       
  
sup first element supportlistperlit x   v 
  
deletesupport sup 
    y   b  litslostexplicitsupport
  
haggisgac literalupdate y   b 
   z varslostimplicitsupport
  
haggisgac variableupdate z 

procedure    haggisgac propagate  propagate x    v 
variables lost implicit supports  call haggisgac variableupdate  procedure      similar procedure    differences return statements
procedure   omitted  check every iteration whether new implicit support
found x exit loop  remove x   v zerolits
new explicit support found  allowing done lazily later call line   
gain efficiency shortgac two reasons  first  variableupdate
called variables lost implicit support  second  outer loop
haggisgac propagate must restarted new support found 
procedure    write number variables lost last
implicit support  reduced worst case number calls variableupdate
haggisgac propagate o n  d  n arity constraint m  since
n often much smaller n even zero  significant gain 
  

fishort long supports constraint propagation

require  x   v  last explicit support x   v deleted
   v d x  supportspervar x    numsupports
supportlistperlit x   v      
  
sup findnewsupport x  v 
  
sup   null
  
prune x   v 
  
else
  
addsupport sup 

procedure    haggisgac literalupdate x   v 

require  variable x
    x   v  zerolits x 
  
supportspervar x    numsupports
  
return
  
supportlistperlit x   v       
  
remove  x   v  zerolits x 
  
else
  
v d x 
  
sup findnewsupport x   v 
  
sup   null
   
prune x   v 
   
else
   
addsupport sup 

procedure     haggisgac variableupdate x 

    dealing efficiently full length supports
full length support added  shortgac increments numsupports supportspervar every variable  since interested condition numsupports  
supportspervar x   full length support cannot change status variable  therefore save overheads case add full length support  achieved
case split haggisgacs versions addsupport deletesupport 
support full length update numsupports  supportspervar  related data
structures  note test apply final support arity n 
initial one omission assigned literals optimisation correct
even assigned literals omitted  omit pseudocode optimisation 
changes straightforward  optimisation often improves performance instances
full length supports      important effect instances
runtimes within      without it  optimisation applicable
shortgac  implement case address key
inefficiency algorithm has  i e  repeated checking variables cannot
lost last implicit support  affect experimental results dramatically 
cases found improved performance haggisgac larger
optimisation provides 
  

finightingale  gent  jefferson    miguel

   experimental evaluation shortgac haggisgac
minion solver       gent  jefferson    miguel      a  used experiments 
changes additional propagators  experiments  compared
methods maintain gac  therefore  solver explores search space case 
since number nodes searched invariant  compare rate search exploration 
measured search nodes per second  
used   core machine     ghz intel xeon e     cpus   gb memory 
running ubuntu linux  possible ran    processes parallel  combination problem instance propagator  report median    runs   cases
possible run    processes parallel exceed  gb memory  these 
ran one process time  report median   runs  instances
marked tables results  one method exceeded  gb  sometimes
ran comparable methods series well  allows consistent comparison
list ndlist  different propagation algorithms  means tables
necessarily indicate method uses  gb memory  find
median robust measure performance  reasons described appendix b 
cases  imposed time limit one hour  limit           search nodes
 whichever first   avoid short runs solver find solution easily 
searched solutions  report complete cpu times  i e  attempted
measure time attributable given propagator include initialisation 
advantage automatically take account factors affecting runtime 
including aspects  e g  cache usage  may realise affect runtime  however
mean results tend understate difference methods studied 
case study  implemented findnewsupport method shortgac
haggisgac specific constraint  used generic list instantiation  section        next difference list instantiation  section        comparison
possible  compare shortgac haggisgac special purpose propagator
 when available  
compare shortgac long  shortgac full length supports  
haggisgac long  gac schema  bessiere   regin        closest equivalent algorithm without strict short supports  discuss gac schema section     
gac schema  shortgac long haggisgac long use  constraint specific 
findnewsupport shortgac  subsequently extend short support full length
using minimum value extra variable 
case  constraint compactly represented disjunction  therefore
compare shortgac haggisgac constructive or  algorithm used
based lagerkvist schultes         without rule entailment detection 

   source code solver three algorithms available http   www cs st andrews ac 
uk  pn haggisgac source tgz problem instances experimental results http   www cs 
st andrews ac uk  pn haggisgac data instances tgz 
   preliminary investigations  found running    processes parallel gives consistent cpu time
results  consistency improved taking median 

  

fishort long supports constraint propagation

 

element
element long
element list
element ndlist
lex
lex long
squarepack
squarepack long
squarepack list
squarepack ndlist

   

 

   

    
   
 
   
 

  

   

    

     

      

figure    summary comparison shortgac haggisgac  x axis median
nodes per second shortgac  y axis speedup  or slowdown  haggisgac  i e  ratio shortgac nodes per second haggisgac 
hence   represents equal behaviour    means haggisgac
faster 

implementation minion fully incremental  disjunct propagated incrementally
branch search backtracked search backtracks  
compare table constraints  described  for example  gent et al 
        constraints large  example  smallest element constraints
reported     allowed tuples  making impossible even generate store
list allowed tuples 
aid comparison haggisgac shortgac  addition tables
compare graphically figure    figure shows relative speedup  or
cases slowdown  using haggisgac compared shortgac 
    case study    element
use quasigroup existence problem qg   colton   miguel        evaluate shortgac haggisgac element constraint  problem class one parameter
n  specifying size n n table  qg  variables domains          n     rows 
columns one diagonal gac alldifferent constraints  following colton miguels
model  element constraints represent qg  property  i j   j i     where
j members quasigroup quasigroup operator   translates
i  j   element qg  aux i  j   i   aux i  j   n qg i  j    qg j  i   aux i  j 
domain          n n    
   personal communication pascal van hentenryck indicated unpublished optimisation
constructive whereby disjuncts need propagated cases  implement
optimisation 

  

finightingale  gent  jefferson    miguel

n
 
 
 
 
  

watch
elt 
      
      
      
      
      

specific
     
     
     
     

     

shortgac
list ndl
           
           
     
   
     
   


     
   

long
    

   

   

   

   

specific
      
     
     
     

     

haggisgac
list ndl
           
           
     
   
     
   


     
   

long
    

    

   

   

   

gac
sch 
    
   

   

   
mem

con

    
    
   

   

   

table    nodes searched per second quasigroup existence problems  mem indicates
running memory      gb   columns correspond propagation algorithms 
watch elt special purpose propagator  shortgac haggisgac
four instantiations  specific  special purpose findnewsupport function
constraint   list  ndl  next difference list   long  as described text  
gac sch gac schema  con constructive or 

constraint element x  y  z   findnewsupport method shortgac returns
tuples form hxi   j    i  z   ji  index vector x j
common value z xi   shortgac list supports form  constructive
or  used  x    z       x    z       
compare shortgac haggisgac special purpose watched element
propagator  gent et al       b   gac schema constructive or  table   presents
results qg   general purpose methods  using short supports  with specific  list
ndlist instantiations  dramatically better alternative  example n      
even haggisgac list method  which slower haggisgac specific 
    times faster constructive or  best methods 
shortgac long runs       faster gac schema n        slower
n     better n      gac schema uses memory  recall
use findnewsupport method  fair comparison efficiently
exploit supports  contrast results reported previously  nightingale
et al          shortgac half speed gac schema  two substantial differences account improvement  improved data structures described
section    remove assigned literals full length supports described
section      haggisgac long consistently faster shortgac long
gac schema 
much faster methods using full length supports  list variants haggisgaclist haggisgac ndlist slower haggisgac element  and
true shortgac   expected neither specialised element
constraint  deal data structures containing lists tuples 
two list variants  ndlist variant runs much slowly  however  memory usage is 
expected  much less haggisgac list  used less half much memory
n      improving almost    times less memory n      
haggisgac element approximately twice fast shortgac element
instances  believe two variables short supports index
result variables meaning always supported explicitly  seen
  

fishort long supports constraint propagation

n

gaclex

 
 
 
 
 
 
 
  
  
  
  
  
  
  
  

       
       
      
      
      
      
      
      
      
      
      
      
      
      
     

shortgac
specific long
            
            
            
            
            
            
      
   
      
   
      
   
      
   
      
    
      
    
      
    
     
    
     
    

haggisgac
specific long
            
             
            
            
            
            
      
   
      
   
      
   
      
   
      
    
      
    
      
    
     
    
     
    

gacschema
     
     
     
     
     
   
   
   
   
    
    
    
    
    

   

con

     
     
     
     
     
   
   
   
   

    

    

    

    

    

    

table    nodes searched per second bibds  gaclex special purpose propagator 
columns named table   

figure    list  ndlist long instantiations haggisgac faster
instantiations shortgac smaller margin  special purpose
watched element propagator fastest method      times faster n      
watched element appears scaling better n increases  constructive
much slower methods exploit strict short supports  however faster
haggisgac long  overall clear exploiting strict short supports
beneficial compared general purpose methods 
    case study    lex ordering
use bibd problem evaluate shortgac haggisgac lexicographic
ordering constraint  lex constraint placed rows columns  perform
double lex symmetry breaking method  flener et al          use bibd model
given frisch  hnich  kiziltan  miguel  walsh         gaclex propagator given frisch  hnich  kiziltan  miguel  walsh         use bibds
parameter values   n       n       n       n      n  
constraint lexleq x    arrays x   define mxi   min dom xi   
myi   max dom yi     findnewsupport method shortgac finds lowest
index          n  mxi   myi     n  case   n arises x cannot
lexicographically less   support sought x       n  support
contains xi   mxi   yi   myi   index j   i  mxj   myj   short support
contains xj   mxj   yj   myj otherwise valid support null returned 
lex constraint two arrays length n domain size dn short
supports short support set  assignments two arrays equal
satisfy constraint cannot reduced  shortgac list shortgac ndlist
  

finightingale  gent  jefferson    miguel

practical substantial constraint omit comparison 
constructive use following representation n     disjuncts   x    y     x   
y  x    y      including final case pairs equal 
table   presents results experiments non list based methods values
n       clear best method special purpose gaclex propagator 
haggisgac coming second  problem  haggisgac shortgac perform similarly  haggisgac shortgac far best general purpose methods 
largest instances run     times slower special purpose method 
outperforming next best method almost     times  again  haggisgac long
shortgac long outperform gac schema  instances difference
even marked 
haggisgac long substantially faster shortgac long  seen
figure    largely explained optimisation section     
summarise  experiments lex constraint clearly show benefit
haggisgac shortgac compared general purpose propagation methods 
speed even approaches special purpose gaclex propagator 
    case study    rectangle packing
rectangle packing problem  simonis   osullivan         with parameters n  width
height  consists packing squares size     n n rectangle size
width height  modelled follows  variables x        xn y        yn  
 xi   yi   represents cartesian coordinates lower left corner square 
domains xi variables          width i   yi variables          height i  
variables branched decreasing order  to place largest square first  
xi yi   smallest value first  type constraint non overlap squares
j   xi   xj    xj   j xi    yi   yj    yj   j yi    minion
special purpose non overlap constraint  simonis   osullivan        
report comparison general purpose methods  experiment used optimum
rectangle sizes reported simonis osullivan 
domains xn yn reduced break flip symmetries described simonis
osullivan         focus performance non overlap constraint 
implement commonly used implied constraints 
findnewsupport function shortgac follows  four disjuncts
entailed given current domains  return empty support  indicating entailment   otherwise  return support two literals satisfy one four disjuncts 
list used shortgac list shortgac ndlist supports size   
table    compare haggisgac shortgac general purpose
methods  see haggisgac fastest method  shortgac second 
haggisgac list haggisgac ndlist  as well shortgac list shortgacndlist  performed well compared gac schema constructive or  however
n       haggisgac list consumes    mb memory haggisgac ndlist    mb 
n      possible run methods    processes parallel 
interestingly  performance two list variants haggisgac reversed
case study    here  ndlist significantly faster list cases  expected 
  

fishort long supports constraint propagation

n w h
        
        
        
        
        
        
        
         
        
         

specific
      
      
      
     
     
      
      
     
      
     

shortgac
list
ndl
     
     
     
     
     
     

           

           

           

           


     
   


   
     


     
   

long
     
     
   
   
   
   
   
   
   
   

specific
      
      
      
      
      
      
      
      
      
     

haggisgac
list
ndl
     
     
     
     
     
     

           

           

           

           

           

           

           

long
     
     
     
   
   
   
   
   
   
   

gac
sch 
     
     
   
   
   
   
   
   
   
   

con

   
   
   
   
   
   
   
  
   
  

table    nodes searched per second rectangle packing instances  columns named
table   

ndlist used less memory  though less dramatically before  used    
    memory haggisgac list 
methods  always least    times slower haggisgac 
haggisgac long faster gac schema cases  shortgac long
faster gac schema instances except            this contradicts result
previously reported  nightingale et al          explanation given
first case study  
table   shows haggisgac  with squarepack instantiation  substantially
faster shortgac instances  exception n      n     
shortgac slightly faster  compared shortgac list  ndlist 
long instantiations figure    see haggisgac mostly   
    faster  summary  results clearly show benefits using strict short
supports 
    comparing haggisgac gac schema
across experiments  haggisgac long runs significantly faster gacschema minimum     faster three times faster even
though code contains overhead dealing strict short supports  compared
memory usage across experiments  found similar performance across instances  found haggisgac long uses less    memory except
bibd instances  bibd uses less     memory gac schema 
however  comparison functional instantiations full length supports  constraints admit strict short supports  section  broaden
comparison using list instantiations rather functional ones  using problem
instances used previously comparing table constraints 
compared gac schema similar haggisgac
shortgac conceptually  three algorithms maintain list supports literal 
updated backtracked search  gac schema carefully implemented
  

finightingale  gent  jefferson    miguel

sports
carseq
graceful
pqueens
bibd

  

  

 

 

 

   
   

    

     

      

figure    comparison gac schema haggisgac list full length table constraints  x axis nodes per second gac schema  y axis speedup
haggisgac list 

following pseudocode original paper  bessiere   regin         code
shared among three algorithms  optimised independently  example 
gac schema different implementation supportlistperlit  named sc  bessiere  
regin         specialised full length supports 
contrast gac schema  table constraint propagators str   lecoutre 
      mddc  cheng   yap        entirely different haggisgac  would
difficult create truly comparable implementations them 
report use haggisgac list only  searches supports
way gac schema  with one difference discuss below   used structured
instances gent et al          except semigroup class  addition  used car
sequencing instances nightingale         specifically model b instances numbered
       instances contain large number ternary table constraints 
figure   shows haggisgac list almost always faster gac schema
problems  bibds clear algorithm better  haggisgac
always least marginally faster sports scheduling  prime queens graceful
graphs instances  cases range        faster  haggisgac substantially
faster car sequencing  seek new supports  haggisgac calls procedure   
finds new support stores index listpos  haggisgac backtrack
listpos described section        gac schema similar  backtrack listpos 
ensures optimality branch search iterating listpos
end list  bessiere   regin         profiling shows gac schema hindered
backtracking listpos  by block copying memory  car sequencing 
large number table constraints       instance     large domains  some size
  

fishort long supports constraint propagation

       alternative memory management techniques might speed gac schema 
claim haggisgac fundamentally    times faster gac schema 
    results summary
summarise three case studies  haggisgac indeed outperform shortgac
many instances  sometimes two times commonly     
shortgac rarely faster  one instance much      overall 
experiments  haggisgac clearly better algorithm shortgac  furthermore 
haggisgac shortgac perform well compared constructive gacschema  result validates idea strict short supports 
finally  shown experimentally haggisgac outperform gac schema
problems containing full length supports  discuss appendix c major focus paper 

   backtrack stability short supports
within search tree  haggisgac often spends significant time backtracking data structures  reducing eliminating backtracking improve efficiency  example mac  
mac   much efficient  in space time  backtracking avoided
 regin         section present new algorithm saves time deleting
short supports backtrack  saves memory bounding total number stored
short supports  including backtrack stack  
new algorithm requires short supports backtrack stability property 
short support backtrack stable iff remains short support backtracking  section      
three case studies  find short supports construct element
lex constraints backtrack stable  rectangle packing not  rectangle
packing  generate empty support constraint entailed  empty support
backtrack stable unless constraint entailed root node search 
introduce algorithm haggisgac stable know short supports
backtrack stable  key change delete supports backtrack
past point introduction  stable  still correct ancestors
node introduced at  save time previous algorithms  since
sometimes need work backtracking  also  show below  obtain
tight limits space usage stored supports 
present haggisgac stable  introduce notion prime support
deleted literal  prime support deleted literal support  either explicit implicit 
valid support literal literal restored backtracking 
invariant maintain deleting literal either labelled deleted
support backtrack stack prime support literals variable currently
implicitly supported  invariant  guarantee backtrack
point literal restored  must supported again  either prime support
restore  known implicit support 
task finding prime support literal naturally splits three cases 
simplest case haggisgac stable deletes literals able find
  

finightingale  gent  jefferson    miguel

necessary new support  prime support implicit explicit support
whose deletion caused fruitless search new support 
second case literal pruned constraint search
procedure  pruned literal explicit support constraint  explicit
supports must deleted longer valid  label arbitrary one
literals prime support  simply choose last one deleted 
third case unfortunately complicated  literal pruned outside
current constraint  literal implicit support explicit support 
difficult precisely pruned literal link implicit support 
providing maintaining link throughout search would negate efficiencies
gained  solution problem lazy  variable pruned
literal implicitly supported  implicit support variable 
maintaining invariant described above  literal pruned need nothing
case  need work variable loses last implicit support 
ever does  happens  invalid literal explicit support must
definition relevant zerolits list  whereas previously ignored invalid literals
iterating zerolits  label deleted implicit support prime
support invalid literal 
show lemma     haggisgac stable stores time
o z  supports  z total number literals  save lot memory
haggisgac shortgac may store o z     supports 
o z  deletions literals branch  deletion new set o z  supports
may stored  experiments later show difference memory usage
significant practice  effective  memory usage reduced    times 
    details haggisgac stable
haggisgac stable  control great care deletion restoration
supports  instead  as rest paper  simply reversing addition deletion
support node respectively deleting adding back backtrack past
node  short never delete active support backtracking  add back
deleted support prime support literal current active support 
deleting support  setup counter numprimesupported  initially   
incremented time find support prime support  propagation
algorithm finishes  support numprimesupported      support destroyed space reclaimed  otherwise  place numprimesupported new pairs
backtrack stack  pair consists deleted support literal prime
support for  backtracking  pop pair  first check current support
already supports literal  so  simply decrement numprimesupported 
reduces    reclaim supports space  literal supported 
restore support via call addsupport  way literals support prime
guaranteed supported 
relatively minor difference iterate zerolits delete invalid literals zerolits  backtracking restore
  

fishort long supports constraint propagation

require  x   v  last explicit support x   v deleted
   v d x 
  
supportspervar x    numsupports supportlistperlit x   v      
  
sup findnewsupport x  v 
  
sup   null
  
prune x   v 
  
increment lastsupportperlit x   v  numprimesupported
  
push hx   v  lastsupportperlit x   v i onto backtrackstack
  
else
  
addsupport sup 
    else
   
increment lastsupportperlit x   v  numprimesupported
   
push hx   v  lastsupportperlit x   v i onto backtrackstack

procedure     haggisgac stable literalupdate   x   v   comparison procedure    update numprimesupported backtrackstack 

zerolits backtrack stack  enables space complexity
result lemma     
haggisgac stable similar haggisgac  appropriate simply describe
differences save space  procedure haggisgac stable propagate almost
procedure    calling backtrack stable variants deletesupport  literalupdate
 procedure     variableupdate  procedure      addition  end algorithm
destroy reclaim space deleted support numprimesupported     
procedure haggisgac stable deletesupport  called support s 
similar predecessor  procedure    additions  first  initialises numprimesupported    second  new data structures lastsupportperlit deleted
literal x   lastsupportpervar variable x  terms procedure   
assigned line   line     respectively   note assignments
make prime support  checked later 
procedure    analogous procedure   enough differences show
detail here  identifies prime supports  necessary increments numprimesupported pushes invalid literal support pairs onto backtrack stack  present
procedure    detail  analogue procedure     identifies prime supports 
increments counter adds pairs backtrackstack  one difficult case arises 
line     here  x   pruned  externally constraint 
pruned procedure     would zerolits  x   restored backtracking still need make sure support  since explicit support  it
zerolits   last support must implicit support deleting  therefore store
support backtrackstack  minor change note remove literals
zerolits  lines       
whenever new search node  including root  entered  null pushed onto
backtrackstack  used marker procedure haggisgac stablebacktrack  procedure      processes literal support pairs reaches null 
restores prime supports literals put back domain backtracking 
support currently known  numprimesupported counter
  

finightingale  gent  jefferson    miguel

require  variable x
    x   v  zerolits x 
  
supportspervar x    numsupports
  
return
  
supportlistperlit x   v       
  
remove  x   v  zerolits x 
  
else
  
v d x 
  
sup findnewsupport x  v 
  
sup   null
   
prune x   v 
   
increment lastsupportpervar x  numprimesupported
   
push hx   v  lastsupportpervar x i onto backtrackstack
   
remove  x   v  zerolits x 
   
else
   
addsupport sup 
   
else
   
increment lastsupportpervar x  numprimesupported
   
push hx   v  lastsupportpervar x i onto backtrackstack
   
remove  x   v  zerolits x 
procedure     haggisgac stable variableupdate   x   similar procedure   
addition maintenance numprimesupported backtrackstack 
   top element backtrackstack null
  
pop hx   v  supi backtrackstack
  
sup yet restored
  
supportspervar x    numsupports supportlistperlit x   v      
  
haggisgac stable addsupport sup 
  
else
  
 another support exists x   v 
  
decrement sup numprimesupported
  
sup numprimesupported    
   
destroy sup reclaim space
   
supportlistperlit x   v      
   
add  x   v  zerolits x 
    pop null backtrackstack

procedure     haggisgac stable backtrack  performs backtracking using backtrackstack 

support becomes zero  support destroyed longer necessary  note
literals put back zerolits necessary line     reversing deletion
procedure    
cannot use optimisation described section      deleting literals supports
variables assigned  may break backtrack stability property 
  

fishort long supports constraint propagation

however  retain optimisation section     full length supports  omit
pseudocode showing interest focusing essential aspects algorithms 
    improved space complexity haggisgac stable
approach improves space complexity haggisgac stable compared haggisgac  following lemma shows 
lemma      constraint involving z literals   z supports stored  either
active deleted supports backtrack stack 
proof  define function supports literals  support still active 
found call findnewsupport specific literal  map support
literal  similarly  support backtrack stack  pair least
one literal prime support for  map support one literals  every
stored support falls one two categories  support deleted
put onto backtrack stack  space reclaimed  three supports mapped
literal because 
valid literals  findnewsupport called existing active support
exists literal 
invalid literals  literal appears pair backtrack stack
twice  case literal appears often twice literal
prime support already stack processed variable loses last implicit
support  case  literal must zerolits  newly deleted implicit
support added backtrack stack literal  happen
delete literal zerolits first time happens 
thus number supports bounded  z 
bound  z lemma     would improve z maintained zerolits eagerly
instead lazily  expense higher overheads elsewhere 

   experimental evaluation haggisgac stable
compare haggisgac stable haggisgac using experimental setup
section    well tables results  provide graphical comparison runtimes
haggisgac stable haggisgac figure    memory usage figure   
table   figure   shows results instances section      present
four instantiations haggisgac stable  along fastest instantiation haggisgac  watched element special purpose propagator  constructive  which
faster gac schema table     element  observe     slowdown 
slight slowdown list variants  full length supports  see almost
identical performance 
table   shows results instances section      haggisgac stable lex performs slightly worse haggisgac lex  though fact never     worse
slightly faster largest instances  might supports found
  

finightingale  gent  jefferson    miguel

deep search likely contain literals supports found earlier  meaning
backtrack longer supports retained instead replaced earlier
efficient short supports  so  advantage disappears long variants  indeed  haggisgac stable long performs much better haggisgac long 
improvement increases n      times n      
rectangle packing instantiation shortgac described section   generates
empty support constraint becomes entailed  causing variables implicitly
supported point on  empty support backtrack stable  cannot
used haggisgac stable  implemented new backtrack stable variant
findnewsupport  empty support returned  otherwise
before  list long variants affected return
empty support case  table    use instances section      results show
significant slowdowns using backtrack stability rectangle packing    times
n       probably inability return empty support 
hand  see speedups     list variants  cases factor
  speedup full length supports 
see figure   memory usage goes greatly stability used
full length supports  possibly contributing speedups cases  greatest
reductions case element  two cases    times less memory 
hand  significant reduction memory usage non long variant 
tested haggisgac stable gac schema section      gave
similar performance haggisgac therefore better gac schema 
omit detailed results  significant memory advantage compared haggisgac  stable variant saving less      therefore seem gain
advantages saw earlier backtrack stability full length supports 
conclude backtrack stability speed haggisgac significantly 
greatly reduce memory usage using full length supports  however  care must
used  backtrack stability harmful insisting backtrack stability increases
size returned supports 

    related work
use counters count supports inspired ac   mohr   henderson        
study compressing tuples constraint compact data structure
order make propagation efficient  example  gent et al         used tries 
cheng yap        applied mdds  extensive study searching
list tuples find first valid tuple  approaches include binary search  lecoutre  
szymanek         trie search  gent et al          approaches similar skip lists
ndlists  gent et al         hologram tuples  lhomme        lhomme   regin        
techniques orthogonal main focus paper assist
finding supports  maintaining set active supports  adapted ndlists
contain short supports section        may interesting adapt
approaches 
str  maintains sparse set valid satisfying tuples constraint  lecoutre 
       updated variable domains computed set time algorithm
  

fishort long supports constraint propagation

n

watchelt

 
 
 
 
  

      
      
      
      
      

haggisgac
specific
      
     
     
     

     

haggisgac stable
specific
list ndlist long
      
     
     
    
     
     
          

     
     
   
   

     
     
   
   



           
   
   

con

    
    
   

   

   

table    nodes searched per second quasigroup existence problems  columns
named table   
n

gaclex

 
 
 
 
 
 
 
  
  
  
  
  
  
  
  

       
       
      
      
      
      
      
      
      
      
      
      
      
      
     

haggisgac
specific long
            
             
            
            
            
            
      
   
      
   
      
   
      
   
      
    
      
    
      
    
     
    
     
    

haggisgac stable
specific
long
      
      
       
     
      
     
      
     
      
     
      
     
      
     
      
   
      
   
      
   
      
   
      
   
      
   
     
   
     
  

gacschema
     
     
     
     
     
   
   
   
   
    
    
    
    
    

   

con

     
     
     
     
     
   
   
   
   

    

    

    

    

    

    

table    nodes searched per second bibds  gaclex special purpose propagator
lex  columns named table   
n w h
        
        
        
        
        
        
        
         
        
         

haggisgac
specific
      
      
      
      
      
      
      
      
      
     

haggisgac stable
specific
list ndlist
      
     
     
      
     
     
      
     
     

     
           

           
     


      
     
     

           
     

           
     


      
     
     

           
     

long
     
     
     
   
   
     
     
     
   
   

gacschema
     
     
   
   
   
   
   
   
   
   

table    nodes searched per second rectangle packing instances  columns named
table   

  

finightingale  gent  jefferson    miguel

element
element long
element list
element ndlist
lex
lex long
squarepack
squarepack long
squarepack list
squarepack ndlist

 
 
 
 
 
   
   
 
   
   
   
   
   
 

  

   

    

     

      

 e   

figure    summary comparison haggisgac haggisgac stable  x axis
median nodes per second haggisgac  y axis speedup  or slowdown 
haggisgac stable 

 

 

   

   

   

    

    
    

element
element long
element list
element ndlist
lex
lex long
squarepack
squarepack long
squarepack list
squarepack ndlist
     

      

 e   

 e   

 e   

figure    summary comparison memory usage  kib  haggisgac haggisgacstable  x axis median memory usage haggisgac  y axis
reduction  or increase  usage haggisgac stable  i e  ratio haggisgac memory usage haggisgac stable  hence   represents
equal behaviour    means haggisgac stable used less memory 

  

fishort long supports constraint propagation

invoked  concept maintaining support  seeking new support literal 
would interesting investigate adapting str  handle short supports  would
result entirely different algorithm ones presented paper  possibly
complementary strengths 
mdd propagator mddc  cheng   yap        maintains mdd incrementally
search  mdd compressed representation satisfying tuples
constraint  time complexity mddc linear initial size mdd  therefore
degree compression vital efficiency algorithm  cases 
constraint amenable strict short supports  compress well mdd
 given appropriate variable ordering   example  lex constraint compresses well
partly  given variable order x    y    x    y           constraint satisfied
assigning prefix variables  lex amenable short supports reason 
however  constraints small set short supports cannot compressed
effectively mdd  suppose disjunction equality constraints pair
n variables domain size d  n   variables  mdd must cn  states 
another property mdd compression might indicate interesting direction future
work  lex compresses well mdd multiple assignments prefix
variables lead subsequent vertex  e g   x       y        x       y        
something short support algorithms currently able exploit 
katsirelos walsh        proposed different generalisation support  named ctuples  c tuple contains set values variable scope constraint 
valid tuple whose values drawn c tuple  full length  support  katsirelos
walsh give outline modified version gac schema directly stores c tuples 
present experiments based different propagator  gac   r  demonstrating
modest speed improvement c tuples compared conventional full length supports 
c tuple contains values variable  nevertheless recorded  in sc  
support value individually  katsirelos   walsh         algorithm
concept implicit support 
context constructive or  lhomme        observed support one
disjunct support values variable contained a  concept similar
short support albeit less general  length supports fixed
length disjuncts  presented non incremental constructive algorithm two
disjuncts 
algorithms similar flavour gac schema  bessiere   regin        
natural compare gac schema  however gac algorithms
gac          bessiere et al         would interesting compare
algorithms 

    conclusions
introduced detailed three general purpose propagation algorithms short
supports  either given specialised function find new supports
constraint  used function accepts explicit list short supports 
strict short supports available  three algorithms perform well  provide much
  

finightingale  gent  jefferson    miguel

better performance general purpose methods gac schema constructive or 
shows value using strict short supports 
first algorithm studied shortgac  described improvements
compared earlier report algorithm  nightingale et al          identified significant inefficiency shortgac dealing explicit supports 
introduced new algorithm  haggisgac corrects flaw  better theoretical
complexities  performs much better shortgac experiments  three
case studies  haggisgac far faster general purpose methods  best case
even achieved speeds     special purpose propagator  perhaps
remarkably  able deal strict short full length supports  haggisgac outperformed shortgac strict short supports gac schema full length
supports  i e  cases algorithms respectively specialised for 
third algorithm  haggisgac stable  retain supports backtracking 
less effective haggisgac invalidates use certain strict short supports 
significantly faster problems full length supports  reduce
memory usage greatly cases 
proposed algorithms excellent propagating disjunctions constraints 
experiments disjunctions found algorithms faster constructive
gac schema least order magnitude  three orders magnitude 
summarise  shown value explicit use strict short supports
general purpose propagation algorithms generalised arc consistency  strict short
supports available  exploiting yields orders magnitude improvements generic
propagation algorithms  cases  even found generic algorithm come
close performance specialised propagator  previously  short supports
seem recognised important right  overall contribution
correct focus short supports first class objects 

acknowledgments
would thank anonymous reviewers bilal syed hussain comments 
epsrc funding work grants ep h         ep e         

appendix a  comparison shortgac shortgac ijcai
section    noted optimised data structures algorithms shortgac  compared previous presentation  nightingale et al          demonstrate
indeed improvements  compared two implementations shortgac
three case studies used paper  use name shortgac ijcai
previous version  quoting results previous work  nightingale et al  
       rerun experiments using environment described section   
updated codebase minion      instead minion      earlier paper 
algorithm instance  report nodes searched per second peak memory use 
table   shows results instances section      clear results
shortgac makes much better use memory faster shortgac ijcai
  

fishort long supports constraint propagation

    

low memory  sections    
high memory  sections    
list   ndlist  section    
gac schema   constructive

    
    
   
    
    
    
    
 
   

 

  

   

    

     

      

 e   

figure    scatterplot median nodes per second  x axis  median absolute
deviation divided median  y axis   distinguish
main experiments sections      cases medians  
runs  list variants used table constraints section      data
paper gac schema constructive or 

instances  table   shows results instances section      element 
shortgac makes better use memory faster shortgac ijcai  although
improvements great before  table    use instances section     
previous two case studies  shortgac consistently better speed
memory use  conclude algorithms data structures used paper
indeed superior used previously  nightingale et al         

appendix b  median absolute deviation experiments
experiments report median either      runs  assess robust
median measure looked  combination instances algorithm 
median absolute deviation  mad   i e  median absolute difference data
points median  figure   shows mad algorithm instance combinations
fraction median case  shows     algorithm instance combinations
tested  including combinations reported detail paper   nodes per
second  maximum mad found always less     median  worst
case        haggisgac long n     table    four
cases mad    median  figures memory usage even
consistent  two cases  at            showing mad    median
others     major conclusions draw regard     change
behaviour one method another significant  therefore say
median robust measure performance 
  

finightingale  gent  jefferson    miguel

n
 
 
 
 
  

shortgac
node rate
     
     
     
     

     

shortgac ijcai
node rate
     
     
     
     

     

shortgac
memory
     
     
     
      

      

shortgac ijcai
memory
      
      
       
       

       

table    nodes searched per second memory use  kib  quasigroup existence problems  comparison shortgac shortgac ijcai 

n
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  

shortgac
node rate
      
      
      
      
      
      
      
      
      
      
      
      
      
     
     

shortgac ijcai
node rate
      
      
      
      
      
      
      
      
      
      
      
      
     
     
     

shortgac
memory
     
      
      
      
      
      
      
      
       
       
       
       
       
       
       

shortgac ijcai
memory
     
      
      
      
      
      
      
      
       
       
       
       
       
       
       

table    nodes searched per second memory use bibd problems  comparison
shortgac shortgac ijcai 

n w h
        
        
        
        
        
        
        
         
        
         

shortgac
node rate
      
      
      
     
     
      
      
     
      
     

shortgac ijcai
node rate
      
      
      
     
     
      
     
     
      
     

shortgac
memory
      
      
      
      
      
      
      
      
      
      

shortgac ijcai
memory
      
      
      
      
      
      
      
      
      
       

table    nodes searched per second memory use rectangle packing  comparison
shortgac shortgac ijcai 

  

fishort long supports constraint propagation

appendix c  comparison gac schema haggisgac
showed section     haggisgac outperforms gac schema dealing
full length supports  despite fact haggisgac small overheads
dealing strict short supports even none exist  discuss briefly
may so 
gac schema concept current supports literal one current support 
one active supports contain literal  additional data
structure s     active support   s    list literals
current support  hence invalidated  gac schema finds new current support
literal s     or deletes literal   haggisgac dispensed
entirely  sign literal needs new support lost current support 
support list  supportlistperlit  empty  small potential saving
maintaining s    
second  possibly important  difference gac schema eager
haggisgac  literal x   v loses current support  gac schema check
active supports containing x   v valid  o n  operation one 
invalid  gac schema calls findnewsupport  returns null x   v
deleted  haggisgac none this  avoiding completely cost checking validity  safe every support invalid  literal deletion support
cause call deletesupport last result empty list  causing call
findnewsupport  approaches correct  gac schemas wasteful
performs unnecessary validity checks  however  one cannot guarantee time saving  gac schema perform deletions sooner  possibly affecting way propagator
interacts propagators 

references
bessiere  c   hebrard  e   hnich  b     walsh  t          complexity reasoning
global constraints  constraints                 
bessiere  c     regin  j  c          arc consistency general constraint networks  preliminary results  proceedings ijcai       pp         
bessiere  c   regin  j  c   yap  r  h  c     zhang  y          optimal coarse grained
arc consistency algorithm  artificial intelligence                  
cheng  k  c  k     yap  r  h  c          mdd based generalized arc consistency
algorithm positive negative table constraints global constraints 
constraints                 
colton  s     miguel  i          constraint generation via automated theory formation 
proceedings cp       pp         
flener  p   frisch  a  m   hnich  b   kiziltan  z   miguel  i   pearson  j     walsh  t         
breaking row column symmetries matrix models  proceedings cp       pp 
       
frisch  a  m   hnich  b   kiziltan  z   miguel  i     walsh  t          global constraints
lexicographic orderings  proceedings cp       pp        
  

finightingale  gent  jefferson    miguel

frisch  a  m   hnich  b   kiziltan  z   miguel  i     walsh  t          propagation algorithms
lexicographic ordering constraints  artificial intelligence                   
gent  i  p          optimality result maintaining list pointers backtracking
search  tech  rep  circa preprint         university st andrews 
gent  i  p   jefferson  c     miguel  i       a   minion  fast scalable constraint solver 
proceedings ecai       pp        
gent  i  p   jefferson  c     miguel  i       b   watched literals constraint propagation
minion  proceedings cp       pp         
gent  i  p   jefferson  c   miguel  i     nightingale  p          data structures generalised
arc consistency extensional constraints  proceedings aaai       pp         
gent  i  p   petrie  k     puget  j  f          handbook constraint programming  foundations artificial intelligence   chap  symmetry constraint programming  pp 
        elsevier science inc   new york  ny  usa 
jefferson  c   moore  n  c  a   nightingale  p     petrie  k  e          implementing logical
connectives constraint programming  artificial intelligence                        
katsirelos  g     walsh  t          compression algorithm large arity extensional
constraints  proceedings cp       pp         
king  a   cromarty  l   paterson  c     boyd  j          applications ultrasonography
reproductive management dux magnus gentis venteris saginati  veterinary
record              
lagerkvist  m  z     schulte  c          propagator groups  proceedings cp       pp 
       
lecoutre  c          str   optimized simple tabular reduction table constraints  constraints                 
lecoutre  c     szymanek  r          generalized arc consistency positive table constraints  proceedings cp       pp         
lhomme  o     regin  j  c          fast arc consistency algorithm n ary constraints 
proceedings aaai       pp         
lhomme  o          efficient filtering algorithm disjunction constraints 
proceedings cp       pp         
lhomme  o          arc consistency filtering algorithms logical combinations constraints  integration ai techniques constraint programming
combinatorial optimization problems  cp ai or     pp         
mackworth  a  k          reading sketch maps  reddy  r   ed    ijcai  pp         
william kaufmann 
mears  c  d          automatic symmetry detection dynamic symmetry breaking
constraint programming  ph d  thesis  clayton school information technology 
monash university 
mohr  r     henderson  t  c          arc path consistency revisited  artificial intelligence                 
  

fishort long supports constraint propagation

nightingale  p          extended global cardinality constraint  empirical survey 
artificial intelligence                  
nightingale  p   gent  i  p   jefferson  c     miguel  i          exploiting short supports
generalised arc consistency arbitrary constraints  proceedings ijcai      
pp         
puget  j  f          automatic detection variable value symmetries  proceedings
cp       pp         
regin  j  c          generalized arc consistency global cardinality constraint  proceedings aaai       pp         
regin  j  c          maintaining arc consistency algorithms search without
additional space cost  proceedings cp       pp         
rossi  f   van beek  p     walsh  t   eds            handbook constraint programming 
elsevier 
schulte  c     tack  g          implementing efficient propagation control  proceedings
trics  techniques implementing constraint programming systems  conference
workshop cp       st andrews  uk 
simonis  h     osullivan  b          search strategies rectangle packing  proceedings
cp       pp       
wurtz  j     muller  t          constructive disjunction revisited  proceedings
  th annual german conference artificial intelligence  advances artificial
intelligence  ki     pp          springer verlag 

  


