journal of artificial intelligence research                 

submitted       published     

on the testability of bdi agent systems
michael winikoff
stephen cranefield

michael winikoff otago ac nz
stephen cranefield otago ac nz

department of information science
university of otago
new zealand

abstract
before deploying a software system we need to assure ourselves  and stakeholders  that
the system will behave correctly  this assurance is usually done by testing the system 
however  it is intuitively obvious that adaptive systems  including agent based systems 
can exhibit complex behaviour  and are thus harder to test  in this paper we examine this
obvious intuition in the case of belief desire intention  bdi  agents  we analyse the
size of the behaviour space of bdi agents and show that although the intuition is correct 
the factors that influence the size are not what we expected them to be  specifically  we
found that the introduction of failure handling had a much larger effect on the size of the
behaviour space than we expected  we also discuss the implications of these findings on
the testability of bdi agents 

   introduction
increasingly we are called upon to develop software systems that operate in dynamic environments  that are robust in the face of failure  that are required to exhibit flexible behaviour  and that operate in open environments  one approach for developing such systems
that has demonstrated its effectiveness in a range of domains is the use of the metaphor
of software agents  wooldridge         agent based systems have been increasingly finding
deployment in a wide range of applications  e g  munroe  miller  belecheanu  pechoucek 
mcburney    luck        benfield  hendrickson    galanti        
as agent based systems are increasingly deployed  the issue of assurance rears its head 
before deploying a system  we need to convince those who will rely on the system  or those
who will be responsible if it fails  that the system will  in fact  work  traditionally  this
assurance is done through testing    however  it is generally accepted that adaptive systems
can exhibit a wide and complex range of behaviours  making testing hard  for example 
validation through extensive tests was mandatory         however  the task proved
challenging         agent based systems explore realms of behaviour outside peoples expectations and often yield surprises   munroe et al         section       
that is  there is an intuition that agent systems exhibit complex behaviour  which makes
them hard to test  in this paper we explore this intuition  focusing on the well known beliefdesire intention  bdi  approach to realising adaptive and flexible agents  rao   georgeff 
   although there is considerable research on formal methods in the context of agent systems  dastani 
hindriks    meyer         it is not yet ready for real world application  see section     and there are
concerns about the scope of the work and its applicability  winikoff        
c
    
ai access foundation  all rights reserved 

fiwinikoff   cranefield

      bratman         which has been demonstrated to be practically applicable  resulting
in reduced development cost and increased flexibility  benfield et al         
we explore the intuition that agent systems are hard to test by analysing both the
space of possible behaviours of bdi agents  that is  the number of paths through a bdi
program  and the probability of failure  we focus on bdi agents because they provide a welldefined execution mechanism that can be analysed  and also because we seek to understand
the complexities  and testability implications  of adaptive and intelligent behaviour in the
absence of parallelism  since the implications of parallelism are already well known  
we derive the number of paths through a bdi program as a function of various parameters  e g  the number of applicable plans per goal and the failure fate   this naturally
leads us also to consider how the number of paths is affected by these various parameters 
as might be expected  we show that the intuition that agent systems are hard to test is
correct  i e  that agent systems have a very large number of paths  we also show that bdi
agents are harder to test than procedural programs  by showing that the number of paths
through a bdi program is much larger than the number of paths through a similarly sized
procedural program 
the contribution of this paper is threefold  firstly  it confirms the intuition that bdi
programs are hard to test  secondly  it does so by quantifying the number of paths  as a
function of parameters of the bdi program  thirdly  we find some surprising results about
how the parameters influence the number of paths 
although there has recently been increasing interest in testing agent systems  zhang 
thangarajah    padgham        ekinci  tiryaki  cetin    dikenelli        gomez sanz 
bota  serrano    pavon        nguyen  perini    tonella      b   there has been surprisingly little work on determining the feasibility of testing agent systems in the first place 
padgham and winikoff        pp        analyse the number of successful executions of a
bdi agents goal plan tree  defined in section     but they do not consider failure or failure
handling in their analysis  nor do they consider testability implications  shaw  farwer and
bordini        have analysed goal plan trees and shown that checking whether a goal plan
tree has an execution schedule with respect to resource requirements is np complete  this
is a different problem to the one that we tackle  they are concerned with the allocation of
resources amongst goals  rather than with the behaviour space 
we now briefly address a number of possible criticisms of this work  by considering
existing work 
   is the number of paths a useful metric for assessing testability 
we consider the related area of software testing  section      and argue that the
metric is a well established one  and is appropriate to use to assess testability 
   isnt this just an obvious corollary of the complexity of htn planning 
we consider in detail the htn planning problem  section      and argue that although
the bdi execution cycle has certain similarities with htn planning  the differences
are significant  and  in particular  they mean that the problem of htn planning is
simply different from the problem of testing bdi programs 
   why use combinatorial analysis  rather than complexity analysis 
our combinatorial analysis is more precise  it yields formulae for the exact number
  

fion the testability of bdi agent systems

of paths  and the exact probabilities of failure  the latter  see section      is more
informative than just having an order of magnitude complexity  additionally it allows
us to consider issues that complexity analysis would not address  such as the effect of
number of failures on the number of paths 
    software testing
we are trying to assess how hard agent systems are to test  more concretely  given a bdi
agent program  we want to know how hard that program is to test  this can be reduced
directly to the question of test set adequacy  an agent program p is easy to test precisely
to the extent that there exists a test set t which is adequate for testing p   where t is
not infeasibly large  conversely  an agent program p is hard to test to the extent that an
adequate test set t would have to be infeasibly large  in other words  the hardness of
testing a program is directly assessed by the size required for a test set to be adequate with
respect to a suitable adequacy criteria 
there are many criteria that can be used to assess whether a given set of tests is adequate  for a recent overview  see mathur         given that we are interested in assessing
the difficulty of testing a given program  we are clearly looking at white box testing  furthermore  we will be working with abstract goal plan trees rather than detailed programs
 see section     this means that we need to consider control flow based metrics  rather
than data flow  since an abstract goal plan tree does not contain data flow information 
focussing on white box testing criteria that are control flow based  a basic and very
long standing criterion for assessing test set adequacy is that all paths in the program be
covered  miller   maloney         for example  consider a program of the following form 
       then do a
   input x

   if condition    

   endif

   do c

       else do b

there are two paths through this program                  and                  and an
adequate test set must have at least two tests to be adequate  one to exercise the first path 
and another to exercise the second  in this case a test set with only a single test will be
inadequate  and will result in part of the program not being executed at all during testing 
an obvious complication in covering all paths in a program is that any loop will result
in an infinite number of paths  since the loop can potentially be executed any number of
times  the standard technique for dealing with this is to bound the length of paths  or the
number of executions of a loop  zhu  hall    may        p        bounding the execution of
loops can be done either by calculating an upper bound on the number of iterations based
on the data  mathur        p       or by only considering paths in which loops are executed
zero times or one time  mathur        p       
one question that might be asked is why we consider all paths  rather than a weaker
criterion  agent applications typically involve environments that are non episodic  that is 
the environments history matters  this means that the behaviour of a given plan or goal
is  in general  sensitive to the agents history  and hence we need to consider the different
possible histories  achieving a goal may be different if it is being done as the first thing the
  

fiwinikoff   cranefield

agent does  or after a failed plan which has already performed a number of actions  this
means that it makes sense to consider a path based criterion for testing 
furthermore  although the all paths adequacy criterion is often considered to be impractical  the reason appears to be primarily the existence of an infinite number of paths in
the presence of loops  for instance  zhu et al         p       say the plan coverage criterion
is too strong to be practically useful for most programs  because there can be an infinite
number of different paths in a program with loops  in our setting  where we do not have
loops  the existence of an infinite number of paths is not an issue  so considering the number
of paths is possible 
we therefore use the number of paths as our proxy measure for testing difficulty  if
there are few paths through the program  then an adequate test set  according to the all
paths criterion  will not need to be large  on the other hand  if the number of paths is
very large  then any adequate test set will need to be very large 
there is one issue we need to consider  since all paths is a strong criterion  it is
possible that  even in the absence  or bounding  of loops  this criterion always results in
an infeasibly large numbers of paths  in order to address this issue we also do an analysis
of the number of paths in procedural programs  of equivalent size   and compare this with
the number of paths for bdi programs  see section    
finally  it bears noting that the all paths criterion only considers which parts of the
program were traversed during testing  but ignores the values of variables  so  for example 
a trivial program consisting of the single statement x    x  x has a single one step path 
which is trivially covered  but many traces  x                  
    htn planning
there are similarities between hierarchical task network  htn  planning  erol  hendler 
  nau        and bdi execution  de silva   padgham         both use a hierarchical
representation with goals  non primitive tasks in htn terminology   plans  decomposition methods  and goal plan trees  task networks   the complexity of htn planning
has been explored  given these similarities  can we simply exploit these known complexity
results 
it turns out that we cannot do so  for the simple reason that the complexity of htn
planning concerns the plan finding problem  which is different to bdi plan execution  as
sardina and padgham explain 
bdi agent systems and htn planners come from different communities and
differ in many important ways  the former focus on the execution of plans 
whereas the latter is concerned with the actual generation of such plans  the
former are generally designed to respond to goals and information  the latter
are designed to bring about goals  in addition  bdi systems are meant to be
embedded in the real world and therefore take decisions based on a particular
 current  state  planners  on the other hand  perform hypothetical reasoning
about actions and their interactions in multiple potential states  thus  failure
has very different meaning for these two types of systems  in the context
of planning  failure means that a plan or potential plan is not suitable  within
bdi agent systems failure typically means that an active  sub plan ought to be
  

fion the testability of bdi agent systems

aborted  whereas backtracking upon failure is an option for planning systems  it
is generally not for bdi systems  as actions are taken in the real world   sardina
  padgham        p      bold emphasis added 
in other words  htn systems plan ahead of execution  whereas bdi systems interleave
execution and planning   
the htn plan existence problem answers the question does a plan exist  and its
complexity has been studied  in settings that correspond to bdi execution  many goals 
total ordering within plans  and with variables  it is known to be expspace hard and
in dexptime  erol  hendler    nau               however  this work does not address
the question of bdi execution  when considering the complexity of plan existence in htn
planning we are asking about the computational complexity of a search process that will
result in a plan  on the other hand  when we are asking about the number of paths in a
goal plan tree we are asking about the possibilities that arise when executing a plan 
to illustrate this point  consider the following example  suppose we have a single goal
g which can be decomposed into two alternative plans  p  and p    plan p  consists of the
sequential execution of actions a  b  and c  and plan p  consists of the sequential execution
of actions d and e  the plan existence problem boils down to considering the options p 
and p    since in this case the search space is very simple  offering only two options  on the
other hand  the question of how many paths exist in bdi execution considers the different
ways in which the goal plan tree can be executed  whereas htn planning considers p  as a
single atomic decomposition  bdi execution needs to consider the sequence of actions a  b  c
as distinct steps  it is possible for all three actions to succeed  giving the trace a  b  c   but
it also possible for action b to fail  followed by p  being  successfully  used  giving the trace
a  b   d  e   or for action c to fail  followed by p  being  successfully  used  giving the trace
a  b  c   d  e  
overall  this means that the complexity analysis of erol et al               is of a
different problem  and that the htn complexity results are not relevant  finally  we note
that  in fact  in our setting  the plan existence problem is actually trivially true  since
bdi programs do not have constraints there is always an expansion of the program into a
sequence of actions 
the remainder of this paper is structured as follows  we begin by briefly presenting
the bdi execution model  section    and discussing how bdi execution can be viewed as a
process of transforming goal plan trees  section     section   is the core of the paper where
we analyse the number of paths in a bdi style goal plan tree  we then consider how our
analysis and its assumptions hold up against a real system and a real platform  section    
and how our analysis of bdi programs compares with the same analysis  number of paths 
of conventional procedural programs  section     finally  we conclude with a discussion of
the implications for testing and future work  section    
   there are approaches that blur this difference by adding look ahead planning to bdi or online execution
to htns  for example the planner in the retsina multi agent system  paolucci  shehory  sycara  kalp 
  pannu        has the ability to interleave planning and execution  however  no theoretical analysis
of this extension has been reported  and the analysis of erol  hendler  and nau              applies to
classical htn planning 

  

fiwinikoff   cranefield

   the bdi execution model
before we describe the belief desire intention  bdi  model we explain why we chose this
model of agent execution  in addition to being well known and widely used  the bdi model
is well defined and generic  that it is well defined allows us to analyse the behaviour spaces
that result from using it  that it is generic implies that our analysis applies to a wide range
of platforms 
the bdi model can be viewed from philosophical  bratman        and logical  rao
  georgeff        perspectives  but we are interested here in the implementation perspective  as exhibited in a range of architectures and platforms  such as jack  busetta 
ronnquist  hodgson    lucas         jam  huber         dmars  dinverno  kinny  luck 
  wooldridge         prs  georgeff   lansky        ingrand  georgeff    rao        
um prs  lee  huber  kenny    durfee         jason  bordini  hubner    wooldridge 
       spark  morley   myers         jadex  pokahr  braubach    lamersdorf       
and irma  bratman  israel    pollack         for the purposes of our analysis here  a
formal and detailed presentation is unnecessary  those interested in formal semantics for
bdi languages are referred to the work of rao         winikoff  padgham  harland  and
thangarajah        and bordini et al          for example 
in the implementation of a bdi agent the key concepts are beliefs  or  more generally 
data   events and plans  the reader may find it surprising that goals are not key concepts in
bdi systems  the reason is that goals are modelled as events  the acquisition of a new goal
is viewed as a new goal event  and the agent responds by selecting and executing a plan
that can handle that event    in the remainder of this section  in keeping with established
practice  we will describe bdi plans as handling events  not goals  
a bdi plan consists of three parts  an event pattern specifying the event s  it is relevant
for  a context condition  a boolean condition  that indicates in what situations the plan can
be used  and a plan body that is executed  a plans event pattern and context condition
may be terms containing variables  so a matching or unification process  depending on the
particular bdi system  is used by bdi interpreters to find plan instances that respond to
a given event  in general the plan body can contain arbitrary code in some programming
language    however for our purposes we assume  that a plan body is a sequence of steps 
where each step is either an action   which can succeed or fail  or an event to be posted 
for example  consider the simple plans shown in figure    the first plan  plan a  is
relevant for handling the event achieve goal go home  and it is applicable in situations
where the agent believes that a train is imminent  the plan body consists of a sequence of
four steps  in this case we assume that these are actions  but they could also be modelled
as events that are handled by further plans  
a key feature of the bdi approach is that each plan encapsulates the conditions under
which it is applicable by defining an event pattern and context condition  this allows
for additional plans for a given event to be added in a modular fashion  since the invoking
   other types of event typically include the addition and removal of beliefs from the agents belief set 
   for example  in jack a plan body is written in a language that is a superset of java 
   this follows abstract notations such as agentspeak l   rao        and can  winikoff et al        
which aim to capture the essence of a range of  more complex  bdi languages 
   this includes both traditional actions that affect the agents environment  and internal actions that
invoke code  or that check whether a certain condition follows from the agents beliefs 

  

fion the testability of bdi agent systems

plan a  handles event 
achieve goal go home
context condition 
train imminent
plan body 
    walk to train station
    check train running on time
    catch train
    walk home
plan b  handles event 
achieve goal go home
context condition 
not raining and have bicycle
plan body 
    cycle home
plan c  handles event 
achieve goal go home
context condition 
true  i e  always applicable 
plan body 
    walk to bus stop
    check buses running
    catch bus
    walk home
figure    three simple plans
context  i e  where the triggering event is posted  does not contain code that selects amongst
the available plans  and this is a key reason for the flexibility of bdi programming 
a typical bdi execution cycle is an elaboration of the following event driven process
 summarised in figure      
   an event occurs  either received from an outside source  or triggered from within the
agent  
   the agent determines a set of instances of plans in its plan library with event patterns
that match the triggering event  this is the set of relevant plan instances 
   the agent evaluates the context conditions of the relevant plan instances to generate
the set of applicable plan instances  a relevant plan instance is applicable if its context
condition is true  if there are no applicable plan instances then the event is deemed
to have failed  and if it has been posted from a plan  then that plan fails  note that a
single relevant plan may lead to no applicable plan instances  if the context condition
is false   or to more than one applicable plan instance  if the context condition  which
may contain free variables  has multiple solutions  
   one of the applicable plan instances is selected and is executed  the selection mechanism varies between platforms  for generality  our analysis does not make any as   bdi engines are  in fact  more complicated than this as they can interleave the execution of multiple
active plan instances  or intentions  that were triggered by different events 

  

fiwinikoff   cranefield

boolean function execute an event 
let relevant plans   set of plan instances resulting from
matching all plans event patterns to an event
let tried plans   
while true do
let applicable plans   set of plan instances resulting from
solving the context conditions of relevant plans
applicable plans    applicable plans   tried plans
if applicable plans is empty then return false
select plan p  applicable plans
tried plans    tried plans   p 
if execute p body    true then return true
endwhile
boolean function execute plan body 
if plan body is empty then return true
elseif execute first plan body     false then return false
else return execute rest plan body  
endif
boolean function execute action 
attempt to perform the action
if action executed successfully then return true else return false endif

figure    bdi execution cycle
sumptions about plan selection  the plans body may create additional events that
are handled using this process 
   if the plan body fails  then failure handling is triggered 
for brevity  in the remainder of the paper we will use the term plan loosely to mean
either a plan or plan instance where the intention is clear from context 
regarding the final step  there are a few approaches to dealing with failure  perhaps
the most common approach  which is used in many of the existing bdi platforms  is to
select an alternative applicable plan  and only consider an event to have failed when there
are no remaining applicable plans  in determining alternative applicable plans one may
either consider the existing set of applicable plans  or re calculate the set of applicable
plans  ignoring those that have already been tried   as is done in figure    this makes
sense because the situation may have changed since the applicable plans were determined 
many  but not all  bdi platforms use the same failure handling mechanism of retrying
plans upon failure  and our analysis applies to all of these platforms 
one alternative failure handling approach  used by jason  bordini et al          is to
post a failure event that can be handled by a user provided plan  although this is more
flexible  since the user can specify what to do upon failure  it does place the burden of
  

fion the testability of bdi agent systems

specifying failure handling on the user  note that jason provides a pattern that allows the
traditional bdi failure handling mechanism to be specified succinctly  bordini et al        
pp           another alternative failure handling approach is used by  apl  dastani 
      and its predecessor   apl  they permit the programmer to write plan repair rules
which conditionally rewrite a  failed  plan into another plan  this approach  like jasons 
is quite flexible  but is not possible to analyse in a general way because the plan rules can
be quite arbitrary  another well known bdi architecture is irma  which is described at a
high level and does not prescribe a specific failure handling mechanism 
a full development of this architecture would have to give an account of the
ways in which a resource bounded agent would monitor her prior plans in the
light of changes in belief  however this is developed  there will of course be
times when an agent will have to give up a prior plan in light of a new belief
that this plan is no longer executable  when this happens  a new process of
deliberation may be triggered  bratman et al         
given the bdi execution cycle discussed above  the three example plans given earlier
 figure    can give rise to a range of behaviours  including the following 
 suppose the event achieve goal go home is posted and the agent believes that a
train is imminent  it walks to the train station  finds out that the train is running on
time  catches the train  and then walks home 
 suppose that upon arrival at the train station the agent finds out that trains are
delayed  step     of plan a fails  and the agent considers alternative plans  if it is
raining at the present time  then plan b is not applicable  and so plan c is adopted
 to catch the bus  
 suppose that the agent has decided to catch the bus  because no train is believed to
be imminent  and it is raining   and that attempting to execute plan c fails  e g  there
is a bus strike   the agent will reconsider its plans and if the rain has stopped  and
it has a bicycle  it may then use plan b 
note that correct  respectively incorrect  behaviour is distinct from successful
 respectively failed  execution of a plan  software testing is in essence the process of running a system and checking whether an observed behaviour trace is correct  i e  conforms
to a specification  which we do not model   on the other hand  bdi agents behaviour traces
are classified as being successful or failed  however  the correctness of a given execution
trace is independent of whether the trace is of a successful or failed execution  a successful
execution may  in fact  exhibit behaviour that is not correct  for instance  a traffic controller
agent may successfully execute actions that set all traffic signals at an intersection to green
and achieve a goal by doing so  this is a successful execution  but incorrect behaviour  it is
also possible for a failed execution to be correct  for instance  if a traffic controller agent is
attempting to route cars from point a to point b  but a traffic accident has blocked a key
bridge between these two points  then the rational  and correct  behaviour for the agent is
to fail to achieve the goal 
  

fiwinikoff   cranefield

   bdi execution as goal plan tree expansion
bdi execution  as summarised in figure    is a dynamic process that progressively executes
actions as goals are posted  in order to more easily analyse this process  we now present an
alternative view that is more declarative  instead of viewing bdi execution as a process 
we view it as a data transformation from a  finite  goal plan tree into a sequence of action
executions 
the events and plans can be visualised as a tree where each goal  has as children the
plan instances that are applicable to it  and each plan instance has as children the sub goals
that it posts  this goal plan tree is an and or tree  each goal is realised by one of its plan
instances  or  and each plan instance needs all of its sub goals to be achieved  and  
viewing bdi execution in terms of a goal plan tree and action sequences makes the
analysis of the behaviour space size  easier  we consider bdi execution as a process of taking
a goal plan tree and transforming it into a sequence recording the  failed and successful 
executions of actions  by progressively making decisions about which plans to use for each
goal and executing these plans 
this process is non deterministic  we need to choose a plan for each goal in the tree 
furthermore  when we consider failure  we need to consider for each action whether it fails
or not  and if it does fail  what failure recovery is done 
we now define the transformation process in detail  prolog code implementing the
process can be found in figure    it defines a non deterministic predicate exec with its first
argument being the  input  goal plan tree  and the second argument an  output  sequence
of actions  a goal plan tree is represented as a prolog term conforming to the following
simple grammar  where gpt abbreviates goal plan tree  aogl abbreviates action or
goal list  and a is a symbol  
hgpt i     goal       goal  hplanlisti  
hplanlisti     hplani   hplani hplanlisti
hplani     plan       plan  haogli  
haogli     act a    hgpt i   act a  haogli   hgpt i haogli
for example  the simple goal plan tree shown in figure   is modelled by the prolog term
goal  plan  act a     plan  act b      
in our analysis we make a simplifying assumption  instead of modelling the instantiation
of plans to plan instances  we assume that the goal plan tree contains applicable plan
instances  thus  in order to transform a goal node into a sequence of actions we  nondeterministically  select one of its applicable plan instances  the selected plan is then
transformed in turn  resulting in an action sequence  line   in figure     when selecting a
plan  we consider the possibility that any of the applicable plans could be chosen  not just
the first plan  this is done because at different points in time different plan instances may
be applicable  we saw an example of this earlier  where plan a was chosen and failed  then
   in order to be consistent with existing practice we shall use the term goal rather than event in the
remainder of this paper 
   in the remainder of this paper we will use the term behaviour space size  rather than the more
cumbersome term number of paths through a bdi program 

  

fion the testability of bdi agent systems

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  

exec   goal           
exec   goal   plans     trace       remove   plans   plan   rest     exec   plan   trace     
  failed   trace       recover   rest   trace    trace     trace   trace    
exec   plan            
exec   plan    step   steps      trace       exec   step   trace     
  failed   trace       trace   trace    continue   steps   trace    trace    
exec   act   action       action    
exec   act   action       action   fail    
failed   trace       append  x    fail     trace   
recover   plans   trace    traces     exec   goal   plans     trace      append   trace    trace    traces   
continue   steps   trace    trace       exec   plan   steps     trace     
append   trace    trace    trace   
remove    x   xs    x   xs   
remove    x   xs    y    x   z        remove   xs  y   z   

figure    prolog code to expand goal plan trees
goal
plan

plan

a

b

figure    a simple goal plan tree

plan c was selected  and also failed   and then finally plan b  which was not applicable
when plan a failed  was selected 
if the selected plan executes successfully  i e  the action trace doesnt end with a fail
marker  line     then the resulting trace is the trace for the goals execution  line     otherwise  we perform failure recovery  line      which is done by taking the remaining plans
and transforming the goal with these plans as options  the resulting action sequence is
appended to the action sequence of the failed plan to obtain a complete action sequence for
the goal 
this process can easily be seen to match that described in figure    with the exception 
discussed above  that we begin with applicable plans  not relevant plans   specifically  an
applicable plan is selected and executed  and if it is successful then execution stops  if it
is not successful  then an alternative plan is selected and execution continues  i e  action
sequences are appended  
in order to transform a plan node we first transform the first step of the plan  which is
either a sub goal or an action  line     if this is successful  then we continue to transform
the rest of the plan  and append the two resulting traces together  lines   and      if the
first step of the plan is not successful  then the trace is simply the trace of the first step
 line     in other words we stop transforming the plan when a step fails  again  this process
can easily be seen to correspond to plan body execution in figure   
  

fiwinikoff   cranefield

finally  in order to transform an action into an action sequence we simply take the
action itself as a singleton sequence  line     however  we do need to also take into account
the possibility that an action may fail  and thus a second possibility is the action followed
by a failure indicator  line     again  this process can easily be seen to correspond to action
execution in figure    note that in our model we dont concern ourselves with why an
action fails  it could be because of a lack of resources  or other environmental issues 
an example of applying this process to two example goal plan trees can be found in
appendix a 

   behaviour space size of bdi agents
we now consider how many paths there are through a goal plan tree that is being used by
a bdi agent to realise a goal   using that tree  we use the analysis of the previous section
as our basis  that is  we view bdi execution as transforming a goal plan tree into action
traces  thus  the question of how large the behaviour space is for bdi agents  is answered
by deriving formulae that allow one to compute the number of behaviours  both successful
and unsuccessful  i e  failed   for a given goal plan tree 
we make the following uniformity assumptions that allow us to perform the analysis 
these simplifying assumptions concern the form of the goal plan tree 
   we assume that all subtrees of a goal or plan node have the same structure  that is 
all of the leaves of the goal plan tree are the same distance  number of edges  away
from the root of the tree  we can therefore define the depth of a goal plan tree as
the number of layers of goal nodes it contains  a goal plan tree of depth   is a plan
with no sub goals  while a goal plan tree of depth d     is either a plan node with
children that are goal nodes at depth d or a goal node with children that are plan
nodes at depth d     note that this definition of depth is the reverse of the usual
definition  where the depth of the trees root is defined as     we use this definition
as it simplifies the presentation of the derivations later in this section 
   we assume that all plan instances at depth d     have k sub goals 
   we assume that all goals have j applicable plan instances  this can be the case if
each goal has j relevant plans  each of which results in exactly one applicable plan
instance  but can also be the case in other ways  for instance  a goal may have  j
relevant plans  half of which are applicable in the current situation  or a goal may have
a single relevant plan that has j applicable instances  note that this assumption rules
out the possibility of there being an infinite number of applicable plan instances  which
would be the case if a plans context condition has an infinite number of solutions 
this cannot occur if the context condition is defined in terms of conjunctions over
propositions that refer to a finite belief base  however  it can occur if the agents
context conditions can also make use of a prolog like knowledge base  as is the case in
some agent oriented programming languages  such as jason or goal   nevertheless 
since we deal with applicable plans  we dont model context conditions 
    we focus on a single goal in our analysis  multiple goals can be treated as the concurrent interleaving
of the individual goals  multiple agents can also be treated as concurrent interleaving  but some care
needs to be taken with the details where an agent is waiting for another agent to respond 

  

fion the testability of bdi agent systems

figure   shows a uniform goal plan tree of depth   
g 

d  

 
r pj 
p           
  
 
 
 
r
 
g         gk 
  
 
 
 
r
 
p         pj 

d  
d  
d  

figure    a uniform goal plan tree
the assumptions made are clearly unrealistic  this means that we have to consider
the possibility that real agent programs behave quite differently  since they do not meet
these assumptions  we address this issue in a number of ways  firstly  in section    
we consider a relaxation of the assumptions by defining semi uniform trees  in which the
number of available plan instances  j  can vary across different levels of the tree  secondly 
in section     we consider an example of a  non uniform  goal plan tree from an industrial
application  we derive the number of paths for this real goal plan tree and compare it to
the analysis of similarly sized uniform goal plan trees to see whether a real  non uniform 
tree has a significantly lower number of paths than a uniform tree  finally  in section     
we consider the issue of infinite trees by allowing trees to be recursive  and defining the
number of paths  up to a bound on the path length  of a recursive tree 
our analysis uses the following terminology 
 our uniformity assumptions mean that the structure of the subtree rooted at a goal
or plan node is determined solely by its depth  and we can therefore denote a goal or
plan node at depth d as gd or pd  respectively  
 we use n  xd   to denote the number of successful execution paths of a goal plan tree
of depth d rooted at x  where x is either a goal g or a plan p   where specifying d is
not important we will sometimes elide it  writing n  x  
 similarly  we use n  xd   to denote the number of unsuccessful execution paths of a
goal plan tree of depth d with root x  either g or p  
 we extend this notation to plan body segments  i e  sequences x            xn where each xi
is a goal or action and   denotes sequential composition  we abbreviate a sequence
of n occurrences of x by xn  for example  g     g    g    g    
    base case  successful executions
we begin by calculating the number of successful paths through a goal plan tree in the
absence of failure  and of failure handling   this analysis follows that of padgham and
winikoff        pp        
roughly speaking  the number of ways a goal can be achieved is the sum of the number
of ways in which its children can be achieved  since the children represent alternatives 
  

fiwinikoff   cranefield

i e  the goal is represented by an or node   on the other hand  the number of ways a plan
can be achieved is the product of the number of ways in which its children can be achieved
 since the children must all be achieved  i e  the plan is represented by an and node  
more precisely  n  x    x      n  x    n  x     that is  the sequence is successful if both x  and
x  are successful 
given a tree with root g  a goal   assume that each of its j children can be achieved in
n different ways     then  because we select one of the children  the number of ways in which
g can be achieved is jn  similarly  for a tree with root p  a plan   assume that each of its
k children can be achieved in n different ways  then  because we execute all of its children 
the number of ways in which p can be executed is n    n  or nk   a plan with no children
 i e  at depth    can be executed  successfully  in exactly one way  this yields the following
definition 
n  gd     j n  pd   
n  p       
n  pd     n  gd k     n  gd  k
expanding this definition we obtain
n  g      j n  p      j     j
k

n  g      j n  p      j  n  g        j  j k     j k  
n  g      j n  p      j  j k    k   j k
n  g      j n  p      j  j k

   k  

   k  

 k   j k

   k    k  

which can be generalised to 
n  gd     j

pd 
i  

ki

if k     this can be simplified using the equivalence k i            k     k        k i      k    
to give the following closed form definition   and if k     we have n  gd     n  pd     j d  
n  gd     j  k
 

n  pd     j

d     k  

k  kd     k  

   
   

note that the equation for n  pd   assumes that sub goals are achieved sequentially  if
they are executed in parallel then the number of options is higher  since we need to consider
all possible interleavings of the sub goals execution  for example  suppose that a plan pd
has two sub goals  g d and g d   where each of the sub goals has n  gd   successful executions 
and each execution has l steps  we assume for ease of analysis that both execution paths
have the same length   the number of ways of interleaving two parallel executions  each of
length l  can be calculated as follows  naish        section    


   l  
 l
 
l
 l    l  
    because the tree is assumed to be uniform  all of the children can be achieved in the same number of
ways  and are thus interchangeable in the analysis  allowing us to write j n rather than n            nj  

  

fion the testability of bdi agent systems

and hence the number of ways of executing pd with parallel execution of subgoals is 
 

 

 



n  pd     n  gd  

 l
l



  n  gd   

   l  
 l    l  

in the remainder of this paper we assume that the sub goals of a plan are achieved
sequentially  since this is the common case  and since it yields a lower figure which  as we
shall see  is still large enough to allow for conclusions to be drawn 
    adding failure
we now extend the analysis to include failure  and determine the number of unsuccessful
executions  i e  executions that result in failure of the top level goal  for the moment we
assume that there is no failure handing  we add failure handling in section      
in order to determine the number of failed executions we have to know where failure
can occur  in bdi systems there are two places where failure occurs  when a goal has no
applicable plan instances  and when an action  within an applicable plan instance  fails 
however  our uniformity assumption means that we do not address the former caseit is
assumed that a goal will always have j instances of applicable plans  note that this is a
conservative assumption  relaxing it results in the number of unsuccessful executions being
even larger 
in order to model the latter case we need to extend our model of plans to encompass
actions  for example  suppose that a plan has a body of the form a   ga  a   gb  a  where ai
are actions  ga and gb are sub goals  and   denotes sequential execution  then the plan
has the following five cases of unsuccessful  i e  failed  executions 
   a  fails
   a  succeeds  but then ga fails
   a  and ga succeed  but a  fails
   a   ga  and a  succeed  but then gb fails
   a   ga  a  and gb succeed  but a  fails
suppose that ga can be executed successfully in n  ga  different ways  then the third
case corresponds to n  ga  different failed executions  for each successful execution of ga 
extend it by adding a failed execution of a   actions can only be executed in one way 
i e  n  a      and n  a        similarly  if gb has n  gb  successful executions then the fifth
case corresponds to n  ga  n  gb  different failed executions  if ga can be unsuccessfully
executed in n  ga  different ways then the second case corresponds to n  ga  different executions  similarly  the fourth case corresponds to n  ga  n  gb  different executions  putting
this together  we have that the total number of unsuccessful executions for a plan p with
body a   ga  a   gb  a  is the sum of those for the above five cases 
    n  ga    n  ga    n  ga  n  gb    n  ga  n  gb 
  

fiwinikoff   cranefield

more formally  n  x    x      n  x      n  x    n  x     that is  the sequence can fail if either
x  fails  or if x  succeeds but x  fails  it follows that n  xk     n  x k and n  xk    
n  x            n  x k     which can easily be proven by induction 
more generally  we assume there are   actions before  after  and between the sub goals
in a plan  i e  the above example plan corresponds to        and the following plan body
corresponds to        a   a   g   a   a   g   a   a   a plan with no sub goals  i e  at depth
   is considered to consist of   actions  which is quite conservative  in particular  when we
use       we assume that plans at depth   consist of only a single action  
the number of unsuccessful execution traces of a goal plan tree can then be defined 
based on the analysis above  as follows  first we calculate the numbers of successes and
failures of the following repeated section of a plan body  gd   a   
n  gd   a      n  gd   n  a   
  n  gd   n  a  
  n  gd     
  n  gd  
n  gd   a      n  gd     n  gd   n  a   
  n  gd     n  gd   n  a            n  a     
  n  gd     n  gd    
we then have for d     
n  pd     n  a     gd   a   k  
  n  a      n  a    n   gd   a   k  
  n  a            n  a         n  a   n   gd   a   k  
        n  gd   a              n  gd   a   k   
       n  gd     n  gd                n  gd  k    
n  gd  k   
       n  gd       n  gd     
 assuming n  gd       
n  gd     
this yields the following definitions for the number of unsuccessful executions of a goalplan tree  without failure handling  the equation for n  gd   is derived using the same
reasoning as in the previous section  a single plan is selected and executed  and there are j
plans 
n  gd     j n  pd   
n  p       
n  gd  k   
n  gd     
 
 for d     and n  gd       

n  pd          n  gd       n  gd   

finally  we note that the analysis of the number of successful executions of a goal plan
tree in the absence of failure handling presented in section     is unaffected by the addition
of actions to plan bodies  this is because there is only one way for a sequence of actions to
succeed  so equations   and   remain correct 
  

fion the testability of bdi agent systems

    adding failure handling
we now consider how the introduction of a failure handling mechanism affects the analysis 
a common means of dealing with failure in bdi systems is to respond to the failure of a
plan by trying an alternative applicable plan for the event that triggered that plan  for
example  suppose that a goal g  e g  achieve goal go home  has three applicable plans pa 
pb and pc  that pa is selected  and that it fails  then the failure handling mechanism will
respond by selecting pb or pc and executing it  assume that pc is selected  then if pc fails 
the last remaining plan  pb  is used  and if it too fails  then the goal is deemed to have
failed 
the result of this is that  as we might hope  it is harder to fail  the only way a goal
execution can fail is if all of the applicable plans are tried and each of them fails    
the number of executions can then be computed as follows  if a goal gd has j applicable plan instances  each having n  pd    unsuccessful executions  then we have n  pd   j
unsuccessful executions of all of these plans in sequence  since the plans can be selected in
any order we multiply this by j  yielding n  gd     j  n  pd   j  
the number of ways in which a plan can fail is still defined by the same equation
because failure handling happens at the level of goalsbut where n  g  refers to the new
definition 
j

n  gd     j  n  pd   

   

 

n  p       

   
 

 k

n  gd   
n  gd     
 
 for d     and n  gd       

n  pd          n  gd       n  gd   

   

turning now to the number of successful executions  i e  n  x   we observe that the
effect of adding failure handling is to convert failures to successes  i e  an execution that
would otherwise be unsuccessful is extended into a longer execution that may succeed 
consider a simple case  a depth   tree consisting of a goal g  e g  achieve goal go home 
with three children  pa  pbandpc  previously the successful executions corresponded to each
of the pi  i e  select a pi and execute it   however  with failure handling  we now have
the following additional successful executions  as well as additional cases corresponding to
different orderings of the plans  e g  pb failing and then pa being successfully executed  
 pa fails  then pb is executed successfully
 pa fails  pb is then executed and fails  and then pc is executed and succeeds
this leads to a definition of the form
n  g    n  pa    n  pa  n  pb    n  pa  n  pb  n  pc 
    in fact  this is actually an underestimate  it is also possible for the goal to fail because none of the untried
relevant plans are applicable in the resulting situation  as noted earlier  we assume in our analysis that
goals cannot fail as a result of there being no applicable plan instances  this is a conservative assumption 
relaxing it results in the number of behaviours being even larger 

  

fiwinikoff   cranefield

however  we need to account for different orderings of the plans  for instance  the case
where the first selected plan succeeds  corresponding to the first term  n  pa   in fact applies
for each of the j plans  so the first term  including different orderings  is j n  p  
similarly  the second term  n  pa  n  pb    corresponding to the case where the initially
selected plan fails but the next plan selected succeeds  in fact applies for j initial plans  and
then for j    next plans  yielding j  j     n  p  n  p  
continuing this process  for j      yields the following formulae 
 

n  g      n  p       n  p  n  p       n  p  n  p 
which generalises to
j 

n  g    j n  p    j  j     n  p  n  p         j  n  p 

n  p 

resulting in the following equations  again  since failure handling is done at the goal level 
the equation for plans is the same as in section      
 

n  gd    

j
x

i 

n  pd   

n  pd   

i  

n  p       
 

j 
 j  i  

   
   

 

n  pd     n  gd  

k

 for d      

   

we have used the standard bdi failure handling mechanism of trying alternative
applicable plans  now let us briefly consider an alternative failure handling mechanism
that simply re posts the event  without tracking which plans have already been attempted 
it is fairly easy to see that this  in fact  creates an infinite number of behaviours  suppose
that a goal g can be achieved by pa or pb  then pa could be selected  executed resulting
in failure  and then pa could be selected again  fail again  etc  this suggests that the
standard bdi failure handling mechanism is  in fact  more appropriate  in that it avoids
an infinite behaviour space  and the possibility of an infinite loop  as discussed earlier  in
section     the failure recovery mechanism used by  apl and  apl  dastani        cannot
be analysed in a general way  since it depends on the details of the specific agent program 
and irma  bratman et al         does not provide sufficient details to allow for analysis 
tables   and   make the various equations developed so far concrete by showing illustrative values for n  and n  for a range of reasonable  and fairly low  values for j  k and
d and using        the number of columns show the number of goals  plans and actions in the tree  the number of actions in brackets is how many actions are executed in a
single  successful  execution with no failure handling  the number of goals is calculated
as follows  at depth   there is a single goal  see figure     at depth n     there are
     j  k  g n   goals  where g n  denotes the number of goals in a depth n tree  this
gives g n         j  k     j  k           j  k n    for example  for j   k      we have
g                       since each goal has exactly j plans  the number of plans in a tree
of depth n is just j  g n   we now consider the number of actions  each non leaf plan has
    k      actions  since it has k goals  there are k     places where there are   actions  
each leaf plan has   actions  a tree of depth n has j   j  k n  leaf plans  let p  n 
be the number of plans in a depth n tree  which is comprised of pn  n  non leaf plans and
  

fion the testability of bdi agent systems

parameters
j k
d
   
 
   
 
   
 
   
 

goals
  
  
   
   

number
plans
  
   
   
   

of
actions
       
        
        
        

n  g 
   
         

n  g 
   
         

                 

                 

              

              

table    illustrative values for n  g  and n  g  without failure handling  the first number under actions  e g      is the number of actions in the tree  the second
 e g      is the number of actions in a single execution where no failures occur 

parameters
j k
d
   
 
   
 
   
 
   
 

goals
  
  
   
   

number
plans
  
   
   
   

of
actions
       
        
        
        

n  g 
           
            
            
            

n  g 
           
            
            
            

table    illustrative values for n  g  and n  g  with failure handling
pl  n  leaf plans  i e  p  n    pn  n    pl  n   then the number of actions in a depth n tree
is      k        pn  n       pl  n   for example  for j   k     and        we have that
p          g          which is comprised of    leaf plans and    non leaf plans  there are
therefore                           actions 
    recurrence relations
the equations in the previous sections define the functions n  and n  as a mutual recurrence
on the depth d of a goal plan tree with a uniform branching structure  the effect of
increasing the parameters k and   is evident at each level of the recursion  but it is not
so clear what the effect is of increasing the number of applicable plan instances j for any
given goal  the aim of this section is to explore the effects of changing j  we do this by
relaxing our uniformity assumption  specifically  we allow the number of plans available to
vary for goal nodes at different depths in the tree  while still assuming that all nodes at a
given depth have the same structure  we refer to these as semi uniform goal plan trees 
we then derive a set of recurrence relations for n  and n  in the presence of failure handling
that explicitly show the effect of adding a new plan for a goal at the root of any particular
sub tree 
we begin by defining the generalised notation n  gj   and n  gj   where j is a list  
 jd   jd            j    in which each element ji represents the number of plans available for goals
at depth i of the goal plan tree  we denote the empty list by hi and write j  j to represent
the list with head j and tail j 
    the order corresponds to our definition of depth  which decreases down the tree 

  

fiwinikoff   cranefield

we can generalise equations   and   to apply to semi uniform goal plan trees  as the
derivation of these equations depended only on the sub nodes of each goal or plan node
having the same structure  this assumption is preserved in this generalised setting  we
therefore rewrite these equations below using this new notation  and also express the right
hand sides as functions f   and f   of n  pj   and  for f     n  pj    our aim is to find a recursive
definition of f   and f   as a recurrence on j 
n  gjj     f    j  n  pj   
n  gjj     f    j  n  pj    n  pj   
where
f    j  a    j  aj
f    j  a  b   

j
x

b ai 

i  

j 
 j  i  

 change bounds on i to         n  hence replace i by i     
 

j 
x

b a i    

i  

j 
 j   i       

 simplify using  j   i           j  i    j  i   
 

j 
x
i  

b ai

j  j  i 
 j  i  

 multiple by i  i  and reorder 
 

j 
x
i  

j 
i  ai  j  i  b
i  j  i  

 
j
 use definition of binomial 
  j  i  j  i   
i
j   
x
j
i  ai  j i  b
 
i

   

i  

the expression on the right of the last line above corresponds to the following combinatorial analysis of f     for a goal gjj   each successful execution will involve a sequence of
i plan executions thatfail  for some i     i  j     followed by one plan execution that
succeeds  there are ji ways of choosing the failed plans  which can be ordered in i  ways 
and each plan has a   n  pj   ways to fail  there are then j i ways of choosing the final
successful plan  which has b   n  pj   ways to succeed 
our goal is now to find an explicit characterisation of the incremental effect of adding an
extra plan on n  gjj   and n  gjj   by finding definitions of f   and f   as recurrence relations
in terms of the parameter j  deriving the recurrence relation for f   is straightforward 
f    j  a    j  aj    j  j                a
    a a      j a    j     a           a     a 
  a   z
j times
  

fion the testability of bdi agent systems

n  gjj     f    j  n  pj    n  pj   
n  gjj     f    j  n  pj   
f       a  b     
f    j     a  b     j      b   a f    j  a  b  

    

 

f     a     
 

f  j     a     j     a f    j  a 
n  phi      
n  phi      
n  pj     n  gj  k   for j    hi
 n  gj  k   
  for j    hi
n  pj         n  gj       n  gj  
n  gj     
figure    recurrence relations for the numbers of failures and successes of a goal plan tree
in the presence of failure handling

this shows that f       a      and f    j     a     j     a f    j  a 
however  the derivation of a recurrence relation for f   is not as simple  here we use
the technique of first finding an exponential generating function  e g f    wilf        for the
sequence  f    j  a  b  
j     and then using that to derive a recurrence relation  the details
are given in appendix b  and yield equation    in figure   
equation     copied from equation    in appendix b  gives us the recurrence relation
  
for the sequence  f    j  a  b  
j   that we have been seeking   figure   brings together the
equations we have so far for the failure handling case  including those from the previous
section defining n  pd   and n  pd    generalised for semi uniform trees  
this formulation gives us a different way of looking at the recurrence  and allows us to
more easily see how the behaviour space grows as the number of applicable plans  j  for a
goal grows  considering the meaning of the parameters a and b as the numbers of failures
and successes  respectively  of a plan at a level below the current goal node  the equation
for f    j     a  b  can be seen to have the following combinatorial interpretation  one plan
must be selected to try initially  there are j    choices  and it can either succeed  in one
of b different ways   meaning no further plans need to be tried  or fail  in one of a different
ways   if it fails  then the goal must then succeed using the remaining j plans  which can
occur in f    j  a  b  ways 
we can see that the growth in the number of successful executions for a goal grows at
a rate greater than j aj   because of the presence of the b term  the relaxed uniformity
    in the simple case when a   b     this is listed as sequence a       in the on line encyclopedia of
integer sequences  sloane         the number of permutations of nonempty subsets of          n  

  

fiwinikoff   cranefield

constraint used in these recurrence relations also gives us a way to investigate the numbers
of traces for goal plan trees of different semi uniform shapes  however  in the remainder of
this paper we will focus on uniform trees using our original parameter j  with the exception
of section      
    the probability of failing
in section     we said that introducing failure handling makes it harder to fail  however 
tables   and   appear at first glance to contradict this  in that there are many more ways
of failing with failure handling than there are without failure handling 
the key to understanding the apparent discrepancy is to consider the probability of
failing  tables   and   merely count the number of possible execution paths  without
considering the likelihood of a particular path being taken  working out the probability of
failing  as we do below  shows that although there are many more ways of failing  and also
of succeeding   the probability of failing is  indeed  much lower 
let us denote the probability of an execution of a goal plan tree with root x and depth
d failing as p  xd    and the probability of it succeeding as p  xd        p  xd   
we assume that the probability of an action failing is a      then the probability of a
given plans actions all succeeding is simply     a  x where x is the number of actions 
hence the probability of a plan failing because of the failure of  one of  its actions is simply
       a  x   i e  for a plan at depth   the probability of failure is 
           a   
and for a plan at depth greater than   the probability of failure due to actions is 
          a     k   
 recall that such a plan has   actions before  after  and between  each of its k sub goals  
considering not only the actions but also the sub goals g            gk of a plan p  we have
that for the plan to succeed  all of the sub goals must succeed  and additionally  the plans
actions must succeed giving p  pd           p  gd  k   we can easily derive from this an
equation for p  pd    given below   note that the same reasoning applies to a plan regardless
of whether there is failure handling  because failure handling is done at the goal level 
in the absence of failure handling  for a goal g with possible plans p            pj to succeed
we must select one plan and execute it  so the probability of success is the probability of
that plan succeeding  i e  p  gd     p  pd     we ignore for the moment the possibility of a
goal failing because there are no applicable plans  this assumption is relaxed later on 
formally  then  we have for the case without failure handling 
p  gd     p  pd   
p  p       
k

p  pd                   p  gd     
    for simplicity  we assume that the failure of an action in a plan is independent of the failure of other
actions in the plan 

  

fion the testability of bdi agent systems

a
    

    

d
 
 
 
 
 
 

no failure handling
   
   
   
   
   
   

with failure handling
     
     
     
      
      
      

table    goal failure probabilities with and without failure handling
now consider what happens when failure handling is added  in this case  in order for
a goal to fail  all of the plans must fail  i e  p  gd     p  pd   j   since failure handling is at
the goal level  the equation for plans is unchanged  giving 
p  gd     p  pd   j
p  p       
k

p  pd                   p  gd     
it is not easy to see from the equations what the patterns of probabilities actually are 
and so  for illustration purposes  table   shows what the probability of failure is  both with
and without failure handling  for two scenarios  these values are computed using j   k    
 i e  a relatively small branching factor  and with        we consider two cases  where
a        and hence          which is rather high   and where a        and hence
       
as can be seen  without failure handling  failure is magnified   the larger the goalplan tree is  the more actions are involved  and hence the greater the chance of an action
somewhere failing  leading to the failure of the top level goal  since there is no failure
handling   on the other hand  with failure handling  the probability of failure is both low 
and doesnt appear to grow significantly as the goal plan tree grows 
we now relax the assumption that a goal cannot fail because there are no applicable
plans  i e  that a goal will only fail once all plans have been tried  unfortunately  relaxing
this assumption complicates the analysis as we need to consider the possibility that none
of the remaining plans are applicable at each point where failure handling is attemped 
let us begin by reconsidering the case where there is no failure handling  we use g to
denote the probability of a goal failing because none of the remaining plans are applicable 
for the case with no failure handling a non zero g indicates that there are situations
where a goal does not have applicable plans  which may indicate an error on the part of
the programmer  or that in certain situations a goal may not be possible to achieve  we
assume  for analysis purposes  that this probability is constant  and in particular  that it
does not depend on which plans have already been tried nor on the number of relevant
plans remaining 
then the probability of a goal failing is p  gd     g       g   p  pd     i e  the goal fails
either because no plans are applicable or because there are applicable plans and the selected
plan fails  as before  the equation for plans is unchanged  since failure handling is done at
  

fiwinikoff   cranefield

the goal level  we now have the following equations for the case without failure handling 
p  gd     g       g   p  pd   
p  p       
k

p  pd                   p  gd     
observe that setting g     yields the equations derived earlier  where we assumed that a
goal cannot fail due to inapplicable plans 
we now consider the probability of failure with failure handling  for a goal with two
plans we have the following cases 
 the goal can fail because no plans are applicable  g  
 if there are applicable plans      g          then the goal can fail if the first selected
plan fails  p  pd           and if failure handling is not successful  which can occur if
either there are no applicable plans  g   or if there are applicable plans      g         
and the selected plan fails  p  pd     
putting this together  for a goal with two plans we have 
p  gd     g       g   p  pd     g       g   p  pd    
in the general case of j available plans  we have that a goal can fail if 
a  there are no applicable plans at the outset  with probability g   or
b  there are applicable plans     g    but the selected plan fails  p  pd     and then
either there are no further applicable plans  g    or
c  there are applicable plans     g    but the selected plan fails  p  pd     and then
either there are no further applicable plans  g   
d  and so on  the reasoning of b is repeated j times 
this gives a definition of the following form 
g       g   p  pd     g       g   p  pd     g        g   
  z   
 z
  
 z
    z 
b
c
d
a
this can be defined in terms of an auxiliary function p  gd   i  which defines the probability
of failure for goal g at depth d where there are i remaining relevant plan instances that may
 or may not  yield any applicable plan instances 
p  gd     p  gd   j 
p  gd        g       g   p  pd   
p  gd   i        g       g   p  pd    p  gd   i 
p  p       
k

p  pd                   p  gd     
  

fion the testability of bdi agent systems

a
    

a
    

d
 
 
 
d
 
 
 

no failure handling
g    
g        g       
   
   
   
   
   
   
   
   
    
g     g         g       
  
  
   
   
   
   
   
   
   

with failure handling
g    
g        g       
     
    
    
     
    
     
     
    
     
g     g         g       
      
    
    
      
    
    
      
    
    

table    goal failure probabilities with and without failure handling when goals can have
no applicable plans

observe that setting g     reduces this to the definition derived earlier  since g    g   x
simplifies to x  and hence p  gd   i    p  pd   i  
as before  it is not immediately clear from the formulae what the actual patterns of
probability are  considering illustrative examples  table   shows that  a  the overall behaviour is the same as before  and  b  if g is assumed to be relatively low compared with the
probability of action failure   and      then it doesnt significantly affect the probabilities 
    analysis of the rate of failures
in this section we briefly examine how the number of traces for a goal plan tree is affected by
placing a bound on the rate of action failures that can occur within a trace  for simplicity 
we work with uniform goal plan trees  but the construction below extends trivially to semiuniform goal plan trees 
in figure   we presented equations for calculating the total number of behaviours for a
goal plan tree  with failure handling   but how many of these behaviours involve a possibly
unrealistic number of action failures  if we make an assumption that there is an upper
limit to the rate of action failures     i e  the number of failures divided by the length of the
trace  how does this affect the number of possible behaviours  do the large numbers that
we have seen reduce significantly 
for instance  considering j   k            and d      there are       possible executions
that result in failure  how many of these involve a high rate of action failure and how many
involve only a small percentage of failures  figure   contains  cumulative  counts that
were generated by looking at all possible executions in this  small  case  plotted against the
number of action failures  the x axis shows for a given value n                 how many
traces there are that have n or fewer action failures  for instance  for n      there are    
traces that have   or fewer action failures  of these     traces      are successful and    are
unsuccessful  figure   shows the equivalent graph for the rate of action failure  each trace
has its failure rate computed  the number of failures divided by the length of the trace  
    bounding the rate of action failures allows us to model an assumption that the environment has limited
unpredictability  or perhaps that the programmer has limited incompetence 

  

fiwinikoff   cranefield

ok 

failed 

both 

     

number of traces  cumula ve  

     

     

     

     

     

    

  

  

  

  

  

  

  

  

ok 

  

   

    

    

    

     

     

failed 

  

  

   

    

     

     

     

both 

  

   

    

     

     

     

     

number of failures 

figure    number of traces  cumulative  vs  number of failures for j   k             d    
    

    

number of traces  cumulative 

    

    

    

    

   

 
   

   

   

   

   

   

   

   

   

 

failure rate

figure    number of traces  cumulative  vs  failure rate for j   k             d    

  

fion the testability of bdi agent systems

and the number of traces are counted for each range of failure rate  for instance  the first
data point in the graph shows that there are    traces with a failure rate      
the question is how to generalise this analysis for larger execution spaces  clearly 
counting all possible executions is not feasible  instead  we turn to generating functions 
for a given plan body segment   s  and particularly for s   gd    we are interested in
computing the numbers of successful and failed traces in which the failure rate is bounded
by a given ratio r between the number of failed actions and the total number of actions 
i e  the proportion of actions in an execution trace that fail  we denote these by n r s 
and n r s   to compute these values  we first determine for integers m     and n    the
numbers of successful and failed traces that have length m and contain exactly n action
failures  denoted n r s  m  n  and n r s  m  n   respectively  we define the length of a trace
to be the number of actions  both successful and unsuccessful  that it contains  note that
for any finite goal plan tree  such as a uniform or semi uniform one  there is a maximum
possible trace length and so n r s  m  n  and n r s  m  n  can only be non zero for a finite
number of integer pairs  m  n  in the positive quadrant of the plane or on the positive m
axis  in the case that n       once we have these values  we can calculate n r s  as the
n
 r  and similarly for n rs using n r s  m  n  
sum of all n r s  m  n  for which m
we begin by considering ordinary    and bivariate generating functions  wilf        for
the values n r s  m  n  and n r s  m  n  
 

fr  s  x  y   
fr  s  x  y   

 x

x

n r s  m  n  xm y n

m   n  
 x

x

n r s  m  n  xm y n

m   n  

an action a has one successful execution  which has length   and contains no action
failures  so fr  a  x  y    x  a power series with the coefficient of x  y   being   and all other
coefficients being     similarly  fr  a  x  y    x  y     xy  as there is one failed execution 
which has length   and one action failure 
we now consider fr  s    s    
fr  s    s    x  y   
 

 x

x

n r s    s    m  n  xm y n

m   n  
 x
 
x
m   n  

x

x


nr s    p  t  nr s    q  u  xm y n
 

 

p q m t u n

the double sum in parentheses considers  for any trace  all possible ways of allocating
the number of actions m and number of action failures n to the  necessarily  successful
executions of s  and s    and the sums are over non negative integer values of p  q  t and u 
    recall that  as defined towards the start of section    page      a plan body segment s is a sequence
x            xn where each xi is either a goal or an action 
    ordinary generating functions differ from exponential generating functions by not including denominators
that are factorials of the powers of the variable s  

  

fiwinikoff   cranefield

we then have 
fr  s    s    x  y   
 


 x
x
x x

n r s    p  t  xp y t n r s    q  u  xq y u

m   p q m n   t u n
 x
 x
 x

x

n r s    p  t  xp y t n r s    q  u  xq y u

p   q   t   u  

x
x

 x

 x

 
p t
 
q u
 
nr s    p  t  x y
nr s    q  u  x y
p   t  

q   u  

 

 

  fr  s    x  y  fr  s    x  y 
p
p p
p
the second line above is derived using the identity 
q
p
m  
p q m f  p  q   
f  p  q   both expressions sum over all non negative integers p and q  but the first expression
does this by first summing over all non negative values m on the horizontal axis  and then
summing over all pairs  p  q  of non negative integers lying on a line with slope   that
intersects the horizontal axis at m 
considering fr  s    s    x  y   we have 
fr  s    s    x  y   
 

 x

x

n r s    s    m  n  xm y n

m   n  
 x
 
x

n r s    m  n 

m   n  

 

 

x

x



nr s    p  t  nr s    q  u  xm y n
 

 

p q m t u n


xx

n r s    m  n  xm y n

m   n  
 x
 
x

 

m   n  

x

x


nr s    p  t  nr s    q  u  xm y n
 

 

p q m t u n

 

  fr  s    x  y 
x
 x

 x

 x

 
n r s    p  t  xp y t
n r s    q  u  xq y u
p   t  

q   u  

  fr  s    x  y    fr  s    x  y  fr  s    x  y 
the second line above is based on the observation that each failed execution of s    s  of
length m and with n action failures is either a failed execution of s  of length m and with n
action failures occurring in that execution  or is a successful execution of s  of length p and
with t failures followed by a failed execution of s  of length q and with u failures  where
p   q   m and t   u   n 
now  assuming that we know fr  gd   x  y  and fr  gd   x  y  for some depth d  we can
construct the functions fr  pd   x  y  and fr  pd   x  y  by applying the results above to expand
the right hand sides of the following equations  which simply replace pd with its plan body  
  

fion the testability of bdi agent systems

fr  pd   x  y    fr  a     gd   a   k   x  y 
fr  pd   x  y    fr  a     gd   a   k   x  y 

it remains to define fr  gd   x  y  and fr  gd   x  y  in terms of fr  pd    x  y  and fr  pd   
x  y   to count the successful executions of gd of length m and with n action failures  we
must first choose one of the j applicable plans to be the one that ultimately succeeds  we
must then choose between   and j  of the remaining applicable plans that were tried but
failed  and consider all possible orderings of these plans  the m actions in the trace and
the n action failures must be distributed across the failed and successful plans  this leads
us to the following derivation of a procedure to construct fr  gd   x  y  
fr  gd   x  y 
 x

x
 
n r gd   m  n  xm y n
m   n  

 

 x

x


j

m   n  

  j

p  


j  
x
j  
p

p  

  j


j  
x
j  

p 

p

x

p 

x

n r pd         f   

p
y


x

x


m   n  

n r pd     i   fi   xm y n

i  

      p  m f    fp  n

 x

x



n r pd         f   

p
y


n r pd     i   fi   xm y n

i  

      p  m f    fp  n

j  
x
p  

 x
 x
p
 x

 x

j  
 
  f
 
  f
p 
nr pd       f   x y
nr pd       f   x y
p
    f   

    f   


j  
x
j  
  j
p  fr  pd    x  y  fr  pd    x  y p
p
p  

constructing fr  gd   x  y  is simpler  a failed execution of a goal involves failed attempts
to execute all j applicable plans  all j  orderings of these plans must be considered  this
gives us the following construction for fr  gd   x  y  
fr  gd   x  y   
 

 x

x

n r gd   m  n  xm y n

m   n  
 x
 
x

x

j 

m   n  

  j 

x
 x


x

      j  m f    fj  n
 

  f

nr pd       f   x y

    f   

  j  fr  pd    x  y j
  

j



nr pd         f       nr pd     j   fj   xm y n
 

 

fiwinikoff   cranefield

the equations above define a recursive procedure for computing fr  gd   x  y  and fr  gd  
x  y  for given values of d  j  k and    as discussed earlier in this section  given a way of
n
calculating n r s  m  n   we can calculate n r s  as a sum of all n r s  m  n  for which m
 r 
 
and similarly for nrs  we have used the python rmpoly and gmpy  libraries to generate
polynomial representations of the functions fr  gd   x  y  and fr  gd   x  y  for any specified
values of d  j  k and l  and to calculate n r s  and n r s  for various ratios r     figure  
shows the results for d   j   k     and       
examining figure   we can conclude two things  on the one hand  the number of traces
really explodes for larger rates of action failures  for example  in figure   most traces have
a failure rate greater than      on the other hand  although making assumptions about the
failure rate does reduce the number of possible traces  the number of traces is still quite
large  note the scale on the y axis   for instance  for a failure rate of      there are around
          failed executions and           successful executions  for a failure rate of     
the respective numbers are           and             and for a failure rate of      they
are           and            
the shape of figure   can be explained as follows  firstly  the occurrence of an action
failure triggers further activity  alternative plans   so more failures result in longer traces 
secondly  there are more longer traces than there are shorter traces  simply because the
longer the trace  the more possibilities there are for variations  e g  different orders of trying
plans   this explains why the increase in figure   starts off slowly and then accelerates 
as we get more failures  we have longer traces  and for these longer traces there are more
of them  in other word  if we were to plot the non cumulative number of paths against the
ratio of action failures we would see an initial increase  as the ratio grows  there are more
paths  what this doesnt explain is why beyond a certain point we get fewer traces  and
the cumulative graph levels out  the explanation here is quite simple  beyond a certain
ratio  which appears to be around      there are no successful traces  and the number of
failed traces also declines 
    recursive trees
in section     we developed recurrence relations that allowed us to relax the assumption
that goal plan trees are uniform  and considered semi uniform trees  in this section we
relax the assumption that goal plan trees are finite  and we also allow trees to have any
shape  we do this by considering arbitrary trees that are allowed to contain labels that
refer to other parts of the tree  i e  we allow trees to be recursive  we then derive generating
functions  which can be seen as an extension of those derived in the previous section  for
the number of paths  both successful and unsuccessful  in executing these recursive goalplan trees  obviously  an infinite tree has an infinite number of paths  and so we define
generating functions that take as a parameter a bound on the lengths of the paths counted 

    there are a finite number of actions that can be attempted during any execution of a goal plan tree  and
this bounds the length of its possible traces and the number of action failures that can occur within them 
thus fr  gd   x  y  and fr  gd   x  y  are polynomials of finite orderonly a finite number of coefficients are
non zero in the infinite sums that define them 

   

fion the testability of bdi agent systems

failed executions  cumulative 

successful executions  cumulative 

both  cumulative 

 e    

   e    

number of traces  cumulative 

 e    

   e    

 e    

   e    

 e    

 e    

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

 

failure rate

figure    number of traces  cumulative  vs  failure rate for j   k   d     and      
for a given upper bound on path length  the equations specify the number of paths that
have at most that many actions    
we begin by defining some notation for representing recursive trees  goals  plan body
multisets  plans  variables and bindings  a goal is represented by a term of the form
goal plan body multiset  where plan body multiset is a multiset representing the different
applicable plan instances that can be used to satisfy the goal  this is a multiset because
for our combinatorial analysis  only the structure of plans is significant  therefore we
use a single abstract action a to represent all actions     and a goal may be achievable
using multiple plan instances that have the same structure  but which we must treat as
distinct  we only need to represent the bodies of the plan instances  so each element in
the multiset  i e  plan  is a sequence of terms separated by the right associative sequential
composition operator    each term in the sequence is either the abstract action term a 
a goal term as defined above  representing a sub goal   or a label  see below   formally 
a plan body multiset p m is a multiset of plans  written  p   c            pj  cj   where each of
the ci is the number of times that the associated plan pi appears in the multiset  we
define the following multiset operations  set p m   is a set of all the pi in the multiset p m  
p m  pi   is the characteristic function denoting the number of times plan pi appears in
the multiset  i e  ci    and p m   p m  is multiset subtraction  defined as p m  p m   x   
max p m   x   p m   x       finally  p m   is the size of the multiset  i e  the sum of the ci  

    we can also use the equations derived in this section for non recursive trees  in which case we allow
     where we define        and f power x    f  
    however  to avoid confusion  we will use numeric subscripts  a    a           to distinguish different occurrences of actions 

   

fiwinikoff   cranefield

in order to allow recursive trees to be represented  it is possible for a step in a plan to
be a label  denoted   i or      referring to a term in the provided binding  which is simply
a mapping from labels to terms  either goal or plan terms   if b is a binding then we write
b   to denote the item that  is mapped to in b  or  if there is no entry for  in b 
for example  consider the simple tree below  consisting of a goal with two plans  together
with a binding that maps the variable  to the root of the tree  the first plan  on the left 
has two steps  an action  a     and a recursive reference to the root of the tree     the
second plan  on the right  just has a single action  a    
   goal
plan

plan
a 



a 

this recursive tree can be represented as follows  we define the binding b      
goal   a         a        which maps  to the whole tree  and then the tree itself is just  
before we proceed to defining generating functions  we introduce some auxiliary notation  if p is a power series then we use the standard notation  xp      xpnn  p to denote
the coefficient of the term xp      xpnn in the series  we define p cond to denote the power
xn

series containing all the terms in p that satisfy the condition cond  we define f  g as
 f  g  power x n   i e  f  g with any terms having a power of x greater than n removed 
n
we define f mx as  f  m power x n   i e   f  m with any terms having a power of x greater
than n removed   
we are now in a position to derive generating functions that specify the number of
paths through an arbitrary  and possible recursive  goal plan tree  given a bound  on the
path length  we define s to be the bdi program represented as a term  i e  goal  plan 
plan multiset  action  or label   and b to be a binding mapping labels to terms  as defined
above   we then define n  s  m  n  b  to be the number of successful paths  with respect
to s and binding b  that have m actions  n of which are failed actions  similarly we define
n  s  m  n  b  to be the number of failed paths  with respect to s and b  that have m actions 
n of which are failed actions  we now want to derive recurrence relations for the generating
functions    
 
f
 s  x  y  b     

 
f
 s  x  y  b     

 x

x
m   n  
 x

x

n  s  m  n  b xm y n
n  s  m  n  b xm y n

m   n  

where  is an upper bound on the number of actions in a path 
    this  and the previous operation  are directly supported by the rmpoly python library for multivariate
polynomials and series  which we have used to compute these generating functions 
    the subscript  is used to distinguish these generating functions  that allow for a recursive tree  from
other generating functions defined elsewhere in the paper 

   

fion the testability of bdi agent systems

in order to simplify the presentation  the details of the more complex derivations are
given in appendix c  the resulting equations are shown in figure     the first two
equations  equations    and    in figure      which are applicable for any term t  capture
the assumption that       and the remaining equations only apply when        the next
two equations simply specify that labels are looked up in the provided binding  equation   
indicates that there is a single successful path through action a  and that it has a single
action and no unsuccessful actions  i e  the generating function is  x  y      equation   
similarly indicates that there is a single unsuccessful path through a single action a  which 
unsurprisingly  has a single unsuccessful action  so the generating function is  x  y     
equations    and    deal with sequences  for a sequence s    s  to succeed both s  and
s  must succeed  and we count the paths by concatenating sub paths  which corresponds to
multiplying power series  a sequence s    s  can fail if either s  fails  or if s  succeeds and
s  then fails  alternatives correspond to the addition of power series   for both equations
there is a special case  if s  is an action  then we can divide the overall path length limit
 precisely  s  must have a trace of length    since it is an action  and s  must therefore
have a maximum length of     
having dealt with labels     single actions  and sequences  we next turn to goals  equations    and      in both cases the derivation is complex  and is covered in appendix c 
 
for f
 equation    and appendix c     the intuition is that a successful path through a
goals execution involves a single successful plan p  and some number of failed executions of
plan selected from the remaining multiset of plans  p m   p      in the case where a plan
appears more than once in the multiset  then we can select any of its occurrences  hence
the multiplication by p m  p   for the number of failed paths of a goal  equation    and
appendix c    we introduce an auxiliary generating function g  p m  x  y  z  b     where
p m is a multiset of plans  and z is a variable whose power z o indicates the exact number of plans from p m that are used  in other words  given the power series denoted by
g  p m  x  y  z  b     the term cmno xm y n z o  o  indicates that there are cmno paths that involve m actions  n of which failed  and exactly o of the plans in p m   the generating
 
function g  is a technical device that allows us to derive the definition of f
that we need 
 
given this power series  the definition of f simply selects the terms that have  p m   as
the power of z  since all plans must fail for a goal to fail  using  and then removes the
z  p m   terms by dividing  because g  is an exponential generating function in z  which
means that it includes a division by a factorial  we need to multiply by the factorial  p m   
to remove it 
 
equation    defines f
 p m  x  y  b     which is used in equation     in terms of the
 
auxiliary function g  its derivation is given in appendix c    the intuition here is that
for each possible number of plans that could be used  o  we limit the power series g  to
that value of o  and remove the z o by dividing  the o  is due to g  being an exponential
generating function in z  see appendix c  

finally  equations    and    give the definition of g  p m  x  y  z  b     see appendix c  
for the derivation   intuitively  equation    creates the power series for each plan type  and
x

then combines them  using     equation    is a little more complex  there is a single way
of failing  when no plans are used  corresponding to the term x  y   z         otherwise we
can select any o of the c plans  and each of the plans must fail  corresponding to the term
   

fiwinikoff   cranefield

 
f
 t  x  y  b        if    

    

 

f t  x  y  b        if    

    

 

 

    

 

 

    

f   x  y  b      f b    x  y  b   
f   x  y  b      f b    x  y  b   
 

    

 

    

f a  x  y  b      x
f a  x  y  b      xy
 

f s    s    x  y  b   
 
 
 
f
 s    x  y  b     f
 s    x  y  b       if s  is an action
 
x
 
 
f s    x  y  b     f
 s    x  y  b    otherwise
 
f
 s    s    x  y  b   
 
 
 
 
 s    x  y  b     f
 s    x  y  b     f
 s    x  y  b       if s  is an action
f
 
x
 
 
 
f
 s    x  y  b    f
 s    x  y  b     f
 s    x  y  b    otherwise
 
f
 goal p m    x  y  b   
x
x
 
 
 
p m  p f
 p  x  y  b     f
 p m  p     x  y  b   

    

    

    

pset p m  
 
f
 goal p m    x  y  b       p m   

 p m  
 
f
 p m  x  y  b     

x
o  

o 

g  p m  x  y  z  b    power z   p m  
z  p m  
g  p m  x  y  z  b    power z  o
zo

    
    

g   p   c            pj  cj    x  y  z  b   
x

x

g   p   c     x  y  z  b         g   pj  cj    x  y  z  b   

 

c  
x
c
g  p c   x  y  z  b         
f    p  x  y  b   ox z o
o 
 

    

    

o  

figure     equations for recursive goal plan trees
 
f
 p  x  y  b      giving the number of failed traces across these o plans as 
x

x

 
 
 
f
 p  x  y  b   ox   f
 p  x  y  b         f
 p  x  y  b   
 
 z
 

o times

we have used the python rmpoly and gmpy  libraries to generate polynomial repre 
 
sentations of the functions f
 t  x  y  b    and f
 t  x  y  b     as defined in figure     for
any specified values of t  b  and   then we defined a simple tree  the one given earlier in
this section as an example  and computed the number of paths for different values of  
   

fion the testability of bdi agent systems

the values of  have been chosen to correspond to values in table    which is where the
values for n  g  and n  g  come from      in table    the values of    and     correspond to
the longest path  and so we argue that when comparing a recursive tree to a uniform tree 
we should consider the same path length limit  the results are shown in table   

  
   

n  g 
           
            

n  g 
           
            

n  s 
          
          

n  s 
         
          

table    comparing n  and n   respectively n  and n   
looking at the numbers in table    it is worth noting that the recursive tree that we
have used is extremely simple  two plans  each with only a single action  the low number
of actions  and sparseness of the tree  account for the relatively low number of unsuccessful
paths  for instance  if we modify the tree by adding extra actions  giving the tree and
binding below  then for       there are around           successful paths  and          
unsuccessful paths  unfortunately  python was unable to calculate n  or n  for this tree
with         but it did manage         for which there are            successful paths 
and          unsuccessful paths  this shows  as expected  that the number of unsuccessful
paths is higher for the more complex tree  that there are fewer successful paths for the
more complex tree can be explained by observing that  for this tree  traces are longer  more
actions need to be done   and so more of the traces are excluded by the bound on trace
length  
   goal
plan

plan
a 

a 



a 

a 

overall  the analysis in this section  and its application to       and     confirms
that the number of paths in a recursive tree depends on the trees structure  which is
unsurprising   but also indicates that even for a very simple recursive tree  the number of
paths for a given upper bound on path length quickly becomes extremely large 

   a reality check
in the previous section we analysed an abstract model of bdi execution in order to determine
the size of the behaviour space  the analysis yielded information about the size of the
behaviour space and how it is affected by various factors  and on the probability of a goal
failing 
in this section we consider the two issues of whether this analysis is faithful  and whether
it is applicable to real systems  the analysis made a number of simplifying assumptions 
    they correspond to the first two rows of the table  which respectively involve    and     actions 

   

fiwinikoff   cranefield

and these mean that the results may not be faithful to the semantics of a real bdi platform 
or that they may not apply to real systems  we thus conduct two reality checks to assess
whether our analysis is faithful  section      and whether it is applicable  section      
we firstly assess whether our analysis is faithful to real bdi platforms  i e  that it does
not omit significant features  or contain errors  we do this by comparing our abstract
bdi execution model with results from a real bdi platform  namely jack  busetta et al  
       this comparison allows us to assess to what extent the analysis of our abstract bdi
execution model matches the execution that takes place in a real  industrial strength  bdi
platform  this comparison is  in essence  a basic reality check  we are simply checking that
the analysis in the previous section does indeed match the execution semantics of a typical
bdi platform  we do this by modelling an artificial goal plan tree in the bdi platform 
next  in order to assess to what extent our analysis results apply to real systems  we
analyse a goal plan tree from a real industrial application  this analysis allows us to
determine the extent to which the conclusions of our analysis of uniform  and semi uniform 
goal plan trees applies to real applications  where the goal plan trees are not likely to be
uniform  in other words  to what extent do the large numbers in tables   and   apply to
real applications 
    a real platform
in order to compare a real bdi platforms execution with the results of our abstract bdi
execution model we implemented the two goal plan trees in appendix a in the jack agent
programming language     the structure of the plans and events   precisely mirrors the
structure of the tree  as in the goal plan tree  each event has two relevant plans  both
of which are always applicable  and selectable in either order  actions were implemented
using code that printed out the action name  and then  depending on a condition  described
below   either continued execution or triggered failure  and printed out a failure indicator  
system out print  a       action  a 
if   n i           
system out print  x   
false     trigger failure
 
the conditions that determined whether an action failed or succeeded  and which plan
was selected first  were controlled by an input  n i  a java class variable   a test harness
systematically generated all inputs  thus forcing all decision options to be explored 
the results matched those computed by the prolog code of figure    giving precisely
the same six traces for the smaller tree  and the same     traces for the larger tree  this
indicates that our abstract bdi execution model is indeed an accurate description of what
takes place in a real bdi platform  specifically jack  
note that we selected jack for two reasons  one is that it is a modern  well known 
industry strength bdi platform  the other  more important  reason  is that jack is a descendent of a line of bdi platforms going back to prs  and thus is a good representative for
    the code is available upon request from the authors 
    jack models a goal as a bdigoalevent 

   

fion the testability of bdi agent systems

parameters
number of
j k
d
goals
actions
   
 
  
       
   
 
           
workflow with    goals   
    the paper says    goals 
but figure    has    goals 

no failure handling
 secs     and     
n  g 
n  g 
   
   
                   
                 
                 
       
       

with failure handling
 section     
n  g 
n  g 
           
           
   
         
            
           
           
  
         
           
           
           

table    illustrative values for n  g  and n  g   bottom part is       in first row        in
second  and       in last row 

a larger family of bdi platforms  in other words  by showing that the bdi execution model
analysed matches jacks model  we are also able to argue that it matches the execution of
jacks predecessors  including prs and dmars   and close relatives  e g  um prs and
jam  
    a real application
we now consider to what extent real systems have deep and branching goal plan trees 
and to what extent the large numbers shown in tables   and   apply to real applications 
rather than to uniform goal plan trees  as an example of a real application we consider an
industrial application at daimler which used bdi agents to realise agile business processes
 burmeister  arnold  copaciu    rimassa         note that finding a suitable application
is somewhat challenging  we need an application that is real  not a toy system   however 
in order to be able to analyse it  the application has to be bdi based  and furthermore 
details about the applications goal plan tree need to be available  unfortunately  many of
the reported bdi based industrial applications do not provide sufficient details about their
internals to allow analysis to be carried out 
figure    shows   a goal plan tree from the work of burmeister et al         which
has    achieve goals in up to   levels     maintain goals     plans and about     context
variables  burmeister et al         p       unlike the typical goal plan trees used in bdi
platforms  the tree in figure    consists of layers of and refined goals  with the only or
refinements being at the leaves  where the plans are   in terms of the analysis presented
in this paper we can treat a link from a goal g to a set of goals  say  g    g    g  as being
equivalent to the goal g having a single plan p which performs g    g    g   and has no actions 
i e        for non leaf plans  
the last row of table   gives the various n values for this goal plan tree  for        top
row          middle row  and        bottom row   note that these figures are actually
lower bounds because we assumed that plans at depth   are simple linear combinations
of   actions  whereas it is clear from burmeister et al         that their plans are in fact
    the details are not meant to be legible  the structure is what matters 

   

fiwinikoff   cranefield

model
ls ab
differe
model
keep th

figuretree  from
goal
of acm
prototype
figure     goal plan
thehierarchy
work of burmeister
et al        
figure     reproduced
with permission from ifaamas 

an advantage of this modeling approach is that it implicitly offers
support for parallel execution of the process parts that do not
depend on each other  this can reduce the overall time needed for
more complicated  and can contain nested decision making  e g   see burmeister et al        
process
execution  moreover maintain goals are a good means to
figure    
provide
process
with
the
agent
monitors
a roughthe
indication
of the size
of aadditional
goal plan tree isagility 
the number
of goals 
with
   goals 
the tree of figure
has sizeto
in be
between
the firstthroughout
two rows of table
comparing e g 
the
conditions
that   have
fulfilled
the   process
number of possible behaviours of the uniform goal plan trees against the real  and nontime
constraints 
and
pro actively
activities
avoid
uniform 
goal plan tree  we
see that
the behaviour initiates
space is somewhat
smaller to
in the
real
tree  but thatbefore
it is stillthey
quite appear 
large  especially in the case with failure handling  however 
problems
we do note the following points 

during development of the prototype the support for rapid
   the tree of figure    only has plans at the leaves  which reduces its complexity  in
prototyping
and execution of process models provided by
other words a goal plan tree that was more typical in having plans alternating with
goals would
have
a larger number
possible
behaviours 
ls abpm
has
proven
to be ofvery
helpful 
the developed models
represent
living process models  which can be directly executed
   the figures for the tree are a conservative estimate  since we assume that leaf plans
and visualized 
the
part ofin the
interface
thatcalculated
is coupled
have only simple
behaviour 
otherweb
words user
the number
of paths
is an
of theis
actual
number of directly
paths in thefrom
real application 
with under estimate
the workflow
generated
the process model 
the
interface is computed directly from the parameters of the
   comparison with procedural programs
corresponding task  context variables  their types and possible
in order to argue that bdi programs are harder to test than non agent programs  we need
values 
with
this approach
in the ofprocess
can be programs 
quickly
a comparison 
specifically 
we need to changes
analyze the number
paths in non agent
and compareand
with tested 
those in agent
programs 
us to address
concern that
modeled
thus
errorsthis
in will
theallow
models
can bethediscovered
the all paths criterion for test suite adequacy always requires an infeasibly large number
and
corrected
in briefly
a short
of tests 
this section
doestime 
this  by analyzing the number of paths in a procedural
program 
as
stated above the starting point for building the acm prototype
model was the acm reference    
process model developed for the
software demonstrator  the underlying agent engine of this
demonstrator  jadex  has a partially different modeling and
execution semantics compared to the ls abpm tool  there were

the m
model
prototy
them
compl
depend
challen
and to
execut
depend
proces

based
be con
of the
contex
manip
model
plans 
of the
compl
possib
variab
variab
one or
proces
variab
startin
goals 
create
but h
model

fion the testability of bdi agent systems

number of actions   statements
  
   
   
   

n m 
             
           
           
           

n  g 
           
            
            
            

n  g 
           
            
            
            

table    comparison of values between n m   n  g  and n  g  
we define a program as being composed of primitive statements s  sequences of statements p    p    or conditionals that select between two sub programs  since we do not capture
the conditions of statements  we elide the condition  and write a conditional as p    p  indicating that one of the pi is selected  note that  as for bdi analysis  we exclude loops 
we define the number of paths in a program p as n p    it is straightforward   to see
that the definition of n p   is 
n s     
n p    p      n p     n p   
n p    p      n p      n p   
in order to compare with bdi programs  we consider the size of the program  and
compare programs of the same size  the key question then is  does a procedural program
with m nodes have significantly fewer paths than a bdi program of the same size  we define
the size of a program p as the number of primitive statements it contains  and denote it
 p    note that this means that we do not count the internal nodes of the syntax tree
 i e  the   or     therefore  when comparing with bdi programs  we consider the size
of a bdi program to be the number of actions    
we now work out how the number of paths varies with the size of the program p   if m is
the size of a program  and therefore a natural number   then we define n m   max n p    
 p     m   that is  n m  is the largest number of paths possible for a program of size m 
appendix d contains the derivation of n m   resulting in the following definition  where
m    is a multiple of    
n   
n   
n   
n m     

 
 
 
 

 
 
 
 
 

  m  

n   
n   
n m 
n m     

 
 
 
 

 
 
 m  
    m  

table   shows some comparison values between n m  and n  g  and n  g   for same sized
programs  based on table    it is worth emphasising that n m  is the highest possible value 
it is defined as the maximum over all possible programs  however  the maximal program
is highly atypical  for example  considering all programs with seven statements  there are
    a path of p    p  simply concatenates a path of p  with a path of p    hence the product  and a path of
p    p  is either a path of p  or a path of p    hence the addition 
    using the total number of nodes in the tree yields almost identical results 

   

fiwinikoff   cranefield

a total of       possible programs  of these      programs  only    have    paths  the
maximum   figure    shows for each number of paths       how many programs have that
many paths  the maximum of    is clearly not typical  indeed  the mean number of paths
for a seven statement program is        and the median is    if we consider all programs
with   statements  then there are         such programs  but only    have the maximal
number of paths  which is      the average number of paths across all the programs is
     
overall  looking at table    we conclude that the number of paths for bdi programs is
much larger than even the  atypical  maximal number of paths for a procedural program
of the same size  this supports the conclusion that bdi programs are harder to test than
procedural programs 
     

number of programs 

     

     

     

    

  
  

  

  

  
  
  
  
  
  
number of paths in a procedural program 

   

   

   

figure     profile of number of paths for all   statement programs

   conclusion
to summarise  our analysis has found that the space of possible behaviours for bdi agents is 
indeed  large  both in an absolute sense  and in a relative sense  compared with procedural
programs of the same size  
as expected  the number of possible behaviours grows as the trees depth  d  and breadth
 j and k  grow  however  somewhat surprisingly  the introduction of failure handling makes
a very significant difference to the number of behaviours  for instance  for a uniform goalplan tree with depth   and j   k      adding failure handling took the number of successful
behaviours from     to                   
before we consider the negative consequences of our analysis  it is worth highlighting
one positive consequence  our analysis provides quantitative support for the long held belief
   

fion the testability of bdi agent systems

that bdi agents allow for the definition of highly flexible and robust agents  flexibility is
defined as the number of possible behaviours of an agent  which we have shown to be large 
robustness is defined as the ability of an agent to recover from failure  the analysis in
section     showed that the bdi failure recovery mechanism is effective at achieving a low
rate of actual failure         even when each action has a reasonable chance of failing      
so what does the analysis in this paper tell us about the testability of bdi agent systems 
before we can answer this question  we need to consider what is being tested  testing is
typically carried out at the levels of individual components  unit testing   collections of
components  integration testing   and the system as a whole 
consider testing of a whole system  the behaviour space sizes depicted in tables     
and   suggest quite strongly that attempting to obtain assurance of a systems correctness
by testing the system as a whole is not feasible  the reason for this is that  as discussed in
section       an adequate test suite  using the all paths criterion for adequacy  requires
at least as many tests as there are paths in the program being tested  if a program has  say 
      paths  then even a test suite with tens of thousands of tests is not just inadequate 
but is hugely inadequate  since it only covers a tiny fraction of a percent of the number of
paths 
in fact  this situation is even worse when we consider not only the number of possible
executions but also the probability of failing  the space of unsuccessful executions is particularly hard to test  since there are many unsuccessful executions  more than successful ones  
and the probability of an unsuccessful execution is low  making this part of the behaviour
space hard to reach  furthermore  as shown in section      although making assumptions
about the possible numbers of action failures that can occur in a given execution reduces
the number of possible behaviours  there are still many many behaviours  even for relatively
small trees  e g  j   k   d      
so system testing of bdi agents seems to be impractical  what about unit testing
and integration testing  unfortunately  it is not always clear how to apply them usefully
to agent systems where the interesting behaviour is complex and possibly emergent  for
example  given an ant colony optimisation system  dorigo   stutzle         testing a single
ant doesnt provide much useful information about the correct functioning of the whole
system  similarly  for bdi agents  when testing a sub goal it can be difficult to ensure that
testing covers all the situations in which the goal may be attempted  consequently  it is
difficult to draw conclusions about the correctness of a goal from the results of testing its
sub goals 
we do need to acknowledge that our analysis is somewhat pessimistic  real bdi systems
do not necessarily have deep or heavily branching goal plan trees  indeed  the tree from
a real application described in section   has a smaller behaviour space than the abstract
goal plan trees analysed in section    however  even though smaller  it is still quite large 
and this did cause problems in validation 

one of the big challenges during the test phase was to keep the model consistent
and to define the right context conditions that result in the correct execution
for all scenarios  therefore more support for dependency analysis  automated
   

fiwinikoff   cranefield

simulation and testing of the process models is needed  burmeister et al        
p         
so where does that leave us with respect to testing agent systems  the conclusion
seems to be that testing a whole bdi system is not feasible  there are a number of possible
approaches for dealing with this issue of testability that could be recommended 
 keep bdi goal plan trees shallow and sparse  this keeps the number of behaviours small  the issue with this approach is that we lose the benefits of the bdi
approach  a reasonably large number of behaviours is desirable in that it provides
flexibility and robustness 
 avoid failure handling  since failure handling is a large contributor to the behaviour space  we could modify agent languages to disable failure handling  again 
this is not a useful approach because disabling failure handling removes the benefits
of the approach  specifically the ability to recover from failures 
 make testing more sophisticated  could testing coverage perhaps be improved
by incorporating additional information such as domain knowledge  and a detailed
model of the environment  which indicates the possible failure modes and their probabilities   the answer is not known  but this is a potentially interesting area for
further work  however  the large number of paths does not encourage much optimism
for this approach 
another  related  direction is to see whether patterns exist in the behaviour space 
since the failure recovery mechanism has a certain structure  it may be that this
results in a behaviour space that is large  but  in some sense  structured  if such
structure exists  it may be useful in making agents more testable  however  at this
point in time  this is a research direction that may or may not turn out to be fruitful 
but is not a viable testing strategy 
finally  a related direction is to try and be more intelligent about the selection of
test cases  in order to gain more coverage from a given number of test cases  one
approach for doing this  which has been recently described  is evolutionary testing
 nguyen  miles  perini  tonella  harman    luck      a   in which genetic evolution
is used to find good  i e  challenging  test cases 
 supplement testing with alternative means of assurance  since testing is not
able to cover a large behaviour space  we should consider other forms of assurance 
a promising candidate here is some form of formal method     unfortunately  formal
methods techniques are not yet applicable to industry sized agent systems  we return
to this below  in section      
    burmeister et al  made the following observation  with this approach changes in the process can be
quickly modeled and tested  thus errors in the models can be discovered and corrected in a short time 
they were discussing the advantages of executable models  and arguing that being able to execute the
model allowed for testing  which was useful in detecting errors in the model  while being able to execute
a model is undoubtedly useful  there is no evidence given  nor is a specific claim made  that testing is
sufficient for assuring the correctness of an agent system 
    see the volume edited by dastani et al         for a recent overview of the current state of the art 
including a chapter on the role of formal methods in the assurance of agents  winikoff        

   

fion the testability of bdi agent systems

 proceed with caution  accept that bdi agent systems are in general robust  due
to their failure handling mechanisms   but that there is  at present  no practical way
of assuring that they will behave appropriately in all possible situations  it is worth
noting that humans are similar in this respect  whilst we can train  examine and
certify a human for a certain role  e g  a pilot or surgeon   there is no way of assuring
that he she will behave appropriately in all situations  consequently  in situations
where incorrect behaviour may have dire consequences  the surrounding system needs
to have safety precautions built in  e g  a process that double checks information  or
a backup system such as a co pilot  
    future work
there is room for extending the analysis of section    firstly  our analysis is for a single
goal within a single agent  multiple agents that are collaborating to achieve a single highlevel goal can be viewed as having a shared goal plan tree where certain goals and or plans
are allocated to certain agents  of course  in such a distributed goal plan tree there
is concurrency  once concurrency is introduced  it would be useful to consider whether
certain interleavings of concurrent goals are in fact equivalent  furthermore  we have only
considered achievement goals  it would be interesting to consider other types of goals  van
riemsdijk  dastani    winikoff         secondly  our analysis has focused on bdi agents 
which are just one particular type of agent  it would be interesting to consider other sorts
of agent systems  and  more broadly  other sorts of adaptive systems 
another extension of the analysis is to consider other criteria for test suite adequacy 
in this paper we have used the all paths criterion  arguing why it is appropriate  we
do recognize that all paths is actually quite a strong criterionit subsumes many other
criteria  zhu et al         figure     an alternative criterion that we could consider is all
edges  also known as branch coverage or decision coverage  it requires that where
there is a choice in the program  such as an if statement  then the tests in the test suite
exercise all options  i e  that all edges in the program graph be covered  the all edges
criterion is weaker than all paths and is regarded as the generally accepted minimum
 jorgensen        
another area for refinement of the analysis is to make it less abstract  two specific areas
where it could be made more detailed are resources and the environment  our analysis does
not consider resources or the environment directly  instead  it considers that actions may
fail for a range of reasons which might include resource issues  or environmental issues  the
analysis could be extended to explicitly consider resources and their interaction with goals
 thangarajah  winikoff  padgham    fischer         it could also be extended with an
explicit model of the environment 
whilst our analysis did consider a real application  it would be desirable to consider a
range of applications  this could provide additional evidence that the analysis is not unduly
pessimistic  and would also lead to an understanding of the variance in goal plan trees and
their characteristics across applications  a key challenge is finding suitable applications that
are bdi based  are sufficiently complex  ideally real applications   and have detailed design
information available  and preferably source code   another challenge is the methodology 
we analysed the shape of the goal plan tree of the daimler workflow application  but did
   

fiwinikoff   cranefield

not have access to run the system  an alternative methodology  which requires access to
the implemented system and probably the source code  is to run it  and force it to generate
all traces for sub goals    which would require modification of either the source code or
the underlying agent platform   once we have collected data on the shape of real world
industrial applications  we will be able to analyse whether uniform and semi uniform goalplan trees are good models of these types of system  or whether we should seek ways to
further relax our uniformity assumption 
more importantly  having highlighted the difficulties in assuring bdi agent systems
through testing  we need to find other ways of assuring such systems 
an approach that has some promise is the automatic generation of test cases for agent
systems  nguyen  perini    tonella        zhang  thangarajah    padgham         however  the size of the behaviour space suggests that the number of test cases needed may
be very large  and that testing for failed plan execution is difficult  one interesting  and
potentially promising  avenue is to use formal techniques to help guide the test generation
process  e g  symbolic execution or specification guided testing   dwyer  hatcliff  pasareanu  robby    visser        
another approach   that has attracted interest is model checking of agent systems
 wooldridge  fisher  huget    parsons        bordini  fisher  pardavila    wooldridge 
      raimondi   lomuscio         this work is promising because model checking techniques use a range of abstractions to cover a large search space without having to deal
with individual cases one at a time  burch  clarke  mcmillan  dill    hwang        fix 
grumberg  heyman  heyman    schuster         furthermore  because verifying a subgoal considers all possibilities  it is possible to combine the verification of different sub goals 
however  more work is needed  raimondi and lomuscio        verify systems where agents
are defined abstractly  i e  not in terms of plans and goals  the mable agent programming
language  wooldridge et al         is actually an imperative language augmented with certain agent features  not a bdi language  and the work of bordini et al         does not
include failure handling  in general  the state of the art in model checking agent system
implementations is still limited to quite small systems  dennis  fisher  webster    bordini 
      
acknowledgements
we would like to thank members of the department of information science at the university
of otago for discussions relating to this paper  we would also like to thank lin padgham
for her comments on a draft of this paper  finally  we would like to thank the anonymous
reviewers for their insightful comments which helped to improve this paper  some of the
work on this paper was done while winikoff was on sabbatical from rmit  visiting the
university of otago 

    generating all traces of the top level goal is not likely to be feasible 
    there has also been work on deductive verification  but  based on research into the verification of
concurrent systems  this appears to be less likely to result in verification tools that are both  relatively 
easy to use and applicable to real systems 

   

fion the testability of bdi agent systems

appendix a  example goal plan trees and their expansions
suppose we have the following two trees  sample  left  and sample   right   the trees
correspond to j      k          d     for sample and d     for sample  
goal
plan
a

goal

plan

goal

b c

goal

d

plan

plan

plan

plan

plan

plan

a

b

e

f

g

h

these trees can be expanded respectively into the following sequences of actions  where
a letter indicates the execution of an action  and a   indicates failure     as predicted by
our formulae  there are four successful executions and two unsuccessful executions for the
first tree 
a
b

a b
b a

a b 
b a 

for the second tree  the expansions are the following     possibilities  consisting of   
successful and    unsuccessful traces  
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a

e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e

b
b cgd
b cgd 
b cg hd
b cg hd 
b cg h 
b chd
b chd 
b ch gd
b ch gd 
b ch g 
b c 
 fb
 fb cgd
 fb cgd 
 fb cg hd
 fb cg hd 
 fb cg h 
 fb chd
 fb chd 

a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a

f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f

b chd
b chd 
b ch gd
b ch gd 
b ch g 
b c 
 eb
 eb cgd
 eb cgd 
 eb cg hd
 eb cg hd 
 eb cg h 
 eb chd
 eb chd 
 eb ch gd
 eb ch gd 
 eb ch g 
 eb c 
 e cgd
 e cgd 

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g

d 
d 
d 
d 
d 
d 
d 
d 
d 
d 
d 
 h
 h
 h
 h
 h
 h
 h
 h
 h

aeb
aeb 
ae fb
ae fb 
ae f 
afb
afb 
af eb
af eb 
af e 
a 
d
d aeb
d aeb 
d ae fb
d ae fb 
d ae f 
d afb
d afb 
d af eb

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h

d afb 
d af eb
d af eb 
d af e 
d a 
 gd
 gd aeb
 gd aeb 
 gd ae fb
 gd ae fb 
 gd ae f 
 gd afb
 gd afb 
 gd af eb
 gd af eb 
 gd af e 
 gd a 
 g aeb
 g aeb 
 g ae fb

    note that the failure marker isnt counted when considering the length of the trace in section     

   

fiwinikoff   cranefield

a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a
a

e fb ch gd
e fb ch gd 
e fb ch g 
e fb c 
e f cgd
e f cgd 
e f cg hd
e f cg hd 
e f cg h 
e f chd
e f chd 
e f ch gd
e f ch gd 
e f ch g 
e f c 
fb
fb cgd
fb cgd 
fb cg hd
fb cg hd 
fb cg h 

af e cg hd
af e cg hd 
af e cg h 
af e chd
af e chd 
af e ch gd
af e ch gd 
af e ch g 
af e c 
a cgd
a cgd 
a cg hd
a cg hd 
a cg h 
a chd
a chd 
a ch gd
a ch gd 
a ch g 
a c 
cgd

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

g hd af eb 
g hd af e 
g hd a 
g h aeb
g h aeb 
g h ae fb
g h ae fb 
g h ae f 
g h afb
g h afb 
g h af eb
g h af eb 
g h af e 
g h a 
hd
hd aeb
hd aeb 
hd ae fb
hd ae fb 
hd ae f 
hd afb

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

h g ae fb 
h g ae f 
h g afb
h g afb 
h g af eb
h g af eb 
h g af e 
h g a 
 aeb
 aeb 
 ae fb
 ae fb 
 ae f 
 afb
 afb 
 af eb
 af eb 
 af e 
 a 

appendix b  analysis of recurrence relations
this appendix contains details of the derivation in section     
the exponential generating function f  x  of the sequence  f    j  a  b  
j   is the function
defined by the following power series 
f  x   


x

f    j  a  b 

j  

xj
j 

    

 by definition of f    
 
 
j   


  
j
x
x
x
x
x
xj
j
j
 
i ai  j i b
 
i ai  j i b
i
j 
i
j 
j  

i  

j  

i  

on the right hand side above we have
 changed the upper limit of the inner sum to  based
j
on the generalised definition of i as j j    j           j i      i   which is valid for all

complex numbers j and non zero integers i  wilf        and gives ji     for i   j 
the right hand side has the form of a product of exponential generating functions  wilf 
      rule      section      



 



  
j
j
x
x
x
x
x
x
j
xj

 j   
 j    
 i  j i 
j 
j 
i
j 
j  

j  

j  

i  

where  for our case   j    j  aj and  j    j b  therefore  we can write 





j
j
x
x
 ax   
x
f  x    
j 
jb 
j 
j 
j  

j  

   

fion the testability of bdi agent systems

p
 
the left hand sum is g ax  where g y    n y n    y
 wilf        equation           

p
n
x
d x
d
 
the right hand sum is equal to bx dx
n   wilf        rule     section        bx dx e
x
 wilf        equation          bxe   thus we have 
f  x   

 
bxex
bxex  
   ax
   ax

p
xj
 
therefore  f       a  b  is the constant term in the power series 
j   f  j  a  b  j    which
is f          to find a recurrence relation defining f    j      a  b  we equate the original
definition of f  x  in equation    with our closed form of this function  differentiate each
side  to give us a power series with the f    j  a  b  values shifted one position to the left  
and multiply by the denominator of the closed form  giving us the following derivation 





d x  
d
bxex
xj 
    ax 
      ax 
f  j  a  b 
dx
j 
dx    ax
j  



x
xj 
b x   ex
abxex
 
      ax 
f  j  a  b j
      ax 
 
j 
   ax
    ax  
j  

 


x
j  



bxex
xj  x  
xj

  b x   ex   a
f  j  a  b j
af  j  a  b j
j 
j 
   ax
 

j  

 

 recall that f     a  b      


x
x
xj
xj
 
 
f  j     a  b  j    

ajf    j  a  b 
 j     
j 
j  

j  

  bxex   bex   a


x

f    j  a  b 

j  

 recall that

bxex

 

j  

equating the coefficients of

xj
j 

xj
j   jb j   

j
x

and ex  

j  

j  

p


x
xj
 b
j  b
j 

xj
j 
xj
j   j   

p



x
xj
x
 a
f    j  a  b 
j 
j 

we get 

f    j     a  b   ajf    j  a  b    bj   b   af    j  a  b 
  f    j     a  b    b j       af    j  a  b    ajf    j  a  b 
   j     b   af    j  a  b  

    

    note that many of the operations performed on generating functions  and all those used in this paper  are
valid without concern about convergence of the series  in combinatorics  generating functions are often
treated not as analytic functions to be evaluated for specific variable values  but rather as formal  possibly
infinite  algebraic objects  which have well defined operations such as addition and multiplication  the
set of formal power series over a finite set of variables has the structure of a ring from abstract algebra 
and in this ring there is no notion of function convergence and evaluation  wilf        ch     

   

fiwinikoff   cranefield

appendix c  analysis of recursive goal plan trees
this appendix contains detailed derivations relating to section     
 
c   derivation of f
 goal p m    x  y  b   
 
we can define f
 goal p m    x  y  b    in terms of n  in the usual way  noting the upper
bound of  to realise the length bound 

 
f
 goal p m    x  y  b     

 x

x

n  goal p m    m  n  b xm y n

m   n  
 

where n goal p m    m  n  b  is as defined in section      we also make use of the nonbounded version  which has only four arguments  
 
f
 goal p m    x  y  b   

 x

x

n  goal p m    m  n  b xm y n

m   n  
 

we then can define n by counting successful traces 
n  goal p m    m  n  b 
x
 
p m  p 

x

n  p  m    n    b  n  p m   p     m    n    b 

m   m   m
n   n   n

pset p m  

where n  p m  m  n  b  is the number of unsuccessful paths using zero or more of the plans
in the plan multiset p m  with respect to binding b  that have m actions  n of which are
failed actions 
the inner sum considers all ways to partition the numbers of actions  m  and action
failures  n  into those caused by a single plan of shape p and p
those p
caused by all the

other
plans 
as
in
section
   
 page
   
we
use
the
identity
m  
p q m f  p  q   
p p
p  
q   f  p  q  to rewrite 
 
f
 goal p m    x  y  b 
 x

x
x
x
 
p m  p 
n  p  m    n    b  n  p m  p     m    n    b xm y n

m   m   m
n   n   n

m   n   pset p m  

x

 

p m  p 

pset p m  

 x

x

x

n  p  m    n    b  n  p m  p     m    n    b xm y n

m   n   m   m   m
n   n   n

to give us 
 
f
 goal p m    x  y  b 
x
 
p m  p 

pset p m  


x
x

 x

x

n  p  m    n    b xm  y n  n  p m  p     m    n    b xm  y n 

m     m     n     n    

   

fion the testability of bdi agent systems

 

x

p m  p 

pset p m  
 x

x

 

n p  m    n    b x

y

 

n  p m  p     m    n    b xm  y n 

m     n    

m     n    

x

 x

x

m  n 

 

 

p m  p  f p  x  y  b  f p m   p     x  y  b 

pset p m  
 
where f
 p m  x  y  b  is the generating function for n  p m  m  n  b   in section c   we
 
provide a definition of f
 p m  x  y  b  in terms of an auxiliary function g   see section c    
we then introduce the bound on the length of paths  giving 
 
f
 goal p m    x  y  b   
x
x
 
 
 
p m  p   f
 p  x  y  b   f
 p m   p       x  y  b  

pset p m  

 

x

x

 
 
p m  p   f
 p  x  y  b     f
 p m   p       x  y  b    

pset p m  
 
c   derivation of f
 goal p m    x  y  b   

similarly to the previous derivation  we define 
 
f
 goal p m    x  y  b     

 x

x

n  goal p m    m  n  b xm y n

m   n  
 
 goal p m            in terms of the plans in p m   we
to derive a recursive definition of f
 
first define a new function n p m  m  n  o  b   which denotes the number of unsuccessful
paths that use o of the plans in the multiset p m   we then have 

n  goal p m    m  n  b    n  p m  m  n   p m    b 
this states that for the goal to fail  all  p m   plans in the multiset must be tried 
we define a generating function g  p m  x  y  z  b    for n  p m  m  n  o  b  that is ordinary in x and y but exponential in z  i e  the coefficients of xm y n z o  o  are the values of
n  p m  m  n  o  b  
we now have 
 
f
 goal p m    x  y  b     

 x

x

n  p m  m  n   p m    b xm y n

m   n  

which we wish to rewrite in terms of g    we do this by generalising the right hand side
to sum over possible values for the number of plans used  o   followed by a restriction to
select only values where o    p m   

   

fiwinikoff   cranefield

 
f
 goal p m    x  y  b   

   p m   

 x

x
n   p m  m  n   p m    b  z  p m  


 p m    z  p m  

xm y n

m   n  

 x
  p
 
o
x
o   n p m  m  n  o  b z  o  power z   p m  
 p m   
xm y n
 p m  
z
m   n  

 

p
   p m   

p p  

m n o
m  
n  
o   n p m  m  n  o  b x y z  o 



power z   p m  

z  p m  

since the nested sum is just the definition of g   see section c     we can simplify this to 
 

f goal p m    x  y  b       p m   

g  p m  x  y  z  b    power z   p m  
z  p m  

 
in section c   we derive a definition of g  p m         in terms of f
 p         for each p 
set p m   

 
c   definition of f
 p m  x  y  b   

recall that n  p m  m  n  b  is the number of unsuccessful paths using zero or more of the
plans in the plan multiset p m  with respect to binding b  that have m actions  n of which
 
are failed actions  and f
 p m  x  y  b    is its ordinary generating function 
first we consider the case when p m is empty  in this case  there is precisely one way
 
to fail  and it generates a trace of length zero  therefore  f
     x  y  b       x  y       
for the case when p m is non empty we can sum over the number of plans used during
execution  which yields the following definition 
 p m  
 

n p m  m  n  b   

x

n  p m  m  n  o  b 

o  

where n  p m  m  n  o  b  is  as before  the number of unsuccessful paths through the plan
 
multiset
m   using o of the plans  therefore  using the definition of f
 p m  x  y  b     
p pp

 
m
n
n
 p
m 
m 
n 
o 
b x
y
 
we
have 
m  
n   
 
f
 p m  x  y  b   

 

m 
 x
  p
x
x

n  p m  m  n  o  b xm y n

m   n   o  

 replace n  by looking up the coefficient of the corresponding term in g   
the o  accounts for the division by o  in g    we also reorder the summations 
 p m  

 

 x

x x

o  xm y n z o  g  p m  x  y  z  b   xm y n

o   m   n  

   

fion the testability of bdi agent systems

 we shift o  outwards  and multiply by z o  z o  
p
 p m   p
m n o
 
m n o
x
n    x y z  g p m  x  y  z  b   x y z
m  
 
o 
zo
o  

 p m  

 

x
o  

o 

g  p m  x  y  z  b    power z  o
zo

c   definition of g  p m  x  y  z  b   
we define g  p m  x  y  z  b    as a generating function for n  p m  m  n  o  b  that is ordinary in x and y but exponential in z  hence the division by o  below   with      as the
maximum allowed trace length 
g  p m  x  y  z  b     

 x
 x

x

n  p m  m  n  o  b 

m   n   o  

xm y n z o
o 

recall that n  p m  m  n  o  b  denotes the number of unsuccessful paths that use o of the
plans in the multiset p m   for an empty multiset of plans there is no successful execution 
and there is a single unsuccessful execution with   actions  that uses   plans  hence 
 
  if m   n   o    
 
n     m  n  o  b   
  otherwise
therefore  g      x  y  z  b         for non empty multisets we must partition the actions
in each trace  the action failures  and numbers of plans used  across the different plan bodies
in the multiset  and also consider all ways that the plans of the various plan shapes can be
interleaved to give an overall order for attempting plans 
n   p   c            pj  cj    m  n  o  b 
x
 
 n   p   c     m    n    o    b     n   pj  cj    mj   nj   oj   b 
m    mj  m
n    nj  n
o    oj  o

where  is the multinomial coefficient
thus 

o
o     oj



 

o 
o      oj  

g   p   c            pj  cj    x  y  z  b   
 by definition of g   but using restriction  rather than a bounded sum on m 
and expanding n  as above 



x
x
o
 
n   p   c     m    n    o    b 
o
 
 
 
o
 
j
m   m  m
m n o  

 

j

n    nj  n
o    oj  o

xm y n z o
   n  pj  cj    mj   nj   oj   b 
o 
 

   

 
power x 

fiwinikoff   cranefield

 


x

x

o 
n   p   c     m    n    o    b 
o
 
 
 
 
o
 
 
j
 m

m n o   m    mj
n    nj  n
o    oj  o

xm y n z o
   n   pj  cj    mj   nj   oj   b 
o 

 
power x 

 cancelling o  and distributing the oi   and the xmi   y ni and z oi  
 


x

x

n   p   c     m    n    o    b 

m n o   m    mj  m
n    nj  n
o    oj  o

xm  y n  z o 
o   

xmj y nj z oj
   n  pj  cj    mj   nj   oj   b 
oj  

 

 

 replacing


x

x

with

m   m   m   m


  


x



x
x

and redistributing sums 

m     m    

n   p   c     m    n    o    b 

xm  y n  z o 

m   n   o    




x



power x 

o   




n   pj  cj    mj   nj   oj   b 

xmj y nj z oj

mj  nj  oj   

oj  


 power x 

x

 replacing restriction  with   



m
n
o
x
 
 
 
x y z  x
 
n   p   c     m    n    o    b 

o   
m   n   o    



m
n
o
x
j
j
j
x
x y z 
  
n   pj  cj    mj   nj   oj   b 
oj  
mj  nj  oj   

 

 by definition of g        
x

x

  g   p   c     x  y  z  b         g   pj  cj    x  y  z  b   

we now need to define g   pi  ci    x  y  z  b    
consider n   p c   m  n  o  b   the simple cases are where o      if we do not use any
plans  then there is only a single unsuccessful
path  which has no actions  m   n       on

c 
the other hand  if o     then we have oc   o  co  
ways of selecting o out of the c available
copies of the plan p  these selected plans can be executed in o  different orders  for each
execution we sum over the possible distributions of actions  successful and unsuccessful 
   

fion the testability of bdi agent systems

amongst the plans  this gives 
 
x
c


o 
n  p  m    n    b     n  p  mo   no   b 


o

m    mo  m
n    no  n
n   p c   m  n  o  b   


 
if m   n   o    



 
otherwise

if o    

we therefore have the following definition of g   p c   x  y  z  b     where the initial   abbreviates  x  y   z        i e  the base case where m   n   o      and the rest is from the
definition of g    expanding n  using the above definition 
g   p c   x  y  z  b   
    

 

x
c
o 
o
m


x

x

n  p  m    n    b     n  p  mo   no   b 

    mo  m
n    no  n

m   n   o  

xm y n z o
o 

 cancel o  o   rearrange sums and replace an upper bound of  on m
with a restriction 





   x
 x
 x
x

c 
 
 
m
n
o

    
n p  m    n    b     n p  mo   no   b x y 

power x  z
o 

o  
m   n  
m    mo  m
n    no  n


x

 replacing

x

m   m   m   m

    

with



x
x

and redistributing sums 

m     m    

  
x
c
o  

o
 x

x

 
n  p  m    n    b xm  y n 



m     n    

 x

x

  
n  p  mo   no   b  xmo y no

mo    no   
o

power x  z
 o
   x
 x

x
c
    
n  p  m  n  b  xm y n
power x  z o
o
m   n  
o  
xx
 
 replace
n  p  m  n  b xm y n with f
 p  x  y  b    as per its definition 
m

n

c  
x
c
    
f    p  x  y  b   o power x  z o
o 
o  
c  
x
c
f    p  x  y  b   ox z o
    
o 
o  

   

fiwinikoff   cranefield

appendix d  analysis of procedural code structures
we seek to derive an expression for the largest possible number of paths that a program of
given size m can have  i e  a definition of n m    max n p      p     m   recall that a
program is either an  atomic  statement s which has a single path  i e  n s        a sequence
of two programs p    p  where n p    p      n p     n p     or a conditional p    p  where
n p    p      n p      n p    
it is relatively easy to see by examining possible programs that for m    we have
n m    m  for instance  the largest number of paths for m     is obtained by the program
s   s   s  it is also easy to show that for m     the largest number of paths possible is   
but what about larger values of m  we observe that for all m     the program   with
the largest number of paths follows a particular form  for m     the program with the
largest path can be written as p     s   s   s    s   s   and we have n p            more
generally  we define s  to be s   s  and s  to be s   s   s  and we then have the following
result  which shows that programs that have a maximal number of paths for their size  can
be considered to be of a particular form 
theorem d   any program of size i  for i      that has the largest possible number of
paths can be written as pi   pi    pi            pik where each of the pij     j  k  is either s 
or s   
proof  we establish this result by induction  we assume that it holds for all n such that
    n  m  and then show that it must also hold for m      so  let us assume that
there is a program pm   which has a maximal number of paths  but is not in the form
j
 
 
k
pm  
  pm  
          pm  
where each pm  
is either s  or s    there are two cases  depending
on the structure of pm     we consider each case in turn and show that in fact either  a 
pm   can be rewritten to be in the desired form  preserving the number of paths and the
program size  or  b  pm   cannot be maximal  since we can construct a program with size
m     that has a larger number of paths than pm    
j
 
 
k
case    pm   has the form pm  
  pm  
          pm  
but at least one of the pm  
is neither
i
s  nor s    let pm   be one of the sub programs that is neither s  nor s    for convenience
i
we define p i as shorthand for pm  
  now  since p i has size less than m      the induction
hypothesis applies     and so it can be written in the form pi    pi          pil where each pij is
either s  or s    it is easy to see that one can then rewrite pm   into the desired form by
exploiting the associativity of    rewriting it as follows 
i 
i  
i 
i  
      pm  
   pi    pi          pij    pm  
                pm  
  pi    pi          pij   pm  
    
i
applying this rewriting to all pm  
that are not s  or s  yields a program that has size
m      the same number of paths as the original program  but that is in the desired form  a
sequence of sub programs  each of which is either s  or s    this shows that the result holds
for m      i e  that a maximal path program can be written in the desired form 
 
 
k
case    pm   does not have the form pm  
  pm  
          pm  
for any k  which means that
 
k
pm   must consist of a single conditional  i e  pm     pm             pm  
for some k     

    in fact there will be more than one maximal path program  but they all have the same structure  modulo
swapping the order of arguments to   and   
    or  if it has size    then it can be written as s    s  which has the maximal number of paths for a program
of size   and meets the desired form 

   

fion the testability of bdi agent systems

 
 
without loss of generality we can view pm   as being of the form pm  
  pm  
 by viewing
 
k
 
k
pm             pm   as  pm              pm   if k       we now consider the following
 
 
sub cases  depending on the values of n pm  
  and n pm  
  
 
 
case  a  both n pm  
  and n pm  
  are greater than    we can then show that pm   is
 
 
 
not maximal  consider the program pm  
  pm  
  pm  
 i e  where   is replaced
 
 
 
 
by     we know that n pm     pm       n pm      n pm  
   without loss of gen 
 
erality  lets assume that n pm      n pm      we then show that the original pm  
 
 
has fewer paths than pm  
  the number of paths of pm   is n pm       n pm  
  
 
 
 
 
 
n pm      since n pm      n pm      we have that n pm       n pm       n pm     
 
 
 
 
 
n pm  
    n pm  
       n pm  
   since n pm  
  and n pm  
  are both greater
 
 
 
 
than    we then have that    n pm       n pm      n pm       n pm  
   i e  that
 
pm   has more paths than pm     and hence pm   is not maximal for m     
 
 
case  b  at least one of n pm  
  and n pm  
  is not greater than    without loss of
 
 
 
generality  we assume that n pm      n pm  
   there are then two cases  n pm  
 
can be either   or   
 
       now the only
sub case  b i   let us consider first the case where n pm  
program that has one path is a statement s  or a sequence of statements s  s          s 
clearly the latter is not maximal since replacing it with s   s           s would
result in a program of the same size but with more paths  so  therefore if pm  
 
 
 
is maximal  then pm  
must be just s  so pm     s   pm  
  therefore pm  
has
size m  there are now two sub cases  either m is still greater than    or m     
the second sub case is simple  if m is   then we can show  by inspecting possible
 
programs of size    that n         and we therefore have that n s   pm  
  
           however  we also know that  s   s   s    s   s  has size   but   paths 
and hence in this sub case pm   cannot have the maximal number of paths  in
the first sub case  where m is still greater than    the induction hypothesis applies
 
 
can be written in the desired form  we abbreviate pm  
by
and therefore pm  
j
i
 
 
p    and then have pm     s    p    p            p    where each p  is either s  or
  
s    consider now the variant program pm  
    s   p      p           p j    which
  
clearly has the same size as pm     we now show that pm  
has more paths than
j
  
 
 
 
pm     n pm             n p      n p            p       n p            p j      n p     
n p             p j     now  n pm            n p      n p             p j     in order to show
  
that n pm       n pm  
  we just need to show that     n p             p j   which
follows from the fact that there must be at least one p i   and that  since each p i
is either s  or s    it has size of at least   
 
 
 
sub case  b ii   we know that n pm  
      and that    n pm  
   since n pm  
 
 
 
 
n pm     we have that n pm        and hence that n pm           n pm     
 
 
 
   n pm  
    n pm  
   now  if n pm  
  is strictly greater than   then we have
 
that n pm     is strictly less than n pm     and we have shown that pm   actually
 
does not have a maximal number of paths  on the other hand  if n pm  
   
 
then we have that n pm           n pm                  however  for values of
m where this theorem applies  we know that n m       and so we therefore have
shown that in this sub case pm   is not maximal for m     

   

fiwinikoff   cranefield

we have shown that if we assume that pm   is maximal but does not have the structure
specified  then in fact one can derive another program  also of size m      but which either
does satisfy the desired structure  or has a larger number of paths than pm     which contradicts our assumption that pm   is maximal  this establishes the desired property for pm    
by induction the result then applies for all m      as desired 
the previous result shows that when considering programs of a given size m that have
the largest possible number of paths  denoted pm    we can limit ourselves to considering
programs that are of the form p m   p m           pkm where each pim is either s   s or s   s   s 
we now derive a definition for n m   firstly  we observe that  by inspecting cases 
n m    m  if m   
n       
n       
the two first cases have been discussed above  for the last case  there are only two programs
which have the appropriate structure and have size    s    s    s   with   paths  and s    s 
 with   paths  
we now consider m      adding a statement to the program  i e  going from m to m   
in effect modifies pm by adding an s to one of the pim   which increments n pim   by one 
since multiplication is commutative and associative  without loss of generality  we assume
m    n p m   and
that we increment n pkm    we therefore have that n pm     n p m           pk 
k
m
m
m
that n pm       n p            pk      n pk         there are two cases 
m    and that therefore
case    if all the pim are s    then we have n pm     n p m           pk 
m        n p        note that in this case p
n pm       n p m           pk 
m
m   can be
 
m
m
written as p            pk    s    s   

case    if some pim are s  and some are s  then we observe that replacing a   with a   gives
a greater increase to the number of paths than replacing a   with a    and hence  after
m   
possibly reordering the pim so that pkm   s    we have n pm     n p m           pk 
 
m
m
and that n pm       n p            pk         n pm       
we therefore have a recursive definition for n m  depending on the form of pm   we next
observe that in fact the form of pm follows a simple cycle  we know that for m      case  
holds  as above  p    s    s     we therefore have that p  can be written as s    s    s    hence
p  can be written as s    s    s  or s    s    s    and hence p  can be written as s    s    s   
more generally  we can prove by induction that pm can be written as p m           pkm where
the following holds   a  if m is a multiple of    then all of the pim are s    and  b  if m is
one more than a multiple of    then exactly two of the pim are s  and the rest are s    and
 c  if m is two more than a multiple of    then exactly one of the pim is s  and the rest are
s    this gives us the following recursive definition  where m    is a multiple of   
n m        n m  

 
 

n m        n m      
   

 
 

fion the testability of bdi agent systems

n m        n m      

 
 

which can be simplified to 
 
 
  
n m        n m  
     n m 
  
   
     n m 
n m        n m  
   
n m        n m  

we can easily derive a non recursive definition by focusing on the last case and observing
that as n             and n m           n m   for m    being a multiple of     then
we have that n m     m     we can substitute this in the definition above to obtain the
following complete definition for n m   where m    is a multiple of   
n       
n       
n       
n       
n       
n m     m  
 
n m       
  m  
 
n m            m  

   

fiwinikoff   cranefield

references
benfield  s  s   hendrickson  j     galanti  d          making a strong business case for
multiagent technology  in stone  p     weiss  g   eds    proceedings of the fifth international joint conference on autonomous agents and multiagent systems  aamas  
pp        acm press 
bordini  r  h   fisher  m   pardavila  c     wooldridge  m          model checking agentspeak  in proceedings of the second international joint conference on autonomous
agents and multiagent systems  aamas   pp          acm press 
bordini  r  h   hubner  j  f     wooldridge  m          programming multi agent systems
in agentspeak using jason  wiley 
bratman  m  e   israel  d  j     pollack  m  e          plans and resource bounded practical
reasoning  computational intelligence            
bratman  m  e          intentions  plans  and practical reason  harvard university press 
cambridge  ma 
burch  j   clarke  e   mcmillan  k   dill  d     hwang  j          symbolic model checking 
     states and beyond  information and computation                 
burmeister  b   arnold  m   copaciu  f     rimassa  g          bdi agents for agile goaloriented business processes  in proceedings of the seventh international conference on
autonomous agents and multiagent systems  aamas   industry track   pp       
ifaamas 
busetta  p   ronnquist  r   hodgson  a     lucas  a          jack intelligent agents components for intelligent agents in java  agentlink news     
dastani  m           apl  a practical agent programming language  autonomous agents
and multi agent systems                 
dastani  m   hindriks  k  v     meyer  j  j  c   eds            specification and verification
of multi agent systems  springer  berlin heidelberg 
de silva  l     padgham  l          a comparison of bdi based real time reasoning and
htn based planning  in webb  g     yu  x   eds    ai       advances in artificial
intelligence  vol       of lecture notes in computer science  pp            springer 
berlin heidelberg 
dennis  l  a   fisher  m   webster  m  p     bordini  r  h          model checking agent
programming languages  automated software engineering              
dinverno  m   kinny  d   luck  m     wooldridge  m          a formal specification of
dmars  in singh  m   rao  a     wooldridge  m   eds    intelligent agents iv 
proceedings of the fourth international workshop on agent theories  architectures 
and languages  vol       of lecture notes in artificial intelligence  pp         
berlin heidelberg  springer 
dorigo  m     stutzle  t          ant colony optimization  mit press 
dwyer  m  b   hatcliff  j   pasareanu  c   robby    visser  w          formal software analysis  emerging trends in software model checking  in future of software engineering
      pp          los alamitos  ca  ieee computer society 
   

fion the testability of bdi agent systems

ekinci  e  e   tiryaki  a  m   cetin  o     dikenelli  o          goal oriented agent testing
revisited  in luck  m     gomez sanz  j  j   eds    agent oriented software engineering ix  vol       of lecture notes in computer science  pp          berlin heidelberg  springer 
erol  k   hendler  j     nau  d          complexity results for htn planning  annals of
mathematics and artificial intelligence               
erol  k   hendler  j  a     nau  d  s          htn planning  complexity and expressivity 
in proceedings of the   th national conference on artificial intelligence  aaai   pp 
          aaai press 
fix  l   grumberg  o   heyman  a   heyman  t     schuster  a          verifying very
large industrial circuits using     processes and beyond  in peled  d     tsay  y k   eds    automated technology for verification and analysis  vol       of lecture
notes in computer science  pp        berlin heidelberg  springer 
georgeff  m  p     lansky  a  l          procedural knowledge  proceedings of the ieee 
special issue on knowledge representation                    
gomez sanz  j  j   bota  j   serrano  e     pavon  j          testing and debugging of
mas interactions with ingenias  in luck  m     gomez sanz  j  j   eds    agentoriented software engineering ix  vol       of lecture notes in computer science 
pp          berlin heidelberg  springer 
huber  m  j          jam  a bdi theoretic mobile agent architecture  in proceedings of
the third international conference on autonomous agents  agents     pp         
acm press 
ingrand  f  f   georgeff  m  p     rao  a  s          an architecture for real time reasoning
and system control  ieee expert              
jorgensen  p          software testing  a craftsmans approach  second edition   crc
press 
lee  j   huber  m  j   kenny  p  g     durfee  e  h          um prs  an implementation of the procedural reasoning system for multirobot applications  in proceedings of the conference on intelligent robotics in field  factory  service  and space
 cirffss     pp          american institute of aeronautics and astronautics 
mathur  a  p          foundations of software testing  pearson 
miller  j  c     maloney  c  j          systematic mistake analysis of digital computer
programs  communications of the acm              
morley  d     myers  k          the spark agent framework  in proceedings of the
third international joint conference on autonomous agents and multiagent systems
 aamas   pp          new york  acm 
munroe  s   miller  t   belecheanu  r   pechoucek  m   mcburney  p     luck  m         
crossing the agent technology chasm  experiences and challenges in commercial applications of agents  knowledge engineering review                 
   

fiwinikoff   cranefield

naish  l          resource oriented deadlock analysis  in dahl  v     niemela  i   eds   
proceedings of the   rd international conference on logic programming  vol       of
lecture notes in computer science  pp          springer  berlin heidelberg 
nguyen  c   miles  s   perini  a   tonella  p   harman  m     luck  m       a   evolutionary testing of autonomous software agents  in proceedings of the  th international
conference on autonomous agents and multiagent systems  aamas   pp         
ifaamas 
nguyen  c  d   perini  a     tonella  p       b   experimental evaluation of ontology based
test generation for multi agent systems  in luck  m     gomez sanz  j  j   eds   
agent oriented software engineering ix  vol       of lecture notes in computer
science  pp          berlin heidelberg  springer 
nguyen  c  d   perini  a     tonella  p          automated continuous testing of multiagent systems  in proceedings of the fifth european workshop on multi agent systems
 eumas  
padgham  l     winikoff  m          developing intelligent agent systems  a practical
guide  john wiley and sons 
paolucci  m   shehory  o   sycara  k  p   kalp  d     pannu  a          a planning component for retsina agents  in jennings  n  r     lesperance  y   eds    proceedings
of the  th international workshop on agent theories  architectures  and languages
 atal   vol       of lecture notes in computer science  pp          berlin heidelberg  springer 
pokahr  a   braubach  l     lamersdorf  w          jadex  a bdi reasoning engine  in
bordini  r  h   dastani  m   dix  j     el fallah seghrouchni  a   eds    multi agent
programming  languages  platforms and applications  chap     pp          springer 
raimondi  f     lomuscio  a          automatic verification of multi agent systems by
model checking via ordered binary decision diagrams  j  applied logic            
    
rao  a  s          agentspeak l   bdi agents speak out in a logical computable language 
in de velde  w  v     perrame  j   eds    agents breaking away  proceedings of
the seventh european workshop on modelling autonomous agents in a multi agent
world  maamaw     vol       of lecture notes in artificial intelligence  pp       
berlin heidelberg  springer 
rao  a  s     georgeff  m  p          modeling rational agents within a bdi architecture 
in allen  j   fikes  r     sandewall  e   eds    proceedings of the second international
conference on principles of knowledge representation and reasoning  pp         
morgan kaufmann 
sardina  s     padgham  l          a bdi agent programming language with failure handling  declarative goals  and planning  autonomous agents and multi agent systems 
             
shaw  p   farwer  b     bordini  r          theoretical and experimental results on the
goal plan tree problem  in proceedings of the seventh international conference on
autonomous agents and multiagent systems  aamas   pp            ifaamas 
   

fion the testability of bdi agent systems

sloane  n  j  a          the on line encyclopedia of integer sequences  http   www research 
att com njas sequences  
thangarajah  j   winikoff  m   padgham  l     fischer  k          avoiding resource
conflicts in intelligent agents  in van harmelen  f   ed    proceedings of the   th
european conference on artificial intelligence  ecai   pp        ios press 
van riemsdijk  m  b   dastani  m     winikoff  m          goals in agent systems  a
unifying framework  in proceedings of the seventh conference on autonomous agents
and multiagent systems  aamas   pp          ifaamas 
wilf  h  s          generatingfunctionology  second edition   academic press inc   boston 
ma  http   www math upenn edu wilf gfology  pdf 
winikoff  m          assurance of agent systems  what role should formal verification
play   in dastani  m   hindriks  k  v     meyer  j  j  c   eds    specification and
verification of multi agent systems  chap      pp          springer  berlin heidelberg 
winikoff  m   padgham  l   harland  j     thangarajah  j          declarative   procedural goals in intelligent agent systems  in proceedings of the eighth international
conference on principles of knowledge representation and reasoning  kr       pp 
        toulouse  france  morgan kaufmann 
wooldridge  m          an introduction to multiagent systems  john wiley   sons 
chichester  england 
wooldridge  m   fisher  m   huget  m  p     parsons  s          model checking multi agent
systems with mable  in proceedings of the first international joint conference on
autonomous agents and multi agent systems  aamas   pp          acm press 
zhang  z   thangarajah  j     padgham  l          model based testing for agent systems 
in filipe  j   shishkov  b   helfert  m     maciaszek  l   eds    software and data
technologies  vol     of communications in computer and information science  pp 
        berlin heidelberg  springer 
zhu  h   hall  p  a  v     may  j  h  r          software unit test coverage and adequacy 
acm computing surveys                 

   

fi