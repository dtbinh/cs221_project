journal artificial intelligence research                  

submitted        published      

exact double oracle algorithm zero sum
extensive form games imperfect information
branislav bosansky

branislav bosansky agents fel cvut cz

agent technology center
department computer science
faculty electrical engineering
czech technical university prague

christopher kiekintveld

cdkiekintveld utep edu

computer science department
university texas el paso  usa

viliam lisy
michal pechoucek

viliam lisy agents fel cvut cz
michal pechoucek agents fel cvut cz

agent technology center
department computer science
faculty electrical engineering
czech technical university prague

abstract
developing scalable solution algorithms one central problems computational
game theory  present iterative algorithm computing exact nash equilibrium
two player zero sum extensive form games imperfect information  approach
combines two key elements      compact sequence form representation extensiveform games     algorithmic framework double oracle methods  main idea
algorithm restrict game allowing players play selected sequences
available actions  solving restricted game  new sequences added finding
best responses current solution using fast algorithms 
experimentally evaluate algorithm set games inspired patrolling
scenarios  board  card games  results show significant runtime improvements
games admitting equilibrium small support  substantial improvement memory use even games large support  improvement memory use particularly
important allows algorithm solve much larger game instances existing
linear programming methods 
main contributions include     generic sequence form double oracle algorithm
solving zero sum extensive form games      fast methods maintaining valid restricted
game model adding new sequences      search algorithm pruning methods
computing best response sequences      theoretical guarantees convergence
algorithm nash equilibrium      experimental analysis algorithm several
games  including approximate version algorithm 

   introduction
game theory widely used methodology analyzing multi agent systems applying
formal mathematical models solution concepts  one focus computational game theory development scalable algorithms reasoning large games 
c
    
ai access foundation  rights reserved 

fibosansky  kiekintveld  lisy    pechoucek

need continued algorithmic advances driven growing number applications
game theory require solving large game instances  example  several decision
support systems recently deployed homeland security domains recommend
policies based game theoretic models placing checkpoints airports  pita  jain 
western  portway  tambe  ordonez  kraus    parachuri         scheduling federal air
marshals  tsai  rathi  kiekintveld  ordonez    tambe         patrolling ports  shieh 
an  yang  tambe  baldwin  direnzo  meyer  baldwin  maule    meyer         capabilities systems based large amount research fast algorithms
security games  tambe         another notable example algorithmic progress
led game theoretic poker agents competitive highly skilled human
opponents  e g   see zinkevich  bowling    burch        sandholm        
focus developing new algorithms important general class games
includes security games poker  well many familiar games  precisely 
study two player zero sum extensive form games  efgs  imperfect information 
class games captures sequential interactions two strictly competitive players
situations make decisions uncertainty  uncertainty caused either
stochastic environment opponent actions directly
observable  consider general models sequential interactions uncertainty 
many fast algorithms developed poker security domains
rely specific game structure 
propose new class algorithms finding exact  or approximate  nash equilibrium solutions class efgs imperfect information  leading exact
algorithm literature uses compact sequence form representation linear programming optimization techniques solve games type  koller  megiddo    von
stengel        von stengel         approach exploits compact representation  improve solution methods adopting algorithmic framework based
decompositions known computational game theory literature oracle algorithms
 mcmahan  gordon    blum         oracle algorithms related methods constraint column generation used solving large scale optimization problems  dantzig  
wolfe        barnhart  johnson  nemhauser  savelsbergh    vance        exploit two
characteristics commonly found games  first  many cases finding solution
game requires using small fraction possible strategies  necessary
enumerate strategies find solution  wilson        koller   megiddo        
second  finding best response specific opponent strategy game computationally
much less expensive solving equilibrium  addition  best response algorithms
often make use domain specific knowledge heuristics speed calculations
even further 
sequence form double oracle algorithm integrates decomposition ideas oracle
algorithms compact sequence form representation efgs imperfect information  results iterative algorithm always need generate
complete linear program game find nash equilibrium solution  main idea
algorithm create restricted game players choose limited
space possible strategies  represented sequences actions   algorithm solves
restricted game uses fast best response algorithm find strategies
original unrestricted game perform well current solution restricted
   

fian exact double oracle algorithm zero sum efgs imperfect information

game  strategies added restricted game process iterates
best response found improve solution  case  current solution
equilibrium original game  typically  solution found adding small
fraction strategies restricted game 
begin presenting related work  technical background  notation 
describe main algorithm three parts      methods creating  solving  expanding valid restricted game      algorithm finding best response strategies
added restricted game      variants main loop controlling iterative
process solving restricted games adding new strategies  present formal analysis
prove algorithm converges nash equilibrium original game  finally  provide experimental evaluation runtime performance convergence
behavior algorithm several realistic games different characteristics including
border patrolling scenario  phantom tic tac toe  simplified variant poker 
compare results state of the art algorithms finding exact approximate solutions  linear programming using sequence form  counterfactual regret
minimization  cfr  zinkevich  johanson  bowling    piccione        lanctot        
experimental results confirm algorithm requires fraction possible sequences solve game practice significantly reduces memory requirements
solving large games  advances state art allows us exactly solve
much larger games compared existing algorithms  moreover  games admitting
equilibrium small support  i e   sequences non zero probability
equilibrium   algorithm achieves significant improvements computation time
finds equilibrium iterations  result hold without using
domain specific knowledge  show incorporating domain specific heuristics
bounds algorithm straightforward way lead even significant
performance improvements  analysis convergence rate shows approximative
bounds value game either similar bit worse early stages
compared cfr  however  convergence behavior cfr algorithm long
tail algorithm always finds exact solution much faster cfr 

   related work
solving imperfect information efgs computationally challenging task  primarily due
uncertainty actions opponent and or stochastic environment 
leading exact algorithm  koller et al         von stengel        based formulating
problem finding optimal strategy play linear program  algorithm exploits
compact representation strategies sequences individual actions  called sequence
form  results linear program linear size size game tree  however 
approach limited applicability since game tree grows exponentially
number sequential actions game  common practice overcoming limited
scalability sequence form linear programming use approximation method 
best known approximative algorithms include counterfactual regret minimization  cfr 
zinkevich et al          improved versions cfr sampling methods  lanctot  waugh 
zinkevich    bowling        gibson  lanctot  burch  szafron    bowling         nesterovs
excessive gap technique  egt  hoda  gilpin  pena    sandholm         variants
   

fibosansky  kiekintveld  lisy    pechoucek

monte carlo tree search  mcts  algorithms applied imperfect information games  e g  
see ponsen  de jong    lanctot        
family counterfactual regret minimization algorithms based learning methods informally described follows  algorithm repeatedly traverses
game tree learns strategy play applying no regret learning rule minimizes specific variant regret  counterfactual regret  information set 
no regret learning converges optimal strategy information set  overall
regret bounded sum regret information set  hence  strategy
whole converges nash equilibrium  main benefits approach include
simplicity robustness  adapted generic games  e g   see lanctot 
gibson  burch  zinkevich    bowling        cfr applied games imperfect
recall   however  algorithm operates complete game tree therefore requires
convergence information sets  slow large games one desires
solution small error 
another popular method excessive gap technique exploits convex properties
sequence form representation uses recent mathematical results finding extreme
points smooth functions  see hoda et al         details   main idea approximate problem finding pair equilibrium strategies two smoothed functions
guiding find approximate solution  although approach achieves faster
convergence comparison cfr  algorithm less robust  it known whether
similar approach used general classes games  less used practice 
cfr  egt operates complete strategy space sequences 
monte carlo tree search  mcts  another family methods shown promise
solving large games  particular perfect information board games go  e g  
lee et al          cfr egt algorithms guaranteed find  nash
equilibrium  convergence equilibrium solution formally shown
variants mcts imperfect information games  contrary  common
version mcts based upper confidence bounds  ucb  selection function
converge incorrect solutions even simultaneous move games  shafiei  sturtevant   
schaeffer        simplest class imperfect information efgs  mcts algorithms therefore  in general  guarantee finding  approximate  optimal solution
imperfect information games  one exception recent proof convergence mcts
certain selection methods simultaneous move games  lisy  kovarik  lanctot   
bosansky         still  using mcts sometimes reasonable choice since produce
good strategies practice  ponsen et al         
contrary existing approximative approaches  algorithm aims find exact solution without explicitly considering strategy complete game tree 
work combines compact sequence form representation double oracle algorithmic framework  previous work double oracle framework focused primarily
applications normal form games  restricted game expanded adding pure
best response strategies iteration  one first examples solving games using
double oracle principle mcmahan et al          introduced doubleoracle algorithm  proved convergence nash equilibrium  experimentally verified
algorithm achieves computation time improvements search game
evader trying cross environment without detected sensors placed
   

fian exact double oracle algorithm zero sum efgs imperfect information

opponent  double oracle algorithm reduced computation time several hours
tens seconds allowed solve much larger instances game  similar success
domain specific double oracle methods demonstrated variety different domains inspired pursuit evasion games  halvorson  conitzer    parr       
security games played graph  jain  korzhyk  vanek  conitzer  tambe    pechoucek 
      letchford   vorobeychik        jain  conitzer    tambe        
works tried apply iterative framework oracle algorithms
efgs  primarily using pure mixed strategies efgs  first work exploited
iterative principle predecessor sequence form linear program formulation  koller
  megiddo         algorithm  authors use representation similar sequence form single player  strategies opponent iteratively
added constraints linear program  there exponential number constraints
formulation   approach seen specific variant oracle algorithms  strategy space expanded gradually single player  algorithm
generalization work  since algorithm uses sequence form representation
players incrementally expands strategy space players 
recent work done mcmahan thesis  mcmahan        followup work  mcmahan   gordon         works authors investigated extension
double oracle algorithm normal form games extensive form case 
double oracle algorithm efgs operates similarly normal form variant
uses pure mixed strategies defined efgs  main disadvantage approach
basic version still requires large amount memory since pure strategy
efg large  one action needs specified information set  
exponential number possible pure strategies  overcome disadvantage 
authors propose modification double oracle algorithm keeps number
strategies restricted game bounded  algorithm removes restricted game
strategies least used current solution restricted game 
order guarantee convergence  algorithm adds iteration restricted
game mixed strategy representing mean removed strategies  convergence
guaranteed similarly fictitious play  see mcmahan   gordon        details  
bounding size restricted game results low memory requirements  however 
algorithm converges extremely slowly take long time  several hours
small game  algorithm achieve small error  see experimental evaluation
mcmahan        mcmahan   gordon        
similar concept using pure strategies efgs used iterative algorithm
designed poker work zinkevich et al          algorithm work
expands restricted game strategies found generalized best response instead
using pure best response strategies  generalized best response nash equilibrium
partially restricted game player computing best response use pure
strategies original unrestricted game  opponent restricted use
strategies restricted game  however  main disadvantages using pure
mixed strategies efgs still present result large memory requirements
exponential number iterations 
contrast  algorithm directly uses compact sequence form representation
efgs uses sequences building blocks  i e   restricted game expanded
   

fibosansky  kiekintveld  lisy    pechoucek

allowing new sequences played next iteration   using sequences
sequence form solving restricted game reduces size restricted game
number iterations  however  introduces new challenges constructing
maintaining restricted game  ensuring convergence nash equilibrium 
must solve algorithm converge correct solution 

   technical background
begin presenting standard game theoretic model extensive form games  followed discussion common solution concepts algorithms computing solutions  present sequence form representation state of theart linear program computing solutions using representation  finally  describe
oracle algorithms used solving normal form games  summary
common notation provided table   quick reference 
    extensive form games
extensive form games  efgs  model sequential interactions players game 
games extensive form visually represented game trees  e g   see figure    
nodes game tree represent states game  state game corresponds
sequence moves executed players game  node assigned player
acts game state associated node  edge game tree
node corresponds action performed player acts node 
extensive form games model limited observations players grouping nodes
information sets  given player cannot distinguish nodes belong
information set player choosing action  model represents
uncertainty environment stochastic events using special nature player 
formally  two player efg defined tuple g    n  h  z  a  p  u  c  i   n set
two players n           use refer one two players  either      
refer opponent i  h denotes finite set nodes game tree  node
corresponds unique history actions taken players nature root
game  hence  use terms history node interchangeably  denote z h
set terminal nodes game  denotes set actions overload
notation use a h  represent set actions available player acting
node h h  specify ha   h  h node h  reached node h executing
action a h   say h prefix h  denote h v h    terminal
node z z define utility function player  ui   z r   study zero sum
games  ui  z    ui  z  holds z z 
function p   h n  c  assigns node player takes action
node  c means nature player selects action node based fixed
probability distribution known players  use function c   h        denote
probability reaching node h due nature  i e   assuming players play
required actions reach node h   value c h  product probabilities
assigned actions taken nature player history h  imperfect observation
player modeled via information sets ii form partition nodes assigned
player  h h   p h    i   every information set contains least one node
   

fian exact double oracle algorithm zero sum efgs imperfect information

node belongs exactly one information set  nodes information set player
indistinguishable player  nodes h single information set ii ii
set possible actions a h   action a h  uniquely identifies information set
ii cannot exist node h  h belong information set
ii allowed played  i e   a h      therefore overload notation
use a ii   denote set actions defined node h information set 
assume perfect recall  means players perfectly remember actions
information gained course game  result  nodes
information set ii history actions player i 
    nash equilibrium extensive form games
solving game requires finding strategy profile  i e   one strategy player 
satisfies conditions defined specific solution concept  nash equilibrium  ne 
best known solution concept game theory describes behavior players
certain assumptions rationality  nash equilibrium  every player plays
best response strategies players  let set pure strategies
player i  efgs  pure strategy assignment exactly one action played
information set  mixed strategy probability distribution set pure
strategies player  denote set mixed strategies player i 
pair strategies            use ui      ui  i     expected outcome
game player players follow strategies   best response player
opponents strategy strategy ibr   ui  ibr     ui  i     
strategies i    strategy profile            ne player
holds best response   game multiple nes  zero sum
setting  equilibria value  i e   expected utility every player
same   called value game  denoted v   problem finding
ne zero sum game polynomial computational complexity size game 
ne solution concept somewhat weak extensive form games  nash equilibrium
requires players act rationally  however  irrational strategies selected
parts game tree reachable players follow ne
strategies  these parts said equilibrium path   reason ne
expect part game played therefore sufficiently restrict
strategies information sets  overcome drawbacks  number refinements
ne introduced imposing restrictions intention describing
sensible strategies  examples include subgame perfect equilibrium  selten        used
perfect information efgs  subgame perfect equilibrium forces strategy profile
nash equilibrium sub game  i e   sub tree rooted node h 
original game  unfortunately  sub games particularly useful imperfectinformation efgs  hence  refinements include strategic from perfect equilibrium
 selten         sequential equilibrium  kreps   wilson         quasi perfect equilibrium
 van damme        miltersen   srensen         first refinement avoids using weakly
dominated strategies equilibrium strategies two player games  van damme       
p      known undominated equilibrium  sequential equilibrium tries
exploit mistakes opponent using notion beliefs consistent
   

fibosansky  kiekintveld  lisy    pechoucek

strategy opponent even information sets equilibrium path  main
intuitions behind first two refinements combined quasi perfect equilibrium 
even though solution described ne always prescribe rational strategies
equilibrium path  still valuable compute exact ne large extensive form
games several reasons  focus zero sum games  ne strategy guarantees
value game even equilibrium path  words  strategy
equilibrium path optimally exploit mistakes opponent  still
guarantees outcome least value gained following equilibrium path  moreover 
refined equilibrium still ne calculating value game often starting
point many algorithms compute refinements example used
computing undominated equilibrium  e g   see ganzfried   sandholm        cermak 
bosansky    lisy        normal form proper equilibrium  miltersen   srensen        
    sequence form linear program
extensive form games perfect recall compactly represented using sequence
form  koller et al         von stengel         sequence ordered list actions taken
single player history h  number actions  i e   length sequence  
denoted  i   empty sequence  i e   sequence actions  denoted  
set possible sequences player denoted set sequences
players         sequence extended single action taken
player i  denoted   i   we use v i  denote prefix i     games
perfect recall  nodes information set ii share sequence actions
player use seqi  ii   denote sequence  overload notation use
seqi  h  denote
leading node h  seqi  h      
sequence of  actions player
 
 
seqi  h     h  h   seqi  h   h h  since action uniquely identifies
information set ii nodes information set share history actions
player i  sequence uniquely identifies information set  use function infi  i   
denote information set last action sequence i  taken 
empty sequence  function infi    information set root node 
finally  define auxiliary payoff function gi   r extends utility
function nodes game tree  payoff function gi represents expected
utility nodes reachable sequentially executing actions specified pair
sequences  
x
gi  i      
ui  h  c h 
   
hz   jn j  seqj  h 

value payoff function defined   leaf reachable sequentially executing actions sequences either actions pair sequences
executed inner node  h h   z  reached  sequential execution actions node h reached  current action executed
sequence  h  defined  i e  
  a h    formally define pair sequences
compatible exists node h h sequence every player equals
seqi  h  
compute nash equilibrium two player zero sum extensive form game
using linear program  lp  polynomial size size game tree using
   

fian exact double oracle algorithm zero sum efgs imperfect information

sequence form  koller et al         von stengel         lp uses equivalent compact
representation mixed strategies players form realization plans  realization
plan sequence probability player play sequence actions
assumption opponent choose compatible sequences actions
reach information sets actions specified sequence defined 
denote realization plan player ri   r  equilibrium realization plans
computed using following lp  e g   see shoham   leyton brown        p       

vinfi  i  

x

max vinfi   
r v
x
 
vii

gi  i     ri  i  

   seq  i     
ii








ri       
x

   
   

ri  i a    ri  i  

ii ii     seqi  ii  

   



   

aa ii  

ri  i    

solving lp yields realization plan player using variables ri   expected values
information sets player  variables vii    lp works follows  player
maximizes expected utility value selecting values variables realization plan constrained equations       probability playing empty
sequence defined    equation     probability playing sequence
equal sum probabilities playing sequences extended exactly one action
 equation     finding realization plan constrained best responding
opponent  player i  ensured equation      player selects
information set ii action minimizes expected utility value vii information set  one constraint defined sequence   last action
sequence determines best action played information set infi  i     ii  
expected utility composed expected utilities information sets reachable
playing sequence  sum v variables left side  expected utilities
leafs sequence leads  sum g values right side constraint  
    double oracle algorithm normal form games
describe concept column constraint generation techniques applied previously
normal form games known double oracle algorithm  mcmahan et al         
normal form games represented using game matrices  rows matrix correspond
pure strategies one player  columns correspond pure strategies opponent 
values matrix cells represent expected outcome game players
play corresponding pure strategies  zero sum normal form games solved linear
programming polynomial time size matrix  e g   see shoham   leytonbrown        p      
figure   shows visualization main structure double oracle algorithm
normal form games  algorithm consists following three steps repeat
convergence 
   

fibosansky  kiekintveld  lisy    pechoucek

figure    schematic double oracle algorithm normal form game 
   create restricted game limiting set pure strategies player
allowed play
   compute pair nash equilibrium strategies restricted game using lp
solving normal form games
   player  compute pure best response strategy equilibrium strategy
opponent found previous step  best response may pure strategy
original unrestricted game
best response strategies computed step   added restricted game  game
matrix expanded adding new rows columns  algorithm continues
next iteration  algorithm terminates neither players improve outcome
game adding new strategy restricted game  case players
play best response strategy opponent original unrestricted game 
algorithm maintains values expected utilities best response strategies
throughout iterations algorithm  values provide bounds value
original unrestricted game v perspective player i  minimal value
past best response calculations represents upper bound value
original game  viu b   maximal value past best response calculations
opponent represents lower bound value original game  vilb   note
bounds holds lower bound player equal negative value
upper bound opponent 
ub
vilb   vi

general  computing best responses computationally less demanding solving
game  since problem reduced single player optimization  due fact bestresponse algorithms operate quickly  e g   exploiting additional domainspecific knowledge   called oracles context  algorithm incrementally
adds strategies one player  algorithm called single oracle algorithm 
algorithm incrementally adds strategies players  algorithm called
double oracle algorithm  double oracle algorithms typically initialized arbitrary
pair strategies  one pure strategy player   however  use larger set
initial strategies selected based domain specific knowledge 
double oracle algorithm zero sum normal form games runs polynomial time
size game matrix  since iteration adds least one pure strategy
   

fian exact double oracle algorithm zero sum efgs imperfect information

figure    example two player extensive form game visualized game tree  circle
player aims maximize utility value  box aims minimize utility value  bold
edges represent sequences actions added restricted game 
restricted game finite pure strategies  algorithm stops
 i      i   iterations  iteration polynomial  since consists solving
linear program computing best responses  relative performance doubleoracle algorithm compared solving linear program original unrestricted game
closely depends number iterations required convergence  worst case 
algorithm adds pure strategies solves original game  although rarely
case practice  estimating expected number iterations needed double oracle
algorithm converge  however  remains open problem 
      towards extensive form games
straightforward method applying double oracle algorithm efgs use pure
strategies defined efgs  i e   assignments action information set  realization
plans  apply exactly algorithm described section i e   iteratively add
pure strategies unrestricted extensive form game restricted game matrix 
however  result exponential number iterations exponentially large
restricted game worst case  algorithm differs significantly idea since
directly operates  more compact  sequences instead full strategies 

   sequence form double oracle algorithm extensive form games
describe sequence form double oracle algorithm solving extensive form
games imperfect information  first  give informal overview algorithm 
use example game depicted figure   illustrate key concepts  afterwards  formally define restricted game describe key components
algorithm  following full example run algorithm 
overall scheme algorithm based double oracle framework described
previous section  main difference algorithm uses sequences define
restrictions game tree  restricted game model defined allowing
players use  i e   play non zero probability  subset sequences
original unrestricted game  restricted subset sequences defines subsets
reachable actions  nodes  information sets original game tree  consider example figure    restricted game defined sequences   a  ac  ad circle
player    x box player  sequences represent actions allowed game 
   

fibosansky  kiekintveld  lisy    pechoucek

define reachable nodes  using history reference   a  ax  axc  axd  
reachable information sets  i    i  circle player information set
box player  
algorithm iteratively adds new sequences allowed actions restricted
game  similarly double oracle algorithm normal form games  restricted game
solved standard zero sum extensive form game using sequence form linear program  best response algorithm searches original unrestricted game find new
sequences add restricted game  sequences added  restricted
game tree expanded adding new actions  nodes  information sets
reachable based new sets allowed sequences  process solving restricted
game adding new sequences iterates new sequences improve solution
added 
two primary complications arise use sequences instead full
strategies double oracle algorithm  due fact sequences necessarily define actions information sets      strategy computed restricted game
may complete strategy original game  define behavior
information sets restricted game      may possible
play every action sequence allowed restricted game  playing
sequence depend compatible sequence actions opponent 
example game tree figure    strategy circle player restricted game
specifies play information sets i  i    consequence second issue
inner nodes original unrestricted game  temporarily  become leafs
restricted game  example  box player add sequence restricted
game making node ay leaf restricted game  since actions
circle player restricted game applicable node 
algorithm solves complications using two novel ideas  first idea
concept default pure strategy  denoted idef    informally speaking  algorithm
assumes player fixed implicit behavior defines player
default information set part restricted game  described
default strategy idef   specifies action every information set  note
default strategy need represented explicitly  which could use large amount
memory   instead  defined implicitly using rules  selecting first action
deterministic method generating ordered set actions a h  node h 
use default pure strategies map every strategy restricted game valid
strategy full game  specifically  strategy original unrestricted game selects
actions according probabilities specified strategy restricted game
every information set part restricted game  information sets
plays according default pure strategy  recall example figure   
pure default strategy circle player ha  c  e  gi  i e   selecting leftmost
action information set   hence  strategy original unrestricted game use
strategy restricted game information sets i  i    select pure actions
e  g information sets i  i  respectively 
second key idea use temporary utility values cases
allowed actions played node restricted game inner
node original game  so called temporary leaf    ensure correct convergence
   

fian exact double oracle algorithm zero sum efgs imperfect information

h
zh
idef
ri     r
c   h   r
gi   h   r
seqi
infi     ii

game tree nodes   histories
leafs   terminal states
implicit default pure strategy player
realization plan player sequence
probability reaching node due nature play
extension utility function nodes 
gi  h    ui  h  c h  h z gi  h      h terminal node  h
  z 
sequence s  actions player leading node   set nodes  
  information set
information set last action sequence executed

table    outline main symbols used paper 

algorithm temporary utilities must assigned provide bound
expected value gained continuing play given node  algorithm uses
value corresponds expected outcome continuing game play  assuming
player making choice temporary leaf uses default strategy 
opponent plays best response  assume add sequence box player
restricted game example tree figure    temporary utility value node ay
would correspond value    since default strategy information set i  play e
circle player  next section formally describe method prove
correctness algorithm given temporary values 
describe detail key parts method  first formally define
restricted game methods expanding restricted game  including details
key ideas introduced above  describe algorithm selecting
new sequences allowed next iteration  decision sequences add
based calculating best response original unrestricted game using game tree
search improved additional pruning techniques  finally  discuss different variations
main logic double oracle algorithm determines player s 
algorithm adds new best response sequences current iteration 
    restricted game
section formally defines restricted game subset original unrestricted
game  restricted game fully specified set allowed sequences  define
sets nodes  actions  information sets subsets original unrestricted sets
based allowed sequences  denote original unrestricted game tuple
g    n  h  z  a  p  u  c  i  restricted game g     n  h     z     a    p  u    c      
sets functions associated restricted game use prime notation  set
players  functions p c remain same 
restricted game defined set allowed sequences  denoted    
returned best response algorithms  indicated above  even allowed sequence
  might playable full length due missing compatible sequences
opponent  therefore  restricted game defined using maximal compatible set
sequences     given set allowed sequences     define   maximal
   

fibosansky  kiekintveld  lisy    pechoucek

subset sequences   that 
 i  i  i    i h h j n seqj  h    j  

n

   

equation     means player every sequence  i   exists
compatible sequence opponent allows sequence executed full
 i e   sequentially executing actions sequences node h
reached seqj  h    j players j n   
set sequences   fully defines restricted game  sets
tuple g  derived     node h restricted game
sequences must played reach h set   players 
h    h h   n seqi  h     

   

pair sequences     nodes reachable executing pair sequences
included h     actions defined node h restricted game
playing action node leads node restricted game 
a   h   a a h    ha h    

h h  

   

nodes restricted game corresponding inner nodes original unrestricted
game may inner nodes restricted game  therefore  set leaves
restricted game union leaf nodes original game inner nodes
original game currently valid continuation restricted game  based
allowed sequences 

z   z h    h h     z   a   h     
   
explicitly differentiate leaves restricted game correspond leaves
original unrestricted game  i e   z   z  leaves restricted game correspond
inner nodes original unrestricted game  i e   z     z   since algorithm assigns
temporary utility values nodes latter case 
information sets restricted game correspond information sets original
unrestricted game  node h belongs information set ip h  original game 
holds restricted game  define information set part
restricted game least one inner node belongs information
set included restricted game 
ii   ii ii   h ii h h     z    

    

information set restricted game ii ii  consists nodes
restricted game i e   h ii   h h    
finally  define modified utility function u  restricted game  primary
reason modified utility function define temporary utility values leaves
set z    z  consider h z    z temporary leaf player player acting
node  i   p h    moreover  let ui  h  expected outcome game starting
node assuming players playing ne strategies original unrestricted
game  modified utility function u i leaf must return value lower bound
   

fian exact double oracle algorithm zero sum efgs imperfect information

value ui  h   due zero sum assumption  value represents upper bound
value opponent i  setting value way ensures two things      player
likely use sequences leading node h optimal strategies restricted game  since
modified utility value upper bound actual value       player adds new
sequences using best response algorithms prolong sequence seqi  h  leading node h
sequences would yield better expected value u i   later show
counterexample setting value otherwise cause algorithm converge
incorrect solution  calculate lower bound setting utility value
corresponds outcome original game player continues playing
br default strategy 
default strategy idef opponent plays best response
valid lower bound since consider single strategy player acting
node h  correspond default strategy  considering strategies could allow
player improve value continuing node h  leaf nodes
h z   z set u i  h  ui  h  
      solving restricted game
restricted game defined section valid zero sum extensive form game
solved using sequence form linear programming described section   
algorithm computes ne restricted game solving pair linear programs using
restricted sets     h     z         modified utility function u   
strategy restricted game translated original game using
pure default strategy extend restricted strategy defined  formally 
ri  mixed strategy represented realization plan player restricted
game  define extended strategy r i strategy identical strategy
restricted game sequences included restricted game  correspond
default strategy idef sequence included restricted game 
 
ri   i  
 i
r i  i  
    
ri   i    idef  i   i   
   i   i    arg maxi    i   i   vi  i    
realization plan sequence allowed restricted game  i e  
   i  
equal realization probability longest prefix sequence allowed
restricted game  denoted i     setting remaining part sequence  i e     i   
correspond default strategy player i  computation expressed
multiplication two probabilities  overload notation use idef  i   i   
  remaining part sequence corresponds default strategy player i 
  otherwise 
iteration double oracle algorithm one sequence form lp solved
player compute pair ne strategies restricted game  denote strategies
   r   r   extended original unrestricted game using
 ri   ri

default strategies 
      expanding restricted game
restricted game expanded adding new sequences set   updating
remaining sets according definition  adding new sequences  algorithm
   

fibosansky  kiekintveld  lisy    pechoucek

calculates stores temporary utility values leaves z     z used
sequence form lp 
updating restricted game  linear programs modified correspond new restricted game  newly added information sets sequences 
new variables created linear programs constraints corresponding
information sets sequences created  equations       moreover  constraints already existing linear program need updated  sequence
added set  i immediate prefix sequence  i e   sequence i  v
 i           i    already part restricted game  need update
constraint information sets ii i    seqi  ii   ensure consistency
strategies  equation     constraint corresponding sequence i   equation    
addition  algorithm updates equations     assigned sequences opponent
g i           finally  algorithm updates constraints previously used
utilities temporary leaf nodes longer leaf nodes restricted game
adding new sequences 
new sequences player found using best response sequence  brs  algorithms described section      perspective sequence form double oracle
algorithm  brs algorithm calculates pure best response player fixed
strategy opponent original unrestricted game  pure best response specifies
action play information set currently reachable given opponents
extended strategy ri   best response formally defined pure realization
plan ribr assigns integer values     sequences  realization plan
necessarily pure strategy original unrestricted game may
action specified every information set  specifically  action specified
information sets reachable     due choices player i      due
zero probability realization plan opponent ri   omitting actions
affect value best response information sets never reached 
hence  ribr holds r i ui  ribr   ri   ui  r i   ri   exists pure best
response strategy ibr ui  ribr   ri     ui  ibr   ri    sequences
used best response pure realization plan probability   returned brs
algorithm call best response sequences 
 i   ribr  i       

    

      example run algorithm
demonstrate sequence form double oracle algorithm example game depicted figure  a  example  two players  circle box  circle aims
maximize utility value leafs  box aims minimize utility value  assume
choosing leftmost action information set default strategy
players game 
algorithm starts empty set allowed sequences restricted game
    hence  algorithm sets current pair  ri   ri   strategies equivalent
def    next  algorithm adds new sequences correspond best response
 idef  
default strategy opponent  example best response sequences
circle player    a  ad      y  box player  sequences added
   

fian exact double oracle algorithm zero sum efgs imperfect information

 a  step  

 b  step  

 d  step  

 c  step  

 e  step  

figure    example steps sequence form double oracle algorithm two player
zero sum game  circle player aims maximize utility value  box aims minimize
utility value  bold edges correspond sequences actions added restricted
game  dashed boxes indicate information sets 
set allowed sequences     next  set sequences restricted game  
updated  maximal compatible set sequences set   cannot contain sequence
ad compatible sequence box player  i e   x case  allowed
restricted game yet sequence ad cannot fully executed  moreover  adding
sequences y  restricted game contain node ay actions e f
defined original unrestricted game  however  continuation
current restricted game yet  hence  node temporary leaf  belongs z     z 
algorithm needs define new value modified utility function u  node 
value u   ay  equal   corresponds outcome game circle
player continues playing default strategy box player plays best response 
complete first step algorithm summarize nodes information sets
included restricted game  h   contains   nodes  the root  node playing
action node ay   two information sets  the information set node ay
added restricted game  node leaf restricted game  
playing sequences probability   nash equilibrium restricted
game  situation depicted figure  b  sequences   shown bold edges 
algorithm proceeds complete list steps algorithm summarized table    second iteration  new sequences b bh added
restricted game  box player add new sequences iteration
best response extended equilibrium strategy circle player i e   playing
sequences a  ac  ae probability    ne updated restricted game changes
playing sequences b  bh sequence y  probability    third iteration
situation changes box player adds sequence x  new sequences
   

fibosansky  kiekintveld  lisy    pechoucek

added circle player  adding sequence x  sequence ad becomes part
set   fully executed due adding compatible sequence x  ne
restricted game fully mixed  sequences starting b played
ratio        x ratio        fourth iteration  algorithm adds
sequence af restricted game  the best response circle player   removes
assigned value u   ay  since node longer belongs set z     algorithm stops
four iterations  sequences added restricted game  solution
  translated solution original unrestricted
restricted game  ri   ri


game   ri   ri   nash equilibrium original game 
iteration
  
  
  
  

br
r
  a  ad
  b  bh
  b  bh
  a  af

br
r
 
 
  x
 

 
 
  a  b  bh
  a  ad  b  bh
  a  ad  af  b  bh

 
 
 
  y  x
  y  x

table    steps sequence form double oracle algorithm applied example 
consider small modification example game utility value
  leaf following action f  i e   node ayf    case  algorithm
need add sequence af  nor ae  restricted game improve
value restricted game  note modified example game shows
algorithm needs set utility values nodes z     z  algorithm simply uses
unmodified utility function  node ay treated zero utility
value  value overestimates outcome actual continuation following node
original game circle player since sequences ae af never
part best response circle player  algorithm converge incorrect
solution 
    best response sequence algorithm
purpose best response sequence  brs  algorithm generate new sequences
added restricted game next iteration  prove
best response better expected value uses sequences currently allowed
restricted game  throughout section use term searching player represent
player algorithm computes best response sequences  refer
player i 
brs algorithm calculates expected value pure best response opponents strategy ri   algorithm returns set best response sequences well
expected value strategy extended strategy opponent 
algorithm based depth first search traverses original unrestricted
game tree  behavior opponent fixed strategy given extended
realization plan ri   save computation time  best response algorithms use branch
bound search best response sequences  algorithm uses bound
expected value inner node  denoted   bound represents minimal
utility value node currently evaluated needs gain order part
   

fian exact double oracle algorithm zero sum efgs imperfect information

require    searching player  h   current node  iik   current information set  r i   opponents
strategy  min maxutility   bounds utility values    lower bound node h
   w r  seqi  h   c h 
   h z
  
return ui  h  w
   else h z     z
  
return u i  h  w
   end

   sort a h  based probability wa r  i seqi  ha  c ha 
   v h  
   a h  
wa    

   
  v h    w wa   maxutility
   
  wa maxutility
   
v   brsi  ha     
   
v    
   
return
   
end
   
vh vh   v 
   
w w wa
   
else
   
return
   
end
    end
    return v h

figure    brsi nodes players 

best response sequence  using bound search  algorithm able
prune branches certainly part best response sequence  bound
set minutility root node 
distinguish   cases search algorithm  either algorithm evaluating
information set  or specifically node h  assigned searching player i 
node assigned one players  either opponent  player i 
chance node   pseudocode two cases depicted figures     
      nodes opponent
first describe case used algorithm evaluates node h assigned either
opponent searching player nature  see figure     main idea
calculate expected utility node according  fixed  strategy player 
strategy known either given extended realization plan ri  
stochastic environment  c   throughout algorithm  variable w represents
probability node based realization probability opponent stochastic
environment  line     value iteratively decreased values wa represent realization probabilities currently evaluated action a h   finally  vh expected
utility value node 
algorithm evaluates actions descending order according probability
played  based r i c  lines       first  calculate new lower bound
   

fibosansky  kiekintveld  lisy    pechoucek

  successor ha  line      new lower bound minimal value must
returned recursive call brsi  ha  optimistic assumption
remaining actions yield maximum possible utility  lower bound
exceed maximum possible utility game  algorithm executed recursively
successors  line      note algorithm evaluate branches zero
realization probability  line    
  possibilities pruning part search algorithm  first
pruning possible currently evaluated node leaf restricted game 
node inner node original node  i e   h z     z  line     algorithm
directly use value modified utility function u  case  since calculated
best response searching player default strategy opponent
applied successors node h since h z     secondly  cut off occurs
new lower bound successor larger maximum possible utility
game  since value never obtained successor  line      finally  cut off
occurs cut off one successors  line     
      nodes searching player
nodes assigned searching player  algorithm evaluates every action
state belongs current information set  algorithm traverses states
descending order according probability occurrence given strategies
opponent nature  line     similar previous case  iteration algorithm
calculates new lower bound successor node  line      new lower bound  
minimal value must returned recursive call brsi  h  a  order
action selected best action information set optimistic
assumption action yields maximum possible utility value applying
remaining states information set  algorithm performs recursive call
 line     action still could best information set  i e   lower
bound exceed maximal possible utility game   note cut off
occurs one successors  currently evaluated action longer best
action information set  hence  va set action evaluated
remaining nodes  algorithm determines action selected
best one information set  evaluates action remaining nodes
information set  finally  algorithm stores values best action
nodes information set  line      reused information set
visited  i e   algorithm reaches different node h  information set
ii   line    
cut off occurs part search algorithm maximal possible value vah
smaller lower bound evaluating node h  means regardless
action selected best action information set  lower bound
node h reached  hence  cut off occurs  line      cut off occurs
information set  information set cannot reached sequences
searching player leading information set cannot part best response 
due propagating cut off least one previous information set searching
player  otherwise tight lower bound set  the bound first set
   

fian exact double oracle algorithm zero sum efgs imperfect information

require    searching player  h   current node  iik   current information set  ri   opponents
strategy  min maxutility   bounds utility values  lower bound node h
   h z
  
return ui  h  r i  seqi  h   c h 
   end
   v h already calculated
  
return v h
   end
   h    h    h  ii  
 
   sort h
value ri  seqi  h     c h   
p descending according
 
   w h  h   r  seqi  h    c h   
    va   a h   maxaction
    h  h  
   
wh  r i  seqi  h     c h   
   
a h   
   
maxaction empty
   
  wh  minutility
   
else
   
   vmaxaction   w minutility   va    w wh    maxutility 
   
end
   
  wh  maxutility
 
   
vah brsi  h  a     
 
   
va va   vah
   
end
   
end
   
maxaction arg maxaa h    va
   
w w wh 

   
h evaluated maxaa h  vah  
   
return
   
end
    end
 
h 
v h h  h  
    store vmaxaction
h
    return vmaxaction

figure    brsi nodes searching player 

information sets searching player   therefore  exists least one action
searching player never evaluated  after cut off  value va
action set   cannot selected best action information set  since
assume perfect recall  nodes information set ii share sequence actions
seqi  ii    hence  node h  ii reached again 
    main loop alternatives
introduce several alternative formulations main loop sequence form
double oracle algorithm  general approach double oracle algorithm solve
restricted game find equilibrium strategy player  compute best responses
original game players  continue next iteration  however 
sequence form lp formulated double oracle scheme way
   

fibosansky  kiekintveld  lisy    pechoucek

iteration algorithm solve restricted game perspective single
player i  words  formulate single lp described section     computes
optimal strategy opponent restricted game  player i   compute
best response player strategy  means iteration
select specific player i  compute best response iteration  call
selection process player selection policy 
several alternatives player selection policy act domainindependent heuristics double oracle algorithm  consider three possible policies 
    standard double oracle player selection policy selecting players iteration      alternating policy  algorithm selects one player switches
players regularly  player selected one iteration  player selected
following iteration   finally     worse player selection policy selects player
currently worse bound solution quality  end iteration
algorithm selects player upper bound utility value away
current value restricted game  formally 


arg max fiviu b vilp
    


vilp last calculated value restricted game player i  intuition
behind choice either bound precise missing sequences
player restricted game need added  upper bound overestimated  either case  best response sequence algorithm run player
next iteration  either add new sequences tighten bound  case tie 
alternating policy applied order guarantee regular switching players 
experimentally compare policies show impact overall performance
sequence form double oracle algorithm  see section    

   theoretical results
section prove sequence form double oracle algorithm always converge nash equilibrium original unrestricted game  first  formally define
strategy computed best response sequence  brs  algorithm  prove lemmas
characteristics brs strategies  finally prove main convergence
result  note variations main loop described section     affect
correctness algorithm long player selection policy ensures improvement made brs algorithm one player brs algorithm run
opponent next iteration 
  realization plan player restricted game g    brs r    
lemma     let ri

returns sequences corresponding realization plan ribr unrestricted game 
ribr part pure best response strategy r i   value returned algorithm
value executing pair strategies ui  r i   ribr   
    searches game tree selects action maximizes value
proof brs ri
game player information sets ii assigned player reachable given
strategy opponent r i   opponents nodes  calculates expected value

   

fian exact double oracle algorithm zero sum efgs imperfect information

  defined value according pure action default
according ri
def
  defined  chance nodes  returns expected value
strategy ri
node sum values successor nodes weighted probabilities 
node h  successors maximal possible value node h
maximal possible value  when playing r i    selections nodes
belong achieves maximal value  hence  form best response strategy
r i  
     denote value returned brs algorithm 
brevity use v brs ri
equal ui  r i   ribr   
  realization plan player restricted game g  let
lemma     let ri

vi value original unrestricted game g player i 
 
v brs ri
   vi  

    

     value best response r  
proof lemma     showed v brs ri

       v
valid strategy original unrestricted game g  v brs ri

vi cannot value game since player strategy r i achieves better
utility  contradiction 
  realization plan player returned lp
lemma     let ri
 
restricted game g let vilp value restricted game returned lp 
 
v brs ri
   vilp  

    

 
proof realization plan ri
part nash equilibrium strategy zero sum
lp
game guarantees value vi
g    best response computation original
unrestricted game g selects actions restricted game g    creates best
response game g  well obtaining value vilp   best response selects action
allowed restricted game g    two cases 
case     best response strategy uses action temporary leaf h z     z 
player makes decision leaf  otherwise value temporary leaf
would directly returned brs  value temporary leaf underestimated player restricted game modified utility function u 
def  
over estimated brs computation best response default strategy
value best response increase including action 
case     best response strategy uses action allowed g  internal node
restricted game h     z     occur nodes assigned player i 
actions player going g  probability zero r i   brs takes action
maximum value nodes assigned player i  reason selecting action
leading outside g  greater equal value best action g   
       v lp
lemma     assumptions previous lemma  v brs ri

returns sequences added restricted game g  next iteration 

   

fibosansky  kiekintveld  lisy    pechoucek

proof based proof previous lemma  brs player improve
value lp  vilp   selecting action present g 
performed node h included g   in makes decision   let  i    
pair sequences leading h  construction restricted game
next iteration  sequence sequence ensures executed full
part new restricted game 
note  lemmas         would hold utility values u  temporary
leaves  h z     z  set arbitrarily  algorithm sets values temporary leaf h
player p h  continues playing default strategy opponent  p h  
playing best response  utility values temporary leaves set arbitrarily
used brs algorithms speed up calculation proposed  see algorithm
figure    line     lemma     need hold cases value
node h strictly overestimates optimal expected value player p h   case 
best response value opponent may lower optimal outcome 


v brs rp h      vp h 
    
hand  brs algorithm use temporary values u 
node  lemma     violated best response value strictly higher
player p h  even though new sequences added restricted game 
theorem     sequence form double oracle algorithm extensive form games described previous section terminates
 
v brs ri
     v brs ri       vilp   vi  

    

always happens finite number iterations  because game finite  
strategies  r i   r i   nash equilibrium original unrestricted game 
proof first show algorithm continues equalities      hold 
        v brs r      lemma     lemma     know
v brs ri

      v lp   restricted game following itersome player holds brs ri

ation larger least one action algorithm continues  worst case 
restricted game equals complete game g    g  cannot extended further 
case brs cannot find better response vi algorithm stops due
lemma     
condition theorem holds algorithm found ne complete
br   brs r     best response r  
game  lemma     know ri


complete game  however  value best response strategy zero sum
game value game  strategy r i optimal part nash
equilibrium game 

   experiments
present experimental evaluation performance sequence form
double oracle algorithm efgs  compare algorithm two state of the art
   

fian exact double oracle algorithm zero sum efgs imperfect information

baselines  full sequence form lp  referred fulllp on   counterfactual regret minimization  cfr   first baseline standard exact method
solving sequence form efg  cfr one leading approximate algorithms applied efg  experimental results demonstrate advantages double oracle
algorithm three different classes realistic efgs  test impact different
variants main loop algorithm described section     
compare three variants sequence form double oracle algorithm      do b
variant best responses calculated players iteration 
    do sa calculates best response single player iteration according
simple alternating policy      do swp variant best response
calculated single player according worse player selection policy 
variants double oracle algorithm use default strategy first
action applicable state played default 
since standardized collection zero sum extensive form games benchmark purposes  use several specific games evaluate double oracle algorithm
identify strengths weaknesses algorithm  games selected
evaluate performance different conditions  games differ maximal
utility players gain  causes imperfect information  structure
information sets  one key characteristics affects performance
double oracle algorithm relative size support nash equilibria  i e   number sequences used ne non zero probability   exist ne
small support  algorithm must necessarily add large fraction sequences
restricted game find solution  mitigating advantages double oracle approach 
present results two types games double oracle significantly outperforms fulllp instances  search game motivated border patrol phantom
tic tac toe  present results simplified version poker doubleoracle algorithm always improve computation time  however  fulllp
limited scalability due larger memory requirements cannot find solutions
larger variants poker  double oracle algorithm able solve instances 
principal interest developing new generic methods solving extensive form
games  therefore  implemented algorithm generic framework modeling arbitrary extensive form games   algorithms use domain specific knowledge
implementation  rely specific ordering actions  drawbacks
generic implementation higher memory requirements additional overhead
algorithms  domain specific implementation could improve performance
eliminating auxiliary data structures  run experiments using
single thread intel i  cpu running     ghz  algorithms given
maximum    gb memory java heap space  used ibm cplex      solving
linear programs  parameter settings use single thread barrier solution
algorithm 
addition runtimes  analyze speed convergence double oracle algorithms compare one state of the art approximative algorithms  counterfactual regret minimization  cfr   implemented cfr domain independent way
   source code available home pages authors 

   

fibosansky  kiekintveld  lisy    pechoucek

based pseudocode work lanctot        p       principle  sufficient
cfr maintain set information sets apply no regret learning rule
information set  however  maintaining traversing set effectively
domain independent manner could affected implementation generic extensiveform games data structures  i e   generating applicable actions states game 
applying actions  etc    therefore use implementation cfr traverses
complete game tree held memory maintain fairness comparison 
guarantee maximal possible speed convergence cfr algorithm  time
necessary build game tree included computation time cfr 
    test domains
search games first test belongs class search  or pursuit evasion  games 
often used experimental evaluation double oracle algorithms  mcmahan et al        
halvorson et al          search game two players  patroller  or defender 
evader  or attacker   game played directed graph  see figure    
evader aims cross safely starting node  e  destination node  d  
defender controls two units move intermediate nodes  the shaded areas 
trying capture evader occupying node evader  turn
players move units simultaneously current node adjacent node 
units stay location  exception evader cannot stay
two leftmost nodes  pre determined number turns made without either player
winning  game draw  example win tie loss game utility
values set           
players unaware location actions player one exception
evader leaves tracks visited nodes discovered defender visits
nodes later  game includes option evader avoid leaving tracks
using special move  a slow move  requires two turns simulate evader covering
tracks 
figure   shows examples graphs used experiments  patrolling units
move shaded areas  p  p    start node shaded
areas  even though graph small  concurrent movement units implies large
branching factor  up    one turn  thus large game trees  up      nodes  
experiments used three different graphs  varied maximum number turns
game  from       altered ability attacker perform slow
moves  labeled sa slow moves allowed  sd otherwise  
phantom tic tac toe second game blind variant well known game
tic tac toe  e g   used lanctot et al          game played     board 
two players  cross circle  attempt place   identical marks horizontal  vertical 
diagonal row win game  blind variant  players unable observe
opponents moves player knows opponent made move
turn  moreover  player tries place mark square already occupied
opponents mark  player learns information place mark
square  again  utility values game set           
   

fian exact double oracle algorithm zero sum efgs imperfect information

figure    three variants graph used experiments search game  refer
g   left   g   middle   g   right  
uncertainty phantom tic tac toe makes game large       nodes  
addition  since one player try several squares move successful  players
necessarily alternate making moves  rule makes structure
information sets rather complicated since opponent never learns many attempts
first player actually performed  single information set contain nodes different
depths game tree 
poker games poker frequently studied literature example large
extensive form game imperfect information  include experiments simplified
two player poker game inspired leduc holdem 
version poker  player starts amount chips
players required put number chips pot  called ante   next
step  nature player deals single card player  the opponent unaware
card  betting round begins  player either fold  the opponent wins pot  
check  let opponent make next move   bet  being first add amount
chips pot   call  add amount chips equal last bet opponent
pot   raise  match increase bet opponent   raise made
players  betting round ends  nature player deals one card
table  second betting round rules begins  second betting
round ends  outcome game determined player wins if      private card
matches table card opponents card match      none players
cards matches table card private card higher private card
opponent      opponent folds  utility value amount chips player
lost  player wins  game draw pot split 
experiments alter number types cards  from     
  types cards leduc   number cards type  from      set   leduc  
maximum length sequence raises betting round  ranging      set  
leduc   number different sizes bets  i e   amount chips added pot 
bet raise actions  ranging      set   leduc  
    results
search games results search game scenarios show sequence form
double oracle algorithm particularly successful applied games nes
small support exist  figure   shows comparison running times fulllp
variants double oracle algorithm  note logarithmic y scale   variants
   

fibosansky  kiekintveld  lisy    pechoucek

   

   

   

   

fulllp
do b
do sa
do swp
time  s   log scale 

time  s   log scale 

   

g  sd

g  sd

g  sd

g  sa

g  sa

   

   

   

g  sa

search game scenarios   depth  

fulllp
do b
do sa
do swp

g  sd

g  sd

g  sd

g  sa

g  sa

g  sa

search game scenarios   depth  

figure    comparison running times   different graphs either slow moves
allowed  sa  disallowed  sd   depth set    left subfigure     right subfigure  
missing values fulllp algorithm indicate algorithm runs memory 

double oracle algorithm several orders magnitude faster fulllp 
apparent fully connected graph  g   generates largest game tree 
slow moves allowed depth set    takes almost     seconds fulllp
solve instance game variants double oracle algorithms solve
game less   seconds  moreover  depth increased    fulllp
unable solve game due memory constraints  fastest variant do swp
solved game less   seconds  similar results obtained graphs 
graph g  induced game difficult double oracle algorithm 
depth set    takes almost   minutes fulllp solve instance 
fastest variant do swp solved game    seconds  reason even though
game tree largest  complex structure information sets 
due limited compatibility among sequences players  patrolling
unit p  observes tracks top row node  second patrolling unit p  capture
evader top row node  middle row node 
comparing different variants sequence form double oracle algorithm
show consistent results  variant consistently better game since
double oracle variants typically able compute nash equilibrium quickly 
however  do swp often fastest settings difference quite significant 
speed up variant offers apparent g  graph  average
instances search game  do sa uses        computation time do b 
do swp uses        
table   shows breakdown cumulative computation time spent different components double oracle algorithm  solving restricted game  lp   calculating best
responses  br   creating valid restricted game selecting new sequences add
 validity   results show due size game  computation
best response sequences takes majority time  typically around     larger
instances   creating restricted game solving takes small fraction
total time  noticeable size final restricted game small
   

fian exact double oracle algorithm zero sum efgs imperfect information

do b

do sa

do swp

cfr

bounds interval size      log scale 

  
 
   
    
     
      
 e   
 

  

   
time  s 

   

   

figure    convergence variants double oracle algorithm cfr search
game domain  y axis displays current approximation error 
algorithm
fulllp
do b
do sa
do swp

overall  s 
      
     
     
     

lp  s 

    
   
    

br  s 

     
     
     

validity  s 

     
    
    

iterations

   
   
   

    

              

            
            
            

    

              

           
           
           

table    cumulative running times different components double oracle algorithm 
iterations  size restricted game terms number sequences compared
size complete game  results shown scenario g   depth    allowed
slow moves 
compared original game  since number sequences second player  the
defender  less     there         sequences defender  
finally  analyze convergence rate variants double oracle algorithm 
results depicted figure    size interval given bounds
viu b vilb defines current error double oracle algorithm  viu b vilb   
convergence rate cfr algorithm depicted  error cfr calculated
way  sum best response values current mean strategies
cfr algorithm  see variants double oracle algorithm perform
similarly error drops quickly   iterations later version
algorithm quickly converges exact solution  results show game
double oracle algorithm quickly find correct sequences actions compute
exact solution  spite size game  comparison  cfr algorithm
quickly learn correct strategies information sets  convergence
long tail      seconds  error cfr equal        dropping
slowly           hour   error cfr quite significant considering value
game case          
phantom tic tac toe results phantom tic tac toe confirm game
suitable sequence form double oracle algorithm  due size game 
baseline algorithms  the fulllp cfr  ran memory able
   

fibosansky  kiekintveld  lisy    pechoucek

do sa

do swp
do b
do sa
do swp

 
time  s   log scale 

bounds interval size      log scale 

do b

   
    
     

   

      
 e   
 

    

     
     
time  s 

     

     

   

random

domain dependent

different action ordering phantom tic tac toe

figure     left  comparison convergence rate double oracle variants phantom tic tac toe   right  comparison performance double oracle variants
phantom tic tac toe domain specific move ordering default strategy used 
algorithm
fulllp
do b
do sa
do swp

overall  s 
n a
      
      
      

lp  s 

     
     
     

br  s 

      
      
      

validity  s 

   
   
   

iterations

   
   
   

    

              

             
             
             

    

              

              
             
             

table    cumulative running times different components double oracle algorithm
game phantom tic tac toe 
solve game  therefore  compare times different variants
double oracle algorithm  figure    left subfigure  shows overall performance three
variants double oracle algorithm form convergence graph  see
performance two variants similar  performance do sa do swp
almost identical  hand  results show do b converges significantly
slower 
time breakdown variants double oracle algorithm shown table   
similarly previous case  majority time        spent calculating
best responses  variants double oracle algorithm  do swp variant
fastest one  converged significantly fewer iterations compared do sa
variant  iterations twice expensive do b variant  
present results demonstrate potential combining sequenceform double oracle algorithm domain specific knowledge  every variant doubleoracle algorithm use move ordering based domain specific heuristics  move
ordering determines default strategy  recall algorithm uses first action
default strategy player   direction search best response
algorithms  replacing randomly generated move ordering heuristic one
chooses better actions first  results show significant improvement performance
variants  see figure    right subfigure   even though changes
rest algorithm  variant able solve game less   hours 
took   hours fastest do swp variant 
   

fian exact double oracle algorithm zero sum efgs imperfect information

   

fulllp
do b
do sa
do swp
   
time  s   log scale 

   
time  s 

   

fulllp
do b
do sa
do swp

   

   

   

  

   

 
r 

r 

r 

r 

increasing number allowed  raise actions 

b 

b 

b 

b 

increasing size possible bets

figure     comparison running times different variants simplified poker
game  left subfigure shows computation times increasing number raise
actions allowed  right subfigure shows computation times increasing number
different bet sizes raise bet actions 
poker games poker represents game double oracle algorithms perform well sequence form lp often faster smaller instances  one significant
difference compared previous games size ne support larger
 around    sequences larger instances   secondly  game trees poker games
relatively shallow imperfect information game due nature 
result  double oracle algorithms require larger number iterations add
sequences restricted game  up     sequences player added even
largest poker scenarios  order find exact solution  however  increasing
depth and or branching factor  size game grows exponentially fulllp
able solve largest instances due memory constraints 
figure    shows selected results simplified poker variants  results
left subfigure show computation times increasing depth game allowing
players re raise  players allowed re raise opponent certain number
times   remaining parameters fixed   types cards    cards type   
different betting sizes  size game grows exponentially  number possible
sequences increasing         player r  scenario  computation time
fulllp directly related size tree increases exponentially
increasing depth  note standard scale   hand  increase
less dramatic variants double oracle algorithm  do swp variant
fastest largest scenario fulllp solved instance     seconds 
took     seconds do swp  finally  fulllp able solve games
increase length r  due memory constraints  computation time
double oracle algorithms increases marginally 
right subfigure figure    shows increase computation time increasing number different bet sizes raise bet actions  remaining parameters
fixed   types cards    cards type    raise actions allowed  again 
game grows exponentially increasing branching factor  number sequences
increases         player b  scenario  computation time
   

fibosansky  kiekintveld  lisy    pechoucek

do b

do sa

do swp

cfr

do b

do swp

cfr

  
bounds interval size      log scale 

bounds interval size      log scale 

  

do sa

 
   
    
     
      
 e   

 
   
    
     
      
 e   

 

  

   

   

   
   
time  s 

   

   

   

 

   

   

   
   
time  s 

    

    

    

figure     comparison convergence variants double oracle algorithm
cfr two variants simplified poker   types cards    cards
type    raise actions allowed    different bet sizes left subfigure 
  raise actions allowed    different bet sizes right subfigure 
algorithm
fulllp
do b
do sa
do swp

overall  s 
      
      
      
      

lp  s 

      
      
      

br  s 

     
     
     

validity  s 

     
     
    

iterations

   
   
   

    

              

             
             
             

    

              

             
             
             

table    cumulative running times different components double oracle algorithm 
iterations  sizes restricted game terms number sequences compared
size complete game  results shown poker scenario   raise
actions allowed    different betting values    types cards    cards type 
algorithms increases exponentially well  note logarithmic scale   results show
even increasing branching factor  double oracle variants tend slower
solving fulllp  however  fulllp ran memory largest
b  setting  double oracle variants able find exact solution using less
memory 
comparing different variants double oracle algorithm using convergence
graph  see figure     decomposition computation times  see table    shows
do swp fastest variant selected scenario  and nearly poker
scenarios   decomposition overall time shows majority computation
time spent solving restricted game lp  up       decomposition shows
do swp typically faster due lower number iterations  addition 
final size restricted game typically smallest variant  average
instances poker games  do sa uses        computation time do b 
do swp uses       computation time 
convergence poker games slower compared search games similar size  note
logarithmic scale figure      comparing double oracle algorithm variants cfr
shows interesting result left subfigure  due size game  speed
cfr convergence nearly double oracle algorithms first
   

fian exact double oracle algorithm zero sum efgs imperfect information

iterations  however  double oracle algorithms continue converge roughly
rate able find exact solution  error cfr algorithm decreases
slowly  scenario depicted left subfigure  cfr algorithm converged
error         the value game case              seconds 
  hour  error dropped         scenarios shallow game trees
larger branching factor  convergence cfr faster beginning compared
double oracle algorithms  right subfigure figure      however  main disadvantage
cfr long tail convergence still case error      seconds
still         the value game          
    discussion results
experimental results support several conclusions  results demonstrate
sequence form double oracle algorithm able compute exact solution much larger
games compared state of the art exact algorithm based sequence form linear
program  moreover  experimentally shown realistic games
small fraction sequences necessary find solution game  cases 
double oracle algorithms significantly speed computation time  results
indicate do swp variant typically fastest  cases  selecting
player currently worse bound performance  do swp version
add important sequences  prove better sequences adjust
upper bound value faster 
comparing speed convergence double oracle algorithms state ofthe art approximative algorithm cfr showed cfr quickly approximates solution
first iterations  however  convergence cfr long tail cfr
able find exact solution larger games reasonable time  another interesting
observation games convergence rate double oracle algorithms
cfr similar first iterations  double oracle algorithms continue
rate find exact solution  long tail convergence remains cfr 
despite fact implementation cfr advantage complete
game tree including states histories memory 
unfortunately  difficult characterize exact properties games
double oracle algorithms perform better terms computation time compared
algorithms  certainly  double oracle algorithm suitable games
equilibria large support due necessity large number iterations 
however  small support equilibrium sufficient condition  apparent
due two graphs shown poker experiments  either depth game tree
branching factor increased  even though game grows exponentially
size support decreases      cases  behavior double oracle
algorithms quite different  conjecture games longer sequences suit
double oracle algorithms better  since several actions form best response sequences
added single iteration  contrasts shallow game trees large
branching factors  iterations necessary add multiple actions  however 
deeper analysis identify exact properties games suitable open
question must analyzed normal form games first 
   

fibosansky  kiekintveld  lisy    pechoucek

   conclusion
present novel exact algorithm solving two player zero sum extensive form games
imperfect information  approach combines compact sequence form representation extensive form games iterative algorithmic framework double oracle
methods  integrates two successful approaches solving large scale games
yet brought together general class games algorithm addresses 
main idea algorithm restrict game allowing players play
restricted set sequences available sequences actions  iteratively expand
restricted game time using fast best response algorithms  although worst
case double oracle algorithm may need add possible sequences  experimental
results different domains prove double oracle algorithm find exact nash
equilibrium prior constructing full linear program complete game  therefore 
sequence form double oracle algorithm reduces main limitation sequence form
linear programmemory requirementsand able solve much larger games compared
state of the art methods  moreover  since algorithm able identify sequences
promising actions without domain specific knowledge  provide significant
runtime improvements 
proposed algorithm another crucial advantage compared current state
art  double oracle framework offers decomposition problem computing
nash equilibrium separate sub problems  including best response algorithms 
choice default strategy  algorithms constructing solving restricted
game  developed solutions sub problems domain independent manner  however  view algorithm general framework
specialized domain specific components take advantage structure specific
problems improve performance sub problems  lead substantial
improvements speed algorithm  number iterations  well reducing
final size restricted game  demonstrated potential domain specific
approach game phantom tic tac toe  another example fast best response
algorithms operate public tree  i e   compact representation games
publicly observable actions  see johanson  bowling  waugh    zinkevich        exploited games poker  finally  formal analysis identifies key properties
domain specific implementations need satisfy guarantee convergence
correct solution game 
algorithm opens large number directions future work  represents new
class methods solving extensive form games imperfect information operates
differently common approaches  e g   counterfactual regret minimization  
many possible alternatives improve performance algorithm remain
investigated  examples include sophisticated calculation utility values
temporary leaves  alternative strategies expanding restricted game  removing
unused sequences restricted game  broader analysis using sequenceform double oracle algorithm approximation technique performed  possibly
exploring alternative approximative best response algorithms based sampling  e g  
monte carlo  techniques 
   

fian exact double oracle algorithm zero sum efgs imperfect information

several theoretical questions could investigated  first  performance double oracle algorithm depends strongly number iterations
sequences need added  however  theoretical question regarding expected
number iterations thus speed convergence double oracle algorithm
explored even simpler game models  e g   games normal form  
analysis simpler models needed identify general properties games
double oracle methods tend faster identify optimal way expanding
restricted game 

acknowledgements
earlier versions paper published european conference artificial
intelligence  ecai   bosansky  kiekintveld  lisy    pechoucek        conference
autonomous agents multi agent systems  aamas   bosansky  kiekintveld  lisy 
cermak    pechoucek         major additions full version include     novel 
detailed description parts algorithm      introduction analysis
different policies player selection main loop double oracle algorithm 
    new experiments phantom tic tac toe domain together thorough
analysis experimental results domains  including analysis convergence
algorithm      experimental comparison cfr  finally     extended analysis
related work 
research supported czech science foundation  grant no  p            
u s  army research office  award no  w   nf            

references
barnhart  c   johnson  e  l   nemhauser  g  l   savelsbergh  m  w  p     vance  p  h 
        branch and price  column generation solving huge integer programs 
operations research             
bosansky  b   kiekintveld  c   lisy  v   cermak  j     pechoucek  m          doubleoracle algorithm computing exact nash equilibrium zero sum extensiveform games  proceedings international conference autonomous agents
multiagent systems  aamas   pp         
bosansky  b   kiekintveld  c   lisy  v     pechoucek  m          iterative algorithm
solving two player zero sum extensive form games imperfect information 
proceedings   th european conference artificial intelligence  ecai   pp 
       
cermak  j   bosansky  b     lisy  v          practical performance refinements
nash equilibria extensive form zero sum games  proceedings european
conference artificial intelligence  ecai   pp         
dantzig  g     wolfe  p          decomposition principle linear programs  operations
research            
ganzfried  s     sandholm  t          improving performance imperfect information
games large state action spaces solving endgames  computer
   

fibosansky  kiekintveld  lisy    pechoucek

poker imperfect information workshop national conference artificial
intelligence  aaai  
gibson  r   lanctot  m   burch  n   szafron  d     bowling  m          generalized sampling variance counterfactual regret minimization  proceedings   th
aaai conference artificial intelligence  pp           
halvorson  e   conitzer  v     parr  r          multi step multi sensor hider seeker games 
proceedings joint international conference artificial intelligence  ijcai  
pp         
hoda  s   gilpin  a   pena  j     sandholm  t          smoothing techniques computing
nash equilibria sequential games  mathematics operations research         
       
jain  m   conitzer  v     tambe  m          security scheduling real world networks 
proceedings international conference autonomous agents multiagent
systems  aamas   pp         
jain  m   korzhyk  d   vanek  o   conitzer  v   tambe  m     pechoucek  m          double
oracle algorithm zero sum security games graph  proceedings   th
international conference autonomous agents multiagent systems  aamas  
pp         
johanson  m   bowling  m   waugh  k     zinkevich  m          accelerating best response
calculation large extensive games  proceedings   nd international joint
conference artificial intelligence  ijcai   pp         
koller  d     megiddo  n          complexity two person zero sum games
extensive form  games economic behavior            
koller  d   megiddo  n     von stengel  b          efficient computation equilibria
extensive two person games  games economic behavior                 
koller  d     megiddo  n          finding mixed strategies small supports extensive form games  international journal game theory           
kreps  d  m     wilson  r          sequential equilibria  econometrica                
lanctot  m          monte carlo sampling regret minimization equilibrium computation decision making large extensive form games  ph d  thesis  university alberta 
lanctot  m   gibson  r   burch  n   zinkevich  m     bowling  m          no regret
learning extensive form games imperfect recall  proceedings   th
international conference machine learning  icml        pp      
lanctot  m   waugh  k   zinkevich  m     bowling  m          monte carlo sampling
regret minimization extensive games  advances neural information
processing systems  nips   pp           
lee  c  s   wang  m  h   chaslot  g   hoock  j  b   rimmel  a   teytaud  o   tsai  s  r  
hsu  s  c     hong  t  p          computational intelligence mogo revealed
taiwans computer go tournaments  ieee transactions computational intelligence ai games          
   

fian exact double oracle algorithm zero sum efgs imperfect information

letchford  j     vorobeychik  y          optimal interdiction attack plans  proceedings   th international conference automonous agents multiagent
systems  aamas   pp         
lisy  v   kovarik  v   lanctot  m     bosansky  b          convergence monte carlo tree
search simultaneous move games  advances neural information processing
systems  nips   vol      pp           
mcmahan  h  b          robust planning domains stochastic outcomes  adversaries  partial observability  ph d  thesis  carnegie mellon university 
mcmahan  h  b     gordon  g  j          fast bundle based anytime algorithm
poker convex games  journal machine learning research   proceedings
track            
mcmahan  h  b   gordon  g  j     blum  a          planning presence cost
functions controlled adversary  proceedings international conference
machine learning  pp         
miltersen  p  b     srensen  t  b          fast algorithms finding proper strategies
game trees  proceedings symposium discrete algorithms  soda   pp 
       
miltersen  p  b     srensen  t  b          computing quasi perfect equilibrium
two player game  economic theory                 
pita  j   jain  m   western  c   portway  c   tambe  m   ordonez  f   kraus  s     parachuri 
p          deployed armor protection  application game theoretic model
security los angeles international airport  proceedings  th international conference autonomous agents multiagent systems  aamas   pp 
       
ponsen  m  j  v   de jong  s     lanctot  m          computing approximate nash equilibria robust best responses using sampling  journal artificial intelligence
research  jair              
sandholm  t          state solving large incomplete information games 
application poker  ai magazine  special issue algorithmic game theory    
   
selten  r          reexamination perfectness concept equilibrium points
extensive games  international journal game theory          
selten  r          spieltheoretische behandlung eines oligopolmodells mit nachfragetrgheit
 an oligopoly model demand inertia   zeitschrift fur die gesamte staatswissenschaft              
shafiei  m   sturtevant  n     schaeffer  j          comparing uct versus cfr simultaneous games  ijcai workshop general game playing 
shieh  e   an  b   yang  r   tambe  m   baldwin  c   direnzo  j   meyer  g   baldwin  c  w  
maule  b  j     meyer  g  r          protect   deployed game theoretic system
protect ports united states  international conference autonomous
agents multiagent systems  aamas   pp       
   

fibosansky  kiekintveld  lisy    pechoucek

shoham  y     leyton brown  k          multiagent systems  algorithmic  gametheoretic  logical foundations  cambridge university press 
tambe  m          security game theory  algorithms  deployed systems  lessons
learned  cambridge university press 
tsai  j   rathi  s   kiekintveld  c   ordonez  f     tambe  m          iris   tool
strategic security allocation transportation networks categories subject
descriptors  proceedings  th international conference autonomous agents
multiagent systems  aamas   pp       
van damme  e          relation perfect equilibria extensive form games
proper equilibria normal form games  game theory          
van damme  e          stability perfection nash equilibria  springer verlag 
von stengel  b          efficient computation behavior strategies  games economic
behavior             
wilson  r          computing equilibria two person games extensive form 
management science                 
zinkevich  m   johanson  m   bowling  m     piccione  c          regret minimization
games incomplete information  advances neural information processing
systems  nips                
zinkevich  m   bowling  m     burch  n          new algorithm generating equilibria
massive zero sum games  proceedings national conference artificial
intelligence  aaai   pp         

   


