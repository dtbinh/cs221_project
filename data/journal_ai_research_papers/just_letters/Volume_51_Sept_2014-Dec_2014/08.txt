journal of artificial intelligence research                  

submitted        published      

the complexity of answering conjunctive and navigational
queries over owl   el knowledge bases
giorgio stefanoni
boris motik

giorgio stefanoni cs ox ac uk
boris motik cs ox ac uk

department of computer science  university of oxford
parks road  oxford ox   qd  united kingdom

markus krotzsch
sebastian rudolph

markus kroetzsch tu dresden de
sebastian rudolph tu dresden de

faculty of computer science  tu dresden
nothnitzer strae           dresden  germany

abstract
owl   el is a popular ontology language that supports role inclusionsaxioms of the
form s     sn v s that capture compositional properties of roles  role inclusions closely
correspond to context free grammars  which was used to show that answering conjunctive
queries  cqs  over owl   el knowledge bases with unrestricted role inclusions is undecidable  however  owl   el inherits from owl   dl the syntactic regularity restriction on
role inclusions  which ensures that role chains implying a particular role can be described
using a finite automaton  fa   this is sufficient to ensure decidability of cq answering 
however  the fas can be worst case exponential in size so the known approaches do not
provide a tight upper complexity bound 
in this paper  we solve this open problem and show that answering cqs over owl
  el knowledge bases is pspace complete in combined complexity  i e   the complexity
measured in the total size of the input   to this end  we use a novel encoding of regular role
inclusions using bounded stack pushdown automatathat is  fas extended with a stack of
bounded size  apart from theoretical interest  our encoding can be used in practical tableau
algorithms to avoid the exponential blowup due to role inclusions  in addition  we sharpen
the lower complexity bound and show that the problem is pspace hard even if we consider
only role inclusions as part of the input  i e   the query and all other parts of the knowledge
base are fixed   finally  we turn our attention to navigational queries over owl   el
knowledge bases  and we show that answering positive  converse free conjunctive graph
xpath queries is pspace complete as well  this is interesting since allowing the converse
operator in queries is known to make the problem exptime hard  thus  in this paper we
present several important contributions to the landscape of the complexity of answering
expressive queries over description logic knowledge bases 

   introduction
description logics  dls   baader  calvanese  mcguinness  nardi    patel schneider       
are a family of knowledge representation formalisms that logically underpin the web ontology language owl    cuenca grau  horrocks  motik  parsia  patel schneider    sattler 
       dl knowledge bases describe a domain in terms of concepts  i e   unary predicates  
roles  i e   binary predicates   and individuals  i e   constants   and they describe the relationships between concepts  roles  and individuals using logical axioms  dls and owl

c
    
ai access foundation  all rights reserved 

fistefanoni  motik  krotzsch    rudolph

  have been steadily gaining in popularity because they provide the developers of modern
information systems with a flexible graph like data model that is natural in countless application areas  such as the semantic web  gutierrez  hurtado  mendelzon    perez        
social network analysis  fan         and network traffic analysis  barrett  jacob    marathe 
       answering queries over dl owl knowledge bases is the core service in applications
as diverse as monitoring financial products within the italian ministry of economy and
finance  de giacomo et al          accessing real time diagnostic data of turbines  giese
et al          and integrating configuration data of air traffic control systems  calvanese
et al          due to the practical importance of query answering  theoretical investigation
of the expressivity and computational complexity of query languages has been high up on
the research agenda of the knowledge representation community in the past decade 
conjunctive queries  cqs   chandra   merlin        are the basic class of queries in
relational databases  querying dl knowledge bases using cqs has been studied in a diverse range of settings  calvanese  de giacomo  lembo  lenzerini    rosati        perezurbina  motik    horrocks        rudolph   glimm        kontchakov  lutz  toman 
wolter    zakharyaschev        ortiz  rudolph    simkus        gottlob   schwentick 
      venetis  stoilos    stamou         however  conjunctive queries are first order definable and thus cannot express certain important properties such as graph reachability 
regular path queries  rpqs   cruz  mendelzon    wood        barcelo        are an alternative query language capable of describing connections between graph vertices using
regular expressions  allowing users to navigate inside a graph  for example  the rpq
 ispartof   haslocation  retrieves all pairs of vertices connected via zero or more ispartof
edges followed by one haslocation edge  furthermore   rpqs extend rpqs with the converse operator  i e   backward navigation   calvanese  vardi  de giacomo    lenzerini 
       nested regular expressions allow for existential quantification over paths  perez 
arenas    gutierrez         and c   rpqs extend both    rpqs and cqs to conjunctions of    rpqs  calvanese  de giacomo  lenzerini    vardi        bienvenu  ortiz   
simkus         finally  inspired by the xpath query language for xml  graph xpath queries
 gxqs  have been recently proposed as a language for querying graph databases  libkin 
martens    vrgoc        and dl knowledge bases  kostylev  reutter    vrgoc        bienvenu  calvanese  ortiz    simkus         gxqs extend  rpqs with negation on regular
expressions  and checking properties of vertices using boolean combinations of node tests
that is  concepts or existential quantifications over paths  for example  the graph xpath
query  ispartof   test cell  hhasspecialityi   haslocation  refines the aforementioned rpq
by requiring that the node between the ispartof edges and the haslocation edge is an instance of the cell concept and does not have an outgoing hasspeciality edge  graph xpath
queries can be straightforwardly extended to conjunctive graph xpath queries  cgxqs   a
query in any of these languages is boolean if it has no answer variables  hence  an answer
to such a query is a boolean value 
    problem setting
although computing answers to a query over a dl knowledge base is a function problem  it
is common in the literature to consider the complexity of the associated decision problem
that is  of checking whether a boolean query is entailed by the knowledge base  in this article

   

fithe complexity of answering cqs and gxqs over owl   el kbs

we follow this well established practice and analyse the computational properties of several
query languages over dl knowledge bases  we follow vardi        and measure the input
size in two ways  combined complexity measures the complexity in terms of the combined
size of the query and the knowledge base  while data complexity measures the complexity
in terms of the size of the data  i e   the query and all other parts of the knowledge bases
are considered to be fixed  
the computational properties of query answering over dl knowledge bases depend on
the expressivity of both the constructs used in the knowledge base and the query language
used  in particular  conjunctive query answering over expressive description logics is at
least exponential in combined complexity  glimm  lutz  horrocks    sattler        lutz 
      and intractable in data complexity  calvanese  de giacomo  lembo  lenzerini   
rosati        ortiz  calvanese    eiter         the problem becomes tractable in data
complexity for the rl  grosof  horrocks  volz    decker        ter horst        and the
ql  calvanese et al         artale  calvanese  kontchakov    zakharyaschev        profiles
of owl    and several worst case optimal algorithms have been proposed that perform well
in practice  urbani  van harmelen  schlobach    bal        rodriguez muro   calvanese 
       in this paper  however  we focus on the owl   el profile of owl    which is based
on the el family of dls  baader  brandt    lutz         basic reasoning problems for
owl   el  such as checking concept subsumption and instance checking  can be decided
in polynomial time  baader et al         krotzsch         which makes this language very
interesting for practical applications  motivated by this observation  in this paper we present
several novel complexity results for answering queries over owl   el knowledge bases 
one of the important modelling constructs of owl   el are role inclusionsaxioms
of the form s     sn v s that express compositional properties of roles  for example  the
following inclusions state that role ispartof is transitive and that  if x is located in y and y
is part of z  then x is located in z 
ispartof  ispartof v ispartof

haslocation  ispartof v haslocation

prior to the introduction of the el family  role inclusions had already been identified as
a source of undecidability in expressive dls because they loosely correspond to context free
grammars  if each inclusion s     sn v s in a knowledge base is seen as a production rule
s  s     sn   then the knowledge base induces a context free language l s  for each role
s  using this correspondence  wessel        showed that checking satisfiability of alcr
knowledge bases with unrestricted role inclusions is undecidable  to regain decidability 
horrocks and sattler        proposed a syntactic regularity restriction on role inclusions
ensuring that each language l s  is regular and can thus be recognised using a finite
automaton  fa   kazakov        later showed that  in some cases  the size of this automaton
is necessarily exponential in the knowledge base size  the owl   dl profile of owl  
extends alcr and thus incorporates the regularity restriction into its definition 
even with unrestricted role inclusions  all standard reasoning problems for el can be
solved in polynomial time  baader et al          moreover  stefanoni  motik  and horrocks
       showed that answering cqs over owl   el knowledge bases without role inclusions
is np complete  however  using the correspondence between role inclusions and contextfree grammars  rosati        and krotzsch  rudolph  and hitzler        independently
proved that answering cqs over el knowledge bases with unrestricted role inclusions is
   

fistefanoni  motik  krotzsch    rudolph

undecidable  furthermore  krotzsch et al         also showed that checking concept subsumptions over el knowledge bases with inverse roles and unrestricted role inclusions is
undecidable 
owl   el inherits the regularity restriction from owl   dl  and so the undecidability proofs by rosati        and krotzsch et al         do not apply to owl   el  in
fact  krotzsch et al         showed that answering cqs over el knowledge bases extended
with regular role inclusions is pspace hard in combined complexity  and they proposed a
cq answering algorithm for a fragment of owl   el with regular role inclusions  this
algorithm  however  runs in pspace only if  for each role s  language l s  can be represented using an automaton of polynomial size  due to the mentioned result by kazakov
        this approach does not provide us with a matching pspace upper bound for the
problem  ortiz et al         proposed a different algorithm for answering cqs over owl  
el knowledge bases  with regular role inclusions and without any restriction on the usage
of other features   similarly to the algorithm by krotzsch et al          the algorithm by
ortiz et al         also encodes regular role inclusions using finite automata  hence  while
both of these algorithms run in time polynomial in the size of the data and thus settle the
question of data complexity  they do not settle the question of combined complexity 
there are comparatively few works on studying the complexity of  conjunctive  graph
xpath queries over dl knowledge bases  in particular  kostylev et al         observed that
gxqs are closely related to propositional dynamic logic with full negation  harel  tiuryn 
  kozen         which immediately shows that answering gxqs over dl knowledge bases
is undecidable even with respect to the empty knowledge base  several gxq fragments
were proposed as a possible solution to this problem  path positive gxqs disallow negation
over role expressions  and positive gxqs further prohibit negation over concepts as well 
kostylev et al         showed that answering path positive gxqs is intractable in data
complexity already for queries without the transitive closure operator and for knowledge
bases containing only instance assertions  recently  bienvenu et al         showed that
answering positive gxqs in a fragment of owl   el is tractable in data complexity  but
exptime complete in combined complexity 
    our contributions
in this paper  we present several novel complexity results on answering queries over owl  
el knowledge bases 
first  we present the first cq answering algorithm that can handle all of owl   el
 with regular role inclusions but without any restriction on the size of the fas  and that
runs in pspace  and thus we settle the open question of the combined complexity of
cq answering for owl   el  our result is based on a novel encoding of the languages
induced by regular role inclusions using pushdown automata  pdas that is  fas extended
with a stack  we show that  for each role s  we can construct in polynomial time a
pda that accepts language l s  and whose computations use a stack of size linear in the
number of role inclusions  bounded stack pdas  anselmo  giammarresi    varricchio 
      recognise precisely the class of regular languages and can be exponentially more
succinct than finite automata  geffert  mereghetti    palano         to obtain a cq
answering algorithm running in pspace  we extend the algorithm by krotzsch et al        

   

fithe complexity of answering cqs and gxqs over owl   el kbs

data
combined

elhodr

ptime

owl   el
ptime

horn shoiq
ptime

horn sroiq
ptime

 ortiz et al        

 theorem    

 ortiz et al        

 ortiz et al        

np

pspace

exptime

 exptime

 stefanoni et al        

 theorem    

 ortiz et al        

 ortiz et al        

table    the complexity landscape of cq answering  all are completeness results 
to handle the universal role  keys  self restrictions  and reflexive roles  thus covering all
features of the el profile apart from datatypes  and we adapt it so that it can handle
regular role inclusions encoded using pdas  apart from allowing us to obtain the complexity
results presented in this paper  the tableau algorithm by horrocks  kutz  and sattler       
used in popular reasoners such as pellet  sirin  parsia  cuenca grau  kalyanpur    katz 
      and fact    tsarkov   horrocks        can be straightforwardly modified to use
bounded stack pdas instead of fas  which could eliminate a potential source of inefficiency
in practice  finally  for brevity and simplicity we do not deal with datatypes in this paper 
however  the set of owl   el datatypes has been designed so as to enable datatype
reasoning using an external datatype checking procedure  baader  brandt    lutz       
cuenca grau et al         that can be easily incorporated into our algorithm 
second  we improve the pspace lower bound by krotzsch et al         by showing
that answering cqs in owl   el is pspace hard already if just the role inclusions are
considered as part of the input  i e   the conjunctive query  the tbox  and the abox are all
fixed   furthermore  we show that cqs can be answered in polynomial time if the query
and the role inclusions are fixed  which emphasises the observation that role inclusions are
the main source of the problems pspace hardness 
third  we show that positive  converse free cgxqsthat is  cgxqs that do not allow
for negation over paths  negation of concepts  and the converse operatorcan be answered
over owl   el knowledge bases using polynomial space  in particular  owl   el allows
for role inclusions  self restrictions  and reflexive roles  which allow us to polynomially reduce answering a cgxq to answering a cq over an extended knowledge base  we also
show that answering positive  converse free gxqs  i e   cgxqs with a single atom  can
be done in time polynomial in the input size  this result is interesting because bienvenu
et al         proved that answering positive gxqs over el knowledge bases is exptimecomplete  hence  adding the converse operator increases the complexity of gxqs  our
results thus show that answering gxqs and cgxqs is as difficult as instance checking and
answering conjunctive queries  respectively  which at least from a theoretical perspective
makes gxqs and cgxqs appealing as query languages for owl   el knowledge bases 
    summary of the complexity landscape
table   summarises the complexity landscape of answering cqs in various dls related to
owl   el  here  elhodr
 is the fragment of owl   el obtained by allowing only simple
role inclusions of the form t v s  and by disallowing the universal role  reflexive roles 
self restrictions  and datatypes  and the combined complexity result for this logic is due to
stefanoni et al          furthermore  horn shoiq extends elhodr
 with inverse roles
and horn qualified number restrictions  and horn sroiq extends horn shoiq with role
   

fistefanoni  motik  krotzsch    rudolph

data

positive
positive
converse free converse free
gxqs
cgxqs
ptime c
ptime c
 theorem    

combined

ptime c
 theorem    

positive
gxqs

path positive
gxqs

gxqs

ptime h

conp h

conp h

 theorem      bienvenu et al          kostylev et al          kostylev et al        

pspace c

exptime h

exptime h

undecidable

 theorem      bienvenu et al          bienvenu et al          kostylev et al        

table    the complexity of answering navigational queries over owl   el knowledge bases
 c means complete  and h means hard 

inclusions  the results for these logics are due to ortiz et al          cq answering is ptimecomplete in data complexity in all cases  which is essentially due to the fact that all of these
logics are horn so no disjunctive reasoning is needed  for the combined complexity  the
table illustrates how the presence of different constructs affects the complexity of answering
cqs  in particular  extending elhodr
 with role inclusions increases the complexity from
np to pspace  by our pspace lower bound  this increase is solely due to role inclusions 
furthermore  extending elhodr
 with inverse roles increases the complexity from np to
exptime  finally  extending owl   el with inverse roles increases the complexity from
pspace to  exptime 
table   summarises the complexity landscape of answering navigational queries over
owl   el knowledge bases  as one can see  adding the converse operator increases the
combined complexity of gxqs to exptime  bienvenu et al          moreover  adding
negation over node tests increases the data complexity of gxqs to conp  whereas adding
negation over path expressions leads to the undecidability in combined complexity  kostylev
et al          in contrast  existential quantification over paths does not increase the complexity  answering positive  converse free  c gxqs over owl   el knowledge bases is as
difficult as answering  c rpqs over el knowledge bases  bienvenu et al         
    organisation of the article
the rest of this article is organised as follows  in section    we present the basic definitions
of finite automata  pushdown automata  the dl underpinning owl   el  and conjunctive
queries  in section    we introduce our novel encoding of regular role inclusions using pdas
of bounded stack size  in section    we present the cq answering algorithm for owl  
el and discuss its complexity  in section    we present our improved pspace lower bound
of answering cqs in owl   el  finally  in section    we introduce  conjunctive  graph
xpath queries  we show how to reduce the problem of answering positive  converse free
conjunctive graph xpath queries to answering ordinary conjunctive queries  and we present
the aforementioned complexity results 

   

fithe complexity of answering cqs and gxqs over owl   el kbs

   preliminaries
in this section we recapitulate the basic definitions of finite automata  pushdown automata 
the dl elro  underpinning owl   el  and conjunctive queries  in the rest of the paper 
 i  j  is the set containing each natural number k  n such that i  k  j 
    automata and language theory
in this article  we use the standard notions of alphabets  which must be finite   strings  string
concatenation  kleene operators  and languages from formal language theory  hopcroft 
motwani    ullman         we assume that alphabets do not contain the special symbol
  which we will use to label transitions in automata that do not consume input symbols 
furthermore   is the empty word  finally  for w and w  words   w  is the number of symbols
occurring in w  and w  w  is the unique word w   such that w    w    w  if such w   exists 
and otherwise w  w  is undefined 
      finite automata
a finite automaton  fa  is a tuple f   hq      i  f i where q is a finite set of states   is
the input alphabet     q          q is the transition function  i  q is the start state 
and f  q is the final state  such f is deterministic if   s         and   s  c      for each
s  q and each c    otherwise  f is nondeterministic  the size  f  of f is the number
of symbols used to encode f on a tape of a turing machine 
an instantaneous description of f is a pair hs  wi such that s  q and w     the
derivation relation   for f is the smallest set such that  for all states s and s  in q  each
symbol c    and each word w     we have
 if s    s  c   then hs  c  wi   hs    wi  and
 if s    s     then hs  wi   hs    wi 
let   be the reflexive and transitive closure of    then  the language accepted by f is
defined as l f     w     hi  wi   hf  i   a language l is regular if and only if an fa
f exists such that l   l f  
      pushdown automata
a pushdown automaton  pda  is a tuple p   hq        i  i  f  f i where q is a finite set
of states   is the input alphabet   is the stack alphabet   is a transition function mapping
each state s  q  each symbol c        and each stack symbol x   to a finite subset
 s  c  x   q     i  q is the start state  i   is the start stack   f  q is the final
state  and f   is the final stack  the size  p  of p is the number of symbols used to
encode p on a tape of a turing machine 
an instantaneous description of p is a triple hs  w  i such that s  q  w     and
     we read the stack content  from left to rightthat is  the leftmost symbol in  is
the top of the stack  the derivation relation   for p is the smallest set such that  for all
states s and s  in q  each symbol c    each word w     each stack symbol x    and
all words  and    in    we have

   

fistefanoni  motik  krotzsch    rudolph

 hs       i   s  c  x  implies hs  c  w  x  i   hs    w      i  and
 hs       i   s    x  implies hs  w  x  i   hs    w      i 
let   be the reflexive and transitive closure of relation    then  the language accepted by
p is defined as l p     w     hi  w  ii   hf    f i  
our definitions of a pda p and of a language l p  are somewhat nonstandard  the
literature typically considers a hopcroft pda  hopcroft et al         ph that differs from
our definition in that it does not contain the final stack f and its initial stack i is a symbol
from   rather than a word over    moreover  the language accepted by ph is defined as
lh  ph      w          hi  w  ii   hf    i   we show next that our definitions are
equivalent to the standard definitions by hopcroft et al         
proposition    the following two properties hold 
    for each pda p  a hopcroft pda ph exists such that l p    lh  ph   
    for each hopcroft pda ph   a pda p exists such that lh  ph     l p  
proof  sketch   we first prove property      after which we prove property     
    we show how to transform an arbitrary pda p into a hopcroft pda ph such that
l p    lh  ph    such ph uses a fresh initial state i  and fresh stack symbols z  and 
not occurring in   symbol z  is the start stack symbol of ph   furthermore  ph has a new
 transition that moves the pda from state i  to the initial state i of p by replacing z 
with i    where i is the start stack of p  at this point  ph simulates p  always leaving
 at the bottom of the stack until it reaches the final state f of p  next  ph uses fresh
states s            s f   and fresh  transitions that move ph from state f to s f   by reading f
from the stack  finally  from s f     pda ph  moves to a fresh final state f   if the top most
symbol on the stack is   thus accepting the input whenever p reaches f with f on its
stack  automata p and ph clearly accept the same languages 
    we show how to transform an arbitrary hopcroft pda ph into a pda p such that
lh  ph     l p   pda p uses a fresh stack symbol   its initial stack is i   where i is
the initial stack symbol of ph   and its final stack is the empty word  then p simulates ph  
always leaving  at the bottom of the stack until it reaches the final state f of ph   next  p
 moves to a fresh final state f   and pops the topmost symbol off the stack  at this point 
the pda takes further  transitions to empty its stack  eventually reaching its final state
with the empty stack  automata p and ph clearly accept the same languages 
for k a natural number  the k bounded language accepted by p is the set lk  p  containing each word w   for which a derivation hs    w      i        hsn   wn   n i exists where
 s  and sn are the start and the final state of p  respectively 
 w    w and wn    
   and n are the start and the final stack of p  respectively  and
  i    k for each i      n  

   

fithe complexity of answering cqs and gxqs over owl   el kbs

then  p has a k bounded stack if l p    lk  p   as the stack of p is bounded by a
constant  pda p can be simulated by a finite automaton that encodes the stack contents
using its states  and so l p  is regular  but translating p into a finite automaton may
require space exponential in k  geffert et al          in contrast  the following proposition
shows that there exists a pda pk such that l pk     lk  p  and the size of pk is polynomial
in the size of p and k 
proposition    for each pda p and natural number k  one can compute in polynomial
time a pda pk such that l pk     lk  p  
proof  let p   hq        i  i  f  f i be a pda and let k  n be a natural number  let
pk   hqk       k   ik   i  fk   f i be the pda defined by
 qk   q      k  
 transition function k is the smallest function such that  for each        k   each symbol
c        all states s  s   q  and each word    such that hs    i   s  c  x 
and            k  we have hhs             i  i  k  hs   i  c  x   and
 ik   hi   i i and fk   hf   f  i 
clearly  pk can be computed in time polynomial in the size of p and k  let   and  k be
the derivation relations for p and pk   respectively  by the definitions of k and ik   we have
that hhs   i  w  i  k hhs    ji  w       i if and only if hs  w  i   hs    w       i         and         j 
and max    j   k  thus  we have lk  p    l pk    as required 
    description logic elro  and conjunctive queries
the description logic elro    underpinning owl   el  is defined w r t  a signature consisting of mutually disjoint and countably infinite alphabets c  r  and i of atomic concepts 
roles  and individuals  respectively  we assume that   c   c    c  where  c is the top
concept and c is the bottom concept  similarly  we assume that   r   r    r  where  r is
the top role  universal role  and r is the bottom role  for each individual a  i  expression
 a  is a nominal that is  a concept consisting precisely of individual a  then  n is the set
containing nominal  a  for each individual a  i  we call each b  c  n a basic concept 
a role chain  is a word over r  for         we call  the empty role chain and we write it
as   concepts  tbox axioms  rbox axioms  and abox axioms are defined as specified in
table    an elro  tbox t is a finite set of concept inclusions  range restrictions  and
keys  and an elro  rbox r is a finite set of role inclusions 
for r an elro  rbox  let r      r     s  r   s occurs in r   furthermore  the
rewrite relation  
 w r t  r is the smallest relation on role chains such that the following
holds for all role chains   and    
    s     
        for each axiom  v s  r 
     r     
        for each role chain   r  
then  
 is the reflexivetransitive closure of 
    for s a role  l s        r   s  
  
is the language induced by rbox r  a role s is simple in r if  for each role chain  with
   

fistefanoni  motik  krotzsch    rudolph

concepts 
top concept
bottom concept
nominal
conjunction
self restriction
existential restriction
role chains 
top role
bottom role
empty role chain
nonempty role chain
tbox axioms 
concept inclusion
range restriction
key

rbox axioms 
role inclusion
abox axioms 
concept assertion
role assertion

syntax

semantics

 c
c
 a 
c ud
s self
s c

i

 ai  
c i  di
 x  i   hx  xi  s i  
 x  i   y  c i   hx  yi  s i  

 r
r

s     sn

i  i

 hx  xi   x  i  
s i      sni

cvd
range s  c 
key c  s        sn  

c i  di
s i  i  c i
for all x  y  z            zn in i such that
individuals a  b  c            cn in i exist with
x   ai   y   bi   and zi   cii for    i  n 
x   y holds whenever  x  y   c i and
 hx  zi i  hy  zi i   sii for    i  n 

vs

i  s i
bi  s i
 si

a b 
s a  b 

hai   bi i

table    interpreting elro  concepts  roles  and axioms in an interpretation i   hi   i i

s 
   we have        an elro  abox a is a finite set of concept and role assertions 
finally  an elro  knowledge base  kb  is a tuple k   ht   r  ai where t is an elro 
tbox  r is an elro  rbox  and a is an elro  abox such that
 for each concept s self occurring in t   role s is simple in r  and
 for each s     sn v s  r and each range s     c   t such that s    
 s  a role sn   r
 

 
exists such that sn  
 sn and range sn   c   t  
let  t     r   and  a  be the numbers of symbols needed to encode t   r  and a  respectively 
on a tape of a turing machine  and let  k     t    r   a   furthermore  for  a knowledge
base  a tbox  or an abox  we define
i     a  i   a occurs in    n      a    a  i    and c     a  c   a occurs in   
   

fithe complexity of answering cqs and gxqs over owl   el kbs

the semantics of elro  is defined as follows  an interpretation is a tuple i   hi   i i
where i is a nonempty set of domain elements  called the domain of i  and i is the interpretation function that maps each individual a  i to a domain element ai  i   each
atomic concept a  c     c   c   to a set ai  i   and each atomic role s  r     r   r  
to a relation s i  i  i   function i is extended to concepts and role chains as shown
in the upper part of table    where  denotes composition of binary relations  an interpretation i is a model of k if it satisfies all axioms occurring in k as shown at the bottom of
table    moreover  k is consistent if a model of k exists  k is inconsistent if no model of
k exists  and k entails a first order sentence   resp  a concept inclusion c v d or a role
inclusion  v s   written k      resp  k    c v d or k     v s   if i      resp  c i  di
or i  s i   for each model i of k  by the definition of l s   we have that   l s  implies
k     v s  knowledge base consistency  entailment of concept inclusions  and entailment
of role inclusions can be decided in polynomial time  krotzsch        baader et al         
      conjunctive queries
a term is an individual or a variable  an atom is an expression of the form a t  or r t    t 
where a is an atomic concept  r is a role  and t  and t are terms  a conjunctive query  cq 
is a formula q    y    x   y   with  a conjunction of atoms over variables  x   y   variables  x
are the answer variables of q  when  x is empty  we call q    y    y   a boolean cq  bcq  
a substitution  is a partial mapping from variables to terms  and dom   and rng  
are the domain and the range of   respectively  for  a conjunction of atoms     is the
result of applying substitution  to the atoms in   then   q     z     where  z contains
 i   y  for each variable y   y such that  y  is a variable  and  ii  each variable y   y such
that  y  is undefined  our definition of  q  is somewhat nonstandard because quantified
variables can also be replaced  for example  given q   y    y    y   r y    y     t  y    y    and
    y    a  y    z   we have  q    y    z r y    a   t  y    z  
let k   ht   r  ai be an elro  knowledge base and let q    y    x   y   be a cq  then
q is over k if q uses only the predicates and the individuals occurring in k  a substitution
 is a candidate answer for q over k  if dom      x and rng    ik   and such  is a certain
answer to q over k if and only if k     q   answering q over k amounts to computing
the set of all certain answers to q over k  as stated  cq answering is a function problem 
thus in this article we study the complexity of the associated decision problem named bcq
answering  which is the problem of deciding  given a boolean cq q over k  whether k    q 
please note that bcq answering is equivalent to the recognition problem which decides 
given a cq q over k and a candidate answer   whether  is a certain answer to q over k 
following vardi         combined complexity assumes that both q and k are part of the
input  and data complexity assumes that only the abox a is part of the input 
    ensuring decidability of bcq answering via regularity
rosati        and krotzsch et al         independently showed that answering boolean
cqs over elro  knowledge bases is undecidable  intuitively  role inclusions can simulate derivations in context free languages  thus  a boolean cq can check whether two
context free languages have a non empty intersection  which is a known undecidable problem  hopcroft et al         

   

fistefanoni  motik  krotzsch    rudolph

to regain decidability  we next recapitulate the definition of so called regular rboxes
by horrocks and sattler         let r be an elro  rbox and let  be the smallest
transitive relation on r such that  for each   t    v s  r with s    t   we have t  s 
then  rbox r is regular if  is irreflexive and each role inclusion  v s  r is of the form
 t    v s 
 t   s  s v s 
 t   s     sn  s v s and si    s for each i      n  
 t   s     sn v s and si    s for each i      n   or
 t   s  s     sn v s and si    s for each i      n  
by induction on  we then define the level lv s  of each role s  r as follows  lv s     
if no t  r exists such that t  s  otherwise  lv s        max lv t     t  s   clearly 
lv s  can be computed in time polynomial in  r   in section   we show that bcq answering
over elro  kbs with regular rboxes is in pspace 
    normalising elro  knowledge bases
for simplicity  in the rest of this paper we assume that each elro  knowledge base
k   ht   r  ai is normalised  which is the case if the following properties hold 
 n   we have ik      and k      a  v  b  for all  a  b   ik with a    b 
 n   each axiom in t is of one of the following forms  for a i  basic concepts and s a role 
a  u a  v a 

a  v s a 

s a  v a 

a v s self

s self v a

 n   each axiom  v s  r is such that       and s     r   and each role in t  a also
occurs in r 
we next show that each knowledge base k can be normalised in polynomial time without
affecting the regularity of the rbox component nor the answers to boolean cqs 
proposition    for each elro  knowledge base k with a regular rbox and each boolean
cq q over k  one can compute in polynomial time a normalised elro  knowledge base
k  and a boolean cq q   such that
 the rbox of k  is regular  and
 q   is over k    and k    q if and only if k     q    
proof  let k be an elro  kb with regular rbox and let q be a boolean cq over k 
we first satisfy property  n    let k  be obtained from k by extending the abox
of k with assertion  c  c  for c a fresh individual  clearly  k     q if and only if k    q 
next  let k  and q   be obtained from k  and q  respectively  by uniformly substituting each
individual a with an arbitrary  but fixed  individual b such that k      a  v  b   entailment
   

fithe complexity of answering cqs and gxqs over owl   el kbs

of concept inclusions can be decided in polynomial time  so k  and q   can be computed in
polynomial time  moreover  k  and q   are obtained by replacing each individual a with an
arbitrary  but fixed individual b such that ai   bi for each model i of k    so q   is over k   
and k     q   if and only if k     q 
we next satisfy property  n    let k  be the result of eliminating all keys from k    as
one can see from table    keys can only derive axioms of the form  a  v  b   moreover 
the effects of such conclusions have already been captured by k    and so k     q   if and
only if k     q     next  we eliminate in polynomial time all range restrictions occurring in
k by applying the syntactic transformation by baader et al          let k  be the resulting
knowledge base  since the definition of elro  knowledge base carefully restricts the
interactions between role inclusions and range restrictions  we have k     q   if and only if
k     q    baader et al          next  following krotzsch         we compute in polynomial
time a knowledge base k  that satisfies  n   such that k     q   if and only if k     q    
we next satisfy property  n    let k  be the result of exhaustively decomposing each
role inclusion  v s of the form  t   t   with        occurring in k  according to the
following rewrite rules  where each occurrence of role s   is fresh 
 t   s     sn  s v s    s    s v s 
s      sn v s    
 
 t  
s     sn v s    s  sn v s  s     sn  v s    
 t   s  s     sn v s 
 
 s  s   v s 
s      sn v s    
only linearly many rewrite steps are required to satisfy  n    and the resulting rbox is
regular  furthermore  each model of k  is also a model of k  and each model i of k 
can be expanded to a model j of k  by interpreting each role s   occurring in k    k  as
 s    j       j   where   is the unique role chain such that   v s   occurs in k    thus  we
have k     q   if and only if k     q     next  let k  be the result of removing each axiom
 v  r in k    all removed axioms are tautologies  so we have k     q   if and only if k     q    
finally  let k  be the result of adding axiom r v s  for each role s that occurs in k  but
does not occur in its rbox component  the axioms in k    k  preserve regularity and are
tautologies  so k     q   if and only if k     q     as required 

   encoding regular rboxes succinctly using bounded stack pdas
each reasoning algorithm for a dl with role inclusions known to us uses a step that checks
whether   l s  holds for an arbitrary role chain  and a role s  for example  to check
whether k    s a  b  holds  an algorithm must ensure that  in each model of k  a role chain
  l s  exists connecting the elements interpreting a and b  although they characterise
languages l s   role inclusions do not lend themselves well to language recognition  so all
algorithms known to us transform role inclusions into another  more manageable form  this
is analogous to the fact that  while regular expressions characterise regular languages  the
former are routinely transformed into fas in order to facilitate language recognition 
horrocks and sattler        showed that  for each regular rbox r and each role s
occurring in r  one can construct an fa fs such that l fs     l s   these fas are used
in a tableau decision procedure for sroiqthe dl underpinning owl   dl  horrocks
et al          given a sroiq knowledge base  the tableau procedure tries to construct
   

fistefanoni  motik  krotzsch    rudolph

s 

is 

start




is 

s 

fs 

is 

fs 



s 

fs 

fs 





is 

s 


is 

s 

is 

fs 

s 

fs 

is 

s 

fs 

figure    the fa fs  as constructed following horrocks and sattler       
a finite graph representing a model of the kb  in which edges are labelled by roles  and
vertices are labelled by concepts  the aforementioned fas are used to ensure that universal
restriction s c obey the constraints imposed by role inclusions  roughly speaking  this is
obtained by running fs over the graph while updating the current state of fs along the
path  and by labelling each reachable vertex in which the state of fs is final with concept
c  simanck        optimised the tableau procedure by simulating fas on the fly  rather
than precomputing them in advance 
horrocks and sattler        observed that their fas can contain exponentially many
states  kazakov        proved that this is unavoidable in some cases  for the regular rbox
rn containing axioms      the size of each fa f with l f    l sn   is exponential in n 
si   si  v si

i      n 

   

this blowup in the number of states is caused by the simple model of computation underlying fas  where the behaviour of the automaton is determined solely by the current state 
in the example above  we have   l sn   whenever  consists of si repeated j times for
some i      n  with j    ni   thus  while parsing such   the fa recognising l sn   must
remember the number of occurrences of si it has already seen  which can be achieved only
by using a different state for each number between   and  n   figure   shows the fa fs 
constructed by horrocks and sattler         to remember the current state  fs  contains
two copies of automaton fs    and each copy of fs  contains two copies of automaton fs   
hence  to obtain a pspace procedure  we must devise a more succinct representation for
the languages induced by role inclusions  towards this goal  we note that role inclusions are
closely related to context free grammars  and that context free languages can be efficiently
recognised using pushdown automata  hopcroft et al        that is  fas extended with
an infinite stack for storing contextual information  hence  given a regular rbox r and a
role s occurring in r  we construct a pda ps that accepts l s   unlike the fa shown in
figure   that remembers contextual information using states  pda ps uses the stack to
remember the current status of the computation and determine how to proceed  we show
that the number of states in ps is polynomial in the size of r  and that ps can recognise
l s  by using a stack of size linear in the size of r  thus  ps provides us with the required
succinct encoding of fs   in section    we use these pdas in an algorithm that answers
boolean cqs over elro  knowledge bases using polynomial space 
   

fithe complexity of answering cqs and gxqs over owl   el kbs

start

is 

s    x x

fs 
  x x

  x is   fs   x

is 

s    x x

i r

fs 

r  x x

f r

  x x
  x is   fs   x

is 

s    x x

fs 

figure    the pda ps  corresponding to the fa fs    where x  r and r  r
in the rest of this section  we fix an arbitrary regular rbox r  by proposition    we
can assume that each role inclusion  v s  r is such that       and s     r   for each
role s occurring in r   we next define the pda ps  
definition    let s  r be a role  then  ps   hqr   r   r   r   is     fs   i is the pda
where qr    it   ft   t  r   is the set of states  r   qr     is the stack alphabet  and
r is the smallest transition function satisfying the following conditions for each x  r  
 r  for each t  r     r    we have hft   xi  r  it   t  x  
 t   for each  v t  r  we have hft   xi  r  it     x  
 t   for each t  t v t  r  we have hit   xi  r  ft     x  
 t   for each t   t v t  r  we have hit    it  xi  r  it     x  
 t   for each t   t  v t  r  we have hit    it   ft  xi  r  it     x  
 t   for each t  t  v t  r  we have hit    ft  xi  r  ft     x  
 ur  for each t  r   we have hf r   xi  r  i r   t  x  
 u   hf r   xi  r  i r     x  
 u   hi r   xi  r  f r     x  
 p  for each t  r and each s  qr   we have hs  i  r  ft     s  
in the following examples  we present the pda that succinctly encodes the fa fs    and
we explain the different types of transitions in definition    and how the content of the
stack influences the computation of pdas 
example    figure   shows the pda ps  corresponding to the fa fs  in figure    a
c  x 

transition hs    i  r  s  c  x  is shown as s  s    where x  indicates that the transition replaces the top most stack symbol x with word   moreover  transitions of the form
 p  from definition   are not shown in the figure for the sake of clarity  as one can see
from the figure  unlike in fa fs    there is no copying of states in pda ps   
   

fistefanoni  motik  krotzsch    rudolph

  x x

start

is

s  x x

  x i r  fs  x

i r

fs

r  x x

f r

  x x

  x fs  x
  x it  x

ip

it

t  x x

ft

  x x
  x x

p  x x

fp
figure    the pda ps for the rbox in example    where x  r and r  r
example    to explain the different types of transitions in definition   and how the stack
is used in the computation of a pda  we use the regular rbox r containing role inclusions
        figure   shows pda ps using the notation from example   
vp

   

t t vt

   

p   r v s

   

st vs

   

p t vt

   

each role t  r is associated with states it and ft   and moving from the former to
the latter ensures that the pda reads a role chain   l t    a transition of type  r  allows
the pda to read t in state it   an  transition of type  t   from it to ft is added if t
is reflexive  and it allows the pda to read the empty role chain  in our example  axiom
    introduces the  transition from ip to fp   moreover  an  transition of type  t   from
ft to it is added if t is transitive  and it allows the pda to read any number of role
chains             n  l t    in our example  axiom     introduces the  transition from ft
to it   transitions of types  ur    u    and  u   analogously reflect the properties of  r  
 ur  allows the pda to read an arbitrary role  and  u   and  u   reflect the reflexivity and
transitivity of  r   respectively  none of these transitions affect the pdas stack 
to illustrate transitions of type  t    we next show how  for     p  s  pda ps
determines that    l s   the latter is ensured by axiom      now assume that pda ps is
in state is with  on its stack  due to axiom      ps can make an  transition of type  t  
to state ip   pushing i r  fs on the stack  since the new state is ip   the pda will next need
to read p   furthermore  the stack content signals to the pda that  after it finishes reading
p   it should move to state i r to read  r and then to state fs to finish reading s  indeed 
ps can then make a transition of type  r  to state fp to read p   followed by an  transition
of type  p  to state i r popping i r off the stack  next  the pda can make a transition of
   

fithe complexity of answering cqs and gxqs over owl   el kbs

type  ur  to state f r reading s  followed by an  transition of type  p  to state fs popping
fs off the stack  at this point  the pda accepts the input 
to illustrate transitions of types  t   and  t    we next show how  for     s p t   pda
ps determines that    l s   the latter is ensured by axioms     and      again  assume
that pda ps is in state is with  on its stack  pda ps can then make a transition of type
 r  to state fs   reading s and leaving the stack unchanged  next  due to axiom      ps can
make an  transition of type  t   to state it   pushing fs on the stack  due to axiom     
pda ps can next make an  transition of type  t   to state ip   pushing it on the stack 
at this point  the stack contains it  fs    next  the pda can make a transition of type
 r  to state fp reading p   and then an  transition of type  p  to state it popping it off
the stack  furthermore  in an analogous way  the pda can move to state ft reading t and
leaving fs   on the stack  finally  the pda can make an  transition of type  p  to state
fs popping fs off the stack  at this point  the pda accepts the input 
to understand the benefit of using pdas rather than fas  note that ps reaches state ip
while recognising both   and     role p occurs in axioms     and      so when ps moves
into state ip in order to read an occurrence of p   it must remember which of the two
axioms caused the move so that it knows how to continue after reading p   for     ps must
continue reading  r   whereas for     it must continue reading t   unlike the fas by horrocks
and sattler        that remember this information by copying states  ps remembers this
information on its stack  for     it reaches ip with i r  fs   on its stack  whereas for    
ps reaches ip with it  fs   on its stack  thus  the stack of ps is analogous to stacks in
programming languages  stack symbols correspond to return addresses  and transitions of
type  p  correspond to return statements 
the following proposition is immediate from the definition of pda ps  
proposition    pda ps can be computed in time polynomial in  r  
the following theorem states that pda ps accepts l s  and that ps has stack bounded
by the size of r  the proof of this result is given in section     
theorem    for each role s  r and each role chain  
     l ps   if and only if   l s   and
   ps has stack bounded by    lv s      
theorem   gives rise to the following notion of the depth of rbox r  which provide us
with a global bound on the stack size of the pdas encoding r 
definition    the depth of the rbox r is defined as dr    maxsr     lv s       
finally  we outline how our bounded stack encoding of regular rboxes can reduce the
space used by the tableau algorithm for sroiq  since elro  does not support inverse
roles  definition   does not directly provide us with an encoding of the languages induced
by sroiq rboxes  nevertheless  we can extend the construction above by completing
rbox r so that inv sn      inv s    v inv s   r for each role inclusion s     sn v s in the
rbox  where inv   maps each role to its inverse  one can check that  for each  inverse  role
   

fistefanoni  motik  krotzsch    rudolph

s  the pda ps constructed using the completed rbox r encodes fs   then  we can modify
the portion of the tableau algorithm responsible for checking the satisfaction of universal
restrictions by running a bounded stack pda over the graph constructed by the tableau
procedure  roughly speaking  for each universal restriction s c labelling a vertex  we run
ps over the graph while updating the current state and the stack of ps   and we label each
reachable vertex in which the current state and stack of ps are final with concept c  since
ps and its stack are of size polynomial in  r   this requires polynomial space  unlike the
fas by horrocks and sattler        and the optimised encoding by simanck         which
may require exponential space 
    proof of correctness
in this section  we prove theorem    towards this goal  let   be the derivation relation
w r t  transition function r   furthermore  for each derivation step hs    i   hs           i 
we write hs    i  x hs           i if hs           i can be obtained from hs    i by applying a
transition of the form  x  from definition   with x   r  t           t   ur  u   u   p  
      soundness and stack boundedness
in this section  we prove that  for each role s  r and each role chain  
     l ps   implies that   l s   and
   ps has stack bounded by    lv s      
to this end  we first show that pda ps satisfies the following liveness property  if during
its computation ps pushes a state s  qr on the stack  then ps will eventually pop s off
the stack  then  we show that each derivation of ps moving from state is to state fs takes
one of five forms  we call such derivations regular  finally  we show that regular derivations
satisfy properties     and     
we start by showing that each pda ps satisfies the following liveness property 
lemma     let hs           i        hsn   n   n  i be an arbitrary derivation such that
s    is   sn   fs   and      for some role s  r and some word   r   then  for each
role t such that lv t     lv s  and each i      n  such that si   it   ft   and i   s i  i 
with s i  qr   an index j   i  n  exists such that
 a  sj   ft and j   i  
 b  for each k   i  j   word k is of the form k    k    i for some k    r   and 
 c  sj     s i   j     i    and j     j  
proof  let hs           i        hsn   n   n  i be as above  and for each i      n      let
xi   r   t            t    ur   u    u    p  be the form of derivation step ithat is  we fix xi  arbitrarily if there is more than one possibility  such that hsi   i   i  i  xi hsi     i     i    i
holds  furthermore  for each role t such that lv t     lv s   let it be the set containing
each index i      n  such that si   it   ft   and i is of the form i    s i  i  with s i  qr  
note that  for each index i  it   due to lv t     lv s   si   it   ft    and sn   fs   we have
   

fithe complexity of answering cqs and gxqs over owl   el kbs

that i   nthat is  hsi   i   i  i   hsi     i     i    i occurs in our derivation  next  by
induction on m  n  we show that  for each role t with m   lv t     lv s  and each i  it  
some j   i  n  exists satisfying properties  a  c  
base case     consider an arbitrary role t  r such that     lv t     lv s   we
consider the interesting case where it      otherwise  properties  a  c  hold vacuously 
since lv t       and si   it   ft    we have xi   r   t    t    ur   u    u    p   by reverseinduction on it  i e   by induction starting from the maximal element   we next show that
each index i  it satisfies the required properties 
base case  let i   max it   if xi   r   t    t    ur   u    u     then si     it   ft   and
i     i   thus  we have i      it   which contradicts the maximality of i  the only
remaining possibility is xi   p  which implies that si   ft   si     s i   i     i    and
i     i   but then  j   i satisfies properties  a  c  
inductive step  consider an arbitrary index i  it such that properties  a  c  hold for
each    it with     i  if xi   r   t    t    ur   u    u     then si     it   ft   and i     i  
hence  ii    it so  by the inductive hypothesis  an index j exists satisfying properties
 a  c   otherwise  if xi   p  then si   ft   si     s i   i     i    and i     i   so j   i
satisfies properties  a  c  
inductive step     consider an arbitrary m  n such that properties  a  c  hold for
each role p  r with lv p    m and lv p     lv s  and each index in ip   furthermore 
consider an arbitrary role t such that m       lv t     lv s   we consider the interesting
case where it      otherwise  properties  a  c  hold vacuously  recall that for each
 v s    r we have s       r   so lv  r       and t     r   thus  each i  it is such that
xi    ur   u    u     by reverse induction on it   we next show that each index i  it satisfies
the required properties 
base case     let i   max it   if xi   r   t    t     then si     it   ft   and i     i  
thus  we have i      it   which contradicts the maximality of i  if xi   t    t    t     then
si     ip   fp   for some role p such that lv p     lv t   and lv p     lv s   furthermore  we
    s   where s   i   f   and    
have that i   is of the form i      i  
i
t
t
t t
i   is a sequence
  
of zero or one states  each state s occurring in i  
is such that s   ir   fr   for some role
r of level less than t   but then  by the inductive hypothesis     an index     i exists
such that s    st and     i   which contradicts the maximality of i  finally  if xi   p 
then si   ft   si     s i   i     i    and i     i   so j   i satisfies properties  a  c  
inductive step     consider an arbitrary index i  it such that properties  a  c  hold
for each index    it with     i  and consider the possible forms of xi  
 xi   r   t    t     then  si     it   ft   and i     i   so i      it   by the inductive
hypothesis     an index j exists satisfying properties  a  c  
 xi   t    then  si     it  and i     it  i for some role t  with lv t      lv t   
thus  i      it    by the inductive hypothesis     an index     i      n  exists such
that s    ft  and     i     furthermore  for each k   i          we have that k is
of the form k    k    i   for some word k    r   finally  s      it and       i  
by the definition of it   we have that        it   by the inductive hypothesis     an
index j exists satisfying properties  a  c  
   

fistefanoni  motik  krotzsch    rudolph

 xi   t    then  si     it  and i     it   ft  i for some roles t  and t  with
lv t      lv t   and lv t      lv t    thus  i      it    by the inductive hypothesis
    an index      i      n  exists such that s     ft  and      i     furthermore  for
each k   i        we have that k is of the form k    k    i   for some word k    r  
finally  s        it  and         ft  i   then          it    again  by the inductive
hypothesis     an index              n  exists such that s     ft  and             
furthermore  for each k                 we have that k is of the form k    k         
for some word k    r   finally  s        ft and         i   by the definition of it   we
have that         it   so  by the inductive hypothesis     an index j exists satisfying
properties  a  c  
 xi   t    then  si     it  and i     ft  i for some role t  with lv t      lv t   
then  i      it    by the inductive hypothesis     an index     i      n  exists
such that s    ft  and     i     for each k   i      we have that k is of the form
k    k    i   for some word k    r   finally  s      ft and       i   by the
definition of it   we have that        it   so  by the inductive hypothesis     an
index j exists satisfying properties  a  c  
 xi   p  then  si   ft   si     s i   i     i    and i     i   therefore  j   i satisfies
properties  a  c  
next  for each role s  r   we define the notion of regular derivations of ps  
definition     the set of regular derivations of p r is inductively defined as follows  for
each role t  r   each role chain i  r   and each   r  
sequr hi r   t      i  ur hf r       i is a regular derivation of p r  
sequ  hi r       i  u  hf r       i is a regular derivation of p r  
sequ  if hi r       i        hf r   k   i and hi r   k   i        hf r   n   i are regular derivations of p r   then the following is also a regular derivation of p r  
hi r       i        hf r   k   i  u  hi r   k   i        hf r   n   i
next  consider an arbitrary natural number m  n and assume that regular derivations of
pt have already been defined for t    r and each role t  r     r   such that lv t    m 
then  for each role s  r     r   with lv s    m      regular derivations of ps are defined
as follows  for each s i   r   each i  r   and each   r  
seqr his   s      i  r hfs       i is a regular derivation of ps  
seqt  if  v s  r  then his       i  t  hfs       i is a regular derivation of ps  
seqt  if s  s v s  r and his       i        hfs   k   i and his   k   i        hfs   n   i
are regular derivations of ps   then the following is also a regular derivation of ps  
his       i        hfs   k   i  t  his   k   i        hfs   n   i

   

fithe complexity of answering cqs and gxqs over owl   el kbs

seqt  if s   s v s  r  his        is  i        hfs    k   is  i is a regular derivation of
ps    and his   k   i        hfs   n   i is a regular derivation of ps   then the following
is also a regular derivation of ps  
his       i  t  his        is  i        hfs    k   is  i  p his   k   i        hfs   n   i
seqt  if s  s  v s  r  his        is   fs  i        hfs    k   is   fs  i is a regular derivation of ps    and his    k   fs  i        hfs    n   fs  i is a regular derivation of ps   
then the following is also a regular derivation of ps  
his      
his        is   fs
fs
his    k  
hfs   n  

i  t 
 i        hfs    k   is   fs  i  p
fs  i  p
 i        hfs    n  
i

seqt  if s  s  v s  r  his       i        hfs   k   i is a regular derivation of ps   and
his    k   fs  i        hfs    n   fs  i is a regular derivation of ps    then the following is also a regular derivation of ps  
his       i        hfs   k   i  t  his    k   fs i        hfs    n   fs i  p hfs   n   i
we are left to show that each derivation of ps that moves the pda from the start state
is to the final state fs is regular and that regular derivations satisfy the required properties 
in the following lemma  we show that derivations which leave a particular word  at the
bottom of the stack are regular and satisfy properties     and      subsequently  we will
show that each accepting derivation of ps is of this form 
lemma     for each role s  r   each word   r   and each derivation of the form
hs           i        hsn   n   n  i such that s    is   sn   fs   and      
 i  the derivation is regular for ps  
 ii  for each i      n   we have that  i       lv s   and
 iii  s 
      n  
proof  we prove the claim by induction on n  n   
base case  for n      consider an arbitrary role s  r   word   r   and sequence
his          i   hfs          i  by definition    only transitions from cases  r    t     ur  
and  u   move ps from state is to state fs   these transitions leave the stack untouched 
so          and property  ii  holds  for properties  i  and  iii   we next consider the
four different forms that the sequence may take 
 his   s         i  r hfs          i  then s     r   so this is a regular derivation of
ps by case seqr and  i  holds  finally         s  which implies s  
        and
so  iii  holds 
   

fistefanoni  motik  krotzsch    rudolph

 his          i  t  hfs          i  then s     r   so this is a regular derivation of ps
by case seqt  and  i  holds  finally           moreover  by case t  of definition   
we have  v s  r  so s  
   hence  s  
      and  iii  holds 
 his   t         i  ur hfs          i  then s    r and t  r   so this is a regular
derivation of p r by case sequr and  i  holds  finally         t  r   which
implies s  
        and so  iii  holds 
 his          i  u  hfs          i  then s    r   so this is a regular derivation of p r
by case sequ  and  i  holds  finally           hence  s  
   and so  iii  holds 
inductive step  consider an arbitrary n  n  and assume that  i  iii  hold for each
role s    r   each word     r   and each derivation hs                 i        hs c    c   c      i
of length at most n and of the form required by this lemma  furthermore  consider an
arbitrary role s  r   an arbitrary word   r   and an arbitrary derivation
hs           i        hsn     n     n    i

   

of length n     such that s    is         and sn     fs   for each i      n      let
xi   r   t            t    ur   u    u    p  be the form of derivation step ithat is  we fix xi  arbitrarily if there is more than one possibility  such that hsi   i   i  i  xi hsi     i     i    i
holds  we next consider the possible forms the sequence might have  and we show that
properties  i  iii  hold in each case 
 case    s    r   we consider the form of hs           i  x  hs           i  since
s    i r   we have x    t    t    t    ur   u     as r is normalised  each  v s    r is
such that s       r   so x    ur  u   and we have s    f r and            since n     
hs           i  x  hs           i occurs in the sequence with x    t    t    u    p   since
s    f r and r is normalised  we have x    u    p   furthermore  since      and by our
assumption on the form of      we have x     p  hence  the only remaining possibility is
that x    u    by case  u   in definition    we have s    i r           and         we
next prove that properties  i  iii  hold 
 i  by sequr and sequ    hs           i  x  hs           i is a regular derivation of p r   by
the inductive hypothesis  hs           i        hsn     n     n    i is also a regular
derivation of ps   by the definition of regular derivations  we have n         but
then      is a regular derivation of ps by case sequ   
 ii  words           are all empty  by the inductive hypothesis  we have          lv  r  
for each        n       therefore   i       lv  r   holds for each i      n      
 iii  by the inductive hypothesis  we have  r  
    n     by cases  ur  and  u    either
        or        t  r   but then   r 
      n   holds 
 case    s     r and k      n  exists with hsk   k   k  i  t  hsk     k     k    i and
sk   fs   then  by case  t   in definition    we have s  s v s  r  sk     is   k     k  
and k     k   we next prove that properties  i  iii  hold 

   

fithe complexity of answering cqs and gxqs over owl   el kbs

 i  by the inductive hypothesis  hs          i        hsk   k   k i is a regular derivation
of ps   by the definition of regular derivations  we have k         since sk     is
and k     k     we have that hsk     k     k    i        hsn     n     n    i
is of the form shown in     and it is shorter than n     so  by the inductive hypothesis 
it is a regular derivation of ps   then      is a regular derivation of ps by case seqt   
 ii  by the inductive hypothesis  we have           lv s  for each         k   as well as
          lv s  for each      k      n       therefore   i       lv s  holds for each
i      n      
 iii  by the inductive hypothesis  we have s  
    k and s  
 k    n     but then 

s  s v s  r and k     k implies that s  
    n   holds 
 case    s     r and no        n  exists with hs           i  t  hs                 i
and s    fs   but k      n  exists such that hsk   k   k  i  t  hsk     k     k    i and
sk   fs   then  let k be the largest such indexthat is  we assume that no m   k exists
such that hsm   m   m  i  t  hsm     m     m    i and sm   fs   then  by case  t   in
definition    for some role s  of level less than s  we have that s  s  v s  r  sk     is   
k     k   and k     fs  k   we next prove that properties  i  iii  hold 
 i  since sk   fs   by the inductive hypothesis then hs           i        hsk   k   k  i
is a regular derivation of ps   by definition     we have that k       since sk     is 
and k     fs      by lemma     an index j   k      n  exists such that sj   fs 
and j   k     furthermore  sj     fs and j       and j     j   we prove that
j       n      for the sake of contradiction  assume that j       n     and consider
the form of transition hsj     j     j    i  xj    hsj     j     j    i  given that
sj     fs and s     r   we must have xj     t    t    p   by the initial assumption 
we have xj      t    furthermore  by the maximality of k  we have xj      t    finally 
since j           we have xj      p  thus  j       n      as required  it follows
that the sequence is of the following form  where k     k and n     n  
his      
   i        hfs   k      i  t 
his    k     k    i        hfs    n   n  i  p
hfs   n        i
by lemma     for each     k      n   we have that   is of the form          fs      in
  
particular  words k  
and n   are both empty  then  by the inductive hypothesis  we
have that his    k     k    i        hfs    n   n  i is a regular derivation of ps   
by case seqt    then     is a regular derivation of ps  
 ii  by the inductive hypothesis  for each         k   we have that           lv s   furthermore  for each      k      n   we have that             lv s     since lv s      lv s 
and            fs   we also have that           lv s   given that n       for each
i      n       we have that  i       lv s  
 iii  by the inductive hypothesis  we have that s  
    k and s   
 k    n   given

that s  
 s  s    that k     k   and that n     n   we obtain that s  
    n    

   

fistefanoni  motik  krotzsch    rudolph

 case    s     r and no        n  exists with hs           i  x  hs                 i 
s    fs and x    t    t     but hs           i  t  hs           i  then  by case  t   in definition    for some role s  of level less than s  we have that s   s v s  r  s    is   
        and     is      we next prove that properties  i  iii  hold 
 i  since s    is  and     is      by lemma     some j      n  exists such that sj   fs 
and j       furthermore  sj     is and j       and j     j   then  the sequence
is of the following form  where        
his      
   i  t 
j  i  p
   i        hfs    j  
his       
his   j     j    i        hfs   n     n    i
by lemma     for each        j   we have that   is of the form          is     
in particular  words     and j   are both empty  by the inductive hypothesis  then
his           i        hfs    j   j  i is a regular derivation of ps    since j        
by the inductive hypothesis  then his   j     j    i        hfs   n     n    i is a
regular derivation of ps   by case seqt    then     is a regular derivation of ps  
 ii  by the inductive hypothesis  for each      j      n       we have that           lv s  
furthermore  for each         j   we have that             lv s     since lv s      lv s 
and            is   we also have that           lv s   finally  since       for each
i      n       we have that  i       lv s  
 iii  by the inductive hypothesis  we have that s   
    j and that s  
 j    n    
given that s  
 s  s  that         and that j     j   we have that s  
   n    
 case    s     r and no        n  exists with hs           i  x  hs                 i 
s    fs   and x    t    t     in addition  hs           i  x  hs           i is such that x     t  
we next consider the remaining possibilities for x    as s    is   we have x     t    t    u    p 
by cases  t     t     u    and  p  of definition    furthermore  due to s     r   we have
x     ur   u    by cases  ur  and  u   of definition    moreover  assume that x    r   t    
then  we have s    fs and       by cases  r  and  t   of definition    since n     and
s     r   the only possibility is that hs           i  p hs           i  which is impossible
due to      and our assumption on the form of      hence  the only remaining possibility
is that x    t    by case  t   in definition    for some roles s  and s  of level less than
s  we have s   s  v s  r  s    is            and     is   fs      we next prove that
properties  i  iii  hold 
 i  since s    is  and     is   fs      by lemma     j       n  exists such that sj    fs 
and j        furthermore  sj       is  and j       fs    and j       j    again 
by lemma     j    j       n  exists such that sj    fs  and j    j       furthermore 
sj       fs and j         and j       j    next  we prove that j        n     
for the sake of contradiction  suppose that j        n     and consider the form
of hsj       j       j      i  xj     hsj       j       j      i  given that sj       fs   we
must have that xj       t    t    u    p   however  we assumed that xj        t    t   
and that s     r   so xj        u    finally  since j             we have xj        p 
   

fithe complexity of answering cqs and gxqs over owl   el kbs

therefore  we have j        n      as required  and the sequence is of the following
form  for         j       j   and n     n  
his      
   i  t 
his       
   i        hfs    j    j   i  p
his    j       j      i        hfs    n   n  i  p
hfs   n     n    i
by lemma     for each         j     word    is of the form            is   fs     
in particular  words     and j    are both empty  then  by the inductive hypothesis 
we have that his           i        hfs    j    j   i is a regular derivation of ps   
similarly  by lemma     for each      j       n   we have that    is of the form
           fs      in particular  words j       and n   are both empty  then  by the
inductive hypothesis  we have that his    j       j      i        hfs    n   n  i is a
regular derivation of ps    by case seqt    then     is a regular derivation of ps  
 ii  by the inductive hypothesis  for each         j     we have that             lv s     since
lv s      lv s  and            is   fs   we also have that           lv s   similarly  by
the inductive hypothesis  for each      j       n   we have that             lv s     since
lv s      lv s  and            fs   we also have that           lv s   since       for
each i      n       we have that  i       lv s  
 iii  by the inductive hypothesis  we have that s   
   j  and s   
 j      n   given

that s  
 s   s    that         and that n     n   we conclude that s  
    n    
there are no other possibilities for the form of      so the claim of this lemma holds for
each derivation of that form 
we are finally ready to show that pda ps satisfies properties     and     
lemma     for each role s  r and each role chain   we have that
     l ps   implies   l s   and
   ps has stack bounded by    lv s      
proof  by the definition of ps   transitions resulting from case p in definition   are the only
ones popping elements from the stack  and these never pop symbol   hence  at each point
i in an accepting derivation of ps   the stack content i is of the form i    i     then 
the two claims follow immediately from lemma    
      completeness
we next prove that our encoding is also complete  thus proving theorem   
lemma     for each role s  r and each role chain   we have that   l s  implies
  l ps   

   

fistefanoni  motik  krotzsch    rudolph

axiom type
 t  
vt
 t  

 t  

 t  

 t  

derivation
i i  t  hft  

  

hit  

  

t t vt

hit  
hit  

t  t      
t      

t   t v t

hit   t   t      
hit    t   t      
hit  
t      

t   t  v t

hit   t   t       
hit    t   t        it   ft
hit   
t       
ft
  
hft  
  

t  t  v t

hit   t  t       
hit   
t       
hft  
    

i i
i i

 r
 r

i i  t 
i t  i i   r
i i  r
i i  t 
 i i   r
 i i   r
i i

i i  r
ft   i i   r
i i

    

i i

hft   t      
hft  
    

i i
i i

 t 

hft    t      
hft  
    

i t  i i
i i

 p

hft    t       it   ft  i i  p
hft   
    
ft   i i   p
hft   t       
hft   
    

i i  t 
ft   i i   p

table    definition of derivation     depending on the form of axiom  v t  
proof  consider an arbitrary role s  r   in the following  for each role chain   we write
 
m
s  
  if    s  furthermore  for each m  n    we write s  
  if role chains             m
exist such that s  
    
   
 m and m     by the definition of l s   we have that
m
  l s  if and only if a natural number m  n exists such that s  
   by induction on
m
m  n  we next show that s  
  implies   l ps   
 

base case  let m      then  we have that s  
 s  we consider two cases depending
on the form of role s  r  
 s    r   by case  ur  in definition    we have that hi r    r   i  ur hf r     i 
 s  r     r    by case  r  in definition    we have his   s  i  r hfs     i 
in either case we have s  l ps    as required 
inductive step  consider an arbitrary m  n and assume that  for each role chain  
m
such that s  
     we have    l ps    we show that the same holds for m      then 
consider arbitrary role chains             m   such that s  
    
   
 m  
 m     by the
definition of relation  
  a role t  r and role chains          exist such that role chain
m is of the form m       t       role chain m   is of the form m                and
m
t  
   since s  
    t       by the inductive hypothesis  we have    t      l ps    so a
sequence hs          i        hsn   n   n i of ps exists with s    is and sn   fs   furthermore 
     and n     finally         t     and n     then there exists an index
i      n     such that i   t     and i          furthermore  for each j      i   role chain


  
j is of the form j    
j  t   for some role chain j  r   next  consider the form of
xi in hsi   i   i i  xi hsi     i     i   i  by definition    only transitions in cases  r  and  ur 
read symbols from the input  so xi   r  ur   we show that the lemma holds in each case 
   

fithe complexity of answering cqs and gxqs over owl   el kbs

 case    consider the case in which xi   r   then  we have si   it and si     ft  
i   i     and t  r     r    due to t  
  and t     r   we have  v t  r  then  the
following is also a derivation of ps

  
  

hs    
          i        hsi   i       i i  

   



   

 the derivation from table   for  v t    
  

hsi        i   i        hsn     n i

    

where the derivation in     is defined in table   depending on the form of axiom  v t  r 
 case    consider the case in which xi   ur   then  we have si   i r and si     f r  
i   i   and t  r   then  the following is also a derivation of ps

  
  

hs    
          i        hsi   i       i i  
  

 the derivation seq      i   in        



  

hsi        i   i        hsn     n i
where the derivation seq       i   in      is inductively defined as follows 
 
hi r        i i  u  hf r        i i
if     
  
seq      i     
  
  
  
hi r        i i  ur hf r        i i  u  seq      i   if    p   

    
    
    

    

therefore  in either case  we have          l ps    as required 

   a polynomial space bcq answering algorithm for elro 
each elro  knowledge base k can be translated into a set of first order horn clauses  so
a boolean cq q over k can be answered by evaluating q over a so called canonical model 
a model that can be homomorphically embedded into any other model of k  canonical
models are usually obtained using chase  many different chase variants have been studied
in the literature  each producing a different  but homomorphically equivalent  canonical
model  johnson   klug        marnette        cal  gottlob    kifer        baget  leclere 
mugnier    salvat         in this paper  we introduce a variant that we call consequencebased chase  and the  possibly infinite  set of assertions ik it produces on k we call the
universal interpretation of k  to compute ik   consequence based chase initialises ik to
contain the abox of k  as well as assertions  a  a    c  a   and  r  a  b  for all individuals a
and b occurring in k  then  it iteratively extends ik using chase rules  the slightly unusual
aspect of our chase variant is that it considers the axioms entailed by  and not only contained
in  k  for example  if ik at some point contains assertion a w  and k    a v s b holds 
then ik is extended with assertions s w  w    and b w    where w  is a fresh term  term w  is
said to be auxiliary and have type s  b and concept type b  the bcq answering algorithm
we present in this section is based on checking consequences of k  so our chase variant
makes our proofs simpler  example    illustrates these aspects 
example     let k   ht   r  i be an elro  kb  where t contains axioms          
and r contains role inclusion      
 a  v s a
   

    

fistefanoni  motik  krotzsch    rudolph

a

b

s

s

  s  a

  s  a

a

s
t

  t  b

r

s

b

  s  b

s

s

s

  s  c

os a

s

s

t

ot b

os b

r
t

s

os c

t
s
s  a

s  a

 
t  b

universal interpretation

compact interpretation

figure    the universal interpretation and the compact interpretation for k
a v s a

    

 b  v s a

    

 b  v t b

    

 b  v s c

    

c v t b

    

c v r  b 

    

st vs

    

figure   shows the universal interpretation ik of k  assertions involving  c and  r are
not shown for clarity  the edges obtained via role inclusions are dashed  remaining edges
are solid  apart from the dotted edges  which denote repetition of solid edges  black edges
are obtained using conventional chase variants  whereas the light grey subbranches of ik
are caused by axioms entailed by  but not occurring in  k  auxiliary terms are labelled
using integers  and the terms type is shown next to each term  universal interpretation ik
can be viewed as a family of directed trees whose roots are the individuals in k and where
solid edges point from parents to children or to the individuals in k  axiom      makes ik
infinite  so a decision procedure for bcq answering cannot simply materialise ik and then
evaluate the query in it  instead  a finitary representation of ik is needed 
by axioms             and       we have k     b  v s b  but then  since  b  b   ik  
the consequence based chase ensures that  s b      b      ik holds as well  in contrast 
commonly considered chase variants do not ensure  s b      b      ik because k does not
contain axiom  b  v s b 
in the rest of this section  we present the first worst case optimal algorithm that decides
k    q given an arbitrary regular elro  kb k and a boolean cq q over k  towards this
goal  in section     we review the existing approaches to answering cqs in dls and discuss
   

fithe complexity of answering cqs and gxqs over owl   el kbs

why these techniques do not provide an optimal procedure for elro    in section    
we discuss the intuitions behind our algorithm  in section     we introduce the algorithm
formally and show that it runs in polynomial space in the combined size of k and q and in
polynomial time in the size of k  and in section     we prove the algorithms correctness 
    existing approaches to answering cqs
techniques for answering conjunctive queries over dl knowledge bases developed thus far
can be broadly classified into the following three groups 
the first group consists of automata based approaches for dls such as horn shiq
and horn sroiq  ortiz et al          sh  eiter  ortiz    simkus      a   and the fragment of elro  obtained by disallowing the universal role  reflexive roles  and self restrictions  krotzsch et al          all these techniques  however  require constructing automata
whose size can be exponential in the size of the knowledge base 
the second group consists of rewriting based approaches  roughly speaking  these approaches rewrite the query and or the tbox into another formalism  usually a union of
cqs or a datalog program  the relevant answers can then be obtained by evaluating the
rewriting over the abox  rewriting based approaches have been proposed for members
of the dl lite family  artale et al         calvanese et al          the dls el  rosati 
       elhio  perez urbina et al         mora  rosati    corcho        and hornshiq  eiter  ortiz  simkus  tran    xiao      b   and members of the datalog family  virgilio  orsi  tanca    torlone         to name just a few  no rewriting approach 
however  supports for both nominals and role inclusions  moreover  a common shortcoming
is that rewritings can be exponential in the query and or tbox size  so these approaches
may also use exponential space 
the third group consists of approaches based on a particular interpretation of k that
we call the compact interpretation  figure   shows this interpretation for the kb k from
example     it finitely approximates the universal interpretation by using individuals of the
form os b to represent all auxiliary terms of type s  b  the compact interpretation can thus
be materialised in space polynomial in  k   and it can be used to answer instance queries
and test atomic subsumptions over k  baader et al         krotzsch         materialising
the compact interpretation lies at the core of many reasoning algorithms for el variants  so
it is natural to try to use this interpretation for answering cqs as well  since the compact
interpretation is a model of k  each cq that maps on the universal interpretation maps on
the compact interpretation as well  however  as example    shows  the converse does not
necessarily hold 
example     let k be as in example     and let q    q    and q  be the following bcqs 
q    x  r x  b 

q    x  s a  x   s b  x 

q    x  t  b  x   s b  x 

the compact interpretation for k is shown in figure    as one can see  it is obtained from
the universal interpretation by merging all terms of type s  b onto the individual os b   now
query q  can be mapped onto both the compact and the universal interpretation  while queries
q  and q  can be mapped only onto the compact interpretation  thus  evaluating q  and q 
over the compact interpretation produces unsound answers 
   

fistefanoni  motik  krotzsch    rudolph

a

b

 a  a

b  b 

ax

y b

r
r d  

s

t b
 

s
s

s b  
s

r

t

t

t r a
 

t
t

s

  t b

t

t

t
t b
 

p
s
s

s

t b

t

 

s
  s b

s

s

p b  

s
s

t

t b   

universal interpretation

s
   s b

s

z b

skeleton for q

figure    the universal interpretation of k and the skeleton for q
as a remedy  combined approaches were developed that first evaluate the query in the
compact interpretation and then filter the results to eliminate unsound answers  such
approaches have been developed for members of the dl lite family  kontchakov et al  
      lutz  seylan  toman    wolter        and the el family  lutz  toman    wolter 
      stefanoni et al         of dls  and the datalog family  gottlob  manna    pieris 
      of rule based languages  in particular  stefanoni et al         developed a filtering
step applicable to the dl elhodr
   but this step breaks down if k contains role inclusions 
query q  from example    can be mapped onto the compact interpretation by mapping
atom s b  x  to a dashed edge  i e   to an edge obtained via role inclusions   moreover  q 
is tree shaped  and so the filtering step by stefanoni et al         does not identify this
match as unsound  this problem can be intuitively understood as follows  by unfolding
the query by       query q  essentially asks whether role chains    l s  and    l t  
exist that label a path of solid edges in ik starting at b  in the compact interpretation 
this is satisfied by     s  t and     t when x is mapped to individual ot b   individual
ot b   however  represents distinct terms   and   from ik   hence  although   is connected
to b via   and   is connected to b via     role chains   and   do not satisfy query q    in
other words  the compact interpretation is too small to represent the relevant conditions 
    intuitions
our worst case optimal procedure for bcq answering in elro  is shown in algorithm  
on page      it essentially extends and refines the algorithm by krotzsch et al          we
explain the underlying intuitions using the knowledge base shown in example    
example     let k be the elro  knowledge base whose tbox contains axioms         
and whose rbox contains role inclusions          
 a  v r a
a v t  b 
   

    
    

fithe complexity of answering cqs and gxqs over owl   el kbs

is

s  x x

fs

  x fs  x

it

t  x x

ft

  x x

figure    the transitions of r corresponding to axioms         
avd

    

 b  v t b

    

 b  v p b

    

b v s self

    

b v t b

    

t t vt

    

st vs

    

moreover  let q be the following boolean cq over k 
q   x  y  z  d x   t  x  z   s y  z 

    

figure   shows the universal interpretation ik for k  notation is as in example     the
solid looping edges on auxiliary terms of concept type b are obtained from axiom       one
can see that k    q holds  for example  the following substitution  embeds q into ik  
    x      y      z     

    

our algorithm uses the pda encoding of the rbox described in section    the transition
function r for axioms          is shown in figure    notation is the same as in example   
and note that figure   is contained in figure   
we must prove the existence of a substitution  mapping q into ik   such a substitution
 can map the binary atoms in q to the dashed edges in figure    dashed edges introduce
shortcuts between terms in ik   but each dashed edge can be unfolded into a path consisting
only of solid edges using the role inclusions in k  the solid paths in ik can be of two
types  auxiliary paths involve only auxiliary terms  whereas nominal paths require moving
through at least one individual  for instance  edge t        can be unfolded into the path
t   t  t  t connecting   with b  b with    and   with    in contrast  edge s       can
be unfolded into the path s   s  t connecting   with itself  and   with    our algorithm
then uses pdas with transition function from figure   to represent each binary atom in
q as a sequence of binary atoms to be mapped over the corresponding solid path in ik  
interpretation ik   however  is infinite  so the space of possible substitutions is also infinite 
hence  to prove the existence of a substitution  mapping q into ik   we cannot simply
enumerate all of them  and we use algorithm   instead 
   

fistefanoni  motik  krotzsch    rudolph

in line   we check whether k is unsatisfiable  if so  then k    q holds trivially  next 
in line   we guess a substitution  and continue checking k     q   thus  this step takes
into account that variables could be mapped to individuals  and that two variables could be
mapped to the same term  in our example  we can guess  to be the identity mapping on
 y   in step    we then guess a finite structure  called the skeleton for  q   which represents
a  possibly infinite  set of substitutions mapping the variables of  q  to distinct auxiliary
terms in ik   figure   shows the skeleton s for the query in example     skeleton vertices
are the individuals of k and the variables of  q   and they are arranged as a forest whose
roots are the individuals  moreover  each vertex v of s is assigned an atomic concept  v  
after this step  skeleton s represents each substitution   if any  satisfying the following
two properties 
    maps each variable x to a term of concept type  x   and
   for each edge hv  v   i in s  we have that   v     is a descendant of   v  in ik  
we next extend s with conditions that prune this set of substitutions  with the goal of
leaving only substitutions compatible with  q that is  that embed  q  into ik  
we establish compatibility with the unary atoms of  q  in line    in particular  consider
atom d x  in  q   by property      each substitution  represented by the skeleton in
figure   maps variable x to a term of concept type  x    a  implying that a   x    ik
holds  but then  since k     x  v d holds  we know that d   x    ik holds as well  thus 
atom d x  is satisfied for each substitution represented by s 
in contrast  we cannot establish compatibility of binary query atoms using entailment
checking only  because vertex labels and the relative position of vertices do not sufficiently
describe the substitutions  for example  substitution
     x      y      z      

    

satisfies properties     and      but t     x      z     ik  
to prune such substitutions  in lines     of algorithm   we guess for each binary atom
in  q  how to unfold it as a sequence of solid steps in ik   as solid paths in ik can go
through nominals or through auxiliary terms only  the two possibilities are accounted for
by the guessing in line    moreover  the skeleton already constrains the relative positions of
query terms  so we represent the unfolding of each binary atom by labelling each edge hv  v   i
in s with a set l v  v     of bounded stack pdas with transition function from figure   so
that each substitution  represented by s also satisfies the following property 
   for each pda p  l v  v      a nonempty role chain   l p  exists labelling a path in
ik over solid edges from   v  to   v     
we next illustrate how to label the edges of s so that all substitutions satisfying properties
       are compatible with each binary atom of  q  
for t  x  z   we must ensure that  for each substitution  represented by s  a role chain
t  l t   exists connecting   x  to   z  using only solid edges  since the relative positions
of   x  and   z  in ik is determined by s as shown in figure    such a path must connect
  x  with b  then connect b with   y   and finally connect   y  with   z   in addition  we
can assume that no individuals occur on paths from b to   y   and from   y  to   z   if a
   

fithe complexity of answering cqs and gxqs over owl   el kbs

 r

d
r

 a 

r

b
t

a

s  t

t  p
t

 b 

start

b

s

start

figure    on the left hand side  the walking finite automaton wfa a   b    transitions involving  c and  r are not shown for clarity   on the right hand side  the stationary finite automaton sfa b 

path from   x  to   z  involves individuals other than b or if it visits b more than once  we
can absorb all such path segments into the subpath from   x  to b  thus  we check the
existence of such t by setting v    au   b in lines     no guessing is possible in line   in
this case  and splitting in lines     the path t into the three subpaths  in particular 
in line    we guess states s    s    and s    ft and in line    we guess stack words        
and      with the following properties 
 i  the subpaths from   x  to b are described by pda pt  whose start state and stack are
it and   respectively  and the final state and stack are s  and     respectively 
 ii  the subpaths from b to   y  are described by pda pt  whose start state and stack are
s  and     respectively  and the final state and stack are s  and     respectively  and
 iii  the subpaths from   y  to   z  are described by pda pt  whose start state and stack
are s  and     respectively  and the final state and stack are s  and     respectively 
we do not know what terms of ik variables y and z should be mapped to  so we cannot
check the existence of paths in  ii  and  iii  independently  therefore  we add in line   
pdas pt  and pt  as constraints on edges hb  yi and hy  zi in s  respectively  the edges
of s thus accumulate all constraints that the moves to auxiliary terms must satisfy  later
we shall explain how in lines      we check these constraints and  if this check passes 
how we know that we can map y and z to auxiliary terms whose concept types are  y 
and  z   respectively  in contrast  the path in  i  finishes in an individual  so we can
check existence of such a path independently from any other constraint  to this end  we
construct the walking finite automaton wfa a   b   shown on the left hand side of figure
   such wfa a   b   describes the moves in ik from terms with concept type  x    a to
individual bthat is  such that   l wfa a   b    for each term w with concept type a
and for each role chain  connecting w to b in ik via solid edges  then  in line    we check
whether the intersection of the languages of wfa a   b   and pt  is empty  as wfa a   b  
is a fa and pt  is a pda  we can test the emptiness of the intersection of their languages in
polynomial time  hopcroft et al          in our example  we can guess s    s    s    ft  
   

fistefanoni  motik  krotzsch    rudolph

thus  pt  accepts the language t    and because b is connected to    y  by a solid edge
labelled by p   adding pt  as constraint on edge hb  yi ensures that substitution   from     
does not satisfy property     
for s y  z   we must ensure that  for each substitution  represented by s  a role chain
s  l s  exists connecting   y  to   z  using only solid edges  now even though z is a
descendant of y in s  in line   we could guess v    au   b  so that s connects   y  with b
and then  without going through individuals  connects b with   z  via   y   in the rest of
this paragraph  however  we consider the case in which s connects   y  with   z  directly 
since that is the only possibility in our example  as one can see in figure    therefore  in
line    we guess v    t   y  but then  a path from   y  to   z  could first loop on   y 
due to self restrictions  then it must actually move from   y  to   z   and finally it could
loop on   z   for reasons we discuss in the following paragraph  we absorb the latter loop
into a constraint added to edge hy  zi  however  we check the existence of the former loop
independently  therefore  in lines     we split s into two subpaths  in particular  in
line    we guess states s  and s    fs   and in line    we guess stack words   and     
with the following properties 
 i  the looping on   y  is described by pda ps  whose start state and stack are is and
  respectively  and the final state and stack are s  and     respectively  and
 ii  the subpaths from   y  to   z  that start with a move from   y   but possibly involve
looping on   z   are described by pda ps  whose start state and stack are s  and    
respectively  and the final state and stack are s  and     respectively 
as in the previous case  we check  ii  by adding ps  as constraint on edge hy  zi in s 
furthermore  we check the existence of a path in  i  by constructing the stationary finite
automaton sfa b  shown on the right hand side of figure    such sfa b  describes the
possible loops on terms with concept type  y    b  that is  such that   l sfa b   for
each term w with concept type b and for each role chain  corresponding to a  possibly
empty  loop on w  then  in line    we check whether the intersection of the languages
of sfa b  and ps  is empty  in our example  we guess s    s    fs   thus ps  accepts the
language s  t    whereas ps  accepts the language t   
before line     skeleton s represents all substitutions that are compatible with the
atoms in  q   but we must still show that at least one such substitution can be realised
by the universal interpretation ik   to this end  we apply algorithm   on page     to each
edge hv  v   i in the skeleton  and thus we check whether terms   v  and   v     in ik exist
that satisfy properties        for all pdas in l v  v      roughly speaking  we solve this
problem by running all pdas in parallel in lines     of algorithm    however  we cannot
materialise ik   so we exploit a property of our consequence based chase procedure  a term
w with concept type a is connected to a term w  with concept type b in ik using a solid
edge labelled by s if and only if k    a v s b  furthermore  the concept type of w fully
describes the solid paths to descendants of w  so we do not need to keep track of the actual
position in ik   instead  we use variable concept to keep track of the current terms concept
type  thus  in line   we check existence of edges in ik via entailment checking  after that 
for each pda  in line    we guess a state s and a stack  of the pda  in line    we check
whether the pda can perform the move  and in line    we actually move the pda  due to
   

fithe complexity of answering cqs and gxqs over owl   el kbs

self restrictions and reflexive roles  however  the pdas need not move in synchrony  after
each move over a solid edge  each of the pdas can independently loop on the current term 
to this end  in line    we guess a state s  and a stack    that the pda moves into after
looping  and in line    we check whether the pda can move from state s with stack  to
state s  with stack    using a role chain compatible with the concept type of the term the
pda is moving into  as given by the stationary finite automaton sfa d   because not all
pdas are required to loop  fa sfa d  accepts the empty word  algorithm   thus checks
loops only after each move  which is why line    in algorithm   is necessary  lines   
take into account that each of the pdas is nondeterministic and so it can initially make
several  transitions  note that an explicit check for  transitions is required only initially
since line    allows for possible  transitions after each move along a solid edge  finally  we
ensure termination of algorithm   by observing that  since the stack of each pda in l v  v    
is bounded  the number of current configurations of each of the pda is exponential  and
so the number of distinct tuples of the current pda configurations is exponential as well 
hence  the algorithm repeats computations after at most exponentially many steps  we
thus obtain a nondeterministic decision procedure running in polynomial space by using a
binary counter to stop the computation after all distinct configurations have been explored 
for the constraints added to s in the previous paragraphs  one can check that algorithm  
returns true on all edges of s  hence  k     q  holds  and thus k    q holds as well 
    formalisation
we now formalise the intuitions from the previous section  towards this goal  we fix a
normalised elro  kb k   ht   r  ai with a regular rbox r  we let qr   r   and r be
as specified in definition    and we let dr be the depth of r as specified in section    we
start by formalising the notion of a skeleton of a boolean cq 
definition     a skeleton for a boolean cq q    y     y   is a triple s   hv  e  i with
the following components 
   v   ik   y is the set of vertices 
   e  v   y is the set of edges such that the directed graph hv  ei is a forest whose
roots are precisely the elements of ik  
       y     c    ck is a function that maps the existential variables of q to atomic
concepts  for convenience   is extended to v by  v      v  for each v  ik  
a path in s is a nonempty sequence of  distinct  vertices v            vn such that n    and 
for each i      n      we have that hvi   vi   i  e 
please observe that  as k is in normal form  there exists at least one individual occurring
in k and thus v  i      we next generalise the notion of a pda encoding the rbox r
from definition   by allowing arbitrary start and final states as well as arbitrary start and
final stacks of size at most dr   these generalised pda will be used in our algorithm to
implement the splitting operation mentioned in section     
definition     for states s  s   qr and words       r with     dr and        dr   a
generalised pda for r is given by pda s    s            hqr   r   r   r   s    s       i 
   

fistefanoni  motik  krotzsch    rudolph

the following definition introduces automata that one can use to succinctly represent
the axioms that logically follow from k 
definition     let a and b be basic concepts  the walking finite automaton from a to
b is given by wfa a  b     hq  r   w   a  bi where q and w are as follows 
 q     c    ck  nk  
 w is the transition function containing d  w  c  s  for each role s  r and all
states c and d in q such that k    c v s d 
the stationary finite automaton for a is given by sfa a     h a   r   s   a  ai where s
contains a  s  a  s  for each role s  r with k    a v s self or k     v s 
boolean cqs can be answered by the nondeterministic procedure entails shown in algorithm    which uses an auxiliary procedure exist shown in algorithm    the following
theorem states that entails k  q  decides k    q  and its proof is given in section     
theorem     let q be a boolean cq over k  then  k    q if and only if a nondeterministic
computation exists such that entails k  q  returns true 
finally  we determine the complexity of the algorithm entails  and towards this goal we
first determine the complexity of the auxiliary function exist 
lemma     function exist a  b   pj   pda sj   j   s j   j         j  m   can be implemented so that it uses space polynomial in m   k  and  if the rbox r is fixed  it runs in
time polynomial in  t      a  
proof  consider arbitrary a  b  and pj   pda sj   j   s j   j    as stated above  let m be as
in algorithm    and let   be the derivation relation corresponding to r   by the definition
of generalised pdas  we have  j    dr and  j     dr for each j      m  
by proposition    using polynomial time one can compute pdas accepting languages
ldr  pda sj   j   s     and ldr  pda s    s          in lines   and     therefore  checks in lines
  and    can be implemented so that they use time  and therefore space  polynomial in
 k   hopcroft et al         ch     
for the space usage of algorithm    please observe that the function stores the following
information at each computation step 
 a  an array state of length m such that state j   qr for each j      m   an array stack of
length m such that stack j   r and  stack j    dr for each j      m  
 b  a generalised pda in line   
 c  a generalised pda and a stationary automaton in line    
 d  a concept concept   a   c    ck in line   
 e  a binary counter k such that    k  m   and
 f  the depth dr of r  an atomic concept d    c    ck   and a role s  r  
   

fithe complexity of answering cqs and gxqs over owl   el kbs

algorithm    entails k  q 
 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  

if k is inconsistent then return true
guess a substitution  with dom      y and rng     y  ik
guess a skeleton s   hv  e  i for  q 
if an atom a t  in  q  exists such that k      t  v a then return false
foreach hv  v   i  e do let l v  v        
foreach binary atom s t  u  in  q  do
let au be the unique individual such that u is reachable from au in s
guess v    t  au   such that u is reachable from v  in s
let v            vn be the unique path in s such that vn   u
guess states s            sn in qr such that sn   fs
guess words            n in r such that n    and  i    dr for each i      n 
foreach i      n  do let l vi    vi      l vi    vi     pda si    i    si   i   
if v   i then
if l wfa  t    v       l pda is     s            then return false
else
if l sfa  v       l pda is     s            then return false
foreach hv  v   i  e do
if not exist  v    v      l v  v      then return false
return true

algorithm    exist a  b   pj   pda sj   j   s j   j         j  m  
 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  

let concept    a and let m          ck      qr  m    r    dr  m
for j     to m do
guess a state s  qr and a word   r such that     dr
if    ldr  pda sj   j   s     then return false
set state j     s and stack j     
guess k  n such that    k  m
for r     to k do
guess s  r and d    c    ck
if k     concept v s d  or k    d v  a  for some a  ik then return false
for j     to m do
guess  s  s     qr and          r with     dr and        dr
if hstate j   s  stack j i    hs    i then return false
if l sfa d    ldr  pda s    s             then return false
set state j     s  and stack j       
set concept    d
if concept    b then return false
if there exists an index j      m  such that state j     s j or stack j     j  then
return false
return true

   

fistefanoni  motik  krotzsch    rudolph

by the definition of dr   we have that dr is linearly bounded by the number of axioms occurring in r  hence  we need at most o m   r   space to store the two arrays  furthermore  we
need at most o m   k   space to store the counter k using binary encoding  by definition
    the size of sfa d  is polynomial in  k   by definition    the size of pda s    s         is polynomial in  r   overall  the space needed to store the required information is polynomial in
m   k   finally  following krotzsch         we can realise the check in step   in polynomial
time  thus  exist can be implemented so that it uses space polynomial in m   k  
next  assume that the rbox r is fixed  then dr   qr   r   and r are all fixed as
well  moreover  m is bounded by the size of r and so it is fixed  and m is linear in the
size of t and a  thus  the number of alternatives in the nondeterministic step in line  
of algorithm   is fixed  so lines    require time polynomial in  t      a   furthermore 
instead of guessing k using the nondeterministic step    we can repeat lines     for each
k      m    which requires a linear number of iterations  to show that lines     can also
be implemented to run in polynomial time  we first define three sets which can be used to
perform the checks in lines        and    
 hs  c  di  r   ck  nk    c       k    c v s d and a  ik   k     d v  a       
 hs  pda s    s        i   for s  r with hs  s  i   hs         i      
 hc  pda s    s        i   for c  ck    c   with l sfa c    ldr  pda s    s                   
given that r is fixed  these sets can be computed in time polynomial in the size of t and
a  we next show that we can implement the for loop in steps     to use space logarithmic
in the size of t   a  and of the sets in equations           for the space usage in lines     
at each computation step of the for loop we store the information from points  a  f  above 
since r and m are fixed  however  points  a  c  require constant space  furthermore  the
checks in lines        and    can be performed by a lookup in sets           by storing
these sets using a suitable binary encoding and by using a binary index into the sets  this
check can be implemented using logarithmic space  finally  as ck and m are linear in the
size of t and a  we can store counter k  concepts d and concept  and role s using a binary
encoding  so the overall space the function needs to store is logarithmic in  t      a   and the
size of the sets           thus  steps     require nondeterministic logarithmic space  and
it is well known that this implies that steps     can be implemented to run in polynomial
time  finally  steps      clearly require polynomial time  consequently  function exist can
be implemented so that it runs in time polynomial in  t      a  for fixed r 
we are now ready to establish the complexity of function entails k  q   in section   we
shall show that our function is worst case optimal in combined and data complexities 
theorem     for q a bcq over k  function entails k  q  can be implemented so that
   it uses space polynomial in the input size 
   if the rbox r is fixed  it runs in nondeterministic polynomial time in the size of the
tbox t   the abox a  and the query q  and
   if the rbox r and the query q are fixed  it runs in  deterministic  polynomial time in
the size of the tbox t and the abox a 
   

fithe complexity of answering cqs and gxqs over owl   el kbs

proof  let q    y    y   be a boolean cq over k 
as shown in proposition    one can compute in lines    and    a pda accepting language
ldr  pda is     s         in polynomial time  so the checks in lines    and    require time
 and therefore space  polynomial in  k   hopcroft et al         ch      moreover  the checks
in lines   and   also require time polynomial in  k   krotzsch        
for      please observe that the function entails as specified in algorithm   stores the
following information at each computation step 
 a substitution  with dom      y and rng     y  ik  
 a skeleton s   hv  e  i for  q  
 a path v            vn in s  a sequence of states s            sn in qr   and a sequence of words
            n in r such that  i    dr for each i      n  
 a function l mapping each edge hv  v   i  e to a set of generalised pda  and 
 a walking automaton wfa  t    v     and a stationary automaton sfa  v     
by the definition of skeleton for  q   we need space polynomial in the size q and k to
store s  moreover  the length of the longest path in s is given by the number of variables
occurring in  q   so we can store the sequences of vertices  states  and words in space
polynomial in  q  and  k  as well  also  each set l v  v     contains at most m pdas  where
m is the number of binary atoms occurring in  q   then  by lemma     entails can be
implemented so that it uses space polynomial in the input size 
for      assume that the rbox r is fixed  by lemma     for a fixed rbox r  step   
can be implemented so that it runs in time polynomial in  t      a   clearly  all other steps
in algorithm   can be implemented to run in nondeterministic polynomial time in the size
of tbox t   abox a  and query q  consequently  for a fixed rbox r  function entails can
be implemented so that it runs in nondeterministic polynomial time in in the size of tbox
t   abox a  and query q 
for      assume that the rbox r and the query q are fixed  then dr   qr   r   and r
are all fixed as well  given that the number of variables occurring in q is fixed  the number
of guessing steps required in steps   and   is fixed  also  the number of alternatives for these
steps is linear in  t      a   thus  steps   and   require polynomial time  furthermore  the
maximum number of iterations of the for loop in steps     is fixed and the length of the
longest path in s is fixed  thus  the number of guessing steps in lines    and    is also
fixed  in addition  the number of alternatives for the guessing steps in lines        and   
is fixed as well  therefore  steps     require time polynomial in  t      a   finally  since
the query is fixed  the maximum number of iterations of the for loop in steps    and   
is also fixed and so  by lemma     steps    and    require time polynomial in t and a 
therefore  entails can be implemented so that it runs in time polynomial in  t      a  for
fixed r and q 

   

fistefanoni  motik  krotzsch    rudolph

    proof of theorem   
we now prove that our function entails k  q  indeed decides k    q  towards this goal  we
start by proving the correctness of function exist  after which we introduce the universal
interpretation of k  and  finally  we show that entails is sound and complete 
      correctness of exist
the following proposition proves the correctness of function exist from algorithm   
lemma     function exist a  b   pj   pda sj   j   s j   j         j  m   returns true if
and only if there exist a natural number k     roles s            sk   basic concepts a            ak
with a    a and ak   b  and role chains  j i   j      m  and i      k   such that the
following conditions hold for each i      k  and each j      m  
   for each a  ik   we have k    ai  v si  ai and k     ai v  a  
   for each role t occurring in j i   we have k    ai v t self or k     v t  
   s   j      sk  j k  ldr  pj   
proof  consider arbitrary a  b  and pj   pda sj   j   s j   j    as stated in the lemma  moreover  let   be the derivation relation corresponding to r  
   assume that there is a nondeterministic computation of exist such that the function
returns true  let k  n be as guessed in step    we show that the for loop in steps    
satisfies the following invariant  after each iteration r  there exist roles s            sr   basic
concepts a            ar   and  for each j      m   role chains j             j r such that a    a 
ar   concept  and the following holds for each i      r  and j      m  
 i  k    ai  v si  ai and  for each a  ik   we have k     ai v  a  
 ii  for each role t occurring in j i   we have k    ai v t self or k     v t  
 iii  s   j      sr  j r  ldr  pda sj   j   state j   stack j    
base case  before the first iteration of the loop  i e   after steps    and for r      
we have concept   a  and   ldr  pda sj   j   state j   stack j   for each j      m   so
properties  i  iii  clearly hold 
inductive step  consider an arbitrary iteration r      k     and assume that properties
 i  iii  hold at the end of iteration r  we show that the same is true after iteration r     
by the inductive hypothesis  there exist roles s            sr   basic concepts a            ar   and  for
each j      m   role chains j             j r such that a    a  ar   concept and properties
 i  iii  hold  let role sr     s and atomic concept ar     d be as guessed in step   
clearly  we have k    concept v sr    ar   and that k     ar   v  a  for each a  ik   as
required for property  i   furthermore  consider an arbitrary j      m   let s  s      and
   be as guessed in step     and let state j  and stack j  be as at the end of iteration r 
then  hstate j   sr     stack j i   hs    i due to step     furthermore  due to step     a role
chain j r   exists such that j r    l sfa d    ldr  pda s    s           by definition   
of stationary automata  for each role t occurring in j r   we have k    d v t self or
   

fithe complexity of answering cqs and gxqs over owl   el kbs

k     v t   as required for property  ii   finally  let state j  and stack j  be as specified
in step     then s   j      sr  j r  sr    j r    ldr  pda sj   j   state j   stack j     so
property  iii  holds 
step    ensures that concept   b  furthermore  steps      ensure that state j    s j and
stack j    j  for each j      m   so pda pj accepts s   j      sk  j k   thus  properties
       of this lemma hold  as required 
   let s            sn be roles  let a            an be basic concepts with a    a and an   b 
and let j i be role chains satisfying properties        of this lemma  each derivation for
s   j      sn  j n of pda pj is of the following form  where sj n     s j and j n     j   
hsj   s   j      sn  j n   j i  
hs j    

hsj     s   j      sn  j n   j   i  

j    s     sn  j n  

hsj     s   j      sn  j n   j   i  

 
j  
i

    



    



    

       

    

 

     
hs j i  

hsj i   si  j i    sn  j n   j i i  

j i  si      sn  j n  

hsj i     si    j i    sn  j n   j i   i  
hs j n  

hsj n   sn  j n   j n i  
hsj n       j n   i

j n  

    



 
j i
i
 
j n
i

 



 

    
    

transition from      to      is special in the sense that it allows pj to make an arbitrary
number of  transitions  the rest of the derivation is regular and consists of reading si and
j i   thus  sj i and s j i are the states of pj before and after  respectively  reading si   and
  are the respective stacks  by property     of this lemma  we have      d
j i and j i
j i
r
 
and  j i    dr  
let xi   hai   s  i     i           sm i   m i i  for each pda  there are  qr   many different
p r
 r    many difstates     ck   different elements in   c  ck   furthermore  there are d   
pdr
ferent stacks of length at most dr   as  r       and dr      we have      r      r    dr  
consequently  there are at most m distinct such tuples  thus  for some k  m   we have that
xk   xn     but then  ak   b  furthermore  for each j      m   we have sj k   sj n     s j
and j k   j n     j    so we have s   j      sk  j k  ldr  pj   
we can now easily construct a nondeterministic computation of exist as follows  in
step    for each j we let s   sj   and    j     clearly  condition in step   is not satisfied 
for each r in the for loop in lines      we proceed as follows 
 in step   we let s   si and d   ai   respectively  clearly  condition in step   is not
satisfied due to property     
    and      
 for each j      m   we let s   s j r   s    sj r        j r
j r     clearly 
condition in step    is not satisfied due to the form of the derivation  furthermore 
condition in step    is not satisfied due to property     and definition    

finally  conditions in steps    and    are not satisfied due to the way in which we chose k 
therefore  function exist returns true in step    

   

fistefanoni  motik  krotzsch    rudolph

rule
 cr  
 cr  

 cr  

 cr  
 cr  

 cr  

 cr  

precondition
k    a  u a  v b
 a   w   a   w    i
k    a v s b
k    b v  a  for some a  ik
a w   i
k    a v s b
k     b v  a  for each a  ik
a w   i
k    s a v b
 s w  w     a w      i
k    s self v b
s w  w   i
role s is simple
k    a v s self
a w   i
role s is simple
  l s 
 w  w     i

conclusion
b w 
s w  a   b a 

s w  fs b  w    b fs b  w  
 c  fs b  w     r  fs b  w   fs b  w  
 r  fs b  w   w    for each term w  occurring in i
 r  w    fs b  w   for each term w  occurring in i
b w 
b w 

s w  w 

s w  w   

table    rules of the consequence based chase
      consequence based chase and universal interpretations
to prove that entails k  q  is sound and complete  we interpret k using the forest shaped
universal interpretation described in section      towards this goal  we next define some
auxiliary notions  then define the universal interpretation  and  finally  we prove two properties of such interpretation 
the universe of k is the set of all terms built from the individuals occurring in k and the
unary function symbols of the form fs a with s  r and a  ck   since k is normalised 
the universe of k is nonempty  a fact is a ground atom constructed using the predicates
occurring in k and the terms from the universe of k  for a role chain    s     sn   terms
w and w    and a set of facts i  we write  w  w     i if  not necessarily distinct  terms
w   w            wn   w  exists such that si  wi    wi    i for each i      n   a set of facts
i entails a boolean cq q    y     y    written i    q  if a substitution  exists such that
dom       y and   q   i  the universal interpretation ik of k is defined as follows 
definition     a chase rule from table   is applicable to a set of facts i if the preconditions
of the rule are satisfied  but i does not contain all conclusions of the rule  a consequencebased chase  often just chase  for k is a sequence of sets of facts i    i          where
i      a  a    c  a    r  a  b     a  b   ik    a

    

and  for each i     set ii   is obtained by extending ii with the conclusion of one  arbitrarily
chosen  chase rule applicable to ii   and ii     ii if no chase rule is applicable to ii   this
   

fithe complexity of answering cqs and gxqs over owl   el kbs

sequence must be fairthat is  if a derivation rule is applicable to some ii for a specific
precondition  then j  i exists suchsthat ij   is obtained from ij by applying the rule to the
mentioned precondition  set ik   in ii is a universal interpretation of k 
since k is in normal form  we have k      a  v  b  for all distinct individuals a and
b in ik   hence  at most one individual a  ik exists in rule  cr   such that k    b v  a  
because of that  it is straightforward to see that ik is independent from the order in which
the chase rules are applied  so we call ik the universal interpretation of k  moreover 
due to fairness  no derivation rule is applicable to ik that is  for each chase rule from
table   either the preconditions of the rule are not satisfied in ik   or ik contains all the
conclusions of the rule  finally  it is well known that  if k is consistent  then ik can be
homomorphically embedded into any model of k  krotzsch et al          consequently  the
universal interpretation ik can be used to answer arbitrary boolean cqs over k 
fact     for each boolean cq q  we have k    q if and only if k     c v c or ik    q 
next  we show how ik relates to the axioms entailed by k  to this end  let  be the
following function mapping each term w in the universe of k to a basic concept 
 
 w  if w  i
 w    
a
if w is of the form w   fs a  w   
proposition     the universal model ik satisfies the following properties 
   for each a w   ik   we have k     w  v a 
   for each s w  w     ik   a nonempty role chain       s        m   sm  m with
  l s  and terms w            wm from the universe of k with w    w and wm   w 
exist such that
 a  for each i      m   either wi  ik   or an atomic concept ai    c    ck exists
such that wi   fsi  ai  wi    and k     ai v  a  for each individual a  ik  
 b  for each i      m   we have k     wi    v si   wi    and
 c  for each i      m  and each role t occurring in i   we have k     wi   v t self
or k     v t  
proof  let i    i          be a chase sequence for k  we show by induction on rule applications that properties     and     are satisfied for each a w   in and each s w  w     in  
respectively  and that in additionally satisfies the following property 
   for each term w occurring in in   we have k    x  w  x  
by the definition of i  and  cr    for each in and all terms w and w  occurring in in   we
clearly have   c  w    r  w  w      r  w    w    in  
base case  consider i    and note that each term w occurring in i  is an individual so
 w     w   consider some a a   i    then either a a   a  a    a   or a    c   so we
have k     a  v a  and property     holds  furthermore  consider some s a  b   i    then
   

fistefanoni  motik  krotzsch    rudolph

s a  b   a or s    r   so we have k     a  v s  b   and property     holds for w    a 
w    b  and    s  finally  property     holds because k    x  a  x  for each a  ik  
inductive step  assume that some in satisfies properties         by considering each
derivation rule  we assume that the rule is applicable to in as shown in table    and we
show that properties        hold for all conclusions of the rule  note that only rule  cr  
can affect property      and we do not explicitly consider properties that hold vacuously 
 cr   by the inductive hypothesis  we have k     w  v a  and k     w  v a    which
implies k     w  v b  as required for property     
 cr   by the inductive hypothesis  we have k     w  v a and k    x  w  x   which
clearly imply k     w  v s b and k    x b x   moreover   a     a   so k     a  v b 
and property     holds  finally  since k     w  v s  a   property     holds for w    w 
w    a  and    s 
 cr   let w     fs b  w   by the inductive hypothesis  we have k     w  v a and
k    x  w  x   so we have k     w  v s b and k    x b x   moreover   w       b  so
k     w     v b  k     w     v  c   and k    x  w     x   as required for properties     and
     respectively  for property      we consider all role assertions derived by the rule 
 s w  w      note that k     w  v s  w     and k     b v  a  for each a  ik   so
property     holds for w    w  w    w     and    s 
  r  w     w      clearly  property     holds for w    w   and         r  
  r  w     w    for some term w  occurring in in   let a be the individual that w  is rooted
in  then   r  a  w     in so  by the inductive hypothesis  a role chain   l  r   and
terms a   w            wm   w  exist satisfying properties  a  c   since k    x  w     x  
we have k     w     v  r   a   thus   r   and w     w            wm satisfy property     
  r  w    w     for some term w  occurring in in   then   r  w    w   in so  by the inductive
hypothesis  a role chain   l  r   and terms w    w            wm   w exist satisfying
properties  a  c   but then     r and w            wm   w   satisfy property     
 cr   by the inductive hypothesis  we have k     w    v a  moreover  terms w            wm
with w    w and wm   w  and a nonempty role chain       s        m   sm  m with
  l s  exist satisfying properties  a  c   by the definition of l s   we have k     v s 
together with the entailments in properties  b  and  c   we have k     w  v s  w     but
then  we have k     w  v s a  which implies k     w  v b  as required for property     
 cr   by the inductive hypothesis  a nonempty role chain   l s  exist satisfying
properties  a  c   moreover  k     v s by the definition of l s   role s is simple  so
        and therefore  can have one of the following two forms 
      and     t   by property  c   we have k     w  v t self or k     v t  
furthermore  due to k     v s  we have k    t v s  but then  k     w  v s self 
and so k     w  v b holds  as required for property     
    s    terms w  and w  satisfying property     are then both equal to w  moreover 
w  is not of the form fs   a   w   so w  ik   furthermore  by property  b  we have
   

fithe complexity of answering cqs and gxqs over owl   el kbs

k     w  v s    w   together with w  ik   we have k     w  v s   self  finally 
due to k     v s  we have k    s  v s  but then  k     w  v s self  and so
k     w  v b holds  as required for property     
 cr   by the inductive hypothesis  we have k     w  v a  from which we can conclude
k     w  v s self  so property     holds for w    w and        s 
 cr   if      then w   w  and k     v s  and property     holds for w    w
and        s  otherwise  assume that  is nonempty and of the form    s     sk  
thus  terms w            wk with w    w and wk   w  exist such that si  wi    wi    in for
i
each i      k   by the inductive hypothesis  for each i      k   terms w i           wm
with
i
i
i
i
i
w    wi  and wmi   wi and a role chain  with   l si   exist satisfying properties
k
i    w i for each
 a  c   note that w i   w    w  that wm
  wk   w    and that wm
 
i 
k
 
k
i      k   by the definition of l s   then       l s   and so property     holds for
            wk           wk  
role chain      k and terms w    w             wm
mk
 
 
      soundness
we are now ready to show that our algorithm entails is sound 
lemma     if a nondeterministic computation exists such that entails k  q  returns true 
then k    q 
proof  assume that a nondeterministic computation exists such that entails k  q  returns
true  if our algorithm returns true in step    then k    q  as k is inconsistent  hence  in the
rest of this proof  we assume that k is consistent and show that ik    q  to this end  let
substitution   skeleton s   hv  e  i  and function l be as determined by entails  graph
hv  ei is a forest rooted in the individuals occurring in k so  by structural induction on this
forest  we define mapping  from v to the universe of k that will satisfy the following 
 i  for each v  v   we have  v    v    ik   and
 ii  for each hv  v   i  e and each pj  l v  v      a role chain j  l pj   exists such that
j    v     v       ik  
base case  for each a  ik   let   a    a  since  a     a  and  a  a   ik   the first
property clearly holds  and the second property is vacuous 
inductive step  consider hv  v   i  e such that   v  has been defined  but   v     has not 
let l v  v        p            pm    since exist  v    v      l v  v      returns true  by lemma   
we have that roles s            sn   atomic concepts a            an   and  for each j      m   a role
chain j   s   j      sn  j n exist such that n     a     v  and an    v      and the
following holds for each i      n  and each j      m  
   for each a  ik   we have k    ai  v si  ai and k     ai v  a  
   for each role t occurring in j i   we have k    ai v t self or k     v t  
   j  ldr  pj   

   

fistefanoni  motik  krotzsch    rudolph

let w      v   let wi   fsi  ai  wi    for i      n   and let   v       wn   since a     v   by
the inductive hypothesis we have a     v    ik   furthermore   cr   is not applicable to
ik so  for each i      n   we have si  wi    wi    ik and ai  wi    ik   thus     v       ik  
as required  finally  for each role t occurring in each j i   we have k    ai v t self or
k     v t    cr   and  cr   are not applicable to ik   respectively  so we have t  wi   wi    ik  
thus  we have j    v     v       ik   as required 
we next show that    q    ik by considering independently each atom in  q   to
prove the lemma  we can combine  and  in the obvious way 
consider an arbitrary unary atom a t  in  q   by step   of algorithm    we have
k     t  v a  which also implies k     t  u  t  v a  by property  i   we have
 t    t    ik   since rule  cr   is not applicable to ik   we have a   t    ik   as required 
consider an arbitrary binary atom s t  u  in  q   let v            vn   s            sn   and
            n be as determined in steps     when algorithm   considers atom s t  u   for each
i      n   we have pda si    i    si   i    l vi    vi   by step     but then  by property  ii 
a role chain i exists such that i  l pda si    i    si   i    and i    vi       vi     ik  
next  we define   by considering the following two cases 
 v   i  by step    of algorithm    a role chain     s     sk exists such that
   l wfa  t    v       by property  i   we have  t    t    ik   moreover  by definition     basic concepts  t    a    a            ak    v    exist with k    aj  v sj  aj
for each j      k   rules  cr   and  cr   are not applicable to ik   so we have
     t     v      ik  
 v    i  which implies v    t  by step    of algorithm    a role chain     t     tk
exists such that    l sfa  v       by property  i   we have  v      v      ik  
moreover  by definition     k     v    v tj  self or k     v tj for each j      k  
rules  cr   and  cr    respectively  are not applicable to ik   thus      t     v      ik  
in either case  by steps    and    we have    l pda is     s          now let          n  
note that we can have n      in which case         clearly  we have      t     vn     ik  
where vn   u  moreover     l pda is     sn   n    with sn   fs and n     finally 
rule  cr   is not applicable to ik   so s   t     u    ik   as required 
      completeness
we next prove that our encoding is also complete  thus proving theorem    
lemma     if k    q  then a nondeterministic computation exists such that entails k  q 
returns true 
proof  assume that k    q  if k is inconsistent  then entails k  q  returns true  as required 
hence  in the rest of this proof  we assume that k is consistent  but then  ik    q  so a
substitution  exists such that  q   ik   let  be as defined in section       
for the substitution  in step    let  y      y  if  y   i  otherwise  let  y  be an
arbitrary  but fixed  variable y   from q such that  y     y      it is straightforward to see
that   q    ik  

   

fithe complexity of answering cqs and gxqs over owl   el kbs

for the skeleton s   hv  e  i in step    set v contains ik and the variables occurring
in  q   and  y      v   for each variable y  v   furthermore  let  be the smallest
irreflexive and transitive relation on the universe of k such that w  fs a  w  for each term
w in the universe of k  then  let hv  v   i  e if and only if  v    v     and no v     v exists
such that  v    v        v      by the definition of   graph hv  ei is a forest rooted in
ik   as required by definition    
in step    for an arbitrary atom a t  in  q   we have a  t    ik   by property     of
proposition     we have k      t   v a  hence  the condition is not satisfied 
now consider an arbitrary edge hv  v   i  e  and let w            wk be terms  let a            ak
be atomic concepts  and let s            sk be roles such that w     v   wk    v      and
wi   fsi  ai  wi    for each i      k   finally  let a     v   note that all of these are
uniquely defined by the edge  and that  by the construction of ik   for each i      k   we have
k    ai  v si  ai and k     ai v  a  for each a  ik   then  a role chain  is compatible
with the edge hv  v   i if role chains             k exists such that    s        sk  k and  for
each i      k  and each role t occurring in i   we have k    ai v t self or k     v t  
in the rest of this proof we will show the following property 
   for each pda p  l v  v      a role chain   l p  exists that is compatible with the
edge hv  v   i 
by lemma    and the above definition of compatibility  property    implies that the
condition in step    is not satisfied for edge hv  v   i 
for the loop in steps      let s t  u  be an arbitrary binary atom in  q   we next
determine the required nondeterministic choices that preserve    in step     and that
satisfy conditions in steps    and     which completes the proof of this lemma  let au  ik
be the unique individual connected to u in hv  ei  since s  t    u    ik   a nonempty
role chain       s        m   sm  m with   l s  and terms w            wm from the
universe of k with w     t  and wm    u  exist satisfying property     of proposition    
to define vertex v  in step    we consider two possibilities  and for each we also define an
index         m  such that w      v    
 if some j      m  exists such that wj  ik   let v    au and let    be the largest index
such that w     au  
 otherwise  let v    t and let        
let v            vn be the unique path connecting v  to u in s  by the definition of    and the
form of the terms w                wm   we have wj   i for each j           m    v      w    
and  vn     wm   thus  for each i      n   a unique index  i exists such that  vi     w i  
now let          s         and let i   s i       i        s i   i for each i      n  
clearly          n   by properties  a  c  of proposition     for each i      n   role chain
i is compatible with the edge hvi    vi i  furthermore    l s  and theorem   imply
  ldr  pda is     fs       and so states s            sn with sn   fs and words             n with
n    exist such that    ldr  pda is     s         and i  ldr  pda si    i    si   i   for
each i      n   since each i is compatible with hvi    vi i  step    preserves property    
as required  finally  we consider step    

   

fistefanoni  motik  krotzsch    rudolph

 v   i  by property  b  of proposition     k     wj    v sj   wj   for each j           
furthermore  by property c of proposition     k     wj   v t self or k     v t for
each j           and each role t occurring in j   thus  k     wj   v t  wj    but
then     l wfa  t    v       so condition in step    is not satisfied 
 v    i  so v    t and         by property  c  of proposition     k     wj   v t self
or k     v t for each role t occurring in     but then     l sfa  v       so
condition in step    is not satisfied 

   the lower complexity bound
in the previous section  we presented a bcq answering algorithm for elro  that uses
space polynomial in the total size of the input  this algorithm is worst case optimal in
combined complexity since krotzsch et al         reduced the pspace hard problem of
checking nonemptiness of the intersection of the languages generated by m deterministic
finite automata f        fm over a common alphabet   kozen        to bcq answering in
elro    in the knowledge base k encoding the problem  a regular rbox contains roles
s        sm such that l si     l fi   for each i      m   furthermore  a tbox ensures that
the universal interpretation ik is a rooted tree so  for each      a term w exists that
is reachable from the root by a chain t
of roles corresponding to   finally  a boolean cq
contains m atoms that check whether i l fi   is nonempty  we next improve this lower
bound by showing that the problem is hard already in the restricted setting where the query 
the tbox  and the abox are all fixed  and just the rbox varies 
theorem     for k a regular elro  knowledge base and q a boolean conjunctive query 
checking k    q is pspace hard even when
 the query is fixed and consist of two binary atoms over a single quantified variable 
 the tbox is fixed and contains only axioms of the form a v s a  and
 the abox is fixed and contains a single unary assertion 
proof  we reduce the pspace hard problem of deciding whether the intersection of the
languages generated by m deterministic finite automata is nonempty  kozen         let
  be deterministic finite automata over alphabet     let  and  be fresh symbols
f             fm
 
 
not occurring in     and let                 for each j      m   let fj   hqj     j   ij   fj i
be the deterministic finite automaton over alphabet  obtained by extending fj  with a
transition labelled by   from the final state fj  of fj  to t
itself  and with a transition labelled
 
 
by t
  from fj to a fresh final state fj of fj   then 
j       if and only if a word
t j l f
 
w  j l fj   exist such that  w  is odd  given w  j l fj    if  w  is odd  then  w        
is odd and w        l fj   for each j      m   and if  w  is even  then  w      is odd and
w     l fj   for each j      m   finally  we assume w l o g  that qi  qj     and qi  r
hold for each    i   j  m  and that   r as well 
let w   st     sn be a word in  such that n is odd  and let      q          qm  
clearly  w  j l fj   holds if and only if a word w   of the form
n
n
w   e      e m  s   o m    o    s   e      e m       e n     en 
m  sn  om    o 

   

    

fithe complexity of answering cqs and gxqs over owl   el kbs

exists such that the following conditions hold for each j      m  
i
 i  for each i      n  with i odd  we have oij  qj and j  ei 
j   si     oj  
i
 ii  for each i      n  with i even  we have eij  qj and j  oi 
j   si     ej   and

 iii  e j   ij and onj   fj  
now let lo   le   l    and l  be the following languages 
lo    e     em  s  om    o    s   and j  ej   s    oj   for each j      m  

    

le    om    o   s  e     em   s   and j  oj   s    ej   for each j      m  

    



l     lo     lo

    


l     i     im       le       fm    f   

    

consider an arbitrary word w   and the corresponding word w     by the definition
of l    we have that w  l  if w is of the form      and it satisfies property  i   similarly 
by the definition of l    we have that w  l  if w is of thet form      and it satisfies
properties  ii  and  iii   thus  w  l   l  if and only if w  j l fj    for simplicity  in
the rest of this proof  we will use the following equivalent formulations of l  and l   
l   lo   lo      lo

    
 

l    i     im       fm    f      i     im       le       fm    f   

    

twe next define a knowledge base k and a fixed query q such that k    q if and only
if j l fj        we will present our construction in stages  and for each we will describe
how it affects the canonical model i   hi   i i of kthat is  the model constructed using
the standard notion of chase  i e   as in definition     but with all semantic conditions on
k replaced by the syntactic checks for axioms in k   for simplicity  we first present k in
which the tbox depends on   and later we modify the encoding to use a fixed tbox 
the tbox t contains axioms       and the abox a contains only axiom       we
assume that ai   a   then  for each word      a domain element a exists that is
connected to a via a chain of roles corresponding to  
a v a

for each symbol   

    

a a  

    

we next present an rbox r consisting of four parts  each encoding languages lo   le  
s m  
s m
l    and l    our encoding uses fresh roles ls  
and ls  
uniquely
o           lo
e           le
 
associated with each role s    as well as fresh roles lo   le   l   l    l    l    and l    
the first part of r contains axioms           it should be clear that  for all words
        where   is a prefix of     we have ha    a  i  lio if and only if       lo  
s v ls m  
o
ej 

ls j  
o

 oj v

ls j
o

s  

    

j      m  s   ej   oj  qj with j  ej   s    oj

    

ls  
o v lo

    
   

fistefanoni  motik  krotzsch    rudolph

the second part of r contains axioms           it should be clear that  for all words
        where   is a prefix of     we have ha    a  i  lie if and only if       le  

oj 

s j 
le

s v ls  
e

s  

    

ls j
e

j      m  s   ej   oj  qj with j  oj   s    ej

    

 ej v

ls m
v le
e

    

the third part of r contains axioms           it should be clear that  for all words
        where   is a prefix of     we have ha    a  i  li  if and only if       l   
s v l

s  

    

lo v l 

    

l  
l  

    

v l 

    

lo  l v
l    l  
l    lo

v

    

the fourth part of r contains axioms           it should be clear that  for all words
        where   is a prefix of     we have ha    a  i  li  if and only if       l   
i     im  l  fm    f  v l 

    

l  
l  

    
    

 l  fm    f  v l 

    

l  le v
l  
i     im 

l  



l  

v

query q is given in       then  k    q if and only if a word    exists such that
ha   a i  li  and ha   a i  li    and the latter is clearly the case if and only if   l   l   
rbox r is regular and of size polynomial in the size of automata f            fm  
q   y  l   a   y   l   a   y 

    

we next tighten this reduction to use the fixed tbox t   consisting of axioms          
where p  and p  are fresh roles 
a v p   a

    

a v p   a

    

now let k   dlog    e  and assume that each symbol    corresponds to a k digit binary
number b     bk with bi          then  let r  be r extended with axioms      
pb      pb k v 

for each    corresponding to b     bk

    

finally  let k    ht     r    ai  and let i   be the canonical model of k    axioms            
and      ensure existence of a binary tree whose edges are labelled with roles p  and p   
furthermore  axioms      ensure that  for each    and each sequence of k edges in this
tree corresponding to the binary number assigned to   there is a shortcut in the tree
   

fithe complexity of answering cqs and gxqs over owl   el kbs

labelled with   thus  i can be homomorphically embedded into i     finally  roles p  and
p  do not occur in r and query q checks for existence of a domain element connected to a  
therefore  the extra edges in i   are irrelevant  consequently  the encoding of languages l 
and l  works in the same way as with the varying tbox t  
finally  we characterise the complexity of bcq answering over elro  knowledge bases 
theorem     for k a regular elro  kb and q a boolean cq  checking k    q is
   ptime complete in data complexity 
   np complete  if the rbox r is fixed  and
   pspace complete in combined complexity 
proof  calvanese et al         proved that bcq answering is ptime hard in data complexity already for el knowledge bases  furthermore  when the query is not fixed  bcq
answering is np hard already over relational databases  chandra   merlin         then
the theorem follows by theorems    and     and by savitchs theorem 

   navigational queries
the data in dl knowledge bases has graph like structure  where unary assertions encode
properties of graph nodes and binary assertions encode graph edges  conjunctive queries
cannot express recursive properties such as reachability  and so their expressivity is often insufficient in applications that require graph navigation  as the popularity of graph
databases is on the rise  a number of navigational languages for querying graph like data
have been proposed  for example  regular path queries  barcelo        use regular expressions to express complex navigational patterns between graph vertices  and graph xpath
queries  libkin et al         extend regular path queries with the converse operator  negation on regular expressions  and checking properties of vertices using boolean combinations
of concepts and existential quantifications over paths  in the dl context  the computational complexity of navigational queries has been studied for several expressive dls and
members of the dl lite family and the el h  fragment of elro   calvanese  eiter   
ortiz        bienvenu et al         kostylev et al         bienvenu et al          in order to
complete the complexity landscape of this problem  in this section we study the problem of
answering graph xpath queries over elro  knowledge bases 
    graph xpath queries
graph xpath queries consist of node expressions and path expressions  whose syntaxes are
defined respectively by the following two context free grammars for b a basic concept and
s a role 
  b                    hi
  s   s                         test  
following libkin et al          we consider the following expression fragments 
   

fistefanoni  motik  krotzsch    rudolph

p e
 

p

g

p

p f
 

s d
 

r s

a

r

b

u
p

s d
 

s

s a
 

s

u

p a
 

s

f

p

r s

c
b

r

d

r s

e

s

p e
 

figure    interpretation i
   the path positive fragment disallows path expressions of the form  
   the positive fragment disallows path expressions of the form  and node expressions
of the form  
   the converse free fragment disallows path expressions of the form s   
a graph xpath atom has the form  s  or  s  t   for  a node expression   a path
expression  and s and t terms  a conjunctive graph xpath query  cgxq  g is an expression
g    y     x   y   where  is a conjunction of graph atoms over variables  x   y   variables  x
are called the answer variables of g  if  x     then g    y     y   is a boolean cgxq 
path positive  positive  and converse free cgxqs are obtained by restricting query atoms
accordingly  finally  a graph xpath query  gxq  is a cgxq containing a single atom 
to define the semantics of cgxqs  let i   hi   i i be a first order interpretation  the
interpretation of node and path expressions in i is inductively defined as follows 
  i
       i
       i
 hi i

 
 
 
 

i     i
    i      i
    i      i
 x  i   y  i   hx  yi  i  

 s   i
       i
        i
   i
  i
 test   i

 
 
 
 
 
 

 hy  xi   hx  yi  s i  
    i      i
    i      i
 i  
i  i     i
 hx  xi   x  i  

please observe that the difference of path expressions   and   corresponds to          
whereas the intersection of   and   corresponds to           moreover  libkin et al 
       define a path expression   which in our setting corresponds to test  c    satisfaction
of a boolean cgxq g in i and cgxq entailment are defined in the obvious way  moreover 
boolean cgxq answering is the problem of checking k    g 
example     we illustrate these definitions using interpretation i shown in figure   
notation is as in example     moreover  let         and   be the following path expressions 
    r  test hs   test a  b i  

    

    u  test hp  test a  b i  

    

   

fithe complexity of answering cqs and gxqs over owl   el kbs

node expressions
tb    b v cb  
t       c  u c  v c       t   t 
t       c  v c      c  v c       t   t 
thi    t   c v chi    t
path expressions
ts   
t      t   t 
t       t   t 
t   t
ttest      c v ttest    self   t

rb   
r      r   r 
r      r   r 
rhi   r

rs    s v ts  
r       t   t  v t       r   r 
r        t  v t       t  v t        r   r 
r     v t   t v t   t  t v t    r
rtest     r

table    encoding positive  converse free node and path expressions using axioms
     r  s   

    

expression   is positive  and it retrieves all pairs of individuals that are connected by a
path of r edges such that  for each element occurring in the path other than the first  there
exists an outgoing path of s edges reaching a member of concept a t b  for example  we
have  hai   di i  hai   ei i       i  
in contrast  expression   is path positive  and it retrieves all pairs of individuals that
are connected by a u  edge such that no p  successor exists that is a member of concept atb 
for example  we have hai   g i i      i   but hai   f i i       i  
finally  expression   is neither positive nor path positive  and it retrieves all pairs of
individuals that are connected by a path not consisting of a sequence of edges described by
the regular expression  r  s    for example  we have hai   di i      i   but hai   ei i       i  
let g   x  y  z    x  y      x  z      x  y  be a conjunctive graph xpath query  and let
    x   a  y   d  z   g  be a substitution  using figure    one can check that i     g  
as observed by kostylev et al          node expressions in graph xpath queries correspond precisely to formulas in propositional dynamic logic with negation  pdl    harel
et al          the satisfiability problem for pdl is undecidable  harel         so answering
gxqs under dl constraints is undecidable  decidability results have been recently obtained for path positive and positive queries over dl lite knowledge bases  kostylev et al  
       in addition  kostylev et al         proved that  for all dls  answering path positive 
converse free gxqs is conp hard in data complexity  finally  bienvenu et al         proved
that answering positive gxqs over el knowledge bases is exptime complete  thus  in
the rest of this section we focus on positive  converse free graph xpath queries 
    complexity of answering positive  converse free graph xpath queries
in the rest of this section  we fix an elro  kb k   ht   r  ai such that r is regular 
we next show that  given a positive  converse free boolean cgxq g  one can construct in
polynomial time a regular elro  kb k  and a boolean cq q   such that k    g if and
only if k     q     our construction of k  combines various expressive features of elro   
   

fistefanoni  motik  krotzsch    rudolph

role inclusions and reflexive roles encode the path expressions of g in the rbox  and selfrestrictions encode the node expressions of g in the tbox 
proposition     given a positive  converse free boolean cgxq g over k  one can compute
in time polynomial in  k     g  an elro  kb k  and a boolean cq q   such that the rbox
of k  is regular  g and q   have equally many atoms  and k    g if and only if k     q    
proof  let g    y     y   be a positive  converse free boolean cgxq over k  for each
positive node expression   let c be a fresh atomic concept uniquely associated with 
and  for each positive  converse free path expression   let t be a fresh role uniquely
associated with   by structural induction  we associate with each   resp    a tbox
t and an rbox r  resp  a tbox t and an rbox r   as shown in table    then  let
k    ht  t     r  r    ai where tbox t   and rbox r  are as follows 
 
 
 
 
t  
t 
t
r   
r 
r
 s 

 s t 

 s 

 s t 

now let q      y        y   be the boolean cq where    contains c  s  for each atom  s   
and t  s  t  for each atom  s  t     clearly  g and q   have the same number of atoms 
moreover  since query g is over k  query q   is over k    finally  both q   and k  can be
computed in polynomial time in the input size  and the rbox of k  is clearly regular  we
next show that k      q   if and only if k     g 
   assume that k      q     so an interpretation i exists such that i    k  and i     q    
since each axiom of k is also an axiom of k    we have that i    k  furthermore  for
each positive node expression  and positive path expression   we have i   c  i and
i   t  i   we prove this claim by simultaneous induction on the structure of node and
path expressions 
base case  for the base case  let  be an arbitrary node expression of the form    b and
let  be an arbitrary path expression of the form    s  since b v cb  t     s v ts  r   
and i is a model of k    the claim easily follows 
inductive step  for the inductive step  we distinguish two cases 
first  consider an arbitrary node expression  such that the property holds for all node
and path expressions occurring in   then let x be an arbitrary element of i and assume
that x  i   we show that x  ci by considering the various forms that  can take 
           since x  i   we have x  i  and x  i    by the inductive hypothesis 
we have x  ci  and x  ci    by the definition of t     we have c  u c  v c  t    
since i is a model of t     we have x  ci   as required 
           the proof for this case is similar to the one above 
    hi  since x  i   there exists y  i such that hx  yi  i   by the inductive
hypothesis  we have hx  yi  ti   by the definition of t     we have t   c v c  t    
since i is a model of t     we have x  ci   as required 
second  consider an arbitrary path expression  such that the property holds for all
node and path expressions occurring in   then let x and y be arbitrary elements of i
and assume that hx  yi  i   we show that hx  yi  ti by considering the various forms
that  can take 
   

fithe complexity of answering cqs and gxqs over owl   el kbs

           since hx  yi  i   there exists z  i such that hx  zi   i and
hz  yi   i   by the inductive hypothesis  we have hx  zi  ti  and hz  yi  ti   
moreover  by the definition of r    we have t   t  v t  r    since i is a model of
r    we have hx  yi  ti   as required 
            since hx  yi  i   we have that hx  yi   i or hx  yi   i   by the
inductive hypothesis  we have hx  yi  ti  or hx  yi  ti    by the definition of r    we
have  t  v t   t  v t    r    since i is a model of r    we have hx  yi  ti  
        first  consider the case in which x   y  by the definition of r    we have
 v t  r    since i is a model of r    we have hx  yi  ti   as required  otherwise 
consider the case in which x    y  since hx  yi  i   elements x            xn with x    x
and xn   y exist in i such that n     and hxi    xi i   i for each i      n   by the
inductive hypothesis  for each i      n   we have hxi    xi i  ti    by the definition
of r    we have t   t  v t  r    since i is a model of r    we have hx  yi  t  
    test    it follows that x   y and that x  i   by the inductive hypothesis  we
have x  ci   by the definition of t     we have c v t  self  t     since i is a model
of t     we have hx  yi  ti   as required 
but then  since node and path expressions in g are positive  i     q   implies i     g 
i 

   assume that k     g  so an interpretation i exists such that i    k and i     g  let
be the interpretation obtained by extending i to the fresh concepts and roles as follows 
 

 c  i   i

 

 

 t  i   i

 

by the definition of k    it is straightforward to see that i      k    furthermore  by the
definition of q     it is straightforward to see that i       q     as required 
next  we establish the complexity of answering positive  converse free  c gxqs over
elro  knowledge bases 
theorem     for k a regular elro  kb and g a positive  converse free boolean cgxq 
checking k    g is ptime complete in data complexity  and pspace complete in combined
complexity  for g a positive  converse free boolean gxq  checking k    g is ptimecomplete in combined and data complexities 
proof  the hardness in data complexity of boolean positive  converse free  c gxqs follows
from the ptime hardness of instance checking in el  calvanese et al         
for positive  converse free gxqs  hardness in combined complexity is inherited from the
ptime hardness of tbox reasoning in el  baader et al          for the matching upper
bounds  proposition    allows us to reduce boolean gxq answering to checking entailments
of the form k     q   where q   is a bcq containing only one atom  we next show that  for
each possible form of q     we can reduce the latter problem to checking entailment of elro 
concept inclusions  which can be decided in ptime  in the following  c is an arbitrarily
chosen individual from ik   
 k     a a  if and only if k      a  v a 
   

fistefanoni  motik  krotzsch    rudolph

 k     y a y  if and only if k      c  v  r  a 
 k     s a  b  if and only if k      a  v s  b  
 k     y s y  b  if and only if k      c  v  r  s  b  
 k     y s a  y  if and only if k      a  v s  c  
 k     y    y   s y    y    if and only if k      c  v  r  s  c  
for positive  converse free cgxqs  hardness in combined complexity is given by theorem     and the matching upper bounds follow from theorem    and proposition    

   conclusions
in this paper  we presented the first cq answering algorithm for owl   el that runs
in pspace  thus closing a longstanding open question  our algorithm is based on an
innovative  succinct encoding of regular role inclusions using bounded stack pdathat is 
finite automata extended with a stack of fixed size  we believe this encoding is interesting
in its own right  as it can be used to optimise popular owl   dl reasoners  moreover  we
refined the previously known pspace lower bound for cq answering by showing that the
problem remains pspace hard even if the query  the tbox  and the abox are all fixed  and
only the rbox varies   thus  we identify role inclusions as the only culprit for the problems
pspace hardness  finally  we showed that positive  converse free gxqs and cgxqs can
be answered over owl   el knowledge bases in ptime and pspace  respectively  this is
interesting because bienvenu et al         have showed that adding the converse operator
makes the problem exptime hard  thus  at least from a theoretical perspective  positive 
converse free  c gxqs seem to provide an adequate language for querying owl   el
knowledge bases 
we see two main open problems for our future work  first  by drawing inspiration
from the succinct encoding of role inclusions  we shall extend the combined approach by
stefanoni et al         to owl   el and thus obtain a practical algorithm  second  as static
query analysis is a fundamental task in query optimisation  we shall study the containment
problem for graph queries under elro  constraints 

acknowledgements
the results in this article are an extension of the results that were published in preliminary form by krotzsch et al         in the proceedings of the  th international semantic
web conference  iswc        this work was supported by alcatel lucent  the eu fp 
project optique  the epsrc projects masi    score   and dbonto  and the dfg project
diamond  emmy noether grant kr           

references
anselmo  m   giammarresi  d     varricchio  s          finite automata and non selfembedding grammars  in proceedings of the  th international conference on im 

   

fithe complexity of answering cqs and gxqs over owl   el kbs

plementation and application of automata  ciaa    pp        berlin  heidelberg 
springer verlag 
artale  a   calvanese  d   kontchakov  r     zakharyaschev  m          the dl lite family
and relations  j  artif  intell  res   jair           
baader  f   brandt  s     lutz  c          pushing the el envelope  in kaelbling  l  p  
  saffiotti  a   eds    proceedings of the   th international joint conference on artificial intelligence  ijcai        pp          edinburgh  uk  morgan kaufmann
publishers 
baader  f   brandt  s     lutz  c          pushing the el envelope further  in clark  k  
  patel schneider  p  f   eds    in proceedings of the owled      dc workshop
on owl  experiences and directions 
baader  f   calvanese  d   mcguinness  d   nardi  d     patel schneider  p  f   eds   
        the description logic handbook  theory  implementation  and applications 
cambridge university press  paperback edition 
baget  j  f   leclere  m   mugnier  m  l     salvat  e          on rules with existential
variables  walking the decidability line  artif  intell                        
barcelo  p          querying graph databases  in hull  r     fan  w   eds    pods  pp 
        acm 
barrett  c   jacob  r     marathe  m          formal language constrained path problems 
siam j  comput                  
bienvenu  m   calvanese  d   ortiz  m     simkus  m          nested regular path queries
in description logics  in proc  of the   th int  conf  on the principles of knowledge
representation and reasoning  kr        aaai press 
bienvenu  m   ortiz  m     simkus  m          conjunctive regular path queries in
lightweight description logics  in rossi  f   ed    ijcai  ijcai aaai 
cal  a   gottlob  g     kifer  m          taming the infinite chase  query answering under
expressive relational constraints  j  artif  intell  res   jair              
calvanese  d   de giacomo  g   lembo  d   lenzerini  m   poggi  a   rodriguez muro  m  
rosati  r   ruzzi  m     savo  d  f          the mastro system for ontology based
data access  semantic web              
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          data
complexity of query answering in description logics  in proc  of the   th int  conf 
on the principles of knowledge representation and reasoning  kr        pp     
    
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          tractable
reasoning and efficient query answering in description logics  the dl lite family  j 
autom  reasoning                 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          data
complexity of query answering in description logics  artificial intelligence          
    

   

fistefanoni  motik  krotzsch    rudolph

calvanese  d   de giacomo  g   lenzerini  m     vardi  m  y          containment of
conjunctive regular path queries with inverse  in proc  of the  th int  conf  on the
principles of knowledge representation and reasoning  kr        pp         
calvanese  d   eiter  t     ortiz  m          regular path queries in expressive description
logics with nominals  in boutilier  c   ed    ijcai       proceedings of the   st
international joint conference on artificial intelligence  pasadena  california  usa 
july              pp         
calvanese  d   vardi  m  y   de giacomo  g     lenzerini  m          view based query
processing for regular path queries with inverse  in proceedings of the nineteenth acm
sigmod sigact sigart symposium on principles of database systems  pods
    pp        new york  ny  usa  acm 
chandra  a  k     merlin  p  m          optimal implementation of conjunctive queries in
relational data bases  in hopcroft  j  e   friedman  e  p     harrison  m  a   eds   
proc  of the  th annual acm symposium on theory of computing  stoc      pp 
      boulder  co  usa  acm press 
cruz  i  f   mendelzon  a  o     wood  p  t          a graphical query language supporting
recursion  sigmod rec                  
cuenca grau  b   horrocks  i   motik  b   parsia  b   patel schneider  p  f     sattler  u 
        owl    the next step for owl  j  web sem                 
de giacomo  g   lembo  d   lenzerini  m   poggi  a   rosati  r   ruzzi  m     savo  d  f 
        mastro  a reasoner for effective ontology based data access  in horrocks 
i   yatskevich  m     jimenez ruiz  e   eds    ore  vol      of ceur workshop
proceedings  ceur ws org 
eiter  t   ortiz  m     simkus  m       a   conjunctive query answering in the description
logic sh using knots  j  comput  syst  sci                
eiter  t   ortiz  m   simkus  m   tran  t  k     xiao  g       b   query rewriting for
horn shiq plus rules  in hoffmann  j     selman  b   eds    aaai  aaai press 
fan  w          graph pattern matching revised for social network analysis  in deutsch 
a   ed    icdt  pp       acm 
geffert  v   mereghetti  c     palano  b          more concise representation of regular
languages by automata and regular expressions  information and computation          
       
giese  m   calvanese  d   haase  p   horrocks  i   ioannidis  y   kllapi  h   koubarakis  m  
lenzerini  m   moller  r   rodriguez muro  m   ozcep  o   rosati  r   schlatte  r  
schmidt  m   soylu  a     waaler  a          scalable end user access to big data  in
akerkar  r   ed    big data computing  crc press 
glimm  b   lutz  c   horrocks  i     sattler  u          conjunctive query answering for
the description logic shiq  j  artif  intell  res   jair              
gottlob  g   manna  m     pieris  a          polynomial combined rewritings for existential
rules  in proc  of the   th int  conf  on the principles of knowledge representation
and reasoning  kr        aaai press 
   

fithe complexity of answering cqs and gxqs over owl   el kbs

gottlob  g     schwentick  t          rewriting ontological queries into small nonrecursive
datalog programs  in brewka  g   eiter  t     mcilraith  s  a   eds    principles of
knowledge representation and reasoning  proceedings of the thirteenth international
conference  kr       rome  italy  june              aaai press 
grosof  b  n   horrocks  i   volz  r     decker  s          description logic programs  combining logic programs with description logic  in proceedings of the   th international
conference on world wide web  pp       
gutierrez  c   hurtado  c  a   mendelzon  a  o     perez  j          foundations of
semantic web databases  j  comput  syst  sci                  
harel  d          dynamic logic  in gabbay  d     guenthner  f   eds    handbook of
philosophical logic vol  ii  pp          reidel publishing company 
harel  d   tiuryn  j     kozen  d          dynamic logic  mit press  cambridge  ma 
usa 
hopcroft  j  e   motwani  r     ullman  j  d          introduction to automata theory 
languages  and computation   international edition     ed   addison wesley 
horrocks  i   kutz  o     sattler  u          the even more irresistible sroiq  in doherty 
p   mylopoulos  j     welty  c  a   eds    kr  pp        aaai press 
horrocks  i     sattler  u          decidability of shiq with complex role inclusion axioms 
artificial intelligence                  
johnson  d  s     klug  a  c          testing containment of conjunctive queries under
functional and inclusion dependencies  j  comput  syst  sci                  
kazakov  y          riq and sroiq are harder than shoiq  in brewka  g     lang 
j   eds    kr  pp          aaai press 
kontchakov  r   lutz  c   toman  d   wolter  f     zakharyaschev  m          the combined approach to ontology based data access  in walsh  t   ed    ijcai      
proceedings of the   nd international joint conference on artificial intelligence 
barcelona  catalonia  spain  july              pp            ijcai aaai 
kostylev  e  v   reutter  j  l     vrgoc  d          xpath for dl lite ontologies  in
bienvenu  m   ortiz  m   rosati  r     simkus  m   eds    informal proceedings of
the   th international workshop on description logics  vienna  austria  july       
       vol       of ceur workshop proceedings  pp          ceur ws org 
kozen  d          lower bounds for natural proof systems  in focs  pp          ieee
computer society 
krotzsch  m          efficient rule based inferencing for owl el  in walsh  t   ed   
proceedings of the   nd international joint conference on artificial intelligence  ijcai     aaai press ijcai           
krotzsch  m   rudolph  s     hitzler  p          conjunctive queries for a tractable fragment
of owl      in aberer  k   choi  k  s   noy  n   allemang  d   lee  k  i   nixon  l  
golbeck  j   mika  p   maynard  d   mizoguchi  r   schreiber  g     cudre mauroux 
p   eds    proceedings of the  th international semantic web conference  iswc    
vol       of lncs  pp          springer 
   

fistefanoni  motik  krotzsch    rudolph

libkin  l   martens  w     vrgoc  d          querying graph databases with xpath  in
tan  w  c   guerrini  g   catania  b     gounaris  a   eds    icdt  pp         
acm 
lutz  c          the complexity of conjunctive query answering in expressive description
logics  in automated reasoning 
lutz  c   seylan  i   toman  d     wolter  f          the combined approach to obda 
taming role hierarchies using filters  in alani  h   kagal  l   fokoue  a   groth  p  t  
biemann  c   parreira  j  x   aroyo  l   noy  n  f   welty  c     janowicz  k   eds   
international semantic web conference      vol       of lecture notes in computer
science  pp          springer 
lutz  c   toman  d     wolter  f          conjunctive query answering in the description logic el using a relational database system  in boutilier  c   ed    ijcai
      proceedings of the   st international joint conference on artificial intelligence 
pasadena  california  usa  july              pp           
marnette  b          generalized schema mappings  from termination to tractability  in
paredaens  j     su  j   eds    pods  pp        acm 
mora  j   rosati  r     corcho  o          kyrie   query rewriting under extensional
constraints in elhio  in mika  p   tudorache  t   bernstein  a   welty  c   knoblock 
c  a   vrandecic  d   groth  p  t   noy  n  f   janowicz  k     goble  c  a   eds   
the semantic web   iswc          th international semantic web conference  riva
del garda  italy  october              proceedings  part i  vol       of lecture notes
in computer science  pp          springer 
ortiz  m   calvanese  d     eiter  t          data complexity of query answering in expressive description logics via tableaux  j  autom  reasoning               
ortiz  m   rudolph  s     simkus  m          query answering in the horn fragments of the
description logics shoiq and sroiq  in walsh  t   ed    ijcai       proceedings of the   nd international joint conference on artificial intelligence  barcelona 
catalonia  spain  july              pp            ijcai aaai 
perez  j   arenas  m     gutierrez  c          nsparql  a navigational language for rdf 
web semant                 
perez urbina  h   motik  b     horrocks  i          tractable query answering and rewriting
under description logic constraints  j  applied logic                
rodriguez muro  m     calvanese  d          high performance query answering over
dl lite ontologies  in brewka  g   eiter  t     mcilraith  s  a   eds    principles of
knowledge representation and reasoning  proceedings of the thirteenth international
conference  kr       rome  italy  june              aaai press 
rosati  r          on conjunctive query answering in el  in calvanese  d   franconi  e  
haarslev  v   lembo  d   motik  b   turhan  a  y     tessaris  s   eds    description
logics  vol      of ceur workshop proceedings  ceur ws org 
rudolph  s     glimm  b          nominals  inverses  counting  and conjunctive queries or 
why infinity is your friend   j  artif  intell  res   jair              
   

fithe complexity of answering cqs and gxqs over owl   el kbs

simanck  f          elimination of complex rias without automata  in kazakov  y  
lembo  d     wolter  f   eds    proceedings of the      international workshop
on description logics  dl       rome  italy  june             vol      of ceur
workshop proceedings  ceur ws org 
sirin  e   parsia  b   cuenca grau  b   kalyanpur  a     katz  y          pellet  a practical
owl dl reasoner  j  web sem               
stefanoni  g   motik  b     horrocks  i          introducing nominals to the combined
query answering approaches for el  in desjardins  m     littman  m  l   eds   
aaai  aaai press 
ter horst  h  j          completeness  decidability and complexity of entailment for rdf
schema and a semantic extension involving the owl vocabulary  web semantics 
science  services and agents on the world wide web                 
tsarkov  d     horrocks  i          fact   description logic reasoner  system description  in furbach  u     shankar  n   eds    ijcar  vol       of lecture notes in
computer science  pp          springer 
urbani  j   van harmelen  f   schlobach  s     bal  h  e          querypie  backward
reasoning for owl horst over very large knowledge bases  in aroyo  l   welty  c  
alani  h   taylor  j   bernstein  a   kagal  l   noy  n  f     blomqvist  e   eds   
international semantic web conference      vol       of lecture notes in computer
science  pp          springer 
vardi  m  y          the complexity of relational query languages  extended abstract   in
proceedings of the fourteenth annual acm symposium on theory of computing  stoc
    pp          new york  ny  usa  acm 
venetis  t   stoilos  g     stamou  g  b          incremental query rewriting for owl   ql 
in kazakov  y   lembo  d     wolter  f   eds    proceedings of the      international
workshop on description logics  dl       rome  italy  june             vol      of
ceur workshop proceedings  ceur ws org 
virgilio  r  d   orsi  g   tanca  l     torlone  r          nyaya  a system supporting the
uniform management of large sets of semantic data  in kementsietsidis  a     salles 
m  a  v   eds    ieee   th international conference on data engineering  icde
       washington  dc  usa  arlington  virginia       april        pp           
ieee computer society 
wessel  m          obstacles on the way to qualitative spatial reasoning with description
logics  some undecidability results  in working notes of the      international
description logics workshop  dl        vol      ceur ws org 

   

fi