journal artificial intelligence research                  

submitted        published      

iterative plan construction workflow satisfiability problem
david cohen
jason crampton
andrei gagarin
gregory gutin
mark jones

d c ohen   rhul   ac   uk
jason  c rampton   rhul   ac   uk
ndrei  g agarin   rhul   ac   uk
g g utin   rhul   ac   uk
ark  j ones   rhul   ac   uk

royal holloway  university london  uk

abstract
workflow satisfiability problem  wsp  problem practical interest arises whenever tasks need performed authorized users  subject constraints defined business
rules  required decide whether exists plan assignment tasks authorized
users constraints satisfied  natural see wsp subclass
constraint satisfaction problem  csp  variables tasks domain set
users  makes wsp distinctive number tasks usually small compared number users  appropriate ask constraint languages wsp
fixed parameter tractable  fpt   parameterized number tasks 
novel approach wsp  using techniques csp  enabled us design generic
algorithm fpt several families workflow constraints considered literature 
furthermore  prove union fpt languages remains fpt satisfy simple compatibility condition  lastly  identify new fpt constraint language  user independent constraints  includes many constraints interest business processing systems 
demonstrate generic algorithm provably optimal running time   k log k   
language  k number tasks 

   introduction
workflow formalises business process  collection interrelated tasks performed
users order achieve objective  many situations  wish restrict users
perform certain tasks  particular  may wish specify lists users authorized
perform workflow tasks  additionally  may wish either particular
requirements business logic security requirements prevent certain combinations
users performing particular combinations tasks  crampton         constraints include
separation of duty  also known two man rule   may used prevent sensitive
combinations tasks performed single user  binding of duty  requires
particular combination tasks executed user  use constraints workflow
management systems enforce security policies studied extensively last fifteen
years  example see work bertino  ferrari  atluri         crampton        wang
li        
    workflow satisfiability problem
possible combination constraints authorization lists unsatisfiable 
sense exist assignment users tasks contraints satisfied
c
    
ai access foundation  rights reserved 

fic ohen   c rampton   g agarin   g utin     j ones

every task performed authorized user  perhaps minimal example requirement
two tasks performed user intersection authorization lists
tasks empty  plan satisfies constraints allocates authorized user task said
valid  workflow satisfiability problem  wsp  takes workflow specification input
returns valid plan one exists null value otherwise  important determine whether
business process satisfiable not  since unsatisfiable one never completed without
violating security policy encoded constraints authorization lists  wang li       
shown  reduction g raph c oloring  wsp np hard subclass
csp  even consider binary separation of duty constraints  nevertheless  practical
applications wsp  require solving algorithm efficient possible  crampton  
gutin             
many hard problems become less complex natural parameter instance bounded 
hence  say problem input size n parameter k fixed parameter tractable  fpt 
admits algorithm running time o f  k nd    constant independent n k 
f computable function depending k  
wang li        first observe fixed parameter algorithmics appropriate
way study wsp  number tasks usually small often much smaller
number users   the literature directly support assumption  although widely cited
study  schaad  moffett    jacob        found number users exceeds job functions 
roles  multiplicative factor around     finding confirmed recent followup study  jayaraman  ganesh  tripunitara  rinard    chapin        workflow specification
usually concerned particular business objective involve small number roles 
taking roles proxy tasks  seems reasonable assume number users
order magnitude greater number tasks   believe  therefore  appropriate
extend work initiated wang li use fixed parameter algorithms solving
wsp parameterized number tasks  and  particular  ask constraint languages
fixed parameter tractable 
wang li        proved that  general  wsp w    hard thus highly unlikely
admit fixed parameter algorithm  showed wsp fpt consider
separation of duty binding of duty constraints  crampton  gutin  yeo        obtained significantly faster fixed parameter algorithms applicable regular constraints  thereby
including cases shown fpt wang li  work  recent research 
demonstrated existence fixed parameter algorithms wsp presence constraint types  crampton  crowston  gutin  jones    ramanujan        crampton   gutin        
define wsp formally introduce number different constraint types  including regular
constraints  section   
use notation  suppresses polynomial factors 
is 
g n  k  m     h n  k  m   exists polynomial q n  k  m  g n  k  m   
o q n  k  m h n  k  m    particular  fpt algorithm one runs time  f  k  
computable function f depending k 

   introduction fixed parameter algorithms complexity found in  example  books downey
fellows         niedermeier  niedermeier        

   

fii terative p lan c onstruction w orkflow atisfiability p roblem

    relation wsp csp
constraint satisfaction problem  csp  general paradigm expressing  declarative
format  problems variables assigned values domain  assignments
constrained restricting allowed simultaneous assignments sets variables 
model useful many application areas including planning  scheduling  frequency assignment
circuit verification  rossi  van beek    walsh         csp community well established
research community dedicated finding effective solution techniques csp  dechter        
csp np hard  even binary not equals constraints allowed domain
three elements  reduce g raph   c oloring csp    hence  considerable
effort made understand effect restricting type allowed constraints  recently significant progress towards completion research program
strong evidence support algebraic dichotomy conjecture bulatov  jeavons
krokhin         characterising precisely kinds constraint language lead polynomial
solvability 
worth noting wsp subclass csp variable  called task
wsp terminology  arbitrary unary constraint  called authorization  assigns
possible values  called users  s  called conservative csp  note  however 
usually csp number variables much larger number values  wsp
number tasks usually much smaller number users  important remember
wsp use term constraint authorizations define special
types constraints  extend types authorizations  remain arbitrary 
    outline paper
novel approach wsp using techniques csp  characterising types constraints
constraint languages particular characteristics  enables us generalise unify existing
algorithms  so  paper  first time  rather considering algorithms specific
constraints  design generic algorithm fixed parameter algorithm several families
workflow constraints considered literature  particular introduce notions userindependent constraints  subsume number well studied constraint types wsp
literature  including regular constraints studied crampton et al         
generic algorithm builds plans incrementally  discarding partial plans never satisfy
constraints  based naive algorithm  presented section      naive algorithm
stores far information required solve wsp  running time better
exhaustively searching valid plan 
generic algorithm uses general classic paradigm  retain little information possible every step algorithm  paradigm used classical polynomial time algorithms gaussian elimination solving systems linear equations constraint propagation
algorithms  used  example  solve  sat polynomial time   generic algorithm uses
paradigm problem specific way  based concepts extension equivalence  planindistinguishability patterns  enabling us retain single pattern equivalence class
indistinguishable plans  extension equivalence plan encodings described section   
way solution constructed algorithm quite unusual accumulation
   wang lis np hardness result wsp thus restatement well known result csp 

   

fic ohen   c rampton   g agarin   g utin     j ones

 representatives of  set solutions goes along users  i e   values csp   along tasks
 i e   variables csp  
analyze running time algorithm introduce notion diversity  see definition     notion reminiscent pathwidth  measures taken prefixes largest
outcome diversity  difference diversity based number equivalence classes  hiding actual structure behind scenes  approach might useful
structural analysis hypergraphs 
section    describe pattern based algorithm demonstrate fixedparameter algorithm wsp user independent constraints  show running time
algorithm   k log k   wsp user independent constraints
algorithm running time   o k log k    wsp user independent constraints unless
exponential time hypothesis   eth  fails  thus  unlike wsp regular constraints
 and problems studied bodlaender  cygan  kratsch    nederlof        fomin  lokshtanov   
saurabh         wsp user independent constraints highly unlikely admit algorithm
running time   o k     show generic algorithm interest constraints
user independent  prove generic algorithm single exponential algorithm
constraint language obtained equivalence relation set users 
section   show generic algorithm deal unions constraint languages 
leads generalisation result user independent constraints  section   discuss
results computational experiments using implementation algorithm  discussed
full detail work cohen  crampton  gagarin  gutin    jones         brief conclusion
given section   

   background
define workflow schema tuple  s  u  a  c   set tasks workflow 
u set users     a s    s   a s  u authorization list task s 
c set workflow constraints  workflow constraint pair c    l     l
set functions l u   l scope constraint  specifies assignments
elements u elements l satisfy constraint c 
given x u   plan function   x  given workflow constraint  l    
x u   plan   x satisfies  l    either l       l  
  plan   x eligible satisfies every constraint c  plan   x
authorized  s  a s    plan valid authorized eligible  plan
  u called complete plan  algorithm solve wsp takes workflow schema
 s  u  a  c  input outputs valid  complete plan  one exists  and null  otherwise  
running example  consider following instance wsp 
instance    task set    s            s    user set u    u            u     authorization
lists follows  where tick indicates given user authorized given task  
   exponential time hypothesis claims algorithm running time   o n     sat n variables  impagliazzo  paturi    zane        

   

fii terative p lan c onstruction w orkflow atisfiability p roblem

s 
s 
s 
s 

u 
 

u 
 
 
 
 

u 

u 

u 

u 

 
 

 
 

 
 

 

constraints follows  s  s  must assigned user  s  s  must
assigned different users  s  s  must assigned different users  s  s  must
assigned different users 
example   illustrates meanings eligible  complete authorised plans context
instance   
example    following table gives assignments four plans                 

 
 
 
 

s 
u 
u 
u 
u 

s 
u 
u 
u 

s 
u 
u 
u 
u 

s 
u 
u 
u 
u 

authorized
 
 
 

eligible
 
 
 

complete
 
 
 

  complete plan authorized eligible  s  s  assigned
different users 
  complete plan eligible authorized  u  authorized s   
  plan authorized eligible  therefore valid  however   
complete plan assignment s   
  complete plan eligible authorized  thus   valid complete plan 
therefore solution 
algorithm runs instance  s  u  a  c  wsp  measure running
time terms n    u    k    s      c    the set authorization lists consists k
lists size n  need consider size separately measuring
running time   say algorithm runs polynomial time running time
p n  k  m   p n  k  m  polynomial n  k m 
    wsp constraints
paper interested complexity wsp workflow constraint language
 the set permissible workflow constraints  restricted  section introduce constraint
types interest  practical applications real world workflows 
assume constraints authorizations checked polynomial time 
means takes polynomial time check whether plan authorized  eligible valid 
correctness algorithm unaffected assumption  choosing constraints
checkable polynomial time would naturally affect running time 
   

fic ohen   c rampton   g agarin   g utin     j ones

      c onstraints efined b inary r elation
constraints two tasks  s    represented form  s  s       binary
relation u  crampton         plan satisfies constraint  s   s     writing
  denote relation   u  u    u u      denote relation   u  v    u  v u  u    v  
separation of duty binding of duty constraints may represented form  s  s       
 s  s        respectively  crampton et al         considered constraints  
equivalence relation defined u   practical example workflow constraints
equivalence relation partitions users different departments  constraints could
enforce two tasks performed members department  constraints
restricted singleton tasks considered  crampton et al         wang   li        
plan satisfies constraint form  s            tasks s    s     
 s     s     
      c ardinality c onstraints
tasks per user counting constraint form  t    tr          t    tr   k s 
plan satisfies  t    tr     user performs either tasks t  tr tasks  tasksper user counting constraints generalize cardinality constraints widely adopted
wsp community  american national standards institute        bertino  bonatti    ferrari 
      joshi  bertino  latif    ghafoor        sandhu  coyne  feinstein    youman        
      r egular c onstraints
say c regular satisfies following condition  partition s            sp
 
every
sp  p  exists eligible complete plan user u  u    si  
plan i    si ui    ui distinct  eligible  regular constraints extend set
constraints considered wang li         crampton et al         show following
constraints regular   s                s              least one sets        singleton 
tasks per user counting constraints form  t    tr      t      
      u ser  i ndependent c onstraints
many business rules concerned identities users complete set tasks 
concerned relationships users  accordingly  say constraint  l    user independent whenever   u u permutation 
  obvious example user independent constraint requirement two
tasks performed different users  separation of duty   complex example suppose
most at least exactly p users required complete sensitive set tasks  cardinality
constraints   p usually small  i e           so  substantial literature constraints method specifying enforcing business rules  for example  gligor  gavrila   
ferraiolo        simon   zurko         including work researchers sap ibm  for example  basin  burri    karjoth        wolter   schaad         widely studied constraints
cardinality constraints separation of duty  form part ansi standard rolebased access control  american national standards institute         developed us national
institute standards technology  nist   short  literature relevant standards suggest user independent constraints interest business processes workflow
   

fii terative p lan c onstruction w orkflow atisfiability p roblem

management systems  definition user independent includes constraints defined
ansi rbac standard many more 
every regular constraint user independent  many user independent constraints
regular  indeed  constraints type  s             user independent  necessarily
regular  crampton et al          many counting constraints global constraint catalogue  beldiceanu  carlsson    rampon        user independent  regular  particular  constraint nvalue  bounds number users performing set
tasks  user independent regular  note  however  constraints form  s    s      
 s    s        user independent general 
important note authorization lists  fundamental access control
system  viewed unary constraints  certainly user independent  presence
user independent constraints authorization lists workflow specification makes
wsp challenging 
    naive algorithm
main aim section present simple algorithm  algorithm    solve
instance wsp  running time algorithm slightly worse brute force algorithm  algorithms basic structure provides starting point develop
efficient algorithm 
need introduce additional notation terminology 
let   x plan s  x u   let task     u ser     x 
important generic algorithm task   u ser   given explicit parts  
particular  set u ser   may different set users assigned task   is 
user u u ser   without task  s    u  worth observing
task   may empty  because may allocate tasks users x  
u u    t u  denotes plan    u   s    u  
two functions f    d  e  f    d  e  disjoint d  d    e  e     
union two disjoint functions f    d  e    f    d  e  function f   f  f 
f   d  d  e  e  f  d     d  di           let g   e
h   e f functions  h g denotes composite function f
h g d    h g d   d  integer p      set  p                   p  
proposition    let  s  u  a  c  instance wsp  n    u    k    s     c  
 s  u  a  c  solved time   n     k   algorithm   
proof  let u            un ordering u   let ui    u            ui    n  
 n  turn  construct set plans u ser     ui valid 
set n contains plan task     s   s  u  a  c  solution  otherwise 
plan solution  s  u  a  c  
algorithm   shows construct sets   hard verify contains exactly
every valid plan u ser     ui   i  implies correctness algorithm 
remains analyse running time 
 n  s  i t   valid plans u ser    
ui   task       construct     need consider plans u ser     u   
exactly  k plans  plan decide polynomial time whether add    
   

fic ohen   c rampton   g agarin   g utin     j ones

algorithm    naive solution procedure wsp
input   instance  s  u  a  c  wsp
  construct ordering u            un u  
  set      
  foreach
 
set    t u    
 
eligible u  a s 
 
set          
 
end
  end
  set     
     n
  
set i      
  
foreach  
  
foreach   task     
  
ui   a s 
  
set      t ui     
  
eligible
  
set i     i      
  
end
  
end
  
end
  
end
  
set       
   end
   foreach n
  
task    
  
return  
  
end
   end
   return null  

construct i    n     need consider every pair          
  task       consider pair             s     ui   plan   s 
 
 
      thus i s   possibilities
   
  s  s   choices   thus 
p
p
 
 
k
k
total number pairs given   i s     s  s     j   j ij  kj    i     k  
pair         decide whether
add    t ui     i   polynomial time  thus 
p
k

k

k
construct takes time   n 
i    i           n n            n        

algorithm   inefficient even small k  due fact contains valid plans
u ser         u            ui    show next section necessary store
much information solve wsp 

 

   

fii terative p lan c onstruction w orkflow atisfiability p roblem

   plan indistinguishability relations
first introduce notion extension equivalence  defined equivalence relation set
plans  informally  relation enables us keep single member equivalence class
building plans incrementally 
definition    given instance  s  u  a  c  wsp  two eligible plans       define
    following conditions hold 
   u ser       u ser     task       task     
       eligible     eligible  plan   disjoint      
equivalence relation set eligible plans  say     extensionequivalent      
example    consider instance   
let      s    s     u    u    function    s      u     s      u    let
     s    s     u    u    function    s      u     s      u   
plans     eligible  u ser       u ser     task      
task      plan   disjoint       plan     satisfy constraints
 s    s          s    s         thus     eligible   eligible  similarly     
eligible   eligible  thus     eligible     eligible 
    extension equivalent 
suppose polynomial time algorithm check whether two eligible plans
extension equivalent  algorithm    could keep track one plan equivalence class  constructing   add     extension equivalent
  already   construct i     may use   proxy     number
extension equivalent classes small compared number plans  worst case running
time algorithm may substantially lower algorithm   
unfortunately  necessarily easy decide two eligible plans extension equivalent 
approach practical  however  always refine  extension equivalence equivalence relation equivalence easy determine  example  identity equivalence
relation plan equivalent refinement 
refined equivalence relation may equivalence classes extensionequivalence  substantially fewer identity relation  may obtain better running
time naive algorithm 
definition    given instance  s  u  a  c  wsp  let set eligible plans
let equivalence relation refining extension equivalence   say planindistinguishability relation  with respect c  if  eligible            
plan   disjoint         eligible           
example    let identity relation plans  is      u ser      
u ser      task       task         s       s  u ser     
   equivalence relation   refinement equivalence relation   every equivalence class   subset
equivalence class    

   

fic ohen   c rampton   g agarin   g utin     j ones

plan indistinguishability relation  shows every plan indistinguishability relation
extension equivalence relation  indeed  plans given example   extension equivalent
identical 
recall refined extension equivalence since may hard determine whether two
eligible plans extension equivalent  therefore natural assume following 
assumption    given plan indistinguishability relation   takes polynomial time check
whether two eligible plans equivalent  
correctness algorithms depend assumption  however  poor choice
plan indistinguishability relation could affect running times 
describe appropriate plan indistinguishability relations constraints
using  case determining two eligible plans equivalent take polynomial
time 
    plan indistinguishability relation user independent constraints
lemma    suppose constraints user independent  let ui relation   ui
 
   u ser       u ser     task       task     
   s  task         s       t     s       t  
ui plan indistinguishability relation set eligible plans 
proof  definition user independent constraints  eligible plan   u u
permutation  eligible  suppose   ui     let   task    
x   u ser      let        t      t   function       t        t 
task t  let      x      t   x      t   arbitrary bijection  note     t          t   
condition   ui    let          permutation         thus  
eligible   eligible 
consider two eligible plans         ui     plan   disjoint  
    first show     ui       clear u ser         u ser      
task         task        s  u ser               s           t  
either s  task       case        s           t  trivially  s 
task      case    s       t  since   ui     hence        s   
       t   thus        s           t         s           t  and  similar
argument  converse holds  thus     ui       furthermore  follows argument
first paragraph     eligible     eligible  thus  condition
definition   second condition definition   hold 
first condition ui trivially satisfies first condition definition    thus  ui satisfies
conditions plan indistinguishability relation 
example    consider instance wsp users u          u  tasks s            s 
constraints user independent  let ui plan indistinguishability relation given
lemma    let c  constraint scope  s    s    s    s    c  satisfied
even number users assigned tasks  s    s    s    s     let c  constraint scope
   

fii terative p lan c onstruction w orkflow atisfiability p roblem

 s    s    s    s    c  satisfied either s  s  assigned different users 
s  s  assigned different users  suppose c  c  constraints whose
scope contains tasks  s    s    s     s    s    s    
consider plans          s    s    s     u    u    u    u       s     
u       s      u       s      u       s      u       s      u       s      u    suppose
      eligible      equivalent ui  
observe plan   disjoint           eligible    
eligible      assign two users  s    s       must assign two users  s    s   
order satisfy c        assign s  s  user    must assign s  s 
different users order satisfy c    long conditions satisfied    satisfies
constraints scope  s    s    s             eligible 
    plan indistinguishability relation equivalence relation constraints
recall given binary relation u   constraint form  si   sj     satisfied plan
 si    sj    recall constraints user independent general 
lemma    suppose equivalence relation u   let v            vl equivalence classes
u   suppose constraints form  si   sj      si   sj       let e relation
  e  
   u ser       u ser     task       task     
   equivalence classes vj vj u ser        vj   u ser         
task         s  vj    s  vj  
e plan indistinguishability relation 
proof  clear e satisfies first condition definition    suppose       eligible
plans   e     let   plan disjoint       first show    
eligible     eligible 
suppose     eligible  consider two tasks t  t  task         t  t    task      
    falsify constraint t  since equal     restricted
 t  t        eligible   t  t    task          break constraints
since   eligible 
may assume task      t  task       definition         t         t   
exists j  l     t      t    vj   vj u ser       
vj   u ser          therefore  definition e      s  vj    s  vj  
task      particular     t  vj          t         t     similar argument 
       t         t           t         t     therefore  every constraint
satisfied        satisfied         therefore     eligible
      similar argument converse holds 
remains show     e       clear user task sets same 
user set  sets  vj   vj u ser            vj   u ser           
 vj   vj u ser            vj   u ser            same  furthermore 
vj set task               s  vj        s  vj   either
task      case vj u ser          vj   u ser           s  vj  
   

fic ohen   c rampton   g agarin   g utin     j ones

task       case        s       s           s   similar argument 
       s  vj          s  vj   thus     e      
example    let equivalence relation users equivalence classes
 u      u      u    u    u      u    u    u     consider instance wsp users u            u 
tasks s            s  constraints form  si   sj      si   sj       let e
plan indistinguishability relation given lemma    suppose constraints whose scope
contains tasks  s    s    s     s    s    s    constraints  s    s         s    s     
 s    s       
consider plans          s    s    s     u    u    u    u       s     
u       s      u       s      u       s      u       s      u       s      u    suppose
      eligible      equivalent e  
observe plan   disjoint           eligible    
eligible   equivalence class members  u    u    u    u    members
 u    u    u    u    class  u    u    u         assign members  u    u    exactly
set  s    s     thus plan   disjoint               satisfy
constraint  s    s       whatever   assigns s    satisfy  s    s        assigns
s  u    satisfy  s    s         assign s  u    long
conditions satisfied    satisfies constraints scope  s    s    s        
    eligible 

   generic algorithm wsp
follows  x u  s  let  x    denote set eligible plans
u ser     x task       section introduce algorithm works
similar way algorithm    except instead storing valid plans particular set users
tasks  construct  x    representative sets task set certain user sets x 
definition  equivalence classes plan indistinguishability relation necessarily partition
 x     hence equivalence class representation form  x  t    
dependent constraint language  remainder section describe algorithm
give examples representations 
    encodings patterns
generic algorithm  construct plans iteratively  using one plan
equivalence class plan indistinguishability relation  running time algorithm
depend number equivalence classes relation  certain sets plans 
ensure sets equivalence classes ordered therefore searched sorted efficiently 
introduce notion encodings patterns  loosely speaking  encoding function
maps plans  equivalence class element  the pattern plans  
encodings ensure logarithmic time access insertion operations representative set plans 
rather linear time naive method would allow 
note use encodings patterns necessary fixed parameter
tractability results  problems could solved without use patterns encodings
fixed parameter time  function k would grow quickly 

   

fii terative p lan c onstruction w orkflow atisfiability p roblem

definition    given instance  s  u  a  c  wsp plan indistinguishability relation
  let set plans  let pat set consider function enc   pat 
x u  s  let pat x      enc  x      say enc  encoding  or
encoding   if  x u         x    
   enc       enc          
   enc     calculated time polynomial n  k  m 
   exists linear ordering pat x    that  p  p  pat x     decide
whether p p  time polynomial n  k  m 
elements pat called  patterns  enc     p say p  pattern  
second third conditions definition   ensure may use encodings organise
plans reasonable time  clear context  refer  encoding
encoding  patterns patterns 
note complexity consequences definition   following 
proposition    encoding plan indistinguishability relation set patterns pat  
assigning patterns pat nodes balanced binary tree  perform following
two operations time  log  pat       i  check whether p pat    ii  insert pattern
p
  pat pat  
proof  recall comparisons polynomial n  k  m  result follows wellknown properties balanced binary trees  e g   see  cormen  stein  rivest    leiserson         
show plan indistinguishability relations given previous section
encodings  first need define lexicographic order 
definition    given totally ordered set  a      total  lexicographic order d tuples
ad defined follows  say  x            xd    y            yd   either xj   yj j  d 
xi   yi xj   yj j   i 
taking   n   k obtain natural lexicographic order nk   
lexicographically order sets disjoint subsets ordered set  
 t            tk    t      tk  
definition    associate k tuple  x            xk   nk  set disjoint subsets
 s            sr    t            tk   follows  xi     ti
  rm   sm   ti rm   sm  
j    ti   tj   sm xi   xj  
otherwise xi   max x            xi         max     
write vec s     x            xk    note vec s  computed time o k     
thus  tasks subset assigned value  assignment integers
tasks performed iteratively  example                   sets  
                      b                        vec a                            
vec  b                              lexicographically bigger b 
   

fic ohen   c rampton   g agarin   g utin     j ones

corollary    let ui plan indistinguishability relation given set user independent
constraints lemma    exists encoding ui  
proof  let s            sk ordering plan  let        u    u u ser   
let vec     vec s    plan   let enc   tuple  u ser    task    vec    
clear enc       enc       ui     r  si     r  sj  
yi   yj vec r      y            yk    r         furthermore clear enc  
determined polynomial time  
remains define linear ordering pat x    given x u  s  two
patterns p    x  t   x            xk     p     x  t   y            yk    pat x     define p p 
 x            xk    y            yk   
example    let enc encoding given proof corollary    let       plans
given example    enc       enc         u    u    u    u      s    s    s                         
corollary    let e plan indistinguishability relation given set constraints equivalence relations lemma    exists encoding e  
proof  suppose equivalence relation users  let v            vp equivalence classes
u   suppose constraints form  si   sj      si   sj      
plan   define enc    u ser    task      


     vj u ser      vj u ser        vj   u ser          j p  
clear enc       enc       e      s  vj
i   vj            furthermore clear enc   determined polynomial
time  
remains define linear ordering pat x    given x u  s  let   x
plan  set disjoint subsets task    natural order  order
patterns pat x    according lexicographic order  

example    let enc encoding given proof corollary    let       plans
given example    enc       enc         u    u    u    u      s    s    s       s    s      
    generic algorithm
use notion diversity introduced next definition analyse running time
generic algorithm 
definition    let  s  u  a  c  instance wsp  n    u    k    s     c  
suppose plan indistinguishability relation respect c  given ordering u            un
u   let ui    u            ui    n   let wi number equivalence classes
set  ui     eligible plans  define diversity respect u            un
w   maxi n  wi  
since generic algorithm stores one plan equivalence class   need
notion representative set 
   

fii terative p lan c onstruction w orkflow atisfiability p roblem

definition    given instance  s  u  a  c  wsp  let   set eligible plans let
plan indistinguishability relation  set    said    representative set respect
following properties hold 
          every plan    valid 
   every valid       exists             
clear context  say       representative set representative set
    generic algorithm based finding plan indistinguishability relations
exist small representative sets 
theorem    let  s  u  a  c  instance wsp  n    u    k    s     c   let
u            un ordering u   let ui    u            ui    n   u      suppose
diversity w respect u            un   furthermore suppose exists  encoding
enc    s  u  a  c  solved time   k w log w  
proof  proof proceeds demonstrating correctness bounding running time
algorithm    solves wsp  begin proof  give overview algorithm   
 n  turn s  construct representative set  ui     
denoted  ui      
well constructing set  ui       maintain companion set pat ui      
enc   ui        provides efficient way representing equivalence classes
 ui       particular  allows us check whether given valid plan added
 ui       faster searching  ui     linearly 
 un   s  constructed  remains check whether  un   s  non empty 
exists valid complete plan   exists valid complete plan    un   s 
   
algorithm   gives details construct  ui      
proof correctness algorithm   proceeds induction  observe first case
 u           possible plan  u       set  u         
  possible plan empty plan    plan added  u       
trivially valid  thus  u       u      representative set  
assume set  ui     constructed  ui    representative set  consider construction  ui       s  clear
added  ui          ui        eligible  furthermore authorized 
union authorized plans    ui        t    ui      thus every plan
 ui       valid plan  ui        hand  suppose valid plan
 ui        let          ui                 let      ui    
   t    ui      assumption  exists    ui           consider
plan      t    ui      clear considered algorithm 
furthermore           t    ui        therefore
eligible  as eligible  authorized  as union two authorized plans   therefore
   

fic ohen   c rampton   g agarin   g utin     j ones

algorithm    generic algorithm wsp
input   instance  s  u  a  c  wsp  ordering u            un u  
plan indistinguishability relation
  set  u              
  foreach  
 
 
set  u         
  end
  set     
    n
 
foreach
 
set  ui          
 
set pat ui          
  
foreach  
  
set           
  
ui   a s    
  
foreach    ui      
  
set      t    ui     
  
eligible
  
set p   enc   
  
p
  pat ui      
  
insert p pat ui        
  
set  ui          ui          
  
end
  
end
  
end
  
end
  
end
  
end
  
set       
   end
    un   s    
  
return  un   s   
   else
  
return null 
   end

valid added  ui       unless  ui       already contains another plan equivalent   thus   ui       contains plan  equivalent   follows
 ui        ui       representative set  required 
remains analyse running time algorithm  proposition    testing whether
pattern p pat ui     inserting p pat ui     takes  log  pat ui         time 
since assumption   assumption time check constraints authorizations
takes polynomial time check eligibility  authorization  equivalence plans  running
   

fii terative p lan c onstruction w orkflow atisfiability p roblem

p
p
p
p

time algorithm   n 
i  

 
 ui  t     log   ui            clear
construction  ui       contains one plan  equivalence class  ui       
sop
definition
  ui         w i      follows running time algorithm
p
n  p

  i     w log w      k w log w  
remark    rather checking whether  un   s  non empty end algorithm 
could instead check whether  ui   s  non empty construction  ui   s  i 
is  stop search soon valid plan task set s  likely lead
saving running time implementation algorithm  paper concerned
worst case running time  would unaffected change  perform check
end algorithm interest clarity 
    application user independent constraints optimality
subsection  show wsp user independent constraints fpt  let bk denote
kth bell number  number partitions set k elements 
lemma    let u            un ordering u   let ui plan indistinguishability relation
given lemma    ui diversity bk respect u            un  
proof  plan   set      u    u u ser    partition tasks task   
furthermore  two plans generate partition equivalent ui   therefore
number equivalence classes ui  ui     exactly number possible partitions
  b t     thus  bk required diversity 
theorem    constraints user independent  wsp solved time
  k log k   
proof  let u            un ordering u   let ui plan indistinguishability relation
given lemma   
lemma    ui diversity bk respect u            un   furthermore  corollary   
exists encoding ui   therefore  may apply theorem   w   bk   get
algorithm running time   k bk log bk       k log k   bk         k  ln k      k
every k  berend   tassa        
running time   k log k   obtained optimal sense algorithm running time
exists  unless eth fails  proof following theorem  use result
lokshtanov  marx    saurabh        theorem      

  o k log k   

theorem    algorithm wsp user independent constraints running time
  o k log k     unless eth fails 
proof  give reduction problem kk ndependent et  given integer parameter
k graph g vertex set v     i  j    i  j  k    decide whether g independent set
 i    k r  k   exists  r  i  i 
informally  k k ndependent et gives us graph k k grid vertices  asks
whether independent set one vertex row  lokshtanov et al         proved
algorithm solve k k ndependent et time  o k log k    unless eth fails 
   

fic ohen   c rampton   g agarin   g utin     j ones

consider instance k k ndependent et graph g  first produce
equivalent instance wsp constraints user independent 
refine instance one user independent constraints 
let u    u            uk   set k users    s            sk   set k tasks  let
authorization lists a si     u  k   i  j  h  l  k   let c  i  j    h  l   denote
constraint scope  si   sh    satisfied plan unless  si     uj
 sh     ul   every pair vertices  i  j    h  l  adjacent g  add constraint
c  i  j    h  l   c 
show  s  u  a  c  es instance wsp g independent set one vertex row  suppose  s  u  a  c  es instance wsp
let valid complete plan   k   let f  i  unique j  si     uj  
    i  f  i      k   set one vertex row g  furthermore  satisfies every constraint  edge g contains one element i  independent
set 
conversely  suppose g es instance k k ndependent
et   k   let

f  i  integer  i  f  i   i  observe ki     si   uf  i    valid complete
plan 
show reduce  s  u  a  c  instance wsp constraints
user independent  main idea introduce new tasks representing users 
constraints  replace mention particular user mention user performs
particular task 
create k new tasks t            tk let      t              tk    let authorization lists
 
 s    u a   ti      ui    k   constraint c  i  j    h  l  
c  let d  i  j    h  l   constraint scope  si   sh   tj   tl    satisfied plan
unless  si      tj    sh      tl    let initially c     c  replace  c     every constraint
c  i  j    h  l   d  i  j      h  l   
since defined equalities  users mentioned  constraints c   userindependent  show  s     u  a    c     equivalent  s  u  a  c   first  suppose
valid complete plan  s  u  a  c   let       u plan    si      si  
 k      tj     uj j  k   easy check satisfies every constraint
c   satisfies every constraint c     since   authorized eligible plan    valid
complete plan  s     u  a    c     
conversely  suppose   valid complete plan  s     u  a    c      since a   ti      ui  
 k      ti     ui every  k    k   let f  i  unique integer
   si     uf  i    define   u  si     uf  i    observe constraints c
satisfied   so  valid complete plan  s  u  a  c  
    application equivalence relation constraints
known restricting wsp equivalence relation constraints enough ensure
problem fpt  crampton et al          however  derive result applying
algorithm directly shown appropriate properties language equivalence relation
constraints  serves demonstrate wide applicability approach 

   

fii terative p lan c onstruction w orkflow atisfiability p roblem

lemma    let e plan indistinguishability relation given set equivalence relation
constraints lemma    exists ordering u            un u e diversity
 k respect u  
proof  suppose equivalence relation users  let v            vp equivalence classes
u   suppose constraints form  si   sj      si   sj      
let u            un ordering u elements vj appear elements
vj     j   j     thus  plan u ser     ui    u            ui   
one integer ji vji u ser        vji   u ser       
follows two plans        ui     e  equivalent   n   s 
provided    t  vji    t  vji   therefore e  k
equivalence classes  ui      required 
theorem    suppose equivalence relation u   suppose constraints form
 si   sj      si   sj       wsp solved time   k   
proof  let u            un ordering u given lemma    let e planindistinguishability relation given lemma   
lemma    e diversity  k respect u            un   furthermore corollary   
exists encoding e   therefore  may apply theorem   w    k   get algorithm
running time   k  k log  k        k   

   unions constraint languages
section show approach allows us easily combine constraint languages shown
fpt wsp  need build bespoke algorithms new constraint language
obtained  show two languages sense compatible 
highlights advantages approach previous methods  required development new algorithms different constraint languages combined instance
wsp  e g   see crampton et al         
theorem    let  s  u  a  c  c    instance wsp  suppose   planindistinguishability relation respect c    plan indistinguishability relation
respect c    given ordering u            un u   let w  diversity   respect
u            un w  diversity   respect u            un  
let equivalence relation            
plan indistinguishability relation respect c  c    diversity w  w 
respect u            un  
proof  first show plan indistinguishability relation respect c  c    let
  eligible plans  with respect c  c       implies       satisfies
conditions plan indistinguishability relation  clear   u ser    
u ser      task     task       consider plan    disjoint      
plan indistinguishability relation respect c           c   eligible
     is  similarly    c   eligible      is  observing
plan c  c   eligible c   eligible c   eligible  implies   
c  c   eligible      is  thus   extension equivalent 
   

fic ohen   c rampton   g agarin   g utin     j ones

    plan indistinguishability relations           
            therefore           thus  satisfies conditions
plan indistinguishability relation 
bound diversity respect u            un   consider ui  
 u            ui    enough note  equivalent plans  ui     must
     equivalence classes  w  choices    equivalence class
w  choices   equivalence class  w  w  equivalence classes
 ui     
remark    given encoding enc    encoding enc      may construct
encoding   given plan   let enc   ordered pair  enc      enc       clear
enc     enc         
given sets ui    u            ui    fix linear orderings enc    ui     
enc     ui       let lexicographic ordering enc   ui        enc     ui     
enc     ui      
nothing stop us applying theorem   multiple times  order get planindistinguishability relation bounded diversity union several constraint languages 
note diversity expected grow exponentially number languages
union  thus  makes sense apply theorem   union small number languages 
however  long fixed number languages  plan indistinguishability
relation fixed parameter diversity  resulting union languages planindistinguishability relation fixed parameter diversity 
use result directly show constraints either user independent
equivalence relation constraints  wsp still fpt 
theorem    suppose equivalence relation u   let  s  u  a  c  instance
wsp  suppose constraints either form   s    s        s    s       userindependent constraints  wsp solved time   k log k k   
proof  let ce c set constraints form  s    s        s    s        let cui
remaining  user independent  constraints 
let u            un ordering u given lemma    lemmas      exists planindistinguishability relation e ce diversity  k respect u            un   furthermore
corollary    e encoding  lemmas      exists plan indistinguishability
relation ui cui diversity bk respect u            un   furthermore corollary   
ui encoding 
therefore theorem    may find plan indistinguishability relation c 
diversity bk  k respect u            un encoding  thus
may apply theorem   w   bk  k   get running time   k bk  k log bk  k     
  k  k log k  o     k log  k log k  o     k        k log k k   

   computational experiments wsp algorithms
apart conducting theoretical research wsp  wang li        carried experimental study problem  due difficulty acquiring real world workflow instances 
   

fii terative p lan c onstruction w orkflow atisfiability p roblem

wang li used synthetic data experimental study  encoded instances wsp
pseudo boolean sat order use pseudo boolean sat solver sat j 
implemented algorithm compared performance sat j another set
synthetic instances wsp  cohen et al          instances use k         
    n     k user independent  cardinality  constraints three different types  vary
number constraints proportions different constraint types  user authorized
    tasks k            tasks k           
tasks k       algorithm implemented c   enhanced inclusion
techniques employed csp solving  propagation  converted wsp instances
pseudo boolean problems processing sat j  experiments performed macbook
pro computer     ghz intel core i  processor   gb      mhz ddr  ram  running
mac os x         
lightly constrained instances  sat j often faster algorithm  largely
number patterns considered algorithm large instances  however  highlyconstrained instances  sat j unable compute decision number instances  because
ran memory   sharp contrast algorithm solved instances  overall 
average  algorithm faster sat j and  particular  two orders magnitude faster
k       moreover  time taken algorithm varies much less sat j  even
unsatisfiable instances  time taken proportional product number
patterns number users   in particular  tested instances  much less dependent
number constraints  parameter cause significant fluctuations time taken sat j
leads sharp increase number variables pseudo boolean encoding   full
details results published  cohen et al         

   conclusion
paper introduced algorithm based notion plan indistinguishability  applicable
wide range wsp instances  showed algorithm powerful enough optimal 
sense  wide class user independent constraints  generic algorithm
fixed parameter algorithm equivalence relation constraints  user independent 
showed deal unions different types constraints using generic algorithm 
particular  proved generic algorithm fixed parameter algorithm union
user independent equivalence relation constraints 

acknowledgments
research supported epsrc grant ep k          grateful referees
useful comments suggestions 

references
american national standards institute        
cits rbac           
   

role based access control  ansi in 

fic ohen   c rampton   g agarin   g utin     j ones

basin  d  a   burri  s  j     karjoth  g          obstruction free authorization enforcement  aligning security business objectives  journal computer security                
beldiceanu  n   carlsson  m     rampon  j  x          global constraint catalog   nd edition
 revision a   working copy       swedish institute computer science  kista  sweden 
berend  d     tassa  t          improved bounds bell numbers moments sums
random variables  probability mathematical statistics                
bertino  e   bonatti  p  a     ferrari  e          trbac  temporal role based access control
model  acm trans  inf  syst  secur                
bertino  e   ferrari  e     atluri  v          specification enforcement authorization
constraints workflow management systems  acm trans  inf  syst  secur               
bodlaender  h  l   cygan  m   kratsch  s     nederlof  j          deterministic single exponential
time algorithms connectivity problems parameterized treewidth  proceedings
  th international conference automata  languages  programming   volume part i 
icalp    pp          berlin  heidelberg  springer verlag 
bulatov  a   jeavons  p     krokhin  a          classifying complexity constraints using
finite algebras  siam journal computing             
cohen  d   crampton  j   gagarin  a   gutin  g     jones  m          engineering algorithms
workflow satisfiability problem user independent constraints  chen  j   hopcroft 
j  e     wang  j   eds    frontiers algorithmics    th international workshop  faw      
zhangjiajie  china  june              proceedings  vol       lecture notes computer
science  pp        springer 
cormen  t  h   stein  c   rivest  r  l     leiserson  c  e          introduction algorithms   nd
edition   mcgraw hill higher education 
crampton  j   crowston  r   gutin  g   jones  m     ramanujan  m          fixed parameter
tractability workflow satisfiability presence seniority constraints  fellows  m  
tan  x     zhu  b   eds    frontiers algorithmics algorithmic aspects information
management  vol       lecture notes computer science  pp          springer
berlin heidelberg 
crampton  j          reference monitor workflow systems constrained task execution 
proceedings tenth acm symposium access control models technologies 
sacmat     pp        new york  ny  usa  acm 
crampton  j     gutin  g          constraint expressions workflow satisfiability  proceedings   th acm symposium access control models technologies  sacmat    
pp        new york  ny  usa  acm 
crampton  j   gutin  g     yeo  a          parameterized complexity kernelization
workflow satisfiability problem  acm trans  inf  syst  secur                  
dechter  r          constraint processing  morgan kaufmann publishers      pine street  sixth
floor  san francisco  ca            
downey  r  g     fellows  m  r          fundamentals parameterized complexity  texts
computer science  springer 
   

fii terative p lan c onstruction w orkflow atisfiability p roblem

fomin  f  v   lokshtanov  d     saurabh  s          efficient computation representative sets
applications parameterized exact algorithms  proceedings twenty fifth
annual acm siam symposium discrete algorithms  soda     pp          siam 
gligor  v   gavrila  s     ferraiolo  d          formal definition separation of duty policies composition       ieee symposium security privacy        proceedings   pp         
impagliazzo  r   paturi  r     zane  f          problems strongly exponential complexity   j  comput  syst  sci                 
jayaraman  k   ganesh  v   tripunitara  m  v   rinard  m  c     chapin  s  j          arbac
policy large multi national bank  corr  abs           
joshi  j  b  d   bertino  e   latif  u     ghafoor  a          generalized temporal role based
access control model  ieee transactions knowledge data engineering              
lokshtanov  d   marx  d     saurabh  s          slightly superexponential parameterized problems 
proceedings twenty second annual acm siam symposium discrete algorithms 
soda     pp          siam 
niedermeier  r          invitation fixed parameter algorithms  oxford university press 
rossi  f   van beek  p     walsh  t   eds            handbook constraint programming 
elsevier 
sandhu  r  s   coyne  e  j   feinstein  h  l     youman  c  e          role based access control
models  computer              
schaad  a   moffett  j     jacob  j          role based access control system european
bank  case study discussion  proceedings sixth acm symposium access
control models technologies  sacmat     pp      new york  ny  usa  acm 
simon  r     zurko  m          separation duty role based environments  computer
security foundations workshop        proceedings     th  pp         
wang  q     li  n          satisfiability resiliency workflow authorization systems  acm
trans  inf  syst  secur                    
wolter  c     schaad  a          modeling task based authorization constraints bpmn 
proceedings  th international conference business process management  bpm   
pp        berlin  heidelberg  springer verlag 

   


