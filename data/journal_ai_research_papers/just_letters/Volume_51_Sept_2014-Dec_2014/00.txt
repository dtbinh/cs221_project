journal of artificial intelligence research               

submitted       published     

cooperative monitoring to diagnose multiagent plans
roberto micalizio
pietro torasso

micalizio di unito it
torasso di unito it

dipartimento di informatica 
universita di torino
corso svizzera              torino  italy

abstract
diagnosing the execution of a multiagent plan  map  means identifying and explaining
action failures  i e   actions that did not reach their expected effects   current approaches
to map diagnosis are substantially centralized  and assume that action failures are independent of each other 
in this paper  the diagnosis of maps  executed in a dynamic and partially observable
environment  is addressed in a fully distributed and asynchronous way  in addition  action
failures are no longer assumed as independent of each other 
the paper presents a novel methodology  named cooperative weak committed monitoring  cwcm   enabling agents to cooperate while monitoring their own actions  cooperation helps the agents to cope with very scarcely observable environments  what an agent
cannot observe directly can be acquired from other agents  cwcm exploits nondeterministic action models to carry out two main tasks  detecting action failures and building
trajectory sets  i e   structures representing the knowledge an agent has about the environment in the recent past   relying on trajectory sets  each agent is able to explain its own
action failures in terms of exogenous events that have occurred during the execution of the
actions themselves  to cope with dependent failures  cwcm is coupled with a diagnostic
engine that distinguishes between primary and secondary action failures 
an experimental analysis demonstrates that the cwcm methodology  together with
the proposed diagnostic inferences  are effective in identifying and explaining action failures
even in scenarios where the system observability is significantly reduced 

   introduction
multiagent plans  maps  are adopted in many applicative domains  from web services to
service robots  whenever the interactions among cooperative agents have to be organized in
advance  i e   planned   in order to reach an acceptable efficiency level during the execution 
consider for instance  orchestrated web services  yan  dague  pencole    cordier        
assembling tasks  heger  hiatt  sellner  simmons    singh        sellner  heger  hiatt 
simmons    singh         or service robotics  micalizio  torasso    torta         maps are
therefore characterized by a cooperative team of agents that perform actions concurrently
in order to achieve a common global goal 
the use of maps in real world scenarios  however  has to cope with a critical issue 
plan actions can deviate from their expected nominal behaviors due to the occurrence of
 unpredictable  exogenous events  these deviations are typically considered as plan failures
since they prevent the agents to reach their goals  indeed  although maps are very versatile
c
    
ai access foundation  all rights reserved 

fimicalizio   torasso

systems  they are also particularly fragile  the failure of an action can easily propagate
through the system causing the failures of other actions  even assigned to different agents 
in order to make the execution of a map robust  i e   tolerant to at least some exogenous
events   it is therefore important to detect and isolate action failures  and provide a human
user  or a plan repair module  with a set of possible explanations for the detected failures 
some recent works  see e g   mi   scacchi        gupta  roos  witteveen  price    de kleer 
      micalizio        have argued that a plan repair procedure can be more effective when
the causes of the plan failure are known  e g   identified via diagnosis  
over the last decade  the problem of diagnosing the execution of a map has been faced
from different perspectives  since their seminal work  kalech and kaminka        focus on
coordination failures and introduce the notion of social diagnosis  social diagnosis relies on
an abstract representation of the map at hand  given in terms of behaviors  and aims at
explaining why two or more agents have selected conflicting behaviors  kalech and kaminka
       and kalech        present alternative algorithms for inferring a social diagnosis 
other approaches  see e g   de jonge  roos    witteveen        roos   witteveen 
      micalizio   torasso              adopt an explicit representation of a map in terms
of agents actions and shared resources  in particular  in their diagnostic framework  roos
and witteveen        and de jonge et al         consider action failures  i e   actions that
do not reach their expected effects   and introduce the notion of plan diagnosis  a plan
diagnosis is a subset of  already performed  actions that  when assumed abnormal  make
the plan execution consistent with the observations received so far  since the same set of
observations can possibly be explained by many plan diagnoses  roos and witteveen       
present a criterion for identifying preferred diagnoses that is based on the predictive power
of these diagnoses 
these proposals  however  rely on some assumptions that might limit their applicability in some real world scenarios  first of all  they assume some form of synchronization
among the agents  e g   synchronized selection of behaviors  or execution of actions   more
importantly  action failures are assumed to be mutually independent  furthermore  in the
particular case of social diagnosis  agents cooperate with each other by exchanging their
own belief states  but this might be a critical issue when they have to keep some information private  on the other hand  in the framework proposed by roos and witteveen        
diagnostic inferences are substantially centralized 
in this paper we aim at relaxing these assumptions by extending the relational based
framework introduced by micalizio and torasso               similarly to roos and witteveen  we adopt an explicit representation of the map at hand in term of agents actions
and shared resources  but differently from them  our action models include nominal as well
as faulty evolutions  as we will argue in the rest of the paper  this kind of extended action
models subsumes the action models proposed by roos and witteveen 
in addition  we aim at a fully distributed solution that does not rely on the synchronized
execution of the actions  i e   no global clock is available   a distributed solution to social
diagnosis was also proposed by kalech  kaminka  meisels  and elmaliach         in their
work  however  a form of synchronization among the agents is required as agents select their
next behavior simultaneously  moreover  the agents cooperate with each other by sharing
their own belief states  in our proposal  coordination among the agents is achieved by means
of the exchange of direct observations between agents  the idea is that an observation
 

ficooperative monitoring to diagnose multiagent plans

acquired by an agent can be used by other agents in their own reasoning  to understand
the difference between exchanging belief states and direct observations  we have to note
that a belief state is an interpretation of observations made by a specific agent according
to its local knowledge  since the agent might have a partial knowledge of the environment 
its belief states could be ambiguous or even erroneous  therefore  when agents exchange
with each other their own beliefs  they may also propagate their errors  conversely  when
the coordination consists in the exchange of direct observations  agents can infer their own
beliefs without the risk of being conditioned by the errors made by others 
we propose a framework that  relying on the notion of partial order  causal link
 pocl  plans  see cox  durfee    bartold        weld        boutilier   brafman        
limits the number of messages exchanged between agents to the number of causal links
existing between actions assigned to different agents 
in our proposal  communication plays a central role not only for assuring a consistent
execution of the map  but also for easing the diagnostic task  we consider that the environment where the agents operate is scarcely observable  so agents can directly acquire
information about just a small portion of their surroundings  dealing with scarce observations can be very challenging for solving the diagnostic task as this situation might
prevent the detection of action failures  to cope with this issue we propose in this paper
a strategy named cooperative weak committed monitoring  cwcm   which extends the
weak committed monitoring introduced by micalizio and torasso         cwcm allows
the agents to cooperate with each other so that an agent can infer the outcome of its own
actions  i e   failure detection  from the pieces of information provided by the other agents 
as soon as failures are detected  these must be diagnosed in order to identify their
root causes  in this paper  we propose a local diagnostic process where each agent can
diagnose the failure of its own actions without the need of interacting with other agents 
in particular  our diagnostic inferences take into account that failures of different actions
may be dependent  in other words  an action failure can be an indirect consequence  i e  
a secondary failure  of the failure of a preceding action  i e   primary failure   identifying
primary and secondary failures is essential from the point of view of plan repair as primary
failures are the root causes for the anomalous observed execution  in principle  a plan repair
that recovers from primary failures should also recover from secondary failures  an interesting property of our methodology is that the process of inferring primary and secondary
failures is performed autonomously by each agent  just relying on the trajectory sets built
during the cooperative monitoring 
    contributions
the paper contributes to the diagnosis of map execution in many ways  first of all 
the paper shows how the extended action models proposed for the monitoring purpose can
be obtained compositionally from the nominal models of actions  and from the models of
the exogenous events that can affect those actions  thus  a knowledge engineer can take
advantage of this by focusing on the models of the elementary components of the systems
 e g   actions and exogenous events   and then creating complex  extended  action models
by composing the elementary components 
 

fimicalizio   torasso

in addition  the proposed cwcm framework is fully distributed  each agent monitors
its own actions  and there is no a central agent that traces all actions in progress  thus 
cwcm can be applied in those domains where agents operate in physically distributed
environments  and hence a centralized solution could be impractical  another important
feature of cwcm is that it is asynchronous  neither assumption on synchronized execution
of actions  nor assumptions on how long actions should last are made  in other words  agents
do not share a global clock  of course  some form of synchronization is still necessary when
mutual exclusion is required for accessing critical resources  in such cases  however  we will
prefer to use the term coordination 
cwcm also represents a valid solution whenever a diagnosis of a map is performed in
environments characterized by scarce observability levels  in fact  a significant contribution
of cwcm is its cooperative monitoring protocol that enables the agents to acquire information about the system resources from each other  in the paper we argue that the number
of messages exchanged via our cooperative protocol is linear in the number of inter agent
causal links  i e   causal dependencies existing between any pair of agents  
a last important contribution of the paper is the ability of distinguishing between primary and secondary failures  previous approaches  see e g   micalizio   torasso        roos
  witteveen         in fact  assume that action failures are independent of each other 
    outline
the paper is organized as follows  in section   we introduce a basic multiagent planning
framework that we use as a starting point of our work  in section   the basic framework is
extended by relaxing some important assumptions  section   formally presents the cooperative weak committed monitoring  cwcm  strategy  while the local diagnostic inferences
are discussed in section    the paper closes with a detailed experimental analysis in section
   and a critical discussion of related works in section   
the paper also includes an appendix where we briefly discuss how cwcm can be
implemented by means of ordered binary decision diagrams  obdds   bryant       
       and formally analyze the computational complexity of such an implementation 

   multiagent planning  a basic framework
this section is organized in three parts  first  we introduce some basic notions on multiagent planning and the terminology we use throughout the paper  then  we discuss how
the propositional planning language can be translated into a state variable representation 
finally  we present a basic strategy for plan execution in multiagent settings in which we
highlight the importance of the cooperation among the agents even under the strong assumption that no exogenous event occurs  such an assumption is relaxed in section   
    preliminary concepts on multiagent planning
since we are interested in diagnosing systems that can be modeled as multiagent plans  we
begin our discussion by presenting a framework developed within the planning community to
represent and synthesize this kind of plans  it is worth noting that the planning problem is
typically approached in propositional terms  preconditions and effects of actions are literals
 

ficooperative monitoring to diagnose multiagent plans

that must be true  respectively  before and after the application of the actions themselves 
thus we intuitively introduce in this section some planning notions in propositional terms 
however  in section      we argue that when addressing the problem of plan execution  it is
more convenient to handle a representation of the system in terms of state variables  and
hence we translate the propositional framework into a state variables one 
an important assumption holding throughout the paper is that  although the observations gathered by agents at execution time can be partial  they are always correct  we will
elaborate more on this point in section     
      multiagent plans
the multiagent plan  map  systems we take into account in this paper can be modeled as
a tuple s ht   res   p i  where 
 t is the team of cooperating agents  agents are denoted by letters i and j 
 res is the set of shared resources and objects available in the environment  we
assume that all the resources are reusable  i e   they are not consumable   and can
only be accessed in mutual exclusion  note that agents can exchange each other pieces
of information about these resources  so the space of resource names is a common
language through which agents communicate 
 p is a completely instantiated partial order causal link plan  pocl   weld        
resulting from a planning phase as the ones by boutilier and brafman        or by
cox et al          for the sake of simplicity  our map p has a simplified structure
since it does not involve concurrency and non concurrency constraints  more precisely 
our map p is a tuple hi  g  a  r  ci where 
  i is a set of propositional atoms representing the initial state of the system at
planning time 
  g is another set of propositional atoms representing the global goal to be achieved 
note that g is the conjunction of sub goals gi each agent i  t is in charge of 
  a is the set of the action instances the agents have to execute  each action a is
assigned to a specific agent in t   at planning time  we assume that an action a
is modeled just in terms of preconditions pre a  and effects eff  a   where both
are conjunctions of grounded atoms  see pddl level    fox   long         in
the rest of the paper  we denote as ail the l th action performed by agent i 
  r is a set of precedence links between action instances  the precedence link ha  a  i
in r means that action a  can only start after the completion of action a 
  c is a set of causal links of the form lk   ha  q  a  i  the link lk states that action
a provides action a  with service q  where q is an atom occurring both in the
effects of a and in the preconditions of a   
we assume that map p  
 is flaw free  a nominal execution of p from i achieves g 
 

fimicalizio   torasso

 is safe with respect to the use of the resources  intuitively  we say that a resource
res  res is used safely iff at each execution step  res is either not assigned  or
assigned to exactly one agent  this is similar to the concurrency requirement  roos
  witteveen         two actions are not executed concurrently if they both require
the same subset of resources 
 has no redundant actions  even though p is not necessarily optimal  it only contains
actions that directly or indirectly provide services to help the achievement of the goal 
this means that there always exists a chain of causal links between any action in the
plan and at least one atom in the goal g 
to guarantee the resource safeness  we introduce the notion of working sessions associated with resources and agents 
definition   let res be a resource in res   and i be an agent in t   a working session
wshres ii for i using res is a pair haio   aic i of actions in ai such that 
 aio precedes aic  i e   aio  aic   where  is the transitive closure of the precedence
relations in r  
 aio is an action in ai through which agent i acquires res  this is modeled by specifying
the atom available res  in the preconditions of aio   moreover  there exists in c an
incoming causal link of the form hajk   available res   aio i  where ajk is an action assigned
to agent j  possibly ajk can be a  i e   the pseudo action whose effects determine the
initial state of the system   action aio opens the working session  no other action
aih  ai between aio and aic  i e   aio  aih  aic    has an incoming causal link labeled
with service available res  coming from an action of another agent j    i 
 aic is an action in ai through which agent i relinquishes resource res in favor of another
agent j    i  this is modeled by means of a causal link haic   available res   ajk i in c 
meaning that action aic releases res as one of its effects  and that available res  is
one of the preconditions of ajk   action aic closes the working session  of course 
agent i can release resource res to at most one agent  i e   the outgoing link
haic   available res   ajk i is unique  in addition  no action aih  ai between aio and aic  
has an outgoing link labeled with service available res  directed towards an action of
another agent j 
 any action aih between aio and aic can use res  i e   res can be mentioned in the preconditions and effects of aih   more precisely  a causal link mentioning res between two
actions aih and aik in ai is allowed only if both aih and aik belong to the same working
session  namely  aio  aih  aik  aic  
given a working session wshres ii   we denote its opening and closing actions as
opening wshres ii   and closing wshres ii    respectively  two working sessions wshres ii and
ws hres ji are consecutive  wshres ii   ws hres ji   if closing wshres ii   provides opening ws hres ji  
with service available res  
proposition   a map p satisfies the resource safeness requirement if for each resource
res  res  all the working sessions over res can be totally ordered in a sequence
ws hres i  i   ws hres i  i         wsnhres in i   for any agent ij  t  with j      n  
 

ficooperative monitoring to diagnose multiagent plans

this means that  independently of the agents accessing the resource  two working sessions
over the same resource res never overlap each other  possibly  an agent i can have more
than one session in the sequence  meaning that the agent acquires and relinquishes resource
res many times along the plan 
the resource safeness requirement is an extension of the concurrency requirement introduced by roos and witteveen         in fact  while the concurrency requirement implicitly
imposes an ordering between two actions that cannot be performed simultaneously  the
resource safeness imposes an ordering between blocks of actions identified by a working session  this is necessary in order to model situations where an agent uses a set of resources
for a number of consecutive actions that cannot be interleaved with the actions of other
agents  a working session is a sort of critical section that cannot be interrupted  it is worth
noting that  since a working session is associated with a single resource  and since there is
no constraint between the working sessions of two resources  it is possible that an action
aic  ai closes two different working sessions  for example  let wshres ii and ws hres   ii be
two working sessions of agent i using resources res and res    respectively  then it is possible
that an action aic is both closing wshres ii   and closing ws hres   ii    in addition  the resource
res could be released in favor of agent j  while resource res  could be released in favor of
another agent k  this is modeled through the two causal links haic   available res   ajx i and
haic   available res     aky i 
      local plans
since we are interested in a fully distributed framework for both plan execution and plan
diagnosis  we impose that every agent just knows the portion of p it has to perform  we
thus introduce the notion of local plan  intuitively  a local plan p i is the projection of p
over the actions assigned to agent i  p is therefore partitioned into as many local plans as
there are agents in t   more formally  given an agent i  t   the local plan p i assigned
i
i   c i i  where i i represents the portion of the
to i is a tuple p i  hi i   gi   ai   ri   clocal
  cin
out
initial state known by agent i when the plan execution starts  gi is the sub goal assigned
i
to agent i  ai   ri and clocal
have the same meaning as a  r and c  respectively  restricted
i   highlight the causal
i
and cin
to the actions assigned to agent i  the remaining sets  cout
dependencies existing between the actions of agent i and actions assigned to other agents in
i maintains all the outgoing causal links modeling services that agent i provides other
t   cout
i maintains all the incoming causal links modeling services that
agents with  whereas  cin
agent i receives from other agents  to simplify the plan structure  precedence links between
actions of different agents are not allowed in r  this  however  is not a real limitation as
precedence links between actions of different agents could be expressed as causal links in
which the exchanged service refers to a dummy resource 
in the rest of the paper we will consider a local plan p i as a partially ordered set of
actions  however  we assume that each agent can perform just one action per time  so in
the rest of the paper we index the actions according to their execution step  in other words 
p i will be executed by i as a sequence hai    ai            ain   ai i  where ai  and ai are two pseudoactions similar to the ones introduced by weld         action ai  has no preconditions and
its effects coincide to the initial state i i known by agent i  in particular  this pseudo action
is also used to determine the initial set of resources assigned to agent i  any link leaving
 

fimicalizio   torasso

from ai  and labeled with service available resk   denotes that resk is assigned to agent i 
action ai   on the other hand  has no effects and its preconditions correspond to sub goal
gi assigned to i 
    translating the propositional framework into a state variable
representation
although most of the planning approaches in literature relies on the propositional language
to represent planning problems  we adopt in this paper a representation based on multivalued state variables which is similar to the sas  approach introduced by jonsson and
backstrom         the reason for this choice stems from the fact that a multi valued
variable implicitly encode mutual exclusion constraints among the values of its domain 
the variable can just assume one value at a given time  thus  it is easier to represent the
evolution of the system state over the time as a sequence of assignments of values to the state
variables  this solution has also been effectively adopted for the diagnosis of plans  roos  
witteveen         and as helmert        has proven  it is not restrictive since it is always
possible to translate a propositional representation into a set of multi valued state variables 
in the rest of the section we briefly describe how the propositional planning language  see
e g   nebel        can be mapped to the state variables representation  three main aspects
are addressed      how to represent agents states in terms of state variables rather than
sets of propositional fluents      how to represent the exchange of services among agents 
and     how to model actions in terms of state variables 
      mapping atoms to variables
from our point of view  both action models and system states can be represented in terms
of a finite set of multi valued state variables  each of which has a finite and discrete domain 
given the map system s ht   res  p i  we associate all agents in t and resources in
res with a set of state variables  each of these variables maps a subset of atoms of the
corresponding propositional representation 
it follows that the current system state is given by the values currently assigned to the
state variables of all agents and resources  such a global view  however  is inadequate to
achieve a fully distributed framework  we thus introduce the notion of agent state  which
just captures the portion of the system state relevant for a specific agent i in the team 
each agent i  t is associated with a set vari of variables  each variable v  vari has
a finite and discrete domain dom v   a state sli for agent i at a given execution step l is
therefore an assignment of values to the variables in vari   more precisely  sli  v   dom v 
is the value assumed by variable v  vari in the agent state sli   a partial agent state li
is an assignment of values to just a subset of variables in vari  
variables in vari are partitioned into two subsets  end i and env i   set end i includes
endogenous state variables  e g   the agent position   whereas env i includes variables about
the shared resources  because of the partitioning of the global system state into agent states 
the state variables of the resources are duplicated into as many copies as there are agents in
t   therefore  for each resource resk  res   there exists a private copy resik belonging to
env i   to maintain the consistency among these private copies  we rely on two assumptions 
    map p is flaw free  and     p satisfies the resource safeness requirement  these two
 

ficooperative monitoring to diagnose multiagent plans

assumptions induce on variables in env i an implicit constraint  at each execution step
only one agent i knows the actual state of a given resource resk   as a consequence  only the
private copy resik keeps the correct value  for all the other agents  resource resk is out of
sight  this is modeled by assigning the value unknown to their local variables about resk  
namely  for each j    i  resjk  unknown  thus the consistency among the different private
copies is implicitly maintained 
of course  when agent j acquires resource resk from agent i  it also comes to know the
actual state of that resource  the values of variables in env i can in fact be exchanged
among the agents  in section     we present a basic cooperative protocol that enables the
agents to share their knowledge about the resources while preserving the resource safeness
requirement  such a basic protocol will be later extended in section      variables in end i  
on the other hand  refer to agent i  and in our framework cannot be shared with other
agents 
      mapping services to variables assignments
since we adopt a representation based on state variables  also a service exchanged between
two agents is conveniently modeled as a value assignment to a resource variable  for instance  the causal link lk   hai   available resk    aj i is used in the propositional representation
to model that action ai  ai provides action aj  aj with resource resk   the same link can
be rewritten in the state variables representation as hai   resk   available  aj i  where resk
is the name with which agents i and j refer to a specific resource in res   in other words 
resk is a sort of meta variable that is known both by agent i and agent j  of course  each
agent maps the meta variable resk into its own private copy  more precisely  by means of
the link hai   resk   available  aj i  agent i is able to communicate j a change in the state of
resource resk   agent j knows that  after the execution of ai   its private variable resjk has the
value available  meaning that j can now use resk   it is worth noting that available is just
a special value  used by agents for exchanging resources  in general  agents communicate
each other domain dependent values about the state of a resource  e g   the position of a
block in the blocks world domain  
relying on the state variables representation  we can identify the set of resources
available to a given agent i at the l th plan execution step as availresi  l     resk 
res  sli  resik     available   in the next subsection we focus on a coordination protocol
that allows agents i and j to exchange information about the shared resources 
      mapping propositional action models to function like models
let q be a subset of the state variables vari   in the rest of the paper we denote with  q 
the space of possible assignments to the variables in q  and with q we denote a specific
assignment in  q   that is  a specific partial state for agent i  in the rest of the paper
we use premises ali   and effects ail   to denote the subset of status variables in vari over
which preconditions and effects  respectively  of action ail are defined  thus premises ail  
represents a specific assignment of values in the space  premises ail     note that the set
of premises includes also those services that must be provided by other agents  and which
therefore correspond to incoming causal links for action ail   similarly  the set of effects
 

fimicalizio   torasso

includes also those services that agent i provides other agents with  encoded as causal links
outgoing from ail  
given an action instance ail  ai   the deterministic  nominal  model of ail is a mapping 
  premises ail    effects ail  
fanom
i
l

where premises ail   is an assignment of variables in premises ail    var i representing
the preconditions of ail   and effects ail   is an assignment of variables in effects ail    vari
modeling the effects of the action  we also assume that effects ail    premises ail    this
is not a substantial limitation  however  any variable v  that in principle would only be
mentioned in the effects of an action model  can also be mentioned in the premises of
the action by allowing v to assume any possible value of its domain  the reason for this
assumption will be clear in section     where we formalize the notion of exogenous events 
since we are interested in the execution of plans  we reformulate the applicability of
an action to a state  see nebel        in terms of executability  given an agent state sli  
an action instance ail  ai is executable in sli   vari   iff sli    premises ail    indeed 
this strong condition will be relaxed in the next section  using the same terminology by
roos and witteveen         we can say that action ail is executable in sli only if ail is fully
i
in
enabled in sli   the result of the execution of ail enabled in sli is the new agent state sl  
i
 var    called successor state 


 sli   effects ail     effects ail   if sli    premises ail   and




sli      and effects ail        
i
sl  
 




 
otherwise 

more precisely  sli   effects ail   is a partial agent state obtained by removing from sli
all variables mentioned in effects ail    such a partial state is subsequently completed with
i   this state
the new assignments in effects ail    yielding a new  complete  agent state sl  
transformation  however  is legal only when      action ail is fully enabled in sli  i e   sli     
and sli    premises ail     and     the action effects are consistent  i e   effects ail         
otherwise  the new agent state is undefined 

    plan execution under nominal conditions
the actual execution of a map requires some form of coordination among the agents 
the decomposition of the global plan into local plans  in fact  allows the agents to execute their actions in a fully distributed way without the intervention of a global manager 
agents execute actions concurrently and asynchronously  i e   no global clock is required  
in addition  differently from previous approaches  see e g   de jonge et al         micalizio
  torasso         where actions just take a single time slot to be completed and their execution is globally synchronized  we do not make any assumption on the duration of each
action  agent coordination is therefore essential in order not to violate the precedence and
causal constraints introduced during the planning phase  for the sake of clarity  we first
present a basic coordination strategy by assuming that 
  

ficooperative monitoring to diagnose multiagent plans

i
i
i
bade p i  hi i   gi   ai   e i   clocal
  cin
  cout
i 
   l   
   sli  i i
   while ail    ai do
  
sli  consume inter agent messages inbox 
  
if ail is executable in sli then
  
execute ail
i
  
sl  
 fanom
 sli  
i
l

  
obsil    gather observations
i
  
if sl  
 obsil       then
   
stop execution and propagate failure
   
end if
i
   
for each causal link lk  cout
such that lk   hail   v   d  ajm i do
   
notify agent j about the achievement of service v   d
   
if v  res and d   available then
i
   
sl  
 v   unknown
   
end if
   
end for
   
l l  
   
end if
    end while

figure    basic distributed plan execution  bade  strategy 
  action based observability  even though the agents do not have a complete view of the
environment  each agent is always able to observe the preconditions and the effects of
the actions it performs  in addition  observations are assumed reliable and correct 
we denote as obsil   the set of observations received by agent i at the l th plus  
execution step after the execution of the l th action  the observations obsil   can be
thought of as sets of value assignments to the variables in effects ail    that is  for each
variable v  effects ail    an assignment v   d belongs to obsil     where d  dom v  
  deterministic actions  actions can never fail and their models precisely define how the
agent state changes 
  static environment  the environment can change only as a consequence of the execution
of the agents actions 
these three strong assumptions will be relaxed in section    where we will present a more
complex coordination strategy that guarantees a consistent access to the resources even
when actions can fail 
      basic coordination protocol
the coordination protocol we adopt is very simple but effective  and exploits the causal links
i models  in fact  the exchange of a service resource between
in p i   each outgoing link in cout
agent i   the service provider   and another agent j   the service client  in order to support
the communication among the agents  we assume that each agent has an inbox  i e   a folder
where messages coming from the other agents are stored  whenever i executes an action
i   i sends a message for each outgoing link of ai notifying
ail having outgoing links in cout
l
i
the receiver that the needed service resource is now available  likewise  each link in cin
  

fimicalizio   torasso

models the exchange of a service resource in which i is the receiver and another agent j is
i   it waits for a
the provider  whenever i has to execute an action having incoming links in cin
message for each of these links since the action becomes executable only when all the required
services resources are provided  under the assumptions made about the map p   this
protocol guarantees that resources are always accessed consistently  in fact  by assumption
p satisfies the resource safeness requirement  which assures that working sessions over the
same resource are totally serialized  in particular  two working sessions wshres ii  ws hres ji are
serialized by means of a causal link hclosing wshres ii    res   available  opening ws hres ji  i 
therefore  when wshres ii closes  agent i notifies agent j that resource res is now available 
    basic distributed plan execution  bade  strategy
the high level plan execution strategy performed by each agent i in the team is outlined
in figure    the strategy consists of a loop that iterates as long as there are actions in
p i to be executed  the first step in the loop is to acquire new information from other
agents about the shared resources  to accomplish this task  agent i plays the role of client
of our coordination protocol and gathers all the notification messages  if any  sent by other
agents  these notification messages  i e   the value assignments they convey  are asserted
within the current agent state sli so that i updates its local view about the system status
and acquires  if available  new resources  after this step  the next action ail is selected  if
ail is not executable yet  agent i keeps waiting for further notification messages  i e   some
services resources are still missing   otherwise  the agent executes ail in the real world  and
i
   note that
by exploiting the nominal model fanom
then estimates the successor state sl  
i
l

the actual execution of ail in the real world may take some time which is not necessarily
known in advance  
once the action ail has been completed  the agent gathers observations about the efi  
fects of the action and matches these observations with the estimated successor state sl  
since we are assuming that actions cannot fail  no discrepancy between observations and
estimations can be discovered  we include the control in line   for compatibility with the
extension described in sections   and    where actions may fail 
after the execution of ail   agent i plays the role of provider in our coordination protocol
and propagates the  positive  effects of action ail towards other agents by sending a notificai  see lines    through    of the algorithm in
tion message for each outgoing link of ail in cout
figure     in particular  in case agent i has just released a resource  v  res   the agent
sets its private copy about that resource to unknown  in this way the resource becomes
unreachable to i and the mutual exclusive access is guaranteed 
the last remark about the basic strategy regards the increment of counter l  note that
l is only incremented when an action is executed  thus l does not correspond to a metric
time  but it is a pointer to the next action to be performed  adhering to the bade strategy 
an agent can conclude its own local plan within a finite amount of time 
proposition   let s   ht   res  p i be a map system such that p is flaw free and satisfies
the resource safeness requirement  if all agents in t follow the bade strategy in figure   
then p is successfully completed in a finite amount of time 
  

ficooperative monitoring to diagnose multiagent plans

proof  it is sufficient to show that at least one action of p is always in execution  at
each step  until the achievement of the goal  by contradiction  let us assume that the goal
has not been reached  and no action is in progress  since we assume here that no failure
can occur  this situation can happen when agents are in deadlock  waiting for services no
one will provide them with  a deadlock may arise either because of an erroneous planning
phase  but then p is not flaw free as initially assumed  or because the bade coordination
strategy is erroneous  let us show that when all agents adopt the bade strategy  and no
failure occurs  the agents never wait indefinitely for accessing a resource  since p satisfies
by assumption the resource safeness requirement  it must hold that wshres ji   wshres ii   i e  
closing wshres ji   provides opening wshres ii    i e   ail   with service res   available  agent
i waits for service res   available only in two situations      agent j has not performed
action closing wshres ji   yet  correct behavior   or     agent j has already performed action
closing wshres ji    but has not sent the appropriate message to i  this second case contradicts the hypotheses that the agents adopt the bade coordination protocol  in fact  as
required by the protocol  whenever a working session wshres ji closes  agent j has to send a
message to the next agent accessing that resource 
therefore  if agents are never in deadlock  at least one action is always in execution  and
since p has a finite number of actions  the goal g must be achieved within a finite amount
of time 

example    we conclude the section by briefly exemplifying the concepts introduced so
far  in particular  we present here the office like domain we used as a test scenario for our
experiments  section     this domain is similar to the ones adopted by micalizio       
and steinbauer and wotawa         in this domain  robotic agents deliver parcels to the
desks of a number of clerks  a robot can carry one or two parcels depending on whether
they are heavy or light  respectively  figure   shows the office like environment we used for
our tests  it includes    desks  distributed over   office rooms  which are connected to each
other by means of   doors  moreover  two repositories contain    parcels to be delivered
   light and   heavy   parcels  repositories  doors  and desks are all critical resources as
they can be used and accessed by only one agent per time  the domain also includes three
parking areas  these are locations where more agents can be positioned simultaneously as
they are not critical resources   the term location is used to identify either parking areas
or resources where agent can be physically positioned  e g   parcels are not locations  
agents can perform the following actions  move from a location to another  load unload
parcels within resources which are locations  i e   not in parking areas   in addition  we
impose that no more than one parcel can be positioned on a desk  while repositories have
unlimited capacity  finally  agents can carry one heavy parcel or two light parcels from a
location to another 
figure   shows a simple example of map in our office domain  the team involves three
agents a   a   and a   whose plans are in given in three columns  respectively  at the
bottom of the picture the effects of pseudoaction a  represent the initial states of the three
agents  at the top of the picture  the premises of pseudoaction a represent the desired
final state  the objective of the map in the figure is to deliver parcel  to desk   i e   an
agent has to unload parcel  when positioned in desk    and then to bring the parcel back to
its initial position in repository repos   similarly  parcel  has first to be delivered to desk  
  

fimicalizio   torasso

figure    the office like environment used for the experiments  five rooms r  r   two
repositories  repos  and repos   eight doors  nine desks  and three parking areas 

and brought back to repository repos   while parcel   that has already been delivered to
desk   has to be delivered to desk   to ease the readability of the picture  we only show the
inter agent causal links  we use two different graphical notations to distinguish between
causal links giving access to resources  diamond headed   and the causal links that model
other kinds of services  black circle headed   for instance  the link between actions a   and
a   is diamond headed  this means that action a   provides a   with service desk    available
 i e   after a     agent a  has no longer access to desk    the three dashed rectangles in the
picture represent the working sessions associated with resource desk   which is used by the
three agents at different execution steps   the working sessions for the other resources have
not been highlighted to avoid the picture becoming too confused  
black circle headed links are used to represent all the other services  for instance  the
  encodes the service desk  content empty 
link between actions a   and a    labeled as  
required by action a   since at most one parcel can be located on a desktop  the link labeled
   from a   to a     encodes two services  desk  content parcel  and parcel  pos desk  
as 
  but they refer to desk  and parcel  
similar services are encoded by link  


   extending the framework
in the previous section we have described a simple coordination strategy that guarantees
the consistent execution of a map p when three strong assumptions hold      each agent
has an action based observability  it can precisely observe the preconditions and the effects
of the actions it performs      the environment is static  no exogenous events are permitted  
and     the actions are deterministic  no deviation from the nominal behavior is possible  
henceforth we extend the basic framework by relaxing these three assumptions and  as a
consequence  by increasing the complexity of the strategy for controlling the distributed
plan execution 
  

ficooperative monitoring to diagnose multiagent plans

parcel  pos repos 
parcel  delivered desk 
a  pos p 

a
parcel  pos desk 
parecel  delivered desk 
a  pos p 

parcel  pos repos 
parcel  delivered desk 
a  pos p 

a   

move repos   p  

a   

a   

unload repos   parcel  

a   

a  

move repos   p  

repos 

a   

carry desk   repos  

move door   p  

a  

a  

unload repos   parcel  
repos 

 


a  

load desk   parcel  

move desk   door  

carry door   repos  

desk 

a  

a  

a  

move door   desk  

unload desk   parcel  

a  

a  

door 

move p   door  

carry door   desk  

 


a  

move p   desk  

desk 

move door   desk  

a  

unload desk   parcel  

move desk   door  

a  

a  

carry door   desk  

unload desk   parcel  

a  

a  

carry repos   door  

a  pos p 
desk  avail
desk  avail
parcel  pos desk 
parcel  delivered desk 
door  avail

load desk   parcel  

a  

load desk   parcel  
desk 

a  
a  

move desk   p  

a  

parcel 

a  

a  
carry desk   door  

carry desk   door  

 


carry repos   desk  

a  

a  

load repos   parcel  

load repos   parcel  

a  

a  

move p   repos  

move p   repos  

a  pos p 
repos  avail
parcel  pos repos 
parcel  delivered no
door  avail

a  pos p 
repos  avail
parcel  pos repos 
parcel  delivered no
desk  avail
door  avail

a 

figure    a simple example of map in the office like domain used for testing 

  

fimicalizio   torasso

    partial observability
the first assumption we relax is the action based observability  in the basic framework 
the observations obsil   agent i receives at the  l      th step of execution cover all the
variables in effects ail    in the extended framework  obsil   becomes just partial since only a
subset of variables in effects ail   is covered in general  and possibly obsil can even be empty 
also in this case we assume that the observations are correct  meaning that the actual
state of an agent cannot be inconsistent with the observations received by the agent itself 
however  observations can be ambiguous in the sense that for a given variable  an agent
just receives a disjunction of possible values  in addition  to guarantee the termination of
the plan execution phase  we assume that each agent observes at least the achievement of
the atoms in its local goal gi  g 
    plan threats
the second extension is about the dynamics of the system  we move from a static system
to a dynamic one  this means that  besides the changes due to the agents actions  the
system can also change as a consequence of exogenous  unpredictable events  which typically represent plan threats  birnbaum  collins  freed    krulwich        for the nominal
execution of the plan  intuitively  a plan threat can be seen as an abrupt change happened
in the environment  i e   resources   or in the state of an agent 
in this paper we associate the occurrence of an exogenous event to the execution of
an action  in other words  an exogenous event can only occur during the execution of
an action and can only affect the active variables of that action  namely  the variables
mentioned within the premises and the effects of the action  thus  an exogenous event
cannot affect simultaneously two or more actions  but it can have indirect effects on many
actions  even of different agents  by means of the shared resources 
in principle  given an exogenous event   one could define a model to predict how  will
affect the execution of an action  in real world domains  however  it is not always possible
to precisely know in advance the actual impact of an exogenous event  on the one hand 
 may have non deterministic effects  on the other hand  not all the effects of  may be
known  to take into account the possibly non deterministic effects of exogenous events  we
model an exogenous event  as a relation happens  defined as follows 
happens   affectedby          affectedby   

   

where affectedby   vari   and  affectedby    is the space of partial agent states defined
over affectedby    it is worth noting that  affectedby    can only be empty when affectedby  is
empty  too  this enables us to state that  when an exogenous event occurs  then a variable in
affectedby  must necessarily evolve unexpectedly  thus  each tuple in the relation happens 
represents a non deterministic effect of   namely  each tuple represents a possible abrupt
change in some agents status variables 
to deal with not known effects of an exogenous event   we extend the domain dom v 
of each variable v  vari with the special value unknown which leaves open any possible
evolution for v 
we denote as x the set of all exogenous events which might occur during the plan
execution  note that x also includes a pseudo event  modeling the absence of abrupt
  

ficooperative monitoring to diagnose multiagent plans

changes  only for this special event it must hold that affectedby      since an exogenous
event  is defined as a state transition over agents state variables   can only affect an
action ail iff
affectedby   effects ail   
   
namely   affects a subset of the variables over which action ail is defined 
given an action ail   x  ail   denotes the subset of exogenous events in x which satisfy
relation      note that  the pseudo event  is always included in x  ail    for any action
ail  ai   since affectedby   i e   the empty set  trivially satisfies relation     
    extended action models
the last extension we propose is about the action models  since plan threats occur during
the execution of actions  their effects combine with the actions effects  to estimate how
the system evolves over time  it is essential to extend the nominal action model in order to
encode  in a single piece of knowledge  the nominal as well as the anomalous evolutions of an
action  intuitively  such an extended model should describe how an agent state sli evolves
i
when agent i has carried out an action instance ail   and when 
into a new agent state sl  
during the execution of the action  an exogenous event   x has occurred  possibly just  
moreover  in the basic framework we give for granted that an action is performed when it is
fully enabled  in our extended framework this condition is not necessarily satisfied  due to
the partial observability  in fact  agent i may be unable to precisely determine whether its
next action is fully enabled or not  to cope with this situation  we introduce in section    
the concept of possibly enabled action  for the time being  we just anticipate that an agent
may decide to perform an action even when that action is not fully enabled  and hence the
extended action model must be so rich to estimate how the state of agent evolves even in
such a situation 
  given
the extended model m ail   of action ail is derived from the nominal model fanom
i
l

in terms of premises and effects  and from the set of exogenous events x  ail    it is formally
defined as 
  x  ail     ail     ail  i 
m ail     hfanom
i
l

and x  ail   have already been introduced  whereas  ail   and  ail   are two
where fanom
i
l

transition relations between partial states in  premises a   and in  effects a    through
which it is possible to predict how the execution of action ail changes the state of the
environment  i e   the resources held by i  and of agent i itself 
relation  ail   estimates the next agents states when action ail is fully enabled in a
state sli   this relation results from the combination of the nominal action model with the
models of the exogenous events in x  ail   
 ail    

 

fi happens   
 fanom
i
l

x  ail  

   

intuitively  fanom
fi happens  is a set of tuples of the form hpre    eff i  where pre equals
i
l

premises ail    and eff   effects ail    models the abrupt changes caused by event  to the
  

fimicalizio   torasso

nominal effects of action ail   formally  for each happening h       i in happens  it holds 


premises ail          effects ail     affectedby        




 
if sli    premises ail   and premises ail       
fanom
fihappens   
i
l


h    ihappens  

 otherwise 

   
it is important to note that  since  is always part of x  ail    the nominal model hpremises ail   
  effects ail  i is always included in  ail    in particular  in such a state transition  no variable can assume value unknown  this follows directly by      the nominal model fanom
i
l

cannot mention the unknown value by definition  and     the exogenous event  cannot
fi happens  just
affect any variable since affectedby  is empty  thus  the operation fanom
i
l
reproduces the nominal behavior 
in addition  note that x  ail   can also include a special exogenous event     this symbol
denotes an indefinite exogenous event for which no model is given  and hence all variables
in effects ail   are mapped to unknown  after the occurrence of   no prediction is possible 
relation  ail   has the same structure as  ail   in terms of preconditions  effects and
exogenous events  but represents a dual version of  ail   since it is defined when ail is not
executable in sli   in fact   ail   is defined in all those states where action ail is not enabled 
let  premises ail    be the space of assignments of values to the variables in premises ail   
 ail   is defined over the space of states  premises ail     premises ail      premises ail  
as 
 ail     premises ail           hunknown          unknowni 
   
where   denotes an indefinite exogenous event as in   note that  ail   is a weaker model
than  ail   since it invariably assigns the unknown value to each variable in effects ail   
that is to say  whenever an action is performed in a wrong configuration  its impact on the
effects ail   variables becomes unpredictable  although we use the same symbol   to denote
indefinite events occurring in  ail   and in   they have slightly different meanings from a
diagnostic point of view that will be discussed in detail in section   
remark    the relational action models we propose are sufficiently flexible to deal with
incomplete or imprecise knowledge  in many cases  in fact  it may be too costly  or even
impossible  to determine how exogenous events impact the variables in effects ali    the
extended framework copes with this problem by allowing three forms of incompleteness 
  the unknown value included in the domain of each variable allows to represent that  as
an effect of an exogenous event  the value of a variable becomes no more predictable 
in the extreme case  all the variables in the effects of an action are set to unknown
 see the weak model for the exogenous event     
  non deterministic action evolutions can be defined  an exogenous event may have
non deterministic effects on the states of the agents 
  the weak relation  allows us to model the status of an agent after the execution of
an action under wrong conditions 
  

ficooperative monitoring to diagnose multiagent plans

remark    since actions can be performed even though they are not fully enabled  how
can we guarantee that the execution of the plan does not violate the resource safeness
requirement  the answer to this question is in the coordination protocol which is part of
the cooperative weak committed monitoring  cwcm  strategy discussed in section    it
is useful to anticipate  however  that the coordination protocol guarantees that an agent
uses a resource only when its actions do not violate the resource safeness requirement 
example    let us consider a simple example from the office domain  and assume that
agent a  is in charge of performing action carry a   parc   desk   desk    such an
action requires a  to move from its current position desk  to position desk  while it is
loaded with parcel parc   the nominal model for such an action can be expressed as the
state transition 
hpos   desk   cobj parc   parc pos  a     pos   desk   cobj parc   parc pos  a i 
where pos and cobj are two endogenous variables for a  representing the current position
of the agent and the carried object  respectively  the state of shared resource parc  is
encoded by variable parc pos   which is the private variable agent a  keeps to maintain
the position of parcel parc   for all the other agents  the local copy of variable parc pos
is unknown 
the actual execution of the carry action can be affected by a number of exogenous
events  for instance  wheelsblocked prevents the agent from moving at all  while wrongstep
allows the agent to move  but in a wrong direction  another event that can affect the
carry action is lostparcel   while the agent is moving  the carried object s  is lost  finally 
  denotes an unpredictable event occurring when the carry action is attempted in a state
in which its preconditions are not satisfied  all these alternative situations are summarized
within the extended model showed in table    the first entry of the table is the nominal
state transition  the only one labeled with   entries from   to   describe how the action
behaves when some known exogenous event occurs  note that  although the exogenous
event is one of the foreseen possibilities  not all its effects may be precisely known  for
instance  as an effect of wrongstep and lostparcel some of the variables assume the value
unknown  the first five entries of the table represent the  relation of the extended model 
the last entry of the table  instead  is the  relation which allows us to make just weak
predictions  the tuple hpos    cobj    parc  place  i is just a shortcut to represent any
possible assignment in which the preconditions are not satisfied  note that  from a practical
point of view  it is not necessary to compute this  potentially huge  set explicitly  as we
discuss in appendix a about the implementation 

    extending some basic concepts
since we have relaxed the three assumptions of the basic framework  we have to review
three important concepts  the state of an agent  the executability of an action  and the
outcome of an action 
  

fimicalizio   torasso

end

t 
t 
t 
t 
t 
t 

env

end

env

pos

cobj

parc pos 

event

pos

cobj

parc pos 

desk 
desk 
desk 
desk 
desk 
 

parc 
parc 
parc 
parc 
parc 
 

a 
a 
a 
a 
a 
 



desk 
desk 
unknown
desk 
desk 
unknown

parc 
parc 
parc 
empty
empty
unknown

a 
a 
a 
desk 
unknown
unknown

wheelblocked
wrongstep
lostparcel
lostparcel
 

table    the extended model for the action instance carry a   b   desk   desk   from
the office domain 

      agents belief states
first of all  each agent in the team must be able to deal with some form of uncertainty 
since actions may evolve non deterministically and since the agent cannot observe all the
effects of its actions  an agent must be able to deal with belief states rather than with agent
states  like an agent state sli   an agent belief state bli encodes the knowledge agent i has
about itself at the l th execution step  while sli is the precise state assumed by i at step
l  bli is a set of possible agent states consistent with the observations received by i  in the
rest of the paper we use lowercase s to indicate an agent state among others within a given
belief state  while we use uppercase s to indicate the actual agent state at a given execution
step  it is important to note that  exactly as an agent state sli   a belief state bli is defined
over all the state variables of agent i  but two states s  and s  in bli differ for at least one
variable  in other words  there must exists at least one variable v  varil such that s   v  
the value assumed by v in s    is different from s   v   of course  this ambiguity represents
an issue in understanding whether the next action ail is executable 
      possibly enabled actions
since we have an agent belief state bli   also the notion of action executability needs to be
revised  a very conservative policy would require action ail to be fully enabled in every
state s in bli   but due to the partial observability this condition might not be satisfied  so
the execution of a map could be stopped because no action is enabled even though no plan
threat has occurred 
to avoid this situation  we propose a more optimistic policy and introduce the notion
of possibly enabled action 
definition   optimistic policy action ail is possibly enabled in bli iff s  bli such that
ail is fully enabled in s  namely  s    premises ail   
it is worth noting that the value unknown cannot be used to qualify an action as fully
enabled  such a value  in fact  is used explicitly to state that the agent does not know the
value of a variable  therefore  if variable v has value unknown in a state s  and v is also
mentioned in premises ail    then ail is not fully enabled in s 
a possibly enabled action is therefore a sort of conjecture  since the action premises
are satisfied in at least one state of the belief state  the action is assumed executable  of
  

ficooperative monitoring to diagnose multiagent plans

course  it may be the case that s  although possible  is not the real state of the agent  and
hence the action is performed when its preconditions are not satisfied in the real world 
      action outcome
in the basic framework we have given for granted that the outcome of an action is always
nominal  in the extended framework  however  actions can fail  we individuate three possible action outcomes  the nominal ok  the anomalous failed  and pending for the intermediate
situations 
i   s    effects ai   
definition   action ail has outcome ok iff s  bl  
l
i
 estimated after the execution of ail   
that is  the actions effects hold in every state in bl  
i
definition   does not hold when there exists at least one state s  bl  
where the nominal
effects are not satisfied  in some previous approaches  micalizio   torasso            a  
we have introduced and adopted the strong committed policy  when the effects of action ail
i   the action has outcome failed  see
are not satisfied in each state of the belief state bl  
definition     the strong committed policy is based on the assumption that  whenever action
ail has been successfully completed  agent i receives an amount of observations sufficient to
detect the success  thereby  when the success cannot be detected  a failure must have
occurred 
this policy  however  may be unacceptable in some real world domains where there are
no guarantees about the system observability  as a consequence  agent i could infer a failure
even when action ail has been completed with success  but the observations are not sufficient
to confirm it 
in this paper we define the failure of an action as the dual case of the success 
i   s     effects ai   
definition   action ail has outcome failed iff s  bl  
l
i
a state s in which all the expected effects of ail
namely  it is not possible to find in bl  
have been achieved 
in all those situations where neither the success  definition    nor the failure  definition
   can be inferred  the action outcome is pending 
i   s    effects ai   and s   b i  
definition   action ail has outcome pending iff s  bl  
l  
l
 
i
s     effects al   

in other words  whenever agent i is unable to determine the success or the failure of
action ail   it postpones the evaluation of the action outcome to some step in the future  the
action is enqueued into a list pactsi of pending actions maintained by agent i  we refer
to this policy as weak committed since the agent does not take decisions whenever there
are insufficient observations sufficient to support them  in the next section we discuss the
impact of the weak committed policy on the monitoring task 

   cooperative weak committed monitoring
in this section we discuss a fully distributed approach to the problem of monitoring the
execution of a map  we consider the extended framework previously discussed which introduces two sources of ambiguity  the agent belief states  and the ambiguous action outcomes 
  

fimicalizio   torasso

to cope with these forms of uncertainty  we propose a monitoring methodology called
cooperative weak committed monitoring  cwcm   which relies on the weak committed
policy  the cwcm approach allows an agent to detect the outcome of an action some
time after its execution  the idea is that the possibly uncertain knowledge an agent has
about the environment and itself can be refined over time by exploiting observations that
the agent will receive in the future  to get this result  cwcm allows the team members to
cooperate with each other during their monitoring tasks 
the rest of this section is organized as follows  we first formalize the notion of trajectoryset maintained by each agent  and explain how the extended action models can be used
to extend the trajectory set one step further  then we discuss how the trajectory set
is refined through the observations and how this helps in determining the outcomes of
pending actions  if any   finally  we redefine the cooperative protocol sketched in the basic
framework to obtain a cooperative monitoring protocol  cwcm is entirely formalized in
terms of relational algebra operators   for a short introduction to the used operators  see
micalizio        
    trajectory set
the weak committed approach requires that an agent be able to reason about its past 
this means that the agent cannot maintain just the last belief state  but it has to keep a
trajectory set  i e   a sequence of belief states that traces the recent history of the agents
state 
we define a trajectory set as a generalization of an agent trajectory  an agent trajectory
for agent i  denoted as tr i     l   is defined over a segment  ai            ail    of the local plan p i  
and consists of an ordered sequence of agent states interleaved with exogenous events in x
 including    an agent trajectory represents a possible evolution of the status of agent i 
consistent with the observations the agent has received so far  more formally 
definition   the agent trajectory tr i     l  over the plan segment  ai            ail    is
tr i     l  hs    e    s            el    sl i
where 
  sk  k      l  is the state of agent i at the k th step such that obsik  sk      
  eh  h      l     is an event in x  ah   labeling the state transition from sh to sh    
an agent trajectory is therefore a sequence of agent states  interleaved by events  that traces
the agent behavior along a given plan segment  for the sake of discussion  we consider the
plan segment as starting from the first performed action ai    in practice  however  the plan
segment under consideration can be an intermediate portion of an agents local plan  we
will return on this point in section     
since each state sk  k in     l   is a complete assignment of values to the agent state
variables in vari   these variables are duplicated as many times as there are actions in the
plan segment under consideration  in the following  we will denote as varik the copies of
the state variables referring to the k th execution step 
as noticed above  however  the partial system observability is in general not sufficient for
the estimation of a unique trajectory  for this reason agent i keeps a trajectory set t r i     l  
  

ficooperative monitoring to diagnose multiagent plans

which contains all possible agent trajectories tr i     l  consistent with the observations received during the execution of the plan segment  ai            ail    
note that  given a trajectory set t r i     l   the agent belief state at any execution step k
in     l  can easily be inferred by projecting t r i     l  over the state variables varik  
bki   projectvari  t r i     l  
k

   

thus definitions    possibly enabled actions      successfully completed actions      failed
actions   and    pending action   which are all based on belief states  are still meaningful
and do not require to be redefined 
in the rest of the paper  the term trajectory frontier  or simply frontier  refers to the
last belief state maintained within a trajectory set  for instance  the frontier of t r i     l  is
the belief state bli   as a general rule  we use l to denote the index of the last execution step
 and hence of the frontier   while k is used to refer to a generic execution step in     l  
    extending the trajectory set
the extension of a trajectory set corresponds to the predictive step of the basic framework
through which the next agent state is estimated  however  while in the basic framework this
step was as easy as a mapping from a state to another  we need a more complex procedure
in our extended framework  given the current trajectory set t r i     l  and the extended
model m ail    the estimation step is defined in relational terms as follows 
t r i     l        t r i     l   m ail     t r i     l  join   ail     ail    

   

the new trajectory set t r i     l      is built with the contribution of both  and 
relations  both relations are in fact used to estimate how the execution of action ail changes
the state of the system  relation  is applied to that portion of bli where action ail is fully
enabled  whereas  relation  is applied to all those states in bli where action ail is not
enabled  i e   the occurrence of an exogenous event has already been assumed 
    refining the trajectory set with observations
in the basic framework we have assumed that  whenever action ail is completed  the agent
i   in the extended framework 
receives observation obsil   just about the new agent state sl  
agent i can also receive observation obsik referring to a past execution step k  i e      k  l  
in the next section we present the cooperative monitoring protocol that is at the basis of
such a message passing among the agents  in this section we discuss how an observation
about the past is handled by a given agent i  intuitively  consuming observation obsik means
selecting from bki all the states that are consistent with it  in relational terms 
refined bki   selectobsi bki
k

   

the result is a refined belief state which is less ambiguous than the original one as a number
of states inconsistent with the observations have been pruned off 
it is important to note that the unknown value is consistent with any concrete observed
value  therefore  for each state s  bki   if a variable v is unknown in s  but v is mentioned
in obsik   then v assumes the observed value obsik  v  in refined bki   note that we do not allow
an observed variable in obsik to assume the value unknown 
  

fimicalizio   torasso

bla 
s l



s l  
wheelblocked
wrongstep

s l

a 
bl  

s l  
s l  

lostparcel
lostparcel
 

s l  
s l  
s l  

figure    a one step trajectory set corresponding to the transition from step l to step l     

example    let us consider again the office domain  and assume that after l steps  the
trajectory frontier of agent a  consists of the following belief state bla   
s l   h pos   desk   cobj   parc   parc pos   a  i
s l   h pos   unknown   cobj   parc   parc pos   a  i
namely  bla  consists of two alternative agent states s l and s l   let us assume that
the next l th action performed by a  is a carry action  whose model has been previously
presented in table    according to equation      it is easy to see that s l matches with
state transitions t  through t  of the carry action model   portion of the model   whereas
state s l matches with transition t    portion of the model   figure   gives an idea of how
these two relations are used to infer the new frontier 
s l     h pos   desk   cobj   parc   parc pos    a  i
s l     h pos   desk   cobj   parc   parc pos    a  i
s l     h pos   unknown  cobj   parc   parc pos   a  i
s l     h pos   desk   cobj   empty  parc pos   desk  i
s l     h pos   desk   cobj   empty  parc pos   unknown i
s l     h pos   unknown   cobj  unknown  parc pos  unknown i
now  let us assume that agent a  receives the observation obsa 
l      hpos   desk i  
which is used to refine the new frontier  it is easy to see that obsa 
l   is consistent with all
the states except s l     in which pos is assigned to a different value  states s l   and s l  
are consistent with obsa 
l   because the unknown value is consistent with any precise value 
the new refined frontier is therefore
s l     h pos   desk   cobj   parc   parc pos    a  i
s l     h pos   desk    cobj   parc   parc pos    a  i
  

ficooperative monitoring to diagnose multiagent plans

s l     h pos   desk   cobj   empty  parc pos   desk  i
s l     h pos   desk   cobj   empty  parc pos   unknown i
s l     h pos   desk    cobj  unknown  parc pos  unknown i
it seems that s l   and s l   are now identical  indeed we do not just consider single
belief states  but trajectories  these two states differ in the way they are achieved  s l   is
inferred assuming that everything goes smoothly  s l   is inferred assuming that something
wrong has occurred  i e   wrongstep    of course  this second hypothesis is not plausible
and we will discuss in the next section how it can be pruned off the trajectory set 

this example shows how consuming a set of observations obsik reduces the ambiguity
within the agent belief state bki   in addition  the consumption of messages has also a
beneficial effect in reducing the ambiguity of the trajectory set t r i     l   in fact  the refined
belief state can in turn be used to filter the trajectory set as follows 
refined t r i     l    selectrefinedbi t r i     l  
k

   

the refined t r i     l  maintains all and only the trajectories that at their k th step have a
state in refined bki   this is an important result since an agent can take advantage of the
observations whenever they are available  even though they refer to a past execution step 
it may happen  in fact  that even though obsik is not enough to determine the outcome
of action aik    another belief state bhi  refined t r i     l  becomes sufficiently precise to
determine the outcome of the pending action aih    in the next section  we exploit this
characteristic to determine the outcomes of pending actions 
    inferring and propagating action outcomes
whenever the current trajectory set is refined with observations  it is useful to scan the
pending action list pactsi   and assess  for each action aik  pactsi   whether either definition
  or   applies 
the outcome of an action is an important piece of information that we can exploit  as
well as observations  to refine the current trajectory set  the outcome of action aik   either
positive or negative  can in fact be used to infer the outcome of other actions in pactsi  
to reach this result we exploit the notions of causal predecessors of aik  predecessors aik    
and of causal successors of aik  successors aih     first of all  we say that action aih indirectly
provides action aik with a service  or that aik indirectly receives a service from aih   iff there
exists a sequence of actions aiv            aivn such that 
   aiv  coincides with aih
   aivn coincides with aik
i
 
   for each action aivx   x      n     there exists a causal link haivx   q  aivx   i in clocal

in other words  there must exist a chain of causal links that starts from aih   passes
through the actions in the sequence aiv            aivn   and ends in aik   indirect causal dependencies that pass through the plans of other agents are not considered by our definition 
for example  having the two causal links haih   q  ajv i and hajv   q     aik i  we cannot say that aih
  

fimicalizio   torasso

indirectly provides aik with a service since action ajv belongs to agent j  this is not a limitation  but an advantage as otherwise the agents should interact heavily in order to compute
indirect causal relations  this notion of indirect dependency between actions is at the basis
of a locality principle that allows an agent to consider just a portion of its local plan during
monitoring and diagnosis 
the set predecessors  aik   is therefore the subset of ai including all and only the actions
that directly or indirectly provide aik with a service  on the other side  successors aik   is
the subset of ai including all and only the actions which  directly or indirectly  receive a
service from aik  
i
given an action aik   we denote as chains to aik   the subset of causal links in clocal
defined
i
i
between actions in predecessors ak    similarly  we denote as chains f rom ak   the subset
i
defined between actions in successors aki   
of causal links in clocal
proposition   let aik be an action whose outcome is ok  then all the causal links in
chains to aik   represent services that have been satisfied 
in fact  if aik has outcome ok  then all the services required by aik were satisfied  and
recursively  all the services required by the actions in predecessors aik   were satisfied too 
proposition    backward propagation of success  let aik be an action whose outcome is ok  and let us mark as satisfied all causal links in chains to aik    then any action
a  pactsi  predecessors  aik   having all outgoing links marked as satisfied  has outcome ok 
too 
proposition   let aik be an action whose outcome is failed  then the services in
chains f rom aik   might be missing 
in fact  since aik has outcome f ailed  at least one of its expected effects is missing  on the
other hand  action aik could have reached a subset of its effects  and such services could be
sufficient to enable some subsequent actions  the forward propagation of the failure must
therefore take into account the results successfully achieved  let us denote as miss aik   the
set of causal links leaving from aik representing missing services 
proposition    forward propagation of failure  let aik be an action whose outcome
is failed  and let us mark as missing each causal link cl in chains f rom aik   that is reachable
from one of the links in miss aik   via a chain of missing causal links  unless cl has already
been marked as satisfied  then  any action a  pactsi  successors aik    having at least one
outgoing link marked as missing  has outcome failed  too 
intuitively  properties   and   assume that an action performed when it is not fully
enabled does not produce correct results  on the other hand  an action that achieves all
its effects must have been performed when it was fully enabled  and hence all the services
mentioned in its premises must have been provided 
  

ficooperative monitoring to diagnose multiagent plans

a 

 

a 

 
   

 

a 

a 

 

 

a 

 

a 

a 

   

 

 
i
 
figure    a portion of a local plan restricted to causal links in clocal

example    in this example we show how the outcome of an action a is actually exploited
to determine the outcomes of other actions  of course  an agent is able to determine the
outcome of a relying on observations and messages from other agents  the cooperative
protocol is discussed in details in the following subsection  for the time being  it is important
to observe that 
 all the positive messages  formalized as confirm messages in the following  received
at a given step are processed before any negative message  i e   disconfirm message 
received at the same step 
 an agent receiving at least one negative message will stop the execution of its plan 
and start a diagnostic phase 
i
are shown 
let us consider the plan segment in figure    where only the links in clocal
and let us assume that agent i performs these actions in the order a    a    a    a    a    and a   
and that all these actions are pending  after the execution of a    agent i discovers that a  has
outcome ok  the outcome is propagated backwards  predecessors a       a    a     thereby
the links in chains to a             are marked as satisfied  of course  link   is also marked
satisfied because of the nominal outcome of a    this enables i to conclude that action a  has
outcome ok  whereas nothing can be concluded about action a  since links   and   are neither
marked as satisfied  nor as missing  let us assume now that i receives some observations
about the service on link    and as a consequence it concludes that a  has outcome failed 
in this case the outcome is propagated forwardly  successors a       a    a    a    a    a    a    
thereby chains f rom a                                however  links       and   have already
been marked as satisfied  in addition  links   and   are not reachable via chain of missing
causal links from link    thus  only links    and   are marked as missing  agent i hence
concludes that actions a  and a  have both outcome f ailed  no outcome is inferred for
action a    which remains pending  and no outcome is inferred for action a  that has not
been performed yet  the outcome of the pending action a  is inferred by means of diagnosis
inferences discussed in section   


relying on properties   and    we can determine the outcome of other pending actions
by just exploiting the causal dependencies existing among the actions  even though the
current trajectory set is still too ambiguous to apply either definition    outcome ok  or
definition    outcome failed  
  

fimicalizio   torasso

note that when we discover that action aih has outcome ok  the exogenous event occurred
during that action is necessarily   thus  we can also filter t r i     l  as follows 
refined t r i     l    selecteh   t r i     l 

    

where eh refers to the h th exogenous event labeling the transition from state sh to state
sh   in t r i     l   through the refinement in      we keep in t r i     l  all the trajectories
which at their h th exogenous event have   thus we keep the transitions that are obtained
through relation   and prune off spurious trajectories contributed by relation  
on the other hand  when the outcome of an action aih is f ailed  we cannot refine the
trajectory set via eh since we just know that eh cannot be   but this is already implicitly
obtained thanks to the refinement in equation     
summing up  our weak committed methodology is able to deal with very scarce observations by using two essential mechanisms  first  we build a trajectory set maintaining
the history of an agent state  and we keep a list of pending action outcomes  second  we
take advantage from observations whenever they are available by revising the knowledge an
agent has about itself  in the very favorable case  this revision process can empty the set of
pending actions 
    cooperative monitoring protocol
the last element of our cwcm methodology is a cooperative monitoring protocol that
allows each agent to exploit information provided by others  the idea is that an agent can
take advantage not only of its own direct observations  but also of the observations that
other agents have about the environment  and in particular about the shared resources 
the cooperative protocol plays a central role in preserving the resource safeness requirement even when actions that are not fully enabled are performed 
      interaction scenarios
as in the bade strategy  in cwcm two agents  i and j  need to interact with each other
when they share a causal link lk   hail   v   d  ajm i where v  res  d  dom v   and v   d is
a value assignment representing the change in the state of some resource requested by agent
i    whereas 
j  contextually to lk  agent i plays the service provider role  with lk  cout
j
agent j plays the role of service client  with lk  cin    in the following we first present
the three interaction scenarios of cwcm  for each of them we shortly report the messages
exchanged between the two agents  then  we present the client and provider roles in detail
by means of high level algorithms 
 notify ready interaction in this interaction the provider is sure of having provided the
client with the requested service  thus  the provider i sends a message habout lk notify
v   d readyi to the client j  no answer from the client to the provider is required 
 notify not accomplished interaction in this scenario  agent i is sure that the requested
service is missing  it therefore sends agent j a message habout lk notify v   d notaccomplishedi to client j  no answer from j is foreseen 
 ask if interaction in this case  the provider i is unable to determine whether the
service v   d has been achieved  thus i asks j for more info by sending j a message
  

ficooperative monitoring to diagnose multiagent plans

cooperative protocol  client inbox  t r i     l   ail  
   for each message m  h about lk notify v   d ready i in inbox s t  lk is an incoming link for ail do
  
remove m from inbox
  
assert v   d in the frontier of t r i     l 
   end for
   for each message m  h about lk ask if v   d accomplished  i in inbox s t  lk is an incoming link for ail
do
  
remove m from inbox
  
if unable to observe v then
  
reply h about lk no info i
  
else
   
obs  observe v
   
if obs equals d then
   
reply h about lk confirm v   d i
   
else if obs is not equal d then
   
reply h about lk disconfirm v   d i
   
end if
   
end if
    end for
    for each message m habout lk notify v   d not accomplishedi in inbox s t  lk is an incoming message
for ail do
   
remove m from inbox
   
stop plan execution
    end for

figure    the pseudo code of the cooperative protocol  client behavior 
habout lk ask if v   d accomplished i  the client can reply to this message in three
different ways 
   habout lk confirm v   di  this message confirms to the provider that the expected
service v   d has actually been achieved 
   habout lk disconfirm v   di when the expected service is missing 
   habout lk no infoi when the client is unable to determine whether the assignment
v   d holds in the environment or not 
in case i receives a no info message from j  i will eventually reply either with a ready
message or with a not accomplished one 
      client role
the algorithm in figure   outlines the behavior of agent i when behaving as a client  this
algorithm takes as inputs the inbox  i e   a collector of messages coming from other agents  
the current trajectory set t r i     l   and the next action to be performed ail  
agent i consumes a message m from inbox only when m is about a service required as a
premise for the execution of ail   for each incoming message m of type ready  lines   through
    agent i uses the information provided by another agent as an observation  we use the
term assert  line    as a shortcut for the relational operations presented in equations    
and     
for each incoming message of the ask if interaction  lines   through      agent i determines whether it is capable of observing v  e g   is i equipped with the right sensor for v   
  

fimicalizio   torasso

in case i cannot observe v  it replies to the provider with a no info message  otherwise  the
agent acquires an observation of v  and replies to the provider accordingly 
finally  whenever agent i receives a not accomplished message  lines    through      i
just stops the execution of its plan as a service required for performing ail is missing  
it is important to note that an agent playing as a client consumes a message m only
if m is relevant for the next action to be performed  thereby  an ask if message could be
answered with a certain amount of delay 
      provider role
the provider behavior is outlined in figure    the algorithm takes as inputs the inbox  the
current trajectory set t r i     l   the list of pending actions pactsi   and the last performed
action ail   more precisely  the last argument can either be null  when no action has been
performed recently  or an actual action instance whose outcome has still to be assessed  we
refine the concept of recently performed action in the next section where we present the
main cwcm plan execution loop 
the algorithm starts by checking the inbox in order to consume answers  if any  to
previous ask if interactions  the algorithm specifies the behavior of agent i according to
the type of received message  in case of confirm messages  lines   through     agent i uses
v   d as an observation to refine its trajectory set  the term assert is used again as
a shortcut for the relational operations in equations     and      the belief state which is
actually refined is the k th     that is  the one that contains the effects of action aik   in
case of a disconfirm message  lines   through      agent i prunes off from the k th    belief
state in t r i     l  each state s in which v   d holds  in case of an incoming message of
type no info  line    through      agent i checks whether all the outgoing links of action
i
have been marked as ans no info  meaning that none of the services provided
aik in cout
i
by ak to other agents have been achieved for sure  if this is the case  agent i marks aik as
not enough info 
after these preliminary steps  agent i has possibly acquired some further information
from others  thus  it can assess the outcome of all pending actions in pactsi   including ail if
not null  line      the algorithm in figure   outlines the steps for assessing the outcomes of
actions in pactsi   and is discussed later on  here it is sufficient to say that assess pendingactions returns two lists of actions  ok list and f ailed list  which can be empty  and contain
actions whose outcome is ok or f ailed  respectively  of course  whenever an action in pactsi
is found to be either ok or f ailed  it is removed from pactsi   and added in the corresponding
list  this process also involves actions previously marked as not enough info 
if action ail is not null  an action has been performed recently   this is the first time
that the outcome of ail is assessed  thus  in case ail has outcome pending  line      agent
i starts an ask if interaction  lines        by asking for further information to all agents
that requires one of the services produced by ail   otherwise  ail is null or ail outcome is not
pending  and the ask if interaction can be skipped 
from line    through line     agent i just sends ready and not accomplished messages
according to the actions in ok list and f ailed list  respectively  in addition  agent i sends a
   the impact of an action failure can be estimated by means of a failure propagation mechanism  micalizio
  torasso      b   for the sake of discussion  we leave the topic out of this paper 

  

ficooperative monitoring to diagnose multiagent plans

cooperative protocol  provider inbox  t r i     l   pactsi   ail  
   for each message m habout lk confirm v   di in inbox do
  
remove m from inbox
  
let lk be haik   v   d  ajm i
  
assert v   d in the k th    belief state within t r i     l 
   end for
   for each message m habout lk disconfirm v   di in inbox do
  
remove m from inbox
  
let lk be haik   v   d  ajm i
  
prune from the k th    belief state within t r i     l  any state s in which v   d
    end for
    for each message m habout lk no infoi in inbox do
   
remove m from inbox
   
let lk be haik   v   d  ajm i
   
mark lk as ans no info
   
if all the links outgoing from aik are marked as ans no info then
   
mark aik as not enough info
   
end if
    end for
    hok list  f ailed listi  assess pending actions pactsi   t r i     l  
    if ail is not null and has outcome pending then
i
   
for each link lk hail   v   d  ajm i  lk  cout
 i    j  do
   
send to j message m h ask if v   d accomplished i
   
end for
    end if
    for each action aik  ok list do
   
for each link lk   haik   v   d  ajm i do
   
send to j message m habout lk notify v   d readyi
   
end for
    end for
    for each action aik s t   aik  f ailed list  or  aik  pactsi and marked as not enough info  do
   
for each link lk   haik   v   d  ajm i do
   
send to j message m habout lk notify v   d not accomplishedi
   
end for
    end for
    return hok list  f ailed listi

figure    the pseudo code of the cooperative protocol  provider behavior 

not accomplished message for each pending action aik marked as not enough info  a pending
action marked as not enough info highlights how scarcely observable the environment is 
in fact  neither agent i  nor other agents waiting for services provided by aik   are capable
of determine whether at least one of the expected services has been provided or not  to
deal with such an ambiguity  agent i prudentially considers the action as probably failed 
although this choice could seem strong  it is necessary to preserve the resource safeness
requirement in very scarcely observable environments  agent i has no evidence supporting
the successful achievement of the effects expected by ail   and hence i cannot notify the
success  at the same time  other agents might be waiting for the services provided by ail  
thus these agents would be stalling without even knowing it  considering ail as failed allows
i to get out of the impasse by notifying the failure to the other agents  which may attempt
some form of plan repair 
  

fimicalizio   torasso

assess pending actions pactsi   t r i     l  
   ok list    
   f ailed list    
   for each action aik  pactsi do
i
  
if s  bk  
  s    effects aik   then
  
ok list  ok list   aik  
  
t r i     l   selectek   t r i     l 
  
oks propagatesuccess pactsi   aik  
  
ok list  ok list  oks
  
pactsi  pactsi   oks
i
   
else if s  bk  
  s     effects aik   then
   
f ailed list  f ailed list   aik  
   
faultypropagatefailure pactsi   aik  
   
f ailed list  f ailed list  faulty
   
pactsi  pactsi   faulty
   
end if
    end for
    remove  if present  mark not enough info from any action in ok list or in f ailed list
    return hok list  f ailed listi

figure    the pseudo code for the assessment of the pending actions 
the algorithm terminates by returning the two lists ok list and f ailed list to the calling
algorithm  shown in figure    and discussed in the next section 
      assessing action outcomes
before presenting the main cwcm algorithm  we shortly present the algorithm for assessing
the pending actions in pactsi at a given execution step  as discussed earlier  the assessment
relies on properties   and    and on equation       the algorithm is shown in figure    it
takes as inputs the list of pending actions pactsi   and the current trajectory set t r i     l  
the algorithm returns two lists  ok list and f ailed list  of actions whose outcomes are either
ok or f ailed  respectively 
the algorithm considers the actions in pactsi  if any   and for each of them tests whether
the action has outcome ok or f ailed  in the first case  the success is backward propagated
 line     oks is the list of successfully completed actions discovered by means of the propagation  these actions are removed from pactsi and added to ok list  in the second case  the
failure is forward propagated  line      faulty is the list of faulty actions discovered by means
of the failure propagation  these actions are removed from pactsi and added to f ailed list 
the algorithm terminates by returning the two  possibly empty  lists ok list and f ailed list 
as mentioned above  an action aik  pactsi   previously marked as not enough info  can be
found with a definitive outcome  ok or f ailed   this may happen because  although the
other agents have not provided i with information about the effects of aik   agent i could
exploit the outcome propagation of the actions preceding and following aik   of course  mark
not enough info is removed from actions in ok list or in f ailed list 
proposition    protocol correctness   resource usage  the cooperative monitoring protocol guarantees that the resource safeness requirement is never violated during the
  

ficooperative monitoring to diagnose multiagent plans

execution of map p   in other words  shared resources are used correctly throughout the
plan execution even when action failures occur 
proof  let us consider the interaction scenarios  and show that in each of them the
resources are accessed consistently  namely  it never happens that two  or more  agents
access the same resource simultaneously 
given the causal link lk   haik   res   available  ajm i  the interaction activated by agent i
depends on the outcome of action aik  
the notify ready interaction is equivalent to the only interaction of the bade framework 
and occurs when aik has outcome ok  in this case all the expected services have been achieved
for sure  thus  when i notifies j that res is now available  i has already released res  the
resource is passed from i to j consistently 
the ask if scenario occurs when aik has outcome pending  and splits into three cases 
   agent j  i e   the client  directly observes that the resource is available  it can therefore
access the resource safely in mutual exclusion 
   agent j directly observes that the resource is still occupied by i  in this case j does not
attempt to access res  the resource is being used by a single agent and the resource
safeness requirement is not violated 
   agent j is unable to say whether resource res is available  from the point of view
of j  the state of res is unknown  and hence  since the preconditions of ajm are not
satisfied  j keeps waiting for more information from i  also in this case res is used at
most by one agent 
the last interaction scenario occurs when aik has outcome f ailed  in this case  i notifies
j that the resource is not available  j does not try to use res as the preconditions of ajm are
not satisfied 

proposition    protocol correctness   provided services  let i and j be two agents
playing the roles of provider and client  respectively  about a given causal link lk   haik   v  
d  ajm i  the cooperative monitoring protocol enables the two agents to determine the actual
value of variable v or at least to determine whether v is different from the expected value d 
proof  the proposition can be proved by considering the different interaction scenarios
of the protocol  the notify ready interaction occurs when agent i can conclude that action
aik has outcome ok   this may happen by means of direct observations about the effects
of aik   or by means of the backward propagation of nominal outcomes   since action aik
has outcome ok  all its effects  including v   d  have been achieved  the ask if interaction
occurs when agent i cannot determine the outcome of aik   and hence the truth value of
statement v   d is not known  in that case agent j is in charge of determining whether
the statement v   d is true or false  agent j can reach this result by means of direct
observations on v  the possible answers of j are three 
 j directly observes v   d  thus the service has been provided 
 j directly observes that v is not d  thus the service has not been provided 
  

fimicalizio   torasso

e    


b a 
t r a        



b a 
s 

 
 

b a 

obsa 
 
b a 


b a 



s 

 

s 

s 

 

s 

  

s 

 

s  

  

s  

s 

 

s  

  

s  

s  
  
s  

 

s 
 

s 
 

figure    the trajectory set kept by agent a  after the execution of the first four actions 
 j is unable to observe v  in that case agent i relies on answers provided by other agents 
if any  asked about the same link  agent i can only conclude that v   d is true when
at least one of the received answers allows it to conclude the nominal outcome of aik  
otherwise  the action is assumed failed  and hence also the service v   d is considered
as missing 
in the last interaction scenario  agent i has directly observed  or indirectly inferred by means
of the forward failure propagation  that v   d is false 

this proposition can be considered as a sort of generalization of proposition   as it
applies to all possible services  not only those services mentioning the available value  this
proposition is important because allows the agents to diagnose themselves without the
necessity of interacting with each other  as we discuss in section   
proposition    protocol complexity  the number of messages exchanged among the
agents is linear in the number n of inter agent causal links 
proof  the provider client interaction occurs only when an agent  playing the role of
provider  has performed an action ail with at least one outgoing  inter agent causal link 
the number of messages exchanged for handling an inter agent causal link depends on the
outcome of ail   when ail has either outcome ok or f ailed  the provider sends just one message
to the client  i e   ready or not accomplished  respectively   on the other hand  when ail has
outcome pending  the two agents exchange each other up to three messages  provider sends
ask if  client answers no info  and then provider either replies ready or not accomplished 
thus in the worst scenario  the number of messages exchanged among the agents is  n 
and hence o n  

example    let us assume that after the execution of the first four actions  the trajectoryset kept by agent a  is the one depicted in figure    this trajectory set contains   belief
states and none of them is sufficiently refined to determine the outcome of an action  thus 
all the actions are currently pending  the edges from a state to another labeled with
 represent the nominal progress of the plan execution  the others instead  labeled with
             model the occurrence of some exogenous event  possibly     
  

ficooperative monitoring to diagnose multiagent plans

to show how an agent can take advantage of the pieces of information provided by
others  let us assume that agent a  receives from another agent an observation obsa 
  about
the effects of action a    for instance  let us assume that action a  corresponds to a move
action  and that observation obsa 
  refers to the position of agent a  after the execution of
a 
a    observation obs  is therefore used to refine the belief state b a    in our example  s 
and s  are the only states in b a  that are consistent with the observation  thanks to this
first refinement  see equations     and      we are able to prune off all those trajectories
that do not pass either through s  or through s   these trajectories are depicted as dotted
edges  dashed edges  on the other hand  are still possible so these trajectories are still kept
within the trajectory set 
however  a further refinement of the trajectory set is possible when we discover that
the refined b a  is now sufficiently precise to determine that action a  has outcome ok  in
fact  the a s position conveyed by observation obsa 
  matches with the expected one  this
means that event e    affecting a    has to be   by pruning the trajectory set with e    
 equation        we are in the fortunate case in which b a  contains just state s    where the
nominal effects of action a  are satisfied  too  by backwards propagating the success of a   
first on a    and then on a  we can conclude that the three actions have all outcome ok 
in fact  after this process  the resulting trajectory set maintains just the bold  solid edges 
whereas all dashed edges have been pruned off  the resulting trajectory set  however  does
not allow us to conclude anything about a    which still remains pending 

    cooperative weak committed monitoring  main algorithm
the main cwcm algorithm is outlined in figure     each agent i  t follows this algorithm to execute and monitor its own local plan p i  
after a few initial steps that set up the agent trajectory set and the set of pending
actions  the algorithm iterates over the actions in p i as far as the next action to be performed
coincides with the pseudo action ai   meaning that p i has been completed   remind that
we assume all actions in p i providing atoms in premises ai   have observable effects   at
the beginning of each iteration  the agent interacts with other agents  line    by playing
the client role of the cooperative protocol  at this step  an agent i consumes ready and
not accomplished messages  if any   and acquires information about the resources required
to perform its next action ail   in case the agent receives a not accomplished message  it stops
the plan execution as some of the preconditions for ail will never be satisfied  in case an
ask if message is received  the agent establishes whether it is able to observe the required
service and answers accordingly  see algorithms in figures   and    
once new information has been acquired and asserted within the agent trajectory set 
agent i assesses whether the next action ail is possibly enabled  definition     in the positive
case  the action is performed in the real world  line     subsequently  the agent estimates
the possible evolutions of ail by exploiting both  ail   and  ail   to extend the current
trajectory set  line     after the completion of action ail   the agents direct observations are
gathered in obsil    line     and asserted in the extended trajectory set  line      also in
this case assert is a shortcut for the relational operations described in equations     and
     action ail is then temporarily put into the list of the pending actions  line      the
outcome assessment is in fact postponed as this step regards all the current pending actions 
  

fimicalizio   torasso

cooperative weak committed monitoring p i  
   l   
   t r i     l   i i   the initial belief state is the initial state of agent i
   pactsi  
   while ail    a do
  
cooperative protocol  client inbox  t r i     l   ail  
  
last  null
  
if ail is possibly enabled in frontier of t r i     l  then
  
execute ail
  
t r i     l       t r i     l   m ail     trajectory set extension by using  ail   and  ail  
   
obsil    gather direct observations
   
assert obsil   in the frontier of t r i     l     
   
pactsi  pactsi   ail  
   
last  ail
   
l l  
   
end if
   
hok list  f ailed listi cooperative protocol  provider inbox  t r i     l   pactsi   last 
   
if f ailed list     or aik  pactsi marked as not enough info then
   
stop execution
   
diagnose p i   pactsi   ok list  f ailed list  t r i     l  
   
switch to safe mode
   
end if
    end while

figure     cooperative weak committed monitoring  high level algorithm 
and it is activated even when no action has been executed  it is important to note that
each iteration of the loop does not necessarily corresponds to the execution of an action 
as we have seen  the provider behavior of the cooperative protocol needs to know whether
an action has been recently performed or not  i e   whether an action has been performed
in the current iteration   to this purpose we use variable last  which is set to null at the
beginning of each iteration  and set to action ail only when the action is actually performed
 line      whenever an action has been performed  the counter l is incremented  line     
that is  the l th plan execution step has been completed 
the while loop proceeds with agent i behaving as provider  line      this step also
includes the evaluation of the outcomes of all the actions in the pactsi list  see algorithm in
figure     the provider behavior returns two lists  ok list and f ailed list  maintaining the
actions with outcome ok and f ailed  respectively  of course  both lists could be empty  as a
side effect  pactsi is modified by removing any action whose outcome is no longer pending 
when the list f ailed list is not empty  or at least one action in pactsi is marked as notenough info  the agent stops the plan execution  and starts a diagnostic process  discussed in
section     then switches to safe mode  an agent in safe mode does not perform actions  but
interacts with other agents trying to reduce the impact of its failure  first of all  an agent
in safe mode answers any ask if message with no info  this prevents the sender from waiting
indefinitely for an answer  moreover  an agent in safe mode releases as many resources as
possible by sending appropriate ready messages  this allows other agents to access those
resources and proceed with their plans  a detailed discussion of the safe mode is out the
scope of this paper  but it can be found in the works by micalizio and torasso      b  and
micalizio        
  

ficooperative monitoring to diagnose multiagent plans

in case no failure has been discovered  and all actions performed so far have outcome
ok  i e   pactsi gets empty   the trajectory set t r i can be simplified  in fact  since all the
past actions have a nominal outcome  it is no longer required to keep the whole past history
since the beginning of the plan execution  thus  it is safe and convenient to forget the past
and keep within the trajectory set just the frontier  the implementation we used in our
experiments adopts this strategy for keeping the size of a trajectory set manageable  for
the sake of discussion  we do not provide further details on this point 
    cooperative weak committed monitoring  correctness
we conclude this section by discussing the correctness of the algorithm in figure    
theorem    cwcm correctness  cwcm assigns action aik outcome 
  ok iff the action has not been affected by exogenous events 
  f ailed iff an exogenous event  possibly     has affected aik  
  alternatively  cwcm marks a pending action aik as not enough info iff no outcome can
be inferred relying on observations from other agents  nor on the outcome propagation technique 
proof  part    action aik has outcome ok iff aik is not affected by exogenous events  in
other words  we have to show that aik reaches effects aik   iff ek    in each trajectory within
t r i     l   where k      l    
   by contradiction  let us assume that effects aik   have been reached  but the nominal
trajectory has been pruned off t r i     l   this can happen during the monitoring process in
just two ways   a  through observations  or  b  through the outcome propagation  let us
consider case  a   and let us suppose that during the monitoring phase agent i receives observations obsik   consistent with effects aik    as an effect of pruning t r i     l  with obsik    
the nominal transition ek    is pruned off t r       l   this  however  is in contradiction with
the definition of extended model m aik    in which only the nominal transitions labeled with
 lead to the nominal effects aik    thus  either obsik   is inconsistent with effects aik    and
hence aik cannot be ok  or obsik   is consistent with effects aik   and ek is  in all trajectories
within t r i     l  
let us now consider case  b   the outcome propagation  there are two cases  backward
propagation of ok  and forward propagation of f ailed  the backward propagation of ok
possibly assigns the nominal outcome to actions aik  pactsi   after the propagation  ek
equals  in each trajectory within t r i   by definition  the forward propagation of f ailed
possibly assigns the not nominal outcome to some actions in aik  pactsi   after the propagation ek is not  in any trajectory in t r i     l   the two propagations cannot change the
outcome of an action which is not in pactsi   if an action has already been assigned an outcome  that outcome cannot be changed anymore  in particular  if aik has outcome ok  and
aih  predecessors aik   is discovered faulty  then the forward propagation of f ailed cannot
prune ek    from t r i     l   in fact  as discussed in proposition    the forward propagation
impacts only the causal links that are neither marked as satisfied  nor as missing  and that
are along a chain of links starting from one of the links in miss aih    but if aik has been
assigned outcome ok  then agent i must have received sufficient observations to determine
that the premises of aik were satisfied  it follows that the services required by aik have
  

fimicalizio   torasso

already been marked as satisfied  thus  the nominal transition ek    cannot be lost as an
effect of the outcome propagation 
   if aik is not affected by an exogenous event  and hence eh    in each trajectory within
t r       l   then aik has outcome ok  i e   reaches effects aik     by construction  the extended
model m aik   guarantees that only the transitions labeled as  leads to states where all
expected effects hold  it follows that  when ek    in all trajectories in t r i     l   aik must
have outcome ok necessarily 
part    action aik has outcome f ailed iff an exogenous event  possibly     has affected its
execution  this can be demonstrated following a reasoning similar to the one in part    we
omit it for brevity 
part    action aik marked as not enough info iff no outcome can be inferred relying on
observations from other agents  nor on the outcome propagation technique  it is easy to see
that cwcm marks aik as not enough info only in one occasion  in the provider behavior 
after that all the answers gathered about aik in an ask if interaction are no info  this exactly
means that no other agent in the team can provide information about the services provided
by aik   on the other hand  the marking is removed only after that aik has been inserted either
into ok list or f ailed list  thus it cannot happen that an action with a definite outcome is
also marked as not enough info 

theorem   given the map system s   ht   res  p i  where p is the plan hi  g  a  r  ci 
the global goal g is achieved from i iff all actions in a have outcome ok 
proof  in the previous theorem we have demonstrated that an action has outcome ok only
when all its effects have been achieved  and that such an outcome cannot be changed as an
effect of further refinements of the trajectory set  thereby  if the global goal g has been
reached  all actions in a must have reached their effects  and hence must have outcome ok 
in fact  since we assume that p has no redundant action  i e   each action in p contributes
to g   it is sufficient that at least one action fails reaching one effect to have     at least
one action has outcome f ailed  and    at least one piece of g has not been achieved 
on the other hand  if all actions in a have outcome ok  g must have been achieved
necessarily  by absurd  all actions in a are ok  but g has not been reached  this can only
happen when p has a flaw  and does not produce g even under nominal conditions  against
the initial assumptions  see section    that p is flaw free and actually produces g 

example   can be used to clarify the proof  in this example we have shown that  when
we restrict b a  to a belief state in which each state satisfies the expected effects of action
a    then action a  has outcome ok  at the same time  this outcome is backward propagated
so that only edges labeled with  can lead to b a    if action a  were the last action of a s
plan  the effects of such an action must be observable  by hypothesis  now  depending on
the available observations  agent a  can either conclude that s   is the actual state after a 
 thereby      the goal has been reached      the trajectory set contains just one trajectory
in which each edge is labeled with   and     all actions have outcome ok   or s   is the
actual agents state  and hence at least one action  i e   a  itself  must have outcome f ailed 
corollary   when the global goal g is achieved  each agent i  t keeps in its trajectory set
t r i     l  only the nominal trajectory hs      s              sl   i  where s     i i and sl      gi  
  

ficooperative monitoring to diagnose multiagent plans

proof  this follows from the two previous theorems  if g has been reached  all actions
in a have outcome ok  theorem     on the other hand  since aik is ok iff ek    in
every trajectory within t r i     l   theorem     it follows that each agent i only keeps in its
trajectory set the nominal trajectory 

the correctness of the monitoring process can therefore be summarized in the following
statement  when the execution of p is not affected by any anomalous event  the cooperative
monitoring is able to keep a trace of the progress until the achievement of the goal g since
the nominal transition is never lost  on the other hand  when the execution of p is affected
by at least one anomalous event  even not known in advance  the cooperative monitoring is
able to detect it and to stop the execution phase  in addition  proposition   assures that
in nominal  as well as anomalous  situations the resources are always accessed consistently 

   plan diagnosis  a local strategy
plan diagnostic inferences start as soon as the cwcm algorithm has discovered the failure
of at least one action  i e   f ailed list is not empty   or a pending action is marked as notenough info  in this section we discuss what we mean by plan diagnosis  and how it can be
inferred  we propose a distributed approach in which each agent infers a diagnosis about
its local plan autonomously  in fact  thanks to proposition    the plan execution is safe
with respect to the use of resources  so an agent can never blame other agents to explain
its own action failures 
    inputs from cwcm
in the previous section we have focused on the monitoring purpose of the cwcm methodology  it is important to note  however  that cwcm also produces useful pieces of information
from a diagnostic point of view  first of all  the actions in f ailed list could be considered as
a plan diagnosis according to the definition by roos and witteveen         namely  a subset
of actions that when assumed faulty explain the observations  however  in f ailed list we
do not take into account that some action failures might be the indirect consequences of
others  thus  f ailed list is not sufficient as we would like to isolate the primary action
failures that have caused other secondary action failures 
in addition  cwcm produces a trajectory set t r i     l   which can be seen as a set
of consistency based diagnoses  reiter         each trajectory in t r i     l  is a possible
explanation for the agents behavior consistent with the observations received by the agent
itself 
    event based explanations
dealing directly with t r i     l   however  might be awkward since it encodes all the possible explanations  including the ones mentioning the indefinite exogenous event     which
should be considered as very unlikely  moreover  trajectories which share the same sequence
of events  but differ for a few state variables  are considered as completely different explanations  thus  t r i     l  needs to be processed in order to be useful  a first reduction of
t r i     l  is given by projecting it over the event variables e            el    we call the resulting
  

fimicalizio   torasso

structure event based explanations  eve  
eve   projecte       el  t r i     l  

    

eve is a set of sequences of exogenous events  including  and      each sequence in
this set is a possible consistency based diagnosis for the anomalous behavior of the agent 
since eve could still contain a huge number of diagnoses  eve is not very informative
for a human user who has to decide how to recover from a plan failure  one way for
further reducing the number of diagnoses would be to prefer diagnoses which involve the
minimum number of exogenous events  unfortunately  this preference criterion would lead
to misleading results because events are dependent on one another  to find meaningful
explanations  one should identify what exogenous events have caused primary action failures
and what exogenous events correspond to secondary action failures 
    minimum primary action failures
to facilitate the identification of primary action failures  we distinguish between indefinite
events   contributed by the  portion of an action model  and indefinite events   contributed by the  portion  while this distinction is not necessary in cwcm  it turns out to
be useful for the diagnostic purpose  intuitively    denotes the occurrence of an exogenous
event affecting the execution of a  possibly  enabled action    is therefore an unknown
abrupt change affecting the nominal behavior of an action  on the other hand    is just
the indefinite event we use to label state transitions when an action has been performed
from a state not satisfying its preconditions  relying on this distinction  it is possible to
identify a primary failure by means of the following definition 
definition   an action ak  pactsi  f ailed list is a primary action failure iff there exists
an explanation x  eve such that x ek       and x ek          where x ek   is the k th event
in explanation x 
in other words  an action ak is considered as a primary failure in a given event based
explanation x  eve iff the occurrence of an exogenous event mentioned in  ak   is
assumed in x  note that in definition   we also examine the set of pending actions pactsi  
including actions marked as not enough info  in addition  note that the set of primary action
failures can never be empty  in fact  an agent starts a diagnosis phase only when one of its
performed actions has been labeled as failed  on the other hand  when an agent stops the
execution of its plan because of another agent fails in providing a service  the first agent is
exonerated from diagnosing itself since none of its actions have been labeled as failed  and
the root causes for the missing service have been located outside its plan 
secondary failures are caused by a primary failure  and are defined as follows 
definition   let x  eve be a possible explanation  let ak  f ailed list  pactsi be
a primary failure in x  then all actions ah  successors ak   such that x eh       are
secondary failures caused by ak according to explanation x 
note that  given a primary failure ak in an explanation x  eve   not all the actions in
successors ak   are necessarily secondary failures  see proposition     in fact  even though
ak has not achieved all its effects  i e   it has outcome failed   the action may have reached
  

ficooperative monitoring to diagnose multiagent plans

some of them  as a consequence  some of the actions in successors ak   may be enabled
despite the failure of ak   for this reason  in definition   we require that an action ah 
successors ak   is labeled as a secondary failure only when the exogenous event   is assumed
in the explanation x  from the definitions of primary and secondary failures the proposition
below follows directly 
proposition    given an explanation x  eve   the set of primary action failures p rmx  
and the set of secondary action failures sndx extracted from x are disjointed 
relying on this proposition  we define primary action failure diagnoses  pads  
definition   let x  eve be a possible event based explanation  the primary action failure
explanation  pad  extracted from x is the pair hp rmx   sndx i such that p rmx and sndx
are the sets of primary and secondary failures  respectively  extracted from x 
of course  since eve in general contains several explanations  and since primary failures are
assumed to be independent of each other  it is possible to extract the minimum cardinality
primary action failure diagnoses  mpads  by simply selecting the explanations with the
minimum set of primary failures 
mp ads    p rmx such that x  eve and  p rmx   is minimum  

    

minimum primary action failure diagnoses  mpads  are indeed what we mean for plan
diagnosis  they localize which actions should be qualified as failed in order to explain the
anomalous observations  
    refining the plan diagnosis
having inferred plan diagnosis  one can refine these diagnoses by identifying their root
causes  our refined explanations are expressed in terms of exogenous events  and can be
extracted from the eve set 
definition    let ah be a primary action failure  and let eve  ah   be the set of explanations x  eve such that ah  p rmx   then the refined explanation for action ah is
refinedexp ah    

 

x eh   

    

xeve  ah  

in other words  refinedexp ah   consists of all the exogenous events that might have
occurred during the execution of action ah   and hence might have caused the failure of ah  
of course  since ah is a primary failure  all secondary failures caused by ah can also be
explained by the occurrence of one of the events in refinedexp ah   
   note that different preference criteria could be adopted to select explanations in eve   for instance  one
could prefer minimality rather than minimum cardinality 

  

fimicalizio   torasso

a 

a 

a 

a 

a 

a 

a 

a 

figure     a portion of the local plan assigned to agent i
example    let us consider the simple local plan in figure    assigned to agent i  to
i
  let us assume that  after
simplify the picture we just show the local causal links in clocal
the execution of such a local plan  agent i detects the failure of action a    the diagnostic
process is activated in order to explain such a failure by identifying its  minimum  set of
primary action failures  the diagnostic process receives in input the list of failed actions
f ailed list  a     the list of successfully completed actions ok list  a     and the list of
the pending actions pactsi    a    a    a    a    a    a     in addition  the diagnostic process
receives also the trajectory set t r i         but for simplicity we show in table   just the set
of event based explanations  eve   extracted from the trajectory set 
from table   it is easy to see that all the explanations  except the last one  explain
the failure of action a  as an indirect effect of a previous failure  i e   a  is a secondary
failure   only the last explanation considers a  as a primary failure  but an unknown  and
very unlikely  exogenous event   must be assumed 
the first step of the diagnostic process consists in inferring the set of mp ads diagnoses 
thus  we identify primary and secondary failures for each explanation in eve  
p ad     x   x   
x   

h a    

 a    a    a   i

h a    a    

 a   i

x    h a    a    a      a   i
x   

h a    

 a    a   i

x   

h a    

i  

we can observe some interesting consequences  first of all  some explanations in eve are
collapsed within a single explanation in p ads  see for instance explanations x  and x  
this is an advantage as we can reduce the number of alternative explanations  in addition 
the sets of primary action failures can be used to identify  subset  minimal diagnoses  for
instance  explanation  a    a    derived from x  is a minimal diagnosis  whereas explanation
 a    a    a    extracted from x  is not  finally  since we assume that primary failures are
independent of each other  we can prefer the subset minimal diagnoses whose cardinality is

x 
x 
x 
x 
x 
x 

a 
 
 





a 




 


a 
 
 

 



a 







a 
 
 





a 


 
 



a 


 
 
 


a 
 
 
 
 
 
 

table    the set eve maintained within the current trajectory set
  

ficooperative monitoring to diagnose multiagent plans

minimal  in our example they are mp ads     a      a      a      in fact  it is thus sufficient
to assume the failure of one of these actions to explain the observations 
as a further step  for each action in mp ads  one can also infer a refined diagnosis 
for instance  it is easy to see that the primary action failure a  has two alternative refined
diagnoses  either   or    see table     whereas the primary action failure a  has   as
single possible refined diagnosis  finally  one has to assume the occurrence of   to explain
the primary action failure a    relying on refined diagnoses  other preference criteria could
be employed and conclude that the primary failure a  is less likely than a  and a    and
hence it could be disregarded 

note that  since each agent is able to diagnose its own plan autonomously  a plan
diagnosis at global level could be inferred by combining the local solutions inferred by each
agent in the team  and such an integration is guaranteed to be globally consistent  in fact 
thanks to proposition   an agent can never blame another agent for the failure of one of its
actions 

   experimental analysis
so far we have addressed both the cwcm methodology and the diagnostic inferences in
a declarative manner by means of relations and relational operators between relations 
relations are a simple  yet powerful formalism to represent nondeterministic action models
and ambiguous belief states  in addition  they can also be used to model very complex
structures such as the trajectory set and the event based explanations  eve   
when it comes to actually implementing the cwcm methodology  however  it must be
noticed that the computational complexity of the algorithm in figure    is dominated by the
complexity of the  macro  operator  involved in the extension of the current trajectoryset  on the other hand  the diagnostic inferences are based on the projection of the current
trajectory set over the event variables  see equation      both these steps might be computationally very expensive  and an efficient implementation of relations and relational
operators therefore becomes essential  a possible way to cope with this issue is to translate
the relations into some symbolic  and hence compact  formalism  and then encode the relational operators as operations in the selected symbolic formalism  alternatively  it may be
possible to exploit the recent advancements in continuous query languages  cqls  to deal
with data streams  see e g   the stream system in arasu  babu    widom         and implement cwcm relying on the primitives made available by the data stream management
system at hand 
in this paper  we have chosen the method of knowledge compilation  and in particular 
we have selected the ordered binary decision diagram  obdd   bryant              formalism to encode relation and relational operators  this choice is justified by two main
reasons  first  obdds are nowadays a well known language made available through many
mature libraries  second  the theoretical results by darwiche and marquis        suggest
that obdds can answer most of queries in polynomial time provided that their sizes remain
tractable  an in depth description on how the cooperative monitoring and diagnosis have
been implemented via obdds is reported in the appendix 
the rest of the section is organized as follows  first  in section      we sketch the
software architecture of our implementation  then in section      we present the experimen  

fimicalizio   torasso

domain

initial
state

p

xml

xml

xml

dispatcher

a 

p a 

ra 

outcome assessment

cw cm

ran

outcome assessment

   

cw cm

diagnosis

extend trj

an

p an

t r a 

diagnosis

extend trj

detected failure

t r an

detected failure

cooperative protocol messages

observations for an
observations for a 

ans next action

simulator

a s next action

domain  initial state

xml

exogenous events

figure     the software architecture of the cwcm implementation used in tests 

tal setting we used to carry out the tests  consisting in the simulated execution of several
maps  finally  we discuss the most interesting results about monitoring  section       and
diagnosis  section      

    software architecture and implementation
the cwcm proposal has been implemented as a java sdk   program  the software
architecture is shown in figure     highlighting the main actors  the dispatcher  the n
agents of a team  from agent a  to agent an   and the simulator  the picture also shows
the internal architecture of the agents  solid edges between modules represent data flows 
dashed edges represents instead control flows  whereas the dotted edge between cw cm s
abstracts all the messages exchanged by the agents during the cooperative monitoring  the
simulation of a map p starts by submitting to the dispatcher module three xml files
containing  respectively  the system domain  i e   what agents and objects are defined in the
scenario at hand   the system initial state  e g   the initial positions of agents  the initial
states of resources  etc    and the map p to be performed  the dispatcher decomposes
p into local plans so that each agent will receive just the portion of p of its interest  in
particular  once p has been decomposed  the dispatcher activates the agents  which are
implemented as threads  by passing them their initial states and their local plans 
  

ficooperative monitoring to diagnose multiagent plans

obdds are made available through the javabdd library     which provides a java  easyto use interface between java and buddy     a popular and mature library for manipulating
obdds written in c 
besides the agents  the dispatcher activates also a simulator  implemented as a thread 
differently from agents  however  the simulator does not receives in input a plan  but just
the initial state of the system  in addition  the simulator reads from a fourth xml file the
exogenous events that have to be injected during the plan execution  more precisely  the
file is a list of agents actions  each of which is associated with the anomalous event that
must occur during the execution of that action  of course  only the subset of actions to be
affected by exogenous events are mentioned in this file 
once the environment has been set up  the dispatcher starts the agents  which will
execute the cwcm algorithm as discussed in section    the actual execution of an action
is just simulated by the simulator  whenever an agent intends to perform an action  it
sends a message to the simulator conveying the action to be performed  the simulator
will simulate the action execution taking into account possible exogenous events that have
to be injected  if the action is associated with observations  the simulator sends to the
corresponding agent an appropriate message  it is worth noting that also the simulator 
like any other agent  uses obdds to estimate the next state of the whole system according
to the actions that are currently in progress  differently from the agents  however  the
simulator always knows the precise state of each agent and resource in the system  some
more details about the use of obdds for handling relations are given in appendix a 
as discussed in section    whenever the failure of an action is detected by an agent i 
the diagnosis module of that agent is activated  the results of the diagnosis inferences 
discussed in section   are saved in a report file ri associated with agent i 
the experiments described in the following were performed on a pc  intel core   duo 
     ghz    gb ram equipped with windows   os  each test is repeated ten times 
and average values are considered in the experimental analysis in order to absorb load
fluctuations of the cpu 
    experimental setting
the domain we used for our tests has already been introduced in example    the actions
each agent can perform are summarized in table       reporting some details about the
encoding of the action models as obdds  more precisely    variables is the number of state
variables over which the obdd is defined  this number includes one variable for encoding
the possibly anomalous event occurring during the action execution  the remaining variables
are used to encode an agent state transition from step t  when the action starts  to step t   
when the action ends  columns   nodes and   trans  report  respectively  the number
of nodes of the obdd encoding the  portion of the action model  and the number of state
transitions encoded by   columns  m nodes and  m trans  refer to the whole extended
model m  including the  portion  in such a domain  each agent handles    variables to
encode its own belief state about the environment 
   http   javabdd sourceforge net index html
   http   sourceforge net projects buddy 
   examples of test cases and action models can be found at
http   www di unito it micalizi cwcm index html 

  

fimicalizio   torasso

move
carry
load
unload

  variables
  
  
  
  

  nodes
   
   
   
   

  trans 
  
  
  
  

 m nodes
   
   
   
   

 m trans 
   
    
   
   

table    some details on the relational action models 
    objectives of the experimental analysis
there are at least three main questions that we want to get answered by means of our
experiments  these questions are 
 does cwcm scale up well as the number of agents in the team grows 
 is cwcm affected by the level of system observability  and if so to what extent 
 is the cooperation among agents really useful for the monitoring purpose 
to answer these questions  we carried out our tests by varying three main characteristics 
team size  observability level  and monitoring strategy 
      team size
to assess the scalability of cwcm  we have generated maps with teams from   to   agents 
thus  we have   scenarios  and for each of them  we have synthesized    maps  the main
characteristics of these maps are reported in table    note that the maps are not trivial as
they consist of a significant number of actions and subgoals to be achieved  the term mapspan refers to the number of execution steps that are required to complete the plan under
nominal conditions and full observability  the concurrency rate  computed as the number
of actions divided by map span  indicates that agents do perform actions concurrently 
finally  the number of inter agent causal links shows how often agents interact with each
other to achieve their own subgoals 
      observability level
to assess the competence of cwcm  the maps were performed under different conditions
of observability  in particular  we considered three degrees of domain observability  in the
following  the term full denotes a complete observability of the effects of the actions
performed by the agents  such a level of observability is unrealistic in practice  but it
represents our benchmark to compare the performance of cwcm in the other observability
conditions  the term high denotes a degree of observability that guarantees to observe
the effects of     of the maps actions  randomly selected  finally  the term low denotes
a degree of observability of just     of the maps actions  again randomly selected 
      monitoring strategies
finally  to assess the actual benefits achieved by the cooperation among the agents during
the monitoring phase  we considered three alternative monitoring strategies 
 bade  already presented in section    is the simplest strategy  based on the strong
committed policy 
  

ficooperative monitoring to diagnose multiagent plans

scenario

 agents

 actions

 subgoals

map span

concurrency
rate

scn 

 

scn 

 

scn 

 

scn 

 

scn 

 

scn 

 

     

     

     

     

     

    

     

     

     

    

    

    

     

     

     

    

    

    

      

     

     

     

    

    

      

     

     

     

     

    

      

     

     

    

    

    

   
   
   
   
   
   

 causal

 inter agent

links

links

      

    

     

    

      

    

     

    

      

    

     

   

      

  

     

    

      

    

     

    

      

     

    

    

table    characteristics of the maps in the six scenarios under nominal conditions  average
values and confidence intervals  

 wcm  weak committed monitoring  introduced by micalizio and torasso       
      is based on the weak committed policy that allows agents to keep trajectorysets to cope with scarce observability  in wcm  an agent i is able to keep pending
actions as far as these actions do not provide services to other agents  differently
from cwcm  in wcm agents cannot cooperate with each other  therefore  when the
outcome of an action a cannot be precisely determined  and a provides another agent
j  i e   i    j  with a service  a is assumed as failed by i  which also stops the execution
of its own plan 
 cwcm  discussed in section    extends the weak committed policy with the active
cooperation among the agents 
      exogenous events
although exogenous events have been generated randomly  their generation reflects the
 expected  probability with which a given exogenous event can occur  for instance  a completely unexpected event  encoded by     is very unlikely to occur  and hence its frequency
in our experiments is pretty low  table   shows the probability distribution used to generate
exogenous events randomly 
    experimental analysis  monitoring
the experimental analysis of the monitoring task is subdivided into two main parts  in
the first one  we assess the three strategies bade  wcm  and cwcm  under nominal
conditions  that is  when no exogenous event occurs during the simulated execution of
maps  the goal is to study the impact of the observability degree on the competence
  

fimicalizio   torasso

exogenous event
blocked wheel
wrong move
lose parcel
slip parcel
blocked arm
 

probability
    
    
    
    
    
  

table    the exogenous events and their frequencies in the experiments 
high observability

wcm

cwcm

  achieved subgoals

  performed actions

high observability
bade
   
  
  
  
  
 
 

 

 

 

 

 

bade

wcm

  
  
  
  
 
 

 

  agent

   
  
  
  
  
 
 

 

 

 

 

 

 

 

 

low observability
bade

cwcm

  achieved subgoals

  performed actions

wcm

 

  agents

low observability
bade

cwcm

   

 

 

wcm

cwcm

   
  
  
  
  
 
 

 

 

 

  agents

  agents

figure      nominal conditions  competence 
achieved goals 

percentage of performed actions and

of the three strategies  in the second part  we assess again the competence of the three
strategies when exogenous events do occur 
      nominal conditions
competence  the competence is estimated as the percentage of actions performed and
subgoals actually achieved by the agents  since under the condition of full observability
the agents perform      of their actions and achieve      of their subgoals in each of the
three strategies  in figure    we just report the results under high and low conditions 
as expected  bade is very sensitive to the observability degree  on the other hand  since
wcm and cwcm keep trajectory sets  they are more tolerant to partial observability 
and generally behave much better than bade  cwcm does better than wcm as the
cooperation between the agents allows them to compensate the lack of direct observations
with messages coming from others  as discussed in section      however  it may be possible
that even the other agents are unable to provide useful pieces of information  thus  also
with the cwcm strategy  an agent decides to stop the execution of its own plan when 
even asking other agents for more observations  it is not possible to determine the outcome
of an action  as explained in section      in this case an agent stops the execution of its
plan by marking some actions as not enough info  this is the reason why the percentage
of performed actions and achieved goals is below      with observability levels high and
  

ficooperative monitoring to diagnose multiagent plans

full observability
wcm

low observability

high observability
bade

cwcm

wcm

cwcm

bade

   

   

   

   

   

   

   

   

   

msec

   

msec

msec

bade

   

   

   

  

  

  

 

 

 

 

 

  agents

 

 

cwcm

   

   

 

wcm

 
 

 

 

 

  agents

 

 

 

 

 

 

 

 

  agents

figure      nominal conditions  monitoring time  average and     confidence interval  for
a single execution step 

low  the results obtained by cwcm are in any case remarkable  in the worst case  scn  
at least     of actions have been performed and     of subgoals have been achieved despite
only     of the actions were observable 
computational time  figure    shows the average time  and the     confidence interval  for monitoring a single step of execution  note that for the bade strategy the monitoring just consists in estimating the next belief state  whereas  wcm and cwcm have to
extend their trajectory sets  in addition  cwcm has also to cooperate with other agents 
the cooperation can introduce further costs as the consumption of a message from another
agent corresponds to an operation on the obdd encoding the current trajectory set  a first
positive result emerging from figure    is that  even in the worst scenario  cwcm takes
no more than     milliseconds for monitoring the execution of an action  this allows us to
conclude that cwcm could be employed effectively in real world domains where agents
actions are performed in the order of seconds 
in addition  it is easy to see that computational time strongly depends on the observability level  for example  under full observability  cwcm and wcm behave very similarly 
in this case  in fact  cwcm agents do not need to cooperate each other  and hence the
two strategies are almost the same  however  when the observability decreases  cwcm
is slightly more expensive than wcm and bade  this higher cost is counterbalanced by
the competence of cwcm  that  as already noticed  outperforms the competence of both
bade and wcm 
from the charts in figure    it is also apparent that there is no strict dependency
between the number of agents in the team and the computational time of the three strategies 
this  in fact  is a consequence of our distributed approach where each agent maintains its
own point of view about the environment  and the cooperation with other agents is just
based on the exchange of messages and not belief states 
obdd dimensions  the relation between time and observability becomes clear when
we consider the sizes of the obdds encoding the trajectory sets  see figure     left  for
brevity we just report the average sizes of the obdds maintained by the three strategies
under high and low observability conditions    it is easy to see that there exists a relation
between the computational time shown in figure    and the sizes of the obdds in figure
   in the full observability case  the obdd sizes for cwcm are well below      nodes  on average  in
addition  cwcm and wcm generate obdds with similar sizes  as expected 

  

fimicalizio   torasso

high observability

high observability
bade

wcm

cwcm

wcm

high observability
wcm

cwcm

cwcm

     

     
    
    
 
 

 

 

 

 

  
  
  
  
  
  
  
  
 

length of a trajectory

  trajectories

  obdd nodes

     

 

 

 

 

low observability
wcm

 

    
    
    
    
    

 

 

 

 

  agents

  agents

bade

 

     

low observability

cwcm

wcm

 

 

 

 

 

 agents
low observability
wcm

cwcm

cwcm

     

     
    
    
 
 

 

 

 

  agents

 

 

  
  
  
  
  
  
  
  
 

length of a trajectory

  trajectories

  obdd nodes

     

 

 

 

 

  agents

 

 

     
    
    
    
    
    
 

 

 

 

 agents

figure      nominal conditions  left  sizes of obdds in number of nodes  average and
    confidence interval   center  average number of trajectories within a
trajectory set  right  average length of one trajectory 

    left  the bigger the obdds the higher the computational time  as we have already
noted  although obdds may get very large  the computational time is still acceptable 
 the biggest obdd that has been observed had        nodes  and was built by cwcm in
scn  under low observability  
obviously  the level of observability has a strong impact on the dimensions of the obdds  in fact  a reduced level of observability makes the trajectory sets more ambiguous 
and hence more trajectories have to be encoded within a single obdd  this is made explicit in figure     center  where we show the number of trajectories encoded  on average 
within a trajectory set at each time instant  and their length  figure     right   of course 
in these two last charts  we only consider wcm and cwcm since the bade strategy does
not build trajectory sets  moreover  note that in the actual implementation of cwcm  the
extension of a trajectory set does not cover the whole plan performed so far  but only the
current subset of pending actions 
cwcm communication analysis  we conclude the study under nominal conditions
with an analysis of the communication required by the cwcm methodology  figure   
shows the average number of messages exchanged among the agents  the first interesting
result is that  under full conditions  the number of exchanged messages coincides with
the number of inter agent causal links  in fact  since these results are taken under nominal
conditions  each action reaches its nominal effects  therefore  the cooperative protocol handles each inter agent causal link by means of a simple ready message sent by the provider to
the client  no answer is required  when the observability level is just high  however  the
number of messages tends to increase  even though it does not increase significantly except
for scenario scn   as expected  the largest number of messages is exchanged when the
observation is low  as expected 
  

ficooperative monitoring to diagnose multiagent plans

cwcm messages in nominal conditions
full

high

low

  

  messages

  
  
  
  
  
  
 
 

 

 

 

 

 

  agents

figure     the number of messages exchanged by cwcm agents in nominal conditions 
high observability

cwcm

bade

   
  
  
  
  
 
 

 

 

 

 

  
  
  
 
 

 

  
  
 
 

 

 

  agents

  achieved subgoals

  achieved subgoals

  

 

 

 

 

wcm

  
  
  
 
 

 

bade

  
  
  
 
 

 

  agents

 

 

 

 

 

low observability

cwcm

  

 

 

  agents

   

 

cwcm

  

high observability
bade

cwcm

  

 

 

wcm

   

  agents

   

 

bade

  

full observability
wcm

low observability

cwcm

   

  agents

bade

wcm

 

 

  achieved subgoals

 

  performed actions

  performed actions

wcm

  performed actions

full observability
bade

wcm

cwcm

   
  
  
  
  
 
 

 

 

 

  agents

figure      faulty conditions  competence  percentages of performed actions and achieved
goals 
      faulty conditions
competence  let us now consider the same test set as before  but we randomly inject
a single exogenous event in each map  the goal is to assess how well the three strategies
behave when partial observability and exogenous events combine together  figure    shows
the competence of the three strategies in such a faulty setting under the three observability
levels  when the environment is fully observable  the three strategies behave exactly the
same  as expected  of course  the percentages of performed actions and achieved goals
depend on how early  or how late  the exogenous event occurs in the map  in general  we
can say that at least     of the actions are performed despite the injected exogenous event 
a similar consideration can be made for the percentage of achieved goals 
when the observability conditions degrade to high and low  however  it is easy to
see that cwcm outperforms the other two strategies  this means that cwcm is actually
more tolerant than the other strategies to partial observability even in the faulty scenario 
  

fimicalizio   torasso

full observability
wcm

bade

cwcm

wcm

low observability

cwcm

bade

   

   

   

   

   

   

   

   

   
   

   
   

  

  

 

 

 

 

 

 

 

msec

   

msec

msec

bade

high observability

 

wcm

cwcm

   
   
  
 

 

 

  agents

 

 

 

 

 

 

  agents

 

 

 

 

  agents

figure      faulty conditions  monitoring time  average and     confidence interval  for
a single execution step 
high observability

high obervability

cwcm

wcm

     
     
    
    
    
    

  
  
  
  
  
 

 
 

 

 

 

 

 

 

 

 

wcm

 

 

wcm

cwcm

     

  trajectories

     
     
    
    
    
    
 

 

  agents

 
 
 
 
 

 

 

 

 

wcm

  
  
  
  
  
 

 

 

 

  agents

 

 

 

 

 

low observability

cwcm

 

 
 

 

  agents

  

 

  

low observability

low observability
bade

 

cwcm

  

  agents

  agents

  obdd nodes

wcm

  

  trajectories

  obdd nodes

     

high observability

cwcm

length of a trajectory

wcm

 

 

length of a trajectory

bade

cwcm

  
  
 
 
 
 
 
 

 

 

 

  agents

figure      faulty conditions  average sizes of obdds encoding a trajectory set  left  
average number of trajectories within a trajectory set  center   average length
of a trajectory set  right  
in particular  since the only difference between cwcm and wcm is the cooperative monitoring  we can conclude that the cooperation among the agents is actually beneficial 
computational time  figure    reports the computational cost  in milliseconds  of the
three strategies under faulty conditions and for the three levels of system observability  it
is important to note that also in this case the computational time strongly depends on
observability level  whereas it does not depend on the number of agents in the team  nor
on the presence of an exogenous event  in fact  the time for monitoring a map affected by
an exogenous event has the same order of magnitude as the monitoring of a map under
nominal conditions  the differences that can be observed by comparing charts in figure
   with charts in figure    are due to the fact that the execution of a map affected by a
fault terminates earlier than a map executed under nominal conditions  independently on
the level of observability 
of course  the bade strategy is the cheapest of the three  but it is unable to monitor
effectively the execution of a map  in fact  the strong committed policy at the basis of this
  

ficooperative monitoring to diagnose multiagent plans

cwcm messages in faulty conditions
full

high

low

  

  messages

  
  
  
  
  
 
 

 

 

 

 

 

 agents

figure     the number of messages exchanged by cwcm agents in faulty conditions 
strategy is too sensitive to the level of observability  and under high and low conditions
it performs poorly 
obdd dimensions  let us consider the dimensions of the obdds maintained by the
three strategies  on the left hand side of figure     we report the sizes  in number of
nodes  of the obdds representing the current belief state  bade strategy   and the current
trajectory set  wcm and cwcm strategies  under the three conditions of observability 
as expected  bade keeps the smallest obdds since it just maintains the last belief state 
but this makes the bade strategy unable to deal with low observability levels  wcm
and cwcm behave similarly under full observability conditions  but cwcm tends to
maintain bigger obdds when the observability level decreases  this result can be explained
by the fact that cwcm can build longer trajectory sets than wcm  figure     right   and
these longer trajectory sets tend to be more ambiguous as demonstrated by the average
number of trajectories within a trajectory set  figure     right  
cwcm communication analysis  figure    shows the number of messages exchanged
by cwcm agents under faulty conditions  the trend is similar to that of nominal conditions  however  the number of messages is slightly lower  this happens because the occurrence of a failure prevents the agents from performing some actions  and as a consequence
some messages will not be exchanged  this is also the reason for having slightly less messages in scn  than scn   in fact  the number of inter agent causal links in the two
scenarios is almost the same  but faults in scn  have a stronger impact than in scn   this
is evident looking at the number of performed actions in scn  and scn   see figure     
    experimental analysis  diagnosis
competence  the competence of the diagnostic inferences is evaluated as the percentage
of cases in which the action affected by the injected exogenous event has been included
within the set of preferred explanations mp ads  figure     left hand side  shows how our
diagnostic inferences behave in the three levels of observability  obviously  under full
observability  the diagnostic inferences always identify the correct primary action failure 
under high and low observability  however  the impaired agent can stop the plan execution due to lack of observations  i e   not enough info   in those cases the diagnosis cannot
identify the primary failure  figure     right hand side  shows also the average distance
 i e   number of actions   between the action affected by an exogenous event  and the action
  

fimicalizio   torasso

full

high

low

full

high

low

 

  

 actions

  diagnosed cases

   

  
  

 
 
 

  
 

 
 

 

 

 

 

 

 

 

 

 agents

 

 

 

 agents

figure      diagnosis  competence  left   and responsiveness  right  

   
 xplanations

eve  all inferred explanations
full

high

low

full

  explanantions

  explanations

  
  
  
  
  
 
 

 

 

 

 

 

low

 
 
 
 
 
 

  agents

high

 

 

 

 

 

 

  agents

figure      diagnosis  eve explanations  left   mpads explanations  right  
in which the failure is actually detected  under full observability  the diagnosis is highly
responsive as it detects an action failure as soon as the exogenous event occurs  i e   the
distance is zero   on the other hand  when the observability is just partial  a cwcm agent
can take longer to detect a failure 
explanations and preferred explanations  in section    we have pointed out that 
given a trajectory set  one can identify two types of explanations  eve and mp ads  the
set eve represents all the explanations that are consistent with the observations received
by an agent  whereas mp ads is the set of primary action failures inferred from eve   figure    shows the cardinalities  on average  of the two sets inferred in the six scenarios and
with different levels of observability  from the two charts in figure    we can draw two conclusions  first  the cardinality of eve strongly depends on the observability level  namely 
the reduction in the observability level causes an increment in the number of possible explanations  however  the cardinality of mp ads is almost independent of the observability
level  in fact  the number of preferred explanations inferred with low observability is similar to the number of preferred explanations inferred with full observability in all the six
scenarios  of course  mp ads sets computed under low observability tend to be slightly
bigger than mp ads sets computed under full observability  but this is a consequence
of the fact that the initial eve set was more ambiguous under low observability  this
means that  regardless of the initial ambiguity of the eve sets  the preferred explanations
are reduced to almost the same subsets in all the six scenarios 
the second important conclusion is that mp ads explanations are substantially more
useful in identifying a fault than eve explanations  in fact  the average cardinality of
mp ads sets is three in the worst cases with low observability  whereas  the average
  

ficooperative monitoring to diagnose multiagent plans

diagnosis  computational time
full

high

low

    

msec

   
   
   
   
 
 

 

 

 

 

 

  agents

figure     diagnosis  computational time 

number of eve explanations in the best case with full observability is eight  but it
rises up to    in the worst case with low observability  see scn    this means that the
mp ads explanations may actually help a human user refine her his hypotheses about the
current situation of the system  this is essential when we consider that diagnosis is just
the first step for recovery  micalizio         thus  a human user  or possibly an automatic
supervisor  has to consider a small number of alternative explanations  and hence can better
focus the plan recovery process on the fault s  that are believed more plausible 
computational effort  finally  we consider the computational time required to infer the
diagnoses  in inferring the eve explanations  the computational cost is mainly due to the
cost of removing non relevant variables from the trajectory set provided by cwcm  see the
appendix for a discussion from a theoretical point of view about the cost of such variable
removal   figure    reports the average computational time  in milliseconds  for extracting
eve explanations in the six scenarios and with the three different levels of observability 
as noticed in the previous section  under low observability  the trajectory set tends to
be bigger than with the other two observability levels  as a consequence the time for
inferring diagnoses under low conditions tends to be higher  however  this time is below
  second even in the worst case  on the other side  under high observability conditions 
the worst time is below     milliseconds  see scenario scn    the worst time falls below
   milliseconds when we consider the full observability level  these computational times
allow us to conclude that the diagnostic task  as the monitoring one  can be performed
on line in a number of applicative domains where actions are performed in the order of
seconds  or even minutes 
    discussion
at the beginning of this experimental analysis we posed three questions  and now we are in
the position to answering them  first of all  the experimental results show that cwcm is
not sensitive to number of agents in the team  this is a consequence of the partitioning of
the global plan into local plans  in such a way  in fact  each agent keeps just its own point
of view on the states of the shared resources  namely  each agent has a local belief state that
does not depend on the number of agents in the team  as we have seen  the consistency
among these local beliefs is guaranteed through the exchange of messages whose number is
linear in the number of inter agent causal links of the map under consideration 
  

fimicalizio   torasso

on the other hand  the level of observability of the system has a strong impact both on
the computational effort of cwcm and on the ambiguity of the trajectory sets computed 
the lower the observability  the higher is the computational cost and the bigger is the
trajectory sets  an important result that emerges from our analysis is that the worst case
scenarios depicted in the appendix are very rare  and never occurred during our experiments  indeed  the compact encoding of trajectory sets and action models obtained via
obdds facilitates a very efficient implementation of cwcm that takes  on average  just
hundreds of milliseconds to monitor a single action  this allows us to conclude that cwcm
can be successfully employed for on line monitoring in many real world domains 
the level of observability has also an impact on the diagnostic inferences  in fact 
the number of eve explanations significantly grows as the observability level decreases 
however  the number of preferred mp ads explanations is not so strongly influenced by
the observability level 
finally  the direct comparison between cwcm and wcm demonstrates that the cooperation among the agents is essential to be tolerant to very scarce observations  the
cooperation  in fact  is the means through which an agent in cwcm can keep longer
trajectory sets than in wcm  these longer trajectory sets give each agent more chances to
collect pieces of information about the successful completion of some pending actions 

   related works
we consider four main families of model based approaches to the diagnosis of dynamic
systems close to our maps 
 discrete event systems  dess  
 relation oriented 
 team oriented 
 resource oriented 
in the rest of this section we briefly review the main approaches within these families 
highlighting differences and similarities with the cwcm methodology proposed here 
    discrete event systems
since the seminal work by sampath  sengupta  lafortune  sinnamohideen  and teneketzis
       on the diagnoser  a huge number of works have addressed the diagnosis of dynamic
systems by modeling such systems as dess  while the diagnoser approach compiles the
diagnostic model  i e   the diagnoser itself  of the whole system off line  other approaches
 see e g   lamperti   zanella        cordier   grastien        compute all possible system
behaviors  and check which of these behaviors are correct  grastien  haslum  and thiebaux
       extends to dess the conflict based approach initially proposed by reiter        on
static systems 
to the best of our knowledge  the des framework that gets closer to ours is the one
presented by grastien  anbulagan  rintanen  and kelareva         in such a framework 
a diagnosis is a label either normal or faulty  associated with a system trajectory  where a
trajectory is a sequence of system states interleaved with events  thus very similar to the
  

ficooperative monitoring to diagnose multiagent plans

trajectories kept within our trajectory sets  a trajectory is normal if it does not contain
fault events  the trajectory is faulty  otherwise 
grastien et al  propose to reduce a diagnosis problem to a sat one  the idea is to formulate a sat problem  in order to answer the question is the observed behavior compatible
with at most i faults occurring   of course  when the answer is yes for i      the system is
assumed nominal as there exists at least one normal path consistent with the observations 
in principle  the proposed system description could encode a map  the execution of actions
could be modeled by a subset of observable events  whereas our exogenous events could be
mapped to unobservable events directly  however  the des framework cannot be directly
applied to the same domains cwcm can deal with  first of all  in the des approach the
next state of the whole system is inferred taking into account the synchronous occurrence
of a set of events  thus  if agents are event generators  it follows that they can only perform
actions synchronously  but in cwcm this restriction is not imposed  moreover  the satbased methodology is centralized as trajectories are about whole system states  whereas
cwcm enables each agent to build local trajectory sets in a distributed way 
    relation oriented approaches
relation oriented approaches have been proposed by micalizio and torasso               we
define these works as relation oriented since action models are expressed in terms of relations
over agents state variables  the advantage of such a kind of model is the possibility of
representing in a single piece of knowledge both the nominal and the abnormal evolutions of
an action  the cwcm methodology falls within such a category  and extends the previous
works in two ways  first of all  cwcm is able to deal with completely unexpected events 
denoted as     for which no model exists  indeed  the occurrence of   during the execution
of an action a maps all variables in effects a  to the unknown value  meaning that these
variables are no longer predictable 
the second important extension is the protocol that allows the agents to cooperate with
each other during the monitoring task  as the experimental results have demonstrated 
cooperation among agents is essential to cope with very scarce observations  by means of
the cooperation  in fact  an agent can acquire new pieces of information that it would not
acquire directly  these further pieces can therefore be used to refine its own trajectory set 
and possibly the outcome of some pending actions could be determined 
    teamwork oriented approaches
rather than diagnosing action failures  as in cwcm  teamwork oriented approaches are
focused on diagnosing teamwork failures  i e   coordination failures  this type of failures
are not necessarily due to erroneous actions  but to wrong decisions taken by the agents 
the detection of teamwork failures has been addressed in some seminal works by tambe
       and kaminka and tambe         kalech and kaminka        have later focused
on the diagnosis of these coordination failures  and have introduced the notion of social
diagnosis  more specifically  the team of cooperating agents is represented in abstract
terms by means of a hierarchy of behaviors  a behavior is an abstraction of the concrete
actions that an agent actually takes in the real world  indeed  behaviors abstract not just
single actions  but possibly sequences of actions  thus  differently from relational  and
  

fimicalizio   torasso

resource oriented approaches  see later   an explicit model of the agents plans is missing in
teamwork oriented solutions 
the social diagnosis framework assumes that agents synchronize themselves to jointly
select a team behavior  a disagreement arises when at least two agents select two behaviors
that are incompatible with each other  such disagreements represent instances of social
diagnosis problems  of course  agents select their behaviors according to their own beliefs 
thus a social diagnosis for a disagreement is a set of conflicting belief states held by a subset
of agents  kalech and kaminka                    propose different methods for inferring
a social diagnosis  these solutions  however  rely on some assumptions that may limit their
applicability in real world scenarios  first of all  it is assumed that all the agents in the team
share the hierarchy of behaviors and that the belief states of the agents are homogeneous
 i e   defined over the same set of propositional atoms   moreover  agents must be willing
to exchange each other their own beliefs  the cwcm methodology we propose  however 
does not suffer from these limitations  cwcm  in fact  makes no assumption about the
agents internal beliefs  in addition  the communication among the agents does not exchange
agents internal beliefs  but observations about shared resources that agents directly gather 
and this guarantees the agents a high degree of privacy 
    resource oriented approaches
the approaches within the resource oriented family have mainly been proposed by roos and
witteveen  we call their approaches resource oriented because  from their point of view 
the system to be diagnosed is a plan  and the state of such a system is given by the states of
the system resources  the execution of an action can just change the state s  of one or more
resource s   these approaches deserve particular attention as they have some similarities
with the cwcm methodology  but there are also a number of relevant differences 
witteveen  roos  van der krogt  and de weerdt        present the basic framework that
they use and extend in their subsequent works  in this framework  actions are modeled as
atomic plan steps  more precisely  action models are functions that deterministically map
resource states in input into resource states in output  these models therefore represent
just the changes normally caused by actions when they are successfully performed  the
faulty behavior of actions  conversely  is modeled via a very weak abnormal function  which
maps the state of each resource in input to the unknown value  this means that  when an
action fails  the states of the resources handled by that action become unpredictable 
a diagnostic problem arises when the observations received at an execution step are
inconsistent with the nominal predictions made through the action models  this means
that at least one of the actions performed so far behaved abnormally  witteveen et al 
       introduce the notion of plan diagnosis as a subset of plan actions that  once qualified
as abnormal  make the observations consistent with the predictions made assuming all the
other actions as nominal 
of course  since there may exist many possible plan diagnoses  it is important to look for
diagnoses that are more preferable than others  roos and witteveen        propose a different preference criterion based on the predictive power that each plan diagnosis has  they
therefore introduce the notion of maximally informative plan diagnosis  maxi diagnosis  as
a set of plan diagnoses that predict correctly the biggest subset of observations  this no  

ficooperative monitoring to diagnose multiagent plans

tion of diagnosis is subsequently refined by the notion of minimal maximally informative
plan diagnosis  mini maxi diagnosis   which is just a subset of maxi diagnosis such that the
number of failed actions to be assumed is minimal 
in the work by de jonge et al          the basic framework is extended  agents are
seen as resources  and action models also includes variables about agents equipment and
environment events  i e   exogenous events   this extension allows the distinction between
primary and secondary diagnoses  while a primary diagnosis is a plan diagnosis  i e  
expressed in terms of failed actions   a secondary diagnosis can be thought of as a second
level diagnosis that tries to explain why a given action failure has occurred 
cwcm tries to resolve the same problem as the one addressed by roos and witteveen
        diagnosing the execution of a map  however  action models are significantly different in the two approaches  from roos and witteveens point of view  action models are
deterministic functions of nominal behavior only  whereas in cwcm  we model actions
as relations that easily accommodate both nominal and faulty evolutions  in particular 
faulty evolutions can be nondeterministic  and just partially specified as they support the
unknown value to indicate that no expectations are possible for a given variable 
another important difference between the two approaches is about the execution of
actions  roos and witteveen assume that actions take just one time instant to be performed
and that action execution proceeds synchronously all over the agents  our cwcm is more
realistic since action execution is asynchronous  even though actions are modeled just in
terms of preconditions and effects  their actual duration is not necessarily one time instant 
as we have seen  in fact  agents cooperate with each other by exploiting the causal and
precedence links that are explicitly defined within our plan model  the plan model adopted
by roos and witteveen  instead  mentions explicitly precedence links only  while it does
not include causal links 
also the process with which a diagnosis is inferred presents substantial differences 
witteveen et al         and de jonge et al         present a centralized method to carry out
diagnostic inferences  a distributed procedure for qualifying actions as abnormal is proposed
by roos and witteveen         but also in this case the detection of a diagnostic problem is
made in a centralized way  moreover  the methodology proposed by roos and witteveen is a
sort of strong committed approach  in the sense that whenever there are some observations 
the system has to infer a diagnosis  on the other hand  our cwcm methodology is fully
distributed both in the detection of a diagnostic problem  i e   monitoring   and in its
solution  in addition  cwcm is inherently weak committed  observations do not necessarily
trigger a diagnostic process  but diagnosis inferences start after an interpretation of the
observations that either lead to     determining an action failure  or     determining that a
service produced in favor of another agents action is actually missing  cwcm achieves this
second point by exploiting both direct observations gathered by the agent  and messages
coming from other agents  this means that when observations are not sufficient to either
reach condition     or      a diagnosis is not inferred 
as said above  de jonge et al         introduce a distinction between primary and
secondary diagnosis  such a distinction can also be found in our methodology  the primary
diagnosis by de jonge et al  corresponds to our minimum primary action failures  mpads  
which identify the actions that should be assumed faulty in order to make the plan execution
consistent with the observations  the secondary diagnosis  on the other hand  corresponds
  

fimicalizio   torasso

to our refined explanations  refinedexp   in which we associate each action in mpads with
a set of exogenous events that  consistently with the observations  might have occurred and
hence caused the action failure 
in this paper we also assess the impact of a primary action failure a  mp ads by
inferring the set of secondary action failures  namely  the subset of actions that fail as an
indirect consequence of the failure of a  although the identification of secondary failures
would be possible  de jonge et al  do not take into account the problem 
in conclusion  the cwcm framework can be considered as an extension of the frameworks by de jonge et al         and roos and witteveen         in fact  the action models
proposed by roos and witteveen can be reproduced within our framework by including in
each relation based model just two entries  one for the deterministic nominal evolution of
the action  and one for the abnormal behavior where all the agent variables become unknown as a consequence of an unpredictable event  these action models could be used by
cwcm as usual to infer a plan diagnosis in a fully distributed way 

   conclusion
plan diagnosis is an essential step to implement robust multiagent planning systems  as
shown in other works  mi   scacchi        gupta et al         micalizio         in fact  the
explanations provided by a plan diagnosis can steer a repair procedure and make the repair
process more effective 
in this paper we have addressed the problem of plan diagnosis by splitting it into two
subproblems  the detection of action failures  and the actual explanation of the detected
action failures in terms of exogenous events that might have occurred  the detection of action failures is achieved by means of the cooperative weak committed monitoring  cwcm 
strategy  which allows agents to cooperate with each other during the monitoring task  cooperation among agents plays a central role not only for the detection of action failures  but
also for their explanations  the cwcm methodology  in fact  allows each agent to build
a structure  i e   a trajectory set   that is an internal representation of the world from the
point of view of the agent itself  relying on this structure  each agent can infer explanations
for its own action failures without the need of interacting with other agents 
the proposed framework to the diagnosis of maps extends previous approaches in
literature  first of all  cwcm is fully distributed and asynchronous  previous approaches
 see e g   kalech   kaminka        roos   witteveen        micalizio   torasso        
instead  are all based on some synchronous step  e g   agents execute actions synchronously  
in our framework an agent can perform its next action as soon as the actions preconditions
are satisfied  to verify this condition  we just impose that agents adhere to a coordination
protocol that guarantees the consistent access to the shared resources 
in addition  we propose here an extension to the relational language for modeling nondeterministic actions  micalizio   torasso         in the previous approach  in fact  we
assume to know in advance all the exogenous events that can affect a given action  in this
paper we are able to deal with partial knowledge about the exogenous events  in particular  we allow to specify just a subset of the effects an exogenous event has on an action
 i e   some agents variables might become unknown after the event   but we also allow to
specify that an action might be affected by an indefinite event whose effects are completely
  

ficooperative monitoring to diagnose multiagent plans

unpredictable  i e   all agents variables become unknown due to the event   this kind of
extended action model subsumes the action models proposed by roos and witteveen  which
just consists of two parts  the nominal action model  and an abnormal model that maps
each agents variable into the unknown value 
cooperation among agents and nondeterministic action models make cwcm particularly apt to deal with dynamic and partially observable environments  on the one side  the
nondeterministic action models we have discussed here capture unexpected changes in the
environment  on the other side  the cooperative monitoring allows each agent to acquire
information about the environment from the other agents  it is important to note that 
differently from other works where agents exchange each other their internal belief states
 see e g   kalech   kaminka         in cwcm an agent just needs to communicate what
it observes  this enables agents to keep private their internal beliefs  in addition  agents
could adopt specific policies for deciding what observations should be forwarded to what
agents  forwarding some observations to more agents  and not just to a single agent as
in the current proposal  might help the agents to discover earlier the outcomes of some
pending actions  we leave this opportunity for future research 
it must also be noted that cwcm just assumes that observations are correct  the
actual state of an agent must not be pruned off the agent belief state due to an erroneous
observation  this assumption is often made also in many model based approaches to diagnosis  see e g   birnbaum et al         brusoni  console  terenziani    theseider dupre 
      pencole   cordier        roos   witteveen        eiter  erdem  faber    senko 
      just to mention a few   correctness of the observations  however  does not implies
that observations must be precise  cwcm can in fact consume ambiguous messages given
as a disjunction of values for the same variable  i e   var   v   var   v         var   vn   
or as a negation of a specific value  i e   var    v   from the point of view of cwcm 
consuming such observations simply corresponds to the selection of states within the belief
state the observations refer to  although this aspect has not been emphasized in the paper 
the ability of dealing with ambiguous observations enriches the communicative capacities
of the agents  for instance  in an ask if interaction  a client  rather than answering with
a generic no info  could give the provider a disjunction of possible resource states among
which  however  the client is incapable to discriminate the actual one  this set of alternative
states is  from the point of view of the provider  much more informative than no info  and
possibly could lead the provider to determine the actual state of the resource at hand 
from the point of view of the diagnostic inference  we have shown that it is possible to
explain action failures by extracting explanations from the trajectory sets built by cwcm 
in particular  we have pointed out that assuming action failures independent of each other
might lead to spurious diagnoses  for this reason we have proposed a methodology for
identifying primary action failures and secondary action failures  which are just an indirect
consequence of the primary ones  a simple preference criterion  based on the minimality of
the primary action failures  has been proposed to prefer alternative explanations 
a deep experimental analysis has shown that both the cooperative monitoring and diagnosis are practically feasible  an efficient implementation based on obdds is discussed in
the appendix together with a computational analysis from a theoretical point of view  the
experiments have highlighted that cwcm scales up well with the number of agents  but it is
affected by the level of observability of the environment  the trajectory sets tend to be big  

fimicalizio   torasso

ger as the environment is less observable  however  the experiments demonstrate that the
cooperation is effective even in dealing with very scarcely observable environments  competence rates for noncooperative solutions  in fact  are comparable with those of cwcm
only when the environment is fully observable  in other situations  instead  cwcm always
exhibits the highest competence 
the proposed framework can be extended in different ways  as mentioned above  we
have so far adopted a careful approach to communication by restricting the agents to talk
with each other only about the exchanged services  however  the agents might be willing
to communicate further pieces of knowledge they have acquired  an interesting possible
extension is to improve the cooperative protocol along this direction  the intuition  in fact 
is that when an agent acquires more information  it could infer the outcome of some of
its pending actions earlier than what it does now  of course  the communication must not
become a bottleneck  so agents should be able to identify what piece of information is worth
to be forwarded to what agents  and avoid broadcasting every observation to all the agents 
the most important extension we aim at  however  is to relax the assumption that
communication among the agents is always reliable  removing such an assumption has
many consequences  first of all  the cooperative monitoring protocol should be extended in
order to deal with messages that can be lost  moreover  proposition    about the safe use
of resources  might no longer be guaranteed by cwcm  thus resources could be accessed
inconsistently  to diagnose these situations we could take a point of view similar to kalech
and kaminkas social diagnosis  in fact  erroneous access to resources  could be considered
as coordination failures  this would impact the diagnostic inferences that should no longer
be local  but distributed  that is  as for the monitoring task  also diagnosis should be
performed by means of the cooperation of a number of agents 

acknowledgments
the authors wish to thank the anonymous reviewers for their insightful comments  that
have substantially contributed to the final shape of this work 

appendix a  implementation and computational analysis
in this appendix we first recall some basic obdd operators and their complexities  and
then we study the computational cost of the most expensive relational operations involved
by the cwcm and diagnostic methodologies discussed above 
a   obdd operators and their complexities
the computational analysis we discuss in the next subsection relies on the results presented
by bryant               in these works  the author discusses an efficient implementation of
obdds operators and their corresponding computational complexities  these results are
summarized in table    where f   f    and f  denote the boolean functions  encoded by the
reduced function graphs g  g    and g    respectively  the size of graph g corresponds to
the number of its vertices  and it is represented as  g   the primitive obdd operators are
reported in the upper side of table   
  

ficooperative monitoring to diagnose multiagent plans

  reduce builds the canonical form of a boolean function f   i e   given a specific variables
ordering  the reduce operator gets a graph g whose size is minimal 
  apply implements binary logical operations between two boolean functions f  and f   
the operator works on graphs g  and g  encoding the two functions  respectively 
op can be any binary logical operator           the computational complexity
in the worst case is o the product of the sizes  i e   number of vertices  of the two
graphs 
  restrict substitutes a constant b to a variable xi in time almost linear in the number
of vertices within the graph g 
  rename renames a set of variables  x with a new one  x    its complexity is exponential
in the number of renamed variables 
  equiv checks the equivalence of the two boolean functions f  and f    since this operator
scans the two corresponding graphs simultaneously  the computational complexity is
linear in their sizes 
in the lower side of table   we report the computational cost in time and space for the relational operators join  intersect  union and project that can be obtained by combining
primitive obdd operators  observe that  among the relational operators  the projection
is the most expensive  in fact  it is exponential in the number of the  binary  variables to
be removed  see e g   torta   torasso        torasso   torta       for details  
a   cwcm  computational analysis
to analyze the computational complexity of cwcm  we consider the high level algorithm
presented in figure     and focus on the computational cost of performing a single iteration
of the while loop when an action ail is actually performed in the real world  in such a
situation there are three main steps that hide potentially expensive operations on relations 
 the extension of the current trajectory set  line    
 the refinement of the trajectory set with the available observations  line     
 the detection of the outcomes of the pending actions  line     figure    
in the rest of this section we analyze the computational effort of each of these steps 
operator
reduce f  
apply op  f    f   
restrict xi   b  f  
rename  f    x   x   
equiv f    f   

time
o  g   log  g  
o  g      g    
o  g  
o  g      x   
o max  g      g     

size
 g 
  g      g   
  g 
  g      x 
n a

join  f    f     union f    f    
intersect f    f     i e   select 
project f    x            xn     y            ym   

o  g      g    
o  g      g    
o    nm    g     

  g      g   
  g      g   
   nm   g 

table    obdd operators and their complexity 
  

fimicalizio   torasso

a     extending the trajectory set
according to equation      the operator   which from t r i     l  yields a new trajectory set
t r i  i  l       involves two join operations  one between t r i     l  and  ail    and one between
t r i     l  and  ail    the results of these two operations are subsequently merged into a new
trajectory set t r i     l      via a union operation  to understand the computational cost of
these relational operations  it is necessary to map them into obdd operators  as already
shown in previous works  see e g   torta   torasso        micalizio         the natural
join can be mapped to the and between two boolean functions  and hence between two
obdds   whereas the union of two relations becomes the boolean or  let gl   gl     g  
and g be the obdds corresponding to the relations t r i     l   t r i     l        ail    and
 ail    respectively  the  operator can be mapped to the following expression in terms of
obdds operations 
gl     apply   apply   gl   g    apply   gl   g   

    

given the operator complexities in table    the computational effort to infer the new
trajectory set is in the worst case 
o  gl        o  gl     g     o  gl     g   
  o  gl      g     g    

    

a     refinement with observations
once the new trajectory set has been inferred  it is refined with the observations obsik
received by the agent  for the sake of exposition  in equations     and     we defined
the refinement of a trajectory set as an intersection between the trajectory set itself and
the belief state bki refined with obsik   note that the extraction of a belief state is a very
expensive operation  thus we try to avoid this operation whenever possible  in this particular
case  since the agent variables v arki are included within the current trajectory set  the
refinement operation can be carried out as an intersection between t r i     l      and obsik  
in terms of obdd operators 
gref  l     apply   gl     gobsi  
k

    

where gobsi is the obdd encoding obsik   and gref  l   is the obdd corresponding to the
k
refined trajectory set refinedt r i     l       it follows that the computational cost of this
operation is
    
o  gref  l        o  gl       gobsi   
k

a     detecting pending actions outcomes
the last step of the cwcm algorithm we consider is the assessment of the outcome of every
action currently within the list of pending actions pactsi   in section    we noted that to
verify the success of a given action aik  pactsi   it is sufficient to check whether the nominal
i
effects of aik are satisfied in every state in bk  
 definition     in case such a condition does
not hold  one has to verify whether the expected nominal effects of aik are missing in each
  

ficooperative monitoring to diagnose multiagent plans

i
state of bk  
 definition     if both checks result in a negative answer  i e   the belief state
i
bk   is still too ambiguous   action aik remains pending 
i
for explicitly checking these conditions might be parextracting the belief state bk  
ticularly expensive  especially when the trajectory set grows over time  the extraction of
a belief state through the project operation  in fact  would require the elimination from
t r i     l      of all the variables we are not interested in  thus  we would remove the variables
about steps               k  k              l      that is l   vari   variables  as table   shows  the
complexity of project is exponential in the number of variables to be removed  so it could
easily become a bottleneck 
to cope with this problem  we implemented the checking for the ok and f ailed outcomes
in a different way  in particular  from definition   it directly follows 
i
i
 
join effects aik   equals bk  
proposition    aik has outcome ok iff bk  

proof  the proof is straightforward  by definition aik has outcome ok iff its nominal effects
i
i
i
are satisfied in every state in bk  
  the join between bk  
and effects aik   yields bk  
only
i
when the nominal effects are already included in every state in bk     and hence the action
has outcome ok 

since bk   is included in refinedt r i      l       the above proposition can be extended
to the whole trajectory set 
proposition    aik has outcome ok iff
refined t r i     l      join effects aik  equalsrefined t r i     l      
that is to say  after the refinement of the trajectory set with the observations  action aik has
outcome ok iff its nominal effects do not filter out any trajectory from refinedt r i     l      
relying on this proposition  we can verify whether aik has outcome ok in two steps  first 
we build a temporary obdd maintaining the result of the join between t r i     l      and
effects aik    and then we check whether the temporary obdd is equivalent to the original
trajectory set  in terms of obdd operators 
outcomeok    equiv gref l     apply   gref l     geffects ai     
k

    

since the size of geffects ai   is negligible when compared to the size of gref l     computak
tional complexity of this check is about o  gref l        
the f ailed outcome can be checked in a similar way  in this case we want to discover
whether the nominal effects of aik are missing in t r i     l       this happens only when the
negation of the effects effects aik   do not represent a possible filter for t r i     l      so that
t r i     l      join effects aik   is again equals to t r i     l       in terms of obdd operators
outcomefailed    equiv gref l     apply   gref l     geffects ai     

    

k

it is important to note that the obdd geffects ai   is computed in constant time directly
k
from geffects ai     in fact  given a boolean function f and the corresponding graph gf   it
k
is sufficient to exchange with each other the   and   nodes in gf to obtain the graph
representation of the boolean function not f    thus  also this check is about o  gref l        
  

fimicalizio   torasso

it follows that the cost for determining the outcomes of the actions in pactsi is 
o  pactsi     g ref  l        

    

from equation       it is easy to see that the computational cost of the cwcm methodology strongly depends on the amount of available observations  the worst case is in fact
when at a give step l  due to very scarce observations  the number of pending actions is
close to l itself  that is   pactsi    l  meaning that almost all the actions performed so far
have outcome pending 
a   diagnosis  computational analysis
the computational cost of the diagnostic process is strongly dominated by the cost for
inferring the event based explanations  eve    as we have shown  in fact  it is possible to
extract the set of minimum cardinality primary action failures explanations  mp ads  from
such a structure  according to equation     the eve set can be extracted as a projection
of the current trajectory set t r i     l  over the event variables e            el    unfortunately  in
this case there is no way to avoid this expensive operation 
to estimate its computational cost  we have first to consider how many binary variables
are within the obdd gl encoding t r i     l   and how many  binary  variables we are going to
remove from that obdd  each state and event variable in t r i  i  l  is in fact a multi valued
variable that is actually implemented in terms of a number of binary variables within the
obdd gl   the number of required binary variables depends on the size of the domain of
the original high level variable  let us assume that d is the size of the largest domain of the
variables in vari   then we can estimate that we need b   log d binary variables for each
variable mentioned in t r i     l   both state and event variables   it is easy to see that the
number of binary variables required to represent a single belief state is w   b   vari    for
each multi valued variable in vari we have b binary variables at obdd level 
the number of binary variables encoding the trajectory set t r i  i  l  is therefore p  
l  w    l      b  in fact  within t r i     l   we have l beliefs and l   event variables  the cost
of projecting t r i     l  over the event variables is therefore 
o   plw   gl       

    

once eve diagnoses have been extracted  it is possible to infer the minimum cardinality
primary failures by exploiting techniques by torasso and torta         which are proven to
be polynomial in the size of the obdd 
a   discussion
a first important result that emerges from the computational analysis above is that the
monitoring of a single execution step with cwcm is not exponential  in fact  we have
shown that each step of its declarative definition can be mapped into a number of obdd
operators whose complexity is polynomial  provided that the sizes of the involved obdds
remain manageable  in particular  we have shown that the only exponential operation used
in the declarative definition  the projection  can be avoided in the actual implementation 
the main concern with cwcm is that the trajectory set may grow over time as an agent
  

ficooperative monitoring to diagnose multiagent plans

performs actions without receiving observations  consequently  also the computational cost
of cwcm tends to grow over time since the size of the obdd encoding the trajectoryset may increase  it is important to note  however  that such a growth is not exponential
but quadratic  see equation        in addition  to estimate the computational costs of
both monitoring and diagnosis  we exploited the estimations reported in table    these 
however  are estimates of the very worst possible cases  but in practice these cases are not
very common  bryant conjectures that  although the theoretical cost of the apply operator
between two obdds g  and g  is o  g      g     in the worst case  in practice the actual
cost is in most of the cases closer to o  g       g       g     where g  is the resulting obdd
 bryant         thus also the size of the resulting  intermediate obdds plays a central
role in determining the actual computational cost 
in the specific case of cwcm  we have to observe that it is not very common for an
agent to perform a long portion of its plan without receiving observations  the cwcm
allows in fact the agents to communicate with each other  therefore  unless an agent is
completely isolated from others  each agent will likely receive observations coming from the
other agents about the services it has provided them with  this means that  in practice 
the size of the obdd encoding the trajectory set should not become intractable because of
the cooperation among the agents  and the experiments we have conducted so far support
this hypothesis 
on the other hand  the diagnostic inferences are slightly more expensive than the monitoring strategy  this because the project operation cannot be avoided in order to infer a
diagnosis  in this case  however  we have to observe that the plan execution has already
been stopped as a consequence of a detected failure  thus  the diagnosis can take more
time to infer a result since it is not constrained to be on line 

references
arasu  a   babu  s     widom  j          the cql continuous query language  semantic
foundations and query execution  the international journal on very large data
bases                 
birnbaum  l   collins  g   freed  m     krulwich  b          model based diagnosis of
planning failures  in proc  of association for the advancement of artificial intelligence
 aaai     pp         
boutilier  c     brafman  r  i          partial order planning with concurrent interacting
actions  journal of artificial intelligence research             
brusoni  v   console  l   terenziani  p     theseider dupre  d          a spectrum of
definitions for temporal model based diagnosis  artificial intelligence            
bryant  r          graph based algorithms for boolean function manipulation  ieee transactions on computers                 
bryant  r          symbolic boolean manipulation with ordered binary decision diagrams 
acm computer surveys             
  

fimicalizio   torasso

cordier  m  o     grastien  a          exploiting independence in a decentralised and
incremental approach of diagnosis  in proc  of the international joint conference on
artifical intelligence  ijcai     pp         
cox  j  s   durfee  e  h     bartold  t          a distributed framework for solving the
multiagent plan coordination problem  in proc  of international conference on autonomous agents and multiagent systems  aamas     pp         
darwiche  a     marquis  p          a knowledge compilation map  journal of artificial
intelligence research             
de jonge  f   roos  n     witteveen  c          primary and secondary diagnosis of multiagent plan execution  journal of autonomous agent and multiagent systems         
       
eiter  t   erdem  e   faber  w     senko  j          a logic based approach to finding
explanations for discrepancies in optimistic plan execution  fundamenta informaticae 
               
fox  m     long  d          pddl     an extension to pddl for expressing temporal
planning domains  journal of artificial intelligence research            
grastien  a   anbulagan  rintanen  j     kelareva  e          diagnosis of discrete event
systems using satisfiability algorithms  in proc  of association for the advancement
of artificial intelligence  aaai     pp         
grastien  a   haslum  p     thiebaux  s          conflict based diagnosis of discrete event
systems  theory and practice  in proceedings of the thirteenth international conference on principles of knowledge representation and reasoning  kr     pp         
gupta  s   roos  n   witteveen  c   price  b     de kleer  j          exploiting shared
resource dependencies in spectrum based plan diagnosis  in proc  of association for
the advancement of artificial intelligence  aaai     pp             
heger  f  w   hiatt  l  m   sellner  b   simmons  r     singh  s          results in sliding
autonomy for multi robot spatial assembly  in proc  international symposium on
artificial intelligence  robotics and automation in space  isairas  
helmert  m          concise finite domain representations for pddl planning tasks  artificial intelligence                    
jonsson  p     backstrom  c          state variable planning under structural restrictions 
algorithms and complexity  artificial intelligence                    
kalech  m          diagnosis of coordination failures  a matrix based approach  journal
of autonomous agents and multiagent systems                
kalech  m     kaminka  g  a          on the design of social diagnosis algorithms for
multi agent teams  in proc  international joint conference on artificial intelligence
 ijcai     pp         
kalech  m     kaminka  g  a          diagnosing a team of agents  scaling up  in proc 
of international conference on autonomous agents and multi agent systems  aamas     pp         
  

ficooperative monitoring to diagnose multiagent plans

kalech  m     kaminka  g  a          on the design of coordination diagnosis algorithms
for teams of situated agents  artificial intelligence                    
kalech  m     kaminka  g  a          coordination diagnostic algorithms for teams of
situated agents  scaling up  computational intelligence                 
kalech  m   kaminka  g  a   meisels  a     elmaliach  y          diagnosis of multi robot
coordination failures using distributed csp algorithms  in proc  of association for
the advancement of artificial intelligence  aaai     pp         
kaminka  g  a     tambe  m          robust multi agent teams via socially attentive
monitoring  journal of artificial intelligence research             
lamperti  g     zanella  m          diagnosis of discrete event systems from uncertain
temporal observations  artificial intelligence                   
mi  p     scacchi  w          articulation  an integrated approach to the diagnosis  replanning  and rescheduling of software process failures  in proc  of knowledge based
software engineering conference  pp       
micalizio  r          action failure recovery via model based diagnosis and conformant
planning  computational intelligence                 
micalizio  r     torasso  p       a   on line monitoring of plan execution  a distributed
approach  knowledge based systems                 
micalizio  r     torasso  p       b   plan diagnosis and agent diagnosis in multi agent
systems  in proc  congress of the italian association for artificial intelligence
 ai ia     vol       of lncs  pp         
micalizio  r     torasso  p          monitoring the execution of a multi agent plan  dealing
with partial observability  in proc  of european conference on artificial intelligence
 ecai     pp         
micalizio  r     torasso  p          agent cooperation for monitoring and diagnosing a
map  in proc  of multiagent system technologies  mates     vol       of lncs 
pp       
micalizio  r   torasso  p     torta  g          on line monitoring and diagnosis of a team
of service robots  a model based approach  ai communications                 
nebel  b          on the compilability and expressive power of propositional planning
formalisms  journal of artificial intelligence research             
pencole  y     cordier  m          a formal framework for the decentralized diagnosis of
large scale discrete event systems and its application to telecommunication networks 
artificial intelligence              
reiter  r          a theory of diagnosis from first principles  artificial intelligence         
     
roos  n     witteveen  c          models and methods for plan diagnosis  journal of
autonomous agent and multiagent systems               
sampath  m   sengupta  r   lafortune  s   sinnamohideen  k     teneketzis  d         
diagnosability of discrete event systems   ieee transactions on automatic control 
                 
  

fimicalizio   torasso

sellner  b   heger  f   hiatt  l   simmons  r     singh  s          coordinated multiagent teams and sliding autonomy for large scale assembly  ieee   special issue on
multi robot systems                     
steinbauer  g     wotawa  f          enhancing plan execution in dynamic domains using
model based reasoning  in intelligent robotics and applications  first international
conference   icira     vol       of lnai  pp         
tambe  m          implementing agent teams in dynamic multi agent environments  applied
artificial intelligence                   
torasso  p     torta  g          computing minimum cardinality diagnoses using obdds 
in german conference on ai  ki     vol       of lncs  pp         
torasso  p     torta  g          model based diagnosis through obdd compilation  a complexity analysis  in reasoning  action and interaction in ai theories and systems 
vol       of lncs  pp         
torta  g     torasso  p          on the role of modeling causal independence for system
model compilation with obdds  ai communications               
weld  d  s          an introduction to least commitment planning  ai magazine         
     
witteveen  c   roos  n   van der krogt  r     de weerdt  m          diagnosis of single
and multi agent plans  in proc  of international conference on autonomous agents
and multiagent systems  aamas     pp         
yan  y   dague  p   pencole  y     cordier  m  o          a model based approach for
diagnosing fault in web service processes  journal of web service research         
      

  

fi