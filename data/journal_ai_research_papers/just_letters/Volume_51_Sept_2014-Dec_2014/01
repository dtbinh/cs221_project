journal artificial intelligence research                 

submitted       published     

testability bdi agent systems
michael winikoff
stephen cranefield

michael winikoff otago ac nz
stephen cranefield otago ac nz

department information science
university otago
new zealand

abstract
deploying software system need assure  and stakeholders 
system behave correctly  assurance usually done testing system 
however  intuitively obvious adaptive systems  including agent based systems 
exhibit complex behaviour  thus harder test  paper examine
obvious intuition case belief desire intention  bdi  agents  analyse
size behaviour space bdi agents show although intuition correct 
factors influence size expected be  specifically 
found introduction failure handling much larger effect size
behaviour space expected  discuss implications findings
testability bdi agents 

   introduction
increasingly called upon develop software systems operate dynamic environments  robust face failure  required exhibit flexible behaviour  operate open environments  one approach developing systems
demonstrated effectiveness range domains use metaphor
software agents  wooldridge         agent based systems increasingly finding
deployment wide range applications  e g  munroe  miller  belecheanu  pechoucek 
mcburney    luck        benfield  hendrickson    galanti        
agent based systems increasingly deployed  issue assurance rears head 
deploying system  need convince rely system  or
responsible fails  system will  fact  work  traditionally 
assurance done testing    however  generally accepted adaptive systems
exhibit wide complex range behaviours  making testing hard  example 
validation extensive tests mandatory         however  task proved
challenging         agent based systems explore realms behaviour outside peoples expectations often yield surprises   munroe et al         section       
is  intuition agent systems exhibit complex behaviour  makes
hard test  paper explore intuition  focusing well known beliefdesire intention  bdi  approach realising adaptive flexible agents  rao   georgeff 
   although considerable research formal methods context agent systems  dastani 
hindriks    meyer         yet ready real world application  see section    
concerns scope work applicability  winikoff        
c
    
ai access foundation  rights reserved 

fiwinikoff   cranefield

      bratman         demonstrated practically applicable  resulting
reduced development cost increased flexibility  benfield et al         
explore intuition agent systems hard test analysing
space possible behaviours bdi agents  is  number paths bdi
program  probability failure  focus bdi agents provide welldefined execution mechanism analysed  seek understand
complexities  and testability implications  adaptive intelligent behaviour
absence parallelism  since implications parallelism already well known  
derive number paths bdi program function various parameters  e g  number applicable plans per goal failure fate   naturally
leads us consider number paths affected various parameters 
might expected  show intuition agent systems hard test
correct  i e  agent systems large number paths  show bdi
agents harder test procedural programs  showing number paths
bdi program much larger number paths similarly sized
procedural program 
contribution paper threefold  firstly  confirms intuition bdi
programs hard test  secondly  quantifying number paths 
function parameters bdi program  thirdly  find surprising results
parameters influence number paths 
although recently increasing interest testing agent systems  zhang 
thangarajah    padgham        ekinci  tiryaki  cetin    dikenelli        gomez sanz 
bota  serrano    pavon        nguyen  perini    tonella      b   surprisingly little work determining feasibility testing agent systems first place 
padgham winikoff        pp        analyse number successful executions
bdi agents goal plan tree  defined section     consider failure failure
handling analysis  consider testability implications  shaw  farwer
bordini        analysed goal plan trees shown checking whether goal plan
tree execution schedule respect resource requirements np complete 
different problem one tackle  concerned allocation
resources amongst goals  rather behaviour space 
briefly address number possible criticisms work  considering
existing work 
   number paths useful metric assessing testability 
consider related area software testing  section      argue
metric well established one  appropriate use assess testability 
   isnt obvious corollary complexity htn planning 
consider detail htn planning problem  section      argue although
bdi execution cycle certain similarities htn planning  differences
significant  and  particular  mean problem htn planning
simply different problem testing bdi programs 
   use combinatorial analysis  rather complexity analysis 
combinatorial analysis precise  yields formulae exact number
  

fion testability bdi agent systems

paths  exact probabilities failure  latter  see section     
informative order magnitude complexity  additionally allows
us consider issues complexity analysis would address  effect
number failures number paths 
    software testing
trying assess hard agent systems test  concretely  given bdi
agent program  want know hard program test  reduced
directly question test set adequacy  agent program p easy test precisely
extent exists test set adequate testing p  
infeasibly large  conversely  agent program p hard test extent
adequate test set would infeasibly large  words  hardness
testing program directly assessed size required test set adequate
respect suitable adequacy criteria 
many criteria used assess whether given set tests adequate  for recent overview  see mathur         given interested assessing
difficulty testing given program  clearly looking white box testing  furthermore  working abstract goal plan trees rather detailed programs
 see section     means need consider control flow based metrics  rather
data flow  since abstract goal plan tree contain data flow information 
focussing white box testing criteria control flow based  basic
long standing criterion assessing test set adequacy paths program
covered  miller   maloney         example  consider program following form 
      
   input x

   condition    

   endif

   c

       else b

two paths program                                  
adequate test set must least two tests adequate  one exercise first path 
another exercise second  case test set single test
inadequate  result part program executed testing 
obvious complication covering paths program loop result
infinite number paths  since loop potentially executed number
times  standard technique dealing bound length paths 
number executions loop  zhu  hall    may        p        bounding execution
loops done either calculating upper bound number iterations based
data  mathur        p       considering paths loops executed
zero times one time  mathur        p       
one question might asked consider paths  rather weaker
criterion  agent applications typically involve environments non episodic  is 
environments history matters  means behaviour given plan goal
is  general  sensitive agents history  hence need consider different
possible histories  achieving goal may different done first thing
  

fiwinikoff   cranefield

agent does  failed plan already performed number actions 
means makes sense consider path based criterion testing 
furthermore  although paths adequacy criterion often considered impractical  reason appears primarily existence infinite number paths
presence loops  instance  zhu et al         p       say plan coverage criterion
strong practically useful programs  infinite
number different paths program loops  setting 
loops  existence infinite number paths issue  considering number
paths possible 
therefore use number paths proxy measure testing difficulty 
paths program  adequate test set  according
paths criterion  need large  hand  number paths
large  adequate test set need large 
one issue need consider  since paths strong criterion 
possible that  even absence  or bounding  loops  criterion always results
infeasibly large numbers paths  order address issue analysis
number paths procedural programs  of equivalent size   compare
number paths bdi programs  see section    
finally  bears noting paths criterion considers parts
program traversed testing  ignores values variables  so  example 
trivial program consisting single statement x    x x single one step path 
trivially covered  many traces  x                  
    htn planning
similarities hierarchical task network  htn  planning  erol  hendler 
  nau        bdi execution  de silva   padgham         use hierarchical
representation goals  non primitive tasks htn terminology   plans  decomposition methods  goal plan trees  task networks   complexity htn planning
explored  given similarities  simply exploit known complexity
results 
turns cannot so  simple reason complexity htn
planning concerns plan finding problem  different bdi plan execution 
sardina padgham explain 
bdi agent systems htn planners come different communities
differ many important ways  former focus execution plans 
whereas latter concerned actual generation plans 
former generally designed respond goals information  latter
designed bring goals  addition  bdi systems meant
embedded real world therefore take decisions based particular
 current  state  planners  hand  perform hypothetical reasoning
actions interactions multiple potential states  thus  failure
different meaning two types systems  context
planning  failure means plan potential plan suitable  within
bdi agent systems failure typically means active  sub plan ought
  

fion testability bdi agent systems

aborted  whereas backtracking upon failure option planning systems 
generally bdi systems  actions taken real world   sardina
  padgham        p      bold emphasis added 
words  htn systems plan ahead execution  whereas bdi systems interleave
execution planning   
htn plan existence problem answers question plan exist 
complexity studied  settings correspond bdi execution  many goals 
total ordering within plans  variables  known expspace hard
dexptime  erol  hendler    nau               however  work address
question bdi execution  considering complexity plan existence htn
planning asking computational complexity search process
result plan  hand  asking number paths
goal plan tree asking possibilities arise executing plan 
illustrate point  consider following example  suppose single goal
g decomposed two alternative plans  p  p    plan p  consists
sequential execution actions a  b  c  plan p  consists sequential execution
actions e  plan existence problem boils considering options p 
p    since case search space simple  offering two options 
hand  question many paths exist bdi execution considers different
ways goal plan tree executed  whereas htn planning considers p 
single atomic decomposition  bdi execution needs consider sequence actions a  b  c
distinct steps  possible three actions succeed  giving trace a  b  c  
possible action b fail  followed p   successfully  used  giving trace
a  b   d  e   action c fail  followed p   successfully  used  giving trace
a  b  c   d  e  
overall  means complexity analysis erol et al              
different problem  htn complexity results relevant  finally  note
that  fact  setting  plan existence problem actually trivially true  since
bdi programs constraints always expansion program
sequence actions 
remainder paper structured follows  begin briefly presenting
bdi execution model  section    discussing bdi execution viewed
process transforming goal plan trees  section     section   core paper
analyse number paths bdi style goal plan tree  consider
analysis assumptions hold real system real platform  section    
analysis bdi programs compares analysis  number paths 
conventional procedural programs  section     finally  conclude discussion
implications testing future work  section    
   approaches blur difference adding look ahead planning bdi online execution
htns  example planner retsina multi agent system  paolucci  shehory  sycara  kalp 
  pannu        ability interleave planning execution  however  theoretical analysis
extension reported  analysis erol  hendler  nau              applies
classical htn planning 

  

fiwinikoff   cranefield

   bdi execution model
describe belief desire intention  bdi  model explain chose
model agent execution  addition well known widely used  bdi model
well defined generic  well defined allows us analyse behaviour spaces
result using it  generic implies analysis applies wide range
platforms 
bdi model viewed philosophical  bratman        logical  rao
  georgeff        perspectives  interested implementation perspective  exhibited range architectures platforms  jack  busetta 
ronnquist  hodgson    lucas         jam  huber         dmars  dinverno  kinny  luck 
  wooldridge         prs  georgeff   lansky        ingrand  georgeff    rao        
um prs  lee  huber  kenny    durfee         jason  bordini  hubner    wooldridge 
       spark  morley   myers         jadex  pokahr  braubach    lamersdorf       
irma  bratman  israel    pollack         purposes analysis here 
formal detailed presentation unnecessary  interested formal semantics
bdi languages referred work rao         winikoff  padgham  harland 
thangarajah        bordini et al          example 
implementation bdi agent key concepts beliefs  or  generally 
data   events plans  reader may find surprising goals key concepts
bdi systems  reason goals modelled events  acquisition new goal
viewed new goal event  agent responds selecting executing plan
handle event    remainder section  keeping established
practice  describe bdi plans handling events  not goals  
bdi plan consists three parts  event pattern specifying event s  relevant
for  context condition  a boolean condition  indicates situations plan
used  plan body executed  plans event pattern context condition
may terms containing variables  matching unification process  depending
particular bdi system  used bdi interpreters find plan instances respond
given event  general plan body contain arbitrary code programming
language    however purposes assume  plan body sequence steps 
step either action   which succeed fail  event posted 
example  consider simple plans shown figure    first plan  plan a 
relevant handling event achieve goal go home  applicable situations
agent believes train imminent  plan body consists sequence
four steps  in case assume actions  could modelled
events handled plans  
key feature bdi approach plan encapsulates conditions
applicable defining event pattern context condition  allows
additional plans given event added modular fashion  since invoking
   types event typically include addition removal beliefs agents belief set 
   example  jack plan body written language superset java 
   follows abstract notations agentspeak l   rao         winikoff et al        
aim capture essence range  more complex  bdi languages 
   includes traditional actions affect agents environment  internal actions
invoke code  check whether certain condition follows agents beliefs 

  

fion testability bdi agent systems

plan a  handles event 
achieve goal go home
context condition 
train imminent
plan body 
    walk train station
    check train running time
    catch train
    walk home
plan b  handles event 
achieve goal go home
context condition 
raining bicycle
plan body 
    cycle home
plan c  handles event 
achieve goal go home
context condition 
true  i e  always applicable 
plan body 
    walk bus stop
    check buses running
    catch bus
    walk home
figure    three simple plans
context  i e  triggering event posted  contain code selects amongst
available plans  key reason flexibility bdi programming 
typical bdi execution cycle elaboration following event driven process
 summarised figure      
   event occurs  either received outside source  triggered within
agent  
   agent determines set instances plans plan library event patterns
match triggering event  set relevant plan instances 
   agent evaluates context conditions relevant plan instances generate
set applicable plan instances  relevant plan instance applicable context
condition true  applicable plan instances event deemed
failed  posted plan  plan fails  note
single relevant plan may lead applicable plan instances  if context condition
false   one applicable plan instance  if context condition 
may contain free variables  multiple solutions  
   one applicable plan instances selected executed  selection mechanism varies platforms  generality  analysis make as   bdi engines are  fact  complicated interleave execution multiple
active plan instances  or intentions  triggered different events 

  

fiwinikoff   cranefield

boolean function execute an event 
let relevant plans   set plan instances resulting
matching plans event patterns an event
let tried plans  
true
let applicable plans   set plan instances resulting
solving context conditions relevant plans
applicable plans    applicable plans   tried plans
applicable plans empty return false
select plan p applicable plans
tried plans    tried plans  p 
execute p body    true return true
endwhile
boolean function execute plan body 
plan body empty return true
elseif execute first plan body     false return false
else return execute rest plan body  
endif
boolean function execute action 
attempt perform action
action executed successfully return true else return false endif

figure    bdi execution cycle
sumptions plan selection  plans body may create additional events
handled using process 
   plan body fails  failure handling triggered 
brevity  remainder paper use term plan loosely mean
either plan plan instance intention clear context 
regarding final step  approaches dealing failure  perhaps
common approach  used many existing bdi platforms 
select alternative applicable plan  consider event failed
remaining applicable plans  determining alternative applicable plans one may
either consider existing set applicable plans  re calculate set applicable
plans  ignoring already tried   done figure    makes
sense situation may changed since applicable plans determined 
many  but all  bdi platforms use failure handling mechanism retrying
plans upon failure  analysis applies platforms 
one alternative failure handling approach  used jason  bordini et al         
post failure event handled user provided plan  although
flexible  since user specify upon failure  place burden
  

fion testability bdi agent systems

specifying failure handling user  note jason provides pattern allows
traditional bdi failure handling mechanism specified succinctly  bordini et al        
pp           another alternative failure handling approach used  apl  dastani 
      predecessor   apl  permit programmer write plan repair rules
conditionally rewrite  failed  plan another plan  approach  jasons 
quite flexible  possible analyse general way plan rules
quite arbitrary  another well known bdi architecture irma  described
high level prescribe specific failure handling mechanism 
full development architecture would give account
ways resource bounded agent would monitor prior plans
light changes belief  however developed  course
times agent give prior plan light new belief
plan longer executable  happens  new process
deliberation may triggered  bratman et al         
given bdi execution cycle discussed above  three example plans given earlier
 figure    give rise range behaviours  including following 
suppose event achieve goal go home posted agent believes
train imminent  walks train station  finds train running
time  catches train  walks home 
suppose upon arrival train station agent finds trains
delayed  step     plan fails  agent considers alternative plans 
raining present time  plan b applicable  plan c adopted
 to catch bus  
suppose agent decided catch bus  because train believed
imminent  raining   attempting execute plan c fails  e g 
bus strike   agent reconsider plans rain stopped  and
bicycle  may use plan b 
note correct  respectively incorrect  behaviour distinct successful
 respectively failed  execution plan  software testing essence process running system checking whether observed behaviour trace correct  i e  conforms
specification  model   hand  bdi agents behaviour traces
classified successful failed  however  correctness given execution
trace independent whether trace successful failed execution  successful
execution may  fact  exhibit behaviour correct  instance  traffic controller
agent may successfully execute actions set traffic signals intersection green
achieve goal so  successful execution  incorrect behaviour 
possible failed execution correct  instance  traffic controller agent
attempting route cars point point b  traffic accident blocked key
bridge two points  rational  and correct  behaviour agent
fail achieve goal 
  

fiwinikoff   cranefield

   bdi execution goal plan tree expansion
bdi execution  summarised figure    dynamic process progressively executes
actions goals posted  order easily analyse process  present
alternative view declarative  instead viewing bdi execution process 
view data transformation  finite  goal plan tree sequence action
executions 
events plans visualised tree goal  children
plan instances applicable it  plan instance children sub goals
posts  goal plan tree and or tree  goal realised one plan
instances  or  plan instance needs sub goals achieved  and  
viewing bdi execution terms goal plan tree action sequences makes
analysis behaviour space size  easier  consider bdi execution process taking
goal plan tree transforming sequence recording  failed successful 
executions actions  progressively making decisions plans use
goal executing plans 
process non deterministic  need choose plan goal tree 
furthermore  consider failure  need consider action whether fails
not  fail  failure recovery done 
define transformation process detail  prolog code implementing
process found figure    defines non deterministic predicate exec first
argument  input  goal plan tree  second argument  output  sequence
actions  goal plan tree represented prolog term conforming following
simple grammar  where gpt abbreviates goal plan tree  aogl abbreviates action
goal list  symbol  
hgpt     goal       goal  hplanlisti  
hplanlisti     hplani   hplani hplanlisti
hplani     plan       plan  haogli  
haogli     act a    hgpt   act a  haogli   hgpt i haogli
example  simple goal plan tree shown figure   modelled prolog term
goal  plan  act a     plan  act b      
analysis make simplifying assumption  instead modelling instantiation
plans plan instances  assume goal plan tree contains applicable plan
instances  thus  order transform goal node sequence actions  nondeterministically  select one applicable plan instances  selected plan
transformed turn  resulting action sequence  line   figure     selecting
plan  consider possibility applicable plans could chosen 
first plan  done different points time different plan instances may
applicable  saw example earlier  plan chosen failed 
   order consistent existing practice shall use term goal rather event
remainder paper 
   remainder paper use term behaviour space size  rather
cumbersome term number paths bdi program 

  

fion testability bdi agent systems

 
 
 
 
 
 
 
 
 
  
  
  
  
  
  

exec   goal           
exec   goal   plans     trace       remove   plans   plan   rest     exec   plan   trace     
  failed   trace       recover   rest   trace    trace     trace   trace    
exec   plan            
exec   plan    step   steps      trace       exec   step   trace     
  failed   trace       trace   trace    continue   steps   trace    trace    
exec   act   action       action    
exec   act   action       action   fail    
failed   trace       append  x    fail     trace   
recover   plans   trace    traces     exec   goal   plans     trace      append   trace    trace    traces   
continue   steps   trace    trace       exec   plan   steps     trace     
append   trace    trace    trace   
remove    x   xs    x   xs   
remove    x   xs    y    x   z        remove   xs  y   z   

figure    prolog code expand goal plan trees
goal
plan

plan



b

figure    simple goal plan tree

plan c selected  and failed   finally plan b  which applicable
plan failed  selected 
selected plan executes successfully  i e  action trace doesnt end fail
marker  line     resulting trace trace goals execution  line     otherwise  perform failure recovery  line      done taking remaining plans
transforming goal plans options  resulting action sequence
appended action sequence failed plan obtain complete action sequence
goal 
process easily seen match described figure    with exception 
discussed above  begin applicable plans  relevant plans   specifically 
applicable plan selected executed  successful execution stops 
successful  alternative plan selected execution continues  i e  action
sequences appended  
order transform plan node first transform first step plan 
either sub goal action  line     successful  continue transform
rest plan  append two resulting traces together  lines       
first step plan successful  trace simply trace first step
 line     words stop transforming plan step fails  again  process
easily seen correspond plan body execution figure   
  

fiwinikoff   cranefield

finally  order transform action action sequence simply take
action singleton sequence  line     however  need take account
possibility action may fail  thus second possibility action followed
failure indicator  line     again  process easily seen correspond action
execution figure    note model dont concern
action fails  could lack resources  environmental issues 
example applying process two example goal plan trees found
appendix a 

   behaviour space size bdi agents
consider many paths goal plan tree used
bdi agent realise goal   using tree  use analysis previous section
basis  is  view bdi execution transforming goal plan tree action
traces  thus  question large behaviour space bdi agents  answered
deriving formulae allow one compute number behaviours  successful
unsuccessful  i e  failed   given goal plan tree 
make following uniformity assumptions allow us perform analysis 
simplifying assumptions concern form goal plan tree 
   assume subtrees goal plan node structure  is 
leaves goal plan tree distance  number edges  away
root tree  therefore define depth goal plan tree
number layers goal nodes contains  goal plan tree depth   plan
sub goals  goal plan tree depth     either plan node
children goal nodes depth goal node children plan
nodes depth    note definition depth reverse usual
definition  where depth trees root defined     use definition
simplifies presentation derivations later section 
   assume plan instances depth     k sub goals 
   assume goals j applicable plan instances  case
goal j relevant plans  results exactly one applicable plan
instance  case ways  instance  goal may  j
relevant plans  half applicable current situation  goal may
single relevant plan j applicable instances  note assumption rules
possibility infinite number applicable plan instances 
would case plans context condition infinite number solutions 
cannot occur context condition defined terms conjunctions
propositions refer finite belief base  however  occur agents
context conditions make use prolog like knowledge base  as case
agent oriented programming languages  jason goal   nevertheless 
since deal applicable plans  dont model context conditions 
    focus single goal analysis  multiple goals treated concurrent interleaving
individual goals  multiple agents treated concurrent interleaving  care
needs taken details agent waiting another agent respond 

  

fion testability bdi agent systems

figure   shows uniform goal plan tree depth   
g 

d  

 
r pj 
p          
  
 
 

r
 
g         gk 
  
 
 

r
 
p         pj 

d  
d  
d  

figure    uniform goal plan tree
assumptions made clearly unrealistic  means consider
possibility real agent programs behave quite differently  since meet
assumptions  address issue number ways  firstly  section    
consider relaxation assumptions defining semi uniform trees 
number available plan instances  j  vary across different levels tree  secondly 
section     consider example  non uniform  goal plan tree industrial
application  derive number paths real goal plan tree compare
analysis similarly sized uniform goal plan trees see whether real  non uniform 
tree significantly lower number paths uniform tree  finally  section     
consider issue infinite trees allowing trees recursive  defining
number paths  up bound path length  recursive tree 
analysis uses following terminology 
uniformity assumptions mean structure subtree rooted goal
plan node determined solely depth  therefore denote goal
plan node depth gd pd  respectively  
use n  xd   denote number successful execution paths goal plan tree
depth rooted x  where x either goal g plan p   specifying
important sometimes elide it  writing n  x  
similarly  use n  xd   denote number unsuccessful execution paths
goal plan tree depth root x  either g p  
extend notation plan body segments  i e  sequences x            xn xi
goal action   denotes sequential composition  abbreviate sequence
n occurrences x xn  for example  g     g    g    g    
    base case  successful executions
begin calculating number successful paths goal plan tree
absence failure  and failure handling   analysis follows padgham
winikoff        pp        
roughly speaking  number ways goal achieved sum number
ways children achieved  since children represent alternatives 
  

fiwinikoff   cranefield

i e  goal represented node   hand  number ways plan
achieved product number ways children achieved
 since children must achieved  i e  plan represented node  
precisely  n  x    x      n  x    n  x     is  sequence successful x 
x  successful 
given tree root g  a goal   assume j children achieved
n different ways     then  select one children  number ways
g achieved jn  similarly  tree root p  a plan   assume
k children achieved n different ways  then  execute children 
number ways p executed n n  nk   plan children
 i e  depth    executed  successfully  exactly one way  yields following
definition 
n  gd     j n  pd   
n  p       
n  pd     n  gd k     n  gd  k
expanding definition obtain
n  g      j n  p      j     j
k

n  g      j n  p      j  n  g        j  j k     j k  
n  g      j n  p      j  j k    k   j k
n  g      j n  p      j  j k

   k  

   k  

 k   j k

   k    k  

generalised to 
n  gd     j

pd 
i  

ki

k     simplified using equivalence k i            k     k        k     k   
give following closed form definition   and k     n  gd     n  pd     j  
n  gd     j  k
 

n  pd     j

    k  

k  kd     k  

   
   

note equation n  pd   assumes sub goals achieved sequentially 
executed parallel number options higher  since need consider
possible interleavings sub goals execution  example  suppose plan pd
two sub goals  g d g d   sub goals n  gd   successful executions 
execution l steps  we assume ease analysis execution paths
length   number ways interleaving two parallel executions 
length l  calculated follows  naish        section    


   l  
 l
 
l
 l    l  
    tree assumed uniform  children achieved number
ways  thus interchangeable analysis  allowing us write j n rather n            nj  

  

fion testability bdi agent systems

hence number ways executing pd parallel execution subgoals is 
 

 

 



n  pd     n  gd  

 l
l



  n  gd   

   l  
 l    l  

remainder paper assume sub goals plan achieved
sequentially  since common case  since yields lower figure which 
shall see  still large enough allow conclusions drawn 
    adding failure
extend analysis include failure  determine number unsuccessful
executions  i e  executions result failure top level goal  moment
assume failure handing  we add failure handling section      
order determine number failed executions know failure
occur  bdi systems two places failure occurs  goal
applicable plan instances  action  within applicable plan instance  fails 
however  uniformity assumption means address former caseit
assumed goal always j instances applicable plans  note
conservative assumption  relaxing results number unsuccessful executions
even larger 
order model latter case need extend model plans encompass
actions  example  suppose plan body form a   ga  a   gb  a  ai
actions  ga gb sub goals    denotes sequential execution  plan
following five cases unsuccessful  i e  failed  executions 
   a  fails
   a  succeeds  ga fails
   a  ga succeed  a  fails
   a   ga  a  succeed  gb fails
   a   ga  a  gb succeed  a  fails
suppose ga executed successfully n  ga  different ways  third
case corresponds n  ga  different failed executions  successful execution ga 
extend adding failed execution a   actions executed one way 
i e  n  a      n  a        similarly  gb n  gb  successful executions fifth
case corresponds n  ga  n  gb  different failed executions  ga unsuccessfully
executed n  ga  different ways second case corresponds n  ga  different executions  similarly  fourth case corresponds n  ga  n  gb  different executions  putting
together  total number unsuccessful executions plan p
body a   ga  a   gb  a  sum five cases 
    n  ga    n  ga    n  ga  n  gb    n  ga  n  gb 
  

fiwinikoff   cranefield

formally  n  x    x      n  x      n  x    n  x     is  sequence fail either
x  fails  x  succeeds x  fails  follows n  xk     n  x k n  xk    
n  x         n  x k     easily proven induction 
generally  assume   actions before  after  sub goals
plan  i e  example plan corresponds        following plan body
corresponds        a   a   g   a   a   g   a   a   plan sub goals  i e  depth
   considered consist   actions  which quite conservative  particular 
use       assume plans depth   consist single action  
number unsuccessful execution traces goal plan tree defined 
based analysis above  follows  first calculate numbers successes
failures following repeated section plan body  gd   a   
n  gd   a      n  gd   n  a   
  n  gd   n  a  
  n  gd     
  n  gd  
n  gd   a      n  gd     n  gd   n  a   
  n  gd     n  gd   n  a         n  a     
  n  gd     n  gd    
    
n  pd     n  a     gd   a   k  
  n  a      n  a    n   gd   a   k  
  n  a         n  a         n  a   n   gd   a   k  
        n  gd   a           n  gd   a   k   
       n  gd     n  gd             n  gd  k    
n  gd  k  
       n  gd       n  gd     
 assuming n  gd       
n  gd    
yields following definitions number unsuccessful executions goalplan tree  without failure handling  equation n  gd   derived using
reasoning previous section  single plan selected executed  j
plans 
n  gd     j n  pd   
n  p       
n  gd  k  
n  gd    
 
 for     n  gd       

n  pd          n  gd       n  gd   

finally  note analysis number successful executions goal plan
tree absence failure handling presented section     unaffected addition
actions plan bodies  one way sequence actions
succeed  equations     remain correct 
  

fion testability bdi agent systems

    adding failure handling
consider introduction failure handling mechanism affects analysis 
common means dealing failure bdi systems respond failure
plan trying alternative applicable plan event triggered plan 
example  suppose goal g  e g  achieve goal go home  three applicable plans pa 
pb pc  pa selected  fails  failure handling mechanism
respond selecting pb pc executing it  assume pc selected  pc fails 
last remaining plan  pb  used  fails  goal deemed
failed 
result that  might hope  harder fail  way goal
execution fail applicable plans tried fails    
number executions computed follows  goal gd j applicable plan instances  n  pd    unsuccessful executions  n  pd   j
unsuccessful executions plans sequence  since plans selected
order multiply j  yielding n  gd     j  n  pd   j  
number ways plan fail still defined equation
failure handling happens level goalsbut n  g  refers new
definition 
j

n  gd     j  n  pd   

   

 

n  p       

   
 

 k

n  gd  
n  gd    
 
 for     n  gd       

n  pd          n  gd       n  gd   

   

turning number successful executions  i e  n  x   observe
effect adding failure handling convert failures successes  i e  execution
would otherwise unsuccessful extended longer execution may succeed 
consider simple case  depth   tree consisting goal g  e g  achieve goal go home 
three children  pa  pbandpc  previously successful executions corresponded
pi  i e  select pi execute it   however  failure handling 
following additional successful executions  as well additional cases corresponding
different orderings plans  e g  pb failing pa successfully executed  
pa fails  pb executed successfully
pa fails  pb executed fails  pc executed succeeds
leads definition form
n  g    n  pa    n  pa  n  pb    n  pa  n  pb  n  pc 
    fact  actually underestimate  possible goal fail none untried
relevant plans applicable resulting situation  noted earlier  assume analysis
goals cannot fail result applicable plan instances  conservative assumption 
relaxing results number behaviours even larger 

  

fiwinikoff   cranefield

however  need account different orderings plans  instance  case
first selected plan succeeds  corresponding first term  n  pa   fact applies
j plans  first term  including different orderings  j n  p  
similarly  second term  n  pa  n  pb    corresponding case initially
selected plan fails next plan selected succeeds  fact applies j initial plans 
j   next plans  yielding j  j    n  p  n  p  
continuing process  for j      yields following formulae 
 

n  g      n  p       n  p  n  p       n  p  n  p 
generalises
j 

n  g    j n  p    j  j    n  p  n  p      j  n  p 

n  p 

resulting following equations  again  since failure handling done goal level 
equation plans section      
 

n  gd    

j
x

i 

n  pd   

n  pd   

i  

n  p       
 

j 
 j i  

   
   

 

n  pd     n  gd  

k

 for      

   

used standard bdi failure handling mechanism trying alternative
applicable plans  let us briefly consider alternative failure handling mechanism
simply re posts event  without tracking plans already attempted 
fairly easy see this  fact  creates infinite number behaviours  suppose
goal g achieved pa pb  pa could selected  executed resulting
failure  pa could selected again  fail again  etc  suggests
standard bdi failure handling mechanism is  fact  appropriate  avoids
infinite behaviour space  possibility infinite loop  discussed earlier  in
section     failure recovery mechanism used  apl  apl  dastani        cannot
analysed general way  since depends details specific agent program 
irma  bratman et al         provide sufficient details allow analysis 
tables     make various equations developed far concrete showing illustrative values n  n  range reasonable  and fairly low  values j  k
using        number columns show number goals  plans actions tree  number actions brackets many actions executed
single  successful  execution failure handling  number goals calculated
follows  depth   single goal  see figure     depth n    
     j k g n   goals  g n  denotes number goals depth n tree 
gives g n         j k     j k        j k n    example  j   k     
g                       since goal exactly j plans  number plans tree
depth n j g n   consider number actions  non leaf plan
   k      actions  since k goals  k     places   actions  
leaf plan   actions  tree depth n j  j k n  leaf plans  let p  n 
number plans depth n tree  comprised pn  n  non leaf plans
  

fion testability bdi agent systems

parameters
j k

   
 
   
 
   
 
   
 

goals
  
  
   
   

number
plans
  
   
   
   


actions
       
        
        
        

n  g 
   
         

n  g 
   
         

                 

                 

              

              

table    illustrative values n  g  n  g  without failure handling  first number actions  e g      number actions tree  second
 e g      number actions single execution failures occur 

parameters
j k

   
 
   
 
   
 
   
 

goals
  
  
   
   

number
plans
  
   
   
   


actions
       
        
        
        

n  g 
         
          
          
          

n  g 
         
          
          
          

table    illustrative values n  g  n  g  failure handling
pl  n  leaf plans  i e  p  n    pn  n    pl  n   number actions depth n tree
    k       pn  n      pl  n   example  j   k           
p         g          comprised    leaf plans    non leaf plans 
therefore                        actions 
    recurrence relations
equations previous sections define functions n  n  mutual recurrence
depth goal plan tree uniform branching structure  effect
increasing parameters k   evident level recursion 
clear effect increasing number applicable plan instances j
given goal  aim section explore effects changing j 
relaxing uniformity assumption  specifically  allow number plans available
vary goal nodes different depths tree  still assuming nodes
given depth structure  refer semi uniform goal plan trees 
derive set recurrence relations n  n  presence failure handling
explicitly show effect adding new plan goal root particular
sub tree 
begin defining generalised notation n  gj   n  gj   j list  
 jd   jd            j    element ji represents number plans available goals
depth goal plan tree  denote empty list hi write j j represent
list head j tail j 
    order corresponds definition depth  decreases tree 

  

fiwinikoff   cranefield

generalise equations     apply semi uniform goal plan trees 
derivation equations depended sub nodes goal plan node
structure  assumption preserved generalised setting 
therefore rewrite equations using new notation  express right
hand sides functions f   f   n  pj    for f     n  pj    aim find recursive
definition f   f   recurrence j 
n  gjj     f    j  n  pj   
n  gjj     f    j  n  pj    n  pj   

f    j  a    j  aj
f    j  a  b   

j
x

b ai 

i  

j 
 j i  

 change bounds         n  hence replace     
 

j 
x

b a i    

i  

j 
 j  i       

 simplify using  j  i           j i    j i   
 

j 
x
i  

b ai

j  j i 
 j i  

 multiple i  i  reorder 
 

j 
x
i  

j 
i  ai  j i  b
i  j i  


j
 use definition binomial 
  j  i  j i   

j 
x
j
i  ai  j i  b
 


   

i  

expression right last line corresponds following combinatorial analysis f     goal gjj   successful execution involve sequence
plan executions thatfail  for i    j    followed one plan execution
succeeds  ji ways choosing failed plans  ordered i  ways 
plan   n  pj   ways fail  j ways choosing final
successful plan  b   n  pj   ways succeed 
goal find explicit characterisation incremental effect adding
extra plan n  gjj   n  gjj   finding definitions f   f   recurrence relations
terms parameter j  deriving recurrence relation f   straightforward 
f    j  a    j  aj    j  j               a
    a      j a    j    a           a     a 
    z
j times
  

fion testability bdi agent systems

n  gjj     f    j  n  pj    n  pj   
n  gjj     f    j  n  pj   
f       a  b     
f    j     a  b     j      b   f    j  a  b  

    

 

f     a     
 

f  j     a     j     f    j  a 
n  phi      
n  phi      
n  pj     n  gj  k   j    hi
n  gj  k  
  j    hi
n  pj         n  gj       n  gj  
n  gj    
figure    recurrence relations numbers failures successes goal plan tree
presence failure handling

shows f       a      f    j     a     j     f    j  a 
however  derivation recurrence relation f   simple  use
technique first finding exponential generating function  e g f    wilf       
sequence  f    j  a  b  
j     using derive recurrence relation  details
given appendix b  yield equation    figure   
equation     copied equation    appendix b  gives us recurrence relation
  
sequence  f    j  a  b  
j   seeking   figure   brings together
equations far failure handling case  including previous
section defining n  pd   n  pd    generalised semi uniform trees  
formulation gives us different way looking recurrence  allows us
easily see behaviour space grows number applicable plans  j 
goal grows  considering meaning parameters b numbers failures
successes  respectively  plan level current goal node  equation
f    j     a  b  seen following combinatorial interpretation  one plan
must selected try initially  there j    choices  either succeed  in one
b different ways   meaning plans need tried  fail  in one different
ways   fails  goal must succeed using remaining j plans 
occur f    j  a  b  ways 
see growth number successful executions goal grows
rate greater j aj   presence b term  relaxed uniformity
    simple case   b     listed sequence a       on line encyclopedia
integer sequences  sloane         number permutations nonempty subsets       n  

  

fiwinikoff   cranefield

constraint used recurrence relations gives us way investigate numbers
traces goal plan trees different semi uniform shapes  however  remainder
paper focus uniform trees using original parameter j  with exception
section      
    probability failing
section     said introducing failure handling makes harder fail  however 
tables     appear first glance contradict this  many ways
failing failure handling without failure handling 
key understanding apparent discrepancy consider probability
failing  tables     merely count number possible execution paths  without
considering likelihood particular path taken  working probability
failing  as below  shows although many ways failing  and
succeeding   probability failing is  indeed  much lower 
let us denote probability execution goal plan tree root x depth
failing p  xd    probability succeeding p  xd       p  xd   
assume probability action failing      probability
given plans actions succeeding simply     x x number actions 
hence probability plan failing failure  one of  actions simply
      x   i e  plan depth   probability failure is 
           
plan depth greater   probability failure due actions is 
           k   
 recall plan   actions before  after  between  k sub goals  
considering actions sub goals g            gk plan p 
plan succeed  sub goals must succeed  additionally  plans
actions must succeed giving p  pd          p  gd  k   easily derive
equation p  pd    given below   note reasoning applies plan regardless
whether failure handling  failure handling done goal level 
absence failure handling  goal g possible plans p            pj succeed
must select one plan execute it  probability success probability
plan succeeding  i e  p  gd     p  pd     ignore moment possibility
goal failing applicable plans  assumption relaxed later on 
formally  then  case without failure handling 
p  gd     p  pd   
p  p       
k

p  pd                p  gd     
    simplicity  assume failure action plan independent failure
actions plan 

  

fion testability bdi agent systems


    

    


 
 
 
 
 
 

failure handling
   
   
   
   
   
   

failure handling
     
     
     
      
      
      

table    goal failure probabilities without failure handling
consider happens failure handling added  case  order
goal fail  plans must fail  i e  p  gd     p  pd   j   since failure handling
goal level  equation plans unchanged  giving 
p  gd     p  pd   j
p  p       
k

p  pd                p  gd     
easy see equations patterns probabilities actually are 
so  illustration purposes  table   shows probability failure is 
without failure handling  two scenarios  values computed using j   k    
 i e  relatively small branching factor         consider two cases 
       hence        which rather high          hence
     
seen  without failure handling  failure magnified   larger goalplan tree is  actions involved  hence greater chance action
somewhere failing  leading failure top level goal  since failure
handling   hand  failure handling  probability failure low 
doesnt appear grow significantly goal plan tree grows 
relax assumption goal cannot fail applicable
plans  i e  goal fail plans tried  unfortunately  relaxing
assumption complicates analysis need consider possibility none
remaining plans applicable point failure handling attemped 
let us begin reconsidering case failure handling  use g
denote probability goal failing none remaining plans applicable 
case failure handling non zero g indicates situations
goal applicable plans  may indicate error part
programmer  certain situations goal may possible achieve 
assume  analysis purposes  probability constant  particular 
depend plans already tried number relevant
plans remaining 
probability goal failing p  gd     g      g   p  pd     i e  goal fails
either plans applicable applicable plans selected
plan fails  before  equation plans unchanged  since failure handling done
  

fiwinikoff   cranefield

goal level  following equations case without failure handling 
p  gd     g      g   p  pd   
p  p       
k

p  pd                p  gd     
observe setting g     yields equations derived earlier  assumed
goal cannot fail due inapplicable plans 
consider probability failure failure handling  goal two
plans following cases 
goal fail plans applicable  g  
applicable plans     g          goal fail first selected
plan fails  p  pd           failure handling successful  occur
either applicable plans  g   applicable plans     g         
selected plan fails  p  pd     
putting together  goal two plans have 
p  gd     g      g   p  pd     g      g   p  pd    
general case j available plans  goal fail if 
a  applicable plans outset  probability g  
b  applicable plans    g    selected plan fails  p  pd    
either applicable plans  g   
c  applicable plans    g    selected plan fails  p  pd    
either applicable plans  g   
d  on  reasoning b repeated j times 
gives definition following form 
g      g   p  pd     g      g   p  pd     g        g   
  z   
 z
  
 z
    z 
b
c


defined terms auxiliary function p  gd   i  defines probability
failure goal g depth remaining relevant plan instances may
 or may not  yield applicable plan instances 
p  gd     p  gd   j 
p  gd        g      g   p  pd   
p  gd          g      g   p  pd    p  gd   i 
p  p       
k

p  pd                p  gd     
  

fion testability bdi agent systems


    


    


 
 
 

 
 
 

failure handling
g    
g        g       
   
   
   
   
   
   
   
   
    
g     g         g       
  
  
   
   
   
   
   
   
   

failure handling
g    
g        g       
     
    
    
     
    
     
     
    
     
g     g         g       
      
    
    
      
    
    
      
    
    

table    goal failure probabilities without failure handling goals
applicable plans

observe setting g     reduces definition derived earlier  since g    g   x
simplifies x  hence p  gd   i    p  pd   i  
before  immediately clear formulae actual patterns
probability are  considering illustrative examples  table   shows  a  overall behaviour before   b  g assumed relatively low compared
probability action failure        doesnt significantly affect probabilities 
    analysis rate failures
section briefly examine number traces goal plan tree affected
placing bound rate action failures occur within trace  simplicity 
work uniform goal plan trees  construction extends trivially semiuniform goal plan trees 
figure   presented equations calculating total number behaviours
goal plan tree  with failure handling   many behaviours involve possibly
unrealistic number action failures  make assumption upper
limit rate action failures     i e  number failures divided length
trace  affect number possible behaviours  large numbers
seen reduce significantly 
instance  considering j   k                       possible executions
result failure  many involve high rate action failure many
involve small percentage failures  figure   contains  cumulative  counts
generated looking possible executions  small  case  plotted
number action failures  x axis shows given value n                many
traces n fewer action failures  instance  n         
traces   fewer action failures      traces      successful   
unsuccessful  figure   shows equivalent graph rate action failure  trace
failure rate computed  the number failures divided length trace  
    bounding rate action failures allows us model assumption environment limited
unpredictability  perhaps programmer limited incompetence 

  

fiwinikoff   cranefield

ok 

failed 

both 

     

number of traces  cumula ve  

     

     

     

     

     

    

  

  

  

  

  

  

  

  

ok 

  

   

    

    

    

     

     

failed 

  

  

   

    

     

     

     

both 

  

   

    

     

     

     

     

number of failures 

figure    number traces  cumulative  vs  number failures j   k                
    

    

number traces  cumulative 

    

    

    

    

   

 
   

   

   

   

   

   

   

   

   

 

failure rate

figure    number traces  cumulative  vs  failure rate j   k                

  

fion testability bdi agent systems

number traces counted range failure rate  instance  first
data point graph shows    traces failure rate     
question generalise analysis larger execution spaces  clearly 
counting possible executions feasible  instead  turn generating functions 
given plan body segment    and particularly   gd    interested
computing numbers successful failed traces failure rate bounded
given ratio r number failed actions total number actions 
i e  proportion actions execution trace fail  denote n r s 
n r s   compute values  first determine integers     n  
numbers successful failed traces length contain exactly n action
failures  denoted n r s  m  n  n r s  m  n   respectively  define length trace
number actions  both successful unsuccessful  contains  note
finite goal plan tree  uniform semi uniform one  maximum
possible trace length n r s  m  n  n r s  m  n  non zero finite
number integer pairs  m  n  positive quadrant plane positive
axis  in case n       values  calculate n r s 
n
r  similarly n rs using n r s  m  n  
sum n r s  m  n 
begin considering ordinary    bivariate generating functions  wilf       
values n r s  m  n  n r s  m  n  
 

fr  s  x  y   
fr  s  x  y   

x

x

n r s  m  n  xm n

m   n  
x

x

n r s  m  n  xm n

m   n  

action one successful execution  length   contains action
failures  fr  a  x  y    x  a power series coefficient x     
coefficients     similarly  fr  a  x  y    x      xy  one failed execution 
length   one action failure 
consider fr  s    s    
fr  s    s    x  y   
 

x

x

n r s    s    m  n  xm n

m   n  
x

x
m   n  

x

x


nr s    p  t  nr s    q  u  xm n
 

 

p q m t u n

double sum parentheses considers  trace  possible ways allocating
number actions number action failures n  necessarily  successful
executions s  s    sums non negative integer values p  q  u 
    recall that  defined towards start section    page      plan body segment sequence
x            xn xi either goal action 
    ordinary generating functions differ exponential generating functions including denominators
factorials powers variable s  

  

fiwinikoff   cranefield

have 
fr  s    s    x  y   
 


x
x
x x

n r s    p  t  xp n r s    q  u  xq u

m   p q m n   t u n
x
x
x

x

n r s    p  t  xp n r s    q  u  xq u

p   q   t   u  

x
x

x

x

 
p
 
q u
 
nr s    p  t  x
nr s    q  u  x
p   t  

q   u  

 

 

  fr  s    x  y  fr  s    x  y 
p
p p
p
second line derived using identity
q
p
m  
p q m f  p  q   
f  p  q   expressions sum non negative integers p q  first expression
first summing non negative values horizontal axis 
summing pairs  p  q  non negative integers lying line slope  
intersects horizontal axis m 
considering fr  s    s    x  y   have 
fr  s    s    x  y   
 

x

x

n r s    s    m  n  xm n

m   n  
x

x

n r s    m  n 

m   n  

 

 

x

x



nr s    p  t  nr s    q  u  xm n
 

 

p q m t u n


xx

n r s    m  n  xm n

m   n  
x

x

 

m   n  

x

x


nr s    p  t  nr s    q  u  xm n
 

 

p q m t u n

 

  fr  s    x  y 
x
x

x

x

 
n r s    p  t  xp
n r s    q  u  xq u
p   t  

q   u  

  fr  s    x  y    fr  s    x  y  fr  s    x  y 
second line based observation failed execution s    s 
length n action failures either failed execution s  length n
action failures occurring execution  successful execution s  length p
failures followed failed execution s  length q u failures 
p   q     u   n 
now  assuming know fr  gd   x  y  fr  gd   x  y  depth d 
construct functions fr  pd   x  y  fr  pd   x  y  applying results expand
right hand sides following equations  which simply replace pd plan body  
  

fion testability bdi agent systems

fr  pd   x  y    fr  a     gd   a   k   x  y 
fr  pd   x  y    fr  a     gd   a   k   x  y 

remains define fr  gd   x  y  fr  gd   x  y  terms fr  pd    x  y  fr  pd   
x  y   count successful executions gd length n action failures 
must first choose one j applicable plans one ultimately succeeds 
must choose   j  remaining applicable plans tried
failed  consider possible orderings plans  actions trace
n action failures must distributed across failed successful plans  leads
us following derivation procedure construct fr  gd   x  y  
fr  gd   x  y 
x

x
 
n r gd   m  n  xm n
m   n  

 

x

x


j

m   n  

  j

p  


j 
x
j  
p

p  

  j


j 
x
j  

p 

p

x

p 

x

n r pd         f   

p



x

x


m   n  

n r pd     i     xm n

i  

      p  m f    fp  n

x

x



n r pd         f   

p



n r pd     i     xm n

i  

      p  m f    fp  n

j 
x
p  

x
x
p
x

x

j  
 
  f
 
  f
p 
nr pd       f   x
nr pd       f   x
p
    f   

    f   


j 
x
j  
  j
p  fr  pd    x  y  fr  pd    x  y p
p
p  

constructing fr  gd   x  y  simpler  failed execution goal involves failed attempts
execute j applicable plans  j  orderings plans must considered 
gives us following construction fr  gd   x  y  
fr  gd   x  y   
 

x

x

n r gd   m  n  xm n

m   n  
x

x

x

j 

m   n  

  j 

x
x


x

      j  m f    fj  n
 

  f

nr pd       f   x

    f   

  j  fr  pd    x  y j
  

j



nr pd         f    nr pd     j   fj   xm n
 

 

fiwinikoff   cranefield

equations define recursive procedure computing fr  gd   x  y  fr  gd  
x  y  given values d  j  k    discussed earlier section  given way
n
calculating n r s  m  n   calculate n r s  sum n r s  m  n 
r 
 
similarly nrs  used python rmpoly gmpy  libraries generate
polynomial representations functions fr  gd   x  y  fr  gd   x  y  specified
values d  j  k l  calculate n r s  n r s  various ratios r     figure  
shows results   j   k           
examining figure   conclude two things  one hand  number traces
really explodes larger rates action failures  example  figure   traces
failure rate greater      hand  although making assumptions
failure rate reduce number possible traces  number traces still quite
large  note scale y axis   instance  failure rate     around
         failed executions          successful executions  failure rate    
respective numbers                     failure rate    
                   
shape figure   explained follows  firstly  occurrence action
failure triggers activity  alternative plans   failures result longer traces 
secondly  longer traces shorter traces  simply
longer trace  possibilities variations  e g  different orders trying
plans   explains increase figure   starts slowly accelerates 
get failures  longer traces  longer traces
them  word  plot non cumulative number paths
ratio action failures would see initial increase  ratio grows 
paths  doesnt explain beyond certain point get fewer traces 
cumulative graph levels out  explanation quite simple  beyond certain
ratio  which appears around      successful traces  number
failed traces declines 
    recursive trees
section     developed recurrence relations allowed us relax assumption
goal plan trees uniform  considered semi uniform trees  section
relax assumption goal plan trees finite  allow trees
shape  considering arbitrary trees allowed contain labels
refer parts tree  i e  allow trees recursive  derive generating
functions  seen extension derived previous section 
number paths  both successful unsuccessful  executing recursive goalplan trees  obviously  infinite tree infinite number paths  define
generating functions take parameter bound lengths paths counted 

    finite number actions attempted execution goal plan tree 
bounds length possible traces number action failures occur within them 
thus fr  gd   x  y  fr  gd   x  y  polynomials finite orderonly finite number coefficients
non zero infinite sums define them 

   

fion testability bdi agent systems

failed executions  cumulative 

successful executions  cumulative 

 cumulative 

 e    

   e    

number traces  cumulative 

 e    

   e    

 e    

   e    

 e    

 e    

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

 

failure rate

figure    number traces  cumulative  vs  failure rate j   k            
given upper bound path length equations specify number paths
many actions    
begin defining notation representing recursive trees  goals  plan body
multisets  plans  variables bindings  goal represented term form
goal plan body multiset  plan body multiset multiset representing different
applicable plan instances used satisfy goal  multiset
combinatorial analysis  structure plans significant  therefore
use single abstract action represent actions     goal may achievable
using multiple plan instances structure  must treat
distinct  need represent bodies plan instances  element
multiset  i e  plan  sequence terms separated right associative sequential
composition operator    term sequence either abstract action term a 
goal term defined  representing sub goal   label  see below   formally 
plan body multiset p multiset plans  written  p   c            pj  cj  
ci number times associated plan pi appears multiset 
define following multiset operations  set p   set pi multiset p  
p  pi   characteristic function denoting number times plan pi appears
multiset  i e  ci    p m  p m  multiset subtraction  defined p m  p m   x   
max p m   x  p m   x       finally  p   size multiset  i e  sum ci  

    use equations derived section non recursive trees  case allow
    define     f power x    f  
    however  avoid confusion  use numeric subscripts  a    a           distinguish different occurrences actions 

   

fiwinikoff   cranefield

order allow recursive trees represented  possible step plan
label  denoted       referring term provided binding  simply
mapping labels terms  either goal plan terms   b binding write
b   denote item mapped b  entry b 
example  consider simple tree below  consisting goal two plans  together
binding maps variable root tree  first plan  on left 
two steps  action  a     recursive reference root tree    
second plan  on right  single action  a    
  goal
plan

plan
a 



a 

recursive tree represented follows  define binding b      
goal   a         a        maps whole tree  tree  
proceed defining generating functions  introduce auxiliary notation  p power series use standard notation  xp   xpnn  p denote
coefficient term xp   xpnn series  define p cond denote power
xn

series containing terms p satisfy condition cond  define f g
 f g  power x n   i e  f g terms power x greater n removed 
n
define f mx  f  m power x n   i e   f  m terms power x greater
n removed   
position derive generating functions specify number
paths arbitrary  possible recursive  goal plan tree  given bound
path length  define bdi program represented term  i e  goal  plan 
plan multiset  action  label   b binding mapping labels terms  as defined
above   define n  s  m  n  b  number successful paths  respect
binding b  actions  n failed actions  similarly define
n  s  m  n  b  number failed paths  respect b  actions 
n failed actions  want derive recurrence relations generating
functions    
 
f
 s  x  y  b     

 
f
 s  x  y  b     

x

x
m   n  
x

x

n  s  m  n  b xm n
n  s  m  n  b xm n

m   n  

upper bound number actions path 
    this  previous operation  directly supported rmpoly python library multivariate
polynomials series  used compute generating functions 
    subscript used distinguish generating functions  allow recursive tree 
generating functions defined elsewhere paper 

   

fion testability bdi agent systems

order simplify presentation  details complex derivations
given appendix c  resulting equations shown figure     first two
equations  equations       figure      applicable term t  capture
assumption      and remaining equations apply       next
two equations simply specify labels looked provided binding  equation   
indicates single successful path action a  single
action unsuccessful actions  i e  generating function  x       equation   
similarly indicates single unsuccessful path single action a  which 
unsurprisingly  single unsuccessful action  so generating function  x      
equations       deal sequences  sequence s    s  succeed s 
s  must succeed  count paths concatenating sub paths  corresponds
multiplying power series  sequence s    s  fail either s  fails  s  succeeds
s  fails  alternatives correspond addition power series   equations
special case  s  action  divide overall path length limit
precisely  s  must trace length    since action  s  must therefore
maximum length   
dealt labels     single actions  sequences  next turn goals  equations         cases derivation complex  covered appendix c 
 
f
 equation    appendix c     intuition successful path
goals execution involves single successful plan p  number failed executions
plan selected remaining multiset plans  p  p      case plan
appears multiset  select occurrences  hence
multiplication p  p   number failed paths goal  equation   
appendix c    introduce auxiliary generating function g  p m  x  y  z  b    
p multiset plans  z variable whose power z indicates exact number plans p used  words  given power series denoted
g  p m  x  y  z  b     term cmno xm n z  o  indicates cmno paths involve actions  n failed  exactly plans p   generating
 
function g  technical device allows us derive definition f
need 
 
given power series  definition f simply selects terms  p  
power z  since plans must fail goal fail  using removes
z  p   terms dividing  g  exponential generating function z 
means includes division factorial  need multiply factorial  p   
remove it 
 
equation    defines f
 p m  x  y  b     used equation     terms
 
auxiliary function g  derivation given appendix c    intuition
possible number plans could used  o  limit power series g 
value o  remove z dividing  o  due g  exponential
generating function z  see appendix c  

finally  equations       give definition g  p m  x  y  z  b     see appendix c  
derivation   intuitively  equation    creates power series plan type 
x

combines  using    equation    little complex  single way
failing  when plans used  corresponding term x    z         otherwise
select c plans  plans must fail  corresponding term
   

fiwinikoff   cranefield

 
f
 t  x  y  b         

    

 

f t  x  y  b         

    

 

 

    

 

 

    

f   x  y  b      f b    x  y  b   
f   x  y  b      f b    x  y  b   
 

    

 

    

f a  x  y  b      x
f a  x  y  b      xy
 

f s    s    x  y  b   
 
 
 
f
 s    x  y  b     f
 s    x  y  b     s  action
 
x
 
 
f s    x  y  b    f
 s    x  y  b    otherwise
 
f
 s    s    x  y  b   
 
 
 
 
 s    x  y  b     f
 s    x  y  b     f
 s    x  y  b     s  action
f
 
x
 
 
 
f
 s    x  y  b    f
 s    x  y  b    f
 s    x  y  b    otherwise
 
f
 goal p    x  y  b   
x
x
 
 
 
p  p f
 p  x  y  b    f
 p  p     x  y  b   

    

    

    

pset p  
 
f
 goal p    x  y  b       p   

 p  
 
f
 p m  x  y  b     

x
o  

o 

g  p m  x  y  z  b    power z   p  
z  p  
g  p m  x  y  z  b    power z  o
zo

    
    

g   p   c            pj  cj    x  y  z  b   
x

x

g   p   c     x  y  z  b    g   pj  cj    x  y  z  b   

 

c
x
c
g  p c   x  y  z  b         
f    p  x  y  b   ox z

 

    

    

o  

figure     equations recursive goal plan trees
 
f
 p  x  y  b      giving number failed traces across plans as 
x

x

 
 
 
f
 p  x  y  b   ox   f
 p  x  y  b    f
 p  x  y  b   
 
 z
 

times

used python rmpoly gmpy  libraries generate polynomial repre 
 
sentations functions f
 t  x  y  b    f
 t  x  y  b     as defined figure    
specified values t  b    defined simple tree  the one given earlier
section example  computed number paths different values  
   

fion testability bdi agent systems

values chosen correspond values table    which
values n  g  n  g  come from      table    values        correspond
longest path  argue comparing recursive tree uniform tree 
consider path length limit  results shown table   

  
   

n  g 
         
          

n  g 
         
          

n  s 
        
        

n  s 
       
        

table    comparing n  n   respectively n  n   
looking numbers table    worth noting recursive tree
used extremely simple  two plans  single action  low number
actions  and sparseness tree  account relatively low number unsuccessful
paths  instance  modify tree adding extra actions  giving tree
binding below       around          successful paths          
unsuccessful paths  unfortunately  python unable calculate n  n  tree
       manage                  successful paths 
         unsuccessful paths  shows  expected  number unsuccessful
paths higher complex tree  fewer successful paths
complex tree explained observing that  tree  traces longer  more
actions need done   traces excluded bound trace
length  
  goal
plan

plan
a 

a 



a 

a 

overall  analysis section  application          confirms
number paths recursive tree depends trees structure  which
unsurprising   indicates even simple recursive tree  number
paths given upper bound path length quickly becomes extremely large 

   reality check
previous section analysed abstract model bdi execution order determine
size behaviour space  analysis yielded information size
behaviour space affected various factors  probability goal
failing 
section consider two issues whether analysis faithful  whether
applicable real systems  analysis made number simplifying assumptions 
    correspond first two rows table  respectively involve        actions 

   

fiwinikoff   cranefield

mean results may faithful semantics real bdi platform 
may apply real systems  thus conduct two reality checks assess
whether analysis faithful  section      whether applicable  section      
firstly assess whether analysis faithful real bdi platforms  i e 
omit significant features  contain errors  comparing abstract
bdi execution model results real bdi platform  namely jack  busetta et al  
       comparison allows us assess extent analysis abstract bdi
execution model matches execution takes place real  industrial strength  bdi
platform  comparison is  essence  basic reality check  simply checking
analysis previous section indeed match execution semantics typical
bdi platform  modelling artificial goal plan tree bdi platform 
next  order assess extent analysis results apply real systems 
analyse goal plan tree real industrial application  analysis allows us
determine extent conclusions analysis uniform  and semi uniform 
goal plan trees applies real applications  goal plan trees likely
uniform  words  extent large numbers tables     apply
real applications 
    real platform
order compare real bdi platforms execution results abstract bdi
execution model implemented two goal plan trees appendix jack agent
programming language     structure plans events   precisely mirrors
structure tree  goal plan tree  event two relevant plans 
always applicable  selectable either order  actions implemented
using code printed action name  then  depending condition  described
below   either continued execution triggered failure  and printed failure indicator  
system out print  a       action  a 
  n i           
system out print  x   
false     trigger failure
 
conditions determined whether action failed succeeded  plan
selected first  controlled input  n i  java class variable   test harness
systematically generated inputs  thus forcing decision options explored 
results matched computed prolog code figure    giving precisely
six traces smaller tree      traces larger tree 
indicates abstract bdi execution model indeed accurate description
takes place real bdi platform  specifically jack  
note selected jack two reasons  one modern  well known 
industry strength bdi platform  other  important  reason  jack descendent line bdi platforms going back prs  thus good representative
    code available upon request authors 
    jack models goal bdigoalevent 

   

fion testability bdi agent systems

parameters
number
j k

goals
actions
   
 
  
       
   
 
           
workflow    goals   
    paper says    goals 
figure       goals 

failure handling
 secs         
n  g 
n  g 
   
   
                   
                 
                 
       
       

failure handling
 section     
n  g 
n  g 
         
         
   
       
          
         
         
  
       
         
         
         

table    illustrative values n  g  n  g   bottom part       first row       
second        last row 

larger family bdi platforms  words  showing bdi execution model
analysed matches jacks model  able argue matches execution
jacks predecessors  including prs dmars   close relatives  e g  um prs
jam  
    real application
consider extent real systems deep branching goal plan trees 
extent large numbers shown tables     apply real applications 
rather uniform goal plan trees  example real application consider
industrial application daimler used bdi agents realise agile business processes
 burmeister  arnold  copaciu    rimassa         note finding suitable application
somewhat challenging  need application real  not toy system   however 
order able analyse it  application bdi based  furthermore 
details applications goal plan tree need available  unfortunately  many
reported bdi based industrial applications provide sufficient details
internals allow analysis carried out 
figure    shows   goal plan tree work burmeister et al        
   achieve goals   levels     maintain goals     plans     context
variables  burmeister et al         p       unlike typical goal plan trees used bdi
platforms  tree figure    consists layers and refined goals 
refinements leaves  where plans are   terms analysis presented
paper treat link goal g set goals  say  g    g    g 
equivalent goal g single plan p performs g    g    g   and actions 
i e        non leaf plans  
last row table   gives various n values goal plan tree         top
row          middle row         bottom row   note figures actually
lower bounds assumed plans depth   simple linear combinations
  actions  whereas clear burmeister et al         plans fact
    details meant legible  structure matters 

   

fiwinikoff   cranefield

model
ls ab
differe
model
keep th

figuretree  from
goal
acm
prototype
figure     goal plan
thehierarchy
work burmeister
et al        
figure     reproduced
permission ifaamas 

advantage modeling approach implicitly offers
support parallel execution process parts
depend other  reduce overall time needed
complicated  contain nested decision making  e g   see burmeister et al        
process
execution  moreover maintain goals good means
figure    
provide
process


agent
monitors
roughthe
indication
size
aadditional
goal plan tree isagility 
number
goals 

   goals 
tree figure
sizeto


firstthroughout
two rows table
comparing e g 

conditions
that  
fulfilled
the   process
number possible behaviours uniform goal plan trees real  and nontime
constraints 

pro actively
activities
avoid
uniform 
goal plan tree 
see
behaviour initiates
space somewhat
smaller

real
tree  thatbefore
stillthey
quite appear 
large  especially case failure handling  however 
problems
note following points 

development prototype support rapid
   tree figure    plans leaves  reduces complexity 
prototyping
execution process models provided
words goal plan tree typical plans alternating
goals would

larger number
possible
behaviours 
ls abpm

proven
ofvery
helpful 
developed models
represent
living process models  directly executed
   figures tree conservative estimate  since assume leaf plans
visualized 

part ofin
interface
thatcalculated
coupled
simple
behaviour 
otherweb
words user
number
paths

theis
actual
number directly
paths thefrom
real application 
under estimate
workflow
generated
process model 

interface computed directly parameters
   comparison procedural programs
corresponding task  context variables  types possible
order argue bdi programs harder test non agent programs  need
values 

approach
ofprocess
programs 
quickly
comparison 
specifically 
need changes
analyze number
paths non agent
compareand
tested 
agent
programs 
us address
concern
modeled
thus
errorsthis

theallow
models
bethediscovered
paths criterion test suite adequacy always requires infeasibly large number

corrected
briefly
short
tests 
section
doestime 
this  analyzing number paths procedural
program 

stated starting point building acm prototype
model acm reference    
process model developed
software demonstrator  underlying agent engine
demonstrator  jadex  partially different modeling
execution semantics compared ls abpm tool 


model
prototy

compl
depend
challen

execut
depend
proces

based
con

contex
manip
model
plans 

compl
possib
variab
variab
one
proces
variab
startin
goals 
create
h
model

fion testability bdi agent systems

number actions   statements
  
   
   
   

n m 
             
         
         
         

n  g 
         
          
          
          

n  g 
         
          
          
          

table    comparison values n m   n  g  n  g  
define program composed primitive statements s  sequences statements p    p    conditionals select two sub programs  since capture
conditions statements  elide condition  write conditional p    p  indicating one pi selected  note that  bdi analysis  exclude loops 
define number paths program p n p    straightforward   see
definition n p   is 
n s     
n p    p      n p    n p   
n p    p      n p      n p   
order compare bdi programs  consider size program 
compare programs size  key question is  procedural program
nodes significantly fewer paths bdi program size  define
size program p number primitive statements contains  denote
 p    note means count internal nodes syntax tree
 i e        therefore  comparing bdi programs  consider size
bdi program number actions    
work number paths varies size program p  
size program  and therefore natural number   define n m  max n p    
 p     m   is  n m  largest number paths possible program size m 
appendix contains derivation n m   resulting following definition  where
  multiple    
n   
n   
n   
n m     

 
 
 
 

 
 
 
 
 

 m  

n   
n   
n m 
n m     

 
 
 
 

 
 
 m  
   m  

table   shows comparison values n m  n  g  n  g   same sized
programs  based table    worth emphasising n m  highest possible value 
defined maximum possible programs  however  maximal program
highly atypical  example  considering programs seven statements 
    path p    p  simply concatenates path p  path p    hence product  path
p    p  either path p  path p    hence addition 
    using total number nodes tree yields almost identical results 

   

fiwinikoff   cranefield

total       possible programs       programs        paths  the
maximum   figure    shows number paths       many programs
many paths  maximum    clearly typical  indeed  mean number paths
seven statement program        median    consider programs
  statements          programs     maximal
number paths  which      average number paths across programs
     
overall  looking table    conclude number paths bdi programs
much larger even  atypical  maximal number paths procedural program
size  supports conclusion bdi programs harder test
procedural programs 
     

number of programs 

     

     

     

    

  
  

  

  

  
  
  
  
  
  
number of paths in a procedural program 

   

   

   

figure     profile number paths   statement programs

   conclusion
summarise  analysis found space possible behaviours bdi agents is 
indeed  large  absolute sense  relative sense  compared procedural
programs size  
expected  number possible behaviours grows trees depth  d  breadth
 j k  grow  however  somewhat surprisingly  introduction failure handling makes
significant difference number behaviours  instance  uniform goalplan tree depth   j   k      adding failure handling took number successful
behaviours                       
consider negative consequences analysis  worth highlighting
one positive consequence  analysis provides quantitative support long held belief
   

fion testability bdi agent systems

bdi agents allow definition highly flexible robust agents  flexibility
defined number possible behaviours agent  shown large 
robustness defined ability agent recover failure  analysis
section     showed bdi failure recovery mechanism effective achieving low
rate actual failure         even action reasonable chance failing      
analysis paper tell us testability bdi agent systems 
answer question  need consider tested  testing
typically carried levels individual components  unit testing   collections
components  integration testing   system whole 
consider testing whole system  behaviour space sizes depicted tables     
  suggest quite strongly attempting obtain assurance systems correctness
testing system whole feasible  reason  as discussed
section       adequate test suite  using paths criterion adequacy  requires
least many tests paths program tested  program has  say 
     paths  even test suite tens thousands tests inadequate 
hugely inadequate  since covers tiny fraction percent number
paths 
fact  situation even worse consider number possible
executions probability failing  space unsuccessful executions particularly hard test  since many unsuccessful executions  more successful ones  
probability unsuccessful execution low  making part behaviour
space hard reach  furthermore  shown section      although making assumptions
possible numbers action failures occur given execution reduces
number possible behaviours  still many many behaviours  even relatively
small trees  e g  j   k        
system testing bdi agents seems impractical  unit testing
integration testing  unfortunately  always clear apply usefully
agent systems interesting behaviour complex possibly emergent 
example  given ant colony optimisation system  dorigo   stutzle         testing single
ant doesnt provide much useful information correct functioning whole
system  similarly  bdi agents  testing sub goal difficult ensure
testing covers situations goal may attempted  consequently 
difficult draw conclusions correctness goal results testing
sub goals 
need acknowledge analysis somewhat pessimistic  real bdi systems
necessarily deep heavily branching goal plan trees  indeed  tree
real application described section   smaller behaviour space abstract
goal plan trees analysed section    however  even though smaller  still quite large 
cause problems validation 

one big challenges test phase keep model consistent
define right context conditions result correct execution
scenarios  therefore support dependency analysis  automated
   

fiwinikoff   cranefield

simulation testing process models needed  burmeister et al        
p         
leave us respect testing agent systems  conclusion
seems testing whole bdi system feasible  number possible
approaches dealing issue testability could recommended 
keep bdi goal plan trees shallow sparse  keeps number behaviours small  issue approach lose benefits bdi
approach  reasonably large number behaviours desirable provides
flexibility robustness 
avoid failure handling  since failure handling large contributor behaviour space  could modify agent languages disable failure handling  again 
useful approach disabling failure handling removes benefits
approach  specifically ability recover failures 
make testing sophisticated  could testing coverage perhaps improved
incorporating additional information domain knowledge  detailed
model environment  which indicates possible failure modes probabilities   answer known  potentially interesting area
work  however  large number paths encourage much optimism
approach 
another  related  direction see whether patterns exist behaviour space 
since failure recovery mechanism certain structure  may
results behaviour space large  but  sense  structured 
structure exists  may useful making agents testable  however 
point time  research direction may may turn fruitful 
viable testing strategy 
finally  related direction try intelligent selection
test cases  order gain coverage given number test cases  one
approach this  recently described  evolutionary testing
 nguyen  miles  perini  tonella  harman    luck      a   genetic evolution
used find good  i e  challenging  test cases 
supplement testing alternative means assurance  since testing
able cover large behaviour space  consider forms assurance 
promising candidate form formal method     unfortunately  formal
methods techniques yet applicable industry sized agent systems  we return
below  section      
    burmeister et al  made following observation  approach changes process
quickly modeled tested  thus errors models discovered corrected short time 
discussing advantages executable models  arguing able execute
model allowed testing  useful detecting errors model  able execute
model undoubtedly useful  evidence given  nor specific claim made  testing
sufficient assuring correctness agent system 
    see volume edited dastani et al         recent overview current state of the art 
including chapter role formal methods assurance agents  winikoff        

   

fion testability bdi agent systems

proceed caution  accept bdi agent systems general robust  due
failure handling mechanisms   is  present  practical way
assuring behave appropriately possible situations  worth
noting humans similar respect  whilst train  examine
certify human certain role  e g  pilot surgeon   way assuring
he she behave appropriately situations  consequently  situations
incorrect behaviour may dire consequences  surrounding system needs
safety precautions built  e g  process double checks information 
backup system co pilot  
    future work
room extending analysis section    firstly  analysis single
goal within single agent  multiple agents collaborating achieve single highlevel goal viewed shared goal plan tree certain goals and or plans
allocated certain agents  course  distributed goal plan tree
concurrency  concurrency introduced  would useful consider whether
certain interleavings concurrent goals fact equivalent  furthermore 
considered achievement goals  would interesting consider types goals  van
riemsdijk  dastani    winikoff         secondly  analysis focused bdi agents 
one particular type agent  would interesting consider sorts
agent systems  and  broadly  sorts adaptive systems 
another extension analysis consider criteria test suite adequacy 
paper used paths criterion  arguing appropriate 
recognize paths actually quite strong criterionit subsumes many
criteria  zhu et al         figure     alternative criterion could consider
edges  known branch coverage decision coverage  requires
choice program  statement  tests test suite
exercise options  i e  edges program graph covered  edges
criterion weaker paths regarded generally accepted minimum
 jorgensen        
another area refinement analysis make less abstract  two specific areas
could made detailed resources environment  analysis
consider resources environment directly  instead  considers actions may
fail range reasons might include resource issues  environmental issues 
analysis could extended explicitly consider resources interaction goals
 thangarajah  winikoff  padgham    fischer         could extended
explicit model environment 
whilst analysis consider real application  would desirable consider
range applications  could provide additional evidence analysis unduly
pessimistic  would lead understanding variance goal plan trees
characteristics across applications  key challenge finding suitable applications
bdi based  sufficiently complex  ideally real applications   detailed design
information available  and preferably source code   another challenge methodology 
analysed shape goal plan tree daimler workflow application 
   

fiwinikoff   cranefield

access run system  alternative methodology  requires access
implemented system probably source code  run it  force generate
traces sub goals    which would require modification either source code
underlying agent platform   collected data shape real world
industrial applications  able analyse whether uniform semi uniform goalplan trees good models types system  whether seek ways
relax uniformity assumption 
importantly  highlighted difficulties assuring bdi agent systems
testing  need find ways assuring systems 
approach promise automatic generation test cases agent
systems  nguyen  perini    tonella        zhang  thangarajah    padgham         however  size behaviour space suggests number test cases needed may
large  testing failed plan execution difficult  one interesting 
potentially promising  avenue use formal techniques help guide test generation
process  e g  symbolic execution specification guided testing   dwyer  hatcliff  pasareanu  robby    visser        
another approach   attracted interest model checking agent systems
 wooldridge  fisher  huget    parsons        bordini  fisher  pardavila    wooldridge 
      raimondi   lomuscio         work promising model checking techniques use range abstractions cover large search space without deal
individual cases one at a time  burch  clarke  mcmillan  dill    hwang        fix 
grumberg  heyman  heyman    schuster         furthermore  verifying subgoal considers possibilities  possible combine verification different sub goals 
however  work needed  raimondi lomuscio        verify systems agents
defined abstractly  i e  terms plans goals  mable agent programming
language  wooldridge et al         actually imperative language augmented certain agent features  bdi language  work bordini et al        
include failure handling  general  state art model checking agent system
implementations still limited quite small systems  dennis  fisher  webster    bordini 
      
acknowledgements
would thank members department information science university
otago discussions relating paper  would thank lin padgham
comments draft paper  finally  would thank anonymous
reviewers insightful comments helped improve paper 
work paper done winikoff sabbatical rmit  visiting
university otago 

    generating traces top level goal likely feasible 
    work deductive verification   based research verification
concurrent systems  appears less likely result verification tools  relatively 
easy use applicable real systems 

   

fion testability bdi agent systems

appendix a  example goal plan trees expansions
suppose following two trees  sample  left  sample   right   trees
correspond j      k              sample     sample  
goal
plan


goal

plan

goal

b c

goal



plan

plan

plan

plan

plan

plan



b

e

f

g

h

trees expanded respectively following sequences actions 
letter indicates execution action    indicates failure     predicted
formulae  four successful executions two unsuccessful executions
first tree 

b

a b
b a

a b 
b a 

second tree  expansions following     possibilities  consisting   
successful    unsuccessful traces  





















e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e
e

b
b cgd
b cgd 
b cg hd
b cg hd 
b cg h 
b chd
b chd 
b ch gd
b ch gd 
b ch g 
b c 
 fb
 fb cgd
 fb cgd 
 fb cg hd
 fb cg hd 
 fb cg h 
 fb chd
 fb chd 






















f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f
f

b chd
b chd 
b ch gd
b ch gd 
b ch g 
b c 
 eb
 eb cgd
 eb cgd 
 eb cg hd
 eb cg hd 
 eb cg h 
 eb chd
 eb chd 
 eb ch gd
 eb ch gd 
 eb ch g 
 eb c 
 e cgd
 e cgd 

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g
g

d 
d 
d 
d 
d 
d 
d 
d 
d 
d 
d 
 h
 h
 h
 h
 h
 h
 h
 h
 h

aeb
aeb 
ae fb
ae fb 
ae f 
afb
afb 
af eb
af eb 
af e 
a 

d aeb
d aeb 
d ae fb
d ae fb 
d ae f 
d afb
d afb 
d af eb

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h

d afb 
d af eb
d af eb 
d af e 
d a 
 gd
 gd aeb
 gd aeb 
 gd ae fb
 gd ae fb 
 gd ae f 
 gd afb
 gd afb 
 gd af eb
 gd af eb 
 gd af e 
 gd a 
 g aeb
 g aeb 
 g ae fb

    note failure marker isnt counted considering length trace section     

   

fiwinikoff   cranefield























e fb ch gd
e fb ch gd 
e fb ch g 
e fb c 
e f cgd
e f cgd 
e f cg hd
e f cg hd 
e f cg h 
e f chd
e f chd 
e f ch gd
e f ch gd 
e f ch g 
e f c 
fb
fb cgd
fb cgd 
fb cg hd
fb cg hd 
fb cg h 

af e cg hd
af e cg hd 
af e cg h 
af e chd
af e chd 
af e ch gd
af e ch gd 
af e ch g 
af e c 
a cgd
a cgd 
a cg hd
a cg hd 
a cg h 
a chd
a chd 
a ch gd
a ch gd 
a ch g 
a c 
cgd

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

g hd af eb 
g hd af e 
g hd a 
g h aeb
g h aeb 
g h ae fb
g h ae fb 
g h ae f 
g h afb
g h afb 
g h af eb
g h af eb 
g h af e 
g h a 
hd
hd aeb
hd aeb 
hd ae fb
hd ae fb 
hd ae f 
hd afb

c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c
c

h g ae fb 
h g ae f 
h g afb
h g afb 
h g af eb
h g af eb 
h g af e 
h g a 
 aeb
 aeb 
 ae fb
 ae fb 
 ae f 
 afb
 afb 
 af eb
 af eb 
 af e 
 a 

appendix b  analysis recurrence relations
appendix contains details derivation section     
exponential generating function f  x  sequence  f    j  a  b  
j   function
defined following power series 
f  x   


x

f    j  a  b 

j  

xj
j 

    

 by definition f    
 
 
j 



j
x
x
x
x
x
xj
j
j
 
i ai  j i b
 
i ai  j i b

j 

j 
j  

i  

j  

i  

right hand side
changed upper limit inner sum based
j
generalised definition j j    j           j      i   valid

complex numbers j non zero integers  wilf        gives ji       j 
right hand side form product exponential generating functions  wilf 
      rule      section      



 




j
j
x
x
x
x
x
x
j
xj

 j 
 j   
 i  j i 
j 
j 

j 
j  

j  

j  

i  

where  case   j    j  aj  j    j b  therefore  write 





j
j
x
x
 ax 
x
f  x   
j 
jb
j 
j 
j  

j  

   

fion testability bdi agent systems

p
 
left hand sum g ax  g y    n n    y
 wilf        equation           

p
n
x
x

 
right hand sum equal bx dx
n   wilf        rule     section        bx dx e
x
 wilf        equation          bxe   thus have 
f  x   

 
bxex
bxex  
  ax
  ax

p
xj
 
therefore  f       a  b  constant term power series
j   f  j  a  b  j   
f          find recurrence relation defining f    j      a  b  equate original
definition f  x  equation    closed form function  differentiate
side  to give us power series f    j  a  b  values shifted one position left  
multiply denominator closed form  giving us following derivation 





x  

bxex
xj
   ax 
     ax 
f  j  a  b 
dx
j 
dx   ax
j  



x
xj 
b x   ex
abxex
 
     ax 
f  j  a  b j
     ax 
 
j 
  ax
   ax  
j  

 


x
j  



bxex
xj  x  
xj

  b x   ex  
f  j  a  b j
af  j  a  b j
j 
j 
  ax
 

j  

 

 recall f     a  b      


x
x
xj
xj
 
 
f  j     a  b  j    

ajf    j  a  b 
 j     
j 
j  

j  

  bxex   bex  


x

f    j  a  b 

j  

 recall

bxex

 

j  

equating coefficients

xj
j 

xj
j   jb j   

j
x

ex  

j  

j  

p


x
xj
 b
j  b
j 

xj
j 
xj
j   j   

p



x
xj
x
 a
f    j  a  b 
j 
j 

get 

f    j     a  b  ajf    j  a  b    bj   b   af    j  a  b 
  f    j     a  b    b j       af    j  a  b    ajf    j  a  b 
   j     b   af    j  a  b  

    

    note many operations performed generating functions  and used paper 
valid without concern convergence series  combinatorics  generating functions often
treated analytic functions evaluated specific variable values  rather formal  possibly
infinite  algebraic objects  well defined operations addition multiplication 
set formal power series finite set variables structure ring abstract algebra 
ring notion function convergence evaluation  wilf        ch     

   

fiwinikoff   cranefield

appendix c  analysis recursive goal plan trees
appendix contains detailed derivations relating section     
 
c   derivation f
 goal p    x  y  b   
 
define f
 goal p    x  y  b    terms n  usual way  noting upper
bound realise length bound 

 
f
 goal p    x  y  b     

x

x

n  goal p    m  n  b xm n

m   n  
 

n goal p    m  n  b  defined section      make use nonbounded version  which four arguments  
 
f
 goal p    x  y  b   

x

x

n  goal p    m  n  b xm n

m   n  
 

define n counting successful traces 
n  goal p    m  n  b 
x
 
p  p 

x

n  p  m    n    b  n  p  p     m    n    b 

m   m   m
n   n   n

pset p  

n  p m  m  n  b  number unsuccessful paths using zero plans
plan multiset p  with respect binding b  actions  n
failed actions 
inner sum considers ways partition numbers actions  m  action
failures  n  caused single plan shape p p
p
caused


plans 


section
   
 page
   

use

identity
m  
p q m f  p  q   
p p
p  
q   f  p  q  rewrite 
 
f
 goal p    x  y  b 
x

x
x
x
 
p  p 
n  p  m    n    b  n  p  p     m    n    b xm n

m   m   m
n   n   n

m   n   pset p  

x

 

p  p 

pset p  

x

x

x

n  p  m    n    b  n  p  p     m    n    b xm n

m   n   m   m   m
n   n   n

give us 
 
f
 goal p    x  y  b 
x
 
p  p 

pset p  


x
x

x

x

n  p  m    n    b xm  n  n  p  p     m    n    b xm  n 

m     m     n     n    

   

fion testability bdi agent systems

 

x

p  p 

pset p  
x

x

 

n p  m    n    b x



 

n  p  p     m    n    b xm  n 

m     n    

m     n    

x

x

x

m  n 

 

 

p  p  f p  x  y  b  f p  p     x  y  b 

pset p  
 
f
 p m  x  y  b  generating function n  p m  m  n  b   section c  
 
provide definition f
 p m  x  y  b  terms auxiliary function g   see section c    
introduce bound length paths giving 
 
f
 goal p    x  y  b   
x
x
 
 
 
p  p   f
 p  x  y  b  f
 p  p       x  y  b  

pset p  

 

x

x

 
 
p  p   f
 p  x  y  b    f
 p  p       x  y  b    

pset p  
 
c   derivation f
 goal p    x  y  b   

similarly previous derivation  define 
 
f
 goal p    x  y  b     

x

x

n  goal p    m  n  b xm n

m   n  
 
 goal p            terms plans p  
derive recursive definition f
 
first define new function n p m  m  n  o  b   denotes number unsuccessful
paths use plans multiset p   have 

n  goal p    m  n  b    n  p m  m  n   p    b 
states goal fail   p   plans multiset must tried 
define generating function g  p m  x  y  z  b    n  p m  m  n  o  b  ordinary x exponential z  i e  coefficients xm n z  o  values
n  p m  m  n  o  b  
have 
 
f
 goal p    x  y  b     

x

x

n  p m  m  n   p    b xm n

m   n  

wish rewrite terms g    generalising right hand side
sum possible values number plans used  o   followed restriction
select values    p   

   

fiwinikoff   cranefield

 
f
 goal p    x  y  b   

   p   

x

x
n   p m  m  n   p    b  z  p  


 p    z  p  

xm n

m   n  

x
p
 

x
o   n p m  m  n  o  b z  o  power z   p  
 p   
xm n
 p  
z
m   n  

 

p
   p   

p p  

n
m  
n  
o   n p m  m  n  o  b x z  o 



power z   p  

z  p  

since nested sum definition g   see section c     simplify to 
 

f goal p    x  y  b       p   

g  p m  x  y  z  b    power z   p  
z  p  

 
section c   derive definition g  p m         terms f
 p         p
set p   

 
c   definition f
 p m  x  y  b   

recall n  p m  m  n  b  number unsuccessful paths using zero
plans plan multiset p  with respect binding b  actions  n
 
failed actions  f
 p m  x  y  b    ordinary generating function 
first consider case p empty  case  precisely one way
 
fail  generates trace length zero  therefore  f
     x  y  b       x        
case p non empty sum number plans used
execution  yields following definition 
 p  
 

n p m  m  n  b   

x

n  p m  m  n  o  b 

o  

n  p m  m  n  o  b  is  before  number unsuccessful paths plan
 
multiset
  using plans  therefore  using definition f
 p m  x  y  b     
p pp

 

n
n
 p
m 
m 
n 
o 
b x

 

have 
m  
n  
 
f
 p m  x  y  b   

 

m 
x
 p
x
x

n  p m  m  n  o  b xm n

m   n   o  

 replace n  looking coefficient corresponding term g   
o  accounts division o  g    reorder summations 
 p  

 

x

x x

o  xm n z  g  p m  x  y  z  b   xm n

o   m   n  

   

fion testability bdi agent systems

 we shift o  outwards  multiply z  z  
p
 p   p
n
 
n
x
n    x z  g p m  x  y  z  b   x z
m  
 
o 
zo
o  

 p  

 

x
o  

o 

g  p m  x  y  z  b    power z  o
zo

c   definition g  p m  x  y  z  b   
define g  p m  x  y  z  b    generating function n  p m  m  n  o  b  ordinary x exponential z  hence division o  below       
maximum allowed trace length 
g  p m  x  y  z  b     

x
x

x

n  p m  m  n  o  b 

m   n   o  

xm n z
o 

recall n  p m  m  n  o  b  denotes number unsuccessful paths use
plans multiset p   empty multiset plans successful execution 
single unsuccessful execution   actions  uses   plans  hence 
 
    n      
 
n     m  n  o  b   
  otherwise
therefore  g      x  y  z  b         non empty multisets must partition actions
trace  action failures  numbers plans used  across different plan bodies
multiset  consider ways plans various plan shapes
interleaved give overall order attempting plans 
n   p   c            pj  cj    m  n  o  b 
x
 
n   p   c     m    n    o    b  n   pj  cj    mj   nj   oj   b 
m    mj  m
n    nj  n
o    oj  o

multinomial coefficient
thus 


o     oj



 

o 
o      oj  

g   p   c            pj  cj    x  y  z  b   
 by definition g   using restriction  rather bounded sum m 
expanding n  above 



x
x

 
n   p   c     m    n    o    b 

 
 
 

 
j
  m  m
m n o  

 

j

n    nj  n
o    oj  o

xm n z
n  pj  cj    mj   nj   oj   b 
o 
 

   

 
power x 

fiwinikoff   cranefield

 


x

x

o 
n   p   c     m    n    o    b 

 
 
 
 

 
 
j
 m

m n o   m    mj
n    nj  n
o    oj  o

xm n z
n   pj  cj    mj   nj   oj   b 
o 

 
power x 

 cancelling o  distributing oi   xmi   ni z oi  
 


x

x

n   p   c     m    n    o    b 

m n o   m    mj  m
n    nj  n
o    oj  o

xm  n  z o 
o   

xmj nj z oj
n  pj  cj    mj   nj   oj   b 
oj  

 

 

 replacing


x

x



m   m   m   m


 


x



x
x

redistributing sums 

m     m    

n   p   c     m    n    o    b 

xm  n  z o 

m   n   o    




x



power x 

o   




n   pj  cj    mj   nj   oj   b 

xmj nj z oj

mj  nj  oj   

oj  


power x 

x

 replacing restriction  




n

x
 
 
 
x z x
 
n   p   c     m    n    o    b 

o   
m   n   o    




n

x
j
j
j
x
x z

n   pj  cj    mj   nj   oj   b 
oj  
mj  nj  oj   

 

 by definition g        
x

x

  g   p   c     x  y  z  b    g   pj  cj    x  y  z  b   

need define g   pi  ci    x  y  z  b    
consider n   p c   m  n  o  b   simple cases      use
plans  single unsuccessful
path  actions  m   n      

c 
hand      oc   o  co  
ways selecting c available
copies plan p  selected plans executed o  different orders 
execution sum possible distributions actions  successful unsuccessful 
   

fion testability bdi agent systems

amongst plans  gives 

x
c


o 
n  p  m    n    b  n  p  mo     b 




m    mo  m
n    no  n
n   p c   m  n  o  b   


 
  n      



 
otherwise

   

therefore following definition g   p c   x  y  z  b     initial   abbreviates  x    z        i e  base case   n        rest
definition g    expanding n  using definition 
g   p c   x  y  z  b   
    



x
c
o 




x

x

n  p  m    n    b  n  p  mo     b 

    mo  m
n    no  n

m   n   o  

xm n z
o 

 cancel o  o   rearrange sums replace upper bound
restriction 





x
x
x
x

c
 
 

n


    
n p  m    n    b  n p  mo     b x

power x  z


o  
m   n  
m    mo  m
n    no  n


x

 replacing

x

m   m   m   m

    





x
x

redistributing sums 

m     m    


x
c
o  


x

x

 
n  p  m    n    b xm  n 



m     n    

x

x

  
n  p  mo     b  xmo

mo      


power x  z
 o
x
x

x
c
    
n  p  m  n  b  xm n
power x  z

m   n  
o  
xx
 
 replace
n  p  m  n  b xm n f
 p  x  y  b    per definition 


n

c
x
c
    
f    p  x  y  b   o power x  z

o  
c
x
c
f    p  x  y  b   ox z
    

o  

   

fiwinikoff   cranefield

appendix d  analysis procedural code structures
seek derive expression largest possible number paths program
given size have  i e  definition n m    max n p      p     m   recall
program either  atomic  statement single path  i e  n s        sequence
two programs p    p  n p    p      n p    n p     conditional p    p 
n p    p      n p      n p    
relatively easy see examining possible programs  
n m    m  instance  largest number paths     obtained program
    s  easy show     largest number paths possible   
larger values m  observe     program  
largest number paths follows particular form      program
largest path written p     s     s    s   s   n p          
generally  define s    s  s      s  following
result  shows programs maximal number paths size 
considered particular form 
theorem d   program size  for      largest possible number
paths written pi   pi    pi            pik pij    j k  either s 
s   
proof  establish result induction  assume holds n
    n m  show must hold      so  let us assume
program pm   maximal number paths  form
j
 
 
k
pm  
  pm  
          pm  
pm  
either s  s    two cases  depending
structure pm     consider case turn show fact either  a 
pm   rewritten desired form  preserving number paths
program size   b  pm   cannot maximal  since construct program size
    larger number paths pm    
j
 
 
k
case    pm   form pm  
  pm  
          pm  
least one pm  
neither

s  s    let pm   one sub programs neither s  s    convenience

define p shorthand pm  
  now  since p size less      induction
hypothesis applies     written form pi    pi          pil pij
either s  s    easy see one rewrite pm   desired form
exploiting associativity    rewriting follows 
i 
i  
i 
i  
      pm  
   pi    pi          pij    pm  
                pm  
  pi    pi          pij   pm  
    

applying rewriting pm  
s  s  yields program size
     number paths original program  desired form 
sequence sub programs  either s  s    shows result holds
     i e  maximal path program written desired form 
 
 
k
case    pm   form pm  
  pm  
          pm  
k  means
 
k
pm   must consist single conditional  i e  pm     pm             pm  
k     

    fact one maximal path program  structure  modulo
swapping order arguments     
    or  size    written s    s  maximal number paths program
size   meets desired form 

   

fion testability bdi agent systems

 
 
without loss generality view pm   form pm  
  pm  
 by viewing
 
k
 
k
pm             pm    pm              pm   k       consider following
 
 
sub cases  depending values n pm  
  n pm  
  
 
 
case  a  n pm  
  n pm  
  greater    show pm  
 
 
 
maximal  consider program pm  
  pm  
  pm  
 i e    replaced
 
 
 
 
    know n pm     pm       n pm     n pm  
   without loss gen 
 
erality  lets assume n pm     n pm      show original pm  
 
 
fewer paths pm  
  number paths pm   n pm       n pm  
  
 
 
 
 
 
n pm      since n pm     n pm      n pm       n pm       n pm    
 
 
 
 
 
n pm  
    n pm  
      n pm  
   since n pm  
  n pm  
  greater
 
 
 
 
     n pm       n pm     n pm       n pm  
   i e 
 
pm   paths pm     hence pm   maximal     
 
 
case  b  least one n pm  
  n pm  
  greater    without loss
 
 
 
generality  assume n pm     n pm  
   two cases  n pm  
 
either     
 
      
sub case  b i   let us consider first case n pm  
program one path statement s  sequence statements s  s          s 
clearly latter maximal since replacing             would
result program size paths  so  therefore pm  
 
 
 
maximal  pm  
must s  pm       pm  
  therefore pm  

size m  two sub cases  either still greater        
second sub case simple    show  inspecting possible
 
programs size    n         therefore n s   pm  
 
           however  know  s     s    s   s  size     paths 
hence sub case pm   cannot maximal number paths 
first sub case  still greater    induction hypothesis applies
 
 
written desired form  abbreviate pm  

therefore pm  
j

 
 
p    pm        p    p            p    p  either s 
  
s    consider variant program pm  
    s   p      p           p j   
  
clearly size pm     show pm  
paths
j
  
 
 
 
pm     n pm             n p     n p            p       n p            p j      n p    
n p             p j     now  n pm            n p     n p             p j     order show
  
n pm       n pm  
  need show     n p             p j  
follows fact must least one p i   that  since p i
either s  s    size least   
 
 
 
sub case  b ii   know n pm  
        n pm  
   since n pm  
 
 
 
 
n pm     n pm       hence n pm           n pm    
 
 
 
  n pm  
    n pm  
   now  n pm  
  strictly greater  
 
n pm     strictly less n pm     shown pm   actually
 
maximal number paths  hand  n pm  
   
 
n pm           n pm                  however  values
theorem applies  know n m       therefore
shown sub case pm   maximal     

   

fiwinikoff   cranefield

shown assume pm   maximal structure
specified  fact one derive another program  size      either
satisfy desired structure  larger number paths pm     contradicts assumption pm   maximal  establishes desired property pm    
induction result applies      desired 
previous result shows considering programs given size
largest possible number paths  denoted pm    limit considering
programs form p m   p m           pkm pim either       s 
derive definition n m   firstly  observe that  inspecting cases 
n m    m   
n       
n       
two first cases discussed above  last case  two programs
appropriate structure size    s    s    s   with   paths  s    s 
 with   paths  
consider      adding statement program  i e  going m   
effect modifies pm adding one pim   increments n pim   one 
since multiplication commutative associative  without loss generality  assume
  n p  
increment n pkm    therefore n pm     n p m           pk 
k



n pm       n p            pk     n pk         two cases 
   therefore
case    pim s    n pm     n p m           pk 
      n p       note case p
n pm       n p m           pk 

m  
 


written p            pk    s    s   

case    pim s  s  observe replacing     gives
greater increase number paths replacing      hence  after
  
possibly reordering pim pkm   s    n pm     n p m           pk 
 


n pm       n p            pk        n pm      
therefore recursive definition n m  depending form pm   next
observe fact form pm follows simple cycle  know      case  
holds  as above  p    s    s     therefore p  written s    s    s    hence
p  written s    s    s  s    s    s    hence p  written s    s    s   
generally  prove induction pm written p m           pkm
following holds   a  multiple    pim s     b 
one multiple    exactly two pim s  rest s   
 c  two multiple    exactly one pim s  rest
s    gives us following recursive definition    multiple   
n m        n m 

 
 

n m        n m     
   

 
 

fion testability bdi agent systems

n m        n m     

 
 

simplified to 
 
 
  
n m        n m 
    n m 
  
   
    n m 
n m        n m 
   
n m        n m 

easily derive non recursive definition focusing last case observing
n             n m          n m   for   multiple    
n m     m     substitute definition obtain
following complete definition n m     multiple   
n       
n       
n       
n       
n       
n m     m  
 
n m       
 m  
 
n m           m  

   

fiwinikoff   cranefield

references
benfield  s  s   hendrickson  j     galanti  d          making strong business case
multiagent technology  stone  p     weiss  g   eds    proceedings fifth international joint conference autonomous agents multiagent systems  aamas  
pp        acm press 
bordini  r  h   fisher  m   pardavila  c     wooldridge  m          model checking agentspeak  proceedings second international joint conference autonomous
agents multiagent systems  aamas   pp          acm press 
bordini  r  h   hubner  j  f     wooldridge  m          programming multi agent systems
agentspeak using jason  wiley 
bratman  m  e   israel  d  j     pollack  m  e          plans resource bounded practical
reasoning  computational intelligence            
bratman  m  e          intentions  plans  practical reason  harvard university press 
cambridge  ma 
burch  j   clarke  e   mcmillan  k   dill  d     hwang  j          symbolic model checking 
     states beyond  information computation                 
burmeister  b   arnold  m   copaciu  f     rimassa  g          bdi agents agile goaloriented business processes  proceedings seventh international conference
autonomous agents multiagent systems  aamas   industry track   pp       
ifaamas 
busetta  p   ronnquist  r   hodgson  a     lucas  a          jack intelligent agents components intelligent agents java  agentlink news     
dastani  m           apl  practical agent programming language  autonomous agents
multi agent systems                 
dastani  m   hindriks  k  v     meyer  j  j  c   eds            specification verification
multi agent systems  springer  berlin heidelberg 
de silva  l     padgham  l          comparison bdi based real time reasoning
htn based planning  webb  g     yu  x   eds    ai       advances artificial
intelligence  vol       lecture notes computer science  pp            springer 
berlin heidelberg 
dennis  l  a   fisher  m   webster  m  p     bordini  r  h          model checking agent
programming languages  automated software engineering              
dinverno  m   kinny  d   luck  m     wooldridge  m          formal specification
dmars  singh  m   rao  a     wooldridge  m   eds    intelligent agents iv 
proceedings fourth international workshop agent theories  architectures 
languages  vol       lecture notes artificial intelligence  pp         
berlin heidelberg  springer 
dorigo  m     stutzle  t          ant colony optimization  mit press 
dwyer  m  b   hatcliff  j   pasareanu  c   robby    visser  w          formal software analysis  emerging trends software model checking  future software engineering
      pp          los alamitos  ca  ieee computer society 
   

fion testability bdi agent systems

ekinci  e  e   tiryaki  a  m   cetin  o     dikenelli  o          goal oriented agent testing
revisited  luck  m     gomez sanz  j  j   eds    agent oriented software engineering ix  vol       lecture notes computer science  pp          berlin heidelberg  springer 
erol  k   hendler  j     nau  d          complexity results htn planning  annals
mathematics artificial intelligence               
erol  k   hendler  j  a     nau  d  s          htn planning  complexity expressivity 
proceedings   th national conference artificial intelligence  aaai   pp 
          aaai press 
fix  l   grumberg  o   heyman  a   heyman  t     schuster  a          verifying
large industrial circuits using     processes beyond  peled  d     tsay  y k   eds    automated technology verification analysis  vol       lecture
notes computer science  pp        berlin heidelberg  springer 
georgeff  m  p     lansky  a  l          procedural knowledge  proceedings ieee 
special issue knowledge representation                    
gomez sanz  j  j   bota  j   serrano  e     pavon  j          testing debugging
mas interactions ingenias  luck  m     gomez sanz  j  j   eds    agentoriented software engineering ix  vol       lecture notes computer science 
pp          berlin heidelberg  springer 
huber  m  j          jam  bdi theoretic mobile agent architecture  proceedings
third international conference autonomous agents  agents     pp         
acm press 
ingrand  f  f   georgeff  m  p     rao  a  s          architecture real time reasoning
system control  ieee expert              
jorgensen  p          software testing  craftsmans approach  second edition   crc
press 
lee  j   huber  m  j   kenny  p  g     durfee  e  h          um prs  implementation procedural reasoning system multirobot applications  proceedings conference intelligent robotics field  factory  service  space
 cirffss     pp          american institute aeronautics astronautics 
mathur  a  p          foundations software testing  pearson 
miller  j  c     maloney  c  j          systematic mistake analysis digital computer
programs  communications acm              
morley  d     myers  k          spark agent framework  proceedings
third international joint conference autonomous agents multiagent systems
 aamas   pp          new york  acm 
munroe  s   miller  t   belecheanu  r   pechoucek  m   mcburney  p     luck  m         
crossing agent technology chasm  experiences challenges commercial applications agents  knowledge engineering review                 
   

fiwinikoff   cranefield

naish  l          resource oriented deadlock analysis  dahl  v     niemela  i   eds   
proceedings   rd international conference logic programming  vol      
lecture notes computer science  pp          springer  berlin heidelberg 
nguyen  c   miles  s   perini  a   tonella  p   harman  m     luck  m       a   evolutionary testing autonomous software agents  proceedings  th international
conference autonomous agents multiagent systems  aamas   pp         
ifaamas 
nguyen  c  d   perini  a     tonella  p       b   experimental evaluation ontology based
test generation multi agent systems  luck  m     gomez sanz  j  j   eds   
agent oriented software engineering ix  vol       lecture notes computer
science  pp          berlin heidelberg  springer 
nguyen  c  d   perini  a     tonella  p          automated continuous testing multiagent systems  proceedings fifth european workshop multi agent systems
 eumas  
padgham  l     winikoff  m          developing intelligent agent systems  practical
guide  john wiley sons 
paolucci  m   shehory  o   sycara  k  p   kalp  d     pannu  a          planning component retsina agents  jennings  n  r     lesperance  y   eds    proceedings
 th international workshop agent theories  architectures  languages
 atal   vol       lecture notes computer science  pp          berlin heidelberg  springer 
pokahr  a   braubach  l     lamersdorf  w          jadex  bdi reasoning engine 
bordini  r  h   dastani  m   dix  j     el fallah seghrouchni  a   eds    multi agent
programming  languages  platforms applications  chap     pp          springer 
raimondi  f     lomuscio  a          automatic verification multi agent systems
model checking via ordered binary decision diagrams  j  applied logic            
    
rao  a  s          agentspeak l   bdi agents speak logical computable language 
de velde  w  v     perrame  j   eds    agents breaking away  proceedings
seventh european workshop modelling autonomous agents multi agent
world  maamaw     vol       lecture notes artificial intelligence  pp       
berlin heidelberg  springer 
rao  a  s     georgeff  m  p          modeling rational agents within bdi architecture 
allen  j   fikes  r     sandewall  e   eds    proceedings second international
conference principles knowledge representation reasoning  pp         
morgan kaufmann 
sardina  s     padgham  l          bdi agent programming language failure handling  declarative goals  planning  autonomous agents multi agent systems 
             
shaw  p   farwer  b     bordini  r          theoretical experimental results
goal plan tree problem  proceedings seventh international conference
autonomous agents multiagent systems  aamas   pp            ifaamas 
   

fion testability bdi agent systems

sloane  n  j  a          on line encyclopedia integer sequences  http   www research 
att com njas sequences  
thangarajah  j   winikoff  m   padgham  l     fischer  k          avoiding resource
conflicts intelligent agents  van harmelen  f   ed    proceedings   th
european conference artificial intelligence  ecai   pp        ios press 
van riemsdijk  m  b   dastani  m     winikoff  m          goals agent systems 
unifying framework  proceedings seventh conference autonomous agents
multiagent systems  aamas   pp          ifaamas 
wilf  h  s          generatingfunctionology  second edition   academic press inc   boston 
ma  http   www math upenn edu wilf gfology  pdf 
winikoff  m          assurance agent systems  role formal verification
play   dastani  m   hindriks  k  v     meyer  j  j  c   eds    specification
verification multi agent systems  chap      pp          springer  berlin heidelberg 
winikoff  m   padgham  l   harland  j     thangarajah  j          declarative   procedural goals intelligent agent systems  proceedings eighth international
conference principles knowledge representation reasoning  kr       pp 
        toulouse  france  morgan kaufmann 
wooldridge  m          introduction multiagent systems  john wiley   sons 
chichester  england 
wooldridge  m   fisher  m   huget  m  p     parsons  s          model checking multi agent
systems mable  proceedings first international joint conference
autonomous agents multi agent systems  aamas   pp          acm press 
zhang  z   thangarajah  j     padgham  l          model based testing agent systems 
filipe  j   shishkov  b   helfert  m     maciaszek  l   eds    software data
technologies  vol     communications computer information science  pp 
        berlin heidelberg  springer 
zhu  h   hall  p  a  v     may  j  h  r          software unit test coverage adequacy 
acm computing surveys                 

   


