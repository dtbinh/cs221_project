journal artificial intelligence research                  

submitted        published      

complexity answering conjunctive navigational
queries owl   el knowledge bases
giorgio stefanoni
boris motik

giorgio stefanoni cs ox ac uk
boris motik cs ox ac uk

department computer science  university oxford
parks road  oxford ox   qd  united kingdom

markus krotzsch
sebastian rudolph

markus kroetzsch tu dresden de
sebastian rudolph tu dresden de

faculty computer science  tu dresden
nothnitzer strae           dresden  germany

abstract
owl   el popular ontology language supports role inclusionsaxioms
form s  sn v capture compositional properties roles  role inclusions closely
correspond context free grammars  used show answering conjunctive
queries  cqs  owl   el knowledge bases unrestricted role inclusions undecidable  however  owl   el inherits owl   dl syntactic regularity restriction
role inclusions  ensures role chains implying particular role described
using finite automaton  fa   sufficient ensure decidability cq answering 
however  fas worst case exponential size known approaches
provide tight upper complexity bound 
paper  solve open problem show answering cqs owl
  el knowledge bases pspace complete combined complexity  i e   complexity
measured total size input   end  use novel encoding regular role
inclusions using bounded stack pushdown automatathat is  fas extended stack
bounded size  apart theoretical interest  encoding used practical tableau
algorithms avoid exponential blowup due role inclusions  addition  sharpen
lower complexity bound show problem pspace hard even consider
role inclusions part input  i e   query parts knowledge
base fixed   finally  turn attention navigational queries owl   el
knowledge bases  show answering positive  converse free conjunctive graph
xpath queries pspace complete well  interesting since allowing converse
operator queries known make problem exptime hard  thus  paper
present several important contributions landscape complexity answering
expressive queries description logic knowledge bases 

   introduction
description logics  dls   baader  calvanese  mcguinness  nardi    patel schneider       
family knowledge representation formalisms logically underpin web ontology language owl    cuenca grau  horrocks  motik  parsia  patel schneider    sattler 
       dl knowledge bases describe domain terms concepts  i e   unary predicates  
roles  i e   binary predicates   individuals  i e   constants   describe relationships concepts  roles  individuals using logical axioms  dls owl

c
    
ai access foundation  rights reserved 

fistefanoni  motik  krotzsch    rudolph

  steadily gaining popularity provide developers modern
information systems flexible graph like data model natural countless application areas  semantic web  gutierrez  hurtado  mendelzon    perez        
social network analysis  fan         network traffic analysis  barrett  jacob    marathe 
       answering queries dl owl knowledge bases core service applications
diverse monitoring financial products within italian ministry economy
finance  de giacomo et al          accessing real time diagnostic data turbines  giese
et al          integrating configuration data air traffic control systems  calvanese
et al          due practical importance query answering  theoretical investigation
expressivity computational complexity query languages high
research agenda knowledge representation community past decade 
conjunctive queries  cqs   chandra   merlin        basic class queries
relational databases  querying dl knowledge bases using cqs studied diverse range settings  calvanese  de giacomo  lembo  lenzerini    rosati        perezurbina  motik    horrocks        rudolph   glimm        kontchakov  lutz  toman 
wolter    zakharyaschev        ortiz  rudolph    simkus        gottlob   schwentick 
      venetis  stoilos    stamou         however  conjunctive queries first order definable thus cannot express certain important properties graph reachability 
regular path queries  rpqs   cruz  mendelzon    wood        barcelo        alternative query language capable describing connections graph vertices using
regular expressions  allowing users navigate inside graph  example  rpq
 ispartof haslocation  retrieves pairs vertices connected via zero ispartof
edges followed one haslocation edge  furthermore   rpqs extend rpqs converse operator  i e   backward navigation   calvanese  vardi  de giacomo    lenzerini 
       nested regular expressions allow existential quantification paths  perez 
arenas    gutierrez         c   rpqs extend    rpqs cqs conjunctions    rpqs  calvanese  de giacomo  lenzerini    vardi        bienvenu  ortiz   
simkus         finally  inspired xpath query language xml  graph xpath queries
 gxqs  recently proposed language querying graph databases  libkin 
martens    vrgoc        dl knowledge bases  kostylev  reutter    vrgoc        bienvenu  calvanese  ortiz    simkus         gxqs extend  rpqs negation regular
expressions  checking properties vertices using boolean combinations node tests
is  concepts existential quantifications paths  example  graph xpath
query  ispartof test cell hhasspecialityi  haslocation  refines aforementioned rpq
requiring node ispartof edges haslocation edge instance cell concept outgoing hasspeciality edge  graph xpath
queries straightforwardly extended conjunctive graph xpath queries  cgxqs  
query languages boolean answer variables  hence  answer
query boolean value 
    problem setting
although computing answers query dl knowledge base function problem 
common literature consider complexity associated decision problem
is  checking whether boolean query entailed knowledge base  article

   

fithe complexity answering cqs gxqs owl   el kbs

follow well established practice analyse computational properties several
query languages dl knowledge bases  follow vardi        measure input
size two ways  combined complexity measures complexity terms combined
size query knowledge base  data complexity measures complexity
terms size data  i e   query parts knowledge bases
considered fixed  
computational properties query answering dl knowledge bases depend
expressivity constructs used knowledge base query language
used  particular  conjunctive query answering expressive description logics
least exponential combined complexity  glimm  lutz  horrocks    sattler        lutz 
      intractable data complexity  calvanese  de giacomo  lembo  lenzerini   
rosati        ortiz  calvanese    eiter         problem becomes tractable data
complexity rl  grosof  horrocks  volz    decker        ter horst       
ql  calvanese et al         artale  calvanese  kontchakov    zakharyaschev        profiles
owl    several worst case optimal algorithms proposed perform well
practice  urbani  van harmelen  schlobach    bal        rodriguez muro   calvanese 
       paper  however  focus owl   el profile owl    based
el family dls  baader  brandt    lutz         basic reasoning problems
owl   el  checking concept subsumption instance checking  decided
polynomial time  baader et al         krotzsch         makes language
interesting practical applications  motivated observation  paper present
several novel complexity results answering queries owl   el knowledge bases 
one important modelling constructs owl   el role inclusionsaxioms
form s  sn v express compositional properties roles  example 
following inclusions state role ispartof transitive that  x located
part z  x located z 
ispartof ispartof v ispartof

haslocation ispartof v haslocation

prior introduction el family  role inclusions already identified
source undecidability expressive dls loosely correspond context free
grammars  inclusion s  sn v knowledge base seen production rule
s  sn   knowledge base induces context free language l s  role
s  using correspondence  wessel        showed checking satisfiability alcr
knowledge bases unrestricted role inclusions undecidable  regain decidability 
horrocks sattler        proposed syntactic regularity restriction role inclusions
ensuring language l s  regular thus recognised using finite
automaton  fa   kazakov        later showed that  cases  size automaton
necessarily exponential knowledge base size  owl   dl profile owl  
extends alcr thus incorporates regularity restriction definition 
even unrestricted role inclusions  standard reasoning problems el
solved polynomial time  baader et al          moreover  stefanoni  motik  horrocks
       showed answering cqs owl   el knowledge bases without role inclusions
np complete  however  using correspondence role inclusions contextfree grammars  rosati        krotzsch  rudolph  hitzler        independently
proved answering cqs el knowledge bases unrestricted role inclusions
   

fistefanoni  motik  krotzsch    rudolph

undecidable  furthermore  krotzsch et al         showed checking concept subsumptions el knowledge bases inverse roles unrestricted role inclusions
undecidable 
owl   el inherits regularity restriction owl   dl  undecidability proofs rosati        krotzsch et al         apply owl   el 
fact  krotzsch et al         showed answering cqs el knowledge bases extended
regular role inclusions pspace hard combined complexity  proposed
cq answering algorithm fragment owl   el regular role inclusions 
algorithm  however  runs pspace if  role s  language l s  represented using automaton polynomial size  due mentioned result kazakov
        approach provide us matching pspace upper bound
problem  ortiz et al         proposed different algorithm answering cqs owl  
el knowledge bases  with regular role inclusions without restriction usage
features   similarly algorithm krotzsch et al          algorithm
ortiz et al         encodes regular role inclusions using finite automata  hence 
algorithms run time polynomial size data thus settle
question data complexity  settle question combined complexity 
comparatively works studying complexity  conjunctive  graph
xpath queries dl knowledge bases  particular  kostylev et al         observed
gxqs closely related propositional dynamic logic full negation  harel  tiuryn 
  kozen         immediately shows answering gxqs dl knowledge bases
undecidable even respect empty knowledge base  several gxq fragments
proposed possible solution problem  path positive gxqs disallow negation
role expressions  positive gxqs prohibit negation concepts well 
kostylev et al         showed answering path positive gxqs intractable data
complexity already queries without transitive closure operator knowledge
bases containing instance assertions  recently  bienvenu et al         showed
answering positive gxqs fragment owl   el tractable data complexity 
exptime complete combined complexity 
    contributions
paper  present several novel complexity results answering queries owl  
el knowledge bases 
first  present first cq answering algorithm handle owl   el
 with regular role inclusions without restriction size fas 
runs pspace  thus settle open question combined complexity
cq answering owl   el  result based novel encoding languages
induced regular role inclusions using pushdown automata  pdas that is  fas extended
stack  show that  role s  construct polynomial time
pda accepts language l s  whose computations use stack size linear
number role inclusions  bounded stack pdas  anselmo  giammarresi    varricchio 
      recognise precisely class regular languages exponentially
succinct finite automata  geffert  mereghetti    palano         obtain cq
answering algorithm running pspace  extend algorithm krotzsch et al        

   

fithe complexity answering cqs gxqs owl   el kbs

data
combined

elhodr

ptime

owl   el
ptime

horn shoiq
ptime

horn sroiq
ptime

 ortiz et al        

 theorem    

 ortiz et al        

 ortiz et al        

np

pspace

exptime

 exptime

 stefanoni et al        

 theorem    

 ortiz et al        

 ortiz et al        

table    complexity landscape cq answering  all completeness results 
handle universal role  keys  self restrictions  reflexive roles  thus covering
features el profile apart datatypes  adapt handle
regular role inclusions encoded using pdas  apart allowing us obtain complexity
results presented paper  tableau algorithm horrocks  kutz  sattler       
used popular reasoners pellet  sirin  parsia  cuenca grau  kalyanpur    katz 
      fact    tsarkov   horrocks        straightforwardly modified use
bounded stack pdas instead fas  could eliminate potential source inefficiency
practice  finally  brevity simplicity deal datatypes paper 
however  set owl   el datatypes designed enable datatype
reasoning using external datatype checking procedure  baader  brandt    lutz       
cuenca grau et al         easily incorporated algorithm 
second  improve pspace lower bound krotzsch et al         showing
answering cqs owl   el pspace hard already role inclusions
considered part input  i e   conjunctive query  tbox  abox
fixed   furthermore  show cqs answered polynomial time query
role inclusions fixed  emphasises observation role inclusions
main source problems pspace hardness 
third  show positive  converse free cgxqsthat is  cgxqs allow
negation paths  negation concepts  converse operatorcan answered
owl   el knowledge bases using polynomial space  particular  owl   el allows
role inclusions  self restrictions  reflexive roles  allow us polynomially reduce answering cgxq answering cq extended knowledge base 
show answering positive  converse free gxqs  i e   cgxqs single atom 
done time polynomial input size  result interesting bienvenu
et al         proved answering positive gxqs el knowledge bases exptimecomplete  hence  adding converse operator increases complexity gxqs 
results thus show answering gxqs cgxqs difficult instance checking
answering conjunctive queries  respectively  least theoretical perspective
makes gxqs cgxqs appealing query languages owl   el knowledge bases 
    summary complexity landscape
table   summarises complexity landscape answering cqs various dls related
owl   el  here  elhodr
fragment owl   el obtained allowing simple
role inclusions form v s  disallowing universal role  reflexive roles 
self restrictions  datatypes  combined complexity result logic due
stefanoni et al          furthermore  horn shoiq extends elhodr
inverse roles
horn qualified number restrictions  horn sroiq extends horn shoiq role
   

fistefanoni  motik  krotzsch    rudolph

data

positive
positive
converse free converse free
gxqs
cgxqs
ptime c
ptime c
 theorem    

combined

ptime c
 theorem    

positive
gxqs

path positive
gxqs

gxqs

ptime h

conp h

conp h

 theorem      bienvenu et al          kostylev et al          kostylev et al        

pspace c

exptime h

exptime h

undecidable

 theorem      bienvenu et al          bienvenu et al          kostylev et al        

table    complexity answering navigational queries owl   el knowledge bases
 c means complete  h means hard 

inclusions  results logics due ortiz et al          cq answering ptimecomplete data complexity cases  essentially due fact
logics horn disjunctive reasoning needed  combined complexity 
table illustrates presence different constructs affects complexity answering
cqs  particular  extending elhodr
role inclusions increases complexity
np pspace  pspace lower bound  increase solely due role inclusions 
furthermore  extending elhodr
inverse roles increases complexity np
exptime  finally  extending owl   el inverse roles increases complexity
pspace  exptime 
table   summarises complexity landscape answering navigational queries
owl   el knowledge bases  one see  adding converse operator increases
combined complexity gxqs exptime  bienvenu et al          moreover  adding
negation node tests increases data complexity gxqs conp  whereas adding
negation path expressions leads undecidability combined complexity  kostylev
et al          contrast  existential quantification paths increase complexity  answering positive  converse free  c gxqs owl   el knowledge bases
difficult answering  c rpqs el knowledge bases  bienvenu et al         
    organisation article
rest article organised follows  section    present basic definitions
finite automata  pushdown automata  dl underpinning owl   el  conjunctive
queries  section    introduce novel encoding regular role inclusions using pdas
bounded stack size  section    present cq answering algorithm owl  
el discuss complexity  section    present improved pspace lower bound
answering cqs owl   el  finally  section    introduce  conjunctive  graph
xpath queries  show reduce problem answering positive  converse free
conjunctive graph xpath queries answering ordinary conjunctive queries  present
aforementioned complexity results 

   

fithe complexity answering cqs gxqs owl   el kbs

   preliminaries
section recapitulate basic definitions finite automata  pushdown automata 
dl elro  underpinning owl   el  conjunctive queries  rest paper 
 i  j  set containing natural number k n k j 
    automata language theory
article  use standard notions alphabets  which must finite   strings  string
concatenation  kleene operators  languages formal language theory  hopcroft 
motwani    ullman         assume alphabets contain special symbol
  use label transitions automata consume input symbols 
furthermore  empty word  finally  w w  words   w  number symbols
occurring w  w w  unique word w   w    w   w  w   exists 
otherwise w w  undefined 
      finite automata
finite automaton  fa  tuple f   hq      i  f q finite set states 
input alphabet    q       q transition function  q start state 
f q final state  f deterministic   s           s  c    
q c   otherwise  f nondeterministic  size  f  f number
symbols used encode f tape turing machine 
instantaneous description f pair hs  wi q w  
derivation relation   f smallest set that  states s  q 
symbol c   word w  
s   s  c   hs  c wi   hs    wi 
s   s     hs  wi   hs    wi 
let   reflexive transitive closure    then  language accepted f
defined l f     w   hi  wi   hf  i   language l regular fa
f exists l   l f  
      pushdown automata
pushdown automaton  pda  tuple p   hq        i  i  f  f q finite set
states  input alphabet  stack alphabet  transition function mapping
state q  symbol c     stack symbol x finite subset
 s  c  x  q   q start state  start stack   f q final
state  f final stack  size  p  p number symbols used
encode p tape turing machine 
instantaneous description p triple hs  w  q  w  
  read stack content left rightthat is  leftmost symbol
top stack  derivation relation   p smallest set that 
states s  q  symbol c   word w   stack symbol x  
words    

   

fistefanoni  motik  krotzsch    rudolph

hs       s  c  x  implies hs  c w  x   hs    w    i 
hs       s    x  implies hs  w  x   hs    w    i 
let   reflexive transitive closure relation    then  language accepted
p defined l p     w   hi  w  ii   hf    f i  
definitions pda p language l p  somewhat nonstandard 
literature typically considers hopcroft pda  hopcroft et al         ph differs
definition contain final stack f initial stack symbol
 rather word    moreover  language accepted ph defined
lh  ph      w     hi  w  ii   hf    i   show next definitions
equivalent standard definitions hopcroft et al         
proposition    following two properties hold 
    pda p  hopcroft pda ph exists l p    lh  ph   
    hopcroft pda ph   pda p exists lh  ph     l p  
proof  sketch   first prove property      prove property     
    show transform arbitrary pda p hopcroft pda ph
l p    lh  ph    ph uses fresh initial state i  fresh stack symbols z 
occurring   symbol z  start stack symbol ph   furthermore  ph new
 transition moves pda state i  initial state p replacing z 
  start stack p  point  ph simulates p  always leaving
bottom stack reaches final state f p  next  ph uses fresh
states s            s f   fresh  transitions move ph state f s f   reading f
stack  finally  s f     pda ph  moves fresh final state f   top most
symbol stack   thus accepting input whenever p reaches f f
stack  automata p ph clearly accept languages 
    show transform arbitrary hopcroft pda ph pda p
lh  ph     l p   pda p uses fresh stack symbol   initial stack
initial stack symbol ph   final stack empty word  p simulates ph  
always leaving bottom stack reaches final state f ph   next  p
 moves fresh final state f   pops topmost symbol stack  point 
pda takes  transitions empty stack  eventually reaching final state
empty stack  automata p ph clearly accept languages 
k natural number  k bounded language accepted p set lk  p  containing word w derivation hs    w          hsn   wn   n exists
s  sn start final state p  respectively 
w    w wn    
  n start final stack p  respectively 
 i   k     n  

   

fithe complexity answering cqs gxqs owl   el kbs

then  p k bounded stack l p    lk  p   stack p bounded
constant  pda p simulated finite automaton encodes stack contents
using states  l p  regular  translating p finite automaton may
require space exponential k  geffert et al          contrast  following proposition
shows exists pda pk l pk     lk  p  size pk polynomial
size p k 
proposition    pda p natural number k  one compute polynomial
time pda pk l pk     lk  p  
proof  let p   hq        i  i  f  f pda let k n natural number  let
pk   hqk       k   ik   i  fk   f pda defined
qk   q     k  
transition function k smallest function that        k   symbol
c     states s  s  q  word hs     s  c  x 
         k  hhs            i  k  hs   i  c  x  
ik   hi   i i fk   hf   f  i 
clearly  pk computed time polynomial size p k  let    k
derivation relations p pk   respectively  definitions k ik  
hhs   i  w   k hhs    ji  w      hs  w    hs    w      i                 j 
max    j  k  thus  lk  p    l pk    required 
    description logic elro  conjunctive queries
description logic elro    underpinning owl   el  defined w r t  signature consisting mutually disjoint countably infinite alphabets c  r  atomic concepts 
roles  individuals  respectively  assume   c   c   c   c top
concept c bottom concept  similarly  assume   r   r   r   r
top role  universal role  r bottom role  individual i  expression
 a  nominal is  concept consisting precisely individual a  then  n set
containing nominal  a  individual i  call b c n basic concept 
role chain word r          call empty role chain write
  concepts  tbox axioms  rbox axioms  abox axioms defined specified
table    elro  tbox finite set concept inclusions  range restrictions 
keys  elro  rbox r finite set role inclusions 
r elro  rbox  let r      r    s r   occurs r   furthermore 
rewrite relation  
w r t  r smallest relation role chains following
holds role chains      
     
    axiom v r 
   r    
    role chain r  
 
reflexivetransitive closure
    role  l s       r    
 
language induced rbox r  role simple r if  role chain
   

fistefanoni  motik  krotzsch    rudolph

concepts 
top concept
bottom concept
nominal
conjunction
self restriction
existential restriction
role chains 
top role
bottom role
empty role chain
nonempty role chain
tbox axioms 
concept inclusion
range restriction
key

rbox axioms 
role inclusion
abox axioms 
concept assertion
role assertion

syntax

semantics

 c
c
 a 
c ud
s self
s c



 ai  
c di
 x   hx  xi  
 x   c   hx  yi  

 r
r

s  sn



 hx  xi   x  
s i sni

cvd
range s  c 
key c  s        sn  

c di
c
x  y  z            zn
individuals a  b  c            cn exist
x   ai     bi   zi   cii   n 
x   holds whenever  x  y  c
 hx  zi i  hy  zi i  sii   n 

vs


bi
si

a b 
s a  b 

hai   bi

table    interpreting elro  concepts  roles  axioms interpretation   hi  

s 
        elro  abox finite set concept role assertions 
finally  elro  knowledge base  kb  tuple k   ht   r  ai elro 
tbox  r elro  rbox  elro  abox
concept s self occurring   role simple r 
s  sn v r range s     c     
s  role sn  r
 

 
exists sn  
sn range sn   c   
let  t     r    a  numbers symbols needed encode   r  a  respectively 
tape turing machine  let  k     t    r   a   furthermore  knowledge
base  tbox  abox  define
    a   occurs    n      a       c     a c   occurs   
   

fithe complexity answering cqs gxqs owl   el kbs

semantics elro  defined follows  interpretation tuple   hi  
nonempty set domain elements  called domain i  interpretation function maps individual domain element ai  
atomic concept c     c   c   set ai   atomic role r     r   r  
relation   function extended concepts role chains shown
upper part table    denotes composition binary relations  interpretation model k satisfies axioms occurring k shown bottom
table    moreover  k consistent model k exists  k inconsistent model
k exists  k entails first order sentence  resp  concept inclusion c v role
inclusion v s   written k     resp  k    c v k    v s       resp  c di
  model k  definition l s   l s  implies
k    v s  knowledge base consistency  entailment concept inclusions  entailment
role inclusions decided polynomial time  krotzsch        baader et al         
      conjunctive queries
term individual variable  atom expression form a t  r t    t 
atomic concept  r role  t  terms  conjunctive query  cq 
formula q    y    x   y   conjunction atoms variables  x  y   variables  x
answer variables q   x empty  call q    y    y   boolean cq  bcq  
substitution partial mapping variables terms  dom   rng  
domain range   respectively  conjunction atoms    
result applying substitution atoms   then   q     z      z contains
 i   y  variable  y  y  variable   ii  variable  y
 y  undefined  definition  q  somewhat nonstandard quantified
variables replaced  example  given q   y    y    y   r y    y     y    y   
   y    a  y    z    q    y    z r y    a   y    z  
let k   ht   r  ai elro  knowledge base let q    y    x   y   cq 
q k q uses predicates individuals occurring k  substitution
candidate answer q k  dom      x rng   ik   certain
answer q k k     q   answering q k amounts computing
set certain answers q k  stated  cq answering function problem 
thus article study complexity associated decision problem named bcq
answering  problem deciding  given boolean cq q k  whether k    q 
please note bcq answering equivalent recognition problem decides 
given cq q k candidate answer   whether certain answer q k 
following vardi         combined complexity assumes q k part
input  data complexity assumes abox part input 
    ensuring decidability bcq answering via regularity
rosati        krotzsch et al         independently showed answering boolean
cqs elro  knowledge bases undecidable  intuitively  role inclusions simulate derivations context free languages  thus  boolean cq check whether two
context free languages non empty intersection  known undecidable problem  hopcroft et al         

   

fistefanoni  motik  krotzsch    rudolph

regain decidability  next recapitulate definition so called regular rboxes
horrocks sattler         let r elro  rbox let smallest
transitive relation r that    v r      s 
then  rbox r regular irreflexive role inclusion v r form
 t   v s 
 t   v s 
 t   s  sn v si        n  
 t   s  sn v si        n  
 t   s  sn v si        n  
induction define level lv s  role r follows  lv s     
r exists s  otherwise  lv s        max lv t     s   clearly 
lv s  computed time polynomial  r   section   show bcq answering
elro  kbs regular rboxes pspace 
    normalising elro  knowledge bases
simplicity  rest paper assume elro  knowledge base
k   ht   r  ai normalised  case following properties hold 
 n   ik      k      a  v  b   a  b  ik    b 
 n   axiom one following forms  a i  basic concepts role 
a  u a  v a 

a  v s a 

s a  v a 

v s self

s self v

 n   axiom v r          r   role
occurs r 
next show knowledge base k normalised polynomial time without
affecting regularity rbox component answers boolean cqs 
proposition    elro  knowledge base k regular rbox boolean
cq q k  one compute polynomial time normalised elro  knowledge base
k  boolean cq q  
rbox k  regular 
q   k    k    q k     q    
proof  let k elro  kb regular rbox let q boolean cq k 
first satisfy property  n    let k  obtained k extending abox
k assertion  c  c  c fresh individual  clearly  k     q k    q 
next  let k  q   obtained k  q  respectively  uniformly substituting
individual arbitrary  fixed  individual b k      a  v  b   entailment
   

fithe complexity answering cqs gxqs owl   el kbs

concept inclusions decided polynomial time  k  q   computed
polynomial time  moreover  k  q   obtained replacing individual
arbitrary  fixed individual b ai   bi model k    q   k   
k     q   k     q 
next satisfy property  n    let k  result eliminating keys k   
one see table    keys derive axioms form  a  v  b   moreover 
effects conclusions already captured k    k     q  
k     q     next  eliminate polynomial time range restrictions occurring
k applying syntactic transformation baader et al          let k  resulting
knowledge base  since definition elro  knowledge base carefully restricts
interactions role inclusions range restrictions  k     q  
k     q    baader et al          next  following krotzsch         compute polynomial
time knowledge base k  satisfies  n   k     q   k     q    
next satisfy property  n    let k  result exhaustively decomposing
role inclusion v form  t   t          occurring k  according
following rewrite rules  occurrence role   fresh 
 t   s  sn v    s   v s 
  sn v    
 
 t  
s  sn v    s sn v s  s  sn  v    
 t   s  sn v
 
 s   v s 
  sn v    
linearly many rewrite steps required satisfy  n    resulting rbox
regular  furthermore  model k  model k  model k 
expanded model j k  interpreting role   occurring k    k 
 s    j       j     unique role chain   v   occurs k    thus 
k     q   k     q     next  let k  result removing axiom
v  r k    removed axioms tautologies  k     q   k     q    
finally  let k  result adding axiom r v s  role occurs k 
occur rbox component  axioms k    k  preserve regularity
tautologies  k     q   k     q     required 

   encoding regular rboxes succinctly using bounded stack pdas
reasoning algorithm dl role inclusions known us uses step checks
whether l s  holds arbitrary role chain role s  example  check
whether k    s a  b  holds  algorithm must ensure that  model k  role chain
l s  exists connecting elements interpreting b  although characterise
languages l s   role inclusions lend well language recognition 
algorithms known us transform role inclusions another  manageable form 
analogous fact that  regular expressions characterise regular languages 
former routinely transformed fas order facilitate language recognition 
horrocks sattler        showed that  regular rbox r role
occurring r  one construct fa fs l fs     l s   fas used
tableau decision procedure sroiqthe dl underpinning owl   dl  horrocks
et al          given sroiq knowledge base  tableau procedure tries construct
   

fistefanoni  motik  krotzsch    rudolph

s 

is 

start




is 

s 

fs 

is 

fs 



s 

fs 

fs 





is 

s 


is 

s 

is 

fs 

s 

fs 

is 

s 

fs 

figure    fa fs  constructed following horrocks sattler       
finite graph representing model kb  edges labelled roles 
vertices labelled concepts  aforementioned fas used ensure universal
restriction s c obey constraints imposed role inclusions  roughly speaking 
obtained running fs graph updating current state fs along
path  labelling reachable vertex state fs final concept
c  simanck        optimised tableau procedure simulating fas on the fly  rather
precomputing advance 
horrocks sattler        observed fas contain exponentially many
states  kazakov        proved unavoidable cases  regular rbox
rn containing axioms      size fa f l f    l sn   exponential n 
si  si  v si

    n 

   

blowup number states caused simple model computation underlying fas  behaviour automaton determined solely current state 
example above  l sn   whenever consists si repeated j times
    n  j    ni   thus  parsing   fa recognising l sn   must
remember number occurrences si already seen  achieved
using different state number    n   figure   shows fa fs 
constructed horrocks sattler         remember current state  fs  contains
two copies automaton fs    copy fs  contains two copies automaton fs   
hence  obtain pspace procedure  must devise succinct representation
languages induced role inclusions  towards goal  note role inclusions
closely related context free grammars  context free languages efficiently
recognised using pushdown automata  hopcroft et al        that is  fas extended
infinite stack storing contextual information  hence  given regular rbox r
role occurring r  construct pda ps accepts l s   unlike fa shown
figure   remembers contextual information using states  pda ps uses stack
remember current status computation determine proceed  show
number states ps polynomial size r  ps recognise
l s  using stack size linear size r  thus  ps provides us required
succinct encoding fs   section    use pdas algorithm answers
boolean cqs elro  knowledge bases using polynomial space 
   

fithe complexity answering cqs gxqs owl   el kbs

start

is 

s    x x

fs 
  x x

  x is  fs  x

is 

s    x x

i r

fs 

r  x x

f r

  x x
  x is  fs  x

is 

s    x x

fs 

figure    pda ps  corresponding fa fs    x r r r
rest section  fix arbitrary regular rbox r  proposition   
assume role inclusion v r          r  
role occurring r   next define pda ps  
definition    let r role  then  ps   hqr   r   r   r       fs   pda
qr    it   ft   r   set states  r   qr    stack alphabet 
r smallest transition function satisfying following conditions x r  
 r  r     r    hft   xi r  it   t  x  
 t   v r  hft   xi r  it     x  
 t   v r  hit   xi r  ft     x  
 t   t  v r  hit    xi r  it     x  
 t   t  t  v r  hit    it  ft xi r  it     x  
 t   t  v r  hit    ft xi r  ft     x  
 ur  r   hf r   xi r  i r   t  x  
 u   hf r   xi r  i r     x  
 u   hi r   xi r  f r     x  
 p  r qr   hs  r  ft     s  
following examples  present pda succinctly encodes fa fs   
explain different types transitions definition    content
stack influences computation pdas 
example    figure   shows pda ps  corresponding fa fs  figure   
c  x 

transition hs    r  s  c  x  shown s    x  indicates transition replaces top most stack symbol x word   moreover  transitions form
 p  definition   shown figure sake clarity  one see
figure  unlike fa fs    copying states pda ps   
   

fistefanoni  motik  krotzsch    rudolph

  x x

start



s  x x

  x i r fs x

i r

fs

r  x x

f r

  x x

  x fs x
  x it x

ip



t  x x

ft

  x x
  x x

p  x x

fp
figure    pda ps rbox example    x r r r
example    explain different types transitions definition   stack
used computation pda  use regular rbox r containing role inclusions
        figure   shows pda ps using notation example   
vp

   

vt

   

p  r v

   

st vs

   

p vt

   

role r associated states ft   moving former
latter ensures pda reads role chain l t    transition type  r  allows
pda read state    transition type  t   ft added
reflexive  allows pda read empty role chain  example  axiom
    introduces  transition ip fp   moreover   transition type  t  
ft added transitive  allows pda read number role
chains             n l t    example  axiom     introduces  transition ft
  transitions types  ur    u     u   analogously reflect properties  r  
 ur  allows pda read arbitrary role   u    u   reflect reflexivity
transitivity  r   respectively  none transitions affect pdas stack 
illustrate transitions type  t    next show how      p s  pda ps
determines   l s   latter ensured axiom      assume pda ps
state stack  due axiom      ps make  transition type  t  
state ip   pushing i r fs stack  since new state ip   pda next need
read p   furthermore  stack content signals pda that  finishes reading
p   move state i r read  r state fs finish reading s  indeed 
ps make transition type  r  state fp read p   followed  transition
type  p  state i r popping i r stack  next  pda make transition
   

fithe complexity answering cqs gxqs owl   el kbs

type  ur  state f r reading s  followed  transition type  p  state fs popping
fs stack  point  pda accepts input 
illustrate transitions types  t    t    next show how      p   pda
ps determines   l s   latter ensured axioms          again  assume
pda ps state stack  pda ps make transition type
 r  state fs   reading leaving stack unchanged  next  due axiom      ps
make  transition type  t   state   pushing fs stack  due axiom     
pda ps next make  transition type  t   state ip   pushing stack 
point  stack contains fs   next  pda make transition type
 r  state fp reading p    transition type  p  state popping
stack  furthermore  analogous way  pda move state ft reading
leaving fs stack  finally  pda make  transition type  p  state
fs popping fs stack  point  pda accepts input 
understand benefit using pdas rather fas  note ps reaches state ip
recognising       role p occurs axioms          ps moves
state ip order read occurrence p   must remember two
axioms caused move knows continue reading p       ps must
continue reading  r   whereas     must continue reading   unlike fas horrocks
sattler        remember information copying states  ps remembers
information stack      reaches ip i r fs stack  whereas    
ps reaches ip fs stack  thus  stack ps analogous stacks
programming languages  stack symbols correspond return addresses  transitions
type  p  correspond return statements 
following proposition immediate definition pda ps  
proposition    pda ps computed time polynomial  r  
following theorem states pda ps accepts l s  ps stack bounded
size r  proof result given section     
theorem    role r role chain  
   l ps   l s  
   ps stack bounded   lv s      
theorem   gives rise following notion depth rbox r  provide us
global bound stack size pdas encoding r 
definition    depth rbox r defined dr    maxsr    lv s       
finally  outline bounded stack encoding regular rboxes reduce
space used tableau algorithm sroiq  since elro  support inverse
roles  definition   directly provide us encoding languages induced
sroiq rboxes  nevertheless  extend construction completing
rbox r inv sn   inv s    v inv s  r role inclusion s  sn v
rbox  inv   maps role inverse  one check that   inverse  role
   

fistefanoni  motik  krotzsch    rudolph

s  pda ps constructed using completed rbox r encodes fs   then  modify
portion tableau algorithm responsible checking satisfaction universal
restrictions running bounded stack pda graph constructed tableau
procedure  roughly speaking  universal restriction s c labelling vertex  run
ps graph updating current state stack ps   label
reachable vertex current state stack ps final concept c  since
ps stack size polynomial  r   requires polynomial space  unlike
fas horrocks sattler        optimised encoding simanck        
may require exponential space 
    proof correctness
section  prove theorem    towards goal  let   derivation relation
w r t  transition function r   furthermore  derivation step hs      hs          i 
write hs     x hs          hs          obtained hs    applying
transition form  x  definition   x  r  t           t   ur  u   u   p  
      soundness stack boundedness
section  prove that  role r role chain  
   l ps   implies l s  
   ps stack bounded   lv s      
end  first show pda ps satisfies following liveness property 
computation ps pushes state qr stack  ps eventually pop
stack  then  show derivation ps moving state state fs takes
one five forms  call derivations regular  finally  show regular derivations
satisfy properties         
start showing pda ps satisfies following liveness property 
lemma     let hs              hsn   n   n arbitrary derivation
s      sn   fs       role r word r   then 
role lv t     lv s      n  si  it   ft     s i i 
s i qr   index j  i  n  exists
 a  sj   ft j    
 b  k  i  j   word k form k    k   k   r   and 
 c  sj     s i   j     i    j     j  
proof  let hs              hsn   n   n above      n     let
xi  r   t            t    ur   u    u    p  form derivation step ithat is  fix xi  arbitrarily one possibility  hsi      xi hsi     i     i  
holds  furthermore  role lv t     lv s   let set containing
index     n  si  it   ft   form    s i i  s i qr  
note that  index   due lv t     lv s   si  it   ft    sn   fs  
   

fithe complexity answering cqs gxqs owl   el kbs

  nthat is  hsi       hsi     i     i   occurs derivation  next 
induction n  show that  role   lv t     lv s   
j  i  n  exists satisfying properties  a  c  
base case     consider arbitrary role r     lv t     lv s  
consider interesting case      otherwise  properties  a  c  hold vacuously 
since lv t       si  it   ft    xi  r   t    t    ur   u    u    p   reverseinduction  i e   induction starting maximal element   next show
index satisfies required properties 
base case  let   max   xi  r   t    t    ur   u    u     si    it   ft  
i       thus        contradicts maximality i 
remaining possibility xi   p  implies si   ft   si     s i   i     i   
i       then  j   satisfies properties  a  c  
inductive step  consider arbitrary index properties  a  c  hold
      i  xi  r   t    t    ur   u    u     si    it   ft   i      
hence  ii   so  inductive hypothesis  index j exists satisfying properties
 a  c   otherwise  xi   p  si   ft   si     s i   i     i    i       j  
satisfies properties  a  c  
inductive step     consider arbitrary n properties  a  c  hold
role p r lv p   lv p     lv s  index ip   furthermore 
consider arbitrary role       lv t     lv s   consider interesting
case      otherwise  properties  a  c  hold vacuously  recall
v   r       r   lv  r           r   thus 
xi    ur   u    u     reverse induction   next show index satisfies
required properties 
base case     let   max   xi  r   t    t     si    it   ft   i      
thus        contradicts maximality i  xi  t    t    t    
si    ip   fp   role p lv p     lv t   lv p     lv s   furthermore 
    i   f     
i   form i      i  




i   sequence
  
zero one states  state occurring i  
 ir   fr   role
r level less   then  inductive hypothesis     index     exists
s    st       contradicts maximality i  finally  xi   p 
si   ft   si     s i   i     i    i       j   satisfies properties  a  c  
inductive step     consider arbitrary index properties  a  c  hold
index       i  consider possible forms xi  
xi  r   t    t     then  si    it   ft   i             inductive
hypothesis     index j exists satisfying properties  a  c  
xi   t    then  si     it  i     role t  lv t      lv t   
thus      it    inductive hypothesis     index    i      n  exists
s    ft      i     furthermore  k  i          k
form k    k   i   word k   r   finally  s             
definition           inductive hypothesis    
index j exists satisfying properties  a  c  
   

fistefanoni  motik  krotzsch    rudolph

xi   t    then  si     it  i     it  ft roles t  t 
lv t      lv t   lv t      lv t    thus      it    inductive hypothesis
    index     i      n  exists s     ft       i     furthermore 
k  i        k form k    k   i   word k   r  
finally  s        it          ft   then         it    again  inductive
hypothesis     index             n  exists s     ft              
furthermore  k                k form k    k        
word k   r   finally  s        ft           definition  
         so  inductive hypothesis     index j exists satisfying
properties  a  c  
xi   t    then  si     it  i     ft role t  lv t      lv t   
then      it    inductive hypothesis     index    i      n  exists
s    ft      i     k  i      k form
k    k   i   word k   r   finally  s      ft        
definition           so  inductive hypothesis    
index j exists satisfying properties  a  c  
xi   p  then  si   ft   si     s i   i     i    i       therefore  j   satisfies
properties  a  c  
next  role r   define notion regular derivations ps  
definition     set regular derivations p r inductively defined follows 
role r   role chain r   r  
sequr hi r        ur hf r       regular derivation p r  
sequ  hi r        u  hf r       regular derivation p r  
sequ  hi r           hf r   k   hi r   k       hf r   n   regular derivations p r   following regular derivation p r  
hi r           hf r   k    u  hi r   k       hf r   n  
next  consider arbitrary natural number n assume regular derivations
pt already defined    r role r     r   lv t   m 
then  role r     r   lv s         regular derivations ps defined
follows  s i  r   r   r  
seqr        r hfs       regular derivation ps  
seqt  v r         t  hfs       regular derivation ps  
seqt  v r           hfs   k     k       hfs   n  
regular derivations ps   following regular derivation ps  
          hfs   k    t    k       hfs   n  

   

fithe complexity answering cqs gxqs owl   el kbs

seqt  s  v r  his            hfs    k   regular derivation
ps      k       hfs   n   regular derivation ps   following
regular derivation ps  
       t  his            hfs    k    p   k       hfs   n  
seqt  s  s  v r  his        is  fs     hfs    k   is  fs regular derivation ps    his    k   fs     hfs    n   fs regular derivation ps   
following regular derivation ps  
     
his        is  fs
fs
his    k  
hfs   n  

 t 
    hfs    k   is  fs  p
fs  p
    hfs    n  


seqt  s  v r            hfs   k   regular derivation ps  
his    k   fs     hfs    n   fs regular derivation ps    following regular derivation ps  
          hfs   k    t  his    k   fs     hfs    n   fs  p hfs   n  
left show derivation ps moves pda start state
final state fs regular regular derivations satisfy required properties 
following lemma  show derivations leave particular word
bottom stack regular satisfy properties          subsequently 
show accepting derivation ps form 
lemma     role r   word r   derivation form
hs              hsn   n   n s      sn   fs        
 i  derivation regular ps  
 ii      n    i     lv s  
 iii 
    n  
proof  prove claim induction n n   
base case  n      consider arbitrary role r   word r   sequence
          hfs         i  definition    transitions cases  r    t     ur  
 u   move ps state state fs   transitions leave stack untouched 
        property  ii  holds  properties  i   iii   next consider
four different forms sequence may take 
         r hfs         i      r   regular derivation
ps case seqr  i  holds  finally        s  implies  
     
 iii  holds 
   

fistefanoni  motik  krotzsch    rudolph

         t  hfs         i      r   regular derivation ps
case seqt   i  holds  finally          moreover  case t  definition   
v r   
  hence   
     iii  holds 
         ur hfs         i     r r   regular
derivation p r case sequr  i  holds  finally        r  
implies  
       iii  holds 
         u  hfs         i     r   regular derivation p r
case sequ   i  holds  finally          hence   
   iii  holds 
inductive step  consider arbitrary n n  assume  i  iii  hold
role   r   word   r   derivation hs                   hs c    c   c   
length n form required lemma  furthermore  consider
arbitrary role r   arbitrary word r   arbitrary derivation
hs              hsn     n     n  

   

length n     s            sn     fs       n     let
xi  r   t            t    ur   u    u    p  form derivation step ithat is  fix xi  arbitrarily one possibility  hsi      xi hsi     i     i  
holds  next consider possible forms sequence might have  show
properties  i  iii  hold case 
 case       r   consider form hs           x  hs          i  since
s    i r   x   t    t    t    ur   u     r normalised  v   r
      r   x   ur  u   s    f r           since n     
hs           x  hs          occurs sequence x   t    t    u    p   since
s    f r r normalised  x   u    p   furthermore  since    
assumption form      x     p  hence  remaining possibility
x    u    case  u   definition    s    i r                  
next prove properties  i  iii  hold 
 i  sequr sequ    hs           x  hs          regular derivation p r  
inductive hypothesis  hs              hsn     n     n   regular
derivation ps   definition regular derivations  n        
then      regular derivation ps case sequ   
 ii  words           empty  inductive hypothesis         lv  r  
      n       therefore   i     lv  r   holds     n      
 iii  inductive hypothesis   r  
  n     cases  ur   u    either
            r   then   r
    n   holds 
 case        r k     n  exists hsk   k   k  t  hsk     k     k  
sk   fs   then  case  t   definition    v r  sk       k     k  
k     k   next prove properties  i  iii  hold 

   

fithe complexity answering cqs gxqs owl   el kbs

 i  inductive hypothesis  hs              hsk   k   k regular derivation
ps   definition regular derivations  k         since sk    
k     k     hsk     k     k       hsn     n     n  
form shown     shorter n     so  inductive hypothesis 
regular derivation ps   then      regular derivation ps case seqt   
 ii  inductive hypothesis          lv s         k   well
        lv s      k      n       therefore   i     lv s  holds
    n      
 iii  inductive hypothesis   
  k  
k   n     then 

v r k     k implies  
  n   holds 
 case        r       n  exists hs           t  hs               
s    fs   k     n  exists hsk   k   k  t  hsk     k     k  
sk   fs   then  let k largest indexthat is  assume   k exists
hsm      t  hsm     m     m   sm   fs   then  case  t  
definition    role s  level less s  s  v r  sk     is   
k     k   k     fs k   next prove properties  i  iii  hold 
 i  since sk   fs   inductive hypothesis hs              hsk   k   k
regular derivation ps   definition     k       since sk     is 
k     fs     lemma     index j  k      n  exists sj   fs 
j   k     furthermore  sj     fs j       j     j   prove
j       n      sake contradiction  assume j       n     consider
form transition hsj     j     j    xj    hsj     j     j   i  given
sj     fs     r   must xj    t    t    p   initial assumption 
xj      t    furthermore  maximality k  xj      t    finally 
since j           xj      p  thus  j       n      required  follows
sequence following form  k     k n     n  
     
      hfs   k      t 
his    k     k       hfs    n   n  p
hfs   n      
lemma        k      n     form         fs    
  
particular  words k  
n   empty  then  inductive hypothesis 
his    k     k       hfs    n   n regular derivation ps   
case seqt        regular derivation ps  
 ii  inductive hypothesis         k           lv s   furthermore      k      n             lv s     since lv s      lv s 
          fs           lv s   given n      
    n        i     lv s  
 iii  inductive hypothesis   
  k s   
k   n   given

 
s    k     k   n     n   obtain  
  n    

   

fistefanoni  motik  krotzsch    rudolph

 case        r       n  exists hs           x  hs                i 
s    fs x   t    t     hs           t  hs          i  then  case  t   definition    role s  level less s  s  v r  s    is   
                next prove properties  i  iii  hold 
 i  since s    is          lemma     j     n  exists sj   fs 
j       furthermore  sj     j       j     j   then  sequence
following form         
     
   t 
j  p
      hfs    j  
his       
  j     j       hfs   n     n  
lemma           j     form            
particular  words     j   empty  inductive hypothesis 
his              hfs    j   j regular derivation ps    since j        
inductive hypothesis    j     j       hfs   n     n  
regular derivation ps   case seqt        regular derivation ps  
 ii  inductive hypothesis      j      n               lv s  
furthermore         j             lv s     since lv s      lv s 
                    lv s   finally  since      
    n        i     lv s  
 iii  inductive hypothesis  s   
  j  
j   n    
given  
s  s          j     j    
  n    
 case        r       n  exists hs           x  hs                i 
s    fs   x   t    t     addition  hs           x  hs          x     t  
next consider remaining possibilities x    s      x     t    t    u    p 
cases  t     t     u     p  definition    furthermore  due     r  
x     ur   u    cases  ur   u   definition    moreover  assume x   r   t    
then  s    fs       cases  r   t   definition    since n    
    r   possibility hs           p hs          i  impossible
due     assumption form      hence  remaining possibility
x    t    case  t   definition    roles s  s  level less
s  s  s  v r  s    is                is  fs     next prove
properties  i  iii  hold 
 i  since s    is      is  fs     lemma     j      n  exists sj    fs 
j        furthermore  sj       is  j       fs   j       j    again 
lemma     j   j       n  exists sj    fs  j    j       furthermore 
sj       fs j         j       j    next  prove j        n     
sake contradiction  suppose j        n     consider form
hsj       j       j      xj     hsj       j       j     i  given sj       fs  
must xj      t    t    u    p   however  assumed xj        t    t   
    r   xj        u    finally  since j             xj        p 
   

fithe complexity answering cqs gxqs owl   el kbs

therefore  j        n      required  sequence following
form          j       j   n     n  
     
   t 
his       
      hfs    j    j   p
his    j       j         hfs    n   n  p
hfs   n     n  
lemma            j     word    form           is  fs    
particular  words     j    empty  then  inductive hypothesis 
his              hfs    j    j  regular derivation ps   
similarly  lemma         j       n      form
          fs     particular  words j       n   empty  then 
inductive hypothesis  his    j       j         hfs    n   n
regular derivation ps    case seqt        regular derivation ps  
 ii  inductive hypothesis         j               lv s     since
lv s      lv s            is  fs           lv s   similarly 
inductive hypothesis      j       n             lv s     since
lv s      lv s            fs           lv s   since      
    n        i     lv s  
 iii  inductive hypothesis  s   
  j  s   
j     n   given

 
s  s            n     n   conclude  
  n    
possibilities form      claim lemma holds
derivation form 
finally ready show pda ps satisfies properties         
lemma     role r role chain  
   l ps   implies l s  
   ps stack bounded   lv s      
proof  definition ps   transitions resulting case p definition  
ones popping elements stack  never pop symbol   hence  point
accepting derivation ps   stack content form    i    then 
two claims follow immediately lemma    
      completeness
next prove encoding complete  thus proving theorem   
lemma     role r role chain   l s  implies
l ps   

   

fistefanoni  motik  krotzsch    rudolph

axiom type
 t  
vt
 t  

 t  

 t  

 t  

derivation
 t  hft  

  

hit  

 

vt

hit  
hit  

    
    

t  v

hit   t      
hit    t      
hit  
    

t  t  v

hit   t  t      
hit    t  t       it  ft
hit   
t      
ft
  
hft  
 

t  v

hit   t      
hit   
t      
hft  
    




 r
 r

 t 
  r
 r
 t 
  r
  r


 r
ft   r


    



hft       
hft  
    




 t 

hft        
hft  
    




 p

hft    t       it  ft  p
hft   
    
ft   p
hft   t      
hft   
    

 t 
ft   p

table    definition derivation     depending form axiom v  
proof  consider arbitrary role r   following  role chain   write
 

 
  s  furthermore  n    write  
role chains            
exist  
   
 
    definition l s  

l s  natural number n exists  
  induction

n  next show  
implies l ps   
 

base case  let      then   
s  consider two cases depending
form role r  
   r   case  ur  definition    hi r    r    ur hf r     i 
r     r    case  r  definition      s   r hfs     i 
either case l ps    required 
inductive step  consider arbitrary n assume that  role chain  

 
      l ps    show holds      then 
consider arbitrary role chains             m    
   
 
 
m    
definition relation  
  role r role chains          exist role chain
form           role chain m   form m            

 
  since  
       inductive hypothesis       l ps   
sequence hs              hsn   n   n ps exists s    sn   fs   furthermore 
    n     finally           n     exists index
    n         i          furthermore  j     i   role chain


  
j form j   
j role chain j r   next  consider form
xi hsi      xi hsi     i     i   i  definition    transitions cases  r   ur 
read symbols input  xi  r  ur   show lemma holds case 
   

fithe complexity answering cqs gxqs owl   el kbs

 case    consider case xi   r   then  si   si     ft  
  i     r     r    due  
    r   v r  then 
following derivation ps

  
  

hs   
          hsi      

   



   

 the derivation table   v    
  

hsi       i       hsn     n

    

derivation     defined table   depending form axiom v r 
 case    consider case xi   ur   then  si   i r si     f r  
  i   r   then  following derivation ps

  
  

hs   
          hsi      
  

 the derivation seq              



  

hsi       i       hsn     n
derivation seq              inductively defined follows 
 
hi r         u  hf r       
   
  
seq         
  
  
  
hi r      ur hf r      u  seq         p  

    
    
    

    

therefore  either case       l ps    required 

   polynomial space bcq answering algorithm elro 
elro  knowledge base k translated set first order horn clauses 
boolean cq q k answered evaluating q so called canonical model
model homomorphically embedded model k  canonical
models usually obtained using chase  many different chase variants studied
literature  producing different  homomorphically equivalent  canonical
model  johnson   klug        marnette        cal  gottlob    kifer        baget  leclere 
mugnier    salvat         paper  introduce variant call consequencebased chase   possibly infinite  set assertions ik produces k call
universal interpretation k  compute ik   consequence based chase initialises ik
contain abox k  well assertions  a  a    c  a    r  a  b  individuals
b occurring k  then  iteratively extends ik using chase rules  slightly unusual
aspect chase variant considers axioms entailed  and contained
in  k  example  ik point contains assertion a w  k    v s b holds 
ik extended assertions s w  w    b w    w  fresh term  term w 
said auxiliary type s  b concept type b  bcq answering algorithm
present section based checking consequences k  chase variant
makes proofs simpler  example    illustrates aspects 
example     let k   ht   r  elro  kb  contains axioms          
r contains role inclusion      
 a  v s a
   

    

fistefanoni  motik  krotzsch    rudolph



b





  s 

  s 






  t  b

r



b

  s  b







  s  c

os a







ot b

os b

r




os c



s 

s 

 
t  b

universal interpretation

compact interpretation

figure    universal interpretation compact interpretation k
v s a

    

 b  v s a

    

 b  v t b

    

 b  v s c

    

c v t b

    

c v r  b 

    

st vs

    

figure   shows universal interpretation ik k  assertions involving  c  r
shown clarity  edges obtained via role inclusions dashed  remaining edges
solid  apart dotted edges  denote repetition solid edges  black edges
obtained using conventional chase variants  whereas light grey subbranches ik
caused axioms entailed by  occurring in  k  auxiliary terms labelled
using integers  terms type shown next term  universal interpretation ik
viewed family directed trees whose roots individuals k
solid edges point parents children individuals k  axiom      makes ik
infinite  decision procedure bcq answering cannot simply materialise ik
evaluate query it  instead  finitary representation ik needed 
axioms                   k     b  v s b  then  since  b  b  ik  
consequence based chase ensures  s b      b     ik holds well  contrast 
commonly considered chase variants ensure  s b      b     ik k
contain axiom  b  v s b 
rest section  present first worst case optimal algorithm decides
k    q given arbitrary regular elro  kb k boolean cq q k  towards
goal  section     review existing approaches answering cqs dls discuss
   

fithe complexity answering cqs gxqs owl   el kbs

techniques provide optimal procedure elro    section    
discuss intuitions behind algorithm  section     introduce algorithm
formally show runs polynomial space combined size k q
polynomial time size k  section     prove algorithms correctness 
    existing approaches answering cqs
techniques answering conjunctive queries dl knowledge bases developed thus far
broadly classified following three groups 
first group consists automata based approaches dls horn shiq
horn sroiq  ortiz et al          sh  eiter  ortiz    simkus      a   fragment elro  obtained disallowing universal role  reflexive roles  self restrictions  krotzsch et al          techniques  however  require constructing automata
whose size exponential size knowledge base 
second group consists rewriting based approaches  roughly speaking  approaches rewrite query and or tbox another formalism  usually union
cqs datalog program  relevant answers obtained evaluating
rewriting abox  rewriting based approaches proposed members
dl lite family  artale et al         calvanese et al          dls el  rosati 
       elhio  perez urbina et al         mora  rosati    corcho        hornshiq  eiter  ortiz  simkus  tran    xiao      b   members datalog family  virgilio  orsi  tanca    torlone         name few  rewriting approach 
however  supports nominals role inclusions  moreover  common shortcoming
rewritings exponential query and or tbox size  approaches
may use exponential space 
third group consists approaches based particular interpretation k
call compact interpretation  figure   shows interpretation kb k
example     finitely approximates universal interpretation using individuals
form os b represent auxiliary terms type s  b  compact interpretation thus
materialised space polynomial  k   used answer instance queries
test atomic subsumptions k  baader et al         krotzsch         materialising
compact interpretation lies core many reasoning algorithms el variants 
natural try use interpretation answering cqs well  since compact
interpretation model k  cq maps universal interpretation maps
compact interpretation well  however  example    shows  converse
necessarily hold 
example     let k example     let q    q    q  following bcqs 
q    x  r x  b 

q    x  s a  x  s b  x 

q    x   b  x  s b  x 

compact interpretation k shown figure    one see  obtained
universal interpretation merging terms type s  b onto individual os b  
query q  mapped onto compact universal interpretation  queries
q  q  mapped onto compact interpretation  thus  evaluating q  q 
compact interpretation produces unsound answers 
   

fistefanoni  motik  krotzsch    rudolph



b

 a 

b  b 

ax

b

r
r d  



t b
 




s b  


r





r a
 






  t b






t b
 

p





t b



 


  s b





p b  






t b   

universal interpretation


   s b



z b

skeleton q

figure    universal interpretation k skeleton q
remedy  combined approaches developed first evaluate query
compact interpretation filter results eliminate unsound answers 
approaches developed members dl lite family  kontchakov et al  
      lutz  seylan  toman    wolter        el family  lutz  toman    wolter 
      stefanoni et al         dls  datalog family  gottlob  manna    pieris 
      rule based languages  particular  stefanoni et al         developed filtering
step applicable dl elhodr
  step breaks k contains role inclusions 
query q  example    mapped onto compact interpretation mapping
atom s b  x  dashed edge  i e   edge obtained via role inclusions   moreover  q 
tree shaped  filtering step stefanoni et al         identify
match unsound  problem intuitively understood follows  unfolding
query       query q  essentially asks whether role chains   l s    l t  
exist label path solid edges ik starting b  compact interpretation 
satisfied         x mapped individual ot b   individual
ot b   however  represents distinct terms     ik   hence  although   connected
b via     connected b via     role chains     satisfy query q   
words  compact interpretation small represent relevant conditions 
    intuitions
worst case optimal procedure bcq answering elro  shown algorithm  
page      essentially extends refines algorithm krotzsch et al         
explain underlying intuitions using knowledge base shown example    
example     let k elro  knowledge base whose tbox contains axioms         
whose rbox contains role inclusions          
 a  v r a
v t  b 
   

    
    

fithe complexity answering cqs gxqs owl   el kbs



s  x x

fs

  x fs x



t  x x

ft

  x x

figure    transitions r corresponding axioms         
avd

    

 b  v t b

    

 b  v p b

    

b v s self

    

b v t b

    

vt

    

st vs

    

moreover  let q following boolean cq k 
q   x  y  z  d x   x  z  s y  z 

    

figure   shows universal interpretation ik k  notation example    
solid looping edges auxiliary terms concept type b obtained axiom       one
see k    q holds  example  following substitution embeds q ik  
   x           z     

    

algorithm uses pda encoding rbox described section    transition
function r axioms          shown figure    notation example   
note figure   contained figure   
must prove existence substitution mapping q ik   substitution
map binary atoms q dashed edges figure    dashed edges introduce
shortcuts terms ik   dashed edge unfolded path consisting
solid edges using role inclusions k  solid paths ik two
types  auxiliary paths involve auxiliary terms  whereas nominal paths require moving
least one individual  instance  edge        unfolded path
  connecting   b  b         contrast  edge s      
unfolded path   connecting   itself       algorithm
uses pdas transition function figure   represent binary atom
q sequence binary atoms mapped corresponding solid path ik  
interpretation ik   however  infinite  space possible substitutions infinite 
hence  prove existence substitution mapping q ik   cannot simply
enumerate them  use algorithm   instead 
   

fistefanoni  motik  krotzsch    rudolph

line   check whether k unsatisfiable  so  k    q holds trivially  next 
line   guess substitution continue checking k     q   thus  step takes
account variables could mapped individuals  two variables could
mapped term  example  guess identity mapping
 y   step    guess finite structure  called skeleton  q   represents
 possibly infinite  set substitutions mapping variables  q  distinct auxiliary
terms ik   figure   shows skeleton query example     skeleton vertices
individuals k variables  q   arranged forest whose
roots individuals  moreover  vertex v assigned atomic concept  v  
step  skeleton represents substitution  if any  satisfying following
two properties 
   maps variable x term concept type  x  
   edge hv  v   s   v     descendant  v  ik  
next extend conditions prune set substitutions  goal
leaving substitutions compatible  q that is  embed  q  ik  
establish compatibility unary atoms  q  line    particular  consider
atom d x   q   property      substitution represented skeleton
figure   maps variable x term concept type  x    a  implying a   x   ik
holds  then  since k     x  v holds  know d   x   ik holds well  thus 
atom d x  satisfied substitution represented s 
contrast  cannot establish compatibility binary query atoms using entailment
checking only  vertex labels relative position vertices sufficiently
describe substitutions  example  substitution
     x           z      

    

satisfies properties              x      z     ik  
prune substitutions  lines     algorithm   guess binary atom
 q  unfold sequence solid steps ik   solid paths ik go
nominals auxiliary terms only  two possibilities accounted
guessing line    moreover  skeleton already constrains relative positions
query terms  represent unfolding binary atom labelling edge hv  v  
set l v  v     bounded stack pdas transition function figure  
substitution represented satisfies following property 
   pda p l v  v      nonempty role chain l p  exists labelling path
ik solid edges  v   v     
next illustrate label edges substitutions satisfying properties
       compatible binary atom  q  
 x  z   must ensure that  substitution represented s  role chain
l t   exists connecting  x   z  using solid edges  since relative positions
 x   z  ik determined shown figure    path must connect
 x  b  connect b  y   finally connect  y   z   addition 
assume individuals occur paths b  y    y   z  
   

fithe complexity answering cqs gxqs owl   el kbs

 r


r

 a 

r

b




s 

t  p


 b 

start

b



start

figure    left hand side  walking finite automaton wfa a   b    transitions involving  c  r shown clarity   right hand side  stationary finite automaton sfa b 

path  x   z  involves individuals b visits b once 
absorb path segments subpath  x  b  thus  check
existence setting v    au   b lines     no guessing possible line  
case  splitting lines     path three subpaths  particular 
line    guess states s    s    s    ft line    guess stack words        
    following properties 
 i  subpaths  x  b described pda pt  whose start state stack
  respectively  final state stack s      respectively 
 ii  subpaths b  y  described pda pt  whose start state stack
s      respectively  final state stack s      respectively 
 iii  subpaths  y   z  described pda pt  whose start state stack
s      respectively  final state stack s      respectively 
know terms ik variables z mapped to  cannot
check existence paths  ii   iii  independently  therefore  add line   
pdas pt  pt  constraints edges hb  yi hy  zi s  respectively  edges
thus accumulate constraints moves auxiliary terms must satisfy  later
shall explain lines      check constraints and  check passes 
know map z auxiliary terms whose concept types  y 
 z   respectively  contrast  path  i  finishes individual 
check existence path independently constraint  end 
construct walking finite automaton wfa a   b   shown left hand side figure
   wfa a   b   describes moves ik terms concept type  x   
individual bthat is  l wfa a   b    term w concept type
role chain connecting w b ik via solid edges  then  line    check
whether intersection languages wfa a   b   pt  empty  wfa a   b  
fa pt  pda  test emptiness intersection languages
polynomial time  hopcroft et al          example  guess s    s    s    ft  
   

fistefanoni  motik  krotzsch    rudolph

thus  pt  accepts language   b connected    y  solid edge
labelled p   adding pt  constraint edge hb  yi ensures substitution       
satisfy property     
s y  z   must ensure that  substitution represented s  role chain
l s  exists connecting  y   z  using solid edges  even though z
descendant s  line   could guess v    au   b  connects  y  b
then  without going individuals  connects b  z  via  y   rest
paragraph  however  consider case connects  y   z  directly 
since possibility example  one see figure    therefore 
line    guess v      y  then  path  y   z  could first loop  y 
due self restrictions  must actually move  y   z   finally could
loop  z   reasons discuss following paragraph  absorb latter loop
constraint added edge hy  zi  however  check existence former loop
independently  therefore  lines     split two subpaths  particular 
line    guess states s  s    fs   line    guess stack words      
following properties 
 i  looping  y  described pda ps  whose start state stack
  respectively  final state stack s      respectively 
 ii  subpaths  y   z  start move  y   possibly involve
looping  z   described pda ps  whose start state stack s     
respectively  final state stack s      respectively 
previous case  check  ii  adding ps  constraint edge hy  zi s 
furthermore  check existence path  i  constructing stationary finite
automaton sfa b  shown right hand side figure    sfa b  describes
possible loops terms concept type  y    b  is  l sfa b  
term w concept type b role chain corresponding  possibly
empty  loop w  then  line    check whether intersection languages
sfa b  ps  empty  example  guess s    s    fs   thus ps  accepts
language   whereas ps  accepts language  
line     skeleton represents substitutions compatible
atoms  q   must still show least one substitution realised
universal interpretation ik   end  apply algorithm   page    
edge hv  v   skeleton  thus check whether terms  v   v     ik exist
satisfy properties        pdas l v  v      roughly speaking  solve
problem running pdas parallel lines     algorithm    however  cannot
materialise ik   exploit property consequence based chase procedure  term
w concept type connected term w  concept type b ik using solid
edge labelled k    v s b  furthermore  concept type w fully
describes solid paths descendants w  need keep track actual
position ik   instead  use variable concept keep track current terms concept
type  thus  line   check existence edges ik via entailment checking  that 
pda  line    guess state stack pda  line    check
whether pda perform move  line    actually move pda  due
   

fithe complexity answering cqs gxqs owl   el kbs

self restrictions reflexive roles  however  pdas need move synchrony 
move solid edge  pdas independently loop current term 
end  line    guess state s  stack   pda moves
looping  line    check whether pda move state stack
state s  stack   using role chain compatible concept type term
pda moving into  given stationary finite automaton sfa d  
pdas required loop  fa sfa d  accepts empty word  algorithm   thus checks
loops move  line    algorithm   necessary  lines   
take account pdas nondeterministic initially make
several  transitions  note explicit check  transitions required initially
since line    allows possible  transitions move along solid edge  finally 
ensure termination algorithm   observing that  since stack pda l v  v    
bounded  number current configurations pda exponential 
number distinct tuples current pda configurations exponential well 
hence  algorithm repeats computations exponentially many steps 
thus obtain nondeterministic decision procedure running polynomial space using
binary counter stop computation distinct configurations explored 
constraints added previous paragraphs  one check algorithm  
returns true edges s  hence  k     q  holds  thus k    q holds well 
    formalisation
formalise intuitions previous section  towards goal  fix
normalised elro  kb k   ht   r  ai regular rbox r  let qr   r   r
specified definition    let dr depth r specified section   
start formalising notion skeleton boolean cq 
definition     skeleton boolean cq q    y     y   triple   hv  e 
following components 
   v   ik  y set vertices 
   e v  y set edges directed graph hv  ei forest whose
roots precisely elements ik  
      y     c   ck function maps existential variables q atomic
concepts  convenience  extended v  v      v  v ik  
path nonempty sequence  distinct  vertices v            vn n   and 
    n     hvi   vi   e 
please observe that  k normal form  exists least one individual occurring
k thus v      next generalise notion pda encoding rbox r
definition   allowing arbitrary start final states well arbitrary start
final stacks size dr   generalised pda used algorithm
implement splitting operation mentioned section     
definition     states s  s  qr words     r    dr       dr  
generalised pda r given pda s    s           hqr   r   r   r   s    s      i 
   

fistefanoni  motik  krotzsch    rudolph

following definition introduces automata one use succinctly represent
axioms logically follow k 
definition     let b basic concepts  walking finite automaton
b given wfa a  b     hq  r   w   a  bi q w follows 
q     c   ck nk  
w transition function containing w  c  s  role r
states c q k    c v s d 
stationary finite automaton given sfa a     h a   r     a  ai
contains  a  s  role r k    v s self k    v s 
boolean cqs answered nondeterministic procedure entails shown algorithm    uses auxiliary procedure exist shown algorithm    following
theorem states entails k  q  decides k    q  proof given section     
theorem     let q boolean cq k  then  k    q nondeterministic
computation exists entails k  q  returns true 
finally  determine complexity algorithm entails  towards goal
first determine complexity auxiliary function exist 
lemma     function exist a  b   pj   pda sj   j   s j   j        j m   implemented uses space polynomial  k  and  rbox r fixed  runs
time polynomial  t      a  
proof  consider arbitrary a  b  pj   pda sj   j   s j   j    stated above  let
algorithm    let   derivation relation corresponding r   definition
generalised pdas   j   dr  j    dr j     m  
proposition    using polynomial time one compute pdas accepting languages
ldr  pda sj   j   s     ldr  pda s    s         lines       therefore  checks lines
     implemented use time  and therefore space  polynomial
 k   hopcroft et al         ch     
space usage algorithm    please observe function stores following
information computation step 
 a  array state length state j  qr j     m   array stack
length stack j  r  stack j   dr j     m  
 b  generalised pda line   
 c  generalised pda stationary automaton line    
 d  concept concept  a   c   ck line   
 e  binary counter k   k  
 f  depth dr r  atomic concept   c   ck   role r  
   

fithe complexity answering cqs gxqs owl   el kbs

algorithm    entails k  q 
 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  

k inconsistent return true
guess substitution dom      y rng    y ik
guess skeleton   hv  e   q 
atom a t   q  exists k      t  v return false
foreach hv  v   e let l v  v       
foreach binary atom s t  u   q 
let au unique individual u reachable au
guess v   t  au   u reachable v 
let v            vn unique path vn   u
guess states s            sn qr sn   fs
guess words            n r n    i   dr     n 
foreach     n  let l vi    vi      l vi    vi    pda si    i    si     
v 
l wfa  t    v      l pda is     s           return false
else
l sfa  v      l pda is     s           return false
foreach hv  v   e
exist  v    v      l v  v      return false
return true

algorithm    exist a  b   pj   pda sj   j   s j   j        j m  
 
 
 
 
 
 
 
 
 
  
  
  
  
  
  
  
  
  
  

let concept    let          ck     qr  m   r    dr  m
j    
guess state qr word r    dr
  ldr  pda sj   j   s     return false
set state j     stack j    
guess k n   k
r     k
guess r   c   ck
k     concept v s d  k    v  a  ik return false
j    
guess  s  s    qr        r    dr       dr
hstate j   s  stack j i    hs    return false
l sfa d   ldr  pda s    s           return false
set state j     s  stack j      
set concept   
concept    b return false
exists index j     m  state j     s j stack j     j 
return false
return true

   

fistefanoni  motik  krotzsch    rudolph

definition dr   dr linearly bounded number axioms occurring r  hence  need o m  r   space store two arrays  furthermore 
need o m  k   space store counter k using binary encoding  definition
    size sfa d  polynomial  k   definition    size pda s    s        polynomial  r   overall  space needed store required information polynomial
 k   finally  following krotzsch         realise check step   polynomial
time  thus  exist implemented uses space polynomial  k  
next  assume rbox r fixed  dr   qr   r   r fixed
well  moreover  bounded size r fixed  linear
size a  thus  number alternatives nondeterministic step line  
algorithm   fixed  lines    require time polynomial  t      a   furthermore 
instead guessing k using nondeterministic step    repeat lines    
k     m    requires linear number iterations  show lines    
implemented run polynomial time  first define three sets used
perform checks lines           
 hs  c  di r  ck nk   c       k    c v s d ik   k     v  a       
 hs  pda s    s       i   r hs  s    hs        i      
 hc  pda s    s       i   c ck   c   l sfa c   ldr  pda s    s                  
given r fixed  sets computed time polynomial size
a  next show implement for loop steps     use space logarithmic
size   a  sets equations           space usage lines     
computation step for loop store information points  a  f  above 
since r fixed  however  points  a  c  require constant space  furthermore 
checks lines           performed lookup sets           storing
sets using suitable binary encoding using binary index sets 
check implemented using logarithmic space  finally  ck linear
size a  store counter k  concepts concept  role using binary
encoding  overall space function needs store logarithmic  t      a  
size sets           thus  steps     require nondeterministic logarithmic space 
well known implies steps     implemented run polynomial
time  finally  steps      clearly require polynomial time  consequently  function exist
implemented runs time polynomial  t      a  fixed r 
ready establish complexity function entails k  q   section  
shall show function worst case optimal combined data complexities 
theorem     q bcq k  function entails k  q  implemented
   uses space polynomial input size 
   rbox r fixed  runs nondeterministic polynomial time size
tbox   abox a  query q 
   rbox r query q fixed  runs  deterministic  polynomial time
size tbox abox a 
   

fithe complexity answering cqs gxqs owl   el kbs

proof  let q    y    y   boolean cq k 
shown proposition    one compute lines       pda accepting language
ldr  pda is     s         polynomial time  checks lines       require time
 and therefore space  polynomial  k   hopcroft et al         ch      moreover  checks
lines     require time polynomial  k   krotzsch        
     please observe function entails specified algorithm   stores
following information computation step 
substitution dom      y rng    y ik  
skeleton   hv  e   q  
path v            vn s  sequence states s            sn qr   sequence words
            n r  i   dr     n  
function l mapping edge hv  v   e set generalised pda  and 
walking automaton wfa  t    v     stationary automaton sfa  v     
definition skeleton  q   need space polynomial size q k
store s  moreover  length longest path given number variables
occurring  q   store sequences vertices  states  words space
polynomial  q   k  well  also  set l v  v     contains pdas 
number binary atoms occurring  q   then  lemma     entails
implemented uses space polynomial input size 
     assume rbox r fixed  lemma     fixed rbox r  step   
implemented runs time polynomial  t      a   clearly  steps
algorithm   implemented run nondeterministic polynomial time size
tbox   abox a  query q  consequently  fixed rbox r  function entails
implemented runs nondeterministic polynomial time size tbox
  abox a  query q 
     assume rbox r query q fixed  dr   qr   r   r
fixed well  given number variables occurring q fixed  number
guessing steps required steps     fixed  also  number alternatives
steps linear  t      a   thus  steps     require polynomial time  furthermore 
maximum number iterations for loop steps     fixed length
longest path fixed  thus  number guessing steps lines      
fixed  addition  number alternatives guessing steps lines          
fixed well  therefore  steps     require time polynomial  t      a   finally  since
query fixed  maximum number iterations for loop steps      
fixed so  lemma     steps       require time polynomial a 
therefore  entails implemented runs time polynomial  t      a 
fixed r q 

   

fistefanoni  motik  krotzsch    rudolph

    proof theorem   
prove function entails k  q  indeed decides k    q  towards goal 
start proving correctness function exist  introduce universal
interpretation k  and  finally  show entails sound complete 
      correctness exist
following proposition proves correctness function exist algorithm   
lemma     function exist a  b   pj   pda sj   j   s j   j        j m   returns true
exist natural number k    roles s            sk   basic concepts a            ak
a    ak   b  role chains  j i   j     m      k  
following conditions hold     k  j     m  
   ik   k    ai  v si  ai k     ai v  a  
   role occurring j i   k    ai v t self k    v  
   s  j   sk j k ldr  pj   
proof  consider arbitrary a  b  pj   pda sj   j   s j   j    stated lemma  moreover  let   derivation relation corresponding r  
   assume nondeterministic computation exist function
returns true  let k n guessed step    show for loop steps    
satisfies following invariant  iteration r  exist roles s            sr   basic
concepts a            ar   and  j     m   role chains j             j r a    a 
ar   concept  following holds     r  j     m  
 i  k    ai  v si  ai and  ik   k     ai v  a  
 ii  role occurring j i   k    ai v t self k    v  
 iii  s  j   sr j r ldr  pda sj   j   state j   stack j    
base case  first iteration loop  i e   steps    r      
concept   a  ldr  pda sj   j   state j   stack j   j     m  
properties  i  iii  clearly hold 
inductive step  consider arbitrary iteration r     k    assume properties
 i  iii  hold end iteration r  show true iteration r     
inductive hypothesis  exist roles s            sr   basic concepts a            ar   and 
j     m   role chains j             j r a    a  ar   concept properties
 i  iii  hold  let role sr     atomic concept ar     guessed step   
clearly  k    concept v sr    ar   k     ar   v  a  ik  
required property  i   furthermore  consider arbitrary j     m   let s  s     
  guessed step     let state j  stack j  end iteration r 
then  hstate j   sr     stack j i   hs    due step     furthermore  due step     role
chain j r   exists j r   l sfa d   ldr  pda s    s          definition   
stationary automata  role occurring j r   k    v t self
   

fithe complexity answering cqs gxqs owl   el kbs

k    v   required property  ii   finally  let state j  stack j  specified
step     s  j   sr j r sr   j r   ldr  pda sj   j   state j   stack j    
property  iii  holds 
step    ensures concept   b  furthermore  steps      ensure state j    s j
stack j    j  j     m   pda pj accepts s  j   sk j k   thus  properties
       lemma hold  required 
   let s            sn roles  let a            basic concepts a      b 
let j i role chains satisfying properties        lemma  derivation
s  j   sn j n pda pj following form  sj n     s j j n     j   
hsj   s  j   sn j n   j  
hs j    

hsj     s  j   sn j n   j    

j   s  sn j n  

hsj     s  j   sn j n   j    

 
j  


    



    



    

       

    

 

     
hs j i  

hsj i   si j i sn j n   j i  

j i si   sn j n  

hsj i     si   j i sn j n   j i    
hs j n  

hsj n   sn j n   j n  
hsj n       j n  

j n  

    



 
j i

 
j n


 



 

    
    

transition           special sense allows pj make arbitrary
number  transitions  rest derivation regular consists reading si
j i   thus  sj i s j i states pj after  respectively  reading si  
  respective stacks  property     lemma     
j i j i
j i
r
 
 j i   dr  
let xi   hai   s  i     i           sm i   m i i  pda   qr   many different
p r
 r    many difstates     ck   different elements   c  ck   furthermore  d   
pdr
ferent stacks length dr    r       dr           r     r    dr  
consequently  distinct tuples  thus  k  
xk   xn     then  ak   b  furthermore  j     m   sj k   sj n     s j
j k   j n     j    s  j   sk j k ldr  pj   
easily construct nondeterministic computation exist follows 
step    j let   sj     j     clearly  condition step   satisfied 
r for loop lines      proceed follows 
step   let   si   ai   respectively  clearly  condition step  
satisfied due property     
       
j     m   let   s j r   s    sj r       j r
j r     clearly 
condition step    satisfied due form derivation  furthermore 
condition step    satisfied due property     definition    

finally  conditions steps       satisfied due way chose k 
therefore  function exist returns true step    

   

fistefanoni  motik  krotzsch    rudolph

rule
 cr  
 cr  

 cr  

 cr  
 cr  

 cr  

 cr  

precondition
k    a  u a  v b
 a   w   a   w  
k    v s b
k    b v  a  ik
a w 
k    v s b
k     b v  a  ik
a w 
k    s a v b
 s w  w     a w    
k    s self v b
s w  w 
role simple
k    v s self
a w 
role simple
l s 
 w  w   

conclusion
b w 
s w  a   b a 

s w  fs b  w    b fs b  w  
 c  fs b  w     r  fs b  w   fs b  w  
 r  fs b  w   w    term w  occurring
 r  w    fs b  w   term w  occurring
b w 
b w 

s w  w 

s w  w   

table    rules consequence based chase
      consequence based chase universal interpretations
prove entails k  q  sound complete  interpret k using forest shaped
universal interpretation described section      towards goal  next define
auxiliary notions  define universal interpretation  and  finally  prove two properties interpretation 
universe k set terms built individuals occurring k
unary function symbols form fs a r ck   since k normalised 
universe k nonempty  fact ground atom constructed using predicates
occurring k terms universe k  role chain   s  sn   terms
w w    set facts i  write  w  w     not necessarily distinct  terms
w   w            wn   w  exists si  wi    wi       n   set facts
entails boolean cq q    y     y    written    q  substitution exists
dom       y  q  i  universal interpretation ik k defined follows 
definition     chase rule table   applicable set facts preconditions
rule satisfied  contain conclusions rule  consequencebased chase  often chase  k sequence sets facts i    i         
i      a  a    c  a    r  a  b     a  b  ik  

    

and     set ii   obtained extending ii conclusion one  arbitrarily
chosen  chase rule applicable ii   ii     ii chase rule applicable ii  
   

fithe complexity answering cqs gxqs owl   el kbs

sequence must fairthat is  derivation rule applicable ii specific
precondition  j exists suchsthat ij   obtained ij applying rule
mentioned precondition  set ik   ii universal interpretation k 
since k normal form  k      a  v  b  distinct individuals
b ik   hence  one individual ik exists rule  cr   k    b v  a  
that  straightforward see ik independent order
chase rules applied  call ik universal interpretation k  moreover 
due fairness  derivation rule applicable ik is  chase rule
table   either preconditions rule satisfied ik   ik contains
conclusions rule  finally  well known that  k consistent  ik
homomorphically embedded model k  krotzsch et al          consequently 
universal interpretation ik used answer arbitrary boolean cqs k 
fact     boolean cq q  k    q k     c v c ik    q 
next  show ik relates axioms entailed k  end  let
following function mapping term w universe k basic concept 
 
 w  w
 w    

w form w   fs a  w   
proposition     universal model ik satisfies following properties 
   a w  ik   k     w  v a 
   s w  w    ik   nonempty role chain     s    m  sm
l s  terms w            wm universe k w    w wm   w 
exist
 a      m   either wi ik   atomic concept ai   c   ck exists
wi   fsi  ai  wi    k     ai v  a  individual ik  
 b      m   k     wi    v si   wi   
 c      m  role occurring   k     wi   v t self
k    v  
proof  let i    i          chase sequence k  show induction rule applications properties         satisfied a w  s w  w     
respectively  additionally satisfies following property 
   term w occurring   k    x  w  x  
definition i   cr    terms w w  occurring  
clearly   c  w    r  w  w      r  w    w    
base case  consider i    note term w occurring i  individual
 w     w   consider a a  i    either a a  a     a      c  
k     a  v a  property     holds  furthermore  consider s a  b  i   
   

fistefanoni  motik  krotzsch    rudolph

s a  b     r   k     a  v s  b   property     holds w    a 
w    b    s  finally  property     holds k    x  a  x  ik  
inductive step  assume satisfies properties         considering
derivation rule  assume rule applicable shown table   
show properties        hold conclusions rule  note rule  cr  
affect property      explicitly consider properties hold vacuously 
 cr   inductive hypothesis  k     w  v a  k     w  v a   
implies k     w  v b  required property     
 cr   inductive hypothesis  k     w  v k    x  w  x  
clearly imply k     w  v s b k    x b x   moreover   a     a   k     a  v b 
property     holds  finally  since k     w  v s  a   property     holds w    w 
w    a    s 
 cr   let w     fs b  w   inductive hypothesis  k     w  v
k    x  w  x   k     w  v s b k    x b x   moreover   w       b 
k     w     v b  k     w     v  c   k    x  w     x   required properties    
     respectively  property      consider role assertions derived rule 
s w  w      note k     w  v s  w     k     b v  a  ik  
property     holds w    w  w    w       s 
 r  w     w      clearly  property     holds w    w          r  
 r  w     w    term w  occurring   let individual w  rooted
in  then   r  a  w    so  inductive hypothesis  role chain l  r  
terms   w            wm   w  exist satisfying properties  a  c   since k    x  w     x  
k     w     v  r   a   thus   r w     w            wm satisfy property     
 r  w    w     term w  occurring   then   r  w    w  so  inductive
hypothesis  role chain l  r   terms w    w            wm   w exist satisfying
properties  a  c   then   r w            wm   w   satisfy property     
 cr   inductive hypothesis  k     w    v a  moreover  terms w            wm
w    w wm   w  nonempty role chain     s    m  sm
l s  exist satisfying properties  a  c   definition l s   k    v s 
together entailments properties  b   c   k     w  v s  w    
then  k     w  v s a  implies k     w  v b  required property     
 cr   inductive hypothesis  nonempty role chain l s  exist satisfying
properties  a  c   moreover  k    v definition l s   role simple 
        therefore one following two forms 
          property  c   k     w  v t self k    v  
furthermore  due k    v s  k    v s  then  k     w  v s self 
k     w  v b holds  required property     
  s    terms w  w  satisfying property     equal w  moreover 
w  form fs   a   w   w ik   furthermore  property  b 
   

fithe complexity answering cqs gxqs owl   el kbs

k     w  v s    w   together w ik   k     w  v s   self  finally 
due k    v s  k    s  v s  then  k     w  v s self 
k     w  v b holds  required property     
 cr   inductive hypothesis  k     w  v a  conclude
k     w  v s self  property     holds w    w       s 
 cr       w   w  k    v s  property     holds w    w
      s  otherwise  assume nonempty form   s  sk  
thus  terms w            wk w    w wk   w  exist si  wi    wi  

    k   inductive hypothesis      k   terms w i           wm






w    wi  wmi   wi role chain l si   exist satisfying properties
k
i    w
 a  c   note w i   w    w  wm
  wk   w    wm
 
i 
k
 
k
    k   definition l s   l s   property     holds
            wk           wk  
role chain   k terms w    w             wm
mk
 
 
      soundness
ready show algorithm entails sound 
lemma     nondeterministic computation exists entails k  q  returns true 
k    q 
proof  assume nondeterministic computation exists entails k  q  returns
true  algorithm returns true step    k    q  k inconsistent  hence 
rest proof  assume k consistent show ik    q  end  let
substitution   skeleton   hv  e  i  function l determined entails  graph
hv  ei forest rooted individuals occurring k so  structural induction
forest  define mapping v universe k satisfy following 
 i  v v    v    v   ik  
 ii  hv  v   e pj l v  v      role chain j l pj   exists
j    v    v      ik  
base case  ik   let  a    a  since  a     a   a  a  ik   first
property clearly holds  second property vacuous 
inductive step  consider hv  v   e  v  defined   v     not 
let l v  v        p            pm    since exist  v    v      l v  v      returns true  lemma   
roles s            sn   atomic concepts a              and  j     m   role
chain j   s  j   sn j n exist n    a     v     v     
following holds     n  j     m  
   ik   k    ai  v si  ai k     ai v  a  
   role occurring j i   k    ai v t self k    v  
   j ldr  pj   

   

fistefanoni  motik  krotzsch    rudolph

let w     v   let wi   fsi  ai  wi        n   let  v       wn   since a     v  
inductive hypothesis a     v   ik   furthermore   cr   applicable
ik so      n   si  wi    wi   ik ai  wi   ik   thus     v      ik  
required  finally  role occurring j i   k    ai v t self
k    v    cr    cr   applicable ik   respectively   wi   wi   ik  
thus  j    v    v      ik   required 
next show   q   ik considering independently atom  q  
prove lemma  combine obvious way 
consider arbitrary unary atom a t   q   step   algorithm   
k     t  v a  implies k     t  u  t  v a  property  i  
 t    t   ik   since rule  cr   applicable ik   a   t   ik   required 
consider arbitrary binary atom s t  u   q   let v            vn   s            sn  
            n determined steps     algorithm   considers atom s t  u  
    n   pda si    i    si     l vi    vi   step     then  property  ii 
role chain exists l pda si    i    si         vi      vi    ik  
next  define   considering following two cases 
v  i  step    algorithm    role chain     s  sk exists
  l wfa  t    v       property  i    t    t   ik   moreover  definition     basic concepts  t    a    a            ak    v    exist k    aj  v sj  aj
j     k   rules  cr    cr   applicable ik  
     t    v     ik  
v    i  implies v    t  step    algorithm    role chain     t  tk
exists   l sfa  v       property  i    v      v     ik  
moreover  definition     k     v    v tj  self k    v tj j     k  
rules  cr    cr    respectively  applicable ik   thus      t    v     ik  
either case  steps         l pda is     s          let       n  
note n      case         clearly       t    vn    ik  
vn   u  moreover    l pda is     sn   n    sn   fs n     finally 
rule  cr   applicable ik   s   t    u   ik   required 
      completeness
next prove encoding complete  thus proving theorem    
lemma     k    q  nondeterministic computation exists entails k  q 
returns true 
proof  assume k    q  k inconsistent  entails k  q  returns true  required 
hence  rest proof  assume k consistent  then  ik    q 
substitution exists  q  ik   let defined section       
substitution step    let  y      y   y  i  otherwise  let  y 
arbitrary  fixed  variable   q  y     y      straightforward see
  q   ik  

   

fithe complexity answering cqs gxqs owl   el kbs

skeleton   hv  e  step    set v contains ik variables occurring
 q    y      v   variable v   furthermore  let smallest
irreflexive transitive relation universe k w fs a  w  term
w universe k  then  let hv  v   e  v   v     v    v exists
 v   v       v      definition   graph hv  ei forest rooted
ik   required definition    
step    arbitrary atom a t   q   a  t   ik   property    
proposition     k      t   v a  hence  condition satisfied 
consider arbitrary edge hv  v   e  let w            wk terms  let a            ak
atomic concepts  let s            sk roles w     v   wk    v     
wi   fsi  ai  wi        k   finally  let a     v   note
uniquely defined edge  that  construction ik       k  
k    ai  v si  ai k     ai v  a  ik   then  role chain compatible
edge hv  v   role chains             k exists   s    sk k and 
    k  role occurring   k    ai v t self k    v  
rest proof show following property 
   pda p l v  v      role chain l p  exists compatible
edge hv  v   i 
lemma    definition compatibility  property    implies
condition step    satisfied edge hv  v   i 
loop steps      let s t  u  arbitrary binary atom  q   next
determine required nondeterministic choices preserve    step    
satisfy conditions steps        completes proof lemma  let au ik
unique individual connected u hv  ei  since s  t    u   ik   nonempty
role chain     s    m  sm l s  terms w            wm
universe k w     t  wm    u  exist satisfying property     proposition    
define vertex v  step    consider two possibilities  define
index        m  w      v    
j     m  exists wj ik   let v    au let    largest index
w     au  
otherwise  let v    let        
let v            vn unique path connecting v  u s  definition   
form terms w                wm   wj   j          m    v      w    
 vn     wm   thus      n   unique index  i exists  vi     w i  
let       s        let   s i      i     s i  i     n  
clearly      n   properties  a  c  proposition         n   role chain
compatible edge hvi    vi i  furthermore  l s  theorem   imply
ldr  pda is     fs       states s            sn sn   fs words             n
n   exist   ldr  pda is     s         ldr  pda si    i    si    
    n   since compatible hvi    vi i  step    preserves property    
required  finally  consider step    

   

fistefanoni  motik  krotzsch    rudolph

v  i  property  b  proposition     k     wj    v sj   wj   j          
furthermore  property c proposition     k     wj   v t self k    v
j          role occurring j   thus  k     wj   v t  wj   
then    l wfa  t    v       condition step    satisfied 
v    i  v            property  c  proposition     k     wj   v t self
k    v role occurring     then    l sfa  v      
condition step    satisfied 

   lower complexity bound
previous section  presented bcq answering algorithm elro  uses
space polynomial total size input  algorithm worst case optimal
combined complexity since krotzsch et al         reduced pspace hard problem
checking nonemptiness intersection languages generated deterministic
finite automata f        fm common alphabet  kozen        bcq answering
elro    knowledge base k encoding problem  regular rbox contains roles
s        sm l si     l fi       m   furthermore  tbox ensures
universal interpretation ik rooted tree so    term w exists
reachable root chain
roles corresponding   finally  boolean cq
contains atoms check whether l fi   nonempty  next improve lower
bound showing problem hard already restricted setting query 
tbox  abox fixed  rbox varies 
theorem     k regular elro  knowledge base q boolean conjunctive query 
checking k    q pspace hard even
query fixed consist two binary atoms single quantified variable 
tbox fixed contains axioms form v s a 
abox fixed contains single unary assertion 
proof  reduce pspace hard problem deciding whether intersection
languages generated deterministic finite automata nonempty  kozen         let
  deterministic finite automata alphabet     let fresh symbols
f             fm
 
 
occurring     let               j     m   let fj   hqj     j   ij   fj
deterministic finite automaton alphabet obtained extending fj 
transition labelled   final state fj  fj 
itself  transition labelled
 
 

  fj fresh final state fj fj   then 
j      word
j l f
 
w j l fj   exist  w  odd  given w j l fj     w  odd   w      
odd w     l fj   j     m    w  even   w     odd
w   l fj   j     m   finally  assume w l o g  qi qj    qi r
hold     j m  r well 
let w   st  sn word n odd  let   q        qm  
clearly  w j l fj   holds word w form
n
n
w   e   e m s  o m o   s  e   e m e n  en 
sn om o 

   

    

fithe complexity answering cqs gxqs owl   el kbs

exists following conditions hold j     m  

 i      n  odd  oij qj j  ei 
j   si     oj  

 ii      n  even  eij qj j  oi 
j   si     ej  

 iii  e j   ij onj   fj  
let lo   le   l    l  following languages 
lo    e  em om o    j  ej   s    oj   j     m  

    

le    om o  e  em   j  oj   s    ej   j     m  

    



l     lo   lo

    


l     i  im     le    fm f   

    

consider arbitrary word w corresponding word w   definition
l    w l  w form      satisfies property  i   similarly 
definition l    w l  w thet form      satisfies
properties  ii   iii   thus  w l  l  w j l fj    simplicity 
rest proof  use following equivalent formulations l  l   
l   lo  lo    lo

    
 

l    i  im    fm f     i  im     le    fm f   

    

twe next define knowledge base k fixed query q k    q
j l fj        present construction stages  describe
affects canonical model   hi   kthat is  model constructed using
standard notion chase  i e   definition     semantic conditions
k replaced syntactic checks axioms k   simplicity  first present k
tbox depends   later modify encoding use fixed tbox 
tbox contains axioms       abox contains axiom      
assume ai     then  word   domain element exists
connected via chain roles corresponding  
v a

symbol

    

a a  

    

next present rbox r consisting four parts  encoding languages lo   le  
s m  
s m
l    l    encoding uses fresh roles ls  
ls  
uniquely
          lo
e           le
 
associated role   well fresh roles lo   le   l   l    l    l    l    
first part r contains axioms           clear that  words
        prefix     ha    a  lio     lo  
v ls m  

ej

ls j  


oj v

ls j




    

j     m  ej   oj qj j  ej   s    oj

    

ls  
v lo

    
   

fistefanoni  motik  krotzsch    rudolph

second part r contains axioms           clear that  words
        prefix     ha    a  lie     le  

oj

s j 
le

v ls  
e



    

ls j
e

j     m  ej   oj qj j  oj   s    ej

    

ej v

ls m
v le
e

    

third part r contains axioms           clear that  words
        prefix     ha    a  li      l   
v l



    

lo v l 

    

l  
l  

    

v l 

    

lo l v
l   l  
l   lo

v

    

fourth part r contains axioms           clear that  words
        prefix     ha    a  li      l   
i  im l fm f  v l 

    

l  
l  

    
    

l fm f  v l 

    

l le v
l  
i  im

l  



l  

v

query q given       then  k    q word exists
ha   li  ha   li    latter clearly case l  l   
rbox r regular size polynomial size automata f            fm  
q   y  l   a   y  l   a   y 

    

next tighten reduction use fixed tbox   consisting axioms          
p  p  fresh roles 
v p   a

    

v p   a

    

let k   dlog    e  assume symbol corresponds k digit binary
number b  bk bi         then  let r  r extended axioms      
pb   pb k v

corresponding b  bk

    

finally  let k    ht     r    ai  let   canonical model k    axioms            
     ensure existence binary tree whose edges labelled roles p  p   
furthermore  axioms      ensure that  sequence k edges
tree corresponding binary number assigned   shortcut tree
   

fithe complexity answering cqs gxqs owl   el kbs

labelled   thus  homomorphically embedded     finally  roles p 
p  occur r query q checks existence domain element connected  
therefore  extra edges   irrelevant  consequently  encoding languages l 
l  works way varying tbox  
finally  characterise complexity bcq answering elro  knowledge bases 
theorem     k regular elro  kb q boolean cq  checking k    q
   ptime complete data complexity 
   np complete  rbox r fixed 
   pspace complete combined complexity 
proof  calvanese et al         proved bcq answering ptime hard data complexity already el knowledge bases  furthermore  query fixed  bcq
answering np hard already relational databases  chandra   merlin        
theorem follows theorems        savitchs theorem 

   navigational queries
data dl knowledge bases graph like structure  unary assertions encode
properties graph nodes binary assertions encode graph edges  conjunctive queries
cannot express recursive properties reachability  expressivity often insufficient applications require graph navigation  popularity graph
databases rise  number navigational languages querying graph like data
proposed  example  regular path queries  barcelo        use regular expressions express complex navigational patterns graph vertices  graph xpath
queries  libkin et al         extend regular path queries converse operator  negation regular expressions  checking properties vertices using boolean combinations
concepts existential quantifications paths  dl context  computational complexity navigational queries studied several expressive dls
members dl lite family el h  fragment elro   calvanese  eiter   
ortiz        bienvenu et al         kostylev et al         bienvenu et al          order
complete complexity landscape problem  section study problem
answering graph xpath queries elro  knowledge bases 
    graph xpath queries
graph xpath queries consist node expressions path expressions  whose syntaxes
defined respectively following two context free grammars b basic concept
role 
b                 hi
                      test  
following libkin et al          consider following expression fragments 
   

fistefanoni  motik  krotzsch    rudolph

p e
 

p

g

p

p f
 

s d
 

r s



r

b

u
p

s d
 



s a
 



u

p a
 



f

p

r s

c
b

r



r s

e



p e
 

figure    interpretation
   path positive fragment disallows path expressions form  
   positive fragment disallows path expressions form node expressions
form  
   converse free fragment disallows path expressions form  
graph xpath atom form  s   s  t   node expression  path
expression  terms  conjunctive graph xpath query  cgxq  g expression
g    y     x   y   conjunction graph atoms variables  x  y   variables  x
called answer variables g   x     g    y     y   boolean cgxq 
path positive  positive  converse free cgxqs obtained restricting query atoms
accordingly  finally  graph xpath query  gxq  cgxq containing single atom 
define semantics cgxqs  let   hi   first order interpretation 
interpretation node path expressions inductively defined follows 
  i
      i
      i
 hi i

 
 
 
 

    i
    i     i
    i     i
 x     hx  yi  

 s  i
      i
        i
   i
  i
 test   i

 
 
 
 
 
 

 hy  xi   hx  yi  
    i     i
    i     i
 i  
    i
 hx  xi   x  

please observe difference path expressions     corresponds          
whereas intersection     corresponds           moreover  libkin et al 
       define path expression   setting corresponds test  c    satisfaction
boolean cgxq g cgxq entailment defined obvious way  moreover 
boolean cgxq answering problem checking k    g 
example     illustrate definitions using interpretation shown figure   
notation example     moreover  let           following path expressions 
    r test hs test a b i  

    

    u test hp test a b i  

    

   

fithe complexity answering cqs gxqs owl   el kbs

node expressions
tb    b v cb  
t       c  u c  v c      t  t 
t       c  v c      c  v c      t  t 
thi    t   c v chi  
path expressions
ts  
t      t  t 
t       t  t 
 
ttest      c v ttest    self 

rb  
r      r  r 
r      r  r 
rhi   r

rs    s v ts  
r       t  t  v t      r  r 
r        t  v t       t  v t       r  r 
r     v   v   v   r
rtest     r

table    encoding positive  converse free node path expressions using axioms
     r s   

    

expression   positive  retrieves pairs individuals connected
path r edges that  element occurring path first 
exists outgoing path s edges reaching member concept b  example 
 hai   di i  hai   ei i      i  
contrast  expression   path positive  retrieves pairs individuals
connected u  edge p  successor exists member concept atb 
example  hai   g     i   hai   f       i  
finally  expression   neither positive path positive  retrieves pairs
individuals connected path consisting sequence edges described
regular expression  r s    example  hai   di     i   hai   ei       i  
let g   x  y  z    x  y     x  z     x  y  conjunctive graph xpath query  let
   x   a    d  z   g  substitution  using figure    one check     g  
observed kostylev et al          node expressions graph xpath queries correspond precisely formulas propositional dynamic logic negation  pdl    harel
et al          satisfiability problem pdl undecidable  harel         answering
gxqs dl constraints undecidable  decidability results recently obtained path positive positive queries dl lite knowledge bases  kostylev et al  
       addition  kostylev et al         proved that  dls  answering path positive 
converse free gxqs conp hard data complexity  finally  bienvenu et al         proved
answering positive gxqs el knowledge bases exptime complete  thus 
rest section focus positive  converse free graph xpath queries 
    complexity answering positive  converse free graph xpath queries
rest section  fix elro  kb k   ht   r  ai r regular 
next show that  given positive  converse free boolean cgxq g  one construct
polynomial time regular elro  kb k  boolean cq q   k    g
k     q     construction k  combines various expressive features elro   
   

fistefanoni  motik  krotzsch    rudolph

role inclusions reflexive roles encode path expressions g rbox  selfrestrictions encode node expressions g tbox 
proposition     given positive  converse free boolean cgxq g k  one compute
time polynomial  k     g  elro  kb k  boolean cq q   rbox
k  regular  g q   equally many atoms  k    g k     q    
proof  let g    y     y   positive  converse free boolean cgxq k 
positive node expression   let c fresh atomic concept uniquely associated
and  positive  converse free path expression   let fresh role uniquely
associated   structural induction  associate  resp    tbox
rbox r  resp  tbox rbox r   shown table    then  let
k    ht     r r    ai tbox   rbox r  follows 
 
 
 
 
t  


r   
r
r
 s 

 s t 

 s 

 s t 

let q      y       y   boolean cq   contains c  s  atom  s 
 s  t  atom  s  t    clearly  g q   number atoms 
moreover  since query g k  query q   k    finally  q   k 
computed polynomial time input size  rbox k  clearly regular 
next show k      q   k     g 
   assume k      q     interpretation exists    k      q    
since axiom k axiom k       k  furthermore 
positive node expression positive path expression    c  i
 t  i   prove claim simultaneous induction structure node
path expressions 
base case  base case  let arbitrary node expression form   b
let arbitrary path expression form   s  since b v cb     v ts r   
model k    claim easily follows 
inductive step  inductive step  distinguish two cases 
first  consider arbitrary node expression property holds node
path expressions occurring   let x arbitrary element assume
x   show x ci considering various forms take 
        since x   x i  x i    inductive hypothesis 
x ci  x ci    definition     c  u c  v c    
since model     x ci   required 
        proof case similar one above 
  hi  since x   exists hx  yi   inductive
hypothesis  hx  yi ti   definition       c v c    
since model     x ci   required 
second  consider arbitrary path expression property holds
node path expressions occurring   let x arbitrary elements
assume hx  yi   show hx  yi ti considering various forms
take 
   

fithe complexity answering cqs gxqs owl   el kbs

        since hx  yi   exists z hx  zi  i
hz  yi  i   inductive hypothesis  hx  zi ti  hz  yi ti   
moreover  definition r    t  t  v r    since model
r    hx  yi ti   required 
          since hx  yi   hx  yi  i hx  yi  i  
inductive hypothesis  hx  yi ti  hx  yi ti    definition r   
 t  v   t  v   r    since model r    hx  yi ti  
      first  consider case x   y  definition r   
v r    since model r    hx  yi ti   required  otherwise 
consider case x    y  since hx  yi   elements x            xn x    x
xn   exist n     hxi    xi  i     n  
inductive hypothesis      n   hxi    xi ti    definition
r    t  t  v r    since model r    hx  yi  
  test    follows x   x   inductive hypothesis 
x ci   definition     c v  self     since model
    hx  yi ti   required 
then  since node path expressions g positive      q   implies     g 
i 

   assume k     g  interpretation exists    k     g  let
interpretation obtained extending fresh concepts roles follows 
 

 c  i  

 

 

 t  i  

 

definition k    straightforward see      k    furthermore 
definition q     straightforward see       q     required 
next  establish complexity answering positive  converse free  c gxqs
elro  knowledge bases 
theorem     k regular elro  kb g positive  converse free boolean cgxq 
checking k    g ptime complete data complexity  pspace complete combined
complexity  g positive  converse free boolean gxq  checking k    g ptimecomplete combined data complexities 
proof  hardness data complexity boolean positive  converse free  c gxqs follows
ptime hardness instance checking el  calvanese et al         
positive  converse free gxqs  hardness combined complexity inherited
ptime hardness tbox reasoning el  baader et al          matching upper
bounds  proposition    allows us reduce boolean gxq answering checking entailments
form k     q   q   bcq containing one atom  next show that 
possible form q     reduce latter problem checking entailment elro 
concept inclusions  decided ptime  following  c arbitrarily
chosen individual ik   
k     a a  k      a  v a 
   

fistefanoni  motik  krotzsch    rudolph

k     y a y  k      c  v  r  a 
k     s a  b  k      a  v s  b  
k     y s y  b  k      c  v  r  s  b  
k     y s a  y  k      a  v s  c  
k     y    y   s y    y    k      c  v  r  s  c  
positive  converse free cgxqs  hardness combined complexity given theorem     matching upper bounds follow theorem    proposition    

   conclusions
paper  presented first cq answering algorithm owl   el runs
pspace  thus closing longstanding open question  algorithm based
innovative  succinct encoding regular role inclusions using bounded stack pdathat is 
finite automata extended stack fixed size  believe encoding interesting
right  used optimise popular owl   dl reasoners  moreover 
refined previously known pspace lower bound cq answering showing
problem remains pspace hard even query  tbox  abox fixed  and
rbox varies   thus  identify role inclusions culprit problems
pspace hardness  finally  showed positive  converse free gxqs cgxqs
answered owl   el knowledge bases ptime pspace  respectively 
interesting bienvenu et al         showed adding converse operator
makes problem exptime hard  thus  least theoretical perspective  positive 
converse free  c gxqs seem provide adequate language querying owl   el
knowledge bases 
see two main open problems future work  first  drawing inspiration
succinct encoding role inclusions  shall extend combined approach
stefanoni et al         owl   el thus obtain practical algorithm  second  static
query analysis fundamental task query optimisation  shall study containment
problem graph queries elro  constraints 

acknowledgements
results article extension results published preliminary form krotzsch et al         proceedings  th international semantic
web conference  iswc        work supported alcatel lucent  eu fp 
project optique  epsrc projects masi    score   dbonto  dfg project
diamond  emmy noether grant kr           

references
anselmo  m   giammarresi  d     varricchio  s          finite automata non selfembedding grammars  proceedings  th international conference im 

   

fithe complexity answering cqs gxqs owl   el kbs

plementation application automata  ciaa    pp        berlin  heidelberg 
springer verlag 
artale  a   calvanese  d   kontchakov  r     zakharyaschev  m          dl lite family
relations  j  artif  intell  res   jair           
baader  f   brandt  s     lutz  c          pushing el envelope  kaelbling  l  p  
  saffiotti  a   eds    proceedings   th international joint conference artificial intelligence  ijcai        pp          edinburgh  uk  morgan kaufmann
publishers 
baader  f   brandt  s     lutz  c          pushing el envelope further  clark  k  
  patel schneider  p  f   eds    proceedings owled      dc workshop
owl  experiences directions 
baader  f   calvanese  d   mcguinness  d   nardi  d     patel schneider  p  f   eds   
        description logic handbook  theory  implementation  applications 
cambridge university press  paperback edition 
baget  j  f   leclere  m   mugnier  m  l     salvat  e          rules existential
variables  walking decidability line  artif  intell                        
barcelo  p          querying graph databases  hull  r     fan  w   eds    pods  pp 
        acm 
barrett  c   jacob  r     marathe  m          formal language constrained path problems 
siam j  comput                  
bienvenu  m   calvanese  d   ortiz  m     simkus  m          nested regular path queries
description logics  proc    th int  conf  principles knowledge
representation reasoning  kr        aaai press 
bienvenu  m   ortiz  m     simkus  m          conjunctive regular path queries
lightweight description logics  rossi  f   ed    ijcai  ijcai aaai 
cal  a   gottlob  g     kifer  m          taming infinite chase  query answering
expressive relational constraints  j  artif  intell  res   jair              
calvanese  d   de giacomo  g   lembo  d   lenzerini  m   poggi  a   rodriguez muro  m  
rosati  r   ruzzi  m     savo  d  f          mastro system ontology based
data access  semantic web              
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          data
complexity query answering description logics  proc    th int  conf 
principles knowledge representation reasoning  kr        pp     
    
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          tractable
reasoning efficient query answering description logics  dl lite family  j 
autom  reasoning                 
calvanese  d   de giacomo  g   lembo  d   lenzerini  m     rosati  r          data
complexity query answering description logics  artificial intelligence          
    

   

fistefanoni  motik  krotzsch    rudolph

calvanese  d   de giacomo  g   lenzerini  m     vardi  m  y          containment
conjunctive regular path queries inverse  proc   th int  conf 
principles knowledge representation reasoning  kr        pp         
calvanese  d   eiter  t     ortiz  m          regular path queries expressive description
logics nominals  boutilier  c   ed    ijcai       proceedings   st
international joint conference artificial intelligence  pasadena  california  usa 
july              pp         
calvanese  d   vardi  m  y   de giacomo  g     lenzerini  m          view based query
processing regular path queries inverse  proceedings nineteenth acm
sigmod sigact sigart symposium principles database systems  pods
    pp        new york  ny  usa  acm 
chandra  a  k     merlin  p  m          optimal implementation conjunctive queries
relational data bases  hopcroft  j  e   friedman  e  p     harrison  m  a   eds   
proc   th annual acm symposium theory computing  stoc      pp 
      boulder  co  usa  acm press 
cruz  i  f   mendelzon  a  o     wood  p  t          graphical query language supporting
recursion  sigmod rec                  
cuenca grau  b   horrocks  i   motik  b   parsia  b   patel schneider  p  f     sattler  u 
        owl    next step owl  j  web sem                 
de giacomo  g   lembo  d   lenzerini  m   poggi  a   rosati  r   ruzzi  m     savo  d  f 
        mastro  reasoner effective ontology based data access  horrocks 
i   yatskevich  m     jimenez ruiz  e   eds    ore  vol      ceur workshop
proceedings  ceur ws org 
eiter  t   ortiz  m     simkus  m       a   conjunctive query answering description
logic sh using knots  j  comput  syst  sci                
eiter  t   ortiz  m   simkus  m   tran  t  k     xiao  g       b   query rewriting
horn shiq plus rules  hoffmann  j     selman  b   eds    aaai  aaai press 
fan  w          graph pattern matching revised social network analysis  deutsch 
a   ed    icdt  pp       acm 
geffert  v   mereghetti  c     palano  b          concise representation regular
languages automata regular expressions  information computation          
       
giese  m   calvanese  d   haase  p   horrocks  i   ioannidis  y   kllapi  h   koubarakis  m  
lenzerini  m   moller  r   rodriguez muro  m   ozcep  o   rosati  r   schlatte  r  
schmidt  m   soylu  a     waaler  a          scalable end user access big data 
akerkar  r   ed    big data computing  crc press 
glimm  b   lutz  c   horrocks  i     sattler  u          conjunctive query answering
description logic shiq  j  artif  intell  res   jair              
gottlob  g   manna  m     pieris  a          polynomial combined rewritings existential
rules  proc    th int  conf  principles knowledge representation
reasoning  kr        aaai press 
   

fithe complexity answering cqs gxqs owl   el kbs

gottlob  g     schwentick  t          rewriting ontological queries small nonrecursive
datalog programs  brewka  g   eiter  t     mcilraith  s  a   eds    principles
knowledge representation reasoning  proceedings thirteenth international
conference  kr       rome  italy  june              aaai press 
grosof  b  n   horrocks  i   volz  r     decker  s          description logic programs  combining logic programs description logic  proceedings   th international
conference world wide web  pp       
gutierrez  c   hurtado  c  a   mendelzon  a  o     perez  j          foundations
semantic web databases  j  comput  syst  sci                  
harel  d          dynamic logic  gabbay  d     guenthner  f   eds    handbook
philosophical logic vol  ii  pp          reidel publishing company 
harel  d   tiuryn  j     kozen  d          dynamic logic  mit press  cambridge  ma 
usa 
hopcroft  j  e   motwani  r     ullman  j  d          introduction automata theory 
languages  computation   international edition     ed   addison wesley 
horrocks  i   kutz  o     sattler  u          even irresistible sroiq  doherty 
p   mylopoulos  j     welty  c  a   eds    kr  pp        aaai press 
horrocks  i     sattler  u          decidability shiq complex role inclusion axioms 
artificial intelligence                  
johnson  d  s     klug  a  c          testing containment conjunctive queries
functional inclusion dependencies  j  comput  syst  sci                  
kazakov  y          riq sroiq harder shoiq  brewka  g     lang 
j   eds    kr  pp          aaai press 
kontchakov  r   lutz  c   toman  d   wolter  f     zakharyaschev  m          combined approach ontology based data access  walsh  t   ed    ijcai      
proceedings   nd international joint conference artificial intelligence 
barcelona  catalonia  spain  july              pp            ijcai aaai 
kostylev  e  v   reutter  j  l     vrgoc  d          xpath dl lite ontologies 
bienvenu  m   ortiz  m   rosati  r     simkus  m   eds    informal proceedings
  th international workshop description logics  vienna  austria  july       
       vol       ceur workshop proceedings  pp          ceur ws org 
kozen  d          lower bounds natural proof systems  focs  pp          ieee
computer society 
krotzsch  m          efficient rule based inferencing owl el  walsh  t   ed   
proceedings   nd international joint conference artificial intelligence  ijcai     aaai press ijcai           
krotzsch  m   rudolph  s     hitzler  p          conjunctive queries tractable fragment
owl      aberer  k   choi  k  s   noy  n   allemang  d   lee  k  i   nixon  l  
golbeck  j   mika  p   maynard  d   mizoguchi  r   schreiber  g     cudre mauroux 
p   eds    proceedings  th international semantic web conference  iswc    
vol       lncs  pp          springer 
   

fistefanoni  motik  krotzsch    rudolph

libkin  l   martens  w     vrgoc  d          querying graph databases xpath 
tan  w  c   guerrini  g   catania  b     gounaris  a   eds    icdt  pp         
acm 
lutz  c          complexity conjunctive query answering expressive description
logics  automated reasoning 
lutz  c   seylan  i   toman  d     wolter  f          combined approach obda 
taming role hierarchies using filters  alani  h   kagal  l   fokoue  a   groth  p  t  
biemann  c   parreira  j  x   aroyo  l   noy  n  f   welty  c     janowicz  k   eds   
international semantic web conference      vol       lecture notes computer
science  pp          springer 
lutz  c   toman  d     wolter  f          conjunctive query answering description logic el using relational database system  boutilier  c   ed    ijcai
      proceedings   st international joint conference artificial intelligence 
pasadena  california  usa  july              pp           
marnette  b          generalized schema mappings  termination tractability 
paredaens  j     su  j   eds    pods  pp        acm 
mora  j   rosati  r     corcho  o          kyrie   query rewriting extensional
constraints elhio  mika  p   tudorache  t   bernstein  a   welty  c   knoblock 
c  a   vrandecic  d   groth  p  t   noy  n  f   janowicz  k     goble  c  a   eds   
semantic web   iswc          th international semantic web conference  riva
del garda  italy  october              proceedings  part i  vol       lecture notes
computer science  pp          springer 
ortiz  m   calvanese  d     eiter  t          data complexity query answering expressive description logics via tableaux  j  autom  reasoning               
ortiz  m   rudolph  s     simkus  m          query answering horn fragments
description logics shoiq sroiq  walsh  t   ed    ijcai       proceedings   nd international joint conference artificial intelligence  barcelona 
catalonia  spain  july              pp            ijcai aaai 
perez  j   arenas  m     gutierrez  c          nsparql  navigational language rdf 
web semant                 
perez urbina  h   motik  b     horrocks  i          tractable query answering rewriting
description logic constraints  j  applied logic                
rodriguez muro  m     calvanese  d          high performance query answering
dl lite ontologies  brewka  g   eiter  t     mcilraith  s  a   eds    principles
knowledge representation reasoning  proceedings thirteenth international
conference  kr       rome  italy  june              aaai press 
rosati  r          conjunctive query answering el  calvanese  d   franconi  e  
haarslev  v   lembo  d   motik  b   turhan  a  y     tessaris  s   eds    description
logics  vol      ceur workshop proceedings  ceur ws org 
rudolph  s     glimm  b          nominals  inverses  counting  conjunctive queries or 
infinity friend   j  artif  intell  res   jair              
   

fithe complexity answering cqs gxqs owl   el kbs

simanck  f          elimination complex rias without automata  kazakov  y  
lembo  d     wolter  f   eds    proceedings      international workshop
description logics  dl       rome  italy  june             vol      ceur
workshop proceedings  ceur ws org 
sirin  e   parsia  b   cuenca grau  b   kalyanpur  a     katz  y          pellet  practical
owl dl reasoner  j  web sem               
stefanoni  g   motik  b     horrocks  i          introducing nominals combined
query answering approaches el  desjardins  m     littman  m  l   eds   
aaai  aaai press 
ter horst  h  j          completeness  decidability complexity entailment rdf
schema semantic extension involving owl vocabulary  web semantics 
science  services agents world wide web                 
tsarkov  d     horrocks  i          fact   description logic reasoner  system description  furbach  u     shankar  n   eds    ijcar  vol       lecture notes
computer science  pp          springer 
urbani  j   van harmelen  f   schlobach  s     bal  h  e          querypie  backward
reasoning owl horst large knowledge bases  aroyo  l   welty  c  
alani  h   taylor  j   bernstein  a   kagal  l   noy  n  f     blomqvist  e   eds   
international semantic web conference      vol       lecture notes computer
science  pp          springer 
vardi  m  y          complexity relational query languages  extended abstract  
proceedings fourteenth annual acm symposium theory computing  stoc
    pp          new york  ny  usa  acm 
venetis  t   stoilos  g     stamou  g  b          incremental query rewriting owl   ql 
kazakov  y   lembo  d     wolter  f   eds    proceedings      international
workshop description logics  dl       rome  italy  june             vol     
ceur workshop proceedings  ceur ws org 
virgilio  r  d   orsi  g   tanca  l     torlone  r          nyaya  system supporting
uniform management large sets semantic data  kementsietsidis  a     salles 
m  a  v   eds    ieee   th international conference data engineering  icde
       washington  dc  usa  arlington  virginia       april        pp           
ieee computer society 
wessel  m          obstacles way qualitative spatial reasoning description
logics  undecidability results  working notes      international
description logics workshop  dl        vol      ceur ws org 

   


