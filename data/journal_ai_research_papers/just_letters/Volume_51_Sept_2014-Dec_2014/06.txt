journal of artificial intelligence research                  

submitted        published      

iterative plan construction for the workflow satisfiability problem
david cohen
jason crampton
andrei gagarin
gregory gutin
mark jones

d c ohen   rhul   ac   uk
jason  c rampton   rhul   ac   uk
a ndrei  g agarin   rhul   ac   uk
g g utin   rhul   ac   uk
m ark  j ones   rhul   ac   uk

royal holloway  university of london  uk

abstract
the workflow satisfiability problem  wsp  is a problem of practical interest that arises whenever tasks need to be performed by authorized users  subject to constraints defined by business
rules  we are required to decide whether there exists a plan  an assignment of tasks to authorized
users  such that all constraints are satisfied  it is natural to see the wsp as a subclass of the
constraint satisfaction problem  csp  in which the variables are tasks and the domain is the set
of users  what makes the wsp distinctive is that the number of tasks is usually very small compared to the number of users  so it is appropriate to ask for which constraint languages the wsp is
fixed parameter tractable  fpt   parameterized by the number of tasks 
this novel approach to the wsp  using techniques from csp  has enabled us to design a generic
algorithm which is fpt for several families of workflow constraints considered in the literature 
furthermore  we prove that the union of fpt languages remains fpt if they satisfy a simple compatibility condition  lastly  we identify a new fpt constraint language  user independent constraints  that includes many of the constraints of interest in business processing systems  we
demonstrate that our generic algorithm has provably optimal running time o   k log k    for this
language  where k is the number of tasks 

   introduction
a workflow formalises a business process  it is a collection of interrelated tasks that are performed
by users in order to achieve some objective  in many situations  we wish to restrict the users that
can perform certain tasks  in particular  we may wish to specify lists of users who are authorized to
perform each of the workflow tasks  additionally  we may wish  either because of the particular
requirements of the business logic or security requirements  to prevent certain combinations of
users from performing particular combinations of tasks  crampton         such constraints include
separation of duty  also known as the two man rule   which may be used to prevent sensitive
combinations of tasks being performed by a single user  and binding of duty  which requires that a
particular combination of tasks is executed by the same user  the use of constraints in workflow
management systems to enforce security policies has been studied extensively in the last fifteen
years  for example see the work of bertino  ferrari  and atluri         crampton        or wang
and li        
    the workflow satisfiability problem
it is possible that the combination of constraints and authorization lists is unsatisfiable  in the
sense that there does not exist an assignment of users to tasks such that all contraints are satisfied
c
    
ai access foundation  all rights reserved 

fic ohen   c rampton   g agarin   g utin     j ones

and every task is performed by an authorized user  perhaps the minimal example being a requirement
that two tasks are performed by the same user but the intersection of the authorization lists for these
tasks is empty  a plan that satisfies all constraints and allocates an authorized user to each task is said
to be valid  the workflow satisfiability problem  wsp  takes a workflow specification as input
and returns a valid plan if one exists and a null value otherwise  it is important to determine whether
a business process is satisfiable or not  since an unsatisfiable one can never be completed without
violating the security policy encoded by the constraints and authorization lists  wang and li       
have shown  by a reduction from g raph c oloring  that the wsp is an np hard subclass of the
csp  even when we only consider binary separation of duty constraints  nevertheless  for practical
applications of the wsp  we require a solving algorithm that is as efficient as possible  crampton  
gutin             
many hard problems become less complex if some natural parameter of the instance is bounded 
hence  we say a problem with input size n and parameter k is fixed parameter tractable  fpt  if it
admits an algorithm with running time o f  k nd    where d is a constant independent of n and k 
and f is a computable function depending only on k  
wang and li        were the first to observe that fixed parameter algorithmics is an appropriate
way to study the wsp  because the number of tasks is usually small and often much smaller than the
number of users   the literature does not directly support this assumption  although a widely cited
study  schaad  moffett    jacob        found that the number of users exceeds that of job functions 
or roles  by a multiplicative factor of around     this finding has been confirmed by a recent followup study  jayaraman  ganesh  tripunitara  rinard    chapin        a workflow specification will
usually be concerned with a particular business objective and involve a small number of roles 
taking roles as a proxy for tasks  it seems reasonable to assume that the number of users will be an
order of magnitude greater than the number of tasks   we believe  therefore  that it is appropriate to
extend the work initiated by wang and li on the use of fixed parameter algorithms for solving the
wsp parameterized by the number of tasks  and  in particular  to ask which constraint languages
are fixed parameter tractable 
wang and li        proved that  in general  the wsp is w    hard and thus is highly unlikely
to admit a fixed parameter algorithm  they also showed that the wsp is fpt if we consider only
separation of duty and binding of duty constraints  crampton  gutin  and yeo        obtained significantly faster fixed parameter algorithms that were applicable to regular constraints  thereby
including the cases shown to be fpt by wang and li  this work  and other recent research  has
demonstrated the existence of fixed parameter algorithms for the wsp in the presence of other constraint types  crampton  crowston  gutin  jones    ramanujan        crampton   gutin        
we define the wsp formally and introduce a number of different constraint types  including regular
constraints  in section   
we will use the o notation  which suppresses polynomial factors 
that is 
g n  k  m    o  h n  k  m   if there exists a polynomial q n  k  m  such that g n  k  m   
o q n  k  m h n  k  m    in particular  an fpt algorithm is one that runs in time o  f  k   for
some computable function f depending only on k 

   an introduction to fixed parameter algorithms and complexity can be found in  for example  the books by downey
and fellows         or niedermeier  niedermeier        

   

fii terative p lan c onstruction for the w orkflow s atisfiability p roblem

    the relation between the wsp and the csp
the constraint satisfaction problem  csp  is a general paradigm for expressing  in a declarative
format  problems where variables are to be assigned values from some domain  the assignments
are constrained by restricting the allowed simultaneous assignments to some sets of variables  this
model is useful in many application areas including planning  scheduling  frequency assignment and
circuit verification  rossi  van beek    walsh         the csp community is a well established
research community dedicated to finding effective solution techniques for the csp  dechter        
the csp is np hard  even when only binary not equals constraints are allowed and the domain
has three elements  as we can reduce g raph   c oloring to the csp    hence  a considerable
effort has been made to understand the effect of restricting the type of allowed constraints  recently there has been significant progress towards the completion of this research program and
there is now strong evidence to support the algebraic dichotomy conjecture of bulatov  jeavons
and krokhin         characterising precisely which kinds of constraint language lead to polynomial
solvability 
it is worth noting that the wsp is a subclass of the csp where for each variable s  called a task
in wsp terminology  we have an arbitrary unary constraint  called an authorization  that assigns
possible values  called users  for s  this is called the conservative csp  note  however  that while
usually in csp the number of variables is much larger than the number of values  for the wsp the
number of tasks is usually much smaller than the number of users  it is important to remember that
for the wsp we do not use the term constraint for authorizations and so when we define special
types of constraints  we do not extend these types to authorizations  which remain arbitrary 
    outline of the paper
our novel approach to the wsp using techniques for the csp  characterising types of constraints
as constraint languages with particular characteristics  enables us to generalise and unify existing
algorithms  so  in this paper  for the first time  rather than considering algorithms for specific
constraints  we design a generic algorithm which is a fixed parameter algorithm for several families
of workflow constraints considered in the literature  in particular we introduce the notions of userindependent constraints  which subsume a number of well studied constraint types from the wsp
literature  including the regular constraints studied by crampton et al         
our generic algorithm builds plans incrementally  discarding partial plans that can never satisfy
the constraints  it is based on a naive algorithm  presented in section      this naive algorithm
stores far more information than is required to solve the wsp  so its running time is no better than
exhaustively searching for a valid plan 
our generic algorithm uses a general and classic paradigm  retain as little information as possible in every step of the algorithm  this paradigm is used in such classical polynomial time algorithms as gaussian elimination for solving systems of linear equations and constraint propagation
algorithms  used  for example  to solve  sat in polynomial time   our generic algorithm uses
this paradigm in a problem specific way  based on the concepts of extension equivalence  planindistinguishability and patterns  enabling us to retain a single pattern for each equivalence class of
indistinguishable plans  extension equivalence and plan encodings are described in section    the
way the solution is constructed by our algorithm is quite unusual because the accumulation of the
   wang and lis np hardness result for the wsp is thus a restatement of this well known result for csp 

   

fic ohen   c rampton   g agarin   g utin     j ones

 representatives of  set of solutions goes along the users  i e   values for csp   not along the tasks
 i e   variables for csp  
to analyze the running time of our algorithm we introduce the notion of diversity  see definition     this notion is reminiscent of pathwidth  measures are taken over all prefixes and the largest
outcome is the diversity  with the difference that the diversity is based on the number of equivalence classes  hiding the actual structure behind the scenes  this approach might also be useful for
structural analysis of hypergraphs 
in section    we describe our pattern based algorithm and demonstrate that it is a fixedparameter algorithm for the wsp with user independent constraints  we show the running time
of our algorithm is o   k log k   for the wsp with user independent constraints and that there is
no algorithm of running time o   o k log k    for the wsp with user independent constraints unless
the exponential time hypothesis   eth  fails  thus  unlike the wsp with regular constraints
 and problems studied by bodlaender  cygan  kratsch    nederlof        fomin  lokshtanov   
saurabh         the wsp with user independent constraints is highly unlikely to admit an algorithm
of running time o   o k     to show that our generic algorithm is of interest for constraints other
than user independent  we prove that the generic algorithm is a single exponential algorithm for a
constraint language obtained by an equivalence relation on the set of users 
in section   we show how our generic algorithm can deal with unions of constraint languages 
this leads to a generalisation of our result for user independent constraints  in section   we discuss
the results of computational experiments using an implementation of our algorithm  discussed in
full detail in the work of cohen  crampton  gagarin  gutin    jones         a brief conclusion is
given in in section   

   background
we define a workflow schema to be a tuple  s  u  a  c   where s is the set of tasks in the workflow 
u is the set of users  a    a s    s  s   where a s   u is the authorization list for task s  and
c is a set of workflow constraints  a workflow constraint is a pair c    l     where l  s and 
is a set of functions from l to u   l is the scope of the constraint   specifies those assignments of
elements of u to elements of l that satisfy the constraint c 
given t  s and x  u   a plan is a function    t  x  given a workflow constraint  l    
t  s and x  u   a plan    t  x satisfies  l    if either l   t     or  l    for some
    a plan    t  x is eligible if  satisfies every constraint in c  a plan    t  x is
authorized if  s   a s  for all s  t   a plan is valid if it is both authorized and eligible  a plan
   s  u is called a complete plan  an algorithm to solve the wsp takes a workflow schema
 s  u  a  c  as input and outputs a valid  complete plan  if one exists  and null  otherwise  
as a running example  consider the following instance of the wsp 
instance    the task set s    s            s    and the user set u    u            u     the authorization
lists are as follows  where a tick indicates that the given user is authorized for the given task  
   the exponential time hypothesis claims there is no algorithm of running time o   o n    for  sat on n variables  impagliazzo  paturi    zane        

   

fii terative p lan c onstruction for the w orkflow s atisfiability p roblem

s 
s 
s 
s 

u 
 

u 
 
 
 
 

u 

u 

u 

u 

 
 

 
 

 
 

 

the constraints are as follows  s  and s  must be assigned to the same user  s  and s  must
be assigned to different users  s  and s  must be assigned to different users  s  and s  must be
assigned to different users 
example   illustrates the meanings of eligible  complete and authorised plans in the context of
instance   
example    the following table gives assignments for four plans                 

 
 
 
 

s 
u 
u 
u 
u 

s 
u 
u 
u 

s 
u 
u 
u 
u 

s 
u 
u 
u 
u 

authorized
 
 
 

eligible
 
 
 

complete
 
 
 

   is a complete plan which is authorized but not eligible  as s  and s  are assigned to
different users 
   is a complete plan which is eligible but not authorized  as u  is not authorized for s   
   is a plan which is authorized and eligible  and therefore valid  however    is not a
complete plan as there is no assignment for s   
   is a complete plan which is eligible and authorized  thus   is a valid complete plan  and
is therefore a solution 
for an algorithm that runs on an instance  s  u  a  c  of the wsp  we will measure the running
time in terms of n    u    k    s   and m    c    the set a of authorization lists consists of k
lists each of size at most n  so we do not need to consider the size of a separately when measuring
the running time   we will say an algorithm runs in polynomial time if it has running time at most
p n  k  m   where p n  k  m  is polynomial in n  k and m 
    wsp constraints
in this paper we are interested in the complexity of the wsp when the workflow constraint language
 the set of permissible workflow constraints  is restricted  in this section we introduce the constraint
types of interest  all of them have practical applications for real world workflows 
we assume that all constraints and authorizations can be checked in polynomial time  this
means that it takes polynomial time to check whether any plan is authorized  eligible and valid 
the correctness of our algorithm is unaffected by this assumption  but choosing constraints not
checkable in polynomial time would naturally affect the running time 
   

fic ohen   c rampton   g agarin   g utin     j ones

      c onstraints d efined by a b inary r elation
constraints on two tasks  s and s    can be represented in the form  s  s       where  is a binary
relation on u  crampton         a plan  satisfies such a constraint if  s    s     writing
  to denote the relation   u  u    u  u   and    to denote the relation   u  v    u  v  u  u    v  
separation of duty and binding of duty constraints may be represented in the form  s  s        and
 s  s        respectively  crampton et al         considered constraints for which  is  or   where
 is an equivalence relation defined on u   a practical example of such workflow constraints is
when the equivalence relation partitions the users into different departments  constraints could then
enforce that two tasks be performed by members of the same department  constraints that are not
restricted to singleton tasks have also been considered  crampton et al         wang   li         a
plan  satisfies a constraint of the form  s     s        if there are tasks s   s   and s    s    such that
 s      s     
      c ardinality c onstraints
a tasks per user counting constraint has the form  t    tr   t    where     t    tr   k and t  s  a
plan  satisfies  t    tr   t   if a user performs either no tasks in t or between t  and tr tasks  tasksper user counting constraints generalize the cardinality constraints which have been widely adopted
by the wsp community  american national standards institute        bertino  bonatti    ferrari 
      joshi  bertino  latif    ghafoor        sandhu  coyne  feinstein    youman        
      r egular c onstraints
we say that c is regular if it satisfies the following condition  if a partition s            sp of s is such
 
that for every
sp i   p  there exists an eligible complete plan  and user u with   u    si   then
the plan i    si  ui    where all ui s are distinct  is eligible  regular constraints extend the set
of constraints considered by wang and li         crampton et al         show that the following
constraints are regular   s     s            s     s          where at least one of the sets s     s    is a singleton 
tasks per user counting constraints of the form  t    tr   t    where t      
      u ser  i ndependent c onstraints
many business rules are not concerned with the identities of the users that complete a set of tasks 
they are only concerned with the relationships between those users  accordingly  we say a constraint  l    is user independent if whenever    and    u  u is a permutation  then
      the most obvious example of a user independent constraint is the requirement that two
tasks are performed by different users  separation of duty   as a more complex example suppose
that at most at least exactly p users are required to complete some sensitive set of tasks  cardinality
constraints   where p is usually small  i e           or so  there is a substantial literature on constraints as a method for specifying and enforcing business rules  for example  gligor  gavrila   
ferraiolo        simon   zurko         including work by researchers at sap and ibm  for example  basin  burri    karjoth        wolter   schaad         the most widely studied constraints
are cardinality constraints and separation of duty  which form part of the ansi standard on rolebased access control  american national standards institute         developed by the us national
institute of standards and technology  nist   in short  the literature and relevant standards suggest that user independent constraints are those of most interest in business processes and workflow
   

fii terative p lan c onstruction for the w orkflow s atisfiability p roblem

management systems  our definition of user independent includes all the constraints defined in the
ansi rbac standard and many more 
every regular constraint is user independent  but many user independent constraints are not
regular  indeed  constraints of the type  s     s         are user independent  but not necessarily
regular  crampton et al          many counting constraints in the global constraint catalogue  beldiceanu  carlsson    rampon        are user independent  but not regular  in particular  the constraint nvalue  which bounds from above the number of users performing a set of
tasks  is user independent but not regular  note  however  that constraints of the form  s    s      
and  s    s        are not user independent in general 
it is important to note that authorization lists  which are fundamental to any access control
system  when viewed as unary constraints  are certainly not user independent  it is the presence of
both user independent constraints and authorization lists in a workflow specification that makes the
wsp challenging 
    a naive algorithm
the main aim of this section is to present a simple algorithm  algorithm    which will solve any
instance of the wsp  the running time of the algorithm is slightly worse than a brute force algorithm  but the algorithms basic structure provides a starting point from which to develop a more
efficient algorithm 
we need to introduce some additional notation and terminology 
let    t  x be a plan for some t  s  x  u   then let task     t and u ser     x 
it is important for our generic algorithm that task   and u ser   are given as explicit parts of  
in particular  the set u ser   may be different from the set of users assigned to a task by   that is 
a user u can be in u ser   without there being a task s such that  s    u  it is worth observing
that task   may be empty  because  may not allocate any tasks to users in x   for any t  s
and u  u    t  u  denotes the plan    t   u  such that  s    u for all s  t  
two functions f    d   e  and f    d   e  are disjoint if d   d    e   e      the
union of two disjoint functions f    d   e    f    d   e  is a function f   f   f  such that
f   d   d   e   e  and f  d    fi  d  for each d  di   where i          let g   d  e
and h   e  f be functions  then h  g denotes the composite function from d to f such that
h  g d    h g d   for each d  d  for an integer p      the set  p                   p  
proposition    let  s  u  a  c  be an instance of the wsp  with n    u    k    s  and m    c  
then  s  u  a  c  can be solved in time o   n     k   by algorithm   
proof  let u            un be an ordering of u   and let ui    u            ui   for each i   n   for each
i   n  in turn  we will construct the set i of all plans  such that u ser     ui and  is valid 
if the set n contains no plan  with task     s  then  s  u  a  c  has no solution  otherwise 
any such plan is a solution for  s  u  a  c  
algorithm   shows how to construct the sets i   it is not hard to verify that i contains exactly
every valid plan  with u ser     ui   for each i  this implies the correctness of our algorithm  it
remains to analyse the running time 
for each i   n  and each t  s  there are at most i t   valid plans  with u ser    
ui   task     t   to construct     we need to consider all plans  with u ser     u    and there
are exactly  k such plans  for each plan we can decide in polynomial time whether to add it to    
   

fic ohen   c rampton   g agarin   g utin     j ones

algorithm    naive solution procedure for the wsp
input   an instance  s  u  a  c  of the wsp
  construct an ordering u            un of u  
  set      
  foreach t  s do
 
set     t  u    
 
if  is eligible and u   a s  for all s  t then
 
set           
 
end
  end
  set i     
   while i   n do
  
set i      
  
foreach     i do
  
foreach t  s   task      do
  
if ui    a s  for all s  t then
  
set         t  ui     
  
if  is eligible then
  
set i     i       
  
end
  
end
  
end
  
end
  
set i   i     
   end
   foreach   n do
  
if task     s then
  
return  
  
end
   end
   return null  

to construct i   for each i   n      we need to consider every pair       t   where     i and
t  s   task       consider the pair       t    where    is an  s     ui   plan for some s    s  and
 
 
t  s   s     thus there are i s   possibilities
for      and there
are   s  s   choices for t   thus 
p
p
 
 
k
k
the total number of pairs is given by s   s i s     s  s     j   j ij  kj    i     k   for each
pair       t   we can decide whether
to add      t  ui     to i   in polynomial time  thus  to
p
k

k

k
construct all i takes time o   n 
i    i          o  n n          o   n        

algorithm   is inefficient even for small k  due to the fact that each i contains all valid plans
with u ser         u            ui    we show in the next section that it is not necessary to store so
much information to solve the wsp 

 

   

fii terative p lan c onstruction for the w orkflow s atisfiability p roblem

   plan indistinguishability relations
we first introduce the notion of extension equivalence  defined by an equivalence relation on the set
of all plans  informally  the relation enables us to keep a single member of each equivalence class
when building plans incrementally 
definition    given an instance  s  u  a  c  of the wsp  and two eligible plans   and     define
     if the following conditions hold 
   u ser       u ser     and task       task     
         is eligible if and only if       is eligible  for any plan    disjoint from   and    
then  is an equivalence relation on the set of eligible plans  and we say   and   are extensionequivalent if       
example    consider instance   
let      s    s      u    u    be the function such that    s      u  and    s      u    let
     s    s      u    u    be the function such that    s      u  and    s      u   
the plans   and   are both eligible  and u ser       u ser     and task      
task      for any plan    disjoint from   and     the plan       will satisfy the constraints
 s    s          s    s         thus       is eligible if and only if    is eligible  similarly        is
eligible if and only if    is eligible  thus       is eligible if and only if       is eligible  and so
  and   are extension equivalent 
suppose that we had a polynomial time algorithm to check whether two eligible plans are
extension equivalent  then in algorithm    we could keep track of just one plan from each equivalence class  when constructing i   we will only add   to i if there is no   extension equivalent
to   already in i   when we construct i     we may use   as a proxy for     if the number of
extension equivalent classes is small compared to the number of plans  then the worst case running
time of the algorithm may be substantially lower than that of algorithm   
unfortunately  it is not necessarily easy to decide if two eligible plans are extension equivalent 
so this approach is not practical  however  we can always refine  extension equivalence to an equivalence relation for which equivalence is easy to determine  for example  the identity equivalence
relation where each plan is only equivalent to itself is such a refinement 
this refined equivalence relation may have more equivalence classes than extensionequivalence  but substantially fewer than the identity relation  so we may obtain a better running
time than the naive algorithm 
definition    given an instance  s  u  a  c  of the wsp  let  be the set of all eligible plans
and let  be an equivalence relation refining extension equivalence on   we say  is a planindistinguishability relation  with respect to c  if  for all eligible       such that        and for
any plan    disjoint from   and   such that       is eligible  we have that               
example    let  be the identity relation on plans  that is       if and only if u ser      
u ser      task       task      and    s       s  for all s  u ser      then  is a
   an equivalence relation   is a refinement of an equivalence relation   if every equivalence class of   is a subset
of some equivalence class of    

   

fic ohen   c rampton   g agarin   g utin     j ones

plan indistinguishability relation  this shows that not every plan indistinguishability relation is the
extension equivalence relation  indeed  the plans given in example   are extension equivalent but
not identical 
recall that we refined extension equivalence since it may be hard to determine whether two
eligible plans are extension equivalent  it is therefore natural to assume the following 
assumption    given a plan indistinguishability relation   it takes polynomial time to check
whether two eligible plans are equivalent under  
the correctness of our algorithms does not depend on this assumption  however  a poor choice
of the plan indistinguishability relation could affect the running times 
we now describe appropriate plan indistinguishability relations for the constraints that we will
be using  in each case determining if two eligible plans are equivalent under  will take polynomial
time 
    plan indistinguishability relation for user independent constraints
lemma    suppose all constraints are user independent  and let ui be a relation such that   ui
  if and only if
   u ser       u ser     and task       task     
   for all s  t  task         s       t  if and only if    s       t  
then ui is a plan indistinguishability relation on the set of eligible plans 
proof  by definition of user independent constraints  if  is an eligible plan and    u  u is
a permutation  then    is also eligible  suppose that   ui     and let t   task     and
x   u ser      let         t       t   be a function such that        t        t  for any
task t  let       x      t    x      t   be an arbitrary bijection  note that     t          t    by
condition   of ui    let              then  is a permutation such that           thus   is
eligible if and only if   is eligible 
now consider two eligible plans       such that   ui     and a plan    disjoint from   and
    first we show that       ui         it is clear that u ser           u ser         and
task           task          now for any s  t  u ser          if          s             t  
then either s  t are both in task       in which case          s             t  trivially  or s  t
are both in task      in which case    s       t  since   ui     and hence          s   
         t   thus if          s             t  then          s             t  and  by a similar
argument  the converse holds  thus       ui         furthermore  it follows by the argument
in the first paragraph that       is eligible if and only if       is eligible  thus  the condition of
definition   and the second condition of definition   hold 
the first condition of ui trivially satisfies the first condition of definition    thus  ui satisfies
all the conditions of a plan indistinguishability relation 
example    consider an instance of the wsp with users u          u  and tasks s            s  in which
all constraints are user independent  let ui be the plan indistinguishability relation given by
lemma    let c  be the constraint with scope  s    s    s    s    such that c  is satisfied if and only if
an even number of users are assigned to tasks in  s    s    s    s     let c  be the constraint with scope
   

fii terative p lan c onstruction for the w orkflow s atisfiability p roblem

 s    s    s    s    such that c  is satisfied if and only if either s  and s  are assigned to different users 
or s  and s  are assigned to different users  suppose that c  and c  are the only constraints whose
scope contains tasks from both  s    s    s    and  s    s    s    
now consider the plans          s    s    s      u    u    u    u    such that    s     
u       s      u       s      u    and    s      u       s      u       s      u    and suppose that
      are both eligible  then   and   are equivalent under ui  
observe that for any plan    disjoint from   and           is eligible if and only if      
is eligible  as   and   both assign two users to  s    s        must assign two users to  s    s    in
order to satisfy c    as   and   both assign s  and s  to the same user     must assign s  and s 
to different users in order to satisfy c    as long as these conditions are satisfied  and    satisfies all
constraints with scope in  s    s    s     then       and       will both be eligible 
    plan indistinguishability relation for equivalence relation constraints
recall that given a binary relation  on u   a constraint of the form  si   sj     is satisfied by a plan 
if  si     sj    recall that such constraints are not user independent in general 
lemma    suppose  is an equivalence relation on u   let v            vl be the equivalence classes
of  over u   suppose all constraints are of the form  si   sj     or  si   sj       let e be a relation
such that   e   if and only if
   u ser       u ser     and task       task     
   for all equivalence classes vj such that vj  u ser         and vj   u ser          we
have that for all s  task         s   vj if and only if    s   vj  
then e is a plan indistinguishability relation 
proof  it is clear that e satisfies the first condition of definition    now suppose       are eligible
plans such that   e     and let    be a plan disjoint from   and     we first show that       is
eligible if and only if       is eligible 
suppose that      is eligible  consider two tasks t  t   task         if  t  t     task      
then       will not falsify any constraint on t and t  since it is equal to       when restricted to
 t  t    and       is eligible  if  t  t     task      then       will not break any constraints
since   is eligible 
so we may assume that t  task      t   task       by definition          t           t   
if and only if there exists j   l  such that    t       t     vj   then vj  u ser         and
vj   u ser          therefore  by definition of e      s   vj if and only if    s   vj   for all
s  task      in particular     t   vj   and so         t           t     by a similar argument 
if          t            t    then          t            t     therefore  every constraint is
satisfied by          if and only if it is satisfied by           therefore if       is eligible then
so is         and by a similar argument the converse holds 
it remains to show that       e         it is clear that the user and task sets are the same 
as they have the same user set  the sets  vj   vj  u ser              vj   u ser             
and  vj   vj  u ser              vj   u ser              are the same  furthermore  for each
vj in this set and any s  task          if          s   vj then          s   vj   as either
s  task      in which case vj  u ser          vj   u ser         and so    s   vj   or
   

fic ohen   c rampton   g agarin   g utin     j ones

s  task       in which case          s        s             s   by a similar argument  if
         s   vj   then          s   vj   thus       e        
example    let  be an equivalence relation on users with equivalence classes
 u      u      u    u    u      u    u    u     consider an instance of the wsp with users u            u 
and tasks s            s  in which all constraints are of the form  si   sj     or  si   sj       let e be the
plan indistinguishability relation given by lemma    suppose that the only constraints whose scope
contains tasks from both  s    s    s    and  s    s    s    are the constraints  s    s         s    s      and
 s    s       
now consider the plans          s    s    s      u    u    u    u    such that    s     
u       s      u       s      u    and    s      u       s      u       s      u    and suppose that
      are both eligible  then   and   are equivalent under e  
observe that for any plan    disjoint from   and           is eligible if and only if      
is eligible  the only  equivalence class with members in  u    u    u    u    and members not in
 u    u    u    u    is the class  u    u    u       and   both assign members of  u    u    to exactly the
set  s    s     thus for any plan    disjoint from   and           and       will both satisfy the
constraint  s    s       whatever    assigns to s    they will both satisfy  s    s      only if    assigns
s  to u    and they will both satisfy  s    s       only if    does not assign s  to u    as long as these
conditions are satisfied  and    satisfies all constraints with scope in  s    s    s     then       and
      will both be eligible 

   a generic algorithm for the wsp
in what follows  for each x  u  t  s  we let  x  t   denote the set of all eligible plans  with
u ser     x an task     t   in this section we will introduce an algorithm that works in a
similar way to algorithm    except that instead of storing all valid plans over a particular set of users
or tasks  we will construct  x  t   representative sets for each task set t and certain user sets x 
by definition  the equivalence classes of any plan indistinguishability relation necessarily partition
 x  t    hence any such equivalence class has a representation of the form  x  t     where  is
dependent on the constraint language  in the remainder of this section we describe the algorithm
and give examples of these representations 
    encodings and patterns
in our generic algorithm  we will construct plans iteratively  using at most one plan from each
equivalence class under a plan indistinguishability relation  the running time of the algorithm will
depend on the number of equivalence classes under this relation  over certain sets of plans  to
ensure that sets of equivalence classes can be ordered and therefore searched and sorted efficiently 
we introduce the notion of encodings and patterns  loosely speaking  an encoding is a function that
maps all the plans in a  equivalence class to the same element  the pattern of those plans   these
encodings ensure logarithmic time access and insertion operations into a representative set of plans 
rather than the linear time that a naive method would allow 
note that the use of encodings and patterns is not necessary for any of our fixed parameter
tractability results  the same problems could be solved without the use of patterns and encodings in
fixed parameter time  but the function in k would grow more quickly 

   

fii terative p lan c onstruction for the w orkflow s atisfiability p roblem

definition    given an instance  s  u  a  c  of the wsp and a plan indistinguishability relation
  let  be the set of all plans  let pat be some set and consider a function enc     pat  for
any x  u  t  s  let pat x  t     enc  x  t     then we say enc is a  encoding  or an
encoding for   if  for any x  u  t  s and any         x  t    we have that
   enc       enc     if and only if       
   enc     can be calculated in time polynomial in n  k  m 
   there exists a linear ordering  on pat x  t   such that  for p  p   pat x  t    we can decide
whether p  p  in time polynomial in n  k  m 
the elements of pat are called  patterns  if enc     p then we say p is the  pattern of  
the second and third conditions of definition   ensure that we may use encodings to organise
our plans in a reasonable time  when  is clear from the context  we will refer to a  encoding as
an encoding and  patterns as patterns 
we note some complexity consequences of definition   in the following 
proposition    for an encoding of a plan indistinguishability relation  and a set of patterns pat  
by assigning patterns in pat to the nodes of a balanced binary tree  we can perform the following
two operations in time o  log  pat       i  check whether p  pat   and  ii  insert a pattern
p
  pat into pat  
proof  recall that comparisons are polynomial in n  k  m  now our result follows from the wellknown properties of balanced binary trees  e g   see  cormen  stein  rivest    leiserson         
we now show that the plan indistinguishability relations given in the previous section have
encodings  we first need to define a lexicographic order 
definition    given a totally ordered set  a     the  total  lexicographic order  on d tuples from
ad is defined as follows  we say that  x            xd     y            yd   if either xj   yj for all j   d 
or there is an i with xi   yi such that xj   yj for all j   i 
taking a   n and d   k we obtain the natural lexicographic order on nk   
we can also lexicographically order the sets of disjoint subsets of an ordered set t  
 t            tk    where t         tk  
definition    we associate a k tuple  x            xk    nk  with each set s of disjoint subsets
 s            sr   of  t            tk   as follows  we have xi     if ti 
  rm   sm   for ti  rm   sm  
 if there are j   i and m such that  ti   tj    sm then xi   xj  
 otherwise xi   max x            xi         where max      
we will write vec s     x            xk    note that vec s  can be computed in time o k     
thus  tasks in the same subset are assigned the same value  this assignment of integers
to tasks can be performed iteratively  for example  for t                  and the sets a  
                      and b                        we have vec a                             and
vec  b                              so a is lexicographically bigger than b 
   

fic ohen   c rampton   g agarin   g utin     j ones

corollary    let ui be the plan indistinguishability relation given for a set of user independent
constraints in lemma    then there exists an encoding for ui  
proof  let s            sk be an ordering of s and  a plan  let s         u    u  u ser    and
let vec     vec s     for a plan   let enc   be the tuple  u ser    task    vec    
it is clear that enc       enc     if and only if   ui     as r  si     r  sj   if and only
if yi   yj in vec r      y            yk    for r          furthermore it is clear that enc   can be
determined in polynomial time for any  
it remains to define a linear ordering on pat x  t   for a given x  u  t  s  for two
patterns p    x  t   x            xk     p     x  t   y            yk     pat x  t    we define p  p  if
 x            xk     y            yk   
example    let enc be the encoding given in the proof of corollary    let       be the plans
given in example    then enc       enc         u    u    u    u      s    s    s                         
corollary    let e be the plan indistinguishability relation given for a set of constraints on equivalence relations in lemma    then there exists an encoding for e  
proof  suppose  is an equivalence relation on users  and let v            vp be the equivalence classes
of  over u   suppose all constraints are of the form  si   sj     or  si   sj      
for a plan   define enc   to be  u ser    task    t     where

 
t        vj  u ser      vj  u ser        vj   u ser           j  p  
it is clear that enc       enc     if and only if   e     as i  s   vj if and only if
s  i   vj    for i          furthermore it is clear that enc   can be determined in polynomial
time for any  
it remains to define a linear ordering on pat x  t   for a given x  u  t  s  let    t  x
be a plan  as t  is a set of disjoint subsets of task    and t has a natural order  we can order
patterns in pat x  t   according to the lexicographic order of t   

example    let enc be the encoding given in the proof of corollary    let       be the plans
given in example    then enc       enc         u    u    u    u      s    s    s       s    s      
    the generic algorithm
we use the notion of diversity introduced in the next definition to analyse the running time of our
generic algorithm 
definition    let  s  u  a  c  be an instance of the wsp  with n    u    k    s  and m    c   and
suppose  is a plan indistinguishability relation with respect to c  given an ordering u            un
of u   let ui    u            ui   for each i   n   let wi be the number of equivalence classes of  over
the set  ui   t   of eligible plans  then we define the diversity of  with respect to u            un to be
w   maxi n  wi  
since our generic algorithm only stores one plan from each equivalence class under   we need
the notion of a representative set 
   

fii terative p lan c onstruction for the w orkflow s atisfiability p roblem

definition    given an instance  s  u  a  c  of the wsp  let   be a set of eligible plans and let 
be a plan indistinguishability relation  a set    is said to be a    representative set with respect to
 if the following properties hold 
           every plan in    is valid 
   for every valid         there exists a         such that          
when  is clear from context  we will say    is a    representative set or a representative set
for     our generic algorithm is based on finding plan indistinguishability relations for which there
exist small representative sets 
theorem    let  s  u  a  c  be an instance of the wsp  with n    u    k    s  and m    c   let
u            un be an ordering of u   and let ui    u            ui   for each i   n   and u      suppose
 has diversity w with respect to u            un   furthermore suppose that there exists a  encoding
enc   then  s  u  a  c  can be solved in time o    k w log w  
proof  the proof proceeds by demonstrating the correctness and then bounding the running time of
algorithm    which solves the wsp  to begin the proof  we give an overview of algorithm   
 for each i   n  in turn and each t  s  we will construct a representative set for  ui   t   
denoted by  ui   t    
 as well as constructing the set  ui   t     we also maintain a companion set pat ui   t    
enc   ui   t      this provides an efficient way of representing the equivalence classes of
 ui   t     in particular  it allows us to check whether a given valid plan  should be added
to  ui   t     faster than by searching  ui   t   linearly 
 after  un   s  has been constructed  it remains to check whether  un   s  is non empty 
as if there exists any valid complete plan   there exists a valid complete plan      un   s 
with       
algorithm   gives the details on how to construct  ui   t   for each i and t  
the proof of correctness of algorithm   proceeds by induction  observe first that for the case
of  u    t     if t     then there is no possible plan in  u    t    and so we set  u    t       if
t    then the only possible plan is the empty plan      this plan is added to  u        as it
is trivially valid  thus  u    t   is a  u    t   representative set for each t  
so now assume that for all t  s the set  ui   t   has been constructed and is a  ui   t  representative set  now consider the construction of  ui     t   for some t  s  it is clear that
for any  added to  ui     t        ui     t    and  is eligible  furthermore  is authorized 
as it is the union of the authorized plans      ui   t     and  t     ui      thus every plan
in  ui     t   is a valid plan in  ui     t    on the other hand  suppose  is a valid plan in
 ui     t    then let t           ui      and t     t   t      and let       ui   so that   
     t     ui      by assumption  there exists       ui   t   such that           consider
the plan           t     ui      it is clear that   will be considered during the algorithm 
furthermore  as         and         t     ui      we have that      therefore   is
eligible  as  is eligible  and also authorized  as it is the union of two authorized plans   therefore
   

fic ohen   c rampton   g agarin   g utin     j ones

algorithm    generic algorithm for the wsp
input   an instance  s  u  a  c  of the wsp  an ordering u            un of u   a
plan indistinguishability relation 
  set  u               
  foreach   
  t  s do
 
set  u    t      
  end
  set i     
  while i   n do
 
foreach t  s do
 
set  ui     t      
 
set pat ui     t      
  
foreach t    t do
  
set t      t   t    
  
if ui    a s  for all s  t    then
  
foreach      ui   t     do
  
set         t     ui     
  
if  is eligible then
  
set p   enc   
  
if p 
  pat ui     t   then
  
insert p into pat ui     t    
  
set  ui     t      ui     t       
  
end
  
end
  
end
  
end
  
end
  
end
  
set i   i     
   end
   if  un   s      then
  
return    un   s   
   else
  
return null 
   end

  is valid and will be added to  ui     t   unless  ui     t   already contains another plan equivalent to   thus   ui     t   contains a plan  equivalent to   from which it follows that
 ui     t   is a  ui     t   representative set  as required 
it remains to analyse the running time of the algorithm  by proposition    testing whether
a pattern p is in pat ui   t   and inserting p into pat ui   t   takes o  log  pat ui   t       time 
since by assumption   and our assumption on the time to check constraints and authorizations it
takes polynomial time to check eligibility  authorization and  equivalence of plans  the running
   

fii terative p lan c onstruction for the w orkflow s atisfiability p roblem

p
p
p
p

time of the algorithm is o   n 
i  
t s
t   t
 ui  t     log   ui     t        it is clear by
construction that  ui   t     contains at most one plan for each  equivalence class over  ui   t     
and sop
by definition
  ui   t        w for all i  t     it follows that the running time of the algorithm
p
n  p

is o   i   t s t   t w log w    o   k w log w  
remark    rather than checking whether  un   s  is non empty at the end of the algorithm  we
could instead check whether  ui   s  is non empty after the construction of  ui   s  for each i 
that is  we can stop our search as soon as we have a valid plan with task set s  this is likely to lead
to a saving in the running time of an implementation of the algorithm  as this paper is concerned
with the worst case running time  which would be unaffected by this change  we perform the check
at the end of the algorithm in the interest of clarity 
    application to user independent constraints and its optimality
in this subsection  we show that the wsp with user independent constraints is fpt  let bk denote
the kth bell number  the number of partitions of a set with k elements 
lemma    let u            un be any ordering of u   and let ui be the plan indistinguishability relation
given in lemma    then ui has diversity bk with respect to u            un  
proof  for any plan   the set      u    u  u ser    is a partition of the tasks in task   
furthermore  two plans that generate the same partition are equivalent under ui   therefore the
number of equivalence classes of ui over  ui   t   is exactly the number of possible partitions of
t   which is b t     thus  bk is the required diversity 
theorem    if all constraints are user independent  then the wsp can be solved in time
o   k log k   
proof  let u            un be any ordering of u   and let ui be the plan indistinguishability relation
given in lemma   
by lemma    ui has diversity bk with respect to u            un   furthermore  by corollary   
there exists an encoding for ui   therefore  we may apply theorem   with w   bk   to get an
algorithm with running time o   k bk log bk     o   k log k   as bk         k  ln k      k for
every k  berend   tassa        
the running time o   k log k   obtained is optimal in the sense that no algorithm of running time
exists  unless the eth fails  in the proof of the following theorem  we use a result
from lokshtanov  marx    saurabh        theorem      

o   o k log k   

theorem    there is no algorithm for the wsp with user independent constraints of running time
o   o k log k     unless the eth fails 
proof  we give a reduction from the problem kk i ndependent s et  given an integer parameter
k and a graph g with vertex set v     i  j    i  j   k    decide whether g has an independent set
i such that  i    k and for each r   k   there exists i such that  r  i   i 
informally  k  k i ndependent s et gives us a graph on a k  k grid of vertices  and asks
whether there is an independent set with one vertex from each row  lokshtanov et al         proved
that there is no algorithm to solve k  k i ndependent s et in time  o k log k    unless the eth fails 
   

fic ohen   c rampton   g agarin   g utin     j ones

consider an instance of k  k i ndependent s et with graph g  we will first produce an
equivalent instance of the wsp in which the constraints are not user independent  we will then
refine this instance to one with user independent constraints 
let u    u            uk   be a set of k users and s    s            sk   a set of k tasks  let the
authorization lists be a si     u for all i   k   for i  j  h  l   k   let c  i  j    h  l   denote
the constraint with scope  si   sh    and which is satisfied by any plan  unless  si     uj and
 sh     ul   for every pair of vertices  i  j    h  l  which are adjacent in g  add the constraint
c  i  j    h  l   to c 
we now show that  s  u  a  c  is a y es instance of the wsp if and only if g has an independent set with one vertex from each row  suppose  s  u  a  c  is a y es instance of the wsp and
let  be a valid complete plan  then for each i   k   let f  i  be the unique j such that  si     uj  
then i     i  f  i     i   k   is a set with one vertex from each row in g  furthermore  as  satisfies every constraint  no edge in g contains more than one element of i  and so i is an independent
set 
conversely  suppose g is a y es instance of k  k i ndependent
s et  for each i   k   let
s
f  i  be an integer such that  i  f  i    i  then observe that ki     si    uf  i    is a valid complete
plan 
we now show how to reduce  s  u  a  c  to an instance of the wsp in which all constraints
are user independent  the main idea is to introduce some new tasks representing the users  and in
the constraints  replace the mention of a particular user with the mention of the user that performs a
particular task 
create k new tasks t            tk and let s     s   t              tk    let the authorization lists be
 
a  s    u for each s  s and a   ti      ui   for each i   k   for each constraint c  i  j    h  l  
in c  let d  i  j    h  l   be the constraint with scope  si   sh   tj   tl    which is satisfied by any plan 
unless  si      tj   and  sh      tl    let initially c     c  now replace  in c     every constraint
c  i  j    h  l   with d  i  j      h  l   
since they are defined by equalities  and no users are mentioned  the constraints in c   are userindependent  we now show that  s     u  a    c     is equivalent to  s  u  a  c   first  suppose that 
is a valid complete plan for  s  u  a  c   then let      s    u be the plan such that     si      si  
for all i   k   and     tj     uj for all j   k   it is easy to check that if  satisfies every constraint
of c then    satisfies every constraint of c     since    is an authorized and eligible plan     is a valid
complete plan for  s     u  a    c     
conversely  suppose that    is a valid complete plan for  s     u  a    c      since a   ti      ui   for
each i   k       ti     ui for every i   k   for each i   k   let f  i  be the unique integer such that
    si     uf  i    then define    s  u by  si     uf  i    and observe that all constraints in c are
satisfied by   so   is a valid complete plan for  s  u  a  c  
    application to equivalence relation constraints
it is known that restricting the wsp to have only equivalence relation constraints is enough to ensure
that the problem is fpt  crampton et al          however  we can derive this result by applying our
algorithm directly having shown the appropriate properties of the language of equivalence relation
constraints  this serves to demonstrate the wide applicability of our approach 

   

fii terative p lan c onstruction for the w orkflow s atisfiability p roblem

lemma    let e be the plan indistinguishability relation given for a set of equivalence relation
constraints in lemma    then there exists an ordering u            un of u such that e has diversity
 k with respect to u  
proof  suppose  is an equivalence relation on users  and let v            vp be the equivalence classes
of  over u   suppose all constraints are of the form  si   sj     or  si   sj      
let u            un be an ordering of u such that all the elements of vj appear before all the elements
of vj     for any j   j     thus  for any i and any plan  with u ser     ui    u            ui    there is
at most one integer ji such that vji  u ser        vji   u ser       
it follows that any two plans         ui   t   are e  equivalent  for any i   n   t  s 
provided that    t   vji if and only if    t   vji for any t  t   therefore e has at most  k
equivalence classes over  ui   t    as required 
theorem    suppose  is an equivalence relation on u   suppose all constraints are of the form
 si   sj     or  si   sj       then the wsp can be solved in time o   k   
proof  let u            un be the ordering of u given by lemma    and let e be the planindistinguishability relation given in lemma   
by lemma    e has diversity  k with respect to u            un   furthermore by corollary    there
exists an encoding for e   therefore  we may apply theorem   with w    k   to get an algorithm
with running time o   k  k log  k      o   k   

   unions of constraint languages
in this section we show how our approach allows us easily to combine constraint languages shown
to be fpt for the wsp  we do not need to build bespoke algorithms for the new constraint language
obtained  only to show that the two languages are in some sense compatible 
this highlights the advantages of our approach over previous methods  which required the development of new algorithms when different constraint languages were combined in an instance of
the wsp  e g   see crampton et al         
theorem    let  s  u  a  c   c    be an instance of the wsp  and suppose   is a planindistinguishability relation with respect to c  and   is a plan indistinguishability relation with
respect to c    given an ordering u            un of u   let w  be the diversity of   with respect to
u            un and w  the diversity of   with respect to u            un  
let  be the equivalence relation such that      if and only if       and         then
 is a plan indistinguishability relation with respect to c   c    and  has diversity w  w  with
respect to u            un  
proof  we first show that  is a plan indistinguishability relation with respect to c   c    let 
and    be eligible plans  with respect to c   c     as      implies       and   satisfies
the conditions of a plan indistinguishability relation  it is clear that if      then u ser    
u ser      and task     task       now consider a plan     disjoint from  and      as   is a
plan indistinguishability relation with respect to c  and         we have that       is c   eligible
if and only if         is  similarly       is c   eligible if and only if         is  observing that a
plan is c   c   eligible if and only if it is c   eligible and c   eligible  this implies that       is
c   c   eligible if and only if         is  thus we have that  and    are extension equivalent 
   

fic ohen   c rampton   g agarin   g utin     j ones

as   and   are plan indistinguishability relations  we have that                 and
                  and therefore                  thus   satisfies all the conditions of a
plan indistinguishability relation 
to bound the diversity of  with respect to u            un   consider any t  s and ui  
 u            ui    it is enough to note that any  equivalent plans in  ui   t   must be in the same
  and    equivalence classes  as there are at most w  choices for the    equivalence class and
at most w  choices for the   equivalence class   has at most w  w  equivalence classes over
 ui   t   
remark    given an encoding enc  for   and an encoding enc  for     we may construct an
encoding for   given a plan   let enc   be the ordered pair  enc      enc       it is clear
that enc     enc      if and only if       
given sets t  s and ui    u            ui    fix linear orderings of enc    ui   t    and
enc     ui   t     then let  be the lexicographic ordering of enc   ui   t      enc     ui   t    
enc     ui   t    
there is nothing to stop us applying theorem   multiple times  in order to get a planindistinguishability relation with bounded diversity for a union of several constraint languages 
note that the diversity can be expected to grow exponentially with the number of languages in the
union  thus  it makes sense to only apply theorem   to the union of a small number of languages 
however  as long as there is a fixed number of languages  and each has a plan indistinguishability
relation with fixed parameter diversity  the resulting union of languages will also have a planindistinguishability relation with fixed parameter diversity 
we can now use this result directly to show that if all our constraints are either user independent
or equivalence relation constraints  then the wsp is still fpt 
theorem    suppose  is an equivalence relation on u   let  s  u  a  c  be an instance of the
wsp  and suppose that all constraints are either of the form   s    s        s    s       or userindependent constraints  then the wsp can be solved in time o   k log k k   
proof  let ce  c be the set of constraints of the form  s    s        s    s        and let cui be the
remaining  user independent  constraints 
let u            un be the ordering of u given by lemma    by lemmas   and    there exists a planindistinguishability relation e for ce that has diversity  k with respect to u            un   furthermore
by corollary    e has an encoding  by lemmas   and    there exists a plan indistinguishability
relation ui for cui that has diversity bk with respect to u            un   furthermore by corollary   
ui has an encoding 
therefore by theorem    we may find a plan indistinguishability relation  for c  such
that  has diversity bk   k with respect to u            un and  has an encoding  thus we
may apply theorem   with w   bk   k   to get a running time of o   k bk  k log bk  k     
o   k  k log k  o     k log  k log k  o     k      o   k log k k   

   computational experiments with wsp algorithms
apart from conducting theoretical research on the wsp  wang and li        carried out an experimental study of the problem  due to the difficulty of acquiring real world workflow instances 
   

fii terative p lan c onstruction for the w orkflow s atisfiability p roblem

wang and li used synthetic data in their experimental study  they encoded instances of the wsp
into pseudo boolean sat in order to use a pseudo boolean sat solver sat j 
we have implemented our algorithm and compared its performance to sat j on another set
of synthetic instances of the wsp  cohen et al          these instances use k          and
    n     k and user independent  cardinality  constraints of three different types  we vary the
number of constraints and the proportions of the different constraint types  each user is authorized
for between   and   tasks for k       between   and    tasks for k       and between   and   
tasks for k       the algorithm was implemented in c   and has been enhanced by the inclusion
of techniques employed in csp solving  such as propagation  we also converted wsp instances into
pseudo boolean problems for processing by sat j  all experiments were performed on a macbook
pro computer with a     ghz intel core i  processor and   gb      mhz ddr  ram  running
mac os x         
for lightly constrained instances  sat j was often faster than our algorithm  largely because
the number of patterns considered by our algorithm is large for such instances  however  for highlyconstrained instances  sat j was unable to compute a decision for a number of instances  because
it ran out of memory   in sharp contrast to our algorithm which solved all instances  overall  on
average  our algorithm was faster than sat j and  in particular  was two orders of magnitude faster
for k       moreover  the time taken by our algorithm varies much less than that of sat j  even
for unsatisfiable instances  because the time taken is proportional to the product of the number of
patterns and the number of users   in particular  in tested instances  it is much less dependent on the
number of constraints  a parameter that can cause significant fluctuations in the time taken by sat j
because it leads to a sharp increase in the number of variables in the pseudo boolean encoding   full
details of our results have been published  cohen et al         

   conclusion
in this paper we introduced an algorithm based on the notion of plan indistinguishability  applicable
to a wide range of wsp instances  we showed that our algorithm is powerful enough to be optimal 
in a sense  for the wide class of user independent constraints  the generic algorithm is also a
fixed parameter algorithm for equivalence relation constraints  which are not user independent  we
showed how to deal with unions of different types of constraints using our generic algorithm  in
particular  we proved that the generic algorithm is a fixed parameter algorithm for the union of
user independent and equivalence relation constraints 

acknowledgments
our research was supported by epsrc grant ep k          we are grateful to the referees for
their useful comments and suggestions 

references
american national standards institute        
cits rbac           
   

role based access control  ansi in 

fic ohen   c rampton   g agarin   g utin     j ones

basin  d  a   burri  s  j     karjoth  g          obstruction free authorization enforcement  aligning security and business objectives  journal of computer security                
beldiceanu  n   carlsson  m     rampon  j  x          global constraint catalog   nd edition
 revision a   working copy       swedish institute of computer science  kista  sweden 
berend  d     tassa  t          improved bounds on bell numbers and on moments of sums of
random variables  probability and mathematical statistics                
bertino  e   bonatti  p  a     ferrari  e          trbac  a temporal role based access control
model  acm trans  inf  syst  secur                
bertino  e   ferrari  e     atluri  v          the specification and enforcement of authorization
constraints in workflow management systems  acm trans  inf  syst  secur               
bodlaender  h  l   cygan  m   kratsch  s     nederlof  j          deterministic single exponential
time algorithms for connectivity problems parameterized by treewidth  in proceedings of the
  th international conference on automata  languages  and programming   volume part i 
icalp    pp          berlin  heidelberg  springer verlag 
bulatov  a   jeavons  p     krokhin  a          classifying the complexity of constraints using
finite algebras  siam journal on computing             
cohen  d   crampton  j   gagarin  a   gutin  g     jones  m          engineering algorithms
for workflow satisfiability problem with user independent constraints  in chen  j   hopcroft 
j  e     wang  j   eds    frontiers in algorithmics    th international workshop  faw      
zhangjiajie  china  june              proceedings  vol       of lecture notes in computer
science  pp        springer 
cormen  t  h   stein  c   rivest  r  l     leiserson  c  e          introduction to algorithms   nd
edition   mcgraw hill higher education 
crampton  j   crowston  r   gutin  g   jones  m     ramanujan  m          fixed parameter
tractability of workflow satisfiability in the presence of seniority constraints  in fellows  m  
tan  x     zhu  b   eds    frontiers in algorithmics and algorithmic aspects in information
and management  vol       of lecture notes in computer science  pp          springer
berlin heidelberg 
crampton  j          a reference monitor for workflow systems with constrained task execution 
in proceedings of the tenth acm symposium on access control models and technologies 
sacmat     pp        new york  ny  usa  acm 
crampton  j     gutin  g          constraint expressions and workflow satisfiability  in proceedings of the   th acm symposium on access control models and technologies  sacmat    
pp        new york  ny  usa  acm 
crampton  j   gutin  g     yeo  a          on the parameterized complexity and kernelization of
the workflow satisfiability problem  acm trans  inf  syst  secur                  
dechter  r          constraint processing  morgan kaufmann publishers      pine street  sixth
floor  san francisco  ca            
downey  r  g     fellows  m  r          fundamentals of parameterized complexity  texts in
computer science  springer 
   

fii terative p lan c onstruction for the w orkflow s atisfiability p roblem

fomin  f  v   lokshtanov  d     saurabh  s          efficient computation of representative sets
with applications in parameterized and exact algorithms  in proceedings of the twenty fifth
annual acm siam symposium on discrete algorithms  soda     pp          siam 
gligor  v   gavrila  s     ferraiolo  d          on the formal definition of separation of duty policies and their composition  in      ieee symposium on security and privacy        proceedings   pp         
impagliazzo  r   paturi  r     zane  f          which problems have strongly exponential complexity   j  comput  syst  sci                 
jayaraman  k   ganesh  v   tripunitara  m  v   rinard  m  c     chapin  s  j          arbac
policy for a large multi national bank  corr  abs           
joshi  j  b  d   bertino  e   latif  u     ghafoor  a          a generalized temporal role based
access control model  ieee transactions on knowledge and data engineering              
lokshtanov  d   marx  d     saurabh  s          slightly superexponential parameterized problems 
in proceedings of the twenty second annual acm siam symposium on discrete algorithms 
soda     pp          siam 
niedermeier  r          invitation to fixed parameter algorithms  oxford university press 
rossi  f   van beek  p     walsh  t   eds            the handbook of constraint programming 
elsevier 
sandhu  r  s   coyne  e  j   feinstein  h  l     youman  c  e          role based access control
models  computer              
schaad  a   moffett  j     jacob  j          the role based access control system of a european
bank  a case study and discussion  in proceedings of the sixth acm symposium on access
control models and technologies  sacmat     pp      new york  ny  usa  acm 
simon  r     zurko  m          separation of duty in role based environments  in computer
security foundations workshop        proceedings     th  pp         
wang  q     li  n          satisfiability and resiliency in workflow authorization systems  acm
trans  inf  syst  secur                    
wolter  c     schaad  a          modeling of task based authorization constraints in bpmn  in
proceedings of the  th international conference on business process management  bpm   
pp        berlin  heidelberg  springer verlag 

   

fi