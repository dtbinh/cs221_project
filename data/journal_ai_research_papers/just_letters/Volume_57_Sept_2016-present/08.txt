journal of artificial intelligence research                 

submitted       published      

a primer on neural network models
for natural language processing
yoav goldberg

yoav goldberg gmail com

computer science department
bar ilan university  israel

abstract
over the past few years  neural networks have re emerged as powerful machine learning
models  yielding state of the art results in fields such as image recognition and speech
processing  more recently  neural network models started to be applied also to textual
natural language signals  again with very promising results  this tutorial surveys neural
network models from the perspective of natural language processing research  in an attempt
to bring natural language researchers up to speed with the neural techniques  the tutorial
covers input encoding for natural language tasks  feed forward networks  convolutional
networks  recurrent networks and recursive networks  as well as the computation graph
abstraction for automatic gradient computation 

   introduction
for over a decade  core nlp techniques were dominated by machine learning approaches
that used linear models such as support vector machines or logistic regression  trained over
very high dimensional yet very sparse feature vectors 
recently  the field has seen some success in switching from such linear models over
sparse inputs to non linear neural network models over dense inputs  while most of the
neural network techniques are easy to apply  sometimes as almost drop in replacements of
the old linear classifiers  there is in many cases a strong barrier of entry  in this tutorial i
attempt to provide nlp practitioners  as well as newcomers  with the basic background 
jargon  tools and methodology that will allow them to understand the principles behind
the neural network models and apply them to their own work  this tutorial is expected
to be self contained  while presenting the different approaches under a unified notation and
framework  it repeats a lot of material which is available elsewhere  it also points to
external sources for more advanced topics when appropriate 
this primer is not intended as a comprehensive resource for those that will go on and
develop the next advances in neural network machinery  though it may serve as a good entry
point   rather  it is aimed at those readers who are interested in taking the existing  useful
technology and applying it in useful and creative ways to their favourite nlp problems  for
more in depth  general discussion of neural networks  the theory behind them  advanced
optimization methods and other advanced topics  the reader is referred to other existing
resources  in particular  the book by bengio  goodfellow  and courville        is highly
recommended 
c
    
ai access foundation  all rights reserved 

figoldberg

    scope
the focus is on applications of neural networks to language processing tasks  however 
some subareas of language processing with neural networks were deliberately left out of
scope of this tutorial  these include the vast literature of language modeling and acoustic
modeling  the use of neural networks for machine translation  and multi modal applications
combining language and other signals such as images and videos  e g  caption generation  
caching methods for efficient runtime performance  methods for efficient training with large
output vocabularies and attention models are also not discussed  word embeddings are
discussed only to the extent that is needed to understand in order to use them as inputs
for other models  other unsupervised approaches  including autoencoders and recursive
autoencoders  also fall out of scope  while some applications of neural networks for language
modeling and machine translation are mentioned in the text  their treatment is by no means
comprehensive 
    a note on terminology
the word feature is used to refer to a concrete  linguistic input such as a word  a suffix  or
a part of speech tag  for example  in a first order part of speech tagger  the features might
be current word  previous word  next word  previous part of speech  the term input
vector is used to refer to the actual input that is fed to the neural network classifier 
similarly  input vector entry refers to a specific value of the input  this is in contrast to
a lot of the neural networks literature in which the word feature is overloaded between
the two uses  and is used primarily to refer to an input vector entry 
    mathematical notation
i use bold upper case letters to represent matrices  x  y  z   and bold lower case letters to
represent vectors  b   when there are series of related matrices and vectors  for example 
where each matrix corresponds to a different layer in the network   superscript indices are
used  w    w     for the rare cases in which we want indicate the power of a matrix or
a vector  a pair of brackets is added around the item to be exponentiated   w      w      
unless otherwise stated  vectors are assumed to be row vectors  we use  v    v    to denote
vector concatenation 
the choice to use row vectors  which are right multiplied by matrices  xw   b  is
somewhat non standard  a lot of the neural networks literature use column vectors that
are left multiplied by matrices  wx   b   we trust the reader to be able to adapt to the
column vectors notation when reading the literature  

   the choice to use the row vectors notation was inspired by the following benefits  it matches the way
input vectors and network diagrams are often drawn in the literature  it makes the hierarchical layered
structure of the network more transparent and puts the input as the left most variable rather than being
nested  it results in fully connected layer dimensions being din  dout rather than dout  din   and it maps
better to the way networks are implemented in code using matrix libraries such as numpy 

   

fia primer on neural networks for nlp

   neural network architectures
neural networks are powerful learning models  we will discuss two kinds of neural network
architectures  that can be mixed and matched  feed forward networks and recurrent  
recursive networks  feed forward networks include networks with fully connected layers 
such as the multi layer perceptron  as well as networks with convolutional and pooling
layers  all of the networks act as classifiers  but each with different strengths 
fully connected feed forward neural networks  section    are non linear learners that
can  for the most part  be used as a drop in replacement wherever a linear learner is used 
this includes binary and multiclass classification problems  as well as more complex structured prediction problems  section     the non linearity of the network  as well as the
ability to easily integrate pre trained word embeddings  often lead to superior classification accuracy  a series of works  managed to obtain improved syntactic parsing results
by simply replacing the linear model of a parser with a fully connected feed forward network  straight forward applications of a feed forward network as a classifier replacement
 usually coupled with the use of pre trained word vectors  provide benefits also for ccg
supertagging   dialog state tracking   pre ordering for statistical machine translation  and
language modeling   iyyer  manjunatha  boyd graber  and daume iii        demonstrate
that multi layer feed forward networks can provide competitive results on sentiment classification and factoid question answering 
networks with convolutional and pooling layers  section    are useful for classification
tasks in which we expect to find strong local clues regarding class membership  but these
clues can appear in different places in the input  for example  in a document classification
task  a single key phrase  or an ngram  can help in determining the topic of the document
 johnson   zhang         we would like to learn that certain sequences of words are good
indicators of the topic  and do not necessarily care where they appear in the document 
convolutional and pooling layers allow the model to learn to find such local indicators 
regardless of their position  convolutional and pooling architecture show promising results
on many tasks  including document classification   short text categorization   sentiment
classification   relation type classification between entities    event detection    paraphrase
identification    semantic role labeling    question answering    predicting box office rev 

   chen and manning         weiss  alberti  collins  and petrov        and pei  ge  and chang       
and durrett and klein       
   lewis and steedman       
   henderson  thomson  and young       
   de gispert  iglesias  and byrne       
   bengio  ducharme  vincent  and janvin        and vaswani  zhao  fossum  and chiang       
   johnson and zhang       
   wang  xu  xu  liu  zhang  wang  and hao      a 
   kalchbrenner  grefenstette  and blunsom        and kim       
    zeng  liu  lai  zhou  and zhao         dos santos  xiang  and zhou       
    chen  xu  liu  zeng  and zhao         nguyen and grishman       
    yin and schutze       
    collobert  weston  bottou  karlen  kavukcuoglu  and kuksa       
    dong  wei  zhou  and xu       

   

figoldberg

enues of movies based on critic reviews    modeling text interestingness    and modeling
the relation between character sequences and part of speech tags   
in natural language we often work with structured data of arbitrary sizes  such as
sequences and trees  we would like to be able to capture regularities in such structures 
or to model similarities between such structures  in many cases  this means encoding
the structure as a fixed width vector  which we can then pass on to another statistical
learner for further processing  while convolutional and pooling architectures allow us to
encode arbitrary large items as fixed size vectors capturing their most salient features 
they do so by sacrificing most of the structural information  recurrent  section     and
recursive  section     architectures  on the other hand  allow us to work with sequences
and trees while preserving a lot of the structural information  recurrent networks  elman 
      are designed to model sequences  while recursive networks  goller   kuchler       
are generalizations of recurrent networks that can handle trees  we will also discuss an
extension of recurrent networks that allow them to model stacks  dyer  ballesteros  ling 
matthews    smith        watanabe   sumita        
recurrent models have been shown to produce very strong results for language modeling      as well as for sequence tagging    machine translation    dependency parsing   
sentiment analysis    noisy text normalization    dialog state tracking    response generation    and modeling the relation between character sequences and part of speech tags   
recursive models were shown to produce state of the art or near state of the art results
for constituency   and dependency   parse re ranking  discourse parsing    semantic relation
classification    political ideology detection based on parse trees    sentiment classification   
target dependent sentiment classification   and question answering   
   
   
   
   

   
   

   
   
   
   
   
   
   
   
   
   
   
   
   
   

bitvai and cohn       
gao  pantel  gamon  he  and deng       
dos santos and zadrozny       
some notable works are by mikolov  karafiat  burget  cernocky  and khudanpur         mikolov 
kombrink  lukas burget  cernocky  and khudanpur         mikolov         duh  neubig  sudoh  and
tsukada         adel  vu  and schultz         auli  galley  quirk  and zweig        and auli and gao
      
irsoy and cardie         xu  auli  and clark         ling  dyer  black  trancoso  fermandez  amir 
marujo  and luis      b 
sundermeyer  alkhouli  wuebker  and ney         tamura  watanabe  and sumita         sutskever 
vinyals  and le        and cho  van merrienboer  gulcehre  bahdanau  bougares  schwenk  and bengio
     b 
dyer et al          watanabe and sumita       
wang  liu  sun  wang  and wang      b 
chrupala       
mrksic  o seaghdha  thomson  gasic  su  vandyke  wen  and young       
sordoni  galley  auli  brockett  ji  mitchell  nie  gao  and dolan       
ling et al       b 
socher  bauer  manning  and ng       
le and zuidema         zhu  qiu  chen  and huang      a 
li  li  and hovy       
hashimoto  miwa  tsuruoka  and chikayama         liu  wei  li  ji  zhou  and wang       
iyyer  enns  boyd graber  and resnik      b 
socher  perelygin  wu  chuang  manning  ng  and potts         hermann and blunsom       
dong  wei  tan  tang  zhou  and xu       
iyyer  boyd graber  claudino  socher  and daume iii      a 

   

fia primer on neural networks for nlp

   feature representation
before discussing the network structure in more depth  it is important to pay attention
to how features are represented  for now  we can think of a feed forward neural network
as a function nn x  that takes as input a din dimensional vector x and produces a dout
dimensional output vector  the function is often used as a classifier  assigning the input x
a degree of membership in one or more of dout classes  the function can be complex  and is
almost always non linear  common structures of this function will be discussed in section   
here  we focus on the input  x  when dealing with natural language  the input x encodes
features such as words  part of speech tags or other linguistic information  perhaps the
biggest conceptual jump when moving from sparse input linear models to neural network
based models is to stop representing each feature as a unique dimension  the so called
one hot representation  and representing them instead as dense vectors  that is  each core
feature is embedded into a d dimensional space  and represented as a vector in that space   
the embeddings  the vector representation of each core feature  can then be trained like
the other parameter of the function nn  figure   shows the two approaches to feature
representation 
the feature embeddings  the values of the vector entries for each feature  are treated
as model parameters that need to be trained together with the other components of the
network  methods of training  or obtaining  the feature embeddings will be discussed later 
for now  consider the feature embeddings as given 
the general structure for an nlp classification system based on a feed forward neural
network is thus 
   extract a set of core linguistic features f            fk that are relevant for predicting the
output class 
   for each feature fi of interest  retrieve the corresponding vector v fi   
   combine the vectors  either by concatenation  summation or a combination of both 
into an input vector x 
   feed x into a non linear classifier  feed forward neural network  
the biggest change in the input  then  is the move from sparse representations in which
each feature is its own dimension  to a dense representation in which each feature is mapped
to a vector  another difference is that we extract only core features and not feature combinations  we will elaborate on both these changes briefly 
    dense vectors vs  one hot representations
what are the benefits of representing our features as vectors instead of as unique ids 
should we always represent features as dense vectors  lets consider the two kinds of
representations 

    different feature types may be embedded into different spaces  for example  one may represent word
features using     dimensions  and part of speech features using    dimensions 

   

figoldberg

figure    sparse vs  dense feature representations  two encodings of the information  current word is dog  previous word is the  previous pos tag is det 
 a  sparse feature vector  each dimension represents a feature  feature combinations receive their own dimensions  feature values are binary  dimensionality
is very high   b  dense  embeddings based feature vector  each core feature is
represented as a vector  each feature corresponds to several input vector entries  no explicit encoding of feature combinations  dimensionality is low  the
feature to vector mappings come from an embedding table 

   

fia primer on neural networks for nlp

one hot each feature is its own dimension 
 dimensionality of one hot vector is same as number of distinct features 

 features are completely independent from one another  the feature word is
dog  is as dis similar to word is thinking  than it is to word is cat  
dense each feature is a d dimensional vector 
 dimensionality of vector is d 

 model training will cause similar features to have similar vectors  information
is shared between similar features 
one benefit of using dense and low dimensional vectors is computational  the majority
of neural network toolkits do not play well with very high dimensional  sparse vectors 
however  this is just a technical obstacle  which can be resolved with some engineering
effort 
the main benefit of the dense representations is in generalization power  if we believe
some features may provide similar clues  it is worthwhile to provide a representation that
is able to capture these similarities  for example  assume we have observed the word dog
many times during training  but only observed the word cat a handful of times  or not at
all  if each of the words is associated with its own dimension  occurrences of dog will not
tell us anything about the occurrences of cat  however  in the dense vectors representation
the learned vector for dog may be similar to the learned vector from cat  allowing the
model to share statistical strength between the two events  this argument assumes that
good vectors are somehow given to us  section   describes ways of obtaining such vector
representations 
in cases where we have relatively few distinct features in the category  and we believe
there are no correlations between the different features  we may use the one hot representation  however  if we believe there are going to be correlations between the different features
in the group  for example  for part of speech tags  we may believe that the different verb
inflections vb and vbz may behave similarly as far as our task is concerned  it may be
worthwhile to let the network figure out the correlations and gain some statistical strength
by sharing the parameters  it may be the case that under some circumstances  when the
feature space is relatively small and the training data is plentiful  or when we do not wish to
share statistical information between distinct words  there are gains to be made from using
the one hot representations  however  this is still an open research question  and there are
no strong evidence to either side  the majority of work  pioneered in collobert   weston 
      collobert et al        chen   manning        advocate the use of dense  trainable
embedding vectors for all features  for work using neural network architecture with sparse
vector encodings see the work by johnson and zhang        
finally  it is important to note that representing features as dense vectors is an integral
part of the neural network framework  and that consequentially the differences between
using sparse and dense feature representations are subtler than they may appear at first 
in fact  using sparse  one hot vectors as input when training a neural network amounts
to dedicating the first layer of the network to learning a dense embedding vector for each
feature based on the training data  we touch on this in section     
   

figoldberg

    variable number of features  continuous bag of words
feed forward networks assume a fixed dimensional input  this can easily accommodate the
case of a feature extraction function that extracts a fixed number of features  each feature
is represented as a vector  and the vectors are concatenated  this way  each region of the
resulting input vector corresponds to a different feature  however  in some cases the number
of features is not known in advance  for example  in document classification it is common
that each word in the sentence is a feature   we thus need to represent an unbounded
number of features using a fixed size vector  one way of achieving this is through a socalled continuous bag of words  cbow  representation  mikolov  chen  corrado    dean 
       the cbow is very similar to the traditional bag of words representation in which
we discard order information  and works by either summing or averaging the embedding
vectors of the corresponding features   
cbow f         fk    

k
 x
v fi  
k

   

i  

a simple variation on the cbow representation is weighted cbow  in which different
vectors receive different weights 
 
wcbow f         fk     pk

i   ai

k
x

ai v fi  

   

i  

here  each feature fi has an associated weight ai   indicating the relative importance of the
feature  for example  in a document classification task  a feature fi may correspond to a
word in the document  and the associated weight ai could be the words tf idf score 
    distance and position features
the linear distance in between two words in a sentence may serve as an informative feature 
for example  in an event extraction task   we may be given a trigger word and a candidate
argument word  and asked to predict if the argument word is indeed an argument of the
trigger  the distance  or relative position  between the trigger and the argument is a strong
signal for this prediction task  in the traditional nlp setup  distances are usually encoded
by binning the distances into several groups  i e                        and associating each
bin with a one hot vector  in a neural architecture  where the input vector is not composed
of binary indicator features  it may seem natural to allocate a single input entry to the
distance feature  where the numeric value of that entry is the distance  however  this
approach is not taken in practice  instead  distance features are encoded similarly to the
    note that if the v fi  s were one hot vectors rather than dense feature representations  the cbow  eq
   and wcbow  eq    would reduce to the traditional  weighted  bag of words representations  which
is in turn equivalent to a sparse feature vector representation in which each binary indicator feature
corresponds to a unique word 
    the event extraction task involves identification of events from a predefined set of event types  for
example identification of purchase events or terror attack events  each event type can be triggered
by various triggering words  commonly verbs   and has several slots  arguments  that needs to be filled
 i e  who purchased  what was purchased  at what amount   

   

fia primer on neural networks for nlp

other feature types  each bin is associated with a d dimensional vector  and these distanceembedding vectors are then trained as regular parameters in the network  zeng et al        
dos santos et al         zhu et al       a  nguyen   grishman        
    feature combinations
note that the feature extraction stage in the neural network settings deals only with extraction of core features  this is in contrast to the traditional linear model based nlp systems
in which the feature designer had to manually specify not only the core features of interest
but also interactions between them  e g   introducing not only a feature stating word is
x and a feature stating tag is y but also combined feature stating word is x and tag
is y or sometimes even word is x  tag is y and previous word is z   the combination
features are crucial in linear models because they introduce more dimensions to the input 
transforming it into a space where the data points are closer to being linearly separable  on
the other hand  the space of possible combinations is very large  and the feature designer
has to spend a lot of time coming up with an effective set of feature combinations  one
of the promises of the non linear neural network models is that one needs to define only
the core features  the non linearity of the classifier  as defined by the network structure 
is expected to take care of finding the indicative feature combinations  alleviating the need
for feature combination engineering 
kernel methods  shawe taylor   cristianini         and in particular polynomial kernels
 kudo   matsumoto         also allow the feature designer to specify only core features 
leaving the feature combination aspect to the learning algorithm  in contrast to neuralnetwork models  kernels methods are convex  admitting exact solutions to the optimization
problem  however  the computational complexity of classification in kernel methods scales
linearly with the size of the training data  making them too slow for most practical purposes 
and not suitable for training with large datasets  on the other hand  the computational
complexity of classification using neural networks scales linearly with the size of the network 
regardless of the training data size 
    dimensionality
how many dimensions should we allocate for each feature  unfortunately  there are no theoretical bounds or even established best practices in this space  clearly  the dimensionality
should grow with the number of the members in the class  you probably want to assign
more dimensions to word embeddings than to part of speech embeddings  but how much is
enough  in current research  the dimensionality of word embedding vectors range between
about    to a few hundreds  and  in some extreme cases  thousands  since the dimensionality of the vectors has a direct effect on memory requirements and processing time  a good
rule of thumb would be to experiment with a few different sizes  and choose a good trade off
between speed and task accuracy 
    vector sharing
consider a case where you have a few features that share the same vocabulary  for example 
when assigning a part of speech to a given word  we may have a set of features considering
   

figoldberg

the previous word  and a set of features considering the next word  when building the input
to the classifier  we will concatenate the vector representation of the previous word to the
vector representation of the next word  the classifier will then be able to distinguish the two
different indicators  and treat them differently  but should the two features share the same
vectors  should the vector for dog previous word be the same as the vector of dog nextword  or should we assign them two distinct vectors  this  again  is mostly an empirical
question  if you believe words behave differently when they appear in different positions
 e g   word x behaves like word y when in the previous position  but x behaves like z when
in the next position  then it may be a good idea to use two different vocabularies and assign
a different set of vectors for each feature type  however  if you believe the words behave
similarly in both locations  then something may be gained by using a shared vocabulary for
both feature types 
    networks output
for multi class classification problems with k classes  the networks output is a k dimensional
vector in which every dimension represents the strength of a particular output class  that
is  the output remains as in the traditional linear models  scalar scores to items in a discrete
set  however  as we will see in section    there is a d  k matrix associated with the output
layer  the columns of this matrix can be thought of as d dimensional embeddings of the
output classes  the vector similarities between the vector representations of the k classes
indicate the models learned similarities between the output classes 
    historical note
representing words as dense vectors for input to a neural network was popularized by bengio
et al         in the context of neural language modeling  it was introduced to nlp tasks in
the pioneering work of collobert  weston and colleagues                 using embeddings
for representing not only words but arbitrary features was popularized following chen and
manning        

   feed forward neural networks
this section introduces feed forward neural networks  it starts with the popular brain
inspired metaphor that triggered them  but quickly switches back to using mathematical
notation  we discuss the structure of feed forward neural networks  their representation
power  and common non linearities and loss functions 
    a brain inspired metaphor
as the name suggests  neural networks are inspired by the brains computation mechanism 
which consists of computation units called neurons  in the metaphor  a neuron is a computational unit that has scalar inputs and outputs  each input has an associated weight 
    while the work by bengio  collobert  weston and colleagues popularized the approaches  they were not
the first to use them  earlier authors that use dense continuous space vectors for representing word inputs
to neural networks include lee et al         and forcada and neco         similarly  continuous space
language models were used for machine translation already by schwenk et al         

   

fia primer on neural networks for nlp

the neuron multiplies each input by its weight  and then sums   them  applies a non linear
function to the result  and passes it to its output  the neurons are connected to each other 
forming a network  the output of a neuron may feed into the inputs of one or more neurons 
such networks were shown to be very capable computational devices  if the weights are set
correctly  a neural network with enough neurons and a non linear activation function can
approximate a very wide range of mathematical functions  we will be more precise about
this later  
output
layer

hidden
layer

hidden
layer

input layer

r

r

y 

y 

y 

r

r

r

r

r

r

r

r

x 

x 

x 

x 

r

figure    feed forward neural network with two hidden layers 
a typical feed forward neural network may be drawn as in figure    each circle is a
neuron  with incoming arrows being the neurons inputs and outgoing arrows being the neurons outputs  each arrow carries a weight  reflecting its importance  not shown   neurons
are arranged in layers  reflecting the flow of information  the bottom layer has no incoming
arrows  and is the input to the network  the top most layer has no outgoing arrows  and is
the output of the network  the other layers are considered hidden  the sigmoid shape
inside the neurons in the middle layers represent a non linear function  i e   the logistic
function        exa    that is applied to the neurons value before passing it to the output 
in the figure  each neuron is connected to all of the neurons in the next layer  this is called
a fully connected layer or an affine layer 
while the brain metaphor is sexy and intriguing  it is also distracting and cumbersome
to manipulate mathematically  we therefore switch to using more concise mathematical
notation  the values of each row of neurons in the network can be thought of as a vector 
in figure   the input layer is a   dimensional vector  x   and the layer above it is a   dimensional vector  h     the fully connected layer can be thought of as a linear transformation
    while summing is the most common operation  other functions  such as a max  are also possible

   

figoldberg

from   dimensions to   dimensions  a fully connected layer implements a vector matrix
multiplication  h   xw where the weight of the connection from the ith neuron in the
input row to the jth neuron in the output row is wij     the values of h are then transformed by a non linear function g that is applied to each value before being passed on to the
next input  the whole computation from input to output can be written as   g xw    w 
where w  are the weights of the first layer and w  are the weights of the second one 
    in mathematical notation
from this point on  we will abandon the brain metaphor and describe networks exclusively
in terms of vector matrix operations 
the simplest neural network is the perceptron  which is a linear function of its inputs 
nnperceptron  x    xw   b

   

x  rdin   w  rdin dout   b  rdout
w is the weight matrix  and b is a bias term    in order to go beyond linear functions  we
introduce a non linear hidden layer  the network in figure   has two such layers   resulting in
the multi layer perceptron with one hidden layer  mlp    a feed forward neural network
with one hidden layer has the form 
nnmlp   x    g xw    b   w    b 

   

x  rdin   w   rdin d    b   rd    w   rd  d    b   rd 
here w  and b  are a matrix and a bias term for the first linear transformation of the
input  g is a non linear function that is applied element wise  also called a non linearity or
an activation function   and w  and b  are the matrix and bias term for a second linear
transform 
breaking it down  xw   b  is a linear transformation of the input x from din dimensions
to d  dimensions  g is then applied to each of the d  dimensions  and the matrix w  together
with bias vector b  are then used to transform the result into the d  dimensional output
vector  the non linear activation function g has a crucial role in the networks ability to
represent complex functions  without the non linearity in g  the neural network can only
represent linear transformations of the input   
we can add additional linear transformations and non linearities  resulting in an mlp
with two hidden layers  the network in figure   is of this form  
nnmlp   x     g    g    xw    b   w    b    w 

   

it is perhaps clearer to write deeper networks like this using intermediary variables 
    to see why this is p
the case  denote the weight of the ith input of the jth neuron in h as wij   the value
of hj is then hj    i   xi  wij  
    the network in figure   does not include bias terms  a bias term can be added to a layer by adding to
it an additional neuron that does not have any incoming connections  whose value is always   
    to see why  consider that a sequence of linear transformations is still a linear transformation 

   

fia primer on neural networks for nlp

nnmlp   x   y
h   g    xw    b   
h   g    h  w    b   

   

y  h  w 
the vector resulting from each linear transform is referred to as a layer  the outer most
linear transform results in the output layer and the other linear transforms result in hidden
layers  each hidden layer is followed by a non linear activation  in some cases  such as in
the last layer of our example  the bias vectors are forced to    dropped  
layers resulting from linear transformations are often referred to as fully connected  or
affine  other types of architectures exist  in particular  image recognition problems benefit
from convolutional and pooling layers  such layers have uses also in language processing 
and will be discussed in section    networks with several hidden layers are said to be deep
networks  hence the name deep learning 
when describing a neural network  one should specify the dimensions of the layers and
the input  a layer will expect a din dimensional vector as its input  and transform it into a
dout dimensional vector  the dimensionality of the layer is taken to be the dimensionality
of its output  for a fully connected layer l x    xw   b with input dimensionality din and
output dimensionality dout   the dimensions of x is    din   of w is din  dout and of b is
   dout  
the output of the network is a dout dimensional vector  in case dout      the networks
output is a scalar  such networks can be used for regression  or scoring  by considering
the value of the output  or for binary classification by consulting the sign of the output 
networks with dout   k     can be used for k class classification  by associating each
dimension with a class  and looking for the dimension with maximal value  similarly  if
the output vector entries are positive and sum to one  the output can be interpreted as
a distribution over class assignments  such output normalization is typically achieved by
applying a softmax transformation on the output layer  see section      
the matrices and the bias terms that define the linear transformations are the parameters of the network  it is common to refer to the collection of all parameters as   together
with the input  the parameters determine the networks output  the training algorithm is
responsible for setting their values such that the networks predictions are correct  training
is discussed in section   
    representation power
in terms of representation power  it was shown by hornik  stinchcombe  and white       
and cybenko        that mlp  is a universal approximator  it can approximate with
any desired non zero amount of error a family of functions   that include all continuous
functions on a closed and bounded subset of rn   and any function mapping from any finite
    specifically  a feed forward network with linear output layer and at least one hidden layer with a squashing activation function can approximate any borel measurable function from one finite dimensional space
to another 

   

figoldberg

dimensional discrete space to another  this may suggest there is no reason to go beyond
mlp  to more complex architectures  however  the theoretical result does not discuss the
learnability of the neural network  it states that a representation exists  but does not say
how easy or hard it is to set the parameters based on training data and a specific learning
algorithm   it also does not guarantee that a training algorithm will find the correct function
generating our training data  finally  it does not state how large the hidden layer should
be  indeed  telgarsky        show that there exist neural networks with many layers of
bounded size that cannot be approximated by networks with fewer layers unless they layers
are exponentially large 
in practice  we train neural networks on relatively small amounts of data using local
search methods such as variants of stochastic gradient descent  and use hidden layers of
relatively modest sizes  up to several thousands   as the universal approximation theorem
does not give any guarantees under these non ideal  real world conditions  there is definitely
benefit to be had in trying out more complex architectures than mlp   in many cases 
however  mlp  does indeed provide strong results  for further discussion on the representation power of feed forward neural networks  see book by bengio et al         section
     

    common non linearities
the non linearity g can take many forms  there is currently no good theory as to which
non linearity to apply in which conditions  and choosing the correct non linearity for a
given task is for the most part an empirical question  i will now go over the common nonlinearities from the literature  the sigmoid  tanh  hard tanh and the rectified linear unit
 relu   some nlp researchers also experimented with other forms of non linearities such
as cube and tanh cube 

      sigmoid
the sigmoid activation function  x           ex    also called the logistic function  is an
s shaped function  transforming each value x into the range         the sigmoid was the
canonical non linearity for neural networks since their inception  but is currently considered
to be deprecated for use in internal layers of neural networks  as the choices listed below
prove to work much better empirically 

      hyperbolic tangent  tanh 
 x

the hyperbolic tangent tanh x    ee x  
activation function is an s shaped function  trans  
forming the values x into the range        
   

fia primer on neural networks for nlp

      hard tanh
the hard tanh activation function is an approximation of the tanh function which is faster
to compute and take derivatives of 


  x    
hardtanh x     
   
x  


x
otherwise
      rectifier  relu 
the rectifier activation function  glorot  bordes    bengio         also known as the
rectified linear unit is a very simple activation function that is easy to work with and was
shown many times to produce excellent results    the relu unit clips each value x     at
   despite its simplicity  it performs well for many tasks  especially when combined with
the dropout regularization technique  see section      
 
 
relu x    max    x   
x

x  
otherwise

   

as a rule of thumb  relu units work better than tanh  and tanh works better than
sigmoid   
    output transformations
in many cases  the output layer vector is also transformed  a common transformation is
the softmax  
x  x            xk
e xi
softmax xi     pk
xj
j   e

   

    the technical advantages of the relu over the sigmoid and tanh activation functions is that it does not
involve expensive to compute functions  and more importantly that it does not saturate  the sigmoid
and tanh activation are capped at    and the gradients at this region of the functions are near zero 
driving the entire gradient near zero  the relu activation does not have this problem  making it
especially suitable for networks with multiple layers  which are susceptible to the vanishing gradients
problem when trained with the saturating units 
    in addition to these activation functions  recent works from the nlp community experiment with and
reported success with other forms of non linearities  the cube activation function  g x     x     was
suggested by chen and manning         who found it to be more effective than other non linearities in
a feed forward network that was used to predict the actions in a greedy transition based dependency
parser  the tanh cube activation function g x    tanh  x     x  was proposed by pei et al         
who found it to be more effective than other non linearities in a feed forward network that was used as
a component in a structured prediction graph based dependency parser 
the cube and tanh cube activation functions are motivated by the desire to better capture interactions between different features  while these activation functions are reported to improve performance
in certain situations  their general applicability is still to be determined 

   

figoldberg

the result is a vector of non negative real numbers that sum to one  making it a discrete
probability distribution over k possible outcomes 
the softmax output transformation is used when we are interested in modeling a probability distribution over the possible output classes  to be effective  it should be used in
conjunction with a probabilistic training objective such as cross entropy  see section      
below  
when the softmax transformation is applied to the output of a network without a hidden
layer  the result is the well known multinomial logistic regression model  also known as a
maximum entropy classifier 
    embedding layers
up until now  the discussion ignored the source of x  treating it as an arbitrary vector 
in an nlp application  x is usually composed of various embeddings vectors  we can be
explicit about the source of x  and include it in the networks definition  we introduce c   
a function from core features to an input vector 
it is common for c to extract the embedding vector associated with each feature  and
concatenate them 
x   c f    f    f      v f     v f     v f    
nnmlp   x   nnmlp   c f    f    f    
 nnmlp    v f     v f     v f     

    

  g  v f     v f     v f    w    b    w    b 
another common choice is for c to sum the embedding vectors  this assumes the embedding vectors all share the same dimensionality  
x   c f    f    f     v f      v f      v f   
nnmlp   x   nnmlp   c f    f    f    
 nnmlp   v f      v f      v f    

    

  g  v f      v f      v f    w    b    w    b 
the form of c is an essential part of the networks design  in many papers  it is common
to refer to c as part of the network  and likewise treat the word embeddings v fi   as resulting
from an embedding layer or lookup layer  consider a vocabulary of  v   words  each
embedded as a d dimensional vector  the collection of vectors can then be thought of as a
 v    d embedding matrix e in which each row corresponds to an embedded feature  let
fi be a  v   dimensional vector  which is all zeros except from one index  corresponding to
the value of the ith feature  in which the value is    this is called a one hot vector   the
multiplication fi e will then select the corresponding row of e  thus  v fi   can be defined
in terms of e and fi  
v fi     fi e
   

    

fia primer on neural networks for nlp

and similarly 
cbow f         fk    

k
x

 fi e     

i  

k
x

fi  e

    

i  

the input to the network is then considered to be a collection of one hot vectors  while
this is elegant and well defined mathematically  an efficient implementation typically involves
a hash based data structure mapping features to their corresponding embedding vectors 
without going through the one hot representation 
in this tutorial  we take c to be separate from the network architecture  the networks
inputs are always dense real valued input vectors  and c is applied before the input is passed
the network  similar to a feature function in the familiar linear models terminology  however  when training a network  the input vector x does remember how it was constructed 
and can propagate error gradients back to its component embedding vectors  as appropriate
 error propagation is discussed in section    
      a note on notation
when describing network layers that get concatenated vectors x  y and z as input  some
authors use explicit concatenation   x  y  z w  b  while others use an affine transformation
 xu   yv   zw   b   if the weight matrices u  v  w in the affine transformation are
different than one another  the two notations are equivalent 
      a note on sparse vs  dense features
consider a network which uses a traditional sparse representation for its input vectors 
and no embedding layer  assuming the set of all available features is v and we have k on
features f            fk   fi  v   the networks input is 
x 

k
x

 v  

x  n 

fi

i  

    

and so the first layer  ignoring the non linear activation  is 
k
x
xw   b    
fi  w

    

i  

w  r v  d   b  rd
this layer selects rows of w corresponding to the input features in x and sums them 
then adding a bias term  this is very similar to an embedding layer that produces a cbow
representation over the features  where the matrix w acts as the embedding matrix  the
main difference is the introduction of the bias vector b  and the fact that the embedding
layer typically does not undergo a non linear activation but rather passed on directly to the
first layer  another difference is that this scenario forces each feature to receive a separate
vector  row in w  while the embedding layer provides more flexibility  allowing for example
for the features next word is dog and previous word is dog to share the same vector 
   

figoldberg

however  these differences are small and subtle  when it comes to multi layer feed forward
networks  the difference between dense and sparse inputs is smaller than it may seem at
first sight 
    loss functions
when training a neural network  more on training in section   below   much like when
training a linear classifier  one defines a loss function l y  y   stating the loss of predicting
y when the true output is y  the training objective is then to minimize the loss across
the different training examples  the loss l y  y  assigns a numerical score  a scalar  for
the networks output y given the true expected output y    the loss function should be
bounded from below  with the minimum attained only for cases where the networks output
is correct 
the parameters of the network  the matrices wi   the biases bi and commonly the embeddings e  are then set in order to minimize the loss l over the training examples  usually 
it is the sum of the losses over the different training examples that is being minimized  
the loss can be an arbitrary function mapping two vectors to a scalar  for practical
purposes of optimization  we restrict ourselves to functions for which we can easily compute
gradients  or sub gradients   in most cases  it is sufficient and advisable to rely on a common
loss function rather than defining your own  for a detailed discussion on loss functions for
neural networks see work by lecun  chopra  hadsell  ranzato  and huang         lecun
and huang        and bengio et al          we now discuss some loss functions that are
commonly used in neural networks for nlp 
      hinge  binary 
for binary classification problems  the networks output is a single scalar y and the intended
output y is in          the classification rule is sign y   and a classification is considered
correct if y  y      meaning that y and y share the same sign  the hinge loss  also known
as margin loss or svm loss  is defined as 
lhinge binary   y  y    max       y  y 

    

the loss is   when y and y share the same sign and  y      otherwise  the loss is linear 
in other words  the binary hinge loss attempts to achieve a correct classification  with a
margin of at least   
      hinge  multiclass 
the hinge loss was extended to the multiclass setting by crammer and singer         let
y   y            yn be the networks output vector  and y be the one hot vector for the correct
output class 
the classification rule is defined as selecting the class with the highest score 
prediction   arg max yi
i

    

    in our notation  both the models output and the expected output are vectors  while in many cases it is
more natural to think of the expected output as a scalar  class assignment   in such cases  y is simply
the corresponding one hot vector 

   

fia primer on neural networks for nlp

denote by t   arg maxi yi the correct class  and by k   arg maxi  t yi the highest scoring
class such that k    t  the multiclass hinge loss is defined as 
lhinge multiclass   y  y    max        yt  yk   

    

the multiclass hinge loss attempts to score the correct class above all other classes with a
margin of at least   
both the binary and multiclass hinge losses are intended to be used with a linear output
layer  the hinge losses are useful whenever we require a hard decision rule  and do not
attempt to model class membership probability 
      log loss
the log loss is a common variation of the hinge loss  which can be seen as a soft version
of the hinge loss with an infinite margin  lecun et al         
llog  y  y    log     exp  yt  yk   

    

      categorical cross entropy loss
the categorical cross entropy loss  also referred to as negative log likelihood   is used when
a probabilistic interpretation of the scores is desired 
let y   y            yn be a vector representing the true multinomial distribution over the
labels            n  and let y   y            yn be the networks output  which was transformed by the
softmax activation function  and represent the class membership conditional distribution
yi   p  y   i x   the categorical cross entropy loss measures the dissimilarity between
the true label distribution y and the predicted label distribution y  and is defined as cross
entropy 
lcross entropy  y  y    

x

yi log yi  

    

i

for hard classification problems in which each training example has a single correct
class assignment  y is a one hot vector representing the true class  in such cases  the cross
entropy can be simplified to 
lcross entropy hard classification   y  y     log yt  

    

where t is the correct class assignment  this attempts to set the probability mass assigned
to the correct class t to    because the scores y have been transformed using the softmax
function and represent a conditional distribution  increasing the mass assigned to the correct
class means decreasing the mass assigned to all the other classes 
the cross entropy loss is very common in the neural networks literature  and produces a
multi class classifier which does not only predict the one best class label but also predicts a
distribution over the possible labels  when using the cross entropy loss  it is assumed that
the networks output is transformed using the softmax transformation 
   

figoldberg

      ranking losses
in some settings  we are not given supervision in term of labels  but rather as pairs of
correct and incorrect items x and x    and our goal is to score correct items above incorrect
ones  such training situations arise when we have only positive examples  and generate
negative examples by corrupting a positive example  a useful loss in such scenarios is the
margin based ranking loss  defined for a pair of correct and incorrect examples 
lranking margin   x  x      max        nn x   nn x     

    

where nn x  is the score assigned by the network for input vector x  the objective is to
score  rank  correct inputs over incorrect ones with a margin of at least   
a common variation is to use the log version of the ranking loss 
lranking log   x  x      log     exp  nn x   nn x      

    

examples using the ranking hinge loss in language tasks include training with the auxiliary tasks used for deriving pre trained word embeddings  see section     in which we are
given a correct word sequence and a corrupted word sequence  and our goal is to score
the correct sequence above the corrupt one  collobert   weston         similarly  van
de cruys        used the ranking loss in a selectional preferences task  in which the network was trained to rank correct verb object pairs above incorrect  automatically derived
ones  and weston  bordes  yakhnenko  and usunier        trained a model to score correct
 head relation trail  triplets above corrupted ones in an information extraction setting  an
example of using the ranking log loss can be found in the work of gao et al          a
variation of the ranking log loss allowing for a different margin for the negative and positive
class is given in work by dos santos et al         

   word embeddings
a main component of the neural network approach is the use of embeddings  representing
each feature as a vector in a low dimensional space  but where do the vectors come from 
this section will survey the common approaches 
    random initialization
when enough supervised training data is available  one can just treat the feature embeddings
the same as the other model parameters  initialize the embedding vectors to random values 
and let the network training procedure tune them into good vectors 
some care has to be taken in the way the random initialization is performed  the method
used by the effective word vec implementation  mikolov et al         mikolov  sutskever 
chen  corrado    dean        is to initialize the word vectors to uniformly sampled random
   
numbers in the range    d
   d   where d is the number of dimensions  another option is to
use xavier
 see section        and initialize with uniformly sampled values
h  initialization
 i
   

from  d   d  
   

fia primer on neural networks for nlp

in practice  one will often use the random initialization approach to initialize the embedding vectors of commonly occurring features  such as part of speech tags or individual
letters  while using some form of supervised or unsupervised pre training to initialize the
potentially rare features  such as features for individual words  the pre trained vectors can
then either be treated as fixed during the network training process  or  more commonly 
treated like the randomly initialized vectors and further tuned to the task at hand 
    supervised task specific pre training
if we are interested in task a  for which we only have a limited amount of labeled data  for
example  syntactic parsing   but there is an auxiliary task b  say  part of speech tagging 
for which we have much more labeled data  we may want to pre train our word vectors so
that they perform well as predictors for task b  and then use the trained vectors for training
task a  in this way  we can utilize the larger amounts of labeled data we have for task b 
when training task a we can either treat the pre trained vectors as fixed  or tune them
further for task a  another option is to train jointly for both objectives  see section   for
more details 
    unsupervised pre training
the common case is that we do not have an auxiliary task with large enough amounts of
annotated data  or maybe we want to help bootstrap the auxiliary task training with better
vectors   in such cases  we resort to unsupervised methods  which can be trained on huge
amounts of unannotated text 
the techniques for training the word vectors are essentially those of supervised learning 
but instead of supervision for the task that we care about  we instead create practically
unlimited number of supervised training instances from raw text  hoping that the tasks
that we created will match  or be close enough to  the final task we care about   
the key idea behind the unsupervised approaches is that one would like the embedding
vectors of similar words to have similar vectors  while word similarity is hard to define
and is usually very task dependent  the current approaches derive from the distributional
hypothesis  harris         stating that words are similar if they appear in similar contexts 
the different methods all create supervised training instances in which the goal is to either
predict the word from its context  or predict the context from the word 
an important benefit of training word embeddings on large amounts of unannotated
data is that it provides vector representations for words that do not appear in the supervised training set  ideally  the representations for these words will be similar to those of
related words that do appear in the training set  allowing the model to generalize better on
unseen events  it is thus desired that the similarity between word vectors learned by the unsupervised algorithm captures the same aspects of similarity that are useful for performing
the intended task of the network 
    the interpretation of creating auxiliary problems from raw text is inspired by ando and zhang      a 
and ando and zhang      b  

   

figoldberg

common unsupervised word embedding algorithms include word vec     mikolov et al  
             glove  pennington  socher    manning        and the collobert and weston
             embeddings algorithm  these models are inspired by neural networks and
are based on stochastic gradient training  however  they are deeply connected to another
family of algorithms which evolved in the nlp and ir communities  and that are based on
matrix factorization  for a discussion see levy   goldberg      b  levy et al         
arguably  the choice of auxiliary problem  what is being predicted  based on what kind
of context  affects the resulting vectors much more than the learning method that is being
used to train them  we thus focus on the different choices of auxiliary problems that are
available  and only skim over the details of the training methods  several software packages
for deriving word vectors are available  including word vec   and gensim   implementing
the word vec models with word windows based contexts  word vecf   which is a modified
version of word vec allowing the use of arbitrary contexts  and glove   implementing the
glove model  many pre trained word vectors are also available for download on the web 
while beyond the scope of this tutorial  it is worth noting that the word embeddings
derived by unsupervised training algorithms have a wide range of applications in nlp
beyond using them for initializing the word embeddings layer of a neural network model 
    training objectives
given a word w and its context c  different algorithms formulate different auxiliary tasks 
in all cases  each word is represented as a d dimensional vector which is initialized to a
random value  training the model to perform the auxiliary tasks well will result in good
word embeddings for relating the words to the contexts  which in turn will result in the
embedding vectors for similar words to be similar to each other 
language modeling inspired approaches such as those taken by mikolov et al         
mnih and kavukcuoglu        as well as glove  pennington et al         use auxiliary tasks
in which the goal is to predict the word given its context  this is posed in a probabilistic
setup  trying to model the conditional probability p  w c  
other approaches reduce the problem to that of binary classification  in addition to
the set d of observed word context pairs  a set d is created from random words and
context pairings  the binary classification problem is then  does the given  w  c  pair
come from d or not  the approaches differ in how the set d is constructed  what is
the structure of the classifier  and what is the objective being optimized  collobert and
weston              take a margin based binary ranking approach  training a feed forward
neural network to score correct  w  c  pairs over incorrect ones  mikolov et al              
take instead a probabilistic version  training a log bilinear model to predict the probability
p   w  c   d w  c  that the pair come from the corpus rather than the random sample 
    while often treated as a single algorithm  word vec is actually a software package including various
training objectives  optimization methods and other hyperparameters  see work by rong        and
levy  goldberg  and dagan        for a discussion 
    https   code google com p word vec 
    https   radimrehurek com gensim 
    https   bitbucket org yoavgo word vecf
    http   nlp stanford edu projects glove 

   

fia primer on neural networks for nlp

    the choice of contexts
in most cases  the contexts of a word are taken to be other words that appear in its
surrounding  either in a short window around it  or within the same sentence  paragraph
or document  in some cases the text is automatically parsed by a syntactic parser  and
the contexts are derived from the syntactic neighbourhood induced by the automatic parse
trees  sometimes  the definitions of words and context change to include also parts of words 
such as prefixes or suffixes 
neural word embeddings originated from the world of language modeling  in which a
network is trained to predict the next word based on a sequence of preceding words  bengio
et al          there  the text is used to create auxiliary tasks in which the aim is to predict
a word based on a context the k previous words  while training for the language modeling
auxiliary prediction problems indeed produce useful embeddings  this approach is needlessly
restricted by the constraints of the language modeling task  in which one is allowed to look
only at the previous words  if we do not care about language modeling but only about the
resulting embeddings  we may do better by ignoring this constraint and taking the context
to be a symmetric window around the focus word 
      window approach
the most common approach is a sliding window approach  in which auxiliary tasks are
created by looking at a sequence of  k     words  the middle word is callled the focus word
and the k words to each side are the contexts  then  either a single task is created in which
the goal is to predict the focus word based on all of the context words  represented either
using cbow  see mikolov et al        or vector concatenation  see collobert   weston 
       or  k distinct tasks are created  each pairing the focus word with a different context
word  the  k tasks approach  popularized by mikolov et al         is referred to as a
skip gram model  skip gram based approaches are shown to be robust and efficient to train
 mikolov et al         pennington et al          and often produce state of the art results 
effect of window size the size of the sliding window has a strong effect on the resulting vector similarities  larger windows tend to produce more topical similarities  i e 
dog  bark and leash will be grouped together  as well as walked  run and walking   while smaller windows tend to produce more functional and syntactic similarities  i e 
poodle  pitbull  rottweiler  or walking running approaching  
positional windows when using the cbow or skip gram context representations  all
the different context words within the window are treated equally  there is no distinction
between context words that are close to the focus words and those that are farther from
it  and likewise there is no distinction between context words that appear before the focus
words to context words that appear after it  such information can easily be factored in by
using positional contexts  indicating for each context word also its relative position to the
focus words  i e  instead of the context word being the it becomes the     indicating
the word appears two positions to the right of the focus word   the use of positional context
together with smaller windows tend to produce similarities that are more syntactic  with
a strong tendency of grouping together words that share a part of speech  as well as being
functionally similar in terms of their semantics  positional vectors were shown by ling 
   

figoldberg

dyer  black  and trancoso      a  to be more effective than window based vectors when
used to initialize networks for part of speech tagging and syntactic dependency parsing 
variants many variants on the window approach are possible  one may lemmatize words
before learning  apply text normalization  filter too short or too long sentences  or remove
capitalization  see  e g   the pre processing steps described in dos santos   gatti        
one may sub sample part of the corpus  skipping with some probability the creation of tasks
from windows that have too common or too rare focus words  the window size may be
dynamic  using a different window size at each turn  one may weigh the different positions
in the window differently  focusing more on trying to predict correctly close word context
pairs than further away ones  each of these choices will effect the resulting vectors  some
of these hyperparameters  and others  are discussed by levy et al         
      sentences  paragraphs or documents
using a skip grams  or cbow  approach  one can consider the contexts of a word to be all
the other words that appear with it in the same sentence  paragraph or document  this is
equivalent to using very large window sizes  and is expected to result in word vectors that
capture topical similarity  words from the same topic  i e  words that one would expect to
appear in the same document  are likely to receive similar vectors  
      syntactic window
some work replace the linear context within a sentence with a syntactic one  levy  
goldberg      a  bansal  gimpel    livescu         the text is automatically parsed
using a dependency parser  and the context of a word is taken to be the words that are
in its proximity in the parse tree  together with the syntactic relation by which they are
connected  such approaches produce highly functional similarities  grouping together words
than can fill the same role in a sentence  e g  colors  names of schools  verbs of movement  
the grouping is also syntactic  grouping together words that share an inflection  levy  
goldberg      a  
      multilingual
another option is using multilingual  translation based contexts  hermann   blunsom 
      faruqui   dyer         for example  given a large amount of sentence aligned parallel
text  one can run a bilingual alignment model such as the ibm model   or model    i e 
using the giza   software   and then use the produced alignments to derive word contexts 
here  the context of a word instance are the foreign language words that are aligned to it 
such alignments tend to result in synonym words receiving similar vectors  some authors
work instead on the sentence alignment level  without relying on word alignments  gouws 
bengio    corrado        or train an end to end machine translation neural network and
use the resulting word embeddings  hill  cho  jean  devin    bengio         an appealing
method is to mix a monolingual window based approach with a multilingual approach 
creating both kinds of auxiliary tasks  this is likely to produce vectors that are similar to
the window based approach  but reducing the somewhat undesired effect of the window   

fia primer on neural networks for nlp

based approach in which antonyms  e g  hot and cold  high and low  tend to receive similar
vectors  faruqui   dyer        
      character based and sub word representations
an interesting line of work attempts to derive the vector representation of a word from the
characters that compose it  such approaches are likely to be particularly useful for tasks
which are syntactic in nature  as the character patterns within words are strongly related
to their syntactic function  these approaches also have the benefit of producing very small
model sizes  only one vector for each character in the alphabet together with a handful of
small matrices needs to be stored   and being able to provide an embedding vector for every
word that may be encountered  dos santos and gatti         dos santos and zadrozny
       and kim et al         model the embedding of a word using a convolutional network
 see section    over the characters  ling et al       b  model the embedding of a word
using the concatenation of the final states of two rnn  lstm  encoders  section      one
reading the characters from left to right  and the other from right to left  both produce
very strong results for part of speech tagging  the work of ballesteros et al         show
that the two lstms encoding of ling et al       b  is beneficial also for representing words
in dependency parsing of morphologically rich languages 
deriving representations of words from the representations of their characters is motivated by the unknown words problem  what do you do when you encounter a word for
which you do not have an embedding vector  working on the level of characters alleviates
this problem to a large extent  as the vocabulary of possible characters is much smaller
than the vocabulary of possible words  however  working on the character level is very
challenging  as the relationship between form  characters  and function  syntax  semantics 
in language is quite loose  restricting oneself to stay on the character level may be an
unnecessarily hard constraint  some researchers propose a middle ground  in which a word
is represented as a combination of a vector for the word itself with vectors of sub word
units that comprise it  the sub word embeddings then help in sharing information between
different words with similar forms  as well as allowing back off to the subword level when
the word is not observed  at the same time  the models are not forced to rely solely on
form when enough observations of the word are available  botha and blunsom        suggest to model the embedding vector of a word as a sum of the word specific vector if such
vector is available  with vectors for the different morphological components that comprise
it  the components are derived using morfessor  creutz   lagus         an unsupervised
morphological segmentation method   gao et al         suggest using as core features not
only the word form itself but also a unique feature  hence a unique embedding vector  for
each of the letter trigrams in the word 

   neural network training
neural network training is done by trying to minimize a loss function over a training set 
using a gradient based method  roughly speaking  all training methods work by repeatedly
computing an estimate of the error over the dataset  computing the gradient with respect
to the error  and then moving the parameters in the opposite direction of the gradient 
models differ in how the error estimate is computed  and how moving in the opposite
   

figoldberg

direction of the gradient is defined  we describe the basic algorithm  stochastic gradient
descent  sgd   and then briefly mention the other approaches with pointers for further
reading  gradient calculation is central to the approach  gradients can be efficiently and
automatically computed using reverse mode differentiation on a computation graph  a
general algorithmic framework for automatically computing the gradient of any network
and loss function  to be discussed in section     
    stochastic gradient training
the common approach for training neural networks is using the stochastic gradient descent
 sgd  algorithm  bottou        lecun  bottou  orr    muller      a  or a variant of it 
sgd is a general optimization algorithm  it receives a function f parameterized by   a
loss function  and desired input and output pairs  it then attempts to set the parameters 
such that the loss of f with respect to the training examples is small  the algorithm works
as follows 
algorithm   online stochastic gradient descent training
   input  function f  x    parameterized with parameters  
   input  training set of inputs x            xn and desired outputs y            yn  
   input  loss function l 
   while stopping criteria not met do
  
sample a training example xi   yi
  
compute the loss l f  xi      yi  
  
g  gradients of l f  xi      yi   w r t 
  
    t g
   return 
pnthe goal of the algorithm is to set the parameters  so as to minimize the total loss
i   l f  xi      yi   over the training set  it works by repeatedly sampling a training example and computing the gradient of the error on the example with respect to the parameters
  line     the input and expected output are assumed to be fixed  and the loss is treated
as a function of the parameters   the parameters  are then updated in the opposite
direction of the gradient  scaled by a learning rate t  line     the learning rate can either
be fixed throughout the training process  or decay as a function of the time step t    for
further discussion on setting the learning rate  see section     
note that the error calculated in line   is based on a single training example  and is thus
just a rough estimate of the corpus wide loss that we are aiming to minimize  the noise in
the loss computation may result in inaccurate gradients  a common way of reducing this
noise is to estimate the error and the gradients based on a sample of m examples  this
gives rise to the minibatch sgd algorithm 
in lines      the algorithm estimates the gradient of the corpus loss based on the
minibatch  after the loop  g contains the gradient estimate  and the parameters  are
updated toward g  the minibatch size can vary in size from m     to m   n  higher
values provide better estimates of the corpus wide gradients  while smaller values allow
    learning rate decay is required in order to prove convergence of sgd 

   

fia primer on neural networks for nlp

algorithm   minibatch stochastic gradient descent training
   input  function f  x    parameterized with parameters  
   input  training set of inputs x            xn and desired outputs y            yn  
   input  loss function l 
   while stopping criteria not met do
  
sample a minibatch of m examples   x    y              xm   ym   
  
g   
  
for i     to m do
  
compute the loss l f  xi      yi  
 
  
g  g   gradients of m
l f  xi      yi   w r t 
    t g
    return 
   

more updates and in turn faster convergence  besides the improved accuracy of the gradients
estimation  the minibatch algorithm provides opportunities for improved training efficiency 
for modest sizes of m  some computing architectures  i e  gpus  allow an efficient parallel
implementation of the computation in lines     with a properly decreasing learning rate 
sgd is guaranteed to converge to a global optimum if the function is convex  however  it
can also be used to optimize non convex functions such as neural network  while there are
no longer guarantees of finding a global optimum  the algorithm proved to be robust and
performs well in practice   
when training a neural network  the parameterized function f is the neural network  and
the parameters  are the linear transformation matrices  bias terms  embedding matrices
and so on  the gradient computation is a key step in the sgd algorithm  as well as in
all other neural network training algorithms  the question is  then  how to compute the
gradients of the networks error with respect to the parameters  fortunately  there is an
easy solution in the form of the backpropagation algorithm  rumelhart  hinton    williams 
      lecun  bottou  bengio    haffner      b   the backpropagation algorithm is a fancy
name for methodically computing the derivatives of a complex expression using the chainrule  while caching intermediary results  more generally  the backpropagation algorithm
is a special case of the reverse mode automatic differentiation algorithm  neidinger       
section    baydin  pearlmutter  radul    siskind        bengio         the following
section describes reverse mode automatic differentiation in the context of the computation
graph abstraction 
      beyond sgd
while the sgd algorithm can and often does produce good results  more advanced algorithms are also available  the sgd momentum  polyak        and nesterov momentum
 sutskever  martens  dahl    hinton        nesterov              algorithms are variants
of sgd in which previous gradients are accumulated and affect the current update  adap    recent work from the neural networks literature argue that the non convexity of the networks is manifested in a proliferation of saddle points rather than local minima  dauphin  pascanu  gulcehre  cho 
ganguli    bengio         this may explain some of the success in training neural networks despite
using local search techniques 

   

figoldberg

tive learning rate algorithms including adagrad  duchi  hazan    singer         adadelta
 zeiler         rmsprop  tieleman   hinton        and adam  kingma   ba        are
designed to select the learning rate for each minibatch  sometimes on a per coordinate basis 
potentially alleviating the need of fiddling with learning rate scheduling  for details of these
algorithms  see the original papers or the book by bengio et al         sections           
as many neural network software frameworks provide implementations of these algorithms 
it is easy and sometimes worthwhile to try out different variants 
    the computation graph abstraction
while one can compute the gradients of the various parameters of a network by hand and
implement them in code  this procedure is cumbersome and error prone  for most purposes  it is preferable to use automatic tools for gradient computation  bengio         the
computation graph abstraction allows us to easily construct arbitrary networks  evaluate
their predictions for given inputs  forward pass   and compute gradients for their parameters
with respect to arbitrary scalar losses  backward pass  
a computation graph is a representation of an arbitrary mathematical computation as
a graph  it is a directed acyclic graph  dag  in which nodes correspond to mathematical
operations or  bound  variables and edges correspond to the flow of intermediary values
between the nodes  the graph structure defines the order of the computation in terms of
the dependencies between the different components  the graph is a dag and not a tree  as
the result of one operation can be the input of several continuations  consider for example
a graph for the computation of  a  b        a  b      
 
 

 
 

 

a

b

 

the computation of a  b is shared  we restrict ourselves to the case where the computation
graph is connected 
since a neural network is essentially a mathematical expression  it can be represented
as a computation graph 
for example  figure  a presents the computation graph for an mlp with one hiddenlayer and a softmax output transformation  in our notation  oval nodes represent mathematical operations or functions  and shaded rectangle nodes represent parameters  bound
variables   network inputs are treated as constants  and drawn without a surrounding node 
input and parameter nodes have no incoming arcs  and output nodes have no outgoing arcs 
the output of each node is a matrix  the dimensionality of which is indicated above the
node 
this graph is incomplete  without specifying the inputs  we cannot compute an output 
figure  b shows a complete graph for an mlp that takes three words as inputs  and predicts
the distribution over part of speech tags for the third word  this graph can be used for
prediction  but not for training  as the output is a vector  not a scalar  and the graph does
not take into account the correct answer or the loss term  finally  the graph in  c shows the
   

fia primer on neural networks for nlp

  
neg
  
log
  
 a 

 b 

 c 

pick

     

     

     

softmax

softmax

softmax

     

     

     

add

add

add

     

     

     

mul

mul

mul

     
tanh

      
w 

     

     
b 

      
w 

tanh

     

     
b 

     

     

add

add

add

     

     

     

mul

mul

mul

       
w 

      

     
b 

concat

       
w 

      

     

       

     

w 

tanh

     

      
x

 

      

     
b 

concat

w 

     

     

     

     

     

     

lookup

lookup

lookup

lookup

lookup

lookup

the

black

dog

the

black

dog

 v      
e

b 

b 

 v      
e

figure    computation graph for mlp    a  graph with unbound input   b  graph
with concrete input   c  graph with concrete input  expected output  and loss
node 

computation graph for a specific training example  in which the inputs are the  embeddings
of  the words the  black  dog  and the expected output is noun  whose index is
    the pick node implements an indexing operation  receiving a vector and an index  in
this case     and returning the corresponding entry in the vector 
once the graph is built  it is straightforward to run either a forward computation  compute the result of the computation  or a backward computation  computing the gradients  
as we show below  constructing the graphs may look daunting  but is actually very easy
using dedicated software libraries and apis 
      forward computation
the forward pass computes the outputs of the nodes in the graph  since each nodes output
depends only on itself and on its incoming edges  it is trivial to compute the outputs of
all nodes by traversing the nodes in a topological order and computing the output of each
node given the already computed outputs of its predecessors 
   

figoldberg

more formally  in a graph of n nodes  we associate each node with an index i according
to their topological ordering  let fi be the function computed by node i  e g  multiplication 
addition           let  i  be the parent nodes of node i  and     i     j   i   j   the
children nodes of node i  these are the arguments of fi    denote by v i  the output of node
i  that is  the application of fi to the output values of its arguments     i   for variable
and input nodes  fi is a constant function and     i  is empty  the forward algorithm
computes the values v i  for all i      n   
algorithm   computation graph forward pass
   for i     to n do
  
let a            am       i 
  
v i   fi  v a             v am   

      backward computation  derivatives  backprop 
the backward pass begins by designating a node n with scalar      output as a loss node 
and running forward computation up to that node  the backward computation computes
n
the gradients with respect to that nodes value  denote by d i  the quantity
  the
i
backpropagation algorithm is used to compute the values d i  for all nodes i 
the backward pass fills a table d i  as follows 
algorithm   computation graph backward pass  backpropagation 
   d n     
   for i   n   to   do
p
fj
  
d i   j i  d j  
i

fj
is the partial derivative of fj      j   w r t the argument i      j  
i
this value depends on the function fj and the values v a             v am    where a            am  
    j   of its arguments  which were computed in the forward pass 

the quantity

thus  in order to define a new kind of node  one need to define two methods  one for
calculating the forward value v i  based on the nodes inputs  and the another for calculating
fi
for each x      i  
x
for further information on automatic differentiation see the work of neidinger       
section    and baydin et al          for more in depth discussion of the backpropagation
algorithm and computation graphs  also called flow graphs  see the work of bengio et al 
       section       lecun et al       b  and bengio         for a popular yet technical
presentation  see the online post by olah      a  
   

fia primer on neural networks for nlp

      software
several software packages implement the computation graph model  including theano    
chainer     penne   and cnn pycnn     all these packages support all the essential components  node types  for defining a wide range of neural network architectures  covering the
structures described in this tutorial and more  graph creation is made almost transparent
by use of operator overloading  the framework defines a type for representing graph nodes
 commonly called expressions   methods for constructing nodes for inputs and parameters 
and a set of functions and mathematical operations that take expressions as input and result
in more complex expressions  for example  the python code for creating the computation
graph from figure   c  using the pycnn framework is 
import pycnn as pc
  model initialization 
model   pc model  
pw    model add parameters          
pb    model add parameters    
pw    model add parameters         
pb    model add parameters    
words   model add lookup parameters           
  building the computation graph 
pc renew cg     create a new graph 
  wrap the model parameters as graph nodes 
w    pc parameter pw  
b    pc parameter pb  
w    pc parameter pw  
b    pc parameter pb  
def get index x   return     place holder
  generate the embeddings layer 
vthe
  pc lookup words  get index  the   
vblack   pc lookup words  get index  black   
vdog
  pc lookup words  get index  dog   
  connect the leaf nodes into a complete graph 
x   pc concatenate  vthe  vblack  vdog  
output   pc softmax w   pc tanh w  x  b   b  
loss    pc log pc pick output     
loss value   loss forward  
loss backward     the gradient is computed
  and stored in the corresponding
  parameters 

most of the code involves various initializations  the first block defines model parameters
that are be shared between different computation graphs  recall that each graph corresponds
to a specific training example   the second block turns the model parameters into the graphnode  expression  types  the third block retrieves the expressions for the embeddings of the
   
   
   
   

http   deeplearning net software theano 
http   chainer org
https   bitbucket org ndnlp penne
https   github com clab cnn

   

figoldberg

input words  finally  the fourth block is where the graph is created  note how transparent
the graph creation is  there is an almost a one to one correspondence between creating
the graph and describing it mathematically  the last block shows a forward and backward
pass  the other software frameworks follow similar patterns 
theano involves an optimizing compiler for computation graphs  which is both a blessing
and a curse  on the one hand  once compiled  large graphs can be run efficiently on either
the cpu or a gpu  making it ideal for large graphs with a fixed structure  where only the
inputs change between instances  however  the compilation step itself can be costly  and it
makes the interface a bit cumbersome to work with  in contrast  the other packages focus on
building large and dynamic computation graphs and executing them on the fly without a
compilation step  while the execution speed may suffer with respect to theanos optimized
version  these packages are especially convenient when working with the recurrent and
recursive networks described in sections        as well as in structured prediction settings
as described in section   
      implementation recipe
using the computation graph abstraction  the pseudo code for a network training algorithm
is given in algorithm   
algorithm   neural network training with computation graph abstraction  using minibatches of size   
   define network parameters 
   for iteration     to n do
  
for training example xi   yi in dataset do
  
loss node  build computation graph xi   yi   parameters 
  
loss node forward  
  
gradients  loss node   backward  
  
parameters  update parameters parameters  gradients 
   return parameters 
here  build computation graph is a user defined function that builds the computation
graph for the given input  output and network structure  returning a single loss node 
update parameters is an optimizer specific update rule  the recipe specifies that a new
graph is created for each training example  this accommodates cases in which the network
structure varies between training example  such as recurrent and recursive neural networks 
to be discussed in sections         for networks with fixed structures  such as an mlps  it
may be more efficient to create one base computation graph and vary only the inputs and
expected outputs between examples 
      network composition
as long as the networks output is a vector     k matrix   it is trivial to compose networks
by making the output of one network the input of another  creating arbitrary networks 
the computation graph abstractions makes this ability explicit  a node in the computation
graph can itself be a computation graph with a designated output node  one can then
   

fia primer on neural networks for nlp

design arbitrarily deep and complex networks  and be able to easily evaluate and train
them thanks to automatic forward and gradient computation  this makes it easy to define
and train networks for structured outputs and multi objective training  as we discuss in
section    as well as complex recurrent and recursive networks  as discussed in sections
     
    optimization issues
once the gradient computation is taken care of  the network is trained using sgd or another
gradient based optimization algorithm  the function being optimized is not convex  and for
a long time training of neural networks was considered a black art which can only be done
by selected few  indeed  many parameters affect the optimization process  and care has to
be taken to tune these parameters  while this tutorial is not intended as a comprehensive
guide to successfully training neural networks  we do list here a few of the prominent issues 
for further discussion on optimization techniques and algorithms for neural networks  refer
to the book by bengio et al         ch      for some theoretical discussion and analysis  refer
to the work of glorot and bengio         for various practical tips and recommendations 
see work of lecun et al       a  and bottou        
      initialization
the non convexity of the loss function means the optimization procedure may get stuck
in a local minimum or a saddle point  and that starting from different initial points  e g 
different random values for the parameters  may result in different results  thus  it is
advised to run several restarts of the training starting at different random initializations 
and choosing the best one based on a development set    the amount of variance in the
results is different for different network formulations and datasets  and cannot be predicted
in advance 
the magnitude of the random values has an important effect on the success of training 
an effective scheme due to glorot and bengio         called xavier initialization after
glorots first name  suggests initializing a weight matrix w  rdin dout as 


 

 
 
w  u 
   
din   dout
din   dout
 

    

where u  a  b  is a uniformly sampled random value in the range  a  b   the suggestion is
based on properties of the tanh activation function  works well on many occasions  and is
the preferred default initialization method by many 
analysis by he et al         suggests that when using relu non linearities  the weights
should be initialized
by sampling from a zero mean gaussian distribution whose standard
q
 
deviation is
din   this initialization was found by he et al to work better than xavier
initialization in an image classification task  especially when deep networks were involved 
    when debugging  and for reproducibility of results  it is advised to used a fixed random seed 

   

figoldberg

      vanishing and exploding gradients
in deep networks  it is common for the error gradients to either vanish  become exceedingly
close to    or explode  become exceedingly high  as they propagate back through the computation graph  the problem becomes more severe in deeper networks  and especially so
in recursive and recurrent networks  pascanu  mikolov    bengio         dealing with the
vanishing gradients problem is still an open research question  solutions include making the
networks shallower  step wise training  first train the first layers based on some auxiliary
output signal  then fix them and train the upper layers of the complete network based on
the real task signal   performing batch normalization  ioffe   szegedy         for every
minibatch  normalizing the inputs to each of the network layers to have zero mean and unit
variance  or using specialized architectures that are designed to assist in gradient flow  e g  
the lstm and gru architectures for recurrent networks  discussed in section      dealing
with the exploding gradients has a simple but very effective solution  clipping the gradients
if their norm exceeds a given threshold  let g be the gradients of all parameters in the
network  and kgk be their l  norm  pascanu et al         suggest to set  g  threshold
kgk g if
kgk   threshold 
      saturation and dead neurons
layers with tanh and sigmoid activations can become saturated  resulting in output values
for that layer that are all close to one  the upper limit of the activation function  saturated
neurons have very small gradients  and should be avoided  layers with the relu activation
cannot be saturated  but can die  most or all values are negative and thus clipped at zero
for all inputs  resulting in a gradient of zero for that layer  if your network does not train
well  it is advisable to monitor the network for layers with many saturated or dead neurons 
saturated neurons are caused by too large values entering the layer  this may be controlled
for by changing the initialization  scaling the range of the input values  or changing the
learning rate  dead neurons are caused by all signals entering the layer being negative  for
example this can happen after a large gradient update   reducing the learning rate will
help in this situation  for saturated layers  another option is to normalize the values in the
saturated layer after the activation  i e  instead of g h    tanh h  using g h    k tanh h 
tanh h k  
layer normalization is an effective measure for countering saturation  but is also expensive
in terms of gradient computation  a related technique is batch normalization  due to ioffe
and szegedy         in which the activations at each layer are normalized so that they
have mean   and variance   across each mini batch  the batch normalization techniques
became a key component for effective training of deep networks in computer vision  as of
this writing  it is less popular in natural language applications 
      shuffling
the order in which the training examples are presented to the network is important  the
sgd formulation above specifies selecting a random example in each turn  in practice  most
implementations go over the training example in order  it is advised to shuffle the training
examples before each pass through the data 
   

fia primer on neural networks for nlp

      learning rate
selection of the learning rate is important  too large learning rates will prevent the network
from converging on an effective solution  too small learning rates will take very long time to
converge  as a rule of thumb  one should experiment with a range of initial learning rates in
range         e g                       monitor the networks loss over time  and decrease the
learning rate once the loss stops improving  learning rate scheduling decreases the rate as a
function of the number of observed minibatches  a common schedule is dividing the initial
learning rate by the iteration number  leon bottou        recommends using a learning
rate of the form t            t   where   is the initial learning rate  t is the learning
rate to use on the tth training example  and  is an additional hyperparameter  he further
recommends determining a good value of   based on a small sample of the data prior to
running on the entire dataset 
      minibatches
parameter updates occur either every training example  minibatches of size    or every k
training examples  some problems benefit from training with larger minibatch sizes  in
terms of the computation graph abstraction  one can create a computation graph for each
of the k training examples  and then connecting the k loss nodes under an averaging node 
whose output will be the loss of the minibatch  large minibatched training can also be
beneficial in terms of computation efficiency on specialized computing architectures such as
gpus  and replacing vector matrix operations by matrix matrix operations  this is beyond
the scope of this tutorial 
    regularization
neural network models have many parameters  and overfitting can easily occur  overfitting
can be alleviated to some extent by regularization  a common regularization method is
l  regularization  placing a squared penalty on parameters with large values by adding
an additive   kk  term to the objective function to be minimized  where  is the set of
model parameters  k  k  is the squared l  norm  sum of squares of the values   and  is a
hyperparameter controlling the amount of regularization 
a recently proposed alternative regularization method is dropout  hinton  srivastava 
krizhevsky  sutskever    salakhutdinov         the dropout method is designed to prevent
the network from learning to rely on specific weights  it works by randomly dropping
 setting to    half of the neurons in the network  or in a specific layer  in each training
example  work by wager et al         establishes a strong connection between the dropout
method and l  regularization 
the dropout technique is one of the key factors contributing to very strong results of
neural network methods on image classification tasks  krizhevsky  sutskever    hinton 
       especially when combined with relu activation units  dahl  sainath    hinton 
       the dropout technique is effective also in nlp applications of neural networks 
   

figoldberg

   cascading and multi task learning
the combination of online training methods with automatic gradient computations using
the computation graph abstraction allows for an easy implementation of model cascading 
parameter sharing and multi task learning 
    model cascading
is a powerful technique in which large networks are built by composing them out of smaller
component networks  for example  we may have a feed forward network for predicting the
part of speech of a word based on its neighbouring words and or the characters that compose
it  in a pipeline approach  we would use this network for predicting parts of speech  and
then feed the predictions as input features to neural network that does syntactic chunking
or parsing  instead  we could think of the hidden layers of this network as an encoding
that captures the relevant information for predicting the part of speech  in a cascading
approach  we take the hidden layers of this network and connect them  and not the part
of speech prediction themselves  as the inputs for the syntactic network  we now have
a larger network that takes as input sequences of words and characters  and outputs a
syntactic structure  the computation graph abstraction allows us to easily propagate the
error gradients from the syntactic task loss all the way back to the characters 
to combat the vanishing gradient problem of deep networks  as well as to make better
use of available training material  the individual component networks parameters can be
bootstrapped by training them separately on a relevant task  before plugging them in to
the larger network for further tuning  for example  the part of speech predicting network
can be trained to accurately predict parts of speech on a relatively large annotated corpus 
before plugging its hidden layer into the syntactic parsing network for which less training
data is available  in case the training data provide direct supervision for both tasks  we can
make use of it during training by creating a network with two outputs  one for each task 
computing a separate loss for each output  and then summing the losses into a single node
from which we backpropagate the error gradients 
model cascading is very common when using convolutional  recursive and recurrent
neural networks  where  for example  a recurrent network is used to encode a sentence into
a fixed sized vector  which is then used as the input of another network  the supervision
signal of the recurrent network comes primarily from the upper network that consumes the
recurrent networks output as it inputs 
    multi task learning
is used when we have related prediction tasks that do not necessarily feed into one another 
but we do believe that information that is useful for one type of prediction can be useful
also to some of the other tasks  for example  chunking  named entity recognition  ner 
and language modeling are examples of synergistic tasks  information for predicting chunk
boundaries  named entity boundaries and the next word in the sentence all rely on some
shared underlying syntactic semantic representation  instead of training a separate network
for each task  we can create a single network with several outputs  a common approach is to
have a multi layer feed forward network  whose final hidden layer  or a concatenation of all
   

fia primer on neural networks for nlp

hidden layers  is then passed to different output layers  this way  most of the parameters
of the network are shared between the different tasks  useful information learned from one
task can then help to disambiguate other tasks  again  the computation graph abstraction
makes it very easy to construct such networks and compute the gradients for them  by
computing a separate loss for each available supervision signal  and then summing the
losses into a single loss that is used for computing the gradients  in case we have several
corpora  each with different kind of supervision signal  e g  we have one corpus for ner
and another for chunking   the training procedure will shuffle all of the available training
example  performing gradient computation and updates with respect to a different loss in
every turn  multi task learning in the context of language processing is introduced and
discussed in the work of collobert et al          for examples of cascaded multi task
learning in a feed forward network  see the work of zhang and weiss         in the context
of recurrent neural networks  see the work of luong  le  sutskever  vinyals  and kaiser
       and sgaard and goldberg        

   structured output prediction
many problems in nlp involve structured outputs  cases where the desired output is not
a class label or distribution over class labels  but a structured object such as a sequence 
a tree or a graph  canonical examples are sequence tagging  e g  part of speech tagging 
sequence segmentation  chunking  ner   and syntactic parsing  in this section  we discuss
how feed forward neural network models can be used for structured tasks  in later sections
we discuss specialized neural network models for dealing with sequences  section     and
trees  section     
    greedy structured prediction
the greedy approach to structured prediction is to decompose the structure prediction
problem into a sequence of local prediction problems and training a classifier to perform
each local decision  at test time  the trained classifier is used in a greedy manner  examples
of this approach are left to right tagging models  gimenez   marquez        and greedy
transition based parsing  nivre         such approaches are easily adapted to use neural
networks by simply replacing the local classifier from a linear classifier such as an svm or
a logistic regression model to a neural network  as demonstrated by chen and manning
       and lewis and steedman        
the greedy approaches suffer from error propagation  where mistakes in early decisions
carry over and influence later decisions  the overall higher accuracy achievable with nonlinear neural network classifiers helps in offsetting this problem to some extent  in addition 
training techniques were proposed for mitigating the error propagation problem by either
attempting to take easier predictions before harder ones  the easy first approach in goldberg   elhadad        or making training conditions more similar to testing conditions by
exposing the training procedure to inputs that result from likely mistakes  hal daume iii 
langford    marcu        goldberg   nivre         these are effective also for training
greedy neural network models  as demonstrated by ma  zhang  and zhu         easy first
tagger  and ballesteros  goldberg  dyer  and smith         dynamic oracle training for
greedy dependency parsing  
   

figoldberg

    search based structured prediction
the common approach to predicting natural language structures is search based  for indepth discussion of search based structure prediction in nlp  see the book by smith        
the techniques can easily be adapted to use a neural network  in the neural networks
literature  such models were discussed under the framework of energy based learning  lecun
et al         section     they are presented here using setup and terminology familiar to
the nlp community 
search based structured prediction is formulated as a search problem over possible structures 
predict x    arg max score x  y 

    

yy x 

where x is an input structure  y is an output over x  in a typical example x is a sentence
and y is a tag assignment or a parse tree over the sentence   y x  is the set of all valid
structures over x  and we are looking for an output y that will maximize the score of the
x  y pair 
the scoring function is defined as a linear model 
score x  y    w   x  y 

    

where  is a feature extraction function and w is a weight vector 
in order to make the search for the optimal y tractable  the structure y is decomposed
into parts  and the feature function is defined in terms of the parts  where  p  is a part local
feature extraction function 
x
 x  y   
 p 
    
pparts x y 

each part is scored separately  and the structure score is the sum of the component
parts scores 

score x  y   w   x  y    w 

x

 p   

py

x
py

w   p   

x

score p 

    

py

where p  y is a shorthand for p  parts x  y   the decomposition of y into parts is such
that there exists an inference algorithm that allows for efficient search for the best scoring
structure given the scores of the individual parts 
one can now trivially replace the linear scoring function over parts with a neuralnetwork 

score x  y   

x

score p   

py

x

nn c p  

py

where c p  maps the part p into a din dimensional vector 
in case of a one hidden layer feed forward network 
   

    

fia primer on neural networks for nlp

score x  y   

x

nnmlp   c p    

x
 g c p w    b    w

    

py

py

c p   rdin   w   rdin d    b   rd    w  rd    a common objective in structured
prediction is making the gold structure y score higher than any other structure y     leading
to the following  generalized perceptron  loss 

max
score x  y      score x  y 
 
y

    

in terms of implementation  this means  create a computation graph cgp for each of
the possible parts  and calculate its score  then  run inference over the scored parts to
find the best scoring structure y     connect the output nodes of the computation graphs
corresponding to parts in the gold  predicted  structure y  y     into a summing node cgy
 cg y    connect cgy and cg y using a minus node  cgl   and compute the gradients 
as argued by lecun et al         section     the generalized perceptron loss may not
be a good loss function when training structured prediction neural networks as it does not
have a margin  and a margin based hinge loss is preferred 

max    m   max
score x  y      score x  y  
 
y   y

    

it is trivial to modify the implementation above to work with the hinge loss 
note that in both cases we lose the nice properties of the linear model  in particular  the
model is no longer convex  this is to be expected  as even the simplest non linear neural
network is already non convex  nonetheless  we could still use standard neural network
optimization techniques to train the structured model 
training and inference is slower  as we have to evaluate the neural network  and take
gradients   parts x  y   times 
structured prediction is a vast field and is beyond the scope of this tutorial  but loss
functions  regularizers and methods described by  e g   smith         such as cost augmented
decoding  can be easily applied or adapted to the neural network framework   
      probabilistic objective  crf 
in a probabilistic framework  conditional random fields  crf   we treat each of the parts
scores as a clique potential  see discussions in smith       and lafferty  mccallum   
pereira        and define the score of each structure y to be 
    one should keep in mind that the resulting objectives are no longer convex  and so lack the formal guarantees and bounds associated with convex optimization problems  similarly  the theory  learning bounds
and guarantees associated with the algorithms do not automatically transfer to the neural versions 

   

figoldberg

p
exp  py score p  
p
scorecrf  x  y    p  y x    p
y   y x  exp  py   score p  
p
exp  py nn  p   
p
 p
y   y x  exp  py   nn  p   

    

the scoring function defines a conditional distribution p  y x   and
p we wish to set the parameters of the network such that corpus conditional log likelihood  xi  yi  training log p  yi  xi  
is maximized 
the loss for a given training example  x  y  is then   log scorecrf  x  y   taking the
gradient with respect to the loss is as involved as building the associated computation
graph  the tricky part is the denominator  the partition function  which requires summing
over the potentially exponentially many structures in y  however  for some problems  a
dynamic programming algorithm exists for efficiently solving the summation in polynomial
time  i e  the forward backward viterbi recurrences for sequences and the cky insideoutside recurrences for tree structures   when such an algorithm exists  it can be adapted
to also create a polynomial size computation graph 
when an efficient enough algorithm for computing the partition function is not available 
approximate methods can be used  for example  one may use beam search for inference 
and for the partition function sum over the structures remaining in the beam instead of
over the exponentially large y x  
sequence level crfs with neural network clique potentials are discussed by peng  bo 
and xu        and do  arti  and others         where they are applied to sequence labeling
of biological data  ocr data and speech signals  and by wang and manning        who
apply them on traditional natural language tagging tasks  chunking and ner   a hinge
based approach was used by pei et al         for arc factored dependency parsing  and the
probabilistic approach by durrett and klein        for a crf constituency parser  the
approximate beam based partition function was effectively used by zhou et al         in a
transition based parser 
      reranking
when searching over all possible structures is intractable  inefficient or hard to integrate
into a model  reranking methods are often used  in the reranking framework  charniak
  johnson        collins   koo        a base model is used to produce a list of the kbest scoring structures  a more complex model is then trained to score the candidates in
the k best list such that the best structure with respect to the gold one is scored highest 
as the search is now performed over k items rather than over an exponential space  the
complex model can condition on  extract features from  arbitrary aspects of the scored
structure  reranking methods are natural candidates for structured prediction using neuralnetwork models  as they allow the modeler to focus on the feature extraction and network
structure  while removing the need to integrate the neural network scoring into a decoder 
indeed  reranking methods are often used for experimenting with neural models that are not
straightforward to integrate into a decoder  such as convolutional  recurrent and recursive
networks  which will be discussed in later sections  works using the reranking approach
   

fia primer on neural networks for nlp

include those of schwenk et al          socher et al          auli et al          le and
zuidema        and zhu et al       a  
      memm and hybrid approaches
other formulations are  of course  also possible  for example  an memm  mccallum 
freitag    pereira        can be trivially adapted to the neural network world by replacing
the logistic regression  maximum entropy  component with an mlp 
hybrid approaches between neural networks and linear models are also explored  in
particular  weiss et al         report strong results for transition based dependency parsing
in a two stage model  in the first stage  a static feed forward neural network  mlp  
is trained to perform well on each of the individual decisions of the structured problem in
isolation  in the second stage  the neural network model is held fixed  and the different layers
 output as well as hidden layer vectors  for each input are then concatenated and used as
the input features of a linear structured perceptron model  collins        that is trained to
perform beam search for the best resulting structure  while it is not clear that such training
regime is more effective than training a single structured prediction neural network  the use
of two simpler  isolated models allowed the researchers to perform a much more extensive
hyper parameter search  e g  tuning layer sizes  activation functions  learning rates and so
on  for each model than is feasible with more complicated networks 

   convolutional layers
sometimes we are interested in making predictions based on ordered sets of items  e g 
the sequence of words in a sentence  the sequence of sentences in a document and so on  
consider for example predicting the sentiment  positive  negative or neutral  of a sentence 
some of the sentence words are very informative of the sentiment  other words are less
informative  and to a good approximation  an informative clue is informative regardless
of its position in the sentence  we would like to feed all of the sentence words into a
learner  and let the training process figure out the important clues  one possible solution is
feeding a cbow representation into a fully connected network such as an mlp  however 
a downside of the cbow approach is that it ignores the ordering information completely 
assigning the sentences it was not good  it was actually quite bad and it was not bad 
it was actually quite good the exact same representation  while the global position of
the indicators not good and not bad does not matter for the classification task  the
local ordering of the words  that the word not appears right before the word bad  is
very important  a naive approach would suggest embedding word pairs  bi grams  rather
than words  and building a cbow over the embedded bigrams  while such an architecture
could be effective  it will result in huge embedding matrices  will not scale for longer ngrams  and will suffer from data sparsity problems as it does not share statistical strength
between different n grams  the embedding of quite good and very good are completely
independent of one another  so if the learner saw only one of them during training  it
will not be able to deduce anything about the other based on its component words   the
convolution and pooling  also called convolutional neural networks  or cnns  architecture
is an elegant and robust solution to this modeling problem  a convolutional neural network
is designed to identify indicative local predictors in a large structure  and combine them
   

figoldberg

to produce a fixed size vector representation of the structure  capturing these local aspects
that are most informative for the prediction task at hand 
convolution and pooling architectures  lecun   bengio        evolved in the neural
networks vision community  where they showed great success as object detectors  recognizing an object from a predefined category  cat  bicycles  regardless of its position
in the image  krizhevsky et al          when applied to images  the architecture is using
  dimensional  grid  convolutions  when applied to text  we are mainly concerned with
  d  sequence  convolutions  convolutional networks were introduced to the nlp community in the pioneering work of collobert  weston and colleagues        who used them for
semantic role labeling  and later by kalchbrenner et al         and kim        who used
them for sentiment and question type classification 
    basic convolution   pooling
the main idea behind a convolution and pooling architecture for language tasks is to apply
a non linear  learned  function over each instantiation of a k word sliding window over
the sentence  this function  also called filter  transforms a window of k words into a d
dimensional vector that captures important properties of the words in the window  each
dimension is sometimes referred to in the literature as a channel   then  a pooling
operation is used to combine the vectors resulting from the different windows into a single
d dimensional vector  by taking the max or the average value observed in each of the d
channels over the different windows  the intention is to focus on the most important
features in the sentence  regardless of their location  the d dimensional vector is then
fed further into a network that is used for prediction  the gradients that are propagated
back from the networks loss during the training process are used to tune the parameters
of the filter function to highlight the aspects of the data that are important for the task
the network is trained for  intuitively  when the sliding window is run over a sequence  the
filter function learns to identify informative k grams 
more formally  consider a sequence of words x   x            xn   each with their corresponding demb dimensional word embedding v xi    a  d convolution layer   of width k works
by moving a sliding window of size k over the sentence  and applying the same filter to
each window in the sequence  v xi    v xi              v xi k      the filter function is usually a
linear transformation followed by a non linear activation function 
let the concatenated vector of the ith window be wi    v xi    v xi              v xi k     
wi  rkdemb   depending on whether we pad the sentence with k    words to each side 
we may get either m   n  k      narrow convolution  or m   n   k     windows  wide
convolution   kalchbrenner et al          the result of the convolution layer is m vectors
p            pm   pi  rdconv where 
pi   g wi w   b 

    

g is a non linear activation function that is applied element wise  w  rkdemb dconv and
b  rdconv are parameters of the network  each pi is a dconv dimensional vector  encoding
     d here refers to a convolution operating over   dimensional inputs such as sequences  as opposed to  d
convolutions which are applied to images 

   

fia primer on neural networks for nlp

  
w

max

the quick brown fox jumped over the lazy dog
the quick brown

mul tanh

quick brown fox

mul tanh

brown fox jumped

mul tanh

fox jumped over

mul tanh

jumped over the

mul tanh

over the lazy

mul tanh

the lazy dog

mul tanh

convolution

pooling

figure     d convolution pooling over the sentence the quick brown fox jumped over the
lazy dog  this is a narrow convolution  no padding is added to the sentence 
with a window size of    each word is translated to a   dim embedding vector
 not shown   the embedding vectors are then concatenated  resulting in   dim
window representations  each of the seven windows is transfered through a     
filter  linear transformation followed by element wise tanh   resulting in seven
  dimensional filtered representations  then  a max pooling operation is applied 
taking the max over each dimension  resulting in a final   dimensional pooled
vector 

the information in wi   ideally  each dimension captures a different kind of indicative information  the m vectors are then combined using a max pooling layer  resulting in a single
dconv dimensional vector c 
cj   max pi  j 
  im

    

pi  j  denotes the jth component of pi   the effect of the max pooling operation is to get the
most salient information across window positions  ideally  each dimension will specialize
in a particular sort of predictors  and max operation will pick on the most important
predictor of each type 
figure   provides an illustration of the process 
the resulting vector c is a representation of the sentence in which each dimension
reflects the most salient information with respect to some prediction task  c is then fed
into a downstream network layers  perhaps in parallel to other vectors  culminating in an
output layer which is used for prediction  the training procedure of the network calculates
the loss with respect to the prediction task  and the error gradients are propagated all the
way back through the pooling and convolution layers  as well as the embedding layers    
    besides being useful for prediction  a by product of the training procedure is a set of parameters w  b
and embeddings v   that can be used in a convolution and pooling architecture to encode arbitrary length

   

figoldberg

while max pooling is the most common pooling operation in text applications  other
pooling operations are also possible  the second most common operation being average
pooling  taking the average value of each index instead of the max 
    dynamic  hierarchical and k max pooling
rather than performing a single pooling operation over the entire sequence  we may want
to retain some positional information based on our domain understanding of the prediction
problem at hand  to this end  we can split the vectors pi into   distinct groups  apply the
pooling separately on each group  and then concatenate the   resulting dconv  dimensional
vectors c            c    the division of the pi s into groups is performed based on domain knowledge  for example  we may conjecture that words appearing early in the sentence are
more indicative than words appearing late  we can then split the sequence into   equally
sized regions  applying a separate max pooling to each region  for example  johnson and
zhang        found that when classifying documents into topics  it is useful to have   
average pooling regions  clearly separating the initial sentences  where the topic is usually
introduced  from later ones  while for a sentiment classification task a single max pooling
operation over the entire sentence was optimal  suggesting that one or two very strong
signals are enough to determine the sentiment  regardless of the position in the sentence  
similarly  in a relation extraction kind of task we may be given two words and asked to
determine the relation between them  we could argue that the words before the first word 
the words after the second word  and the words between them provide three different kinds
of information  chen et al          we can thus split the pi vectors accordingly  pooling
separately the windows resulting from each group 
another variation is using a hierarchy of convolutional layers  in which we have a succession of convolution and pooling layers  where each stage applies a convolution to a sequence 
pools every k neighboring vectors  performs a convolution on the resulting pooled sequence 
applies another convolution and so on  this architecture allows sensitivity to increasingly
larger structures 
finally  kalchbrenner et al         introduced a k max pooling operation  in which the
top k values in each dimension are retained instead of only the best one  while preserving
the order in which they appeared in the text  for example a  consider the following matrix 

 
 

 

 
 

 
 
 
 
 


 
 

 

 
 



a   max pooling over the column vectors will result in         while a   max pooling


     
will result in the following matrix 
whose rows will then be concatenated to
     


           
sentences into fixed size vectors  such that sentences that share the same kind of predictive information
will be close to each other 

   

fia primer on neural networks for nlp

the k max pooling operation makes it possible to pool the k most active indicators that
may be a number of positions apart  it preserves the order of the features  but is insensitive
to their specific positions  it can also discern more finely the number of times the feature
is highly activated  kalchbrenner et al         
    variations
rather than a single convolutional layer  several convolutional layers may be applied in
parallel  for example  we may have four different convolutional layers  each with a different
window size in the range     capturing n gram sequences of varying lengths  the result
of each convolutional layer will then be pooled  and the resulting vectors concatenated and
fed to further processing  kim        
the convolutional architecture need not be restricted into the linear ordering of a sentence  for example  ma et al         generalize the convolution operation to work over
syntactic dependency trees  there  each window is around a node in the syntactic tree 
and the pooling is performed over the different nodes  similarly  liu et al         apply a
convolutional architecture on top of dependency paths extracted from dependency trees  le
and zuidema        propose to perform max pooling over vectors representing the different
derivations leading to the same chart item in a chart parser 

    recurrent neural networks  modeling sequences and stacks
when dealing with language data  it is very common to work with sequences  such as words
 sequences of letters   sentences  sequences of words  and documents  we saw how feedforward networks can accommodate arbitrary feature functions over sequences through the
use of vector concatenation and vector addition  cbow   in particular  the cbow representations allows to encode arbitrary length sequences as fixed sized vectors  however 
the cbow representation is quite limited  and forces one to disregard the order of features  the convolutional networks also allow encoding a sequence into a fixed size vector 
while representations derived from convolutional networks are an improvement above the
cbow representation as they offer some sensitivity to word order  their order sensitivity is
restricted to mostly local patterns  and disregards the order of patterns that are far apart
in the sequence 
recurrent neural networks  rnns   elman        allow representing arbitrarily sized
structured inputs in a fixed size vector  while paying attention to the structured properties
of the input 
     the rnn abstraction
we use xi j to denote the sequence of vectors xi           xj   the rnn abstraction takes as
input an ordered list of input vectors x         xn together with an initial state vector s   
and returns an ordered list of state vectors s         sn   as well as an ordered list of output
vectors y         yn   an output vector yi is a function of the corresponding state vector
si   the input vectors xi are presented to the rnn in a sequential fashion  and the state
vector si and output vector yi represent the state of the rnn after observing the inputs
x  i   the output vector yi is then used for further prediction  for example  a model for
   

figoldberg

predicting the conditional probability of an event e given the sequence m  i can be defined
as p e   j x  i     softmax yi w   b  j   the jth element in the output vector resulting
from the softmax operation  the rnn model provides a framework for conditioning on the
entire history x            xi without resorting to the markov assumption which is traditionally
used for modeling sequences    indeed  rnn based language models result in very good
perplexity scores when compared to n gram based models 
mathematically  we have a recursively defined function r that takes as input a state
vector si and an input vector xi     and results in a new state vector si     an additional
function o is used to map a state vector si to an output vector yi     when constructing an
rnn  much like when constructing a feed forward network  one has to specify the dimension
of the inputs xi as well as the dimensions of the outputs yi   the dimensions of the states
si are a function of the output dimension   
rnn s    x  n    s  n   y  n
si   r si    xi  

    

yi   o si  
xi  rdin   yi  rdout   si  rf  dout  
the functions r and o are the same across the sequence positions  but the rnn keeps
track of the states of computation through the state vector that is kept and being passed
between invocations of r 
graphically  the rnn has been traditionally presented as in figure   
yi

si 

r o



xi

si

figure    graphical representation of an rnn  recursive  
    the kth order markov assumption states that the observation at time i is independent of the observations
at times i   k   j  j     given the observations at times i          i  k  this assumption is at the
basis for many sequence modeling technique such as n gram models and hidden markov models 
    using the o function is somewhat non standard  and is used in order to unify the different rnn models
to to be presented in the next section  for the simple rnn  elman rnn  and the gru architectures 
o is the identity mapping  and for the lstm architecture o selects a fixed subset of the state 
    while rnn architectures in which the state dimension is independent of the output dimension are
possible  the current popular architectures  including the simple rnn  the lstm and the gru do not
follow this flexibility 

   

fia primer on neural networks for nlp

this presentation follows the recursive definition  and is correct for arbitrary long sequences 
however  for a finite sized input sequence  and all input sequences we deal with are finite 
one can unroll the recursion  resulting in the structure in figure   
y 

s 

r o

x 

y 

y 

s 

r o

s 

r o

x 

y 

s 

x 

r o

x 

y 

s 

r o

s 

x 



figure    graphical representation of an rnn  unrolled  

while not usually shown in the visualization  we include here the parameters  in order
to highlight the fact that the same parameters are shared across all time steps  different
instantiations of r and o will result in different network structures  and will exhibit different
properties in terms of their running times and their ability to be trained effectively using
gradient based methods  however  they all adhere to the same abstract interface  we will
provide details of concrete instantiations of r and o  the simple rnn  the lstm and the
gru  in section     before that  lets consider modeling with the rnn abstraction 
first  we note that the value of si is based on the entire input x         xi   for example 
by expanding the recursion for i     we get 

s   r s    x   
s

z      
 r r s    x     x   
s

z      
 r r r s    x     x     x   

    

s

z      
 r r r r s    x     x     x     x   
thus  sn  as well as yn   could be thought of as encoding the entire input sequence    is
the encoding useful  this depends on our definition of usefulness  the job of the network
training is to set the parameters of r and o such that the state conveys useful information
for the task we are tying to solve 
    note that  unless r is specifically designed against this  it is likely that the later elements of the input
sequence have stronger effect on sn than earlier ones 

   

figoldberg

     rnn training
viewed as in figure   it is easy to see that an unrolled rnn is just a very deep neural
network  or rather  a very large computation graph with somewhat complex nodes   in
which the same parameters are shared across many parts of the computation  to train an
rnn network  then  all we need to do is to create the unrolled computation graph for a
given input sequence  add a loss node to the unrolled graph  and then use the backward
 backpropagation  algorithm to compute the gradients with respect to that loss  this
procedure is referred to in the rnn literature as backpropagation through time  or bptt
 werbos           there are various ways in which the supervision signal can be applied 
       acceptor
one option is to base the supervision signal only on the final output vector  yn   viewed this
way  the rnn is an acceptor  we observe the final state  and then decide on an outcome   
for example  consider training an rnn to read the characters of a word one by one and
then use the final state to predict the part of speech of that word  this is inspired by ling
et al       b   an rnn that reads in a sentence and  based on the final state decides if it
conveys positive or negative sentiment  this is inspired by wang et al       b  or an rnn
that reads in a sequence of words and decides whether it is a valid noun phrase  the loss
in such cases is defined in terms of a function of yn   o sn    and the error gradients will
backpropagate through the rest of the sequence  see figure       the loss can take any
familiar form  cross entropy  hinge  margin  etc 
       encoder
similar to the acceptor case  an encoder supervision uses only the final output vector  yn  
however  unlike the acceptor  where a prediction is made solely on the basis of the final
vector  here the final vector is treated as an encoding of the information in the sequence  and
is used as additional information together with other signals  for example  an extractive
document summarization system may first run over the document with an rnn  resulting
    variants of the bptt algorithm include unrolling the rnn only for a fixed number of input symbols at
each time  first unroll the rnn for inputs x  k   resulting in s  k   compute a loss  and backpropagate
the error through the network  k steps back   then  unroll the inputs xk    k   this time using sk as the
initial state  and again backpropagate the error for k steps  and so on  this strategy is based on the
observations that for the simple rnn variant  the gradients after k steps tend to vanish  for large enough
k   and so omitting them is negligible  this procedure allows training of arbitrarily long sequences  for
rnn variants such as the lstm or the gru that are designed specifically to mitigate the vanishing
gradients problem  this fixed size unrolling is less motivated  yet it is still being used  for example when
doing language modeling over a book without breaking it into sentences  a similar variant unrolls the
network for the entire sequence in the forward step  but only propagates the gradients back for k steps
from each position 
    the terminology is borrowed from finite state acceptors  however  the rnn has a potentially infinite
number of states  making it necessary to rely on a function other than a lookup table for mapping states
to decisions 
    this kind of supervision signal may be hard to train for long sequences  especially so with the simplernn  because of the vanishing gradients problem  it is also a generally hard learning task  as we do not
tell the process on which parts of the input to focus 

   

fia primer on neural networks for nlp

loss
predict  
calc loss
y 
s 

r o

s 

x 

r o

s 

x 

r o

s 

x 

r o

s 

x 

r o

x 

figure    acceptor rnn training graph 
in a vector yn summarizing the entire document  then  yn will be used together with other
features in order to select the sentences to be included in the summarization 
       transducer
another option is to treat the rnn as a transducer  producing an output for each input
it reads in  modeled this way  we can compute a local loss signal llocal  yi   yi   for each
of the outputs yp
i based on a true label yi   the loss for unrolled sequence will then be 
l y  n
   y  n     ni   llocal  yi   yi    or using another combination rather than a sum such
as an average or a weighted average  see figure     one example for such a transducer
is a sequence tagger  in which we take xi n to be feature representations for the n words
of a sentence  and yi as an input for predicting the tag assignment of word i based on
words   i  a ccg super tagger based on such an architecture provides state of the art
ccg super tagging results  xu et al         
loss

sum

predict  
calc loss

predict  
calc loss

y 
s 

r o

x 

predict  
calc loss

y 
s 

r o

x 

predict  
calc loss

y 
s 

r o

x 

predict  
calc loss

y 
s 

r o

x 

y 
s 

r o

x 

figure    transducer rnn training graph 
a very natural use case of the transduction setup is for language modeling  in which the
sequence of words x  i is used to predict a distribution over the  i     th word  rnn based
language models are shown to provide better perplexities than traditional language models
 mikolov et al         sundermeyer  schluter    ney        mikolov        jozefowicz 
vinyals  schuster  shazeer    wu        
using rnns as transducers allows us to relax the markov assumption that is traditionally taken in language models and hmm taggers  and condition on the entire prediction
   

figoldberg

history  the power of the ability to condition on arbitrarily long histories is demonstrated
in generative character level rnn models  in which a text is generated character by character  each character conditioning on the previous ones  sutskever  martens    hinton        
the generated texts show sensitivity to properties that are not captured by n gram language
models  including line lengths and nested parenthesis balancing  for a good demonstration
and analysis of the properties of rnn based character level language models  see the work
of karpathy  johnson  and li        
       encoder   decoder
finally  an important special case of the encoder scenario is the encoder decoder framework
 cho  van merrienboer  bahdanau    bengio      a  sutskever et al          the rnn is
used to encode the sequence into a vector representation yn   and this vector representation
is then used as auxiliary input to another rnn that is used as a decoder  for example 
in a machine translation setup the first rnn encodes the source sentence into a vector
representation yn   and then this state vector is fed into a separate  decoder  rnn that
is trained to predict  using a transducer like language modeling objective  the words of
the target language sentence based on the previously predicted words as well as yn   the
supervision happens only for the decoder rnn  but the gradients are propagated all the
way back to the encoder rnn  see figure    
loss

sum

predict  
calc loss

predict  
calc loss

y 
sd 

rd  od

y 
sd 

re  oe

x 

se 

sd 

rd  od

x 

re  oe

x 

se 

predict  
calc loss

y 

rd  od

x 

se 

predict  
calc loss

y 
sd 

rd  od

x 

re  oe

x 

se 

predict  
calc loss
y 
sd 

rd  od

x 

re  oe

x 

se 

x 

re  oe

se 

x 

figure    encoder decoder rnn training graph 
such an approach was shown to be surprisingly effective for machine translation  sutskever
et al         using lstm rnns  in order for this technique to work  sutskever et al  found
it effective to input the source sentence in reverse  such that xn corresponds to the first
   

fia primer on neural networks for nlp

word of the sentence  in this way  it is easier for the second rnn to establish the relation
between the first word of the source sentence to the first word of the target sentence 
another use case of the encoder decoder framework is for sequence transduction  here 
in order to generate tags t            tn   an encoder rnn is first used to encode the sentence
x  n into fixed sized vector  this vector is then fed as the initial state vector of another
 transducer  rnn  which is used together with x  n to predict the label ti at each position
i  this approach was used by filippova  alfonseca  colmenares  kaiser  and vinyals       
to model sentence compression by deletion 
     multi layer  stacked  rnns
rnns can be stacked in layers  forming a grid  hihi   bengio         consider k rnns 
j
rnn            rnnk   where the jth rnn has states sj  n and outputs y  n
  the input for the
first rnn are x  n   while the input of the jth rnn  j     are the outputs of the rnn
j 
k  
below it  y  n
  the output of the entire formation is the output of the last rnn  y  n
such layered architectures are often called deep rnns  a visual representation of a   layer
rnn is given in figure    
y 

y 

y  
s  

r   o 

y  
s  

y  
s  

r   o 

r   o 

x 

r   o 

r   o 

r   o 

r   o 

r   o 

x 

r   o 

x 

r   o 

y  
s  

y  
s  

y  
s  

y 

y  
s  

y  
s  

y  
s  

y 

y  
s  

y  
s  

y  
s  

y 

r   o 

r   o 

x 

s  

y  
s  

y  
s  

r   o 

r   o 

s  

y  
s  

r   o 

s  

x 

figure     a   layer  deep  rnn architecture 
while it is not theoretically clear what is the additional power gained by the deeper
architecture  it was observed empirically that deep rnns work better than shallower ones
on some tasks  in particular  sutskever et al         report that a   layers deep architecture was crucial in achieving good machine translation performance in an encoder decoder
framework  irsoy and cardie        also report improved results from moving from a onelayer birnn to an architecture with several layers  many other works report result using
layered rnn architectures  but do not explicitly compare to   layer rnns 
     bidirectional rnns  birnn 
a useful elaboration of an rnn is a bidirectional rnn  birnn  also commonly referred
to as birnn   schuster   paliwal        graves           consider the task of sequence
tagging over a sentence x            xn   an rnn allows us to compute a function of the ith word
    when used with a specific rnn architecture such as an lstm  the model is called bilstm 

   

figoldberg

xi based on the past  the words x  i up to and including it  however  the following words
xi n may also be useful for prediction  as is evident by the common sliding window approach
in which the focus word is categorized based on a window of k words surrounding it  much
like the rnn relaxes the markov assumption and allows looking arbitrarily back into the
past  the birnn relaxes the fixed window size assumption  allowing to look arbitrarily far
at both the past and the future 
consider an input sequence x  n   the birnn works by maintaining two separate states 
f
si and sbi for each input position i  the forward state sfi is based on x    x            xi   while
the backward state sbi is based on xn   xn            xi   the forward and backward states are
generated by two different rnns  the first rnn  rf   of   is fed the input sequence x  n
as is  while the second rnn  rb   ob   is fed the input sequence in reverse  the state
representation si is then composed of both the forward and backward states 
the output at position i is based on the concatenation of the two output vectors
yi    yif   yib      of  sfi    ob  sbi     taking into account both the past and the future  the
vector yi can then be used directly for prediction  or fed as part of the input to a more
complex network  while the two rnns are run independently of each other  the error gradients at position i will flow both forward and backward through the two rnns  a visual
representation of the birnn architecture is given in figure    
ythe

ybrown

concat

concat

sb 

rb  ob
y f

sf 

rf  of

xthe

concat
y b

y b
sb  

rb  ob

sb  

rf  of

rb  ob
y f

sf 

rf  of

xbrown

xfox

y

concat
y b

y f
sf 

yjumped

yfox

concat
y b

sb  

rb  ob
y f

sf 

rf  of

xjumped

y b
sb  

sb  

rb  ob
y f

sf 

sf 

rf  of

x

figure     birnn over the sentence the brown fox jumped   
the use of birnns for sequence tagging was introduced to the nlp community by irsoy
and cardie        
     rnns for representing stacks
some algorithms in language processing  including those for transition based parsing  nivre 
       require performing feature extraction over a stack  instead of being confined to
looking at the k top most elements of the stack  the rnn framework can be used to provide
a fixed sized vector encoding of the entire stack 
the main intuition is that a stack is essentially a sequence  and so the stack state can be
represented by taking the stack elements and feeding them in order into an rnn  resulting
in a final encoding of the entire stack  in order to do this computation efficiently  without
   

fia primer on neural networks for nlp

performing an o n  stack encoding operation each time the stack changes   the rnn state
is maintained together with the stack state  if the stack was push only  this would be
trivial  whenever a new element x is pushed into the stack  the corresponding vector x
will be used together with the rnn state si in order to obtain a new state si     dealing
with pop operation is more challenging  but can be solved by using the persistent stack
data structure  okasaki        goldberg  zhao    huang         persistent  or immutable 
data structures keep old versions of themselves intact when modified  the persistent stack
construction represents a stack as a pointer to the head of a linked list  an empty stack is
the empty list  the push operation appends an element to the list  returning the new head 
the pop operation then returns the parent of the head  but keeping the original list intact 
from the point of view of someone who held a pointer to the previous head  the stack did
not change  a subsequent push operation will add a new child to the same node  applying
this procedure throughout the lifetime of the stack results in a tree  where the root is an
empty stack and each path from a node to the root represents an intermediary stack state 
figure    provides an example of such a tree  the same process can be applied in the
computation graph construction  creating an rnn with a tree structure instead of a chain
structure  backpropagating the error from a given node will then affect all the elements
that participated in the stack when the node was created  in order  figure    shows the
computation graph for the stack rnn corresponding to the last state in figure     this
modeling approach was proposed independently by dyer et al         and watanabe and
sumita        for transition based dependency parsing 
head

head


head

a

a



    push a

head
a



b

    push b

b

d

head

c

a



    push c

b

c

a



    pop

    push d

head

d



a

b
head

    pop

c

d



a

b

c



a

b

c

b

head

e

e

d

d

c



a

b

f

c

head
    pop

    push e

    push f

figure     an immutable stack construction for the sequence of operations push a  push b 
push c  pop  push d  pop  pop  push e  push f 

     a note on reading the literature
unfortunately  it is often the case that inferring the exact model form from reading its
description in a research paper can be quite challenging  many aspects of the models
   

figoldberg

ya e

r o

ya e f

sa e

ya b d xe

sa

ya

so

r o

xa

ya b

sa

r o

xb

sa b

ya c

r o

sa e f

xf

sa b d

r o

sa b

r o

xd

sa c

xc

figure     the stack rnn corresponding to the final state in figure    

are not yet standardized  and different researchers use the same terms to refer to slightly
different things  to list a few examples  the inputs to the rnn can be either one hot vectors
 in which case the embedding matrix is internal to the rnn  or embedded representations 
the input sequence can be padded with start of sequence and or end of sequence symbols 
or not  while the output of an rnn is usually assumed to be a vector which is expected
to be fed to additional layers followed by a softmax for prediction  as is the case in the
presentation in this tutorial   some papers assume the softmax to be part of the rnn itself 
in multi layer rnn  the state vector can be either the output of the top most layer  or a
concatenation of the outputs from all layers  when using the encoder decoder framework 
conditioning on the output of the encoder can be interpreted in various different ways  and
so on  on top of that  the lstm architecture described in the next section has many small
variants  which are all referred to under the common name lstm  some of these choices
are made explicit in the papers  other require careful reading  and others still are not even
mentioned  or are hidden behind ambiguous figures or phrasing 
as a reader  be aware of these issues when reading and interpret model descriptions  as
a writer  be aware of these issues as well  either fully specify your model in mathematical
notation  or refer to a different source in which the model is fully specified  if such a source
is available  if using the default implementation from a software package without knowing
the details  be explicit of that fact and specify the software package you use  in any case 
dont rely solely on figures or natural language text when describing your model  as these
are often ambiguous 
   

fia primer on neural networks for nlp

    concrete rnn architectures
we now turn to present three different instantiations of the abstract rn n architecture
discussed in the previous section  providing concrete definitions of the functions r and o 
these are the simple rnn  srnn   the long short term memory  lstm  and the gated
recurrent unit  gru  
     simple rnn
the simplest rnn formulation  known as an elman network or simple rnn  s rnn   was
proposed by elman        and explored for use in language modeling by mikolov        
the s rnn takes the following form 
si  rsrnn  si    xi     g xi wx   si  ws   b 
yi  osrnn  si     si

    

si   yi  rds   xi  rdx   wx  rdx ds   ws  rds ds   b  rds
that is  the state at position i is a linear combination of the input at position i and
the previous state  passed through a non linear activation  commonly tanh or relu   the
output at position i is the same as the hidden state in that position   
in spite of its simplicity  the simple rnn provides strong results for sequence tagging
 xu et al         as well as language modeling  for comprehensive discussion on using
simple rnns for language modeling  see the phd thesis by mikolov        
     lstm
the s rnn is hard to train effectively because of the vanishing gradients problem  pascanu
et al          error signals  gradients  in later steps in the sequence diminish quickly in
the back propagation process  and do not reach earlier input signals  making it hard for
the s rnn to capture long range dependencies  the long short term memory  lstm 
architecture  hochreiter   schmidhuber        was designed to solve the vanishing gradients
problem  the main idea behind the lstm is to introduce as part of the state representation
also memory cells  a vector  that can preserve gradients across time  access to the
memory cells is controlled by gating components  smooth mathematical functions that
simulate logical gates  at each input state  a gate is used to decide how much of the new
input should be written to the memory cell  and how much of the current content of the
memory cell should be forgotten  concretely  a gate g        n is a vector of values in the
range        that is multiplied component wise with another vector v  rn   and the result is
then added to another vector  the values of g are designed to be close to either   or    i e 
by using a sigmoid function  indices in v corresponding to near one values in g are allowed
to pass  while those corresponding to near zero values are blocked 
    some authors treat the output at position i as a more complicated function of the state  e g  a linear
transformation  or an mlp  in our presentation  such further transformation of the output are not
considered part of the rnn  but as separate computations that are applied to the rnns output 

   

figoldberg

mathematically  the lstm architecture is defined as   

sj   rlstm  sj    xj     cj   hj  
cj  cj  fi f   g fi i

hj   tanh cj   fi o

i   xj wxi   hj  whi  

f   xj wxf   hj  whf  
o   xj w

xo

  hj  w

ho

    

 

g   tanh xj wxg   hj  whg  
yj   olstm  sj    hj

sj  r dh   xi  rdx   cj   hj   i  f   o  g  rdh   wx  rdx dh   wh  rdh dh  
the symbol fi is used to denote component wise product  the state at time j is composed of two vectors  cj and hj   where cj is the memory component and hj is the hidden
state component  there are three gates  i  f and o  controlling for input  f orget and output 
the gate values are computed based on linear combinations of the current input xj and the
previous state hj    passed through a sigmoid activation function  an update candidate g
is computed as a linear combination of xj and hj    passed through a tanh activation function  the memory cj is then updated  the forget gate controls how much of the previous
memory to keep  cj  fi f    and the input gate controls how much of the proposed update
to keep  g fi i   finally  the value of hj  which is also the output yj   is determined based
on the content of the memory cj   passed through a tanh non linearity and controlled by the
output gate  the gating mechanisms allow for gradients related to the memory part cj to
stay high across very long time ranges 
for further discussion on the lstm architecture see the phd thesis by alex graves
        as well as the online post by olah      b   for an analysis of the behavior of an
lstm when used as a character level language model  see the work of karpathy et al 
       
for further explanation of the motivation behind the gating mechanism in the lstm
 and the gru  and its relation to solving the vanishing gradient problem in recurrent neural
networks  see sections     and     in the detailed course notes of cho        
lstms are currently the most successful type of rnn architecture  and they are responsible for many state of the art sequence modeling results  the main competitor of the
lstm rnn is the gru  to be discussed next 
    there are many variants on the lstm architecture presented here  for example  forget gates were not
part of the original proposal by hochreiter and schmidhuber         but are shown to be an important
part of the architecture  other variants include peephole connections and gate tying  for an overview
and comprehensive empirical comparison of various lstm architectures see the work of greff  srivastava 
koutnk  steunebrink  and schmidhuber        

   

fia primer on neural networks for nlp

       practical considerations
when training lstm networks  jozefowicz et al         strongly recommend to always
initialize the bias term of the forget gate to be close to one  when applying dropout to an
rnn with an lstm  zaremba et al         found out that it is crucial to apply dropout
only on the non recurrent connection  i e  only to apply it between layers and not between
sequence positions 
     gru
the lstm architecture is very effective  but also quite complicated  the complexity of the
system makes it hard to analyze  and also computationally expensive to work with  the
gated recurrent unit  gru  was recently introduced by cho et al       b  as an alternative
to the lstm  it was subsequently shown by chung et al         to perform comparably to
the lstm on several  non textual  datasets 
like the lstm  the gru is also based on a gating mechanism  but with substantially
fewer gates and without a separate memory component 
sj   rgru  sj    xj        z  fi sj    z fi sj
z   xj wxz   sj  wsz  
r   xj wxr   sj  wsr  
sj   tanh xj wxs    sj  fi r wsg  

    

yj   ogru  sj    sj
sj   sj  rds   xi  rdx   z  r  rds   wx  rdx ds   ws  rds ds  
one gate  r  is used to control access to the previous state sj  and compute a proposed update sj   the updated state sj  which also serves as the output yj   is then determined based
on an interpolation of the previous state sj  and the proposal sj   where the proportions of
the interpolation are controlled using the gate z   
the gru was shown to be effective in language modeling and machine translation 
however  the jury is still out between the gru  the lstm and possible alternative rnn
architectures  and the subject is actively researched  for an empirical exploration of the
gru and the lstm architectures  see work of jozefowicz et al         
     other variants
the gated architectures of the lstm and the gru help in alleviating the vanishing gradients problem of the simple rnn  and allow these rnns to capture dependencies that span
long time ranges  some researchers explore simpler architectures than the lstm and the
gru for achieving similar benefits 
mikolov et al         observed that the matrix multiplication si  ws coupled with the
nonlinearity g in the update rule r of the simple rnn causes the state vector si to undergo
    the states s are often called h in the gru literature 

   

figoldberg

large changes at each time step  prohibiting it from remembering information over long
time periods  they propose to split the state vector si into a slow changing component ci
 context units  and a fast changing component hi     the slow changing component ci is
updated according to a linear interpolation of the input and the previous component  ci  
     xi wx    ci    where           this update allows ci to accumulate the previous
inputs  the fast changing component hi is updated similarly to the simple rnn update
rule  but changed to take ci into account as well    hi    xi wx    hi  wh   ci wc   
finally  the output yi is the concatenation of the slow and the fast changing parts of the
state  yi    ci   hi    mikolov et al  demonstrate that this architecture provides competitive
perplexities to the much more complex lstm on language modeling tasks 
the approach of mikolov et al  can be interpreted as constraining the block of the
matrix ws in the s rnn corresponding to ci to be a multiply of the identity matrix  see
mikolov et al         for the details   le  jaitly  and hinton        propose an even simpler
approach  set the activation function of the s rnn to a relu  and initialize the biases b
as zeroes and the matrix ws as the identify matrix  this causes an untrained rnn to copy
the previous state to the current state  add the effect of the current input xi and set the
negative values to zero  after setting this initial bias towards state copying  the training
procedure allows ws to change freely  le et al  demonstrate that this simple modification
makes the s rnn comparable to an lstm with the same number of parameters on several
tasks  including language modeling 

    modeling trees  recursive neural networks
the rnn is very useful for modeling sequences  in language processing  it is often natural
and desirable to work with tree structures  the trees can be syntactic trees  discourse trees 
or even trees representing the sentiment expressed by various parts of a sentence  socher
et al          we may want to predict values based on specific tree nodes  predict values
based on the root nodes  or assign a quality score to a complete tree or part of a tree  in
other cases  we may not care about the tree structure directly but rather reason about spans
in the sentence  in such cases  the tree is merely used as a backbone structure which helps
guide the encoding process of the sequence into a fixed size vector 
the recursive neural network  recnn  abstraction  pollack         popularized in nlp
by richard socher and colleagues  socher  manning    ng        socher  lin  ng    manning        socher et al         socher        is a generalization of the rnn from sequences
to  binary  trees   
much like the rnn encodes each sentence prefix as a state vector  the recnn encodes
each tree node as a state vector in rd   we can then use these state vectors either to predict
values of the corresponding nodes  assign quality values to each node  or as a semantic
representation of the spans rooted at the nodes 
    we depart from the notation of mikolov et al         and reuse the symbols used in the lstm description 
    the update rule diverges from the s rnn update rule also by fixing the non linearity to be a sigmoid
function  and by not using a bias term  however  these changes are not discussed as central to the
proposal 
    while presented in terms of binary parse trees  the concepts easily transfer to general recursively defined
data structures  with the major technical challenge is the definition of an effective form for r  the
combination function 

   

fia primer on neural networks for nlp

the main intuition behind the recursive neural networks is that each subtree is represented as a d dimensional vector  and the representation of a node p with children c  and c 
is a function of the representation of the nodes  vec p    f  vec c     vec c      where f is a
composition function taking two d dimensional vectors and returning a single d dimensional
vector  much like the rnn state si is used to encode the entire sequence x    i  the recnn
state associated with a tree node p encodes the entire subtree rooted at p  see figure   
for an illustration 

s 
combine

n p   

vp  

combine

n p   

v  

figure     illustration of a recursive neural network  the representations of v and np 
are combined to form the representation of vp  the representations of vp and
np  are then combined to form the representation of s 

     formal definition
consider a binary parse tree t over an n word sentence  as a reminder  an ordered 
unlabeled tree over a string x            xn can be represented as a unique set of triplets  i  k  j  
s t  i  k  j  each such triplet indicates that a node spanning words xi j is parent of the
nodes spanning xi k and xk   j   triplets of the form  i  i  i  correspond to terminal symbols
at the tree leaves  the words xi    moving from the unlabeled case to the labeled one  we can
represent a tree as a set of   tuples  a  b  c  i  k  j   whereas i  k and j indicate the spans
as before  and a  b and c are the node labels of of the nodes spanning xi j   xi k and xk   j
respectively  here  leaf nodes have the form  a  a  a  i  i  i   where a is a pre terminal
symbol  we refer to such tuples as production rules  for an example  consider the syntactic
tree for the sentence the boy saw her duck 
   

figoldberg

s
vp

np

np

det noun verb
the

boy

saw

det noun
her

duck

its corresponding unlabeled and labeled representations are  
unlabeled
       
       
       
       
       
       
       
       
       

labeled
 det  det  det          
 noun  noun  noun          
 verb  verb  verb          
 det  det  det          
 noun  noun  noun          
 np  det  noun          
 vp  verb  np          
 np  det  noun          
 s  np  vp          

corresponding span
x    the
x    boy
saw
her
duck
her duck
saw her duck
the boy
the boy saw her duck

a
the set of production rules above can be uniquely converted to a set tree nodes qi j
 indicating a node with symbol a over the span xi j   by simply ignoring the elements
 b  c  k  in each production rule  we are now in position to define the recursive neural
network 
a recursive neural network  recnn  is a function that takes as input a parse tree over an
n word sentence x            xn   each of the sentences words is represented as a d dimensional
vector xi   and the tree is represented as a set t of production rules  a  b  c  i  j  k  
a   the recnn returns as output a corresponding set of
denote the nodes of t by qi j
a
d
inside state vectors si j   where each inside state vector sa
i j  r represents the corresponding
a   and encodes the entire structure rooted at that node  like the sequence rnn 
tree node qi j
the tree shaped recnn is defined recursively using a function r  where the inside vector of
a given node is defined as a function of the inside vectors of its direct children    formally 

d
a
recnn x            xn   t     sa
i j  r   qi j  t  

sa
i i  v xi  

b
c
sa
i j  r a  b  c  si k   sk   j  

    
b
c
 t   qk   j
t
qi k

    le and zuidema        extend the recnn definition such that each node has  in addition to its inside
state vector  also an outside state vector representing the entire structure around the subtree rooted
at that node  their formulation is based on the recursive computation of the classic inside outside
algorithm  and can be thought of as the birnn counterpart of the tree recnn  for details  see work by
le and zuidema 

   

fia primer on neural networks for nlp

the function r usually takes the form of a simple linear transformation  which may or
may not be followed by a non linear activation function g 
c
b
c
r a  b  c  sb
i k   sk   j     g  si k   sk   j  w 

    

this formulation of r ignores the tree labels  using the same matrix w  r dd for all
combinations  this may be a useful formulation in case the node labels do not exist  e g 
when the tree does not represent a syntactic structure with clearly defined labels  or when
they are unreliable  however  if the labels are available  it is generally useful to include them
in the composition function  one approach would be to introduce label embeddings v a 
mapping each non terminal symbol to a dnt dimensional vector  and change r to include
the embedded symbols in the combination function 
c
b
c
r a  b  c  sb
i k   sk   j     g  si k   sk   j   v a   v b  w 

    

 here  w  r d  dnt d    such approach is taken by qian  tian  huang  liu  zhu  and
zhu         an alternative approach  due to socher et al         is to untie the weights
according to the non terminals  using a different composition matrix for each b  c pair of
symbols   
bc
c
b
c
 
r a  b  c  sb
i k   sk   j     g  si k   sk   j  w

    

this formulation is useful when the number of non terminal symbols  or the number of
possible symbol combinations  is relatively small  as is usually the case with phrase structure
parse trees  a similar model was also used by hashimoto et al         to encode subtrees
in semantic relation classification task 
     extensions and variations
as all of the definitions of r above suffer from the vanishing gradients problem of the
simple rnn  several authors sought to replace it with functions inspired by the long shortterm memory  lstm  gated architecture  resulting in tree shaped lstms  tai  socher   
manning        zhu  sobhani    guo      b   the question of optimal tree representation
is still very much an open research question  and the vast space of possible combination
functions r is yet to be explored  other proposed variants on tree structured rnns includes
a recursive matrix vector model  socher  huval  manning    ng        and recursive neural
tensor network  socher et al          in the first variant  each word is represented as a
combination of a vector and a matrix  where the vector defines the words static semantic
content as before  while the matrix acts as a learned operator for the word  allowing
more subtle semantic compositions than the addition and weighted averaging implied by
the concatenation followed by linear transformation function  in the second variant  words
are associated with vectors as usual  but the composition function becomes more expressive
by basing it on tensor instead of matrix operations 
    while not explored in the literature  a trivial extension would condition the transformation matrix also
on a 

   

figoldberg

     training recursive neural networks
the training procedure for a recursive neural network follows the same recipe as training
other forms of networks  define a loss  spell out the computation graph  compute gradients
using backpropagation     and train the parameters using sgd 
with regard to the loss function  similar to the sequence rnn one can associate a loss
either with the root of the tree  with any given node  or with a set of nodes  in which case
the individual nodes losses are combined  usually by summation  the loss function is based
on the labeled training data which associates a label or other quantity with different tree
nodes 
additionally  one can treat the recnn as an encoder  whereas the inside vector associated with a node is taken to be an encoding of the tree rooted at that node  the encoding
can potentially be sensitive to arbitrary properties of the structure  the vector is then
passed as input to another network 
for further discussion on recursive neural networks and their use in natural language
tasks  refer to the phd thesis of richard socher        

    conclusions
neural networks are powerful learners  providing opportunities ranging from non linear
classification to non markovian modeling of sequences and trees  we hope that this exposition helps nlp researchers to incorporate neural network models in their work and take
advantage of their power 

references
adel  h   vu  n  t     schultz  t          combination of recurrent neural networks and
factored language models for code switching language modeling  in proceedings
of the   st annual meeting of the association for computational linguistics  volume    short papers   pp          sofia  bulgaria  association for computational
linguistics 
ando  r     zhang  t       a   a high performance semi supervised learning method
for text chunking  in proceedings of the   rd annual meeting of the association for
computational linguistics  acl     pp      ann arbor  michigan  association for
computational linguistics 
ando  r  k     zhang  t       b   a framework for learning predictive structures from
multiple tasks and unlabeled data  the journal of machine learning research    
         
auli  m   galley  m   quirk  c     zweig  g          joint language and translation modeling with recurrent neural networks  in proceedings of the      conference on
empirical methods in natural language processing  pp            seattle  washington  usa  association for computational linguistics 
    before the introduction of the computation graph abstraction  the specific backpropagation procedure for
computing the gradients in a recnn as defined above was referred to as the back propagation through
structure  bpts  algorithm  goller   kuchler        

   

fia primer on neural networks for nlp

auli  m     gao  j          decoder integration and expected bleu training for recurrent
neural network language models  in proceedings of the   nd annual meeting of the
association for computational linguistics  volume    short papers   pp         
baltimore  maryland  association for computational linguistics 
ballesteros  m   dyer  c     smith  n  a          improved transition based parsing by
modeling characters instead of words with lstms  in proceedings of the      conference on empirical methods in natural language processing  pp          lisbon 
portugal  association for computational linguistics 
ballesteros  m   goldberg  y   dyer  c     smith  n  a          training with exploration
improves a greedy stack lstm parser  arxiv             cs  
bansal  m   gimpel  k     livescu  k          tailoring continuous word representations
for dependency parsing  in proceedings of the   nd annual meeting of the association
for computational linguistics  volume    short papers   pp          baltimore 
maryland  association for computational linguistics 
baydin  a  g   pearlmutter  b  a   radul  a  a     siskind  j  m          automatic
differentiation in machine learning  a survey  arxiv             cs  
bengio  y          practical recommendations for gradient based training of deep architectures  arxiv            cs  
bengio  y   ducharme  r   vincent  p     janvin  c          a neural probabilistic language model  j  mach  learn  res               
bengio  y   goodfellow  i  j     courville  a          deep learning  book in preparation
for mit press 
bitvai  z     cohn  t          non linear text regression with a deep convolutional
neural network  in proceedings of the   rd annual meeting of the association for
computational linguistics and the  th international joint conference on natural language processing  volume    short papers   pp          beijing  china  association
for computational linguistics 
botha  j  a     blunsom  p          compositional morphology for word representations
and language modelling  in proceedings of the   st international conference on
machine learning  icml   beijing  china   award for best application paper  
bottou  l          stochastic gradient descent tricks  in neural networks  tricks of the
trade  pp          springer 
charniak  e     johnson  m          coarse to fine n best parsing and maxent discriminative reranking  in proceedings of the   rd annual meeting of the association for
computational linguistics  acl     pp          ann arbor  michigan  association
for computational linguistics 
chen  d     manning  c          a fast and accurate dependency parser using neural
networks  in proceedings of the      conference on empirical methods in natural
language processing  emnlp   pp          doha  qatar  association for computational linguistics 
   

figoldberg

chen  y   xu  l   liu  k   zeng  d     zhao  j          event extraction via dynamic
multi pooling convolutional neural networks  in proceedings of the   rd annual
meeting of the association for computational linguistics and the  th international
joint conference on natural language processing  volume    long papers   pp     
     beijing  china  association for computational linguistics 
cho  k          natural language understanding with distributed representation 
arxiv             cs  stat  
cho  k   van merrienboer  b   bahdanau  d     bengio  y       a   on the properties of
neural machine translation  encoderdecoder approaches  in proceedings of ssst   eighth workshop on syntax  semantics and structure in statistical translation 
pp          doha  qatar  association for computational linguistics 
cho  k   van merrienboer  b   gulcehre  c   bahdanau  d   bougares  f   schwenk  h    
bengio  y       b   learning phrase representations using rnn encoderdecoder for
statistical machine translation  in proceedings of the      conference on empirical
methods in natural language processing  emnlp   pp            doha  qatar 
association for computational linguistics 
chrupala  g          normalizing tweets with edit scripts and recurrent neural embeddings 
in proceedings of the   nd annual meeting of the association for computational linguistics  volume    short papers   pp          baltimore  maryland  association for
computational linguistics 
chung  j   gulcehre  c   cho  k     bengio  y          empirical evaluation of gated
recurrent neural networks on sequence modeling  arxiv            cs  
collins  m          discriminative training methods for hidden markov models  theory
and experiments with perceptron algorithms  in proceedings of the      conference on empirical methods in natural language processing  pp      association for
computational linguistics 
collins  m     koo  t          discriminative reranking for natural language parsing 
computational linguistics               
collobert  r     weston  j          a unified architecture for natural language processing 
deep neural networks with multitask learning  in proceedings of the   th international
conference on machine learning  pp          acm 
collobert  r   weston  j   bottou  l   karlen  m   kavukcuoglu  k     kuksa  p         
natural language processing  almost  from scratch  the journal of machine learning
research               
crammer  k     singer  y          on the algorithmic implementation of multiclass kernelbased vector machines  the journal of machine learning research            
creutz  m     lagus  k          unsupervised models for morpheme segmentation and
morphology learning  acm trans  speech lang  process                  
cybenko  g          approximation by superpositions of a sigmoidal function  mathematics
of control  signals and systems                
   

fia primer on neural networks for nlp

dahl  g   sainath  t     hinton  g          improving deep neural networks for lvcsr
using rectified linear units and dropout  in      ieee international conference on
acoustics  speech and signal processing  icassp   pp           
dauphin  y  n   pascanu  r   gulcehre  c   cho  k   ganguli  s     bengio  y         
identifying and attacking the saddle point problem in high dimensional non convex
optimization  in ghahramani  z   welling  m   cortes  c   lawrence  n  d     weinberger  k  q   eds    advances in neural information processing systems     pp 
          curran associates  inc 
de gispert  a   iglesias  g     byrne  b          fast and accurate preordering for smt
using neural networks  in proceedings of the      conference of the north american
chapter of the association for computational linguistics  human language technologies  pp            denver  colorado  association for computational linguistics 
do  t   arti  t     others         neural conditional random fields  in international
conference on artificial intelligence and statistics  pp         
dong  l   wei  f   tan  c   tang  d   zhou  m     xu  k          adaptive recursive neural
network for target dependent twitter sentiment classification  in proceedings of
the   nd annual meeting of the association for computational linguistics  volume
   short papers   pp        baltimore  maryland  association for computational
linguistics 
dong  l   wei  f   zhou  m     xu  k          question answering over freebase with
multi column convolutional neural networks  in proceedings of the   rd annual
meeting of the association for computational linguistics and the  th international
joint conference on natural language processing  volume    long papers   pp     
     beijing  china  association for computational linguistics 
dos santos  c     gatti  m          deep convolutional neural networks for sentiment
analysis of short texts  in proceedings of coling       the   th international conference on computational linguistics  technical papers  pp        dublin  ireland 
dublin city university and association for computational linguistics 
dos santos  c   xiang  b     zhou  b          classifying relations by ranking with
convolutional neural networks  in proceedings of the   rd annual meeting of the
association for computational linguistics and the  th international joint conference on natural language processing  volume    long papers   pp          beijing 
china  association for computational linguistics 
dos santos  c     zadrozny  b          learning character level representations for partof speech tagging  in proceedings of the   st international conference on machine
learning  icml   pp           
duchi  j   hazan  e     singer  y          adaptive subgradient methods for online learning
and stochastic optimization  the journal of machine learning research          
     
duh  k   neubig  g   sudoh  k     tsukada  h          adaptation data selection using neural language models  experiments in machine translation  in proceedings
   

figoldberg

of the   st annual meeting of the association for computational linguistics  volume    short papers   pp          sofia  bulgaria  association for computational
linguistics 
durrett  g     klein  d          neural crf parsing  in proceedings of the   rd annual
meeting of the association for computational linguistics and the  th international
joint conference on natural language processing  volume    long papers   pp     
     beijing  china  association for computational linguistics 
dyer  c   ballesteros  m   ling  w   matthews  a     smith  n  a          transitionbased dependency parsing with stack long short term memory  in proceedings of
the   rd annual meeting of the association for computational linguistics and the
 th international joint conference on natural language processing  volume    long
papers   pp          beijing  china  association for computational linguistics 
elman  j  l          finding structure in time  cognitive science                 
faruqui  m     dyer  c          improving vector space word representations using multilingual correlation  in proceedings of the   th conference of the european chapter
of the association for computational linguistics  pp          gothenburg  sweden 
association for computational linguistics 
filippova  k   alfonseca  e   colmenares  c  a   kaiser  l     vinyals  o          sentence
compression by deletion with lstms  in proceedings of the      conference on
empirical methods in natural language processing  pp          lisbon  portugal 
association for computational linguistics 
forcada  m  l     neco  r  p          recursive hetero associative memories for translation 
in biological and artificial computation  from neuroscience to technology  pp     
     springer 
gao  j   pantel  p   gamon  m   he  x     deng  l          modeling interestingness with
deep neural networks  in proceedings of the      conference on empirical methods
in natural language processing  emnlp   pp       doha  qatar  association for
computational linguistics 
gimenez  j     marquez  l          svmtool  a general pos tagger generator based on
support vector machines  in proceedings of the  th lrec  lisbon  portugal 
glorot  x     bengio  y          understanding the difficulty of training deep feedforward
neural networks  in international conference on artificial intelligence and statistics 
pp         
glorot  x   bordes  a     bengio  y          deep sparse rectifier neural networks  in
international conference on artificial intelligence and statistics  pp         
goldberg  y     elhadad  m          an efficient algorithm for easy first non directional
dependency parsing  in human language technologies  the      annual conference
of the north american chapter of the association for computational linguistics  pp 
        los angeles  california  association for computational linguistics 
goldberg  y     levy  o          word vec explained  deriving mikolov et al s negativesampling word embedding method  arxiv            cs  stat  
   

fia primer on neural networks for nlp

goldberg  y     nivre  j          training deterministic parsers with non deterministic
oracles  transactions of the association for computational linguistics            
    
goldberg  y   zhao  k     huang  l          efficient implementation of beam search
incremental parsers  in proceedings of the   st annual meeting of the association for
computational linguistics  volume    short papers   pp          sofia  bulgaria 
association for computational linguistics 
goller  c     kuchler  a          learning task dependent distributed representations
by backpropagation through structure  in in proc  of the icnn     pp         
ieee 
gouws  s   bengio  y     corrado  g          bilbowa  fast bilingual distributed representations without word alignments  in proceedings of the   nd international
conference on machine learning  pp         
graves  a          supervised sequence labelling with recurrent neural networks  ph d 
thesis  technische universitat munchen 
greff  k   srivastava  r  k   koutnk  j   steunebrink  b  r     schmidhuber  j         
lstm  a search space odyssey  arxiv             cs  
hal daume iii  langford  j     marcu  d          search based structured prediction 
machine learning journal  mlj  
harris  z          distributional structure  word                  
hashimoto  k   miwa  m   tsuruoka  y     chikayama  t          simple customization
of recursive neural networks for semantic relation classification  in proceedings
of the      conference on empirical methods in natural language processing  pp 
          seattle  washington  usa  association for computational linguistics 
he  k   zhang  x   ren  s     sun  j          delving deep into rectifiers  surpassing
human level performance on imagenet classification  arxiv             cs  
henderson  m   thomson  b     young  s          deep neural network approach for the
dialog state tracking challenge  in proceedings of the sigdial      conference 
pp          metz  france  association for computational linguistics 
hermann  k  m     blunsom  p          the role of syntax in vector space models of
compositional semantics  in proceedings of the   st annual meeting of the association for computational linguistics  volume    long papers   pp          sofia 
bulgaria  association for computational linguistics 
hermann  k  m     blunsom  p          multilingual models for compositional distributed
semantics  in proceedings of the   nd annual meeting of the association for computational linguistics  volume    long papers   pp        baltimore  maryland 
association for computational linguistics 
hihi  s  e     bengio  y          hierarchical recurrent neural networks for long term
dependencies  in touretzky  d  s   mozer  m  c     hasselmo  m  e   eds    advances
in neural information processing systems    pp          mit press 
   

figoldberg

hill  f   cho  k   jean  s   devin  c     bengio  y          embedding word similarity
with neural machine translation  arxiv            cs  
hinton  g  e   srivastava  n   krizhevsky  a   sutskever  i     salakhutdinov  r  r 
        improving neural networks by preventing co adaptation of feature detectors 
arxiv            cs  
hochreiter  s     schmidhuber  j          long short term memory  neural computation 
                
hornik  k   stinchcombe  m     white  h          multilayer feedforward networks are
universal approximators  neural networks                
ioffe  s     szegedy  c          batch normalization  accelerating deep network training
by reducing internal covariate shift  arxiv             cs  
irsoy  o     cardie  c          opinion mining with deep recurrent neural networks 
in proceedings of the      conference on empirical methods in natural language
processing  emnlp   pp          doha  qatar  association for computational linguistics 
iyyer  m   boyd graber  j   claudino  l   socher  r     daume iii  h       a   a neural
network for factoid question answering over paragraphs  in proceedings of the     
conference on empirical methods in natural language processing  emnlp   pp 
        doha  qatar  association for computational linguistics 
iyyer  m   enns  p   boyd graber  j     resnik  p       b   political ideology detection
using recursive neural networks  in proceedings of the   nd annual meeting of the
association for computational linguistics  volume    long papers   pp           
baltimore  maryland  association for computational linguistics 
iyyer  m   manjunatha  v   boyd graber  j     daume iii  h          deep unordered
composition rivals syntactic methods for text classification  in proceedings of the
  rd annual meeting of the association for computational linguistics and the  th
international joint conference on natural language processing  volume    long papers   pp            beijing  china  association for computational linguistics 
johnson  r     zhang  t          effective use of word order for text categorization with
convolutional neural networks  in proceedings of the      conference of the north
american chapter of the association for computational linguistics  human language technologies  pp          denver  colorado  association for computational
linguistics 
jozefowicz  r   vinyals  o   schuster  m   shazeer  n     wu  y          exploring the
limits of language modeling  arxiv             cs  
jozefowicz  r   zaremba  w     sutskever  i          an empirical exploration of recurrent network architectures  in proceedings of the   nd international conference on
machine learning  icml      pp           
kalchbrenner  n   grefenstette  e     blunsom  p          a convolutional neural network
for modelling sentences  in proceedings of the   nd annual meeting of the association for computational linguistics  volume    long papers   pp          baltimore 
maryland  association for computational linguistics 
   

fia primer on neural networks for nlp

karpathy  a   johnson  j     li  f  f          visualizing and understanding recurrent
networks  arxiv             cs  
kim  y          convolutional neural networks for sentence classification  in proceedings of the      conference on empirical methods in natural language processing
 emnlp   pp            doha  qatar  association for computational linguistics 
kim  y   jernite  y   sontag  d     rush  a  m          character aware neural language
models  arxiv             cs  stat  
kingma  d     ba  j         
arxiv            cs  

adam  a method for stochastic optimization 

krizhevsky  a   sutskever  i     hinton  g  e          imagenet classification with deep
convolutional neural networks  in pereira  f   burges  c  j  c   bottou  l     weinberger  k  q   eds    advances in neural information processing systems     pp 
          curran associates  inc 
kudo  t     matsumoto  y          fast methods for kernel based text analysis  in
proceedings of the   st annual meeting on association for computational linguistics volume    acl     pp        stroudsburg  pa  usa  association for computational
linguistics 
lafferty  j   mccallum  a     pereira  f  c          conditional random fields  probabilistic
models for segmenting and labeling sequence data  in proceedings of icml 
le  p     zuidema  w          the inside outside recursive neural network model for
dependency parsing  in proceedings of the      conference on empirical methods in
natural language processing  emnlp   pp          doha  qatar  association for
computational linguistics 
le  p     zuidema  w          the forest convolutional network  compositional distributional semantics with a neural chart and without binarization  in proceedings
of the      conference on empirical methods in natural language processing  pp 
          lisbon  portugal  association for computational linguistics 
le  q  v   jaitly  n     hinton  g  e          a simple way to initialize recurrent networks
of rectified linear units  arxiv             cs  
lecun  y     bengio  y          convolutional networks for images  speech  and timeseries  in arbib  m  a   ed    the handbook of brain theory and neural networks 
mit press 
lecun  y   bottou  l   orr  g     muller  k       a   efficient backprop  in orr  g    
k  m   eds    neural networks  tricks of the trade  springer 
lecun  y   bottou  l   bengio  y     haffner  p       b   gradient based learning applied
to pattern recognition  proceedings of the ieee                    
lecun  y   chopra  s   hadsell  r   ranzato  m     huang  f          a tutorial on energybased learning  predicting structured data       
lecun  y     huang  f          loss functions for discriminative training of energybased
models  in proceedings of aistats  aistats 
   

figoldberg

lee  g   flowers  m     dyer  m  g          learning distributed representations of conceptual knowledge and their application to script based story processing  in connectionist
natural language processing  pp          springer 
levy  o     goldberg  y       a   dependency based word embeddings  in proceedings of
the   nd annual meeting of the association for computational linguistics  volume
   short papers   pp          baltimore  maryland  association for computational
linguistics 
levy  o     goldberg  y       b   neural word embedding as implicit matrix factorization  in ghahramani  z   welling  m   cortes  c   lawrence  n  d     weinberger 
k  q   eds    advances in neural information processing systems     pp           
curran associates  inc 
levy  o   goldberg  y     dagan  i          improving distributional similarity with
lessons learned from word embeddings  transactions of the association for computational linguistics                
lewis  m     steedman  m          improved ccg parsing with semi supervised supertagging  transactions of the association for computational linguistics                
li  j   li  r     hovy  e          recursive deep models for discourse parsing  in proceedings of the      conference on empirical methods in natural language processing
 emnlp   pp            doha  qatar  association for computational linguistics 
ling  w   dyer  c   black  a  w     trancoso  i       a   two too simple adaptations of
word vec for syntax problems  in proceedings of the      conference of the north
american chapter of the association for computational linguistics  human language technologies  pp            denver  colorado  association for computational
linguistics 
ling  w   dyer  c   black  a  w   trancoso  i   fermandez  r   amir  s   marujo  l    
luis  t       b   finding function in form  compositional character models for
open vocabulary word representation  in proceedings of the      conference on
empirical methods in natural language processing  pp            lisbon  portugal 
association for computational linguistics 
liu  y   wei  f   li  s   ji  h   zhou  m     wang  h          a dependency based neural
network for relation classification  in proceedings of the   rd annual meeting of the
association for computational linguistics and the  th international joint conference on natural language processing  volume    short papers   pp          beijing 
china  association for computational linguistics 
luong  m  t   le  q  v   sutskever  i   vinyals  o     kaiser  l          multi task sequence
to sequence learning  arxiv             cs  stat  
ma  j   zhang  y     zhu  j          tagging the web  building a robust web tagger
with neural network  in proceedings of the   nd annual meeting of the association for computational linguistics  volume    long papers   pp          baltimore 
maryland  association for computational linguistics 
ma  m   huang  l   zhou  b     xiang  b          dependency based convolutional neural
networks for sentence embedding  in proceedings of the   rd annual meeting of the
   

fia primer on neural networks for nlp

association for computational linguistics and the  th international joint conference on natural language processing  volume    short papers   pp          beijing 
china  association for computational linguistics 
mccallum  a   freitag  d     pereira  f  c          maximum entropy markov models for
information extraction and segmentation   in icml  vol      pp         
mikolov  t   chen  k   corrado  g     dean  j          efficient estimation of word
representations in vector space  arxiv            cs  
mikolov  t   joulin  a   chopra  s   mathieu  m     ranzato  m          learning longer
memory in recurrent neural networks  arxiv            cs  
mikolov  t   karafiat  m   burget  l   cernocky  j     khudanpur  s          recurrent
neural network based language model   in interspeech         th annual conference of the international speech communication association  makuhari  chiba 
japan  september              pp           
mikolov  t   kombrink  s   lukas burget  cernocky  j  h     khudanpur  s          extensions of recurrent neural network language model  in acoustics  speech and signal
processing  icassp        ieee international conference on  pp            ieee 
mikolov  t   sutskever  i   chen  k   corrado  g  s     dean  j          distributed representations of words and phrases and their compositionality  in burges  c  j  c  
bottou  l   welling  m   ghahramani  z     weinberger  k  q   eds    advances in
neural information processing systems     pp            curran associates  inc 
mikolov  t          statistical language models based on neural networks  ph d  thesis  ph 
d  thesis  brno university of technology 
mnih  a     kavukcuoglu  k          learning word embeddings efficiently with noisecontrastive estimation  in burges  c  j  c   bottou  l   welling  m   ghahramani  z  
  weinberger  k  q   eds    advances in neural information processing systems    
pp            curran associates  inc 
mrksic  n   o seaghdha  d   thomson  b   gasic  m   su  p  h   vandyke  d   wen  t  h  
  young  s          multi domain dialog state tracking using recurrent neural
networks  in proceedings of the   rd annual meeting of the association for computational linguistics and the  th international joint conference on natural language
processing  volume    short papers   pp          beijing  china  association for
computational linguistics 
neidinger  r          introduction to automatic differentiation and matlab objectoriented programming  siam review                 
nesterov  y          a method of solving a convex programming problem with convergence
rate o    k    in soviet mathematics doklady  vol      pp         
nesterov  y          introductory lectures on convex optimization  kluwer academic publishers 
nguyen  t  h     grishman  r          event detection and domain adaptation with
convolutional neural networks  in proceedings of the   rd annual meeting of the
   

figoldberg

association for computational linguistics and the  th international joint conference on natural language processing  volume    short papers   pp          beijing 
china  association for computational linguistics 
nivre  j          algorithms for deterministic incremental dependency parsing  computational linguistics                 
okasaki  c          purely functional data structures  cambridge university press  cambridge  u k   new york 
olah  c       a   calculus on computational graphs  backpropagation  retrieved from
http   colah github io posts         backprop  
olah  c       b   understanding lstm networks  retrieved from http   colah 
github io posts         understanding lstms  
pascanu  r   mikolov  t     bengio  y          on the difficulty of training recurrent
neural networks  arxiv            cs  
pei  w   ge  t     chang  b          an effective neural network model for graph based
dependency parsing  in proceedings of the   rd annual meeting of the association
for computational linguistics and the  th international joint conference on natural
language processing  volume    long papers   pp          beijing  china  association for computational linguistics 
peng  j   bo  l     xu  j          conditional neural fields  in bengio  y   schuurmans 
d   lafferty  j  d   williams  c  k  i     culotta  a   eds    advances in neural
information processing systems     pp            curran associates  inc 
pennington  j   socher  r     manning  c          glove  global vectors for word representation  in proceedings of the      conference on empirical methods in natural
language processing  emnlp   pp            doha  qatar  association for computational linguistics 
pollack  j  b          recursive distributed representations  artificial intelligence     
      
polyak  b  t          some methods of speeding up the convergence of iteration methods 
ussr computational mathematics and mathematical physics               
qian  q   tian  b   huang  m   liu  y   zhu  x     zhu  x          learning tag embeddings
and tag specific composition functions in recursive neural network  in proceedings
of the   rd annual meeting of the association for computational linguistics and the
 th international joint conference on natural language processing  volume    long
papers   pp            beijing  china  association for computational linguistics 
rong  x          word vec parameter learning explained  arxiv            cs  
rumelhart  d  e   hinton  g  e     williams  r  j          learning representations by
back propagating errors  nature                     
schuster  m     paliwal  k  k          bidirectional recurrent neural networks  ieee
transactions on signal processing                    
   

fia primer on neural networks for nlp

schwenk  h   dchelotte  d     gauvain  j  l          continuous space language models
for statistical machine translation  in proceedings of the coling acl on main
conference poster sessions  pp          association for computational linguistics 
shawe taylor  j     cristianini  n          kernel methods for pattern analysis  cambridge
university press 
smith  n  a          linguistic structure prediction  synthesis lectures on human language technologies  morgan and claypool 
socher  r          recursive deep learning for natural language processing and computer
vision  ph d  thesis  stanford university 
socher  r   bauer  j   manning  c  d     ng  a  y          parsing with compositional
vector grammars  in proceedings of the   st annual meeting of the association for
computational linguistics  volume    long papers   pp          sofia  bulgaria 
association for computational linguistics 
socher  r   huval  b   manning  c  d     ng  a  y          semantic compositionality
through recursive matrix vector spaces  in proceedings of the      joint conference
on empirical methods in natural language processing and computational natural
language learning  pp            jeju island  korea  association for computational
linguistics 
socher  r   lin  c  c  y   ng  a  y     manning  c  d          parsing natural scenes
and natural language with recursive neural networks  in getoor  l     scheffer  t 
 eds    proceedings of the   th international conference on machine learning  icml
      bellevue  washington  usa  june      july          pp          omnipress 
socher  r   manning  c     ng  a          learning continuous phrase representations
and syntactic parsing with recursive neural networks  in proceedings of the deep
learning and unsupervised feature learning workshop of  nips        pp     

socher  r   perelygin  a   wu  j   chuang  j   manning  c  d   ng  a     potts  c         
recursive deep models for semantic compositionality over a sentiment treebank 
in proceedings of the      conference on empirical methods in natural language
processing  pp            seattle  washington  usa  association for computational
linguistics 
sgaard  a     goldberg  y          deep multi task learning with low level tasks supervised
at lower layers  in proceedings of the   th annual meeting of the association for
computational linguistics  volume    short papers   pp          association for
computational linguistics 
sordoni  a   galley  m   auli  m   brockett  c   ji  y   mitchell  m   nie  j  y   gao  j  
  dolan  b          a neural network approach to context sensitive generation
of conversational responses  in proceedings of the      conference of the north
american chapter of the association for computational linguistics  human language technologies  pp          denver  colorado  association for computational
linguistics 
sundermeyer  m   alkhouli  t   wuebker  j     ney  h          translation modeling
with bidirectional recurrent neural networks  in proceedings of the      conference
   

figoldberg

on empirical methods in natural language processing  emnlp   pp        doha 
qatar  association for computational linguistics 
sundermeyer  m   schluter  r     ney  h          lstm neural networks for language
modeling   in interspeech 
sutskever  i   martens  j   dahl  g     hinton  g          on the importance of initialization
and momentum in deep learning  in proceedings of the   th international conference
on machine learning  icml      pp           
sutskever  i   martens  j     hinton  g  e          generating text with recurrent neural
networks  in proceedings of the   th international conference on machine learning
 icml      pp           
sutskever  i   vinyals  o     le  q  v  v          sequence to sequence learning with
neural networks  in ghahramani  z   welling  m   cortes  c   lawrence  n  d    
weinberger  k  q   eds    advances in neural information processing systems     pp 
          curran associates  inc 
tai  k  s   socher  r     manning  c  d          improved semantic representations from
tree structured long short term memory networks  in proceedings of the   rd annual meeting of the association for computational linguistics and the  th international joint conference on natural language processing  volume    long papers  
pp            beijing  china  association for computational linguistics 
tamura  a   watanabe  t     sumita  e          recurrent neural networks for word
alignment model  in proceedings of the   nd annual meeting of the association
for computational linguistics  volume    long papers   pp            baltimore 
maryland  association for computational linguistics 
telgarsky  m          benefits of depth in neural networks  arxiv             cs  stat  
tieleman  t     hinton  g          lecture    rmsprop  divide the gradient by a running
average of its recent magnitude  coursera  neural networks for machine learning 
van de cruys  t          a neural network approach to selectional preference acquisition  in proceedings of the      conference on empirical methods in natural language processing  emnlp   pp        doha  qatar  association for computational
linguistics 
vaswani  a   zhao  y   fossum  v     chiang  d          decoding with large scale neural language models improves translation  in proceedings of the      conference on
empirical methods in natural language processing  pp            seattle  washington  usa  association for computational linguistics 
wager  s   wang  s     liang  p  s          dropout training as adaptive regularization 
in burges  c  j  c   bottou  l   welling  m   ghahramani  z     weinberger  k  q 
 eds    advances in neural information processing systems     pp          curran
associates  inc 
wang  m     manning  c  d          effect of non linear deep architecture in sequence
labeling   in ijcnlp  pp           
   

fia primer on neural networks for nlp

wang  p   xu  j   xu  b   liu  c   zhang  h   wang  f     hao  h       a   semantic clustering and convolutional neural network for short text categorization  in proceedings
of the   rd annual meeting of the association for computational linguistics and the
 th international joint conference on natural language processing  volume    short
papers   pp          beijing  china  association for computational linguistics 
wang  x   liu  y   sun  c   wang  b     wang  x       b   predicting polarities of tweets
by composing word embeddings with long short term memory  in proceedings of
the   rd annual meeting of the association for computational linguistics and the
 th international joint conference on natural language processing  volume    long
papers   pp            beijing  china  association for computational linguistics 
watanabe  t     sumita  e          transition based neural constituent parsing  in proceedings of the   rd annual meeting of the association for computational linguistics
and the  th international joint conference on natural language processing  volume
   long papers   pp            beijing  china  association for computational linguistics 
weiss  d   alberti  c   collins  m     petrov  s          structured training for neural
network transition based parsing  in proceedings of the   rd annual meeting of the
association for computational linguistics and the  th international joint conference on natural language processing  volume    long papers   pp          beijing 
china  association for computational linguistics 
werbos  p  j          backpropagation through time  what it does and how to do it  
proceedings of the ieee                      
weston  j   bordes  a   yakhnenko  o     usunier  n          connecting language and
knowledge bases with embedding models for relation extraction  in proceedings
of the      conference on empirical methods in natural language processing  pp 
          seattle  washington  usa  association for computational linguistics 
xu  w   auli  m     clark  s          ccg supertagging with a recurrent neural network 
in proceedings of the   rd annual meeting of the association for computational linguistics and the  th international joint conference on natural language processing
 volume    short papers   pp          beijing  china  association for computational
linguistics 
yin  w     schutze  h          convolutional neural network for paraphrase identification 
in proceedings of the      conference of the north american chapter of the association for computational linguistics  human language technologies  pp         
denver  colorado  association for computational linguistics 
zaremba  w   sutskever  i     vinyals  o          recurrent neural network regularization 
arxiv            cs  
zeiler  m  d          adadelta  an adaptive learning rate method  arxiv          
 cs  
zeng  d   liu  k   lai  s   zhou  g     zhao  j          relation classification via convolutional deep neural network  in proceedings of coling       the   th international
   

figoldberg

conference on computational linguistics  technical papers  pp            dublin 
ireland  dublin city university and association for computational linguistics 
zhang  y     weiss  d          stack propagation  improved representation learning for syntax  in proceedings of the   th annual meeting of the association for computational
linguistics  volume    long papers   pp            association for computational
linguistics 
zhou  h   zhang  y   huang  s     chen  j          a neural probabilistic structuredprediction model for transition based dependency parsing  in proceedings of the
  rd annual meeting of the association for computational linguistics and the  th
international joint conference on natural language processing  volume    long papers   pp            beijing  china  association for computational linguistics 
zhu  c   qiu  x   chen  x     huang  x       a   a re ranking model for dependency
parser with recursive convolutional neural network  in proceedings of the   rd
annual meeting of the association for computational linguistics and the  th international joint conference on natural language processing  volume    long papers  
pp            beijing  china  association for computational linguistics 
zhu  x   sobhani  p     guo  h       b   long short term memory over tree structures 
arxiv             cs  

   

fi