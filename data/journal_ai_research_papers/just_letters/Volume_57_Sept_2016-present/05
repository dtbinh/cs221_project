journal artificial intelligence research                 

submitted        published      

goal probability analysis mdp probabilistic planning 
exploring enhancing state art
marcel steinmetz
jorg hoffmann

steinmetz   cs   uni   saarland   de
hoffmann   cs   uni   saarland   de

saarland university 
saarland informatics campus 
saarbrucken  germany

olivier buffet

olivier   buffet   loria   fr

inria   universite de lorraine   cnrs 
nancy  france

abstract
unavoidable dead ends common many probabilistic planning problems  e g  actions may fail operating resource constraints  important objective settings
maxprob  determining maximal probability goal reached  policy
achieving probability  yet algorithms maxprob probabilistic planning severely underexplored  extent scant evidence empirical state art actually is 
close gap comprehensive empirical analysis  design explore large space
heuristic search algorithms  systematizing known algorithms contributing several new algorithm variants  consider maxprob  well weaker objectives baptize atleastprob
 requiring achieve given goal probabilty threshold  approxprob  requiring compute
maximum goal probability given accuracy   explore general case
may   reward cycles  practically relevant special case acyclic planning 
planning limited action cost budget  design suitable termination criteria  search algorithm variants  dead end pruning methods using classical planning heuristics  node selection
strategies  design benchmark suite comprising      instances adapted
ippc  resource constrained planning  simulated penetration testing  evaluation clarifies
state art  characterizes behavior wide range heuristic search algorithms 
demonstrates significant benefits new algorithm variants 

   introduction
many probabilistic planning problems contain unavoidable dead ends  e g  kolobov  mausam 
weld    geffner        teichteil konigsbuch  vidal    infantes        kolobov  mausam    weld 
      teichteil konigsbuch         i e   policy guarantees eventually  circumstances 
attain goal  examples planning resource constraints limited budget  situations
actions may fail eventually run options  one important objective
maxprob  determining maximal probability goal reached  and identifying
policy achieving probability   maxprob partly underlies international probabilistic planning competition  ippc   younes  littman  weissman    asmuth        bryce   buffet 
      coles  coles  garca olaya  jimenez  linares lopez  sanner    yoon         planners evaluated often reach goal online policy execution   the time limit
ippc setting mixes maxprob bias towards policies reaching goal quickly 
c
    
ai access foundation  rights reserved 

fis teinmetz   h offmann   b uffet

relates proposals kolobov et al        teichteil konigsbuch        asking
cheapest policy among maximizing goal probability  proposal chatterjee 
chmelik  gupta    kanodia              asking cheapest policy ensuring target state
reached almost surely partially observable setting  
consider mdp based probabilistic planning  factored models  probabilistic extensions
strips  whose state spaces may large build explicitly  focus optimal offline
setting  i e   solving maxprob exactly  setup objective certainly relevant 
little work towards developing solvers  main effort made kolobov et al         
discuss detail below  hou  yeoh  varakantham        consider several variants
topological vi  dai  mausam  weld    goldsmith         solving maxprob necessitating
build entire reachable state space  works addressing goal probability maximization
aim guaranteeing optimality  e g  teichteil konigsbuch  kuter    infantes        camacho 
muise    mcilraith        
mdp heuristic search  barto  bradtke    singh        hansen   zilberstein        bonet
  geffner      b  mcmahan  likhachev    gordon        smith   simmons        bonet  
geffner        potential find optimal policies without building entire state space 
kolobov et al         authors addressing optimal maxprob heuristic search 
part reason lack research heuristic search maxprob following two major obstacles  first  mdp heuristic search successful expected cost minimization 
suffers lack admissible  upper bounding  heuristic estimators goal probability 
best known possibility detect dead ends set initial heuristic estimate    using
trivial upper bound   elsewhere  second  maxprob fit stochastic shortest path  ssp 
framework  bertsekas         due   reward cycles  pointed kolobov et al         
maxprob equivalent non discounted reward maximization problem  non goal cycles
receive   reward thus improper policies accumulate reward  
address second problem  kolobov et al         devised fret  find  revise  eliminate traps  framework  admits heuristic search  yet requires several iterations complete
searches  heuristic search iterations  fret eliminates   reward cycles  traps   fret iterates cycles persist  kolobov et al s contribution mainly theoretical considering maxprob much larger class generalized ssps empirical evaluation
serves merely proof concept  experiment single domain  explodingblocks  
run one configuration search  lrtdp  bonet   geffner      b   one possibility
dead end detection thus non trivial initial heuristic estimates  sixthsense  kolobov  mausam 
  weld         outperform value iteration  vi   dead end detection used
vi  remains unclear extent improvement due actual heuristic search 
rather state pruning itself 
summary  heuristic search maxprob challenging  addressed
kolobov et al          limited experiments  given this 
 i  actually empirical state art heuristic search maxprob 
known algorithms  variants thereof  work better 
explore large design space algorithms  show that  indeed  variants work
much better 
 ii  simpler yet still relevant special cases  weaker objectives  may easier
solve 
   

fig oal p robability nalysis p robabilistic p lanning

indeed practically relevant cases necessitate fret  weaker objectives
enable refer early termination 
elaborate first  ii   state space planning task hand acyclic  clearly fret
needed  cycles particular   reward cycles state space
finite  execution end  goal non goal  absorbing state  implies
within realm ssps  special case is  however  still practically relevant  illustration 
acyclic state spaces occur even standard ippc benchmarks  namely triangletireworld
domain moves made one direction  importantly  planning limited
action cost budget  limited budget planning  acyclic state spaces action costs non   
strictly decreasing remaining budget  similar class scenarios every action consumes non   amount non replenishable resource  another example recently proposed
models simulated penetration testing  per hoffmann         mdp models network
intrusion point view attacker  state space acyclic exploit
attempted  trying exploit network configuration would
yield outcome   states thus need remember remaining action set  every action
application strictly reduces set 
regarding weaker objectives  alternatives maxprob  reasonable ask whether
maximum goal probability exceeds given threshold   require computing maximum goal
probability given accuracy   refer objectives atleastprob approxprob
respectively   example  penetration testing  atleastprob naturally assesses level network security  attacker reach target host probability greater given security
margin  e g   customer data server compromised probability greater      
atleastprob approxprob allow early termination based maintaining both  lower  pessimistic  bound v l upper  admissible optimistic  bound v u   especially promising
atleastprob  terminate lower bound already good enough  v l   
upper bound already proves infeasibility  v u      good anytime behavior  either
bounds  translates early termination 
let us elaborate  i   exploring state art beyond  design algorithm
space characterized by 
 a  search algorithm  design variants ao  nilsson         lrtdp  bonet   geffner 
    b   depth first oriented heuristic searches  bonet   geffner      a         maintaining
upper lower bounds early termination 
 b  fret  design new variant fret better suited problems uninformative initial
upper bounds 
 c  bisimulation reduction  design new probabilistic state space reduction method  via bisimulation relative all outcomes determinization  e g  bonet   geffner      b  yoon  fern 
  givan        little   thiebaux        
   atleastprob relates mdp model checking  one typically wants validate given pctl  probabilistic
computation tree logic  formula valid probability  baier  groer  leucker  bollig    ciesinski       
kwiatkowska  parker    qu      a  kwiatkowska  norman    parker      b   relates constrained mdps
 altman         enforcing minimum success probability could expressed constraint particular
quantity  chance constrained pomdps  santana  thibaux    williams        different atleastprob
constraint probability remain safe states  reach goal states 

   

fis teinmetz   h offmann   b uffet

 d  dead end pruning method  employ classical planning heuristic functions dead end detection probabilistic planning  via all outcomes determinization  previously done
teichteil konigsbuch et al          especially promising limited budget planning 
prune state admissible classical planning estimate exceeds remaining
budget s 
 e  node selection strategy  design comprehensive arsenal simple strategies  biasing tie
breaking action state selection manners targeted fostering early termination 
implemented techniques within fast downward  fd   helmert         thus contributing  side effect work  ideal implementation basis exploiting classical planning
heuristic search techniques mdp heuristic search  
algorithm dimensions  a   e  orthogonal  excepting dependencies  particular
bisimulation reduction subsumes dead end pruning   explore behavior resulting
design space large benchmark suite design purpose  suite includes domains
ippc  resource constrained planning  penetration testing  limitedbudget version unlimited budget version  suite comprises      benchmark instances
total   amongst things  observe 
heuristic search yields substantial benefits  even trivial admissible heuristic setting
initial estimate   everywhere      total coverage across benchmarks  
admissible heuristics based dead end detection        
early termination yields substantial benefits  e g  atleastprob          
           
fret variant yields dramatic benefits       total coverage cyclic benchmarks  
bisimulation reduction yields optimal maxprob solver excells triangletireworld 
even surpassing prob prp  muise  mcilraith    beck        camacho et al        
standard version goal achieved certainty hence
prob prp optimal  limited budget version so 
side  discover landmarks compilation per domshlak mirkis         employed
dead end pruning oversubscription planning setting  actually  own  equivalent
pruning remaining budget standard admissible landmark heuristic 
relevant work because  otherwise  compilation would canonical candidate
dead end pruning setting  indeed started investigation  
paper organized follows  section   describes model syntax semantics  goal
probability analysis without action cost budget limit  section   specifies search
algorithm  a  fret variants  b   section   describes bisimulation reduction method  c  
section   describes dead end pruning methods  d   section   describes node selection
strategies  e   present experiments section    conclude section   
two appendices giving additional technical details sketch main text  appendix b
   source code available http   fai cs uni saarland de downloads fd prob tar bz 
  
benchmark
suite

available

http   fai cs uni saarland de downloads 
ppddl benchmarks acyclic tar bz   acyclic cases  http   fai cs uni saarland 
de downloads ppddl benchmarks cyclic tar bz   cyclic cases  

   

fig oal p robability nalysis p robabilistic p lanning

regarding domshlak mirkis        landmarks compilation  appendix regarding depthfirst oriented heuristic searches   

   mdp models
consider ppddl style models  younes et al          precisely probabilistic extensions
strips  employ two formalism variants  without limited action cost budget 
specify first unlimited budget version  planning tasks tuples    f  a  i  g  consisting
finite set f facts  finite set actions  initial state f   goal g f  
pair  pre a   o a   pre a  f precondition  o a  finite set
outcomes o  o a  tuple  p o   add  o   del  o  
p outcome probability p o   add list
add  o  f   delete list del  o  f   require oo a  p o      
given task   state space probabilistic transition system  s  p  i  s     here 
set states  associated set f  s  true facts  initial state  
set goal states s  contains g f  s   transitions  transition
probability function p             defined follows  action applicable state
pre a  f  s    s   goal states absorbing  see below   a s  denote
set actions applicable s  given s  a s   outcome o a   sjok denote
result outcome s  i e   f  sjok      f  s  add  o     del  o   define p  s  a  t     p o 
applicable   sjok   otherwise  define p  s  a  t        there transition  
absorbing states outgoing transitions  no applicable actions   set non goal
absorbing states lost states denoted  
limited budget planning  extend follows  limited budget task tuple
   f  a  i  g  b   including budget b r 
    associating
 

addition


true
facts
f
 s  
states
action outcome cost c o  r 
 
associated remaining budget b s  r  states negative remaining budget b s     
legal may occur  lost    due following definitions goal states 
action applicability  transitions  goal states s  g f  s 
b s     i e   must reach goal   remaining budget  actions applicable
pre a  f  s  least one outcome fits within remaining budget  i e  
exists o a  c o  b s   outcome states sjok  outcomes cost deduced
remaining budget  i e   b sjok     b s  c o  
notes order regarding limited budget planning  c o      o  state
space viewed directed graph arc  s  t  whenever action mapping
non   probability acyclic every transition strictly reduces remaining budget 
state space infinite due continuous state variable b s   reachable part  which
algorithms consider  finite  note remaining budget local state 
states policy violate budget  parts policy  even outcomes
action  still continue trying reach goal  differs constrained mdps  altman 
       budget bound applied globally expected cost policy  note
   paper extension previous conference paper  steinmetz  hoffmann    buffet         cover larger
space algorithms  now including depth first oriented heuristic searches   provide comprehensive explanations
discussions  present experiments detail 
   assume o a  leads different outcome state  simplify notation  our
implementation make assumption  

   

fis teinmetz   h offmann   b uffet

that  single budget considered sake simplicity  framework results
straightforwardly extend models multiple budget variables 
limited budget planning explored deterministic oversubscription setting  objective maximize reward achieved  soft  goals subject budget  domshlak
  mirkis         classical planning variant would relate resource constrained planning  e g 
haslum   geffner        nakhost  hoffmann    muller        coles  coles  fox    long       
single consumed resource  probabilistic variant previously considered
hou et al          prior work probabilistic planning resources  e g  marecki  
tambe        meuleau  benazera  brafman  hansen    mausam        coles        often
assumed limited budgets non   consumption  dealt uncertain continuous resource
consumption  contrast discrete fixed budget consumed action costs 
though relatively restricted  limited budget probabilistic planning quite natural  decision
making often constrained finite budget  furthermore  non   costs often reasonable
assume  applies to  example  penetration testing  problems asking achieve goal within
given number steps  e g  finite horizon goal probability maximization  special case 
let us define solutions planning tasks  well objectives wish
achieve  policy partial function      s          mapping non absorbing
state within domain either action applicable s  dont care symbol  
symbol used  only  policies already achieve sufficient goal probability elsewhere 
need elaborate act descendants  is  still require closed
policies  see below   use explicitly indicate special cases actions may chosen
arbitrarily  formally   s    extends domain picking  every   s  reachable
 t  undefined  arbitrary action applicable setting  t     a 
policy closed state if  every state   s  reachable    t 
defined  closed closed initial state i  proper if  every state
defined  eventually reaches absorbing state probability    
following kolobov et al          formulate goal probability maximal non discounted
expected reward reaching goal gives reward   rewards    value
v  s  policy closed state is 

s 
 

v  s     p
   


p  s   s   t v  t  otherwise
optimal value state
v  s   

max

  closed

v  s 

   

observe that  difference kolobov et al  consider problems general maxprob  dont need exclude improper maximization 
negative rewards  i e   policies cannot gain anything infinite cycles 
given value function v  any function mapping states r   bellman update operator
defined  usual  maximization actions relative current values given v  
   keep mind absorbing states setting s    i e   goal states lost states  ssp
policy considered valid executions end goal state finding shortest path
implies path exists maxprob policy valid executions end absorbing  goal non goal 
state executions may fail  need always terminate 

   

fig oal p robability nalysis p robabilistic p lanning


s 
 

v  s      
p

maxaa s  p  s  a  t v  t  otherwise

   

difference v  s  prior update  updated value according right hand
side  called bellman residual 
greedy policy value function v selects non absorbing state action obtaining maximum right hand side equation  note greedy policy unique
tie breaking   refer state space subgraph induced states reachable
using greedy policy  greedy graph  v  greedy graph  refer
state space subgraph induced states reachable greedy policy v   i e  
allowing state choose action greedy v  
acyclic state spaces  every run ends absorbing state finite number steps 
facing ssp problem  subject definition absorbing states  cf  above 
bellman update operator unique fixed point v   converges initial v  
cyclic state spaces  pointed kolobov et al          bellman update operator may
multiple sub optimal fixed points  updates optimistic  upper bound  initialization
v guaranteed converge optimum v   one either use pessimistic  lowerbound  initialization v   updates guaranteed converge v   one use
kolobov et al s fret method described earlier 
consider three different objectives  algorithmic problems  goal probability analysis 
maxprob  find optimal policy  i e   closed s t  v  i    v  i  
atleastprob  find policy guaranteeing user defined goal probability threshold         i e  
closed s t  v  i     or prove exist  
approxprob  find policy optimal user defined goal probability accuracy         i e  
closed s t  v  i  v  i   
define algorithm family addressing problems  cover search algorithms  bisimulation reduction  dead end pruning  node selection strategies  order 

   search algorithms
use value iteration  vi  baseline  design variants ao lrtdp  well family
depth first oriented heuristic searches  systematizing algorithm parameters underlying improved
lao  here  ilao    hansen   zilberstein         heuristic dynamic programming  bonet  
geffner      a   learning depth first search  bonet   geffner         furthermore design
variant fret better suited problems uninformative initial upper bounds 
    vi
pre process vi  make one forward pass building reachable state space  actually
pruned subgraph  see section     initialize value function pessimistically  simply  
everywhere  acyclic cases  perform single backward pass bellman updates  starting
absorbing states updating children parents  thus computing optimal value function
updating every state exactly once 
   

fis teinmetz   h offmann   b uffet

procedure goalprob ao
initialize consist i  initialize i 
loop
 maxprob  v l  i      
 atleastprob v l  i   
 approxprob  v l  i    v u  i  v l  i   
return l endif    early termination  positive    
 atleastprob  v u  i     
return impossible endif    early termination  negative    
ex  leaf state   s  reachable using u
select state
else return u endif    regular termination   
p  s  a  t     
already contained
insert child   initialize t 
else insert new parent
endif
endfor
backwardsupdate s 
endloop
procedure
initialize s  
 
u
v  s    
  otherwise
  s 
l
v  s    
  otherwise
  s  l  s     endif

figure    ao  search maxprob  atleastprob  approxprob  as indicated   acyclic state
spaces  u current greedy policy v u   l current greedy policy v l  
backwardsupdate s  procedure updates v u   u   v l   l   states may
several parents   first make backwards sweep collect sub graph  s ending
 to update v u u   greedy sub graph v u suffices   update  s
reverse topological order 
general cyclic case  assume convergence parameter  likewise algorithms addressing case   compute  consistent value function  bellman
residual every state   efficient value iteration  employ topological vi per
dai et al          find strongly connected components  scc  state space  handle
scc individually  children sccs parent sccs  vi scc stops every state
 consistent 
dai et al         introduce focused topological vi  eliminates sub optimal actions
pre process obtain smaller sccs  much runtime effective  still
requires building entire state space  experiments  runtime memory exhaustion
process  i e   building state space  reason vi failures 
consider focused topological vi here 
    ao
ao   restrict acyclic case  overhead repeated value iteration
fixed points  inherent lao  hansen   zilberstein         disappears   the ilao variant 
   

fig oal p robability nalysis p robabilistic p lanning

issue addressed depth first orientation  covered part
depth first oriented heuristic search family introduced section     below  
figure   shows pseudo code goalprob ao variant  algorithm incrementally constructs subgraph state space  handling duplicates simple  identifying search
nodes states  state space acyclic  reason  simple backward updating
suffices maintain value function  adopting ideas prior work  e g  mcmahan et al        
little  aberdeen    thiebaux        smith   simmons        kuter   hu         maintain
two value functions  namely upper bound v u lower bound v l goal probability 
lack heuristic estimators goal probability  value functions initialized trivially 
  v u   v l   except absorbing states exact value known   dead end
detection  simple non trivial v u initialization  discussed section     nevertheless 
bounds useful search  early termination  v l v u    detecting
sub optimal parts state space  v u    observe latter  note that  refute action a 
may suffice reduce v u one outcomes  hence  even trivial initialization  v u
may allow disregard parts search space  usual way admissible heuristic functions 
shall see  kind behavior occurs frequently practice  as reflected benchmarks  
regarding early termination  lower bound enables positive early termination
already guarantee sufficient goal probability  namely    maxprob    atleastprob      approxprob   upper bound enables negative early termination atleastprob  v u  i     
approxprob  clearly terminate v u  i  v l  i    relevant observation
v l  i       maxprob  v l  i     approxprob  criteria redundant
maintaining upper bound  i e   heuristic search  v l  i      trivially
v u  i  v l  i    v l  i       search branch achieving goal certainty 
v u  i      well search terminates regularly  configurations maintaining v u  
however  criteria useful reduce search 
correctness goalprob ao easy establish  standard properties bellman
updates  point time execution algorithm  state  
v l  s  v  s  v u  s   i e   v l v u lower respectively upper bounds goal
probability  indeed  bounds monotone  bertsekas   tsitsiklis 
       precisely  v l
p
u
l
v exact absorbing states  satisfy v  s  maxaa s  p  s  a  t v l  t  respectively
p
v u  s  maxaa s  p  s  a  t v u  t  non absorbing ones  v l v u
initialized functions trivially satisfying properties  properties invariant
bellman updates non absorbing states  given monotonicity  v l grow  v u
decrease   thanks monotonicity  arguments given lao  hansen  
zilberstein         get v u converges v finite time u  greedy graph 
finally  need prove that  case early termination returning l   greedy policy l
v l actually achieves want  i e       l closed     l provides sufficient goal
l
probability  i e   v  i  v l  i        l always closed policy  applies
dont care symbol non absorbing leaf states    note applied l
l
states        show that  states s  v  s  v l  s  
claim trivial states l  s      never updated v l  s      
states s  claim follows simple inductive reasoning maximal distance
l
absorbing state l  greedy graph  absorbing states s  v  s    v l  s    v  s  
p
l
l
claim trivially satisfied  induction step  v  s    p  s  l  s   t v  t 
l
l
definition v   while  induction hypothesis  v  t  v l  t  states
   

fis teinmetz   h offmann   b uffet

procedure goalprob lrtdp
    i   initialize i 
loop
 early termination criteria exactly goalprob ao  
labeled solved
lrtdp trial i 
else return u endif    regular termination   
endloop
procedure lrtdp trial s  
p    empty stack
labeled solved
push onto p
s  break endif
 cyclic   consistent break endif 
p  s  a  t     
  initialize t  endif
endfor
update v u  s   u  s   v l  s   l  s 
   sample according p  s  u  s   t 
endwhile
p empty
pop p
 acyclic  checksolved s     break endif 
 cyclic  checksolved s    break endif 
endwhile

figure    lrtdp maxprob  atleastprob  approxprob  acyclic general  cyclic  state
spaces  u current greedy policy v u   l current greedy policy v l  
checksolved s    procedure exactly specified bonet geffner      b  
visits states reachable using u   initializing previously visited  stopping
 consistent  performs updates bottom up  labeling solved iff
descendants  consistent  change update v l l along v u
u  
p
l
p  s  l  s   t       words v  s  p  s  l  s   t v l  t   plugging
definition l  s   using monotonicity property  easy conclude
l
v  s  v l  s   desired 
    lrtdp
figure   shows pseudo code goalprob lrtdp variant  applicable general case  cyclic
well acyclic problems   assume that  cyclic cases  algorithm run within fret
framework  main change original version lrtdp consists maintaining lower
bound addition upper  optimistic  bound  adding early termination criteria
goalprob ao   correctness early termination follows arguments before  i e  
v l  s  v u  s  monotone lower respectively upper bounds  l always closed policy 
note true even general cyclic case  i e   early termination applies 
terminate overall fret process 
change make additional stopping criterion trials cyclic case 
namely current state  consistent  kolobov et al         use criterion keep trials
   

fig oal p robability nalysis p robabilistic p lanning

procedure goalprob dfhs
    i 
loop
 early termination criteria exactly goalprob ao  
 label labeled solved 
 vi u changed running vi u  greedy graph 
dfhs exploration i 
clean visited markers
else return u endif    regular termination   
endloop
procedure dfhs exploration s  
  initialize s  endif
s  labeled solved
label solved
return
endif
f lag   
fw
v u  s   consistent f lag      endif
update v u  s   u  s   v l  s   l  s 
consist f lag return   endif
endif
mark visited
foreach p  s  u  s   t     
visited f lag    dfhs exploration t  f lag endif
done
f lag fw
v u  s   consistent f lag      endif
update v u  s   u  s   v l  s   l  s 
endif
label f lag label solved endif
return f lag

figure    depth first heuristic search  dfhs  acyclic maxprob  atleastprob  approxprob  cyclic version shown appendix uses tarjans scc procedure
instead depth first search  vi  label  fw  consist boolean algorithm parameters  see text   recall u  greedy graph set states reachable using
current greedy policy u   f lag returned dfhs exploration used inside
recursion  it ignored top level calls   decide whether backward update
state forward updates use 

getting trapped   reward  non goal  cycles  criterion preserves property that  upon
regular termination  states reachable using u  consistent  

cyclic case  v u fixed point found lrtdp may sub optimal  use
fret  acyclic case  use      single call lrtdp suffices 
   

fis teinmetz   h offmann   b uffet

    depth first heuristic search
finally consider systematic heuristic searches  not based trials lrtdp  strong
depth first orientation  intuitively  orientation especially beneficial context
likely lead absorbing states  thus states non trivial heuristic function initialization 
quickly  refer algorithms depth first heuristic search  dfhs   known instances
ilao  hansen   zilberstein          heuristic dynamic programming  hdp   bonet   geffner 
    a   learning depth first search  ldfs   bonet   geffner         commonality lies
conducting depth first searches  dfs  state space subgraph defined actions greedy
current upper bound v u   updated backwards dfs  termination criterion applies  algorithms differ depth first branches terminated  overall algorithm
terminated  whether updates performed forward direction  here  systematize parameters  obtaining dfhs algorithm family containing previous algorithms
family members 
figure   gives pseudo code description dfhs algorithm family  simplicity 
figure considers acyclic problems only  cyclic problems  instead dfs algorithms use
tarjans depth first scc algorithm  tarjan         order detect sccs time
exploration updates  suggested bonet geffner      a    knowing
sccs required correct solved labeling general case   pseudo code description
dfhs algorithm family general  cyclic  case given appendix a 
algorithms search u  greedy graph  variant would instead search v u greedy graph  variant  employed ldfs  effective goal probability analysis
v u   everywhere initially  v u  greedy graph entire  dead end pruned  reachable
state space  hence omit option  therewith ldfs  dfhs family  matters may
change better admissible heuristic functions identified future work  cf  section    
algorithms update values backward direction  leaving state  fw algorithm
parameter true  value updates done forward direction  entering state 
consistently yields  small  advantages empirically  switch fw true algorithm
configurations  except one corresponding known algorithm ilao use
technique  detecting whether optimal solution found done two ways     
label  maintaining solved labels dfs      vi  running value iteration u greedy graph dfs terminated       u optimal initial state labeled solved 
     one terminate greedy policy change vi  use forward updates 
 as already check bellman residual anyway  additional option consist
stop search  inconsistent states  opposed stopping absorbing states  overall 
run   different parameter settings dfhs  overviewed table   
correctness early termination follows arguments before 
correctness regular termination  need show fixed point policy obtained  i e   upon
regular termination      u  greedy graph contains  inconsistent states  holds
algorithm variants fit bonet geffners      a  find and revise schema finite state
space monotone optimistic bound      search iteration find update
   updates trials are  difference original lrtdp formulation  related trial stopping guarantee
goal probability maximization  turn consistently yield  small  advantages empirically  keep
here 
   brief description ilao hansen zilberstein        thus depth first orientation subject
interpretation  design follows bonet geffner        mgpt tool 

   

fig oal p robability nalysis p robabilistic p lanning

acronym
dfhsvi
dfhsfwd
vi
dfhsfwdcons
vi
dfhsfwd
lab
dfhsfwdcons
lab

termination
vi
vi
vi
label
label

fw 

yes
yes
yes
yes

cons 


yes

yes

known 
yes  ilao  hansen   zilberstein       
no  new variant
no  new variant
no  new variant
yes  hdp  bonet   geffner      a 


table    depth first heuristic search  dfhs  family overview  include ldfs  bonet
  geffner        as  due considering v u  greedy graph rather u  greedy
graph  ldfs work well maxprob  see text  
least one  inconsistent state      condition     met  given depth first search  respectively
tarjans algorithm  general case  clear     holds true  regarding      obvious
vi termination option used   holds label termination option state
labeled solved descendant states u  greedy graph  consistent 
done table    usually omit goalprob  algorithm names  keep mind
though algorithms differ original ones  particular terms early termination
depends objective maxprob  atleastprob  approxprob  study termination
benefits lower vs  upper bound  switch bound individually 
x denotes one search algorithms  denote x u x l variants x maintaining
v u respectively v l   sometimes write x lu make explicit bounds
used  early termination criteria involving non maintained bound disabled  x u  
leaves negative criterion v u  i    atleastprob  x l still positive criteria 
test version x l x ao   canonical representative  non vi  blind search 
ao  l   non absorbing leaf states open  rather reachable using u   
case regular termination return l  
    fret
previously hinted  kolobov et al s        fret performs iteration complete searches 
starts upper bound approximation v u v   continuously updated throughout
fret process  within fret iteration  heuristic search algorithm runs termination 
i e   finding fixed point policy  iterations  fret runs trap elimination
step  finds traps v u  greedy graph  fret forces next search iteration
include traps  fret terminates v u  greedy graph contain trap 
trap elimination step works follows  trap subset non absorbing states
greedy policy remain indefinitely  i e   outgoing transitions v u  greedy
graph lead another trap state   trap removed collapsing states
single state st   incoming transitions st incoming state  
outgoing transitions transitions  states exiting  note transitions are 
construction  contained v u  greedy graph  
transformation obviously prevents occuring later iterations  preserves

v trap states identical v values  trap states non absorbing reach
other  states reach   reward transitions  note holds regardless
   note that  acyclic case  full vi actually needed algorithm could simplified  leave way
here  used ilao general case  simplicity presentation 

   

fis teinmetz   h offmann   b uffet

v u   i e   holds parts state space v u yet converged  
finite number possible traps state space  fret eventually finds v u whose v u greedy graph contain trap  graph  v u  greedy policy extracted 
contain traps  hence proper trap collapsed state space  hence optimal
state space  optimal policy original task constructed acting  within
collapsed traps  way exit taken eventually reached certainty   this
correctness argument given kolobov        
new variant fret differs original version terms state space
subgraph considered  instead v u  greedy graph  use u  greedy graph  i e   consider
actions selected current greedy policy  cf  discussion dfhs above  
refer design fret  u   refer kolobov et al s        design fret v u  
easy see fret  u still correct  arguments remain intact stated 
fret v u potentially eliminates traps iteration  may hence require fewer iterations  yet traps may actually need eliminated  we might eventually find optimal
policy entering them   trap elimination step may much costly  particular 
goal probability analysis  fret v u typically ineffective because  similarly discussed
dfhs  first fret step v u often   almost everywhere  v u  greedy graph
almost entire reachable state space  shall see  fret  u clearly outperforms fret v u  

   state space reduction via determinized bisimulation
bisimulation known method reduce state space size mdps probabilistic planning  e g 
dean   givan         idea essentially group equivalent sets states together block
states  solve smaller mdp block states  here  observe approach fruitfully combined state of the art classical planning techniques  namely mergeand shrink heuristics  drager  finkbeiner    podelski        helmert  haslum  hoffmann    nissim         allow effectively compute bisimulation determinized state space 
determinized bisimilar states bisimilar probabilistic state space well  identifies practical special case probabilistic bisimulation given factored  strips like  problem
specification 
let us spell little detail  given task  with without budget limit  
probabilistic bisimulation partitioning p    b            bn   state set that 
every bi bj   every action a  every s  bi   following two properties satisfied
 dean   givan        
 i  applicable iff applicable t 
p
p
 ii  applicable t  oo a  sjokbj p o    oo a  tjokbj p o  
dean givan show optimal solution bisimulation mdp induces optimal
solution mdp itself  words  suffices work block states bi  
now  denote det all outcomes determinization  e g  yoon et al         little
  thiebaux         separate action adet
every o a   inheriting preo
condition os adds  deletes  cost  determinized bisimulation partitioning
p    b            bn   states that  every bi bj   every determinized action adet
 
every s  bi   following two properties satisfied  milner        helmert et al         
det
 a  adet
applicable iff ao applicable t 

   

fig oal p robability nalysis p robabilistic p lanning

det
det
 b  adet
applicable t  sjao k bj iff tjao k bj  

easy see  b            bn   probabilistic bisimulation   since action
adet
applicable state iff corresponding action original mdp applicable s 
 a  directly implies  i    b   know every action applicable s  t 
det
outcome o a   sjadet
k bj iff tjao k bj   obviously implies  ii  
restrictive needed insists subset outcomes sides  rather
summed up probability same 
compute determinized bisimulation   nave solution build state
space front computing determinized bisimulation it  one potentially much
better though  using merge and shrink widely employed shrinking strategies based
bisimulation  nissim  hoffmann    helmert        katz  hoffmann    helmert        helmert
et al          nutshell  algorithm framework constructs abstraction starting
collection abstractions considering single state variable only  iteratively merging
two abstractions  replacing synchronized product  single abstraction
left  shrinking abstractions bisimulation thereof every merging step 
shall see experiments  often still incurs prohibitive overhead  feasible 
lead substantial state space size reductions  cases  results tremendous performance
improvements 

   dead end pruning
refer states v  s       i e   goal cannot reached s  dead ends 
one detects via dead end detection technique  one treat exactly lost
state  except setting l  s     need act non absorbing states   constitutes
pruning method itself  useful search algorithm  state space needs
longer explored  apart pruning itself  heuristic search algorithms  dead end
detection provides non trivial initialization v u   initialize v u  s      instead
v u  s      detected dead end  informed initial upper bound typically
leads additional search reductions 
detect dead ends  kolobov et al         employ sixthsense  kolobov et al         
learns dead end detection rules generalizing information obtained using classical planner  instead exploit power classical planning heuristic functions readily
available fd implementation framework run all outcomes determinization 
especially promising limited budget planning  use lower bounds determinized
remaining cost detect states insufficient remaining budget  observe natural
effective using admissible remaining cost estimators  yet would impractical using actual classical planner  which would need optimal thus prohibitively slow   unlimited budget
case  use heuristic function able detect dead ends  returning    applies
known heuristics  indeed  merge and shrink heuristics recently shown extremely competitive dead end detectors  hoffmann  kissmann    torralba        
make concrete  consider state task   denote det alloutcomes determinization   let h classical planning heuristic function  h guarantees
return dead ends  h s    det   exists sequence action
outcomes achieving goal s  v  s       limited budget task  h admissible 
h s    b s   cannot achieve goal within budget  thus v  s      
   

fis teinmetz   h offmann   b uffet

experiment state of the art heuristic functions  namely  a  admissible landmark
heuristic per karpas domshlak          b  lm cut  helmert   domshlak          c  several
variants merge and shrink heuristics   d  hmax  bonet   geffner        simple
canonical option   a  turned perform consistently worse  b   report
 b   d  
limited budget planning  considered adopting problem reformulation domshlak mirkis        oversubscription planning  reduces budget b using landmarks
exchange allows traversing yet unused landmarks reduced cost search  turns
out  however  pruning states whose reformulated budget     equivalent much simpler method pruning states whose heuristic  a  exceeds  original not reformulated  remaining
budget  added value domshlak mirkis reformulation thus lies  pruning per se 
compilation planning language resulting combinability heuristics 
give full details appendix b  get intuition domshlak mirkis reformulation
is  per se  equivalent  a   assume simplicity l set disjoint disjunctive action landmarks initial state  assume actions unit costs  say prune reduced budget  b   s        reduced initial budget b     b l   reduced costs allow applying member actions yet non used landmarks   cost  non used landmarks given search
path l l touched path  consider state reached path  a  denote
non used landmarks l    cost saved  a thanks reformulation exactly
used landmarks   l l     hence b   s    b     a  l l        b l    a   l l      b  a  l    
pruned reformulation  b   s       iff b   a   l        iff b   a     l     latter
condition  however  exactly pruning condition using simple method  a  instead 

   node selection strategies
algorithms  good anytime behavior v l and or v u may translate early termination 
explore potential fostering via     biasing tie breaking selection best
actions u greedy respect v u       biasing  respectively  outcome state sampling
trials  lrtdp  choice expanded leaf states  ao    precise regarding
latter  usual  maintain state open flags ao   true state open descendants within
u  greedy graph  select leaf state expand going forward using u  
action one open outcome state t  select best according bias      note
    relevant dfhs  every iteration dfs explores outcomes anyhow 
hence  dfhs  use u tie breaking criteria     explained follows 
experimented variety strategies  follows  strategy specifies one
        only  setting default strategy  strategy corresponds
commonly used settings  uses arbitrary tie breaking      fixed manner  changing
u  s  action becomes strictly better s  suggested bonet geffner
     b  lrtdp  bias     outcome states ao  an open outcome state selected
arbitrarily   bias     lrtdp outcome probability  tried most prob outcome
bias strategy ao   likely open outcome state selected 
h bias strategy prefers states smaller h value  heuristic h one
used dead end pruning    specifically  action selection tie breaking      actions
    experimented strategy using merge and shrink determinized action costs set negated
logarithm outcome probability  compare e g  jimenez  coles    smith         compelling theory

   

fig oal p robability nalysis p robabilistic p lanning

p
u
maximizing optimistic expected
pgoal probability p  s  a  t v  t   select minimizing expected heuristic value p  s  a  t h t   outcome state bias     obtained
 
renormalizing weighed probabilities h t 
p  s  a  t   prefer high probability outcomes
small h value 
inspired brtdp  mcmahan et al          experiment gap bias strategy  biasing
u
l
search towards states large
precisely      break ties favor actions
pv v gaps 
maximizing expected gap p  s  a  t  v u  t v l  t        renormalize weighed
probabilities  v u  t  v l  t   p  s  a  t  
inspired common methods classical planning  e g  hoffmann   nebel        helmert 
      richter   helmert         experiment preferred actions strategy     
u  s  action participating delete relaxed determinized plan s 
prefers set p
maximizing p  s  a  t v u  t  exists 
ao  l special case  maintain upper bound thus selection
    actions u greedy respect v u   apply node selection strategies     directly
set  all  leaf states current search graph   default strategy depth first 
rationale try reach absorbing states quickly  h bias strategy selects deepest leaf
minimal h value  preferred actions strategy selects deepest open leaf reachable using
preferred actions  furthermore experiment breadth first strategy  comparison 

   experiments
implemented algorithms fast downward  fd   helmert         ran experiments
extensive suite benchmarks    evaluation first summarize results acyclic
benchmarks  where fret needed   ones cyclic benchmarks  where fret
needed  
    experiments setup
start giving details implementation describing benchmark suite used
experiments 
      mplementation
model pertains goal directed mdps limited number  explicitly listed  outcomes
per action  naturally use ppddl  younes et al          rather rddl  sanner        coles
et al          surface level language  fds pre processes extended handle ppddl 
added support specifying  numeric  budget limit 
given fd implementation framework contrast previous works optimal probabilistic
planning  implemented algorithms scratch  fret  closely followed original
implementation  details specified kolobov et al          based personal communication andrey kolobov   kolobovs original source code available anymore 
plays role state of the art comparison  see next  
because  then  bisimulation based heuristic corresponds exact goal probability best outcome sequence
state  yet  already pointed out  computing heuristic often infeasible 
    source code available online appendix  downloaded http   fai cs unisaarland de downloads fd prob tar bz 

   

fis teinmetz   h offmann   b uffet

given scant prior work optimal goal probability analysis  cf  section     state art
represented topological vi  lrtdp u dead end pruning acyclic problems 
fret v u using lrtdp u dead end pruning cyclic problems  configurations
particular points space configurations explore  comparison state art
part comparison across configurations  thing missing particular form
dead end detection  sixthsense prior work  kolobov et al         
sixthsense complex method advanced dead end pruning via heuristic functions readily
available framework  re implement sixthsense  discussion cyclic problems
section     includes detailed comparison results kolobov et al  
ippc explodingblocks domain kolobov et al  considered 
note providing quality guarantees important property study  reason 
sake clarity  compare unbounded suboptimal approaches 
using algorithm discounted criterion assigning large finite penalties dead ends
 teichteil konigsbuch et al         kolobov et al         
furthermore  atleastprob special case mdp model checking  one may wonder
probabilistic model checking tools  e g  prism  kwiatkowska et al       b   would fare
problem planning benchmarks  investigate question here  would entail
translation ppddl model checking language  non trivial makes direct
comparison algorithms taking different inputs problematic  one may speculate that  given
focus blind searches  model checking tools inferior heuristic search approaches
fare well  remains question future work 
      b enchmark uite
aim comprehensively explore relevant problem space  designed broad suite
benchmarks       instances total  based domains ippc  resource constrained
planning  penetration testing  pentesting  
ippc  selected pddl domains strips format  moderate nonstrips constructs easily compilable strips  resulted    domains ippc  
ippc    selected recent benchmark suite these 
resource constrained planning  adopted nomystery  rovers  tpp benchmarks
nakhost et al          precisely suites single consumed resource  fuel  energy  money   correspond limited budget planning    created probabilistic versions
adding uncertainty underlying road map  akin canadian traveler scenario 
road segment present given probability  this encoded separate  probabilistic  action attempting segment first time   simplicity  set probability    
throughout 
pentesting  general objective using exploits compromise computers network  one another  specific targets reached  or action available   modified
pomdp generator sarraute  buffet  hoffmann         based test scenario used core security  http   www coresecurity com   output ppddl encodings
hoffmanns        attack asset mdp pentesting models  models  network configura    make benchmarks feasible optimal probabilistic planning  reduce size parameters  number
locations etc   scaled parameters number      chosen get instances borderline
feasibility vi 

   

fig oal p robability nalysis p robabilistic p lanning

tion known fixed  exploit callable succeeds  or fails  probability  generator uses network consisting exposed part  sensitive part  user part 
allows scale numbers h hosts e exploits  sarraute et al s pomdp model
solver  sarsop  see kurniawati  hsu    lee        guarantee optimality  scale
h      e         benchmarks  fixed h   e simplicity  and obtain number
instances similar benchmark domains   scaled instances            without
budget limit              budget limit 
benchmark tasks  except pentesting ones already
generated separate limited budget version anyway   obtained several limited budget benchmarks  follows  set outcome costs   otherwise specified  determined
minimum budget  bmin   required achieve non   goal probability  resource constrained
benchmarks  bmin determined generator itself  minimum amount resource required
reach goal deterministic domain version  benchmarks  ran fd
lm cut all outcomes determinization   failed  skipped   otherwise
read bmin cost optimal plan created several limited budget tasks  c   differing
constrainedness level c  namely  following nakhost et al          set global budget b
 c  b    c bmin   c factor available budget exceeds minimum
needed  to able reach goal all   let c range                         
atleastprob  let range                               pointless   approxprob 
let range                               pointless   cyclic problems  convergence
parameter set          the value used kolobov et al          experiments
run cluster intel e       machines running      ghz  time memory cut offs
   minutes   gb 
    acyclic planning
consider first acyclic planning  pertains budget limited benchmarks  pentesting
without budget limit  well ippc triangletireworld  moves made
one direction state space acyclic   consider   objectives maxprob  atleastprob 
approxprob  run    search algorithm variants  vi  ao   lrtdp    dfhs variants 
subsets bounds applicable     node selection strategies explained  deadend pruning  run lm cut  well merge and shrink  m s  state of the art shrinking
strategies based bisimulation abstraction size bound n   show data n  
n      k  we tried n    k    k     k  resulted similar behavior   run
variants without dead end pruning  use deterministic bisimulation  db  reduced state space
vi   and if  bisimulation successfully computed  block state mdp easily
solved simplest algorithm  given db  require dead end pruning
dead ends already removed reduced state space 
overall  yields     different possible algorithm configurations  actually test
configurations  course  interesting  needed make essential
observations  instead organize experiment terms three parts         focusing
particular issue interest  consider table    gives overview configurations
considered experiment  design experiments follows 
    modeling solving entire network  is  domain dependent decomposition algorithm  al 
trading accuracy performance  sarraute et al  scale much further 

   

fis teinmetz   h offmann   b uffet

experiment

search algorithm


pruning

node selection

  configs



ao  u  
maxprob search   prun  vi  ao  l  
default
lrtdp 
 
dfhs 
u
u         
ing
vi db
vi  ao  l  
ao  u  

atleastprob   approx  ao  lu  
lrtdp u  
   
lm cut
default
prob parameters
lrtdp lu  
hdp u  
hdp lu   vi db
vi  ao  l  
ao  u  
               

lrtdp u  
atleastprob   approx  ao  lu  
   
lm cut            respeclrtdp lu  
hdp u  
prob node selection
tively 
hdp lu   vi db
   

  

  

  

table    overview algorithms tested acyclic problems  section      numbers brackets give
number options number obvious           note total
number configurations gets multiplied   atleastprob vs  approxprob result
different algorithm configurations  using different termination criteria   hdp
member dfhs family  corresponding bonet geffners      a 
dfhsfwdcons
lab
hdp algorithm 
    first evaluate different search algorithms dead end pruning methods maxprob  fixing
node selection strategy default 
omit x lu variants  because  explained earlier  maxprob heuristic search 
maintaining v l redundant  early termination dominated regular termination  
using default node selection strategy makes sense node selection strategies
relevant anytime performance  i e   early termination  plays minor role
maxprob  whose early termination possibility exceptional case initial state
lower bound becomes v l  i      
    next fix best performing dead end pruning method  analyze search algorithm performance atleastprob approxprob function parameter respectively  
fix node selection strategy default here  leaving examination experiment
    
    finally let node selection strategies range  keeping otherwise setting experiment
    
conclude discussion     additional data illustrating typical anytime behavior 
part experiment described separate sub section follows 
          earch lgorithms   p runing ethods ax p rob
table   shows coverage data  i e   number benchmark tasks maxprob solved
within given time memory limits 
pruning methods  lm cut clearly stands out  every search algorithm  yields
far best overall coverage  m s substantial advantages rectangletireworld
nomystery b  note that  n     overall coverage worse using pruning
all  due prohibitive overhead  domains  computing bisimulation
determinized state space  and  invested effort  pays use bisimulation
   

fig oal p robability nalysis p robabilistic p lanning

domain

 

triatire

  

blocksw b
boxworl b
drive b
elevator b
expbloc b
random b
rectire b
tirewor b
triatire b
zenotra b

  
  
  
  
  
  
  
  
  
  

nomystery b   
rovers b
  
tpp b
  
pentest b
pentest
p

  
  
   

domain

 

triatire

  

blocksw b
boxworl b
drive b
elevator b
expbloc b
random b
rectire b
tirewor b
triatire b
zenotra b

  
  
  
  
  
  
  
  
  
  

nomystery b   
rovers b
  
tpp b
  
pentest b
pentest
p

  
  
   

dfhsfwd
dfhsfwdcons
 u
dfhsfwd
vi  u
vi
lab  u
lm m s
lm m s
lm m s

n
n
n
ippc benchmarks
          
                   
          
ippc benchmarks budget limit
                                                  
       
       
       
       
 
                                                  
                                                  
                                                  
                                                  
                                                  
                                                  
                                                  
                                                  
probabilistic resource constrained benchmarks budget limit
                                                  
                                                  
                                                  
pentesting benchmarks
                                                  
       
       
       
       
 
                                                                   
dfhsvi  u
lm m s
n

hdp u
lm m s
n
        
  
 
  
  
  
  
  
  
  
  

  
 
  
  
  
  
  
  
  
  

        
        
        
        
     
           

ao  l
ao  u
lrtdp u
hdp u
lm m s
lm m s
lm m s
lm m s
n
n
n
n
ippc benchmarks
       
                                           
ippc benchmarks budget limit
                                                           
       
       
       
       
       
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
                                                           
probabilistic resource constrained benchmarks budget limit
                                                           
                                                           
                                                           
pentesting benchmarks
                                                           
       
       
       
       
       
                                                                               
vi
lm m s
n

  
 
  
  
  
  
  
  
  
  

vi

db
  
  
 
  
  
  
  
  
  
  
  
  
  
  
  
 
   

table    acyclic planning  maxprob coverage  number tasks solved within time   memory
limits   best values  within table  boldface  top  dfhs variants  recall hdp
dfhsfwdcons
member dfhs family  dfhsvi ilao    bottom  remaining
lab
search algorithms  including overall best dfhs variant  domains  b modified
budget limit     number instances    pruning  else pruning 
remaining budget  b domains  based h   domains  lm  lm cut 
m s  merge and shrink  n size bound n      k  size bound  vi db 
vi run reduced  deterministic bisimulated  state space  default node selection 

   

fis teinmetz   h offmann   b uffet

   

   

   

   

lrtdp u  lm cut 

lrtdp u

reduced mdp state space  vi db   rather dead end pruning  extreme
example latter triangletireworld  far beyond standard benchmarks table    triangleside length      vi db scales side length    original domain limited budget
version  comparison  hitherto best solver far prob prp  camacho et al         
scales side length    original domain  optimal goal probability    i e  
presence strong cyclic plans holds original domain limited budget
version   we could actually run prob prp limited budget domain version  prob prp
natively support budget  hard coding budget ppddl resulted encodings
large pre process  
comparing different dfhs u variants  configuration clearly stands out 
overall  perform equally well  though fwdcons variants  cutting exploration
inconsistent states rather absorbing states  slight edge  difference mainly comes
triangletireworld  explodingblocks  tpp b  fwdcons configurations solve
instances  zenotravel b fwdcons configurations perform slightly worse counterparts  termination parameter  vi vs  label  almost effect coverage  due
gives best coverage results 
similarity dfhs configurations  dfhsfwdcons
lab


representative


dfhs
family

remaining discussion 
use dfhsfwdcons
lab
fwdcons
corresponds hdp  simplicity refer name 
dfhslab
ao  l better vi case early termination v l      full certainty
policy found visiting entire state space  happens rarely here  ao  l
dominated vi  this changes atleastprob  see figures  a   below   failures vi
due memory runtime exhaustion building reachable state space  lrtdp u clearly
outperforms ao  u   presumably tends find absorbing states quickly  lrtdp u
hdp u par  lm cut solve exact number instances  though
exactly instances   otherwise hdp u solves slightly fewer tasks lrtdp u  
gauge efficiency heuristic search vs  blind search maxprob  compare lrtdp u vs 
vi table    contrary intuition good initial goal probability estimator required
heuristic search useful  lrtdp u clearly superior  advantage grow quality
initialization  lm cut yields largest coverage increase far  however  even without
dead end pruning  i e   trivial initialization v u   lrtdp u dominates vi throughout 
improves coverage      domains 

   
   
   

   
   
   

   
     
  

   

   

   

   
vi

   

   

     
  

   

   

   

   
   
vi  lm cut 

   

   

figure    acyclic planning  number states visited  vi  x  vs  lrtdp u  y   pruning
 left  respectively lm cut pruning  right   default node selection 
next shed additional light comparing search space sizes runtime values 
tables     provide aggregate data  figure   gives scatter plot canonical comparison
   

fig oal p robability nalysis p robabilistic p lanning

ao  u
lrtdp u
lm
m s

lm
m s
n

n

ippc benchmarks
                       
               
               
               
               
ippc benchmarks budget limit
                
                               
               
           
 
         
 
            
 
               
               
   k                                                     
   k                                        
           
   k                 k             
               
               
             
   k                                                  
   k                 k             
                                                  
                                          
 
 
   k                  
 
 
                   
   k                      k                   k               
   k                      k                  
                                                              
                 
                                               
probabilistic resource constrained benchmarks budget limit
   k                k                k            
    k                     k                
   k                                                         
   k                      k                   k               
   k                      k          k      
   k                      
                                 
   k                     k                     k                 
pentesting benchmarks
                                                  
                                                                     
                                                           
                                                                       


domain

 

triatire
only h

 
 

blocksw b
  
drive b
  
elevator b
  
expbloc b
  
non trivial  
only h
 
random b
  
non trivial  
only h
 
rectire b
  
non trivial   
triatire b
  
non trivial  
only h
 
zenotra b
  
non trivial   
nomystery b   
only h
 
rovers b
  
non trivial   
only h
 
tpp b
 
non trivial  
pentest b
  
non trivial  
pentest
 
non trivial  

vi
lm
m s
n






hdp u
lm
m s
n


               
                       
                
             
               
                  
                   
   k             
               
                
   k             
    
         
                
               
   k               
   k                  
                    
                     
   k            
    k                
                    
   k                 
   k                
                    
   k           
  
                
                       
                   
                       

table    acyclic planning  maxprob geometric mean search space size  number states visited 
multiples         gives size instance basis  namely instances solved
shown configurations  skipping instances solved   second configurations  non trivial uses instances solved vi     second 
only h uses instances commonly solved ao  u   lrtdp u   hdp u  
solved vi  rows empty instance basis skipped  default node selection 
vi lrtdp u   data ao  l shown coverage dominated vi  cf 
table     goes runtime search space  include non trivial rows
tables show behavior interesting instances  averages skewed
many small instances domains  include only h rows elucidate
behavior challenging instances beyond reach vi 
clear message table   figure   heuristic search algorithms  apart
exceptions  visit much fewer states vi does  even trivial upper bound initialization search spaces reduced domains except rectangletireworld pentest 
instance  using lrtdp u instead vi results gain around   order magnitude many
instances  larger gains  up   orders magnitude  occur rare cases  giving
heuristic search algorithms additional information earlier dead end detection  differences become even larger 
   

fis teinmetz   h offmann   b uffet

domain

 

triatire
only h

 
 

blocksw b
  
drive b
  
elevator b
  
expbloc b
  
non trivial  
only h
 
random b
  
non trivial  
only h
 
rectire b
  
non trivial   
triatire b
  
non trivial  
only h
 
zenotra b
  
non trivial   
nomystery b   
only h
 
rovers b
  
non trivial   
only h
 
tpp b
 
non trivial  
pentest b
  
non trivial  
pentest
 
non trivial  

ao  u
lrtdp u
hdp u
lm m s
lm m s
lm m s
n

n

n

ippc benchmarks
           
 
 
         
     
 
           
                               
                  
ippc benchmarks budget limit
               
       
                     
       
     
            
       
      
              
              
               
 
         
           
           
            
   
    
                  
   
          
                  
                
               
               
                                                        
               
                               
               
                   
                                 
                 
                                                           
              
                                                      
                                                                          
                
                                
               
                
            
      
                          
                                      
               
          
 
                
                    
          
                                                                              
probabilistic resource constrained benchmarks budget limit
                                                                    
                                                      
               
                       
                             
                                                                            
                                                                
                 
                                   
                 
                                                                            
pentesting benchmarks
            
   
          
            
   
          
                 
               
                  
                
               
                   
         
               
   
          
                
                 
                  
vi
lm m s
n



table    acyclic planning  maxprob geometric mean runtime  in cpu seconds   setup
presentation table   
previously hinted  observations made clarity before 
kolobov et al         report lrtdp beat vi maxprob  consider single domain  experiment trivially initialized v u   use dead end pruning
vi  lrtdp already benefits smaller state space  impact heuristic search
remains unclear 
even though search space heuristic search algorithms many cases small
fraction whole  dead end pruned  state space  necessarily reflected runtime 
instances solved vi  typically fast  often faster heuristic search rarely
outperformed significantly  despite larger search spaces  i e   heuristic search
visit less states suffers updates  recall vi updates
visited state exactly once   significant runtime advantages vi  in non trvial rows 
obtained heuristic search explodingblocksb  randomb  triangletireworldb 
comparing heuristic search algorithms  conclusions fine grained overall
similar concluded coverage above  lrtdp u dominates ao  u almost throughout 
note that  even though search space size ao  u lrtdp u almost always similar  ao  u
requires lot time lrtdp u   performs updates  across nontrivial commonly solved instances tables  geometric mean number updates done
   

fig oal p robability nalysis p robabilistic p lanning

ao  u   times higher lrtdp u   lrtdp u hdp u non trivial
value initialization give similar results  terms coverage  terms
runtime search space size  lrtdp u is  however  effective domains  e g  
rectangletireworld zenotravel  additional dead end detection method used 
hand  hdp u slight edge probabilistic resource constrained domains  one notable
case lrtdp u consistently outperforms hdp u triangletireworld 
impact dead end pruning vi typically moderate  gains heuristic search
much pronounced  thanks stronger heuristic function initialization  especially ao  u
benefits lot  lrtdp u hdp u benefit well  smaller extent  partly
already effective first place  comparing across different dead end pruning methods 
although m s n   clearly yields largest search space reductions  necessarily
recognizes dead ends  overhead bisimulation computation outweighs search space
reduction cases  terms pruning power  m s n      k lm cut
heuristic overall roughly similar  yet lm cut edge runtime 
          l east p rob pprox p rob parameter nalysis
turn weaker objectives  atleastprob approxprob  fix lm cut  almost
always effective  dead end pruning  examine power early termination different
search algorithms node selection strategies  best viewed function goal probability threshold atleastprob  desired goal probability accuracy approxprob  vi
forms baseline independent     consider figure   
vi
lrtdp u

   

vi

lrtdp lu

ao  lu

hdp u

hdp lu

   

   
   
  solved instances

  solved instances

   

ao  l

ao  u

   
   
   
   
   

ao  l

ao  u

lrtdp lu

ao  lu

hdp u

hdp lu

   
   
   
   
   
   

   

   

   

   
                                     


lrtdp u

                                     


 a 
 b 
figure    acyclic planning  total coverage atleastprob function  a   approxprob function  b   configurations use default node selection lm cut
dead end pruning 
atleastprob  figure  a   interesting region benchmark instances feasible
vi yet sometimes feasible search algorithms  one clear feature superiority
lrtdp ao hdp  one see smaller values   lrtdp able
update v l much effectively hdp  resulting larger coverage lrtdp region
   

fis teinmetz   h offmann   b uffet

smaller values  ao  l exhibits strikingly strong behavior small values   approaching
 and one case  surpassing  performance lrtdp u   evidently  depth first expansion
strategy quite effective anytime behavior v l thus termination via v l  i   
way effective heuristic search ao  lu   shall see  figure    
often effective lrtdp  general  algorithms  using v l clear advantage
small   larger   maintaining v l become burden  yet v u advantage due early
termination v u  i      algorithms using bounds exhibit easy hard easy pattern 
spike left hand side figure    a   i e   significantly worse performance      
       outlier due pentest domains without domains  ao  lu  
lrtdp lu hdp lu exhibit strict easy hard easy pattern  because  contrast typical probabilistic planning scenarios  penetration testing goal probability chance
successful attack typically small  indeed benchmarks  searches using
upper bound quickly obtain v u  i         terminating early based v u  i          
takes long time obtain v u  i        
approxprob  figure  b   smaller values consistently result worse performance 
see superiority lrtdp ao hdp   relatively  compared ao  lu  
strong behavior ao  l regions allowing aggressive early termination  again  key
lrtdp beating hdp clearly due lrtdp updating v l much effectively  hdp lu
improve hdp u small margin  nonetheless  see superiority algorithms
using bounds dont 
          n ode election trategies
figure   shows different node selection strategies atleastprob  the relative performance node
selection strategies approxprob  include separate figure that  
lrtdp lu  def 
ao  l  bfs 

   

  solved instances

   

ao  lu  def 
ao  lu  h 

ao  l  dfs 
ao  l  h 

ao  lu  o prob 
hdp lu  def 

vi

   
   
   
   
   
   
   
   
                                     


figure    acyclic planning  total coverage atleastprob function   varying node
selection strategy  configurations use lm cut dead end pruning 
readability  show competitive base algorithms  ao  l   ao  lu   lrtdp lu  
hdp lu  as well vi baseline   lrtdp hdp  show default node selection  consistently works basically well alternatives  ao  l   see
   

fig oal p robability nalysis p robabilistic p lanning

depth first strategy important  and way beyond breadth first  worse vi  
h bias strategy marginally  consistently  better depth first  ao  lu   h bias
most prob outcome bias helpful  substantially improving default strategy 
h bias consistently improves bit default ao   gap bias preferred actions strategies
shown consistently slightly worse  apparently  gap bias leads
breadth first style behavior  preferred actions mainly cause runtime overhead  
          n llustration ypical nytime b ehavior
conclude discussion acyclic planning  figure   exemplifies typical anytime behavior  i e  
development v l  i  v u  i  bounds initial state value  function runtime 
lrtdp lu ao  l  
 

lrtdp v u lm cut

lrtdp v l

lrtdp v l lm cut

ao  

ao  

l

 

l lm cut

   
probability

probability

   

lrtdp v u

   
   
   

   
   
   

 

 
 

   

   
   
time  s 

   

   

 

   

 a 

lrtdp v u

lrtdp v u lm cut

lrtdp v l

lrtdp v l lm cut

ao  l

ao  l lm cut

   
   
time  s 

   

   

 b 

figure    acyclic planning  anytime behavior lrtdp lu  v v l   ao  l  v l only  
function runtime  elevators instance     without pruning lm cut pruning 
constrainedness level c        a  respectively c        b   default node selection 
u

benefit lm cut pruning evident  observe ao  l way effective
lrtdp quickly improving lower bound  indeed  runs shown find optimal policy
quickly  across benchmarks solved ao  l lrtdp  omitting
took     second      cases ao  l finds optimal policy faster lrtdp   geometric  average  ao  l takes     time taken lrtdp purpose  downside 
unless v  i    ao  l must explore entire state space  runs figure   exhaust memory
maxprob  summary  heuristic search much stronger proving maximum goal
probability found  often distracting improving v l quickly 
parts figure   use base instance different constrainedness levels c 
draw conclusions effect surplus budget  budget  actions
applied reaching absorbing states  adversely affects upper bound  consistently
across experiments   takes much longer time decrease  lower bound 
hand  often increases quickly higher c easier find goal states 
   

fis teinmetz   h offmann   b uffet

    cyclic planning fret
consider cyclic planning  pertaining standard ippc benchmarks  probabilistic
nomystery  rovers  tpp without budget  nor resource   limit  run lrtdp dfhs 
ao restricted acyclic state spaces  use two different variants fret described earlier 
fret v u per kolobov et al          new variant fret  u   consider   objectives 
  dead end pruning methods  as lm cut returns iff cheaper heuristic hmax does 
use hmax here   vary node selection strategies because  seen before 
lrtdp dfhs bring notable advantage default strategy  use
deterministic bisimulation  db  reduced state space base algorithm  differences
emerge  in difference acyclic case  vi algorithms  need
run fret  again  given db require dead end pruning 
overall  yields     different possible algorithm configurations  before 
interesting  instead organize experiment terms parts focusing issues
interest  specifically  parts     maxprob     atleastprob approxprob before 
node selection strategies relevant here  previous part     considering
these  integrate data illustrating anytime behavior discussion      table   gives
overview tested configurations 
experiment
fret variant
search algorithm
pruning
  configs
maxprob search   prun   
  
  fret v u   fret  u vi  lrtdp u   dfhs          db
ing
   

vi 
atleastprob   approxu
u lrtdp   
 
fret v
 
fret 
lu
prob parameters
hdp lu

lrtdp u  
hdp u  

hmax

  

table    overview algorithms tested cyclic problems  section      note vi require  hence combined with  fret  denote  not using fret all 
       note number configurations gets multiplied   atleastprob
vs  approxprob result different algorithm configurations  using different termination
criteria   configurations tested use default node selection 
          earch lgorithms   p runing ethods ax p rob
table   shows coverage data  before  dfhs family shown top  remaining
search algorithms  including competitive dfhs algorithm hdp 
shown bottom  vary fret variant top space reasons  as 
fret v u   coverage differences across dfhs family members 
similarly acyclic case  dfhs configurations stopping exploration  inconsistent
states give slightly better results stopping absorbing states  termination
parameter almost effect coverage  hdp  i e   dfhsfwdcons
  solves one task
lab
explodingblocks dfhsfwdcons
 

otherwise

coverage


same  akin
vi
acyclic case  lrtdp hdp perform equally well  though hdp slight edge
combination fret  u  
running search deterministic bismulation state space less effective cyclic
benchmarks acyclic ones  gives clear advantage rovers 
   

fig oal p robability nalysis p robabilistic p lanning


domain

 

blocksworld
boxworld
drive
elevators
explodingblocks
random
rectangletireworld
tireworld
zenotravel
nomystery
rovers
tpp
p

domain
blocksworld
boxworld
drive
elevators
explodingblocks
random
rectangletireworld
tireworld
zenotravel
nomystery
rovers
tpp
p

    
    
    
     
    
    
     
     
    
    
    
    
      

 

fret  u
dfhsvi  u
dfhsfwdcons
 u
dfhsfwd
hdp u
vi
lab  u
hmax m s
hmax m s hmax m s hmax m s
n bs
n bs
n bs
n bs
n
ippc benchmarks
         
         
         
         
     
         
         
         
         
     
                                                           
                                                           
                                                  
         
         
         
         
     
                                                                    
                                                                    
         
         
         
         
     
probabilistic resource constrained benchmarks
         
         
         
         
     
         
         
         
         
     
         
         
         
         
     
                                                                         
dfhsfwd
vi  u
hmax m s

 
 
  
  
 
 
  
  
 

 
 
  
  
 
 
  
  
 

 
 
  
  
 
 
  
  
 

    
    
    
      

 
 
 
  

 
 
 
  

  
  
  
  
  
  
  
  
  

fret v u
fret  u
lrtdp u
hdp u
lrtdp u
hdp u
hmax m s hmax m s hmax m s hmax m s
n db
n db
n db
n
ippc benchmarks
     
         
         
         
     
     
         
         
         
     
                                                     
                                                     
     
         
                           
     
         
         
         
     
                                                              
                                                              
     
         
         
         
     
probabilistic resource constrained benchmarks
     
         
         
         
     
     
         
         
         
     
     
         
         
         
     
                                                                

vi
hmax m s
n db


bs
 
 
 
 
 
 
  
  
 
 
 
 
  


db
 
 
 
 
 
 
  
  
 
 
 
 
  

table    cyclic planning  maxprob coverage  best values  within table  boldface  fretv u per kolobov et al          fret  u modified version  top  dfhs variants
member dfhs family  dfhsvi ilao   
 recall hdp dfhsfwdcons
lab
showing dominating fret version  fret  u   bottom  remaining search algorithms  varying fret version  including overall best dfhs variant 
dead end pruning variants  none  else based heuristic value   hmax respectively merge and shrink  n size bound n      k  size bound   db  run
reduced  deterministic bisimulated  state space  default node selection 
striking result far fret  u outperforms vi fret v u substantially  note that  domains except explodingblocks rovers  advantage vi
obtained even without dead end pruning  i e   trivial initialization v u   strongly confirms
power heuristic search even absence good admissible goal probability estimators 
before  shed additional light coverage results search space size runtime
data  figure   compares search space sizes vi vs  fret  u   non trivial initialization
using hmax useful  gains   orders magnitude possible even without it 
table   provides aggregate search space size runtime data  data shown configuration using fret v u hdp  data almost identical fret v u lrtdp 
   

fi   

   

   

   
fret  u  hmax  

fret  u

teinmetz   h offmann   b uffet

   
   
   

   
   
   
   

   
     
  

   

   

   
vi

   

   

     
  

   

   

   

   
   
vi  hmax  

   

   

figure    cyclic planning  number states visited  vi  x  vs  fret  u using lrtdp u  y  
pruning  left  respectively hmax pruning  right  
fret v u
fret  u
lrtdp u
lrtdp u
m s
hmax
m s
hmax
m s

n

n

n

ippc benchmarks
   
   
     
   
   
   
   
     
   
      
 
          
 
          
 
   
   
 
     
   
 
     
   
 
                                 
           
   
                                    
                  
   
   
   
     
        
   
   
        
   
 
       
   
 
      
   
        
  
  
                 
 
          
 
                            
 
          
 
          
                 
   
              
   
probabilistic resource constrained benchmarks
                                                             
                                 
   
   
   
   
   
                                                          
                                                          
ippc benchmarks
   
   
       
   
   
   
   
   
   
   
   
   
       
   
   
   
   
   
   
   
   
   
       
   
   
   
   
   
   
   
                                     
   
           
   k          k         k           
         
         
 
 
       
 
 
   
   
 
 
   
 
 
     
 
 
     
 
 
 
   k    k    k                  
   
   
   
   
   
   k    k    k    k    k    k
   
   
   
   
   
                                   
   
   
   
   
   
probabilistic resource constrained benchmarks
   k    k    k    k    k    k                          
   k    k    k    k    k    k                         
   k    k    k    k    k    k                           
   k    k    k    k    k    k                              

vi
hmax
domain

 

blocksworld
drive
elevators
explodingblocks
non trivial
rectangletireworld
non trivial
tireworld
non trivial
zenotravel

 
 
 
 
 
 
 
 
 
 

 
 
 
   
    
   
   
   
  
    

 
 
 
   
   
 
   
    
    
    

nomystery
rovers
tpp
non trivial

 
 
 
 

    
    
    
    

    
    
    
    

blocksworld
drive
elevators
explodingblocks
non trivial
rectangletireworld
non trivial
tireworld
non trivial
zenotravel

 
   
   
 
   
   
 
   
   
            
     k      
 
   
   
 
 
   
     k    k
     k    k
             

nomystery
rovers
tpp
non trivial

 
 
 
 

   k
   k
   k
   k

   k
   k
   k
   k

hdp u
hmax
m s
n

   
   
   
          
     
   
           
            
   
   
   
   
   
   
          
          
   
        
                 
   
   
   
              
                
   
   
   
   
   
   
   
  
         
   
 
   
 
   
   
   
   
   
   

   
   
   
   
   
 
 
   
   
   

                 
              
              
                 

table    cyclic planning  top  maxprob geometric mean runtime  in cpu seconds   bottom 
maxprob geometric mean search space size  number states visited  multiples      
similar setup presentation table      gives size instance basis 
default commonly solved instances  skipping trivial ones  non trivial uses
instances solved vi     second   only h shown  see text  

   

fig oal p robability nalysis p robabilistic p lanning

search space sizes exactly same  runtimes differ seconds  difference
tables      include only h rows  would interesting here 
fret v u hardly solves instances vi  would excluded rows 
then  data would compare lrtdp vs  hdp  perform similarly anyway 
striking table   consistency which  extent which  fret  u visits
less states competitors  for lrtdp hdp   advantage typically yields better
runtimes well  notable exception nomystery  larger number fret iterations results substantial slow down  despite much smaller search space  fret v u
lrtdp requires    fret iterations average  nomystery instances commonly
solved fret  u lrtdp  latter configuration requires       iterations average  similarly using hdp 
impact dead end pruning notably smaller acyclic case  search spaces
reduced substantially single domain  explodingblocks  domains  either
reduction  minor moderate one only 
vi  kolobov 
vi
vi  hmax  
fret v u  kolobov 
fret v u  hmax  
fret  u  hmax  

   
   

   

time  s 

states visited

   

   

   

   
   
   

   
 

 

 
 
problem  

 

   

 

 

 

 
 
problem  

 

 

 a 
 b 
figure    cyclic planning  results explodingblocks  shown kolobov et al          fret
vs vi   a  number states visited   b  runtime cpu seconds  function
ippc instance index  different variants included comparison  data kolobov
et al  taken paper  as code available anymore   hence runtime
comparison modulo different computational platforms  treated
care  shown fret configurations use lrtdp u   default node selection 
explodingblocks happens single domain kolobov et al         experimented with 
figure   provides detailed comparison kolobov et al s data  state art
measure provided previous work  use exact runtime search space size data reported
kolobov et al   recall source code available anymore 
kolobov et al         ran vi pruning vs  fret v u using lrtdp pruning based
sixthsense  kolobov et al          observed coverage   former  
latter  identical results vi vs  fret v u using lrtdp hmax   give
   

fis teinmetz   h offmann   b uffet

detail  figure   shows number states visited  total runtime  terms plots ippc
instance index done kolobov et al        
consider first figure    a   search space size  difference vi  kolobov 
vi different task state representation resulting respective implementation
framework  fd framework somewhat effective  substantially better performance
vi hmax dead end pruning shows omission kolobov et al s        study  using
dead end pruning fret vi  indeed obfuscates possible conclusions regarding
effect heuristic search vs  effect state pruning itself  hmax pruning  vi almost
effective fret v u using pruning  kolobov et al s fret v u close
this  except exploring significantly less states large instances  latter shows  especially
given effective representation fd  sixthsense stronger dead end detector
hmax   hardly surprising  considering information sources sixthsense outcomes
 determinized  classical planning guidance  h   graphplan  based validity tests 
hand  sixthsenses information sources much time intensive hmax  
presumably reason runtime picture figure    b   latter qualitatively
similar  a   except fret v u  kolobov  significantly worse  rather better 
largest instance  last conclusion taken grain salt though  given different
computational environments 
certainly  given clarity fret  u advantage search space size runtime  one
conclude variant fret substantially improves previous state art 
          l east p rob pprox p rob parameter nalysis
weaker objectives atleastprob approxprob  examine coverage function respectively   figure    shows data 
fret v u   behavior figure    similar acyclic case figure   
particular  maintaining upper lower bound  fret v u exhibits easy hardeasy pattern due advantages early termination 
fret  u   though  curves flat   observation small advantage
using v l addition v u   due scaling benchmarks  combined extreme
performance loss point scaling  domain  instance number x
that  x  fret  u solve instances completely  i e   solving maxprob   x
neither v l  i  v u  i  improved all  remaining   respectively   time memory
limit  smaller instances  get expected anytime behavior  figure    exemplifies this 
easy hard easy pattern would thus emerge smaller runtime memory limits   

   conclusion
optimal goal probability analysis probabilistic planning notoriously hard problem 
extent amount work addressing limited  investigation contributes comprehensive design space known adapted algorithms addressing problem  designing several new
algorithm variants along way  establishing fd implementation basis supporting tight
integration mdp heuristic search classical planning techniques  experiments clarify
    figure     b  considers largest instance feasible using hmax pruning  figure     a  considers secondlargest instance feasible without pruning  largest one feasible without pruning  namely instance     maximum goal probability   anytime curve v u interesting 

   

fig oal p robability nalysis p robabilistic p lanning

fret v u lrtdp u

fret  u lrtdp u

fret v u lrtdp u

fret  u lrtdp u

fret v u lrtdp lu
fret v u hdp u
fret v u hdp lu
vi

fret  u lrtdp lu
fret  u hdp u
fret  u hdp lu

fret v u lrtdp lu
fret v u hdp u
fret v u hdp lu
vi

fret  u lrtdp lu
fret  u hdp u
fret  u hdp lu

   
  solved instances

  solved instances

   

   

  

   

  

                                     


                                     


 a 

 b 

 

 

   

   
probability

probability

figure     cyclic planning  total coverage atleastprob function  a   approxprob function  b   configurations use default node selection hmax
dead end pruning 

   
   

   
   

   

   

 

 
 

  

  
time  s 

 

  

 a 

   

   
   
time  s 

   

 b 
fret  u

figure     cyclic planning  anytime behavior
lrtdp lu hdp lu  
default node selection   a  without pruning explodingblocks instance      b 
hmax pruning instance    
empirical state art  exhibit substantial improvements thanks new techniques technique combinations  furthermore showcase opportunities arising naturally acyclic
problems  early termination criteria weaker maximum goal probability 
hope encouraging results new implementation basis inspire renewed
interest research important problem  many promising future directions 
would emphasize 
advanced admissible goal probability estimators  could obtained  e g  abstractions interpreted bounded parameter mdps  givan  leach    dean         promis   

fis teinmetz   h offmann   b uffet

ing approach extend state of the art classical planning abstraction techniques pattern
databases  edelkamp        haslum  botea  helmert  bonet    koenig         merge andshrink  helmert et al          cartesian abstractions  seipp   helmert             
probabilistic setting 
hybrids heuristic search monte carlo tree search  appears promising option
improve anytime behavior  respect upper and or lower bound  thus foster
early termination  inspiration could taken existing hybrids  geared toward
purposes  keller   eyerich        bonet   geffner        keller   helmert        
exploiting dominance relations  goal probability higher dominating states 
raising opportunity prune dominated regions and or transfer upper lower bounds across
states  state domination ubiquitous limited budget planning  and resource constrained
planning   general domination relations shown exist many
classical planning problems  torralba   hoffmann         transfer techniques probabilistic case  via all outcomes determinization  straightforward 
last least  simulated penetration testing application worth algorithms research
right  basic idea exploit particular structure models  specifically
partially delete relaxed behavior  characterizing property simulated penetration testing
action  applicable  remains applicable first executed  once attacker gets
position enabling exploit  exploit remains enabled   hence  delete relaxed planning 
find optimal solution  navely branch action every state ever after 
combat this  least three interesting directions  following pommerening helmerts
       methods computing h    different branching schemes might apply  challenge
maintain value function correctness  following gefen brafmans        methods computing h    partial order reduction could adapted  challenge deal action
interference entailed shared budget  finally  methods specific probabilistic setting may
apply  intuitively  preserve optimality  certain actions need attempted alternate
goal path failed  suggests identify  branch at  particular critical points along
search path 

acknowledgments
work partially supported german research foundation  dfg   grant ho
          critically constrained planning via partial delete relaxation  well federal ministry education research  bmbf  funding center it security 
privacy accountability  cispa  grant   kis      thank christian muise
probabilistic pddl extension fd parser  thank andrey kolobov discussions 
thank anonymous reviewers  whose comments helped improve paper 

appendix a  depth first heuristic search cyclic problems
pseudo code family depth first heuristic search algorithms  dfhs  general  cyclic 
probabilistic planning problems shown figure    
   

fig oal p robability nalysis p robabilistic p lanning

procedure goalprob dfhs
    i  
loop
 early termination criteria exactly goalprob ao  
 label labeled solved 
 vi u changed running vi u  greedy graph 
index     
dfhs exploration i 
set idx visited states
clean stack visited
else return u endif    regular termination   
endloop
procedure dfhs exploration s  
  initialize s  endif
s  labeled solved
label solved
return
endif
f lag   
fw
v u  s  consistent f lag      endif
update v u  s   u  s   v l  s   l  s 
consist f lag return   endif
endif
s idx    index  s lowlink    index
push onto stack  mark visited
index    index    
foreach p  s  u  s   t     
t idx  
f lag    dfhs exploration s  f lag
t idx   t lowlink   s lowlink s lowlink    t lowlink endif
else stack t idx   s lowlink s lowlink    t idx endif
done
f lag fw
v u  s   consistent f lag      endif
update v u  s   u  s   v l  s   l  s 
endif
label f lag s idx   s lowlink
forever
   stack pop  
label solved
  break endif
done
endif
return f lag

figure     depth first heuristic search  dfhs  general  cyclic  maxprob  atleastprob 
approxprob 

appendix b  landmarks pruning  admissible heuristic vs  budget reduction
stated  domshlak mirkis        problem reformulation  pruning states based global
budget reduced using disjunctive action landmarks  equivalent  regarding states pruned
method own  much simpler method using landmarks pruning
   

fis teinmetz   h offmann   b uffet

remaining original budget  give argument  previously made unit costs
pairwise disjoint landmarks  general setting  assume classical planning setup
simplicity  arguments probabilistic oversubscription setups essentially same 
assume strips planning task    f  a  i  g   action costs c a  global
budget b  use notation following admissible landmark heuristics per karpas domshlak
        let l set disjunctive action landmarks i  i e   every l l every
action sequence  a leading goal   a touches l  there exists l used  a   let
furthermore
cp   l   r 
  cost partitioning  i e   function satisfying  a 
p
c a  l p
c a   denote h l     minal cp a  l   subset l  l landmarks
denote h l       ll  h l   intuitively  landmark l l assigned weight h l  via cp 
admissible heuristic value h l  obtained summing weights 
describe domshlak mirkis        pruning technique terms  domshlak
mirkis formulation terms compilation planning language  complicated  equivalent formulation far pruning concerned 
domshlak mirkis technique maintains non used landmarks part states  namely 
state reached path  a  l l non used iff  a touch l  denote set nonused landmarks l s   obviously  l l s  landmarks s  note that  l s 
part state  even two search paths lead end state use different landmarks 
end states considered different  restriction arises compilation approach 
book keeping landmarks must happen inside language  i e   inside states  one
could formulate pruning technique without restriction  get back below 
pruning technique arises interplay reduced global budget reduced
action costs depending non used landmarks  define reduced global budget b     b h l  
action a  denote l a  set landmarks participates in  i e   l a      l   l l 
l   state search  applicable action a  transition t  a  
reduced cost  namely cost c a  h l a  l t    words  reduce cost
 summed up  weight non used landmarks participates in 
consider state search  denote remaining reduced budget b   s  
say prune iff b   s         consider path  a ending s  non used landmarks
part state  paths must touch
p subset landmarks l  namely
l   l s   denote actual cost  a c  a     a a c a   relative cost  cost saved
thanks cost reduction exactly h l   l s    weight touched landmarks  therefore 
b   s    b   c  
a  h l   l s     p b h l   c  a    h l   l s    p
definition h 
p
equals  b h l   c  a    ll l s  h l   equals b c  a  ll s  h l   
b c  a  h l s    thus  pruned  b   s       iff b c  a    h l s    latter condition
b s    h l s    exactly pruning condition resulting using h l s  
admissible heuristic function pruning remaining budget 
non compilation setting  one could  indeed customary admissible landmark heuristics  handle landmarks path dependent manner  is  non used landmarks maintained
    domshlak mirkis        maintain remaining budget part state  instead prune g s   
b    is  obviously  equivalent  except duplicate detection powerful compares states based
facts f  s  only  purpose discussion here  make difference  note that 
probabilistic setting  distinguish states based f  s  b s   goal probability depends
maintaining best way reaching f  s  suffice compute exact goal probability
initial state 

   

fig oal p robability nalysis p robabilistic p lanning

annotations states rather part them  multiple search paths may end state
use different landmarks  set remaining landmarks l s  union
individual path  is  l l non used iff exists least one path
touch l  still suffices show l landmark s  landmark heuristic approach per karpas domshlak        kind book keeping  uses admissible
heuristic value h l s   
one apply domshlak mirkis        reformulation technique without maintaining
landmarks part state  notion transition cost reduction would become
complicated  lest one loses information   because  reached a   reduced
cost due touching landmark l    later find another path a   touch l   
l  actually still valid landmark s  therefore need reduce cost
a     account this  would revise path costs posthoc  every time new path
becomes available  revisions  cost reduction path  a exactly
h l   l s    weight non used landmarks l s  longer subtracted  weight
landmarks l   l s  subtracted every  a because  definition  every  a touches every
l l   l s   cost saved every path  a s  relative  a  exactly h l   l s   
point arguments apply show pruning equivalent pruning
via b s    h l s     this stronger pruning method would get without posthoc
path cost revision  
summary  based reduced remaining budget b   s      equivalent pruning based
original remaining budget vs  landmark heuristic b s    h l s    noted  though 
pruning benefit domshlak mirkis        reformulation technique 
technique allows compute another  complementary  admissible heuristic h reformulated task    and domshlak mirkis point part motivation 
practice   perspective here  landmark heuristic h used additively
admissible pruning remaining budget  additivity achieved method
generalizing cost partitionings      cost reduced variant action applied
once  h abstract away constraint  h uses action twice  employs
reduced cost once  yet pays full cost second time  exploring kind generalized
cost partitioning detail interesting research line future work 

references
altman  e          constrained markov decision processes  crc press 
baier  c   groer  m   leucker  m   bollig  b     ciesinski  f          controller synthesis
probabilistic systems  extended abstract   pp          springer us  boston  ma 
barto  a  g   bradtke  s  j     singh  s  p          learning act using real time dynamic programming  artificial intelligence                 
bertsekas  d          dynamic programming optimal control     volumes   athena scientific 
bertsekas  d     tsitsiklis  j          neurodynamic programming  athena scientific 
bonet  b     geffner  h          planning heuristic search  artificial intelligence          
    
   

fis teinmetz   h offmann   b uffet

bonet  b     geffner  h       a   faster heuristic search algorithms planning uncertainty
full feedback  gottlob  g   ed    proceedings   th international joint conference artificial intelligence  ijcai     pp            acapulco  mexico  morgan kaufmann 
bonet  b     geffner  h       b   labeled rtdp  improving convergence real time dynamic
programming  giunchiglia  e   muscettola  n     nau  d   eds    proceedings   th
international conference automated planning scheduling  icaps     pp       
trento  italy  morgan kaufmann 
bonet  b     geffner  h          mgpt  probabilistic planner based heuristic search  journal
artificial intelligence research             
bonet  b     geffner  h          learning depth first search  unified approach heuristic search
deterministic non deterministic settings  application mdps  long  d    
smith  s   eds    proceedings   th international conference automated planning
scheduling  icaps     pp          ambleside  uk  morgan kaufmann 
bonet  b     geffner  h          action selection mdps  anytime ao  versus uct  hoffmann  j     selman  b   eds    proceedings   th aaai conference artificial intelligence  aaai     toronto  on  canada  aaai press 
bryce  d     buffet  o           th international planning competition  uncertainty part  proceedings  th international planning competition  ipc    
camacho  a   muise  c     mcilraith  s  a          fond robust probabilistic planning  computing compact policies bypass avoidable deadends  coles  a   coles  a  
edelkamp  s   magazzeni  d     sanner  s   eds    proceedings   th international
conference automated planning scheduling  icaps     aaai press 
chatterjee  k   chmelik  m   gupta  r     kanodia  a          optimal cost almost sure reachability pomdps  bonet  b     koenig  s   eds    proceedings   th aaai conference
artificial intelligence  aaai     pp            aaai press 
chatterjee  k   chmelik  m   gupta  r     kanodia  a          optimal cost almost sure reachability pomdps  artificial intelligence            
coles  a  j          opportunistic branched plans maximise utility presence resource
uncertainty  raedt  l  d   ed    proceedings   th european conference artificial
intelligence  ecai     pp          montpellier  france  ios press 
coles  a  j   coles  a   fox  m     long  d          hybrid lp rpg heuristic modelling
numeric resource flows planning  journal artificial intelligence research             
coles  a  j   coles  a   garca olaya  a   jimenez  s   linares lopez  c   sanner  s     yoon  s 
        survey seventh international planning competition  ai magazine        
dai  p   mausam  weld  d  s     goldsmith  j          topological value iteration algorithms 
journal artificial intelligence research             
dean  t  l     givan  r          model minimization markov decision processes  kuipers 
b  j     webber  b   eds    proceedings   th national conference american
association artificial intelligence  aaai     pp          portland  or  mit press 
   

fig oal p robability nalysis p robabilistic p lanning

domshlak  c     mirkis  v          deterministic oversubscription planning heuristic search 
abstractions reformulations  journal artificial intelligence research            
drager  k   finkbeiner  b     podelski  a          directed model checking distancepreserving abstractions  international journal software tools technology transfer 
            
edelkamp  s          planning pattern databases  cesta  a     borrajo  d   eds    proceedings  th european conference planning  ecp     pp        springer verlag 
gefen  a     brafman  r  i          pruning methods optimal delete free planning  bonet 
b   mccluskey  l   silva  j  r     williams  b   eds    proceedings   nd international
conference automated planning scheduling  icaps     aaai press 
givan  r   leach  s  m     dean  t          bounded parameter markov decision processes  artificial intelligence                  
hansen  e  a     zilberstein  s          lao    heuristic search algorithm finds solutions
loops  artificial intelligence                 
haslum  p   botea  a   helmert  m   bonet  b     koenig  s          domain independent construction pattern database heuristics cost optimal planning  howe  a     holte 
r  c   eds    proceedings   nd national conference american association
artificial intelligence  aaai     pp            vancouver  bc  canada  aaai press 
haslum  p     geffner  h          heuristic planning time resources  cesta  a    
borrajo  d   eds    proceedings  th european conference planning  ecp     pp 
        springer verlag 
helmert  m          fast downward planning system  journal artificial intelligence research             
helmert  m     domshlak  c          landmarks  critical paths abstractions  whats difference anyway   gerevini  a   howe  a   cesta  a     refanidis  i   eds    proceedings
  th international conference automated planning scheduling  icaps     pp 
        aaai press 
helmert  m   haslum  p   hoffmann  j     nissim  r          merge   shrink abstraction  method
generating lower bounds factored state spaces  journal association computing machinery        
hoffmann  j          simulated penetration testing  dijkstra turing test    brafman  r   domshlak  c   haslum  p     zilberstein  s   eds    proceedings   th international conference automated planning scheduling  icaps     aaai press 
hoffmann  j   kissmann  p     torralba  a          distance  cares  tailoring merge andshrink heuristics detect unsolvability  schaub  t   ed    proceedings   st european
conference artificial intelligence  ecai     prague  czech republic  ios press 
hoffmann  j     nebel  b          planning system  fast plan generation heuristic
search  journal artificial intelligence research             
hou  p   yeoh  w     varakantham  p          revisiting risk sensitive mdps  new algorithms
results  chien  s   do  m   fern  a     ruml  w   eds    proceedings   th
international conference automated planning scheduling  icaps     aaai press 
   

fis teinmetz   h offmann   b uffet

jimenez  s   coles  a     smith  a          planning probabilistic domains using deterministic
numeric planner  proceedings   th workshop uk planning scheduling
special interest group  plansig    
karpas  e     domshlak  c          cost optimal planning landmarks  boutilier  c   ed   
proceedings   st international joint conference artificial intelligence  ijcai    
pp            pasadena  california  usa  morgan kaufmann 
katz  m   hoffmann  j     helmert  m          relax bisimulation   bonet  b   mccluskey  l   silva  j  r     williams  b   eds    proceedings   nd international conference automated planning scheduling  icaps     pp          aaai press 
keller  t     eyerich  p          prost  probabilistic planning based uct  bonet  b  
mccluskey  l   silva  j  r     williams  b   eds    proceedings   nd international
conference automated planning scheduling  icaps     aaai press 
keller  t     helmert  m          trial based heuristic tree search finite horizon mdps 
borrajo  d   fratini  s   kambhampati  s     oddi  a   eds    proceedings   rd international conference automated planning scheduling  icaps     rome  italy  aaai
press 
kolobov  a          scalable methods expressive models planning uncertainty 
ph d  thesis  university washington 
kolobov  a   mausam    weld  d  s          sixthsense  fast reliable recognition dead ends
mdps  fox  m     poole  d   eds    proceedings   th national conference
american association artificial intelligence  aaai     atlanta  ga  usa  aaai press 
kolobov  a   mausam    weld  d  s          theory goal oriented mdps dead ends 
de freitas  n     murphy  k  p   eds    proceedings   th conference uncertainty
artificial intelligence  uai     pp          catalina island  ca  usa  auai press 
kolobov  a   mausam  weld  d  s     geffner  h          heuristic search generalized stochastic
shortest path mdps  bacchus  f   domshlak  c   edelkamp  s     helmert  m   eds   
proceedings   st international conference automated planning scheduling
 icaps     aaai press 
kurniawati  h   hsu  d     lee  w  s          sarsop  efficient point based pomdp planning
approximating optimally reachable belief spaces  robotics  science systems iv 
kuter  u     hu  j          computing using lower upper bounds action elimination
mdp planning  miguel  i     ruml  w   eds    proceedings  th international symposium abstraction  reformulation  approximation  sara      vol       lecture
notes computer science  whistler  canada  springer verlag 
kwiatkowska  m   parker  d     qu  h       a   incremental quantitative verification markov
decision processes       ieee ifip   st international conference dependable systems
networks  dsn   pp         
kwiatkowska  m  z   norman  g     parker  d       b   prism      verification probabilistic
real time systems  gopalakrishnan  g     qadeer  s   eds    proceedings   rd international conference computer aided verification  cav     vol       lecture notes
computer science  pp          springer 
   

fig oal p robability nalysis p robabilistic p lanning

little  i   aberdeen  d     thiebaux  s          prottle  probabilistic temporal planner  veloso 
m  m     kambhampati  s   eds    proceedings   th national conference american association artificial intelligence  aaai     pp            pittsburgh  pennsylvania  usa  aaai press 
little  i     thiebaux  s          probabilistic planning vs replanning  icaps workshop
international planning competition  past  present future 
marecki  j     tambe  m          towards faster planning continuous resources stochastic
domains  fox  d     gomes  c   eds    proceedings   rd national conference
american association artificial intelligence  aaai     pp            chicago  illinois 
usa  aaai press 
mcmahan  h  b   likhachev  m     gordon  g  j          bounded real time dynamic programming  rtdp monotone upper bounds performance guarantees  proceedings
  nd international conference machine learning  icml     
meuleau  n   benazera  e   brafman  r  i   hansen  e  a     mausam  m          heuristic search
approach planning continuous resources stochastic domains  journal artificial
intelligence research              
milner  r          operational algebraic semantics concurrent processes  van leeuwen  j 
 ed    handbook theoretical computer science  volume b  formal models sematics 
pp            elsevier mit press 
muise  c  j   mcilraith  s  a     beck  j  c          improved non deterministic planning
exploiting state relevance  bonet  b   mccluskey  l   silva  j  r     williams  b   eds   
proceedings   nd international conference automated planning scheduling
 icaps     aaai press 
nakhost  h   hoffmann  j     muller  m          resource constrained planning  monte carlo
random walk approach  bonet  b   mccluskey  l   silva  j  r     williams  b   eds   
proceedings   nd international conference automated planning scheduling
 icaps     pp          aaai press 
nilsson  n  j          problem solving methods artificial intelligence  mcgraw hill 
nissim  r   hoffmann  j     helmert  m          computing perfect heuristics polynomial time 
bisimulation merge and shrink abstraction optimal planning  walsh  t   ed   
proceedings   nd international joint conference artificial intelligence  ijcai    
pp            aaai press ijcai 
pommerening  f     helmert  m          optimal planning delete free tasks incremental
lm cut  bonet  b   mccluskey  l   silva  j  r     williams  b   eds    proceedings
  nd international conference automated planning scheduling  icaps     aaai
press 
richter  s     helmert  m          preferred operators deferred evaluation satisficing planning  gerevini  a   howe  a   cesta  a     refanidis  i   eds    proceedings   th
international conference automated planning scheduling  icaps     pp         
aaai press 
   

fis teinmetz   h offmann   b uffet

sanner  s          relational dynamic influence diagram language  rddl   language description 
available http   users cecs anu edu au ssanner ippc      rddl 
pdf 
santana  p   thibaux  s     williams  b          rao   algorithm chance constrained
pomdps  schuurmans  d     wellman  m   eds    proceedings   th aaai conference artificial intelligence  aaai     pp            aaai press 
sarraute  c   buffet  o     hoffmann  j          pomdps make better hackers  accounting
uncertainty penetration testing  hoffmann  j     selman  b   eds    proceedings
  th aaai conference artificial intelligence  aaai     pp            toronto  on 
canada  aaai press 
seipp  j     helmert  m          counterexample guided cartesian abstraction refinement 
borrajo  d   fratini  s   kambhampati  s     oddi  a   eds    proceedings   rd international conference automated planning scheduling  icaps     pp         
rome  italy  aaai press 
seipp  j     helmert  m          diverse additive cartesian abstraction heuristics  chien  s  
do  m   fern  a     ruml  w   eds    proceedings   th international conference
automated planning scheduling  icaps     aaai press 
smith  t     simmons  r  g          focused real time dynamic programming mdps  squeezing heuristic  gil  y     mooney  r  j   eds    proceedings   st
national conference american association artificial intelligence  aaai     pp 
          boston  massachusetts  usa  aaai press 
steinmetz  m   hoffmann  j     buffet  o          revisiting goal probability analysis probabilistic planning  coles  a   coles  a   edelkamp  s   magazzeni  d     sanner  s   eds   
proceedings   th international conference automated planning scheduling
 icaps     aaai press 
tarjan  r  e          depth first search linear graph algorithms  siam journal computing 
             
teichteil konigsbuch  f          stochastic safest shortest path problems  hoffmann  j  
  selman  b   eds    proceedings   th aaai conference artificial intelligence
 aaai     toronto  on  canada  aaai press 
teichteil konigsbuch  f   kuter  u     infantes  g          incremental plan aggregation generating policies mdps  van der hoek  w   kaminka  g  a   lesperance  y   luck  m    
sen  s   eds    proceedings  th international conference autonomous agents
multiagent systems  aamas     pp            ifaamas 
teichteil konigsbuch  f   vidal  v     infantes  g          extending classical planning heuristics
probabilistic planning dead ends  burgard  w     roth  d   eds    proceedings
  th national conference american association artificial intelligence  aaai    
san francisco  ca  usa  aaai press 
torralba  a     hoffmann  j          simulation based admissible dominance pruning  yang 
q   ed    proceedings   th international joint conference artificial intelligence
 ijcai     pp            aaai press ijcai 
   

fig oal p robability nalysis p robabilistic p lanning

yoon  s  w   fern  a     givan  r          ff replan  baseline probabilistic planning 
boddy  m   fox  m     thiebaux  s   eds    proceedings   th international conference
automated planning scheduling  icaps     pp          providence  rhode island 
usa  morgan kaufmann 
younes  h  l  s   littman  m  l   weissman  d     asmuth  j          first probabilistic track
international planning competition  journal artificial intelligence research     
       

   


